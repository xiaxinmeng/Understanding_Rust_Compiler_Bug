{"sha": "78f617800fd723a721582660f455d22e5b21eb4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4ZjYxNzgwMGZkNzIzYTcyMTU4MjY2MGY0NTVkMjJlNWIyMWViNGM=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-01-20T20:15:37Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-01-29T22:58:10Z"}, "message": "save-anlaysis: misc bug fixes\n\nIn particular, handling of struct literals where the struct name is a type alias, and tuple indexing.\n\nPlus some other stuff.", "tree": {"sha": "75056aa2328da2cecbdd7b386e0b7d296ac12369", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75056aa2328da2cecbdd7b386e0b7d296ac12369"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78f617800fd723a721582660f455d22e5b21eb4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78f617800fd723a721582660f455d22e5b21eb4c", "html_url": "https://github.com/rust-lang/rust/commit/78f617800fd723a721582660f455d22e5b21eb4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78f617800fd723a721582660f455d22e5b21eb4c/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcbd418b1c228addbe0dd14893c6ae9692aab8fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcbd418b1c228addbe0dd14893c6ae9692aab8fd", "html_url": "https://github.com/rust-lang/rust/commit/dcbd418b1c228addbe0dd14893c6ae9692aab8fd"}], "stats": {"total": 85, "additions": 56, "deletions": 29}, "files": [{"sha": "354a9cb817bdf2f8b628a647728e7f92e3fe2d1d", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 39, "deletions": 26, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/78f617800fd723a721582660f455d22e5b21eb4c/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f617800fd723a721582660f455d22e5b21eb4c/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=78f617800fd723a721582660f455d22e5b21eb4c", "patch": "@@ -814,7 +814,13 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                        sub_span,\n                                                        def_id,\n                                                        self.cur_scope),\n-            def::DefStaticMethod(declid, provenence) => {\n+            def::DefTy(def_id, _) => self.fmt.ref_str(recorder::TypeRef,\n+                                                      span,\n+                                                      sub_span,\n+                                                      def_id,\n+                                                      self.cur_scope),\n+            def::DefStaticMethod(declid, provenence) |\n+            def::DefMethod(declid, _, provenence) => {\n                 let sub_span = self.span.sub_span_for_meth_name(span);\n                 let defid = if declid.krate == ast::LOCAL_CRATE {\n                     let ti = ty::impl_or_trait_item(&self.analysis.ty_cx,\n@@ -856,13 +862,17 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                        Some(declid),\n                                        self.cur_scope);\n             },\n-            def::DefFn(def_id, _) => self.fmt.fn_call_str(span,\n-                                                          sub_span,\n-                                                          def_id,\n-                                                          self.cur_scope),\n+            def::DefFn(def_id, _) => {\n+                self.fmt.fn_call_str(span,\n+                                     sub_span,\n+                                     def_id,\n+                                     self.cur_scope)\n+            }\n             _ => self.sess.span_bug(span,\n-                                    &format!(\"Unexpected def kind while looking up path in '{}'\",\n-                                            self.span.snippet(span))[]),\n+                                    &format!(\"Unexpected def kind while looking \\\n+                                              up path in `{}`: `{:?}`\",\n+                                             self.span.snippet(span),\n+                                             *def)[]),\n         }\n         // modules or types in the path prefix\n         match *def {\n@@ -886,21 +896,21 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             return\n         }\n \n-        let mut struct_def: Option<DefId> = None;\n-        match self.lookup_type_ref(ex.id) {\n-            Some(id) => {\n-                struct_def = Some(id);\n+        self.write_sub_paths_truncated(path, false);\n+\n+        let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, ex).sty;\n+        let struct_def = match *ty {\n+            ty::ty_struct(def_id, _) => {\n                 let sub_span = self.span.span_for_last_ident(path.span);\n                 self.fmt.ref_str(recorder::StructRef,\n                                  path.span,\n                                  sub_span,\n-                                 id,\n+                                 def_id,\n                                  self.cur_scope);\n-            },\n-            None => ()\n-        }\n-\n-        self.write_sub_paths_truncated(path, false);\n+                Some(def_id)\n+            }\n+            _ => None\n+        };\n \n         for field in fields.iter() {\n             match struct_def {\n@@ -1335,8 +1345,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 }\n \n                 self.visit_expr(&**sub_ex);\n-\n-                match ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty {\n+                let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty;\n+                match *ty {\n                     ty::ty_struct(def_id, _) => {\n                         let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n                         for f in fields.iter() {\n@@ -1350,9 +1360,9 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                 break;\n                             }\n                         }\n-                    },\n+                    }\n                     _ => self.sess.span_bug(ex.span,\n-                                            \"Expected struct type, but not ty_struct\"),\n+                                            &format!(\"Expected struct type, found {:?}\", ty)[]),\n                 }\n             },\n             ast::ExprTupField(ref sub_ex, idx) => {\n@@ -1362,12 +1372,13 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n \n                 self.visit_expr(&**sub_ex);\n \n-                match ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty {\n+                let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty;\n+                match *ty {\n                     ty::ty_struct(def_id, _) => {\n                         let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n                         for (i, f) in fields.iter().enumerate() {\n                             if i == idx.node {\n-                                let sub_span = self.span.span_for_last_ident(ex.span);\n+                                let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);\n                                 self.fmt.ref_str(recorder::VarRef,\n                                                  ex.span,\n                                                  sub_span,\n@@ -1376,9 +1387,11 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                 break;\n                             }\n                         }\n-                    },\n+                    }\n+                    ty::ty_tup(_) => {}\n                     _ => self.sess.span_bug(ex.span,\n-                                            \"Expected struct type, but not ty_struct\"),\n+                                            &format!(\"Expected struct or tuple \\\n+                                                      type, found {:?}\", ty)[]),\n                 }\n             },\n             ast::ExprClosure(_, _, ref decl, ref body) => {\n@@ -1454,7 +1467,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                           &value[],\n                                           \"\")\n                 }\n-                def::DefVariant(..) => {\n+                def::DefVariant(..) | def::DefTy(..) | def::DefStruct(..) => {\n                     paths_to_process.push((id, p.clone(), Some(ref_kind)))\n                 }\n                 // FIXME(nrc) what are these doing here?"}, {"sha": "1378d40920808570c6ae64f2ba761e85bee149d3", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78f617800fd723a721582660f455d22e5b21eb4c/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f617800fd723a721582660f455d22e5b21eb4c/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=78f617800fd723a721582660f455d22e5b21eb4c", "patch": "@@ -62,7 +62,7 @@ macro_rules! svec {\n     })\n }\n \n-#[derive(Copy,Debug)]\n+#[derive(Copy, Debug, Eq, PartialEq)]\n pub enum Row {\n     Variable,\n     Enum,"}, {"sha": "0e623ab1b7e04c87abf629bb4e160895e1121399", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/78f617800fd723a721582660f455d22e5b21eb4c/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f617800fd723a721582660f455d22e5b21eb4c/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=78f617800fd723a721582660f455d22e5b21eb4c", "patch": "@@ -37,7 +37,7 @@ impl<'a> SpanUtils<'a> {\n         let lo_pos_byte = self.sess.codemap().lookup_byte_offset(span.lo).pos;\n         let hi_pos_byte = self.sess.codemap().lookup_byte_offset(span.hi).pos;\n \n-        format!(\"file_name,{},file_line,{},file_col,{},extent_start,{},extent_start_bytes,{},\\\n+        format!(\"file_name,\\\"{}\\\",file_line,{},file_col,{},extent_start,{},extent_start_bytes,{},\\\n                  file_line_end,{},file_col_end,{},extent_end,{},extent_end_bytes,{}\",\n                 lo_loc.file.name,\n                 lo_loc.line, lo_loc.col.to_usize(), lo_pos.to_usize(), lo_pos_byte.to_usize(),\n@@ -205,6 +205,7 @@ impl<'a> SpanUtils<'a> {\n             bracket_count += match prev.tok {\n                 token::Lt => 1,\n                 token::Gt => -1,\n+                token::BinOp(token::Shl) => 2,\n                 token::BinOp(token::Shr) => -2,\n                 _ => 0\n             };\n@@ -296,13 +297,25 @@ impl<'a> SpanUtils<'a> {\n     pub fn sub_span_after_keyword(&self,\n                                   span: Span,\n                                   keyword: keywords::Keyword) -> Option<Span> {\n+        self.sub_span_after(span, |t| t.is_keyword(keyword))\n+    }\n+\n+    pub fn sub_span_after_token(&self,\n+                                span: Span,\n+                                tok: Token) -> Option<Span> {\n+        self.sub_span_after(span, |t| t == tok)\n+    }\n+\n+    fn sub_span_after<F: Fn(Token) -> bool>(&self,\n+                                            span: Span,\n+                                            f: F) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n         loop {\n             let ts = toks.real_token();\n             if ts.tok == token::Eof {\n                 return None;\n             }\n-            if ts.tok.is_keyword(keyword) {\n+            if f(ts.tok) {\n                 let ts = toks.real_token();\n                 if ts.tok == token::Eof {\n                     return None\n@@ -313,6 +326,7 @@ impl<'a> SpanUtils<'a> {\n         }\n     }\n \n+\n     // Returns a list of the spans of idents in a patch.\n     // E.g., For foo::bar<x,t>::baz, we return [foo, bar, baz] (well, their spans)\n     pub fn spans_for_path_segments(&self, path: &ast::Path) -> Vec<Span> {"}]}