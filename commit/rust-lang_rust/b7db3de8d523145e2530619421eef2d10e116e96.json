{"sha": "b7db3de8d523145e2530619421eef2d10e116e96", "node_id": "C_kwDOAAsO6NoAKGI3ZGIzZGU4ZDUyMzE0NWUyNTMwNjE5NDIxZWVmMmQxMGUxMTZlOTY", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-05-27T12:46:54Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-05-27T12:46:54Z"}, "message": "Clean up usage of `cx.tcx` when `tcx` is already set into a variable", "tree": {"sha": "325ae518442389bbad0e40e956019be6d2fb8491", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/325ae518442389bbad0e40e956019be6d2fb8491"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7db3de8d523145e2530619421eef2d10e116e96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7db3de8d523145e2530619421eef2d10e116e96", "html_url": "https://github.com/rust-lang/rust/commit/b7db3de8d523145e2530619421eef2d10e116e96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7db3de8d523145e2530619421eef2d10e116e96/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "223f6f5926893bf82c5f2f9b1bb78fa6f1d1d1aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/223f6f5926893bf82c5f2f9b1bb78fa6f1d1d1aa", "html_url": "https://github.com/rust-lang/rust/commit/223f6f5926893bf82c5f2f9b1bb78fa6f1d1d1aa"}], "stats": {"total": 82, "additions": 39, "deletions": 43}, "files": [{"sha": "7dc08b3b1ffa672737049afc16c90c6776eebc1a", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7db3de8d523145e2530619421eef2d10e116e96/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7db3de8d523145e2530619421eef2d10e116e96/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=b7db3de8d523145e2530619421eef2d10e116e96", "patch": "@@ -355,9 +355,9 @@ pub(crate) fn build_impl(\n         return;\n     }\n \n-    let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_impl\");\n-\n     let tcx = cx.tcx;\n+    let _prof_timer = tcx.sess.prof.generic_activity(\"build_impl\");\n+\n     let associated_trait = tcx.impl_trait_ref(did).map(ty::EarlyBinder::skip_binder);\n \n     // Only inline impl if the implemented trait is"}, {"sha": "366f93952963ff6faa7418989a3f0db6de72cd4b", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7db3de8d523145e2530619421eef2d10e116e96/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7db3de8d523145e2530619421eef2d10e116e96/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=b7db3de8d523145e2530619421eef2d10e116e96", "patch": "@@ -193,7 +193,7 @@ pub(crate) fn build_deref_target_impls(\n         };\n \n         if let Some(prim) = target.primitive_type() {\n-            let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_primitive_inherent_impls\");\n+            let _prof_timer = tcx.sess.prof.generic_activity(\"build_primitive_inherent_impls\");\n             for did in prim.impls(tcx).filter(|did| !did.is_local()) {\n                 inline::build_impl(cx, did, None, ret);\n             }"}, {"sha": "297e70a4b2f2ad8de27c2ed0822e8258291e961e", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7db3de8d523145e2530619421eef2d10e116e96/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7db3de8d523145e2530619421eef2d10e116e96/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=b7db3de8d523145e2530619421eef2d10e116e96", "patch": "@@ -147,7 +147,7 @@ impl Cache {\n \n         // Cache where all our extern crates are located\n         // FIXME: this part is specific to HTML so it'd be nice to remove it from the common code\n-        for &crate_num in cx.tcx.crates(()) {\n+        for &crate_num in tcx.crates(()) {\n             let e = ExternalCrate { crate_num };\n \n             let name = e.name(tcx);"}, {"sha": "dd23abf0e2c9b1d8f5d4acdbd5c7759a30efcf8e", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b7db3de8d523145e2530619421eef2d10e116e96/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7db3de8d523145e2530619421eef2d10e116e96/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=b7db3de8d523145e2530619421eef2d10e116e96", "patch": "@@ -356,18 +356,18 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n \n             clean::ImportItem(ref import) => {\n                 let stab_tags = if let Some(import_def_id) = import.source.did {\n-                    let ast_attrs = cx.tcx().get_attrs_unchecked(import_def_id);\n+                    let ast_attrs = tcx.get_attrs_unchecked(import_def_id);\n                     let import_attrs = Box::new(clean::Attributes::from_ast(ast_attrs));\n \n                     // Just need an item with the correct def_id and attrs\n                     let import_item = clean::Item {\n                         item_id: import_def_id.into(),\n                         attrs: import_attrs,\n-                        cfg: ast_attrs.cfg(cx.tcx(), &cx.cache().hidden_cfg),\n+                        cfg: ast_attrs.cfg(tcx, &cx.cache().hidden_cfg),\n                         ..myitem.clone()\n                     };\n \n-                    let stab_tags = Some(extra_info_tags(&import_item, item, cx.tcx()).to_string());\n+                    let stab_tags = Some(extra_info_tags(&import_item, item, tcx).to_string());\n                     stab_tags\n                 } else {\n                     None\n@@ -405,8 +405,7 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n \n                 let unsafety_flag = match *myitem.kind {\n                     clean::FunctionItem(_) | clean::ForeignFunctionItem(_)\n-                        if myitem.fn_header(cx.tcx()).unwrap().unsafety\n-                            == hir::Unsafety::Unsafe =>\n+                        if myitem.fn_header(tcx).unwrap().unsafety == hir::Unsafety::Unsafe =>\n                     {\n                         \"<sup title=\\\"unsafe function\\\">\u26a0</sup>\"\n                     }\n@@ -439,7 +438,7 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                      {docs_before}{docs}{docs_after}\",\n                     name = myitem.name.unwrap(),\n                     visibility_emoji = visibility_emoji,\n-                    stab_tags = extra_info_tags(myitem, item, cx.tcx()),\n+                    stab_tags = extra_info_tags(myitem, item, tcx),\n                     class = myitem.type_(),\n                     unsafety_flag = unsafety_flag,\n                     href = item_path(myitem.type_(), myitem.name.unwrap().as_str()),\n@@ -886,7 +885,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n             write_small_section_header(w, \"foreign-impls\", \"Implementations on Foreign Types\", \"\");\n \n             for implementor in foreign {\n-                let provided_methods = implementor.inner_impl().provided_trait_methods(cx.tcx());\n+                let provided_methods = implementor.inner_impl().provided_trait_methods(tcx);\n                 let assoc_link =\n                     AssocItemLink::GotoSource(implementor.impl_item.item_id, &provided_methods);\n                 render_impl(\n@@ -919,7 +918,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n         }\n         w.write_str(\"</div>\");\n \n-        if t.is_auto(cx.tcx()) {\n+        if t.is_auto(tcx) {\n             write_small_section_header(\n                 w,\n                 \"synthetic-implementors\",\n@@ -948,7 +947,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n             \"<div id=\\\"implementors-list\\\"></div>\",\n         );\n \n-        if t.is_auto(cx.tcx()) {\n+        if t.is_auto(tcx) {\n             write_small_section_header(\n                 w,\n                 \"synthetic-implementors\","}, {"sha": "c9b95b1e64599fe42dc6056fec76cb33333ad3ad", "filename": "src/librustdoc/html/render/type_layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7db3de8d523145e2530619421eef2d10e116e96/src%2Flibrustdoc%2Fhtml%2Frender%2Ftype_layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7db3de8d523145e2530619421eef2d10e116e96/src%2Flibrustdoc%2Fhtml%2Frender%2Ftype_layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Ftype_layout.rs?ref=b7db3de8d523145e2530619421eef2d10e116e96", "patch": "@@ -54,13 +54,13 @@ pub(crate) fn document_type_layout<'a, 'cx: 'a>(\n                     } else if let Primitive::Int(i, _) = tag.primitive() {\n                         i.size().bytes()\n                     } else {\n-                        span_bug!(cx.tcx().def_span(ty_def_id), \"tag is neither niche nor int\")\n+                        span_bug!(tcx.def_span(ty_def_id), \"tag is neither niche nor int\")\n                     };\n                 variants\n                     .iter_enumerated()\n                     .map(|(variant_idx, variant_layout)| {\n                         let Adt(adt, _) = type_layout.ty.kind() else {\n-                            span_bug!(cx.tcx().def_span(ty_def_id), \"not an adt\")\n+                            span_bug!(tcx.def_span(ty_def_id), \"not an adt\")\n                         };\n                         let name = adt.variant(variant_idx).name;\n                         let is_unsized = variant_layout.abi.is_unsized();"}, {"sha": "8ab7e58bf74981e71dd8a4ec581136ac82b1f7a9", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7db3de8d523145e2530619421eef2d10e116e96/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7db3de8d523145e2530619421eef2d10e116e96/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=b7db3de8d523145e2530619421eef2d10e116e96", "patch": "@@ -723,7 +723,7 @@ fn resolve_associated_trait_item<'a>(\n         .iter()\n         .flat_map(|&(impl_, trait_)| {\n             filter_assoc_items_by_name_and_namespace(\n-                cx.tcx,\n+                tcx,\n                 trait_,\n                 Ident::with_dummy_span(item_name),\n                 ns,\n@@ -1706,7 +1706,7 @@ fn resolution_failure(\n                             if let Ok(v_res) = collector.resolve(start, ns, item_id, module_id) {\n                                 debug!(\"found partial_res={:?}\", v_res);\n                                 if !v_res.is_empty() {\n-                                    *partial_res = Some(full_res(collector.cx.tcx, v_res[0]));\n+                                    *partial_res = Some(full_res(tcx, v_res[0]));\n                                     *unresolved = end.into();\n                                     break 'outer;\n                                 }"}, {"sha": "fbf827cce0984cf101774bf55c7d5d49d51c7d65", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b7db3de8d523145e2530619421eef2d10e116e96/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7db3de8d523145e2530619421eef2d10e116e96/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=b7db3de8d523145e2530619421eef2d10e116e96", "patch": "@@ -19,9 +19,10 @@ pub(crate) const COLLECT_TRAIT_IMPLS: Pass = Pass {\n };\n \n pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n+    let tcx = cx.tcx;\n     // We need to check if there are errors before running this pass because it would crash when\n     // we try to get auto and blanket implementations.\n-    if cx.tcx.sess.diagnostic().has_errors_or_lint_errors().is_some() {\n+    if tcx.sess.diagnostic().has_errors_or_lint_errors().is_some() {\n         return krate;\n     }\n \n@@ -32,8 +33,7 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n     });\n \n     let local_crate = ExternalCrate { crate_num: LOCAL_CRATE };\n-    let prims: FxHashSet<PrimitiveType> =\n-        local_crate.primitives(cx.tcx).iter().map(|p| p.1).collect();\n+    let prims: FxHashSet<PrimitiveType> = local_crate.primitives(tcx).iter().map(|p| p.1).collect();\n \n     let crate_items = {\n         let mut coll = ItemCollector::new();\n@@ -46,24 +46,23 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n \n     // External trait impls.\n     {\n-        let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_extern_trait_impls\");\n-        for &cnum in cx.tcx.crates(()) {\n-            for &impl_def_id in cx.tcx.trait_impls_in_crate(cnum) {\n+        let _prof_timer = tcx.sess.prof.generic_activity(\"build_extern_trait_impls\");\n+        for &cnum in tcx.crates(()) {\n+            for &impl_def_id in tcx.trait_impls_in_crate(cnum) {\n                 inline::build_impl(cx, impl_def_id, None, &mut new_items_external);\n             }\n         }\n     }\n \n     // Local trait impls.\n     {\n-        let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_local_trait_impls\");\n+        let _prof_timer = tcx.sess.prof.generic_activity(\"build_local_trait_impls\");\n         let mut attr_buf = Vec::new();\n-        for &impl_def_id in cx.tcx.trait_impls_in_crate(LOCAL_CRATE) {\n-            let mut parent = Some(cx.tcx.parent(impl_def_id));\n+        for &impl_def_id in tcx.trait_impls_in_crate(LOCAL_CRATE) {\n+            let mut parent = Some(tcx.parent(impl_def_id));\n             while let Some(did) = parent {\n                 attr_buf.extend(\n-                    cx.tcx\n-                        .get_attrs(did, sym::doc)\n+                    tcx.get_attrs(did, sym::doc)\n                         .filter(|attr| {\n                             if let Some([attr]) = attr.meta_item_list().as_deref() {\n                                 attr.has_name(sym::cfg)\n@@ -73,25 +72,24 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n                         })\n                         .cloned(),\n                 );\n-                parent = cx.tcx.opt_parent(did);\n+                parent = tcx.opt_parent(did);\n             }\n             inline::build_impl(cx, impl_def_id, Some((&attr_buf, None)), &mut new_items_local);\n             attr_buf.clear();\n         }\n     }\n \n-    cx.tcx.sess.prof.generic_activity(\"build_primitive_trait_impls\").run(|| {\n-        for def_id in PrimitiveType::all_impls(cx.tcx) {\n+    tcx.sess.prof.generic_activity(\"build_primitive_trait_impls\").run(|| {\n+        for def_id in PrimitiveType::all_impls(tcx) {\n             // Try to inline primitive impls from other crates.\n             if !def_id.is_local() {\n                 inline::build_impl(cx, def_id, None, &mut new_items_external);\n             }\n         }\n-        for (prim, did) in PrimitiveType::primitive_locations(cx.tcx) {\n+        for (prim, did) in PrimitiveType::primitive_locations(tcx) {\n             // Do not calculate blanket impl list for docs that are not going to be rendered.\n             // While the `impl` blocks themselves are only in `libcore`, the module with `doc`\n             // attached is directly included in `libstd` as well.\n-            let tcx = cx.tcx;\n             if did.is_local() {\n                 for def_id in prim.impls(tcx).filter(|def_id| {\n                     // Avoid including impl blocks with filled-in generics.\n@@ -157,7 +155,7 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n     // scan through included items ahead of time to splice in Deref targets to the \"valid\" sets\n     for it in new_items_external.iter().chain(new_items_local.iter()) {\n         if let ImplItem(box Impl { ref for_, ref trait_, ref items, .. }) = *it.kind &&\n-            trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait() &&\n+            trait_.as_ref().map(|t| t.def_id()) == tcx.lang_items().deref_trait() &&\n             cleaner.keep_impl(for_, true)\n         {\n             let target = items\n@@ -199,7 +197,7 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n         if let ImplItem(box Impl { ref for_, ref trait_, ref kind, .. }) = *it.kind {\n             cleaner.keep_impl(\n                 for_,\n-                trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait(),\n+                trait_.as_ref().map(|t| t.def_id()) == tcx.lang_items().deref_trait(),\n             ) || trait_.as_ref().map_or(false, |t| cleaner.keep_impl_with_def_id(t.def_id().into()))\n                 || kind.is_blanket()\n         } else {"}, {"sha": "6feb6537dd7d1b9ba85c2c0613743e128982eaea", "filename": "src/librustdoc/passes/lint/unescaped_backticks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7db3de8d523145e2530619421eef2d10e116e96/src%2Flibrustdoc%2Fpasses%2Flint%2Funescaped_backticks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7db3de8d523145e2530619421eef2d10e116e96/src%2Flibrustdoc%2Fpasses%2Flint%2Funescaped_backticks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Flint%2Funescaped_backticks.rs?ref=b7db3de8d523145e2530619421eef2d10e116e96", "patch": "@@ -56,7 +56,7 @@ pub(crate) fn visit_item(cx: &DocContext<'_>, item: &Item) {\n                 )\n                 .unwrap_or_else(|| item.attr_span(tcx));\n \n-                cx.tcx.struct_span_lint_hir(crate::lint::UNESCAPED_BACKTICKS, hir_id, span, \"unescaped backtick\", |lint| {\n+                tcx.struct_span_lint_hir(crate::lint::UNESCAPED_BACKTICKS, hir_id, span, \"unescaped backtick\", |lint| {\n                     let mut help_emitted = false;\n \n                     match element.prev_code_guess {"}, {"sha": "1681386ce192e743e4b80494f839801c5744b1cd", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b7db3de8d523145e2530619421eef2d10e116e96/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7db3de8d523145e2530619421eef2d10e116e96/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=b7db3de8d523145e2530619421eef2d10e116e96", "patch": "@@ -280,26 +280,25 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             return false;\n         };\n \n-        let is_private =\n-            !self.cx.cache.effective_visibilities.is_directly_public(self.cx.tcx, ori_res_did);\n-        let is_hidden = inherits_doc_hidden(self.cx.tcx, res_did, None);\n+        let is_private = !self.cx.cache.effective_visibilities.is_directly_public(tcx, ori_res_did);\n+        let is_hidden = inherits_doc_hidden(tcx, res_did, None);\n \n         // Only inline if requested or if the item would otherwise be stripped.\n         if (!please_inline && !is_private && !is_hidden) || is_no_inline {\n             return false;\n         }\n \n         if !please_inline &&\n-            let Some(item_def_id) = reexport_chain(self.cx.tcx, def_id, res_did).iter()\n+            let Some(item_def_id) = reexport_chain(tcx, def_id, res_did).iter()\n                 .flat_map(|reexport| reexport.id()).map(|id| id.expect_local())\n                 .chain(iter::once(res_did)).nth(1) &&\n             item_def_id != def_id &&\n             self\n                 .cx\n                 .cache\n                 .effective_visibilities\n-                .is_directly_public(self.cx.tcx, item_def_id.to_def_id()) &&\n-            !inherits_doc_hidden(self.cx.tcx, item_def_id, None)\n+                .is_directly_public(tcx, item_def_id.to_def_id()) &&\n+            !inherits_doc_hidden(tcx, item_def_id, None)\n         {\n             // The imported item is public and not `doc(hidden)` so no need to inline it.\n             return false;\n@@ -313,7 +312,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             Node::Item(&hir::Item { kind: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for &i in m.item_ids {\n-                    let i = self.cx.tcx.hir().item(i);\n+                    let i = tcx.hir().item(i);\n                     self.visit_item_inner(i, None, Some(def_id));\n                 }\n                 self.inlining = prev;"}]}