{"sha": "0887456401755b626f08b94f012222fbee4b0323", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ODc0NTY0MDE3NTViNjI2ZjA4Yjk0ZjAxMjIyMmZiZWU0YjAzMjM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-27T21:57:35Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-04T15:02:40Z"}, "message": "extend NLL universe code to have >1 placeholder within one universe", "tree": {"sha": "54eab73249d8e71277507acdc210b2fae4ed4207", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54eab73249d8e71277507acdc210b2fae4ed4207"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0887456401755b626f08b94f012222fbee4b0323", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0887456401755b626f08b94f012222fbee4b0323", "html_url": "https://github.com/rust-lang/rust/commit/0887456401755b626f08b94f012222fbee4b0323", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0887456401755b626f08b94f012222fbee4b0323/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c2fc333f0aca12509907cee377a13b61bf97e8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c2fc333f0aca12509907cee377a13b61bf97e8f", "html_url": "https://github.com/rust-lang/rust/commit/4c2fc333f0aca12509907cee377a13b61bf97e8f"}], "stats": {"total": 350, "additions": 226, "deletions": 124}, "files": [{"sha": "ba0f8af4f720e5568b53c54e44b3b6cc2db973dc", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0887456401755b626f08b94f012222fbee4b0323/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0887456401755b626f08b94f012222fbee4b0323/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=0887456401755b626f08b94f012222fbee4b0323", "patch": "@@ -586,15 +586,20 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// the [rustc guide].\n     ///\n     /// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/traits/hrtb.html\n-    pub fn replace_late_bound_regions_with_placeholders<T>(&self,\n-                                           binder: &ty::Binder<T>)\n-                                           -> (T, PlaceholderMap<'tcx>)\n-        where T : TypeFoldable<'tcx>\n+    pub fn replace_late_bound_regions_with_placeholders<T>(\n+        &self,\n+        binder: &ty::Binder<T>,\n+    ) -> (T, PlaceholderMap<'tcx>)\n+    where\n+        T : TypeFoldable<'tcx>,\n     {\n         let new_universe = self.create_subuniverse();\n \n         let (result, map) = self.tcx.replace_late_bound_regions(binder, |br| {\n-            self.tcx.mk_region(ty::RePlaceholder(new_universe, br))\n+            self.tcx.mk_region(ty::RePlaceholder(ty::Placeholder {\n+                universe: new_universe,\n+                name: br,\n+            }))\n         });\n \n         debug!(\"skolemize_bound_regions(binder={:?}, result={:?}, map={:?})\",\n@@ -758,7 +763,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     assert!(\n                         match *r {\n                             ty::ReVar(_) => true,\n-                            ty::RePlaceholder(_, ref br1) => br == br1,\n+                            ty::RePlaceholder(index) => index.name == *br,\n                             _ => false,\n                         },\n                         \"leak-check would have us replace {:?} with {:?}\","}, {"sha": "291b46edccfb2342b6b9f981fd4865d1d95ba4b7", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0887456401755b626f08b94f012222fbee4b0323/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0887456401755b626f08b94f012222fbee4b0323/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=0887456401755b626f08b94f012222fbee4b0323", "patch": "@@ -406,12 +406,14 @@ pub enum RegionVariableOrigin {\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum NLLRegionVariableOrigin {\n-    // During NLL region processing, we create variables for free\n-    // regions that we encounter in the function signature and\n-    // elsewhere. This origin indices we've got one of those.\n+    /// During NLL region processing, we create variables for free\n+    /// regions that we encounter in the function signature and\n+    /// elsewhere. This origin indices we've got one of those.\n     FreeRegion,\n \n-    BoundRegion(ty::UniverseIndex),\n+    /// \"Universal\" instantiation of a higher-ranked region (e.g.,\n+    /// from a `for<'a> T` binder). Meant to represent \"any region\".\n+    Placeholder(ty::Placeholder),\n \n     Existential,\n }\n@@ -420,7 +422,7 @@ impl NLLRegionVariableOrigin {\n     pub fn is_universal(self) -> bool {\n         match self {\n             NLLRegionVariableOrigin::FreeRegion => true,\n-            NLLRegionVariableOrigin::BoundRegion(..) => true,\n+            NLLRegionVariableOrigin::Placeholder(..) => true,\n             NLLRegionVariableOrigin::Existential => false,\n         }\n     }"}, {"sha": "4040e6677e967874a00b9ca3d37eba4d9cf632d3", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0887456401755b626f08b94f012222fbee4b0323/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0887456401755b626f08b94f012222fbee4b0323/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=0887456401755b626f08b94f012222fbee4b0323", "patch": "@@ -830,7 +830,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             | ty::ReErased\n             | ty::ReFree(..)\n             | ty::ReEarlyBound(..) => ty::UniverseIndex::ROOT,\n-            ty::RePlaceholder(universe, _) => universe,\n+            ty::RePlaceholder(placeholder) => placeholder.universe,\n             ty::ReClosureBound(vid) | ty::ReVar(vid) => self.var_universe(vid),\n             ty::ReLateBound(..) => bug!(\"universe(): encountered bound region {:?}\", region),\n             ty::ReCanonical(..) => bug!("}, {"sha": "eb3b6f28202dd3f90ad86ca6539a785723e974a1", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0887456401755b626f08b94f012222fbee4b0323/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0887456401755b626f08b94f012222fbee4b0323/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=0887456401755b626f08b94f012222fbee4b0323", "patch": "@@ -1980,15 +1980,16 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             obligation.predicate.def_id(),\n             obligation.predicate.skip_binder().trait_ref.self_ty(),\n             |impl_def_id| {\n-                self.probe(|this, snapshot| /* [1] */\n-                    if let Ok(placeholder_map) = this.match_impl(impl_def_id, obligation, snapshot) {\n+                self.probe(|this, snapshot| {\n+                    if let Ok(placeholder_map) = this.match_impl(impl_def_id, obligation, snapshot)\n+                    {\n                         candidates.vec.push(ImplCandidate(impl_def_id));\n \n                         // NB: we can safely drop the placeholder map\n-                        // since we are in a probe [1]\n+                        // since we are in a probe.\n                         mem::drop(placeholder_map);\n                     }\n-                );\n+                });\n             },\n         );\n "}, {"sha": "74a8ccd07c75f5fc5fad08542a310e25ca879694", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0887456401755b626f08b94f012222fbee4b0323/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0887456401755b626f08b94f012222fbee4b0323/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=0887456401755b626f08b94f012222fbee4b0323", "patch": "@@ -1553,6 +1553,18 @@ impl From<u32> for UniverseIndex {\n     }\n }\n \n+/// The \"placeholder index\" fully defines a placeholder region.\n+/// Placeholder regions are identified by both a **universe** as well\n+/// as a \"bound-region\" within that universe. The `bound_region` is\n+/// basically a name -- distinct bound regions within the same\n+/// universe are just two regions with an unknown relationship to one\n+/// another.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, PartialOrd, Ord)]\n+pub struct Placeholder {\n+    pub universe: UniverseIndex,\n+    pub name: BoundRegion,\n+}\n+\n /// When type checking, we use the `ParamEnv` to track\n /// details about the set of where-clauses that are in scope at this\n /// particular point."}, {"sha": "d8dd73da536d8e70217b1d94b5d208056ba5eacd", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0887456401755b626f08b94f012222fbee4b0323/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0887456401755b626f08b94f012222fbee4b0323/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=0887456401755b626f08b94f012222fbee4b0323", "patch": "@@ -1134,7 +1134,7 @@ pub enum RegionKind {\n \n     /// A placeholder region - basically the higher-ranked version of ReFree.\n     /// Should not exist after typeck.\n-    RePlaceholder(ty::UniverseIndex, BoundRegion),\n+    RePlaceholder(ty::Placeholder),\n \n     /// Empty lifetime is for data that is never accessed.\n     /// Bottom in the region lattice. We treat ReEmpty somewhat\n@@ -1338,7 +1338,7 @@ impl RegionKind {\n             RegionKind::ReScope(..) => false,\n             RegionKind::ReStatic => true,\n             RegionKind::ReVar(..) => false,\n-            RegionKind::RePlaceholder(_, br) => br.is_named(),\n+            RegionKind::RePlaceholder(placeholder) => placeholder.name.is_named(),\n             RegionKind::ReEmpty => false,\n             RegionKind::ReErased => false,\n             RegionKind::ReClosureBound(..) => false,"}, {"sha": "33534ab27f1470e125e0ba0afc6de37f4fa804aa", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0887456401755b626f08b94f012222fbee4b0323/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0887456401755b626f08b94f012222fbee4b0323/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=0887456401755b626f08b94f012222fbee4b0323", "patch": "@@ -803,7 +803,7 @@ define_print! {\n                 }\n                 ty::ReLateBound(_, br) |\n                 ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n-                ty::RePlaceholder(_, br) => {\n+                ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n                     write!(f, \"{}\", br)\n                 }\n                 ty::ReScope(scope) if cx.identify_regions => {\n@@ -872,8 +872,8 @@ define_print! {\n                     write!(f, \"'?{}\", c.index())\n                 }\n \n-                ty::RePlaceholder(universe, ref bound_region) => {\n-                    write!(f, \"RePlaceholder({:?}, {:?})\", universe, bound_region)\n+                ty::RePlaceholder(placeholder) => {\n+                    write!(f, \"RePlaceholder({:?})\", placeholder)\n                 }\n \n                 ty::ReEmpty => write!(f, \"ReEmpty\"),"}, {"sha": "bc0729458031648d17bd7601157d14475e3c76ee", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0887456401755b626f08b94f012222fbee4b0323/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0887456401755b626f08b94f012222fbee4b0323/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=0887456401755b626f08b94f012222fbee4b0323", "patch": "@@ -1780,9 +1780,11 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n         // lifetimes without names with the value `'0`.\n         match ty.sty {\n             ty::TyKind::Ref(ty::RegionKind::ReLateBound(_, br), _, _)\n-            | ty::TyKind::Ref(ty::RegionKind::RePlaceholder(_, br), _, _) => {\n-                with_highlight_region_for_bound_region(*br, counter, || format!(\"{}\", ty))\n-            }\n+            | ty::TyKind::Ref(\n+                ty::RegionKind::RePlaceholder(ty::Placeholder { name: br, .. }),\n+                _,\n+                _,\n+            ) => with_highlight_region_for_bound_region(*br, counter, || format!(\"{}\", ty)),\n             _ => format!(\"{}\", ty),\n         }\n     }\n@@ -1792,7 +1794,8 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n     fn get_region_name_for_ty(&self, ty: ty::Ty<'tcx>, counter: usize) -> String {\n         match ty.sty {\n             ty::TyKind::Ref(region, _, _) => match region {\n-                ty::RegionKind::ReLateBound(_, br) | ty::RegionKind::RePlaceholder(_, br) => {\n+                ty::RegionKind::ReLateBound(_, br)\n+                | ty::RegionKind::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n                     with_highlight_region_for_bound_region(*br, counter, || format!(\"{}\", region))\n                 }\n                 _ => format!(\"{}\", region),"}, {"sha": "b11369116d4cd7188a5a6c10985ae49932c70f02", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0887456401755b626f08b94f012222fbee4b0323/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0887456401755b626f08b94f012222fbee4b0323/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=0887456401755b626f08b94f012222fbee4b0323", "patch": "@@ -11,7 +11,7 @@\n use super::universal_regions::UniversalRegions;\n use borrow_check::nll::constraints::graph::NormalConstraintGraph;\n use borrow_check::nll::constraints::{ConstraintSccIndex, ConstraintSet, OutlivesConstraint};\n-use borrow_check::nll::region_infer::values::{RegionElement, ToElementIndex};\n+use borrow_check::nll::region_infer::values::{PlaceholderIndices, RegionElement, ToElementIndex};\n use borrow_check::nll::type_check::free_region_relations::UniversalRegionRelations;\n use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n@@ -197,18 +197,21 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .collect();\n \n         // Compute the max universe used anywhere amongst the regions.\n-        let max_universe = definitions\n+        let placeholder_indices: PlaceholderIndices = definitions\n             .iter()\n-            .map(|d| d.universe)\n-            .max()\n-            .unwrap_or(ty::UniverseIndex::ROOT);\n+            .filter_map(|d| match d.origin {\n+                NLLRegionVariableOrigin::Placeholder(placeholder) => Some(placeholder),\n+                _ => None,\n+            })\n+            .collect();\n \n         let constraints = Rc::new(outlives_constraints); // freeze constraints\n         let constraint_graph = Rc::new(constraints.graph(definitions.len()));\n         let fr_static = universal_regions.fr_static;\n         let constraint_sccs = Rc::new(constraints.compute_sccs(&constraint_graph, fr_static));\n \n-        let mut scc_values = RegionValues::new(elements, universal_regions.len(), max_universe);\n+        let mut scc_values =\n+            RegionValues::new(elements, universal_regions.len(), placeholder_indices);\n \n         for region in liveness_constraints.rows() {\n             let scc = constraint_sccs.scc(region);\n@@ -329,17 +332,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     self.scc_values.add_element(scc, variable);\n                 }\n \n-                NLLRegionVariableOrigin::BoundRegion(ui) => {\n-                    // Each placeholder region X outlives its\n-                    // associated universe but nothing else. Every\n-                    // placeholder region is always in a universe that\n-                    // contains `ui` -- but when placeholder regions\n-                    // are placed into an SCC, that SCC may include\n-                    // things from other universes that do not include\n-                    // `ui`.\n+                NLLRegionVariableOrigin::Placeholder(placeholder) => {\n+                    // Each placeholder region is only visible from\n+                    // its universe `ui` and its superuniverses. So we\n+                    // can't just add it into `scc` unless the\n+                    // universe of the scc can name this region.\n                     let scc_universe = self.scc_universes[scc];\n-                    if ui.is_subset_of(scc_universe) {\n-                        self.scc_values.add_element(scc, ui);\n+                    if placeholder.universe.is_subset_of(scc_universe) {\n+                        self.scc_values.add_element(scc, placeholder);\n                     } else {\n                         self.add_incompatible_universe(scc);\n                     }\n@@ -544,8 +544,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // B's value, and check whether all of them are nameable\n         // from universe_a\n         self.scc_values\n-            .subuniverses_contained_in(scc_b)\n-            .all(|u| u.is_subset_of(universe_a))\n+            .placeholders_contained_in(scc_b)\n+            .all(|p| p.universe.is_subset_of(universe_a))\n     }\n \n     /// Extend `scc` so that it can outlive some placeholder region\n@@ -1076,8 +1076,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     );\n                 }\n \n-                NLLRegionVariableOrigin::BoundRegion(universe) => {\n-                    self.check_bound_universal_region(infcx, mir, mir_def_id, fr, universe);\n+                NLLRegionVariableOrigin::Placeholder(placeholder) => {\n+                    self.check_bound_universal_region(infcx, mir, mir_def_id, fr, placeholder);\n                 }\n \n                 NLLRegionVariableOrigin::Existential => {\n@@ -1113,7 +1113,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         assert!(self.scc_universes[longer_fr_scc] == ty::UniverseIndex::ROOT);\n         debug_assert!(\n             self.scc_values\n-                .subuniverses_contained_in(longer_fr_scc)\n+                .placeholders_contained_in(longer_fr_scc)\n                 .next()\n                 .is_none()\n         );\n@@ -1181,9 +1181,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir: &Mir<'tcx>,\n         _mir_def_id: DefId,\n         longer_fr: RegionVid,\n-        universe: ty::UniverseIndex,\n+        placeholder: ty::Placeholder,\n     ) {\n-        debug!(\"check_bound_universal_region(fr={:?})\", longer_fr);\n+        debug!(\n+            \"check_bound_universal_region(fr={:?}, placeholder={:?})\",\n+            longer_fr, placeholder,\n+        );\n \n         let longer_fr_scc = self.constraint_sccs.scc(longer_fr);\n \n@@ -1196,7 +1199,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 .find(|element| match element {\n                     RegionElement::Location(_) => true,\n                     RegionElement::RootUniversalRegion(_) => true,\n-                    RegionElement::SubUniversalRegion(ui) => *ui != universe,\n+                    RegionElement::PlaceholderRegion(placeholder1) => placeholder != *placeholder1,\n                 })\n         } {\n             Some(v) => v,\n@@ -1207,10 +1210,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let error_region = match error_element {\n             RegionElement::Location(l) => self.find_sub_region_live_at(longer_fr, l),\n             RegionElement::RootUniversalRegion(r) => r,\n-            RegionElement::SubUniversalRegion(error_ui) => self.definitions\n+            RegionElement::PlaceholderRegion(error_placeholder) => self.definitions\n                 .iter_enumerated()\n                 .filter_map(|(r, definition)| match definition.origin {\n-                    NLLRegionVariableOrigin::BoundRegion(ui) if error_ui == ui => Some(r),\n+                    NLLRegionVariableOrigin::Placeholder(p) if p == error_placeholder => Some(r),\n                     _ => None,\n                 })\n                 .next()"}, {"sha": "6407661d2921f50178bade326383d3c781fbb50b", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 85, "deletions": 37, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/0887456401755b626f08b94f012222fbee4b0323/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0887456401755b626f08b94f012222fbee4b0323/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=0887456401755b626f08b94f012222fbee4b0323", "patch": "@@ -11,6 +11,7 @@\n use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::ty::{self, RegionVid};\n use rustc_data_structures::bit_set::{HybridBitSet, SparseBitMatrix};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::fmt::Debug;\n@@ -31,8 +32,7 @@ crate struct RegionValueElements {\n impl RegionValueElements {\n     crate fn new(mir: &Mir<'_>) -> Self {\n         let mut num_points = 0;\n-        let statements_before_block: IndexVec<BasicBlock, usize> = mir\n-            .basic_blocks()\n+        let statements_before_block: IndexVec<BasicBlock, usize> = mir.basic_blocks()\n             .iter()\n             .map(|block_data| {\n                 let v = num_points;\n@@ -48,7 +48,7 @@ impl RegionValueElements {\n \n         let mut basic_blocks = IndexVec::with_capacity(num_points);\n         for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {\n-            basic_blocks.extend((0 .. bb_data.statements.len() + 1).map(|_| bb));\n+            basic_blocks.extend((0..bb_data.statements.len() + 1).map(|_| bb));\n         }\n \n         Self {\n@@ -85,7 +85,10 @@ impl RegionValueElements {\n         let block = self.basic_blocks[index];\n         let start_index = self.statements_before_block[block];\n         let statement_index = index.index() - start_index;\n-        Location { block, statement_index }\n+        Location {\n+            block,\n+            statement_index,\n+        }\n     }\n \n     /// Sometimes we get point-indices back from bitsets that may be\n@@ -103,13 +106,15 @@ impl RegionValueElements {\n         index: PointIndex,\n         stack: &mut Vec<PointIndex>,\n     ) {\n-        let Location { block, statement_index } = self.to_location(index);\n+        let Location {\n+            block,\n+            statement_index,\n+        } = self.to_location(index);\n         if statement_index == 0 {\n             // If this is a basic block head, then the predecessors are\n             // the the terminators of other basic blocks\n             stack.extend(\n-                mir\n-                    .predecessors_for(block)\n+                mir.predecessors_for(block)\n                     .iter()\n                     .map(|&pred_bb| mir.terminator_loc(pred_bb))\n                     .map(|pred_loc| self.point_from_location(pred_loc)),\n@@ -127,10 +132,7 @@ newtype_index! {\n     pub struct PointIndex { DEBUG_FORMAT = \"PointIndex({})\" }\n }\n \n-/// A single integer representing a (non-zero) `UniverseIndex`.\n-/// Computed just by subtracting one from `UniverseIndex`; this is\n-/// because the `0` value for `UniverseIndex` represents the root\n-/// universe, and we don't need/want a bit for that one.\n+/// A single integer representing a `ty::Placeholder`.\n newtype_index! {\n     pub struct PlaceholderIndex { DEBUG_FORMAT = \"PlaceholderIndex({})\" }\n }\n@@ -148,7 +150,7 @@ crate enum RegionElement {\n \n     /// A subuniverse from a subuniverse (e.g., instantiated from a\n     /// `for<'a> fn(&'a u32)` type).\n-    SubUniversalRegion(ty::UniverseIndex),\n+    PlaceholderRegion(ty::Placeholder),\n }\n \n /// When we initially compute liveness, we use a bit matrix storing\n@@ -185,7 +187,10 @@ impl<N: Idx> LivenessValues<N> {\n     /// Adds all the elements in the given bit array into the given\n     /// region. Returns true if any of them are newly added.\n     crate fn add_elements(&mut self, row: N, locations: &HybridBitSet<PointIndex>) -> bool {\n-        debug!(\"LivenessValues::add_elements(row={:?}, locations={:?})\", row, locations);\n+        debug!(\n+            \"LivenessValues::add_elements(row={:?}, locations={:?})\",\n+            row, locations\n+        );\n         self.points.union_into_row(row, locations)\n     }\n \n@@ -214,6 +219,52 @@ impl<N: Idx> LivenessValues<N> {\n     }\n }\n \n+/// Maps from `ty::Placeholder` values that are used in the rest of\n+/// rustc to the internal `PlaceholderIndex` values that are used in\n+/// NLL.\n+#[derive(Default)]\n+crate struct PlaceholderIndices {\n+    to_index: FxHashMap<ty::Placeholder, PlaceholderIndex>,\n+    from_index: IndexVec<PlaceholderIndex, ty::Placeholder>,\n+}\n+\n+impl PlaceholderIndices {\n+    crate fn insert(&mut self, placeholder: ty::Placeholder) -> PlaceholderIndex {\n+        let PlaceholderIndices {\n+            to_index,\n+            from_index,\n+        } = self;\n+        *to_index\n+            .entry(placeholder)\n+            .or_insert_with(|| from_index.push(placeholder))\n+    }\n+\n+    crate fn lookup_index(&self, placeholder: ty::Placeholder) -> PlaceholderIndex {\n+        self.to_index[&placeholder]\n+    }\n+\n+    crate fn lookup_placeholder(&self, placeholder: PlaceholderIndex) -> ty::Placeholder {\n+        self.from_index[placeholder]\n+    }\n+\n+    crate fn len(&self) -> usize {\n+        self.from_index.len()\n+    }\n+}\n+\n+impl ::std::iter::FromIterator<ty::Placeholder> for PlaceholderIndices {\n+    fn from_iter<I>(iter: I) -> Self\n+    where\n+        I: IntoIterator<Item = ty::Placeholder>,\n+    {\n+        let mut result = Self::default();\n+        iter.into_iter().for_each(|p| {\n+            result.insert(p);\n+        });\n+        result\n+    }\n+}\n+\n /// Stores the full values for a set of regions (in contrast to\n /// `LivenessValues`, which only stores those points in the where a\n /// region is live). The full value for a region may contain points in\n@@ -235,6 +286,7 @@ impl<N: Idx> LivenessValues<N> {\n #[derive(Clone)]\n crate struct RegionValues<N: Idx> {\n     elements: Rc<RegionValueElements>,\n+    placeholder_indices: Rc<PlaceholderIndices>,\n     points: SparseBitMatrix<N, PointIndex>,\n     free_regions: SparseBitMatrix<N, RegionVid>,\n \n@@ -250,12 +302,13 @@ impl<N: Idx> RegionValues<N> {\n     crate fn new(\n         elements: &Rc<RegionValueElements>,\n         num_universal_regions: usize,\n-        max_universe: ty::UniverseIndex,\n+        placeholder_indices: PlaceholderIndices,\n     ) -> Self {\n-        let num_placeholders = max_universe.as_usize();\n+        let num_placeholders = placeholder_indices.len();\n         Self {\n             elements: elements.clone(),\n             points: SparseBitMatrix::new(elements.num_points),\n+            placeholder_indices: Rc::new(placeholder_indices),\n             free_regions: SparseBitMatrix::new(num_universal_regions),\n             placeholders: SparseBitMatrix::new(num_placeholders),\n         }\n@@ -313,14 +366,11 @@ impl<N: Idx> RegionValues<N> {\n \n     /// Returns the locations contained within a given region `r`.\n     crate fn locations_outlived_by<'a>(&'a self, r: N) -> impl Iterator<Item = Location> + 'a {\n-        self.points\n-            .row(r)\n-            .into_iter()\n-            .flat_map(move |set| {\n-                set.iter()\n-                    .take_while(move |&p| self.elements.point_in_range(p))\n-                    .map(move |p| self.elements.to_location(p))\n-            })\n+        self.points.row(r).into_iter().flat_map(move |set| {\n+            set.iter()\n+                .take_while(move |&p| self.elements.point_in_range(p))\n+                .map(move |p| self.elements.to_location(p))\n+        })\n     }\n \n     /// Returns just the universal regions that are contained in a given region's value.\n@@ -335,32 +385,30 @@ impl<N: Idx> RegionValues<N> {\n     }\n \n     /// Returns all the elements contained in a given region's value.\n-    crate fn subuniverses_contained_in<'a>(\n+    crate fn placeholders_contained_in<'a>(\n         &'a self,\n         r: N,\n-    ) -> impl Iterator<Item = ty::UniverseIndex> + 'a {\n+    ) -> impl Iterator<Item = ty::Placeholder> + 'a {\n         self.placeholders\n             .row(r)\n             .into_iter()\n             .flat_map(|set| set.iter())\n-            .map(|p| ty::UniverseIndex::from_u32((p.index() + 1) as u32))\n+            .map(move |p| self.placeholder_indices.lookup_placeholder(p))\n     }\n \n     /// Returns all the elements contained in a given region's value.\n     crate fn elements_contained_in<'a>(&'a self, r: N) -> impl Iterator<Item = RegionElement> + 'a {\n         let points_iter = self.locations_outlived_by(r).map(RegionElement::Location);\n \n-        let free_regions_iter = self\n-            .universal_regions_outlived_by(r)\n+        let free_regions_iter = self.universal_regions_outlived_by(r)\n             .map(RegionElement::RootUniversalRegion);\n \n-        let subuniverses_iter = self\n-            .subuniverses_contained_in(r)\n-            .map(RegionElement::SubUniversalRegion);\n+        let placeholder_universes_iter = self.placeholders_contained_in(r)\n+            .map(RegionElement::PlaceholderRegion);\n \n         points_iter\n             .chain(free_regions_iter)\n-            .chain(subuniverses_iter)\n+            .chain(placeholder_universes_iter)\n     }\n \n     /// Returns a \"pretty\" string value of the region. Meant for debugging.\n@@ -397,14 +445,14 @@ impl ToElementIndex for RegionVid {\n     }\n }\n \n-impl ToElementIndex for ty::UniverseIndex {\n+impl ToElementIndex for ty::Placeholder {\n     fn add_to_row<N: Idx>(self, values: &mut RegionValues<N>, row: N) -> bool {\n-        let index = PlaceholderIndex::new(self.as_usize() - 1);\n+        let index = values.placeholder_indices.lookup_index(self);\n         values.placeholders.insert(row, index)\n     }\n \n     fn contained_in_row<N: Idx>(self, values: &RegionValues<N>, row: N) -> bool {\n-        let index = PlaceholderIndex::new(self.as_usize() - 1);\n+        let index = values.placeholder_indices.lookup_index(self);\n         values.placeholders.contains(row, index)\n     }\n }\n@@ -467,15 +515,15 @@ fn region_value_str(elements: impl IntoIterator<Item = RegionElement>) -> String\n                 result.push_str(&format!(\"{:?}\", fr));\n             }\n \n-            RegionElement::SubUniversalRegion(ur) => {\n+            RegionElement::PlaceholderRegion(placeholder) => {\n                 if let Some((location1, location2)) = open_location {\n                     push_sep(&mut result);\n                     push_location_range(&mut result, location1, location2);\n                     open_location = None;\n                 }\n \n                 push_sep(&mut result);\n-                result.push_str(&format!(\"{:?}\", ur));\n+                result.push_str(&format!(\"{:?}\", placeholder));\n             }\n         }\n     }"}, {"sha": "8addafaedadf7ab17cce0f62490b9b363ffcb7b4", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 64, "deletions": 36, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/0887456401755b626f08b94f012222fbee4b0323/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0887456401755b626f08b94f012222fbee4b0323/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=0887456401755b626f08b94f012222fbee4b0323", "patch": "@@ -146,18 +146,27 @@ trait TypeRelatingDelegate<'tcx> {\n     /// delegate.\n     fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>);\n \n-    /// Creates a new region variable representing an instantiated\n-    /// higher-ranked region; this will be either existential or\n-    /// universal depending on the context.  So e.g. if you have\n-    /// `for<'a> fn(..) <: for<'b> fn(..)`, then we will first\n-    /// instantiate `'b` with a universally quantitifed region and\n-    /// then `'a` with an existentially quantified region (the order\n-    /// is important so that the existential region `'a` can see the\n-    /// universal one).\n-    fn next_region_var(\n-        &mut self,\n-        universally_quantified: UniversallyQuantified,\n-    ) -> ty::Region<'tcx>;\n+    /// Creates a new universe index. Used when instantiating placeholders.\n+    fn next_subuniverse(&mut self) -> ty::UniverseIndex;\n+\n+    /// Creates a new region variable representing a higher-ranked\n+    /// region that is instantiated existentially. This creates an\n+    /// inference variable, typically.\n+    ///\n+    /// So e.g. if you have `for<'a> fn(..) <: for<'b> fn(..)`, then\n+    /// we will invoke this method to instantiate `'a` with an\n+    /// inference variable (though `'b` would be instantiated first,\n+    /// as a placeholder).\n+    fn next_existential_region_var(&mut self) -> ty::Region<'tcx>;\n+\n+    /// Creates a new region variable representing a\n+    /// higher-ranked region that is instantiated universally.\n+    /// This creates a new region placeholder, typically.\n+    ///\n+    /// So e.g. if you have `for<'a> fn(..) <: for<'b> fn(..)`, then\n+    /// we will invoke this method to instantiate `'b` with a\n+    /// placeholder region.\n+    fn next_placeholder_region(&mut self, placeholder: ty::Placeholder) -> ty::Region<'tcx>;\n \n     /// Creates a new existential region in the given universe. This\n     /// is used when handling subtyping and type variables -- if we\n@@ -197,15 +206,17 @@ impl NllTypeRelatingDelegate<'me, 'bccx, 'gcx, 'tcx> {\n }\n \n impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, '_, 'tcx> {\n-    fn next_region_var(\n-        &mut self,\n-        universally_quantified: UniversallyQuantified,\n-    ) -> ty::Region<'tcx> {\n-        let origin = if universally_quantified.0 {\n-            NLLRegionVariableOrigin::BoundRegion(self.infcx.create_subuniverse())\n-        } else {\n-            NLLRegionVariableOrigin::Existential\n-        };\n+    fn next_subuniverse(&mut self) -> ty::UniverseIndex {\n+        self.infcx.create_subuniverse()\n+    }\n+\n+    fn next_existential_region_var(&mut self) -> ty::Region<'tcx> {\n+        let origin = NLLRegionVariableOrigin::Existential;\n+        self.infcx.next_nll_region_var(origin)\n+    }\n+\n+    fn next_placeholder_region(&mut self, placeholder: ty::Placeholder) -> ty::Region<'tcx> {\n+        let origin = NLLRegionVariableOrigin::Placeholder(placeholder);\n         self.infcx.next_nll_region_var(origin)\n     }\n \n@@ -286,12 +297,37 @@ where\n         universally_quantified: UniversallyQuantified,\n     ) -> BoundRegionScope<'tcx> {\n         let mut scope = BoundRegionScope::default();\n+\n+        // Create a callback that creates (via the delegate) either an\n+        // existential or placeholder region as needed.\n+        let mut next_region = {\n+            let delegate = &mut self.delegate;\n+            let mut lazy_universe = None;\n+            move |br: ty::BoundRegion| {\n+                if universally_quantified.0 {\n+                    // The first time this closure is called, create a\n+                    // new universe for the placeholders we will make\n+                    // from here out.\n+                    let universe = lazy_universe.unwrap_or_else(|| {\n+                        let universe = delegate.next_subuniverse();\n+                        lazy_universe = Some(universe);\n+                        universe\n+                    });\n+\n+                    let placeholder = ty::Placeholder { universe, name: br };\n+                    delegate.next_placeholder_region(placeholder)\n+                } else {\n+                    delegate.next_existential_region_var()\n+                }\n+            }\n+        };\n+\n         value.skip_binder().visit_with(&mut ScopeInstantiator {\n-            delegate: &mut self.delegate,\n+            next_region: &mut next_region,\n             target_index: ty::INNERMOST,\n-            universally_quantified,\n             bound_region_scope: &mut scope,\n         });\n+\n         scope\n     }\n \n@@ -604,21 +640,14 @@ where\n /// binder depth, and finds late-bound regions targeting the\n /// `for<..`>.  For each of those, it creates an entry in\n /// `bound_region_scope`.\n-struct ScopeInstantiator<'me, 'tcx: 'me, D>\n-where\n-    D: TypeRelatingDelegate<'tcx> + 'me,\n-{\n-    delegate: &'me mut D,\n+struct ScopeInstantiator<'me, 'tcx: 'me> {\n+    next_region: &'me mut dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n     // The debruijn index of the scope we are instantiating.\n     target_index: ty::DebruijnIndex,\n-    universally_quantified: UniversallyQuantified,\n     bound_region_scope: &'me mut BoundRegionScope<'tcx>,\n }\n \n-impl<'me, 'tcx, D> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx, D>\n-where\n-    D: TypeRelatingDelegate<'tcx>,\n-{\n+impl<'me, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx> {\n     fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n         self.target_index.shift_in(1);\n         t.super_visit_with(self);\n@@ -629,9 +658,8 @@ where\n \n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n         let ScopeInstantiator {\n-            universally_quantified,\n             bound_region_scope,\n-            delegate,\n+            next_region,\n             ..\n         } = self;\n \n@@ -640,7 +668,7 @@ where\n                 bound_region_scope\n                     .map\n                     .entry(*br)\n-                    .or_insert_with(|| delegate.next_region_var(*universally_quantified));\n+                    .or_insert_with(|| next_region(*br));\n             }\n \n             _ => {}"}]}