{"sha": "6ca454f12c13cd34ca41741d372485e34f79706a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjYTQ1NGYxMmMxM2NkMzRjYTQxNzQxZDM3MjQ4NWUzNGY3OTcwNmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-18T20:51:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-18T20:51:46Z"}, "message": "auto merge of #14854 : jakub-/rust/issue-10991, r=pcwalton\n\nFixes #10991.", "tree": {"sha": "1385420072176bad4fbd476ac8cb96f1327be28d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1385420072176bad4fbd476ac8cb96f1327be28d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ca454f12c13cd34ca41741d372485e34f79706a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ca454f12c13cd34ca41741d372485e34f79706a", "html_url": "https://github.com/rust-lang/rust/commit/6ca454f12c13cd34ca41741d372485e34f79706a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ca454f12c13cd34ca41741d372485e34f79706a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "557b9e7f0f2010a15ab6f93f02bacf52bb1f696d", "url": "https://api.github.com/repos/rust-lang/rust/commits/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d", "html_url": "https://github.com/rust-lang/rust/commit/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d"}, {"sha": "f6efb54d4446313d6dba93dd6bde33cd79354543", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6efb54d4446313d6dba93dd6bde33cd79354543", "html_url": "https://github.com/rust-lang/rust/commit/f6efb54d4446313d6dba93dd6bde33cd79354543"}], "stats": {"total": 86, "additions": 29, "deletions": 57}, "files": [{"sha": "ad8b6e6e53380011ffd6bb51cf53c78de695b2da", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 57, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/6ca454f12c13cd34ca41741d372485e34f79706a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ca454f12c13cd34ca41741d372485e34f79706a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=6ca454f12c13cd34ca41741d372485e34f79706a", "patch": "@@ -3025,6 +3025,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 _ if ty::type_is_trait(t_1) => {},\n \n                 _ => {\n+                    let t_1 = structurally_resolved_type(fcx, e.span, t_1);\n+                    let t_e = structurally_resolved_type(fcx, e.span, t_e);\n+\n                     if ty::type_is_nil(t_e) {\n                         fcx.type_error_message(expr.span, |actual| {\n                             format!(\"cast from nil: `{}` as `{}`\",\n@@ -3039,21 +3042,14 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                         }, t_e, None);\n                     }\n \n-                    let t1 = structurally_resolved_type(fcx, e.span, t_1);\n-                    let te = structurally_resolved_type(fcx, e.span, t_e);\n-                    let t_1_is_scalar = type_is_scalar(fcx, expr.span, t_1);\n-                    let t_1_is_char = type_is_char(fcx, expr.span, t_1);\n-                    let t_1_is_bare_fn = type_is_bare_fn(fcx, expr.span, t_1);\n-                    let t_1_is_float = type_is_floating_point(fcx,\n-                                                              expr.span,\n-                                                              t_1);\n+                    let t_1_is_scalar = ty::type_is_scalar(t_1);\n+                    let t_1_is_char = ty::type_is_char(t_1);\n+                    let t_1_is_bare_fn = ty::type_is_bare_fn(t_1);\n+                    let t_1_is_float = ty::type_is_floating_point(t_1);\n \n                     // casts to scalars other than `char` and `bare fn` are trivial\n-                    let t_1_is_trivial = t_1_is_scalar &&\n-                        !t_1_is_char && !t_1_is_bare_fn;\n-\n-                    if type_is_c_like_enum(fcx, expr.span, t_e) &&\n-                            t_1_is_trivial {\n+                    let t_1_is_trivial = t_1_is_scalar && !t_1_is_char && !t_1_is_bare_fn;\n+                    if ty::type_is_c_like_enum(fcx.tcx(), t_e) && t_1_is_trivial {\n                         if t_1_is_float {\n                             fcx.type_error_message(expr.span, |actual| {\n                                 format!(\"illegal cast; cast through an \\\n@@ -3064,22 +3060,20 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                         }\n                         // casts from C-like enums are allowed\n                     } else if t_1_is_char {\n-                        let te = fcx.infcx().resolve_type_vars_if_possible(te);\n-                        if ty::get(te).sty != ty::ty_uint(ast::TyU8) {\n+                        let t_e = fcx.infcx().resolve_type_vars_if_possible(t_e);\n+                        if ty::get(t_e).sty != ty::ty_uint(ast::TyU8) {\n                             fcx.type_error_message(expr.span, |actual| {\n                                 format!(\"only `u8` can be cast as \\\n                                          `char`, not `{}`\", actual)\n                             }, t_e, None);\n                         }\n-                    } else if ty::get(t1).sty == ty::ty_bool {\n+                    } else if ty::get(t_1).sty == ty::ty_bool {\n                         fcx.tcx()\n                            .sess\n                            .span_err(expr.span,\n                                      \"cannot cast as `bool`, compare with \\\n                                       zero instead\");\n-                    } else if type_is_region_ptr(fcx, expr.span, t_e) &&\n-                        type_is_unsafe_ptr(fcx, expr.span, t_1) {\n-\n+                    } else if ty::type_is_region_ptr(t_e) && ty::type_is_unsafe_ptr(t_1) {\n                         fn is_vec(t: ty::t) -> bool {\n                             match ty::get(t).sty {\n                                 ty::ty_vec(..) => true,\n@@ -3112,7 +3106,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n                         /* this cast is only allowed from &[T] to *T or\n                         &T to *T. */\n-                        match (&ty::get(te).sty, &ty::get(t_1).sty) {\n+                        match (&ty::get(t_e).sty, &ty::get(t_1).sty) {\n                             (&ty::ty_rptr(_, ty::mt { ty: mt1, mutbl: ast::MutImmutable }),\n                              &ty::ty_ptr(ty::mt { ty: mt2, mutbl: ast::MutImmutable }))\n                             if types_compatible(fcx, e.span, mt1, mt2) => {\n@@ -3122,8 +3116,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                 demand::coerce(fcx, e.span, t_1, &**e);\n                             }\n                         }\n-                    } else if !(type_is_scalar(fcx,expr.span,t_e)\n-                                && t_1_is_trivial) {\n+                    } else if !(ty::type_is_scalar(t_e) && t_1_is_trivial) {\n                         /*\n                         If more type combinations should be supported than are\n                         supported here, then file an enhancement issue and\n@@ -4205,41 +4198,6 @@ pub fn type_is_uint(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n     return ty::type_is_uint(typ_s);\n }\n \n-pub fn type_is_scalar(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_scalar(typ_s);\n-}\n-\n-pub fn type_is_char(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_char(typ_s);\n-}\n-\n-pub fn type_is_bare_fn(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_bare_fn(typ_s);\n-}\n-\n-pub fn type_is_floating_point(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_floating_point(typ_s);\n-}\n-\n-pub fn type_is_unsafe_ptr(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_unsafe_ptr(typ_s);\n-}\n-\n-pub fn type_is_region_ptr(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_region_ptr(typ_s);\n-}\n-\n-pub fn type_is_c_like_enum(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_c_like_enum(fcx.ccx.tcx, typ_s);\n-}\n-\n pub fn ast_expr_vstore_to_ty(fcx: &FnCtxt,\n                              e: &ast::Expr,\n                              v: ast::ExprVstore,"}, {"sha": "8f7e6470f909530117d0c527fe0f5591ac48c0ef", "filename": "src/test/compile-fail/issue-10991.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6ca454f12c13cd34ca41741d372485e34f79706a/src%2Ftest%2Fcompile-fail%2Fissue-10991.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ca454f12c13cd34ca41741d372485e34f79706a/src%2Ftest%2Fcompile-fail%2Fissue-10991.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10991.rs?ref=6ca454f12c13cd34ca41741d372485e34f79706a", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let nil = ();\n+    let _t = nil as uint; //~ ERROR: cast from nil: `()` as `uint`\n+}"}]}