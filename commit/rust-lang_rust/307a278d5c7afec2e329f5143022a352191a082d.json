{"sha": "307a278d5c7afec2e329f5143022a352191a082d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwN2EyNzhkNWM3YWZlYzJlMzI5ZjUxNDMwMjJhMzUyMTkxYTA4MmQ=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2021-01-01T22:14:35Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2021-01-24T20:28:30Z"}, "message": "Identify subpatterns by the path to them instead of spans", "tree": {"sha": "0002a2ed3415f7503409fb32e948962324bf8eec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0002a2ed3415f7503409fb32e948962324bf8eec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/307a278d5c7afec2e329f5143022a352191a082d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/307a278d5c7afec2e329f5143022a352191a082d", "html_url": "https://github.com/rust-lang/rust/commit/307a278d5c7afec2e329f5143022a352191a082d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/307a278d5c7afec2e329f5143022a352191a082d/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0162d603b335e7f08b86cdddbb51197202a5a79a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0162d603b335e7f08b86cdddbb51197202a5a79a", "html_url": "https://github.com/rust-lang/rust/commit/0162d603b335e7f08b86cdddbb51197202a5a79a"}], "stats": {"total": 384, "additions": 252, "deletions": 132}, "files": [{"sha": "6ec602ff59b9ce2ad8e32fbe7b81933572b70e53", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/307a278d5c7afec2e329f5143022a352191a082d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307a278d5c7afec2e329f5143022a352191a082d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=307a278d5c7afec2e329f5143022a352191a082d", "patch": "@@ -434,7 +434,7 @@ fn report_arm_reachability<'p, 'tcx>(\n             Reachable(unreachables) if unreachables.is_empty() => {}\n             // The arm is reachable, but contains unreachable subpatterns (from or-patterns).\n             Reachable(unreachables) => {\n-                let mut unreachables: Vec<_> = unreachables.iter().collect();\n+                let mut unreachables = unreachables.clone();\n                 // Emit lints in the order in which they occur in the file.\n                 unreachables.sort_unstable();\n                 for span in unreachables {"}, {"sha": "3c3eb801f94ea0011e778e36c1a9e433731273ee", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 234, "deletions": 107, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/307a278d5c7afec2e329f5143022a352191a082d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307a278d5c7afec2e329f5143022a352191a082d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=307a278d5c7afec2e329f5143022a352191a082d", "patch": "@@ -288,6 +288,7 @@ use super::{Pat, PatKind};\n use super::{PatternFoldable, PatternFolder};\n \n use rustc_data_structures::captures::Captures;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::OnceCell;\n \n use rustc_arena::TypedArena;\n@@ -618,82 +619,236 @@ impl<'p, 'tcx> FromIterator<PatStack<'p, 'tcx>> for Matrix<'p, 'tcx> {\n     }\n }\n \n-/// Represents a set of `Span`s closed under the containment relation. That is, if a `Span` is\n-/// contained in the set then all `Span`s contained in it are also implicitly contained in the set.\n-/// In particular this means that when intersecting two sets, taking the intersection of some span\n-/// and one of its subspans returns the subspan, whereas a simple `HashSet` would have returned an\n-/// empty intersection.\n-/// It is assumed that two spans don't overlap without one being contained in the other; in other\n-/// words, that the inclusion structure forms a tree and not a DAG.\n-/// Intersection is not very efficient. It compares everything pairwise. If needed it could be made\n-/// faster by sorting the `Span`s and merging cleverly.\n-#[derive(Debug, Clone, Default)]\n-pub(crate) struct SpanSet {\n-    /// The minimal set of `Span`s required to represent the whole set. If A and B are `Span`s in\n-    /// the `SpanSet`, and A is a descendant of B, then only B will be in `root_spans`.\n-    /// Invariant: the spans are disjoint.\n-    root_spans: Vec<Span>,\n+/// Given a pattern or a pattern-stack, this struct captures a set of its subpattern branches. We\n+/// use that to track unreachable sub-patterns arising from or-patterns. In the absence of\n+/// or-patterns this will always be either `Empty` or `Full`.\n+/// We support a limited set of operations, so not all possible sets of subpatterns can be\n+/// represented. That's ok, we only want the ones that make sense to capture unreachable\n+/// subpatterns.\n+/// What we're trying to do is illustrated by this:\n+/// ```\n+/// match (true, true) {\n+///     (true, true) => {}\n+///     (true | false, true | false) => {}\n+/// }\n+/// ```\n+/// When we try the alternatives of the first or-pattern, the last `true` is unreachable in the\n+/// first alternative but no the other. So we don't want to report it as unreachable. Therefore we\n+/// intersect sets of unreachable patterns coming from different alternatives in order to figure\n+/// out which subpatterns are overall unreachable.\n+#[derive(Debug, Clone)]\n+enum SubPatSet<'p, 'tcx> {\n+    /// The set containing the full pattern.\n+    Full,\n+    /// The empty set.\n+    Empty,\n+    /// If the pattern is a pattern with a constructor or a pattern-stack, we store a set for each\n+    /// of its subpatterns. Missing entries in the map are implicitly empty.\n+    Seq { subpats: FxHashMap<usize, SubPatSet<'p, 'tcx>> },\n+    /// If the pattern is an or-pattern, we store a set for each of its alternatives. Missing\n+    /// entries in the map are implicitly full. Note: we always flatten nested or-patterns.\n+    Alt {\n+        subpats: FxHashMap<usize, SubPatSet<'p, 'tcx>>,\n+        /// Counts the total number of alternatives in the pattern\n+        alt_count: usize,\n+        /// We keep the pattern around to retrieve spans.\n+        pat: &'p Pat<'tcx>,\n+    },\n }\n \n-impl SpanSet {\n-    /// Creates an empty set.\n-    fn new() -> Self {\n-        Self::default()\n-    }\n-\n-    /// Tests whether the set is empty.\n-    pub(crate) fn is_empty(&self) -> bool {\n-        self.root_spans.is_empty()\n+impl<'p, 'tcx> SubPatSet<'p, 'tcx> {\n+    fn empty() -> Self {\n+        SubPatSet::Empty\n     }\n-\n-    /// Iterate over the disjoint list of spans at the roots of this set.\n-    pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item = Span> + Captures<'a> {\n-        self.root_spans.iter().copied()\n+    fn full() -> Self {\n+        SubPatSet::Full\n     }\n \n-    /// Tests whether the set contains a given Span.\n-    fn contains(&self, span: Span) -> bool {\n-        self.iter().any(|root_span| root_span.contains(span))\n+    fn is_full(&self) -> bool {\n+        match self {\n+            SubPatSet::Full => true,\n+            SubPatSet::Empty => false,\n+            // If any subpattern in a sequence is unreachable, the whole pattern is unreachable.\n+            SubPatSet::Seq { subpats } => subpats.values().any(|set| set.is_full()),\n+            SubPatSet::Alt { subpats, .. } => subpats.values().all(|set| set.is_full()),\n+        }\n     }\n \n-    /// Add a span to the set if we know the span has no intersection in this set.\n-    fn push_nonintersecting(&mut self, new_span: Span) {\n-        self.root_spans.push(new_span);\n+    fn is_empty(&self) -> bool {\n+        match self {\n+            SubPatSet::Full => false,\n+            SubPatSet::Empty => true,\n+            SubPatSet::Seq { subpats } => subpats.values().all(|sub_set| sub_set.is_empty()),\n+            SubPatSet::Alt { subpats, alt_count, .. } => {\n+                subpats.len() == *alt_count && subpats.values().all(|set| set.is_empty())\n+            }\n+        }\n     }\n \n-    fn intersection_mut(&mut self, other: &Self) {\n-        if self.is_empty() || other.is_empty() {\n-            *self = Self::new();\n+    /// Intersect `self` with `other`, mutating `self`.\n+    fn intersect(&mut self, other: Self) {\n+        use SubPatSet::*;\n+        // Intersecting with empty stays empty; intersecting with full changes nothing.\n+        if self.is_empty() || other.is_full() {\n+            return;\n+        } else if self.is_full() {\n+            *self = other;\n+            return;\n+        } else if other.is_empty() {\n+            *self = Empty;\n             return;\n         }\n-        // Those that were in `self` but not contained in `other`\n-        let mut leftover = SpanSet::new();\n-        // We keep the elements in `self` that are also in `other`.\n-        self.root_spans.retain(|span| {\n-            let retain = other.contains(*span);\n-            if !retain {\n-                leftover.root_spans.push(*span);\n+\n+        match (&mut *self, other) {\n+            (Seq { subpats: s_set }, Seq { subpats: mut o_set }) => {\n+                s_set.retain(|i, s_sub_set| {\n+                    // Missing entries count as empty.\n+                    let o_sub_set = o_set.remove(&i).unwrap_or(Empty);\n+                    s_sub_set.intersect(o_sub_set);\n+                    // We drop empty entries.\n+                    !s_sub_set.is_empty()\n+                });\n+                // Everything left in `o_set` is missing from `s_set`, i.e. counts as empty. Since\n+                // intersecting with empty returns empty, we can drop those entries.\n             }\n-            retain\n-        });\n-        // We keep the elements in `other` that are also in the original `self`. You might think\n-        // this is not needed because `self` already contains the intersection. But those aren't\n-        // just sets of things. If `self = [a]`, `other = [b]` and `a` contains `b`, then `b`\n-        // belongs in the intersection but we didn't catch it in the filtering above. We look at\n-        // `leftover` instead of the full original `self` to avoid duplicates.\n-        for span in other.iter() {\n-            if leftover.contains(span) {\n-                self.root_spans.push(span);\n+            (Alt { subpats: s_set, .. }, Alt { subpats: mut o_set, .. }) => {\n+                s_set.retain(|i, s_sub_set| {\n+                    // Missing entries count as full.\n+                    let o_sub_set = o_set.remove(&i).unwrap_or(Full);\n+                    s_sub_set.intersect(o_sub_set);\n+                    // We drop full entries.\n+                    !s_sub_set.is_full()\n+                });\n+                // Everything left in `o_set` is missing from `s_set`, i.e. counts as full. Since\n+                // intersecting with full changes nothing, we can take those entries as is.\n+                s_set.extend(o_set);\n             }\n+            _ => bug!(),\n+        }\n+\n+        if self.is_empty() {\n+            *self = Empty;\n         }\n     }\n+\n+    /// Returns a list of the spans of the unreachable subpatterns. If `self` is full we return\n+    /// `None`.\n+    fn to_spans(&self) -> Option<Vec<Span>> {\n+        /// Panics if `set.is_full()`.\n+        fn fill_spans(set: &SubPatSet<'_, '_>, spans: &mut Vec<Span>) {\n+            match set {\n+                SubPatSet::Full => bug!(),\n+                SubPatSet::Empty => {}\n+                SubPatSet::Seq { subpats } => {\n+                    for (_, sub_set) in subpats {\n+                        fill_spans(sub_set, spans);\n+                    }\n+                }\n+                SubPatSet::Alt { subpats, pat, alt_count, .. } => {\n+                    let expanded = pat.expand_or_pat();\n+                    for i in 0..*alt_count {\n+                        let sub_set = subpats.get(&i).unwrap_or(&SubPatSet::Full);\n+                        if sub_set.is_full() {\n+                            spans.push(expanded[i].span);\n+                        } else {\n+                            fill_spans(sub_set, spans);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if self.is_full() {\n+            return None;\n+        }\n+        if self.is_empty() {\n+            return Some(Vec::new());\n+        }\n+        let mut spans = Vec::new();\n+        fill_spans(self, &mut spans);\n+        Some(spans)\n+    }\n+\n+    /// When `self` refers to a patstack that was obtained from specialization, after running\n+    /// `unspecialize` it will refer to the original patstack before specialization.\n+    fn unspecialize(self, arity: usize) -> Self {\n+        use SubPatSet::*;\n+        match self {\n+            Full => Full,\n+            Empty => Empty,\n+            Seq { subpats } => {\n+                // We gather the first `arity` subpatterns together and shift the remaining ones.\n+                let mut new_subpats = FxHashMap::default();\n+                let mut new_subpats_first_col = FxHashMap::default();\n+                for (i, sub_set) in subpats {\n+                    if i < arity {\n+                        // The first `arity` indices are now part of the pattern in the first\n+                        // column.\n+                        new_subpats_first_col.insert(i, sub_set);\n+                    } else {\n+                        // Indices after `arity` are simply shifted\n+                        new_subpats.insert(i - arity + 1, sub_set);\n+                    }\n+                }\n+                if !new_subpats_first_col.is_empty() {\n+                    new_subpats.insert(0, Seq { subpats: new_subpats_first_col });\n+                }\n+                Seq { subpats: new_subpats }\n+            }\n+            Alt { .. } => bug!(), // `self` is a patstack\n+        }\n+    }\n+\n+    /// When `self` refers to a patstack that was obtained from splitting an or-pattern, after\n+    /// running `unspecialize` it will refer to the original patstack before splitting.\n+    ///\n+    /// This case is subtle. Consider:\n+    /// ```\n+    /// match Some(true) {\n+    ///     Some(true) => {}\n+    ///     None | Some(true | false) => {}\n+    /// }\n+    /// ```\n+    /// Imagine we naively preserved the sets of unreachable subpatterns. Here `None` would return\n+    /// the empty set and `Some(true | false)` would return the set containing `true`. Intersecting\n+    /// those two would return the empty set, so we'd miss that the last `true` is unreachable.\n+    /// To fix that, when specializing a given alternative of an or-pattern, we consider all other\n+    /// alternatives as unreachable. That way, intersecting the results will not unduly discard\n+    /// unreachable subpatterns coming from the other alternatives. This is what this function does\n+    /// (remember that missing entries in the `Alt` case count as full; in other words alternatives\n+    /// other than `alt_id` count as unreachable).\n+    fn unsplit_or_pat(mut self, alt_id: usize, alt_count: usize, pat: &'p Pat<'tcx>) -> Self {\n+        use SubPatSet::*;\n+        if self.is_full() {\n+            return Full;\n+        }\n+\n+        let set_first_col = match &mut self {\n+            Empty => Empty,\n+            Seq { subpats } => subpats.remove(&0).unwrap_or(Empty),\n+            Full => unreachable!(),\n+            Alt { .. } => bug!(), // `self` is a patstack\n+        };\n+        let mut subpats_first_col = FxHashMap::default();\n+        subpats_first_col.insert(alt_id, set_first_col);\n+        let set_first_col = Alt { subpats: subpats_first_col, pat, alt_count };\n+\n+        let mut subpats = match self {\n+            Empty => FxHashMap::default(),\n+            Seq { subpats } => subpats,\n+            Full => unreachable!(),\n+            Alt { .. } => bug!(), // `self` is a patstack\n+        };\n+        subpats.insert(0, set_first_col);\n+        Seq { subpats }\n+    }\n }\n \n #[derive(Clone, Debug)]\n-enum Usefulness<'tcx> {\n+enum Usefulness<'p, 'tcx> {\n     /// Potentially carries a set of sub-branches that have been found to be unreachable. Used\n     /// only in the presence of or-patterns, otherwise it stays empty.\n-    NoWitnesses(SpanSet),\n+    NoWitnesses(SubPatSet<'p, 'tcx>),\n     /// When not carrying witnesses, indicates that the whole pattern is unreachable.\n     NoWitnessesFull,\n     /// Carries a list of witnesses of non-exhaustiveness. Non-empty.\n@@ -702,11 +857,11 @@ enum Usefulness<'tcx> {\n     WithWitnessesEmpty,\n }\n \n-impl<'tcx> Usefulness<'tcx> {\n+impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n     fn new_useful(preference: WitnessPreference) -> Self {\n         match preference {\n             ConstructWitness => WithWitnesses(vec![Witness(vec![])]),\n-            LeaveOutWitness => NoWitnesses(Default::default()),\n+            LeaveOutWitness => NoWitnesses(SubPatSet::empty()),\n         }\n     }\n     fn new_not_useful(preference: WitnessPreference) -> Self {\n@@ -718,33 +873,13 @@ impl<'tcx> Usefulness<'tcx> {\n \n     /// Combine usefulnesses from two branches. This is an associative operation.\n     fn extend(&mut self, other: Self) {\n-        // If we have detected some unreachable sub-branches, we only want to keep them when they\n-        // were unreachable in _all_ branches. Eg. in the following, the last `true` is unreachable\n-        // in the second branch of the first or-pattern, but not otherwise. Therefore we don't want\n-        // to lint that it is unreachable.\n-        // ```\n-        // match (true, true) {\n-        //     (true, true) => {}\n-        //     (false | true, false | true) => {}\n-        // }\n-        // ```\n-        // Here however we _do_ want to lint that the last `false` is unreachable. In order to\n-        // handle that correctly, each branch of an or-pattern marks the other branches as\n-        // unreachable (see `unsplit_or_pat`). That way, intersecting the results will correctly\n-        // identify unreachable sub-patterns.\n-        // ```\n-        // match None {\n-        //     Some(false) => {}\n-        //     None | Some(true | false) => {}\n-        // }\n-        // ```\n         match (&mut *self, other) {\n             (WithWitnesses(s), WithWitnesses(o)) => s.extend(o),\n             (WithWitnessesEmpty, WithWitnesses(o)) => *self = WithWitnesses(o),\n             (WithWitnesses(_), WithWitnessesEmpty) => {}\n             (WithWitnessesEmpty, WithWitnessesEmpty) => {}\n \n-            (NoWitnesses(s), NoWitnesses(o)) => s.intersection_mut(&o),\n+            (NoWitnesses(s), NoWitnesses(o)) => s.intersect(o),\n             (NoWitnessesFull, NoWitnesses(o)) => *self = NoWitnesses(o),\n             (NoWitnesses(_), NoWitnessesFull) => {}\n             (NoWitnessesFull, NoWitnessesFull) => {}\n@@ -761,8 +896,8 @@ impl<'tcx> Usefulness<'tcx> {\n         let mut ret = Self::new_not_useful(pref);\n         for u in usefulnesses {\n             ret.extend(u);\n-            if let NoWitnesses(spans) = &ret {\n-                if spans.is_empty() {\n+            if let NoWitnesses(subpats) = &ret {\n+                if subpats.is_empty() {\n                     // Once we reach the empty set, more intersections won't change the result.\n                     return ret;\n                 }\n@@ -773,30 +908,19 @@ impl<'tcx> Usefulness<'tcx> {\n \n     /// After calculating the usefulness for a branch of an or-pattern, call this to make this\n     /// usefulness mergeable with those from the other branches.\n-    fn unsplit_or_pat(self, this_span: Span, or_pat_spans: &[Span]) -> Self {\n-        match self {\n-            NoWitnesses(mut spans) => {\n-                // We register the spans of the other branches of this or-pattern as being\n-                // unreachable from this one. This ensures that intersecting together the sets of\n-                // spans returns what we want.\n-                // Until we optimize `SpanSet` however, intersecting this entails a number of\n-                // comparisons quadratic in the number of branches.\n-                for &span in or_pat_spans {\n-                    if span != this_span {\n-                        spans.push_nonintersecting(span);\n-                    }\n-                }\n-                NoWitnesses(spans)\n-            }\n-            NoWitnessesFull => NoWitnessesFull,\n+    fn unsplit_or_pat(self, alt_id: usize, alt_count: usize, pat: &'p Pat<'tcx>) -> Self {\n+        let subpats = match self {\n+            NoWitnesses(subpats) => subpats,\n+            NoWitnessesFull => SubPatSet::full(),\n             WithWitnesses(_) | WithWitnessesEmpty => bug!(),\n-        }\n+        };\n+        NoWitnesses(subpats.unsplit_or_pat(alt_id, alt_count, pat))\n     }\n \n     /// After calculating usefulness after a specialization, call this to recontruct a usefulness\n     /// that makes sense for the matrix pre-specialization. This new usefulness can then be merged\n     /// with the results of specializing with the other constructors.\n-    fn apply_constructor<'p>(\n+    fn apply_constructor(\n         self,\n         pcx: PatCtxt<'_, 'p, 'tcx>,\n         matrix: &Matrix<'p, 'tcx>, // used to compute missing ctors\n@@ -836,7 +960,9 @@ impl<'tcx> Usefulness<'tcx> {\n                 };\n                 WithWitnesses(new_witnesses)\n             }\n-            x => x,\n+            NoWitnesses(subpats) => NoWitnesses(subpats.unspecialize(ctor_wild_subpatterns.len())),\n+            NoWitnessesFull => NoWitnessesFull,\n+            WithWitnessesEmpty => WithWitnessesEmpty,\n         }\n     }\n }\n@@ -953,7 +1079,7 @@ fn is_useful<'p, 'tcx>(\n     hir_id: HirId,\n     is_under_guard: bool,\n     is_top_level: bool,\n-) -> Usefulness<'tcx> {\n+) -> Usefulness<'p, 'tcx> {\n     debug!(\"matrix,v={:?}{:?}\", matrix, v);\n     let Matrix { patterns: rows, .. } = matrix;\n \n@@ -981,13 +1107,13 @@ fn is_useful<'p, 'tcx>(\n     // If the first pattern is an or-pattern, expand it.\n     let ret = if v.head().is_or_pat() {\n         debug!(\"expanding or-pattern\");\n+        let v_head = v.head();\n         let vs: Vec<_> = v.expand_or_pat().collect();\n-        let subspans: Vec<_> = vs.iter().map(|v| v.head().span).collect();\n+        let alt_count = vs.len();\n         // We expand the or pattern, trying each of its branches in turn and keeping careful track\n         // of possible unreachable sub-branches.\n         let mut matrix = matrix.clone();\n-        let usefulnesses = vs.into_iter().map(|v| {\n-            let v_span = v.head().span;\n+        let usefulnesses = vs.into_iter().enumerate().map(|(i, v)| {\n             let usefulness =\n                 is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n             // If pattern has a guard don't add it to the matrix.\n@@ -996,7 +1122,7 @@ fn is_useful<'p, 'tcx>(\n                 // branches like `Some(_) | Some(0)`.\n                 matrix.push(v);\n             }\n-            usefulness.unsplit_or_pat(v_span, &subspans)\n+            usefulness.unsplit_or_pat(i, alt_count, v_head)\n         });\n         Usefulness::merge(witness_preference, usefulnesses)\n     } else {\n@@ -1045,7 +1171,7 @@ crate struct MatchArm<'p, 'tcx> {\n crate enum Reachability {\n     /// Potentially carries a set of sub-branches that have been found to be unreachable. Used only\n     /// in the presence of or-patterns, otherwise it stays empty.\n-    Reachable(SpanSet),\n+    Reachable(Vec<Span>),\n     Unreachable,\n }\n \n@@ -1081,7 +1207,8 @@ crate fn compute_match_usefulness<'p, 'tcx>(\n                 matrix.push(v);\n             }\n             let reachability = match usefulness {\n-                NoWitnesses(spans) => Reachability::Reachable(spans),\n+                NoWitnesses(subpats) if subpats.is_full() => Reachability::Unreachable,\n+                NoWitnesses(subpats) => Reachability::Reachable(subpats.to_spans().unwrap()),\n                 NoWitnessesFull => Reachability::Unreachable,\n                 WithWitnesses(..) | WithWitnessesEmpty => bug!(),\n             };"}, {"sha": "bdb7a1ec92b7f3ce42e3640d36b897d59db603fc", "filename": "src/test/ui/or-patterns/exhaustiveness-unreachable-pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/307a278d5c7afec2e329f5143022a352191a082d/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307a278d5c7afec2e329f5143022a352191a082d/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs?ref=307a278d5c7afec2e329f5143022a352191a082d", "patch": "@@ -103,8 +103,8 @@ fn main() {\n     }\n     macro_rules! t_or_f {\n         () => {\n-            (true // FIXME: should be unreachable\n-                        | false)\n+            (true //~ ERROR unreachable\n+            | false)\n         };\n     }\n     match (true, None) {"}, {"sha": "51991fc6039674c364009ade50068b34c7a3381c", "filename": "src/test/ui/or-patterns/exhaustiveness-unreachable-pattern.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/307a278d5c7afec2e329f5143022a352191a082d/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/307a278d5c7afec2e329f5143022a352191a082d/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr?ref=307a278d5c7afec2e329f5143022a352191a082d", "patch": "@@ -131,6 +131,17 @@ error: unreachable pattern\n LL |         (true | false, None | Some(true\n    |                                    ^^^^\n \n+error: unreachable pattern\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:106:14\n+   |\n+LL |             (true\n+   |              ^^^^\n+...\n+LL |         (true | false, None | Some(t_or_f!())) => {}\n+   |                                    --------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n error: unreachable pattern\n   --> $DIR/exhaustiveness-unreachable-pattern.rs:117:14\n    |\n@@ -155,5 +166,5 @@ error: unreachable pattern\n LL |             | true,\n    |               ^^^^\n \n-error: aborting due to 25 previous errors\n+error: aborting due to 26 previous errors\n "}, {"sha": "aac7d7d5385a4177851250643fb5d45bad2443d2", "filename": "src/test/ui/pattern/usefulness/issue-80501-or-pat-and-macro.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/307a278d5c7afec2e329f5143022a352191a082d/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-80501-or-pat-and-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307a278d5c7afec2e329f5143022a352191a082d/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-80501-or-pat-and-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-80501-or-pat-and-macro.rs?ref=307a278d5c7afec2e329f5143022a352191a082d", "patch": "@@ -1,5 +1,5 @@\n+// check-pass\n #![deny(unreachable_patterns)]\n-//~^ NOTE: lint level is defined here\n pub enum TypeCtor {\n     Slice,\n     Array,\n@@ -9,13 +9,13 @@ pub struct ApplicationTy(TypeCtor);\n \n macro_rules! ty_app {\n     ($ctor:pat) => {\n-        ApplicationTy($ctor) //~ ERROR unreachable pattern\n+        ApplicationTy($ctor)\n     };\n }\n \n fn _foo(ty: ApplicationTy) {\n     match ty {\n-        ty_app!(TypeCtor::Array) | ty_app!(TypeCtor::Slice) => {} //~ NOTE: in this expansion\n+        ty_app!(TypeCtor::Array) | ty_app!(TypeCtor::Slice) => {}\n     }\n \n     // same as above, with the macro expanded"}, {"sha": "9d12b4a20e953dbf6f56f0ca3cf1670859eb9dd3", "filename": "src/test/ui/pattern/usefulness/issue-80501-or-pat-and-macro.stderr", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0162d603b335e7f08b86cdddbb51197202a5a79a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-80501-or-pat-and-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0162d603b335e7f08b86cdddbb51197202a5a79a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-80501-or-pat-and-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-80501-or-pat-and-macro.stderr?ref=0162d603b335e7f08b86cdddbb51197202a5a79a", "patch": "@@ -1,18 +0,0 @@\n-error: unreachable pattern\n-  --> $DIR/issue-80501-or-pat-and-macro.rs:12:9\n-   |\n-LL |         ApplicationTy($ctor)\n-   |         ^^^^^^^^^^^^^^^^^^^^\n-...\n-LL |         ty_app!(TypeCtor::Array) | ty_app!(TypeCtor::Slice) => {}\n-   |                                    ------------------------ in this macro invocation\n-   |\n-note: the lint level is defined here\n-  --> $DIR/issue-80501-or-pat-and-macro.rs:1:9\n-   |\n-LL | #![deny(unreachable_patterns)]\n-   |         ^^^^^^^^^^^^^^^^^^^^\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error: aborting due to previous error\n-"}]}