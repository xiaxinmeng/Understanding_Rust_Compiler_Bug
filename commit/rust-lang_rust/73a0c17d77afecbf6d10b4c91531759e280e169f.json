{"sha": "73a0c17d77afecbf6d10b4c91531759e280e169f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczYTBjMTdkNzdhZmVjYmY2ZDEwYjRjOTE1MzE3NTllMjgwZTE2OWY=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-03-23T01:03:12Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-03-23T03:32:47Z"}, "message": "Make cross-crate calls to class methods work", "tree": {"sha": "e2a4a8449c3bc2c35264a90edbf69dd5077d21fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2a4a8449c3bc2c35264a90edbf69dd5077d21fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73a0c17d77afecbf6d10b4c91531759e280e169f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73a0c17d77afecbf6d10b4c91531759e280e169f", "html_url": "https://github.com/rust-lang/rust/commit/73a0c17d77afecbf6d10b4c91531759e280e169f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73a0c17d77afecbf6d10b4c91531759e280e169f/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7f1490d6e783df8c33e53738afa4f2508f18194", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7f1490d6e783df8c33e53738afa4f2508f18194", "html_url": "https://github.com/rust-lang/rust/commit/f7f1490d6e783df8c33e53738afa4f2508f18194"}], "stats": {"total": 123, "additions": 99, "deletions": 24}, "files": [{"sha": "00aa26969d7f4e3279dd6065730adf9d62de7478", "filename": "src/rustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73a0c17d77afecbf6d10b4c91531759e280e169f/src%2Frustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a0c17d77afecbf6d10b4c91531759e280e169f/src%2Frustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcommon.rs?ref=73a0c17d77afecbf6d10b4c91531759e280e169f", "patch": "@@ -78,7 +78,7 @@ const tag_path: uint = 0x40u;\n const tag_path_len: uint = 0x41u;\n const tag_path_elt_mod: uint = 0x42u;\n const tag_path_elt_name: uint = 0x43u;\n-const tag_items_class_member: uint = 0x44u;\n+const tag_item_field: uint = 0x44u;\n \n // used to encode crate_ctxt side tables\n enum astencode_tag { // Reserves 0x50 -- 0x6f"}, {"sha": "02b506f70706499a4b62ea561e196670e5f85900", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/73a0c17d77afecbf6d10b4c91531759e280e169f/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a0c17d77afecbf6d10b4c91531759e280e169f/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=73a0c17d77afecbf6d10b4c91531759e280e169f", "patch": "@@ -13,6 +13,7 @@ import std::map::hashmap;\n \n export get_symbol;\n export get_class_fields;\n+export get_class_method;\n // export get_class_method_ids;\n export get_field_type;\n export get_type_param_count;\n@@ -179,6 +180,16 @@ fn get_impl_method(cstore: cstore::cstore, def: ast::def_id, mname: str)\n     decoder::get_impl_method(cdata, def.node, mname)\n }\n \n+/* Because classes use the iface format rather than the impl format\n+   for their methods (so that get_iface_methods can be reused to get\n+   class methods), classes require a slightly different version of\n+   get_impl_method. Sigh. */\n+fn get_class_method(cstore: cstore::cstore, def: ast::def_id, mname: str)\n+    -> ast::def_id {\n+    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    decoder::get_class_method(cdata, def.node, mname)\n+}\n+\n fn item_is_intrinsic(cstore: cstore::cstore, def: ast::def_id) -> bool {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::item_is_intrinsic(cdata, def.node)"}, {"sha": "cf1947a96dceeecd120f02492739df156bc9789e", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/73a0c17d77afecbf6d10b4c91531759e280e169f/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a0c17d77afecbf6d10b4c91531759e280e169f/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=73a0c17d77afecbf6d10b4c91531759e280e169f", "patch": "@@ -23,6 +23,7 @@ export get_enum_variants;\n export get_type;\n export get_type_param_count;\n export get_impl_iface;\n+export get_class_method;\n export get_impl_method;\n export lookup_def;\n export lookup_item_name;\n@@ -289,6 +290,25 @@ fn get_impl_method(cdata: cmd, id: ast::node_id, name: str) -> ast::def_id {\n     option::get(found)\n }\n \n+fn get_class_method(cdata: cmd, id: ast::node_id, name: str) -> ast::def_id {\n+    let items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n+    let mut found = none;\n+    let cls_items = alt maybe_find_item(id, items) {\n+            some(it) { it }\n+            none { fail (#fmt(\"get_class_method: class id not found \\\n+             when looking up method %s\", name)) }};\n+    ebml::tagged_docs(cls_items, tag_item_method) {|mid|\n+        let m_did = class_member_id(mid, cdata);\n+        if item_name(mid) == name {\n+            found = some(m_did);\n+        }\n+    }\n+    alt found {\n+      some(found) { found }\n+      none { fail (#fmt(\"get_class_method: no method named %s\", name)) }\n+    }\n+}\n+\n fn item_is_intrinsic(cdata: cmd, id: ast::node_id) -> bool {\n     let mut intrinsic = false;\n     ebml::tagged_docs(lookup_item(id, cdata.data), tag_item_is_intrinsic,\n@@ -306,6 +326,7 @@ fn get_item_path(cdata: cmd, id: ast::node_id) -> ast_map::path {\n \n fn maybe_get_item_ast(cdata: cmd, tcx: ty::ctxt, maps: maps,\n                       id: ast::node_id) -> csearch::found_ast {\n+    #debug(\"Looking up item: %d\", id);\n     let item_doc = lookup_item(id, cdata.data);\n     let path = vec::init(item_path(item_doc));\n     alt astencode::decode_inlined_item(cdata, tcx, maps, path, item_doc) {\n@@ -389,6 +410,7 @@ fn get_impls_for_mod(cdata: cmd, m_id: ast::node_id,\n     @result\n }\n \n+/* Works for both classes and ifaces */\n fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     -> @[ty::method] {\n     let data = cdata.data;\n@@ -417,7 +439,7 @@ fn get_class_members(cdata: cmd, id: ast::node_id,\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = [];\n-    ebml::tagged_docs(item, tag_items_data_item) {|an_item|\n+    ebml::tagged_docs(item, tag_item_field) {|an_item|\n        if item_family(an_item) == family {\n           let name = item_name(an_item);\n           let did = class_member_id(an_item, cdata);"}, {"sha": "a5c2ef30f7f680dbc6b850fa1ece233b20a7fb18", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 61, "deletions": 18, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/73a0c17d77afecbf6d10b4c91531759e280e169f/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a0c17d77afecbf6d10b4c91531759e280e169f/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=73a0c17d77afecbf6d10b4c91531759e280e169f", "patch": "@@ -353,19 +353,12 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n \n /* Returns an index of items in this class */\n fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n-                         id: node_id, path: ast_map::path, name: ident,\n-                         tps: [ty_param], items: [@class_item])\n+                         id: node_id, path: ast_map::path,\n+                         items: [@class_item],\n+                         global_index: @mutable[entry<int>])\n  -> [entry<int>] {\n     let index = @mutable [];\n-\n     let tcx = ecx.ccx.tcx;\n-    encode_def_id(ebml_w, local_def(id));\n-    encode_family(ebml_w, 'C');\n-    encode_type_param_bounds(ebml_w, ecx, tps);\n-    encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n-    encode_name(ebml_w, name);\n-    encode_path(ebml_w, path, ast_map::path_name(name));\n-\n     for ci in items {\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n@@ -380,22 +373,23 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n           encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n           /* TODO: mutability */\n           encode_def_id(ebml_w, local_def(id));\n+          ebml_w.end_tag();\n         }\n         class_method(m) {\n           *index += [{val: m.id, pos: ebml_w.writer.tell()}];\n-          ebml_w.start_tag(tag_items_data_item);\n-          encode_family(ebml_w, 'h');\n-          encode_name(ebml_w, m.ident);\n+          /* Not sure whether we really need to have two indices,\n+             but it works for now -- tjc */\n+          *global_index += [{val: m.id, pos: ebml_w.writer.tell()}];\n           let impl_path = path + [ast_map::path_name(m.ident)];\n           /*\n             Recall methods are (currently) monomorphic, and we don't\n             repeat the class's ty params in the method decl\n           */\n+          #debug(\"encode_info_for_class: doing %s %d\", m.ident, m.id);\n           encode_info_for_method(ecx, ebml_w, impl_path,\n                                  should_inline(m.attrs), id, m, []);\n         }\n       }\n-      ebml_w.end_tag();\n     }\n     *index\n }\n@@ -404,6 +398,7 @@ fn encode_info_for_fn(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                       id: node_id, ident: ident, path: ast_map::path,\n                       item: option<@item>, tps: [ty_param], decl: fn_decl) {\n         ebml_w.start_tag(tag_items_data_item);\n+        encode_name(ebml_w, ident);\n         encode_def_id(ebml_w, local_def(id));\n         encode_family(ebml_w, purity_fn_family(decl.purity));\n         encode_type_param_bounds(ebml_w, ecx, tps);\n@@ -469,10 +464,16 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n     let tcx = ecx.ccx.tcx;\n     let must_write = alt item.node { item_enum(_, _) { true } _ { false } };\n     if !must_write && !ecx.ccx.reachable.contains_key(item.id) { ret; }\n-    *index += [{val: item.id, pos: ebml_w.writer.tell()}];\n+\n+    fn add_to_index_(item: @item, ebml_w: ebml::writer,\n+                     index: @mutable [entry<int>]) {\n+        *index += [{val: item.id, pos: ebml_w.writer.tell()}];\n+    }\n+    let add_to_index = bind add_to_index_(item, ebml_w, index);\n \n     alt item.node {\n       item_const(_, _) {\n+        add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'c');\n@@ -482,6 +483,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml_w.end_tag();\n       }\n       item_fn(decl, tps, _) {\n+        add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, purity_fn_family(decl.purity));\n@@ -496,9 +498,11 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml_w.end_tag();\n       }\n       item_mod(m) {\n+        add_to_index();\n         encode_info_for_mod(ecx, ebml_w, m, item.id, path, item.ident);\n       }\n       item_native_mod(_) {\n+        add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'n');\n@@ -507,6 +511,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml_w.end_tag();\n       }\n       item_ty(_, tps) {\n+        add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'y');\n@@ -517,6 +522,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml_w.end_tag();\n       }\n       item_enum(variants, tps) {\n+        add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 't');\n@@ -533,15 +539,50 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                                  path, index, tps);\n       }\n       item_class(tps,items,ctor) {\n+        /* First, encode the fields and methods\n+           These come first because we need to write them to make\n+           the index, and the index needs to be in the item for the\n+           class itself */\n+        let idx = encode_info_for_class(ecx, ebml_w, item.id, path, items,\n+                                          index);\n+        /* Index the class*/\n+        add_to_index();\n+        /* Now, make an item for the class itself */\n         ebml_w.start_tag(tag_items_data_item);\n-        let idx = encode_info_for_class(ecx, ebml_w, item.id, path,\n-                 item.ident, tps, items);\n-        /* each class must have its own index */\n+        encode_def_id(ebml_w, local_def(item.id));\n+        encode_family(ebml_w, 'C');\n+        encode_type_param_bounds(ebml_w, ecx, tps);\n+        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+        encode_name(ebml_w, item.ident);\n+        encode_path(ebml_w, path, ast_map::path_name(item.ident));\n+\n+        /* Encode def_ids for each field and method\n+         for methods, write all the stuff get_iface_method\n+        needs to know*/\n+        let (fs,ms) = ast_util::split_class_items(items);\n+        for f in fs {\n+           ebml_w.start_tag(tag_item_field);\n+           encode_family(ebml_w, 'g');\n+           encode_name(ebml_w, f.ident);\n+           encode_def_id(ebml_w, local_def(f.id));\n+           ebml_w.end_tag();\n+        }\n+        for m in ms {\n+           ebml_w.start_tag(tag_item_method);\n+           #debug(\"Writing %s %d\", m.ident, m.id);\n+           encode_family(ebml_w, purity_fn_family(m.decl.purity));\n+           encode_name(ebml_w, m.ident);\n+           encode_type(ecx, ebml_w, node_id_to_type(tcx, m.id));\n+           encode_def_id(ebml_w, local_def(m.id));\n+           ebml_w.end_tag();\n+        }\n+        /* Each class has its own index -- encode it */\n         let bkts = create_index(idx, hash_node_id);\n         encode_index(ebml_w, bkts, write_int);\n         ebml_w.end_tag();\n       }\n       item_res(_, tps, _, _, ctor_id) {\n+        add_to_index();\n         let fn_ty = node_id_to_type(tcx, ctor_id);\n \n         ebml_w.start_tag(tag_items_data_item);\n@@ -565,6 +606,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml_w.end_tag();\n       }\n       item_impl(tps, ifce, _, methods) {\n+        add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'i');\n@@ -598,6 +640,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         }\n       }\n       item_iface(tps, ms) {\n+        add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'I');"}, {"sha": "808c731816fc5a17afaa9301f4916469779ce8ef", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73a0c17d77afecbf6d10b4c91531759e280e169f/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a0c17d77afecbf6d10b4c91531759e280e169f/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=73a0c17d77afecbf6d10b4c91531759e280e169f", "patch": "@@ -2606,7 +2606,7 @@ fn lookup_class_method_by_name(cx:ctxt, did: ast::def_id, name: ident,\n                                   name));\n     }\n     else {\n-      csearch::get_impl_method(cx.sess.cstore, did, name)\n+      csearch::get_class_method(cx.sess.cstore, did, name)\n     }\n }\n "}, {"sha": "c114cad85d2bf4a297e116ddfbbd17b6e5e2e5ba", "filename": "src/test/run-pass/class-method-cross-crate.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/73a0c17d77afecbf6d10b4c91531759e280e169f/src%2Ftest%2Frun-pass%2Fclass-method-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a0c17d77afecbf6d10b4c91531759e280e169f/src%2Ftest%2Frun-pass%2Fclass-method-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-method-cross-crate.rs?ref=73a0c17d77afecbf6d10b4c91531759e280e169f", "patch": "@@ -1,8 +1,7 @@\n-// xfail-test\n // xfail-fast\n // aux-build:cci_class_2.rs\n-use cci_class;\n-import cci_class::kitties::*;\n+use cci_class_2;\n+import cci_class_2::kitties::*;\n \n fn main() {\n   let nyan : cat = cat(52u, 99);"}]}