{"sha": "fffacb34fec23da45c4d18ce8504c7947527aa78", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmZmFjYjM0ZmVjMjNkYTQ1YzRkMThjZTg1MDRjNzk0NzUyN2FhNzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-25T13:46:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-25T13:46:37Z"}, "message": "auto merge of #10646 : alexcrichton/rust/issue-10645, r=luqmana\n\nThis is a behavioral difference in libuv between different platforms in\r\ndifferent situations. It turns out that libuv on windows will immediately\r\nallocate a buffer instead of waiting for data to be ready. What this implies is\r\nthat we must have our custom data set on the handle before we call\r\nuv_read_start.\r\n\r\nI wish I knew of a way to test this, but this relies to being on the windows\r\nplatform *and* reading from a true TTY handle which only happens when this is\r\nactually attached to a terminal. I have manually verified this works.\r\n\r\nCloses #10645", "tree": {"sha": "a59470563bc3b39b3d32f16ea5fb235c0a1d48e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a59470563bc3b39b3d32f16ea5fb235c0a1d48e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fffacb34fec23da45c4d18ce8504c7947527aa78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fffacb34fec23da45c4d18ce8504c7947527aa78", "html_url": "https://github.com/rust-lang/rust/commit/fffacb34fec23da45c4d18ce8504c7947527aa78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fffacb34fec23da45c4d18ce8504c7947527aa78/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1746c0269d356a93aaef367541872d363651cb23", "url": "https://api.github.com/repos/rust-lang/rust/commits/1746c0269d356a93aaef367541872d363651cb23", "html_url": "https://github.com/rust-lang/rust/commit/1746c0269d356a93aaef367541872d363651cb23"}, {"sha": "6acf227cc8db09ca25d274918f860849c41df19a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6acf227cc8db09ca25d274918f860849c41df19a", "html_url": "https://github.com/rust-lang/rust/commit/6acf227cc8db09ca25d274918f860849c41df19a"}], "stats": {"total": 25, "additions": 15, "deletions": 10}, "files": [{"sha": "47ef26ee9d42c17c1e87f6105db855307081ef74", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fffacb34fec23da45c4d18ce8504c7947527aa78/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fffacb34fec23da45c4d18ce8504c7947527aa78/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=fffacb34fec23da45c4d18ce8504c7947527aa78", "patch": "@@ -69,22 +69,27 @@ impl StreamWatcher {\n         // uv_read_stop function\n         let _f = ForbidUnwind::new(\"stream read\");\n \n+        let mut rcx = ReadContext {\n+            buf: Some(slice_to_uv_buf(buf)),\n+            result: 0,\n+            task: None,\n+        };\n+        // When reading a TTY stream on windows, libuv will invoke alloc_cb\n+        // immediately as part of the call to alloc_cb. What this means is that\n+        // we must be ready for this to happen (by setting the data in the uv\n+        // handle). In theory this otherwise doesn't need to happen until after\n+        // the read is succesfully started.\n+        unsafe {\n+            uvll::set_data_for_uv_handle(self.handle, &rcx)\n+        }\n+\n         // Send off the read request, but don't block until we're sure that the\n         // read request is queued.\n         match unsafe {\n             uvll::uv_read_start(self.handle, alloc_cb, read_cb)\n         } {\n             0 => {\n-                let mut rcx = ReadContext {\n-                    buf: Some(slice_to_uv_buf(buf)),\n-                    result: 0,\n-                    task: None,\n-                };\n-                do wait_until_woken_after(&mut rcx.task) {\n-                    unsafe {\n-                        uvll::set_data_for_uv_handle(self.handle, &rcx)\n-                    }\n-                }\n+                wait_until_woken_after(&mut rcx.task, || {});\n                 match rcx.result {\n                     n if n < 0 => Err(UvError(n as c_int)),\n                     n => Ok(n as uint),"}]}