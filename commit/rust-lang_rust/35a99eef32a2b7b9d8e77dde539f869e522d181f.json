{"sha": "35a99eef32a2b7b9d8e77dde539f869e522d181f", "node_id": "C_kwDOAAsO6NoAKDM1YTk5ZWVmMzJhMmI3YjlkOGU3N2RkZTUzOWY4NjllNTIyZDE4MWY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-18T08:53:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-18T08:53:49Z"}, "message": "Auto merge of #104417 - mejrs:mir_build, r=davidtwco\n\nMigrate rustc_mir_build diagnostics\n\nRebases https://github.com/rust-lang/rust/pull/100854\n\n~~The remaining issue is how to better resolve https://github.com/rust-lang/rust/commit/72bea68af4ee2a41c44998916f6a789163f12e7d~~\n\n~~The diagnostic macros seems to generate a broken diagnostic, and I couldn't figure out how to manually format the fluent message, so I hardcoded the format string for now. I'd like pointers to a better fix for this.~~\n\nAlso, I'm not 100% sure I didn't mess up a rebase somewhere \ud83d\ude42\n\nr? `@davidtwco`", "tree": {"sha": "92eb8761928adde225eae4c6f4bdb3e6c95784c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92eb8761928adde225eae4c6f4bdb3e6c95784c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35a99eef32a2b7b9d8e77dde539f869e522d181f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35a99eef32a2b7b9d8e77dde539f869e522d181f", "html_url": "https://github.com/rust-lang/rust/commit/35a99eef32a2b7b9d8e77dde539f869e522d181f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35a99eef32a2b7b9d8e77dde539f869e522d181f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48b3c4612681ba7828880aa9e675452c62714bbf", "url": "https://api.github.com/repos/rust-lang/rust/commits/48b3c4612681ba7828880aa9e675452c62714bbf", "html_url": "https://github.com/rust-lang/rust/commit/48b3c4612681ba7828880aa9e675452c62714bbf"}, {"sha": "f7e894c000d6526c32422c6282ce277c05499a94", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7e894c000d6526c32422c6282ce277c05499a94", "html_url": "https://github.com/rust-lang/rust/commit/f7e894c000d6526c32422c6282ce277c05499a94"}], "stats": {"total": 1505, "additions": 1203, "deletions": 302}, "files": [{"sha": "cce203ef728fa6a85e0eea853b3f41c9b90ac58d", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35a99eef32a2b7b9d8e77dde539f869e522d181f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/35a99eef32a2b7b9d8e77dde539f869e522d181f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=35a99eef32a2b7b9d8e77dde539f869e522d181f", "patch": "@@ -4069,6 +4069,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_infer\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_serialize\",\n  \"rustc_session\","}, {"sha": "60d3d3e69abbe13385988c7a2478e4c33dea03e6", "filename": "compiler/rustc_error_messages/locales/en-US/mir_build.ftl", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/35a99eef32a2b7b9d8e77dde539f869e522d181f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/35a99eef32a2b7b9d8e77dde539f869e522d181f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl?ref=35a99eef32a2b7b9d8e77dde539f869e522d181f", "patch": "@@ -0,0 +1,301 @@\n+mir_build_unconditional_recursion = function cannot return without recursing\n+    .label = cannot return without recursing\n+    .help = a `loop` may express intention better if this is on purpose\n+\n+mir_build_unconditional_recursion_call_site_label = recursive call site\n+\n+mir_build_unsafe_op_in_unsafe_fn_call_to_unsafe_fn_requires_unsafe =\n+    call to unsafe function `{$function}` is unsafe and requires unsafe block (error E0133)\n+    .note = consult the function's documentation for information on how to avoid undefined behavior\n+    .label = call to unsafe function\n+\n+mir_build_unsafe_op_in_unsafe_fn_call_to_unsafe_fn_requires_unsafe_nameless =\n+    call to unsafe function is unsafe and requires unsafe block (error E0133)\n+    .note = consult the function's documentation for information on how to avoid undefined behavior\n+    .label = call to unsafe function\n+\n+mir_build_unsafe_op_in_unsafe_fn_inline_assembly_requires_unsafe =\n+    use of inline assembly is unsafe and requires unsafe block (error E0133)\n+    .note = inline assembly is entirely unchecked and can cause undefined behavior\n+    .label = use of inline assembly\n+\n+mir_build_unsafe_op_in_unsafe_fn_initializing_type_with_requires_unsafe =\n+    initializing type with `rustc_layout_scalar_valid_range` attr is unsafe and requires unsafe\n+    block (error E0133)\n+    .note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n+    .label = initializing type with `rustc_layout_scalar_valid_range` attr\n+\n+mir_build_unsafe_op_in_unsafe_fn_mutable_static_requires_unsafe =\n+    use of mutable static is unsafe and requires unsafe block (error E0133)\n+    .note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n+    .label = use of mutable static\n+\n+mir_build_unsafe_op_in_unsafe_fn_extern_static_requires_unsafe =\n+    use of extern static is unsafe and requires unsafe block (error E0133)\n+    .note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n+    .label = use of extern static\n+\n+mir_build_unsafe_op_in_unsafe_fn_deref_raw_pointer_requires_unsafe =\n+    dereference of raw pointer is unsafe and requires unsafe block (error E0133)\n+    .note = raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+    .label = dereference of raw pointer\n+\n+mir_build_unsafe_op_in_unsafe_fn_union_field_requires_unsafe =\n+    access to union field is unsafe and requires unsafe block (error E0133)\n+    .note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+    .label = access to union field\n+\n+mir_build_unsafe_op_in_unsafe_fn_mutation_of_layout_constrained_field_requires_unsafe =\n+    mutation of layout constrained field is unsafe and requires unsafe block (error E0133)\n+    .note = mutating layout constrained fields cannot statically be checked for valid values\n+    .label = mutation of layout constrained field\n+\n+mir_build_unsafe_op_in_unsafe_fn_borrow_of_layout_constrained_field_requires_unsafe =\n+    borrow of layout constrained field with interior mutability is unsafe and requires unsafe block (error E0133)\n+    .note = references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n+    .label = borrow of layout constrained field with interior mutability\n+\n+mir_build_unsafe_op_in_unsafe_fn_call_to_fn_with_requires_unsafe =\n+    call to function `{$function}` with `#[target_feature]` is unsafe and requires unsafe block (error E0133)\n+    .note = can only be called if the required target features are available\n+    .label = call to function with `#[target_feature]`\n+\n+mir_build_call_to_unsafe_fn_requires_unsafe =\n+    call to unsafe function `{$function}` is unsafe and requires unsafe block\n+    .note = consult the function's documentation for information on how to avoid undefined behavior\n+    .label = call to unsafe function\n+\n+mir_build_call_to_unsafe_fn_requires_unsafe_nameless =\n+    call to unsafe function is unsafe and requires unsafe block\n+    .note = consult the function's documentation for information on how to avoid undefined behavior\n+    .label = call to unsafe function\n+\n+mir_build_call_to_unsafe_fn_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    call to unsafe function `{$function}` is unsafe and requires unsafe function or block\n+    .note = consult the function's documentation for information on how to avoid undefined behavior\n+    .label = call to unsafe function\n+\n+mir_build_call_to_unsafe_fn_requires_unsafe_nameless_unsafe_op_in_unsafe_fn_allowed =\n+    call to unsafe function is unsafe and requires unsafe function or block\n+    .note = consult the function's documentation for information on how to avoid undefined behavior\n+    .label = call to unsafe function\n+\n+mir_build_inline_assembly_requires_unsafe =\n+    use of inline assembly is unsafe and requires unsafe block\n+    .note = inline assembly is entirely unchecked and can cause undefined behavior\n+    .label = use of inline assembly\n+\n+mir_build_inline_assembly_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    use of inline assembly is unsafe and requires unsafe function or block\n+    .note = inline assembly is entirely unchecked and can cause undefined behavior\n+    .label = use of inline assembly\n+\n+mir_build_initializing_type_with_requires_unsafe =\n+    initializing type with `rustc_layout_scalar_valid_range` attr is unsafe and requires unsafe block\n+    .note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n+    .label = initializing type with `rustc_layout_scalar_valid_range` attr\n+\n+mir_build_initializing_type_with_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    initializing type with `rustc_layout_scalar_valid_range` attr is unsafe and requires unsafe function or block\n+    .note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n+    .label = initializing type with `rustc_layout_scalar_valid_range` attr\n+\n+mir_build_mutable_static_requires_unsafe =\n+    use of mutable static is unsafe and requires unsafe block\n+    .note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n+    .label = use of mutable static\n+\n+mir_build_mutable_static_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    use of mutable static is unsafe and requires unsafe function or block\n+    .note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n+    .label = use of mutable static\n+\n+mir_build_extern_static_requires_unsafe =\n+    use of extern static is unsafe and requires unsafe block\n+    .note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n+    .label = use of extern static\n+\n+mir_build_extern_static_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    use of extern static is unsafe and requires unsafe function or block\n+    .note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n+    .label = use of extern static\n+\n+mir_build_deref_raw_pointer_requires_unsafe =\n+    dereference of raw pointer is unsafe and requires unsafe block\n+    .note = raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+    .label = dereference of raw pointer\n+\n+mir_build_deref_raw_pointer_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    dereference of raw pointer is unsafe and requires unsafe function or block\n+    .note = raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+    .label = dereference of raw pointer\n+\n+mir_build_union_field_requires_unsafe =\n+    access to union field is unsafe and requires unsafe block\n+    .note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+    .label = access to union field\n+\n+mir_build_union_field_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    access to union field is unsafe and requires unsafe function or block\n+    .note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+    .label = access to union field\n+\n+mir_build_mutation_of_layout_constrained_field_requires_unsafe =\n+    mutation of layout constrained field is unsafe and requires unsafe block\n+    .note = mutating layout constrained fields cannot statically be checked for valid values\n+    .label = mutation of layout constrained field\n+\n+mir_build_mutation_of_layout_constrained_field_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    mutation of layout constrained field is unsafe and requires unsafe function or block\n+    .note = mutating layout constrained fields cannot statically be checked for valid values\n+    .label = mutation of layout constrained field\n+\n+mir_build_borrow_of_layout_constrained_field_requires_unsafe =\n+    borrow of layout constrained field with interior mutability is unsafe and requires unsafe block\n+    .note = references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n+    .label = borrow of layout constrained field with interior mutability\n+\n+mir_build_borrow_of_layout_constrained_field_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    borrow of layout constrained field with interior mutability is unsafe and requires unsafe function or block\n+    .note = references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n+    .label = borrow of layout constrained field with interior mutability\n+\n+mir_build_call_to_fn_with_requires_unsafe =\n+    call to function `{$function}` with `#[target_feature]` is unsafe and requires unsafe block\n+    .note = can only be called if the required target features are available\n+    .label = call to function with `#[target_feature]`\n+\n+mir_build_call_to_fn_with_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    call to function `{$function}` with `#[target_feature]` is unsafe and requires unsafe function or block\n+    .note = can only be called if the required target features are available\n+    .label = call to function with `#[target_feature]`\n+\n+mir_build_unused_unsafe = unnecessary `unsafe` block\n+    .label = unnecessary `unsafe` block\n+\n+mir_build_unused_unsafe_enclosing_block_label = because it's nested under this `unsafe` block\n+mir_build_unused_unsafe_enclosing_fn_label = because it's nested under this `unsafe` fn\n+\n+mir_build_non_exhaustive_patterns_type_not_empty = non-exhaustive patterns: type `{$ty}` is non-empty\n+    .def_note = `{$peeled_ty}` defined here\n+    .type_note = the matched value is of type `{$ty}`\n+    .non_exhaustive_type_note = the matched value is of type `{$ty}`, which is marked as non-exhaustive\n+    .reference_note = references are always considered inhabited\n+    .suggestion = ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+    .help = ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n+\n+mir_build_static_in_pattern = statics cannot be referenced in patterns\n+\n+mir_build_assoc_const_in_pattern = associated consts cannot be referenced in patterns\n+\n+mir_build_const_param_in_pattern = const parameters cannot be referenced in patterns\n+\n+mir_build_non_const_path = runtime values cannot be referenced in patterns\n+\n+mir_build_unreachable_pattern = unreachable pattern\n+    .label = unreachable pattern\n+    .catchall_label = matches any value\n+\n+mir_build_const_pattern_depends_on_generic_parameter =\n+    constant pattern depends on a generic parameter\n+\n+mir_build_could_not_eval_const_pattern = could not evaluate constant pattern\n+\n+mir_build_lower_range_bound_must_be_less_than_or_equal_to_upper =\n+    lower range bound must be less than or equal to upper\n+    .label = lower bound larger than upper bound\n+    .teach_note = When matching against a range, the compiler verifies that the range is non-empty. Range patterns include both end-points, so this is equivalent to requiring the start of the range to be less than or equal to the end of the range.\n+\n+mir_build_lower_range_bound_must_be_less_than_upper = lower range bound must be less than upper\n+\n+mir_build_leading_irrefutable_let_patterns = leading irrefutable {$count ->\n+        [one] pattern\n+        *[other] patterns\n+    } in let chain\n+    .note = {$count ->\n+        [one] this pattern\n+        *[other] these patterns\n+    } will always match\n+    .help = consider moving {$count ->\n+        [one] it\n+        *[other] them\n+    } outside of the construct\n+\n+mir_build_trailing_irrefutable_let_patterns = trailing irrefutable {$count ->\n+        [one] pattern\n+        *[other] patterns\n+    } in let chain\n+    .note = {$count ->\n+        [one] this pattern\n+        *[other] these patterns\n+    } will always match\n+    .help = consider moving {$count ->\n+        [one] it\n+        *[other] them\n+    } into the body\n+\n+mir_build_bindings_with_variant_name =\n+    pattern binding `{$ident}` is named the same as one of the variants of the type `{$ty_path}`\n+    .suggestion = to match on the variant, qualify the path\n+\n+mir_build_irrefutable_let_patterns_generic_let = irrefutable `let` {$count ->\n+        [one] pattern\n+        *[other] patterns\n+    }\n+    .note = {$count ->\n+        [one] this pattern\n+        *[other] these patterns\n+    } will always match, so the `let` is useless\n+    .help = consider removing `let`\n+\n+mir_build_irrefutable_let_patterns_if_let = irrefutable `if let` {$count ->\n+        [one] pattern\n+        *[other] patterns\n+    }\n+    .note = {$count ->\n+        [one] this pattern\n+        *[other] these patterns\n+    } will always match, so the `if let` is useless\n+    .help = consider replacing the `if let` with a `let`\n+\n+mir_build_irrefutable_let_patterns_if_let_guard = irrefutable `if let` guard {$count ->\n+        [one] pattern\n+        *[other] patterns\n+    }\n+    .note = {$count ->\n+        [one] this pattern\n+        *[other] these patterns\n+    } will always match, so the guard is useless\n+    .help = consider removing the guard and adding a `let` inside the match arm\n+\n+mir_build_irrefutable_let_patterns_let_else = irrefutable `let...else` {$count ->\n+        [one] pattern\n+        *[other] patterns\n+    }\n+    .note = {$count ->\n+        [one] this pattern\n+        *[other] these patterns\n+    } will always match, so the `else` clause is useless\n+    .help = consider removing the `else` clause\n+\n+mir_build_irrefutable_let_patterns_while_let = irrefutable `while let` {$count ->\n+        [one] pattern\n+        *[other] patterns\n+    }\n+    .note = {$count ->\n+        [one] this pattern\n+        *[other] these patterns\n+    } will always match, so the loop will never exit\n+    .help = consider instead using a `loop {\"{\"} ... {\"}\"}` with a `let` inside it\n+\n+mir_build_borrow_of_moved_value = borrow of moved value\n+    .label = value moved into `{$name}` here\n+    .occurs_because_label = move occurs because `{$name}` has type `{$ty}` which does not implement the `Copy` trait\n+    .value_borrowed_label = value borrowed here after move\n+    .suggestion = borrow this binding in the pattern to avoid moving the value\n+\n+mir_build_multiple_mut_borrows = cannot borrow value as mutable more than once at a time\n+    .label = first mutable borrow, by `{$name}`, occurs here\n+    .mutable_borrow = another mutable borrow, by `{$name_mut}`, occurs here\n+    .immutable_borrow = also borrowed as immutable, by `{$name_immut}`, here\n+    .moved = also moved into `{$name_moved}` here"}, {"sha": "25d0e736e599f5ee4d66e501bb62bff8617a2102", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35a99eef32a2b7b9d8e77dde539f869e522d181f/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a99eef32a2b7b9d8e77dde539f869e522d181f/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=35a99eef32a2b7b9d8e77dde539f869e522d181f", "patch": "@@ -57,6 +57,7 @@ fluent_messages! {\n     lint => \"../locales/en-US/lint.ftl\",\n     metadata => \"../locales/en-US/metadata.ftl\",\n     middle => \"../locales/en-US/middle.ftl\",\n+    mir_build => \"../locales/en-US/mir_build.ftl\",\n     mir_dataflow => \"../locales/en-US/mir_dataflow.ftl\",\n     monomorphize => \"../locales/en-US/monomorphize.ftl\",\n     parse => \"../locales/en-US/parse.ftl\","}, {"sha": "4ad3343d3031b2fa1e0f23eb2efc03ffd85edad1", "filename": "compiler/rustc_mir_build/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35a99eef32a2b7b9d8e77dde539f869e522d181f/compiler%2Frustc_mir_build%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/35a99eef32a2b7b9d8e77dde539f869e522d181f/compiler%2Frustc_mir_build%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2FCargo.toml?ref=35a99eef32a2b7b9d8e77dde539f869e522d181f", "patch": "@@ -17,6 +17,7 @@ rustc_index = { path = \"../rustc_index\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_infer = { path = \"../rustc_infer\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "99e96ff77ced9bff4c0ab710e1db1fafc01ebb66", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 185, "deletions": 95, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/35a99eef32a2b7b9d8e77dde539f869e522d181f/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a99eef32a2b7b9d8e77dde539f869e522d181f/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=35a99eef32a2b7b9d8e77dde539f869e522d181f", "patch": "@@ -1,7 +1,7 @@\n use crate::build::ExprCategory;\n+use crate::errors::*;\n use rustc_middle::thir::visit::{self, Visitor};\n \n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_middle::mir::BorrowKind;\n use rustc_middle::thir::*;\n@@ -12,7 +12,6 @@ use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n \n-use std::borrow::Cow;\n use std::ops::Bound;\n \n struct UnsafetyVisitor<'a, 'tcx> {\n@@ -46,7 +45,9 @@ impl<'tcx> UnsafetyVisitor<'_, 'tcx> {\n             self.warn_unused_unsafe(\n                 hir_id,\n                 block_span,\n-                Some((self.tcx.sess.source_map().guess_head_span(enclosing_span), \"block\")),\n+                Some(UnusedUnsafeEnclosing::Block {\n+                    span: self.tcx.sess.source_map().guess_head_span(enclosing_span),\n+                }),\n             );\n             f(self);\n         } else {\n@@ -60,7 +61,9 @@ impl<'tcx> UnsafetyVisitor<'_, 'tcx> {\n                     hir_id,\n                     span,\n                     if self.unsafe_op_in_unsafe_fn_allowed() {\n-                        self.body_unsafety.unsafe_fn_sig_span().map(|span| (span, \"fn\"))\n+                        self.body_unsafety\n+                            .unsafe_fn_sig_span()\n+                            .map(|span| UnusedUnsafeEnclosing::Function { span })\n                     } else {\n                         None\n                     },\n@@ -83,30 +86,11 @@ impl<'tcx> UnsafetyVisitor<'_, 'tcx> {\n             }\n             SafetyContext::UnsafeFn if unsafe_op_in_unsafe_fn_allowed => {}\n             SafetyContext::UnsafeFn => {\n-                let (description, note) = kind.description_and_note(self.tcx);\n                 // unsafe_op_in_unsafe_fn is disallowed\n-                self.tcx.struct_span_lint_hir(\n-                    UNSAFE_OP_IN_UNSAFE_FN,\n-                    self.hir_context,\n-                    span,\n-                    format!(\"{} is unsafe and requires unsafe block (error E0133)\", description,),\n-                    |lint| lint.span_label(span, kind.simple_description()).note(note),\n-                )\n+                kind.emit_unsafe_op_in_unsafe_fn_lint(self.tcx, self.hir_context, span);\n             }\n             SafetyContext::Safe => {\n-                let (description, note) = kind.description_and_note(self.tcx);\n-                let fn_sugg = if unsafe_op_in_unsafe_fn_allowed { \" function or\" } else { \"\" };\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0133,\n-                    \"{} is unsafe and requires unsafe{} block\",\n-                    description,\n-                    fn_sugg,\n-                )\n-                .span_label(span, kind.simple_description())\n-                .note(note)\n-                .emit();\n+                kind.emit_requires_unsafe_err(self.tcx, span, unsafe_op_in_unsafe_fn_allowed);\n             }\n         }\n     }\n@@ -115,17 +99,15 @@ impl<'tcx> UnsafetyVisitor<'_, 'tcx> {\n         &self,\n         hir_id: hir::HirId,\n         block_span: Span,\n-        enclosing_unsafe: Option<(Span, &'static str)>,\n+        enclosing_unsafe: Option<UnusedUnsafeEnclosing>,\n     ) {\n         let block_span = self.tcx.sess.source_map().guess_head_span(block_span);\n-        let msg = \"unnecessary `unsafe` block\";\n-        self.tcx.struct_span_lint_hir(UNUSED_UNSAFE, hir_id, block_span, msg, |lint| {\n-            lint.span_label(block_span, msg);\n-            if let Some((span, kind)) = enclosing_unsafe {\n-                lint.span_label(span, format!(\"because it's nested under this `unsafe` {}\", kind));\n-            }\n-            lint\n-        });\n+        self.tcx.emit_spanned_lint(\n+            UNUSED_UNSAFE,\n+            hir_id,\n+            block_span,\n+            UnusedUnsafe { span: block_span, enclosing: enclosing_unsafe },\n+        );\n     }\n \n     /// Whether the `unsafe_op_in_unsafe_fn` lint is `allow`ed at the current HIR node.\n@@ -536,81 +518,189 @@ enum UnsafeOpKind {\n use UnsafeOpKind::*;\n \n impl UnsafeOpKind {\n-    pub fn simple_description(&self) -> &'static str {\n-        match self {\n-            CallToUnsafeFunction(..) => \"call to unsafe function\",\n-            UseOfInlineAssembly => \"use of inline assembly\",\n-            InitializingTypeWith => \"initializing type with `rustc_layout_scalar_valid_range` attr\",\n-            UseOfMutableStatic => \"use of mutable static\",\n-            UseOfExternStatic => \"use of extern static\",\n-            DerefOfRawPointer => \"dereference of raw pointer\",\n-            AccessToUnionField => \"access to union field\",\n-            MutationOfLayoutConstrainedField => \"mutation of layout constrained field\",\n-            BorrowOfLayoutConstrainedField => {\n-                \"borrow of layout constrained field with interior mutability\"\n-            }\n-            CallToFunctionWith(..) => \"call to function with `#[target_feature]`\",\n-        }\n-    }\n-\n-    pub fn description_and_note(&self, tcx: TyCtxt<'_>) -> (Cow<'static, str>, &'static str) {\n+    pub fn emit_unsafe_op_in_unsafe_fn_lint(\n+        &self,\n+        tcx: TyCtxt<'_>,\n+        hir_id: hir::HirId,\n+        span: Span,\n+    ) {\n         match self {\n-            CallToUnsafeFunction(did) => (\n-                if let Some(did) = did {\n-                    Cow::from(format!(\"call to unsafe function `{}`\", tcx.def_path_str(*did)))\n-                } else {\n-                    Cow::Borrowed(self.simple_description())\n+            CallToUnsafeFunction(did) if did.is_some() => tcx.emit_spanned_lint(\n+                UNSAFE_OP_IN_UNSAFE_FN,\n+                hir_id,\n+                span,\n+                UnsafeOpInUnsafeFnCallToUnsafeFunctionRequiresUnsafe {\n+                    span,\n+                    function: &tcx.def_path_str(did.unwrap()),\n                 },\n-                \"consult the function's documentation for information on how to avoid undefined \\\n-                 behavior\",\n             ),\n-            UseOfInlineAssembly => (\n-                Cow::Borrowed(self.simple_description()),\n-                \"inline assembly is entirely unchecked and can cause undefined behavior\",\n+            CallToUnsafeFunction(..) => tcx.emit_spanned_lint(\n+                UNSAFE_OP_IN_UNSAFE_FN,\n+                hir_id,\n+                span,\n+                UnsafeOpInUnsafeFnCallToUnsafeFunctionRequiresUnsafeNameless { span },\n+            ),\n+            UseOfInlineAssembly => tcx.emit_spanned_lint(\n+                UNSAFE_OP_IN_UNSAFE_FN,\n+                hir_id,\n+                span,\n+                UnsafeOpInUnsafeFnUseOfInlineAssemblyRequiresUnsafe { span },\n             ),\n-            InitializingTypeWith => (\n-                Cow::Borrowed(self.simple_description()),\n-                \"initializing a layout restricted type's field with a value outside the valid \\\n-                 range is undefined behavior\",\n+            InitializingTypeWith => tcx.emit_spanned_lint(\n+                UNSAFE_OP_IN_UNSAFE_FN,\n+                hir_id,\n+                span,\n+                UnsafeOpInUnsafeFnInitializingTypeWithRequiresUnsafe { span },\n             ),\n-            UseOfMutableStatic => (\n-                Cow::Borrowed(self.simple_description()),\n-                \"mutable statics can be mutated by multiple threads: aliasing violations or data \\\n-                 races will cause undefined behavior\",\n+            UseOfMutableStatic => tcx.emit_spanned_lint(\n+                UNSAFE_OP_IN_UNSAFE_FN,\n+                hir_id,\n+                span,\n+                UnsafeOpInUnsafeFnUseOfMutableStaticRequiresUnsafe { span },\n             ),\n-            UseOfExternStatic => (\n-                Cow::Borrowed(self.simple_description()),\n-                \"extern statics are not controlled by the Rust type system: invalid data, \\\n-                 aliasing violations or data races will cause undefined behavior\",\n+            UseOfExternStatic => tcx.emit_spanned_lint(\n+                UNSAFE_OP_IN_UNSAFE_FN,\n+                hir_id,\n+                span,\n+                UnsafeOpInUnsafeFnUseOfExternStaticRequiresUnsafe { span },\n             ),\n-            DerefOfRawPointer => (\n-                Cow::Borrowed(self.simple_description()),\n-                \"raw pointers may be null, dangling or unaligned; they can violate aliasing rules \\\n-                 and cause data races: all of these are undefined behavior\",\n+            DerefOfRawPointer => tcx.emit_spanned_lint(\n+                UNSAFE_OP_IN_UNSAFE_FN,\n+                hir_id,\n+                span,\n+                UnsafeOpInUnsafeFnDerefOfRawPointerRequiresUnsafe { span },\n             ),\n-            AccessToUnionField => (\n-                Cow::Borrowed(self.simple_description()),\n-                \"the field may not be properly initialized: using uninitialized data will cause \\\n-                 undefined behavior\",\n+            AccessToUnionField => tcx.emit_spanned_lint(\n+                UNSAFE_OP_IN_UNSAFE_FN,\n+                hir_id,\n+                span,\n+                UnsafeOpInUnsafeFnAccessToUnionFieldRequiresUnsafe { span },\n             ),\n-            MutationOfLayoutConstrainedField => (\n-                Cow::Borrowed(self.simple_description()),\n-                \"mutating layout constrained fields cannot statically be checked for valid values\",\n+            MutationOfLayoutConstrainedField => tcx.emit_spanned_lint(\n+                UNSAFE_OP_IN_UNSAFE_FN,\n+                hir_id,\n+                span,\n+                UnsafeOpInUnsafeFnMutationOfLayoutConstrainedFieldRequiresUnsafe { span },\n             ),\n-            BorrowOfLayoutConstrainedField => (\n-                Cow::Borrowed(self.simple_description()),\n-                \"references to fields of layout constrained fields lose the constraints. Coupled \\\n-                 with interior mutability, the field can be changed to invalid values\",\n+            BorrowOfLayoutConstrainedField => tcx.emit_spanned_lint(\n+                UNSAFE_OP_IN_UNSAFE_FN,\n+                hir_id,\n+                span,\n+                UnsafeOpInUnsafeFnBorrowOfLayoutConstrainedFieldRequiresUnsafe { span },\n             ),\n-            CallToFunctionWith(did) => (\n-                Cow::from(format!(\n-                    \"call to function `{}` with `#[target_feature]`\",\n-                    tcx.def_path_str(*did)\n-                )),\n-                \"can only be called if the required target features are available\",\n+            CallToFunctionWith(did) => tcx.emit_spanned_lint(\n+                UNSAFE_OP_IN_UNSAFE_FN,\n+                hir_id,\n+                span,\n+                UnsafeOpInUnsafeFnCallToFunctionWithRequiresUnsafe {\n+                    span,\n+                    function: &tcx.def_path_str(*did),\n+                },\n             ),\n         }\n     }\n+\n+    pub fn emit_requires_unsafe_err(\n+        &self,\n+        tcx: TyCtxt<'_>,\n+        span: Span,\n+        unsafe_op_in_unsafe_fn_allowed: bool,\n+    ) {\n+        match self {\n+            CallToUnsafeFunction(did) if did.is_some() && unsafe_op_in_unsafe_fn_allowed => {\n+                tcx.sess.emit_err(CallToUnsafeFunctionRequiresUnsafeUnsafeOpInUnsafeFnAllowed {\n+                    span,\n+                    function: &tcx.def_path_str(did.unwrap()),\n+                });\n+            }\n+            CallToUnsafeFunction(did) if did.is_some() => {\n+                tcx.sess.emit_err(CallToUnsafeFunctionRequiresUnsafe {\n+                    span,\n+                    function: &tcx.def_path_str(did.unwrap()),\n+                });\n+            }\n+            CallToUnsafeFunction(..) if unsafe_op_in_unsafe_fn_allowed => {\n+                tcx.sess.emit_err(\n+                    CallToUnsafeFunctionRequiresUnsafeNamelessUnsafeOpInUnsafeFnAllowed { span },\n+                );\n+            }\n+            CallToUnsafeFunction(..) => {\n+                tcx.sess.emit_err(CallToUnsafeFunctionRequiresUnsafeNameless { span });\n+            }\n+            UseOfInlineAssembly if unsafe_op_in_unsafe_fn_allowed => {\n+                tcx.sess\n+                    .emit_err(UseOfInlineAssemblyRequiresUnsafeUnsafeOpInUnsafeFnAllowed { span });\n+            }\n+            UseOfInlineAssembly => {\n+                tcx.sess.emit_err(UseOfInlineAssemblyRequiresUnsafe { span });\n+            }\n+            InitializingTypeWith if unsafe_op_in_unsafe_fn_allowed => {\n+                tcx.sess\n+                    .emit_err(InitializingTypeWithRequiresUnsafeUnsafeOpInUnsafeFnAllowed { span });\n+            }\n+            InitializingTypeWith => {\n+                tcx.sess.emit_err(InitializingTypeWithRequiresUnsafe { span });\n+            }\n+            UseOfMutableStatic if unsafe_op_in_unsafe_fn_allowed => {\n+                tcx.sess\n+                    .emit_err(UseOfMutableStaticRequiresUnsafeUnsafeOpInUnsafeFnAllowed { span });\n+            }\n+            UseOfMutableStatic => {\n+                tcx.sess.emit_err(UseOfMutableStaticRequiresUnsafe { span });\n+            }\n+            UseOfExternStatic if unsafe_op_in_unsafe_fn_allowed => {\n+                tcx.sess\n+                    .emit_err(UseOfExternStaticRequiresUnsafeUnsafeOpInUnsafeFnAllowed { span });\n+            }\n+            UseOfExternStatic => {\n+                tcx.sess.emit_err(UseOfExternStaticRequiresUnsafe { span });\n+            }\n+            DerefOfRawPointer if unsafe_op_in_unsafe_fn_allowed => {\n+                tcx.sess\n+                    .emit_err(DerefOfRawPointerRequiresUnsafeUnsafeOpInUnsafeFnAllowed { span });\n+            }\n+            DerefOfRawPointer => {\n+                tcx.sess.emit_err(DerefOfRawPointerRequiresUnsafe { span });\n+            }\n+            AccessToUnionField if unsafe_op_in_unsafe_fn_allowed => {\n+                tcx.sess\n+                    .emit_err(AccessToUnionFieldRequiresUnsafeUnsafeOpInUnsafeFnAllowed { span });\n+            }\n+            AccessToUnionField => {\n+                tcx.sess.emit_err(AccessToUnionFieldRequiresUnsafe { span });\n+            }\n+            MutationOfLayoutConstrainedField if unsafe_op_in_unsafe_fn_allowed => {\n+                tcx.sess.emit_err(\n+                    MutationOfLayoutConstrainedFieldRequiresUnsafeUnsafeOpInUnsafeFnAllowed {\n+                        span,\n+                    },\n+                );\n+            }\n+            MutationOfLayoutConstrainedField => {\n+                tcx.sess.emit_err(MutationOfLayoutConstrainedFieldRequiresUnsafe { span });\n+            }\n+            BorrowOfLayoutConstrainedField if unsafe_op_in_unsafe_fn_allowed => {\n+                tcx.sess.emit_err(\n+                    BorrowOfLayoutConstrainedFieldRequiresUnsafeUnsafeOpInUnsafeFnAllowed { span },\n+                );\n+            }\n+            BorrowOfLayoutConstrainedField => {\n+                tcx.sess.emit_err(BorrowOfLayoutConstrainedFieldRequiresUnsafe { span });\n+            }\n+            CallToFunctionWith(did) if unsafe_op_in_unsafe_fn_allowed => {\n+                tcx.sess.emit_err(CallToFunctionWithRequiresUnsafeUnsafeOpInUnsafeFnAllowed {\n+                    span,\n+                    function: &tcx.def_path_str(*did),\n+                });\n+            }\n+            CallToFunctionWith(did) => {\n+                tcx.sess.emit_err(CallToFunctionWithRequiresUnsafe {\n+                    span,\n+                    function: &tcx.def_path_str(*did),\n+                });\n+            }\n+        }\n+    }\n }\n \n pub fn check_unsafety<'tcx>(tcx: TyCtxt<'tcx>, def: ty::WithOptConstParam<LocalDefId>) {"}, {"sha": "68179001b916dbc3ac5128f91d7ed1cdcd7fe6e6", "filename": "compiler/rustc_mir_build/src/errors.rs", "status": "added", "additions": 616, "deletions": 0, "changes": 616, "blob_url": "https://github.com/rust-lang/rust/blob/35a99eef32a2b7b9d8e77dde539f869e522d181f/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a99eef32a2b7b9d8e77dde539f869e522d181f/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs?ref=35a99eef32a2b7b9d8e77dde539f869e522d181f", "patch": "@@ -0,0 +1,616 @@\n+use crate::thir::pattern::MatchCheckCtxt;\n+use rustc_errors::Handler;\n+use rustc_errors::{\n+    error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic, MultiSpan,\n+};\n+use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::{symbol::Ident, Span};\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unconditional_recursion)]\n+#[help]\n+pub struct UnconditionalRecursion {\n+    #[label]\n+    pub span: Span,\n+    #[label(mir_build_unconditional_recursion_call_site_label)]\n+    pub call_sites: Vec<Span>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unsafe_op_in_unsafe_fn_call_to_unsafe_fn_requires_unsafe)]\n+#[note]\n+pub struct UnsafeOpInUnsafeFnCallToUnsafeFunctionRequiresUnsafe<'a> {\n+    #[label]\n+    pub span: Span,\n+    pub function: &'a str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unsafe_op_in_unsafe_fn_call_to_unsafe_fn_requires_unsafe_nameless)]\n+#[note]\n+pub struct UnsafeOpInUnsafeFnCallToUnsafeFunctionRequiresUnsafeNameless {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unsafe_op_in_unsafe_fn_inline_assembly_requires_unsafe)]\n+#[note]\n+pub struct UnsafeOpInUnsafeFnUseOfInlineAssemblyRequiresUnsafe {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unsafe_op_in_unsafe_fn_initializing_type_with_requires_unsafe)]\n+#[note]\n+pub struct UnsafeOpInUnsafeFnInitializingTypeWithRequiresUnsafe {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unsafe_op_in_unsafe_fn_mutable_static_requires_unsafe)]\n+#[note]\n+pub struct UnsafeOpInUnsafeFnUseOfMutableStaticRequiresUnsafe {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unsafe_op_in_unsafe_fn_extern_static_requires_unsafe)]\n+#[note]\n+pub struct UnsafeOpInUnsafeFnUseOfExternStaticRequiresUnsafe {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unsafe_op_in_unsafe_fn_deref_raw_pointer_requires_unsafe)]\n+#[note]\n+pub struct UnsafeOpInUnsafeFnDerefOfRawPointerRequiresUnsafe {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unsafe_op_in_unsafe_fn_union_field_requires_unsafe)]\n+#[note]\n+pub struct UnsafeOpInUnsafeFnAccessToUnionFieldRequiresUnsafe {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unsafe_op_in_unsafe_fn_mutation_of_layout_constrained_field_requires_unsafe)]\n+#[note]\n+pub struct UnsafeOpInUnsafeFnMutationOfLayoutConstrainedFieldRequiresUnsafe {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unsafe_op_in_unsafe_fn_borrow_of_layout_constrained_field_requires_unsafe)]\n+pub struct UnsafeOpInUnsafeFnBorrowOfLayoutConstrainedFieldRequiresUnsafe {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unsafe_op_in_unsafe_fn_call_to_fn_with_requires_unsafe)]\n+#[note]\n+pub struct UnsafeOpInUnsafeFnCallToFunctionWithRequiresUnsafe<'a> {\n+    #[label]\n+    pub span: Span,\n+    pub function: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_call_to_unsafe_fn_requires_unsafe, code = \"E0133\")]\n+#[note]\n+pub struct CallToUnsafeFunctionRequiresUnsafe<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub function: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_call_to_unsafe_fn_requires_unsafe_nameless, code = \"E0133\")]\n+#[note]\n+pub struct CallToUnsafeFunctionRequiresUnsafeNameless {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_call_to_unsafe_fn_requires_unsafe_unsafe_op_in_unsafe_fn_allowed, code = \"E0133\")]\n+#[note]\n+pub struct CallToUnsafeFunctionRequiresUnsafeUnsafeOpInUnsafeFnAllowed<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub function: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(\n+    mir_build_call_to_unsafe_fn_requires_unsafe_nameless_unsafe_op_in_unsafe_fn_allowed,\n+    code = \"E0133\"\n+)]\n+#[note]\n+pub struct CallToUnsafeFunctionRequiresUnsafeNamelessUnsafeOpInUnsafeFnAllowed {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_inline_assembly_requires_unsafe, code = \"E0133\")]\n+#[note]\n+pub struct UseOfInlineAssemblyRequiresUnsafe {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_inline_assembly_requires_unsafe_unsafe_op_in_unsafe_fn_allowed, code = \"E0133\")]\n+#[note]\n+pub struct UseOfInlineAssemblyRequiresUnsafeUnsafeOpInUnsafeFnAllowed {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_initializing_type_with_requires_unsafe, code = \"E0133\")]\n+#[note]\n+pub struct InitializingTypeWithRequiresUnsafe {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(\n+    mir_build_initializing_type_with_requires_unsafe_unsafe_op_in_unsafe_fn_allowed,\n+    code = \"E0133\"\n+)]\n+#[note]\n+pub struct InitializingTypeWithRequiresUnsafeUnsafeOpInUnsafeFnAllowed {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_mutable_static_requires_unsafe, code = \"E0133\")]\n+#[note]\n+pub struct UseOfMutableStaticRequiresUnsafe {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_mutable_static_requires_unsafe_unsafe_op_in_unsafe_fn_allowed, code = \"E0133\")]\n+#[note]\n+pub struct UseOfMutableStaticRequiresUnsafeUnsafeOpInUnsafeFnAllowed {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_extern_static_requires_unsafe, code = \"E0133\")]\n+#[note]\n+pub struct UseOfExternStaticRequiresUnsafe {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_extern_static_requires_unsafe_unsafe_op_in_unsafe_fn_allowed, code = \"E0133\")]\n+#[note]\n+pub struct UseOfExternStaticRequiresUnsafeUnsafeOpInUnsafeFnAllowed {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_deref_raw_pointer_requires_unsafe, code = \"E0133\")]\n+#[note]\n+pub struct DerefOfRawPointerRequiresUnsafe {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_deref_raw_pointer_requires_unsafe_unsafe_op_in_unsafe_fn_allowed, code = \"E0133\")]\n+#[note]\n+pub struct DerefOfRawPointerRequiresUnsafeUnsafeOpInUnsafeFnAllowed {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_union_field_requires_unsafe, code = \"E0133\")]\n+#[note]\n+pub struct AccessToUnionFieldRequiresUnsafe {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_union_field_requires_unsafe_unsafe_op_in_unsafe_fn_allowed, code = \"E0133\")]\n+#[note]\n+pub struct AccessToUnionFieldRequiresUnsafeUnsafeOpInUnsafeFnAllowed {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_mutation_of_layout_constrained_field_requires_unsafe, code = \"E0133\")]\n+#[note]\n+pub struct MutationOfLayoutConstrainedFieldRequiresUnsafe {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(\n+    mir_build_mutation_of_layout_constrained_field_requires_unsafe_unsafe_op_in_unsafe_fn_allowed,\n+    code = \"E0133\"\n+)]\n+#[note]\n+pub struct MutationOfLayoutConstrainedFieldRequiresUnsafeUnsafeOpInUnsafeFnAllowed {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_borrow_of_layout_constrained_field_requires_unsafe, code = \"E0133\")]\n+#[note]\n+pub struct BorrowOfLayoutConstrainedFieldRequiresUnsafe {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(\n+    mir_build_borrow_of_layout_constrained_field_requires_unsafe_unsafe_op_in_unsafe_fn_allowed,\n+    code = \"E0133\"\n+)]\n+#[note]\n+pub struct BorrowOfLayoutConstrainedFieldRequiresUnsafeUnsafeOpInUnsafeFnAllowed {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_call_to_fn_with_requires_unsafe, code = \"E0133\")]\n+#[note]\n+pub struct CallToFunctionWithRequiresUnsafe<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub function: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_call_to_fn_with_requires_unsafe_unsafe_op_in_unsafe_fn_allowed, code = \"E0133\")]\n+#[note]\n+pub struct CallToFunctionWithRequiresUnsafeUnsafeOpInUnsafeFnAllowed<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub function: &'a str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unused_unsafe)]\n+pub struct UnusedUnsafe {\n+    #[label]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub enclosing: Option<UnusedUnsafeEnclosing>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum UnusedUnsafeEnclosing {\n+    #[label(mir_build_unused_unsafe_enclosing_block_label)]\n+    Block {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[label(mir_build_unused_unsafe_enclosing_fn_label)]\n+    Function {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+pub(crate) struct NonExhaustivePatternsTypeNotEmpty<'p, 'tcx, 'm> {\n+    pub cx: &'m MatchCheckCtxt<'p, 'tcx>,\n+    pub expr_span: Span,\n+    pub span: Span,\n+    pub ty: Ty<'tcx>,\n+}\n+\n+impl<'a> IntoDiagnostic<'a> for NonExhaustivePatternsTypeNotEmpty<'_, '_, '_> {\n+    fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag = handler.struct_span_err_with_code(\n+            self.span,\n+            rustc_errors::fluent::mir_build_non_exhaustive_patterns_type_not_empty,\n+            error_code!(E0004),\n+        );\n+\n+        let peeled_ty = self.ty.peel_refs();\n+        diag.set_arg(\"ty\", self.ty);\n+        diag.set_arg(\"peeled_ty\", peeled_ty);\n+\n+        if let ty::Adt(def, _) = peeled_ty.kind() {\n+            let def_span = self\n+                .cx\n+                .tcx\n+                .hir()\n+                .get_if_local(def.did())\n+                .and_then(|node| node.ident())\n+                .map(|ident| ident.span)\n+                .unwrap_or_else(|| self.cx.tcx.def_span(def.did()));\n+\n+            // workaround to make test pass\n+            let mut span: MultiSpan = def_span.into();\n+            span.push_span_label(def_span, \"\");\n+\n+            diag.span_note(span, rustc_errors::fluent::def_note);\n+        }\n+\n+        let is_variant_list_non_exhaustive = match self.ty.kind() {\n+            ty::Adt(def, _) if def.is_variant_list_non_exhaustive() && !def.did().is_local() => {\n+                true\n+            }\n+            _ => false,\n+        };\n+\n+        if is_variant_list_non_exhaustive {\n+            diag.note(rustc_errors::fluent::non_exhaustive_type_note);\n+        } else {\n+            diag.note(rustc_errors::fluent::type_note);\n+        }\n+\n+        if let ty::Ref(_, sub_ty, _) = self.ty.kind() {\n+            if !sub_ty.is_inhabited_from(self.cx.tcx, self.cx.module, self.cx.param_env) {\n+                diag.note(rustc_errors::fluent::reference_note);\n+            }\n+        }\n+\n+        let mut suggestion = None;\n+        let sm = self.cx.tcx.sess.source_map();\n+        if self.span.eq_ctxt(self.expr_span) {\n+            // Get the span for the empty match body `{}`.\n+            let (indentation, more) = if let Some(snippet) = sm.indentation_before(self.span) {\n+                (format!(\"\\n{}\", snippet), \"    \")\n+            } else {\n+                (\" \".to_string(), \"\")\n+            };\n+            suggestion = Some((\n+                self.span.shrink_to_hi().with_hi(self.expr_span.hi()),\n+                format!(\n+                    \" {{{indentation}{more}_ => todo!(),{indentation}}}\",\n+                    indentation = indentation,\n+                    more = more,\n+                ),\n+            ));\n+        }\n+\n+        if let Some((span, sugg)) = suggestion {\n+            diag.span_suggestion_verbose(\n+                span,\n+                rustc_errors::fluent::suggestion,\n+                sugg,\n+                Applicability::HasPlaceholders,\n+            );\n+        } else {\n+            diag.help(rustc_errors::fluent::help);\n+        }\n+\n+        diag\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_static_in_pattern, code = \"E0158\")]\n+pub struct StaticInPattern {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_assoc_const_in_pattern, code = \"E0158\")]\n+pub struct AssocConstInPattern {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_const_param_in_pattern, code = \"E0158\")]\n+pub struct ConstParamInPattern {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_non_const_path, code = \"E0080\")]\n+pub struct NonConstPath {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unreachable_pattern)]\n+pub struct UnreachablePattern {\n+    #[label]\n+    pub span: Option<Span>,\n+    #[label(catchall_label)]\n+    pub catchall: Option<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_const_pattern_depends_on_generic_parameter)]\n+pub struct ConstPatternDependsOnGenericParameter {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_could_not_eval_const_pattern)]\n+pub struct CouldNotEvalConstPattern {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_lower_range_bound_must_be_less_than_or_equal_to_upper, code = \"E0030\")]\n+pub struct LowerRangeBoundMustBeLessThanOrEqualToUpper {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[note(teach_note)]\n+    pub teach: Option<()>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_lower_range_bound_must_be_less_than_upper, code = \"E0579\")]\n+pub struct LowerRangeBoundMustBeLessThanUpper {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_leading_irrefutable_let_patterns)]\n+#[note]\n+#[help]\n+pub struct LeadingIrrefutableLetPatterns {\n+    pub count: usize,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_trailing_irrefutable_let_patterns)]\n+#[note]\n+#[help]\n+pub struct TrailingIrrefutableLetPatterns {\n+    pub count: usize,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_bindings_with_variant_name, code = \"E0170\")]\n+pub struct BindingsWithVariantName {\n+    #[suggestion(code = \"{ty_path}::{ident}\", applicability = \"machine-applicable\")]\n+    pub suggestion: Option<Span>,\n+    pub ty_path: String,\n+    pub ident: Ident,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_irrefutable_let_patterns_generic_let)]\n+#[note]\n+#[help]\n+pub struct IrrefutableLetPatternsGenericLet {\n+    pub count: usize,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_irrefutable_let_patterns_if_let)]\n+#[note]\n+#[help]\n+pub struct IrrefutableLetPatternsIfLet {\n+    pub count: usize,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_irrefutable_let_patterns_if_let_guard)]\n+#[note]\n+#[help]\n+pub struct IrrefutableLetPatternsIfLetGuard {\n+    pub count: usize,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_irrefutable_let_patterns_let_else)]\n+#[note]\n+#[help]\n+pub struct IrrefutableLetPatternsLetElse {\n+    pub count: usize,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_irrefutable_let_patterns_while_let)]\n+#[note]\n+#[help]\n+pub struct IrrefutableLetPatternsWhileLet {\n+    pub count: usize,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_borrow_of_moved_value)]\n+pub struct BorrowOfMovedValue<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    #[label(occurs_because_label)]\n+    pub binding_span: Span,\n+    #[label(value_borrowed_label)]\n+    pub conflicts_ref: Vec<Span>,\n+    pub name: Ident,\n+    pub ty: Ty<'tcx>,\n+    #[suggestion(code = \"ref \", applicability = \"machine-applicable\")]\n+    pub suggest_borrowing: Option<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_multiple_mut_borrows)]\n+pub struct MultipleMutBorrows {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub binding_span: Span,\n+    #[subdiagnostic]\n+    pub occurences: Vec<MultipleMutBorrowOccurence>,\n+    pub name: Ident,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum MultipleMutBorrowOccurence {\n+    #[label(mutable_borrow)]\n+    Mutable {\n+        #[primary_span]\n+        span: Span,\n+        name_mut: Ident,\n+    },\n+    #[label(immutable_borrow)]\n+    Immutable {\n+        #[primary_span]\n+        span: Span,\n+        name_immut: Ident,\n+    },\n+    #[label(moved)]\n+    Moved {\n+        #[primary_span]\n+        span: Span,\n+        name_moved: Ident,\n+    },\n+}"}, {"sha": "2b05e92fdcf20c0913e199bf11fdeeb591b73d8d", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35a99eef32a2b7b9d8e77dde539f869e522d181f/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a99eef32a2b7b9d8e77dde539f869e522d181f/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=35a99eef32a2b7b9d8e77dde539f869e522d181f", "patch": "@@ -19,6 +19,7 @@ extern crate rustc_middle;\n \n mod build;\n mod check_unsafety;\n+mod errors;\n mod lints;\n pub mod thir;\n "}, {"sha": "8529c64cd5cca64213f3b1efedb38df29c0094b5", "filename": "compiler/rustc_mir_build/src/lints.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/35a99eef32a2b7b9d8e77dde539f869e522d181f/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a99eef32a2b7b9d8e77dde539f869e522d181f/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs?ref=35a99eef32a2b7b9d8e77dde539f869e522d181f", "patch": "@@ -1,3 +1,4 @@\n+use crate::errors::UnconditionalRecursion;\n use rustc_data_structures::graph::iterate::{\n     NodeStatus, TriColorDepthFirstSearch, TriColorVisitor,\n };\n@@ -36,19 +37,11 @@ pub(crate) fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) {\n \n         let sp = tcx.def_span(def_id);\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-        tcx.struct_span_lint_hir(\n+        tcx.emit_spanned_lint(\n             UNCONDITIONAL_RECURSION,\n             hir_id,\n             sp,\n-            \"function cannot return without recursing\",\n-            |lint| {\n-                lint.span_label(sp, \"cannot return without recursing\");\n-                // offer some help to the programmer.\n-                for call_span in vis.reachable_recursive_calls {\n-                    lint.span_label(call_span, \"recursive call site\");\n-                }\n-                lint.help(\"a `loop` may express intention better if this is on purpose\")\n-            },\n+            UnconditionalRecursion { span: sp, call_sites: vis.reachable_recursive_calls },\n         );\n     }\n }"}, {"sha": "a94d8d6c6431c81c0d95e2f525d9cff0d8c12d08", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 72, "deletions": 158, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/35a99eef32a2b7b9d8e77dde539f869e522d181f/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a99eef32a2b7b9d8e77dde539f869e522d181f/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=35a99eef32a2b7b9d8e77dde539f869e522d181f", "patch": "@@ -4,18 +4,22 @@ use super::usefulness::{\n };\n use super::{PatCtxt, PatternError};\n \n+use crate::errors::*;\n+\n use rustc_arena::TypedArena;\n use rustc_ast::Mutability;\n use rustc_errors::{\n-    error_code, pluralize, struct_span_err, Applicability, DelayDm, Diagnostic, DiagnosticBuilder,\n-    ErrorGuaranteed, MultiSpan,\n+    pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n+    MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_hir::def::*;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{HirId, Pat};\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n+\n use rustc_session::lint::builtin::{\n     BINDINGS_WITH_VARIANT_NAME, IRREFUTABLE_LET_PATTERNS, UNREACHABLE_PATTERNS,\n };\n@@ -107,28 +111,20 @@ impl PatCtxt<'_, '_> {\n         for error in &self.errors {\n             match *error {\n                 PatternError::StaticInPattern(span) => {\n-                    self.span_e0158(span, \"statics cannot be referenced in patterns\")\n+                    self.tcx.sess.emit_err(StaticInPattern { span });\n                 }\n                 PatternError::AssocConstInPattern(span) => {\n-                    self.span_e0158(span, \"associated consts cannot be referenced in patterns\")\n+                    self.tcx.sess.emit_err(AssocConstInPattern { span });\n                 }\n                 PatternError::ConstParamInPattern(span) => {\n-                    self.span_e0158(span, \"const parameters cannot be referenced in patterns\")\n+                    self.tcx.sess.emit_err(ConstParamInPattern { span });\n                 }\n                 PatternError::NonConstPath(span) => {\n-                    rustc_middle::mir::interpret::struct_error(\n-                        self.tcx.at(span),\n-                        \"runtime values cannot be referenced in patterns\",\n-                    )\n-                    .emit();\n+                    self.tcx.sess.emit_err(NonConstPath { span });\n                 }\n             }\n         }\n     }\n-\n-    fn span_e0158(&self, span: Span, text: &str) {\n-        struct_span_err!(self.tcx.sess, span, E0158, \"{}\", text).emit();\n-    }\n }\n \n impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n@@ -345,29 +341,6 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             );\n             return true;\n         }\n-        let lint_affix = |affix: &[Option<(Span, bool)>], kind, suggestion| {\n-            let span_start = affix[0].unwrap().0;\n-            let span_end = affix.last().unwrap().unwrap().0;\n-            let span = span_start.to(span_end);\n-            let cnt = affix.len();\n-            let s = pluralize!(cnt);\n-            cx.tcx.struct_span_lint_hir(\n-                IRREFUTABLE_LET_PATTERNS,\n-                top,\n-                span,\n-                format!(\"{kind} irrefutable pattern{s} in let chain\"),\n-                |lint| {\n-                    lint.note(format!(\n-                        \"{these} pattern{s} will always match\",\n-                        these = pluralize!(\"this\", cnt),\n-                    ))\n-                    .help(format!(\n-                        \"consider moving {} {suggestion}\",\n-                        if cnt > 1 { \"them\" } else { \"it\" }\n-                    ))\n-                },\n-            );\n-        };\n         if let Some(until) = chain_refutabilities.iter().position(|r| !matches!(*r, Some((_, false)))) && until > 0 {\n             // The chain has a non-zero prefix of irrefutable `let` statements.\n \n@@ -381,13 +354,21 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             if !matches!(let_source, LetSource::WhileLet | LetSource::IfLetGuard) {\n                 // Emit the lint\n                 let prefix = &chain_refutabilities[..until];\n-                lint_affix(prefix, \"leading\", \"outside of the construct\");\n+                let span_start = prefix[0].unwrap().0;\n+                let span_end = prefix.last().unwrap().unwrap().0;\n+                let span = span_start.to(span_end);\n+                let count = prefix.len();\n+                cx.tcx.emit_spanned_lint(IRREFUTABLE_LET_PATTERNS, top, span, LeadingIrrefutableLetPatterns { count });\n             }\n         }\n         if let Some(from) = chain_refutabilities.iter().rposition(|r| !matches!(*r, Some((_, false)))) && from != (chain_refutabilities.len() - 1) {\n             // The chain has a non-empty suffix of irrefutable `let` statements\n             let suffix = &chain_refutabilities[from + 1..];\n-            lint_affix(suffix, \"trailing\", \"into the body\");\n+            let span_start = suffix[0].unwrap().0;\n+            let span_end = suffix.last().unwrap().unwrap().0;\n+            let span = span_start.to(span_end);\n+            let count = suffix.len();\n+            cx.tcx.emit_spanned_lint(IRREFUTABLE_LET_PATTERNS, top, span, TrailingIrrefutableLetPatterns { count });\n         }\n         true\n     }\n@@ -568,32 +549,22 @@ fn check_for_bindings_named_same_as_variants(\n             })\n         {\n             let variant_count = edef.variants().len();\n-            cx.tcx.struct_span_lint_hir(\n+            let ty_path = with_no_trimmed_paths!({\n+                cx.tcx.def_path_str(edef.did())\n+            });\n+            cx.tcx.emit_spanned_lint(\n                 BINDINGS_WITH_VARIANT_NAME,\n                 p.hir_id,\n                 p.span,\n-                DelayDm(|| format!(\n-                    \"pattern binding `{}` is named the same as one \\\n-                        of the variants of the type `{}`\",\n-                    ident, cx.tcx.def_path_str(edef.did())\n-                )),\n-                |lint| {\n-                    let ty_path = cx.tcx.def_path_str(edef.did());\n-                    lint.code(error_code!(E0170));\n-\n+                BindingsWithVariantName {\n                     // If this is an irrefutable pattern, and there's > 1 variant,\n                     // then we can't actually match on this. Applying the below\n                     // suggestion would produce code that breaks on `check_irrefutable`.\n-                    if rf == Refutable || variant_count == 1 {\n-                        lint.span_suggestion(\n-                            p.span,\n-                            \"to match on the variant, qualify the path\",\n-                            format!(\"{}::{}\", ty_path, ident),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-\n-                    lint\n+                    suggestion: if rf == Refutable || variant_count == 1 {\n+                        Some(p.span)\n+                    } else { None },\n+                    ty_path,\n+                    ident,\n                 },\n             )\n         }\n@@ -611,14 +582,12 @@ fn pat_is_catchall(pat: &DeconstructedPat<'_, '_>) -> bool {\n }\n \n fn unreachable_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, catchall: Option<Span>) {\n-    tcx.struct_span_lint_hir(UNREACHABLE_PATTERNS, id, span, \"unreachable pattern\", |lint| {\n-        if let Some(catchall) = catchall {\n-            // We had a catchall pattern, hint at that.\n-            lint.span_label(span, \"unreachable pattern\");\n-            lint.span_label(catchall, \"matches any value\");\n-        }\n-        lint\n-    });\n+    tcx.emit_spanned_lint(\n+        UNREACHABLE_PATTERNS,\n+        id,\n+        span,\n+        UnreachablePattern { span: if catchall.is_some() { Some(span) } else { None }, catchall },\n+    );\n }\n \n fn irrefutable_let_pattern(tcx: TyCtxt<'_>, id: HirId, span: Span) {\n@@ -634,67 +603,18 @@ fn irrefutable_let_patterns(\n     span: Span,\n ) {\n     macro_rules! emit_diag {\n-        (\n-            $lint:expr,\n-            $source_name:expr,\n-            $note_sufix:expr,\n-            $help_sufix:expr\n-        ) => {{\n-            let s = pluralize!(count);\n-            let these = pluralize!(\"this\", count);\n-            tcx.struct_span_lint_hir(\n-                IRREFUTABLE_LET_PATTERNS,\n-                id,\n-                span,\n-                format!(\"irrefutable {} pattern{s}\", $source_name),\n-                |lint| {\n-                    lint.note(&format!(\n-                        \"{these} pattern{s} will always match, so the {}\",\n-                        $note_sufix\n-                    ))\n-                    .help(concat!(\"consider \", $help_sufix))\n-                },\n-            )\n+        ($lint:tt) => {{\n+            tcx.emit_spanned_lint(IRREFUTABLE_LET_PATTERNS, id, span, $lint { count });\n         }};\n     }\n \n     match source {\n-        LetSource::GenericLet => {\n-            emit_diag!(lint, \"`let`\", \"`let` is useless\", \"removing `let`\");\n-        }\n-        LetSource::IfLet => {\n-            emit_diag!(\n-                lint,\n-                \"`if let`\",\n-                \"`if let` is useless\",\n-                \"replacing the `if let` with a `let`\"\n-            );\n-        }\n-        LetSource::IfLetGuard => {\n-            emit_diag!(\n-                lint,\n-                \"`if let` guard\",\n-                \"guard is useless\",\n-                \"removing the guard and adding a `let` inside the match arm\"\n-            );\n-        }\n-        LetSource::LetElse => {\n-            emit_diag!(\n-                lint,\n-                \"`let...else`\",\n-                \"`else` clause is useless\",\n-                \"removing the `else` clause\"\n-            );\n-        }\n-        LetSource::WhileLet => {\n-            emit_diag!(\n-                lint,\n-                \"`while let`\",\n-                \"loop will never exit\",\n-                \"instead using a `loop { ... }` with a `let` inside it\"\n-            );\n-        }\n-    };\n+        LetSource::GenericLet => emit_diag!(IrrefutableLetPatternsGenericLet),\n+        LetSource::IfLet => emit_diag!(IrrefutableLetPatternsIfLet),\n+        LetSource::IfLetGuard => emit_diag!(IrrefutableLetPatternsIfLetGuard),\n+        LetSource::LetElse => emit_diag!(IrrefutableLetPatternsLetElse),\n+        LetSource::WhileLet => emit_diag!(IrrefutableLetPatternsWhileLet),\n+    }\n }\n \n fn is_let_irrefutable<'p, 'tcx>(\n@@ -760,15 +680,17 @@ fn non_exhaustive_match<'p, 'tcx>(\n     // informative.\n     let mut err;\n     let pattern;\n-    let mut patterns_len = 0;\n+    let patterns_len;\n     if is_empty_match && !non_empty_enum {\n-        err = create_e0004(\n-            cx.tcx.sess,\n-            sp,\n-            format!(\"non-exhaustive patterns: type `{}` is non-empty\", scrut_ty),\n-        );\n-        pattern = \"_\".to_string();\n+        cx.tcx.sess.emit_err(NonExhaustivePatternsTypeNotEmpty {\n+            cx,\n+            expr_span,\n+            span: sp,\n+            ty: scrut_ty,\n+        });\n+        return;\n     } else {\n+        // FIXME: migration of this diagnostic will require list support\n         let joined_patterns = joined_uncovered_patterns(cx, &witnesses);\n         err = create_e0004(\n             cx.tcx.sess,\n@@ -1039,24 +961,17 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_, '_>, pat: &Pa\n                 }\n             });\n             if !conflicts_ref.is_empty() {\n-                let occurs_because = format!(\n-                    \"move occurs because `{}` has type `{}` which does not implement the `Copy` trait\",\n+                sess.emit_err(BorrowOfMovedValue {\n+                    span: pat.span,\n+                    binding_span,\n+                    conflicts_ref,\n                     name,\n-                    typeck_results.node_type(pat.hir_id),\n-                );\n-                let mut err = sess.struct_span_err(pat.span, \"borrow of moved value\");\n-                err.span_label(binding_span, format!(\"value moved into `{}` here\", name))\n-                    .span_label(binding_span, occurs_because)\n-                    .span_labels(conflicts_ref, \"value borrowed here after move\");\n-                if pat.span.contains(binding_span) {\n-                    err.span_suggestion_verbose(\n-                        binding_span.shrink_to_lo(),\n-                        \"borrow this binding in the pattern to avoid moving the value\",\n-                        \"ref \".to_string(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-                err.emit();\n+                    ty: typeck_results.node_type(pat.hir_id),\n+                    suggest_borrowing: pat\n+                        .span\n+                        .contains(binding_span)\n+                        .then(|| binding_span.shrink_to_lo()),\n+                });\n             }\n             return;\n         }\n@@ -1086,19 +1001,18 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_, '_>, pat: &Pa\n     // Report errors if any.\n     if !conflicts_mut_mut.is_empty() {\n         // Report mutability conflicts for e.g. `ref mut x @ Some(ref mut y)`.\n-        let mut err = sess\n-            .struct_span_err(pat.span, \"cannot borrow value as mutable more than once at a time\");\n-        err.span_label(binding_span, format!(\"first mutable borrow, by `{}`, occurs here\", name));\n-        for (span, name) in conflicts_mut_mut {\n-            err.span_label(span, format!(\"another mutable borrow, by `{}`, occurs here\", name));\n+        let mut occurences = vec![];\n+\n+        for (span, name_mut) in conflicts_mut_mut {\n+            occurences.push(MultipleMutBorrowOccurence::Mutable { span, name_mut });\n         }\n-        for (span, name) in conflicts_mut_ref {\n-            err.span_label(span, format!(\"also borrowed as immutable, by `{}`, here\", name));\n+        for (span, name_immut) in conflicts_mut_ref {\n+            occurences.push(MultipleMutBorrowOccurence::Immutable { span, name_immut });\n         }\n-        for (span, name) in conflicts_move {\n-            err.span_label(span, format!(\"also moved into `{}` here\", name));\n+        for (span, name_moved) in conflicts_move {\n+            occurences.push(MultipleMutBorrowOccurence::Moved { span, name_moved });\n         }\n-        err.emit();\n+        sess.emit_err(MultipleMutBorrows { span: pat.span, binding_span, occurences, name });\n     } else if !conflicts_mut_ref.is_empty() {\n         // Report mutability conflicts for e.g. `ref x @ Some(ref mut y)` or the converse.\n         let (primary, also) = match mut_outer {"}, {"sha": "2c775b397182b352eea62549c4b7179129e20178", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 11, "deletions": 28, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/35a99eef32a2b7b9d8e77dde539f869e522d181f/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a99eef32a2b7b9d8e77dde539f869e522d181f/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=35a99eef32a2b7b9d8e77dde539f869e522d181f", "patch": "@@ -6,10 +6,12 @@ mod deconstruct_pat;\n mod usefulness;\n \n pub(crate) use self::check_match::check_match;\n+pub(crate) use self::usefulness::MatchCheckCtxt;\n \n+use crate::errors::*;\n use crate::thir::util::UserAnnotatedTyHelpers;\n \n-use rustc_errors::struct_span_err;\n+use rustc_errors::error_code;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::pat_util::EnumerateAndAdjustIterator;\n@@ -139,13 +141,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n             // `x..y` where `x >= y`. The range is empty => error.\n             (RangeEnd::Excluded, _) => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0579,\n-                    \"lower range bound must be less than upper\"\n-                )\n-                .emit();\n+                self.tcx.sess.emit_err(LowerRangeBoundMustBeLessThanUpper { span });\n                 PatKind::Wild\n             }\n             // `x..=y` where `x == y`.\n@@ -156,23 +152,10 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n             // `x..=y` where `x > y` hence the range is empty => error.\n             (RangeEnd::Included, _) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n+                self.tcx.sess.emit_err(LowerRangeBoundMustBeLessThanOrEqualToUpper {\n                     span,\n-                    E0030,\n-                    \"lower range bound must be less than or equal to upper\"\n-                );\n-                err.span_label(span, \"lower bound larger than upper bound\");\n-                if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                    err.note(\n-                        \"When matching against a range, the compiler \\\n-                              verifies that the range is non-empty. Range \\\n-                              patterns include both end-points, so this is \\\n-                              equivalent to requiring the start of the range \\\n-                              to be less than or equal to the end of the range.\",\n-                    );\n-                }\n-                err.emit();\n+                    teach: if self.tcx.sess.teach(&error_code!(E0030)) { Some(()) } else { None },\n+                });\n                 PatKind::Wild\n             }\n         }\n@@ -501,7 +484,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n \n             Err(_) => {\n-                self.tcx.sess.span_err(span, \"could not evaluate constant pattern\");\n+                self.tcx.sess.emit_err(CouldNotEvalConstPattern { span });\n                 return pat_from_kind(PatKind::Wild);\n             }\n         };\n@@ -548,11 +531,11 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             Err(ErrorHandled::TooGeneric) => {\n                 // While `Reported | Linted` cases will have diagnostics emitted already\n                 // it is not true for TooGeneric case, so we need to give user more information.\n-                self.tcx.sess.span_err(span, \"constant pattern depends on a generic parameter\");\n+                self.tcx.sess.emit_err(ConstPatternDependsOnGenericParameter { span });\n                 pat_from_kind(PatKind::Wild)\n             }\n             Err(_) => {\n-                self.tcx.sess.span_err(span, \"could not evaluate constant pattern\");\n+                self.tcx.sess.emit_err(CouldNotEvalConstPattern { span });\n                 pat_from_kind(PatKind::Wild)\n             }\n         }\n@@ -584,7 +567,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             mir::ConstantKind::Val(_, _) => self.const_to_pat(value, id, span, false).kind,\n             mir::ConstantKind::Unevaluated(..) => {\n                 // If we land here it means the const can't be evaluated because it's `TooGeneric`.\n-                self.tcx.sess.span_err(span, \"constant pattern depends on a generic parameter\");\n+                self.tcx.sess.emit_err(ConstPatternDependsOnGenericParameter { span });\n                 return PatKind::Wild;\n             }\n         }"}, {"sha": "d4e88aa26436162160ff0ccc02e3b169e9b4de17", "filename": "src/test/ui/lint/lint-uppercase-variables.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35a99eef32a2b7b9d8e77dde539f869e522d181f/src%2Ftest%2Fui%2Flint%2Flint-uppercase-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a99eef32a2b7b9d8e77dde539f869e522d181f/src%2Ftest%2Fui%2Flint%2Flint-uppercase-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-uppercase-variables.rs?ref=35a99eef32a2b7b9d8e77dde539f869e522d181f", "patch": "@@ -20,19 +20,19 @@ fn main() {\n \n     match foo::Foo::Foo {\n         Foo => {}\n-//~^ ERROR variable `Foo` should have a snake case name\n-//~^^ WARN `Foo` is named the same as one of the variants of the type `Foo`\n-//~^^^ WARN unused variable: `Foo`\n+    //~^ ERROR variable `Foo` should have a snake case name\n+    //~^^ WARN `Foo` is named the same as one of the variants of the type `foo::Foo`\n+    //~^^^ WARN unused variable: `Foo`\n     }\n \n     let Foo = foo::Foo::Foo;\n     //~^ ERROR variable `Foo` should have a snake case name\n-    //~^^ WARN `Foo` is named the same as one of the variants of the type `Foo`\n+    //~^^ WARN `Foo` is named the same as one of the variants of the type `foo::Foo`\n     //~^^^ WARN unused variable: `Foo`\n \n     fn in_param(Foo: foo::Foo) {}\n     //~^ ERROR variable `Foo` should have a snake case name\n-    //~^^ WARN `Foo` is named the same as one of the variants of the type `Foo`\n+    //~^^ WARN `Foo` is named the same as one of the variants of the type `foo::Foo`\n     //~^^^ WARN unused variable: `Foo`\n \n     test(1);"}, {"sha": "d476d856e24c59b060ccdd85be6ff1c681e4180a", "filename": "src/test/ui/lint/lint-uppercase-variables.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35a99eef32a2b7b9d8e77dde539f869e522d181f/src%2Ftest%2Fui%2Flint%2Flint-uppercase-variables.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/35a99eef32a2b7b9d8e77dde539f869e522d181f/src%2Ftest%2Fui%2Flint%2Flint-uppercase-variables.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-uppercase-variables.stderr?ref=35a99eef32a2b7b9d8e77dde539f869e522d181f", "patch": "@@ -1,22 +1,22 @@\n-warning[E0170]: pattern binding `Foo` is named the same as one of the variants of the type `Foo`\n+warning[E0170]: pattern binding `Foo` is named the same as one of the variants of the type `foo::Foo`\n   --> $DIR/lint-uppercase-variables.rs:22:9\n    |\n LL |         Foo => {}\n-   |         ^^^ help: to match on the variant, qualify the path: `Foo::Foo`\n+   |         ^^^ help: to match on the variant, qualify the path: `foo::Foo::Foo`\n    |\n    = note: `#[warn(bindings_with_variant_name)]` on by default\n \n-warning[E0170]: pattern binding `Foo` is named the same as one of the variants of the type `Foo`\n+warning[E0170]: pattern binding `Foo` is named the same as one of the variants of the type `foo::Foo`\n   --> $DIR/lint-uppercase-variables.rs:28:9\n    |\n LL |     let Foo = foo::Foo::Foo;\n-   |         ^^^ help: to match on the variant, qualify the path: `Foo::Foo`\n+   |         ^^^ help: to match on the variant, qualify the path: `foo::Foo::Foo`\n \n-warning[E0170]: pattern binding `Foo` is named the same as one of the variants of the type `Foo`\n+warning[E0170]: pattern binding `Foo` is named the same as one of the variants of the type `foo::Foo`\n   --> $DIR/lint-uppercase-variables.rs:33:17\n    |\n LL |     fn in_param(Foo: foo::Foo) {}\n-   |                 ^^^ help: to match on the variant, qualify the path: `Foo::Foo`\n+   |                 ^^^ help: to match on the variant, qualify the path: `foo::Foo::Foo`\n \n warning: unused variable: `Foo`\n   --> $DIR/lint-uppercase-variables.rs:22:9"}]}