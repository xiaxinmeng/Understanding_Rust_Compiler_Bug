{"sha": "ed81098fcca409261db3408115725d07729ac39a", "node_id": "C_kwDOAAsO6NoAKGVkODEwOThmY2NhNDA5MjYxZGIzNDA4MTE1NzI1ZDA3NzI5YWMzOWE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-12-11T16:35:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-11T16:35:27Z"}, "message": "Rollup merge of #91721 - danielhenrymantilla:patch-1, r=joshtriplett\n\nMinor improvements to `future::join!`'s implementation\n\nThis is a follow-up from #91645, regarding [some remarks I made](https://rust-lang.zulipchat.com/#narrow/stream/187312-wg-async-foundations/topic/join!/near/264293660).\n\nMainly:\n  - it hides the recursive munching through a private `macro`, to avoid leaking such details (a corollary is getting rid of the need to use ``@`` to disambiguate);\n  - it uses a `match` binding, _outside_ the `async move` block, to better match the semantics from function-like syntax;\n  - it pre-pins the future before calling into `poll_fn`, since `poll_fn`, alone, cannot guarantee that its capture does not move (to clarify: I believe the previous code was sound, thanks to the outer layer of `async`. But I find it clearer / more robust to refactorings this way \ud83d\ude42).\n  - it uses `@ibraheemdev's` very neat `.ready()?`;\n  - it renames `Took` to `Taken` for consistency with `Done` (tiny nit \ud83d\ude04).\n\n~~TODO~~Done:\n\n  - [x] Add unit tests to enforce the function-like `:value` semantics are respected.\n\nr? `@nrc`", "tree": {"sha": "f24f94686d343aea73170bbead142b770da14f74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f24f94686d343aea73170bbead142b770da14f74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed81098fcca409261db3408115725d07729ac39a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhtNNQCRBK7hj4Ov3rIwAAvAQIAAc8acrD6cJaVlK1W8RX/7gt\nhG3oBZX4LTwtXKeLQlaADUX2TCHX2r5yF38shY7S1Xc5z7h00R5IeDqJ9mUoN4da\nJX23gyk4C0qaQfzOLi5PO5DMXCXsc0Ebt82LzbF7P9q/UEaq+44FwcTFW70ZXhk6\nHRDo0zokKza54B5wcroKQsARhM3wQf1mEZIMYJtl96wJJBC5pPQmAXiV3GAsyWXC\nSO4GlT7YHR2/1AxEDNwqOxxS9nGuX3vOqOJtooYv6f/jTU+cQTHtw64N5rRjv9kG\nM1eAYu5PDsgCOgluTn99gd5ldl5sgWtkd4fK6EHBqtja0xVWG2Ian2LLGLSanZ4=\n=nA8M\n-----END PGP SIGNATURE-----\n", "payload": "tree f24f94686d343aea73170bbead142b770da14f74\nparent 60b9f3130d1e41cf6c53ea8159ac44457ea8fe04\nparent 67ab53daee2fd42a8ae643225acfc7c7c074e0f7\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1639240527 +0100\ncommitter GitHub <noreply@github.com> 1639240527 +0100\n\nRollup merge of #91721 - danielhenrymantilla:patch-1, r=joshtriplett\n\nMinor improvements to `future::join!`'s implementation\n\nThis is a follow-up from #91645, regarding [some remarks I made](https://rust-lang.zulipchat.com/#narrow/stream/187312-wg-async-foundations/topic/join!/near/264293660).\n\nMainly:\n  - it hides the recursive munching through a private `macro`, to avoid leaking such details (a corollary is getting rid of the need to use ``@`` to disambiguate);\n  - it uses a `match` binding, _outside_ the `async move` block, to better match the semantics from function-like syntax;\n  - it pre-pins the future before calling into `poll_fn`, since `poll_fn`, alone, cannot guarantee that its capture does not move (to clarify: I believe the previous code was sound, thanks to the outer layer of `async`. But I find it clearer / more robust to refactorings this way \ud83d\ude42).\n  - it uses `@ibraheemdev's` very neat `.ready()?`;\n  - it renames `Took` to `Taken` for consistency with `Done` (tiny nit \ud83d\ude04).\n\n~~TODO~~Done:\n\n  - [x] Add unit tests to enforce the function-like `:value` semantics are respected.\n\nr? `@nrc`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed81098fcca409261db3408115725d07729ac39a", "html_url": "https://github.com/rust-lang/rust/commit/ed81098fcca409261db3408115725d07729ac39a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed81098fcca409261db3408115725d07729ac39a/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60b9f3130d1e41cf6c53ea8159ac44457ea8fe04", "url": "https://api.github.com/repos/rust-lang/rust/commits/60b9f3130d1e41cf6c53ea8159ac44457ea8fe04", "html_url": "https://github.com/rust-lang/rust/commit/60b9f3130d1e41cf6c53ea8159ac44457ea8fe04"}, {"sha": "67ab53daee2fd42a8ae643225acfc7c7c074e0f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/67ab53daee2fd42a8ae643225acfc7c7c074e0f7", "html_url": "https://github.com/rust-lang/rust/commit/67ab53daee2fd42a8ae643225acfc7c7c074e0f7"}], "stats": {"total": 189, "additions": 135, "deletions": 54}, "files": [{"sha": "a6ffbe07d91b0e6642b62fafce24a03f29efcc51", "filename": "library/core/src/future/join.rs", "status": "modified", "additions": 100, "deletions": 54, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/ed81098fcca409261db3408115725d07729ac39a/library%2Fcore%2Fsrc%2Ffuture%2Fjoin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed81098fcca409261db3408115725d07729ac39a/library%2Fcore%2Fsrc%2Ffuture%2Fjoin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fjoin.rs?ref=ed81098fcca409261db3408115725d07729ac39a", "patch": "@@ -1,4 +1,4 @@\n-#![allow(unused_imports)] // items are used by the macro\n+#![allow(unused_imports, unused_macros)] // items are used by the macro\n \n use crate::cell::UnsafeCell;\n use crate::future::{poll_fn, Future};\n@@ -45,59 +45,104 @@ use crate::task::{Context, Poll};\n /// # };\n /// ```\n #[unstable(feature = \"future_join\", issue = \"91642\")]\n-pub macro join {\n-    ( $($fut:expr),* $(,)?) => {\n-        join! { @count: (), @futures: {}, @rest: ($($fut,)*) }\n-    },\n-    // Recurse until we have the position of each future in the tuple\n+pub macro join( $($fut:expr),+ $(,)? ) {\n+    // Funnel through an internal macro not to leak implementation details.\n+    join_internal! {\n+        current_position: []\n+        futures_and_positions: []\n+        munching: [ $($fut)+ ]\n+    }\n+}\n+\n+// FIXME(danielhenrymantilla): a private macro should need no stability guarantee.\n+#[unstable(feature = \"future_join\", issue = \"91642\")]\n+/// To be able to *name* the i-th future in the tuple (say we want the .4-th),\n+/// the following trick will be used: `let (_, _, _, _, it, ..) = tuple;`\n+/// In order to do that, we need to generate a `i`-long repetition of `_`,\n+/// for each i-th fut. Hence the recursive muncher approach.\n+macro join_internal {\n+    // Recursion step: map each future with its \"position\" (underscore count).\n     (\n-        // A token for each future that has been expanded: \"_ _ _\"\n-        @count: ($($count:tt)*),\n-        // Futures and their positions in the tuple: \"{ a => (_), b => (_ _)) }\"\n-        @futures: { $($fut:tt)* },\n-        // Take a future from @rest to expand\n-        @rest: ($current:expr, $($rest:tt)*)\n-    ) => {\n-        join! {\n-            @count: ($($count)* _),\n-            @futures: { $($fut)* $current => ($($count)*), },\n-            @rest: ($($rest)*)\n+        // Accumulate a token for each future that has been expanded: \"_ _ _\".\n+        current_position: [\n+            $($underscores:tt)*\n+        ]\n+        // Accumulate Futures and their positions in the tuple: `_0th ()   _1st ( _ ) \u2026`.\n+        futures_and_positions: [\n+            $($acc:tt)*\n+        ]\n+        // Munch one future.\n+        munching: [\n+            $current:tt\n+            $($rest:tt)*\n+        ]\n+    ) => (\n+        join_internal! {\n+            current_position: [\n+                $($underscores)*\n+                _\n+            ]\n+            futures_and_positions: [\n+                $($acc)*\n+                $current ( $($underscores)* )\n+            ]\n+            munching: [\n+                $($rest)*\n+            ]\n         }\n-    },\n-    // Now generate the output future\n-    (\n-        @count: ($($count:tt)*),\n-        @futures: {\n-            $( $(@$f:tt)? $fut:expr => ( $($pos:tt)* ), )*\n-        },\n-        @rest: ()\n-    ) => {\n-        async move {\n-            let mut futures = ( $( MaybeDone::Future($fut), )* );\n+    ),\n \n+    // End of recursion: generate the output future.\n+    (\n+        current_position: $_:tt\n+        futures_and_positions: [\n+            $(\n+                $fut_expr:tt ( $($pos:tt)* )\n+            )*\n+        ]\n+        // Nothing left to munch.\n+        munching: []\n+    ) => (\n+        match ( $( MaybeDone::Future($fut_expr), )* ) { futures => async {\n+            let mut futures = futures;\n+            // SAFETY: this is `pin_mut!`.\n+            let mut futures = unsafe { Pin::new_unchecked(&mut futures) };\n             poll_fn(move |cx| {\n                 let mut done = true;\n-\n+                // For each `fut`, pin-project to it, and poll it.\n                 $(\n-                    let ( $($pos,)* fut, .. ) = &mut futures;\n-\n-                    // SAFETY: The futures are never moved\n-                    done &= unsafe { Pin::new_unchecked(fut).poll(cx).is_ready() };\n+                    // SAFETY: pinning projection\n+                    let fut = unsafe {\n+                        futures.as_mut().map_unchecked_mut(|it| {\n+                            let ( $($pos,)* fut, .. ) = it;\n+                            fut\n+                        })\n+                    };\n+                    // Despite how tempting it may be to `let () = fut.poll(cx).ready()?;`\n+                    // doing so would defeat the point of `join!`: to start polling eagerly all\n+                    // of the futures, to allow parallelizing the waits.\n+                    done &= fut.poll(cx).is_ready();\n                 )*\n-\n-                if done {\n-                    // Extract all the outputs\n-                    Poll::Ready(($({\n-                        let ( $($pos,)* fut, .. ) = &mut futures;\n-\n-                        fut.take_output().unwrap()\n-                    }),*))\n-                } else {\n-                    Poll::Pending\n+                if !done {\n+                    return Poll::Pending;\n                 }\n+                // All ready; time to extract all the outputs.\n+\n+                // SAFETY: `.take_output()` does not break the `Pin` invariants for that `fut`.\n+                let futures = unsafe {\n+                    futures.as_mut().get_unchecked_mut()\n+                };\n+                Poll::Ready(\n+                    ($(\n+                        {\n+                            let ( $($pos,)* fut, .. ) = &mut *futures;\n+                            fut.take_output().unwrap()\n+                        }\n+                    ),*) // <- no trailing comma since we don't want 1-tuples.\n+                )\n             }).await\n-        }\n-    }\n+        }}\n+    ),\n }\n \n /// Future used by `join!` that stores it's output to\n@@ -109,14 +154,14 @@ pub macro join {\n pub enum MaybeDone<F: Future> {\n     Future(F),\n     Done(F::Output),\n-    Took,\n+    Taken,\n }\n \n #[unstable(feature = \"future_join\", issue = \"91642\")]\n impl<F: Future> MaybeDone<F> {\n     pub fn take_output(&mut self) -> Option<F::Output> {\n-        match &*self {\n-            MaybeDone::Done(_) => match mem::replace(self, Self::Took) {\n+        match *self {\n+            MaybeDone::Done(_) => match mem::replace(self, Self::Taken) {\n                 MaybeDone::Done(val) => Some(val),\n                 _ => unreachable!(),\n             },\n@@ -132,13 +177,14 @@ impl<F: Future> Future for MaybeDone<F> {\n     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n         // SAFETY: pinning in structural for `f`\n         unsafe {\n-            match self.as_mut().get_unchecked_mut() {\n-                MaybeDone::Future(f) => match Pin::new_unchecked(f).poll(cx) {\n-                    Poll::Ready(val) => self.set(Self::Done(val)),\n-                    Poll::Pending => return Poll::Pending,\n-                },\n+            // Do not mix match ergonomics with unsafe.\n+            match *self.as_mut().get_unchecked_mut() {\n+                MaybeDone::Future(ref mut f) => {\n+                    let val = Pin::new_unchecked(f).poll(cx).ready()?;\n+                    self.set(Self::Done(val));\n+                }\n                 MaybeDone::Done(_) => {}\n-                MaybeDone::Took => unreachable!(),\n+                MaybeDone::Taken => unreachable!(),\n             }\n         }\n "}, {"sha": "e8b83b5cbc21ebc146a826ca137784aeb60dd6c1", "filename": "library/core/tests/future.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ed81098fcca409261db3408115725d07729ac39a/library%2Fcore%2Ftests%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed81098fcca409261db3408115725d07729ac39a/library%2Fcore%2Ftests%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Ffuture.rs?ref=ed81098fcca409261db3408115725d07729ac39a", "patch": "@@ -64,6 +64,40 @@ fn test_join() {\n     });\n }\n \n+/// Tests that `join!(\u2026)` behaves \"like a function\": evaluating its arguments\n+/// before applying any of its own logic.\n+///\n+/// _e.g._, `join!(async_fn(&borrowed), \u2026)` does not consume `borrowed`;\n+/// and `join!(opt_fut?, \u2026)` does let that `?` refer to the callsite scope.\n+mod test_join_function_like_value_arg_semantics {\n+    use super::*;\n+\n+    async fn async_fn(_: impl Sized) {}\n+\n+    // no need to _run_ this test, just to compile it.\n+    fn _join_does_not_unnecessarily_move_mentioned_bindings() {\n+        let not_copy = vec![()];\n+        let _ = join!(async_fn(&not_copy)); // should not move `not_copy`\n+        let _ = &not_copy; // OK\n+    }\n+\n+    #[test]\n+    fn join_lets_control_flow_effects_such_as_try_flow_through() {\n+        let maybe_fut = None;\n+        if false {\n+            *&mut { maybe_fut } = Some(async {});\n+            loop {}\n+        }\n+        assert!(Option::is_none(&try { join!(maybe_fut?, async { unreachable!() }) }));\n+    }\n+\n+    #[test]\n+    fn join_is_able_to_handle_temporaries() {\n+        let _ = join!(async_fn(&String::from(\"temporary\")));\n+        let () = block_on(join!(async_fn(&String::from(\"temporary\"))));\n+    }\n+}\n+\n fn block_on(fut: impl Future) {\n     struct Waker;\n     impl Wake for Waker {"}, {"sha": "012e6e5b57ad050986c1f8ee807d014eb8ca7da5", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed81098fcca409261db3408115725d07729ac39a/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed81098fcca409261db3408115725d07729ac39a/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=ed81098fcca409261db3408115725d07729ac39a", "patch": "@@ -49,6 +49,7 @@\n #![feature(str_internals)]\n #![feature(test)]\n #![feature(trusted_len)]\n+#![feature(try_blocks)]\n #![feature(try_trait_v2)]\n #![feature(slice_internals)]\n #![feature(slice_partition_dedup)]"}]}