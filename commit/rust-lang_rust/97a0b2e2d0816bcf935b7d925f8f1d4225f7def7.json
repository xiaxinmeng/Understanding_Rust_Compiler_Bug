{"sha": "97a0b2e2d0816bcf935b7d925f8f1d4225f7def7", "node_id": "C_kwDOAAsO6NoAKDk3YTBiMmUyZDA4MTZiY2Y5MzViN2Q5MjVmOGYxZDQyMjVmN2RlZjc", "commit": {"author": {"name": "R\u00e9my Rakic", "email": "remy.rakic+github@gmail.com", "date": "2022-05-31T10:36:48Z"}, "committer": {"name": "R\u00e9my Rakic", "email": "remy.rakic+github@gmail.com", "date": "2022-06-28T20:09:28Z"}, "message": "ctfe interning: don't walk allocations that don't need it\n\nThe interning of const allocations visits the mplace looking for references\nto intern. Walking big aggregates like big static arrays can be costly,\nso we only do it if the allocation we're interning contains references\nor interior mutability.\n\nWalking ZSTs was avoided before, and this optimization is now applied\nto cases where there are no references/relocations either.", "tree": {"sha": "a208e171052803518458d407ea351febf779c697", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a208e171052803518458d407ea351febf779c697"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97a0b2e2d0816bcf935b7d925f8f1d4225f7def7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97a0b2e2d0816bcf935b7d925f8f1d4225f7def7", "html_url": "https://github.com/rust-lang/rust/commit/97a0b2e2d0816bcf935b7d925f8f1d4225f7def7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97a0b2e2d0816bcf935b7d925f8f1d4225f7def7/comments", "author": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94e93749ab00539a11e90426ea87382c433530a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/94e93749ab00539a11e90426ea87382c433530a8", "html_url": "https://github.com/rust-lang/rust/commit/94e93749ab00539a11e90426ea87382c433530a8"}], "stats": {"total": 28, "additions": 25, "deletions": 3}, "files": [{"sha": "808e7db5ae3c0d78b77274f26e9a6eadd330068b", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/97a0b2e2d0816bcf935b7d925f8f1d4225f7def7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97a0b2e2d0816bcf935b7d925f8f1d4225f7def7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=97a0b2e2d0816bcf935b7d925f8f1d4225f7def7", "patch": "@@ -168,10 +168,22 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n         mplace: &MPlaceTy<'tcx>,\n         fields: impl Iterator<Item = InterpResult<'tcx, Self::V>>,\n     ) -> InterpResult<'tcx> {\n-        // ZSTs cannot contain pointers, so we can skip them.\n-        if mplace.layout.is_zst() {\n+        // We want to walk the aggregate to look for reference types to intern. While doing that we\n+        // also need to take special care of interior mutability.\n+        //\n+        // As an optimization, however, if the allocation does not contain any pointers: we don't\n+        // need to do the walk. It can be costly for big arrays for example (e.g. issue #93215).\n+\n+        let Some((size, align)) = self.ecx.size_and_align_of_mplace(&mplace)? else {\n+            // We could be dealing with an extern type here in the future, so we do the regular\n+            // walk.\n+            return self.walk_aggregate(mplace, fields);\n+        };\n+\n+        let Some(alloc) = self.ecx.get_ptr_alloc(mplace.ptr, size, align)? else {\n+            // ZSTs cannot contain pointers, so we can skip them.\n             return Ok(());\n-        }\n+        };\n \n         if let Some(def) = mplace.layout.ty.ty_adt_def() {\n             if Some(def.did()) == self.ecx.tcx.lang_items().unsafe_cell_type() {\n@@ -186,6 +198,11 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n             }\n         }\n \n+        if !alloc.has_relocations() {\n+            // There are no refs or relocations in this allocation, we can skip the interning walk.\n+            return Ok(());\n+        }\n+\n         self.walk_aggregate(mplace, fields)\n     }\n "}, {"sha": "fb82406ce8246643b83554cbfc7698a4d31e44d6", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/97a0b2e2d0816bcf935b7d925f8f1d4225f7def7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97a0b2e2d0816bcf935b7d925f8f1d4225f7def7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=97a0b2e2d0816bcf935b7d925f8f1d4225f7def7", "patch": "@@ -942,6 +942,11 @@ impl<'tcx, 'a, Tag: Provenance, Extra> AllocRef<'a, 'tcx, Tag, Extra> {\n             .check_bytes(&self.tcx, self.range.subrange(range), allow_uninit, allow_ptr)\n             .map_err(|e| e.to_interp_error(self.alloc_id))?)\n     }\n+\n+    /// Returns whether the allocation has relocations for the entire range of the `AllocRef`.\n+    pub(crate) fn has_relocations(&self) -> bool {\n+        !self.alloc.get_relocations(&self.tcx, self.range).is_empty()\n+    }\n }\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {"}]}