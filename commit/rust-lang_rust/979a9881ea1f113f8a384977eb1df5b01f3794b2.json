{"sha": "979a9881ea1f113f8a384977eb1df5b01f3794b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3OWE5ODgxZWExZjExM2Y4YTM4NDk3N2ViMWRmNWIwMWYzNzk0YjI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-03-14T20:48:36Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-03-15T08:21:20Z"}, "message": "Move the API json dumper to use rls-data too", "tree": {"sha": "7d35ef18941ec21b9051d87cc9f9a51e806d6a53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d35ef18941ec21b9051d87cc9f9a51e806d6a53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/979a9881ea1f113f8a384977eb1df5b01f3794b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/979a9881ea1f113f8a384977eb1df5b01f3794b2", "html_url": "https://github.com/rust-lang/rust/commit/979a9881ea1f113f8a384977eb1df5b01f3794b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/979a9881ea1f113f8a384977eb1df5b01f3794b2/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf07f1c6bb2a93eb02325a76ad855449b8f0ea5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf07f1c6bb2a93eb02325a76ad855449b8f0ea5b", "html_url": "https://github.com/rust-lang/rust/commit/bf07f1c6bb2a93eb02325a76ad855449b8f0ea5b"}], "stats": {"total": 461, "additions": 147, "deletions": 314}, "files": [{"sha": "41221ad986379b7f720875fa5ce997d95675dd8a", "filename": "src/librustc_save_analysis/json_api_dumper.rs", "status": "modified", "additions": 146, "deletions": 313, "changes": 459, "blob_url": "https://github.com/rust-lang/rust/blob/979a9881ea1f113f8a384977eb1df5b01f3794b2/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/979a9881ea1f113f8a384977eb1df5b01f3794b2/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs?ref=979a9881ea1f113f8a384977eb1df5b01f3794b2", "patch": "@@ -10,24 +10,22 @@\n \n use std::io::Write;\n \n-use rustc::hir::def_id::DefId;\n use rustc_serialize::json::as_json;\n \n use external_data::*;\n-use data::{VariableKind, Visibility, SigElement};\n+use data::{VariableKind, Visibility};\n use dump::Dump;\n-use super::Format;\n+use json_dumper::id_from_def_id;\n \n-use rls_data::{SpanData, CratePreludeData};\n+use rls_data::{Analysis, Import, ImportKind, Def, DefKind, CratePreludeData};\n \n \n // A dumper to dump a restricted set of JSON information, designed for use with\n // libraries distributed without their source. Clients are likely to use type\n // information here, and (for example) generate Rustdoc URLs, but don't need\n // information for navigating the source of the crate.\n // Relative to the regular JSON save-analysis info, this form is filtered to\n-// remove non-visible items, but includes some extra info for items (e.g., the\n-// parent field for finding the struct to which a field belongs).\n+// remove non-visible items.\n pub struct JsonApiDumper<'b, W: Write + 'b> {\n     output: &'b mut W,\n     result: Analysis,\n@@ -50,7 +48,7 @@ impl<'b, W: Write> Drop for JsonApiDumper<'b, W> {\n macro_rules! impl_fn {\n     ($fn_name: ident, $data_type: ident, $bucket: ident) => {\n         fn $fn_name(&mut self, data: $data_type) {\n-            if let Some(datum) = From::from(data) {\n+            if let Some(datum) = data.into() {\n                 self.result.$bucket.push(datum);\n             }\n         }\n@@ -79,11 +77,11 @@ impl<'b, W: Write + 'b> Dump for JsonApiDumper<'b, W> {\n \n     fn impl_data(&mut self, data: ImplData) {\n         if data.self_ref.is_some() {\n-            self.result.relations.push(From::from(data));\n+            self.result.relations.push(data.into());\n         }\n     }\n     fn inheritance(&mut self, data: InheritanceData) {\n-        self.result.relations.push(From::from(data));\n+        self.result.relations.push(data.into());\n     }\n }\n \n@@ -92,426 +90,261 @@ impl<'b, W: Write + 'b> Dump for JsonApiDumper<'b, W> {\n // method, but not the supplied method). In both cases, we are currently\n // ignoring it.\n \n-#[derive(Debug, RustcEncodable)]\n-struct Analysis {\n-    kind: Format,\n-    prelude: Option<CratePreludeData>,\n-    imports: Vec<Import>,\n-    defs: Vec<Def>,\n-    relations: Vec<Relation>,\n-    // These two fields are dummies so that clients can parse the two kinds of\n-    // JSON data in the same way.\n-    refs: Vec<()>,\n-    macro_refs: Vec<()>,\n-}\n-\n-impl Analysis {\n-    fn new() -> Analysis {\n-        Analysis {\n-            kind: Format::JsonApi,\n-            prelude: None,\n-            imports: vec![],\n-            defs: vec![],\n-            relations: vec![],\n-            refs: vec![],\n-            macro_refs: vec![],\n-        }\n-    }\n-}\n-\n-// DefId::index is a newtype and so the JSON serialisation is ugly. Therefore\n-// we use our own Id which is the same, but without the newtype.\n-#[derive(Debug, RustcEncodable)]\n-struct Id {\n-    krate: u32,\n-    index: u32,\n-}\n-\n-impl From<DefId> for Id {\n-    fn from(id: DefId) -> Id {\n-        Id {\n-            krate: id.krate.as_u32(),\n-            index: id.index.as_u32(),\n-        }\n-    }\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-struct Import {\n-    kind: ImportKind,\n-    id: Id,\n-    span: SpanData,\n-    name: String,\n-    value: String,\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-enum ImportKind {\n-    Use,\n-    GlobUse,\n-}\n-\n-impl From<UseData> for Option<Import> {\n-    fn from(data: UseData) -> Option<Import> {\n-        match data.visibility {\n+impl Into<Option<Import>> for UseData {\n+    fn into(self) -> Option<Import> {\n+        match self.visibility {\n             Visibility::Public => Some(Import {\n                 kind: ImportKind::Use,\n-                id: From::from(data.id),\n-                span: data.span,\n-                name: data.name,\n+                ref_id: self.mod_id.map(|id| id_from_def_id(id)),\n+                span: self.span,\n+                name: self.name,\n                 value: String::new(),\n             }),\n             _ => None,\n         }\n     }\n }\n-impl From<UseGlobData> for Option<Import> {\n-    fn from(data: UseGlobData) -> Option<Import> {\n-        match data.visibility {\n+impl Into<Option<Import>> for UseGlobData {\n+    fn into(self) -> Option<Import> {\n+        match self.visibility {\n             Visibility::Public => Some(Import {\n                 kind: ImportKind::GlobUse,\n-                id: From::from(data.id),\n-                span: data.span,\n+                ref_id: None,\n+                span: self.span,\n                 name: \"*\".to_owned(),\n-                value: data.names.join(\", \"),\n+                value: self.names.join(\", \"),\n             }),\n             _ => None,\n         }\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n-struct Def {\n-    kind: DefKind,\n-    id: Id,\n-    span: SpanData,\n-    name: String,\n-    qualname: String,\n-    value: String,\n-    parent: Option<Id>,\n-    children: Vec<Id>,\n-    decl_id: Option<Id>,\n-    docs: String,\n-    sig: Option<JsonSignature>,\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-enum DefKind {\n-    // value = variant names\n-    Enum,\n-    // value = enum name + variant name + types\n-    Tuple,\n-    // value = [enum name +] name + fields\n-    Struct,\n-    // value = signature\n-    Trait,\n-    // value = type + generics\n-    Function,\n-    // value = type + generics\n-    Method,\n-    // No id, no value.\n-    Macro,\n-    // value = file_name\n-    Mod,\n-    // value = aliased type\n-    Type,\n-    // value = type and init expression (for all variable kinds).\n-    Static,\n-    Const,\n-    Field,\n-}\n-\n-impl From<EnumData> for Option<Def> {\n-    fn from(data: EnumData) -> Option<Def> {\n-        match data.visibility {\n+impl Into<Option<Def>> for EnumData {\n+    fn into(self) -> Option<Def> {\n+        match self.visibility {\n             Visibility::Public => Some(Def {\n                 kind: DefKind::Enum,\n-                id: From::from(data.id),\n-                span: data.span,\n-                name: data.name,\n-                qualname: data.qualname,\n-                value: data.value,\n+                id: id_from_def_id(self.id),\n+                span: self.span,\n+                name: self.name,\n+                qualname: self.qualname,\n+                value: self.value,\n                 parent: None,\n-                children: data.variants.into_iter().map(|id| From::from(id)).collect(),\n+                children: self.variants.into_iter().map(|id| id_from_def_id(id)).collect(),\n                 decl_id: None,\n-                docs: data.docs,\n-                sig: Some(From::from(data.sig)),\n+                docs: self.docs,\n+                sig: Some(self.sig.into()),\n+                attributes: vec![],\n             }),\n             _ => None,\n         }\n     }\n }\n \n-impl From<TupleVariantData> for Option<Def> {\n-    fn from(data: TupleVariantData) -> Option<Def> {\n+impl Into<Option<Def>> for TupleVariantData {\n+    fn into(self) -> Option<Def> {\n         Some(Def {\n             kind: DefKind::Tuple,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n-            parent: data.parent.map(|id| From::from(id)),\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n+            parent: self.parent.map(|id| id_from_def_id(id)),\n             children: vec![],\n             decl_id: None,\n-            docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n+            docs: self.docs,\n+            sig: Some(self.sig.into()),\n+            attributes: vec![],\n         })\n     }\n }\n-impl From<StructVariantData> for Option<Def> {\n-    fn from(data: StructVariantData) -> Option<Def> {\n+impl Into<Option<Def>> for StructVariantData {\n+    fn into(self) -> Option<Def> {\n         Some(Def {\n             kind: DefKind::Struct,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n-            parent: data.parent.map(|id| From::from(id)),\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n+            parent: self.parent.map(|id| id_from_def_id(id)),\n             children: vec![],\n             decl_id: None,\n-            docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n+            docs: self.docs,\n+            sig: Some(self.sig.into()),\n+            attributes: vec![],\n         })\n     }\n }\n-impl From<StructData> for Option<Def> {\n-    fn from(data: StructData) -> Option<Def> {\n-        match data.visibility {\n+impl Into<Option<Def>> for StructData {\n+    fn into(self) -> Option<Def> {\n+        match self.visibility {\n             Visibility::Public => Some(Def {\n             kind: DefKind::Struct,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n             parent: None,\n-            children: data.fields.into_iter().map(|id| From::from(id)).collect(),\n+            children: self.fields.into_iter().map(|id| id_from_def_id(id)).collect(),\n             decl_id: None,\n-            docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n+            docs: self.docs,\n+            sig: Some(self.sig.into()),\n+            attributes: vec![],\n         }),\n             _ => None,\n         }\n     }\n }\n-impl From<TraitData> for Option<Def> {\n-    fn from(data: TraitData) -> Option<Def> {\n-        match data.visibility {\n+impl Into<Option<Def>> for TraitData {\n+    fn into(self) -> Option<Def> {\n+        match self.visibility {\n             Visibility::Public => Some(Def {\n                 kind: DefKind::Trait,\n-                id: From::from(data.id),\n-                span: data.span,\n-                name: data.name,\n-                qualname: data.qualname,\n-                value: data.value,\n-                children: data.items.into_iter().map(|id| From::from(id)).collect(),\n+                id: id_from_def_id(self.id),\n+                span: self.span,\n+                name: self.name,\n+                qualname: self.qualname,\n+                value: self.value,\n+                children: self.items.into_iter().map(|id| id_from_def_id(id)).collect(),\n                 parent: None,\n                 decl_id: None,\n-                docs: data.docs,\n-                sig: Some(From::from(data.sig)),\n+                docs: self.docs,\n+                sig: Some(self.sig.into()),\n+                attributes: vec![],\n             }),\n             _ => None,\n         }\n     }\n }\n-impl From<FunctionData> for Option<Def> {\n-    fn from(data: FunctionData) -> Option<Def> {\n-        match data.visibility {\n+impl Into<Option<Def>> for FunctionData {\n+    fn into(self) -> Option<Def> {\n+        match self.visibility {\n             Visibility::Public => Some(Def {\n                 kind: DefKind::Function,\n-                id: From::from(data.id),\n-                span: data.span,\n-                name: data.name,\n-                qualname: data.qualname,\n-                value: data.value,\n+                id: id_from_def_id(self.id),\n+                span: self.span,\n+                name: self.name,\n+                qualname: self.qualname,\n+                value: self.value,\n                 children: vec![],\n-                parent: data.parent.map(|id| From::from(id)),\n+                parent: self.parent.map(|id| id_from_def_id(id)),\n                 decl_id: None,\n-                docs: data.docs,\n-                sig: Some(From::from(data.sig)),\n+                docs: self.docs,\n+                sig: Some(self.sig.into()),\n+                attributes: vec![],\n             }),\n             _ => None,\n         }\n     }\n }\n-impl From<MethodData> for Option<Def> {\n-    fn from(data: MethodData) -> Option<Def> {\n-        match data.visibility {\n+impl Into<Option<Def>> for MethodData {\n+    fn into(self) -> Option<Def> {\n+        match self.visibility {\n             Visibility::Public => Some(Def {\n                 kind: DefKind::Method,\n-                id: From::from(data.id),\n-                span: data.span,\n-                name: data.name,\n-                qualname: data.qualname,\n-                value: data.value,\n+                id: id_from_def_id(self.id),\n+                span: self.span,\n+                name: self.name,\n+                qualname: self.qualname,\n+                value: self.value,\n                 children: vec![],\n-                parent: data.parent.map(|id| From::from(id)),\n-                decl_id: data.decl_id.map(|id| From::from(id)),\n-                docs: data.docs,\n-                sig: Some(From::from(data.sig)),\n+                parent: self.parent.map(|id| id_from_def_id(id)),\n+                decl_id: self.decl_id.map(|id| id_from_def_id(id)),\n+                docs: self.docs,\n+                sig: Some(self.sig.into()),\n+                attributes: vec![],\n             }),\n             _ => None,\n         }\n     }\n }\n-impl From<MacroData> for Option<Def> {\n-    fn from(data: MacroData) -> Option<Def> {\n+impl Into<Option<Def>> for MacroData {\n+    fn into(self) -> Option<Def> {\n         Some(Def {\n             kind: DefKind::Macro,\n-            id: From::from(null_def_id()),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n+            id: id_from_def_id(null_def_id()),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n             value: String::new(),\n             children: vec![],\n             parent: None,\n             decl_id: None,\n-            docs: data.docs,\n+            docs: self.docs,\n             sig: None,\n+            attributes: vec![],\n         })\n     }\n }\n-impl From<ModData> for Option<Def> {\n-    fn from(data:ModData) -> Option<Def> {\n-        match data.visibility {\n+impl Into<Option<Def>> for ModData {\n+    fn into(self) -> Option<Def> {\n+        match self.visibility {\n             Visibility::Public => Some(Def {\n                 kind: DefKind::Mod,\n-                id: From::from(data.id),\n-                span: data.span,\n-                name: data.name,\n-                qualname: data.qualname,\n-                value: data.filename,\n-                children: data.items.into_iter().map(|id| From::from(id)).collect(),\n+                id: id_from_def_id(self.id),\n+                span: self.span,\n+                name: self.name,\n+                qualname: self.qualname,\n+                value: self.filename,\n+                children: self.items.into_iter().map(|id| id_from_def_id(id)).collect(),\n                 parent: None,\n                 decl_id: None,\n-                docs: data.docs,\n-                sig: Some(From::from(data.sig)),\n+                docs: self.docs,\n+                sig: Some(self.sig.into()),\n+                attributes: vec![],\n             }),\n             _ => None,\n         }\n     }\n }\n-impl From<TypeDefData> for Option<Def> {\n-    fn from(data: TypeDefData) -> Option<Def> {\n-        match data.visibility {\n+impl Into<Option<Def>> for TypeDefData {\n+    fn into(self) -> Option<Def> {\n+        match self.visibility {\n             Visibility::Public => Some(Def {\n                 kind: DefKind::Type,\n-                id: From::from(data.id),\n-                span: data.span,\n-                name: data.name,\n-                qualname: data.qualname,\n-                value: data.value,\n+                id: id_from_def_id(self.id),\n+                span: self.span,\n+                name: self.name,\n+                qualname: self.qualname,\n+                value: self.value,\n                 children: vec![],\n-                parent: data.parent.map(|id| From::from(id)),\n+                parent: self.parent.map(|id| id_from_def_id(id)),\n                 decl_id: None,\n                 docs: String::new(),\n-                sig: data.sig.map(|s| From::from(s)),\n+                sig: self.sig.map(|s| s.into()),\n+                attributes: vec![],\n             }),\n             _ => None,\n         }\n     }\n }\n \n-impl From<VariableData> for Option<Def> {\n-    fn from(data: VariableData) -> Option<Def> {\n-        match data.visibility {\n+impl Into<Option<Def>> for VariableData {\n+    fn into(self) -> Option<Def> {\n+        match self.visibility {\n             Visibility::Public => Some(Def {\n-                kind: match data.kind {\n+                kind: match self.kind {\n                     VariableKind::Static => DefKind::Static,\n                     VariableKind::Const => DefKind::Const,\n                     VariableKind::Local => { return None }\n                     VariableKind::Field => DefKind::Field,\n                 },\n-                id: From::from(data.id),\n-                span: data.span,\n-                name: data.name,\n-                qualname: data.qualname,\n-                value: data.value,\n+                id: id_from_def_id(self.id),\n+                span: self.span,\n+                name: self.name,\n+                qualname: self.qualname,\n+                value: self.value,\n                 children: vec![],\n-                parent: data.parent.map(|id| From::from(id)),\n+                parent: self.parent.map(|id| id_from_def_id(id)),\n                 decl_id: None,\n-                docs: data.docs,\n-                sig: data.sig.map(|s| From::from(s)),\n+                docs: self.docs,\n+                sig: self.sig.map(|s| s.into()),\n+                attributes: vec![],\n             }),\n             _ => None,\n         }\n     }\n }\n-\n-#[derive(Debug, RustcEncodable)]\n-struct Relation {\n-    span: SpanData,\n-    kind: RelationKind,\n-    from: Id,\n-    to: Id,\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-enum RelationKind {\n-    Impl,\n-    SuperTrait,\n-}\n-\n-impl From<ImplData> for Relation {\n-    fn from(data: ImplData) -> Relation {\n-        Relation {\n-            span: data.span,\n-            kind: RelationKind::Impl,\n-            from: From::from(data.self_ref.unwrap_or(null_def_id())),\n-            to: From::from(data.trait_ref.unwrap_or(null_def_id())),\n-        }\n-    }\n-}\n-\n-impl From<InheritanceData> for Relation {\n-    fn from(data: InheritanceData) -> Relation {\n-        Relation {\n-            span: data.span,\n-            kind: RelationKind::SuperTrait,\n-            from: From::from(data.base_id),\n-            to: From::from(data.deriv_id),\n-        }\n-    }\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-pub struct JsonSignature {\n-    span: SpanData,\n-    text: String,\n-    ident_start: usize,\n-    ident_end: usize,\n-    defs: Vec<JsonSigElement>,\n-    refs: Vec<JsonSigElement>,\n-}\n-\n-impl From<Signature> for JsonSignature {\n-    fn from(data: Signature) -> JsonSignature {\n-        JsonSignature {\n-            span: data.span,\n-            text: data.text,\n-            ident_start: data.ident_start,\n-            ident_end: data.ident_end,\n-            defs: data.defs.into_iter().map(|s| From::from(s)).collect(),\n-            refs: data.refs.into_iter().map(|s| From::from(s)).collect(),\n-        }\n-    }\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-pub struct JsonSigElement {\n-    id: Id,\n-    start: usize,\n-    end: usize,\n-}\n-\n-impl From<SigElement> for JsonSigElement {\n-    fn from(data: SigElement) -> JsonSigElement {\n-        JsonSigElement {\n-            id: From::from(data.id),\n-            start: data.start,\n-            end: data.end,\n-        }\n-    }\n-}"}, {"sha": "acc877d3947758fb20a222e51c2f6a896fe5c3e4", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/979a9881ea1f113f8a384977eb1df5b01f3794b2/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/979a9881ea1f113f8a384977eb1df5b01f3794b2/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=979a9881ea1f113f8a384977eb1df5b01f3794b2", "patch": "@@ -136,7 +136,7 @@ impl<'b, W: Write + 'b> Dump for JsonDumper<'b, W> {\n \n // DefId::index is a newtype and so the JSON serialisation is ugly. Therefore\n // we use our own Id which is the same, but without the newtype.\n-fn id_from_def_id(id: DefId) -> Id {\n+pub fn id_from_def_id(id: DefId) -> Id {\n     Id {\n         krate: id.krate.as_u32(),\n         index: id.index.as_u32(),"}]}