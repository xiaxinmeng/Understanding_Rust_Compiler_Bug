{"sha": "6bbeffc8c56893548f5667844f59ce5a76f9fd98", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiYmVmZmM4YzU2ODkzNTQ4ZjU2Njc4NDRmNTljZTVhNzZmOWZkOTg=", "commit": {"author": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-08-01T07:41:42Z"}, "committer": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-08-01T07:41:42Z"}, "message": "SSR: Allow `self` in patterns.\n\nIt's now consistent with other variables in that if the pattern\nreferences self, only the `self` in scope where the rule is invoked will\nbe accepted. Since `self` doesn't work the same as other paths, this is\nimplemented by restricting the search to just the current function.\nPrior to this change (since path resolution was implemented), having\nself in a pattern would just result in no matches.", "tree": {"sha": "446162072916f99a3c9b4c5e1734fbcc56cbd3f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/446162072916f99a3c9b4c5e1734fbcc56cbd3f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bbeffc8c56893548f5667844f59ce5a76f9fd98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bbeffc8c56893548f5667844f59ce5a76f9fd98", "html_url": "https://github.com/rust-lang/rust/commit/6bbeffc8c56893548f5667844f59ce5a76f9fd98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bbeffc8c56893548f5667844f59ce5a76f9fd98/comments", "author": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5af32aeb2b83c7ae8adf3e088bf4f3691aa45eb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5af32aeb2b83c7ae8adf3e088bf4f3691aa45eb1", "html_url": "https://github.com/rust-lang/rust/commit/5af32aeb2b83c7ae8adf3e088bf4f3691aa45eb1"}], "stats": {"total": 80, "additions": 74, "deletions": 6}, "files": [{"sha": "c780b460a72ffffe7c006392f79ff80d331cca49", "filename": "crates/ra_ssr/src/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6bbeffc8c56893548f5667844f59ce5a76f9fd98/crates%2Fra_ssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bbeffc8c56893548f5667844f59ce5a76f9fd98/crates%2Fra_ssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Flib.rs?ref=6bbeffc8c56893548f5667844f59ce5a76f9fd98", "patch": "@@ -66,12 +66,7 @@ impl<'db> MatchFinder<'db> {\n         restrict_ranges.retain(|range| !range.range.is_empty());\n         let sema = Semantics::new(db);\n         let resolution_scope = resolving::ResolutionScope::new(&sema, lookup_context);\n-        MatchFinder {\n-            sema: Semantics::new(db),\n-            rules: Vec::new(),\n-            resolution_scope,\n-            restrict_ranges,\n-        }\n+        MatchFinder { sema, rules: Vec::new(), resolution_scope, restrict_ranges }\n     }\n \n     /// Constructs an instance using the start of the first file in `db` as the lookup context."}, {"sha": "0ac929bd555719b4a07d79f5ddd0a1f6016b17b6", "filename": "crates/ra_ssr/src/resolving.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6bbeffc8c56893548f5667844f59ce5a76f9fd98/crates%2Fra_ssr%2Fsrc%2Fresolving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bbeffc8c56893548f5667844f59ce5a76f9fd98/crates%2Fra_ssr%2Fsrc%2Fresolving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fresolving.rs?ref=6bbeffc8c56893548f5667844f59ce5a76f9fd98", "patch": "@@ -11,6 +11,7 @@ use test_utils::mark;\n pub(crate) struct ResolutionScope<'db> {\n     scope: hir::SemanticsScope<'db>,\n     hygiene: hir::Hygiene,\n+    node: SyntaxNode,\n }\n \n pub(crate) struct ResolvedRule {\n@@ -25,6 +26,7 @@ pub(crate) struct ResolvedPattern {\n     // Paths in `node` that we've resolved.\n     pub(crate) resolved_paths: FxHashMap<SyntaxNode, ResolvedPath>,\n     pub(crate) ufcs_function_calls: FxHashMap<SyntaxNode, hir::Function>,\n+    pub(crate) contains_self: bool,\n }\n \n pub(crate) struct ResolvedPath {\n@@ -68,6 +70,7 @@ struct Resolver<'a, 'db> {\n \n impl Resolver<'_, '_> {\n     fn resolve_pattern_tree(&self, pattern: SyntaxNode) -> Result<ResolvedPattern, SsrError> {\n+        use ra_syntax::{SyntaxElement, T};\n         let mut resolved_paths = FxHashMap::default();\n         self.resolve(pattern.clone(), 0, &mut resolved_paths)?;\n         let ufcs_function_calls = resolved_paths\n@@ -85,11 +88,17 @@ impl Resolver<'_, '_> {\n                 None\n             })\n             .collect();\n+        let contains_self =\n+            pattern.descendants_with_tokens().any(|node_or_token| match node_or_token {\n+                SyntaxElement::Token(t) => t.kind() == T![self],\n+                _ => false,\n+            });\n         Ok(ResolvedPattern {\n             node: pattern,\n             resolved_paths,\n             placeholders_by_stand_in: self.placeholders_by_stand_in.clone(),\n             ufcs_function_calls,\n+            contains_self,\n         })\n     }\n \n@@ -101,6 +110,10 @@ impl Resolver<'_, '_> {\n     ) -> Result<(), SsrError> {\n         use ra_syntax::ast::AstNode;\n         if let Some(path) = ast::Path::cast(node.clone()) {\n+            if is_self(&path) {\n+                // Self cannot be resolved like other paths.\n+                return Ok(());\n+            }\n             // Check if this is an appropriate place in the path to resolve. If the path is\n             // something like `a::B::<i32>::c` then we want to resolve `a::B`. If the path contains\n             // a placeholder. e.g. `a::$b::c` then we want to resolve `a`.\n@@ -157,6 +170,18 @@ impl<'db> ResolutionScope<'db> {\n         ResolutionScope {\n             scope,\n             hygiene: hir::Hygiene::new(sema.db, resolve_context.file_id.into()),\n+            node,\n+        }\n+    }\n+\n+    /// Returns the function in which SSR was invoked, if any.\n+    pub(crate) fn current_function(&self) -> Option<SyntaxNode> {\n+        let mut node = self.node.clone();\n+        loop {\n+            if node.kind() == SyntaxKind::FN {\n+                return Some(node);\n+            }\n+            node = node.parent()?;\n         }\n     }\n \n@@ -186,6 +211,10 @@ impl<'db> ResolutionScope<'db> {\n     }\n }\n \n+fn is_self(path: &ast::Path) -> bool {\n+    path.segment().map(|segment| segment.self_token().is_some()).unwrap_or(false)\n+}\n+\n /// Returns a suitable node for resolving paths in the current scope. If we create a scope based on\n /// a statement node, then we can't resolve local variables that were defined in the current scope\n /// (only in parent scopes). So we find another node, ideally a child of the statement where local"}, {"sha": "85ffa2ac23fc101b311b19c5d8ea86ce61f698fb", "filename": "crates/ra_ssr/src/search.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6bbeffc8c56893548f5667844f59ce5a76f9fd98/crates%2Fra_ssr%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bbeffc8c56893548f5667844f59ce5a76f9fd98/crates%2Fra_ssr%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fsearch.rs?ref=6bbeffc8c56893548f5667844f59ce5a76f9fd98", "patch": "@@ -33,6 +33,15 @@ impl<'db> MatchFinder<'db> {\n         usage_cache: &mut UsageCache,\n         matches_out: &mut Vec<Match>,\n     ) {\n+        if rule.pattern.contains_self {\n+            // If the pattern contains `self` we restrict the scope of the search to just the\n+            // current method. No other method can reference the same `self`. This makes the\n+            // behavior of `self` consistent with other variables.\n+            if let Some(current_function) = self.resolution_scope.current_function() {\n+                self.slow_scan_node(&current_function, rule, &None, matches_out);\n+            }\n+            return;\n+        }\n         if pick_path_for_usages(&rule.pattern).is_none() {\n             self.slow_scan(rule, matches_out);\n             return;"}, {"sha": "d483640df1c4572dfb7ed80eb0617e40605d8102", "filename": "crates/ra_ssr/src/tests.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6bbeffc8c56893548f5667844f59ce5a76f9fd98/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bbeffc8c56893548f5667844f59ce5a76f9fd98/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ftests.rs?ref=6bbeffc8c56893548f5667844f59ce5a76f9fd98", "patch": "@@ -1044,3 +1044,38 @@ fn replace_nonpath_within_selection() {\n             }\"#]],\n     );\n }\n+\n+#[test]\n+fn replace_self() {\n+    // `foo(self)` occurs twice in the code, however only the first occurrence is the `self` that's\n+    // in scope where the rule is invoked.\n+    assert_ssr_transform(\n+        \"foo(self) ==>> bar(self)\",\n+        r#\"\n+        struct S1 {}\n+        fn foo(_: &S1) {}\n+        fn bar(_: &S1) {}\n+        impl S1 {\n+            fn f1(&self) {\n+                foo(self)<|>\n+            }\n+            fn f2(&self) {\n+                foo(self)\n+            }\n+        }\n+        \"#,\n+        expect![[r#\"\n+            struct S1 {}\n+            fn foo(_: &S1) {}\n+            fn bar(_: &S1) {}\n+            impl S1 {\n+                fn f1(&self) {\n+                    bar(self)\n+                }\n+                fn f2(&self) {\n+                    foo(self)\n+                }\n+            }\n+        \"#]],\n+    );\n+}"}]}