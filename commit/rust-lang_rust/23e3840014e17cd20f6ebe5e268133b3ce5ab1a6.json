{"sha": "23e3840014e17cd20f6ebe5e268133b3ce5ab1a6", "node_id": "C_kwDOAAsO6NoAKDIzZTM4NDAwMTRlMTdjZDIwZjZlYmU1ZTI2ODEzM2IzY2U1YWIxYTY", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2023-01-05T09:15:33Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2023-02-23T13:05:03Z"}, "message": "Remove dead unwinds before drop elaboration\n\nAs a part of drop elaboration, we identify dead unwinds, i.e., unwind\nedges on a drop terminators which are known to be unreachable, because\nthere is no need to drop anything.\n\nPreviously, the data flow framework was informed about the dead unwinds,\nand it assumed those edges are absent from MIR. Unfortunately, the data\nflow framework wasn't consistent in maintaining this assumption.\n\nIn particular, if a block was reachable only through a dead unwind edge,\nits state was propagated to other blocks still. This became an issue in\nthe context of change removes DropAndReplace terminator, since it\nintroduces initialization into cleanup blocks.\n\nTo avoid this issue, remove unreachable unwind edges before the drop\nelaboration, and elaborate only blocks that remain reachable.", "tree": {"sha": "b93649562063a9b4f68ccb6186aa1aba4c778542", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b93649562063a9b4f68ccb6186aa1aba4c778542"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23e3840014e17cd20f6ebe5e268133b3ce5ab1a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23e3840014e17cd20f6ebe5e268133b3ce5ab1a6", "html_url": "https://github.com/rust-lang/rust/commit/23e3840014e17cd20f6ebe5e268133b3ce5ab1a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23e3840014e17cd20f6ebe5e268133b3ce5ab1a6/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00eec854f167c546cedd0911f4cc302a54ed0be9", "url": "https://api.github.com/repos/rust-lang/rust/commits/00eec854f167c546cedd0911f4cc302a54ed0be9", "html_url": "https://github.com/rust-lang/rust/commit/00eec854f167c546cedd0911f4cc302a54ed0be9"}], "stats": {"total": 120, "additions": 44, "deletions": 76}, "files": [{"sha": "2ae3ae02fcc4e24634114a410ad80e7aa8bf8bc4", "filename": "compiler/rustc_mir_dataflow/src/framework/direction.rs", "status": "modified", "additions": 3, "deletions": 28, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/23e3840014e17cd20f6ebe5e268133b3ce5ab1a6/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23e3840014e17cd20f6ebe5e268133b3ce5ab1a6/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs?ref=23e3840014e17cd20f6ebe5e268133b3ce5ab1a6", "patch": "@@ -1,4 +1,3 @@\n-use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::{self, BasicBlock, Location, SwitchTargets};\n use rustc_middle::ty::TyCtxt;\n use std::ops::RangeInclusive;\n@@ -54,7 +53,6 @@ pub trait Direction {\n         analysis: &A,\n         tcx: TyCtxt<'tcx>,\n         body: &mir::Body<'tcx>,\n-        dead_unwinds: Option<&BitSet<BasicBlock>>,\n         exit_state: &mut A::Domain,\n         block: (BasicBlock, &'_ mir::BasicBlockData<'tcx>),\n         propagate: impl FnMut(BasicBlock, &A::Domain),\n@@ -221,7 +219,6 @@ impl Direction for Backward {\n         analysis: &A,\n         _tcx: TyCtxt<'tcx>,\n         body: &mir::Body<'tcx>,\n-        dead_unwinds: Option<&BitSet<BasicBlock>>,\n         exit_state: &mut A::Domain,\n         (bb, _bb_data): (BasicBlock, &'_ mir::BasicBlockData<'tcx>),\n         mut propagate: impl FnMut(BasicBlock, &A::Domain),\n@@ -278,20 +275,6 @@ impl Direction for Backward {\n                     }\n                 }\n \n-                // Ignore dead unwinds.\n-                mir::TerminatorKind::Call { cleanup: Some(unwind), .. }\n-                | mir::TerminatorKind::Assert { cleanup: Some(unwind), .. }\n-                | mir::TerminatorKind::Drop { unwind: Some(unwind), .. }\n-                | mir::TerminatorKind::DropAndReplace { unwind: Some(unwind), .. }\n-                | mir::TerminatorKind::FalseUnwind { unwind: Some(unwind), .. }\n-                | mir::TerminatorKind::InlineAsm { cleanup: Some(unwind), .. }\n-                    if unwind == bb =>\n-                {\n-                    if dead_unwinds.map_or(true, |dead| !dead.contains(pred)) {\n-                        propagate(pred, exit_state);\n-                    }\n-                }\n-\n                 _ => propagate(pred, exit_state),\n             }\n         }\n@@ -304,7 +287,6 @@ struct BackwardSwitchIntEdgeEffectsApplier<'a, 'tcx, D, F> {\n     exit_state: &'a mut D,\n     bb: BasicBlock,\n     propagate: &'a mut F,\n-\n     effects_applied: bool,\n }\n \n@@ -484,7 +466,6 @@ impl Direction for Forward {\n         analysis: &A,\n         _tcx: TyCtxt<'tcx>,\n         _body: &mir::Body<'tcx>,\n-        dead_unwinds: Option<&BitSet<BasicBlock>>,\n         exit_state: &mut A::Domain,\n         (bb, bb_data): (BasicBlock, &'_ mir::BasicBlockData<'tcx>),\n         mut propagate: impl FnMut(BasicBlock, &A::Domain),\n@@ -502,9 +483,7 @@ impl Direction for Forward {\n             | DropAndReplace { target, unwind, value: _, place: _ }\n             | FalseUnwind { real_target: target, unwind } => {\n                 if let Some(unwind) = unwind {\n-                    if dead_unwinds.map_or(true, |dead| !dead.contains(bb)) {\n-                        propagate(unwind, exit_state);\n-                    }\n+                    propagate(unwind, exit_state);\n                 }\n \n                 propagate(target, exit_state);\n@@ -534,9 +513,7 @@ impl Direction for Forward {\n                 fn_span: _,\n             } => {\n                 if let Some(unwind) = cleanup {\n-                    if dead_unwinds.map_or(true, |dead| !dead.contains(bb)) {\n-                        propagate(unwind, exit_state);\n-                    }\n+                    propagate(unwind, exit_state);\n                 }\n \n                 if let Some(target) = target {\n@@ -560,9 +537,7 @@ impl Direction for Forward {\n                 cleanup,\n             } => {\n                 if let Some(unwind) = cleanup {\n-                    if dead_unwinds.map_or(true, |dead| !dead.contains(bb)) {\n-                        propagate(unwind, exit_state);\n-                    }\n+                    propagate(unwind, exit_state);\n                 }\n \n                 if let Some(target) = destination {"}, {"sha": "91c3bf0ad21f1f7f2da213cc025c1c9115af1170", "filename": "compiler/rustc_mir_dataflow/src/framework/engine.rs", "status": "modified", "additions": 2, "deletions": 30, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/23e3840014e17cd20f6ebe5e268133b3ce5ab1a6/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23e3840014e17cd20f6ebe5e268133b3ce5ab1a6/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs?ref=23e3840014e17cd20f6ebe5e268133b3ce5ab1a6", "patch": "@@ -12,7 +12,6 @@ use rustc_ast as ast;\n use rustc_data_structures::work_queue::WorkQueue;\n use rustc_graphviz as dot;\n use rustc_hir::def_id::DefId;\n-use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::{self, traversal, BasicBlock};\n use rustc_middle::mir::{create_dump_file, dump_enabled};\n@@ -78,7 +77,6 @@ where\n {\n     tcx: TyCtxt<'tcx>,\n     body: &'a mir::Body<'tcx>,\n-    dead_unwinds: Option<&'a BitSet<BasicBlock>>,\n     entry_sets: IndexVec<BasicBlock, A::Domain>,\n     pass_name: Option<&'static str>,\n     analysis: A,\n@@ -154,25 +152,7 @@ where\n             bug!(\"`initialize_start_block` is not yet supported for backward dataflow analyses\");\n         }\n \n-        Engine {\n-            analysis,\n-            tcx,\n-            body,\n-            dead_unwinds: None,\n-            pass_name: None,\n-            entry_sets,\n-            apply_trans_for_block,\n-        }\n-    }\n-\n-    /// Signals that we do not want dataflow state to propagate across unwind edges for these\n-    /// `BasicBlock`s.\n-    ///\n-    /// You must take care that `dead_unwinds` does not contain a `BasicBlock` that *can* actually\n-    /// unwind during execution. Otherwise, your dataflow results will not be correct.\n-    pub fn dead_unwinds(mut self, dead_unwinds: &'a BitSet<BasicBlock>) -> Self {\n-        self.dead_unwinds = Some(dead_unwinds);\n-        self\n+        Engine { analysis, tcx, body, pass_name: None, entry_sets, apply_trans_for_block }\n     }\n \n     /// Adds an identifier to the graphviz output for this particular run of a dataflow analysis.\n@@ -190,14 +170,7 @@ where\n         A::Domain: DebugWithContext<A>,\n     {\n         let Engine {\n-            analysis,\n-            body,\n-            dead_unwinds,\n-            mut entry_sets,\n-            tcx,\n-            apply_trans_for_block,\n-            pass_name,\n-            ..\n+            analysis, body, mut entry_sets, tcx, apply_trans_for_block, pass_name, ..\n         } = self;\n \n         let mut dirty_queue: WorkQueue<BasicBlock> = WorkQueue::with_none(body.basic_blocks.len());\n@@ -236,7 +209,6 @@ where\n                 &analysis,\n                 tcx,\n                 body,\n-                dead_unwinds,\n                 &mut state,\n                 (bb, bb_data),\n                 |target: BasicBlock, state: &A::Domain| {"}, {"sha": "bdfd8dc6e99b56c02dfccd5c8dc1d6219c9806d8", "filename": "compiler/rustc_mir_transform/src/elaborate_drops.rs", "status": "modified", "additions": 39, "deletions": 18, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/23e3840014e17cd20f6ebe5e268133b3ce5ab1a6/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23e3840014e17cd20f6ebe5e268133b3ce5ab1a6/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs?ref=23e3840014e17cd20f6ebe5e268133b3ce5ab1a6", "patch": "@@ -67,25 +67,24 @@ impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n         };\n         let un_derefer = UnDerefer { tcx: tcx, derefer_sidetable: side_table };\n         let elaborate_patch = {\n-            let body = &*body;\n             let env = MoveDataParamEnv { move_data, param_env };\n-            let dead_unwinds = find_dead_unwinds(tcx, body, &env, &un_derefer);\n+            remove_dead_unwinds(tcx, body, &env, &un_derefer);\n \n             let inits = MaybeInitializedPlaces::new(tcx, body, &env)\n                 .into_engine(tcx, body)\n-                .dead_unwinds(&dead_unwinds)\n                 .pass_name(\"elaborate_drops\")\n                 .iterate_to_fixpoint()\n                 .into_results_cursor(body);\n \n             let uninits = MaybeUninitializedPlaces::new(tcx, body, &env)\n                 .mark_inactive_variants_as_uninit()\n                 .into_engine(tcx, body)\n-                .dead_unwinds(&dead_unwinds)\n                 .pass_name(\"elaborate_drops\")\n                 .iterate_to_fixpoint()\n                 .into_results_cursor(body);\n \n+            let reachable = traversal::reachable_as_bitset(body);\n+\n             ElaborateDropsCtxt {\n                 tcx,\n                 body,\n@@ -94,6 +93,7 @@ impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n                 drop_flags: Default::default(),\n                 patch: MirPatch::new(body),\n                 un_derefer: un_derefer,\n+                reachable,\n             }\n             .elaborate()\n         };\n@@ -102,22 +102,21 @@ impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n     }\n }\n \n-/// Returns the set of basic blocks whose unwind edges are known\n-/// to not be reachable, because they are `drop` terminators\n+/// Removes unwind edges which are known to be unreachable, because they are in `drop` terminators\n /// that can't drop anything.\n-fn find_dead_unwinds<'tcx>(\n+fn remove_dead_unwinds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    body: &Body<'tcx>,\n+    body: &mut Body<'tcx>,\n     env: &MoveDataParamEnv<'tcx>,\n     und: &UnDerefer<'tcx>,\n-) -> BitSet<BasicBlock> {\n-    debug!(\"find_dead_unwinds({:?})\", body.span);\n+) {\n+    debug!(\"remove_dead_unwinds({:?})\", body.span);\n     // We only need to do this pass once, because unwind edges can only\n     // reach cleanup blocks, which can't have unwind edges themselves.\n-    let mut dead_unwinds = BitSet::new_empty(body.basic_blocks.len());\n+    let mut dead_unwinds = Vec::new();\n     let mut flow_inits = MaybeInitializedPlaces::new(tcx, body, &env)\n         .into_engine(tcx, body)\n-        .pass_name(\"find_dead_unwinds\")\n+        .pass_name(\"remove_dead_unwinds\")\n         .iterate_to_fixpoint()\n         .into_results_cursor(body);\n     for (bb, bb_data) in body.basic_blocks.iter_enumerated() {\n@@ -129,16 +128,16 @@ fn find_dead_unwinds<'tcx>(\n             _ => continue,\n         };\n \n-        debug!(\"find_dead_unwinds @ {:?}: {:?}\", bb, bb_data);\n+        debug!(\"remove_dead_unwinds @ {:?}: {:?}\", bb, bb_data);\n \n         let LookupResult::Exact(path) = env.move_data.rev_lookup.find(place.as_ref()) else {\n-            debug!(\"find_dead_unwinds: has parent; skipping\");\n+            debug!(\"remove_dead_unwinds: has parent; skipping\");\n             continue;\n         };\n \n         flow_inits.seek_before_primary_effect(body.terminator_loc(bb));\n         debug!(\n-            \"find_dead_unwinds @ {:?}: path({:?})={:?}; init_data={:?}\",\n+            \"remove_dead_unwinds @ {:?}: path({:?})={:?}; init_data={:?}\",\n             bb,\n             place,\n             path,\n@@ -150,13 +149,22 @@ fn find_dead_unwinds<'tcx>(\n             maybe_live |= flow_inits.contains(child);\n         });\n \n-        debug!(\"find_dead_unwinds @ {:?}: maybe_live={}\", bb, maybe_live);\n+        debug!(\"remove_dead_unwinds @ {:?}: maybe_live={}\", bb, maybe_live);\n         if !maybe_live {\n-            dead_unwinds.insert(bb);\n+            dead_unwinds.push(bb);\n         }\n     }\n \n-    dead_unwinds\n+    if dead_unwinds.is_empty() {\n+        return;\n+    }\n+\n+    let basic_blocks = body.basic_blocks.as_mut();\n+    for &bb in dead_unwinds.iter() {\n+        if let Some(unwind) = basic_blocks[bb].terminator_mut().unwind_mut() {\n+            *unwind = None;\n+        }\n+    }\n }\n \n struct InitializationData<'mir, 'tcx> {\n@@ -290,6 +298,7 @@ struct ElaborateDropsCtxt<'a, 'tcx> {\n     drop_flags: FxHashMap<MovePathIndex, Local>,\n     patch: MirPatch<'tcx>,\n     un_derefer: UnDerefer<'tcx>,\n+    reachable: BitSet<BasicBlock>,\n }\n \n impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n@@ -329,6 +338,9 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n     fn collect_drop_flags(&mut self) {\n         for (bb, data) in self.body.basic_blocks.iter_enumerated() {\n+            if !self.reachable.contains(bb) {\n+                continue;\n+            }\n             let terminator = data.terminator();\n             let place = match terminator.kind {\n                 TerminatorKind::Drop { ref place, .. }\n@@ -384,6 +396,9 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n     fn elaborate_drops(&mut self) {\n         for (bb, data) in self.body.basic_blocks.iter_enumerated() {\n+            if !self.reachable.contains(bb) {\n+                continue;\n+            }\n             let loc = Location { block: bb, statement_index: data.statements.len() };\n             let terminator = data.terminator();\n \n@@ -541,6 +556,9 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n     fn drop_flags_for_fn_rets(&mut self) {\n         for (bb, data) in self.body.basic_blocks.iter_enumerated() {\n+            if !self.reachable.contains(bb) {\n+                continue;\n+            }\n             if let TerminatorKind::Call {\n                 destination, target: Some(tgt), cleanup: Some(_), ..\n             } = data.terminator().kind\n@@ -576,6 +594,9 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         // clobbered before they are read.\n \n         for (bb, data) in self.body.basic_blocks.iter_enumerated() {\n+            if !self.reachable.contains(bb) {\n+                continue;\n+            }\n             debug!(\"drop_flags_for_locs({:?})\", data);\n             for i in 0..(data.statements.len() + 1) {\n                 debug!(\"drop_flag_for_locs: stmt {}\", i);"}]}