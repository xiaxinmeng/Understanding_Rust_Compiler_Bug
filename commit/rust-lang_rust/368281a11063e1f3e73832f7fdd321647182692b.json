{"sha": "368281a11063e1f3e73832f7fdd321647182692b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2ODI4MWExMTA2M2UxZjNlNzM4MzJmN2ZkZDMyMTY0NzE4MjY5MmI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-10T01:46:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-10T01:46:28Z"}, "message": "Rollup merge of #37412 - eddyb:lazy-6, r=nikomatsakis\n\n[6/n] rustc: transition HIR function bodies from Block to Expr.\n\n_This is part of a series ([prev](https://github.com/rust-lang/rust/pull/37408) | [next](https://github.com/rust-lang/rust/pull/37676)) of patches designed to rework rustc into an out-of-order on-demand pipeline model for both better feature support (e.g. [MIR-based](https://github.com/solson/miri) early constant evaluation) and incremental execution of compiler passes (e.g. type-checking), with beneficial consequences to IDE support as well.\nIf any motivation is unclear, please ask for additional PR description clarifications or code comments._\n\n<hr>\n\nThe main change here is that functions and closures both use `Expr` instead of `Block` for their bodies.\nFor closures this actually allows a honest representation of brace-less closure bodies, e.g. `|x| x + 1` is now distinguishable from `|x| { x + 1 }`, therefore this PR is `[syntax-breaking]` (cc @Manishearth).\n\nUsing `Expr` allows more logic to be shared between constant bodies and function bodies, with some small such changes already part of this PR, and eventually easing #35078 and per-body type tables.\n\nIncidentally, there used to be some corners cut here and there and as such I had to (re)write divergence tracking for type-checking so that it is capable of understanding basic structured control-flow:\n\n``` rust\nfn a(x: bool) -> i32 {\n    // match also works (as long as all arms diverge)\n    if x { panic!(\"true\") } else { return 1; }\n    0 // \"unreachable expression\" after this PR\n}\n```\n\nAnd since liveness' \"not all control paths return a value\" moved to type-checking we can have nice things:\n\n``` rust\n// before & after:\nfn b() -> i32 { 0; } // help: consider removing this semicolon\n\n// only after this PR\nfn c() -> i32 { { 0; } } // help: consider removing this semicolon\nfn d() { let x: i32 = { 0; }; } // help: consider removing this semicolon\nfn e() { f({ 0; }); } // help: consider removing this semicolon\n```", "tree": {"sha": "f99aea3896836097aee24548dbc03f870b69fbe1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f99aea3896836097aee24548dbc03f870b69fbe1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/368281a11063e1f3e73832f7fdd321647182692b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/368281a11063e1f3e73832f7fdd321647182692b", "html_url": "https://github.com/rust-lang/rust/commit/368281a11063e1f3e73832f7fdd321647182692b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/368281a11063e1f3e73832f7fdd321647182692b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d4a3500ff51dc4352fae847529451d51474ab0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d4a3500ff51dc4352fae847529451d51474ab0f", "html_url": "https://github.com/rust-lang/rust/commit/8d4a3500ff51dc4352fae847529451d51474ab0f"}, {"sha": "8e9106c531c559bf923de93cccbeb0fa0a47451f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e9106c531c559bf923de93cccbeb0fa0a47451f", "html_url": "https://github.com/rust-lang/rust/commit/8e9106c531c559bf923de93cccbeb0fa0a47451f"}], "stats": {"total": 1607, "additions": 778, "deletions": 829}, "files": [{"sha": "853f81ceaa9b8746ddf9a9df54414671d7e07c4c", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -53,7 +53,7 @@ pub unsafe extern fn __rust_maybe_catch_panic(f: fn(*mut u8),\n // now hopefully.\n #[no_mangle]\n pub unsafe extern fn __rust_start_panic(_data: usize, _vtable: usize) -> u32 {\n-    return abort();\n+    abort();\n \n     #[cfg(unix)]\n     unsafe fn abort() -> ! {"}, {"sha": "22c7d14be29d205dbe172c7a96ca322605d7df6d", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -33,25 +33,25 @@ struct LoopScope {\n }\n \n pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           blk: &hir::Block) -> CFG {\n+                           body: &hir::Expr) -> CFG {\n     let mut graph = graph::Graph::new();\n     let entry = graph.add_node(CFGNodeData::Entry);\n \n     // `fn_exit` is target of return exprs, which lies somewhere\n-    // outside input `blk`. (Distinguishing `fn_exit` and `block_exit`\n+    // outside input `body`. (Distinguishing `fn_exit` and `body_exit`\n     // also resolves chicken-and-egg problem that arises if you try to\n-    // have return exprs jump to `block_exit` during construction.)\n+    // have return exprs jump to `body_exit` during construction.)\n     let fn_exit = graph.add_node(CFGNodeData::Exit);\n-    let block_exit;\n+    let body_exit;\n \n     let mut cfg_builder = CFGBuilder {\n         graph: graph,\n         fn_exit: fn_exit,\n         tcx: tcx,\n         loop_scopes: Vec::new()\n     };\n-    block_exit = cfg_builder.block(blk, entry);\n-    cfg_builder.add_contained_edge(block_exit, fn_exit);\n+    body_exit = cfg_builder.expr(body, entry);\n+    cfg_builder.add_contained_edge(body_exit, fn_exit);\n     let CFGBuilder {graph, ..} = cfg_builder;\n     CFG {graph: graph,\n          entry: entry,"}, {"sha": "43434b884c8d4b7e55b96c41c678565362ad7ef4", "filename": "src/librustc/cfg/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fmod.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -59,8 +59,8 @@ pub type CFGEdge = graph::Edge<CFGEdgeData>;\n \n impl CFG {\n     pub fn new<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         blk: &hir::Block) -> CFG {\n-        construct::construct(tcx, blk)\n+                         body: &hir::Expr) -> CFG {\n+        construct::construct(tcx, body)\n     }\n \n     pub fn node_is_reachable(&self, id: ast::NodeId) -> bool {"}, {"sha": "ec09877ae121cdfeba73bc638f2ecf3492afee51", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 114, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -672,120 +672,6 @@ extern \"C\" {\n ```\n \"##,\n \n-E0269: r##\"\n-A returned value was expected but not all control paths return one.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0269\n-fn abracada_FAIL() -> String {\n-    \"this won't work\".to_string();\n-    // error: not all control paths return a value\n-}\n-```\n-\n-In the previous code, the function is supposed to return a `String`, however,\n-the code returns nothing (because of the ';'). Another erroneous code would be:\n-\n-```compile_fail\n-fn abracada_FAIL(b: bool) -> u32 {\n-    if b {\n-        0\n-    } else {\n-        \"a\" // It fails because an `u32` was expected and something else is\n-            // returned.\n-    }\n-}\n-```\n-\n-It is advisable to find out what the unhandled cases are and check for them,\n-returning an appropriate value or panicking if necessary. Check if you need\n-to remove a semicolon from the last expression, like in the first erroneous\n-code example.\n-\"##,\n-\n-E0270: r##\"\n-Rust lets you define functions which are known to never return, i.e. are\n-'diverging', by marking its return type as `!`.\n-\n-For example, the following functions never return:\n-\n-```no_run\n-fn foo() -> ! {\n-    loop {}\n-}\n-\n-fn bar() -> ! {\n-    foo() // foo() is diverging, so this will diverge too\n-}\n-\n-fn baz() -> ! {\n-    panic!(); // this macro internally expands to a call to a diverging function\n-}\n-```\n-\n-Such functions can be used in a place where a value is expected without\n-returning a value of that type, for instance:\n-\n-```no_run\n-fn foo() -> ! {\n-    loop {}\n-}\n-\n-let x = 3;\n-\n-let y = match x {\n-    1 => 1,\n-    2 => 4,\n-    _ => foo() // diverging function called here\n-};\n-\n-println!(\"{}\", y)\n-```\n-\n-If the third arm of the match block is reached, since `foo()` doesn't ever\n-return control to the match block, it is fine to use it in a place where an\n-integer was expected. The `match` block will never finish executing, and any\n-point where `y` (like the print statement) is needed will not be reached.\n-\n-However, if we had a diverging function that actually does finish execution:\n-\n-```ignore\n-fn foo() -> ! {\n-    loop {break;}\n-}\n-```\n-\n-Then we would have an unknown value for `y` in the following code:\n-\n-```no_run\n-fn foo() -> ! {\n-    loop {}\n-}\n-\n-let x = 3;\n-\n-let y = match x {\n-    1 => 1,\n-    2 => 4,\n-    _ => foo()\n-};\n-\n-println!(\"{}\", y);\n-```\n-\n-In the previous example, the print statement was never reached when the\n-wildcard match arm was hit, so we were okay with `foo()` not returning an\n-integer that we could set to `y`. But in this example, `foo()` actually does\n-return control, so the print statement will be executed with an uninitialized\n-value.\n-\n-Obviously we cannot have functions which are allowed to be used in such\n-positions and yet can return control. So, if you are defining a function that\n-returns `!`, make sure that there is no way for it to actually finish\n-executing.\n-\"##,\n-\n E0271: r##\"\n This is because of a type mismatch between the associated type of some\n trait (e.g. `T::Bar`, where `T` implements `trait Quux { type Bar; }`)"}, {"sha": "9932e5fe6862305cd366b9fd34f38ced1191f38d", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -138,7 +138,7 @@ pub trait Visitor<'v> : Sized {\n     fn visit_where_predicate(&mut self, predicate: &'v WherePredicate) {\n         walk_where_predicate(self, predicate)\n     }\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Block, s: Span, id: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Expr, s: Span, id: NodeId) {\n         walk_fn(self, fk, fd, b, s, id)\n     }\n     fn visit_trait_item(&mut self, ti: &'v TraitItem) {\n@@ -635,13 +635,13 @@ pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'\n pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n                                    function_kind: FnKind<'v>,\n                                    function_declaration: &'v FnDecl,\n-                                   function_body: &'v Block,\n+                                   function_body: &'v Expr,\n                                    _span: Span,\n                                    id: NodeId) {\n     visitor.visit_id(id);\n     walk_fn_decl(visitor, function_declaration);\n     walk_fn_kind(visitor, function_kind);\n-    visitor.visit_block(function_body)\n+    visitor.visit_expr(function_body)\n }\n \n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem) {\n@@ -925,7 +925,7 @@ impl<'v> Visitor<'v> for IdRangeComputingVisitor {\n /// Computes the id range for a single fn body, ignoring nested items.\n pub fn compute_id_range_for_fn_body(fk: FnKind,\n                                     decl: &FnDecl,\n-                                    body: &Block,\n+                                    body: &Expr,\n                                     sp: Span,\n                                     id: NodeId)\n                                     -> IdRange {"}, {"sha": "b985298e47cc2f8ed0d7ccecab551a0edae0e99f", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -595,12 +595,13 @@ impl<'a> LoweringContext<'a> {\n                 hir::ItemConst(self.lower_ty(t), self.lower_expr(e))\n             }\n             ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n+                let body = self.lower_block(body);\n                 hir::ItemFn(self.lower_fn_decl(decl),\n                             self.lower_unsafety(unsafety),\n                             self.lower_constness(constness),\n                             abi,\n                             self.lower_generics(generics),\n-                            self.lower_block(body))\n+                            self.expr_block(body, ThinVec::new()))\n             }\n             ItemKind::Mod(ref m) => hir::ItemMod(self.lower_mod(m)),\n             ItemKind::ForeignMod(ref nm) => hir::ItemForeignMod(self.lower_foreign_mod(nm)),\n@@ -665,7 +666,10 @@ impl<'a> LoweringContext<'a> {\n                     }\n                     TraitItemKind::Method(ref sig, ref body) => {\n                         hir::MethodTraitItem(this.lower_method_sig(sig),\n-                                             body.as_ref().map(|x| this.lower_block(x)))\n+                                             body.as_ref().map(|x| {\n+                            let body = this.lower_block(x);\n+                            this.expr_block(body, ThinVec::new())\n+                        }))\n                     }\n                     TraitItemKind::Type(ref bounds, ref default) => {\n                         hir::TypeTraitItem(this.lower_bounds(bounds),\n@@ -691,8 +695,9 @@ impl<'a> LoweringContext<'a> {\n                         hir::ImplItemKind::Const(this.lower_ty(ty), this.lower_expr(expr))\n                     }\n                     ImplItemKind::Method(ref sig, ref body) => {\n+                        let body = this.lower_block(body);\n                         hir::ImplItemKind::Method(this.lower_method_sig(sig),\n-                                                  this.lower_block(body))\n+                                                  this.expr_block(body, ThinVec::new()))\n                     }\n                     ImplItemKind::Type(ref ty) => hir::ImplItemKind::Type(this.lower_ty(ty)),\n                     ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n@@ -1110,7 +1115,7 @@ impl<'a> LoweringContext<'a> {\n                     self.with_parent_def(e.id, |this| {\n                         hir::ExprClosure(this.lower_capture_clause(capture_clause),\n                                          this.lower_fn_decl(decl),\n-                                         this.lower_block(body),\n+                                         this.lower_expr(body),\n                                          fn_decl_span)\n                     })\n                 }"}, {"sha": "325a90ea91e0ec25b18cd60d50f9c3fa4a548a66", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -21,11 +21,9 @@\n //! nested within a uniquely determined `FnLike`), and users can ask\n //! for the `Code` associated with a particular NodeId.\n \n-pub use self::Code::*;\n-\n use hir as ast;\n use hir::map::{self, Node};\n-use hir::{Block, FnDecl};\n+use hir::{Expr, FnDecl};\n use hir::intravisit::FnKind;\n use syntax::abi;\n use syntax::ast::{Attribute, Name, NodeId};\n@@ -50,7 +48,7 @@ pub trait MaybeFnLike { fn is_fn_like(&self) -> bool; }\n /// Components shared by fn-like things (fn items, methods, closures).\n pub struct FnParts<'a> {\n     pub decl: &'a FnDecl,\n-    pub body: &'a Block,\n+    pub body: &'a Expr,\n     pub kind: FnKind<'a>,\n     pub span: Span,\n     pub id:   NodeId,\n@@ -77,29 +75,32 @@ impl MaybeFnLike for ast::Expr {\n     }\n }\n \n-/// Carries either an FnLikeNode or a Block, as these are the two\n+/// Carries either an FnLikeNode or a Expr, as these are the two\n /// constructs that correspond to \"code\" (as in, something from which\n /// we can construct a control-flow graph).\n #[derive(Copy, Clone)]\n pub enum Code<'a> {\n-    FnLikeCode(FnLikeNode<'a>),\n-    BlockCode(&'a Block),\n+    FnLike(FnLikeNode<'a>),\n+    Expr(&'a Expr),\n }\n \n impl<'a> Code<'a> {\n     pub fn id(&self) -> NodeId {\n         match *self {\n-            FnLikeCode(node) => node.id(),\n-            BlockCode(block) => block.id,\n+            Code::FnLike(node) => node.id(),\n+            Code::Expr(block) => block.id,\n         }\n     }\n \n-    /// Attempts to construct a Code from presumed FnLike or Block node input.\n-    pub fn from_node(node: Node) -> Option<Code> {\n-        if let map::NodeBlock(block) = node {\n-            Some(BlockCode(block))\n-        } else {\n-            FnLikeNode::from_node(node).map(|fn_like| FnLikeCode(fn_like))\n+    /// Attempts to construct a Code from presumed FnLike or Expr node input.\n+    pub fn from_node(map: &map::Map<'a>, id: NodeId) -> Option<Code<'a>> {\n+        match map.get(id) {\n+            map::NodeBlock(_) => {\n+                //  Use the parent, hopefully an expression node.\n+                Code::from_node(map, map.get_parent_node(id))\n+            }\n+            map::NodeExpr(expr) => Some(Code::Expr(expr)),\n+            node => FnLikeNode::from_node(node).map(Code::FnLike)\n         }\n     }\n }\n@@ -114,7 +115,7 @@ struct ItemFnParts<'a> {\n     abi:      abi::Abi,\n     vis:      &'a ast::Visibility,\n     generics: &'a ast::Generics,\n-    body:     &'a Block,\n+    body:     &'a Expr,\n     id:       NodeId,\n     span:     Span,\n     attrs:    &'a [Attribute],\n@@ -124,14 +125,14 @@ struct ItemFnParts<'a> {\n /// for use when implementing FnLikeNode operations.\n struct ClosureParts<'a> {\n     decl: &'a FnDecl,\n-    body: &'a Block,\n+    body: &'a Expr,\n     id: NodeId,\n     span: Span,\n     attrs: &'a [Attribute],\n }\n \n impl<'a> ClosureParts<'a> {\n-    fn new(d: &'a FnDecl, b: &'a Block, id: NodeId, s: Span, attrs: &'a [Attribute]) -> Self {\n+    fn new(d: &'a FnDecl, b: &'a Expr, id: NodeId, s: Span, attrs: &'a [Attribute]) -> Self {\n         ClosureParts {\n             decl: d,\n             body: b,\n@@ -171,9 +172,9 @@ impl<'a> FnLikeNode<'a> {\n         }\n     }\n \n-    pub fn body(self) -> &'a Block {\n+    pub fn body(self) -> &'a Expr {\n         self.handle(|i: ItemFnParts<'a>|  &*i.body,\n-                    |_, _, _: &'a ast::MethodSig, _, body: &'a ast::Block, _, _|  body,\n+                    |_, _, _: &'a ast::MethodSig, _, body: &'a ast::Expr, _, _|  body,\n                     |c: ClosureParts<'a>| c.body)\n     }\n \n@@ -214,7 +215,7 @@ impl<'a> FnLikeNode<'a> {\n                   Name,\n                   &'a ast::MethodSig,\n                   Option<&'a ast::Visibility>,\n-                  &'a ast::Block,\n+                  &'a ast::Expr,\n                   Span,\n                   &'a [Attribute])\n                   -> A,"}, {"sha": "e23a721da08a693371e891c9c841d23818a3ae00", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -211,7 +211,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     }\n \n     fn visit_fn(&mut self, fk: intravisit::FnKind<'ast>, fd: &'ast FnDecl,\n-                b: &'ast Block, s: Span, id: NodeId) {\n+                b: &'ast Expr, s: Span, id: NodeId) {\n         assert_eq!(self.parent_node, id);\n         intravisit::walk_fn(self, fk, fd, b, s, id);\n     }"}, {"sha": "6b5b8101a146ca57fd92184ab0300bd74030e905", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -904,7 +904,7 @@ pub enum Expr_ {\n     /// A closure (for example, `move |a, b, c| {a + b + c}`).\n     ///\n     /// The final span is the span of the argument block `|...|`\n-    ExprClosure(CaptureClause, P<FnDecl>, P<Block>, Span),\n+    ExprClosure(CaptureClause, P<FnDecl>, P<Expr>, Span),\n     /// A block (`{ ... }`)\n     ExprBlock(P<Block>),\n \n@@ -1035,7 +1035,7 @@ pub enum TraitItem_ {\n     /// must contain a value)\n     ConstTraitItem(P<Ty>, Option<P<Expr>>),\n     /// A method with an optional body\n-    MethodTraitItem(MethodSig, Option<P<Block>>),\n+    MethodTraitItem(MethodSig, Option<P<Expr>>),\n     /// An associated type with (possibly empty) bounds and optional concrete\n     /// type\n     TypeTraitItem(TyParamBounds, Option<P<Ty>>),\n@@ -1060,7 +1060,7 @@ pub enum ImplItemKind {\n     /// of the expression\n     Const(P<Ty>, P<Expr>),\n     /// A method implementation with the given signature and body\n-    Method(MethodSig, P<Block>),\n+    Method(MethodSig, P<Expr>),\n     /// An associated type\n     Type(P<Ty>),\n }\n@@ -1501,7 +1501,7 @@ pub enum Item_ {\n     /// A `const` item\n     ItemConst(P<Ty>, P<Expr>),\n     /// A function declaration\n-    ItemFn(P<FnDecl>, Unsafety, Constness, Abi, Generics, P<Block>),\n+    ItemFn(P<FnDecl>, Unsafety, Constness, Abi, Generics, P<Expr>),\n     /// A module\n     ItemMod(Mod),\n     /// An external module"}, {"sha": "2c4ffb853c1f3af157a3d5e4d57e45a3e80191f0", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -713,7 +713,9 @@ impl<'a> State<'a> {\n                               typarams,\n                               &item.vis)?;\n                 word(&mut self.s, \" \")?;\n-                self.print_block_with_attrs(&body, &item.attrs)?;\n+                self.end()?; // need to close a box\n+                self.end()?; // need to close a box\n+                self.print_expr(&body)?;\n             }\n             hir::ItemMod(ref _mod) => {\n                 self.head(&visibility_qualified(&item.vis, \"mod\"))?;\n@@ -1002,7 +1004,9 @@ impl<'a> State<'a> {\n                 self.print_method_sig(ti.name, sig, &hir::Inherited)?;\n                 if let Some(ref body) = *body {\n                     self.nbsp()?;\n-                    self.print_block_with_attrs(body, &ti.attrs)?;\n+                    self.end()?; // need to close a box\n+                    self.end()?; // need to close a box\n+                    self.print_expr(body)?;\n                 } else {\n                     word(&mut self.s, \";\")?;\n                 }\n@@ -1034,7 +1038,9 @@ impl<'a> State<'a> {\n                 self.head(\"\")?;\n                 self.print_method_sig(ii.name, sig, &ii.vis)?;\n                 self.nbsp()?;\n-                self.print_block_with_attrs(body, &ii.attrs)?;\n+                self.end()?; // need to close a box\n+                self.end()?; // need to close a box\n+                self.print_expr(body)?;\n             }\n             hir::ImplItemKind::Type(ref ty) => {\n                 self.print_associated_type(ii.name, None, Some(ty))?;\n@@ -1402,26 +1408,10 @@ impl<'a> State<'a> {\n                 self.print_fn_block_args(&decl)?;\n                 space(&mut self.s)?;\n \n-                let default_return = match decl.output {\n-                    hir::DefaultReturn(..) => true,\n-                    _ => false,\n-                };\n+                // this is a bare expression\n+                self.print_expr(body)?;\n+                self.end()?; // need to close a box\n \n-                if !default_return || !body.stmts.is_empty() || body.expr.is_none() {\n-                    self.print_block_unclosed(&body)?;\n-                } else {\n-                    // we extract the block, so as not to create another set of boxes\n-                    match body.expr.as_ref().unwrap().node {\n-                        hir::ExprBlock(ref blk) => {\n-                            self.print_block_unclosed(&blk)?;\n-                        }\n-                        _ => {\n-                            // this is a bare expression\n-                            self.print_expr(body.expr.as_ref().map(|e| &**e).unwrap())?;\n-                            self.end()?; // need to close a box\n-                        }\n-                    }\n-                }\n                 // a box will be closed by print_expr, but we didn't want an overall\n                 // wrapper so we closed the corresponding opening. so create an\n                 // empty box to satisfy the close."}, {"sha": "f44f82860077e21498288a59f723c02962d33ad0", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -838,7 +838,7 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: hir_visit::FnKind<'v>, decl: &'v hir::FnDecl,\n-                body: &'v hir::Block, span: Span, id: ast::NodeId) {\n+                body: &'v hir::Expr, span: Span, id: ast::NodeId) {\n         run_lints!(self, check_fn, late_passes, fk, decl, body, span, id);\n         hir_visit::walk_fn(self, fk, decl, body, span, id);\n         run_lints!(self, check_fn_post, late_passes, fk, decl, body, span, id);\n@@ -994,10 +994,10 @@ impl<'a> ast_visit::Visitor for EarlyContext<'a> {\n     }\n \n     fn visit_fn(&mut self, fk: ast_visit::FnKind, decl: &ast::FnDecl,\n-                body: &ast::Block, span: Span, id: ast::NodeId) {\n-        run_lints!(self, check_fn, early_passes, fk, decl, body, span, id);\n-        ast_visit::walk_fn(self, fk, decl, body, span);\n-        run_lints!(self, check_fn_post, early_passes, fk, decl, body, span, id);\n+                span: Span, id: ast::NodeId) {\n+        run_lints!(self, check_fn, early_passes, fk, decl, span, id);\n+        ast_visit::walk_fn(self, fk, decl, span);\n+        run_lints!(self, check_fn_post, early_passes, fk, decl, span, id);\n     }\n \n     fn visit_variant_data(&mut self,"}, {"sha": "6f7102229f8d6150ecef22853b687cfe78b26216", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -151,9 +151,9 @@ pub trait LateLintPass: LintPass {\n     fn check_ty(&mut self, _: &LateContext, _: &hir::Ty) { }\n     fn check_generics(&mut self, _: &LateContext, _: &hir::Generics) { }\n     fn check_fn(&mut self, _: &LateContext,\n-        _: FnKind, _: &hir::FnDecl, _: &hir::Block, _: Span, _: ast::NodeId) { }\n+        _: FnKind, _: &hir::FnDecl, _: &hir::Expr, _: Span, _: ast::NodeId) { }\n     fn check_fn_post(&mut self, _: &LateContext,\n-        _: FnKind, _: &hir::FnDecl, _: &hir::Block, _: Span, _: ast::NodeId) { }\n+        _: FnKind, _: &hir::FnDecl, _: &hir::Expr, _: Span, _: ast::NodeId) { }\n     fn check_trait_item(&mut self, _: &LateContext, _: &hir::TraitItem) { }\n     fn check_trait_item_post(&mut self, _: &LateContext, _: &hir::TraitItem) { }\n     fn check_impl_item(&mut self, _: &LateContext, _: &hir::ImplItem) { }\n@@ -200,9 +200,9 @@ pub trait EarlyLintPass: LintPass {\n     fn check_ty(&mut self, _: &EarlyContext, _: &ast::Ty) { }\n     fn check_generics(&mut self, _: &EarlyContext, _: &ast::Generics) { }\n     fn check_fn(&mut self, _: &EarlyContext,\n-        _: ast_visit::FnKind, _: &ast::FnDecl, _: &ast::Block, _: Span, _: ast::NodeId) { }\n+        _: ast_visit::FnKind, _: &ast::FnDecl, _: Span, _: ast::NodeId) { }\n     fn check_fn_post(&mut self, _: &EarlyContext,\n-        _: ast_visit::FnKind, _: &ast::FnDecl, _: &ast::Block, _: Span, _: ast::NodeId) { }\n+        _: ast_visit::FnKind, _: &ast::FnDecl, _: Span, _: ast::NodeId) { }\n     fn check_trait_item(&mut self, _: &EarlyContext, _: &ast::TraitItem) { }\n     fn check_trait_item_post(&mut self, _: &EarlyContext, _: &ast::TraitItem) { }\n     fn check_impl_item(&mut self, _: &EarlyContext, _: &ast::ImplItem) { }"}, {"sha": "1ec3d0db8e0aa3a4a57efcc6371a48a70d1c4b75", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -498,7 +498,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n //                                ^^^^^^^^^^^^^ only needed for pretty printing\n-    pub fn propagate(&mut self, cfg: &cfg::CFG, blk: &hir::Block) {\n+    pub fn propagate(&mut self, cfg: &cfg::CFG, body: &hir::Expr) {\n         //! Performs the data flow analysis.\n \n         if self.bits_per_id == 0 {\n@@ -524,17 +524,17 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n         debug!(\"Dataflow result for {}:\", self.analysis_name);\n         debug!(\"{}\", {\n             let mut v = Vec::new();\n-            self.pretty_print_to(box &mut v, blk).unwrap();\n+            self.pretty_print_to(box &mut v, body).unwrap();\n             String::from_utf8(v).unwrap()\n         });\n     }\n \n     fn pretty_print_to<'b>(&self, wr: Box<io::Write + 'b>,\n-                           blk: &hir::Block) -> io::Result<()> {\n+                           body: &hir::Expr) -> io::Result<()> {\n         let mut ps = pprust::rust_printer_annotated(wr, self, None);\n         ps.cbox(pprust::indent_unit)?;\n         ps.ibox(0)?;\n-        ps.print_block(blk)?;\n+        ps.print_expr(body)?;\n         pp::eof(&mut ps.s)\n     }\n }"}, {"sha": "23fc5911259dc920685fa5b65364afe2d62678ef", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -566,7 +566,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n                     self.warn_dead_code(impl_item.id, impl_item.span,\n                                         impl_item.name, \"method\");\n                 }\n-                intravisit::walk_block(self, body)\n+                intravisit::walk_expr(self, body)\n             }\n             hir::ImplItemKind::Type(..) => {}\n         }\n@@ -575,11 +575,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n     // Overwrite so that we don't warn the trait item itself.\n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n         match trait_item.node {\n-            hir::ConstTraitItem(_, Some(ref expr)) => {\n-                intravisit::walk_expr(self, expr)\n-            }\n+            hir::ConstTraitItem(_, Some(ref body))|\n             hir::MethodTraitItem(_, Some(ref body)) => {\n-                intravisit::walk_block(self, body)\n+                intravisit::walk_expr(self, body)\n             }\n             hir::ConstTraitItem(_, None) |\n             hir::MethodTraitItem(_, None) |"}, {"sha": "5634e2012c971209c9d0afbce238f3ddcb6cfaa3", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -94,7 +94,7 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n     fn visit_fn(&mut self, fn_kind: FnKind<'v>, fn_decl: &'v hir::FnDecl,\n-                block: &'v hir::Block, span: Span, id: ast::NodeId) {\n+                block: &'v hir::Expr, span: Span, id: ast::NodeId) {\n \n         let (is_item_fn, is_unsafe_fn) = match fn_kind {\n             FnKind::ItemFn(_, _, unsafety, ..) =>"}, {"sha": "231da576f2b99d8f821a1d2aeed6480fac018a05", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -290,14 +290,14 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n     pub fn walk_fn(&mut self,\n                    decl: &hir::FnDecl,\n-                   body: &hir::Block) {\n+                   body: &hir::Expr) {\n         self.walk_arg_patterns(decl, body);\n-        self.walk_block(body);\n+        self.consume_expr(body);\n     }\n \n     fn walk_arg_patterns(&mut self,\n                          decl: &hir::FnDecl,\n-                         body: &hir::Block) {\n+                         body: &hir::Expr) {\n         for arg in &decl.inputs {\n             let arg_ty = return_if_err!(self.mc.infcx.node_ty(arg.pat.id));\n "}, {"sha": "7dbf9aa74144d4a4254aba531afbde1ca8ab4cb1", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -144,7 +144,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Block, s: Span, id: ast::NodeId) {\n+                b: &'v hir::Expr, s: Span, id: ast::NodeId) {\n         if let FnKind::Closure(..) = fk {\n             span_bug!(s, \"intrinsicck: closure outside of function\")\n         }"}, {"sha": "a654d65bc67961af65392e9a8abf56b26f921555", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 22, "deletions": 71, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -123,10 +123,9 @@ use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n use syntax::ast::{self, NodeId};\n-use syntax::codemap::original_sp;\n use syntax::parse::token::keywords;\n use syntax::ptr::P;\n-use syntax_pos::{BytePos, Span};\n+use syntax_pos::Span;\n \n use hir::Expr;\n use hir;\n@@ -187,7 +186,7 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt) -> String {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for IrMaps<'a, 'tcx> {\n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Block, s: Span, id: NodeId) {\n+                b: &'v hir::Expr, s: Span, id: NodeId) {\n         visit_fn(self, fk, fd, b, s, id);\n     }\n     fn visit_local(&mut self, l: &hir::Local) { visit_local(self, l); }\n@@ -352,9 +351,9 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for Liveness<'a, 'tcx> {\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Block, s: Span, n: NodeId) {\n-        check_fn(self, fk, fd, b, s, n);\n+    fn visit_fn(&mut self, _: FnKind<'v>, _: &'v hir::FnDecl,\n+                _: &'v hir::Expr, _: Span, _: NodeId) {\n+        // do not check contents of nested fns\n     }\n     fn visit_local(&mut self, l: &hir::Local) {\n         check_local(self, l);\n@@ -370,7 +369,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Liveness<'a, 'tcx> {\n fn visit_fn(ir: &mut IrMaps,\n             fk: FnKind,\n             decl: &hir::FnDecl,\n-            body: &hir::Block,\n+            body: &hir::Expr,\n             sp: Span,\n             id: ast::NodeId) {\n     debug!(\"visit_fn\");\n@@ -405,10 +404,10 @@ fn visit_fn(ir: &mut IrMaps,\n \n     // compute liveness\n     let mut lsets = Liveness::new(&mut fn_maps, specials);\n-    let entry_ln = lsets.compute(decl, body);\n+    let entry_ln = lsets.compute(body);\n \n     // check for various error conditions\n-    lsets.visit_block(body);\n+    lsets.visit_expr(body);\n     lsets.check_ret(id, sp, fk, entry_ln, body);\n     lsets.warn_about_unused_args(decl, entry_ln);\n }\n@@ -821,17 +820,23 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     // _______________________________________________________________________\n \n-    fn compute(&mut self, decl: &hir::FnDecl, body: &hir::Block) -> LiveNode {\n+    fn compute(&mut self, body: &hir::Expr) -> LiveNode {\n         // if there is a `break` or `again` at the top level, then it's\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n \n-        debug!(\"compute: using id for block, {}\", block_to_string(body));\n+        debug!(\"compute: using id for body, {}\", expr_to_string(body));\n \n         let exit_ln = self.s.exit_ln;\n-        let entry_ln: LiveNode =\n-            self.with_loop_nodes(body.id, exit_ln, exit_ln,\n-              |this| this.propagate_through_fn_block(decl, body));\n+        let entry_ln: LiveNode = self.with_loop_nodes(body.id, exit_ln, exit_ln, |this| {\n+            // the fallthrough exit is only for those cases where we do not\n+            // explicitly return:\n+            let s = this.s;\n+            this.init_from_succ(s.fallthrough_ln, s.exit_ln);\n+            this.acc(s.fallthrough_ln, s.clean_exit_var, ACC_READ);\n+\n+            this.propagate_through_expr(body, s.fallthrough_ln)\n+        });\n \n         // hack to skip the loop unless debug! is enabled:\n         debug!(\"^^ liveness computation results for body {} (entry={:?})\",\n@@ -846,20 +851,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         entry_ln\n     }\n \n-    fn propagate_through_fn_block(&mut self, _: &hir::FnDecl, blk: &hir::Block)\n-                                  -> LiveNode {\n-        // the fallthrough exit is only for those cases where we do not\n-        // explicitly return:\n-        let s = self.s;\n-        self.init_from_succ(s.fallthrough_ln, s.exit_ln);\n-        if blk.expr.is_none() {\n-            self.acc(s.fallthrough_ln, s.no_ret_var, ACC_READ)\n-        }\n-        self.acc(s.fallthrough_ln, s.clean_exit_var, ACC_READ);\n-\n-        self.propagate_through_block(blk, s.fallthrough_ln)\n-    }\n-\n     fn propagate_through_block(&mut self, blk: &hir::Block, succ: LiveNode)\n                                -> LiveNode {\n         let succ = self.propagate_through_opt_expr(blk.expr.as_ref().map(|e| &**e), succ);\n@@ -1448,15 +1439,6 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n     }\n }\n \n-fn check_fn(_v: &Liveness,\n-            _fk: FnKind,\n-            _decl: &hir::FnDecl,\n-            _body: &hir::Block,\n-            _sp: Span,\n-            _id: NodeId) {\n-    // do not check contents of nested fns\n-}\n-\n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn fn_ret(&self, id: NodeId) -> ty::Binder<Ty<'tcx>> {\n         let fn_ty = self.ir.tcx.tables().node_id_to_type(id);\n@@ -1472,7 +1454,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                  sp: Span,\n                  _fk: FnKind,\n                  entry_ln: LiveNode,\n-                 body: &hir::Block)\n+                 body: &hir::Expr)\n     {\n         // within the fn body, late-bound regions are liberated\n         // and must outlive the *call-site* of the function.\n@@ -1481,13 +1463,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 self.ir.tcx.region_maps.call_site_extent(id, body.id),\n                 &self.fn_ret(id));\n \n-        if fn_ret.is_never() {\n-            // FIXME(durka) this rejects code like `fn foo(x: !) -> ! { x }`\n-            if self.live_on_entry(entry_ln, self.s.clean_exit_var).is_some() {\n-                span_err!(self.ir.tcx.sess, sp, E0270,\n-                          \"computation may converge in a function marked as diverging\");\n-            }\n-        } else if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n+        if !fn_ret.is_never() && self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n             let param_env = ParameterEnvironment::for_item(self.ir.tcx, id);\n             let t_ret_subst = fn_ret.subst(self.ir.tcx, &param_env.free_substs);\n             let is_nil = self.ir.tcx.infer_ctxt(None, Some(param_env),\n@@ -1498,32 +1474,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             // for nil return types, it is ok to not return a value expl.\n             if !is_nil {\n-                let ends_with_stmt = match body.expr {\n-                    None if !body.stmts.is_empty() =>\n-                        match body.stmts.last().unwrap().node {\n-                            hir::StmtSemi(ref e, _) => {\n-                                self.ir.tcx.tables().expr_ty(&e) == fn_ret\n-                            },\n-                            _ => false\n-                        },\n-                    _ => false\n-                };\n-                let mut err = struct_span_err!(self.ir.tcx.sess,\n-                                               sp,\n-                                               E0269,\n-                                               \"not all control paths return a value\");\n-                if ends_with_stmt {\n-                    let last_stmt = body.stmts.last().unwrap();\n-                    let original_span = original_sp(self.ir.tcx.sess.codemap(),\n-                                                    last_stmt.span, sp);\n-                    let span_semicolon = Span {\n-                        lo: original_span.hi - BytePos(1),\n-                        hi: original_span.hi,\n-                        expn_id: original_span.expn_id\n-                    };\n-                    err.span_help(span_semicolon, \"consider removing this semicolon:\");\n-                }\n-                err.emit();\n+                span_bug!(sp, \"not all control paths return a value\");\n             }\n         }\n     }"}, {"sha": "7868e700f2701c0c03cb1e2ed6005d83aa4dba12", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -248,9 +248,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         match *node {\n             ast_map::NodeItem(item) => {\n                 match item.node {\n-                    hir::ItemFn(.., ref search_block) => {\n+                    hir::ItemFn(.., ref body) => {\n                         if item_might_be_inlined(&item) {\n-                            intravisit::walk_block(self, &search_block)\n+                            self.visit_expr(body);\n                         }\n                     }\n \n@@ -278,11 +278,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::MethodTraitItem(_, None) => {\n                         // Keep going, nothing to get exported\n                     }\n-                    hir::ConstTraitItem(_, Some(ref expr)) => {\n-                        self.visit_expr(&expr);\n-                    }\n+                    hir::ConstTraitItem(_, Some(ref body)) |\n                     hir::MethodTraitItem(_, Some(ref body)) => {\n-                        intravisit::walk_block(self, body);\n+                        self.visit_expr(body);\n                     }\n                     hir::TypeTraitItem(..) => {}\n                 }\n@@ -295,7 +293,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ImplItemKind::Method(ref sig, ref body) => {\n                         let did = self.tcx.map.get_parent_did(search_item);\n                         if method_might_be_inlined(self.tcx, sig, impl_item, did) {\n-                            intravisit::walk_block(self, body)\n+                            self.visit_expr(body)\n                         }\n                     }\n                     hir::ImplItemKind::Type(_) => {}"}, {"sha": "34a6a547d9440fb84a391ff851152b6fb3602e61", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -490,12 +490,7 @@ impl RegionMaps {\n         // if there's one. Static items, for instance, won't\n         // have an enclosing scope, hence no scope will be\n         // returned.\n-        let expr_extent = self.node_extent(expr_id);\n-        // For some reason, the expr's scope itself is skipped here.\n-        let mut id = match scope_map[expr_extent.0 as usize].into_option() {\n-            Some(i) => i,\n-            _ => return None\n-        };\n+        let mut id = self.node_extent(expr_id);\n \n         while let Some(p) = scope_map[id.0 as usize].into_option() {\n             match code_extents[p.0 as usize] {\n@@ -1086,7 +1081,7 @@ fn resolve_item(visitor: &mut RegionResolutionVisitor, item: &hir::Item) {\n fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n               kind: FnKind,\n               decl: &hir::FnDecl,\n-              body: &hir::Block,\n+              body: &hir::Expr,\n               sp: Span,\n               id: ast::NodeId) {\n     debug!(\"region::resolve_fn(id={:?}, \\\n@@ -1128,7 +1123,7 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n         parent: fn_decl_scope,\n         var_parent: fn_decl_scope\n     };\n-    visitor.visit_block(body);\n+    visitor.visit_expr(body);\n \n     // Restore context we had at the start.\n     visitor.cx = outer_cx;\n@@ -1191,7 +1186,7 @@ impl<'a, 'v> Visitor<'v> for RegionResolutionVisitor<'a> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl,\n-                b: &'v Block, s: Span, n: NodeId) {\n+                b: &'v Expr, s: Span, n: NodeId) {\n         resolve_fn(self, fk, fd, b, s, n);\n     }\n     fn visit_arm(&mut self, a: &Arm) {"}, {"sha": "292d9592ceb0cf0bc60a978e49d95244397760f8", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -202,7 +202,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'v>, decl: &'v hir::FnDecl,\n-                b: &'v hir::Block, s: Span, fn_id: ast::NodeId) {\n+                b: &'v hir::Expr, s: Span, fn_id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(_, generics, ..) => {\n                 self.visit_early_late(fn_id,decl, generics, |this| {\n@@ -403,7 +403,7 @@ fn signal_shadowing_problem(sess: &Session, name: ast::Name, orig: Original, sha\n \n // Adds all labels in `b` to `ctxt.labels_in_fn`, signalling a warning\n // if one of the label shadows a lifetime or another label.\n-fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Block) {\n+fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Expr) {\n     struct GatherLabels<'a> {\n         sess: &'a Session,\n         scope: Scope<'a>,\n@@ -415,7 +415,7 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Block) {\n         scope: ctxt.scope,\n         labels_in_fn: &mut ctxt.labels_in_fn,\n     };\n-    gather.visit_block(b);\n+    gather.visit_expr(b);\n     return;\n \n     impl<'v, 'a> Visitor<'v> for GatherLabels<'a> {\n@@ -493,7 +493,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn add_scope_and_walk_fn<'b>(&mut self,\n                                  fk: FnKind,\n                                  fd: &hir::FnDecl,\n-                                 fb: &'b hir::Block,\n+                                 fb: &'b hir::Expr,\n                                  _span: Span,\n                                  fn_id: ast::NodeId) {\n \n@@ -516,7 +516,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         extract_labels(self, fb);\n \n         self.with(FnScope { fn_id: fn_id, body_id: fb.id, s: self.scope },\n-                  |_old_scope, this| this.visit_block(fb))\n+                  |_old_scope, this| this.visit_expr(fb))\n     }\n \n     fn with<F>(&mut self, wrap_scope: ScopeChain, f: F) where"}, {"sha": "5ed628d7dcae5f8be847efa4e5c71043bfd67c3f", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -190,7 +190,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                      all_loans: &[Loan<'tcx>],\n                                      fn_id: ast::NodeId,\n                                      decl: &hir::FnDecl,\n-                                     body: &hir::Block) {\n+                                     body: &hir::Expr) {\n     debug!(\"check_loans(body id={})\", body.id);\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);"}, {"sha": "8f2afa7f808227d1f2eef48a54505112c7c9db01", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -42,7 +42,7 @@ mod move_error;\n pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                     fn_id: NodeId,\n                                     decl: &hir::FnDecl,\n-                                    body: &hir::Block)\n+                                    body: &hir::Expr)\n                                     -> (Vec<Loan<'tcx>>,\n                                         move_data::MoveData<'tcx>) {\n     let mut glcx = GatherLoanCtxt {"}, {"sha": "836832de5b9c40f52d55daba45721962135764a7", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -58,7 +58,7 @@ pub struct MoveDataParamEnv<'tcx> {\n pub fn borrowck_mir(bcx: &mut BorrowckCtxt,\n                     fk: FnKind,\n                     _decl: &hir::FnDecl,\n-                    body: &hir::Block,\n+                    body: &hir::Expr,\n                     _sp: Span,\n                     id: ast::NodeId,\n                     attributes: &[ast::Attribute]) {"}, {"sha": "fb842f70a54a15bc71e68829d326f53704607bd2", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -47,9 +47,7 @@ use syntax_pos::{MultiSpan, Span};\n use errors::DiagnosticBuilder;\n \n use rustc::hir;\n-use rustc::hir::{FnDecl, Block};\n-use rustc::hir::intravisit;\n-use rustc::hir::intravisit::{Visitor, FnKind};\n+use rustc::hir::intravisit::{self, Visitor, FnKind};\n \n pub mod check_loans;\n \n@@ -65,8 +63,8 @@ pub struct LoanDataFlowOperator;\n pub type LoanDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, LoanDataFlowOperator>;\n \n impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl,\n-                b: &'v Block, s: Span, id: ast::NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n+                b: &'v hir::Expr, s: Span, id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(..) |\n             FnKind::Method(..) => {\n@@ -159,7 +157,7 @@ pub struct AnalysisData<'a, 'tcx: 'a> {\n fn borrowck_fn(this: &mut BorrowckCtxt,\n                fk: FnKind,\n                decl: &hir::FnDecl,\n-               body: &hir::Block,\n+               body: &hir::Expr,\n                sp: Span,\n                id: ast::NodeId,\n                attributes: &[ast::Attribute]) {\n@@ -200,7 +198,7 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                                           fk: FnKind,\n                                           decl: &hir::FnDecl,\n                                           cfg: &cfg::CFG,\n-                                          body: &hir::Block,\n+                                          body: &hir::Expr,\n                                           sp: Span,\n                                           id: ast::NodeId)\n                                           -> AnalysisData<'a, 'tcx>"}, {"sha": "32bda5e11620ac2429a3dd22be4257b4dc18adf4", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -656,7 +656,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n                cfg: &cfg::CFG,\n                id_range: IdRange,\n                decl: &hir::FnDecl,\n-               body: &hir::Block)\n+               body: &hir::Expr)\n                -> FlowedMoveData<'a, 'tcx> {\n         let mut dfcx_moves =\n             DataFlowContext::new(tcx,"}, {"sha": "e0e8a215919217c126c940138e8bf06278c1b85c", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -65,7 +65,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for OuterVisitor<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Block, s: Span, id: ast::NodeId) {\n+                b: &'v hir::Expr, s: Span, id: ast::NodeId) {\n         if let FnKind::Closure(..) = fk {\n             span_bug!(s, \"check_match: closure outside of function\")\n         }\n@@ -113,7 +113,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MatchVisitor<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Block, s: Span, n: ast::NodeId) {\n+                b: &'v hir::Expr, s: Span, n: ast::NodeId) {\n         intravisit::walk_fn(self, fk, fd, b, s, n);\n \n         for input in &fd.inputs {"}, {"sha": "5f0c94744a1185f78b63246241a8c395fec2d734", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -857,11 +857,10 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n               callee => signal!(e, CallOn(callee)),\n           };\n           let (decl, result) = if let Some(fn_like) = lookup_const_fn_by_id(tcx, did) {\n-              (fn_like.decl(), &fn_like.body().expr)\n+              (fn_like.decl(), fn_like.body())\n           } else {\n               signal!(e, NonConstPath)\n           };\n-          let result = result.as_ref().expect(\"const fn has no result expression\");\n           assert_eq!(decl.inputs.len(), args.len());\n \n           let mut call_args = DefIdMap();"}, {"sha": "7e60c40220f84eed8acb55dac747dc42f71be9c6", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -455,8 +455,6 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n             1 => panic!(\"make_input should have provided valid inputs\"),\n             _ => early_error(sopts.error_format, \"multiple input filenames provided\"),\n         }\n-\n-        None\n     }\n \n     fn late_callback(&mut self,"}, {"sha": "ecbf28c1082f989e2e58f19d2065efe38095e6ea", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -701,8 +701,8 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n                                        mut out: W)\n                                        -> io::Result<()> {\n     let cfg = match code {\n-        blocks::BlockCode(block) => cfg::CFG::new(tcx, &block),\n-        blocks::FnLikeCode(fn_like) => cfg::CFG::new(tcx, &fn_like.body()),\n+        blocks::Code::Expr(expr) => cfg::CFG::new(tcx, expr),\n+        blocks::Code::FnLike(fn_like) => cfg::CFG::new(tcx, fn_like.body()),\n     };\n     let labelled_edges = mode != PpFlowGraphMode::UnlabelledEdges;\n     let lcfg = LabelledCFG {\n@@ -717,12 +717,12 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n             let r = dot::render(&lcfg, &mut out);\n             return expand_err_details(r);\n         }\n-        blocks::BlockCode(_) => {\n+        blocks::Code::Expr(_) => {\n             tcx.sess.err(\"--pretty flowgraph with -Z flowgraph-print annotations requires \\\n                           fn-like node id.\");\n             return Ok(());\n         }\n-        blocks::FnLikeCode(fn_like) => {\n+        blocks::Code::FnLike(fn_like) => {\n             let (bccx, analysis_data) =\n                 borrowck::build_borrowck_dataflow_data_for_fn(tcx, fn_like.to_fn_parts(), &cfg);\n \n@@ -990,8 +990,7 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                     tcx.sess.fatal(&format!(\"--pretty flowgraph couldn't find id: {}\", nodeid))\n                 });\n \n-                let code = blocks::Code::from_node(node);\n-                match code {\n+                match blocks::Code::from_node(&tcx.map, nodeid) {\n                     Some(code) => {\n                         let variants = gather_flowgraph_variants(tcx.sess);\n "}, {"sha": "6320a923d690c720004d972187252c76e93729e7", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -250,7 +250,7 @@ impl LateLintPass for NonSnakeCase {\n                 cx: &LateContext,\n                 fk: FnKind,\n                 _: &hir::FnDecl,\n-                _: &hir::Block,\n+                _: &hir::Expr,\n                 span: Span,\n                 id: ast::NodeId) {\n         match fk {"}, {"sha": "c19b3c40f65c09ad40481e33cdc2ad429e32ead0", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -222,7 +222,7 @@ impl LateLintPass for UnsafeCode {\n                 cx: &LateContext,\n                 fk: FnKind,\n                 _: &hir::FnDecl,\n-                _: &hir::Block,\n+                _: &hir::Expr,\n                 span: Span,\n                 _: ast::NodeId) {\n         match fk {\n@@ -812,7 +812,7 @@ impl LateLintPass for UnconditionalRecursion {\n                 cx: &LateContext,\n                 fn_kind: FnKind,\n                 _: &hir::FnDecl,\n-                blk: &hir::Block,\n+                blk: &hir::Expr,\n                 sp: Span,\n                 id: ast::NodeId) {\n         let method = match fn_kind {"}, {"sha": "0668d362037dd3450a3f98c37086cde0f35b1eba", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -99,7 +99,7 @@ impl LateLintPass for UnusedMut {\n                 cx: &LateContext,\n                 _: FnKind,\n                 decl: &hir::FnDecl,\n-                _: &hir::Block,\n+                _: &hir::Expr,\n                 _: Span,\n                 _: ast::NodeId) {\n         for a in &decl.inputs {"}, {"sha": "902798ec980061fe0bcfdf6276b45b7bbd65dd77", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -156,7 +156,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                        fn_id: ast::NodeId,\n                                        arguments: A,\n                                        return_ty: Ty<'gcx>,\n-                                       ast_block: &'gcx hir::Block)\n+                                       ast_body: &'gcx hir::Expr)\n                                        -> (Mir<'tcx>, ScopeAuxiliaryVec)\n     where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n {\n@@ -166,7 +166,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let span = tcx.map.span(fn_id);\n     let mut builder = Builder::new(hir, span, arguments.len(), return_ty);\n \n-    let body_id = ast_block.id;\n+    let body_id = ast_body.id;\n     let call_site_extent =\n         tcx.region_maps.lookup_code_extent(\n             CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body_id });\n@@ -176,7 +176,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let mut block = START_BLOCK;\n     unpack!(block = builder.in_scope(call_site_extent, block, |builder| {\n         unpack!(block = builder.in_scope(arg_extent, block, |builder| {\n-            builder.args_and_body(block, return_ty, &arguments, arg_extent, ast_block)\n+            builder.args_and_body(block, &arguments, arg_extent, ast_body)\n         }));\n         // Attribute epilogue to function's closing brace\n         let fn_end = Span { lo: span.hi, ..span };\n@@ -310,10 +310,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn args_and_body(&mut self,\n                      mut block: BasicBlock,\n-                     return_ty: Ty<'tcx>,\n                      arguments: &[(Ty<'gcx>, Option<&'gcx hir::Pat>)],\n                      argument_extent: CodeExtent,\n-                     ast_block: &'gcx hir::Block)\n+                     ast_body: &'gcx hir::Expr)\n                      -> BlockAnd<()>\n     {\n         // Allocate locals for the function arguments\n@@ -342,12 +341,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             if let Some(pattern) = pattern {\n                 let pattern = Pattern::from_hir(self.hir.tcx(), pattern);\n-                scope = self.declare_bindings(scope, ast_block.span, &pattern);\n+                scope = self.declare_bindings(scope, ast_body.span, &pattern);\n                 unpack!(block = self.lvalue_into_pattern(block, pattern, &lvalue));\n             }\n \n             // Make sure we drop (parts of) the argument even when not matched on.\n-            self.schedule_drop(pattern.as_ref().map_or(ast_block.span, |pat| pat.span),\n+            self.schedule_drop(pattern.as_ref().map_or(ast_body.span, |pat| pat.span),\n                                argument_extent, &lvalue, ty);\n \n         }\n@@ -357,13 +356,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             self.visibility_scope = visibility_scope;\n         }\n \n-        // FIXME(#32959): temporary hack for the issue at hand\n-        let return_is_unit = return_ty.is_nil();\n-        // start the first basic block and translate the body\n-        unpack!(block = self.ast_block(&Lvalue::Local(RETURN_POINTER),\n-                return_is_unit, block, ast_block));\n-\n-        block.unit()\n+        let body = self.hir.mirror(ast_body);\n+        self.into(&Lvalue::Local(RETURN_POINTER), block, body)\n     }\n \n     fn get_unit_temp(&mut self) -> Lvalue<'tcx> {"}, {"sha": "af2f9adfc9a8ccc77aa9c4909ae2f789627db8a1", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -209,7 +209,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     fn visit_fn(&mut self,\n                 fk: FnKind<'tcx>,\n                 decl: &'tcx hir::FnDecl,\n-                body: &'tcx hir::Block,\n+                body: &'tcx hir::Expr,\n                 span: Span,\n                 id: ast::NodeId) {\n         // fetch the fully liberated fn signature (that is, all bound"}, {"sha": "02a0b3ab28d622026e73f87f912a7e92d0ad4ab6", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -134,7 +134,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     fn fn_like(&mut self,\n                fk: FnKind,\n                fd: &hir::FnDecl,\n-               b: &hir::Block,\n+               b: &hir::Expr,\n                s: Span,\n                fn_id: ast::NodeId)\n                -> ConstQualif {\n@@ -265,7 +265,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n     fn visit_fn(&mut self,\n                 fk: FnKind<'v>,\n                 fd: &'v hir::FnDecl,\n-                b: &'v hir::Block,\n+                b: &'v hir::Expr,\n                 s: Span,\n                 fn_id: ast::NodeId) {\n         self.fn_like(fk, fd, b, s, fn_id);"}, {"sha": "417987d9664e0f3533e651fa0d9e74b4e92db517", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -164,7 +164,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     fn visit_fn(&mut self,\n                 fk: hir_visit::FnKind<'v>,\n                 fd: &'v hir::FnDecl,\n-                b: &'v hir::Block,\n+                b: &'v hir::Expr,\n                 s: Span,\n                 id: NodeId) {\n         self.record(\"FnDecl\", Id::None, fd);\n@@ -295,11 +295,10 @@ impl<'v> ast_visit::Visitor for StatCollector<'v> {\n     fn visit_fn(&mut self,\n                 fk: ast_visit::FnKind,\n                 fd: &ast::FnDecl,\n-                b: &ast::Block,\n                 s: Span,\n                 _: NodeId) {\n         self.record(\"FnDecl\", Id::None, fd);\n-        ast_visit::walk_fn(self, fk, fd, b, s)\n+        ast_visit::walk_fn(self, fk, fd, s)\n     }\n \n     fn visit_trait_item(&mut self, ti: &ast::TraitItem) {"}, {"sha": "e58cd893819339636d12191b447389d37fcc862b", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -54,7 +54,7 @@ impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n                 self.with_context(Loop, |v| v.visit_block(&b));\n             }\n             hir::ExprClosure(.., ref b, _) => {\n-                self.with_context(Closure, |v| v.visit_block(&b));\n+                self.with_context(Closure, |v| v.visit_expr(&b));\n             }\n             hir::ExprBreak(_) => self.require_loop(\"break\", e.span),\n             hir::ExprAgain(_) => self.require_loop(\"continue\", e.span),"}, {"sha": "d55ce4c356384618062967a8f35089f8131f343b", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -35,7 +35,7 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n     fn visit_fn(&mut self,\n                 fk: intravisit::FnKind<'v>,\n                 fd: &'v hir::FnDecl,\n-                b: &'v hir::Block,\n+                b: &'v hir::Expr,\n                 s: Span,\n                 fn_id: ast::NodeId) {\n         // FIXME (@jroesch) change this to be an inference context"}, {"sha": "664efc27fbb53045326c491938e7f334f4047d46", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -596,21 +596,52 @@ impl<'a> Visitor for Resolver<'a> {\n     fn visit_fn(&mut self,\n                 function_kind: FnKind,\n                 declaration: &FnDecl,\n-                block: &Block,\n                 _: Span,\n                 node_id: NodeId) {\n         let rib_kind = match function_kind {\n             FnKind::ItemFn(_, generics, ..) => {\n                 self.visit_generics(generics);\n                 ItemRibKind\n             }\n-            FnKind::Method(_, sig, _) => {\n+            FnKind::Method(_, sig, _, _) => {\n                 self.visit_generics(&sig.generics);\n                 MethodRibKind(!sig.decl.has_self())\n             }\n-            FnKind::Closure => ClosureRibKind(node_id),\n+            FnKind::Closure(_) => ClosureRibKind(node_id),\n         };\n-        self.resolve_function(rib_kind, declaration, block);\n+\n+        // Create a value rib for the function.\n+        self.value_ribs.push(Rib::new(rib_kind));\n+\n+        // Create a label rib for the function.\n+        self.label_ribs.push(Rib::new(rib_kind));\n+\n+        // Add each argument to the rib.\n+        let mut bindings_list = FxHashMap();\n+        for argument in &declaration.inputs {\n+            self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n+\n+            self.visit_ty(&argument.ty);\n+\n+            debug!(\"(resolving function) recorded argument\");\n+        }\n+        visit::walk_fn_ret_ty(self, &declaration.output);\n+\n+        // Resolve the function body.\n+        match function_kind {\n+            FnKind::ItemFn(.., body) |\n+            FnKind::Method(.., body) => {\n+                self.visit_block(body);\n+            }\n+            FnKind::Closure(body) => {\n+                self.visit_expr(body);\n+            }\n+        };\n+\n+        debug!(\"(resolving function) leaving function\");\n+\n+        self.label_ribs.pop();\n+        self.value_ribs.pop();\n     }\n }\n \n@@ -1856,36 +1887,6 @@ impl<'a> Resolver<'a> {\n         self.value_ribs.pop();\n     }\n \n-    fn resolve_function(&mut self,\n-                        rib_kind: RibKind<'a>,\n-                        declaration: &FnDecl,\n-                        block: &Block) {\n-        // Create a value rib for the function.\n-        self.value_ribs.push(Rib::new(rib_kind));\n-\n-        // Create a label rib for the function.\n-        self.label_ribs.push(Rib::new(rib_kind));\n-\n-        // Add each argument to the rib.\n-        let mut bindings_list = FxHashMap();\n-        for argument in &declaration.inputs {\n-            self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n-\n-            self.visit_ty(&argument.ty);\n-\n-            debug!(\"(resolving function) recorded argument\");\n-        }\n-        visit::walk_fn_ret_ty(self, &declaration.output);\n-\n-        // Resolve the function body.\n-        self.visit_block(block);\n-\n-        debug!(\"(resolving function) leaving function\");\n-\n-        self.label_ribs.pop();\n-        self.value_ribs.pop();\n-    }\n-\n     fn resolve_trait_reference(&mut self,\n                                id: NodeId,\n                                trait_path: &Path,"}, {"sha": "36c6a6760137f20f1c20ffac98461a311406b541", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -1412,7 +1412,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                 }\n \n                 // walk the body\n-                self.nest(ex.id, |v| v.visit_block(&body));\n+                self.nest(ex.id, |v| v.visit_expr(body));\n             }\n             ast::ExprKind::ForLoop(ref pattern, ref subexpression, ref block, _) |\n             ast::ExprKind::WhileLet(ref pattern, ref subexpression, ref block, _) => {"}, {"sha": "ca630624cdb3889aafc18b40fce0b4e1b2ccc8af", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -13,7 +13,7 @@ use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::infer::{self, InferOk, TypeOrigin};\n use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n-use check::{FnCtxt, Expectation};\n+use check::{FnCtxt, Expectation, Diverges};\n use util::nodemap::FxHashMap;\n \n use std::collections::hash_map::Entry::{Occupied, Vacant};\n@@ -360,9 +360,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n         true\n     }\n-}\n \n-impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_match(&self,\n                        expr: &'gcx hir::Expr,\n                        discrim: &'gcx hir::Expr,\n@@ -390,14 +388,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             discrim_ty = self.next_ty_var();\n             self.check_expr_has_type(discrim, discrim_ty);\n         };\n+        let discrim_diverges = self.diverges.get();\n+        self.diverges.set(Diverges::Maybe);\n \n         // Typecheck the patterns first, so that we get types for all the\n         // bindings.\n-        for arm in arms {\n+        let all_arm_pats_diverge: Vec<_> = arms.iter().map(|arm| {\n+            let mut all_pats_diverge = Diverges::WarnedAlways;\n             for p in &arm.pats {\n+                self.diverges.set(Diverges::Maybe);\n                 self.check_pat(&p, discrim_ty);\n+                all_pats_diverge &= self.diverges.get();\n             }\n-        }\n+            all_pats_diverge\n+        }).collect();\n \n         // Now typecheck the blocks.\n         //\n@@ -410,6 +414,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // type in that case)\n         let expected = expected.adjust_for_branches(self);\n         let mut result_ty = self.next_diverging_ty_var();\n+        let mut all_arms_diverge = Diverges::WarnedAlways;\n         let coerce_first = match expected {\n             // We don't coerce to `()` so that if the match expression is a\n             // statement it's branches can have any consistent type. That allows\n@@ -422,11 +427,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => result_ty\n         };\n \n-        for (i, arm) in arms.iter().enumerate() {\n+        for (i, (arm, pats_diverge)) in arms.iter().zip(all_arm_pats_diverge).enumerate() {\n             if let Some(ref e) = arm.guard {\n+                self.diverges.set(pats_diverge);\n                 self.check_expr_has_type(e, tcx.types.bool);\n             }\n+\n+            self.diverges.set(pats_diverge);\n             let arm_ty = self.check_expr_with_expectation(&arm.body, expected);\n+            all_arms_diverge &= self.diverges.get();\n \n             if result_ty.references_error() || arm_ty.references_error() {\n                 result_ty = tcx.types.err;\n@@ -476,11 +485,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n         }\n \n+        // We won't diverge unless the discriminant or all arms diverge.\n+        self.diverges.set(discrim_diverges | all_arms_diverge);\n+\n         result_ty\n     }\n-}\n \n-impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_pat_struct(&self,\n                         pat: &'gcx hir::Pat,\n                         path: &hir::Path,"}, {"sha": "af834f3f84d4775c986801a0325e855adecd4716", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -23,7 +23,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               expr: &hir::Expr,\n                               _capture: hir::CaptureClause,\n                               decl: &'gcx hir::FnDecl,\n-                              body: &'gcx hir::Block,\n+                              body: &'gcx hir::Expr,\n                               expected: Expectation<'tcx>)\n                               -> Ty<'tcx> {\n         debug!(\"check_expr_closure(expr={:?},expected={:?})\",\n@@ -44,7 +44,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                      expr: &hir::Expr,\n                      opt_kind: Option<ty::ClosureKind>,\n                      decl: &'gcx hir::FnDecl,\n-                     body: &'gcx hir::Block,\n+                     body: &'gcx hir::Expr,\n                      expected_sig: Option<ty::FnSig<'tcx>>)\n                      -> Ty<'tcx> {\n         let expr_def_id = self.tcx.map.local_def_id(expr.id);"}, {"sha": "08242cff112ceee9221179aa6a3bd69987f4cb7a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 298, "deletions": 179, "changes": 477, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -106,17 +106,18 @@ use util::common::{block_query, ErrorReported, indenter, loop_query};\n use util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap};\n \n use std::cell::{Cell, Ref, RefCell};\n+use std::cmp;\n use std::mem::replace;\n-use std::ops::Deref;\n+use std::ops::{self, Deref};\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n-use syntax::codemap::{self, Spanned};\n+use syntax::codemap::{self, original_sp, Spanned};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::parse::token::{self, InternedString, keywords};\n use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n-use syntax_pos::{self, Span};\n+use syntax_pos::{self, BytePos, Span};\n \n use rustc::hir::intravisit::{self, Visitor};\n use rustc::hir::{self, PatKind};\n@@ -351,6 +352,59 @@ impl UnsafetyState {\n     }\n }\n \n+/// Whether a node ever exits normally or not.\n+/// Tracked semi-automatically (through type variables\n+/// marked as diverging), with some manual adjustments\n+/// for control-flow primitives (approximating a CFG).\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n+enum Diverges {\n+    /// Potentially unknown, some cases converge,\n+    /// others require a CFG to determine them.\n+    Maybe,\n+\n+    /// Definitely known to diverge and therefore\n+    /// not reach the next sibling or its parent.\n+    Always,\n+\n+    /// Same as `Always` but with a reachability\n+    /// warning already emitted\n+    WarnedAlways\n+}\n+\n+// Convenience impls for combinig `Diverges`.\n+\n+impl ops::BitAnd for Diverges {\n+    type Output = Self;\n+    fn bitand(self, other: Self) -> Self {\n+        cmp::min(self, other)\n+    }\n+}\n+\n+impl ops::BitOr for Diverges {\n+    type Output = Self;\n+    fn bitor(self, other: Self) -> Self {\n+        cmp::max(self, other)\n+    }\n+}\n+\n+impl ops::BitAndAssign for Diverges {\n+    fn bitand_assign(&mut self, other: Self) {\n+        *self = *self & other;\n+    }\n+}\n+\n+impl ops::BitOrAssign for Diverges {\n+    fn bitor_assign(&mut self, other: Self) {\n+        *self = *self | other;\n+    }\n+}\n+\n+impl Diverges {\n+    fn always(self) -> bool {\n+        self >= Diverges::Always\n+    }\n+}\n+\n #[derive(Clone)]\n pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n@@ -371,6 +425,12 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     ps: RefCell<UnsafetyState>,\n \n+    /// Whether the last checked node can ever exit.\n+    diverges: Cell<Diverges>,\n+\n+    /// Whether any child nodes have any type errors.\n+    has_errors: Cell<bool>,\n+\n     inh: &'a Inherited<'a, 'gcx, 'tcx>,\n }\n \n@@ -534,7 +594,7 @@ pub fn check_drop_impls(ccx: &CrateCtxt) -> CompileResult {\n \n fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            decl: &'tcx hir::FnDecl,\n-                           body: &'tcx hir::Block,\n+                           body: &'tcx hir::Expr,\n                            fn_id: ast::NodeId,\n                            span: Span) {\n     let raw_fty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(fn_id)).ty;\n@@ -558,7 +618,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let fcx = check_fn(&inh, fn_ty.unsafety, fn_id, &fn_sig, decl, fn_id, body);\n \n         fcx.select_all_obligations_and_apply_defaults();\n-        fcx.closure_analyze_fn(body);\n+        fcx.closure_analyze(body);\n         fcx.select_obligations_where_possible();\n         fcx.check_casts();\n         fcx.select_all_obligations_or_error(); // Casts can introduce new obligations.\n@@ -654,7 +714,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n \n     // Don't descend into the bodies of nested closures\n     fn visit_fn(&mut self, _: intravisit::FnKind<'gcx>, _: &'gcx hir::FnDecl,\n-                _: &'gcx hir::Block, _: Span, _: ast::NodeId) { }\n+                _: &'gcx hir::Expr, _: Span, _: ast::NodeId) { }\n }\n \n /// Helper used by check_bare_fn and check_expr_fn. Does the grungy work of checking a function\n@@ -669,7 +729,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                             fn_sig: &ty::FnSig<'tcx>,\n                             decl: &'gcx hir::FnDecl,\n                             fn_id: ast::NodeId,\n-                            body: &'gcx hir::Block)\n+                            body: &'gcx hir::Expr)\n                             -> FnCtxt<'a, 'gcx, 'tcx>\n {\n     let mut fn_sig = fn_sig.clone();\n@@ -709,18 +769,12 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n             fcx.write_ty(input.id, arg_ty);\n         }\n \n-        visit.visit_block(body);\n+        visit.visit_expr(body);\n     }\n \n     inherited.tables.borrow_mut().liberated_fn_sigs.insert(fn_id, fn_sig);\n \n-    // FIXME(aburka) do we need this special case? and should it be is_uninhabited?\n-    let expected = if fcx.ret_ty.is_never() {\n-        NoExpectation\n-    } else {\n-        ExpectHasType(fcx.ret_ty)\n-    };\n-    fcx.check_block_with_expected(body, expected);\n+    fcx.check_expr_coercable_to_type(body, fcx.ret_ty);\n \n     fcx\n }\n@@ -1151,7 +1205,7 @@ fn check_const_with_type<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n         fcx.check_expr_coercable_to_type(expr, expected_type);\n \n         fcx.select_all_obligations_and_apply_defaults();\n-        fcx.closure_analyze_const(expr);\n+        fcx.closure_analyze(expr);\n         fcx.select_obligations_where_possible();\n         fcx.check_casts();\n         fcx.select_all_obligations_or_error();\n@@ -1437,6 +1491,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ret_ty: rty,\n             ps: RefCell::new(UnsafetyState::function(hir::Unsafety::Normal,\n                                                      ast::CRATE_NODE_ID)),\n+            diverges: Cell::new(Diverges::Maybe),\n+            has_errors: Cell::new(false),\n             inh: inh,\n         }\n     }\n@@ -1453,6 +1509,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.sess.err_count() - self.err_count_on_creation\n     }\n \n+    /// Produce warning on the given node, if the current point in the\n+    /// function is unreachable, and there hasn't been another warning.\n+    fn warn_if_unreachable(&self, id: ast::NodeId, span: Span, kind: &str) {\n+        if self.diverges.get() == Diverges::Always {\n+            self.diverges.set(Diverges::WarnedAlways);\n+\n+            self.tcx.sess.add_lint(lint::builtin::UNREACHABLE_CODE,\n+                                   id, span,\n+                                   format!(\"unreachable {}\", kind));\n+        }\n+    }\n+\n     /// Resolves type variables in `ty` if possible. Unlike the infcx\n     /// version (resolve_type_vars_if_possible), this version will\n     /// also select obligations if it seems useful, in an effort\n@@ -1523,6 +1591,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"write_ty({}, {:?}) in fcx {}\",\n                node_id, ty, self.tag());\n         self.tables.borrow_mut().node_types.insert(node_id, ty);\n+\n+        if ty.references_error() {\n+            self.has_errors.set(true);\n+        }\n+\n+        // FIXME(canndrew): This is_never should probably be an is_uninhabited\n+        if ty.is_never() || self.type_var_diverges(ty) {\n+            self.diverges.set(self.diverges.get() | Diverges::Always);\n+        }\n     }\n \n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts<'tcx>) {\n@@ -2455,21 +2532,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Check the arguments.\n         // We do this in a pretty awful way: first we typecheck any arguments\n-        // that are not anonymous functions, then we typecheck the anonymous\n-        // functions. This is so that we have more information about the types\n-        // of arguments when we typecheck the functions. This isn't really the\n-        // right way to do this.\n-        let xs = [false, true];\n-        let mut any_diverges = false; // has any of the arguments diverged?\n-        let mut warned = false; // have we already warned about unreachable code?\n-        for check_blocks in &xs {\n-            let check_blocks = *check_blocks;\n-            debug!(\"check_blocks={}\", check_blocks);\n+        // that are not closures, then we typecheck the closures. This is so\n+        // that we have more information about the types of arguments when we\n+        // typecheck the functions. This isn't really the right way to do this.\n+        for &check_closures in &[false, true] {\n+            debug!(\"check_closures={}\", check_closures);\n \n             // More awful hacks: before we check argument types, try to do\n             // an \"opportunistic\" vtable resolution of any trait bounds on\n             // the call. This helps coercions.\n-            if check_blocks {\n+            if check_closures {\n                 self.select_obligations_where_possible();\n             }\n \n@@ -2484,61 +2556,43 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 supplied_arg_count\n             };\n             for (i, arg) in args.iter().take(t).enumerate() {\n-                if any_diverges && !warned {\n-                    self.tcx\n-                        .sess\n-                        .add_lint(lint::builtin::UNREACHABLE_CODE,\n-                                  arg.id,\n-                                  arg.span,\n-                                  \"unreachable expression\".to_string());\n-                    warned = true;\n+                // Warn only for the first loop (the \"no closures\" one).\n+                // Closure arguments themselves can't be diverging, but\n+                // a previous argument can, e.g. `foo(panic!(), || {})`.\n+                if !check_closures {\n+                    self.warn_if_unreachable(arg.id, arg.span, \"expression\");\n                 }\n-                let is_block = match arg.node {\n+\n+                let is_closure = match arg.node {\n                     hir::ExprClosure(..) => true,\n                     _ => false\n                 };\n \n-                if is_block == check_blocks {\n-                    debug!(\"checking the argument\");\n-                    let formal_ty = formal_tys[i];\n+                if is_closure != check_closures {\n+                    continue;\n+                }\n \n-                    // The special-cased logic below has three functions:\n-                    // 1. Provide as good of an expected type as possible.\n-                    let expected = expected_arg_tys.get(i).map(|&ty| {\n-                        Expectation::rvalue_hint(self, ty)\n-                    });\n+                debug!(\"checking the argument\");\n+                let formal_ty = formal_tys[i];\n \n-                    let checked_ty = self.check_expr_with_expectation(&arg,\n-                                            expected.unwrap_or(ExpectHasType(formal_ty)));\n-                    // 2. Coerce to the most detailed type that could be coerced\n-                    //    to, which is `expected_ty` if `rvalue_hint` returns an\n-                    //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n-                    let coerce_ty = expected.and_then(|e| e.only_has_type(self));\n-                    self.demand_coerce(&arg, checked_ty, coerce_ty.unwrap_or(formal_ty));\n-\n-                    // 3. Relate the expected type and the formal one,\n-                    //    if the expected type was used for the coercion.\n-                    coerce_ty.map(|ty| self.demand_suptype(arg.span, formal_ty, ty));\n-                }\n+                // The special-cased logic below has three functions:\n+                // 1. Provide as good of an expected type as possible.\n+                let expected = expected_arg_tys.get(i).map(|&ty| {\n+                    Expectation::rvalue_hint(self, ty)\n+                });\n \n-                if let Some(&arg_ty) = self.tables.borrow().node_types.get(&arg.id) {\n-                    // FIXME(canndrew): This is_never should probably be an is_uninhabited\n-                    any_diverges = any_diverges ||\n-                                   self.type_var_diverges(arg_ty) ||\n-                                   arg_ty.is_never();\n-                }\n-            }\n-            if any_diverges && !warned {\n-                let parent = self.tcx.map.get_parent_node(args[0].id);\n-                self.tcx\n-                    .sess\n-                    .add_lint(lint::builtin::UNREACHABLE_CODE,\n-                              parent,\n-                              sp,\n-                              \"unreachable call\".to_string());\n-                warned = true;\n+                let checked_ty = self.check_expr_with_expectation(&arg,\n+                                        expected.unwrap_or(ExpectHasType(formal_ty)));\n+                // 2. Coerce to the most detailed type that could be coerced\n+                //    to, which is `expected_ty` if `rvalue_hint` returns an\n+                //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n+                let coerce_ty = expected.and_then(|e| e.only_has_type(self));\n+                self.demand_coerce(&arg, checked_ty, coerce_ty.unwrap_or(formal_ty));\n+\n+                // 3. Relate the expected type and the formal one,\n+                //    if the expected type was used for the coercion.\n+                coerce_ty.map(|ty| self.demand_suptype(arg.span, formal_ty, ty));\n             }\n-\n         }\n \n         // We also need to make sure we at least write the ty of the other\n@@ -2789,18 +2843,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        sp: Span,\n                        expected: Expectation<'tcx>) -> Ty<'tcx> {\n         let cond_ty = self.check_expr_has_type(cond_expr, self.tcx.types.bool);\n+        let cond_diverges = self.diverges.get();\n+        self.diverges.set(Diverges::Maybe);\n \n         let expected = expected.adjust_for_branches(self);\n         let then_ty = self.check_block_with_expected(then_blk, expected);\n+        let then_diverges = self.diverges.get();\n+        self.diverges.set(Diverges::Maybe);\n \n         let unit = self.tcx.mk_nil();\n         let (origin, expected, found, result) =\n         if let Some(else_expr) = opt_else_expr {\n             let else_ty = self.check_expr_with_expectation(else_expr, expected);\n-            let origin = TypeOrigin::IfExpression(sp);\n+            let else_diverges = self.diverges.get();\n \n             // Only try to coerce-unify if we have a then expression\n             // to assign coercions to, otherwise it's () or diverging.\n+            let origin = TypeOrigin::IfExpression(sp);\n             let result = if let Some(ref then) = then_blk.expr {\n                 let res = self.try_find_coercion_lub(origin, || Some(&**then),\n                                                      then_ty, else_expr, else_ty);\n@@ -2826,8 +2885,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         })\n                 })\n             };\n+\n+            // We won't diverge unless both branches do (or the condition does).\n+            self.diverges.set(cond_diverges | then_diverges & else_diverges);\n+\n             (origin, then_ty, else_ty, result)\n         } else {\n+            // If the condition is false we can't diverge.\n+            self.diverges.set(cond_diverges);\n+\n             let origin = TypeOrigin::IfExpressionWithNoElse(sp);\n             (origin, unit, then_ty,\n              self.eq_types(true, origin, unit, then_ty)\n@@ -3288,10 +3354,36 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                    lvalue_pref: LvaluePreference) -> Ty<'tcx> {\n         debug!(\">> typechecking: expr={:?} expected={:?}\",\n                expr, expected);\n+\n+        // Warn for expressions after diverging siblings.\n+        self.warn_if_unreachable(expr.id, expr.span, \"expression\");\n+\n+        // Hide the outer diverging and has_errors flags.\n+        let old_diverges = self.diverges.get();\n+        let old_has_errors = self.has_errors.get();\n+        self.diverges.set(Diverges::Maybe);\n+        self.has_errors.set(false);\n+\n         let ty = self.check_expr_kind(expr, expected, lvalue_pref);\n \n+        // Warn for non-block expressions with diverging children.\n+        match expr.node {\n+            hir::ExprBlock(_) |\n+            hir::ExprLoop(..) | hir::ExprWhile(..) |\n+            hir::ExprIf(..) | hir::ExprMatch(..) => {}\n+\n+            _ => self.warn_if_unreachable(expr.id, expr.span, \"expression\")\n+        }\n+\n+        // Record the type, which applies it effects.\n+        // We need to do this after the warning above, so that\n+        // we don't warn for the diverging expression itself.\n         self.write_ty(expr.id, ty);\n \n+        // Combine the diverging and has_error flags.\n+        self.diverges.set(self.diverges.get() | old_diverges);\n+        self.has_errors.set(self.has_errors.get() | old_has_errors);\n+\n         debug!(\"type of expr({}) {} is...\", expr.id,\n                pprust::expr_to_string(expr));\n         debug!(\"... {:?}, expected is {:?}\",\n@@ -3516,22 +3608,29 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                  expr.span, expected)\n           }\n           hir::ExprWhile(ref cond, ref body, _) => {\n-            let cond_ty = self.check_expr_has_type(&cond, tcx.types.bool);\n+            self.check_expr_has_type(&cond, tcx.types.bool);\n+            let cond_diverging = self.diverges.get();\n             self.check_block_no_value(&body);\n-            let body_ty = self.node_ty(body.id);\n-            if cond_ty.references_error() || body_ty.references_error() {\n+\n+            // We may never reach the body so it diverging means nothing.\n+            self.diverges.set(cond_diverging);\n+\n+            if self.has_errors.get() {\n                 tcx.types.err\n-            }\n-            else {\n+            } else {\n                 tcx.mk_nil()\n             }\n           }\n           hir::ExprLoop(ref body, _) => {\n             self.check_block_no_value(&body);\n-            if !may_break(tcx, expr.id, &body) {\n-                tcx.types.never\n-            } else {\n+            if may_break(tcx, expr.id, &body) {\n+                // No way to know whether it's diverging because\n+                // of a `break` or an outer `break` or `return.\n+                self.diverges.set(Diverges::Maybe);\n+\n                 tcx.mk_nil()\n+            } else {\n+                tcx.types.never\n             }\n           }\n           hir::ExprMatch(ref discrim, ref arms, match_src) => {\n@@ -3864,55 +3963,66 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn check_stmt(&self, stmt: &'gcx hir::Stmt) {\n-        let node_id;\n-        let mut saw_bot = false;\n-        let mut saw_err = false;\n+        // Don't do all the complex logic below for DeclItem.\n         match stmt.node {\n-          hir::StmtDecl(ref decl, id) => {\n-            node_id = id;\n-            match decl.node {\n-              hir::DeclLocal(ref l) => {\n-                  self.check_decl_local(&l);\n-                  let l_t = self.node_ty(l.id);\n-                  saw_bot = saw_bot || self.type_var_diverges(l_t);\n-                  saw_err = saw_err || l_t.references_error();\n-              }\n-              hir::DeclItem(_) => {/* ignore for now */ }\n+            hir::StmtDecl(ref decl, id) => {\n+                match decl.node {\n+                    hir::DeclLocal(_) => {}\n+                    hir::DeclItem(_) => {\n+                        self.write_nil(id);\n+                        return;\n+                    }\n+                }\n             }\n-          }\n-          hir::StmtExpr(ref expr, id) => {\n-            node_id = id;\n-            // Check with expected type of ()\n-            let ty = self.check_expr_has_type(&expr, self.tcx.mk_nil());\n-            saw_bot = saw_bot || self.type_var_diverges(ty);\n-            saw_err = saw_err || ty.references_error();\n-          }\n-          hir::StmtSemi(ref expr, id) => {\n-            node_id = id;\n-            let ty = self.check_expr(&expr);\n-            saw_bot |= self.type_var_diverges(ty);\n-            saw_err |= ty.references_error();\n-          }\n-        }\n-        if saw_bot {\n-            self.write_ty(node_id, self.next_diverging_ty_var());\n+            hir::StmtExpr(..) | hir::StmtSemi(..) => {}\n         }\n-        else if saw_err {\n+\n+        self.warn_if_unreachable(stmt.node.id(), stmt.span, \"statement\");\n+\n+        // Hide the outer diverging and has_errors flags.\n+        let old_diverges = self.diverges.get();\n+        let old_has_errors = self.has_errors.get();\n+        self.diverges.set(Diverges::Maybe);\n+        self.has_errors.set(false);\n+\n+        let node_id = match stmt.node {\n+            hir::StmtDecl(ref decl, id) => {\n+                match decl.node {\n+                    hir::DeclLocal(ref l) => {\n+                        self.check_decl_local(&l);\n+                    }\n+                    hir::DeclItem(_) => {/* ignore for now */ }\n+                }\n+                id\n+            }\n+            hir::StmtExpr(ref expr, id) => {\n+                // Check with expected type of ()\n+                self.check_expr_has_type(&expr, self.tcx.mk_nil());\n+                id\n+            }\n+            hir::StmtSemi(ref expr, id) => {\n+                self.check_expr(&expr);\n+                id\n+            }\n+        };\n+\n+        if self.has_errors.get() {\n             self.write_error(node_id);\n-        }\n-        else {\n+        } else if self.diverges.get().always() {\n+            self.write_ty(node_id, self.next_diverging_ty_var());\n+        } else {\n             self.write_nil(node_id);\n         }\n+\n+        // Combine the diverging and has_error flags.\n+        self.diverges.set(self.diverges.get() | old_diverges);\n+        self.has_errors.set(self.has_errors.get() | old_has_errors);\n     }\n \n     pub fn check_block_no_value(&self, blk: &'gcx hir::Block)  {\n-        let blkty = self.check_block_with_expected(blk, ExpectHasType(self.tcx.mk_nil()));\n-        if blkty.references_error() {\n-            self.write_error(blk.id);\n-        } else {\n-            let nilty = self.tcx.mk_nil();\n-            self.demand_suptype(blk.span, nilty, blkty);\n-        }\n+        let unit = self.tcx.mk_nil();\n+        let ty = self.check_block_with_expected(blk, ExpectHasType(unit));\n+        self.demand_suptype(blk.span, unit, ty);\n     }\n \n     fn check_block_with_expected(&self,\n@@ -3924,72 +4034,81 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             replace(&mut *fcx_ps, unsafety_state)\n         };\n \n-        let mut warned = false;\n-        let mut any_diverges = false;\n-        let mut any_err = false;\n         for s in &blk.stmts {\n             self.check_stmt(s);\n-            let s_id = s.node.id();\n-            let s_ty = self.node_ty(s_id);\n-            if any_diverges && !warned && match s.node {\n-                hir::StmtDecl(ref decl, _) => {\n-                    match decl.node {\n-                        hir::DeclLocal(_) => true,\n-                        _ => false,\n+        }\n+\n+        let mut ty = match blk.expr {\n+            Some(ref e) => self.check_expr_with_expectation(e, expected),\n+            None => self.tcx.mk_nil()\n+        };\n+\n+        if self.diverges.get().always() {\n+            if let ExpectHasType(ety) = expected {\n+                // Avoid forcing a type (only `!` for now) in unreachable code.\n+                // FIXME(aburka) do we need this special case? and should it be is_uninhabited?\n+                if !ety.is_never() {\n+                    if let Some(ref e) = blk.expr {\n+                        // Coerce the tail expression to the right type.\n+                        self.demand_coerce(e, ty, ety);\n                     }\n                 }\n-                hir::StmtExpr(..) | hir::StmtSemi(..) => true,\n-            } {\n-                self.tcx\n-                    .sess\n-                    .add_lint(lint::builtin::UNREACHABLE_CODE,\n-                              s_id,\n-                              s.span,\n-                              \"unreachable statement\".to_string());\n-                warned = true;\n             }\n-            // FIXME(canndrew): This is_never should probably be an is_uninhabited\n-            any_diverges = any_diverges ||\n-                           self.type_var_diverges(s_ty) ||\n-                           s_ty.is_never();\n-            any_err = any_err || s_ty.references_error();\n-        }\n-        let ty = match blk.expr {\n-            None => if any_err {\n-                self.tcx.types.err\n-            } else if any_diverges {\n-                self.next_diverging_ty_var()\n+\n+            ty = self.next_diverging_ty_var();\n+        } else if let ExpectHasType(ety) = expected {\n+            if let Some(ref e) = blk.expr {\n+                // Coerce the tail expression to the right type.\n+                self.demand_coerce(e, ty, ety);\n             } else {\n-                self.tcx.mk_nil()\n-            },\n-            Some(ref e) => {\n-                if any_diverges && !warned {\n-                    self.tcx\n-                        .sess\n-                        .add_lint(lint::builtin::UNREACHABLE_CODE,\n-                                  e.id,\n-                                  e.span,\n-                                  \"unreachable expression\".to_string());\n-                }\n-                let ety = match expected {\n-                    ExpectHasType(ety) => {\n-                        self.check_expr_coercable_to_type(&e, ety);\n-                        ety\n-                    }\n-                    _ => {\n-                        self.check_expr_with_expectation(&e, expected)\n-                    }\n-                };\n+                // We're not diverging and there's an expected type, which,\n+                // in case it's not `()`, could result in an error higher-up.\n+                // We have a chance to error here early and be more helpful.\n+                let origin = TypeOrigin::Misc(blk.span);\n+                let trace = TypeTrace::types(origin, false, ty, ety);\n+                match self.sub_types(false, origin, ty, ety) {\n+                    Ok(InferOk { obligations, .. }) => {\n+                        // FIXME(#32730) propagate obligations\n+                        assert!(obligations.is_empty());\n+                    },\n+                    Err(err) => {\n+                        let mut err = self.report_and_explain_type_error(trace, &err);\n+\n+                        // Be helpful when the user wrote `{... expr;}` and\n+                        // taking the `;` off is enough to fix the error.\n+                        let mut extra_semi = None;\n+                        if let Some(stmt) = blk.stmts.last() {\n+                            if let hir::StmtSemi(ref e, _) = stmt.node {\n+                                if self.can_sub_types(self.node_ty(e.id), ety).is_ok() {\n+                                    extra_semi = Some(stmt);\n+                                }\n+                            }\n+                        }\n+                        if let Some(last_stmt) = extra_semi {\n+                            let original_span = original_sp(self.tcx.sess.codemap(),\n+                                                            last_stmt.span, blk.span);\n+                            let span_semi = Span {\n+                                lo: original_span.hi - BytePos(1),\n+                                hi: original_span.hi,\n+                                expn_id: original_span.expn_id\n+                            };\n+                            err.span_help(span_semi, \"consider removing this semicolon:\");\n+                        }\n \n-                if any_err {\n-                    self.tcx.types.err\n-                } else if any_diverges {\n-                    self.next_diverging_ty_var()\n-                } else {\n-                    ety\n+                        err.emit();\n+                    }\n                 }\n             }\n-        };\n+\n+            // We already applied the type (and potentially errored),\n+            // use the expected type to avoid further errors out.\n+            ty = ety;\n+        }\n+\n+        if self.has_errors.get() || ty.references_error() {\n+            ty = self.tcx.types.err\n+        }\n+\n         self.write_ty(blk.id, ty);\n \n         *self.ps.borrow_mut() = prev;"}, {"sha": "8b4975b7e3a2f723331219af60397986596beed3", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -75,8 +75,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match BinOpCategory::from(op) {\n             BinOpCategory::Shortcircuit => {\n                 // && and || are a simple case.\n+                let lhs_diverges = self.diverges.get();\n                 self.demand_suptype(lhs_expr.span, tcx.mk_bool(), lhs_ty);\n                 self.check_expr_coercable_to_type(rhs_expr, tcx.mk_bool());\n+\n+                // Depending on the LHS' value, the RHS can never execute.\n+                self.diverges.set(lhs_diverges);\n+\n                 tcx.mk_bool()\n             }\n             _ => {"}, {"sha": "d4e5e9a5bb355f5b0520b77f2574c23d6ff598dd", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -142,13 +142,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn regionck_fn(&self,\n                        fn_id: ast::NodeId,\n                        decl: &hir::FnDecl,\n-                       blk: &hir::Block) {\n+                       body: &hir::Expr) {\n         debug!(\"regionck_fn(id={})\", fn_id);\n-        let mut rcx = RegionCtxt::new(self, RepeatingScope(blk.id), blk.id, Subject(fn_id));\n+        let mut rcx = RegionCtxt::new(self, RepeatingScope(body.id), body.id, Subject(fn_id));\n \n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n-            rcx.visit_fn_body(fn_id, decl, blk, self.tcx.map.span(fn_id));\n+            rcx.visit_fn_body(fn_id, decl, body, self.tcx.map.span(fn_id));\n         }\n \n         rcx.free_region_map.relate_free_regions_from_predicates(\n@@ -268,7 +268,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn visit_fn_body(&mut self,\n                      id: ast::NodeId, // the id of the fn itself\n                      fn_decl: &hir::FnDecl,\n-                     body: &hir::Block,\n+                     body: &hir::Expr,\n                      span: Span)\n     {\n         // When we enter a function, we can derive\n@@ -305,7 +305,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         self.relate_free_regions(&fn_sig_tys[..], body.id, span);\n         self.link_fn_args(self.tcx.region_maps.node_extent(body.id),\n                           &fn_decl.inputs[..]);\n-        self.visit_block(body);\n+        self.visit_expr(body);\n         self.visit_region_obligations(body.id);\n \n         let call_site_scope = self.call_site_scope.unwrap();\n@@ -480,7 +480,7 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n     // regions, until regionck, as described in #3238.\n \n     fn visit_fn(&mut self, _fk: intravisit::FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Block, span: Span, id: ast::NodeId) {\n+                b: &'v hir::Expr, span: Span, id: ast::NodeId) {\n         self.visit_fn_body(id, fd, b, span)\n     }\n \n@@ -825,7 +825,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn check_expr_fn_block(&mut self,\n                            expr: &hir::Expr,\n-                           body: &hir::Block) {\n+                           body: &hir::Expr) {\n         let repeating_scope = self.set_repeating_scope(body.id);\n         intravisit::walk_expr(self, expr);\n         self.set_repeating_scope(repeating_scope);"}, {"sha": "2fea86cb212070844afd79696d14dc6c1100b609", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -57,18 +57,7 @@ use rustc::util::nodemap::NodeMap;\n // PUBLIC ENTRY POINTS\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn closure_analyze_fn(&self, body: &hir::Block) {\n-        let mut seed = SeedBorrowKind::new(self);\n-        seed.visit_block(body);\n-\n-        let mut adjust = AdjustBorrowKind::new(self, seed.temp_closure_kinds);\n-        adjust.visit_block(body);\n-\n-        // it's our job to process these.\n-        assert!(self.deferred_call_resolutions.borrow().is_empty());\n-    }\n-\n-    pub fn closure_analyze_const(&self, body: &hir::Expr) {\n+    pub fn closure_analyze(&self, body: &hir::Expr) {\n         let mut seed = SeedBorrowKind::new(self);\n         seed.visit_expr(body);\n \n@@ -110,7 +99,7 @@ impl<'a, 'gcx, 'tcx> SeedBorrowKind<'a, 'gcx, 'tcx> {\n     fn check_closure(&mut self,\n                      expr: &hir::Expr,\n                      capture_clause: hir::CaptureClause,\n-                     _body: &hir::Block)\n+                     _body: &hir::Expr)\n     {\n         let closure_def_id = self.fcx.tcx.map.local_def_id(expr.id);\n         if !self.fcx.tables.borrow().closure_kinds.contains_key(&closure_def_id) {\n@@ -164,7 +153,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                        id: ast::NodeId,\n                        span: Span,\n                        decl: &hir::FnDecl,\n-                       body: &hir::Block) {\n+                       body: &hir::Expr) {\n         /*!\n          * Analysis starting point.\n          */\n@@ -497,7 +486,7 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for AdjustBorrowKind<'a, 'gcx, 'tcx> {\n     fn visit_fn(&mut self,\n                 fn_kind: intravisit::FnKind<'v>,\n                 decl: &'v hir::FnDecl,\n-                body: &'v hir::Block,\n+                body: &'v hir::Expr,\n                 span: Span,\n                 id: ast::NodeId)\n     {"}, {"sha": "4136f543cccaf2dd2c1f477141947bb6430f11dc", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -348,7 +348,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n \n     fn check_item_fn(&mut self,\n                      item: &hir::Item,\n-                     body: &hir::Block)\n+                     body: &hir::Expr)\n     {\n         self.for_item(item).with_fcx(|fcx, this| {\n             let free_substs = &fcx.parameter_environment.free_substs;"}, {"sha": "9f3214a0d813e6e88d392810727b598a751178f3", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -49,11 +49,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn resolve_type_vars_in_fn(&self,\n                                    decl: &hir::FnDecl,\n-                                   blk: &hir::Block,\n+                                   body: &hir::Expr,\n                                    item_id: ast::NodeId) {\n         assert_eq!(self.writeback_errors.get(), false);\n         let mut wbcx = WritebackCx::new(self);\n-        wbcx.visit_block(blk);\n+        wbcx.visit_expr(body);\n         for arg in &decl.inputs {\n             wbcx.visit_node_id(ResolvingPattern(arg.pat.span), arg.id);\n             wbcx.visit_pat(&arg.pat);"}, {"sha": "f5cd089e923d7c7efe3dbbcdf7001d45656e5e06", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -1017,10 +1017,10 @@ pub enum ExprKind {\n     Loop(P<Block>, Option<SpannedIdent>),\n     /// A `match` block.\n     Match(P<Expr>, Vec<Arm>),\n-    /// A closure (for example, `move |a, b, c| {a + b + c}`)\n+    /// A closure (for example, `move |a, b, c| a + b + c`)\n     ///\n     /// The final span is the span of the argument block `|...|`\n-    Closure(CaptureBy, P<FnDecl>, P<Block>, Span),\n+    Closure(CaptureBy, P<FnDecl>, P<Expr>, Span),\n     /// A block (`{ ... }`)\n     Block(P<Block>),\n "}, {"sha": "c3e28cbb006a07795499c4af50cae727df286ed4", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 15, "deletions": 30, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -198,17 +198,13 @@ pub trait AstBuilder {\n     fn lambda_fn_decl(&self,\n                       span: Span,\n                       fn_decl: P<ast::FnDecl>,\n-                      blk: P<ast::Block>,\n+                      body: P<ast::Expr>,\n                       fn_decl_span: Span)\n                       -> P<ast::Expr>;\n \n-    fn lambda(&self, span: Span, ids: Vec<ast::Ident>, blk: P<ast::Block>) -> P<ast::Expr>;\n-    fn lambda0(&self, span: Span, blk: P<ast::Block>) -> P<ast::Expr>;\n-    fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> P<ast::Expr>;\n-\n-    fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident> , blk: P<ast::Expr>) -> P<ast::Expr>;\n-    fn lambda_expr_0(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Expr>;\n-    fn lambda_expr_1(&self, span: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr>;\n+    fn lambda(&self, span: Span, ids: Vec<ast::Ident>, body: P<ast::Expr>) -> P<ast::Expr>;\n+    fn lambda0(&self, span: Span, body: P<ast::Expr>) -> P<ast::Expr>;\n+    fn lambda1(&self, span: Span, body: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr>;\n \n     fn lambda_stmts(&self, span: Span, ids: Vec<ast::Ident>,\n                     blk: Vec<ast::Stmt>) -> P<ast::Expr>;\n@@ -940,19 +936,19 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn lambda_fn_decl(&self,\n                       span: Span,\n                       fn_decl: P<ast::FnDecl>,\n-                      blk: P<ast::Block>,\n+                      body: P<ast::Expr>,\n                       fn_decl_span: Span) // span of the `|...|` part\n                       -> P<ast::Expr> {\n         self.expr(span, ast::ExprKind::Closure(ast::CaptureBy::Ref,\n                                                fn_decl,\n-                                               blk,\n+                                               body,\n                                                fn_decl_span))\n     }\n \n     fn lambda(&self,\n               span: Span,\n               ids: Vec<ast::Ident>,\n-              blk: P<ast::Block>)\n+              body: P<ast::Expr>)\n               -> P<ast::Expr> {\n         let fn_decl = self.fn_decl(\n             ids.iter().map(|id| self.arg(span, *id, self.ty_infer(span))).collect(),\n@@ -962,41 +958,30 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         // part of the lambda, but it probably (maybe?) corresponds to\n         // the entire lambda body. Probably we should extend the API\n         // here, but that's not entirely clear.\n-        self.expr(span, ast::ExprKind::Closure(ast::CaptureBy::Ref, fn_decl, blk, span))\n-    }\n-\n-    fn lambda0(&self, span: Span, blk: P<ast::Block>) -> P<ast::Expr> {\n-        self.lambda(span, Vec::new(), blk)\n+        self.expr(span, ast::ExprKind::Closure(ast::CaptureBy::Ref, fn_decl, body, span))\n     }\n \n-    fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> P<ast::Expr> {\n-        self.lambda(span, vec![ident], blk)\n+    fn lambda0(&self, span: Span, body: P<ast::Expr>) -> P<ast::Expr> {\n+        self.lambda(span, Vec::new(), body)\n     }\n \n-    fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident>,\n-                   expr: P<ast::Expr>) -> P<ast::Expr> {\n-        self.lambda(span, ids, self.block_expr(expr))\n-    }\n-    fn lambda_expr_0(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n-        self.lambda0(span, self.block_expr(expr))\n-    }\n-    fn lambda_expr_1(&self, span: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr> {\n-        self.lambda1(span, self.block_expr(expr), ident)\n+    fn lambda1(&self, span: Span, body: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr> {\n+        self.lambda(span, vec![ident], body)\n     }\n \n     fn lambda_stmts(&self,\n                     span: Span,\n                     ids: Vec<ast::Ident>,\n                     stmts: Vec<ast::Stmt>)\n                     -> P<ast::Expr> {\n-        self.lambda(span, ids, self.block(span, stmts))\n+        self.lambda(span, ids, self.expr_block(self.block(span, stmts)))\n     }\n     fn lambda_stmts_0(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Expr> {\n-        self.lambda0(span, self.block(span, stmts))\n+        self.lambda0(span, self.expr_block(self.block(span, stmts)))\n     }\n     fn lambda_stmts_1(&self, span: Span, stmts: Vec<ast::Stmt>,\n                       ident: ast::Ident) -> P<ast::Expr> {\n-        self.lambda1(span, self.block(span, stmts), ident)\n+        self.lambda1(span, self.expr_block(self.block(span, stmts)), ident)\n     }\n \n     fn arg(&self, span: Span, ident: ast::Ident, ty: P<ast::Ty>) -> ast::Arg {"}, {"sha": "f51822ec2fe807e2fbbe2c8a6c65b5c675f6c3f3", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -1228,12 +1228,11 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n     fn visit_fn(&mut self,\n                 fn_kind: FnKind,\n                 fn_decl: &ast::FnDecl,\n-                block: &ast::Block,\n                 span: Span,\n                 _node_id: NodeId) {\n         // check for const fn declarations\n         match fn_kind {\n-            FnKind::ItemFn(_, _, _, Spanned { node: ast::Constness::Const, .. }, _, _) => {\n+            FnKind::ItemFn(_, _, _, Spanned { node: ast::Constness::Const, .. }, _, _, _) => {\n                 gate_feature_post!(&self, const_fn, span, \"const fn is unstable\");\n             }\n             _ => {\n@@ -1245,13 +1244,13 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n         }\n \n         match fn_kind {\n-            FnKind::ItemFn(_, _, _, _, abi, _) |\n-            FnKind::Method(_, &ast::MethodSig { abi, .. }, _) => {\n+            FnKind::ItemFn(_, _, _, _, abi, _, _) |\n+            FnKind::Method(_, &ast::MethodSig { abi, .. }, _, _) => {\n                 self.check_abi(abi, span);\n             }\n             _ => {}\n         }\n-        visit::walk_fn(self, fn_kind, fn_decl, block, span);\n+        visit::walk_fn(self, fn_kind, fn_decl, span);\n     }\n \n     fn visit_trait_item(&mut self, ti: &ast::TraitItem) {"}, {"sha": "2e62f23578d815884167938f18949d42c69beb9a", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -1201,7 +1201,7 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n             ExprKind::Closure(capture_clause, decl, body, span) => {\n                 ExprKind::Closure(capture_clause,\n                                   folder.fold_fn_decl(decl),\n-                                  folder.fold_block(body),\n+                                  folder.fold_expr(body),\n                                   folder.new_span(span))\n             }\n             ExprKind::Block(blk) => ExprKind::Block(folder.fold_block(blk)),"}, {"sha": "7d15334ff9f4e3634ef8b977f9edea18ccaa9182", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -3162,25 +3162,12 @@ impl<'a> Parser<'a> {\n         let decl = self.parse_fn_block_decl()?;\n         let decl_hi = self.prev_span.hi;\n         let body = match decl.output {\n-            FunctionRetTy::Default(_) => {\n-                // If no explicit return type is given, parse any\n-                // expr and wrap it up in a dummy block:\n-                let body_expr = self.parse_expr()?;\n-                P(ast::Block {\n-                    id: ast::DUMMY_NODE_ID,\n-                    span: body_expr.span,\n-                    stmts: vec![Stmt {\n-                        span: body_expr.span,\n-                        node: StmtKind::Expr(body_expr),\n-                        id: ast::DUMMY_NODE_ID,\n-                    }],\n-                    rules: BlockCheckMode::Default,\n-                })\n-            }\n+            FunctionRetTy::Default(_) => self.parse_expr()?,\n             _ => {\n                 // If an explicit return type is given, require a\n                 // block to appear (RFC 968).\n-                self.parse_block()?\n+                let body_lo = self.span.lo;\n+                self.parse_block_expr(body_lo, BlockCheckMode::Default, ThinVec::new())?\n             }\n         };\n "}, {"sha": "203c19285ac2c366e01f83b5d4eebc32cd35f772", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -2128,26 +2128,8 @@ impl<'a> State<'a> {\n \n                 try!(self.print_fn_block_args(&decl));\n                 try!(space(&mut self.s));\n-\n-                let default_return = match decl.output {\n-                    ast::FunctionRetTy::Default(..) => true,\n-                    _ => false\n-                };\n-\n-                match body.stmts.last().map(|stmt| &stmt.node) {\n-                    Some(&ast::StmtKind::Expr(ref i_expr)) if default_return &&\n-                                                              body.stmts.len() == 1 => {\n-                        // we extract the block, so as not to create another set of boxes\n-                        if let ast::ExprKind::Block(ref blk) = i_expr.node {\n-                            try!(self.print_block_unclosed_with_attrs(&blk, &i_expr.attrs));\n-                        } else {\n-                            // this is a bare expression\n-                            try!(self.print_expr(&i_expr));\n-                            try!(self.end()); // need to close a box\n-                        }\n-                    }\n-                    _ => try!(self.print_block_unclosed(&body)),\n-                }\n+                try!(self.print_expr(body));\n+                try!(self.end()); // need to close a box\n \n                 // a box will be closed by print_expr, but we didn't want an overall\n                 // wrapper so we closed the corresponding opening. so create an"}, {"sha": "a1f07381db705910e14e766b5520b8d95c463929", "filename": "src/libsyntax/util/node_count.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnode_count.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -75,9 +75,9 @@ impl Visitor for NodeCounter {\n         self.count += 1;\n         walk_generics(self, g)\n     }\n-    fn visit_fn(&mut self, fk: FnKind, fd: &FnDecl, b: &Block, s: Span, _: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind, fd: &FnDecl, s: Span, _: NodeId) {\n         self.count += 1;\n-        walk_fn(self, fk, fd, b, s)\n+        walk_fn(self, fk, fd, s)\n     }\n     fn visit_trait_item(&mut self, ti: &TraitItem) {\n         self.count += 1;"}, {"sha": "7c1ff617ab64d00b46d07021b15c5f83ab79abb7", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -31,13 +31,13 @@ use codemap::Spanned;\n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum FnKind<'a> {\n     /// fn foo() or extern \"Abi\" fn foo()\n-    ItemFn(Ident, &'a Generics, Unsafety, Spanned<Constness>, Abi, &'a Visibility),\n+    ItemFn(Ident, &'a Generics, Unsafety, Spanned<Constness>, Abi, &'a Visibility, &'a Block),\n \n     /// fn foo(&self)\n-    Method(Ident, &'a MethodSig, Option<&'a Visibility>),\n+    Method(Ident, &'a MethodSig, Option<&'a Visibility>, &'a Block),\n \n-    /// |x, y| {}\n-    Closure,\n+    /// |x, y| body\n+    Closure(&'a Expr),\n }\n \n /// Each method of the Visitor trait is a hook to be potentially\n@@ -68,8 +68,8 @@ pub trait Visitor: Sized {\n     fn visit_expr_post(&mut self, _ex: &Expr) { }\n     fn visit_ty(&mut self, t: &Ty) { walk_ty(self, t) }\n     fn visit_generics(&mut self, g: &Generics) { walk_generics(self, g) }\n-    fn visit_fn(&mut self, fk: FnKind, fd: &FnDecl, b: &Block, s: Span, _: NodeId) {\n-        walk_fn(self, fk, fd, b, s)\n+    fn visit_fn(&mut self, fk: FnKind, fd: &FnDecl, s: Span, _: NodeId) {\n+        walk_fn(self, fk, fd, s)\n     }\n     fn visit_trait_item(&mut self, ti: &TraitItem) { walk_trait_item(self, ti) }\n     fn visit_impl_item(&mut self, ii: &ImplItem) { walk_impl_item(self, ii) }\n@@ -246,9 +246,8 @@ pub fn walk_item<V: Visitor>(visitor: &mut V, item: &Item) {\n         }\n         ItemKind::Fn(ref declaration, unsafety, constness, abi, ref generics, ref body) => {\n             visitor.visit_fn(FnKind::ItemFn(item.ident, generics, unsafety,\n-                                            constness, abi, &item.vis),\n+                                            constness, abi, &item.vis, body),\n                              declaration,\n-                             body,\n                              item.span,\n                              item.id)\n         }\n@@ -519,26 +518,27 @@ pub fn walk_fn_decl<V: Visitor>(visitor: &mut V, function_declaration: &FnDecl)\n     visitor.visit_fn_ret_ty(&function_declaration.output)\n }\n \n-pub fn walk_fn_kind<V: Visitor>(visitor: &mut V, function_kind: FnKind) {\n-    match function_kind {\n-        FnKind::ItemFn(_, generics, _, _, _, _) => {\n+pub fn walk_fn<V>(visitor: &mut V, kind: FnKind, declaration: &FnDecl, _span: Span)\n+    where V: Visitor,\n+{\n+    match kind {\n+        FnKind::ItemFn(_, generics, _, _, _, _, body) => {\n             visitor.visit_generics(generics);\n+            walk_fn_decl(visitor, declaration);\n+            visitor.visit_block(body);\n         }\n-        FnKind::Method(_, ref sig, _) => {\n+        FnKind::Method(_, ref sig, _, body) => {\n             visitor.visit_generics(&sig.generics);\n+            walk_fn_decl(visitor, declaration);\n+            visitor.visit_block(body);\n+        }\n+        FnKind::Closure(body) => {\n+            walk_fn_decl(visitor, declaration);\n+            visitor.visit_expr(body);\n         }\n-        FnKind::Closure => {}\n     }\n }\n \n-pub fn walk_fn<V>(visitor: &mut V, kind: FnKind, declaration: &FnDecl, body: &Block, _span: Span)\n-    where V: Visitor,\n-{\n-    walk_fn_kind(visitor, kind);\n-    walk_fn_decl(visitor, declaration);\n-    visitor.visit_block(body)\n-}\n-\n pub fn walk_trait_item<V: Visitor>(visitor: &mut V, trait_item: &TraitItem) {\n     visitor.visit_ident(trait_item.span, trait_item.ident);\n     walk_list!(visitor, visit_attribute, &trait_item.attrs);\n@@ -552,8 +552,8 @@ pub fn walk_trait_item<V: Visitor>(visitor: &mut V, trait_item: &TraitItem) {\n             walk_fn_decl(visitor, &sig.decl);\n         }\n         TraitItemKind::Method(ref sig, Some(ref body)) => {\n-            visitor.visit_fn(FnKind::Method(trait_item.ident, sig, None), &sig.decl,\n-                             body, trait_item.span, trait_item.id);\n+            visitor.visit_fn(FnKind::Method(trait_item.ident, sig, None, body),\n+                             &sig.decl, trait_item.span, trait_item.id);\n         }\n         TraitItemKind::Type(ref bounds, ref default) => {\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n@@ -575,8 +575,8 @@ pub fn walk_impl_item<V: Visitor>(visitor: &mut V, impl_item: &ImplItem) {\n             visitor.visit_expr(expr);\n         }\n         ImplItemKind::Method(ref sig, ref body) => {\n-            visitor.visit_fn(FnKind::Method(impl_item.ident, sig, Some(&impl_item.vis)), &sig.decl,\n-                             body, impl_item.span, impl_item.id);\n+            visitor.visit_fn(FnKind::Method(impl_item.ident, sig, Some(&impl_item.vis), body),\n+                             &sig.decl, impl_item.span, impl_item.id);\n         }\n         ImplItemKind::Type(ref ty) => {\n             visitor.visit_ty(ty);\n@@ -711,9 +711,8 @@ pub fn walk_expr<V: Visitor>(visitor: &mut V, expression: &Expr) {\n             walk_list!(visitor, visit_arm, arms);\n         }\n         ExprKind::Closure(_, ref function_declaration, ref body, _decl_span) => {\n-            visitor.visit_fn(FnKind::Closure,\n+            visitor.visit_fn(FnKind::Closure(body),\n                              function_declaration,\n-                             body,\n                              expression.span,\n                              expression.id)\n         }"}, {"sha": "dc1f7b4e6201e7132f989a8929b0337d7a6652cc", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -133,7 +133,7 @@ fn decodable_substructure(cx: &mut ExtCtxt,\n                                 cx.ident_of(\"read_struct\"),\n                                 vec![cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n                                      cx.expr_usize(trait_span, nfields),\n-                                     cx.lambda_expr_1(trait_span, result, blkarg)])\n+                                     cx.lambda1(trait_span, result, blkarg)])\n         }\n         StaticEnum(_, ref fields) => {\n             let variant = cx.ident_of(\"i\");\n@@ -165,7 +165,7 @@ fn decodable_substructure(cx: &mut ExtCtxt,\n             let result =\n                 cx.expr_ok(trait_span,\n                            cx.expr_match(trait_span, cx.expr_ident(trait_span, variant), arms));\n-            let lambda = cx.lambda_expr(trait_span, vec![blkarg, variant], result);\n+            let lambda = cx.lambda(trait_span, vec![blkarg, variant], result);\n             let variant_vec = cx.expr_vec(trait_span, variants);\n             let variant_vec = cx.expr_addr_of(trait_span, variant_vec);\n             let result = cx.expr_method_call(trait_span,\n@@ -176,7 +176,7 @@ fn decodable_substructure(cx: &mut ExtCtxt,\n                                 decoder,\n                                 cx.ident_of(\"read_enum\"),\n                                 vec![cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n-                                     cx.lambda_expr_1(trait_span, result, blkarg)])\n+                                     cx.lambda1(trait_span, result, blkarg)])\n         }\n         _ => cx.bug(\"expected StaticEnum or StaticStruct in derive(Decodable)\"),\n     };"}, {"sha": "ebbddc6e48084464208cd33b9dacce183863b98b", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -197,7 +197,7 @@ fn encodable_substructure(cx: &mut ExtCtxt,\n                 };\n                 let self_ref = cx.expr_addr_of(span, self_.clone());\n                 let enc = cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n-                let lambda = cx.lambda_expr_1(span, enc, blkarg);\n+                let lambda = cx.lambda1(span, enc, blkarg);\n                 let call = cx.expr_method_call(span,\n                                                blkencoder.clone(),\n                                                emit_struct_field,\n@@ -246,7 +246,7 @@ fn encodable_substructure(cx: &mut ExtCtxt,\n                     let self_ref = cx.expr_addr_of(span, self_.clone());\n                     let enc =\n                         cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n-                    let lambda = cx.lambda_expr_1(span, enc, blkarg);\n+                    let lambda = cx.lambda1(span, enc, blkarg);\n                     let call = cx.expr_method_call(span,\n                                                    blkencoder.clone(),\n                                                    emit_variant_arg,\n@@ -273,7 +273,7 @@ fn encodable_substructure(cx: &mut ExtCtxt,\n                                                 cx.expr_usize(trait_span, idx),\n                                                 cx.expr_usize(trait_span, fields.len()),\n                                                 blk]);\n-            let blk = cx.lambda_expr_1(trait_span, call, blkarg);\n+            let blk = cx.lambda1(trait_span, call, blkarg);\n             let ret = cx.expr_method_call(trait_span,\n                                           encoder,\n                                           cx.ident_of(\"emit_enum\"),"}, {"sha": "11d90658ab26a710394018faf64437376534dab4", "filename": "src/test/compile-fail/E0138.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2FE0138.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2FE0138.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0138.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -11,10 +11,10 @@\n #![feature(start)]\n \n #[start]\n-fn foo(argc: isize, argv: *const *const u8) -> isize {}\n+fn foo(argc: isize, argv: *const *const u8) -> isize { 0 }\n //~^ NOTE previous `start` function here\n \n #[start]\n-fn f(argc: isize, argv: *const *const u8) -> isize {}\n+fn f(argc: isize, argv: *const *const u8) -> isize { 0 }\n //~^ ERROR E0138\n //~| NOTE multiple `start` functions"}, {"sha": "530a0e415622815150b4d26221f1bbf95ea9561c", "filename": "src/test/compile-fail/consider-removing-last-semi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fconsider-removing-last-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fconsider-removing-last-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconsider-removing-last-semi.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f() -> String {  //~ ERROR E0269\n+fn f() -> String {  //~ ERROR mismatched types\n     0u8;\n     \"bla\".to_string();  //~ HELP consider removing this semicolon\n }\n \n-fn g() -> String {  //~ ERROR E0269\n+fn g() -> String {  //~ ERROR mismatched types\n     \"this won't work\".to_string();\n     \"removeme\".to_string(); //~ HELP consider removing this semicolon\n }"}, {"sha": "3a27c084133283775744cedb465c7c06446523b3", "filename": "src/test/compile-fail/diverging-fn-tail-35849.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fdiverging-fn-tail-35849.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fdiverging-fn-tail-35849.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdiverging-fn-tail-35849.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn _converge() -> ! { //~ ERROR computation may converge\n-    42\n+fn _converge() -> ! {\n+    42 //~ ERROR mismatched types\n }\n \n fn main() { }"}, {"sha": "192f78e41cb43cdf23d71c231f4661fc63ac3870", "filename": "src/test/compile-fail/issue-11714.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fissue-11714.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fissue-11714.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11714.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn blah() -> i32 { //~ ERROR not all control paths return a value\n+fn blah() -> i32 { //~ ERROR mismatched types\n     1\n \n     ; //~ HELP consider removing this semicolon:"}, {"sha": "9406199afc231904e58df233178c4f6c544673eb", "filename": "src/test/compile-fail/issue-13428.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fissue-13428.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fissue-13428.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13428.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -10,15 +10,15 @@\n \n // Regression test for #13428\n \n-fn foo() -> String {  //~ ERROR not all control paths return a value\n+fn foo() -> String {  //~ ERROR mismatched types\n     format!(\"Hello {}\",\n             \"world\")\n     // Put the trailing semicolon on its own line to test that the\n     // note message gets the offending semicolon exactly\n     ;   //~ HELP consider removing this semicolon\n }\n \n-fn bar() -> String {  //~ ERROR not all control paths return a value\n+fn bar() -> String {  //~ ERROR mismatched types\n     \"foobar\".to_string()\n     ;   //~ HELP consider removing this semicolon\n }"}, {"sha": "81f66e3e2cfeeb855648c2ae8b1d4af4a89a2674", "filename": "src/test/compile-fail/issue-22645.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fissue-22645.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fissue-22645.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22645.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -17,7 +17,7 @@ struct Bob;\n \n impl<RHS: Scalar> Add <RHS> for Bob {\n   type Output = Bob;\n-  fn add(self, rhs : RHS) -> Bob {}\n+  fn add(self, rhs : RHS) -> Bob { Bob }\n }\n \n fn main() {"}, {"sha": "a791758ad1763c630ae2fb9e3ae7454c81da4a57", "filename": "src/test/compile-fail/issue-22684.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fissue-22684.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fissue-22684.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22684.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -15,7 +15,7 @@ mod foo {\n     }\n \n     pub trait Baz {\n-        fn bar(&self) -> bool {}\n+        fn bar(&self) -> bool { true }\n     }\n     impl Baz for Foo {}\n }"}, {"sha": "97ba222fe45f08204f48595e3a7a21356c302fb3", "filename": "src/test/compile-fail/issue-29161.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fissue-29161.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fissue-29161.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-29161.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -13,7 +13,7 @@ mod a {\n \n     impl Default for A {\n         pub fn default() -> A { //~ ERROR unnecessary visibility qualifier\n-            A;\n+            A\n         }\n     }\n }"}, {"sha": "e5cb81303277112c6617c62b0ebe70d72c4319a0", "filename": "src/test/compile-fail/issue-32323.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fissue-32323.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fissue-32323.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32323.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -13,6 +13,6 @@ pub trait Tr<'a> {\n }\n \n pub fn f<'a, T: Tr<'a>>() -> <T as Tr<'a>>::Out {}\n-//~^ ERROR not all control paths return a value\n+//~^ ERROR mismatched types\n \n pub fn main() {}"}, {"sha": "a77b27150d7978e917a44d64b0e45d30dbc0664b", "filename": "src/test/compile-fail/issue-5239-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fissue-5239-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fissue-5239-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5239-1.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -11,7 +11,7 @@\n // Regression test for issue #5239\n \n fn main() {\n-    let x = |ref x: isize| -> isize { x += 1; };\n+    let x = |ref x: isize| { x += 1; };\n     //~^ ERROR E0368\n     //~| NOTE cannot use `+=` on type `&isize`\n }"}, {"sha": "a078cdea4ac4d70be1c1ee2eb0fc6c1ff04690c7", "filename": "src/test/compile-fail/issue-6458-4.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -8,11 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo(b: bool) -> Result<bool,String> {\n-    Err(\"bar\".to_string());\n-    //~^ ERROR unable to infer enough type information about `_` [E0282]\n-    //~| NOTE cannot infer type for `_`\n-    //~| NOTE type annotations or generic parameter binding\n+fn foo(b: bool) -> Result<bool,String> { //~ ERROR mismatched types\n+    Err(\"bar\".to_string()); //~ HELP consider removing this semicolon\n }\n \n fn main() {"}, {"sha": "1ee4be08a1c5096e78af89ec9c3d13c39c2b3b87", "filename": "src/test/compile-fail/liveness-forgot-ret.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fliveness-forgot-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fliveness-forgot-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-forgot-ret.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: not all control paths return a value\n-\n fn god_exists(a: isize) -> bool { return god_exists(a); }\n \n fn f(a: isize) -> isize { if god_exists(a) { return 5; }; }\n+//~^ ERROR mismatched types\n \n fn main() { f(12); }"}, {"sha": "69bceec8c3225ee70366326b172d6b09edbb226a", "filename": "src/test/compile-fail/liveness-issue-2163.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -13,6 +13,6 @@ use std::vec::Vec;\n fn main() {\n     let a: Vec<isize> = Vec::new();\n     a.iter().all(|_| -> bool {\n-        //~^ ERROR not all control paths return a value\n+        //~^ ERROR mismatched types\n     });\n }"}, {"sha": "a35eb1af4f336ea6019909e9e7518146ed2446da", "filename": "src/test/compile-fail/liveness-missing-ret2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fliveness-missing-ret2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fliveness-missing-ret2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-missing-ret2.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: not all control paths return a value\n-\n-fn f() -> isize {\n+fn f() -> isize { //~ ERROR mismatched types\n     // Make sure typestate doesn't interpret this match expression as\n     // the function result\n    match true { true => { } _ => {} };"}, {"sha": "ada91c38d48c3fd77b5e19d8b5aa697eb07adff4", "filename": "src/test/compile-fail/liveness-return-last-stmt-semi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fliveness-return-last-stmt-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fliveness-return-last-stmt-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-return-last-stmt-semi.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -11,16 +11,16 @@\n // regression test for #8005\n \n macro_rules! test { () => { fn foo() -> i32 { 1; } } }\n-                                           //~^ ERROR not all control paths return a value\n+                                           //~^ ERROR mismatched types\n                                            //~| HELP consider removing this semicolon\n \n-fn no_return() -> i32 {} //~ ERROR  not all control paths return a value\n+fn no_return() -> i32 {} //~ ERROR mismatched types\n \n-fn bar(x: u32) -> u32 { //~ ERROR  not all control paths return a value\n+fn bar(x: u32) -> u32 { //~ ERROR mismatched types\n     x * 2; //~ HELP consider removing this semicolon\n }\n \n-fn baz(x: u64) -> u32 { //~ ERROR  not all control paths return a value\n+fn baz(x: u64) -> u32 { //~ ERROR mismatched types\n     x * 2;\n }\n "}, {"sha": "2878cbc7fc15488d6fcfb865390be929d419f7c9", "filename": "src/test/compile-fail/main-wrong-type-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type-2.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -10,4 +10,5 @@\n \n fn main() -> char {\n //~^ ERROR: main function has wrong type\n+    ' '\n }"}, {"sha": "0f4b0919b6500842c7566ceefa0f099fb0a05bf5", "filename": "src/test/compile-fail/on-unimplemented/on-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-trait.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -16,7 +16,7 @@ trait Foo<Bar, Baz, Quux>\n {}\n \n fn foobar<U: Clone, T: Foo<u8, U, u32>>() -> T {\n-\n+    panic!()\n }\n \n #[rustc_on_unimplemented=\"a collection of type `{Self}` cannot be built from an iterator over elements of type `{A}`\"]"}, {"sha": "4796548112d9e0ae4b201cda345f95c4b93ec344", "filename": "src/test/compile-fail/private-in-public-lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-lint.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -13,7 +13,7 @@ mod m1 {\n     struct Priv;\n \n     impl Pub {\n-        pub fn f() -> Priv {} //~ ERROR private type in public interface\n+        pub fn f() -> Priv {Priv} //~ ERROR private type in public interface\n     }\n }\n \n@@ -24,7 +24,7 @@ mod m2 {\n     struct Priv;\n \n     impl Pub {\n-        pub fn f() -> Priv {} //~ ERROR private type in public interface\n+        pub fn f() -> Priv {Priv} //~ ERROR private type in public interface\n     }\n }\n "}, {"sha": "ce40702b3dc2adff68a339c812cfa578a7c5de1d", "filename": "src/test/compile-fail/required-lang-item.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Frequired-lang-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Frequired-lang-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frequired-lang-item.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -11,6 +11,7 @@\n #![feature(lang_items, no_core)]\n #![no_core]\n \n+#[lang=\"copy\"] pub trait Copy { }\n #[lang=\"sized\"] pub trait Sized { }\n \n // error-pattern:requires `start` lang_item"}, {"sha": "72462468432d9aedb4a6b49a68d0421f48c119ff", "filename": "src/test/compile-fail/unreachable-in-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Funreachable-in-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Funreachable-in-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funreachable-in-call.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -24,7 +24,7 @@ fn diverge_first() {\n          get_u8()); //~ ERROR unreachable expression\n }\n fn diverge_second() {\n-    call( //~ ERROR unreachable call\n+    call( //~ ERROR unreachable expression\n         get_u8(),\n         diverge());\n }"}, {"sha": "ffc39008c4e5a1b7ff16274fd63e1c5c485efcaf", "filename": "src/test/compile-fail/where-clauses-unsatisfied.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-unsatisfied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-unsatisfied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-unsatisfied.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn equal<T>(_: &T, _: &T) -> bool where T : Eq {\n-}\n+fn equal<T>(a: &T, b: &T) -> bool where T : Eq { a == b }\n \n struct Struct;\n "}, {"sha": "1da6735918012f11be58ef6b620cbaec9b8ca17e", "filename": "src/test/parse-fail/closure-return-syntax.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fparse-fail%2Fclosure-return-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fparse-fail%2Fclosure-return-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fclosure-return-syntax.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -12,5 +12,6 @@\n // unless it uses braces.\n \n fn main() {\n-    let x = || -> i32 22; //~ ERROR expected `{`, found `22`\n+    let x = || -> i32 22;\n+    //~^ ERROR expected one of `!`, `(`, `::`, `<`, or `{`, found `22`\n }"}, {"sha": "24b0f90d08e4d21cc56bf8c2e15e4ea142e8ce25", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 66, "deletions": 58, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -18,18 +18,18 @@\n \n // #4264 fixed-length vector types\n \n-pub fn foo(_: [i32; (3 as usize)]) { }\n+pub fn foo(_: [i32; (3 as usize)]) ({ } as ())\n \n-pub fn bar() {\n-    const FOO: usize = ((5 as usize) - (4 as usize) as usize);\n-    let _: [(); (FOO as usize)] = ([(() as ())] as [(); 1]);\n+pub fn bar() ({\n+                  const FOO: usize = ((5 as usize) - (4 as usize) as usize);\n+                  let _: [(); (FOO as usize)] = ([(() as ())] as [(); 1]);\n \n-    let _: [(); (1 as usize)] = ([(() as ())] as [(); 1]);\n+                  let _: [(); (1 as usize)] = ([(() as ())] as [(); 1]);\n \n-    let _ =\n-        (((&([(1 as i32), (2 as i32), (3 as i32)] as [i32; 3]) as &[i32; 3])\n-             as *const _ as *const [i32; 3]) as *const [i32; (3 as usize)] as\n-            *const [i32; 3]);\n+                  let _ =\n+                      (((&([(1 as i32), (2 as i32), (3 as i32)] as [i32; 3])\n+                            as &[i32; 3]) as *const _ as *const [i32; 3]) as\n+                          *const [i32; (3 as usize)] as *const [i32; 3]);\n \n \n \n@@ -38,58 +38,66 @@\n \n \n \n-    (($crate::fmt::format as\n-         fn(std::fmt::Arguments<'_>) -> std::string::String {std::fmt::format})(((::std::fmt::Arguments::new_v1\n-                                                                                     as\n-                                                                                     fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments<'_>::new_v1})(({\n-                                                                                                                                                                                                 static __STATIC_FMTSTR:\n-                                                                                                                                                                                                        &'static [&'static str]\n-                                                                                                                                                                                                        =\n-                                                                                                                                                                                                     (&([(\"test\"\n-                                                                                                                                                                                                             as\n-                                                                                                                                                                                                             &'static str)]\n-                                                                                                                                                                                                           as\n-                                                                                                                                                                                                           [&'static str; 1])\n-                                                                                                                                                                                                         as\n-                                                                                                                                                                                                         &'static [&'static str; 1]);\n-                                                                                                                                                                                                 (__STATIC_FMTSTR\n-                                                                                                                                                                                                     as\n-                                                                                                                                                                                                     &'static [&'static str])\n-                                                                                                                                                                                             }\n-                                                                                                                                                                                                as\n-                                                                                                                                                                                                &[&str]),\n-                                                                                                                                                                                            (&(match (()\n-                                                                                                                                                                                                         as\n-                                                                                                                                                                                                         ())\n-                                                                                                                                                                                                   {\n-                                                                                                                                                                                                   ()\n-                                                                                                                                                                                                   =>\n-                                                                                                                                                                                                   ([]\n-                                                                                                                                                                                                       as\n-                                                                                                                                                                                                       [std::fmt::ArgumentV1<'_>; 0]),\n-                                                                                                                                                                                               }\n-                                                                                                                                                                                                  as\n-                                                                                                                                                                                                  [std::fmt::ArgumentV1<'_>; 0])\n-                                                                                                                                                                                                as\n-                                                                                                                                                                                                &[std::fmt::ArgumentV1<'_>; 0]))\n-                                                                                    as\n-                                                                                    std::fmt::Arguments<'_>))\n-        as std::string::String);\n-}\n+\n+                  (($crate::fmt::format as\n+                       fn(std::fmt::Arguments<'_>) -> std::string::String {std::fmt::format})(((::std::fmt::Arguments::new_v1\n+                                                                                                   as\n+                                                                                                   fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments<'_>::new_v1})(({\n+                                                                                                                                                                                                               static __STATIC_FMTSTR:\n+                                                                                                                                                                                                                      &'static [&'static str]\n+                                                                                                                                                                                                                      =\n+                                                                                                                                                                                                                   (&([(\"test\"\n+                                                                                                                                                                                                                           as\n+                                                                                                                                                                                                                           &'static str)]\n+                                                                                                                                                                                                                         as\n+                                                                                                                                                                                                                         [&'static str; 1])\n+                                                                                                                                                                                                                       as\n+                                                                                                                                                                                                                       &'static [&'static str; 1]);\n+                                                                                                                                                                                                               (__STATIC_FMTSTR\n+                                                                                                                                                                                                                   as\n+                                                                                                                                                                                                                   &'static [&'static str])\n+                                                                                                                                                                                                           }\n+                                                                                                                                                                                                              as\n+                                                                                                                                                                                                              &[&str]),\n+                                                                                                                                                                                                          (&(match (()\n+                                                                                                                                                                                                                       as\n+                                                                                                                                                                                                                       ())\n+                                                                                                                                                                                                                 {\n+                                                                                                                                                                                                                 ()\n+                                                                                                                                                                                                                 =>\n+                                                                                                                                                                                                                 ([]\n+                                                                                                                                                                                                                     as\n+                                                                                                                                                                                                                     [std::fmt::ArgumentV1<'_>; 0]),\n+                                                                                                                                                                                                             }\n+                                                                                                                                                                                                                as\n+                                                                                                                                                                                                                [std::fmt::ArgumentV1<'_>; 0])\n+                                                                                                                                                                                                              as\n+                                                                                                                                                                                                              &[std::fmt::ArgumentV1<'_>; 0]))\n+                                                                                                  as\n+                                                                                                  std::fmt::Arguments<'_>))\n+                      as std::string::String);\n+              } as ())\n pub type Foo = [i32; (3 as usize)];\n pub struct Bar {\n     pub x: [i32; (3 as usize)],\n }\n pub struct TupleBar([i32; (4 as usize)]);\n pub enum Baz { BazVariant([i32; (5 as usize)]), }\n-pub fn id<T>(x: T) -> T { (x as T) }\n-pub fn use_id() {\n-    let _ =\n-        ((id::<[i32; (3 as usize)]> as\n-             fn([i32; 3]) -> [i32; 3] {id::<[i32; 3]>})(([(1 as i32),\n-                                                          (2 as i32),\n-                                                          (3 as i32)] as\n-                                                            [i32; 3])) as\n-            [i32; 3]);\n-}\n-fn main() { }\n+pub fn id<T>(x: T) -> T ({ (x as T) } as T)\n+pub fn use_id() ({\n+                     let _ =\n+                         ((id::<[i32; (3 as usize)]> as\n+                              fn([i32; 3]) -> [i32; 3] {id::<[i32; 3]>})(([(1\n+                                                                               as\n+                                                                               i32),\n+                                                                           (2\n+                                                                               as\n+                                                                               i32),\n+                                                                           (3\n+                                                                               as\n+                                                                               i32)]\n+                                                                             as\n+                                                                             [i32; 3]))\n+                             as [i32; 3]);\n+                 } as ())\n+fn main() ({ } as ())"}, {"sha": "1c443020d2e934970fef26d77a8b57fb318bdd82", "filename": "src/test/pretty/stmt_expr_attributes.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -198,14 +198,20 @@ fn _11() {\n                 };\n     let _ = #[attr] || #[attr] ();\n     let _ = #[attr] move || #[attr] ();\n-    let _ = #[attr] || {\n-        #![attr]\n-        #[attr]\n-        () };\n-    let _ = #[attr] move || {\n-        #![attr]\n-        #[attr]\n-        () };\n+    let _ =\n+        #[attr] ||\n+                    {\n+                        #![attr]\n+                        #[attr]\n+                        ()\n+                    };\n+    let _ =\n+        #[attr] move ||\n+                    {\n+                        #![attr]\n+                        #[attr]\n+                        ()\n+                    };\n     let _ =\n         #[attr] {\n                     #![attr]"}, {"sha": "8ea8370ab235d1308b4ff3d19d67e5be9f409405", "filename": "src/test/run-make/graphviz-flowgraph/f00.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff00.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff00.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff00.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -2,6 +2,8 @@ digraph block {\n     N0[label=\"entry\"];\n     N1[label=\"exit\"];\n     N2[label=\"block { }\"];\n+    N3[label=\"expr { }\"];\n     N0 -> N2;\n-    N2 -> N1;\n+    N2 -> N3;\n+    N3 -> N1;\n }"}, {"sha": "5982fbea76902905e78eaa4dc307eacdb10ddf56", "filename": "src/test/run-make/graphviz-flowgraph/f01.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff01.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff01.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff01.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -4,8 +4,10 @@ digraph block {\n     N2[label=\"expr 1\"];\n     N3[label=\"stmt 1;\"];\n     N4[label=\"block { 1; }\"];\n+    N5[label=\"expr { 1; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n-    N4 -> N1;\n+    N4 -> N5;\n+    N5 -> N1;\n }"}, {"sha": "1639785bd68c0abe7c1df7b2e11ae36e37004915", "filename": "src/test/run-make/graphviz-flowgraph/f02.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff02.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff02.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff02.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -4,8 +4,10 @@ digraph block {\n     N2[label=\"local _x\"];\n     N3[label=\"stmt let _x: isize;\"];\n     N4[label=\"block { let _x: isize; }\"];\n+    N5[label=\"expr { let _x: isize; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n-    N4 -> N1;\n+    N4 -> N5;\n+    N5 -> N1;\n }"}, {"sha": "b0ae00d81675a6ee3ccc4a5f4dec9db63cdad371", "filename": "src/test/run-make/graphviz-flowgraph/f03.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff03.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff03.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff03.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -6,10 +6,12 @@ digraph block {\n     N4[label=\"expr 3 + 4\"];\n     N5[label=\"stmt 3 + 4;\"];\n     N6[label=\"block { 3 + 4; }\"];\n+    N7[label=\"expr { 3 + 4; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n     N5 -> N6;\n-    N6 -> N1;\n+    N6 -> N7;\n+    N7 -> N1;\n }"}, {"sha": "41ace15a4c680d18194f79a45d832ab27e8b92ba", "filename": "src/test/run-make/graphviz-flowgraph/f04.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff04.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff04.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff04.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -5,9 +5,11 @@ digraph block {\n     N3[label=\"local _x\"];\n     N4[label=\"stmt let _x = 4;\"];\n     N5[label=\"block { let _x = 4; }\"];\n+    N6[label=\"expr { let _x = 4; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n-    N5 -> N1;\n+    N5 -> N6;\n+    N6 -> N1;\n }"}, {"sha": "72b8ae71751c2f7d7493ae3ed3a2157c5cb4a02d", "filename": "src/test/run-make/graphviz-flowgraph/f05.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff05.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff05.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff05.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -9,6 +9,7 @@ digraph block {\n     N7[label=\"pat (_x, _y)\"];\n     N8[label=\"stmt let (_x, _y) = (5, 55);\"];\n     N9[label=\"block { let (_x, _y) = (5, 55); }\"];\n+    N10[label=\"expr { let (_x, _y) = (5, 55); }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -17,5 +18,6 @@ digraph block {\n     N6 -> N7;\n     N7 -> N8;\n     N8 -> N9;\n-    N9 -> N1;\n+    N9 -> N10;\n+    N10 -> N1;\n }"}, {"sha": "acba71ef625ff2db3f0afe2ca9ddae3566ab5b98", "filename": "src/test/run-make/graphviz-flowgraph/f06.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff06.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff06.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff06.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -7,11 +7,13 @@ digraph block {\n     N5[label=\"pat S6 { val: _x }\"];\n     N6[label=\"stmt let S6 { val: _x } = S6{val: 6,};\"];\n     N7[label=\"block { let S6 { val: _x } = S6{val: 6,}; }\"];\n+    N8[label=\"expr { let S6 { val: _x } = S6{val: 6,}; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n     N5 -> N6;\n     N6 -> N7;\n-    N7 -> N1;\n+    N7 -> N8;\n+    N8 -> N1;\n }"}, {"sha": "251e2b39f14c8fa6be9f4d142417493c62440caa", "filename": "src/test/run-make/graphviz-flowgraph/f07.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -17,6 +17,7 @@ digraph block {\n     N15[label=\"expr x + y\"];\n     N16[label=\"stmt match [7, 77, 777, 7777] { [x, y, ..] => x + y, };\"];\n     N17[label=\"block { match [7, 77, 777, 7777] { [x, y, ..] => x + y, }; }\"];\n+    N18[label=\"expr { match [7, 77, 777, 7777] { [x, y, ..] => x + y, }; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -33,5 +34,6 @@ digraph block {\n     N15 -> N7;\n     N7 -> N16;\n     N16 -> N17;\n-    N17 -> N1;\n+    N17 -> N18;\n+    N18 -> N1;\n }"}, {"sha": "e2779c9414a9e5a9d1e7d75ad9121f313b6c992f", "filename": "src/test/run-make/graphviz-flowgraph/f08.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff08.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff08.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff08.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -16,6 +16,7 @@ digraph block {\n     N14[label=\"block { _y = 888; }\"];\n     N15[label=\"expr if x > 88 { _y = 888; }\"];\n     N16[label=\"block { let x = 8; let _y; if x > 88 { _y = 888; } }\"];\n+    N17[label=\"expr { let x = 8; let _y; if x > 88 { _y = 888; } }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -32,5 +33,6 @@ digraph block {\n     N9 -> N15;\n     N14 -> N15;\n     N15 -> N16;\n-    N16 -> N1;\n+    N16 -> N17;\n+    N17 -> N1;\n }"}, {"sha": "536abde91e81a9c3a5323ea77ccb980384c08024", "filename": "src/test/run-make/graphviz-flowgraph/f09.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff09.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff09.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff09.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -24,6 +24,7 @@ digraph block {\n     N22[label=\"expr { _y = 94 + 95; }\"];\n     N23[label=\"expr if x > 92 { _y = 93; } else { _y = 94 + 95; }\"];\n     N24[label=\"block { let x = 91; let _y; if x > 92 { _y = 93; } else { _y = 94 + 95; } }\"];\n+    N25[label=\"expr { let x = 91; let _y; if x > 92 { _y = 93; } else { _y = 94 + 95; } }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -48,5 +49,6 @@ digraph block {\n     N14 -> N23;\n     N22 -> N23;\n     N23 -> N24;\n-    N24 -> N1;\n+    N24 -> N25;\n+    N25 -> N1;\n }"}, {"sha": "a3b531b1e2f413b6984fc6f8327f3229616a4943", "filename": "src/test/run-make/graphviz-flowgraph/f10.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff10.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff10.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff10.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -15,6 +15,7 @@ digraph block {\n     N13[label=\"stmt x -= 1;\"];\n     N14[label=\"block { x -= 1; }\"];\n     N15[label=\"block { let mut x = 10; while x > 0 { x -= 1; } }\"];\n+    N16[label=\"expr { let mut x = 10; while x > 0 { x -= 1; } }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -30,5 +31,6 @@ digraph block {\n     N13 -> N14;\n     N14 -> N5;\n     N9 -> N15;\n-    N15 -> N1;\n+    N15 -> N16;\n+    N16 -> N1;\n }"}, {"sha": "70034d299ba95f7c1bb03fa7072f15213e6cd73d", "filename": "src/test/run-make/graphviz-flowgraph/f11.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff11.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff11.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff11.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -15,6 +15,7 @@ digraph block {\n     N13[label=\"expr \\\"unreachable\\\"\"];\n     N14[label=\"stmt \\\"unreachable\\\";\"];\n     N15[label=\"block { let mut _x = 11; loop  { _x -= 1; } \\\"unreachable\\\"; }\"];\n+    N16[label=\"expr { let mut _x = 11; loop  { _x -= 1; } \\\"unreachable\\\"; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -29,5 +30,6 @@ digraph block {\n     N12 -> N13;\n     N13 -> N14;\n     N14 -> N15;\n-    N15 -> N1;\n+    N15 -> N16;\n+    N16 -> N1;\n }"}, {"sha": "245afc43504c473660a2bc23c11374722c5c78c9", "filename": "src/test/run-make/graphviz-flowgraph/f12.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff12.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff12.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff12.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -22,6 +22,7 @@ digraph block {\n     N20[label=\"expr if x == 2 { break ; \\\"unreachable\\\"; }\"];\n     N21[label=\"block { x -= 1; if x == 2 { break ; \\\"unreachable\\\"; } }\"];\n     N22[label=\"block { let mut x = 12; loop  { x -= 1; if x == 2 { break ; \\\"unreachable\\\"; } } }\"];\n+    N23[label=\"expr { let mut x = 12; loop  { x -= 1; if x == 2 { break ; \\\"unreachable\\\"; } } }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -44,5 +45,6 @@ digraph block {\n     N20 -> N21;\n     N21 -> N5;\n     N6 -> N22;\n-    N22 -> N1;\n+    N22 -> N23;\n+    N23 -> N1;\n }"}, {"sha": "0f268bd0f2aeb530f58a0ad19ab250e5c585c23f", "filename": "src/test/run-make/graphviz-flowgraph/f13.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -24,6 +24,7 @@ digraph block {\n     N22[label=\"expr _y\"];\n     N23[label=\"expr _y = v + 1\"];\n     N24[label=\"block {\\l    let x = E13::E13b(13);\\l    let _y;\\l    match x { E13::E13a => _y = 1, E13::E13b(v) => _y = v + 1, }\\l}\\l\"];\n+    N25[label=\"expr {\\l    let x = E13::E13b(13);\\l    let _y;\\l    match x { E13::E13a => _y = 1, E13::E13b(v) => _y = v + 1, }\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -48,5 +49,6 @@ digraph block {\n     N22 -> N23;\n     N23 -> N10;\n     N10 -> N24;\n-    N24 -> N1;\n+    N24 -> N25;\n+    N25 -> N1;\n }"}, {"sha": "719a6cf2619d37f8dfc6f09bc5b390dcd6a90e8a", "filename": "src/test/run-make/graphviz-flowgraph/f14.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff14.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff14.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff14.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -15,6 +15,7 @@ digraph block {\n     N13[label=\"block { return; \\\"unreachable\\\"; }\"];\n     N14[label=\"expr if x > 1 { return; \\\"unreachable\\\"; }\"];\n     N15[label=\"block { let x = 14; if x > 1 { return; \\\"unreachable\\\"; } }\"];\n+    N16[label=\"expr { let x = 14; if x > 1 { return; \\\"unreachable\\\"; } }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -30,5 +31,6 @@ digraph block {\n     N7 -> N14;\n     N13 -> N14;\n     N14 -> N15;\n-    N15 -> N1;\n+    N15 -> N16;\n+    N16 -> N1;\n }"}, {"sha": "d8cbd8411e2095b47d48b9c2222a3d70881b4772", "filename": "src/test/run-make/graphviz-flowgraph/f15.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -49,6 +49,7 @@ digraph block {\n     N47[label=\"stmt x -= 5;\"];\n     N48[label=\"block {\\l    \\'inner:\\l        loop  {\\l            if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2 { break ; \\\"unreachable\\\"; }\\l            y -= 3;\\l        }\\l    y -= 4;\\l    x -= 5;\\l}\\l\"];\n     N49[label=\"block {\\l    let mut x = 15;\\l    let mut y = 151;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2 { break ; \\\"unreachable\\\"; }\\l                    y -= 3;\\l                }\\l            y -= 4;\\l            x -= 5;\\l        }\\l}\\l\"];\n+    N50[label=\"expr {\\l    let mut x = 15;\\l    let mut y = 151;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2 { break ; \\\"unreachable\\\"; }\\l                    y -= 3;\\l                }\\l            y -= 4;\\l            x -= 5;\\l        }\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -99,5 +100,6 @@ digraph block {\n     N47 -> N48;\n     N48 -> N8;\n     N9 -> N49;\n-    N49 -> N1;\n+    N49 -> N50;\n+    N50 -> N1;\n }"}, {"sha": "b11881247fb6a3d8dd1d2dfb9b7aaa0da916689b", "filename": "src/test/run-make/graphviz-flowgraph/f16.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -52,6 +52,7 @@ digraph block {\n     N50[label=\"expr \\\"unreachable\\\"\"];\n     N51[label=\"stmt \\\"unreachable\\\";\"];\n     N52[label=\"block {\\l    let mut x = 16;\\l    let mut y = 16;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 1 { break ; \\\"unreachable\\\"; }\\l                    y -= 1;\\l                }\\l            y -= 1;\\l            x -= 1;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n+    N53[label=\"expr {\\l    let mut x = 16;\\l    let mut y = 16;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 1 { break ; \\\"unreachable\\\"; }\\l                    y -= 1;\\l                }\\l            y -= 1;\\l            x -= 1;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -105,5 +106,6 @@ digraph block {\n     N49 -> N50;\n     N50 -> N51;\n     N51 -> N52;\n-    N52 -> N1;\n+    N52 -> N53;\n+    N53 -> N1;\n }"}, {"sha": "705eece77558dcc38d262cd116f6ea9fd5f19084", "filename": "src/test/run-make/graphviz-flowgraph/f17.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff17.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff17.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff17.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -8,12 +8,14 @@ digraph block {\n     N6[label=\"local _v\"];\n     N7[label=\"stmt let _v = [1, 7, 17];\"];\n     N8[label=\"block { let _v = [1, 7, 17]; }\"];\n+    N9[label=\"expr { let _v = [1, 7, 17]; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n     N5 -> N6;\n     N6 -> N7;\n     N7 -> N8;\n-    N8 -> N1;\n+    N8 -> N9;\n+    N9 -> N1;\n }"}, {"sha": "c1d6e3023fbc163eb6954560c05fad3a5fdb0621", "filename": "src/test/run-make/graphviz-flowgraph/f18.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff18.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff18.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff18.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -9,6 +9,7 @@ digraph block {\n     N7[label=\"expr inner(inner(18))\"];\n     N8[label=\"stmt inner(inner(18));\"];\n     N9[label=\"block { inner(inner(18)); }\"];\n+    N10[label=\"expr { inner(inner(18)); }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -17,5 +18,6 @@ digraph block {\n     N6 -> N7;\n     N7 -> N8;\n     N8 -> N9;\n-    N9 -> N1;\n+    N9 -> N10;\n+    N10 -> N1;\n }"}, {"sha": "d2f9f41f647beb48e6772f75f402e150abf6941d", "filename": "src/test/run-make/graphviz-flowgraph/f19.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff19.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff19.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff19.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -12,6 +12,7 @@ digraph block {\n     N10[label=\"expr s.inner().inner()\"];\n     N11[label=\"stmt s.inner().inner();\"];\n     N12[label=\"block { let s = S19{x: 19,}; s.inner().inner(); }\"];\n+    N13[label=\"expr { let s = S19{x: 19,}; s.inner().inner(); }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -23,5 +24,6 @@ digraph block {\n     N9 -> N10;\n     N10 -> N11;\n     N11 -> N12;\n-    N12 -> N1;\n+    N12 -> N13;\n+    N13 -> N1;\n }"}, {"sha": "120eab4dac909e6652a53c9688a7220476a6f8b6", "filename": "src/test/run-make/graphviz-flowgraph/f20.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff20.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff20.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff20.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -12,6 +12,7 @@ digraph block {\n     N10[label=\"expr v[20]\"];\n     N11[label=\"stmt v[20];\"];\n     N12[label=\"block { let v = [2, 0, 20]; v[20]; }\"];\n+    N13[label=\"expr { let v = [2, 0, 20]; v[20]; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -23,5 +24,6 @@ digraph block {\n     N9 -> N10;\n     N10 -> N11;\n     N11 -> N12;\n-    N12 -> N1;\n+    N12 -> N13;\n+    N13 -> N1;\n }"}, {"sha": "370dcdd8554da3071f7f2f0609f3277173b853f2", "filename": "src/test/run-make/graphviz-flowgraph/f21.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff21.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff21.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff21.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -47,6 +47,7 @@ digraph block {\n     N45[label=\"stmt \\\"unreachable\\\";\"];\n     N46[label=\"block {\\l    \\'inner:\\l        loop  {\\l            if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2 { return; \\\"unreachable\\\"; }\\l            y -= 3;\\l            x -= 5;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n     N47[label=\"block {\\l    let mut x = 15;\\l    let mut y = 151;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2 { return; \\\"unreachable\\\"; }\\l                    y -= 3;\\l                    x -= 5;\\l                }\\l            \\\"unreachable\\\";\\l        }\\l}\\l\"];\n+    N48[label=\"expr {\\l    let mut x = 15;\\l    let mut y = 151;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2 { return; \\\"unreachable\\\"; }\\l                    y -= 3;\\l                    x -= 5;\\l                }\\l            \\\"unreachable\\\";\\l        }\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -95,5 +96,6 @@ digraph block {\n     N45 -> N46;\n     N46 -> N8;\n     N9 -> N47;\n-    N47 -> N1;\n+    N47 -> N48;\n+    N48 -> N1;\n }"}, {"sha": "9d3bc22831a139f1aee227b24747d12cee5efcbb", "filename": "src/test/run-make/graphviz-flowgraph/f22.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff22.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff22.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff22.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -50,6 +50,7 @@ digraph block {\n     N48[label=\"expr \\\"unreachable\\\"\"];\n     N49[label=\"stmt \\\"unreachable\\\";\"];\n     N50[label=\"block {\\l    let mut x = 15;\\l    let mut y = 151;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2 { return; \\\"unreachable\\\"; }\\l                    x -= 1;\\l                    y -= 3;\\l                }\\l            \\\"unreachable\\\";\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n+    N51[label=\"expr {\\l    let mut x = 15;\\l    let mut y = 151;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2 { return; \\\"unreachable\\\"; }\\l                    x -= 1;\\l                    y -= 3;\\l                }\\l            \\\"unreachable\\\";\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -101,5 +102,6 @@ digraph block {\n     N47 -> N48;\n     N48 -> N49;\n     N49 -> N50;\n-    N50 -> N1;\n+    N50 -> N51;\n+    N51 -> N1;\n }"}, {"sha": "f152977438c505d87a932e5680012be93872eb69", "filename": "src/test/run-make/graphviz-flowgraph/f23.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -52,6 +52,7 @@ digraph block {\n     N50[label=\"block { y -= 1; while z > 0 { z -= 1; } if x > 10 { return; \\\"unreachable\\\"; } }\"];\n     N51[label=\"block {\\l    x -= 1;\\l    while y > 0 {\\l        y -= 1;\\l        while z > 0 { z -= 1; }\\l        if x > 10 { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n     N52[label=\"block {\\l    let mut x = 23;\\l    let mut y = 23;\\l    let mut z = 23;\\l    while x > 0 {\\l        x -= 1;\\l        while y > 0 {\\l            y -= 1;\\l            while z > 0 { z -= 1; }\\l            if x > 10 { return; \\\"unreachable\\\"; }\\l        }\\l    }\\l}\\l\"];\n+    N53[label=\"expr {\\l    let mut x = 23;\\l    let mut y = 23;\\l    let mut z = 23;\\l    while x > 0 {\\l        x -= 1;\\l        while y > 0 {\\l            y -= 1;\\l            while z > 0 { z -= 1; }\\l            if x > 10 { return; \\\"unreachable\\\"; }\\l        }\\l    }\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -107,5 +108,6 @@ digraph block {\n     N24 -> N51;\n     N51 -> N11;\n     N15 -> N52;\n-    N52 -> N1;\n+    N52 -> N53;\n+    N53 -> N1;\n }"}, {"sha": "e40dd014f0a4de54a49a3057ddc612f9ebb0a15a", "filename": "src/test/run-make/graphviz-flowgraph/f24.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff24.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff24.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff24.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -76,6 +76,7 @@ digraph block {\n     N74[label=\"block {\\l    if y == 0 { break ; \\\"unreachable\\\"; }\\l    y -= 1;\\l    loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l    if x > 10 { return; \\\"unreachable\\\"; }\\l}\\l\"];\n     N75[label=\"block {\\l    if x == 0 { break ; \\\"unreachable\\\"; }\\l    x -= 1;\\l    loop  {\\l        if y == 0 { break ; \\\"unreachable\\\"; }\\l        y -= 1;\\l        loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l        if x > 10 { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n     N76[label=\"block {\\l    let mut x = 24;\\l    let mut y = 24;\\l    let mut z = 24;\\l    loop  {\\l        if x == 0 { break ; \\\"unreachable\\\"; }\\l        x -= 1;\\l        loop  {\\l            if y == 0 { break ; \\\"unreachable\\\"; }\\l            y -= 1;\\l            loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l            if x > 10 { return; \\\"unreachable\\\"; }\\l        }\\l    }\\l}\\l\"];\n+    N77[label=\"expr {\\l    let mut x = 24;\\l    let mut y = 24;\\l    let mut z = 24;\\l    loop  {\\l        if x == 0 { break ; \\\"unreachable\\\"; }\\l        x -= 1;\\l        loop  {\\l            if y == 0 { break ; \\\"unreachable\\\"; }\\l            y -= 1;\\l            loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l            if x > 10 { return; \\\"unreachable\\\"; }\\l        }\\l    }\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -155,5 +156,6 @@ digraph block {\n     N29 -> N75;\n     N75 -> N11;\n     N12 -> N76;\n-    N76 -> N1;\n+    N76 -> N77;\n+    N77 -> N1;\n }"}, {"sha": "1e2df1ab5e7b7ba10baf7d45462bf8b808ca8e98", "filename": "src/test/run-make/graphviz-flowgraph/f25.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff25.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/368281a11063e1f3e73832f7fdd321647182692b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff25.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff25.dot-expected.dot?ref=368281a11063e1f3e73832f7fdd321647182692b", "patch": "@@ -76,6 +76,7 @@ digraph block {\n     N74[label=\"block {\\l    if y == 0 { break ; \\\"unreachable\\\"; }\\l    y -= 1;\\l    \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l    if x > 10 { continue \\'a ; \\\"unreachable\\\"; }\\l}\\l\"];\n     N75[label=\"block {\\l    if x == 0 { break ; \\\"unreachable\\\"; }\\l    x -= 1;\\l    \\'a:\\l        loop  {\\l            if y == 0 { break ; \\\"unreachable\\\"; }\\l            y -= 1;\\l            \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l            if x > 10 { continue \\'a ; \\\"unreachable\\\"; }\\l        }\\l}\\l\"];\n     N76[label=\"block {\\l    let mut x = 25;\\l    let mut y = 25;\\l    let mut z = 25;\\l    \\'a:\\l        loop  {\\l            if x == 0 { break ; \\\"unreachable\\\"; }\\l            x -= 1;\\l            \\'a:\\l                loop  {\\l                    if y == 0 { break ; \\\"unreachable\\\"; }\\l                    y -= 1;\\l                    \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l                    if x > 10 { continue \\'a ; \\\"unreachable\\\"; }\\l                }\\l        }\\l}\\l\"];\n+    N77[label=\"expr {\\l    let mut x = 25;\\l    let mut y = 25;\\l    let mut z = 25;\\l    \\'a:\\l        loop  {\\l            if x == 0 { break ; \\\"unreachable\\\"; }\\l            x -= 1;\\l            \\'a:\\l                loop  {\\l                    if y == 0 { break ; \\\"unreachable\\\"; }\\l                    y -= 1;\\l                    \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l                    if x > 10 { continue \\'a ; \\\"unreachable\\\"; }\\l                }\\l        }\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -155,5 +156,6 @@ digraph block {\n     N29 -> N75;\n     N75 -> N11;\n     N12 -> N76;\n-    N76 -> N1;\n+    N76 -> N77;\n+    N77 -> N1;\n }"}]}