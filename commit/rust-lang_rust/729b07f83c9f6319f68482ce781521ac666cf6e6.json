{"sha": "729b07f83c9f6319f68482ce781521ac666cf6e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyOWIwN2Y4M2M5ZjYzMTlmNjg0ODJjZTc4MTUyMWFjNjY2Y2Y2ZTY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-06-20T19:25:52Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-07-08T17:55:10Z"}, "message": "Modify borrow checker to visit irrefutable patterns that appear in\nlet and function arguments; modify type checker to store type\ninformation for all patterns and handles some missing cases.", "tree": {"sha": "614e42d094d600d95a97549e9e0cd7d6c94dfe64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/614e42d094d600d95a97549e9e0cd7d6c94dfe64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/729b07f83c9f6319f68482ce781521ac666cf6e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/729b07f83c9f6319f68482ce781521ac666cf6e6", "html_url": "https://github.com/rust-lang/rust/commit/729b07f83c9f6319f68482ce781521ac666cf6e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/729b07f83c9f6319f68482ce781521ac666cf6e6/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d3262ca7b94b53178daa06fa72d5427584ae842", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d3262ca7b94b53178daa06fa72d5427584ae842", "html_url": "https://github.com/rust-lang/rust/commit/2d3262ca7b94b53178daa06fa72d5427584ae842"}], "stats": {"total": 400, "additions": 249, "deletions": 151}, "files": [{"sha": "a455bdc436cadb1c2be881b410dbd8aa1c1707ef", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 40, "deletions": 51, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/729b07f83c9f6319f68482ce781521ac666cf6e6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/729b07f83c9f6319f68482ce781521ac666cf6e6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=729b07f83c9f6319f68482ce781521ac666cf6e6", "patch": "@@ -65,7 +65,7 @@ pub fn check_loans(bccx: @BorrowckCtxt,\n \n enum MoveError {\n     MoveOk,\n-    MoveWhileBorrowed(/*move*/@LoanPath, /*loan*/@LoanPath, /*loan*/span)\n+    MoveWhileBorrowed(/*loan*/@LoanPath, /*loan*/span)\n }\n \n impl<'self> CheckLoanCtxt<'self> {\n@@ -348,7 +348,7 @@ impl<'self> CheckLoanCtxt<'self> {\n                         cmt = b;\n                     }\n \n-                    mc::cat_rvalue |\n+                    mc::cat_rvalue(*) |\n                     mc::cat_static_item |\n                     mc::cat_implicit_self |\n                     mc::cat_copied_upvar(*) |\n@@ -547,45 +547,50 @@ impl<'self> CheckLoanCtxt<'self> {\n                  self.bccx.loan_path_to_str(loan_path)));\n     }\n \n-    pub fn check_move_out_from_expr(&self, ex: @ast::expr) {\n-        match ex.node {\n-            ast::expr_paren(*) => {\n-                /* In the case of an expr_paren(), the expression inside\n-                 * the parens will also be marked as being moved.  Ignore\n-                 * the parents then so as not to report duplicate errors. */\n+    fn check_move_out_from_expr(&self, expr: @ast::expr) {\n+        match expr.node {\n+            ast::expr_fn_block(*) => {\n+                // moves due to capture clauses are checked\n+                // in `check_loans_in_fn`, so that we can\n+                // give a better error message\n             }\n             _ => {\n-                let cmt = self.bccx.cat_expr(ex);\n-                match self.analyze_move_out_from_cmt(cmt) {\n-                    MoveOk => {}\n-                    MoveWhileBorrowed(move_path, loan_path, loan_span) => {\n-                        self.bccx.span_err(\n-                            cmt.span,\n-                            fmt!(\"cannot move out of `%s` \\\n-                                  because it is borrowed\",\n-                                 self.bccx.loan_path_to_str(move_path)));\n-                        self.bccx.span_note(\n-                            loan_span,\n-                            fmt!(\"borrow of `%s` occurs here\",\n-                                 self.bccx.loan_path_to_str(loan_path)));\n-                    }\n+                self.check_move_out_from_id(expr.id, expr.span)\n+            }\n+        }\n+    }\n+\n+    fn check_move_out_from_id(&self, id: ast::node_id, span: span) {\n+        for self.move_data.each_path_moved_by(id) |_, move_path| {\n+            match self.analyze_move_out_from(id, move_path) {\n+                MoveOk => {}\n+                MoveWhileBorrowed(loan_path, loan_span) => {\n+                    self.bccx.span_err(\n+                        span,\n+                        fmt!(\"cannot move out of `%s` \\\n+                              because it is borrowed\",\n+                             self.bccx.loan_path_to_str(move_path)));\n+                    self.bccx.span_note(\n+                        loan_span,\n+                        fmt!(\"borrow of `%s` occurs here\",\n+                             self.bccx.loan_path_to_str(loan_path)));\n                 }\n             }\n         }\n     }\n \n-    pub fn analyze_move_out_from_cmt(&self, cmt: mc::cmt) -> MoveError {\n-        debug!(\"analyze_move_out_from_cmt(cmt=%s)\", cmt.repr(self.tcx()));\n+    pub fn analyze_move_out_from(&self,\n+                                 expr_id: ast::node_id,\n+                                 move_path: @LoanPath) -> MoveError {\n+        debug!(\"analyze_move_out_from(expr_id=%?, move_path=%s)\",\n+               expr_id, move_path.repr(self.tcx()));\n \n         // FIXME(#4384) inadequare if/when we permit `move a.b`\n \n         // check for a conflicting loan:\n-        let r = opt_loan_path(cmt);\n-        for r.iter().advance |&lp| {\n-            for self.each_in_scope_restriction(cmt.id, lp) |loan, _| {\n-                // Any restriction prevents moves.\n-                return MoveWhileBorrowed(lp, loan.loan_path, loan.span);\n-            }\n+        for self.each_in_scope_restriction(expr_id, move_path) |loan, _| {\n+            // Any restriction prevents moves.\n+            return MoveWhileBorrowed(loan.loan_path, loan.span);\n         }\n \n         MoveOk\n@@ -652,13 +657,11 @@ fn check_loans_in_fn<'a>(fk: &visit::fn_kind,\n                                  closure_id: ast::node_id,\n                                  cap_var: &moves::CaptureVar) {\n             let var_id = ast_util::def_id_of_def(cap_var.def).node;\n-            let ty = ty::node_id_to_type(this.tcx(), var_id);\n-            let cmt = this.bccx.cat_def(closure_id, cap_var.span,\n-                                        ty, cap_var.def);\n-            let move_err = this.analyze_move_out_from_cmt(cmt);\n+            let move_path = @LpVar(var_id);\n+            let move_err = this.analyze_move_out_from(closure_id, move_path);\n             match move_err {\n                 MoveOk => {}\n-                MoveWhileBorrowed(move_path, loan_path, loan_span) => {\n+                MoveWhileBorrowed(loan_path, loan_span) => {\n                     this.bccx.span_err(\n                         cap_var.span,\n                         fmt!(\"cannot move `%s` into closure \\\n@@ -689,10 +692,7 @@ fn check_loans_in_expr<'a>(expr: @ast::expr,\n            expr.repr(this.tcx()));\n \n     this.check_for_conflicting_loans(expr.id);\n-\n-    if this.bccx.moves_map.contains(&expr.id) {\n-        this.check_move_out_from_expr(expr);\n-    }\n+    this.check_move_out_from_expr(expr);\n \n     match expr.node {\n       ast::expr_self |\n@@ -742,18 +742,7 @@ fn check_loans_in_pat<'a>(pat: @ast::pat,\n                                        visit::vt<@mut CheckLoanCtxt<'a>>))\n {\n     this.check_for_conflicting_loans(pat.id);\n-\n-    // Note: moves out of pattern bindings are not checked by\n-    // the borrow checker, at least not directly.  What happens\n-    // is that if there are any moved bindings, the discriminant\n-    // will be considered a move, and this will be checked as\n-    // normal.  Then, in `middle::check_match`, we will check\n-    // that no move occurs in a binding that is underneath an\n-    // `@` or `&`.  Together these give the same guarantees as\n-    // `check_move_out_from_expr()` without requiring us to\n-    // rewalk the patterns and rebuild the pattern\n-    // categorizations.\n-\n+    this.check_move_out_from_id(pat.id, pat.span);\n     visit::visit_pat(pat, (this, vt));\n }\n "}, {"sha": "5d91916d0044a07ac1f90ecd4e6d98ea8676e7bc", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/729b07f83c9f6319f68482ce781521ac666cf6e6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/729b07f83c9f6319f68482ce781521ac666cf6e6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=729b07f83c9f6319f68482ce781521ac666cf6e6", "patch": "@@ -67,7 +67,7 @@ impl GuaranteeLifetimeContext {\n         //! Main routine. Walks down `cmt` until we find the \"guarantor\".\n \n         match cmt.cat {\n-            mc::cat_rvalue |\n+            mc::cat_rvalue(*) |\n             mc::cat_implicit_self |\n             mc::cat_copied_upvar(*) |                  // L-Local\n             mc::cat_local(*) |                         // L-Local\n@@ -179,7 +179,7 @@ impl GuaranteeLifetimeContext {\n         //! lvalue.\n \n         cmt.mutbl.is_immutable() || match cmt.guarantor().cat {\n-            mc::cat_rvalue => true,\n+            mc::cat_rvalue(*) => true,\n             _ => false\n         }\n     }\n@@ -299,7 +299,7 @@ impl GuaranteeLifetimeContext {\n             mc::cat_arg(id) => {\n                 self.bccx.moved_variables_set.contains(&id)\n             }\n-            mc::cat_rvalue |\n+            mc::cat_rvalue(*) |\n             mc::cat_static_item |\n             mc::cat_implicit_self |\n             mc::cat_copied_upvar(*) |\n@@ -325,8 +325,8 @@ impl GuaranteeLifetimeContext {\n         // See the SCOPE(LV) function in doc.rs\n \n         match cmt.cat {\n-            mc::cat_rvalue => {\n-                ty::re_scope(self.bccx.tcx.region_maps.cleanup_scope(cmt.id))\n+            mc::cat_rvalue(cleanup_scope_id) => {\n+                ty::re_scope(cleanup_scope_id)\n             }\n             mc::cat_implicit_self |\n             mc::cat_copied_upvar(_) => {"}, {"sha": "86baf53528427287e447bf10eef9a14dbe11b9bc", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 95, "deletions": 34, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/729b07f83c9f6319f68482ce781521ac666cf6e6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/729b07f83c9f6319f68482ce781521ac666cf6e6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=729b07f83c9f6319f68482ce781521ac666cf6e6", "patch": "@@ -73,6 +73,7 @@ struct GatherLoanCtxt {\n }\n \n pub fn gather_loans(bccx: @BorrowckCtxt,\n+                    decl: &ast::fn_decl,\n                     body: &ast::blk)\n                     -> (id_range, @mut ~[Loan], @mut move_data::MoveData) {\n     let glcx = @mut GatherLoanCtxt {\n@@ -83,6 +84,7 @@ pub fn gather_loans(bccx: @BorrowckCtxt,\n         repeating_ids: ~[body.node.id],\n         move_data: @mut MoveData::new()\n     };\n+    glcx.gather_fn_arg_patterns(decl, body);\n     let v = visit::mk_vt(@visit::Visitor {visit_expr: gather_loans_in_expr,\n                                           visit_block: gather_loans_in_block,\n                                           visit_fn: gather_loans_in_fn,\n@@ -124,6 +126,7 @@ fn gather_loans_in_fn(fk: &visit::fn_kind,\n             this.push_repeating_id(body.node.id);\n             visit::visit_fn(fk, decl, body, sp, id, (this, v));\n             this.pop_repeating_id(body.node.id);\n+            this.gather_fn_arg_patterns(decl, body);\n         }\n     }\n }\n@@ -138,26 +141,33 @@ fn gather_loans_in_block(blk: &ast::blk,\n fn gather_loans_in_local(local: @ast::local,\n                          (this, vt): (@mut GatherLoanCtxt,\n                                       visit::vt<@mut GatherLoanCtxt>)) {\n-    if local.node.init.is_none() {\n-        // Variable declarations without initializers are considered \"moves\":\n-        let tcx = this.bccx.tcx;\n-        do pat_util::pat_bindings(tcx.def_map, local.node.pat) |_, id, span, _| {\n-            gather_moves::gather_decl(this.bccx,\n-                                      this.move_data,\n-                                      id,\n-                                      span,\n-                                      id);\n+    match local.node.init {\n+        None => {\n+            // Variable declarations without initializers are considered \"moves\":\n+            let tcx = this.bccx.tcx;\n+            do pat_util::pat_bindings(tcx.def_map, local.node.pat)\n+                |_, id, span, _| {\n+                gather_moves::gather_decl(this.bccx,\n+                                          this.move_data,\n+                                          id,\n+                                          span,\n+                                          id);\n+            }\n         }\n-    } else {\n-        // Variable declarations with initializers are considered \"assigns\":\n-        let tcx = this.bccx.tcx;\n-        do pat_util::pat_bindings(tcx.def_map, local.node.pat) |_, id, span, _| {\n-            gather_moves::gather_assignment(this.bccx,\n-                                            this.move_data,\n-                                            id,\n-                                            span,\n-                                            @LpVar(id),\n-                                            id);\n+        Some(init) => {\n+            // Variable declarations with initializers are considered \"assigns\":\n+            let tcx = this.bccx.tcx;\n+            do pat_util::pat_bindings(tcx.def_map, local.node.pat)\n+                |_, id, span, _| {\n+                gather_moves::gather_assignment(this.bccx,\n+                                                this.move_data,\n+                                                id,\n+                                                span,\n+                                                @LpVar(id),\n+                                                id);\n+            }\n+            let init_cmt = this.bccx.cat_expr(init);\n+            this.gather_pat(init_cmt, local.node.pat, None);\n         }\n     }\n \n@@ -230,7 +240,7 @@ fn gather_loans_in_expr(ex: @ast::expr,\n         let cmt = this.bccx.cat_expr(ex_v);\n         for arms.iter().advance |arm| {\n             for arm.pats.iter().advance |pat| {\n-                this.gather_pat(cmt, *pat, arm.body.node.id, ex.id);\n+                this.gather_pat(cmt, *pat, Some((arm.body.node.id, ex.id)));\n             }\n         }\n         visit::visit_expr(ex, (this, vt));\n@@ -596,11 +606,40 @@ impl GatherLoanCtxt {\n         }\n     }\n \n-    pub fn gather_pat(&mut self,\n-                      discr_cmt: mc::cmt,\n-                      root_pat: @ast::pat,\n-                      arm_body_id: ast::node_id,\n-                      match_id: ast::node_id) {\n+    fn gather_fn_arg_patterns(&mut self,\n+                              decl: &ast::fn_decl,\n+                              body: &ast::blk) {\n+        /*!\n+         * Walks the patterns for fn arguments, checking that they\n+         * do not attempt illegal moves or create refs that outlive\n+         * the arguments themselves. Just a shallow wrapper around\n+         * `gather_pat()`.\n+         */\n+\n+        let mc_ctxt = self.bccx.mc_ctxt();\n+        for decl.inputs.each |arg| {\n+            let arg_ty = ty::node_id_to_type(self.tcx(), arg.pat.id);\n+\n+            let arg_cmt = mc_ctxt.cat_rvalue(\n+                arg.id,\n+                arg.pat.span,\n+                body.node.id, // Arguments live only as long as the fn body.\n+                arg_ty);\n+\n+            self.gather_pat(arg_cmt, arg.pat, None);\n+        }\n+    }\n+\n+    fn gather_pat(&mut self,\n+                  discr_cmt: mc::cmt,\n+                  root_pat: @ast::pat,\n+                  arm_match_ids: Option<(ast::node_id, ast::node_id)>) {\n+        /*!\n+         * Walks patterns, examining the bindings to determine if they\n+         * cause borrows (`ref` bindings, vector patterns) or\n+         * moves (non-`ref` bindings with linear type).\n+         */\n+\n         do self.bccx.cat_pattern(discr_cmt, root_pat) |cmt, pat| {\n             match pat.node {\n               ast::pat_ident(bm, _, _) if self.pat_is_binding(pat) => {\n@@ -621,15 +660,19 @@ impl GatherLoanCtxt {\n                     // with a cat_discr() node.  There is a detailed\n                     // discussion of the function of this node in\n                     // `lifetime.rs`:\n-                    let arm_scope = ty::re_scope(arm_body_id);\n-                    if self.bccx.is_subregion_of(scope_r, arm_scope) {\n-                        let cmt_discr = self.bccx.cat_discr(cmt, match_id);\n-                        self.guarantee_valid(pat.id, pat.span,\n-                                             cmt_discr, mutbl, scope_r);\n-                    } else {\n-                        self.guarantee_valid(pat.id, pat.span,\n-                                             cmt, mutbl, scope_r);\n-                    }\n+                    let cmt_discr = match arm_match_ids {\n+                        None => cmt,\n+                        Some((arm_id, match_id)) => {\n+                            let arm_scope = ty::re_scope(arm_id);\n+                            if self.bccx.is_subregion_of(scope_r, arm_scope) {\n+                                self.bccx.cat_discr(cmt, match_id)\n+                            } else {\n+                                cmt\n+                            }\n+                        }\n+                    };\n+                    self.guarantee_valid(pat.id, pat.span,\n+                                         cmt_discr, mutbl, scope_r);\n                   }\n                   ast::bind_infer => {\n                       // No borrows here, but there may be moves\n@@ -652,6 +695,24 @@ impl GatherLoanCtxt {\n                       self.vec_slice_info(slice_pat, slice_ty);\n                   let mcx = self.bccx.mc_ctxt();\n                   let cmt_index = mcx.cat_index(slice_pat, cmt, 0);\n+\n+                  // Note: We declare here that the borrow occurs upon\n+                  // entering the `[...]` pattern. This implies that\n+                  // something like `[a, ..b]` where `a` is a move is\n+                  // illegal, because the borrow is already in effect.\n+                  // In fact such a move would be safe-ish, but it\n+                  // effectively *requires* that we use the nulling\n+                  // out semantics to indicate when a value has been\n+                  // moved, which we are trying to move away from.\n+                  // Otherwise, how can we indicate that the first\n+                  // element in the vector has been moved?\n+                  // Eventually, we could perhaps modify this rule to\n+                  // permit `[..a, b]` where `b` is a move, because in\n+                  // that case we can adjust the length of the\n+                  // original vec accordingly, but we'd have to make\n+                  // trans do the right thing, and it would only work\n+                  // for `~` vectors. It seems simpler to just require\n+                  // that people call `vec.pop()` or `vec.unshift()`.\n                   self.guarantee_valid(pat.id, pat.span,\n                                        cmt_index, slice_mutbl, slice_r);\n               }"}, {"sha": "e568da5eedfae98a65ffa90c25c8e09745c1b94b", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/729b07f83c9f6319f68482ce781521ac666cf6e6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/729b07f83c9f6319f68482ce781521ac666cf6e6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=729b07f83c9f6319f68482ce781521ac666cf6e6", "patch": "@@ -64,7 +64,7 @@ impl RestrictionsContext {\n         }\n \n         match cmt.cat {\n-            mc::cat_rvalue => {\n+            mc::cat_rvalue(*) => {\n                 // Effectively, rvalues are stored into a\n                 // non-aliasable temporary on the stack. Since they\n                 // are inherently non-aliasable, they can only be"}, {"sha": "47d35d73df09bbdd4a191cabf2e66e1021f3b7e6", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/729b07f83c9f6319f68482ce781521ac666cf6e6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/729b07f83c9f6319f68482ce781521ac666cf6e6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=729b07f83c9f6319f68482ce781521ac666cf6e6", "patch": "@@ -124,7 +124,7 @@ fn borrowck_fn(fk: &visit::fn_kind,\n \n             // Check the body of fn items.\n             let (id_range, all_loans, move_data) =\n-                gather_loans::gather_loans(this, body);\n+                gather_loans::gather_loans(this, decl, body);\n             let mut loan_dfcx =\n                 DataFlowContext::new(this.tcx,\n                                      this.method_map,\n@@ -264,7 +264,7 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n     //! traverses the CMT.\n \n     match cmt.cat {\n-        mc::cat_rvalue |\n+        mc::cat_rvalue(*) |\n         mc::cat_static_item |\n         mc::cat_copied_upvar(_) |\n         mc::cat_implicit_self => {\n@@ -485,7 +485,7 @@ impl BorrowckCtxt {\n \n     pub fn mc_ctxt(&self) -> mc::mem_categorization_ctxt {\n         mc::mem_categorization_ctxt {tcx: self.tcx,\n-                                 method_map: self.method_map}\n+                                     method_map: self.method_map}\n     }\n \n     pub fn cat_pattern(&self,"}, {"sha": "7ec1ff3c628e4ad3ca018485b572fbb733aadde1", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/729b07f83c9f6319f68482ce781521ac666cf6e6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/729b07f83c9f6319f68482ce781521ac666cf6e6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=729b07f83c9f6319f68482ce781521ac666cf6e6", "patch": "@@ -474,6 +474,24 @@ impl FlowedMoveData {\n         }\n     }\n \n+    pub fn each_path_moved_by(&self,\n+                              id: ast::node_id,\n+                              f: &fn(&Move, @LoanPath) -> bool)\n+                              -> bool {\n+        /*!\n+         * Iterates through each path moved by `id`\n+         */\n+\n+        for self.dfcx_moves.each_gen_bit_frozen(id) |index| {\n+            let move = &self.move_data.moves[index];\n+            let moved_path = move.path;\n+            if !f(move, self.move_data.path(moved_path).loan_path) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n     pub fn each_move_of(&self,\n                         id: ast::node_id,\n                         loan_path: @LoanPath,"}, {"sha": "02f7294ffcd3b604cce5d438deb26a42aa3ac28f", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/729b07f83c9f6319f68482ce781521ac666cf6e6/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/729b07f83c9f6319f68482ce781521ac666cf6e6/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=729b07f83c9f6319f68482ce781521ac666cf6e6", "patch": "@@ -49,23 +49,13 @@ pub fn check_crate(tcx: ty::ctxt,\n     tcx.sess.abort_if_errors();\n }\n \n-pub fn expr_is_non_moving_lvalue(cx: &MatchCheckCtxt, expr: &expr) -> bool {\n-    if !ty::expr_is_lval(cx.tcx, cx.method_map, expr) {\n-        return false;\n-    }\n-\n-    !cx.moves_map.contains(&expr.id)\n-}\n-\n pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, (s, v): ((), visit::vt<()>)) {\n     visit::visit_expr(ex, (s, v));\n     match ex.node {\n       expr_match(scrut, ref arms) => {\n         // First, check legality of move bindings.\n-        let is_non_moving_lvalue = expr_is_non_moving_lvalue(cx, ex);\n         for arms.iter().advance |arm| {\n             check_legality_of_move_bindings(cx,\n-                                            is_non_moving_lvalue,\n                                             arm.guard.is_some(),\n                                             arm.pats);\n         }\n@@ -758,11 +748,7 @@ pub fn check_local(cx: &MatchCheckCtxt,\n     }\n \n     // Check legality of move bindings.\n-    let is_lvalue = match loc.node.init {\n-        Some(init) => expr_is_non_moving_lvalue(cx, init),\n-        None => true\n-    };\n-    check_legality_of_move_bindings(cx, is_lvalue, false, [ loc.node.pat ]);\n+    check_legality_of_move_bindings(cx, false, [ loc.node.pat ]);\n }\n \n pub fn check_fn(cx: &MatchCheckCtxt,\n@@ -821,7 +807,6 @@ pub fn is_refutable(cx: &MatchCheckCtxt, pat: &pat) -> bool {\n // Legality of move bindings checking\n \n pub fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n-                                       is_lvalue: bool,\n                                        has_guard: bool,\n                                        pats: &[@pat]) {\n     let tcx = cx.tcx;\n@@ -861,11 +846,6 @@ pub fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n             tcx.sess.span_note(\n                 by_ref_span.get(),\n                 \"by-ref binding occurs here\");\n-        } else if is_lvalue {\n-            tcx.sess.span_err(\n-                p.span,\n-                \"cannot bind by-move when \\\n-                 matching an lvalue\");\n         }\n     };\n "}, {"sha": "ec375eaba0e86b93c81a796a973b0284abaf0a99", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/729b07f83c9f6319f68482ce781521ac666cf6e6/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/729b07f83c9f6319f68482ce781521ac666cf6e6/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=729b07f83c9f6319f68482ce781521ac666cf6e6", "patch": "@@ -422,8 +422,8 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                  loop_scopes: &mut ~[LoopScope]) {\n         match decl.node {\n             ast::decl_local(local) => {\n-                self.walk_pat(local.node.pat, in_out, loop_scopes);\n                 self.walk_opt_expr(local.node.init, in_out, loop_scopes);\n+                self.walk_pat(local.node.pat, in_out, loop_scopes);\n             }\n \n             ast::decl_item(_) => {}"}, {"sha": "ac7805146e4864c04524afee30113f5dcfc74f99", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/729b07f83c9f6319f68482ce781521ac666cf6e6/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/729b07f83c9f6319f68482ce781521ac666cf6e6/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=729b07f83c9f6319f68482ce781521ac666cf6e6", "patch": "@@ -60,7 +60,7 @@ use syntax::print::pprust;\n \n #[deriving(Eq)]\n pub enum categorization {\n-    cat_rvalue,                        // result of eval'ing some misc expr\n+    cat_rvalue(ast::node_id),          // temporary val, argument is its scope\n     cat_static_item,\n     cat_implicit_self,\n     cat_copied_upvar(CopiedUpvar),     // upvar copied into @fn or ~fn env\n@@ -350,7 +350,7 @@ impl mem_categorization_ctxt {\n                 // Convert a bare fn to a closure by adding NULL env.\n                 // Result is an rvalue.\n                 let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n-                self.cat_rvalue(expr, expr_ty)\n+                self.cat_rvalue_node(expr, expr_ty)\n             }\n \n             Some(\n@@ -360,7 +360,7 @@ impl mem_categorization_ctxt {\n                 // Equivalent to &*expr or something similar.\n                 // Result is an rvalue.\n                 let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n-                self.cat_rvalue(expr, expr_ty)\n+                self.cat_rvalue_node(expr, expr_ty)\n             }\n \n             Some(\n@@ -390,7 +390,7 @@ impl mem_categorization_ctxt {\n         match expr.node {\n           ast::expr_unary(_, ast::deref, e_base) => {\n             if self.method_map.contains_key(&expr.id) {\n-                return self.cat_rvalue(expr, expr_ty);\n+                return self.cat_rvalue_node(expr, expr_ty);\n             }\n \n             let base_cmt = self.cat_expr(e_base);\n@@ -408,7 +408,7 @@ impl mem_categorization_ctxt {\n \n           ast::expr_index(_, base, _) => {\n             if self.method_map.contains_key(&expr.id) {\n-                return self.cat_rvalue(expr, expr_ty);\n+                return self.cat_rvalue_node(expr, expr_ty);\n             }\n \n             let base_cmt = self.cat_expr(base);\n@@ -433,7 +433,7 @@ impl mem_categorization_ctxt {\n           ast::expr_match(*) | ast::expr_lit(*) | ast::expr_break(*) |\n           ast::expr_mac(*) | ast::expr_again(*) | ast::expr_struct(*) |\n           ast::expr_repeat(*) | ast::expr_inline_asm(*) => {\n-            return self.cat_rvalue(expr, expr_ty);\n+            return self.cat_rvalue_node(expr, expr_ty);\n           }\n         }\n     }\n@@ -577,11 +577,24 @@ impl mem_categorization_ctxt {\n         }\n     }\n \n-    pub fn cat_rvalue<N:ast_node>(&self, elt: N, expr_ty: ty::t) -> cmt {\n+    pub fn cat_rvalue_node<N:ast_node>(&self,\n+                                       node: N,\n+                                       expr_ty: ty::t) -> cmt {\n+        self.cat_rvalue(node.id(),\n+                        node.span(),\n+                        self.tcx.region_maps.cleanup_scope(node.id()),\n+                        expr_ty)\n+    }\n+\n+    pub fn cat_rvalue(&self,\n+                      cmt_id: ast::node_id,\n+                      span: span,\n+                      cleanup_scope_id: ast::node_id,\n+                      expr_ty: ty::t) -> cmt {\n         @cmt_ {\n-            id:elt.id(),\n-            span:elt.span(),\n-            cat:cat_rvalue,\n+            id:cmt_id,\n+            span:span,\n+            cat:cat_rvalue(cleanup_scope_id),\n             mutbl:McDeclared,\n             ty:expr_ty\n         }\n@@ -970,7 +983,7 @@ impl mem_categorization_ctxt {\n               }\n               for slice.iter().advance |&slice_pat| {\n                   let slice_ty = self.pat_ty(slice_pat);\n-                  let slice_cmt = self.cat_rvalue(pat, slice_ty);\n+                  let slice_cmt = self.cat_rvalue_node(pat, slice_ty);\n                   self.cat_pattern(slice_cmt, slice_pat, |x,y| op(x,y));\n               }\n               for after.iter().advance |&after_pat| {\n@@ -1003,7 +1016,7 @@ impl mem_categorization_ctxt {\n           cat_copied_upvar(_) => {\n               ~\"captured outer variable in a heap closure\"\n           }\n-          cat_rvalue => {\n+          cat_rvalue(*) => {\n               ~\"non-lvalue\"\n           }\n           cat_local(_) => {\n@@ -1100,7 +1113,7 @@ impl cmt_ {\n         //! determines how long the value in `self` remains live.\n \n         match self.cat {\n-            cat_rvalue |\n+            cat_rvalue(*) |\n             cat_static_item |\n             cat_implicit_self |\n             cat_copied_upvar(*) |\n@@ -1187,11 +1200,13 @@ impl Repr for categorization {\n         match *self {\n             cat_static_item |\n             cat_implicit_self |\n-            cat_rvalue |\n+            cat_rvalue(*) |\n             cat_copied_upvar(*) |\n             cat_local(*) |\n             cat_self(*) |\n-            cat_arg(*) => fmt!(\"%?\", *self),\n+            cat_arg(*) => {\n+                fmt!(\"%?\", *self)\n+            }\n             cat_deref(cmt, derefs, ptr) => {\n                 fmt!(\"%s->(%s, %u)\", cmt.cat.repr(tcx),\n                      ptr_sigil(ptr), derefs)\n@@ -1205,7 +1220,9 @@ impl Repr for categorization {\n                 fmt!(\"%s->(enum)\", cmt.cat.repr(tcx))\n             }\n             cat_stack_upvar(cmt) |\n-            cat_discr(cmt, _) => cmt.cat.repr(tcx)\n+            cat_discr(cmt, _) => {\n+                cmt.cat.repr(tcx)\n+            }\n         }\n     }\n }"}, {"sha": "e9a73a513c8d809c0b947bdd5c13c170a5a3eb76", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 41, "deletions": 5, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/729b07f83c9f6319f68482ce781521ac666cf6e6/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/729b07f83c9f6319f68482ce781521ac666cf6e6/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=729b07f83c9f6319f68482ce781521ac666cf6e6", "patch": "@@ -190,10 +190,19 @@ enum UseMode {\n \n pub fn compute_moves(tcx: ty::ctxt,\n                      method_map: method_map,\n+<<<<<<< HEAD\n                      crate: &crate) -> MoveMaps\n {\n+||||||| merged common ancestors\n+                     crate: @crate) -> MoveMaps\n+{\n+=======\n+                     crate: @crate) -> MoveMaps {\n+>>>>>>> Modify borrow checker to visit irrefutable patterns that appear in\n     let visitor = visit::mk_vt(@visit::Visitor {\n+        visit_fn: compute_modes_for_fn,\n         visit_expr: compute_modes_for_expr,\n+        visit_local: compute_modes_for_local,\n         .. *visit::default_visitor()\n     });\n     let visit_cx = VisitContext {\n@@ -220,9 +229,31 @@ pub fn moved_variable_node_id_from_def(def: def) -> Option<node_id> {\n     }\n }\n \n-// ______________________________________________________________________\n+///////////////////////////////////////////////////////////////////////////\n // Expressions\n \n+fn compute_modes_for_local<'a>(local: @local,\n+                               (cx, v): (VisitContext,\n+                                         vt<VisitContext>)) {\n+    cx.use_pat(local.node.pat);\n+    for local.node.init.iter().advance |&init| {\n+        cx.use_expr(init, Read, v);\n+    }\n+}\n+\n+fn compute_modes_for_fn(fk: &visit::fn_kind,\n+                        decl: &fn_decl,\n+                        body: &blk,\n+                        span: span,\n+                        id: node_id,\n+                        (cx, v): (VisitContext,\n+                                  vt<VisitContext>)) {\n+    for decl.inputs.each |a| {\n+        cx.use_pat(a.pat);\n+    }\n+    visit::visit_fn(fk, decl, body, span, id, (cx, v));\n+}\n+\n fn compute_modes_for_expr(expr: @expr,\n                           (cx, v): (VisitContext,\n                                     vt<VisitContext>))\n@@ -522,7 +553,10 @@ impl VisitContext {\n                 self.use_expr(base, comp_mode, visitor);\n             }\n \n-            expr_fn_block(_, ref body) => {\n+            expr_fn_block(ref decl, ref body) => {\n+                for decl.inputs.each |a| {\n+                    self.use_pat(a.pat);\n+                }\n                 let cap_vars = self.compute_captures(expr.id);\n                 self.move_maps.capture_map.insert(expr.id, cap_vars);\n                 self.consume_block(body, visitor);\n@@ -580,13 +614,15 @@ impl VisitContext {\n          * into itself or not based on its type and annotation.\n          */\n \n-        do pat_bindings(self.tcx.def_map, pat) |bm, id, _span, _path| {\n+        do pat_bindings(self.tcx.def_map, pat) |bm, id, _span, path| {\n             let binding_moves = match bm {\n                 bind_by_ref(_) => false,\n                 bind_infer => {\n                     let pat_ty = ty::node_id_to_type(self.tcx, id);\n-                    debug!(\"pattern %? type is %s\",\n-                           id, pat_ty.repr(self.tcx));\n+                    debug!(\"pattern %? %s type is %s\",\n+                           id,\n+                           ast_util::path_to_ident(path).repr(self.tcx),\n+                           pat_ty.repr(self.tcx));\n                     ty::type_moves_by_default(self.tcx, pat_ty)\n                 }\n             };"}, {"sha": "ac7a9db99e9ac55311b71ebb9c304add836d96a9", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/729b07f83c9f6319f68482ce781521ac666cf6e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/729b07f83c9f6319f68482ce781521ac666cf6e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=729b07f83c9f6319f68482ce781521ac666cf6e6", "patch": "@@ -158,9 +158,9 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n                 None => {\n                     fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                        |expected, actual| {\n-                                                       expected.map_default(~\"\", |&e| {\n+                                                       expected.map_default(~\"\", |e| {\n                         fmt!(\"mismatched types: expected `%s` but found %s\",\n-                             e, actual)})},\n+                             *e, actual)})},\n                              Some(expected), ~\"a structure pattern\",\n                              None);\n                     fcx.write_error(pat.id);\n@@ -200,9 +200,9 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n         _ => {\n             fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                |expected, actual| {\n-                                               expected.map_default(~\"\", |&e| {\n+                                               expected.map_default(~\"\", |e| {\n                     fmt!(\"mismatched types: expected `%s` but found %s\",\n-                         e, actual)})},\n+                         *e, actual)})},\n                     Some(expected), ~\"an enum or structure pattern\",\n                     None);\n             fcx.write_error(pat.id);\n@@ -534,9 +534,9 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n                     _ => ty::terr_mismatch\n                 };\n                 fcx.infcx().type_error_message_str_with_expected(pat.span, |expected, actual| {\n-                expected.map_default(~\"\", |&e| {\n+                expected.map_default(~\"\", |e| {\n                     fmt!(\"mismatched types: expected `%s` but found %s\",\n-                                     e, actual)})}, Some(expected), ~\"tuple\", Some(&type_error));\n+                                     *e, actual)})}, Some(expected), ~\"tuple\", Some(&type_error));\n                 fcx.write_error(pat.id);\n             }\n         }\n@@ -583,9 +583,9 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n               fcx.infcx().type_error_message_str_with_expected(\n                   pat.span,\n                   |expected, actual| {\n-                      expected.map_default(~\"\", |&e| {\n+                      expected.map_default(~\"\", |e| {\n                           fmt!(\"mismatched types: expected `%s` but found %s\",\n-                               e, actual)})},\n+                               *e, actual)})},\n                   Some(expected),\n                   ~\"a vector pattern\",\n                   None);\n@@ -641,9 +641,9 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n             fcx.infcx().type_error_message_str_with_expected(\n                 span,\n                 |expected, actual| {\n-                    expected.map_default(~\"\", |&e| {\n+                    expected.map_default(~\"\", |e| {\n                         fmt!(\"mismatched types: expected `%s` but found %s\",\n-                             e, actual)})},\n+                             *e, actual)})},\n                 Some(expected),\n                 fmt!(\"%s pattern\", match pointer_kind {\n                     Managed => \"an @-box\","}, {"sha": "d59c8e5e894fbd0e1d2ca1985341d2e089e6e962", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/729b07f83c9f6319f68482ce781521ac666cf6e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/729b07f83c9f6319f68482ce781521ac666cf6e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=729b07f83c9f6319f68482ce781521ac666cf6e6", "patch": "@@ -350,10 +350,7 @@ pub fn resolve_type_vars_in_fn(fcx: @mut FnCtxt,\n                                    self_info.self_id);\n     }\n     for decl.inputs.iter().advance |arg| {\n-        do pat_util::pat_bindings(fcx.tcx().def_map, arg.pat)\n-                |_bm, pat_id, span, _path| {\n-            resolve_type_vars_for_node(wbcx, span, pat_id);\n-        }\n+        (visit.visit_pat)(arg.pat, (wbcx, visit));\n         // Privacy needs the type for the whole pattern, not just each binding\n         if !pat_util::pat_is_binding(fcx.tcx().def_map, arg.pat) {\n             resolve_type_vars_for_node(wbcx, arg.pat.span, arg.pat.id);"}]}