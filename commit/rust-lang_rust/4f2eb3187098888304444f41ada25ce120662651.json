{"sha": "4f2eb3187098888304444f41ada25ce120662651", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMmViMzE4NzA5ODg4ODMwNDQ0NGY0MWFkYTI1Y2UxMjA2NjI2NTE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-13T23:27:55Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-13T23:27:55Z"}, "message": "rustc: Write types contained in \"trivial annotations\" to the table", "tree": {"sha": "a1e11fc331ccad846f8bef09b93bea77b6f2439b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1e11fc331ccad846f8bef09b93bea77b6f2439b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f2eb3187098888304444f41ada25ce120662651", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f2eb3187098888304444f41ada25ce120662651", "html_url": "https://github.com/rust-lang/rust/commit/4f2eb3187098888304444f41ada25ce120662651", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f2eb3187098888304444f41ada25ce120662651/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e888fe6f9b8ed0c47df2ed17e50c2d391c1dc647", "url": "https://api.github.com/repos/rust-lang/rust/commits/e888fe6f9b8ed0c47df2ed17e50c2d391c1dc647", "html_url": "https://github.com/rust-lang/rust/commit/e888fe6f9b8ed0c47df2ed17e50c2d391c1dc647"}], "stats": {"total": 180, "additions": 135, "deletions": 45}, "files": [{"sha": "4a8f59747164238fc3add9066e20eecd610e4d34", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 135, "deletions": 45, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/4f2eb3187098888304444f41ada25ce120662651/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f2eb3187098888304444f41ada25ce120662651/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=4f2eb3187098888304444f41ada25ce120662651", "patch": "@@ -371,6 +371,7 @@ fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast::ty ast_ty) -> ty::t {\n     ret ast_ty_to_ty(ccx.tcx, f, ast_ty);\n }\n \n+\n // Writes a type parameter count and type pair into the node type table.\n fn write_type(&node_type_table ntt, uint node_id,\n               &ty_param_substs_opt_and_ty tpot) {\n@@ -381,6 +382,11 @@ fn write_type(&node_type_table ntt, uint node_id,\n          some[ty_param_substs_opt_and_ty](tpot));\n }\n \n+// Writes a type with no type parameters into the node type table.\n+fn write_type_only(&node_type_table ntt, uint node_id, ty::t ty) {\n+    be write_type(ntt, node_id, tup(none[vec[ty::t]], ty));\n+}\n+\n \n // Item collection - a pair of bootstrap passes:\n //\n@@ -639,6 +645,8 @@ mod Collect {\n                 ann=triv_ann(ast::ann_tag(variant.node.ann), result_ty)\n                 with variant.node\n             );\n+            write_type_only(cx.node_types, ast::ann_tag(variant.node.ann),\n+                            result_ty);\n             result += vec(fold::respan(variant.span, variant_t));\n         }\n \n@@ -708,6 +716,7 @@ mod Collect {\n         auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast::item_const(i, t, ex, id,\n                                     triv_ann(ast::ann_tag(a), typ));\n+        write_type_only(e.cx.node_types, ast::ann_tag(a), typ);\n         ret @fold::respan[ast::item_](sp, item);\n     }\n \n@@ -718,6 +727,7 @@ mod Collect {\n         auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast::item_fn(i, f, ty_params, id,\n                                  triv_ann(ast::ann_tag(a), typ));\n+        write_type_only(e.cx.node_types, ast::ann_tag(a), typ);\n         ret @fold::respan[ast::item_](sp, item);\n     }\n \n@@ -728,7 +738,8 @@ mod Collect {\n         // assert (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast::native_item_fn(i, ln, d, ty_params, id,\n-                                       triv_ann(ast::ann_tag(a), typ));\n+                                        triv_ann(ast::ann_tag(a), typ));\n+        write_type_only(e.cx.node_types, ast::ann_tag(a), typ);\n         ret @fold::respan[ast::native_item_](sp, item);\n     }\n \n@@ -770,20 +781,23 @@ mod Collect {\n             let ast::method_ m_;\n             let @ast::method m;\n             auto meth_tfn = ty::mk_fn(e.cx.tcx,\n-                                     meth_ty.proto,\n-                                     meth_ty.inputs,\n-                                     meth_ty.output);\n+                                      meth_ty.proto,\n+                                      meth_ty.inputs,\n+                                      meth_ty.output);\n             m_ = rec(ann=triv_ann(ast::ann_tag(meth.node.ann), meth_tfn)\n                      with meth.node\n             );\n             m = @rec(node=m_ with *meth);\n+            write_type_only(e.cx.node_types, ast::ann_tag(meth.node.ann),\n+                            meth_tfn);\n             _vec::push[@ast::method](methods, m);\n         }\n         auto g = bind getter(e.cx, _);\n         for (ast::obj_field fld in ob.fields) {\n             let ty::t fty = ast_ty_to_ty(e.cx.tcx, g, fld.ty);\n             let ast::obj_field f =\n                 rec(ann=triv_ann(ast::ann_tag(fld.ann), fty) with fld);\n+            write_type_only(e.cx.node_types, ast::ann_tag(fld.ann), fty);\n             _vec::push[ast::obj_field](fields, f);\n         }\n \n@@ -798,6 +812,8 @@ mod Collect {\n                     ann=triv_ann(ast::ann_tag(d.node.ann), dtor_tfn)\n                     with d.node\n                 );\n+                write_type_only(e.cx.node_types, ast::ann_tag(d.node.ann),\n+                                dtor_tfn);\n                 dtor = some[@ast::method](@rec(node=d_ with *d));\n             }\n             case (none[@ast::method]) { }\n@@ -809,6 +825,7 @@ mod Collect {\n                        with ob);\n         auto item = ast::item_obj(i, ob_, ty_params, odid,\n                                   triv_ann(ast::ann_tag(a), t));\n+        write_type_only(e.cx.node_types, ast::ann_tag(a), t);\n         ret @fold::respan[ast::item_](sp, item);\n     }\n \n@@ -819,6 +836,7 @@ mod Collect {\n         auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast::item_ty(i, t, ty_params, id,\n                                  triv_ann(ast::ann_tag(a), typ));\n+        write_type_only(e.cx.node_types, ast::ann_tag(a), typ);\n         ret @fold::respan[ast::item_](sp, item);\n     }\n \n@@ -1249,6 +1267,7 @@ mod Pushdown {\n                 }\n                 e_1 = ast::expr_vec(es_1, mut,\n                                     triv_ann(ast::ann_tag(ann), t));\n+                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n             }\n             case (ast::expr_tup(?es_0, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n@@ -1270,6 +1289,7 @@ mod Pushdown {\n                     }\n                 }\n                 e_1 = ast::expr_tup(elts_1, triv_ann(ast::ann_tag(ann), t));\n+                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n             }\n             case (ast::expr_rec(?fields_0, ?base_0, ?ann)) {\n \n@@ -1328,12 +1348,14 @@ mod Pushdown {\n                 }\n                 e_1 = ast::expr_rec(fields_1, base_1,\n                                     triv_ann(ast::ann_tag(ann), t));\n+                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n             }\n             case (ast::expr_bind(?sube, ?es, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                         ann_to_type(fcx.ccx.node_types, ann));\n                 e_1 = ast::expr_bind(sube, es,\n                                      triv_ann(ast::ann_tag(ann), t));\n+                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n             }\n             case (ast::expr_call(?sube, ?es, ?ann)) {\n                 // NB: we call 'Demand::autoderef' and pass in adk only in\n@@ -1344,18 +1366,21 @@ mod Pushdown {\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n                 e_1 = ast::expr_call(sube, es,\n                                      triv_ann(ast::ann_tag(ann), t));\n+                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n             }\n             case (ast::expr_self_method(?id, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                        ann_to_type(fcx.ccx.node_types, ann));\n                 e_1 = ast::expr_self_method(id,\n                                             triv_ann(ast::ann_tag(ann), t));\n+                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n             }\n             case (ast::expr_binary(?bop, ?lhs, ?rhs, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                        ann_to_type(fcx.ccx.node_types, ann));\n                 e_1 = ast::expr_binary(bop, lhs, rhs,\n                                        triv_ann(ast::ann_tag(ann), t));\n+                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n             }\n             case (ast::expr_unary(?uop, ?sube, ?ann)) {\n                 // See note in expr_unary for why we're calling\n@@ -1364,17 +1389,20 @@ mod Pushdown {\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n                 e_1 = ast::expr_unary(uop, sube,\n                                       triv_ann(ast::ann_tag(ann), t));\n+                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n             }\n             case (ast::expr_lit(?lit, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                         ann_to_type(fcx.ccx.node_types, ann));\n                 e_1 = ast::expr_lit(lit, triv_ann(ast::ann_tag(ann), t));\n+                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n             }\n             case (ast::expr_cast(?sube, ?ast_ty, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                         ann_to_type(fcx.ccx.node_types, ann));\n                 e_1 = ast::expr_cast(sube, ast_ty,\n                                      triv_ann(ast::ann_tag(ann), t));\n+                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n             }\n             case (ast::expr_if(?cond, ?then_0, ?else_0, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n@@ -1391,35 +1419,41 @@ mod Pushdown {\n                 }\n                 e_1 = ast::expr_if(cond, then_1, else_1,\n                                    triv_ann(ast::ann_tag(ann), t));\n+                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n             }\n             case (ast::expr_for(?decl, ?seq, ?bloc, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                        ann_to_type(fcx.ccx.node_types, ann));\n                 e_1 = ast::expr_for(decl, seq, bloc,\n                                     triv_ann(ast::ann_tag(ann), t));\n+                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n             }\n             case (ast::expr_for_each(?decl, ?seq, ?bloc, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                        ann_to_type(fcx.ccx.node_types, ann));\n                 e_1 = ast::expr_for_each(decl, seq, bloc,\n                                          triv_ann(ast::ann_tag(ann), t));\n+                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n             }\n             case (ast::expr_while(?cond, ?bloc, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                        ann_to_type(fcx.ccx.node_types, ann));\n                 e_1 = ast::expr_while(cond, bloc,\n                                       triv_ann(ast::ann_tag(ann), t));\n+                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n             }\n             case (ast::expr_do_while(?bloc, ?cond, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                        ann_to_type(fcx.ccx.node_types, ann));\n                 e_1 = ast::expr_do_while(bloc, cond,\n                                          triv_ann(ast::ann_tag(ann), t));\n+                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n             }\n             case (ast::expr_block(?bloc, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n                 e_1 = ast::expr_block(bloc, triv_ann(ast::ann_tag(ann), t));\n+                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n             }\n             case (ast::expr_assign(?lhs_0, ?rhs_0, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n@@ -1428,6 +1462,7 @@ mod Pushdown {\n                 auto rhs_1 = pushdown_expr(fcx, expected, rhs_0);\n                 e_1 = ast::expr_assign(lhs_1, rhs_1,\n                                        triv_ann(ast::ann_tag(ann), t));\n+                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n             }\n             case (ast::expr_assign_op(?op, ?lhs_0, ?rhs_0, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n@@ -1436,18 +1471,21 @@ mod Pushdown {\n                 auto rhs_1 = pushdown_expr(fcx, expected, rhs_0);\n                 e_1 = ast::expr_assign_op(op, lhs_1, rhs_1,\n                                           triv_ann(ast::ann_tag(ann), t));\n+                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n             }\n             case (ast::expr_field(?lhs, ?rhs, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n                 e_1 = ast::expr_field(lhs, rhs,\n                                       triv_ann(ast::ann_tag(ann), t));\n+                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n             }\n             case (ast::expr_index(?base, ?index, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n                 e_1 = ast::expr_index(base, index,\n                                       triv_ann(ast::ann_tag(ann), t));\n+                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n             }\n             case (ast::expr_path(?pth, ?ann)) {\n                 auto tp_substs_0 = ty::ann_to_type_params(fcx.ccx.node_types,\n@@ -1491,6 +1529,7 @@ mod Pushdown {\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n                 e_1 = ast::expr_ext(p, args, body, expanded,\n                                     triv_ann(ast::ann_tag(ann), t));\n+                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n             }\n             /* FIXME: should this check the type annotations? */\n             case (ast::expr_fail(_))  { e_1 = e.node; } \n@@ -1507,6 +1546,7 @@ mod Pushdown {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                         ann_to_type(fcx.ccx.node_types, ann));\n                 e_1 = ast::expr_port(triv_ann(ast::ann_tag(ann), t));\n+                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n             }\n \n             case (ast::expr_chan(?es, ?ann)) {\n@@ -1524,6 +1564,7 @@ mod Pushdown {\n                     }\n                 }\n                 e_1 = ast::expr_chan(es_1, triv_ann(ast::ann_tag(ann), t));\n+                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n             }\n \n             case (ast::expr_alt(?discrim, ?arms_0, ?ann)) {\n@@ -1538,6 +1579,7 @@ mod Pushdown {\n                 }\n                 e_1 = ast::expr_alt(discrim, arms_1,\n                                     triv_ann(ast::ann_tag(ann), t));\n+                write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), t);\n             }\n \n             case (ast::expr_recv(?lval_0, ?expr_0, ?ann)) {\n@@ -1615,6 +1657,7 @@ fn writeback_local(&option::t[@fn_ctxt] env, &span sp, &@ast::local local)\n     auto local_wb = @rec(ann=triv_ann(ast::ann_tag(local.ann), local_ty)\n                          with *local\n     );\n+    write_type_only(fcx.ccx.node_types, ast::ann_tag(local.ann), local_ty);\n     ret @fold::respan[ast::decl_](sp, ast::decl_local(local_wb));\n }\n \n@@ -1689,15 +1732,19 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat) -> @ast::pat {\n     auto new_pat;\n     alt (pat.node) {\n         case (ast::pat_wild(?ann)) {\n-            new_pat = ast::pat_wild(triv_ann(ast::ann_tag(ann),\n-                                             next_ty_var(fcx.ccx)));\n+            auto typ = next_ty_var(fcx.ccx);\n+            write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), typ);\n+            new_pat = ast::pat_wild(triv_ann(ast::ann_tag(ann), typ));\n         }\n         case (ast::pat_lit(?lt, ?ann)) {\n-            new_pat = ast::pat_lit(lt, triv_ann(ast::ann_tag(ann),\n-                                                check_lit(fcx.ccx, lt)));\n+            auto typ = check_lit(fcx.ccx, lt);\n+            write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), typ);\n+            new_pat = ast::pat_lit(lt, triv_ann(ast::ann_tag(ann), typ));\n         }\n         case (ast::pat_bind(?id, ?def_id, ?a)) {\n-            auto ann = triv_ann(ast::ann_tag(a), next_ty_var(fcx.ccx));\n+            auto typ = next_ty_var(fcx.ccx);\n+            auto ann = triv_ann(ast::ann_tag(a), typ);\n+            write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), typ);\n             new_pat = ast::pat_bind(id, def_id, ann);\n         }\n         case (ast::pat_tag(?p, ?subpats, ?old_ann)) {\n@@ -1908,6 +1955,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n         auto ann = triv_ann(ast::ann_tag(a),\n                             expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, rhs_1));\n+        write_type_only(fcx.ccx.node_types, ast::ann_tag(a),\n+                        expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, rhs_1));\n         ret tup(lhs_1, rhs_1, ann);\n     }\n \n@@ -1936,6 +1985,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n         case (ast::expr_lit(?lit, ?a)) {\n             auto typ = check_lit(fcx.ccx, lit);\n             auto ann = triv_ann(ast::ann_tag(a), typ);\n+            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), typ);\n             ret @fold::respan[ast::expr_](expr.span, ast::expr_lit(lit, ann));\n         }\n \n@@ -1966,9 +2016,10 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             }\n \n             auto ann = triv_ann(ast::ann_tag(a), t);\n+            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), t);\n             ret @fold::respan[ast::expr_](expr.span,\n-                                        ast::expr_binary(binop, lhs_1, rhs_1,\n-                                                        ann));\n+                                          ast::expr_binary(binop, lhs_1,\n+                                                           rhs_1, ann));\n         }\n \n \n@@ -1997,8 +2048,9 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             }\n \n             auto ann = triv_ann(ast::ann_tag(a), oper_t);\n+            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), oper_t);\n             ret @fold::respan[ast::expr_](expr.span,\n-                                        ast::expr_unary(unop, oper_1, ann));\n+                                          ast::expr_unary(unop, oper_1, ann));\n         }\n \n         case (ast::expr_path(?pth, ?old_ann)) {\n@@ -2026,14 +2078,16 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             }\n \n             auto e = ast::expr_path(pth, triv_ann(ast::ann_tag(old_ann),\n-                                    tpt._1));\n+                                                  tpt._1));\n+            write_type_only(fcx.ccx.node_types, ast::ann_tag(old_ann), tpt._1);\n             ret @fold::respan[ast::expr_](expr.span, e);\n         }\n \n         case (ast::expr_ext(?p, ?args, ?body, ?expanded, ?a)) {\n             auto exp_ = check_expr(fcx, expanded);\n             auto t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, exp_);\n             auto ann = triv_ann(ast::ann_tag(a), t);\n+            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), t);\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_ext(p, args, body, exp_,\n                                                      ann));\n@@ -2217,6 +2271,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             auto rhs_1 = Pushdown::pushdown_expr(fcx, item_t, rhs_0);\n \n             auto ann = triv_ann(ast::ann_tag(a), chan_t);\n+            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), chan_t);\n             auto newexpr = ast::expr_send(lhs_1, rhs_1, ann);\n             ret @fold::respan[ast::expr_](expr.span, newexpr);\n         }\n@@ -2243,6 +2298,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             auto lhs_1 = Pushdown::pushdown_expr(fcx, item_t, lhs_0);\n \n             auto ann = triv_ann(ast::ann_tag(a), item_t);\n+            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), item_t);\n             auto newexpr = ast::expr_recv(lhs_1, rhs_1, ann);\n             ret @fold::respan[ast::expr_](expr.span, newexpr);\n         }\n@@ -2275,6 +2331,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             auto thn_1 = Pushdown::pushdown_block(fcx, elsopt_t, thn_0);\n \n             auto ann = triv_ann(ast::ann_tag(a), elsopt_t);\n+            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), elsopt_t);\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_if(cond_1, thn_1,\n                                                     elsopt_1, ann));\n@@ -2288,21 +2345,25 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             // FIXME: enforce that the type of the decl is the element type\n             // of the seq.\n \n-            auto ann = triv_ann(ast::ann_tag(a), ty::mk_nil(fcx.ccx.tcx));\n+            auto typ = ty::mk_nil(fcx.ccx.tcx);\n+            auto ann = triv_ann(ast::ann_tag(a), typ);\n+            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), typ);\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_for(decl_1, seq_1,\n-                                                     body_1, ann));\n+                                                      body_1, ann));\n         }\n \n         case (ast::expr_for_each(?decl, ?seq, ?body, ?a)) {\n             auto decl_1 = check_decl_local(fcx, decl);\n             auto seq_1 = check_expr(fcx, seq);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = triv_ann(ast::ann_tag(a), ty::mk_nil(fcx.ccx.tcx));\n+            auto typ = ty::mk_nil(fcx.ccx.tcx);\n+            auto ann = triv_ann(ast::ann_tag(a), typ);\n+            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), typ);\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_for_each(decl_1, seq_1,\n-                                                          body_1, ann));\n+                                                           body_1, ann));\n         }\n \n         case (ast::expr_while(?cond, ?body, ?a)) {\n@@ -2312,9 +2373,12 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                                                   cond_0);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = triv_ann(ast::ann_tag(a), ty::mk_nil(fcx.ccx.tcx));\n+            auto typ = ty::mk_nil(fcx.ccx.tcx);\n+            auto ann = triv_ann(ast::ann_tag(a), typ);\n+            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), typ);\n             ret @fold::respan[ast::expr_](expr.span,\n-                                        ast::expr_while(cond_1, body_1, ann));\n+                                          ast::expr_while(cond_1, body_1,\n+                                                          ann));\n         }\n \n         case (ast::expr_do_while(?body, ?cond, ?a)) {\n@@ -2324,12 +2388,12 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                                                   cond_0);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = triv_ann(ast::ann_tag(a),\n-                                block_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                         body_1));\n+            auto typ = block_ty(fcx.ccx.tcx, fcx.ccx.node_types, body_1);\n+            auto ann = triv_ann(ast::ann_tag(a), typ);\n+            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), typ);\n             ret @fold::respan[ast::expr_](expr.span,\n-                                        ast::expr_do_while(body_1, cond_1,\n-                                                          ann));\n+                                          ast::expr_do_while(body_1, cond_1,\n+                                                             ann));\n         }\n \n         case (ast::expr_alt(?expr, ?arms, ?a)) {\n@@ -2379,21 +2443,24 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             auto expr_1 = Pushdown::pushdown_expr(fcx, pattern_ty, expr_0);\n \n             auto ann = triv_ann(ast::ann_tag(a), result_ty);\n+            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), result_ty);\n             ret @fold::respan[ast::expr_](expr.span,\n-                                        ast::expr_alt(expr_1, arms_1, ann));\n+                                          ast::expr_alt(expr_1, arms_1, ann));\n         }\n \n         case (ast::expr_block(?b, ?a)) {\n             auto b_0 = check_block(fcx, b);\n             auto ann;\n             alt (b_0.node.expr) {\n                 case (some[@ast::expr](?expr)) {\n-                    ann = triv_ann(ast::ann_tag(a),\n-                                   expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                           expr));\n+                    auto typ = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr);\n+                    ann = triv_ann(ast::ann_tag(a), typ);\n+                    write_type_only(fcx.ccx.node_types, ast::ann_tag(a), typ);\n                 }\n                 case (none[@ast::expr]) {\n-                    ann = triv_ann(ast::ann_tag(a), ty::mk_nil(fcx.ccx.tcx));\n+                    auto typ = ty::mk_nil(fcx.ccx.tcx);\n+                    ann = triv_ann(ast::ann_tag(a), typ);\n+                    write_type_only(fcx.ccx.node_types, ast::ann_tag(a), typ);\n                 }\n             }\n             ret @fold::respan(expr.span, ast::expr_block(b_0, ann));\n@@ -2434,9 +2501,10 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n             auto t_1 = ty::mk_fn(fcx.ccx.tcx, proto_1, arg_tys_1, rt_1);\n             auto ann = triv_ann(ast::ann_tag(a), t_1);\n+            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), t_1);\n             ret @fold::respan[ast::expr_](expr.span,\n-                                        ast::expr_bind(result._0, result._1,\n-                                                      ann));\n+                                          ast::expr_bind(result._0, result._1,\n+                                                         ann));\n         }\n \n         case (ast::expr_call(?f, ?args, ?a)) {\n@@ -2463,6 +2531,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             }\n \n             auto ann = triv_ann(ast::ann_tag(a), rt_1);\n+            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), rt_1);\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_call(f_1, args_1, ann));\n         }\n@@ -2498,6 +2567,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             }\n \n             auto ann = triv_ann(ast::ann_tag(a), t);\n+            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), t);\n \n             require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n \n@@ -2530,10 +2600,12 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n             // FIXME: Other typechecks needed\n \n-            auto ann = triv_ann(ast::ann_tag(a), ty::mk_task(fcx.ccx.tcx));\n+            auto typ = ty::mk_task(fcx.ccx.tcx);\n+            auto ann = triv_ann(ast::ann_tag(a), typ);\n+            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), typ);\n             ret @fold::respan[ast::expr_](expr.span,\n-                                        ast::expr_spawn(dom, name,\n-                                                       f_1, args_1, ann));\n+                                          ast::expr_spawn(dom, name,\n+                                                          f_1, args_1, ann));\n         }\n \n         case (ast::expr_cast(?e, ?t, ?a)) {\n@@ -2551,6 +2623,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             }\n \n             auto ann = triv_ann(ast::ann_tag(a), t_1);\n+            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), t_1);\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_cast(e_1, t, ann));\n         }\n@@ -2574,8 +2647,9 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 _vec::push[@ast::expr](args_1,expr_1);\n             }\n \n-            auto ann = triv_ann(ast::ann_tag(a),\n-                                ty::mk_vec(fcx.ccx.tcx, rec(ty=t, mut=mut)));\n+            auto typ = ty::mk_vec(fcx.ccx.tcx, rec(ty=t, mut=mut));\n+            auto ann = triv_ann(ast::ann_tag(a), typ);\n+            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), typ);\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_vec(args_1, mut, ann));\n         }\n@@ -2592,8 +2666,9 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 elts_mt += vec(rec(ty=expr_t, mut=e.mut));\n             }\n \n-            auto ann = triv_ann(ast::ann_tag(a),\n-                                ty::mk_tup(fcx.ccx.tcx, elts_mt));\n+            auto typ = ty::mk_tup(fcx.ccx.tcx, elts_mt);\n+            auto ann = triv_ann(ast::ann_tag(a), typ);\n+            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), typ);\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_tup(elts_1, ann));\n         }\n@@ -2625,8 +2700,9 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n             alt (base) {\n                 case (none[@ast::expr]) {\n-                    ann = triv_ann(ast::ann_tag(a),\n-                                   ty::mk_rec(fcx.ccx.tcx, fields_t));\n+                    auto typ = ty::mk_rec(fcx.ccx.tcx, fields_t);\n+                    ann = triv_ann(ast::ann_tag(a), typ);\n+                    write_type_only(fcx.ccx.node_types, ast::ann_tag(a), typ);\n                 }\n \n                 case (some[@ast::expr](?bexpr)) {\n@@ -2648,6 +2724,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                     }\n \n                     ann = triv_ann(ast::ann_tag(a), bexpr_t);\n+                    write_type_only(fcx.ccx.node_types, ast::ann_tag(a),\n+                                    bexpr_t);\n \n                     for (ty::field f in fields_t) {\n                         auto found = false;\n@@ -2685,6 +2763,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                                               \"bad index on tuple\");\n                     }\n                     auto ann = triv_ann(ast::ann_tag(a), args.(ix).ty);\n+                    write_type_only(fcx.ccx.node_types, ast::ann_tag(a),\n+                                    args.(ix).ty);\n                     ret @fold::respan[ast::expr_](expr.span,\n                                                 ast::expr_field(base_1,\n                                                                field,\n@@ -2699,6 +2779,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                                               \"bad index on record\");\n                     }\n                     auto ann = triv_ann(ast::ann_tag(a), fields.(ix).mt.ty);\n+                    write_type_only(fcx.ccx.node_types, ast::ann_tag(a),\n+                                    fields.(ix).mt.ty);\n                     ret @fold::respan[ast::expr_](expr.span,\n                                                 ast::expr_field(base_1,\n                                                                field,\n@@ -2716,6 +2798,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                     auto t = ty::mk_fn(fcx.ccx.tcx, meth.proto,\n                                       meth.inputs, meth.output);\n                     auto ann = triv_ann(ast::ann_tag(a), t);\n+                    write_type_only(fcx.ccx.node_types, ast::ann_tag(a), t);\n                     ret @fold::respan[ast::expr_](expr.span,\n                                                 ast::expr_field(base_1,\n                                                                field,\n@@ -2746,6 +2829,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                              + ty_to_str(fcx.ccx.tcx, idx_t));\n                     }\n                     auto ann = triv_ann(ast::ann_tag(a), mt.ty);\n+                    write_type_only(fcx.ccx.node_types, ast::ann_tag(a),\n+                                    mt.ty);\n                     ret @fold::respan[ast::expr_](expr.span,\n                                                 ast::expr_index(base_1,\n                                                                idx_1,\n@@ -2758,9 +2843,9 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                              \"non-integral type of str index: \"\n                              + ty_to_str(fcx.ccx.tcx, idx_t));\n                     }\n-                    auto ann = triv_ann(ast::ann_tag(a),\n-                                        ty::mk_mach(fcx.ccx.tcx,\n-                                                    common::ty_u8));\n+                    auto typ = ty::mk_mach(fcx.ccx.tcx, common::ty_u8);\n+                    auto ann = triv_ann(ast::ann_tag(a), typ);\n+                    write_type_only(fcx.ccx.node_types, ast::ann_tag(a), typ);\n                     ret @fold::respan[ast::expr_](expr.span,\n                                                 ast::expr_index(base_1,\n                                                                idx_1,\n@@ -2779,6 +2864,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             auto t = next_ty_var(fcx.ccx);\n             auto pt = ty::mk_port(fcx.ccx.tcx, t);\n             auto ann = triv_ann(ast::ann_tag(a), pt);\n+            write_type_only(fcx.ccx.node_types, ast::ann_tag(a), pt);\n             ret @fold::respan[ast::expr_](expr.span, ast::expr_port(ann));\n         }\n \n@@ -2789,6 +2875,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 case (ty::ty_port(?subtype)) {\n                     auto ct = ty::mk_chan(fcx.ccx.tcx, subtype);\n                     auto ann = triv_ann(ast::ann_tag(a), ct);\n+                    write_type_only(fcx.ccx.node_types, ast::ann_tag(a), ct);\n                     ret @fold::respan[ast::expr_](expr.span,\n                                                 ast::expr_chan(expr_1, ann));\n                 }\n@@ -2837,6 +2924,8 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast::decl decl) -> @ast::decl {\n             alt (a_res) {\n                 case (ann_none(_)) {\n                     a_res = triv_ann(ast::ann_tag(a_res), t);\n+                    write_type_only(fcx.ccx.node_types, ast::ann_tag(a_res),\n+                                    t);\n                 }\n                 case (_) {}\n             }\n@@ -3005,8 +3094,9 @@ fn check_item_fn(&@crate_ctxt ccx, &span sp, &ast::ident ident, &ast::_fn f,\n     }\n \n     auto output_ty = ast_ty_to_ty_crate(ccx, f.decl.output);\n-    auto fn_ann = triv_ann(ast::ann_tag(ann),\n-                           ty::mk_fn(ccx.tcx, f.proto, inputs, output_ty));\n+    auto typ = ty::mk_fn(ccx.tcx, f.proto, inputs, output_ty);\n+    auto fn_ann = triv_ann(ast::ann_tag(ann), typ);\n+    write_type_only(ccx.node_types, ast::ann_tag(ann), typ);\n \n     auto item = ast::item_fn(ident, f, ty_params, id, fn_ann);\n     ret @fold::respan[ast::item_](sp, item);"}]}