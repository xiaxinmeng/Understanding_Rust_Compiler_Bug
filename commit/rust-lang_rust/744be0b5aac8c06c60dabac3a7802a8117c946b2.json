{"sha": "744be0b5aac8c06c60dabac3a7802a8117c946b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0NGJlMGI1YWFjOGMwNmM2MGRhYmFjM2E3ODAyYTgxMTdjOTQ2YjI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-04-14T06:04:55Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-04-19T22:13:35Z"}, "message": "HIR visitor for DefCollector\n\nSo that we can work with inlined HIR from metadata.", "tree": {"sha": "ad3e9a2fae68deb5e85b8a5393200e7486738c04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad3e9a2fae68deb5e85b8a5393200e7486738c04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/744be0b5aac8c06c60dabac3a7802a8117c946b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/744be0b5aac8c06c60dabac3a7802a8117c946b2", "html_url": "https://github.com/rust-lang/rust/commit/744be0b5aac8c06c60dabac3a7802a8117c946b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/744be0b5aac8c06c60dabac3a7802a8117c946b2/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c37d4bb1d1b8df21e1e4c8a634127cee871f7ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c37d4bb1d1b8df21e1e4c8a634127cee871f7ab", "html_url": "https://github.com/rust-lang/rust/commit/0c37d4bb1d1b8df21e1e4c8a634127cee871f7ab"}], "stats": {"total": 189, "additions": 175, "deletions": 14}, "files": [{"sha": "f8d0243548fd13afcb031a57281975812cf484ed", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 168, "deletions": 6, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/744be0b5aac8c06c60dabac3a7802a8117c946b2/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744be0b5aac8c06c60dabac3a7802a8117c946b2/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=744be0b5aac8c06c60dabac3a7802a8117c946b2", "patch": "@@ -10,20 +10,28 @@\n \n use super::*;\n \n+use hir;\n+use hir::intravisit;\n use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n \n+use middle::cstore::InlinedItem;\n+\n use syntax::ast::*;\n use syntax::visit;\n \n /// Creates def ids for nodes in the HIR.\n-pub struct DefCollector {\n+pub struct DefCollector<'ast> {\n+    // If we are walking HIR (c.f., AST), we need to keep a reference to the\n+    // crate.\n+    hir_crate: Option<&'ast hir::Crate>,\n     pub definitions: Definitions,\n-    pub parent_def: Option<DefIndex>,\n+    parent_def: Option<DefIndex>,\n }\n \n-impl DefCollector {\n-    pub fn root() -> DefCollector {\n+impl<'ast> DefCollector<'ast> {\n+    pub fn root() -> DefCollector<'ast> {\n         let mut collector = DefCollector {\n+            hir_crate: None,\n             definitions: Definitions::new(),\n             parent_def: None,\n         };\n@@ -39,8 +47,9 @@ impl DefCollector {\n                   parent_def_path: DefPath,\n                   parent_def_id: DefId,\n                   definitions: Definitions)\n-                  -> DefCollector {\n+                  -> DefCollector<'ast> {\n         let mut collector = DefCollector {\n+            hir_crate: None,\n             parent_def: None,\n             definitions: definitions,\n         };\n@@ -57,6 +66,11 @@ impl DefCollector {\n         collector\n     }\n \n+    pub fn walk_item(&mut self, ii: &'ast InlinedItem, krate: &'ast hir::Crate) {\n+        self.hir_crate = Some(krate);\n+        ii.visit(self);\n+    }\n+\n     fn parent_def(&self) -> Option<DefIndex> {\n         self.parent_def\n     }\n@@ -83,7 +97,7 @@ impl DefCollector {\n     }\n }\n \n-impl<'ast> visit::Visitor<'ast> for DefCollector {\n+impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n     fn visit_item(&mut self, i: &'ast Item) {\n         debug!(\"visit_item: {:?}\", i);\n \n@@ -226,3 +240,151 @@ impl<'ast> visit::Visitor<'ast> for DefCollector {\n         self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.ident.name));\n     }\n }\n+\n+// We walk the HIR rather than the AST when reading items from metadata.\n+impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n+    /// Because we want to track parent items and so forth, enable\n+    /// deep walking so that we walk nested items in the context of\n+    /// their outer items.\n+    fn visit_nested_item(&mut self, item_id: hir::ItemId) {\n+        debug!(\"visit_nested_item: {:?}\", item_id);\n+        let item = self.hir_crate.unwrap().item(item_id.id);\n+        self.visit_item(item)\n+    }\n+\n+    fn visit_item(&mut self, i: &'ast hir::Item) {\n+        debug!(\"visit_item: {:?}\", i);\n+\n+        // Pick the def data. This need not be unique, but the more\n+        // information we encapsulate into\n+        let def_data = match i.node {\n+            hir::ItemDefaultImpl(..) | hir::ItemImpl(..) =>\n+                DefPathData::Impl,\n+            hir::ItemEnum(..) | hir::ItemStruct(..) | hir::ItemTrait(..) |\n+            hir::ItemExternCrate(..) | hir::ItemMod(..) | hir::ItemForeignMod(..) |\n+            hir::ItemTy(..) =>\n+                DefPathData::TypeNs(i.name),\n+            hir::ItemStatic(..) | hir::ItemConst(..) | hir::ItemFn(..) =>\n+                DefPathData::ValueNs(i.name),\n+            hir::ItemUse(..) => DefPathData::Misc,\n+        };\n+        let def = self.create_def(i.id, def_data);\n+\n+        self.with_parent(def, |this| {\n+            match i.node {\n+                hir::ItemEnum(ref enum_definition, _) => {\n+                    for v in &enum_definition.variants {\n+                        let variant_def_index =\n+                            this.create_def(v.node.data.id(),\n+                                            DefPathData::EnumVariant(v.node.name));\n+\n+                        for field in v.node.data.fields() {\n+                            this.create_def_with_parent(Some(variant_def_index),\n+                                                        field.id,\n+                                                        DefPathData::Field(field.name));\n+                        }\n+                    }\n+                }\n+                hir::ItemStruct(ref struct_def, _) => {\n+                    // If this is a tuple-like struct, register the constructor.\n+                    if !struct_def.is_struct() {\n+                        this.create_def(struct_def.id(),\n+                                        DefPathData::StructCtor);\n+                    }\n+\n+                    for field in struct_def.fields() {\n+                        this.create_def(field.id, DefPathData::Field(field.name));\n+                    }\n+                }\n+                _ => {}\n+            }\n+            intravisit::walk_item(this, i);\n+        });\n+    }\n+\n+    fn visit_foreign_item(&mut self, foreign_item: &'ast hir::ForeignItem) {\n+        let def = self.create_def(foreign_item.id, DefPathData::ValueNs(foreign_item.name));\n+\n+        self.with_parent(def, |this| {\n+            intravisit::walk_foreign_item(this, foreign_item);\n+        });\n+    }\n+\n+    fn visit_generics(&mut self, generics: &'ast hir::Generics) {\n+        for ty_param in generics.ty_params.iter() {\n+            self.create_def(ty_param.id, DefPathData::TypeParam(ty_param.name));\n+        }\n+\n+        intravisit::walk_generics(self, generics);\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'ast hir::TraitItem) {\n+        let def_data = match ti.node {\n+            hir::MethodTraitItem(..) | hir::ConstTraitItem(..) =>\n+                DefPathData::ValueNs(ti.name),\n+            hir::TypeTraitItem(..) => DefPathData::TypeNs(ti.name),\n+        };\n+\n+        let def = self.create_def(ti.id, def_data);\n+        self.with_parent(def, |this| {\n+            if let hir::ConstTraitItem(_, Some(ref expr)) = ti.node {\n+                this.create_def(expr.id, DefPathData::Initializer);\n+            }\n+\n+            intravisit::walk_trait_item(this, ti);\n+        });\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'ast hir::ImplItem) {\n+        let def_data = match ii.node {\n+            hir::ImplItemKind::Method(..) | hir::ImplItemKind::Const(..) =>\n+                DefPathData::ValueNs(ii.name),\n+            hir::ImplItemKind::Type(..) => DefPathData::TypeNs(ii.name),\n+        };\n+\n+        let def = self.create_def(ii.id, def_data);\n+        self.with_parent(def, |this| {\n+            if let hir::ImplItemKind::Const(_, ref expr) = ii.node {\n+                this.create_def(expr.id, DefPathData::Initializer);\n+            }\n+\n+            intravisit::walk_impl_item(this, ii);\n+        });\n+    }\n+\n+    fn visit_pat(&mut self, pat: &'ast hir::Pat) {\n+        let maybe_binding = match pat.node {\n+            hir::PatKind::Ident(_, id, _) => Some(id.node),\n+            _ => None\n+        };\n+\n+        let parent_def = self.parent_def;\n+        if let Some(id) = maybe_binding {\n+            let def = self.create_def(pat.id, DefPathData::Binding(id.name));\n+            self.parent_def = Some(def);\n+        }\n+\n+        intravisit::walk_pat(self, pat);\n+        self.parent_def = parent_def;\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'ast hir::Expr) {\n+        let parent_def = self.parent_def;\n+\n+        if let hir::ExprClosure(..) = expr.node {\n+            let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n+            self.parent_def = Some(def);\n+        }\n+\n+        intravisit::walk_expr(self, expr);\n+        self.parent_def = parent_def;\n+    }\n+\n+    fn visit_lifetime_def(&mut self, def: &'ast hir::LifetimeDef) {\n+        self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name));\n+    }\n+\n+    fn visit_macro_def(&mut self, macro_def: &'ast hir::MacroDef) {\n+        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.name));\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "1d0c40646b51a885589cf157d5dc4f32654b582c", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/744be0b5aac8c06c60dabac3a7802a8117c946b2/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744be0b5aac8c06c60dabac3a7802a8117c946b2/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=744be0b5aac8c06c60dabac3a7802a8117c946b2", "patch": "@@ -843,14 +843,13 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n     let ii = map.forest.inlined_items.alloc(ii);\n     let ii_parent_id = fld.new_id(DUMMY_NODE_ID);\n \n-    // TODO need to save defs in metadata :-(\n-    // let defs = mem::replace(&mut *map.definitions.borrow_mut(), Definitions::new());\n-    // let mut def_collector = DefCollector::extend(ii_parent_id,\n-    //                                              parent_def_path.clone(),\n-    //                                              parent_def_id,\n-    //                                              defs);\n-    // ii.visit(&mut def_collector);\n-    // *map.definitions.borrow_mut() = def_collector.definitions;\n+    let defs = mem::replace(&mut *map.definitions.borrow_mut(), Definitions::new());\n+    let mut def_collector = DefCollector::extend(ii_parent_id,\n+                                                 parent_def_path.clone(),\n+                                                 parent_def_id,\n+                                                 defs);\n+    def_collector.walk_item(ii, map.krate());\n+    *map.definitions.borrow_mut() = def_collector.definitions;\n \n     let mut collector = NodeCollector::extend(map.krate(),\n                                               ii,"}]}