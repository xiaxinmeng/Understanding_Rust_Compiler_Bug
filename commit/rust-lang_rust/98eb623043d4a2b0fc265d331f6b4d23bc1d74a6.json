{"sha": "98eb623043d4a2b0fc265d331f6b4d23bc1d74a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4ZWI2MjMwNDNkNGEyYjBmYzI2NWQzMzFmNmI0ZDIzYmMxZDc0YTY=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-02-27T19:05:21Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-02-27T19:05:21Z"}, "message": "Merge pull request #720 from mcarton/formatting\n\nFormatting lints for `=@` and `else if`s", "tree": {"sha": "d64d135f01235996f42f0b4081932f644d83d4b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d64d135f01235996f42f0b4081932f644d83d4b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98eb623043d4a2b0fc265d331f6b4d23bc1d74a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98eb623043d4a2b0fc265d331f6b4d23bc1d74a6", "html_url": "https://github.com/rust-lang/rust/commit/98eb623043d4a2b0fc265d331f6b4d23bc1d74a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98eb623043d4a2b0fc265d331f6b4d23bc1d74a6/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14d2afbf0337155091d1109a33779d2c9ce2617e", "url": "https://api.github.com/repos/rust-lang/rust/commits/14d2afbf0337155091d1109a33779d2c9ce2617e", "html_url": "https://github.com/rust-lang/rust/commit/14d2afbf0337155091d1109a33779d2c9ce2617e"}, {"sha": "05178c92b900caeee17bfc4acbaf6baf6600f089", "url": "https://api.github.com/repos/rust-lang/rust/commits/05178c92b900caeee17bfc4acbaf6baf6600f089", "html_url": "https://github.com/rust-lang/rust/commit/05178c92b900caeee17bfc4acbaf6baf6600f089"}], "stats": {"total": 504, "additions": 375, "deletions": 129}, "files": [{"sha": "c9730c4c58b6d186249cff0111240697e363d815", "filename": "README.md", "status": "modified", "additions": 129, "deletions": 127, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/98eb623043d4a2b0fc265d331f6b4d23bc1d74a6/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/98eb623043d4a2b0fc265d331f6b4d23bc1d74a6/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=98eb623043d4a2b0fc265d331f6b4d23bc1d74a6", "patch": "@@ -8,133 +8,135 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 123 lints included in this crate:\n-\n-name                                                                                                           | default | meaning\n----------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n-[absurd_extreme_comparisons](https://github.com/Manishearth/rust-clippy/wiki#absurd_extreme_comparisons)       | warn    | a comparison involving a maximum or minimum value involves a case that is always true or always false\n-[approx_constant](https://github.com/Manishearth/rust-clippy/wiki#approx_constant)                             | warn    | the approximate of a known float constant (in `std::f64::consts` or `std::f32::consts`) is found; suggests to use the constant\n-[bad_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#bad_bit_mask)                                   | warn    | expressions of the form `_ & mask == select` that will only ever return `true` or `false` (because in the example `select` containing bits that `mask` doesn't have)\n-[block_in_if_condition_expr](https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_expr)       | warn    | braces can be eliminated in conditions that are expressions, e.g `if { true } ...`\n-[block_in_if_condition_stmt](https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_stmt)       | warn    | avoid complex blocks in conditions, instead move the block higher and bind it with 'let'; e.g: `if { let x = true; x } ...`\n-[bool_comparison](https://github.com/Manishearth/rust-clippy/wiki#bool_comparison)                             | warn    | comparing a variable to a boolean, e.g. `if x == true`\n-[box_vec](https://github.com/Manishearth/rust-clippy/wiki#box_vec)                                             | warn    | usage of `Box<Vec<T>>`, vector elements are already on the heap\n-[boxed_local](https://github.com/Manishearth/rust-clippy/wiki#boxed_local)                                     | warn    | using Box<T> where unnecessary\n-[cast_possible_truncation](https://github.com/Manishearth/rust-clippy/wiki#cast_possible_truncation)           | allow   | casts that may cause truncation of the value, e.g `x as u8` where `x: u32`, or `x as i32` where `x: f32`\n-[cast_possible_wrap](https://github.com/Manishearth/rust-clippy/wiki#cast_possible_wrap)                       | allow   | casts that may cause wrapping around the value, e.g `x as i32` where `x: u32` and `x > i32::MAX`\n-[cast_precision_loss](https://github.com/Manishearth/rust-clippy/wiki#cast_precision_loss)                     | allow   | casts that cause loss of precision, e.g `x as f32` where `x: u64`\n-[cast_sign_loss](https://github.com/Manishearth/rust-clippy/wiki#cast_sign_loss)                               | allow   | casts from signed types to unsigned types, e.g `x as u32` where `x: i32`\n-[char_lit_as_u8](https://github.com/Manishearth/rust-clippy/wiki#char_lit_as_u8)                               | warn    | Casting a character literal to u8\n-[chars_next_cmp](https://github.com/Manishearth/rust-clippy/wiki#chars_next_cmp)                               | warn    | using `.chars().next()` to check if a string starts with a char\n-[clone_double_ref](https://github.com/Manishearth/rust-clippy/wiki#clone_double_ref)                           | warn    | using `clone` on `&&T`\n-[clone_on_copy](https://github.com/Manishearth/rust-clippy/wiki#clone_on_copy)                                 | warn    | using `clone` on a `Copy` type\n-[cmp_nan](https://github.com/Manishearth/rust-clippy/wiki#cmp_nan)                                             | deny    | comparisons to NAN (which will always return false, which is probably not intended)\n-[cmp_owned](https://github.com/Manishearth/rust-clippy/wiki#cmp_owned)                                         | warn    | creating owned instances for comparing with others, e.g. `x == \"foo\".to_string()`\n-[collapsible_if](https://github.com/Manishearth/rust-clippy/wiki#collapsible_if)                               | warn    | two nested `if`-expressions can be collapsed into one, e.g. `if x { if y { foo() } }` can be written as `if x && y { foo() }` and an `else { if .. } expression can be collapsed to `else if`\n-[cyclomatic_complexity](https://github.com/Manishearth/rust-clippy/wiki#cyclomatic_complexity)                 | warn    | finds functions that should be split up into multiple functions\n-[deprecated_semver](https://github.com/Manishearth/rust-clippy/wiki#deprecated_semver)                         | warn    | `Warn` on `#[deprecated(since = \"x\")]` where x is not semver\n-[derive_hash_xor_eq](https://github.com/Manishearth/rust-clippy/wiki#derive_hash_xor_eq)                       | warn    | deriving `Hash` but implementing `PartialEq` explicitly\n-[drop_ref](https://github.com/Manishearth/rust-clippy/wiki#drop_ref)                                           | warn    | call to `std::mem::drop` with a reference instead of an owned value, which will not call the `Drop::drop` method on the underlying value\n-[duplicate_underscore_argument](https://github.com/Manishearth/rust-clippy/wiki#duplicate_underscore_argument) | warn    | Function arguments having names which only differ by an underscore\n-[empty_loop](https://github.com/Manishearth/rust-clippy/wiki#empty_loop)                                       | warn    | empty `loop {}` detected\n-[enum_glob_use](https://github.com/Manishearth/rust-clippy/wiki#enum_glob_use)                                 | allow   | finds use items that import all variants of an enum\n-[enum_variant_names](https://github.com/Manishearth/rust-clippy/wiki#enum_variant_names)                       | warn    | finds enums where all variants share a prefix/postfix\n-[eq_op](https://github.com/Manishearth/rust-clippy/wiki#eq_op)                                                 | warn    | equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)\n-[expl_impl_clone_on_copy](https://github.com/Manishearth/rust-clippy/wiki#expl_impl_clone_on_copy)             | warn    | implementing `Clone` explicitly on `Copy` types\n-[explicit_counter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_counter_loop)                 | warn    | for-looping with an explicit counter when `_.enumerate()` would do\n-[explicit_iter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_iter_loop)                       | warn    | for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\n-[extend_from_slice](https://github.com/Manishearth/rust-clippy/wiki#extend_from_slice)                         | warn    | `.extend_from_slice(_)` is a faster way to extend a Vec by a slice\n-[filter_next](https://github.com/Manishearth/rust-clippy/wiki#filter_next)                                     | warn    | using `filter(p).next()`, which is more succinctly expressed as `.find(p)`\n-[float_cmp](https://github.com/Manishearth/rust-clippy/wiki#float_cmp)                                         | warn    | using `==` or `!=` on float values (as floating-point operations usually involve rounding errors, it is always better to check for approximate equality within small bounds)\n-[for_kv_map](https://github.com/Manishearth/rust-clippy/wiki#for_kv_map)                                       | warn    | looping on a map using `iter` when `keys` or `values` would do\n-[for_loop_over_option](https://github.com/Manishearth/rust-clippy/wiki#for_loop_over_option)                   | warn    | for-looping over an `Option`, which is more clearly expressed as an `if let`\n-[for_loop_over_result](https://github.com/Manishearth/rust-clippy/wiki#for_loop_over_result)                   | warn    | for-looping over a `Result`, which is more clearly expressed as an `if let`\n-[identity_op](https://github.com/Manishearth/rust-clippy/wiki#identity_op)                                     | warn    | using identity operations, e.g. `x + 0` or `y / 1`\n-[if_same_then_else](https://github.com/Manishearth/rust-clippy/wiki#if_same_then_else)                         | warn    | if with the same *then* and *else* blocks\n-[ifs_same_cond](https://github.com/Manishearth/rust-clippy/wiki#ifs_same_cond)                                 | warn    | consecutive `ifs` with the same condition\n-[ineffective_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#ineffective_bit_mask)                   | warn    | expressions where a bit mask will be rendered useless by a comparison, e.g. `(x | 1) > 2`\n-[inline_always](https://github.com/Manishearth/rust-clippy/wiki#inline_always)                                 | warn    | `#[inline(always)]` is a bad idea in most cases\n-[invalid_regex](https://github.com/Manishearth/rust-clippy/wiki#invalid_regex)                                 | deny    | finds invalid regular expressions in `Regex::new(_)` invocations\n-[items_after_statements](https://github.com/Manishearth/rust-clippy/wiki#items_after_statements)               | warn    | finds blocks where an item comes after a statement\n-[iter_next_loop](https://github.com/Manishearth/rust-clippy/wiki#iter_next_loop)                               | warn    | for-looping over `_.next()` which is probably not intended\n-[len_without_is_empty](https://github.com/Manishearth/rust-clippy/wiki#len_without_is_empty)                   | warn    | traits and impls that have `.len()` but not `.is_empty()`\n-[len_zero](https://github.com/Manishearth/rust-clippy/wiki#len_zero)                                           | warn    | checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` could be used instead\n-[let_and_return](https://github.com/Manishearth/rust-clippy/wiki#let_and_return)                               | warn    | creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\n-[let_unit_value](https://github.com/Manishearth/rust-clippy/wiki#let_unit_value)                               | warn    | creating a let binding to a value of unit type, which usually can't be used afterwards\n-[linkedlist](https://github.com/Manishearth/rust-clippy/wiki#linkedlist)                                       | warn    | usage of LinkedList, usually a vector is faster, or a more specialized data structure like a VecDeque\n-[map_clone](https://github.com/Manishearth/rust-clippy/wiki#map_clone)                                         | warn    | using `.map(|x| x.clone())` to clone an iterator or option's contents (recommends `.cloned()` instead)\n-[map_entry](https://github.com/Manishearth/rust-clippy/wiki#map_entry)                                         | warn    | use of `contains_key` followed by `insert` on a `HashMap` or `BTreeMap`\n-[match_bool](https://github.com/Manishearth/rust-clippy/wiki#match_bool)                                       | warn    | a match on boolean expression; recommends `if..else` block instead\n-[match_overlapping_arm](https://github.com/Manishearth/rust-clippy/wiki#match_overlapping_arm)                 | warn    | a match has overlapping arms\n-[match_ref_pats](https://github.com/Manishearth/rust-clippy/wiki#match_ref_pats)                               | warn    | a match or `if let` has all arms prefixed with `&`; the match expression can be dereferenced instead\n-[match_same_arms](https://github.com/Manishearth/rust-clippy/wiki#match_same_arms)                             | warn    | `match` with identical arm bodies\n-[min_max](https://github.com/Manishearth/rust-clippy/wiki#min_max)                                             | warn    | `min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant\n-[modulo_one](https://github.com/Manishearth/rust-clippy/wiki#modulo_one)                                       | warn    | taking a number modulo 1, which always returns 0\n-[mut_mut](https://github.com/Manishearth/rust-clippy/wiki#mut_mut)                                             | allow   | usage of double-mut refs, e.g. `&mut &mut ...` (either copy'n'paste error, or shows a fundamental misunderstanding of references)\n-[mutex_atomic](https://github.com/Manishearth/rust-clippy/wiki#mutex_atomic)                                   | warn    | using a Mutex where an atomic value could be used instead\n-[mutex_integer](https://github.com/Manishearth/rust-clippy/wiki#mutex_integer)                                 | allow   | using a Mutex for an integer type\n-[needless_bool](https://github.com/Manishearth/rust-clippy/wiki#needless_bool)                                 | warn    | if-statements with plain booleans in the then- and else-clause, e.g. `if p { true } else { false }`\n-[needless_lifetimes](https://github.com/Manishearth/rust-clippy/wiki#needless_lifetimes)                       | warn    | using explicit lifetimes for references in function arguments when elision rules would allow omitting them\n-[needless_range_loop](https://github.com/Manishearth/rust-clippy/wiki#needless_range_loop)                     | warn    | for-looping over a range of indices where an iterator over items would do\n-[needless_return](https://github.com/Manishearth/rust-clippy/wiki#needless_return)                             | warn    | using a return statement like `return expr;` where an expression would suffice\n-[needless_update](https://github.com/Manishearth/rust-clippy/wiki#needless_update)                             | warn    | using `{ ..base }` when there are no missing fields\n-[new_ret_no_self](https://github.com/Manishearth/rust-clippy/wiki#new_ret_no_self)                             | warn    | not returning `Self` in a `new` method\n-[no_effect](https://github.com/Manishearth/rust-clippy/wiki#no_effect)                                         | warn    | statements with no effect\n-[non_ascii_literal](https://github.com/Manishearth/rust-clippy/wiki#non_ascii_literal)                         | allow   | using any literal non-ASCII chars in a string literal; suggests using the \\\\u escape instead\n-[nonsensical_open_options](https://github.com/Manishearth/rust-clippy/wiki#nonsensical_open_options)           | warn    | nonsensical combination of options for opening a file\n-[ok_expect](https://github.com/Manishearth/rust-clippy/wiki#ok_expect)                                         | warn    | using `ok().expect()`, which gives worse error messages than calling `expect` directly on the Result\n-[option_map_unwrap_or](https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or)                   | warn    | using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as `map_or(a, f)`\n-[option_map_unwrap_or_else](https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or_else)         | warn    | using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as `map_or_else(g, f)`\n-[option_unwrap_used](https://github.com/Manishearth/rust-clippy/wiki#option_unwrap_used)                       | allow   | using `Option.unwrap()`, which should at least get a better message using `expect()`\n-[or_fun_call](https://github.com/Manishearth/rust-clippy/wiki#or_fun_call)                                     | warn    | using any `*or` method when the `*or_else` would do\n-[out_of_bounds_indexing](https://github.com/Manishearth/rust-clippy/wiki#out_of_bounds_indexing)               | deny    | out of bound constant indexing\n-[panic_params](https://github.com/Manishearth/rust-clippy/wiki#panic_params)                                   | warn    | missing parameters in `panic!`\n-[precedence](https://github.com/Manishearth/rust-clippy/wiki#precedence)                                       | warn    | catches operations where precedence may be unclear. See the wiki for a list of cases caught\n-[print_stdout](https://github.com/Manishearth/rust-clippy/wiki#print_stdout)                                   | allow   | printing on stdout\n-[ptr_arg](https://github.com/Manishearth/rust-clippy/wiki#ptr_arg)                                             | warn    | fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` instead, respectively\n-[range_step_by_zero](https://github.com/Manishearth/rust-clippy/wiki#range_step_by_zero)                       | warn    | using Range::step_by(0), which produces an infinite iterator\n-[range_zip_with_len](https://github.com/Manishearth/rust-clippy/wiki#range_zip_with_len)                       | warn    | zipping iterator with a range when enumerate() would do\n-[redundant_closure](https://github.com/Manishearth/rust-clippy/wiki#redundant_closure)                         | warn    | using redundant closures, i.e. `|a| foo(a)` (which can be written as just `foo`)\n-[redundant_pattern](https://github.com/Manishearth/rust-clippy/wiki#redundant_pattern)                         | warn    | using `name @ _` in a pattern\n-[regex_macro](https://github.com/Manishearth/rust-clippy/wiki#regex_macro)                                     | warn    | finds use of `regex!(_)`, suggests `Regex::new(_)` instead\n-[result_unwrap_used](https://github.com/Manishearth/rust-clippy/wiki#result_unwrap_used)                       | allow   | using `Result.unwrap()`, which might be better handled\n-[reverse_range_loop](https://github.com/Manishearth/rust-clippy/wiki#reverse_range_loop)                       | warn    | Iterating over an empty range, such as `10..0` or `5..5`\n-[search_is_some](https://github.com/Manishearth/rust-clippy/wiki#search_is_some)                               | warn    | using an iterator search followed by `is_some()`, which is more succinctly expressed as a call to `any()`\n-[shadow_reuse](https://github.com/Manishearth/rust-clippy/wiki#shadow_reuse)                                   | allow   | rebinding a name to an expression that re-uses the original value, e.g. `let x = x + 1`\n-[shadow_same](https://github.com/Manishearth/rust-clippy/wiki#shadow_same)                                     | allow   | rebinding a name to itself, e.g. `let mut x = &mut x`\n-[shadow_unrelated](https://github.com/Manishearth/rust-clippy/wiki#shadow_unrelated)                           | allow   | The name is re-bound without even using the original value\n-[should_implement_trait](https://github.com/Manishearth/rust-clippy/wiki#should_implement_trait)               | warn    | defining a method that should be implementing a std trait\n-[single_char_pattern](https://github.com/Manishearth/rust-clippy/wiki#single_char_pattern)                     | warn    | using a single-character str where a char could be used, e.g. `_.split(\"x\")`\n-[single_match](https://github.com/Manishearth/rust-clippy/wiki#single_match)                                   | warn    | a match statement with a single nontrivial arm (i.e, where the other arm is `_ => {}`) is used; recommends `if let` instead\n-[single_match_else](https://github.com/Manishearth/rust-clippy/wiki#single_match_else)                         | allow   | a match statement with a two arms where the second arm's pattern is a wildcard; recommends `if let` instead\n-[str_to_string](https://github.com/Manishearth/rust-clippy/wiki#str_to_string)                                 | warn    | using `to_string()` on a str, which should be `to_owned()`\n-[string_add](https://github.com/Manishearth/rust-clippy/wiki#string_add)                                       | allow   | using `x + ..` where x is a `String`; suggests using `push_str()` instead\n-[string_add_assign](https://github.com/Manishearth/rust-clippy/wiki#string_add_assign)                         | allow   | using `x = x + ..` where x is a `String`; suggests using `push_str()` instead\n-[string_lit_as_bytes](https://github.com/Manishearth/rust-clippy/wiki#string_lit_as_bytes)                     | warn    | calling `as_bytes` on a string literal; suggests using a byte string literal instead\n-[string_to_string](https://github.com/Manishearth/rust-clippy/wiki#string_to_string)                           | warn    | calling `String::to_string` which is inefficient\n-[temporary_assignment](https://github.com/Manishearth/rust-clippy/wiki#temporary_assignment)                   | warn    | assignments to temporaries\n-[toplevel_ref_arg](https://github.com/Manishearth/rust-clippy/wiki#toplevel_ref_arg)                           | warn    | An entire binding was declared as `ref`, in a function argument (`fn foo(ref x: Bar)`), or a `let` statement (`let ref x = foo()`). In such cases, it is preferred to take references with `&`.\n-[trivial_regex](https://github.com/Manishearth/rust-clippy/wiki#trivial_regex)                                 | warn    | finds trivial regular expressions in `Regex::new(_)` invocations\n-[type_complexity](https://github.com/Manishearth/rust-clippy/wiki#type_complexity)                             | warn    | usage of very complex types; recommends factoring out parts into `type` definitions\n-[unicode_not_nfc](https://github.com/Manishearth/rust-clippy/wiki#unicode_not_nfc)                             | allow   | using a unicode literal not in NFC normal form (see http://www.unicode.org/reports/tr15/ for further information)\n-[unit_cmp](https://github.com/Manishearth/rust-clippy/wiki#unit_cmp)                                           | warn    | comparing unit values (which is always `true` or `false`, respectively)\n-[unnecessary_mut_passed](https://github.com/Manishearth/rust-clippy/wiki#unnecessary_mut_passed)               | warn    | an argument is passed as a mutable reference although the function/method only demands an immutable reference\n-[unneeded_field_pattern](https://github.com/Manishearth/rust-clippy/wiki#unneeded_field_pattern)               | warn    | Struct fields are bound to a wildcard instead of using `..`\n-[unstable_as_mut_slice](https://github.com/Manishearth/rust-clippy/wiki#unstable_as_mut_slice)                 | warn    | as_mut_slice is not stable and can be replaced by &mut v[..]see https://github.com/rust-lang/rust/issues/27729\n-[unstable_as_slice](https://github.com/Manishearth/rust-clippy/wiki#unstable_as_slice)                         | warn    | as_slice is not stable and can be replaced by & v[..]see https://github.com/rust-lang/rust/issues/27729\n-[unused_collect](https://github.com/Manishearth/rust-clippy/wiki#unused_collect)                               | warn    | `collect()`ing an iterator without using the result; this is usually better written as a for loop\n-[unused_lifetimes](https://github.com/Manishearth/rust-clippy/wiki#unused_lifetimes)                           | warn    | unused lifetimes in function definitions\n-[use_debug](https://github.com/Manishearth/rust-clippy/wiki#use_debug)                                         | allow   | use `Debug`-based formatting\n-[used_underscore_binding](https://github.com/Manishearth/rust-clippy/wiki#used_underscore_binding)             | warn    | using a binding which is prefixed with an underscore\n-[useless_format](https://github.com/Manishearth/rust-clippy/wiki#useless_format)                               | warn    | useless use of `format!`\n-[useless_transmute](https://github.com/Manishearth/rust-clippy/wiki#useless_transmute)                         | warn    | transmutes that have the same to and from types\n-[useless_vec](https://github.com/Manishearth/rust-clippy/wiki#useless_vec)                                     | warn    | useless `vec!`\n-[while_let_loop](https://github.com/Manishearth/rust-clippy/wiki#while_let_loop)                               | warn    | `loop { if let { ... } else break }` can be written as a `while let` loop\n-[while_let_on_iterator](https://github.com/Manishearth/rust-clippy/wiki#while_let_on_iterator)                 | warn    | using a while-let loop instead of a for loop on an iterator\n-[wrong_pub_self_convention](https://github.com/Manishearth/rust-clippy/wiki#wrong_pub_self_convention)         | allow   | defining a public method named with an established prefix (like \"into_\") that takes `self` with the wrong convention\n-[wrong_self_convention](https://github.com/Manishearth/rust-clippy/wiki#wrong_self_convention)                 | warn    | defining a method named with an established prefix (like \"into_\") that takes `self` with the wrong convention\n-[zero_divided_by_zero](https://github.com/Manishearth/rust-clippy/wiki#zero_divided_by_zero)                   | warn    | usage of `0.0 / 0.0` to obtain NaN instead of std::f32::NaN or std::f64::NaN\n-[zero_width_space](https://github.com/Manishearth/rust-clippy/wiki#zero_width_space)                           | deny    | using a zero-width space in a string literal, which is confusing\n+There are 125 lints included in this crate:\n+\n+name                                                                                                                 | default | meaning\n+---------------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n+[absurd_extreme_comparisons](https://github.com/Manishearth/rust-clippy/wiki#absurd_extreme_comparisons)             | warn    | a comparison involving a maximum or minimum value involves a case that is always true or always false\n+[approx_constant](https://github.com/Manishearth/rust-clippy/wiki#approx_constant)                                   | warn    | the approximate of a known float constant (in `std::f64::consts` or `std::f32::consts`) is found; suggests to use the constant\n+[bad_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#bad_bit_mask)                                         | warn    | expressions of the form `_ & mask == select` that will only ever return `true` or `false` (because in the example `select` containing bits that `mask` doesn't have)\n+[block_in_if_condition_expr](https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_expr)             | warn    | braces can be eliminated in conditions that are expressions, e.g `if { true } ...`\n+[block_in_if_condition_stmt](https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_stmt)             | warn    | avoid complex blocks in conditions, instead move the block higher and bind it with 'let'; e.g: `if { let x = true; x } ...`\n+[bool_comparison](https://github.com/Manishearth/rust-clippy/wiki#bool_comparison)                                   | warn    | comparing a variable to a boolean, e.g. `if x == true`\n+[box_vec](https://github.com/Manishearth/rust-clippy/wiki#box_vec)                                                   | warn    | usage of `Box<Vec<T>>`, vector elements are already on the heap\n+[boxed_local](https://github.com/Manishearth/rust-clippy/wiki#boxed_local)                                           | warn    | using Box<T> where unnecessary\n+[cast_possible_truncation](https://github.com/Manishearth/rust-clippy/wiki#cast_possible_truncation)                 | allow   | casts that may cause truncation of the value, e.g `x as u8` where `x: u32`, or `x as i32` where `x: f32`\n+[cast_possible_wrap](https://github.com/Manishearth/rust-clippy/wiki#cast_possible_wrap)                             | allow   | casts that may cause wrapping around the value, e.g `x as i32` where `x: u32` and `x > i32::MAX`\n+[cast_precision_loss](https://github.com/Manishearth/rust-clippy/wiki#cast_precision_loss)                           | allow   | casts that cause loss of precision, e.g `x as f32` where `x: u64`\n+[cast_sign_loss](https://github.com/Manishearth/rust-clippy/wiki#cast_sign_loss)                                     | allow   | casts from signed types to unsigned types, e.g `x as u32` where `x: i32`\n+[char_lit_as_u8](https://github.com/Manishearth/rust-clippy/wiki#char_lit_as_u8)                                     | warn    | Casting a character literal to u8\n+[chars_next_cmp](https://github.com/Manishearth/rust-clippy/wiki#chars_next_cmp)                                     | warn    | using `.chars().next()` to check if a string starts with a char\n+[clone_double_ref](https://github.com/Manishearth/rust-clippy/wiki#clone_double_ref)                                 | warn    | using `clone` on `&&T`\n+[clone_on_copy](https://github.com/Manishearth/rust-clippy/wiki#clone_on_copy)                                       | warn    | using `clone` on a `Copy` type\n+[cmp_nan](https://github.com/Manishearth/rust-clippy/wiki#cmp_nan)                                                   | deny    | comparisons to NAN (which will always return false, which is probably not intended)\n+[cmp_owned](https://github.com/Manishearth/rust-clippy/wiki#cmp_owned)                                               | warn    | creating owned instances for comparing with others, e.g. `x == \"foo\".to_string()`\n+[collapsible_if](https://github.com/Manishearth/rust-clippy/wiki#collapsible_if)                                     | warn    | two nested `if`-expressions can be collapsed into one, e.g. `if x { if y { foo() } }` can be written as `if x && y { foo() }` and an `else { if .. } expression can be collapsed to `else if`\n+[cyclomatic_complexity](https://github.com/Manishearth/rust-clippy/wiki#cyclomatic_complexity)                       | warn    | finds functions that should be split up into multiple functions\n+[deprecated_semver](https://github.com/Manishearth/rust-clippy/wiki#deprecated_semver)                               | warn    | `Warn` on `#[deprecated(since = \"x\")]` where x is not semver\n+[derive_hash_xor_eq](https://github.com/Manishearth/rust-clippy/wiki#derive_hash_xor_eq)                             | warn    | deriving `Hash` but implementing `PartialEq` explicitly\n+[drop_ref](https://github.com/Manishearth/rust-clippy/wiki#drop_ref)                                                 | warn    | call to `std::mem::drop` with a reference instead of an owned value, which will not call the `Drop::drop` method on the underlying value\n+[duplicate_underscore_argument](https://github.com/Manishearth/rust-clippy/wiki#duplicate_underscore_argument)       | warn    | Function arguments having names which only differ by an underscore\n+[empty_loop](https://github.com/Manishearth/rust-clippy/wiki#empty_loop)                                             | warn    | empty `loop {}` detected\n+[enum_glob_use](https://github.com/Manishearth/rust-clippy/wiki#enum_glob_use)                                       | allow   | finds use items that import all variants of an enum\n+[enum_variant_names](https://github.com/Manishearth/rust-clippy/wiki#enum_variant_names)                             | warn    | finds enums where all variants share a prefix/postfix\n+[eq_op](https://github.com/Manishearth/rust-clippy/wiki#eq_op)                                                       | warn    | equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)\n+[expl_impl_clone_on_copy](https://github.com/Manishearth/rust-clippy/wiki#expl_impl_clone_on_copy)                   | warn    | implementing `Clone` explicitly on `Copy` types\n+[explicit_counter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_counter_loop)                       | warn    | for-looping with an explicit counter when `_.enumerate()` would do\n+[explicit_iter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_iter_loop)                             | warn    | for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\n+[extend_from_slice](https://github.com/Manishearth/rust-clippy/wiki#extend_from_slice)                               | warn    | `.extend_from_slice(_)` is a faster way to extend a Vec by a slice\n+[filter_next](https://github.com/Manishearth/rust-clippy/wiki#filter_next)                                           | warn    | using `filter(p).next()`, which is more succinctly expressed as `.find(p)`\n+[float_cmp](https://github.com/Manishearth/rust-clippy/wiki#float_cmp)                                               | warn    | using `==` or `!=` on float values (as floating-point operations usually involve rounding errors, it is always better to check for approximate equality within small bounds)\n+[for_kv_map](https://github.com/Manishearth/rust-clippy/wiki#for_kv_map)                                             | warn    | looping on a map using `iter` when `keys` or `values` would do\n+[for_loop_over_option](https://github.com/Manishearth/rust-clippy/wiki#for_loop_over_option)                         | warn    | for-looping over an `Option`, which is more clearly expressed as an `if let`\n+[for_loop_over_result](https://github.com/Manishearth/rust-clippy/wiki#for_loop_over_result)                         | warn    | for-looping over a `Result`, which is more clearly expressed as an `if let`\n+[identity_op](https://github.com/Manishearth/rust-clippy/wiki#identity_op)                                           | warn    | using identity operations, e.g. `x + 0` or `y / 1`\n+[if_same_then_else](https://github.com/Manishearth/rust-clippy/wiki#if_same_then_else)                               | warn    | if with the same *then* and *else* blocks\n+[ifs_same_cond](https://github.com/Manishearth/rust-clippy/wiki#ifs_same_cond)                                       | warn    | consecutive `ifs` with the same condition\n+[ineffective_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#ineffective_bit_mask)                         | warn    | expressions where a bit mask will be rendered useless by a comparison, e.g. `(x | 1) > 2`\n+[inline_always](https://github.com/Manishearth/rust-clippy/wiki#inline_always)                                       | warn    | `#[inline(always)]` is a bad idea in most cases\n+[invalid_regex](https://github.com/Manishearth/rust-clippy/wiki#invalid_regex)                                       | deny    | finds invalid regular expressions in `Regex::new(_)` invocations\n+[items_after_statements](https://github.com/Manishearth/rust-clippy/wiki#items_after_statements)                     | warn    | finds blocks where an item comes after a statement\n+[iter_next_loop](https://github.com/Manishearth/rust-clippy/wiki#iter_next_loop)                                     | warn    | for-looping over `_.next()` which is probably not intended\n+[len_without_is_empty](https://github.com/Manishearth/rust-clippy/wiki#len_without_is_empty)                         | warn    | traits and impls that have `.len()` but not `.is_empty()`\n+[len_zero](https://github.com/Manishearth/rust-clippy/wiki#len_zero)                                                 | warn    | checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` could be used instead\n+[let_and_return](https://github.com/Manishearth/rust-clippy/wiki#let_and_return)                                     | warn    | creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\n+[let_unit_value](https://github.com/Manishearth/rust-clippy/wiki#let_unit_value)                                     | warn    | creating a let binding to a value of unit type, which usually can't be used afterwards\n+[linkedlist](https://github.com/Manishearth/rust-clippy/wiki#linkedlist)                                             | warn    | usage of LinkedList, usually a vector is faster, or a more specialized data structure like a VecDeque\n+[map_clone](https://github.com/Manishearth/rust-clippy/wiki#map_clone)                                               | warn    | using `.map(|x| x.clone())` to clone an iterator or option's contents (recommends `.cloned()` instead)\n+[map_entry](https://github.com/Manishearth/rust-clippy/wiki#map_entry)                                               | warn    | use of `contains_key` followed by `insert` on a `HashMap` or `BTreeMap`\n+[match_bool](https://github.com/Manishearth/rust-clippy/wiki#match_bool)                                             | warn    | a match on boolean expression; recommends `if..else` block instead\n+[match_overlapping_arm](https://github.com/Manishearth/rust-clippy/wiki#match_overlapping_arm)                       | warn    | a match has overlapping arms\n+[match_ref_pats](https://github.com/Manishearth/rust-clippy/wiki#match_ref_pats)                                     | warn    | a match or `if let` has all arms prefixed with `&`; the match expression can be dereferenced instead\n+[match_same_arms](https://github.com/Manishearth/rust-clippy/wiki#match_same_arms)                                   | warn    | `match` with identical arm bodies\n+[min_max](https://github.com/Manishearth/rust-clippy/wiki#min_max)                                                   | warn    | `min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant\n+[modulo_one](https://github.com/Manishearth/rust-clippy/wiki#modulo_one)                                             | warn    | taking a number modulo 1, which always returns 0\n+[mut_mut](https://github.com/Manishearth/rust-clippy/wiki#mut_mut)                                                   | allow   | usage of double-mut refs, e.g. `&mut &mut ...` (either copy'n'paste error, or shows a fundamental misunderstanding of references)\n+[mutex_atomic](https://github.com/Manishearth/rust-clippy/wiki#mutex_atomic)                                         | warn    | using a Mutex where an atomic value could be used instead\n+[mutex_integer](https://github.com/Manishearth/rust-clippy/wiki#mutex_integer)                                       | allow   | using a Mutex for an integer type\n+[needless_bool](https://github.com/Manishearth/rust-clippy/wiki#needless_bool)                                       | warn    | if-statements with plain booleans in the then- and else-clause, e.g. `if p { true } else { false }`\n+[needless_lifetimes](https://github.com/Manishearth/rust-clippy/wiki#needless_lifetimes)                             | warn    | using explicit lifetimes for references in function arguments when elision rules would allow omitting them\n+[needless_range_loop](https://github.com/Manishearth/rust-clippy/wiki#needless_range_loop)                           | warn    | for-looping over a range of indices where an iterator over items would do\n+[needless_return](https://github.com/Manishearth/rust-clippy/wiki#needless_return)                                   | warn    | using a return statement like `return expr;` where an expression would suffice\n+[needless_update](https://github.com/Manishearth/rust-clippy/wiki#needless_update)                                   | warn    | using `{ ..base }` when there are no missing fields\n+[new_ret_no_self](https://github.com/Manishearth/rust-clippy/wiki#new_ret_no_self)                                   | warn    | not returning `Self` in a `new` method\n+[no_effect](https://github.com/Manishearth/rust-clippy/wiki#no_effect)                                               | warn    | statements with no effect\n+[non_ascii_literal](https://github.com/Manishearth/rust-clippy/wiki#non_ascii_literal)                               | allow   | using any literal non-ASCII chars in a string literal; suggests using the \\\\u escape instead\n+[nonsensical_open_options](https://github.com/Manishearth/rust-clippy/wiki#nonsensical_open_options)                 | warn    | nonsensical combination of options for opening a file\n+[ok_expect](https://github.com/Manishearth/rust-clippy/wiki#ok_expect)                                               | warn    | using `ok().expect()`, which gives worse error messages than calling `expect` directly on the Result\n+[option_map_unwrap_or](https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or)                         | warn    | using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as `map_or(a, f)`\n+[option_map_unwrap_or_else](https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or_else)               | warn    | using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as `map_or_else(g, f)`\n+[option_unwrap_used](https://github.com/Manishearth/rust-clippy/wiki#option_unwrap_used)                             | allow   | using `Option.unwrap()`, which should at least get a better message using `expect()`\n+[or_fun_call](https://github.com/Manishearth/rust-clippy/wiki#or_fun_call)                                           | warn    | using any `*or` method when the `*or_else` would do\n+[out_of_bounds_indexing](https://github.com/Manishearth/rust-clippy/wiki#out_of_bounds_indexing)                     | deny    | out of bound constant indexing\n+[panic_params](https://github.com/Manishearth/rust-clippy/wiki#panic_params)                                         | warn    | missing parameters in `panic!`\n+[precedence](https://github.com/Manishearth/rust-clippy/wiki#precedence)                                             | warn    | catches operations where precedence may be unclear. See the wiki for a list of cases caught\n+[print_stdout](https://github.com/Manishearth/rust-clippy/wiki#print_stdout)                                         | allow   | printing on stdout\n+[ptr_arg](https://github.com/Manishearth/rust-clippy/wiki#ptr_arg)                                                   | warn    | fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` instead, respectively\n+[range_step_by_zero](https://github.com/Manishearth/rust-clippy/wiki#range_step_by_zero)                             | warn    | using Range::step_by(0), which produces an infinite iterator\n+[range_zip_with_len](https://github.com/Manishearth/rust-clippy/wiki#range_zip_with_len)                             | warn    | zipping iterator with a range when enumerate() would do\n+[redundant_closure](https://github.com/Manishearth/rust-clippy/wiki#redundant_closure)                               | warn    | using redundant closures, i.e. `|a| foo(a)` (which can be written as just `foo`)\n+[redundant_pattern](https://github.com/Manishearth/rust-clippy/wiki#redundant_pattern)                               | warn    | using `name @ _` in a pattern\n+[regex_macro](https://github.com/Manishearth/rust-clippy/wiki#regex_macro)                                           | warn    | finds use of `regex!(_)`, suggests `Regex::new(_)` instead\n+[result_unwrap_used](https://github.com/Manishearth/rust-clippy/wiki#result_unwrap_used)                             | allow   | using `Result.unwrap()`, which might be better handled\n+[reverse_range_loop](https://github.com/Manishearth/rust-clippy/wiki#reverse_range_loop)                             | warn    | Iterating over an empty range, such as `10..0` or `5..5`\n+[search_is_some](https://github.com/Manishearth/rust-clippy/wiki#search_is_some)                                     | warn    | using an iterator search followed by `is_some()`, which is more succinctly expressed as a call to `any()`\n+[shadow_reuse](https://github.com/Manishearth/rust-clippy/wiki#shadow_reuse)                                         | allow   | rebinding a name to an expression that re-uses the original value, e.g. `let x = x + 1`\n+[shadow_same](https://github.com/Manishearth/rust-clippy/wiki#shadow_same)                                           | allow   | rebinding a name to itself, e.g. `let mut x = &mut x`\n+[shadow_unrelated](https://github.com/Manishearth/rust-clippy/wiki#shadow_unrelated)                                 | allow   | The name is re-bound without even using the original value\n+[should_implement_trait](https://github.com/Manishearth/rust-clippy/wiki#should_implement_trait)                     | warn    | defining a method that should be implementing a std trait\n+[single_char_pattern](https://github.com/Manishearth/rust-clippy/wiki#single_char_pattern)                           | warn    | using a single-character str where a char could be used, e.g. `_.split(\"x\")`\n+[single_match](https://github.com/Manishearth/rust-clippy/wiki#single_match)                                         | warn    | a match statement with a single nontrivial arm (i.e, where the other arm is `_ => {}`) is used; recommends `if let` instead\n+[single_match_else](https://github.com/Manishearth/rust-clippy/wiki#single_match_else)                               | allow   | a match statement with a two arms where the second arm's pattern is a wildcard; recommends `if let` instead\n+[str_to_string](https://github.com/Manishearth/rust-clippy/wiki#str_to_string)                                       | warn    | using `to_string()` on a str, which should be `to_owned()`\n+[string_add](https://github.com/Manishearth/rust-clippy/wiki#string_add)                                             | allow   | using `x + ..` where x is a `String`; suggests using `push_str()` instead\n+[string_add_assign](https://github.com/Manishearth/rust-clippy/wiki#string_add_assign)                               | allow   | using `x = x + ..` where x is a `String`; suggests using `push_str()` instead\n+[string_lit_as_bytes](https://github.com/Manishearth/rust-clippy/wiki#string_lit_as_bytes)                           | warn    | calling `as_bytes` on a string literal; suggests using a byte string literal instead\n+[string_to_string](https://github.com/Manishearth/rust-clippy/wiki#string_to_string)                                 | warn    | calling `String::to_string` which is inefficient\n+[suspicious_assignment_formatting](https://github.com/Manishearth/rust-clippy/wiki#suspicious_assignment_formatting) | warn    | suspicious formatting of `*=`, `-=` or `!=`\n+[suspicious_else_formatting](https://github.com/Manishearth/rust-clippy/wiki#suspicious_else_formatting)             | warn    | suspicious formatting of `else if`\n+[temporary_assignment](https://github.com/Manishearth/rust-clippy/wiki#temporary_assignment)                         | warn    | assignments to temporaries\n+[toplevel_ref_arg](https://github.com/Manishearth/rust-clippy/wiki#toplevel_ref_arg)                                 | warn    | An entire binding was declared as `ref`, in a function argument (`fn foo(ref x: Bar)`), or a `let` statement (`let ref x = foo()`). In such cases, it is preferred to take references with `&`.\n+[trivial_regex](https://github.com/Manishearth/rust-clippy/wiki#trivial_regex)                                       | warn    | finds trivial regular expressions in `Regex::new(_)` invocations\n+[type_complexity](https://github.com/Manishearth/rust-clippy/wiki#type_complexity)                                   | warn    | usage of very complex types; recommends factoring out parts into `type` definitions\n+[unicode_not_nfc](https://github.com/Manishearth/rust-clippy/wiki#unicode_not_nfc)                                   | allow   | using a unicode literal not in NFC normal form (see http://www.unicode.org/reports/tr15/ for further information)\n+[unit_cmp](https://github.com/Manishearth/rust-clippy/wiki#unit_cmp)                                                 | warn    | comparing unit values (which is always `true` or `false`, respectively)\n+[unnecessary_mut_passed](https://github.com/Manishearth/rust-clippy/wiki#unnecessary_mut_passed)                     | warn    | an argument is passed as a mutable reference although the function/method only demands an immutable reference\n+[unneeded_field_pattern](https://github.com/Manishearth/rust-clippy/wiki#unneeded_field_pattern)                     | warn    | Struct fields are bound to a wildcard instead of using `..`\n+[unstable_as_mut_slice](https://github.com/Manishearth/rust-clippy/wiki#unstable_as_mut_slice)                       | warn    | as_mut_slice is not stable and can be replaced by &mut v[..]see https://github.com/rust-lang/rust/issues/27729\n+[unstable_as_slice](https://github.com/Manishearth/rust-clippy/wiki#unstable_as_slice)                               | warn    | as_slice is not stable and can be replaced by & v[..]see https://github.com/rust-lang/rust/issues/27729\n+[unused_collect](https://github.com/Manishearth/rust-clippy/wiki#unused_collect)                                     | warn    | `collect()`ing an iterator without using the result; this is usually better written as a for loop\n+[unused_lifetimes](https://github.com/Manishearth/rust-clippy/wiki#unused_lifetimes)                                 | warn    | unused lifetimes in function definitions\n+[use_debug](https://github.com/Manishearth/rust-clippy/wiki#use_debug)                                               | allow   | use `Debug`-based formatting\n+[used_underscore_binding](https://github.com/Manishearth/rust-clippy/wiki#used_underscore_binding)                   | warn    | using a binding which is prefixed with an underscore\n+[useless_format](https://github.com/Manishearth/rust-clippy/wiki#useless_format)                                     | warn    | useless use of `format!`\n+[useless_transmute](https://github.com/Manishearth/rust-clippy/wiki#useless_transmute)                               | warn    | transmutes that have the same to and from types\n+[useless_vec](https://github.com/Manishearth/rust-clippy/wiki#useless_vec)                                           | warn    | useless `vec!`\n+[while_let_loop](https://github.com/Manishearth/rust-clippy/wiki#while_let_loop)                                     | warn    | `loop { if let { ... } else break }` can be written as a `while let` loop\n+[while_let_on_iterator](https://github.com/Manishearth/rust-clippy/wiki#while_let_on_iterator)                       | warn    | using a while-let loop instead of a for loop on an iterator\n+[wrong_pub_self_convention](https://github.com/Manishearth/rust-clippy/wiki#wrong_pub_self_convention)               | allow   | defining a public method named with an established prefix (like \"into_\") that takes `self` with the wrong convention\n+[wrong_self_convention](https://github.com/Manishearth/rust-clippy/wiki#wrong_self_convention)                       | warn    | defining a method named with an established prefix (like \"into_\") that takes `self` with the wrong convention\n+[zero_divided_by_zero](https://github.com/Manishearth/rust-clippy/wiki#zero_divided_by_zero)                         | warn    | usage of `0.0 / 0.0` to obtain NaN instead of std::f32::NaN or std::f64::NaN\n+[zero_width_space](https://github.com/Manishearth/rust-clippy/wiki#zero_width_space)                                 | deny    | using a zero-width space in a string literal, which is confusing\n \n More to come, please [file an issue](https://github.com/Manishearth/rust-clippy/issues) if you have ideas!\n "}, {"sha": "64f45d72c12e27b83a114e77c276d7ede433dea7", "filename": "src/consts.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98eb623043d4a2b0fc265d331f6b4d23bc1d74a6/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98eb623043d4a2b0fc265d331f6b4d23bc1d74a6/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=98eb623043d4a2b0fc265d331f6b4d23bc1d74a6", "patch": "@@ -206,7 +206,6 @@ fn lit_to_constant(lit: &LitKind) -> Constant {\n }\n \n fn constant_not(o: Constant) -> Option<Constant> {\n-    use syntax::ast::LitIntType::*;\n     use self::Constant::*;\n     match o {\n         Bool(b) => Some(Bool(!b)),\n@@ -232,7 +231,6 @@ fn constant_not(o: Constant) -> Option<Constant> {\n }\n \n fn constant_negate(o: Constant) -> Option<Constant> {\n-    use syntax::ast::LitIntType::*;\n     use self::Constant::*;\n     match o {\n         Int(value, LitIntType::Signed(ity), sign) => Some(Int(value, LitIntType::Signed(ity), neg_sign(sign))),"}, {"sha": "efcb222ebed85a64392a57d63b5e8babd07e8e44", "filename": "src/formatting.rs", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/98eb623043d4a2b0fc265d331f6b4d23bc1d74a6/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98eb623043d4a2b0fc265d331f6b4d23bc1d74a6/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=98eb623043d4a2b0fc265d331f6b4d23bc1d74a6", "patch": "@@ -0,0 +1,166 @@\n+use rustc::lint::*;\n+use syntax::codemap::mk_sp;\n+use syntax::ast;\n+use utils::{differing_macro_contexts, in_macro, snippet_opt, span_note_and_lint};\n+use syntax::ptr::P;\n+\n+/// **What it does:** This lint looks for use of the non-existent `=*`, `=!` and `=-` operators.\n+///\n+/// **Why is this bad?** This is either a typo of `*=`, `!=` or `-=` or confusing.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust,ignore\n+/// a =- 42; // confusing, should it be `a -= 42` or `a = -42`?\n+/// ```\n+declare_lint! {\n+    pub SUSPICIOUS_ASSIGNMENT_FORMATTING,\n+    Warn,\n+    \"suspicious formatting of `*=`, `-=` or `!=`\"\n+}\n+\n+/// **What it does:** This lint checks for formatting of `else if`. It lints if the `else` and `if`\n+/// are not on the same line or the `else` seems to be missing.\n+///\n+/// **Why is this bad?** This is probably some refactoring remnant, even if the code is correct, it\n+/// might look confusing.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust,ignore\n+/// if foo {\n+/// } if bar { // looks like an `else` is missing here\n+/// }\n+///\n+/// if foo {\n+/// } else\n+///\n+/// if bar { // this is the `else` block of the previous `if`, but should it be?\n+/// }\n+/// ```\n+declare_lint! {\n+    pub SUSPICIOUS_ELSE_FORMATTING,\n+    Warn,\n+    \"suspicious formatting of `else if`\"\n+}\n+\n+#[derive(Copy,Clone)]\n+pub struct Formatting;\n+\n+impl LintPass for Formatting {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array![SUSPICIOUS_ASSIGNMENT_FORMATTING, SUSPICIOUS_ELSE_FORMATTING]\n+    }\n+}\n+\n+impl EarlyLintPass for Formatting {\n+    fn check_block(&mut self, cx: &EarlyContext, block: &ast::Block) {\n+        for w in block.stmts.windows(2) {\n+            match (&w[0].node, &w[1].node) {\n+                (&ast::StmtKind::Expr(ref first, _), &ast::StmtKind::Expr(ref second, _)) |\n+                (&ast::StmtKind::Expr(ref first, _), &ast::StmtKind::Semi(ref second, _)) => {\n+                    check_consecutive_ifs(cx, first, second);\n+                }\n+                _ => (),\n+            }\n+        }\n+\n+        if let Some(ref expr) = block.expr {\n+            if let Some(ref stmt) = block.stmts.iter().last() {\n+                if let ast::StmtKind::Expr(ref first, _) = stmt.node {\n+                    check_consecutive_ifs(cx, first, expr);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &EarlyContext, expr: &ast::Expr) {\n+        check_assign(cx, expr);\n+        check_else_if(cx, expr);\n+    }\n+}\n+\n+/// Implementation of the SUSPICIOUS_ASSIGNMENT_FORMATTING lint.\n+fn check_assign(cx: &EarlyContext, expr: &ast::Expr) {\n+    if let ast::ExprKind::Assign(ref lhs, ref rhs) = expr.node {\n+        if !differing_macro_contexts(lhs.span, rhs.span) && !in_macro(cx, lhs.span) {\n+            let eq_span = mk_sp(lhs.span.hi, rhs.span.lo);\n+\n+            if let ast::ExprKind::Unary(op, ref sub_rhs) = rhs.node {\n+                if let Some(eq_snippet) = snippet_opt(cx, eq_span) {\n+                    let op = ast::UnOp::to_string(op);\n+                    let eqop_span = mk_sp(lhs.span.hi, sub_rhs.span.lo);\n+                    if eq_snippet.ends_with('=') {\n+                        span_note_and_lint(cx,\n+                                           SUSPICIOUS_ASSIGNMENT_FORMATTING,\n+                                           eqop_span,\n+                                           &format!(\"this looks like you are trying to use `.. {op}= ..`, but you really are doing `.. = ({op} ..)`\", op=op),\n+                                           eqop_span,\n+                                           &format!(\"to remove this lint, use either `{op}=` or `= {op}`\", op=op));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Implementation of the SUSPICIOUS_ELSE_FORMATTING lint for weird `else if`.\n+fn check_else_if(cx: &EarlyContext, expr: &ast::Expr) {\n+    if let Some((then, &Some(ref else_))) = unsugar_if(expr) {\n+        if unsugar_if(else_).is_some() &&\n+        !differing_macro_contexts(then.span, else_.span) &&\n+        !in_macro(cx, then.span) {\n+            // this will be a span from the closing \u2018}\u2019 of the \u201cthen\u201d block (excluding) to the\n+            // \u201cif\u201d of the \u201celse if\u201d block (excluding)\n+            let else_span = mk_sp(then.span.hi, else_.span.lo);\n+\n+            // the snippet should look like \" else \\n    \" with maybe comments anywhere\n+            // it\u2019s bad when there is a \u2018\\n\u2019 after the \u201celse\u201d\n+            if let Some(else_snippet) = snippet_opt(cx, else_span) {\n+                let else_pos = else_snippet.find(\"else\").expect(\"there must be a `else` here\");\n+\n+                if else_snippet[else_pos..].contains('\\n') {\n+                    span_note_and_lint(cx,\n+                                       SUSPICIOUS_ELSE_FORMATTING,\n+                                       else_span,\n+                                       \"this is an `else if` but the formatting might hide it\",\n+                                       else_span,\n+                                       \"to remove this lint, remove the `else` or remove the new line between `else` and `if`\");\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Implementation of the `SUSPICIOUS_ELSE_FORMATTING` lint for consecutive ifs.\n+fn check_consecutive_ifs(cx: &EarlyContext, first: &ast::Expr, second: &ast::Expr) {\n+    if !differing_macro_contexts(first.span, second.span) &&\n+    !in_macro(cx, first.span) &&\n+    unsugar_if(first).is_some() &&\n+    unsugar_if(second).is_some() {\n+        // where the else would be\n+        let else_span = mk_sp(first.span.hi, second.span.lo);\n+\n+        if let Some(else_snippet) = snippet_opt(cx, else_span) {\n+            if !else_snippet.contains('\\n') {\n+                span_note_and_lint(cx,\n+                                   SUSPICIOUS_ELSE_FORMATTING,\n+                                   else_span,\n+                                   \"this looks like an `else if` but the `else` is missing\",\n+                                   else_span,\n+                                   \"to remove this lint, add the missing `else` or add a new line before the second `if`\");\n+            }\n+        }\n+    }\n+}\n+\n+/// Match `if` or `else if` expressions and return the `then` and `else` block.\n+fn unsugar_if(expr: &ast::Expr) -> Option<(&P<ast::Block>, &Option<P<ast::Expr>>)>{\n+    match expr.node {\n+        ast::ExprKind::If(_, ref then, ref else_) |\n+        ast::ExprKind::IfLet(_, _, ref then, ref else_) => Some((then, else_)),\n+        _ => None,\n+    }\n+}"}, {"sha": "47d9fc6f24c50da0809cff61fdd91aff8c719312", "filename": "src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98eb623043d4a2b0fc265d331f6b4d23bc1d74a6/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98eb623043d4a2b0fc265d331f6b4d23bc1d74a6/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=98eb623043d4a2b0fc265d331f6b4d23bc1d74a6", "patch": "@@ -57,6 +57,7 @@ pub mod eq_op;\n pub mod escape;\n pub mod eta_reduction;\n pub mod format;\n+pub mod formatting;\n pub mod identity_op;\n pub mod items_after_statements;\n pub mod len_zero;\n@@ -165,6 +166,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box regex::RegexPass::default());\n     reg.register_late_lint_pass(box copies::CopyAndPaste);\n     reg.register_late_lint_pass(box format::FormatMacLint);\n+    reg.register_early_lint_pass(box formatting::Formatting);\n \n     reg.register_lint_group(\"clippy_pedantic\", vec![\n         enum_glob_use::ENUM_GLOB_USE,\n@@ -212,6 +214,8 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         escape::BOXED_LOCAL,\n         eta_reduction::REDUNDANT_CLOSURE,\n         format::USELESS_FORMAT,\n+        formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING,\n+        formatting::SUSPICIOUS_ELSE_FORMATTING,\n         identity_op::IDENTITY_OP,\n         items_after_statements::ITEMS_AFTER_STATEMENTS,\n         len_zero::LEN_WITHOUT_IS_EMPTY,"}, {"sha": "14a23111ec7e54def16121c710316c0a89103842", "filename": "tests/compile-fail/formatting.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/98eb623043d4a2b0fc265d331f6b4d23bc1d74a6/tests%2Fcompile-fail%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98eb623043d4a2b0fc265d331f6b4d23bc1d74a6/tests%2Fcompile-fail%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fformatting.rs?ref=98eb623043d4a2b0fc265d331f6b4d23bc1d74a6", "patch": "@@ -0,0 +1,76 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#![deny(clippy)]\n+#![allow(unused_variables)]\n+#![allow(unused_assignments)]\n+#![allow(if_same_then_else)]\n+\n+fn foo() -> bool { true }\n+\n+fn main() {\n+    // weird `else if` formatting:\n+    if foo() {\n+    } if foo() { //~ERROR this looks like an `else if` but the `else` is missing\n+    }\n+\n+    let _ = {\n+        if foo() {\n+        } if foo() { //~ERROR this looks like an `else if` but the `else` is missing\n+        }\n+        else {\n+        }\n+    };\n+\n+    if foo() {\n+    } else //~ERROR this is an `else if` but the formatting might hide it\n+    if foo() { // the span of the above error should continue here\n+    }\n+\n+    if foo() {\n+    } //~ERROR this is an `else if` but the formatting might hide it\n+    else\n+    if foo() { // the span of the above error should continue here\n+    }\n+\n+    // those are ok:\n+    if foo() {\n+    }\n+    if foo() {\n+    }\n+\n+    if foo() {\n+    } else if foo() {\n+    }\n+\n+    if foo() {\n+    }\n+    else if foo() {\n+    }\n+\n+    if foo() {\n+    }\n+\n+    else if\n+\n+    foo() {}\n+\n+    // weird op_eq formatting:\n+    let mut a = 42;\n+    a =- 35;\n+    //~^ ERROR this looks like you are trying to use `.. -= ..`, but you really are doing `.. = (- ..)`\n+    //~| NOTE to remove this lint, use either `-=` or `= -`\n+    a =* &191;\n+    //~^ ERROR this looks like you are trying to use `.. *= ..`, but you really are doing `.. = (* ..)`\n+    //~| NOTE to remove this lint, use either `*=` or `= *`\n+\n+    let mut b = true;\n+    b =! false;\n+    //~^ ERROR this looks like you are trying to use `.. != ..`, but you really are doing `.. = (! ..)`\n+    //~| NOTE to remove this lint, use either `!=` or `= !`\n+\n+    // those are ok:\n+    a = -35;\n+    a = *&191;\n+    b = !false;\n+}"}]}