{"sha": "1dc5e1aa94d1c82d12385dfcb95c75cbaaa318a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkYzVlMWFhOTRkMWM4MmQxMjM4NWRmY2I5NWM3NWNiYWFhMzE4YTk=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-09T10:17:11Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-09T10:58:07Z"}, "message": "Monomorphize methods and bounded parameters\n\nIssue #1736", "tree": {"sha": "02ef5d7e0c1c936eea24923d398a7acfb763c1e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02ef5d7e0c1c936eea24923d398a7acfb763c1e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1dc5e1aa94d1c82d12385dfcb95c75cbaaa318a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1dc5e1aa94d1c82d12385dfcb95c75cbaaa318a9", "html_url": "https://github.com/rust-lang/rust/commit/1dc5e1aa94d1c82d12385dfcb95c75cbaaa318a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1dc5e1aa94d1c82d12385dfcb95c75cbaaa318a9/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "149d1d4a6e3bb8a439eff78cc6edb25f16aa47c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/149d1d4a6e3bb8a439eff78cc6edb25f16aa47c5", "html_url": "https://github.com/rust-lang/rust/commit/149d1d4a6e3bb8a439eff78cc6edb25f16aa47c5"}], "stats": {"total": 182, "additions": 143, "deletions": 39}, "files": [{"sha": "5973be0cbd7b8cf007d8de6cfd3db7eea5fdce6c", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dc5e1aa94d1c82d12385dfcb95c75cbaaa318a9/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc5e1aa94d1c82d12385dfcb95c75cbaaa318a9/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=1dc5e1aa94d1c82d12385dfcb95c75cbaaa318a9", "patch": "@@ -10,7 +10,7 @@ type path = [path_elt];\n enum ast_node {\n     node_item(@item, @path),\n     node_native_item(@native_item, @path),\n-    node_method(@method, @path),\n+    node_method(@method, node_id, @path),\n     node_variant(variant, def_id, @path),\n     node_expr(@expr),\n     // Locals are numbered, because the alias analysis needs to know in which\n@@ -69,7 +69,7 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n     cx.map.insert(i.id, node_item(i, @cx.path));\n     alt i.node {\n       item_impl(_, _, _, ms) {\n-        for m in ms { cx.map.insert(m.id, node_method(m, @cx.path)); }\n+        for m in ms { cx.map.insert(m.id, node_method(m, i.id, @cx.path)); }\n       }\n       item_res(_, _, _, dtor_id, ctor_id) {\n         cx.map.insert(ctor_id, node_res_ctor(i));"}, {"sha": "bb38a10120728783b7cfd5e427d85422b391e0d2", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dc5e1aa94d1c82d12385dfcb95c75cbaaa318a9/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc5e1aa94d1c82d12385dfcb95c75cbaaa318a9/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=1dc5e1aa94d1c82d12385dfcb95c75cbaaa318a9", "patch": "@@ -802,7 +802,7 @@ fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n                 bound to non-function\"); }\n         }\n       }\n-      ast_map::node_method(method, _) {\n+      ast_map::node_method(method, _, _) {\n           (method.ident, method.decl.output, method.id)\n       }\n       ast_map::node_res_ctor(item) {"}, {"sha": "f8accd50714fac653428823516542a4a63bf6982", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 48, "deletions": 29, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/1dc5e1aa94d1c82d12385dfcb95c75cbaaa318a9/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc5e1aa94d1c82d12385dfcb95c75cbaaa318a9/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=1dc5e1aa94d1c82d12385dfcb95c75cbaaa318a9", "patch": "@@ -2450,10 +2450,12 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n       some(val) { ret some(val); }\n       none {}\n     }\n+\n     let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n     let mono_ty = ty::substitute_type_params(ccx.tcx, substs, tpt.ty);\n     let llfty = type_of_fn_from_ty(ccx, mono_ty, []);\n     let lldecl;\n+    let psubsts = some({tys: substs, dicts: dicts, bounds: tpt.bounds});\n     alt ccx.tcx.items.get(fn_id.node) {\n       ast_map::node_item(item, pt) {\n         let pt = *pt + [path_name(item.ident)];\n@@ -2462,10 +2464,10 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n         alt item.node {\n           ast::item_fn(decl, _, body) {\n             trans_fn(ccx, pt, decl, body, lldecl, no_self, [],\n-                     some(substs), fn_id.node);\n+                     psubsts, fn_id.node);\n           }\n           ast::item_res(decl, _, _, _, ctor_id) {\n-            trans_res_ctor(ccx, pt, decl, ctor_id, [], some(substs), lldecl);\n+            trans_res_ctor(ccx, pt, decl, ctor_id, [], psubsts, lldecl);\n           }\n           _ { fail \"Unexpected item type\"; }\n         }\n@@ -2478,7 +2480,16 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n         let this_tv = option::get(vec::find(*tvs, {|tv|\n             tv.id.node == fn_id.node}));\n         trans_enum_variant(ccx, enum_id.node, v, this_tv.disr_val,\n-                           vec::len(*tvs) == 1u, [], some(substs), lldecl);\n+                           vec::len(*tvs) == 1u, [], psubsts, lldecl);\n+      }\n+      ast_map::node_method(mth, impl_id, pt) {\n+        let pt = *pt + [path_name(mth.ident)];\n+        let s = mangle_exported_name(ccx, pt, mono_ty);\n+        lldecl = decl_cdecl_fn(ccx.llmod, s, llfty);\n+        let selfty = ty::node_id_to_type(ccx.tcx, impl_id);\n+        let selfty = ty::substitute_type_params(ccx.tcx, substs, selfty);\n+        trans_fn(ccx, pt, mth.decl, mth.body, lldecl,\n+                 impl_self(selfty), [], psubsts, fn_id.node);\n       }\n       ast_map::node_native_item(_, _) {\n         ret none;\n@@ -2490,19 +2501,35 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n     some(val)\n }\n \n-fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id)\n+fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id,\n+                  substs: option<([ty::t], typeck::dict_res)>)\n     -> lval_maybe_callee {\n     let ccx = bcx_ccx(bcx);\n     let tys = ty::node_id_to_type_params(ccx.tcx, id);\n     let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n-    if ccx.sess.opts.monomorphize && vec::len(tys) > 0u &&\n+    if ccx.sess.opts.monomorphize &&\n+       (option::is_some(substs) || vec::len(tys) > 0u) &&\n        fn_id.crate == ast::local_crate &&\n-       !vec::any(tys, {|t| ty::type_has_params(t)}) &&\n-       vec::all(*tpt.bounds, {|bs| vec::all(*bs, {|b|\n-           alt b { ty::bound_iface(_) { false } _ { true } }\n-       })}) {\n-        let dicts = ccx.dict_map.find(id);\n-        alt monomorphic_fn(ccx, fn_id, tys, dicts) {\n+       !vec::any(tys, {|t| ty::type_has_params(t)}) {\n+        let mono = alt substs {\n+          some((stys, dicts)) {\n+            if (vec::len(stys) + vec::len(stys)) > 0u {\n+                monomorphic_fn(ccx, fn_id, stys + tys, some(dicts))\n+            } else { none }\n+          }\n+          none {\n+            alt ccx.dict_map.find(id) {\n+              some(dicts) {\n+                alt impl::resolve_dicts_in_fn_ctxt(bcx.fcx, dicts) {\n+                  some(dicts) { monomorphic_fn(ccx, fn_id, tys, some(dicts)) }\n+                  none { none }\n+                }\n+              }\n+              none { monomorphic_fn(ccx, fn_id, tys, none) }\n+            }\n+          }\n+        };\n+        alt mono {\n           some({llfn, fty}) {\n             ret {bcx: bcx, val: llfn,\n                  kind: owned, env: null_env,\n@@ -2601,12 +2628,12 @@ fn trans_var(cx: @block_ctxt, def: ast::def, id: ast::node_id)\n     let ccx = bcx_ccx(cx);\n     alt def {\n       ast::def_fn(did, _) {\n-        ret lval_static_fn(cx, did, id);\n+        ret lval_static_fn(cx, did, id, none);\n       }\n       ast::def_variant(tid, vid) {\n         if vec::len(ty::enum_variant_with_id(ccx.tcx, tid, vid).args) > 0u {\n             // N-ary variant.\n-            ret lval_static_fn(cx, vid, id);\n+            ret lval_static_fn(cx, vid, id, none);\n         } else {\n             // Nullary variant.\n             let enum_ty = ty::node_id_to_type(ccx.tcx, id);\n@@ -4259,7 +4286,7 @@ fn mk_standard_basic_blocks(llfn: ValueRef) ->\n //  - trans_args\n fn new_fn_ctxt_w_id(ccx: @crate_ctxt, path: path,\n                     llfndecl: ValueRef, id: ast::node_id,\n-                    param_substs: option<[ty::t]>,\n+                    param_substs: option<param_substs>,\n                     sp: option<span>) -> @fn_ctxt {\n     let llbbs = mk_standard_basic_blocks(llfndecl);\n     ret @{llfn: llfndecl,\n@@ -4405,7 +4432,7 @@ enum self_arg { impl_self(ty::t), no_self, }\n fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n                  body: ast::blk, llfndecl: ValueRef,\n                  ty_self: self_arg, ty_params: [ast::ty_param],\n-                 param_substs: option<[ty::t]>,\n+                 param_substs: option<param_substs>,\n                  id: ast::node_id, maybe_load_env: fn(@fn_ctxt)) {\n     set_uwtable(llfndecl);\n \n@@ -4421,14 +4448,6 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n     let block_ty = node_id_type(bcx, body.node.id);\n \n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, id));\n-    alt param_substs {\n-      some(ts) {\n-        arg_tys = vec::map(arg_tys, {|a|\n-            {mode: a.mode,\n-             ty: ty::substitute_type_params(fcx.ccx.tcx, ts, a.ty)}})\n-      }\n-      _ {}\n-    }\n     bcx = copy_args_to_allocas(fcx, bcx, decl.inputs, arg_tys);\n \n     maybe_load_env(fcx);\n@@ -4454,7 +4473,7 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n // function.\n fn trans_fn(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n             body: ast::blk, llfndecl: ValueRef, ty_self: self_arg,\n-            ty_params: [ast::ty_param], param_substs: option<[ty::t]>,\n+            ty_params: [ast::ty_param], param_substs: option<param_substs>,\n             id: ast::node_id) {\n     let do_time = ccx.sess.opts.stats;\n     let start = if do_time { time::get_time() }\n@@ -4473,7 +4492,7 @@ fn trans_fn(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n \n fn trans_res_ctor(ccx: @crate_ctxt, path: path, dtor: ast::fn_decl,\n                   ctor_id: ast::node_id, ty_params: [ast::ty_param],\n-                  param_substs: option<[ty::t]>, llfndecl: ValueRef) {\n+                  param_substs: option<param_substs>, llfndecl: ValueRef) {\n     // Create a function for the constructor\n     let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, ctor_id,\n                                param_substs, none);\n@@ -4505,11 +4524,11 @@ fn trans_res_ctor(ccx: @crate_ctxt, path: path, dtor: ast::fn_decl,\n }\n \n \n-fn trans_enum_variant(ccx: @crate_ctxt,\n-                      enum_id: ast::node_id,\n+fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n                       variant: ast::variant, disr: int, is_degen: bool,\n                       ty_params: [ast::ty_param],\n-                      param_substs: option<[ty::t]>, llfndecl: ValueRef) {\n+                      param_substs: option<param_substs>,\n+                      llfndecl: ValueRef) {\n     // Translate variant arguments to function arguments.\n     let fn_args = [], i = 0u;\n     for varg in variant.node.args {\n@@ -4522,7 +4541,7 @@ fn trans_enum_variant(ccx: @crate_ctxt,\n                                param_substs, none);\n     create_llargs_for_fn_args(fcx, no_self, fn_args, ty_params);\n     let ty_param_substs = alt param_substs {\n-      some(ts) { ts }\n+      some(substs) { substs.tys }\n       none {\n         let i = 0u;\n         vec::map(ty_params, {|tp|"}, {"sha": "e714dca039cfbae979f261df8a1af48686d34694", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1dc5e1aa94d1c82d12385dfcb95c75cbaaa318a9/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc5e1aa94d1c82d12385dfcb95c75cbaaa318a9/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=1dc5e1aa94d1c82d12385dfcb95c75cbaaa318a9", "patch": "@@ -132,6 +132,10 @@ enum local_val { local_mem(ValueRef), local_imm(ValueRef), }\n \n type fn_ty_param = {desc: ValueRef, dicts: option<[ValueRef]>};\n \n+type param_substs = {tys: [ty::t],\n+                     dicts: option<typeck::dict_res>,\n+                     bounds: @[ty::param_bounds]};\n+\n // Function context.  Every LLVM function we create will have one of\n // these.\n type fn_ctxt = {\n@@ -200,7 +204,7 @@ type fn_ctxt = {\n \n     // If this function is being monomorphized, this contains the type\n     // substitutions used.\n-    param_substs: option<[ty::t]>,\n+    param_substs: option<param_substs>,\n \n     // The source span and nesting context where this function comes from, for\n     // error reporting and symbol generation.\n@@ -901,7 +905,7 @@ fn node_id_type(bcx: @block_ctxt, id: ast::node_id) -> ty::t {\n     let tcx = bcx_tcx(bcx);\n     let t = ty::node_id_to_type(tcx, id);\n     alt bcx.fcx.param_substs {\n-      some(s) { ty::substitute_type_params(tcx, s, t) }\n+      some(substs) { ty::substitute_type_params(tcx, substs.tys, t) }\n       _ { t }\n     }\n }"}, {"sha": "2de21f8fb2e796bcf8d6bfeaed6c4438b93ccb4a", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 85, "deletions": 4, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/1dc5e1aa94d1c82d12385dfcb95c75cbaaa318a9/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc5e1aa94d1c82d12385dfcb95c75cbaaa318a9/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=1dc5e1aa94d1c82d12385dfcb95c75cbaaa318a9", "patch": "@@ -76,10 +76,18 @@ fn trans_method_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n     -> lval_maybe_callee {\n     alt origin {\n       typeck::method_static(did) {\n-        trans_static_callee(bcx, callee_id, self, did)\n+        trans_static_callee(bcx, callee_id, self, did, none)\n       }\n       typeck::method_param(iid, off, p, b) {\n-        trans_param_callee(bcx, callee_id, self, iid, off, p, b)\n+        alt bcx.fcx.param_substs {\n+          some(substs) {\n+            trans_monomorphized_callee(bcx, callee_id, self,\n+                                       iid, off, p, b, substs)\n+          }\n+          none {\n+            trans_param_callee(bcx, callee_id, self, iid, off, p, b)\n+          }\n+        }\n       }\n       typeck::method_iface(off) {\n         trans_iface_callee(bcx, callee_id, self, off)\n@@ -89,10 +97,11 @@ fn trans_method_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n \n // Method callee where the method is statically known\n fn trans_static_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n-                       base: @ast::expr, did: ast::def_id)\n+                       base: @ast::expr, did: ast::def_id,\n+                       substs: option<([ty::t], typeck::dict_res)>)\n     -> lval_maybe_callee {\n     let {bcx, val} = trans_self_arg(bcx, base);\n-    {env: self_env(val) with lval_static_fn(bcx, did, callee_id)}\n+    {env: self_env(val) with lval_static_fn(bcx, did, callee_id, substs)}\n }\n \n fn wrapper_fn_ty(ccx: @crate_ctxt, dict_ty: TypeRef, fty: ty::t,\n@@ -135,6 +144,38 @@ fn trans_vtable_callee(bcx: @block_ctxt, self: ValueRef, dict: ValueRef,\n      generic: generic}\n }\n \n+fn trans_monomorphized_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n+                              base: @ast::expr, iface_id: ast::def_id,\n+                              n_method: uint, n_param: uint, n_bound: uint,\n+                              substs: param_substs) -> lval_maybe_callee {\n+    alt find_dict_in_fn_ctxt(substs, n_param, n_bound) {\n+      typeck::dict_static(impl_did, tys, sub_origins) {\n+        let tcx = bcx_tcx(bcx);\n+        if impl_did.crate != ast::local_crate {\n+            ret trans_param_callee(bcx, callee_id, base, iface_id,\n+                                   n_method, n_param, n_bound);\n+        }\n+        let mname = ty::iface_methods(tcx, iface_id)[n_method].ident;\n+        let mth = alt tcx.items.get(impl_did.node) {\n+          ast_map::node_item(@{node: ast::item_impl(_, _, _, ms), _}, _) {\n+            option::get(vec::find(ms, {|m| m.ident == mname}))\n+          }\n+          _ { fail; }\n+        };\n+        ret trans_static_callee(bcx, callee_id, base,\n+                                ast_util::local_def(mth.id),\n+                                some((tys, sub_origins)));\n+      }\n+      typeck::dict_iface(_) {\n+        ret trans_iface_callee(bcx, callee_id, base, n_method);\n+      }\n+      typeck::dict_param(n_param, n_bound) {\n+        fail \"dict_param left in monomorphized function's dict substs\";\n+      }\n+    }\n+}\n+\n+\n // Method callee where the dict comes from a type param\n fn trans_param_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n                       base: @ast::expr, iface_id: ast::def_id, n_method: uint,\n@@ -184,6 +225,46 @@ fn trans_vtable(ccx: @crate_ctxt, id: ast::node_id, name: str,\n     ccx.item_symbols.insert(id, name);\n }\n \n+fn find_dict_in_fn_ctxt(ps: param_substs, n_param: uint, n_bound: uint)\n+    -> typeck::dict_origin {\n+    let dict_off = n_bound, i = 0u;\n+    // Dicts are stored in a flat array, finding the right one is\n+    // somewhat awkward\n+    for bounds in *ps.bounds {\n+        i += 1u;\n+        if i >= n_param { break; }\n+        for bound in *bounds {\n+            alt bound { ty::bound_iface(_) { dict_off += 1u; } _ {} }\n+        }\n+    }\n+    option::get(ps.dicts)[dict_off]\n+}\n+\n+fn resolve_dicts_in_fn_ctxt(fcx: @fn_ctxt, dicts: typeck::dict_res)\n+    -> option<typeck::dict_res> {\n+    let result = [];\n+    for dict in *dicts {\n+        result += [alt dict {\n+          typeck::dict_static(iid, tys, sub) {\n+            alt resolve_dicts_in_fn_ctxt(fcx, sub) {\n+              some(sub) { typeck::dict_static(iid, tys, sub) }\n+              none { ret none; }\n+            }\n+          }\n+          typeck::dict_param(n_param, n_bound) {\n+            alt fcx.param_substs {\n+              some(substs) {\n+                find_dict_in_fn_ctxt(substs, n_param, n_bound)\n+              }\n+              none { ret none; }\n+            }\n+          }\n+          _ { dict }\n+        }];\n+    }\n+    some(@result)\n+}\n+\n fn trans_wrapper(ccx: @crate_ctxt, pt: path, llfty: TypeRef,\n                  fill: fn(ValueRef, @block_ctxt) -> @block_ctxt)\n     -> ValueRef {"}, {"sha": "a26ef788abd8c0f3c89b496b440bbc43d0cb5c6b", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dc5e1aa94d1c82d12385dfcb95c75cbaaa318a9/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc5e1aa94d1c82d12385dfcb95c75cbaaa318a9/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=1dc5e1aa94d1c82d12385dfcb95c75cbaaa318a9", "patch": "@@ -1663,7 +1663,7 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n     fn ty_from_did(tcx: ty::ctxt, did: ast::def_id) -> ty::t {\n         if did.crate == ast::local_crate {\n             alt tcx.items.get(did.node) {\n-              ast_map::node_method(m, _) {\n+              ast_map::node_method(m, _, _) {\n                 let mt = ty_of_method(tcx, m_check, m);\n                 ty::mk_fn(tcx, mt.fty)\n               }"}]}