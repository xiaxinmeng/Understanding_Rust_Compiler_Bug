{"sha": "c8f4efc006c24bfb427e9dd70853fb3e41584aa9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4ZjRlZmMwMDZjMjRiZmI0MjdlOWRkNzA4NTNmYjNlNDE1ODRhYTk=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-19T20:12:48Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-19T20:12:48Z"}, "message": "mention interaction with Deref in intro", "tree": {"sha": "da654fc2d9cd69cc87b67fe134246f1d5a48b4dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da654fc2d9cd69cc87b67fe134246f1d5a48b4dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8f4efc006c24bfb427e9dd70853fb3e41584aa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8f4efc006c24bfb427e9dd70853fb3e41584aa9", "html_url": "https://github.com/rust-lang/rust/commit/c8f4efc006c24bfb427e9dd70853fb3e41584aa9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8f4efc006c24bfb427e9dd70853fb3e41584aa9/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c774bc650a6b19e6ca6b970dda294ba8937a6548", "url": "https://api.github.com/repos/rust-lang/rust/commits/c774bc650a6b19e6ca6b970dda294ba8937a6548", "html_url": "https://github.com/rust-lang/rust/commit/c774bc650a6b19e6ca6b970dda294ba8937a6548"}], "stats": {"total": 47, "additions": 38, "deletions": 9}, "files": [{"sha": "8acc215d01738fac8f68b51db4f3654696556561", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 38, "deletions": 9, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c8f4efc006c24bfb427e9dd70853fb3e41584aa9/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f4efc006c24bfb427e9dd70853fb3e41584aa9/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=c8f4efc006c24bfb427e9dd70853fb3e41584aa9", "patch": "@@ -19,6 +19,7 @@\n //! obtain a `Box` or reference to pinned data, which implies that you cannot use\n //! operations such as [`mem::swap`]:\n //! ```\n+//! use std::pin::Pin;\n //! fn swap_pins<T>(x: Pin<&mut T>, y: Pin<&mut T>) {\n //!     // `mem::swap` needs `&mut T`, but we cannot get it.\n //!     // We are stuck, we cannot swap the contents of these references.\n@@ -32,6 +33,15 @@\n //! prevents certain *values* (pointed to by pointers wrapped in `Pin`) from being\n //! moved by making it impossible to call methods like [`mem::swap`] on them.\n //!\n+//! [`Pin`] can be used to wrap any pointer type, and as such it interacts with\n+//! [`Deref`] and [`DerefMut`]. A `Pin<P>` where `P: Deref` should be considered\n+//! as a \"`P`-style pointer\" to a pinned `P::Target` -- so, a `Pin<Box<T>>` is\n+//! an owned pointer to a pinned `T`, and a `Pin<Rc<T>>` is a reference-counted\n+//! pointer to a pinned `T`.\n+//! For correctness, [`Pin`] relies on the [`Deref`] and [`DerefMut`] implementations\n+//! to not move out of their `self` parameter, and to only ever return a pointer\n+//! to pinned data when they are called on a pinned pointer.\n+//!\n //! # `Unpin`\n //!\n //! However, these restrictions are usually not necessary. Many types are always freely\n@@ -114,7 +124,7 @@\n //! list element will patch the pointers of its predecessor and successor to remove itself\n //! from the list.\n //!\n-//! To make this work, it is crucial taht we can actually rely on `drop` being called.\n+//! To make this work, it is crucial that we can actually rely on `drop` being called.\n //! And, in fact, this is a guarantee that `Pin` provides.\n //!\n //! # `Drop` guarantee\n@@ -219,6 +229,8 @@\n //!\n //! [`Pin`]: struct.Pin.html\n //! [`Unpin`]: ../../std/marker/trait.Unpin.html\n+//! [`Deref`]: ../../std/ops/trait.Deref.html\n+//! [`DerefMut`]: ../../std/ops/trait.DerefMut.html\n //! [`mem::swap`]: ../../std/mem/fn.swap.html\n //! [`mem::forget`]: ../../std/mem/fn.forget.html\n //! [`Box`]: ../../std/boxed/struct.Box.html\n@@ -319,16 +331,16 @@ impl<P: Deref> Pin<P> {\n     /// Construct a new `Pin` around a reference to some data of a type that\n     /// may or may not implement `Unpin`.\n     ///\n+    /// If `pointer` dereferences to an `Unpin` type, `Pin::new` should be used\n+    /// instead.\n+    ///\n     /// # Safety\n     ///\n     /// This constructor is unsafe because we cannot guarantee that the data\n     /// pointed to by `pointer` is pinned, meaning that the data will not be moved or\n     /// its storage invalidated until it gets dropped. If the constructed `Pin<P>` does\n     /// not guarantee that the data `P` points to is pinned, constructing a\n-    /// `Pin<P>` is unsafe. In particular, calling `Pin::new_unchecked`\n-    /// on an `&'a mut T` is unsafe because while you are able to pin it for the given\n-    /// lifetime `'a`, you have no control over whether it is kept pinned once `'a`\n-    /// ends. A value, once pinned, must remain pinned forever (unless its type implements `Unpin`).\n+    /// `Pin<P>` is unsafe. In particular,\n     ///\n     /// By using this method, you are making a promise about the `P::Deref` and\n     /// `P::DerefMut` implementations, if they exist. Most importantly, they\n@@ -340,21 +352,38 @@ impl<P: Deref> Pin<P> {\n     /// must not be possible to obtain a `&mut P::Target` and then\n     /// move out of that reference (using, for example [`mem::swap`]).\n     ///\n-    /// For example, the following is a *violation* of `Pin`'s safety:\n+    /// For example, calling `Pin::new_unchecked`\n+    /// on an `&'a mut T` is unsafe because while you are able to pin it for the given\n+    /// lifetime `'a`, you have no control over whether it is kept pinned once `'a` ends:\n     /// ```\n     /// use std::mem;\n     /// use std::pin::Pin;\n     ///\n-    /// fn foo<T>(mut a: T, mut b: T) {\n+    /// fn move_pinned_ref<T>(mut a: T, mut b: T) {\n     ///     unsafe { let p = Pin::new_unchecked(&mut a); } // should mean `a` can never move again\n     ///     mem::swap(&mut a, &mut b);\n     ///     // the address of `a` changed to `b`'s stack slot, so `a` got moved even\n     ///     // though we have previously pinned it!\n     /// }\n     /// ```\n+    /// A value, once pinned, must remain pinned forever (unless its type implements `Unpin`).\n     ///\n-    /// If `pointer` dereferences to an `Unpin` type, `Pin::new` should be used\n-    /// instead.\n+    /// Similarily, calling `Pin::new_unchecked` on a `Rc<T>` is unsafe because there could be\n+    /// aliases to the same data that are not subject to the pinning restrictions:\n+    /// ```\n+    /// use std::rc::Rc;\n+    /// use std::pin::Pin;\n+    ///\n+    /// fn move_pinned_rc<T>(mut x: Rc<T>) {\n+    ///     let pinned = unsafe { Pin::new_unchecked(x.clone()) };\n+    ///     { let p: Pin<&T> = pinned.as_ref(); } // should mean the pointee can never move again\n+    ///     drop(pinned);\n+    ///     let content = Rc::get_mut(&mut x).unwrap();\n+    ///     // Now, if `x` was the only reference, we have a mutable reference to\n+    ///     // data that we pinned above, which we could use to move it as we have\n+    ///     // seen in the previous example.\n+    ///  }\n+    ///  ```\n     ///\n     /// [`mem::swap`]: ../../std/mem/fn.swap.html\n     #[stable(feature = \"pin\", since = \"1.33.0\")]"}]}