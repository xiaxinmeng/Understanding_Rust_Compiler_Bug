{"sha": "ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmMmY1ZjZkOGVmNTEwMTBkMDYwZDZmOGNmZjZjYWMyZWY4M2ZkNDI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-11T14:33:42Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-11T01:14:58Z"}, "message": "typeck: Avoid passing &TyCtxt around where possible.", "tree": {"sha": "bcad64a4db0b489019924c731bbdc5f3f8fe9d75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bcad64a4db0b489019924c731bbdc5f3f8fe9d75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42", "html_url": "https://github.com/rust-lang/rust/commit/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e387e6c7c82bed6a32631a04bc66f3957384faa8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e387e6c7c82bed6a32631a04bc66f3957384faa8", "html_url": "https://github.com/rust-lang/rust/commit/e387e6c7c82bed6a32631a04bc66f3957384faa8"}], "stats": {"total": 647, "additions": 288, "deletions": 359}, "files": [{"sha": "a18fdebbaa9175efcd0e41fa8cef0f63d70765a2", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42", "patch": "@@ -33,7 +33,7 @@ use hir;\n \n pub trait IntTypeExt {\n     fn to_ty<'tcx>(&self, tcx: &TyCtxt<'tcx>) -> Ty<'tcx>;\n-    fn disr_incr(&self, val: Disr) -> Option<Disr>;\n+    fn disr_incr(&self, tcx: &TyCtxt, val: Option<Disr>) -> Option<Disr>;\n     fn assert_ty_matches(&self, val: Disr);\n     fn initial_discriminant(&self, tcx: &TyCtxt) -> Disr;\n }\n@@ -93,9 +93,13 @@ impl IntTypeExt for attr::IntType {\n         }\n     }\n \n-    fn disr_incr(&self, val: Disr) -> Option<Disr> {\n-        self.assert_ty_matches(val);\n-        (val + ConstInt::Infer(1)).ok()\n+    fn disr_incr(&self, tcx: &TyCtxt, val: Option<Disr>) -> Option<Disr> {\n+        if let Some(val) = val {\n+            self.assert_ty_matches(val);\n+            (val + ConstInt::Infer(1)).ok()\n+        } else {\n+            Some(self.initial_discriminant(tcx))\n+        }\n     }\n }\n "}, {"sha": "b756df05faa5cd081f8453cf9e9848155381a13c", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42", "patch": "@@ -338,7 +338,7 @@ pub fn ast_path_substs_for_ty<'tcx>(\n         }\n     };\n \n-    prohibit_projections(this.tcx(), &assoc_bindings);\n+    assoc_bindings.first().map(|b| prohibit_projection(this.tcx(), b.span));\n \n     create_substs_for_ast_path(this,\n                                span,\n@@ -580,10 +580,11 @@ fn convert_angle_bracketed_parameters<'tcx>(this: &AstConv<'tcx>,\n /// Returns the appropriate lifetime to use for any output lifetimes\n /// (if one exists) and a vector of the (pattern, number of lifetimes)\n /// corresponding to each input type/pattern.\n-fn find_implied_output_region<'tcx>(tcx: &TyCtxt<'tcx>,\n+fn find_implied_output_region<'tcx>(this: &AstConv<'tcx>,\n                                     input_tys: &[Ty<'tcx>],\n                                     input_pats: Vec<String>) -> ElidedLifetime\n {\n+    let tcx = this.tcx();\n     let mut lifetimes_for_params = Vec::new();\n     let mut possible_implied_output_region = None;\n \n@@ -655,7 +656,7 @@ fn convert_parenthesized_parameters<'tcx>(this: &AstConv<'tcx>,\n                    .collect::<Vec<Ty<'tcx>>>();\n \n     let input_params = vec![String::new(); inputs.len()];\n-    let implied_output_region = find_implied_output_region(this.tcx(), &inputs, input_params);\n+    let implied_output_region = find_implied_output_region(this, &inputs, input_params);\n \n     let input_ty = this.tcx().mk_tup(inputs);\n \n@@ -824,7 +825,7 @@ fn ast_path_to_mono_trait_ref<'a,'tcx>(this: &AstConv<'tcx>,\n                                         trait_def_id,\n                                         self_ty,\n                                         trait_segment);\n-    prohibit_projections(this.tcx(), &assoc_bindings);\n+    assoc_bindings.first().map(|b| prohibit_projection(this.tcx(), b.span));\n     ty::TraitRef::new(trait_def_id, substs)\n }\n \n@@ -960,7 +961,7 @@ fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n         }\n     }\n \n-    let candidate = one_bound_for_assoc_type(tcx,\n+    let candidate = one_bound_for_assoc_type(this,\n                                              candidates,\n                                              &trait_ref.to_string(),\n                                              &binding.item_name.as_str(),\n@@ -1219,7 +1220,7 @@ fn find_bound_for_assoc_item<'tcx>(this: &AstConv<'tcx>,\n         .filter(|b| this.trait_defines_associated_type_named(b.def_id(), assoc_name))\n         .collect();\n \n-    one_bound_for_assoc_type(tcx,\n+    one_bound_for_assoc_type(this,\n                              suitable_bounds,\n                              &ty_param_name.as_str(),\n                              &assoc_name.as_str(),\n@@ -1229,23 +1230,23 @@ fn find_bound_for_assoc_item<'tcx>(this: &AstConv<'tcx>,\n \n // Checks that bounds contains exactly one element and reports appropriate\n // errors otherwise.\n-fn one_bound_for_assoc_type<'tcx>(tcx: &TyCtxt<'tcx>,\n+fn one_bound_for_assoc_type<'tcx>(this: &AstConv<'tcx>,\n                                   bounds: Vec<ty::PolyTraitRef<'tcx>>,\n                                   ty_param_name: &str,\n                                   assoc_name: &str,\n                                   span: Span)\n     -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n {\n     if bounds.is_empty() {\n-        span_err!(tcx.sess, span, E0220,\n+        span_err!(this.tcx().sess, span, E0220,\n                   \"associated type `{}` not found for `{}`\",\n                   assoc_name,\n                   ty_param_name);\n         return Err(ErrorReported);\n     }\n \n     if bounds.len() > 1 {\n-        let mut err = struct_span_err!(tcx.sess, span, E0221,\n+        let mut err = struct_span_err!(this.tcx().sess, span, E0221,\n                                        \"ambiguous associated type `{}` in bounds of `{}`\",\n                                        assoc_name,\n                                        ty_param_name);\n@@ -1305,7 +1306,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                                                      assoc_name))\n                 .collect();\n \n-            match one_bound_for_assoc_type(tcx,\n+            match one_bound_for_assoc_type(this,\n                                            candidates,\n                                            \"Self\",\n                                            &assoc_name.as_str(),\n@@ -1814,7 +1815,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n     // have that lifetime.\n     let implied_output_region = match explicit_self_category {\n         Some(ty::ExplicitSelfCategory::ByReference(region, _)) => Ok(region),\n-        _ => find_implied_output_region(this.tcx(), &arg_tys, arg_pats)\n+        _ => find_implied_output_region(this, &arg_tys, arg_pats)\n     };\n \n     let output_ty = match decl.output {\n@@ -2208,14 +2209,6 @@ pub fn partition_bounds<'a>(tcx: &TyCtxt,\n     }\n }\n \n-fn prohibit_projections<'tcx>(tcx: &TyCtxt<'tcx>,\n-                              bindings: &[ConvertedBinding<'tcx>])\n-{\n-    for binding in bindings.iter().take(1) {\n-        prohibit_projection(tcx, binding.span);\n-    }\n-}\n-\n fn check_type_argument_count(tcx: &TyCtxt, span: Span, supplied: usize,\n                              required: usize, accepted: usize) {\n     if supplied < required {"}, {"sha": "b07437d299b2114beabc76decc1e7d4ec632f358", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42", "patch": "@@ -116,7 +116,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n             // Check that the types of the end-points can be unified.\n             let types_unify = require_same_types(\n-                tcx, Some(fcx.infcx()), false, pat.span, rhs_ty, lhs_ty,\n+                fcx.ccx, Some(fcx.infcx()), pat.span, rhs_ty, lhs_ty,\n                 \"mismatched types in range\",\n             );\n "}, {"sha": "5d37d5123e4456e569677095f9c0d78e4ab47aa1", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42", "patch": "@@ -251,7 +251,7 @@ fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n             // In that case, we check each argument against \"error\" in order to\n             // set up all the node type bindings.\n             error_fn_sig = ty::Binder(ty::FnSig {\n-                inputs: err_args(fcx.tcx(), arg_exprs.len()),\n+                inputs: err_args(fcx, arg_exprs.len()),\n                 output: ty::FnConverging(fcx.tcx().types.err),\n                 variadic: false\n             });"}, {"sha": "28d8206a145ec6e24903c9a7e08666f3d1ff7cc0", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42", "patch": "@@ -10,13 +10,14 @@\n \n use middle::free_region::FreeRegionMap;\n use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin};\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty;\n use rustc::traits::{self, ProjectionMode};\n use rustc::ty::subst::{self, Subst, Substs, VecPerParamSpace};\n \n use syntax::ast;\n use syntax::codemap::Span;\n \n+use CrateCtxt;\n use super::assoc;\n \n /// Checks that a method from an impl conforms to the signature of\n@@ -30,18 +31,19 @@ use super::assoc;\n /// - trait_m: the method in the trait\n /// - impl_trait_ref: the TraitRef corresponding to the trait implementation\n \n-pub fn compare_impl_method<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                 impl_m: &ty::Method<'tcx>,\n-                                 impl_m_span: Span,\n-                                 impl_m_body_id: ast::NodeId,\n-                                 trait_m: &ty::Method<'tcx>,\n-                                 impl_trait_ref: &ty::TraitRef<'tcx>) {\n+pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                     impl_m: &ty::Method<'tcx>,\n+                                     impl_m_span: Span,\n+                                     impl_m_body_id: ast::NodeId,\n+                                     trait_m: &ty::Method<'tcx>,\n+                                     impl_trait_ref: &ty::TraitRef<'tcx>) {\n     debug!(\"compare_impl_method(impl_trait_ref={:?})\",\n            impl_trait_ref);\n \n     debug!(\"compare_impl_method: impl_trait_ref (liberated) = {:?}\",\n            impl_trait_ref);\n \n+    let tcx = ccx.tcx;\n     let mut infcx = InferCtxt::new(tcx, &tcx.tables, None, ProjectionMode::AnyFinal);\n     let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n@@ -186,7 +188,7 @@ pub fn compare_impl_method<'tcx>(tcx: &TyCtxt<'tcx>,\n \n     // Check region bounds. FIXME(@jroesch) refactor this away when removing\n     // ParamBounds.\n-    if !check_region_bounds_on_impl_method(tcx,\n+    if !check_region_bounds_on_impl_method(ccx,\n                                            impl_m_span,\n                                            impl_m,\n                                            &trait_m.generics,\n@@ -364,14 +366,14 @@ pub fn compare_impl_method<'tcx>(tcx: &TyCtxt<'tcx>,\n \n     infcx.resolve_regions_and_report_errors(&free_regions, impl_m_body_id);\n \n-    fn check_region_bounds_on_impl_method<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                                span: Span,\n-                                                impl_m: &ty::Method<'tcx>,\n-                                                trait_generics: &ty::Generics<'tcx>,\n-                                                impl_generics: &ty::Generics<'tcx>,\n-                                                trait_to_skol_substs: &Substs<'tcx>,\n-                                                impl_to_skol_substs: &Substs<'tcx>)\n-                                                -> bool\n+    fn check_region_bounds_on_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                                    span: Span,\n+                                                    impl_m: &ty::Method<'tcx>,\n+                                                    trait_generics: &ty::Generics<'tcx>,\n+                                                    impl_generics: &ty::Generics<'tcx>,\n+                                                    trait_to_skol_substs: &Substs<'tcx>,\n+                                                    impl_to_skol_substs: &Substs<'tcx>)\n+                                                    -> bool\n     {\n \n         let trait_params = trait_generics.regions.get_slice(subst::FnSpace);\n@@ -397,7 +399,7 @@ pub fn compare_impl_method<'tcx>(tcx: &TyCtxt<'tcx>,\n         // are zero. Since I don't quite know how to phrase things at\n         // the moment, give a kind of vague error message.\n         if trait_params.len() != impl_params.len() {\n-            span_err!(tcx.sess, span, E0195,\n+            span_err!(ccx.tcx.sess, span, E0195,\n                 \"lifetime parameters or bounds on method `{}` do \\\n                          not match the trait declaration\",\n                          impl_m.name);\n@@ -408,14 +410,15 @@ pub fn compare_impl_method<'tcx>(tcx: &TyCtxt<'tcx>,\n     }\n }\n \n-pub fn compare_const_impl<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                impl_c: &ty::AssociatedConst<'tcx>,\n-                                impl_c_span: Span,\n-                                trait_c: &ty::AssociatedConst<'tcx>,\n-                                impl_trait_ref: &ty::TraitRef<'tcx>) {\n+pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                    impl_c: &ty::AssociatedConst<'tcx>,\n+                                    impl_c_span: Span,\n+                                    trait_c: &ty::AssociatedConst<'tcx>,\n+                                    impl_trait_ref: &ty::TraitRef<'tcx>) {\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\",\n            impl_trait_ref);\n \n+    let tcx = ccx.tcx;\n     let infcx = InferCtxt::new(tcx, &tcx.tables, None, ProjectionMode::AnyFinal);\n     let mut fulfillment_cx = traits::FulfillmentContext::new();\n "}, {"sha": "0ddf616bb54f49211e03125e036828058a03c715", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42", "patch": "@@ -8,14 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use CrateCtxt;\n use check::regionck::{self, Rcx};\n \n use hir::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n use rustc::infer::{self, InferCtxt};\n use middle::region;\n use rustc::ty::subst::{self, Subst};\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty};\n use rustc::traits::{self, ProjectionMode};\n use util::nodemap::FnvHashSet;\n \n@@ -39,20 +40,20 @@ use syntax::codemap::{self, Span};\n ///    struct/enum definition for the nominal type itself (i.e.\n ///    cannot do `struct S<T>; impl<T:Clone> Drop for S<T> { ... }`).\n ///\n-pub fn check_drop_impl(tcx: &TyCtxt, drop_impl_did: DefId) -> Result<(), ()> {\n+pub fn check_drop_impl(ccx: &CrateCtxt, drop_impl_did: DefId) -> Result<(), ()> {\n     let ty::TypeScheme { generics: ref dtor_generics,\n-                         ty: dtor_self_type } = tcx.lookup_item_type(drop_impl_did);\n-    let dtor_predicates = tcx.lookup_predicates(drop_impl_did);\n+                         ty: dtor_self_type } = ccx.tcx.lookup_item_type(drop_impl_did);\n+    let dtor_predicates = ccx.tcx.lookup_predicates(drop_impl_did);\n     match dtor_self_type.sty {\n         ty::TyEnum(adt_def, self_to_impl_substs) |\n         ty::TyStruct(adt_def, self_to_impl_substs) => {\n-            ensure_drop_params_and_item_params_correspond(tcx,\n+            ensure_drop_params_and_item_params_correspond(ccx,\n                                                           drop_impl_did,\n                                                           dtor_generics,\n                                                           &dtor_self_type,\n                                                           adt_def.did)?;\n \n-            ensure_drop_predicates_are_implied_by_item_defn(tcx,\n+            ensure_drop_predicates_are_implied_by_item_defn(ccx,\n                                                             drop_impl_did,\n                                                             &dtor_predicates,\n                                                             adt_def.did,\n@@ -61,21 +62,22 @@ pub fn check_drop_impl(tcx: &TyCtxt, drop_impl_did: DefId) -> Result<(), ()> {\n         _ => {\n             // Destructors only work on nominal types.  This was\n             // already checked by coherence, so we can panic here.\n-            let span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n+            let span = ccx.tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n             span_bug!(span,\n                       \"should have been rejected by coherence check: {}\",\n                       dtor_self_type);\n         }\n     }\n }\n \n-fn ensure_drop_params_and_item_params_correspond<'tcx>(\n-    tcx: &TyCtxt<'tcx>,\n+fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n+    ccx: &CrateCtxt<'a, 'tcx>,\n     drop_impl_did: DefId,\n     drop_impl_generics: &ty::Generics<'tcx>,\n     drop_impl_ty: &ty::Ty<'tcx>,\n     self_type_did: DefId) -> Result<(), ()>\n {\n+    let tcx = ccx.tcx;\n     let drop_impl_node_id = tcx.map.as_local_node_id(drop_impl_did).unwrap();\n     let self_type_node_id = tcx.map.as_local_node_id(self_type_did).unwrap();\n \n@@ -124,8 +126,8 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n \n /// Confirms that every predicate imposed by dtor_predicates is\n /// implied by assuming the predicates attached to self_type_did.\n-fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n-    tcx: &TyCtxt<'tcx>,\n+fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n+    ccx: &CrateCtxt<'a, 'tcx>,\n     drop_impl_did: DefId,\n     dtor_predicates: &ty::GenericPredicates<'tcx>,\n     self_type_did: DefId,\n@@ -166,6 +168,8 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     // absent. So we report an error that the Drop impl injected a\n     // predicate that is not present on the struct definition.\n \n+    let tcx = ccx.tcx;\n+\n     let self_type_node_id = tcx.map.as_local_node_id(self_type_did).unwrap();\n \n     let drop_impl_span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n@@ -407,7 +411,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n     // unbounded type parameter `T`, we must resume the recursive\n     // analysis on `T` (since it would be ignored by\n     // type_must_outlive).\n-    if has_dtor_of_interest(tcx, ty) {\n+    if has_dtor_of_interest(cx, ty) {\n         debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n                 {}ty: {} - is a dtorck type!\",\n                (0..depth).map(|_| ' ').collect::<String>(),\n@@ -499,11 +503,11 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n     }\n }\n \n-fn has_dtor_of_interest<'tcx>(tcx: &TyCtxt<'tcx>,\n-                              ty: ty::Ty<'tcx>) -> bool {\n+fn has_dtor_of_interest<'a, 'b, 'tcx>(cx: &DropckContext<'a, 'b, 'tcx>,\n+                                      ty: ty::Ty<'tcx>) -> bool {\n     match ty.sty {\n         ty::TyEnum(def, _) | ty::TyStruct(def, _) => {\n-            def.is_dtorck(tcx)\n+            def.is_dtorck(cx.rcx.tcx())\n         }\n         ty::TyTrait(..) | ty::TyProjection(..) => {\n             debug!(\"ty: {:?} isn't known, and therefore is a dropck type\", ty);"}, {"sha": "79aa647d239d7f09a79691d369dd361f10de7249", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 18, "deletions": 30, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42", "patch": "@@ -14,7 +14,7 @@\n use intrinsics;\n use rustc::ty::subst::{self, Substs};\n use rustc::ty::FnSig;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty};\n use {CrateCtxt, require_same_types};\n \n use std::collections::{HashMap};\n@@ -25,11 +25,13 @@ use syntax::parse::token;\n \n use rustc::hir;\n \n-fn equate_intrinsic_type<'a, 'tcx>(tcx: &TyCtxt<'tcx>, it: &hir::ForeignItem,\n+fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                   it: &hir::ForeignItem,\n                                    n_tps: usize,\n                                    abi: Abi,\n                                    inputs: Vec<ty::Ty<'tcx>>,\n                                    output: ty::FnOutput<'tcx>) {\n+    let tcx = ccx.tcx;\n     let def_id = tcx.map.local_def_id(it.id);\n     let i_ty = tcx.lookup_item_type(def_id);\n \n@@ -52,9 +54,8 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: &TyCtxt<'tcx>, it: &hir::ForeignItem,\n              parameters: found {}, expected {}\",\n              i_n_tps, n_tps);\n     } else {\n-        require_same_types(tcx,\n+        require_same_types(ccx,\n                            None,\n-                           false,\n                            it.span,\n                            i_ty.ty,\n                            fty,\n@@ -304,14 +305,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n         };\n         (n_tps, inputs, ty::FnConverging(output))\n     };\n-    equate_intrinsic_type(\n-        tcx,\n-        it,\n-        n_tps,\n-        Abi::RustIntrinsic,\n-        inputs,\n-        output\n-        )\n+    equate_intrinsic_type(ccx, it, n_tps, Abi::RustIntrinsic, inputs, output)\n }\n \n /// Type-check `extern \"platform-intrinsic\" { ... }` functions.\n@@ -377,10 +371,10 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n                     }\n                     let input_pairs = intr.inputs.iter().zip(&sig.inputs);\n                     for (i, (expected_arg, arg)) in input_pairs.enumerate() {\n-                        match_intrinsic_type_to_type(tcx, &format!(\"argument {}\", i + 1), it.span,\n+                        match_intrinsic_type_to_type(ccx, &format!(\"argument {}\", i + 1), it.span,\n                                                      &mut structural_to_nomimal, expected_arg, arg);\n                     }\n-                    match_intrinsic_type_to_type(tcx, \"return value\", it.span,\n+                    match_intrinsic_type_to_type(ccx, \"return value\", it.span,\n                                                  &mut structural_to_nomimal,\n                                                  &intr.output, sig.output.unwrap());\n                     return\n@@ -394,21 +388,15 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n         }\n     };\n \n-    equate_intrinsic_type(\n-        tcx,\n-        it,\n-        n_tps,\n-        Abi::PlatformIntrinsic,\n-        inputs,\n-        ty::FnConverging(output)\n-        )\n+    equate_intrinsic_type(ccx, it, n_tps, Abi::PlatformIntrinsic,\n+                          inputs, ty::FnConverging(output))\n }\n \n // walk the expected type and the actual type in lock step, checking they're\n // the same, in a kinda-structural way, i.e. `Vector`s have to be simd structs with\n // exactly the right element type\n fn match_intrinsic_type_to_type<'tcx, 'a>(\n-        tcx: &TyCtxt<'tcx>,\n+        ccx: &CrateCtxt<'a, 'tcx>,\n         position: &str,\n         span: Span,\n         structural_to_nominal: &mut HashMap<&'a intrinsics::Type, ty::Ty<'tcx>>,\n@@ -417,7 +405,7 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n     use intrinsics::Type::*;\n \n     let simple_error = |real: &str, expected: &str| {\n-        span_err!(tcx.sess, span, E0442,\n+        span_err!(ccx.tcx.sess, span, E0442,\n                   \"intrinsic {} has wrong type: found {}, expected {}\",\n                   position, real, expected)\n     };\n@@ -455,7 +443,7 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n                         simple_error(&format!(\"`{}`\", t),\n                                      if const_ {\"const pointer\"} else {\"mut pointer\"})\n                     }\n-                    match_intrinsic_type_to_type(tcx, position, span, structural_to_nominal,\n+                    match_intrinsic_type_to_type(ccx, position, span, structural_to_nominal,\n                                                  inner_expected, ty)\n                 }\n                 _ => simple_error(&format!(\"`{}`\", t), \"raw pointer\"),\n@@ -466,19 +454,19 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n                 simple_error(&format!(\"non-simd type `{}`\", t), \"simd type\");\n                 return;\n             }\n-            let t_len = t.simd_size(tcx);\n+            let t_len = t.simd_size(ccx.tcx);\n             if len as usize != t_len {\n                 simple_error(&format!(\"vector with length {}\", t_len),\n                              &format!(\"length {}\", len));\n                 return;\n             }\n-            let t_ty = t.simd_type(tcx);\n+            let t_ty = t.simd_type(ccx.tcx);\n             {\n                 // check that a given structural type always has the same an intrinsic definition\n                 let previous = structural_to_nominal.entry(expected).or_insert(t);\n                 if *previous != t {\n                     // this gets its own error code because it is non-trivial\n-                    span_err!(tcx.sess, span, E0443,\n+                    span_err!(ccx.tcx.sess, span, E0443,\n                               \"intrinsic {} has wrong type: found `{}`, expected `{}` which \\\n                                was used for this vector type previously in this signature\",\n                               position,\n@@ -487,7 +475,7 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n                     return;\n                 }\n             }\n-            match_intrinsic_type_to_type(tcx,\n+            match_intrinsic_type_to_type(ccx,\n                                          position,\n                                          span,\n                                          structural_to_nominal,\n@@ -503,7 +491,7 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n                         return\n                     }\n                     for (e, c) in expected_contents.iter().zip(contents) {\n-                        match_intrinsic_type_to_type(tcx, position, span, structural_to_nominal,\n+                        match_intrinsic_type_to_type(ccx, position, span, structural_to_nominal,\n                                                      e, c)\n                     }\n                 }"}, {"sha": "467956b6497ae70fcca66d7e5ddd090ef7a521a0", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42", "patch": "@@ -15,7 +15,7 @@ use hir::def::Def;\n use hir::def_id::DefId;\n use rustc::ty::subst;\n use rustc::traits;\n-use rustc::ty::{self, TyCtxt, ToPredicate, ToPolyTraitRef, TraitRef, TypeFoldable};\n+use rustc::ty::{self, ToPredicate, ToPolyTraitRef, TraitRef, TypeFoldable};\n use rustc::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n use rustc::infer;\n \n@@ -219,7 +219,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // Trait must have a method named `m_name` and it should not have\n     // type parameters or early-bound regions.\n     let tcx = fcx.tcx();\n-    let method_item = trait_item(tcx, trait_def_id, m_name).unwrap();\n+    let method_item = trait_item(fcx, trait_def_id, m_name).unwrap();\n     let method_ty = method_item.as_opt_method().unwrap();\n     assert_eq!(method_ty.generics.types.len(subst::FnSpace), 0);\n     assert_eq!(method_ty.generics.regions.len(subst::FnSpace), 0);\n@@ -361,26 +361,26 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n /// Find item with name `item_name` defined in `trait_def_id`\n /// and return it, or `None`, if no such item.\n-fn trait_item<'tcx>(tcx: &TyCtxt<'tcx>,\n-                    trait_def_id: DefId,\n-                    item_name: ast::Name)\n-                    -> Option<ty::ImplOrTraitItem<'tcx>>\n+pub fn trait_item<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                            trait_def_id: DefId,\n+                            item_name: ast::Name)\n+                            -> Option<ty::ImplOrTraitItem<'tcx>>\n {\n-    let trait_items = tcx.trait_items(trait_def_id);\n+    let trait_items = fcx.tcx().trait_items(trait_def_id);\n     trait_items.iter()\n                .find(|item| item.name() == item_name)\n                .cloned()\n }\n \n-fn impl_item<'tcx>(tcx: &TyCtxt<'tcx>,\n-                   impl_def_id: DefId,\n-                   item_name: ast::Name)\n-                   -> Option<ty::ImplOrTraitItem<'tcx>>\n+pub fn impl_item<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                           impl_def_id: DefId,\n+                           item_name: ast::Name)\n+                           -> Option<ty::ImplOrTraitItem<'tcx>>\n {\n-    let impl_items = tcx.impl_items.borrow();\n+    let impl_items = fcx.tcx().impl_items.borrow();\n     let impl_items = impl_items.get(&impl_def_id).unwrap();\n     impl_items\n         .iter()\n-        .map(|&did| tcx.impl_or_trait_item(did.def_id()))\n+        .map(|&did| fcx.tcx().impl_or_trait_item(did.def_id()))\n         .find(|m| m.name() == item_name)\n }"}, {"sha": "96cedc76d0508389e25f11e22cb75f2f8a85d01b", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 14, "deletions": 29, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42", "patch": "@@ -406,7 +406,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         debug!(\"assemble_inherent_impl_probe {:?}\", impl_def_id);\n \n-        let item = match impl_item(self.tcx(), impl_def_id, self.item_name) {\n+        let item = match self.impl_item(impl_def_id) {\n             Some(m) => m,\n             None => { return; } // No method with correct name on this impl\n         };\n@@ -563,9 +563,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         let tcx = self.tcx();\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n-            let item = match trait_item(tcx,\n-                                        bound_trait_ref.def_id(),\n-                                        self.item_name) {\n+            let item = match self.trait_item(bound_trait_ref.def_id()) {\n                 Some(v) => v,\n                 None => { continue; }\n             };\n@@ -1311,33 +1309,20 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     {\n         self.tcx().erase_late_bound_regions(value)\n     }\n-}\n \n-fn impl_item<'tcx>(tcx: &TyCtxt<'tcx>,\n-                   impl_def_id: DefId,\n-                   item_name: ast::Name)\n-                   -> Option<ty::ImplOrTraitItem<'tcx>>\n-{\n-    let impl_items = tcx.impl_items.borrow();\n-    let impl_items = impl_items.get(&impl_def_id).unwrap();\n-    impl_items\n-        .iter()\n-        .map(|&did| tcx.impl_or_trait_item(did.def_id()))\n-        .find(|item| item.name() == item_name)\n-}\n+    fn impl_item(&self, impl_def_id: DefId)\n+                 -> Option<ty::ImplOrTraitItem<'tcx>>\n+    {\n+        super::impl_item(self.fcx, impl_def_id, self.item_name)\n+    }\n \n-/// Find item with name `item_name` defined in `trait_def_id`\n-/// and return it, or `None`, if no such item.\n-fn trait_item<'tcx>(tcx: &TyCtxt<'tcx>,\n-                    trait_def_id: DefId,\n-                    item_name: ast::Name)\n-                    -> Option<ty::ImplOrTraitItem<'tcx>>\n-{\n-    let trait_items = tcx.trait_items(trait_def_id);\n-    debug!(\"trait_method; items: {:?}\", trait_items);\n-    trait_items.iter()\n-               .find(|item| item.name() == item_name)\n-               .cloned()\n+    /// Find item with name `item_name` defined in `trait_def_id`\n+    /// and return it, or `None`, if no such item.\n+    fn trait_item(&self, trait_def_id: DefId)\n+                  -> Option<ty::ImplOrTraitItem<'tcx>>\n+    {\n+        super::trait_item(self.fcx, trait_def_id, self.item_name)\n+    }\n }\n \n impl<'tcx> Candidate<'tcx> {"}, {"sha": "9b81c4e2e9236aec1adb9f2cf7bf468640e7117f", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42", "patch": "@@ -233,10 +233,10 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 CandidateSource::ImplSource(impl_did) => {\n                     // Provide the best span we can. Use the item, if local to crate, else\n                     // the impl, if local to crate (item may be defaulted), else nothing.\n-                    let item = impl_item(fcx.tcx(), impl_did, item_name)\n+                    let item = impl_item(fcx, impl_did, item_name)\n                         .or_else(|| {\n                             trait_item(\n-                                fcx.tcx(),\n+                                fcx,\n                                 fcx.tcx().impl_trait_ref(impl_did).unwrap().def_id,\n                                 item_name\n                             )\n@@ -268,7 +268,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     }\n                 }\n                 CandidateSource::TraitSource(trait_did) => {\n-                    let item = trait_item(fcx.tcx(), trait_did, item_name).unwrap();\n+                    let item = trait_item(fcx, trait_did, item_name).unwrap();\n                     let item_span = fcx.tcx().map.def_id_span(item.def_id(), span);\n                     span_note!(err, item_span,\n                                \"candidate #{} is defined in the trait `{}`\",\n@@ -291,8 +291,6 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                       rcvr_expr: Option<&hir::Expr>,\n                                       valid_out_of_scope_traits: Vec<DefId>)\n {\n-    let tcx = fcx.tcx();\n-\n     if !valid_out_of_scope_traits.is_empty() {\n         let mut candidates = valid_out_of_scope_traits;\n         candidates.sort();\n@@ -328,7 +326,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             // implementing a trait would be legal but is rejected\n             // here).\n             (type_is_local || info.def_id.is_local())\n-                && trait_item(tcx, info.def_id, item_name).is_some()\n+                && trait_item(fcx, info.def_id, item_name).is_some()\n         })\n         .collect::<Vec<_>>();\n "}, {"sha": "d9807cc7baed3c327a74eb8429c2761e4a9bda3f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42", "patch": "@@ -413,7 +413,7 @@ pub fn check_drop_impls(ccx: &CrateCtxt) -> CompileResult {\n         drop_trait.for_each_impl(ccx.tcx, |drop_impl_did| {\n             let _task = ccx.tcx.dep_graph.in_task(DepNode::DropckImpl(drop_impl_did));\n             if drop_impl_did.is_local() {\n-                match dropck::check_drop_impl(ccx.tcx, drop_impl_did) {\n+                match dropck::check_drop_impl(ccx, drop_impl_did) {\n                     Ok(()) => {}\n                     Err(()) => {\n                         assert!(ccx.tcx.sess.has_errors());\n@@ -947,7 +947,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n                     // Find associated const definition.\n                     if let &ty::ConstTraitItem(ref trait_const) = ty_trait_item {\n-                        compare_const_impl(ccx.tcx,\n+                        compare_const_impl(ccx,\n                                            &impl_const,\n                                            impl_item.span,\n                                            trait_const,\n@@ -969,7 +969,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     };\n \n                     if let &ty::MethodTraitItem(ref trait_method) = ty_trait_item {\n-                        compare_impl_method(ccx.tcx,\n+                        compare_impl_method(ccx,\n                                             &impl_method,\n                                             impl_item.span,\n                                             body.id,\n@@ -2116,7 +2116,7 @@ pub fn autoderef<'a, 'b, 'tcx, E, I, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 let method_call = MethodCall::autoderef(expr.id, autoderefs as u32);\n                 fcx.inh.tables.borrow_mut().method_map.insert(method_call, method);\n             }\n-            make_overloaded_lvalue_return_type(fcx.tcx(), method)\n+            make_overloaded_lvalue_return_type(fcx, method)\n         } else {\n             return (resolved_t, autoderefs, None);\n         };\n@@ -2167,14 +2167,14 @@ fn try_overloaded_deref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n /// For the overloaded lvalue expressions (`*x`, `x[3]`), the trait returns a type of `&T`, but the\n /// actual type we assign to the *expression* is `T`. So this function just peels off the return\n /// type by one layer to yield `T`.\n-fn make_overloaded_lvalue_return_type<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                            method: MethodCallee<'tcx>)\n-                                            -> ty::TypeAndMut<'tcx>\n+fn make_overloaded_lvalue_return_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                                method: MethodCallee<'tcx>)\n+                                                -> ty::TypeAndMut<'tcx>\n {\n     // extract method return type, which will be &T;\n     // all LB regions should have been instantiated during method lookup\n     let ret_ty = method.ty.fn_ret();\n-    let ret_ty = tcx.no_late_bound_regions(&ret_ty).unwrap().unwrap();\n+    let ret_ty = fcx.tcx().no_late_bound_regions(&ret_ty).unwrap().unwrap();\n \n     // method returns &T, but the type as visible to user is T, so deref\n     ret_ty.builtin_deref(true, NoPreference).unwrap()\n@@ -2295,7 +2295,7 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     method.map(|method| {\n         debug!(\"try_index_step: success, using overloaded indexing\");\n         fcx.inh.tables.borrow_mut().method_map.insert(method_call, method);\n-        (input_ty, make_overloaded_lvalue_return_type(fcx.tcx(), method).ty)\n+        (input_ty, make_overloaded_lvalue_return_type(fcx, method).ty)\n     })\n }\n \n@@ -2308,7 +2308,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          expected: Expectation<'tcx>)\n                                          -> ty::FnOutput<'tcx> {\n     if method_fn_ty.references_error() {\n-        let err_inputs = err_args(fcx.tcx(), args_no_rcvr.len());\n+        let err_inputs = err_args(fcx, args_no_rcvr.len());\n \n         let err_inputs = match tuple_arguments {\n             DontTupleArguments => err_inputs,\n@@ -2387,7 +2387,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         args.len(),\n                         if args.len() == 1 {\" was\"} else {\"s were\"});\n                     expected_arg_tys = &[];\n-                    err_args(fcx.tcx(), args.len())\n+                    err_args(fcx, args.len())\n                 } else {\n                     expected_arg_tys = match expected_arg_tys.get(0) {\n                         Some(&ty) => match ty.sty {\n@@ -2404,7 +2404,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     \"cannot use call notation; the first type parameter \\\n                      for the function trait is neither a tuple nor unit\");\n                 expected_arg_tys = &[];\n-                err_args(fcx.tcx(), args.len())\n+                err_args(fcx, args.len())\n             }\n         }\n     } else if expected_arg_count == supplied_arg_count {\n@@ -2421,7 +2421,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 supplied_arg_count,\n                 if supplied_arg_count == 1 {\" was\"} else {\"s were\"});\n             expected_arg_tys = &[];\n-            err_args(fcx.tcx(), supplied_arg_count)\n+            err_args(fcx, supplied_arg_count)\n         }\n     } else {\n         span_err!(tcx.sess, sp, E0061,\n@@ -2431,7 +2431,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             supplied_arg_count,\n             if supplied_arg_count == 1 {\" was\"} else {\"s were\"});\n         expected_arg_tys = &[];\n-        err_args(fcx.tcx(), supplied_arg_count)\n+        err_args(fcx, supplied_arg_count)\n     };\n \n     debug!(\"check_argument_types: formal_tys={:?}\",\n@@ -2490,7 +2490,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 // The special-cased logic below has three functions:\n                 // 1. Provide as good of an expected type as possible.\n                 let expected = expected_arg_tys.get(i).map(|&ty| {\n-                    Expectation::rvalue_hint(fcx.tcx(), ty)\n+                    Expectation::rvalue_hint(fcx, ty)\n                 });\n \n                 check_expr_with_expectation(fcx, &arg,\n@@ -2571,9 +2571,8 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n }\n \n-// FIXME(#17596) Ty<'tcx> is incorrectly invariant w.r.t 'tcx.\n-fn err_args<'tcx>(tcx: &TyCtxt<'tcx>, len: usize) -> Vec<Ty<'tcx>> {\n-    (0..len).map(|_| tcx.types.err).collect()\n+fn err_args<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, len: usize) -> Vec<Ty<'tcx>> {\n+    (0..len).map(|_| fcx.tcx().types.err).collect()\n }\n \n fn write_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -3241,7 +3240,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n       hir::ExprBox(ref subexpr) => {\n         let expected_inner = expected.to_option(fcx).map_or(NoExpectation, |ty| {\n             match ty.sty {\n-                ty::TyBox(ty) => Expectation::rvalue_hint(tcx, ty),\n+                ty::TyBox(ty) => Expectation::rvalue_hint(fcx, ty),\n                 _ => NoExpectation\n             }\n         });\n@@ -3286,7 +3285,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         oprnd_t = mt.ty;\n                     } else if let Some(method) = try_overloaded_deref(\n                             fcx, expr.span, Some(&oprnd), oprnd_t, lvalue_pref) {\n-                        oprnd_t = make_overloaded_lvalue_return_type(tcx, method).ty;\n+                        oprnd_t = make_overloaded_lvalue_return_type(fcx, method).ty;\n                         fcx.inh.tables.borrow_mut().method_map.insert(MethodCall::expr(expr.id),\n                                                                       method);\n                     } else {\n@@ -3329,7 +3328,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         // the last field of a struct can be unsized.\n                         ExpectHasType(mt.ty)\n                     } else {\n-                        Expectation::rvalue_hint(tcx, mt.ty)\n+                        Expectation::rvalue_hint(fcx, mt.ty)\n                     }\n                 }\n                 _ => NoExpectation\n@@ -3810,8 +3809,8 @@ impl<'tcx> Expectation<'tcx> {\n     /// which still is useful, because it informs integer literals and the like.\n     /// See the test case `test/run-pass/coerce-expect-unsized.rs` and #20169\n     /// for examples of where this comes up,.\n-    fn rvalue_hint(tcx: &TyCtxt<'tcx>, ty: Ty<'tcx>) -> Expectation<'tcx> {\n-        match tcx.struct_tail(ty).sty {\n+    fn rvalue_hint<'a>(fcx: &FnCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> Expectation<'tcx> {\n+        match fcx.tcx().struct_tail(ty).sty {\n             ty::TySlice(_) | ty::TyStr | ty::TyTrait(..) => {\n                 ExpectRvalueLikeUnsized(ty)\n             }"}, {"sha": "17856dc4255c888b0db272aed2c718186c153a43", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42", "patch": "@@ -414,7 +414,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         debug!(\"check_method_receiver: receiver ty = {:?}\", rcvr_ty);\n \n         let _ = ::require_same_types(\n-            fcx.tcx(), Some(fcx.infcx()), false, span,\n+            fcx.ccx, Some(fcx.infcx()), span,\n             sig.inputs[0], rcvr_ty,\n             \"mismatched method receiver\");\n     }\n@@ -435,8 +435,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                      .map(|p| Parameter::Type(p))\n                      .collect();\n \n-        identify_constrained_type_params(self.tcx(),\n-                                         ty_predicates.predicates.as_slice(),\n+        identify_constrained_type_params(ty_predicates.predicates.as_slice(),\n                                          None,\n                                          &mut constrained_parameters);\n \n@@ -494,7 +493,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                          span: Span,\n                          param_name: ast::Name)\n     {\n-        let mut err = error_392(self.tcx(), span, param_name);\n+        let mut err = error_392(self.ccx, span, param_name);\n \n         let suggested_marker_id = self.tcx().lang_items.phantom_data();\n         match suggested_marker_id {\n@@ -512,9 +511,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     }\n }\n \n-fn reject_shadowing_type_parameters<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                          span: Span,\n-                                          generics: &ty::Generics<'tcx>) {\n+fn reject_shadowing_type_parameters(tcx: &TyCtxt, span: Span, generics: &ty::Generics) {\n     let impl_params = generics.types.get_slice(subst::TypeSpace).iter()\n         .map(|tp| tp.name).collect::<HashSet<_>>();\n \n@@ -607,25 +604,25 @@ fn impl_implied_bounds<'fcx,'tcx>(fcx: &FnCtxt<'fcx, 'tcx>,\n     }\n }\n \n-pub fn error_192<'ccx,'tcx>(ccx: &'ccx CrateCtxt<'ccx, 'tcx>, span: Span) {\n+fn error_192(ccx: &CrateCtxt, span: Span) {\n     span_err!(ccx.tcx.sess, span, E0192,\n               \"negative impls are only allowed for traits with \\\n                default impls (e.g., `Send` and `Sync`)\")\n }\n \n-pub fn error_380<'ccx,'tcx>(ccx: &'ccx CrateCtxt<'ccx, 'tcx>, span: Span) {\n+fn error_380(ccx: &CrateCtxt, span: Span) {\n     span_err!(ccx.tcx.sess, span, E0380,\n               \"traits with default impls (`e.g. unsafe impl \\\n                Trait for ..`) must have no methods or associated items\")\n }\n \n-pub fn error_392<'tcx>(tcx: &TyCtxt<'tcx>, span: Span, param_name: ast::Name)\n+fn error_392<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, span: Span, param_name: ast::Name)\n                        -> DiagnosticBuilder<'tcx> {\n-    struct_span_err!(tcx.sess, span, E0392,\n+    struct_span_err!(ccx.tcx.sess, span, E0392,\n                      \"parameter `{}` is never used\", param_name)\n }\n \n-pub fn error_194<'tcx>(tcx: &TyCtxt<'tcx>, span: Span, name: ast::Name) {\n+fn error_194(tcx: &TyCtxt, span: Span, name: ast::Name) {\n     span_err!(tcx.sess, span, E0194,\n               \"type parameter `{}` shadows another type parameter of the same name\",\n               name);"}, {"sha": "a7039dcd91c3d9b4d0d9ada11d1255959d0ea0a4", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42", "patch": "@@ -195,15 +195,15 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n \n         let var_ty = self.fcx.local_ty(l.span, l.id);\n         let var_ty = self.resolve(&var_ty, ResolvingLocal(l.span));\n-        write_ty_to_tcx(self.tcx(), l.id, var_ty);\n+        write_ty_to_tcx(self.fcx.ccx, l.id, var_ty);\n         intravisit::walk_local(self, l);\n     }\n \n     fn visit_ty(&mut self, t: &hir::Ty) {\n         match t.node {\n             hir::TyFixedLengthVec(ref ty, ref count_expr) => {\n                 self.visit_ty(&ty);\n-                write_ty_to_tcx(self.tcx(), count_expr.id, self.tcx().types.usize);\n+                write_ty_to_tcx(self.fcx.ccx, count_expr.id, self.tcx().types.usize);\n             }\n             hir::TyBareFn(ref function_declaration) => {\n                 intravisit::walk_fn_decl_nopat(self, &function_declaration.decl);\n@@ -263,12 +263,12 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         // Resolve the type of the node with id `id`\n         let n_ty = self.fcx.node_ty(id);\n         let n_ty = self.resolve(&n_ty, reason);\n-        write_ty_to_tcx(self.tcx(), id, n_ty);\n+        write_ty_to_tcx(self.fcx.ccx, id, n_ty);\n         debug!(\"Node {} has type {:?}\", id, n_ty);\n \n         // Resolve any substitutions\n         self.fcx.opt_node_ty_substs(id, |item_substs| {\n-            write_substs_to_tcx(self.tcx(), id,\n+            write_substs_to_tcx(self.fcx.ccx, id,\n                                 self.resolve(item_substs, reason));\n         });\n     }"}, {"sha": "9393dd1bce7a905421974cfc480f21d4e589932a", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 110, "deletions": 140, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42", "patch": "@@ -87,9 +87,7 @@ use std::collections::HashSet;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::rc::Rc;\n \n-use syntax::abi;\n-use syntax::ast;\n-use syntax::attr;\n+use syntax::{abi, ast, attr};\n use syntax::codemap::Span;\n use syntax::parse::token::keywords;\n use syntax::ptr::P;\n@@ -565,7 +563,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     });\n     ccx.tcx.predicates.borrow_mut().insert(def_id, ty_method.predicates.clone());\n \n-    write_ty_to_tcx(ccx.tcx, id, fty);\n+    write_ty_to_tcx(ccx, id, fty);\n \n     debug!(\"writing method type: def_id={:?} mty={:?}\",\n             def_id, ty_method);\n@@ -582,7 +580,7 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n {\n     let tt = ccx.icx(struct_predicates).to_ty(&ExplicitRscope, &field.ty);\n     ty_f.fulfill_ty(tt);\n-    write_ty_to_tcx(ccx.tcx, field.id, tt);\n+    write_ty_to_tcx(ccx, field.id, tt);\n \n     /* add the field to the tcache */\n     ccx.tcx.register_item_type(ccx.tcx.map.local_def_id(field.id),\n@@ -606,7 +604,7 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     ccx.tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(id),\n                                            ty::GenericPredicates::empty());\n \n-    write_ty_to_tcx(ccx.tcx, id, ty);\n+    write_ty_to_tcx(ccx, id, ty);\n \n     let associated_const = Rc::new(ty::AssociatedConst {\n         name: name,\n@@ -684,7 +682,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n         }\n         hir::ItemEnum(ref enum_definition, _) => {\n             let (scheme, predicates) = convert_typed_item(ccx, it);\n-            write_ty_to_tcx(tcx, it.id, scheme.ty);\n+            write_ty_to_tcx(ccx, it.id, scheme.ty);\n             convert_enum_variant_types(ccx,\n                                        tcx.lookup_adt_def_master(ccx.tcx.map.local_def_id(it.id)),\n                                        scheme,\n@@ -717,7 +715,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             debug!(\"convert: impl_bounds={:?}\", ty_predicates);\n \n             let selfty = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, &selfty);\n-            write_ty_to_tcx(tcx, it.id, selfty);\n+            write_ty_to_tcx(ccx, it.id, selfty);\n \n             tcx.register_item_type(def_id,\n                                    TypeScheme { generics: ty_generics.clone(),\n@@ -730,7 +728,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             });\n             tcx.impl_trait_refs.borrow_mut().insert(def_id, trait_ref);\n \n-            enforce_impl_params_are_constrained(tcx, generics, &mut ty_predicates, def_id);\n+            enforce_impl_params_are_constrained(ccx, generics, &mut ty_predicates, def_id);\n             tcx.predicates.borrow_mut().insert(def_id, ty_predicates.clone());\n \n \n@@ -807,7 +805,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                 }\n             }\n \n-            enforce_impl_lifetimes_are_constrained(tcx, generics, def_id, impl_items);\n+            enforce_impl_lifetimes_are_constrained(ccx, generics, def_id, impl_items);\n         },\n         hir::ItemTrait(_, _, _, ref trait_items) => {\n             let trait_def = trait_def_of_item(ccx, it);\n@@ -891,7 +889,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n         },\n         hir::ItemStruct(ref struct_def, _) => {\n             let (scheme, predicates) = convert_typed_item(ccx, it);\n-            write_ty_to_tcx(tcx, it.id, scheme.ty);\n+            write_ty_to_tcx(ccx, it.id, scheme.ty);\n \n             let it_def_id = ccx.tcx.map.local_def_id(it.id);\n             let variant = tcx.lookup_adt_def_master(it_def_id).struct_variant();\n@@ -907,14 +905,14 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n         hir::ItemTy(_, ref generics) => {\n             ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n             let (scheme, _) = convert_typed_item(ccx, it);\n-            write_ty_to_tcx(tcx, it.id, scheme.ty);\n+            write_ty_to_tcx(ccx, it.id, scheme.ty);\n         },\n         _ => {\n             // This call populates the type cache with the converted type\n             // of the item in passing. All we have to do here is to write\n             // it into the node type table.\n             let (scheme, _) = convert_typed_item(ccx, it);\n-            write_ty_to_tcx(tcx, it.id, scheme.ty);\n+            write_ty_to_tcx(ccx, it.id, scheme.ty);\n         },\n     }\n }\n@@ -946,7 +944,7 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             })\n         }\n     };\n-    write_ty_to_tcx(tcx, ctor_id, ctor_ty);\n+    write_ty_to_tcx(ccx, ctor_id, ctor_ty);\n     tcx.predicates.borrow_mut().insert(tcx.map.local_def_id(ctor_id), predicates);\n     tcx.register_item_type(tcx.map.local_def_id(ctor_id),\n                            TypeScheme {\n@@ -978,18 +976,19 @@ fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn convert_struct_variant<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                did: DefId,\n-                                name: ast::Name,\n-                                disr_val: ty::Disr,\n-                                def: &hir::VariantData) -> ty::VariantDefData<'tcx, 'tcx> {\n+fn convert_struct_variant<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                    did: DefId,\n+                                    name: ast::Name,\n+                                    disr_val: ty::Disr,\n+                                    def: &hir::VariantData)\n+                                    -> ty::VariantDefData<'tcx, 'tcx> {\n     let mut seen_fields: FnvHashMap<ast::Name, Span> = FnvHashMap();\n-    let node_id = tcx.map.as_local_node_id(did).unwrap();\n+    let node_id = ccx.tcx.map.as_local_node_id(did).unwrap();\n     let fields = def.fields().iter().map(|f| {\n-        let fid = tcx.map.local_def_id(f.id);\n+        let fid = ccx.tcx.map.local_def_id(f.id);\n         let dup_span = seen_fields.get(&f.name).cloned();\n         if let Some(prev_span) = dup_span {\n-            let mut err = struct_span_err!(tcx.sess, f.span, E0124,\n+            let mut err = struct_span_err!(ccx.tcx.sess, f.span, E0124,\n                                            \"field `{}` is already declared\",\n                                            f.name);\n             span_note!(&mut err, prev_span, \"previously declared here\");\n@@ -998,7 +997,8 @@ fn convert_struct_variant<'tcx>(tcx: &TyCtxt<'tcx>,\n             seen_fields.insert(f.name, f.span);\n         }\n \n-        ty::FieldDefData::new(fid, f.name, ty::Visibility::from_hir(&f.vis, node_id, tcx))\n+        ty::FieldDefData::new(fid, f.name,\n+            ty::Visibility::from_hir(&f.vis, node_id, ccx.tcx))\n     }).collect();\n     ty::VariantDefData {\n         did: did,\n@@ -1009,71 +1009,63 @@ fn convert_struct_variant<'tcx>(tcx: &TyCtxt<'tcx>,\n     }\n }\n \n-fn convert_struct_def<'tcx>(tcx: &TyCtxt<'tcx>,\n-                            it: &hir::Item,\n-                            def: &hir::VariantData)\n-                            -> ty::AdtDefMaster<'tcx>\n+fn convert_struct_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                it: &hir::Item,\n+                                def: &hir::VariantData)\n+                                -> ty::AdtDefMaster<'tcx>\n {\n \n-    let did = tcx.map.local_def_id(it.id);\n+    let did = ccx.tcx.map.local_def_id(it.id);\n     let ctor_id = if !def.is_struct() {\n-        tcx.map.local_def_id(def.id())\n+        ccx.tcx.map.local_def_id(def.id())\n     } else {\n         did\n     };\n-    tcx.intern_adt_def(\n-        did,\n-        ty::AdtKind::Struct,\n-        vec![convert_struct_variant(tcx, ctor_id, it.name, ConstInt::Infer(0), def)]\n-    )\n+    ccx.tcx.intern_adt_def(did, ty::AdtKind::Struct,\n+        vec![convert_struct_variant(ccx, ctor_id, it.name, ConstInt::Infer(0), def)])\n }\n \n-fn convert_enum_def<'tcx>(tcx: &TyCtxt<'tcx>,\n-                          it: &hir::Item,\n-                          def: &hir::EnumDef)\n-                          -> ty::AdtDefMaster<'tcx>\n-{\n-    fn print_err(tcx: &TyCtxt, span: Span, ty: ty::Ty, cv: ConstVal) {\n-        struct_span_err!(tcx.sess, span, E0079, \"mismatched types\")\n-            .note_expected_found(&\"type\", &ty, &format!(\"{}\", cv.description()))\n-            .emit();\n-    }\n-    fn evaluate_disr_expr<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                repr_ty: attr::IntType,\n-                                e: &hir::Expr) -> Option<ty::Disr> {\n+    fn evaluate_disr_expr(ccx: &CrateCtxt, repr_ty: attr::IntType, e: &hir::Expr)\n+                          -> Option<ty::Disr> {\n         debug!(\"disr expr, checking {}\", pprust::expr_to_string(e));\n \n-        let ty_hint = repr_ty.to_ty(tcx);\n+        let ty_hint = repr_ty.to_ty(ccx.tcx);\n+        let print_err = |cv: ConstVal| {\n+            struct_span_err!(ccx.tcx.sess, e.span, E0079, \"mismatched types\")\n+                .note_expected_found(&\"type\", &ty_hint, &format!(\"{}\", cv.description()))\n+                .emit();\n+        };\n+\n         let hint = UncheckedExprHint(ty_hint);\n-        match eval_const_expr_partial(tcx, e, hint, None) {\n+        match eval_const_expr_partial(ccx.tcx, e, hint, None) {\n             Ok(ConstVal::Integral(i)) => {\n                 // FIXME: eval_const_expr_partial should return an error if the hint is wrong\n                 match (repr_ty, i) {\n-                    (attr::SignedInt(ast::IntTy::I8), ConstInt::I8(_)) => Some(i),\n-                    (attr::SignedInt(ast::IntTy::I16), ConstInt::I16(_)) => Some(i),\n-                    (attr::SignedInt(ast::IntTy::I32), ConstInt::I32(_)) => Some(i),\n-                    (attr::SignedInt(ast::IntTy::I64), ConstInt::I64(_)) => Some(i),\n-                    (attr::SignedInt(ast::IntTy::Is), ConstInt::Isize(_)) => Some(i),\n-                    (attr::UnsignedInt(ast::UintTy::U8), ConstInt::U8(_)) => Some(i),\n-                    (attr::UnsignedInt(ast::UintTy::U16), ConstInt::U16(_)) => Some(i),\n-                    (attr::UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) => Some(i),\n-                    (attr::UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) => Some(i),\n+                    (attr::SignedInt(ast::IntTy::I8), ConstInt::I8(_)) |\n+                    (attr::SignedInt(ast::IntTy::I16), ConstInt::I16(_)) |\n+                    (attr::SignedInt(ast::IntTy::I32), ConstInt::I32(_)) |\n+                    (attr::SignedInt(ast::IntTy::I64), ConstInt::I64(_)) |\n+                    (attr::SignedInt(ast::IntTy::Is), ConstInt::Isize(_)) |\n+                    (attr::UnsignedInt(ast::UintTy::U8), ConstInt::U8(_)) |\n+                    (attr::UnsignedInt(ast::UintTy::U16), ConstInt::U16(_)) |\n+                    (attr::UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) |\n+                    (attr::UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) |\n                     (attr::UnsignedInt(ast::UintTy::Us), ConstInt::Usize(_)) => Some(i),\n                     (_, i) => {\n-                        print_err(tcx, e.span, ty_hint, ConstVal::Integral(i));\n+                        print_err(ConstVal::Integral(i));\n                         None\n                     },\n                 }\n             },\n             Ok(cv) => {\n-                print_err(tcx, e.span, ty_hint, cv);\n+                print_err(cv);\n                 None\n             },\n             // enum variant evaluation happens before the global constant check\n             // so we need to report the real error\n             Err(ConstEvalErr { kind: ErroneousReferencedConstant(box err), ..}) |\n             Err(err) => {\n-                let mut diag = struct_span_err!(tcx.sess, err.span, E0080,\n+                let mut diag = struct_span_err!(ccx.tcx.sess, err.span, E0080,\n                                                 \"constant evaluation error: {}\",\n                                                 err.description());\n                 if !e.span.contains(err.span) {\n@@ -1085,54 +1077,34 @@ fn convert_enum_def<'tcx>(tcx: &TyCtxt<'tcx>,\n         }\n     }\n \n-    fn report_discrim_overflow(tcx: &TyCtxt,\n-                               variant_span: Span,\n-                               variant_name: &str,\n-                               prev_val: ty::Disr) {\n-        span_err!(tcx.sess, variant_span, E0370,\n-                  \"enum discriminant overflowed on value after {}; \\\n-                   set explicitly via {} = {} if that is desired outcome\",\n-                  prev_val, variant_name, prev_val.wrap_incr());\n-    }\n-\n-    fn next_disr(tcx: &TyCtxt,\n-                 v: &hir::Variant,\n-                 repr_type: attr::IntType,\n-                 prev_disr_val: Option<ty::Disr>) -> Option<ty::Disr> {\n-        if let Some(prev_disr_val) = prev_disr_val {\n-            let result = repr_type.disr_incr(prev_disr_val);\n-            if let None = result {\n-                report_discrim_overflow(tcx, v.span, &v.node.name.as_str(), prev_disr_val);\n-            }\n-            result\n-        } else {\n-            Some(repr_type.initial_discriminant(tcx))\n-        }\n-    }\n-    fn convert_enum_variant<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                  v: &hir::Variant,\n-                                  disr: ty::Disr)\n-                                  -> ty::VariantDefData<'tcx, 'tcx>\n-    {\n-        let did = tcx.map.local_def_id(v.node.data.id());\n-        let name = v.node.name;\n-        convert_struct_variant(tcx, did, name, disr, &v.node.data)\n-    }\n+fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                              it: &hir::Item,\n+                              def: &hir::EnumDef)\n+                              -> ty::AdtDefMaster<'tcx>\n+{\n+    let tcx = ccx.tcx;\n     let did = tcx.map.local_def_id(it.id);\n     let repr_hints = tcx.lookup_repr_hints(did);\n     let repr_type = tcx.enum_repr_type(repr_hints.get(0));\n-    let mut prev_disr = None;\n+    let initial = repr_type.initial_discriminant(tcx);\n+    let mut prev_disr = None::<ty::Disr>;\n     let variants = def.variants.iter().map(|v| {\n-        let disr = match v.node.disr_expr {\n-            Some(ref e) => evaluate_disr_expr(tcx, repr_type, e),\n-            None => next_disr(tcx, v, repr_type, prev_disr)\n-        }.unwrap_or_else(|| {\n-            prev_disr.map(ty::Disr::wrap_incr)\n-                     .unwrap_or(repr_type.initial_discriminant(tcx))\n-        });\n-\n+        let wrapped_disr = prev_disr.map_or(initial, |d| d.wrap_incr());\n+        let disr = if let Some(ref e) = v.node.disr_expr {\n+            evaluate_disr_expr(ccx, repr_type, e)\n+        } else if let Some(disr) = repr_type.disr_incr(tcx, prev_disr) {\n+            Some(disr)\n+        } else {\n+            span_err!(tcx.sess, v.span, E0370,\n+                      \"enum discriminant overflowed on value after {}; \\\n+                       set explicitly via {} = {} if that is desired outcome\",\n+                      prev_disr.unwrap(), v.node.name, wrapped_disr);\n+            None\n+        }.unwrap_or(wrapped_disr);\n         prev_disr = Some(disr);\n-        convert_enum_variant(tcx, v, disr)\n+\n+        let did = tcx.map.local_def_id(v.node.data.id());\n+        convert_struct_variant(ccx, did, v.node.name, disr, &v.node.data)\n     }).collect();\n     tcx.intern_adt_def(tcx.map.local_def_id(it.id), ty::AdtKind::Enum, variants)\n }\n@@ -1471,16 +1443,16 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n         hir::ItemEnum(ref ei, ref generics) => {\n+            let def = convert_enum_def(ccx, it, ei);\n             let ty_generics = ty_generics_for_type(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n-            let def = convert_enum_def(tcx, it, ei);\n             let t = tcx.mk_enum(def, tcx.mk_substs(substs));\n             ty::TypeScheme { ty: t, generics: ty_generics }\n         }\n         hir::ItemStruct(ref si, ref generics) => {\n+            let def = convert_struct_def(ccx, it, si);\n             let ty_generics = ty_generics_for_type(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n-            let def = convert_struct_def(tcx, it, si);\n             let t = tcx.mk_struct(def, tcx.mk_substs(substs));\n             ty::TypeScheme { ty: t, generics: ty_generics }\n         }\n@@ -1606,7 +1578,7 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let abi = tcx.map.get_foreign_abi(it.id);\n \n     let scheme = type_scheme_of_foreign_item(ccx, it, abi);\n-    write_ty_to_tcx(ccx.tcx, it.id, scheme.ty);\n+    write_ty_to_tcx(ccx, it.id, scheme.ty);\n \n     let predicates = match it.node {\n         hir::ForeignItemFn(_, ref generics) => {\n@@ -2229,13 +2201,13 @@ fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n }\n \n /// Checks that all the type parameters on an impl\n-fn enforce_impl_params_are_constrained<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                             ast_generics: &hir::Generics,\n-                                             impl_predicates: &mut ty::GenericPredicates<'tcx>,\n-                                             impl_def_id: DefId)\n+fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                                 ast_generics: &hir::Generics,\n+                                                 impl_predicates: &mut ty::GenericPredicates<'tcx>,\n+                                                 impl_def_id: DefId)\n {\n-    let impl_scheme = tcx.lookup_item_type(impl_def_id);\n-    let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n+    let impl_scheme = ccx.tcx.lookup_item_type(impl_def_id);\n+    let impl_trait_ref = ccx.tcx.impl_trait_ref(impl_def_id);\n \n     assert!(impl_predicates.predicates.is_empty_in(FnSpace));\n     assert!(impl_predicates.predicates.is_empty_in(SelfSpace));\n@@ -2249,8 +2221,7 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &TyCtxt<'tcx>,\n         input_parameters.extend(ctp::parameters_for_trait_ref(trait_ref, false));\n     }\n \n-    ctp::setup_constraining_predicates(tcx,\n-                                       impl_predicates.predicates.get_mut_slice(TypeSpace),\n+    ctp::setup_constraining_predicates(impl_predicates.predicates.get_mut_slice(TypeSpace),\n                                        impl_trait_ref,\n                                        &mut input_parameters);\n \n@@ -2259,42 +2230,41 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &TyCtxt<'tcx>,\n                                      idx: index as u32,\n                                      name: ty_param.name };\n         if !input_parameters.contains(&ctp::Parameter::Type(param_ty)) {\n-            report_unused_parameter(tcx, ty_param.span, \"type\", &param_ty.to_string());\n+            report_unused_parameter(ccx, ty_param.span, \"type\", &param_ty.to_string());\n         }\n     }\n }\n \n-fn enforce_impl_lifetimes_are_constrained<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                                ast_generics: &hir::Generics,\n-                                                impl_def_id: DefId,\n-                                                impl_items: &[hir::ImplItem])\n+fn enforce_impl_lifetimes_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                                    ast_generics: &hir::Generics,\n+                                                    impl_def_id: DefId,\n+                                                    impl_items: &[hir::ImplItem])\n {\n     // Every lifetime used in an associated type must be constrained.\n-    let impl_scheme = tcx.lookup_item_type(impl_def_id);\n-    let impl_predicates = tcx.lookup_predicates(impl_def_id);\n-    let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n+    let impl_scheme = ccx.tcx.lookup_item_type(impl_def_id);\n+    let impl_predicates = ccx.tcx.lookup_predicates(impl_def_id);\n+    let impl_trait_ref = ccx.tcx.impl_trait_ref(impl_def_id);\n \n     let mut input_parameters: HashSet<_> =\n         ctp::parameters_for_type(impl_scheme.ty, false).into_iter().collect();\n     if let Some(ref trait_ref) = impl_trait_ref {\n         input_parameters.extend(ctp::parameters_for_trait_ref(trait_ref, false));\n     }\n-    ctp::identify_constrained_type_params(tcx,\n+    ctp::identify_constrained_type_params(\n         &impl_predicates.predicates.as_slice(), impl_trait_ref, &mut input_parameters);\n \n-    let lifetimes_in_associated_types: HashSet<_> =\n-        impl_items.iter()\n-                  .map(|item| tcx.impl_or_trait_item(tcx.map.local_def_id(item.id)))\n-                  .filter_map(|item| match item {\n-                      ty::TypeTraitItem(ref assoc_ty) => assoc_ty.ty,\n-                      ty::ConstTraitItem(..) | ty::MethodTraitItem(..) => None\n-                  })\n-                  .flat_map(|ty| ctp::parameters_for_type(ty, true))\n-                  .filter_map(|p| match p {\n-                      ctp::Parameter::Type(_) => None,\n-                      ctp::Parameter::Region(r) => Some(r),\n-                  })\n-                  .collect();\n+    let lifetimes_in_associated_types: HashSet<_> = impl_items.iter()\n+        .map(|item| ccx.tcx.impl_or_trait_item(ccx.tcx.map.local_def_id(item.id)))\n+        .filter_map(|item| match item {\n+            ty::TypeTraitItem(ref assoc_ty) => assoc_ty.ty,\n+            ty::ConstTraitItem(..) | ty::MethodTraitItem(..) => None\n+        })\n+        .flat_map(|ty| ctp::parameters_for_type(ty, true))\n+        .filter_map(|p| match p {\n+            ctp::Parameter::Type(_) => None,\n+            ctp::Parameter::Region(r) => Some(r),\n+        })\n+        .collect();\n \n     for (index, lifetime_def) in ast_generics.lifetimes.iter().enumerate() {\n         let region = ty::EarlyBoundRegion { space: TypeSpace,\n@@ -2304,7 +2274,7 @@ fn enforce_impl_lifetimes_are_constrained<'tcx>(tcx: &TyCtxt<'tcx>,\n             lifetimes_in_associated_types.contains(&region) && // (*)\n             !input_parameters.contains(&ctp::Parameter::Region(region))\n         {\n-            report_unused_parameter(tcx, lifetime_def.lifetime.span,\n+            report_unused_parameter(ccx, lifetime_def.lifetime.span,\n                                     \"lifetime\", &region.name.to_string());\n         }\n     }\n@@ -2329,12 +2299,12 @@ fn enforce_impl_lifetimes_are_constrained<'tcx>(tcx: &TyCtxt<'tcx>,\n     // used elsewhere are not projected back out.\n }\n \n-fn report_unused_parameter(tcx: &TyCtxt,\n+fn report_unused_parameter(ccx: &CrateCtxt,\n                            span: Span,\n                            kind: &str,\n                            name: &str)\n {\n-    span_err!(tcx.sess, span, E0207,\n+    span_err!(ccx.tcx.sess, span, E0207,\n               \"the {} parameter `{}` is not constrained by the \\\n                impl trait, self type, or predicates\",\n               kind, name);"}, {"sha": "08c1b5fcc82c3dc9e72d7ec0f6d35e17f4dd2756", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::ty::subst;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, subst, Ty};\n \n use std::collections::HashSet;\n \n@@ -94,13 +93,12 @@ fn parameters_for_region(region: &ty::Region) -> Option<Parameter> {\n     }\n }\n \n-pub fn identify_constrained_type_params<'tcx>(_tcx: &TyCtxt<'tcx>,\n-                                              predicates: &[ty::Predicate<'tcx>],\n+pub fn identify_constrained_type_params<'tcx>(predicates: &[ty::Predicate<'tcx>],\n                                               impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n                                               input_parameters: &mut HashSet<Parameter>)\n {\n     let mut predicates = predicates.to_owned();\n-    setup_constraining_predicates(_tcx, &mut predicates, impl_trait_ref, input_parameters);\n+    setup_constraining_predicates(&mut predicates, impl_trait_ref, input_parameters);\n }\n \n \n@@ -144,8 +142,7 @@ pub fn identify_constrained_type_params<'tcx>(_tcx: &TyCtxt<'tcx>,\n /// which is determined by 1, which requires `U`, that is determined\n /// by 0. I should probably pick a less tangled example, but I can't\n /// think of any.\n-pub fn setup_constraining_predicates<'tcx>(_tcx: &TyCtxt<'tcx>,\n-                                           predicates: &mut [ty::Predicate<'tcx>],\n+pub fn setup_constraining_predicates<'tcx>(predicates: &mut [ty::Predicate<'tcx>],\n                                            impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n                                            input_parameters: &mut HashSet<Parameter>)\n {"}, {"sha": "e5e4fda10efc12f9aa4f858d3f8482efb5ebd67b", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 24, "deletions": 33, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42", "patch": "@@ -153,13 +153,13 @@ pub struct CrateCtxt<'a, 'tcx: 'a> {\n }\n \n // Functions that write types into the node type table\n-fn write_ty_to_tcx<'tcx>(tcx: &TyCtxt<'tcx>, node_id: ast::NodeId, ty: Ty<'tcx>) {\n+fn write_ty_to_tcx<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, node_id: ast::NodeId, ty: Ty<'tcx>) {\n     debug!(\"write_ty_to_tcx({}, {:?})\", node_id,  ty);\n     assert!(!ty.needs_infer());\n-    tcx.node_type_insert(node_id, ty);\n+    ccx.tcx.node_type_insert(node_id, ty);\n }\n \n-fn write_substs_to_tcx<'tcx>(tcx: &TyCtxt<'tcx>,\n+fn write_substs_to_tcx<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                  node_id: ast::NodeId,\n                                  item_substs: ty::ItemSubsts<'tcx>) {\n     if !item_substs.is_noop() {\n@@ -169,7 +169,7 @@ fn write_substs_to_tcx<'tcx>(tcx: &TyCtxt<'tcx>,\n \n         assert!(!item_substs.substs.types.needs_infer());\n \n-        tcx.tables.borrow_mut().item_substs.insert(node_id, item_substs);\n+        ccx.tcx.tables.borrow_mut().item_substs.insert(node_id, item_substs);\n     }\n }\n \n@@ -192,44 +192,35 @@ fn require_c_abi_if_variadic(tcx: &TyCtxt,\n     }\n }\n \n-fn require_same_types<'a, 'tcx>(tcx: &TyCtxt<'tcx>,\n+fn require_same_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 maybe_infcx: Option<&infer::InferCtxt<'a, 'tcx>>,\n-                                t1_is_expected: bool,\n                                 span: Span,\n                                 t1: Ty<'tcx>,\n                                 t2: Ty<'tcx>,\n                                 msg: &str)\n                                 -> bool\n {\n-    let result = match maybe_infcx {\n-        None => {\n-            let infcx = InferCtxt::new(tcx, &tcx.tables, None, ProjectionMode::AnyFinal);\n-            infer::mk_eqty(&infcx, t1_is_expected, TypeOrigin::Misc(span), t1, t2)\n-        }\n-        Some(infcx) => {\n-            infer::mk_eqty(infcx, t1_is_expected, TypeOrigin::Misc(span), t1, t2)\n-        }\n+    let err = if let Some(infcx) = maybe_infcx {\n+        infer::mk_eqty(infcx, false, TypeOrigin::Misc(span), t1, t2).err()\n+    } else {\n+        let infcx = InferCtxt::new(ccx.tcx, &ccx.tcx.tables, None, ProjectionMode::AnyFinal);\n+        infer::mk_eqty(&infcx, false, TypeOrigin::Misc(span), t1, t2).err()\n     };\n \n-    match result {\n-        Ok(_) => true,\n-        Err(ref terr) => {\n-            let mut err = struct_span_err!(tcx.sess, span, E0211, \"{}\", msg);\n-            err = err.span_label(span, &terr);\n-            let (mut expected_ty, mut found_ty) =\n-                if t1_is_expected {(t1, t2)} else {(t2, t1)};\n-            if let Some(infcx) = maybe_infcx {\n-                expected_ty = infcx.resolve_type_vars_if_possible(&expected_ty);\n-                found_ty = infcx.resolve_type_vars_if_possible(&found_ty);\n-            }\n-            err = err.note_expected_found(&\"type\",\n-                                          &expected_ty,\n-                                          &found_ty);\n-            tcx.note_and_explain_type_err(&mut err, terr, span);\n-            err.emit();\n-            false\n+    if let Some(ref terr) = err {\n+        let mut err = struct_span_err!(ccx.tcx.sess, span, E0211, \"{}\", msg);\n+        err = err.span_label(span, &terr);\n+        let (mut expected_ty, mut found_ty) = (t2, t1);\n+        if let Some(infcx) = maybe_infcx {\n+            expected_ty = infcx.resolve_type_vars_if_possible(&expected_ty);\n+            found_ty = infcx.resolve_type_vars_if_possible(&found_ty);\n         }\n+        err = err.note_expected_found(&\"type\", &expected_ty, &found_ty);\n+        ccx.tcx.note_and_explain_type_err(&mut err, terr, span);\n+        err.emit();\n     }\n+\n+    err.is_none()\n }\n \n fn check_main_fn_ty(ccx: &CrateCtxt,\n@@ -265,7 +256,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 })\n             });\n \n-            require_same_types(tcx, None, false, main_span, main_t, se_ty,\n+            require_same_types(ccx, None, main_span, main_t, se_ty,\n                                \"main function has wrong type\");\n         }\n         _ => {\n@@ -313,7 +304,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 }),\n             });\n \n-            require_same_types(tcx, None, false, start_span, start_t, se_ty,\n+            require_same_types(ccx, None, start_span, start_t, se_ty,\n                                \"start function has wrong type\");\n         }\n         _ => {"}]}