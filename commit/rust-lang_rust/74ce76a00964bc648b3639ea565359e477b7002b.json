{"sha": "74ce76a00964bc648b3639ea565359e477b7002b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0Y2U3NmEwMDk2NGJjNjQ4YjM2MzllYTU2NTM1OWU0NzdiNzAwMmI=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-08-07T20:30:01Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-08-14T19:35:46Z"}, "message": "Treat assigning the destination of a call as an assignment", "tree": {"sha": "6f444185afe908b19c06a60176914c74dfc17f11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f444185afe908b19c06a60176914c74dfc17f11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74ce76a00964bc648b3639ea565359e477b7002b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74ce76a00964bc648b3639ea565359e477b7002b", "html_url": "https://github.com/rust-lang/rust/commit/74ce76a00964bc648b3639ea565359e477b7002b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74ce76a00964bc648b3639ea565359e477b7002b/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "092f03a07aa075c6b5cfecc47a8be6e133073819", "url": "https://api.github.com/repos/rust-lang/rust/commits/092f03a07aa075c6b5cfecc47a8be6e133073819", "html_url": "https://github.com/rust-lang/rust/commit/092f03a07aa075c6b5cfecc47a8be6e133073819"}], "stats": {"total": 49, "additions": 42, "deletions": 7}, "files": [{"sha": "3a83db3ad6ad54507378c2dfbfd8b052cceb5e85", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 40, "deletions": 5, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/74ce76a00964bc648b3639ea565359e477b7002b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ce76a00964bc648b3639ea565359e477b7002b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=74ce76a00964bc648b3639ea565359e477b7002b", "patch": "@@ -14,7 +14,7 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc::infer::InferCtxt;\n use rustc::mir::{self, Location, Mir, Place, Rvalue, StatementKind, TerminatorKind};\n-use rustc::ty::RegionVid;\n+use rustc::ty::{TyCtxt, RegionVid};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::Diagnostic;\n use std::collections::VecDeque;\n@@ -67,6 +67,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn best_blame_constraint(\n         &self,\n         mir: &Mir<'tcx>,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n         from_region: RegionVid,\n         target_test: impl Fn(RegionVid) -> bool,\n     ) -> (ConstraintCategory, Span, RegionVid) {\n@@ -92,7 +93,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Classify each of the constraints along the path.\n         let mut categorized_path: Vec<(ConstraintCategory, Span)> = path\n             .iter()\n-            .map(|&index| self.classify_constraint(index, mir))\n+            .map(|&index| self.classify_constraint(index, mir, tcx))\n             .collect();\n         debug!(\n             \"best_blame_constraint: categorized_path={:#?}\",\n@@ -231,6 +232,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         index: ConstraintIndex,\n         mir: &Mir<'tcx>,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n     ) -> (ConstraintCategory, Span) {\n         let constraint = self.constraints[index];\n         debug!(\"classify_constraint: constraint={:?}\", constraint);\n@@ -254,7 +256,34 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 debug!(\"classify_constraint: terminator.kind={:?}\", terminator.kind);\n                 match terminator.kind {\n                     TerminatorKind::DropAndReplace { .. } => ConstraintCategory::Assignment,\n-                    TerminatorKind::Call { .. } => ConstraintCategory::CallArgument,\n+                    // Classify calls differently depending on whether or not\n+                    // the sub region appears in the destination type (so the\n+                    // sup region is in the return type). If the return type\n+                    // contains the sub-region, then this is either an\n+                    // assignment or a return, depending on whether we are\n+                    // writing to the RETURN_PLACE or not.\n+                    //\n+                    // The idea here is that the region is being propagated\n+                    // from an input into the output place, so it's a kind of\n+                    // assignment. Otherwise, if the sub-region only appears in\n+                    // the argument types, then use the CallArgument\n+                    // classification.\n+                    TerminatorKind::Call { destination: Some((ref place, _)), .. } => {\n+                        if tcx.any_free_region_meets(\n+                            &place.ty(mir, tcx).to_ty(tcx),\n+                            |region| self.to_region_vid(region) == constraint.sub,\n+                        ) {\n+                            match place {\n+                                Place::Local(mir::RETURN_PLACE) => ConstraintCategory::Return,\n+                                _ => ConstraintCategory::Assignment,\n+                            }\n+                        } else {\n+                            ConstraintCategory::CallArgument\n+                        }\n+                    }\n+                    TerminatorKind::Call { destination: None, .. } => {\n+                        ConstraintCategory::CallArgument\n+                    }\n                     _ => ConstraintCategory::Other,\n                 }\n             } else {\n@@ -304,7 +333,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) {\n         debug!(\"report_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n-        let (category, span, _) = self.best_blame_constraint(mir, fr, |r| r == outlived_fr);\n+        let (category, span, _) = self.best_blame_constraint(\n+            mir,\n+            infcx.tcx,\n+            fr,\n+            |r| r == outlived_fr\n+        );\n \n         // Check if we can use one of the \"nice region errors\".\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n@@ -446,10 +480,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     crate fn find_outlives_blame_span(\n         &self,\n         mir: &Mir<'tcx>,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n         fr1: RegionVid,\n         fr2: RegionVid,\n     ) -> Span {\n-        let (_, span, _) = self.best_blame_constraint(mir, fr1, |r| r == fr2);\n+        let (_, span, _) = self.best_blame_constraint(mir, tcx, fr1, |r| r == fr2);\n         span\n     }\n }"}, {"sha": "ebcc044093a6589ae5344a61fd083dcdd4994977", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74ce76a00964bc648b3639ea565359e477b7002b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ce76a00964bc648b3639ea565359e477b7002b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=74ce76a00964bc648b3639ea565359e477b7002b", "patch": "@@ -1040,7 +1040,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 longer_fr, shorter_fr,\n             );\n \n-            let blame_span = self.find_outlives_blame_span(mir, longer_fr, shorter_fr);\n+            let blame_span = self.find_outlives_blame_span(mir, infcx.tcx, longer_fr, shorter_fr);\n \n             if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n                 // Shrink `fr` until we find a non-local region (if we do).\n@@ -1128,7 +1128,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         };\n \n         // Find the code to blame for the fact that `longer_fr` outlives `error_fr`.\n-        let span = self.find_outlives_blame_span(mir, longer_fr, error_region);\n+        let span = self.find_outlives_blame_span(mir, infcx.tcx, longer_fr, error_region);\n \n         // Obviously, this error message is far from satisfactory.\n         // At present, though, it only appears in unit tests --"}]}