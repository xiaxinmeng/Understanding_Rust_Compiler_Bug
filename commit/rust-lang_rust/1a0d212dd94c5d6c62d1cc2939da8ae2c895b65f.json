{"sha": "1a0d212dd94c5d6c62d1cc2939da8ae2c895b65f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhMGQyMTJkZDk0YzVkNmM2MmQxY2MyOTM5ZGE4YWUyYzg5NWI2NWY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-03-20T17:01:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-03-22T15:49:45Z"}, "message": "Build up the result of fmt! in a buffer instead of a vector", "tree": {"sha": "a0304a11593b116c11095d84f5dd7f9be4ec37cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0304a11593b116c11095d84f5dd7f9be4ec37cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a0d212dd94c5d6c62d1cc2939da8ae2c895b65f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a0d212dd94c5d6c62d1cc2939da8ae2c895b65f", "html_url": "https://github.com/rust-lang/rust/commit/1a0d212dd94c5d6c62d1cc2939da8ae2c895b65f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a0d212dd94c5d6c62d1cc2939da8ae2c895b65f/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d700500d0cc506f34dccdb8379cc1102becfd24f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d700500d0cc506f34dccdb8379cc1102becfd24f", "html_url": "https://github.com/rust-lang/rust/commit/d700500d0cc506f34dccdb8379cc1102becfd24f"}], "stats": {"total": 74, "additions": 44, "deletions": 30}, "files": [{"sha": "c2f4cbf3db2465efc1353449df29c534ff63b8d2", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1a0d212dd94c5d6c62d1cc2939da8ae2c895b65f/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0d212dd94c5d6c62d1cc2939da8ae2c895b65f/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=1a0d212dd94c5d6c62d1cc2939da8ae2c895b65f", "patch": "@@ -108,6 +108,9 @@ pub fn mk_access(cx: @ext_ctxt, sp: span, +p: ~[ast::ident], m: ast::ident)\n pub fn mk_addr_of(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     return mk_expr(cx, sp, ast::expr_addr_of(ast::m_imm, e));\n }\n+pub fn mk_mut_addr_of(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n+    return mk_expr(cx, sp, ast::expr_addr_of(ast::m_mutbl, e));\n+}\n pub fn mk_call_(cx: @ext_ctxt, sp: span, fn_expr: @ast::expr,\n                 +args: ~[@ast::expr]) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_call(fn_expr, args, ast::NoSugar))"}, {"sha": "4c7dd454983dfd7a000d0bd0592b66fa33b5cf6e", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/1a0d212dd94c5d6c62d1cc2939da8ae2c895b65f/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0d212dd94c5d6c62d1cc2939da8ae2c895b65f/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=1a0d212dd94c5d6c62d1cc2939da8ae2c895b65f", "patch": "@@ -221,6 +221,7 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n         }\n     }\n     fn log_conv(c: &Conv) {\n+        debug!(\"Building conversion:\");\n         match c.param {\n           Some(p) => { debug!(\"param: %s\", p.to_str()); }\n           _ => debug!(\"param: none\")\n@@ -268,49 +269,59 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n           TyPoly => debug!(\"type: poly\")\n         }\n     }\n+\n+    /* Translate each piece (portion of the fmt expression) into a ~str\n+       expression to be concatenated below */\n     let fmt_sp = args[0].span;\n     let mut n = 0u;\n-    let mut piece_exprs = ~[];\n     let nargs = args.len();\n-    for pieces.each |pc| {\n-        match *pc {\n-          PieceString(ref s) => {\n-            piece_exprs.push(mk_uniq_str(cx, fmt_sp, copy *s))\n-          }\n-          PieceConv(ref conv) => {\n-            n += 1u;\n-            if n >= nargs {\n-                cx.span_fatal(sp,\n-                              ~\"not enough arguments to fmt! \" +\n+    let pieces = do vec::map_consume(pieces) |pc| {\n+        match pc {\n+            PieceString(s) => mk_uniq_str(cx, fmt_sp, s),\n+            PieceConv(ref conv) => {\n+                n += 1u;\n+                if n >= nargs {\n+                    cx.span_fatal(sp,\n+                                  ~\"not enough arguments to fmt! \" +\n                                   ~\"for the given format string\");\n+                }\n+                log_conv(conv);\n+                make_new_conv(cx, fmt_sp, conv, args[n])\n             }\n-            debug!(\"Building conversion:\");\n-            log_conv(conv);\n-            let arg_expr = args[n];\n-            let c_expr = make_new_conv(\n-                cx,\n-                fmt_sp,\n-                conv,\n-                arg_expr\n-            );\n-            piece_exprs.push(c_expr);\n-          }\n         }\n-    }\n+    };\n     let expected_nargs = n + 1u; // n conversions + the fmt string\n-\n     if expected_nargs < nargs {\n         cx.span_fatal\n             (sp, fmt!(\"too many arguments to fmt!. found %u, expected %u\",\n                            nargs, expected_nargs));\n     }\n \n-    let arg_vec = mk_fixed_vec_e(cx, fmt_sp, piece_exprs);\n-    return mk_call_global(cx,\n-                          fmt_sp,\n-                          ~[cx.parse_sess().interner.intern(@~\"str\"),\n-                            cx.parse_sess().interner.intern(@~\"concat\")],\n-                          ~[arg_vec]);\n+    /* Concatenate all of the strings together with str::push_str. This\n+       involves storing the first piece into a local variable, and then\n+       pushing each other piece onto the local. The local is contained in its\n+       own block to not conflict with other names as much as possible */\n+    let ident = cx.parse_sess().interner.intern(@~\"__fmtbuf\");\n+    let buf = || mk_path(cx, fmt_sp, ~[ident]);\n+    let str_ident = cx.parse_sess().interner.intern(@~\"str\");\n+    let push_ident = cx.parse_sess().interner.intern(@~\"push_str\");\n+\n+    let mut first = true;\n+    let stms = do vec::map_consume(pieces) |pc| {\n+        if first {\n+            first = false;\n+            mk_local(cx, fmt_sp, true, ident, pc)\n+        } else {\n+            let call = mk_call_global(cx,\n+                                      fmt_sp,\n+                                      ~[str_ident, push_ident],\n+                                      ~[mk_mut_addr_of(cx, fmt_sp, buf()),\n+                                        pc]);\n+            mk_stmt(cx, fmt_sp, call)\n+        }\n+    };\n+\n+    return mk_block(cx, fmt_sp, ~[], stms, Some(buf()));\n }\n //\n // Local Variables:"}]}