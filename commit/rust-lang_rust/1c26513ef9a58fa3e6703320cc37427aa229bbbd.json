{"sha": "1c26513ef9a58fa3e6703320cc37427aa229bbbd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjMjY1MTNlZjlhNThmYTNlNjcwMzMyMGNjMzc0MjdhYTIyOWJiYmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-14T15:50:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-14T15:50:50Z"}, "message": "auto merge of #9180 : blake2-ppc/rust/reduce-either, r=catamorphism\n\nWork a bit towards #9157 \"Remove Either\". These instances don't need to use Either and are better expressed in other ways (removing allocations and simplifying types).", "tree": {"sha": "2d769c50c2a442c6f3fd0773fa5106ba51af10f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d769c50c2a442c6f3fd0773fa5106ba51af10f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c26513ef9a58fa3e6703320cc37427aa229bbbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c26513ef9a58fa3e6703320cc37427aa229bbbd", "html_url": "https://github.com/rust-lang/rust/commit/1c26513ef9a58fa3e6703320cc37427aa229bbbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c26513ef9a58fa3e6703320cc37427aa229bbbd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d905f1314d243eb1572588f7e7e98768f8bb711", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d905f1314d243eb1572588f7e7e98768f8bb711", "html_url": "https://github.com/rust-lang/rust/commit/5d905f1314d243eb1572588f7e7e98768f8bb711"}, {"sha": "15c9dc7a86d14f4aba3e23f91af65671aa4b5001", "url": "https://api.github.com/repos/rust-lang/rust/commits/15c9dc7a86d14f4aba3e23f91af65671aa4b5001", "html_url": "https://github.com/rust-lang/rust/commit/15c9dc7a86d14f4aba3e23f91af65671aa4b5001"}], "stats": {"total": 124, "additions": 58, "deletions": 66}, "files": [{"sha": "1658bb5f1614e28c287d9b9bc64d93e62eebf47b", "filename": "src/libextra/test.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1c26513ef9a58fa3e6703320cc37427aa229bbbd/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c26513ef9a58fa3e6703320cc37427aa229bbbd/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=1c26513ef9a58fa3e6703320cc37427aa229bbbd", "patch": "@@ -31,7 +31,6 @@ use treemap::TreeMap;\n use std::clone::Clone;\n use std::comm::{stream, SharedChan, GenericPort, GenericChan};\n use std::libc;\n-use std::either;\n use std::io;\n use std::result;\n use std::task;\n@@ -127,8 +126,8 @@ pub type MetricDiff = TreeMap<~str,MetricChange>;\n pub fn test_main(args: &[~str], tests: ~[TestDescAndFn]) {\n     let opts =\n         match parse_opts(args) {\n-          either::Left(o) => o,\n-          either::Right(m) => fail!(m)\n+            Ok(o) => o,\n+            Err(msg) => fail!(msg)\n         };\n     if !run_tests_console(&opts, tests) { fail!(\"Some tests failed\"); }\n }\n@@ -169,7 +168,7 @@ pub struct TestOpts {\n     logfile: Option<Path>\n }\n \n-type OptRes = Either<TestOpts, ~str>;\n+type OptRes = Result<TestOpts, ~str>;\n \n fn optgroups() -> ~[getopts::groups::OptGroup] {\n     ~[groups::optflag(\"\", \"ignored\", \"Run ignored tests\"),\n@@ -228,7 +227,7 @@ pub fn parse_opts(args: &[~str]) -> OptRes {\n     let matches =\n         match groups::getopts(args_, optgroups()) {\n           Ok(m) => m,\n-          Err(f) => return either::Right(getopts::fail_str(f))\n+          Err(f) => return Err(getopts::fail_str(f))\n         };\n \n     if getopts::opt_present(&matches, \"h\") { usage(args[0], \"h\"); }\n@@ -274,7 +273,7 @@ pub fn parse_opts(args: &[~str]) -> OptRes {\n         logfile: logfile\n     };\n \n-    either::Left(test_opts)\n+    Ok(test_opts)\n }\n \n pub fn opt_shard(maybestr: Option<~str>) -> Option<(uint,uint)> {\n@@ -1155,7 +1154,6 @@ mod tests {\n                StaticTestName, DynTestName, DynTestFn};\n     use test::{TestOpts, run_test};\n \n-    use std::either;\n     use std::comm::{stream, SharedChan};\n     use tempfile;\n     use std::os;\n@@ -1236,8 +1234,8 @@ mod tests {\n     fn first_free_arg_should_be_a_filter() {\n         let args = ~[~\"progname\", ~\"filter\"];\n         let opts = match parse_opts(args) {\n-          either::Left(o) => o,\n-          _ => fail!(\"Malformed arg in first_free_arg_should_be_a_filter\")\n+            Ok(o) => o,\n+            _ => fail!(\"Malformed arg in first_free_arg_should_be_a_filter\")\n         };\n         assert!(\"filter\" == opts.filter.clone().unwrap());\n     }\n@@ -1246,8 +1244,8 @@ mod tests {\n     fn parse_ignored_flag() {\n         let args = ~[~\"progname\", ~\"filter\", ~\"--ignored\"];\n         let opts = match parse_opts(args) {\n-          either::Left(o) => o,\n-          _ => fail!(\"Malformed arg in parse_ignored_flag\")\n+            Ok(o) => o,\n+            _ => fail!(\"Malformed arg in parse_ignored_flag\")\n         };\n         assert!((opts.run_ignored));\n     }"}, {"sha": "aeec4b4258b39084c6d6a136e1743535fbf379a9", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1c26513ef9a58fa3e6703320cc37427aa229bbbd/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c26513ef9a58fa3e6703320cc37427aa229bbbd/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=1c26513ef9a58fa3e6703320cc37427aa229bbbd", "patch": "@@ -19,7 +19,6 @@ use arc::{Arc,RWArc};\n use treemap::TreeMap;\n use std::cell::Cell;\n use std::comm::{PortOne, oneshot};\n-use std::either::{Either, Left, Right};\n use std::{io, os, task};\n \n /**\n@@ -252,9 +251,9 @@ struct Exec {\n     discovered_outputs: WorkMap\n }\n \n-struct Work<'self, T> {\n-    prep: &'self Prep<'self>,\n-    res: Option<Either<T,PortOne<(Exec,T)>>>\n+enum Work<'self, T> {\n+    WorkValue(T),\n+    WorkFromTask(&'self Prep<'self>, PortOne<(Exec, T)>),\n }\n \n fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n@@ -426,15 +425,15 @@ impl<'self> Prep<'self> {\n             db.prepare(self.fn_name, &self.declared_inputs)\n         };\n \n-        let res = match cached {\n+        match cached {\n             Some((ref disc_in, ref disc_out, ref res))\n             if self.all_fresh(\"declared input\",&self.declared_inputs) &&\n                self.all_fresh(\"discovered input\", disc_in) &&\n                self.all_fresh(\"discovered output\", disc_out) => {\n                 debug!(\"Cache hit!\");\n                 debug!(\"Trying to decode: %? / %? / %?\",\n                        disc_in, disc_out, *res);\n-                Left(json_decode(*res))\n+                Work::from_value(json_decode(*res))\n             }\n \n             _ => {\n@@ -453,10 +452,9 @@ impl<'self> Prep<'self> {\n                     let v = blk(&mut exe);\n                     chan.send((exe, v));\n                 }\n-                Right(port)\n+                Work::from_task(self, port)\n             }\n-        };\n-        Work::new(self, res)\n+        }\n     }\n }\n \n@@ -465,16 +463,18 @@ impl<'self, T:Send +\n        Decodable<json::Decoder>>\n     Work<'self, T> { // FIXME(#5121)\n \n-    pub fn new(p: &'self Prep<'self>, e: Either<T,PortOne<(Exec,T)>>) -> Work<'self, T> {\n-        Work { prep: p, res: Some(e) }\n+    pub fn from_value(elt: T) -> Work<'self, T> {\n+        WorkValue(elt)\n+    }\n+    pub fn from_task(prep: &'self Prep<'self>, port: PortOne<(Exec, T)>)\n+        -> Work<'self, T> {\n+        WorkFromTask(prep, port)\n     }\n \n     pub fn unwrap(self) -> T {\n-        let Work { prep, res } = self;\n-        match res {\n-            None => fail!(),\n-            Some(Left(v)) => v,\n-            Some(Right(port)) => {\n+        match self {\n+            WorkValue(v) => v,\n+            WorkFromTask(prep, port) => {\n                 let (exe, v) = port.recv();\n                 let s = json_encode(&v);\n                 do prep.ctxt.db.write |db| {"}, {"sha": "db5edc2009e516353b910b2d9d0962ceae4e5ccb", "filename": "src/libstd/logging.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1c26513ef9a58fa3e6703320cc37427aa229bbbd/src%2Flibstd%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c26513ef9a58fa3e6703320cc37427aa229bbbd/src%2Flibstd%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flogging.rs?ref=1c26513ef9a58fa3e6703320cc37427aa229bbbd", "patch": "@@ -12,9 +12,8 @@\n \n use option::*;\n use os;\n-use either::*;\n use rt;\n-use rt::logging::{Logger, StdErrLogger};\n+use rt::logging::{Logger, StdErrLogger, OwnedString};\n \n /// Turns on logging to stdout globally\n pub fn console_on() {\n@@ -57,12 +56,12 @@ fn newsched_log_str(msg: ~str) {\n         match optional_task {\n             Some(local) => {\n                 // Use the available logger\n-                (*local).logger.log(Left(msg));\n+                (*local).logger.log(OwnedString(msg));\n             }\n             None => {\n                 // There is no logger anywhere, just write to stderr\n                 let mut logger = StdErrLogger;\n-                logger.log(Left(msg));\n+                logger.log(OwnedString(msg));\n             }\n         }\n     }"}, {"sha": "d0bbf5c0506dc0dd5aad85802f85c6521e2c5e2d", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1c26513ef9a58fa3e6703320cc37427aa229bbbd/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c26513ef9a58fa3e6703320cc37427aa229bbbd/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=1c26513ef9a58fa3e6703320cc37427aa229bbbd", "patch": "@@ -7,7 +7,6 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-use either::*;\n use libc::{uintptr_t, exit, STDERR_FILENO};\n use option::{Some, None, Option};\n use rt::util::dumb_println;\n@@ -168,29 +167,32 @@ fn update_log_settings(crate_map: *u8, settings: ~str) {\n     }\n }\n \n+/// Represent a string with `Send` bound.\n+pub enum SendableString {\n+    OwnedString(~str),\n+    StaticString(&'static str)\n+}\n+\n pub trait Logger {\n-    fn log(&mut self, msg: Either<~str, &'static str>);\n+    fn log(&mut self, msg: SendableString);\n }\n \n pub struct StdErrLogger;\n \n impl Logger for StdErrLogger {\n-    fn log(&mut self, msg: Either<~str, &'static str>) {\n+    fn log(&mut self, msg: SendableString) {\n         use io::{Writer, WriterUtil};\n \n         if !should_log_console() {\n             return;\n         }\n \n         let s: &str = match msg {\n-            Left(ref s) => {\n-                let s: &str = *s;\n-                s\n-            }\n-            Right(ref s) => {\n-                let s: &str = *s;\n-                s\n-            }\n+            OwnedString(ref s) => {\n+                let slc: &str = *s;\n+                slc\n+            },\n+            StaticString(s) => s,\n         };\n \n         // Truncate the string"}, {"sha": "f7f7fef6fa09320a7033599c912d5454360f8c80", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1c26513ef9a58fa3e6703320cc37427aa229bbbd/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c26513ef9a58fa3e6703320cc37427aa229bbbd/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=1c26513ef9a58fa3e6703320cc37427aa229bbbd", "patch": "@@ -136,12 +136,11 @@ impl FailWithCause for &'static str {\n \n // FIXME #4427: Temporary until rt::rt_fail_ goes away\n pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n-    use either::Left;\n     use option::{Some, None};\n     use rt::in_green_task_context;\n     use rt::task::Task;\n     use rt::local::Local;\n-    use rt::logging::Logger;\n+    use rt::logging::{Logger, OwnedString};\n     use str::Str;\n \n     unsafe {\n@@ -164,7 +163,7 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n                          msg, file, line as int)\n                 };\n \n-                task.logger.log(Left(msg));\n+                task.logger.log(OwnedString(msg));\n             }\n         } else {\n             rterrln!(\"failed in non-task context at '%s', %s:%i\","}, {"sha": "f05452bb6c504d584ece8c54484ecf5e0fa80940", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1c26513ef9a58fa3e6703320cc37427aa229bbbd/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c26513ef9a58fa3e6703320cc37427aa229bbbd/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1c26513ef9a58fa3e6703320cc37427aa229bbbd", "patch": "@@ -80,8 +80,6 @@ use parse::{new_sub_parser_from_file, ParseSess};\n use opt_vec;\n use opt_vec::OptVec;\n \n-use std::either::Either;\n-use std::either;\n use std::hashmap::HashSet;\n use std::util;\n use std::vec;\n@@ -94,7 +92,6 @@ enum restriction {\n     RESTRICT_NO_BAR_OR_DOUBLEBAR_OP,\n }\n \n-type arg_or_capture_item = Either<arg, ()>;\n type item_info = (Ident, item_, Option<~[Attribute]>);\n \n /// How to parse a path. There are four different kinds of paths, all of which\n@@ -936,7 +933,7 @@ impl Parser {\n             let (explicit_self, d) = do self.parse_fn_decl_with_self() |p| {\n                 // This is somewhat dubious; We don't want to allow argument\n                 // names to be left off if there is a definition...\n-                either::Left(p.parse_arg_general(false))\n+                p.parse_arg_general(false)\n             };\n \n             let hi = p.last_span.hi;\n@@ -1290,12 +1287,12 @@ impl Parser {\n     }\n \n     // parse a single function argument\n-    pub fn parse_arg(&self) -> arg_or_capture_item {\n-        either::Left(self.parse_arg_general(true))\n+    pub fn parse_arg(&self) -> arg {\n+        self.parse_arg_general(true)\n     }\n \n     // parse an argument in a lambda header e.g. |arg, arg|\n-    pub fn parse_fn_block_arg(&self) -> arg_or_capture_item {\n+    pub fn parse_fn_block_arg(&self) -> arg {\n         self.parse_arg_mode();\n         let is_mutbl = self.eat_keyword(keywords::Mut);\n         let pat = self.parse_pat();\n@@ -1308,12 +1305,12 @@ impl Parser {\n                 span: mk_sp(self.span.lo, self.span.hi),\n             }\n         };\n-        either::Left(ast::arg {\n+        ast::arg {\n             is_mutbl: is_mutbl,\n             ty: t,\n             pat: pat,\n             id: ast::DUMMY_NODE_ID\n-        })\n+        }\n     }\n \n     pub fn maybe_parse_fixed_vstore(&self) -> Option<@ast::Expr> {\n@@ -3500,19 +3497,17 @@ impl Parser {\n \n     // parse the argument list and result type of a function declaration\n     pub fn parse_fn_decl(&self) -> fn_decl {\n-        let args_or_capture_items: ~[arg_or_capture_item] =\n+        let args: ~[arg] =\n             self.parse_unspanned_seq(\n                 &token::LPAREN,\n                 &token::RPAREN,\n                 seq_sep_trailing_disallowed(token::COMMA),\n                 |p| p.parse_arg()\n             );\n \n-        let inputs = either::lefts(args_or_capture_items.move_iter()).collect();\n-\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n         ast::fn_decl {\n-            inputs: inputs,\n+            inputs: args,\n             output: ret_ty,\n             cf: ret_style,\n         }\n@@ -3542,7 +3537,7 @@ impl Parser {\n     fn parse_fn_decl_with_self(\n         &self,\n         parse_arg_fn:\n-        &fn(&Parser) -> arg_or_capture_item\n+        &fn(&Parser) -> arg\n     ) -> (explicit_self, fn_decl) {\n         fn maybe_parse_explicit_self(\n             cnstr: &fn(v: Mutability) -> ast::explicit_self_,\n@@ -3650,20 +3645,20 @@ impl Parser {\n         };\n \n         // If we parsed a self type, expect a comma before the argument list.\n-        let args_or_capture_items;\n+        let fn_inputs;\n         if explicit_self != sty_static {\n             match *self.token {\n                 token::COMMA => {\n                     self.bump();\n                     let sep = seq_sep_trailing_disallowed(token::COMMA);\n-                    args_or_capture_items = self.parse_seq_to_before_end(\n+                    fn_inputs = self.parse_seq_to_before_end(\n                         &token::RPAREN,\n                         sep,\n                         parse_arg_fn\n                     );\n                 }\n                 token::RPAREN => {\n-                    args_or_capture_items = ~[];\n+                    fn_inputs = ~[];\n                 }\n                 _ => {\n                     self.fatal(\n@@ -3676,7 +3671,7 @@ impl Parser {\n             }\n         } else {\n             let sep = seq_sep_trailing_disallowed(token::COMMA);\n-            args_or_capture_items = self.parse_seq_to_before_end(\n+            fn_inputs = self.parse_seq_to_before_end(\n                 &token::RPAREN,\n                 sep,\n                 parse_arg_fn\n@@ -3687,11 +3682,10 @@ impl Parser {\n \n         let hi = self.span.hi;\n \n-        let inputs = either::lefts(args_or_capture_items.move_iter()).collect();\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n \n         let fn_decl = ast::fn_decl {\n-            inputs: inputs,\n+            inputs: fn_inputs,\n             output: ret_ty,\n             cf: ret_style\n         };\n@@ -3720,7 +3714,7 @@ impl Parser {\n         };\n \n         ast::fn_decl {\n-            inputs: either::lefts(inputs_captures.move_iter()).collect(),\n+            inputs: inputs_captures,\n             output: output,\n             cf: return_val,\n         }"}]}