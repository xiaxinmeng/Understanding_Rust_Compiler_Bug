{"sha": "97ec6a27ecb9bd643903c343397e69fd2c01d77e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3ZWM2YTI3ZWNiOWJkNjQzOTAzYzM0MzM5N2U2OWZkMmMwMWQ3N2U=", "commit": {"author": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-08-12T10:17:09Z"}, "committer": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-08-12T10:17:09Z"}, "message": "add `make::ext::path_from_idents`", "tree": {"sha": "1b3bc9c7ec75dd0b42352c3b0c1ff17d83845c35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b3bc9c7ec75dd0b42352c3b0c1ff17d83845c35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97ec6a27ecb9bd643903c343397e69fd2c01d77e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97ec6a27ecb9bd643903c343397e69fd2c01d77e", "html_url": "https://github.com/rust-lang/rust/commit/97ec6a27ecb9bd643903c343397e69fd2c01d77e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97ec6a27ecb9bd643903c343397e69fd2c01d77e/comments", "author": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df19895ba6e8429d7ffae03e95c787fd2d2bd6f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/df19895ba6e8429d7ffae03e95c787fd2d2bd6f8", "html_url": "https://github.com/rust-lang/rust/commit/df19895ba6e8429d7ffae03e95c787fd2d2bd6f8"}], "stats": {"total": 61, "additions": 39, "deletions": 22}, "files": [{"sha": "111fa0b23fcf388b94608aeb32409ae5fb117c32", "filename": "crates/ide_assists/src/utils/gen_trait_fn_body.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/97ec6a27ecb9bd643903c343397e69fd2c01d77e/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97ec6a27ecb9bd643903c343397e69fd2c01d77e/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs?ref=97ec6a27ecb9bd643903c343397e69fd2c01d77e", "patch": "@@ -38,7 +38,8 @@ fn gen_clone_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n             let list = enum_.variant_list()?;\n             let mut arms = vec![];\n             for variant in list.variants() {\n-                let variant_name = make_variant_path(&variant)?;\n+                let name = variant.name()?;\n+                let variant_name = make::ext::path_from_idents([\"Self\", &format!(\"{}\", name)])?;\n \n                 match variant.field_list() {\n                     // => match self { Self::Name { x } => Self::Name { x: x.clone() } }\n@@ -148,7 +149,8 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n             let mut arms = vec![];\n             for variant in list.variants() {\n                 let name = variant.name()?;\n-                let variant_name = make::path_pat(make::path_from_text(&format!(\"Self::{}\", name)));\n+                let variant_name =\n+                    make::path_pat(make::ext::path_from_idents([\"Self\", &format!(\"{}\", name)])?);\n \n                 let target = make::expr_path(make::ext::ident_path(\"f\").into());\n                 let fmt_string = make::expr_literal(&(format!(\"\\\"{}\\\"\", name))).into();\n@@ -220,9 +222,9 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n \n /// Generate a `Debug` impl based on the fields and members of the target type.\n fn gen_default_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n-    fn gen_default_call() -> ast::Expr {\n-        let fn_name = make::path_from_text(&\"Default::default\");\n-        make::expr_call(make::expr_path(fn_name), make::arg_list(None))\n+    fn gen_default_call() -> Option<ast::Expr> {\n+        let fn_name = make::ext::path_from_idents([\"Default\", \"default\"])?;\n+        Some(make::expr_call(make::expr_path(fn_name), make::arg_list(None)))\n     }\n     match adt {\n         // `Debug` cannot be derived for unions, so no default impl can be provided.\n@@ -234,7 +236,7 @@ fn gen_default_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                 Some(ast::FieldList::RecordFieldList(field_list)) => {\n                     let mut fields = vec![];\n                     for field in field_list.fields() {\n-                        let method_call = gen_default_call();\n+                        let method_call = gen_default_call()?;\n                         let name_ref = make::name_ref(&field.name()?.to_string());\n                         let field = make::record_expr_field(name_ref, Some(method_call));\n                         fields.push(field);\n@@ -245,7 +247,10 @@ fn gen_default_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                 }\n                 Some(ast::FieldList::TupleFieldList(field_list)) => {\n                     let struct_name = make::expr_path(make::ext::ident_path(\"Self\"));\n-                    let fields = field_list.fields().map(|_| gen_default_call());\n+                    let fields = field_list\n+                        .fields()\n+                        .map(|_| gen_default_call())\n+                        .collect::<Option<Vec<ast::Expr>>>()?;\n                     make::expr_call(struct_name, make::arg_list(fields))\n                 }\n                 None => {\n@@ -276,7 +281,7 @@ fn gen_hash_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n \n         // => std::mem::discriminant(self).hash(state);\n         ast::Adt::Enum(_) => {\n-            let fn_name = make_discriminant();\n+            let fn_name = make_discriminant()?;\n \n             let arg = make::expr_path(make::ext::ident_path(\"self\"));\n             let fn_call = make::expr_call(fn_name, make::arg_list(Some(arg)));\n@@ -336,6 +341,10 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n         make::record_pat_with_fields(record_name, list)\n     }\n \n+    fn gen_variant_path(variant: &ast::Variant) -> Option<ast::Path> {\n+        make::ext::path_from_idents([\"Self\", &variant.name()?.to_string()])\n+    }\n+\n     fn gen_tuple_field(field_name: &String) -> ast::Pat {\n         ast::Pat::IdentPat(make::ident_pat(false, false, make::name(field_name)))\n     }\n@@ -344,15 +353,15 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n     // generate this code `Self` for the time being.\n \n     let body = match adt {\n-        // `PartialEq` cannot be derived for unions, so no default impl can be provided.\n+        // `Hash` cannot be derived for unions, so no default impl can be provided.\n         ast::Adt::Union(_) => return None,\n \n         ast::Adt::Enum(enum_) => {\n             // => std::mem::discriminant(self) == std::mem::discriminant(other)\n             let lhs_name = make::expr_path(make::ext::ident_path(\"self\"));\n-            let lhs = make::expr_call(make_discriminant(), make::arg_list(Some(lhs_name.clone())));\n+            let lhs = make::expr_call(make_discriminant()?, make::arg_list(Some(lhs_name.clone())));\n             let rhs_name = make::expr_path(make::ext::ident_path(\"other\"));\n-            let rhs = make::expr_call(make_discriminant(), make::arg_list(Some(rhs_name.clone())));\n+            let rhs = make::expr_call(make_discriminant()?, make::arg_list(Some(rhs_name.clone())));\n             let eq_check = make::expr_op(ast::BinOp::EqualityTest, lhs, rhs);\n \n             let mut case_count = 0;\n@@ -381,8 +390,8 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                             expr = gen_eq_chain(expr, cmp);\n                         }\n \n-                        let left = gen_record_pat(make_variant_path(&variant)?, l_fields);\n-                        let right = gen_record_pat(make_variant_path(&variant)?, r_fields);\n+                        let left = gen_record_pat(gen_variant_path(&variant)?, l_fields);\n+                        let right = gen_record_pat(gen_variant_path(&variant)?, r_fields);\n                         let tuple = make::tuple_pat(vec![left.into(), right.into()]);\n \n                         if let Some(expr) = expr {\n@@ -410,8 +419,8 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                             expr = gen_eq_chain(expr, cmp);\n                         }\n \n-                        let left = make::tuple_struct_pat(make_variant_path(&variant)?, l_fields);\n-                        let right = make::tuple_struct_pat(make_variant_path(&variant)?, r_fields);\n+                        let left = make::tuple_struct_pat(gen_variant_path(&variant)?, l_fields);\n+                        let right = make::tuple_struct_pat(gen_variant_path(&variant)?, r_fields);\n                         let tuple = make::tuple_pat(vec![left.into(), right.into()]);\n \n                         if let Some(expr) = expr {\n@@ -466,7 +475,7 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                 make::block_expr(None, expr).indent(ast::edit::IndentLevel(1))\n             }\n \n-            // No fields in the body means there's nothing to compare.\n+            // No fields in the body means there's nothing to hash.\n             None => {\n                 let expr = make::expr_literal(\"true\").into();\n                 make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1))\n@@ -478,10 +487,6 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n     Some(())\n }\n \n-fn make_discriminant() -> ast::Expr {\n-    make::expr_path(make::path_from_text(\"core::mem::discriminant\"))\n-}\n-\n-fn make_variant_path(variant: &ast::Variant) -> Option<ast::Path> {\n-    Some(make::path_from_text(&format!(\"Self::{}\", &variant.name()?)))\n+fn make_discriminant() -> Option<ast::Expr> {\n+    Some(make::expr_path(make::ext::path_from_idents([\"core\", \"mem\", \"discriminant\"])?))\n }"}, {"sha": "e6fab72ac0526d984d5aaf3ec55e73e57077cad7", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/97ec6a27ecb9bd643903c343397e69fd2c01d77e/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97ec6a27ecb9bd643903c343397e69fd2c01d77e/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=97ec6a27ecb9bd643903c343397e69fd2c01d77e", "patch": "@@ -32,6 +32,18 @@ pub mod ext {\n         path_unqualified(path_segment(name_ref(ident)))\n     }\n \n+    pub fn path_from_idents<'a>(\n+        parts: impl std::iter::IntoIterator<Item = &'a str>,\n+    ) -> Option<ast::Path> {\n+        let mut iter = parts.into_iter();\n+        let base = ext::ident_path(iter.next()?);\n+        let path = iter.fold(base, |base, s| {\n+            let path = ext::ident_path(s);\n+            path_concat(base, path)\n+        });\n+        Some(path)\n+    }\n+\n     pub fn expr_unreachable() -> ast::Expr {\n         expr_from_text(\"unreachable!()\")\n     }"}]}