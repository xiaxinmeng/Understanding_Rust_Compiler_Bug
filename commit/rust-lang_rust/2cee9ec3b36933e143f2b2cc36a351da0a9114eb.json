{"sha": "2cee9ec3b36933e143f2b2cc36a351da0a9114eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjZWU5ZWMzYjM2OTMzZTE0M2YyYjJjYzM2YTM1MWRhMGE5MTE0ZWI=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-17T23:14:09Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-17T23:40:15Z"}, "message": "Ensure that macro invocations are folded and visited the same order.", "tree": {"sha": "fd71a428e868abd931dd70ee8b91cbfb23a7ed79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd71a428e868abd931dd70ee8b91cbfb23a7ed79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2cee9ec3b36933e143f2b2cc36a351da0a9114eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2cee9ec3b36933e143f2b2cc36a351da0a9114eb", "html_url": "https://github.com/rust-lang/rust/commit/2cee9ec3b36933e143f2b2cc36a351da0a9114eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2cee9ec3b36933e143f2b2cc36a351da0a9114eb/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb62f4d544c954d355716dca8beb55726036721e", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb62f4d544c954d355716dca8beb55726036721e", "html_url": "https://github.com/rust-lang/rust/commit/fb62f4d544c954d355716dca8beb55726036721e"}], "stats": {"total": 94, "additions": 36, "deletions": 58}, "files": [{"sha": "36f273e1dbc299f3c6c31773578ee050307f6649", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 31, "deletions": 53, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/2cee9ec3b36933e143f2b2cc36a351da0a9114eb/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cee9ec3b36933e143f2b2cc36a351da0a9114eb/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=2cee9ec3b36933e143f2b2cc36a351da0a9114eb", "patch": "@@ -478,8 +478,8 @@ pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedPara\n pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n     l.map(|Local {id, pat, ty, init, span, attrs}| Local {\n         id: fld.new_id(id),\n-        ty: ty.map(|t| fld.fold_ty(t)),\n         pat: fld.fold_pat(pat),\n+        ty: ty.map(|t| fld.fold_ty(t)),\n         init: init.map(|e| fld.fold_expr(e)),\n         span: fld.new_span(span),\n         attrs: fold_attrs(attrs.into(), fld).into(),\n@@ -860,65 +860,46 @@ pub fn noop_fold_item_kind<T: Folder>(i: ItemKind, folder: &mut T) -> ItemKind {\n             ItemKind::Const(folder.fold_ty(t), folder.fold_expr(e))\n         }\n         ItemKind::Fn(decl, unsafety, constness, abi, generics, body) => {\n-            ItemKind::Fn(\n-                folder.fold_fn_decl(decl),\n-                unsafety,\n-                constness,\n-                abi,\n-                folder.fold_generics(generics),\n-                folder.fold_block(body)\n-            )\n+            let generics = folder.fold_generics(generics);\n+            let decl = folder.fold_fn_decl(decl);\n+            let body = folder.fold_block(body);\n+            ItemKind::Fn(decl, unsafety, constness, abi, generics, body)\n         }\n         ItemKind::Mod(m) => ItemKind::Mod(folder.fold_mod(m)),\n         ItemKind::ForeignMod(nm) => ItemKind::ForeignMod(folder.fold_foreign_mod(nm)),\n         ItemKind::Ty(t, generics) => {\n             ItemKind::Ty(folder.fold_ty(t), folder.fold_generics(generics))\n         }\n         ItemKind::Enum(enum_definition, generics) => {\n-            ItemKind::Enum(\n-                ast::EnumDef {\n-                    variants: enum_definition.variants.move_map(|x| folder.fold_variant(x)),\n-                },\n-                folder.fold_generics(generics))\n+            let generics = folder.fold_generics(generics);\n+            let variants = enum_definition.variants.move_map(|x| folder.fold_variant(x));\n+            ItemKind::Enum(ast::EnumDef { variants: variants }, generics)\n         }\n         ItemKind::Struct(struct_def, generics) => {\n-            let struct_def = folder.fold_variant_data(struct_def);\n-            ItemKind::Struct(struct_def, folder.fold_generics(generics))\n+            let generics = folder.fold_generics(generics);\n+            ItemKind::Struct(folder.fold_variant_data(struct_def), generics)\n         }\n         ItemKind::Union(struct_def, generics) => {\n-            let struct_def = folder.fold_variant_data(struct_def);\n-            ItemKind::Union(struct_def, folder.fold_generics(generics))\n+            let generics = folder.fold_generics(generics);\n+            ItemKind::Union(folder.fold_variant_data(struct_def), generics)\n         }\n         ItemKind::DefaultImpl(unsafety, ref trait_ref) => {\n             ItemKind::DefaultImpl(unsafety, folder.fold_trait_ref((*trait_ref).clone()))\n         }\n-        ItemKind::Impl(unsafety, polarity, generics, ifce, ty, impl_items) => {\n-            let new_impl_items = impl_items.move_flat_map(|item| {\n-                folder.fold_impl_item(item)\n-            });\n-            let ifce = match ifce {\n-                None => None,\n-                Some(ref trait_ref) => {\n-                    Some(folder.fold_trait_ref((*trait_ref).clone()))\n-                }\n-            };\n-            ItemKind::Impl(unsafety,\n-                     polarity,\n-                     folder.fold_generics(generics),\n-                     ifce,\n-                     folder.fold_ty(ty),\n-                     new_impl_items)\n-        }\n-        ItemKind::Trait(unsafety, generics, bounds, items) => {\n-            let bounds = folder.fold_bounds(bounds);\n-            let items = items.move_flat_map(|item| {\n-                folder.fold_trait_item(item)\n-            });\n-            ItemKind::Trait(unsafety,\n-                      folder.fold_generics(generics),\n-                      bounds,\n-                      items)\n-        }\n+        ItemKind::Impl(unsafety, polarity, generics, ifce, ty, impl_items) => ItemKind::Impl(\n+            unsafety,\n+            polarity,\n+            folder.fold_generics(generics),\n+            ifce.map(|trait_ref| folder.fold_trait_ref(trait_ref.clone())),\n+            folder.fold_ty(ty),\n+            impl_items.move_flat_map(|item| folder.fold_impl_item(item)),\n+        ),\n+        ItemKind::Trait(unsafety, generics, bounds, items) => ItemKind::Trait(\n+            unsafety,\n+            folder.fold_generics(generics),\n+            folder.fold_bounds(bounds),\n+            items.move_flat_map(|item| folder.fold_trait_item(item)),\n+        ),\n         ItemKind::Mac(m) => ItemKind::Mac(folder.fold_mac(m)),\n     }\n }\n@@ -954,9 +935,9 @@ pub fn noop_fold_impl_item<T: Folder>(i: ImplItem, folder: &mut T)\n                                       -> SmallVector<ImplItem> {\n     SmallVector::one(ImplItem {\n         id: folder.new_id(i.id),\n+        vis: folder.fold_vis(i.vis),\n         ident: folder.fold_ident(i.ident),\n         attrs: fold_attrs(i.attrs, folder),\n-        vis: folder.fold_vis(i.vis),\n         defaultness: i.defaultness,\n         node: match i.node  {\n             ast::ImplItemKind::Const(ty, expr) => {\n@@ -1031,22 +1012,20 @@ pub fn noop_fold_item<T: Folder>(i: P<Item>, folder: &mut T) -> SmallVector<P<It\n // fold one item into exactly one item\n pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span}: Item,\n                                         folder: &mut T) -> Item {\n-    let id = folder.new_id(id);\n-    let node = folder.fold_item_kind(node);\n-\n     Item {\n-        id: id,\n+        id: folder.new_id(id),\n+        vis: folder.fold_vis(vis),\n         ident: folder.fold_ident(ident),\n         attrs: fold_attrs(attrs, folder),\n-        node: node,\n-        vis: folder.fold_vis(vis),\n+        node: folder.fold_item_kind(node),\n         span: folder.new_span(span)\n     }\n }\n \n pub fn noop_fold_foreign_item<T: Folder>(ni: ForeignItem, folder: &mut T) -> ForeignItem {\n     ForeignItem {\n         id: folder.new_id(ni.id),\n+        vis: folder.fold_vis(ni.vis),\n         ident: folder.fold_ident(ni.ident),\n         attrs: fold_attrs(ni.attrs, folder),\n         node: match ni.node {\n@@ -1057,7 +1036,6 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: ForeignItem, folder: &mut T) -> For\n                 ForeignItemKind::Static(folder.fold_ty(t), m)\n             }\n         },\n-        vis: folder.fold_vis(ni.vis),\n         span: folder.new_span(ni.span)\n     }\n }"}, {"sha": "57b06c40878fe9dcea3adc3c7486a9a0f4c6a018", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2cee9ec3b36933e143f2b2cc36a351da0a9114eb/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cee9ec3b36933e143f2b2cc36a351da0a9114eb/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=2cee9ec3b36933e143f2b2cc36a351da0a9114eb", "patch": "@@ -532,8 +532,8 @@ pub fn walk_fn_kind<V: Visitor>(visitor: &mut V, function_kind: FnKind) {\n pub fn walk_fn<V>(visitor: &mut V, kind: FnKind, declaration: &FnDecl, body: &Block, _span: Span)\n     where V: Visitor,\n {\n-    walk_fn_decl(visitor, declaration);\n     walk_fn_kind(visitor, kind);\n+    walk_fn_decl(visitor, declaration);\n     visitor.visit_block(body)\n }\n \n@@ -652,13 +652,13 @@ pub fn walk_expr<V: Visitor>(visitor: &mut V, expression: &Expr) {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n         ExprKind::Call(ref callee_expression, ref arguments) => {\n+            visitor.visit_expr(callee_expression);\n             walk_list!(visitor, visit_expr, arguments);\n-            visitor.visit_expr(callee_expression)\n         }\n         ExprKind::MethodCall(ref ident, ref types, ref arguments) => {\n             visitor.visit_ident(ident.span, ident.node);\n-            walk_list!(visitor, visit_expr, arguments);\n             walk_list!(visitor, visit_ty, types);\n+            walk_list!(visitor, visit_expr, arguments);\n         }\n         ExprKind::Binary(_, ref left_expression, ref right_expression) => {\n             visitor.visit_expr(left_expression);\n@@ -717,12 +717,12 @@ pub fn walk_expr<V: Visitor>(visitor: &mut V, expression: &Expr) {\n         }\n         ExprKind::Block(ref block) => visitor.visit_block(block),\n         ExprKind::Assign(ref left_hand_expression, ref right_hand_expression) => {\n+            visitor.visit_expr(left_hand_expression);\n             visitor.visit_expr(right_hand_expression);\n-            visitor.visit_expr(left_hand_expression)\n         }\n         ExprKind::AssignOp(_, ref left_expression, ref right_expression) => {\n+            visitor.visit_expr(left_expression);\n             visitor.visit_expr(right_expression);\n-            visitor.visit_expr(left_expression)\n         }\n         ExprKind::Field(ref subexpression, ref ident) => {\n             visitor.visit_expr(subexpression);"}]}