{"sha": "e2f79572fbcbe103346c950d95d7335f6c804d83", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyZjc5NTcyZmJjYmUxMDMzNDZjOTUwZDk1ZDczMzVmNmM4MDRkODM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-05T22:13:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-05T22:13:32Z"}, "message": "Auto merge of #84176 - GuillaumeGomez:src-to-definition, r=jyn514\n\nGenerate links to definition in rustdoc source code pages\n\n## Description\n\nThis PR adds an option (disabled by default) to add links in the source code page on ident. So for for example:\n\n```rust\nmod other_module;\nstruct Foo;\nfn bar() {}\n\nfn x<T: other_module::Trait>(f: Foo, g: other_module::Whatever, t: &T) {\n    let f: Foo = Foo;\n    bar();\n    f.some_method();\n}\n```\n\nIn the example (mostly in the `x` function), `other_module::Trait`, `Foo`, `other_module::Whatever`, `bar` and `some_method` are now links (and `other_module` at the top too).\n\nIn case there is a type coming from another crate, it'll link to its documentation page and not its definition (but you can then click on `[src]` so I guess it's fine).\n\nAnother important detail: I voluntarily didn't add links for primitive types. I think we can discuss about adding links on them or not in a later PR (adding the support for them would require only a few lines).\n\nHere is a video summing up everything I wrote above:\n\nhttps://user-images.githubusercontent.com/3050060/114622354-21307b00-9cae-11eb-834d-f6d8178a37bd.mp4\n\n## Performance impact\n\nSo, on my computer, the performance remains more or less the same (which is quite surprising but that's a nice surprise). Here are the numbers:\n\nWithout the option:\n * core:  1m 21s\n * alloc: 26.78s\n * std: 27.30s\n * proc_macro: 4.50s\n\nWith source to definition links generation (I enabled by default the option):\n * core: 1m 25s\n * alloc: 25.76s\n * std: 27.07s\n * proc_macro: 4.66s\n\nSo no real change here (again, I'm very surprised by this fact).\n\nFor the size of the generated source files (only taking into account the `src` folder here since it's the only one impacted) by running `du -shc .` (when I am in the source folder).\n\nWithout the option: 11.939 MB\nWith the option: 12.611 MB\n\nSo not a big change here either. In all those docs, I ran `grep -nR '<a class=' . | wc -l` and got 43917. So there are quite a lot of links added. :)\n\ncc `@rust-lang/rustdoc`\nr? `@jyn514`", "tree": {"sha": "ef82f17d038e8def55e8012ed214619cb686ccbd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef82f17d038e8def55e8012ed214619cb686ccbd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2f79572fbcbe103346c950d95d7335f6c804d83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2f79572fbcbe103346c950d95d7335f6c804d83", "html_url": "https://github.com/rust-lang/rust/commit/e2f79572fbcbe103346c950d95d7335f6c804d83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2f79572fbcbe103346c950d95d7335f6c804d83/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f07ae408fce782bf1058e3de808f1b6f9ab60a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f07ae408fce782bf1058e3de808f1b6f9ab60a4", "html_url": "https://github.com/rust-lang/rust/commit/2f07ae408fce782bf1058e3de808f1b6f9ab60a4"}, {"sha": "ba11dc7fddd58eb3559d0724e8ced0d2c2128f4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba11dc7fddd58eb3559d0724e8ced0d2c2128f4a", "html_url": "https://github.com/rust-lang/rust/commit/ba11dc7fddd58eb3559d0724e8ced0d2c2128f4a"}], "stats": {"total": 838, "additions": 707, "deletions": 131}, "files": [{"sha": "fc0924ac5f920540e5e596e619362d347530f058", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -342,6 +342,9 @@ struct HandlerInner {\n     deduplicated_warn_count: usize,\n \n     future_breakage_diagnostics: Vec<Diagnostic>,\n+\n+    /// If set to `true`, no warning or error will be emitted.\n+    quiet: bool,\n }\n \n /// A key denoting where from a diagnostic was stashed.\n@@ -456,10 +459,19 @@ impl Handler {\n                 emitted_diagnostics: Default::default(),\n                 stashed_diagnostics: Default::default(),\n                 future_breakage_diagnostics: Vec::new(),\n+                quiet: false,\n             }),\n         }\n     }\n \n+    pub fn with_disabled_diagnostic<T, F: FnOnce() -> T>(&self, f: F) -> T {\n+        let prev = self.inner.borrow_mut().quiet;\n+        self.inner.borrow_mut().quiet = true;\n+        let ret = f();\n+        self.inner.borrow_mut().quiet = prev;\n+        ret\n+    }\n+\n     // This is here to not allow mutation of flags;\n     // as of this writing it's only used in tests in librustc_middle.\n     pub fn can_emit_warnings(&self) -> bool {\n@@ -818,7 +830,7 @@ impl HandlerInner {\n     }\n \n     fn emit_diagnostic(&mut self, diagnostic: &Diagnostic) {\n-        if diagnostic.cancelled() {\n+        if diagnostic.cancelled() || self.quiet {\n             return;\n         }\n \n@@ -1035,6 +1047,9 @@ impl HandlerInner {\n     }\n \n     fn delay_as_bug(&mut self, diagnostic: Diagnostic) {\n+        if self.quiet {\n+            return;\n+        }\n         if self.flags.report_delayed_bugs {\n             self.emit_diagnostic(&diagnostic);\n         }"}, {"sha": "fe87867d2996cdf210798ee0624baf24b513c87c", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -500,6 +500,10 @@ impl Session {\n         &self.parse_sess.span_diagnostic\n     }\n \n+    pub fn with_disabled_diagnostic<T, F: FnOnce() -> T>(&self, f: F) -> T {\n+        self.parse_sess.span_diagnostic.with_disabled_diagnostic(f)\n+    }\n+\n     /// Analogous to calling methods on the given `DiagnosticBuilder`, but\n     /// deduplicates on lint ID, span (if any), and message for this `Session`\n     fn diag_once<'a, 'b>("}, {"sha": "207c89cbfe87e7d2386e2ec254bd3e8c785860c1", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -98,7 +98,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                     visibility: Inherited,\n                     def_id: ItemId::Blanket { impl_id: impl_def_id, for_: item_def_id },\n                     kind: box ImplItem(Impl {\n-                        span: Span::from_rustc_span(self.cx.tcx.def_span(impl_def_id)),\n+                        span: Span::new(self.cx.tcx.def_span(impl_def_id)),\n                         unsafety: hir::Unsafety::Normal,\n                         generics: (\n                             self.cx.tcx.generics_of(impl_def_id),"}, {"sha": "43979423ae615822a01763363820ba07c98153aa", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -517,7 +517,7 @@ fn build_module(\n         }\n     }\n \n-    let span = clean::Span::from_rustc_span(cx.tcx.def_span(did));\n+    let span = clean::Span::new(cx.tcx.def_span(did));\n     clean::Module { items, span }\n }\n "}, {"sha": "3d65fcedaf4e53470d7c6b502195b8be01e2756f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -95,7 +95,8 @@ impl Clean<Item> for doctree::Module<'_> {\n \n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n-        let span = Span::from_rustc_span({\n+\n+        let span = Span::new({\n             let where_outer = self.where_outer(cx.tcx);\n             let sm = cx.sess().source_map();\n             let outer = sm.lookup_char_pos(where_outer.lo());"}, {"sha": "22e4d21c87bdf0405594ec2c0030b3e91da844c2", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -343,7 +343,7 @@ crate struct Item {\n rustc_data_structures::static_assert_size!(Item, 56);\n \n crate fn rustc_span(def_id: DefId, tcx: TyCtxt<'_>) -> Span {\n-    Span::from_rustc_span(def_id.as_local().map_or_else(\n+    Span::new(def_id.as_local().map_or_else(\n         || tcx.def_span(def_id),\n         |local| {\n             let hir = tcx.hir();\n@@ -1943,10 +1943,11 @@ crate enum Variant {\n crate struct Span(rustc_span::Span);\n \n impl Span {\n-    crate fn from_rustc_span(sp: rustc_span::Span) -> Self {\n-        // Get the macro invocation instead of the definition,\n-        // in case the span is result of a macro expansion.\n-        // (See rust-lang/rust#39726)\n+    /// Wraps a [`rustc_span::Span`]. In case this span is the result of a macro expansion, the\n+    /// span will be updated to point to the macro invocation instead of the macro definition.\n+    ///\n+    /// (See rust-lang/rust#39726)\n+    crate fn new(sp: rustc_span::Span) -> Self {\n         Self(sp.source_callsite())\n     }\n "}, {"sha": "e44158bc042308da91fec47203100a9fc539f1a3", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -276,6 +276,8 @@ crate struct RenderOptions {\n     crate show_type_layout: bool,\n     crate unstable_features: rustc_feature::UnstableFeatures,\n     crate emit: Vec<EmitType>,\n+    /// If `true`, HTML source pages will generate links for items to their definition.\n+    crate generate_link_to_definition: bool,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -655,6 +657,15 @@ impl Options {\n         let generate_redirect_map = matches.opt_present(\"generate-redirect-map\");\n         let show_type_layout = matches.opt_present(\"show-type-layout\");\n         let nocapture = matches.opt_present(\"nocapture\");\n+        let generate_link_to_definition = matches.opt_present(\"generate-link-to-definition\");\n+\n+        if generate_link_to_definition && (show_coverage || output_format != OutputFormat::Html) {\n+            diag.struct_err(\n+                \"--generate-link-to-definition option can only be used with HTML output format\",\n+            )\n+            .emit();\n+            return Err(1);\n+        }\n \n         let (lint_opts, describe_lints, lint_cap) =\n             get_cmd_lint_options(matches, error_format, &debugging_opts);\n@@ -721,6 +732,7 @@ impl Options {\n                     crate_name.as_deref(),\n                 ),\n                 emit,\n+                generate_link_to_definition,\n             },\n             crate_name,\n             output_format,"}, {"sha": "eb7c12d13c339029bacf8566c62837f88dae3071", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -484,7 +484,11 @@ crate enum HrefError {\n     NotInExternalCache,\n }\n \n-crate fn href(did: DefId, cx: &Context<'_>) -> Result<(String, ItemType, Vec<String>), HrefError> {\n+crate fn href_with_root_path(\n+    did: DefId,\n+    cx: &Context<'_>,\n+    root_path: Option<&str>,\n+) -> Result<(String, ItemType, Vec<String>), HrefError> {\n     let cache = &cx.cache();\n     let relative_to = &cx.current;\n     fn to_module_fqp(shortty: ItemType, fqp: &[String]) -> &[String] {\n@@ -495,6 +499,7 @@ crate fn href(did: DefId, cx: &Context<'_>) -> Result<(String, ItemType, Vec<Str\n         return Err(HrefError::Private);\n     }\n \n+    let mut is_remote = false;\n     let (fqp, shortty, mut url_parts) = match cache.paths.get(&did) {\n         Some(&(ref fqp, shortty)) => (fqp, shortty, {\n             let module_fqp = to_module_fqp(shortty, fqp);\n@@ -508,6 +513,7 @@ crate fn href(did: DefId, cx: &Context<'_>) -> Result<(String, ItemType, Vec<Str\n                     shortty,\n                     match cache.extern_locations[&did.krate] {\n                         ExternalLocation::Remote(ref s) => {\n+                            is_remote = true;\n                             let s = s.trim_end_matches('/');\n                             let mut s = vec![s];\n                             s.extend(module_fqp[..].iter().map(String::as_str));\n@@ -522,6 +528,12 @@ crate fn href(did: DefId, cx: &Context<'_>) -> Result<(String, ItemType, Vec<Str\n             }\n         }\n     };\n+    if !is_remote {\n+        if let Some(root_path) = root_path {\n+            let root = root_path.trim_end_matches('/');\n+            url_parts.insert(0, root);\n+        }\n+    }\n     let last = &fqp.last().unwrap()[..];\n     let filename;\n     match shortty {\n@@ -536,6 +548,10 @@ crate fn href(did: DefId, cx: &Context<'_>) -> Result<(String, ItemType, Vec<Str\n     Ok((url_parts.join(\"/\"), shortty, fqp.to_vec()))\n }\n \n+crate fn href(did: DefId, cx: &Context<'_>) -> Result<(String, ItemType, Vec<String>), HrefError> {\n+    href_with_root_path(did, cx, None)\n+}\n+\n /// Both paths should only be modules.\n /// This is because modules get their own directories; that is, `std::vec` and `std::vec::Vec` will\n /// both need `../iter/trait.Iterator.html` to get at the iterator trait."}, {"sha": "3cdb1352bef956045502b1d557e4d49ffe2c7209", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 185, "deletions": 47, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -6,15 +6,28 @@\n //! Use the `render_with_highlighting` to highlight some rust code.\n \n use crate::html::escape::Escape;\n+use crate::html::render::Context;\n \n-use std::fmt::Display;\n+use std::fmt::{Display, Write};\n use std::iter::Peekable;\n \n use rustc_lexer::{LiteralKind, TokenKind};\n use rustc_span::edition::Edition;\n use rustc_span::symbol::Symbol;\n-\n-use super::format::Buffer;\n+use rustc_span::{BytePos, Span, DUMMY_SP};\n+\n+use super::format::{self, Buffer};\n+use super::render::LinkFromSrc;\n+\n+/// This type is needed in case we want to render links on items to allow to go to their definition.\n+crate struct ContextInfo<'a, 'b, 'c> {\n+    crate context: &'a Context<'b>,\n+    /// This span contains the current file we're going through.\n+    crate file_span: Span,\n+    /// This field is used to know \"how far\" from the top of the directory we are to link to either\n+    /// documentation pages or other source pages.\n+    crate root_path: &'c str,\n+}\n \n /// Highlights `src`, returning the HTML output.\n crate fn render_with_highlighting(\n@@ -25,6 +38,7 @@ crate fn render_with_highlighting(\n     tooltip: Option<(Option<Edition>, &str)>,\n     edition: Edition,\n     extra_content: Option<Buffer>,\n+    context_info: Option<ContextInfo<'_, '_, '_>>,\n ) {\n     debug!(\"highlighting: ================\\n{}\\n==============\", src);\n     if let Some((edition_info, class)) = tooltip {\n@@ -41,7 +55,7 @@ crate fn render_with_highlighting(\n     }\n \n     write_header(out, class, extra_content);\n-    write_code(out, &src, edition);\n+    write_code(out, &src, edition, context_info);\n     write_footer(out, playground_button);\n }\n \n@@ -57,16 +71,33 @@ fn write_header(out: &mut Buffer, class: Option<&str>, extra_content: Option<Buf\n     }\n }\n \n-fn write_code(out: &mut Buffer, src: &str, edition: Edition) {\n+/// Convert the given `src` source code into HTML by adding classes for highlighting.\n+///\n+/// This code is used to render code blocks (in the documentation) as well as the source code pages.\n+///\n+/// Some explanations on the last arguments:\n+///\n+/// In case we are rendering a code block and not a source code file, `context_info` will be `None`.\n+/// To put it more simply: if `context_info` is `None`, the code won't try to generate links to an\n+/// item definition.\n+///\n+/// More explanations about spans and how we use them here are provided in the\n+fn write_code(\n+    out: &mut Buffer,\n+    src: &str,\n+    edition: Edition,\n+    context_info: Option<ContextInfo<'_, '_, '_>>,\n+) {\n     // This replace allows to fix how the code source with DOS backline characters is displayed.\n     let src = src.replace(\"\\r\\n\", \"\\n\");\n-    Classifier::new(&src, edition).highlight(&mut |highlight| {\n-        match highlight {\n-            Highlight::Token { text, class } => string(out, Escape(text), class),\n-            Highlight::EnterSpan { class } => enter_span(out, class),\n-            Highlight::ExitSpan => exit_span(out),\n-        };\n-    });\n+    Classifier::new(&src, edition, context_info.as_ref().map(|c| c.file_span).unwrap_or(DUMMY_SP))\n+        .highlight(&mut |highlight| {\n+            match highlight {\n+                Highlight::Token { text, class } => string(out, Escape(text), class, &context_info),\n+                Highlight::EnterSpan { class } => enter_span(out, class),\n+                Highlight::ExitSpan => exit_span(out),\n+            };\n+        });\n }\n \n fn write_footer(out: &mut Buffer, playground_button: Option<&str>) {\n@@ -82,14 +113,14 @@ enum Class {\n     KeyWord,\n     // Keywords that do pointer/reference stuff.\n     RefKeyWord,\n-    Self_,\n+    Self_(Span),\n     Op,\n     Macro,\n     MacroNonTerminal,\n     String,\n     Number,\n     Bool,\n-    Ident,\n+    Ident(Span),\n     Lifetime,\n     PreludeTy,\n     PreludeVal,\n@@ -105,20 +136,29 @@ impl Class {\n             Class::Attribute => \"attribute\",\n             Class::KeyWord => \"kw\",\n             Class::RefKeyWord => \"kw-2\",\n-            Class::Self_ => \"self\",\n+            Class::Self_(_) => \"self\",\n             Class::Op => \"op\",\n             Class::Macro => \"macro\",\n             Class::MacroNonTerminal => \"macro-nonterminal\",\n             Class::String => \"string\",\n             Class::Number => \"number\",\n             Class::Bool => \"bool-val\",\n-            Class::Ident => \"ident\",\n+            Class::Ident(_) => \"ident\",\n             Class::Lifetime => \"lifetime\",\n             Class::PreludeTy => \"prelude-ty\",\n             Class::PreludeVal => \"prelude-val\",\n             Class::QuestionMark => \"question-mark\",\n         }\n     }\n+\n+    /// In case this is an item which can be converted into a link to a definition, it'll contain\n+    /// a \"span\" (a tuple representing `(lo, hi)` equivalent of `Span`).\n+    fn get_span(self) -> Option<Span> {\n+        match self {\n+            Self::Ident(sp) | Self::Self_(sp) => Some(sp),\n+            _ => None,\n+        }\n+    }\n }\n \n enum Highlight<'a> {\n@@ -144,14 +184,19 @@ impl Iterator for TokenIter<'a> {\n     }\n }\n \n-fn get_real_ident_class(text: &str, edition: Edition) -> Class {\n-    match text {\n+/// Classifies into identifier class; returns `None` if this is a non-keyword identifier.\n+fn get_real_ident_class(text: &str, edition: Edition, allow_path_keywords: bool) -> Option<Class> {\n+    let ignore: &[&str] =\n+        if allow_path_keywords { &[\"self\", \"Self\", \"super\", \"crate\"] } else { &[\"self\", \"Self\"] };\n+    if ignore.iter().any(|k| *k == text) {\n+        return None;\n+    }\n+    Some(match text {\n         \"ref\" | \"mut\" => Class::RefKeyWord,\n-        \"self\" | \"Self\" => Class::Self_,\n         \"false\" | \"true\" => Class::Bool,\n         _ if Symbol::intern(text).is_reserved(|| edition) => Class::KeyWord,\n-        _ => Class::Ident,\n-    }\n+        _ => return None,\n+    })\n }\n \n /// Processes program tokens, classifying strings of text by highlighting\n@@ -163,11 +208,14 @@ struct Classifier<'a> {\n     in_macro_nonterminal: bool,\n     edition: Edition,\n     byte_pos: u32,\n+    file_span: Span,\n     src: &'a str,\n }\n \n impl<'a> Classifier<'a> {\n-    fn new(src: &str, edition: Edition) -> Classifier<'_> {\n+    /// Takes as argument the source code to HTML-ify, the rust edition to use and the source code\n+    /// file span which will be used later on by the `span_correspondance_map`.\n+    fn new(src: &str, edition: Edition, file_span: Span) -> Classifier<'_> {\n         let tokens = TokenIter { src }.peekable();\n         Classifier {\n             tokens,\n@@ -176,10 +224,18 @@ impl<'a> Classifier<'a> {\n             in_macro_nonterminal: false,\n             edition,\n             byte_pos: 0,\n+            file_span,\n             src,\n         }\n     }\n \n+    /// Convenient wrapper to create a [`Span`] from a position in the file.\n+    fn new_span(&self, lo: u32, text: &str) -> Span {\n+        let hi = lo + text.len() as u32;\n+        let file_lo = self.file_span.lo();\n+        self.file_span.with_lo(file_lo + BytePos(lo)).with_hi(file_lo + BytePos(hi))\n+    }\n+\n     /// Concatenate colons and idents as one when possible.\n     fn get_full_ident_path(&mut self) -> Vec<(TokenKind, usize, usize)> {\n         let start = self.byte_pos as usize;\n@@ -201,17 +257,17 @@ impl<'a> Classifier<'a> {\n                 if has_ident {\n                     return vec![(TokenKind::Ident, start, pos), (TokenKind::Colon, pos, pos + nb)];\n                 } else {\n-                    return vec![(TokenKind::Colon, pos, pos + nb)];\n+                    return vec![(TokenKind::Colon, start, pos + nb)];\n                 }\n             }\n \n-            if let Some((Class::Ident, text)) = self.tokens.peek().map(|(token, text)| {\n+            if let Some((None, text)) = self.tokens.peek().map(|(token, text)| {\n                 if *token == TokenKind::Ident {\n-                    let class = get_real_ident_class(text, edition);\n+                    let class = get_real_ident_class(text, edition, true);\n                     (class, text)\n                 } else {\n                     // Doesn't matter which Class we put in here...\n-                    (Class::Comment, text)\n+                    (Some(Class::Comment), text)\n                 }\n             }) {\n                 // We only \"add\" the colon if there is an ident behind.\n@@ -221,7 +277,7 @@ impl<'a> Classifier<'a> {\n             } else if nb > 0 && has_ident {\n                 return vec![(TokenKind::Ident, start, pos), (TokenKind::Colon, pos, pos + nb)];\n             } else if nb > 0 {\n-                return vec![(TokenKind::Colon, pos, pos + nb)];\n+                return vec![(TokenKind::Colon, start, start + nb)];\n             } else if has_ident {\n                 return vec![(TokenKind::Ident, start, pos)];\n             } else {\n@@ -230,11 +286,15 @@ impl<'a> Classifier<'a> {\n         }\n     }\n \n-    /// Wraps the tokens iteration to ensure that the byte_pos is always correct.\n-    fn next(&mut self) -> Option<(TokenKind, &'a str)> {\n+    /// Wraps the tokens iteration to ensure that the `byte_pos` is always correct.\n+    ///\n+    /// It returns the token's kind, the token as a string and its byte position in the source\n+    /// string.\n+    fn next(&mut self) -> Option<(TokenKind, &'a str, u32)> {\n         if let Some((kind, text)) = self.tokens.next() {\n+            let before = self.byte_pos;\n             self.byte_pos += text.len() as u32;\n-            Some((kind, text))\n+            Some((kind, text, before))\n         } else {\n             None\n         }\n@@ -254,23 +314,36 @@ impl<'a> Classifier<'a> {\n                 .unwrap_or(false)\n             {\n                 let tokens = self.get_full_ident_path();\n-                for (token, start, end) in tokens {\n-                    let text = &self.src[start..end];\n-                    self.advance(token, text, sink);\n+                for (token, start, end) in &tokens {\n+                    let text = &self.src[*start..*end];\n+                    self.advance(*token, text, sink, *start as u32);\n                     self.byte_pos += text.len() as u32;\n                 }\n+                if !tokens.is_empty() {\n+                    continue;\n+                }\n             }\n-            if let Some((token, text)) = self.next() {\n-                self.advance(token, text, sink);\n+            if let Some((token, text, before)) = self.next() {\n+                self.advance(token, text, sink, before);\n             } else {\n                 break;\n             }\n         }\n     }\n \n-    /// Single step of highlighting. This will classify `token`, but maybe also\n-    /// a couple of following ones as well.\n-    fn advance(&mut self, token: TokenKind, text: &'a str, sink: &mut dyn FnMut(Highlight<'a>)) {\n+    /// Single step of highlighting. This will classify `token`, but maybe also a couple of\n+    /// following ones as well.\n+    ///\n+    /// `before` is the position of the given token in the `source` string and is used as \"lo\" byte\n+    /// in case we want to try to generate a link for this token using the\n+    /// `span_correspondance_map`.\n+    fn advance(\n+        &mut self,\n+        token: TokenKind,\n+        text: &'a str,\n+        sink: &mut dyn FnMut(Highlight<'a>),\n+        before: u32,\n+    ) {\n         let lookahead = self.peek();\n         let no_highlight = |sink: &mut dyn FnMut(_)| sink(Highlight::Token { text, class: None });\n         let class = match token {\n@@ -401,19 +474,22 @@ impl<'a> Classifier<'a> {\n                 sink(Highlight::Token { text, class: None });\n                 return;\n             }\n-            TokenKind::Ident => match get_real_ident_class(text, self.edition) {\n-                Class::Ident => match text {\n+            TokenKind::Ident => match get_real_ident_class(text, self.edition, false) {\n+                None => match text {\n                     \"Option\" | \"Result\" => Class::PreludeTy,\n                     \"Some\" | \"None\" | \"Ok\" | \"Err\" => Class::PreludeVal,\n                     _ if self.in_macro_nonterminal => {\n                         self.in_macro_nonterminal = false;\n                         Class::MacroNonTerminal\n                     }\n-                    _ => Class::Ident,\n+                    \"self\" | \"Self\" => Class::Self_(self.new_span(before, text)),\n+                    _ => Class::Ident(self.new_span(before, text)),\n                 },\n-                c => c,\n+                Some(c) => c,\n             },\n-            TokenKind::RawIdent | TokenKind::UnknownPrefix => Class::Ident,\n+            TokenKind::RawIdent | TokenKind::UnknownPrefix => {\n+                Class::Ident(self.new_span(before, text))\n+            }\n             TokenKind::Lifetime { .. } => Class::Lifetime,\n         };\n         // Anything that didn't return above is the simple case where we the\n@@ -446,13 +522,75 @@ fn exit_span(out: &mut Buffer) {\n ///     enter_span(Foo), string(\"text\", None), exit_span()\n ///     string(\"text\", Foo)\n /// ```\n+///\n /// The latter can be thought of as a shorthand for the former, which is more\n /// flexible.\n-fn string<T: Display>(out: &mut Buffer, text: T, klass: Option<Class>) {\n-    match klass {\n-        None => write!(out, \"{}\", text),\n-        Some(klass) => write!(out, \"<span class=\\\"{}\\\">{}</span>\", klass.as_html(), text),\n+///\n+/// Note that if `context` is not `None` and that the given `klass` contains a `Span`, the function\n+/// will then try to find this `span` in the `span_correspondance_map`. If found, it'll then\n+/// generate a link for this element (which corresponds to where its definition is located).\n+fn string<T: Display>(\n+    out: &mut Buffer,\n+    text: T,\n+    klass: Option<Class>,\n+    context_info: &Option<ContextInfo<'_, '_, '_>>,\n+) {\n+    let klass = match klass {\n+        None => return write!(out, \"{}\", text),\n+        Some(klass) => klass,\n+    };\n+    let def_span = match klass.get_span() {\n+        Some(d) => d,\n+        None => {\n+            write!(out, \"<span class=\\\"{}\\\">{}</span>\", klass.as_html(), text);\n+            return;\n+        }\n+    };\n+    let mut text_s = text.to_string();\n+    if text_s.contains(\"::\") {\n+        text_s = text_s.split(\"::\").intersperse(\"::\").fold(String::new(), |mut path, t| {\n+            match t {\n+                \"self\" | \"Self\" => write!(\n+                    &mut path,\n+                    \"<span class=\\\"{}\\\">{}</span>\",\n+                    Class::Self_(DUMMY_SP).as_html(),\n+                    t\n+                ),\n+                \"crate\" | \"super\" => {\n+                    write!(&mut path, \"<span class=\\\"{}\\\">{}</span>\", Class::KeyWord.as_html(), t)\n+                }\n+                t => write!(&mut path, \"{}\", t),\n+            }\n+            .expect(\"Failed to build source HTML path\");\n+            path\n+        });\n+    }\n+    if let Some(context_info) = context_info {\n+        if let Some(href) =\n+            context_info.context.shared.span_correspondance_map.get(&def_span).and_then(|href| {\n+                let context = context_info.context;\n+                // FIXME: later on, it'd be nice to provide two links (if possible) for all items:\n+                // one to the documentation page and one to the source definition.\n+                // FIXME: currently, external items only generate a link to their documentation,\n+                // a link to their definition can be generated using this:\n+                // https://github.com/rust-lang/rust/blob/60f1a2fc4b535ead9c85ce085fdce49b1b097531/src/librustdoc/html/render/context.rs#L315-L338\n+                match href {\n+                    LinkFromSrc::Local(span) => context\n+                        .href_from_span(*span)\n+                        .map(|s| format!(\"{}{}\", context_info.root_path, s)),\n+                    LinkFromSrc::External(def_id) => {\n+                        format::href_with_root_path(*def_id, context, Some(context_info.root_path))\n+                            .ok()\n+                            .map(|(url, _, _)| url)\n+                    }\n+                }\n+            })\n+        {\n+            write!(out, \"<a class=\\\"{}\\\" href=\\\"{}\\\">{}</a>\", klass.as_html(), href, text_s);\n+            return;\n+        }\n     }\n+    write!(out, \"<span class=\\\"{}\\\">{}</span>\", klass.as_html(), text_s);\n }\n \n #[cfg(test)]"}, {"sha": "abc2db1790c535ff2ec97fd972dc19afce84315d", "filename": "src/librustdoc/html/highlight/fixtures/highlight.html", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fhighlight.html", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fhighlight.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fhighlight.html?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -0,0 +1,4 @@\n+<span class=\"kw\">use</span> <span class=\"ident\"><span class=\"kw\">crate</span>::a::foo</span>;\n+<span class=\"kw\">use</span> <span class=\"ident\"><span class=\"self\">self</span>::whatever</span>;\n+<span class=\"kw\">let</span> <span class=\"ident\">x</span> <span class=\"op\">=</span> <span class=\"ident\"><span class=\"kw\">super</span>::b::foo</span>;\n+<span class=\"kw\">let</span> <span class=\"ident\">y</span> <span class=\"op\">=</span> <span class=\"ident\"><span class=\"self\">Self</span>::whatever</span>;\n\\ No newline at end of file"}, {"sha": "866caea9256096757deb7b404527950e3a4cedc6", "filename": "src/librustdoc/html/highlight/fixtures/sample.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.html", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.html?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -23,7 +23,7 @@\n     <span class=\"macro\">assert!</span>(<span class=\"self\">self</span>.<span class=\"ident\">length</span> <span class=\"op\">&lt;</span> <span class=\"ident\">N</span> <span class=\"op\">&amp;&amp;</span> <span class=\"ident\">index</span> <span class=\"op\">&lt;</span><span class=\"op\">=</span> <span class=\"self\">self</span>.<span class=\"ident\">length</span>);\n     <span class=\"ident\">::std::env::var</span>(<span class=\"string\">&quot;gateau&quot;</span>).<span class=\"ident\">is_ok</span>();\n     <span class=\"attribute\">#[<span class=\"ident\">rustfmt::skip</span>]</span>\n-    <span class=\"kw\">let</span> <span class=\"ident\">s</span>:<span class=\"ident\">std</span><span class=\"ident\">::path::PathBuf</span> <span class=\"op\">=</span> <span class=\"ident\">std::path::PathBuf::new</span>();\n+    <span class=\"kw\">let</span> <span class=\"ident\">s</span>:<span class=\"ident\">std::path::PathBuf</span> <span class=\"op\">=</span> <span class=\"ident\">std::path::PathBuf::new</span>();\n     <span class=\"kw\">let</span> <span class=\"kw-2\">mut</span> <span class=\"ident\">s</span> <span class=\"op\">=</span> <span class=\"ident\">String::new</span>();\n \n     <span class=\"kw\">match</span> <span class=\"kw-2\">&amp;</span><span class=\"ident\">s</span> {"}, {"sha": "68592ae96c187b273eebb1c5d76c417b0fa86954", "filename": "src/librustdoc/html/highlight/tests.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -22,7 +22,7 @@ fn test_html_highlighting() {\n         let src = include_str!(\"fixtures/sample.rs\");\n         let html = {\n             let mut out = Buffer::new();\n-            write_code(&mut out, src, Edition::Edition2018);\n+            write_code(&mut out, src, Edition::Edition2018, None);\n             format!(\"{}<pre><code>{}</code></pre>\\n\", STYLE, out.into_inner())\n         };\n         expect_file![\"fixtures/sample.html\"].assert_eq(&html);\n@@ -36,7 +36,21 @@ fn test_dos_backline() {\n     println!(\\\"foo\\\");\\r\\n\\\n }\\r\\n\";\n         let mut html = Buffer::new();\n-        write_code(&mut html, src, Edition::Edition2018);\n+        write_code(&mut html, src, Edition::Edition2018, None);\n         expect_file![\"fixtures/dos_line.html\"].assert_eq(&html.into_inner());\n     });\n }\n+\n+#[test]\n+fn test_keyword_highlight() {\n+    create_default_session_globals_then(|| {\n+        let src = \"use crate::a::foo;\n+use self::whatever;\n+let x = super::b::foo;\n+let y = Self::whatever;\";\n+\n+        let mut html = Buffer::new();\n+        write_code(&mut html, src, Edition::Edition2018, None);\n+        expect_file![\"fixtures/highlight.html\"].assert_eq(&html.into_inner());\n+    });\n+}"}, {"sha": "472323daf3017ae594eebe2a42b091a0cd505f98", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -330,6 +330,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n             tooltip,\n             edition,\n             None,\n+            None,\n         );\n         Some(Event::Html(s.into_inner().into()))\n     }"}, {"sha": "6ce0828e159402b867eb447921efc0d2e6ada44c", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 47, "deletions": 23, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -17,7 +17,10 @@ use rustc_span::symbol::sym;\n use super::cache::{build_index, ExternalLocation};\n use super::print_item::{full_path, item_path, print_item};\n use super::write_shared::write_shared;\n-use super::{print_sidebar, settings, AllTypes, NameDoc, StylePath, BASIC_KEYWORDS};\n+use super::{\n+    collect_spans_and_sources, print_sidebar, settings, AllTypes, LinkFromSrc, NameDoc, StylePath,\n+    BASIC_KEYWORDS,\n+};\n \n use crate::clean;\n use crate::clean::ExternalCrate;\n@@ -46,7 +49,7 @@ crate struct Context<'tcx> {\n     pub(crate) current: Vec<String>,\n     /// The current destination folder of where HTML artifacts should be placed.\n     /// This changes as the context descends into the module hierarchy.\n-    pub(super) dst: PathBuf,\n+    crate dst: PathBuf,\n     /// A flag, which when `true`, will render pages which redirect to the\n     /// real location of an item. This is used to allow external links to\n     /// publicly reused items to redirect to the right location.\n@@ -58,7 +61,7 @@ crate struct Context<'tcx> {\n     /// Issue for improving the situation: [#82381][]\n     ///\n     /// [#82381]: https://github.com/rust-lang/rust/issues/82381\n-    pub(super) shared: Rc<SharedContext<'tcx>>,\n+    crate shared: Rc<SharedContext<'tcx>>,\n     /// The [`Cache`] used during rendering.\n     ///\n     /// Ideally the cache would be in [`SharedContext`], but it's mutated\n@@ -68,7 +71,11 @@ crate struct Context<'tcx> {\n     /// It's immutable once in `Context`, so it's not as bad that it's not in\n     /// `SharedContext`.\n     // FIXME: move `cache` to `SharedContext`\n-    pub(super) cache: Rc<Cache>,\n+    crate cache: Rc<Cache>,\n+    /// This flag indicates whether `[src]` links should be generated or not. If\n+    /// the source files are present in the html rendering, then this will be\n+    /// `true`.\n+    crate include_sources: bool,\n }\n \n // `Context` is cloned a lot, so we don't want the size to grow unexpectedly.\n@@ -84,10 +91,6 @@ crate struct SharedContext<'tcx> {\n     /// This describes the layout of each page, and is not modified after\n     /// creation of the context (contains info like the favicon and added html).\n     crate layout: layout::Layout,\n-    /// This flag indicates whether `[src]` links should be generated or not. If\n-    /// the source files are present in the html rendering, then this will be\n-    /// `true`.\n-    crate include_sources: bool,\n     /// The local file sources we've emitted and their respective url-paths.\n     crate local_sources: FxHashMap<PathBuf, String>,\n     /// Show the memory layout of types in the docs.\n@@ -125,6 +128,10 @@ crate struct SharedContext<'tcx> {\n     redirections: Option<RefCell<FxHashMap<String, String>>>,\n \n     pub(crate) templates: tera::Tera,\n+\n+    /// Correspondance map used to link types used in the source code pages to allow to click on\n+    /// links to jump to the type's definition.\n+    crate span_correspondance_map: FxHashMap<rustc_span::Span, LinkFromSrc>,\n }\n \n impl SharedContext<'_> {\n@@ -293,15 +300,19 @@ impl<'tcx> Context<'tcx> {\n     /// may happen, for example, with externally inlined items where the source\n     /// of their crate documentation isn't known.\n     pub(super) fn src_href(&self, item: &clean::Item) -> Option<String> {\n-        if item.span(self.tcx()).is_dummy() {\n+        self.href_from_span(item.span(self.tcx()))\n+    }\n+\n+    crate fn href_from_span(&self, span: clean::Span) -> Option<String> {\n+        if span.is_dummy() {\n             return None;\n         }\n         let mut root = self.root_path();\n         let mut path = String::new();\n-        let cnum = item.span(self.tcx()).cnum(self.sess());\n+        let cnum = span.cnum(self.sess());\n \n         // We can safely ignore synthetic `SourceFile`s.\n-        let file = match item.span(self.tcx()).filename(self.sess()) {\n+        let file = match span.filename(self.sess()) {\n             FileName::Real(ref path) => path.local_path_if_available().to_path_buf(),\n             _ => return None,\n         };\n@@ -339,8 +350,8 @@ impl<'tcx> Context<'tcx> {\n             (&*symbol, &path)\n         };\n \n-        let loline = item.span(self.tcx()).lo(self.sess()).line;\n-        let hiline = item.span(self.tcx()).hi(self.sess()).line;\n+        let loline = span.lo(self.sess()).line;\n+        let hiline = span.hi(self.sess()).line;\n         let lines =\n             if loline == hiline { loline.to_string() } else { format!(\"{}-{}\", loline, hiline) };\n         Some(format!(\n@@ -362,9 +373,9 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n     const RUN_ON_MODULE: bool = true;\n \n     fn init(\n-        mut krate: clean::Crate,\n+        krate: clean::Crate,\n         options: RenderOptions,\n-        mut cache: Cache,\n+        cache: Cache,\n         tcx: TyCtxt<'tcx>,\n     ) -> Result<(Self, clean::Crate), Error> {\n         // need to save a copy of the options for rendering the index page\n@@ -385,6 +396,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             unstable_features,\n             generate_redirect_map,\n             show_type_layout,\n+            generate_link_to_definition,\n             ..\n         } = options;\n \n@@ -444,13 +456,21 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n                 _ => {}\n             }\n         }\n+\n+        let (mut krate, local_sources, matches) = collect_spans_and_sources(\n+            tcx,\n+            krate,\n+            &src_root,\n+            include_sources,\n+            generate_link_to_definition,\n+        );\n+\n         let (sender, receiver) = channel();\n         let mut scx = SharedContext {\n             tcx,\n             collapsed: krate.collapsed,\n             src_root,\n-            include_sources,\n-            local_sources: Default::default(),\n+            local_sources,\n             issue_tracker_base_url,\n             layout,\n             created_dirs: Default::default(),\n@@ -466,6 +486,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             redirections: if generate_redirect_map { Some(Default::default()) } else { None },\n             show_type_layout,\n             templates,\n+            span_correspondance_map: matches,\n         };\n \n         // Add the default themes to the `Vec` of stylepaths\n@@ -483,12 +504,6 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n \n         let dst = output;\n         scx.ensure_dir(&dst)?;\n-        if emit_crate {\n-            krate = sources::render(&dst, &mut scx, krate)?;\n-        }\n-\n-        // Build our search index\n-        let index = build_index(&krate, &mut cache, tcx);\n \n         let mut cx = Context {\n             current: Vec::new(),\n@@ -497,8 +512,16 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             id_map: RefCell::new(id_map),\n             shared: Rc::new(scx),\n             cache: Rc::new(cache),\n+            include_sources,\n         };\n \n+        if emit_crate {\n+            krate = sources::render(&mut cx, krate)?;\n+        }\n+\n+        // Build our search index\n+        let index = build_index(&krate, Rc::get_mut(&mut cx.cache).unwrap(), tcx);\n+\n         // Write shared runs within a flock; disable thread dispatching of IO temporarily.\n         Rc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(true);\n         write_shared(&cx, &krate, index, &md_opts)?;\n@@ -514,6 +537,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             id_map: RefCell::new(IdMap::new()),\n             shared: Rc::clone(&self.shared),\n             cache: Rc::clone(&self.cache),\n+            include_sources: self.include_sources,\n         }\n     }\n "}, {"sha": "fd2e18a8be77f0d3933d14c4e1174076649ec3d6", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -30,9 +30,11 @@ mod tests;\n \n mod context;\n mod print_item;\n+mod span_map;\n mod write_shared;\n \n crate use context::*;\n+crate use span_map::{collect_spans_and_sources, LinkFromSrc};\n \n use std::collections::VecDeque;\n use std::default::Default;"}, {"sha": "f31305c76e642582b3306cdd3d07f1b02d5ba526", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -119,7 +119,7 @@ pub(super) fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer,\n     // [src] link in the downstream documentation will actually come back to\n     // this page, and this link will be auto-clicked. The `id` attribute is\n     // used to find the link to auto-click.\n-    if cx.shared.include_sources && !item.is_primitive() {\n+    if cx.include_sources && !item.is_primitive() {\n         write_srclink(cx, item, buf);\n     }\n \n@@ -1081,6 +1081,7 @@ fn item_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Mac\n             None,\n             it.span(cx.tcx()).inner().edition(),\n             None,\n+            None,\n         );\n     });\n     document(w, cx, it, None)"}, {"sha": "b35cd45dc9a886c60979dd15ba134df14b162a6a", "filename": "src/librustdoc/html/render/span_map.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -0,0 +1,164 @@\n+use crate::clean;\n+use crate::html::sources;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_hir::{ExprKind, GenericParam, GenericParamKind, HirId, Mod, Node};\n+use rustc_middle::ty::TyCtxt;\n+use rustc_span::Span;\n+\n+use std::path::{Path, PathBuf};\n+\n+/// This enum allows us to store two different kinds of information:\n+///\n+/// In case the `span` definition comes from the same crate, we can simply get the `span` and use\n+/// it as is.\n+///\n+/// Otherwise, we store the definition `DefId` and will generate a link to the documentation page\n+/// instead of the source code directly.\n+#[derive(Debug)]\n+crate enum LinkFromSrc {\n+    Local(clean::Span),\n+    External(DefId),\n+}\n+\n+/// This function will do at most two things:\n+///\n+/// 1. Generate a `span` correspondance map which links an item `span` to its definition `span`.\n+/// 2. Collect the source code files.\n+///\n+/// It returns the `krate`, the source code files and the `span` correspondance map.\n+///\n+/// Note about the `span` correspondance map: the keys are actually `(lo, hi)` of `span`s. We don't\n+/// need the `span` context later on, only their position, so instead of keep a whole `Span`, we\n+/// only keep the `lo` and `hi`.\n+crate fn collect_spans_and_sources(\n+    tcx: TyCtxt<'_>,\n+    krate: clean::Crate,\n+    src_root: &Path,\n+    include_sources: bool,\n+    generate_link_to_definition: bool,\n+) -> (clean::Crate, FxHashMap<PathBuf, String>, FxHashMap<Span, LinkFromSrc>) {\n+    let mut visitor = SpanMapVisitor { tcx, matches: FxHashMap::default() };\n+\n+    if include_sources {\n+        if generate_link_to_definition {\n+            intravisit::walk_crate(&mut visitor, tcx.hir().krate());\n+        }\n+        let (krate, sources) = sources::collect_local_sources(tcx, src_root, krate);\n+        (krate, sources, visitor.matches)\n+    } else {\n+        (krate, Default::default(), Default::default())\n+    }\n+}\n+\n+struct SpanMapVisitor<'tcx> {\n+    crate tcx: TyCtxt<'tcx>,\n+    crate matches: FxHashMap<Span, LinkFromSrc>,\n+}\n+\n+impl<'tcx> SpanMapVisitor<'tcx> {\n+    /// This function is where we handle `hir::Path` elements and add them into the \"span map\".\n+    fn handle_path(&mut self, path: &rustc_hir::Path<'_>, path_span: Option<Span>) {\n+        let info = match path.res {\n+            // FIXME: For now, we only handle `DefKind` if it's not `DefKind::TyParam` or\n+            // `DefKind::Macro`. Would be nice to support them too alongside the other `DefKind`\n+            // (such as primitive types!).\n+            Res::Def(kind, def_id) if kind != DefKind::TyParam => {\n+                if matches!(kind, DefKind::Macro(_)) {\n+                    return;\n+                }\n+                Some(def_id)\n+            }\n+            Res::Local(_) => None,\n+            Res::Err => return,\n+            _ => return,\n+        };\n+        if let Some(span) = self.tcx.hir().res_span(path.res) {\n+            self.matches.insert(\n+                path_span.unwrap_or_else(|| path.span),\n+                LinkFromSrc::Local(clean::Span::new(span)),\n+            );\n+        } else if let Some(def_id) = info {\n+            self.matches\n+                .insert(path_span.unwrap_or_else(|| path.span), LinkFromSrc::External(def_id));\n+        }\n+    }\n+}\n+\n+impl Visitor<'tcx> for SpanMapVisitor<'tcx> {\n+    type Map = rustc_middle::hir::map::Map<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::All(self.tcx.hir())\n+    }\n+\n+    fn visit_generic_param(&mut self, p: &'tcx GenericParam<'tcx>) {\n+        if !matches!(p.kind, GenericParamKind::Type { .. }) {\n+            return;\n+        }\n+        for bound in p.bounds {\n+            if let Some(trait_ref) = bound.trait_ref() {\n+                self.handle_path(&trait_ref.path, None);\n+            }\n+        }\n+    }\n+\n+    fn visit_path(&mut self, path: &'tcx rustc_hir::Path<'tcx>, _id: HirId) {\n+        self.handle_path(path, None);\n+        intravisit::walk_path(self, path);\n+    }\n+\n+    fn visit_mod(&mut self, m: &'tcx Mod<'tcx>, span: Span, id: HirId) {\n+        // To make the difference between \"mod foo {}\" and \"mod foo;\". In case we \"import\" another\n+        // file, we want to link to it. Otherwise no need to create a link.\n+        if !span.overlaps(m.inner) {\n+            // Now that we confirmed it's a file import, we want to get the span for the module\n+            // name only and not all the \"mod foo;\".\n+            if let Some(node) = self.tcx.hir().find(id) {\n+                match node {\n+                    Node::Item(item) => {\n+                        self.matches\n+                            .insert(item.ident.span, LinkFromSrc::Local(clean::Span::new(m.inner)));\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+        intravisit::walk_mod(self, m, id);\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx rustc_hir::Expr<'tcx>) {\n+        match expr.kind {\n+            ExprKind::MethodCall(segment, method_span, _, _) => {\n+                if let Some(hir_id) = segment.hir_id {\n+                    let hir = self.tcx.hir();\n+                    let body_id = hir.enclosing_body_owner(hir_id);\n+                    let typeck_results = self.tcx.sess.with_disabled_diagnostic(|| {\n+                        self.tcx.typeck_body(\n+                            hir.maybe_body_owned_by(body_id).expect(\"a body which isn't a body\"),\n+                        )\n+                    });\n+                    if let Some(def_id) = typeck_results.type_dependent_def_id(expr.hir_id) {\n+                        self.matches.insert(\n+                            method_span,\n+                            match hir.span_if_local(def_id) {\n+                                Some(span) => LinkFromSrc::Local(clean::Span::new(span)),\n+                                None => LinkFromSrc::External(def_id),\n+                            },\n+                        );\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+        intravisit::walk_expr(self, expr);\n+    }\n+\n+    fn visit_use(&mut self, path: &'tcx rustc_hir::Path<'tcx>, id: HirId) {\n+        self.handle_path(path, None);\n+        intravisit::walk_use(self, path, id);\n+    }\n+}"}, {"sha": "c16769c474a2124b5abf63d5ddf17d41427f1bbc", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -272,7 +272,7 @@ pub(super) fn write_shared(\n     write_minify(\"search.js\", static_files::SEARCH_JS)?;\n     write_minify(\"settings.js\", static_files::SETTINGS_JS)?;\n \n-    if cx.shared.include_sources {\n+    if cx.include_sources {\n         write_minify(\"source-script.js\", static_files::sidebar::SOURCE_SCRIPT)?;\n     }\n \n@@ -398,7 +398,7 @@ pub(super) fn write_shared(\n         }\n     }\n \n-    if cx.shared.include_sources {\n+    if cx.include_sources {\n         let mut hierarchy = Hierarchy::new(OsString::new());\n         for source in cx\n             .shared"}, {"sha": "73916e204d9426aa805a9e8915f0ac5bdcccd83f", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 127, "deletions": 45, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -5,61 +5,128 @@ use crate::fold::DocFolder;\n use crate::html::format::Buffer;\n use crate::html::highlight;\n use crate::html::layout;\n-use crate::html::render::{SharedContext, BASIC_KEYWORDS};\n+use crate::html::render::{Context, BASIC_KEYWORDS};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_middle::ty::TyCtxt;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::source_map::FileName;\n use std::ffi::OsStr;\n use std::fs;\n use std::path::{Component, Path, PathBuf};\n \n-crate fn render(\n-    dst: &Path,\n-    scx: &mut SharedContext<'_>,\n-    krate: clean::Crate,\n-) -> Result<clean::Crate, Error> {\n+crate fn render(cx: &mut Context<'_>, krate: clean::Crate) -> Result<clean::Crate, Error> {\n     info!(\"emitting source files\");\n-    let dst = dst.join(\"src\").join(&*krate.name.as_str());\n-    scx.ensure_dir(&dst)?;\n-    let mut folder = SourceCollector { dst, scx };\n+    let dst = cx.dst.join(\"src\").join(&*krate.name.as_str());\n+    cx.shared.ensure_dir(&dst)?;\n+    let mut folder = SourceCollector { dst, cx, emitted_local_sources: FxHashSet::default() };\n     Ok(folder.fold_crate(krate))\n }\n \n+crate fn collect_local_sources<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    src_root: &Path,\n+    krate: clean::Crate,\n+) -> (clean::Crate, FxHashMap<PathBuf, String>) {\n+    let mut lsc = LocalSourcesCollector { tcx, local_sources: FxHashMap::default(), src_root };\n+\n+    let krate = lsc.fold_crate(krate);\n+    (krate, lsc.local_sources)\n+}\n+\n+struct LocalSourcesCollector<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    local_sources: FxHashMap<PathBuf, String>,\n+    src_root: &'a Path,\n+}\n+\n+fn is_real_and_local(span: clean::Span, sess: &Session) -> bool {\n+    span.filename(sess).is_real() && span.cnum(sess) == LOCAL_CRATE\n+}\n+\n+impl LocalSourcesCollector<'_, '_> {\n+    fn add_local_source(&mut self, item: &clean::Item) {\n+        let sess = self.tcx.sess;\n+        let span = item.span(self.tcx);\n+        // skip all synthetic \"files\"\n+        if !is_real_and_local(span, sess) {\n+            return;\n+        }\n+        let filename = span.filename(sess);\n+        let p = match filename {\n+            FileName::Real(ref file) => match file.local_path() {\n+                Some(p) => p.to_path_buf(),\n+                _ => return,\n+            },\n+            _ => return,\n+        };\n+        if self.local_sources.contains_key(&*p) {\n+            // We've already emitted this source\n+            return;\n+        }\n+\n+        let mut href = String::new();\n+        clean_path(&self.src_root, &p, false, |component| {\n+            href.push_str(&component.to_string_lossy());\n+            href.push('/');\n+        });\n+\n+        let src_fname = p.file_name().expect(\"source has no filename\").to_os_string();\n+        let mut fname = src_fname.clone();\n+        fname.push(\".html\");\n+        href.push_str(&fname.to_string_lossy());\n+        self.local_sources.insert(p, href);\n+    }\n+}\n+\n+impl DocFolder for LocalSourcesCollector<'_, '_> {\n+    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n+        self.add_local_source(&item);\n+\n+        // FIXME: if `include_sources` isn't set and DocFolder didn't require consuming the crate by value,\n+        // we could return None here without having to walk the rest of the crate.\n+        Some(self.fold_item_recur(item))\n+    }\n+}\n+\n /// Helper struct to render all source code to HTML pages\n struct SourceCollector<'a, 'tcx> {\n-    scx: &'a mut SharedContext<'tcx>,\n+    cx: &'a mut Context<'tcx>,\n \n     /// Root destination to place all HTML output into\n     dst: PathBuf,\n+    emitted_local_sources: FxHashSet<PathBuf>,\n }\n \n impl DocFolder for SourceCollector<'_, '_> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n+        let tcx = self.cx.tcx();\n+        let span = item.span(tcx);\n+        let sess = tcx.sess;\n+\n         // If we're not rendering sources, there's nothing to do.\n         // If we're including source files, and we haven't seen this file yet,\n         // then we need to render it out to the filesystem.\n-        if self.scx.include_sources\n-            // skip all synthetic \"files\"\n-            && item.span(self.scx.tcx).filename(self.sess()).is_real()\n-            // skip non-local files\n-            && item.span(self.scx.tcx).cnum(self.sess()) == LOCAL_CRATE\n-        {\n-            let filename = item.span(self.scx.tcx).filename(self.sess());\n+        if self.cx.include_sources && is_real_and_local(span, sess) {\n+            let filename = span.filename(sess);\n+            let span = span.inner();\n+            let pos = sess.source_map().lookup_source_file(span.lo());\n+            let file_span = span.with_lo(pos.start_pos).with_hi(pos.end_pos);\n             // If it turns out that we couldn't read this file, then we probably\n             // can't read any of the files (generating html output from json or\n             // something like that), so just don't include sources for the\n             // entire crate. The other option is maintaining this mapping on a\n             // per-file basis, but that's probably not worth it...\n-            self.scx.include_sources = match self.emit_source(&filename) {\n+            self.cx.include_sources = match self.emit_source(&filename, file_span) {\n                 Ok(()) => true,\n                 Err(e) => {\n-                    self.scx.tcx.sess.span_err(\n-                        item.span(self.scx.tcx).inner(),\n+                    self.cx.shared.tcx.sess.span_err(\n+                        span,\n                         &format!(\n                             \"failed to render source code for `{}`: {}\",\n                             filename.prefer_local(),\n-                            e\n+                            e,\n                         ),\n                     );\n                     false\n@@ -73,12 +140,12 @@ impl DocFolder for SourceCollector<'_, '_> {\n }\n \n impl SourceCollector<'_, 'tcx> {\n-    fn sess(&self) -> &'tcx Session {\n-        &self.scx.tcx.sess\n-    }\n-\n     /// Renders the given filename into its corresponding HTML source file.\n-    fn emit_source(&mut self, filename: &FileName) -> Result<(), Error> {\n+    fn emit_source(\n+        &mut self,\n+        filename: &FileName,\n+        file_span: rustc_span::Span,\n+    ) -> Result<(), Error> {\n         let p = match *filename {\n             FileName::Real(ref file) => {\n                 if let Some(local_path) = file.local_path() {\n@@ -89,7 +156,7 @@ impl SourceCollector<'_, 'tcx> {\n             }\n             _ => return Ok(()),\n         };\n-        if self.scx.local_sources.contains_key(&*p) {\n+        if self.emitted_local_sources.contains(&*p) {\n             // We've already emitted this source\n             return Ok(());\n         }\n@@ -107,44 +174,43 @@ impl SourceCollector<'_, 'tcx> {\n         // Create the intermediate directories\n         let mut cur = self.dst.clone();\n         let mut root_path = String::from(\"../../\");\n-        let mut href = String::new();\n-        clean_path(&self.scx.src_root, &p, false, |component| {\n+        clean_path(&self.cx.shared.src_root, &p, false, |component| {\n             cur.push(component);\n             root_path.push_str(\"../\");\n-            href.push_str(&component.to_string_lossy());\n-            href.push('/');\n         });\n-        self.scx.ensure_dir(&cur)?;\n+\n+        self.cx.shared.ensure_dir(&cur)?;\n \n         let src_fname = p.file_name().expect(\"source has no filename\").to_os_string();\n         let mut fname = src_fname.clone();\n         fname.push(\".html\");\n         cur.push(&fname);\n-        href.push_str(&fname.to_string_lossy());\n \n         let title = format!(\"{} - source\", src_fname.to_string_lossy());\n         let desc = format!(\"Source of the Rust file `{}`.\", filename.prefer_remapped());\n         let page = layout::Page {\n             title: &title,\n             css_class: \"source\",\n             root_path: &root_path,\n-            static_root_path: self.scx.static_root_path.as_deref(),\n+            static_root_path: self.cx.shared.static_root_path.as_deref(),\n             description: &desc,\n             keywords: BASIC_KEYWORDS,\n-            resource_suffix: &self.scx.resource_suffix,\n-            extra_scripts: &[&format!(\"source-files{}\", self.scx.resource_suffix)],\n-            static_extra_scripts: &[&format!(\"source-script{}\", self.scx.resource_suffix)],\n+            resource_suffix: &self.cx.shared.resource_suffix,\n+            extra_scripts: &[&format!(\"source-files{}\", self.cx.shared.resource_suffix)],\n+            static_extra_scripts: &[&format!(\"source-script{}\", self.cx.shared.resource_suffix)],\n         };\n         let v = layout::render(\n-            &self.scx.templates,\n-            &self.scx.layout,\n+            &self.cx.shared.templates,\n+            &self.cx.shared.layout,\n             &page,\n             \"\",\n-            |buf: &mut _| print_src(buf, contents, self.scx.edition()),\n-            &self.scx.style_files,\n+            |buf: &mut _| {\n+                print_src(buf, contents, self.cx.shared.edition(), file_span, &self.cx, &root_path)\n+            },\n+            &self.cx.shared.style_files,\n         );\n-        self.scx.fs.write(&cur, v.as_bytes())?;\n-        self.scx.local_sources.insert(p, href);\n+        self.cx.shared.fs.write(&cur, v.as_bytes())?;\n+        self.emitted_local_sources.insert(p);\n         Ok(())\n     }\n }\n@@ -178,7 +244,14 @@ where\n \n /// Wrapper struct to render the source code of a file. This will do things like\n /// adding line numbers to the left-hand side.\n-fn print_src(buf: &mut Buffer, s: &str, edition: Edition) {\n+fn print_src(\n+    buf: &mut Buffer,\n+    s: &str,\n+    edition: Edition,\n+    file_span: rustc_span::Span,\n+    context: &Context<'_>,\n+    root_path: &str,\n+) {\n     let lines = s.lines().count();\n     let mut line_numbers = Buffer::empty_from(buf);\n     let mut cols = 0;\n@@ -192,5 +265,14 @@ fn print_src(buf: &mut Buffer, s: &str, edition: Edition) {\n         writeln!(line_numbers, \"<span id=\\\"{0}\\\">{0:1$}</span>\", i, cols);\n     }\n     line_numbers.write_str(\"</pre>\");\n-    highlight::render_with_highlighting(s, buf, None, None, None, edition, Some(line_numbers));\n+    highlight::render_with_highlighting(\n+        s,\n+        buf,\n+        None,\n+        None,\n+        None,\n+        edition,\n+        Some(line_numbers),\n+        Some(highlight::ContextInfo { context, file_span, root_path }),\n+    );\n }"}, {"sha": "bbc48f49e63e184d98b6438af0213a627d81b5f4", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -450,6 +450,10 @@ nav.sub {\n \tborder-bottom-left-radius: 5px;\n }\n \n+.example-wrap > pre.rust a:hover {\n+\ttext-decoration: underline;\n+}\n+\n .rustdoc:not(.source) .example-wrap > pre:not(.line-number) {\n \twidth: 100%;\n \toverflow-x: auto;"}, {"sha": "a98725e683cb6d678052602bf490dfc5b0fec64d", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -607,6 +607,13 @@ fn opts() -> Vec<RustcOptGroup> {\n         unstable(\"nocapture\", |o| {\n             o.optflag(\"\", \"nocapture\", \"Don't capture stdout and stderr of tests\")\n         }),\n+        unstable(\"generate-link-to-definition\", |o| {\n+            o.optflag(\n+                \"\",\n+                \"generate-link-to-definition\",\n+                \"Make the identifiers in the HTML source code pages navigable\",\n+            )\n+        }),\n     ]\n }\n "}, {"sha": "87620d74ee6455d5d37118b089a252a29d6c8cdf", "filename": "src/test/rustdoc-ui/generate-link-to-definition-opt-unstable.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Ftest%2Frustdoc-ui%2Fgenerate-link-to-definition-opt-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Ftest%2Frustdoc-ui%2Fgenerate-link-to-definition-opt-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fgenerate-link-to-definition-opt-unstable.rs?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -0,0 +1,6 @@\n+// This test purpose is to check that the \"--generate-link-to-definition\"\n+// option can only be used on nightly.\n+\n+// compile-flags: --generate-link-to-definition\n+\n+pub fn f() {}"}, {"sha": "a8ddf91bcbf15acad8d1e2e0bca0fa8f7a4592a4", "filename": "src/test/rustdoc-ui/generate-link-to-definition-opt-unstable.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Ftest%2Frustdoc-ui%2Fgenerate-link-to-definition-opt-unstable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Ftest%2Frustdoc-ui%2Fgenerate-link-to-definition-opt-unstable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fgenerate-link-to-definition-opt-unstable.stderr?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -0,0 +1,2 @@\n+error: the `-Z unstable-options` flag must also be passed to enable the flag `generate-link-to-definition`\n+"}, {"sha": "8f4f561b44dcc5c5c4a172a9f6ca006e1e9eeab7", "filename": "src/test/rustdoc-ui/generate-link-to-definition-opt.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Ftest%2Frustdoc-ui%2Fgenerate-link-to-definition-opt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Ftest%2Frustdoc-ui%2Fgenerate-link-to-definition-opt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fgenerate-link-to-definition-opt.rs?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -0,0 +1,6 @@\n+// This test purpose is to check that the \"--generate-link-to-definition\"\n+// option can only be used with HTML generation.\n+\n+// compile-flags: -Zunstable-options --generate-link-to-definition --output-format json\n+\n+pub fn f() {}"}, {"sha": "4c8c607e7da231243f3b67bd84da85c73c3996b2", "filename": "src/test/rustdoc-ui/generate-link-to-definition-opt.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Ftest%2Frustdoc-ui%2Fgenerate-link-to-definition-opt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Ftest%2Frustdoc-ui%2Fgenerate-link-to-definition-opt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fgenerate-link-to-definition-opt.stderr?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -0,0 +1,2 @@\n+error: --generate-link-to-definition option can only be used with HTML output format\n+"}, {"sha": "da5142087ddee8a59322bc0602e9d307566f2c3d", "filename": "src/test/rustdoc-ui/generate-link-to-definition-opt2.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Ftest%2Frustdoc-ui%2Fgenerate-link-to-definition-opt2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Ftest%2Frustdoc-ui%2Fgenerate-link-to-definition-opt2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fgenerate-link-to-definition-opt2.rs?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -0,0 +1,6 @@\n+// This test purpose is to check that the \"--generate-link-to-definition\"\n+// option can only be used with HTML generation.\n+\n+// compile-flags: -Zunstable-options --generate-link-to-definition --show-coverage\n+\n+pub fn f() {}"}, {"sha": "4c8c607e7da231243f3b67bd84da85c73c3996b2", "filename": "src/test/rustdoc-ui/generate-link-to-definition-opt2.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Ftest%2Frustdoc-ui%2Fgenerate-link-to-definition-opt2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Ftest%2Frustdoc-ui%2Fgenerate-link-to-definition-opt2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fgenerate-link-to-definition-opt2.stderr?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -0,0 +1,2 @@\n+error: --generate-link-to-definition option can only be used with HTML output format\n+"}, {"sha": "8700d688ef7e25f85ef025bf7d2a99d6d45eec7d", "filename": "src/test/rustdoc/auxiliary/source-code-bar.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Ftest%2Frustdoc%2Fauxiliary%2Fsource-code-bar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Ftest%2Frustdoc%2Fauxiliary%2Fsource-code-bar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fsource-code-bar.rs?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -0,0 +1,17 @@\n+//! just some other file. :)\n+\n+use crate::Foo;\n+\n+pub struct Bar {\n+    field: Foo,\n+}\n+\n+pub struct Bar2 {\n+    field: crate::Foo,\n+}\n+\n+pub mod sub {\n+    pub trait Trait {\n+        fn tadam() {}\n+    }\n+}"}, {"sha": "72a5c1a0ae97e53284e9245127d5a621970e0663", "filename": "src/test/rustdoc/auxiliary/source_code.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Ftest%2Frustdoc%2Fauxiliary%2Fsource_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Ftest%2Frustdoc%2Fauxiliary%2Fsource_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fsource_code.rs?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -0,0 +1 @@\n+pub struct SourceCode;"}, {"sha": "e3ae79ccdb17ad52effb5bdc8d04ec2da9a0daa8", "filename": "src/test/rustdoc/check-source-code-urls-to-def.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Ftest%2Frustdoc%2Fcheck-source-code-urls-to-def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f79572fbcbe103346c950d95d7335f6c804d83/src%2Ftest%2Frustdoc%2Fcheck-source-code-urls-to-def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcheck-source-code-urls-to-def.rs?ref=e2f79572fbcbe103346c950d95d7335f6c804d83", "patch": "@@ -0,0 +1,44 @@\n+// compile-flags: -Zunstable-options --generate-link-to-definition\n+// aux-build:source_code.rs\n+// build-aux-docs\n+\n+#![crate_name = \"foo\"]\n+\n+extern crate source_code;\n+\n+// @has 'src/foo/check-source-code-urls-to-def.rs.html'\n+\n+// @has - '//a[@href=\"../../src/foo/auxiliary/source-code-bar.rs.html#1-17\"]' 'bar'\n+#[path = \"auxiliary/source-code-bar.rs\"]\n+pub mod bar;\n+\n+// @count - '//a[@href=\"../../src/foo/auxiliary/source-code-bar.rs.html#5-7\"]' 4\n+use bar::Bar;\n+// @has - '//a[@href=\"../../src/foo/auxiliary/source-code-bar.rs.html#13-17\"]' 'self'\n+// @has - '//a[@href=\"../../src/foo/auxiliary/source-code-bar.rs.html#14-16\"]' 'Trait'\n+use bar::sub::{self, Trait};\n+\n+pub struct Foo;\n+\n+impl Foo {\n+    fn hello(&self) {}\n+}\n+\n+fn babar() {}\n+\n+// @has - '//a/@href' '/struct.String.html'\n+// @count - '//a[@href=\"../../src/foo/check-source-code-urls-to-def.rs.html#21\"]' 5\n+// @has - '//a[@href=\"../../source_code/struct.SourceCode.html\"]' 'source_code::SourceCode'\n+pub fn foo(a: u32, b: &str, c: String, d: Foo, e: bar::Bar, f: source_code::SourceCode) {\n+    let x = 12;\n+    let y: Foo = Foo;\n+    let z: Bar = bar::Bar { field: Foo };\n+    babar();\n+    // @has - '//a[@href=\"../../src/foo/check-source-code-urls-to-def.rs.html#24\"]' 'hello'\n+    y.hello();\n+}\n+\n+// @has - '//a[@href=\"../../src/foo/auxiliary/source-code-bar.rs.html#14-16\"]' 'bar::sub::Trait'\n+// @has - '//a[@href=\"../../src/foo/auxiliary/source-code-bar.rs.html#14-16\"]' 'Trait'\n+pub fn foo2<T: bar::sub::Trait, V: Trait>(t: &T, v: &V) {\n+}"}]}