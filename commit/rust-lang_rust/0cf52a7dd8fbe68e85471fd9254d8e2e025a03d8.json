{"sha": "0cf52a7dd8fbe68e85471fd9254d8e2e025a03d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjZjUyYTdkZDhmYmU2OGU4NTQ3MWZkOTI1NGQ4ZTJlMDI1YTAzZDg=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-01-02T23:50:18Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-01-10T00:46:15Z"}, "message": "Parse `?const Trait` bound syntax\n\nThe grammar also handles `?const ?Trait` even though this is\nsemantically redundant.", "tree": {"sha": "d9983eed48a9c539764a9ba958782a0e6326d5aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9983eed48a9c539764a9ba958782a0e6326d5aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0cf52a7dd8fbe68e85471fd9254d8e2e025a03d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0cf52a7dd8fbe68e85471fd9254d8e2e025a03d8", "html_url": "https://github.com/rust-lang/rust/commit/0cf52a7dd8fbe68e85471fd9254d8e2e025a03d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0cf52a7dd8fbe68e85471fd9254d8e2e025a03d8/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c3fe9de4e9b7c41cc0ba86696b4e58f9e0e36e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c3fe9de4e9b7c41cc0ba86696b4e58f9e0e36e4", "html_url": "https://github.com/rust-lang/rust/commit/1c3fe9de4e9b7c41cc0ba86696b4e58f9e0e36e4"}], "stats": {"total": 91, "additions": 77, "deletions": 14}, "files": [{"sha": "ea14aa278ac29e3f83455d4b551695b3b9286494", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 77, "deletions": 14, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/0cf52a7dd8fbe68e85471fd9254d8e2e025a03d8/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf52a7dd8fbe68e85471fd9254d8e2e025a03d8/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=0cf52a7dd8fbe68e85471fd9254d8e2e025a03d8", "patch": "@@ -6,7 +6,7 @@ use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n use rustc_error_codes::*;\n use rustc_errors::{pluralize, struct_span_err, Applicability, PResult};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::kw;\n+use rustc_span::symbol::{kw, sym};\n use syntax::ast::{\n     self, BareFnTy, FunctionRetTy, GenericParam, Ident, Lifetime, MutTy, Ty, TyKind,\n };\n@@ -17,6 +17,24 @@ use syntax::ast::{Mac, Mutability};\n use syntax::ptr::P;\n use syntax::token::{self, Token};\n \n+/// Any `?` or `?const` modifiers that appear at the start of a bound.\n+struct BoundModifiers {\n+    /// `?Trait`.\n+    maybe: Option<Span>,\n+\n+    /// `?const Trait`.\n+    maybe_const: Option<Span>,\n+}\n+\n+impl BoundModifiers {\n+    fn trait_bound_modifier(&self) -> TraitBoundModifier {\n+        match self.maybe {\n+            Some(_) => TraitBoundModifier::Maybe,\n+            None => TraitBoundModifier::None,\n+        }\n+    }\n+}\n+\n /// Returns `true` if `IDENT t` can start a type -- `IDENT::a::b`, `IDENT<u8, u8>`,\n /// `IDENT<<u8 as Trait>::AssocTy>`.\n ///\n@@ -195,7 +213,9 @@ impl<'a> Parser<'a> {\n         lo: Span,\n         parse_plus: bool,\n     ) -> PResult<'a, TyKind> {\n-        let poly_trait_ref = PolyTraitRef::new(generic_params, path, lo.to(self.prev_span));\n+        assert_ne!(self.token, token::Question);\n+\n+        let poly_trait_ref = PolyTraitRef::new(generic_params, path, None, lo.to(self.prev_span));\n         let mut bounds = vec![GenericBound::Trait(poly_trait_ref, TraitBoundModifier::None)];\n         if parse_plus {\n             self.eat_plus(); // `+`, or `+=` gets split and `+` is discarded\n@@ -421,12 +441,15 @@ impl<'a> Parser<'a> {\n         let has_parens = self.eat(&token::OpenDelim(token::Paren));\n         let inner_lo = self.token.span;\n         let is_negative = self.eat(&token::Not);\n-        let question = self.eat(&token::Question).then_some(self.prev_span);\n+\n+        let modifiers = self.parse_ty_bound_modifiers();\n         let bound = if self.token.is_lifetime() {\n-            self.parse_generic_lt_bound(lo, inner_lo, has_parens, question)?\n+            self.error_lt_bound_with_modifiers(modifiers);\n+            self.parse_generic_lt_bound(lo, inner_lo, has_parens)?\n         } else {\n-            self.parse_generic_ty_bound(lo, has_parens, question)?\n+            self.parse_generic_ty_bound(lo, has_parens, modifiers)?\n         };\n+\n         Ok(if is_negative { Err(anchor_lo.to(self.prev_span)) } else { Ok(bound) })\n     }\n \n@@ -439,9 +462,7 @@ impl<'a> Parser<'a> {\n         lo: Span,\n         inner_lo: Span,\n         has_parens: bool,\n-        question: Option<Span>,\n     ) -> PResult<'a, GenericBound> {\n-        self.error_opt_out_lifetime(question);\n         let bound = GenericBound::Outlives(self.expect_lifetime());\n         if has_parens {\n             // FIXME(Centril): Consider not erroring here and accepting `('lt)` instead,\n@@ -451,8 +472,17 @@ impl<'a> Parser<'a> {\n         Ok(bound)\n     }\n \n-    fn error_opt_out_lifetime(&self, question: Option<Span>) {\n-        if let Some(span) = question {\n+    /// Emits an error if any trait bound modifiers were present.\n+    fn error_lt_bound_with_modifiers(&self, modifiers: BoundModifiers) {\n+        if let Some(span) = modifiers.maybe_const {\n+            self.struct_span_err(\n+                span,\n+                \"`?const` may only modify trait bounds, not lifetime bounds\",\n+            )\n+            .emit();\n+        }\n+\n+        if let Some(span) = modifiers.maybe {\n             self.struct_span_err(span, \"`?` may only modify trait bounds, not lifetime bounds\")\n                 .emit();\n         }\n@@ -478,25 +508,58 @@ impl<'a> Parser<'a> {\n         Ok(())\n     }\n \n+    /// Parses the modifiers that may precede a trait in a bound, e.g. `?Trait` or `?const Trait`.\n+    ///\n+    /// If no modifiers are present, this does not consume any tokens.\n+    ///\n+    /// ```\n+    /// TY_BOUND_MODIFIERS = \"?\" [\"const\" [\"?\"]]\n+    /// ```\n+    fn parse_ty_bound_modifiers(&mut self) -> BoundModifiers {\n+        if !self.eat(&token::Question) {\n+            return BoundModifiers { maybe: None, maybe_const: None };\n+        }\n+\n+        // `? ...`\n+        let first_question = self.prev_span;\n+        if !self.eat_keyword(kw::Const) {\n+            return BoundModifiers { maybe: Some(first_question), maybe_const: None };\n+        }\n+\n+        // `?const ...`\n+        let maybe_const = first_question.to(self.prev_span);\n+        self.sess.gated_spans.gate(sym::const_trait_bound_opt_out, maybe_const);\n+        if !self.eat(&token::Question) {\n+            return BoundModifiers { maybe: None, maybe_const: Some(maybe_const) };\n+        }\n+\n+        // `?const ? ...`\n+        let second_question = self.prev_span;\n+        BoundModifiers { maybe: Some(second_question), maybe_const: Some(maybe_const) }\n+    }\n+\n     /// Parses a type bound according to:\n     /// ```\n     /// TY_BOUND = TY_BOUND_NOPAREN | (TY_BOUND_NOPAREN)\n-    /// TY_BOUND_NOPAREN = [?] [for<LT_PARAM_DEFS>] SIMPLE_PATH (e.g., `?for<'a: 'b> m::Trait<'a>`)\n+    /// TY_BOUND_NOPAREN = [TY_BOUND_MODIFIERS] [for<LT_PARAM_DEFS>] SIMPLE_PATH\n     /// ```\n+    ///\n+    /// For example, this grammar accepts `?const ?for<'a: 'b> m::Trait<'a>`.\n     fn parse_generic_ty_bound(\n         &mut self,\n         lo: Span,\n         has_parens: bool,\n-        question: Option<Span>,\n+        modifiers: BoundModifiers,\n     ) -> PResult<'a, GenericBound> {\n         let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n         let path = self.parse_path(PathStyle::Type)?;\n         if has_parens {\n             self.expect(&token::CloseDelim(token::Paren))?;\n         }\n-        let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo.to(self.prev_span));\n-        let modifier = question.map_or(TraitBoundModifier::None, |_| TraitBoundModifier::Maybe);\n-        Ok(GenericBound::Trait(poly_trait, modifier))\n+\n+        let constness = modifiers.maybe_const.map(|_| ast::Constness::NotConst);\n+        let poly_trait = PolyTraitRef::new(lifetime_defs, path, constness, lo.to(self.prev_span));\n+        Ok(GenericBound::Trait(poly_trait, modifiers.trait_bound_modifier()))\n     }\n \n     /// Optionally parses `for<$generic_params>`."}]}