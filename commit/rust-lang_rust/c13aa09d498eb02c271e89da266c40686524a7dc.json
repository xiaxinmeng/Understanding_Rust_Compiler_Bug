{"sha": "c13aa09d498eb02c271e89da266c40686524a7dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxM2FhMDlkNDk4ZWIwMmMyNzFlODlkYTI2NmM0MDY4NjUyNGE3ZGM=", "commit": {"author": {"name": "Gabriel Smith", "email": "ga29smith@gmail.com", "date": "2019-03-01T04:05:47Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-05-01T22:10:57Z"}, "message": "impl fold_const for TypeFreshener\n\nSigned-off-by: Gabriel Smith <ga29smith@gmail.com>", "tree": {"sha": "ba1cd22fc1397d449ae3adaae034f4dd35c9f3a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba1cd22fc1397d449ae3adaae034f4dd35c9f3a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c13aa09d498eb02c271e89da266c40686524a7dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c13aa09d498eb02c271e89da266c40686524a7dc", "html_url": "https://github.com/rust-lang/rust/commit/c13aa09d498eb02c271e89da266c40686524a7dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c13aa09d498eb02c271e89da266c40686524a7dc/comments", "author": {"login": "yodaldevoid", "id": 1204409, "node_id": "MDQ6VXNlcjEyMDQ0MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1204409?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yodaldevoid", "html_url": "https://github.com/yodaldevoid", "followers_url": "https://api.github.com/users/yodaldevoid/followers", "following_url": "https://api.github.com/users/yodaldevoid/following{/other_user}", "gists_url": "https://api.github.com/users/yodaldevoid/gists{/gist_id}", "starred_url": "https://api.github.com/users/yodaldevoid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yodaldevoid/subscriptions", "organizations_url": "https://api.github.com/users/yodaldevoid/orgs", "repos_url": "https://api.github.com/users/yodaldevoid/repos", "events_url": "https://api.github.com/users/yodaldevoid/events{/privacy}", "received_events_url": "https://api.github.com/users/yodaldevoid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e965b756035f5c746f79d04369e0b33ffa71e10e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e965b756035f5c746f79d04369e0b33ffa71e10e", "html_url": "https://github.com/rust-lang/rust/commit/e965b756035f5c746f79d04369e0b33ffa71e10e"}], "stats": {"total": 114, "additions": 92, "deletions": 22}, "files": [{"sha": "b43f78efffb60125fabb4b9ec12ef115786d435e", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 92, "deletions": 22, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/c13aa09d498eb02c271e89da266c40686524a7dc/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c13aa09d498eb02c271e89da266c40686524a7dc/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=c13aa09d498eb02c271e89da266c40686524a7dc", "patch": "@@ -31,6 +31,7 @@\n //! variable only once, and it does so as soon as it can, so it is reasonable to ask what the type\n //! inferencer knows \"so far\".\n \n+use crate::mir::interpret::ConstValue;\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use crate::ty::fold::TypeFolder;\n use crate::util::nodemap::FxHashMap;\n@@ -42,42 +43,74 @@ use super::unify_key::ToType;\n \n pub struct TypeFreshener<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    freshen_count: u32,\n-    freshen_map: FxHashMap<ty::InferTy, Ty<'tcx>>,\n+    ty_freshen_count: u32,\n+    const_freshen_count: u32,\n+    ty_freshen_map: FxHashMap<ty::InferTy, Ty<'tcx>>,\n+    const_freshen_map: FxHashMap<ty::InferConst<'tcx>, &'tcx ty::LazyConst<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n     pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>)\n                -> TypeFreshener<'a, 'gcx, 'tcx> {\n         TypeFreshener {\n             infcx,\n-            freshen_count: 0,\n-            freshen_map: Default::default(),\n+            ty_freshen_count: 0,\n+            const_freshen_count: 0,\n+            ty_freshen_map: Default::default(),\n+            const_freshen_map: Default::default(),\n         }\n     }\n \n-    fn freshen<F>(&mut self,\n-                  opt_ty: Option<Ty<'tcx>>,\n-                  key: ty::InferTy,\n-                  freshener: F)\n-                  -> Ty<'tcx> where\n+    fn freshen_ty<F>(\n+        &mut self,\n+        opt_ty: Option<Ty<'tcx>>,\n+        key: ty::InferTy,\n+        freshener: F,\n+    ) -> Ty<'tcx>\n+    where\n         F: FnOnce(u32) -> ty::InferTy,\n     {\n         if let Some(ty) = opt_ty {\n             return ty.fold_with(self);\n         }\n \n-        match self.freshen_map.entry(key) {\n+        match self.ty_freshen_map.entry(key) {\n             Entry::Occupied(entry) => *entry.get(),\n             Entry::Vacant(entry) => {\n-                let index = self.freshen_count;\n-                self.freshen_count += 1;\n+                let index = self.ty_freshen_count;\n+                self.ty_freshen_count += 1;\n                 let t = self.infcx.tcx.mk_ty_infer(freshener(index));\n                 entry.insert(t);\n                 t\n             }\n         }\n     }\n+\n+    fn freshen_const<F>(\n+        &mut self,\n+        opt_ct: Option<&'tcx ty::LazyConst<'tcx>>,\n+        key: ty::InferConst<'tcx>,\n+        freshener: F,\n+        ty: Ty<'tcx>,\n+    ) -> &'tcx ty::LazyConst<'tcx>\n+    where\n+        F: FnOnce(u32) -> ty::InferConst<'tcx>,\n+    {\n+        if let Some(ct) = opt_ct {\n+            return ct.fold_with(self);\n+        }\n+\n+        match self.const_freshen_map.entry(key) {\n+            Entry::Occupied(entry) => *entry.get(),\n+            Entry::Vacant(entry) => {\n+                let index = self.const_freshen_count;\n+                self.const_freshen_count += 1;\n+                let ct = self.infcx.tcx.mk_const_infer(freshener(index), ty);\n+                entry.insert(ct);\n+                ct\n+            }\n+        }\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n@@ -124,14 +157,14 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n         match t.sty {\n             ty::Infer(ty::TyVar(v)) => {\n                 let opt_ty = self.infcx.type_variables.borrow_mut().probe(v).known();\n-                self.freshen(\n+                self.freshen_ty(\n                     opt_ty,\n                     ty::TyVar(v),\n                     ty::FreshTy)\n             }\n \n             ty::Infer(ty::IntVar(v)) => {\n-                self.freshen(\n+                self.freshen_ty(\n                     self.infcx.int_unification_table.borrow_mut()\n                                                     .probe_value(v)\n                                                     .map(|v| v.to_type(tcx)),\n@@ -140,22 +173,22 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             }\n \n             ty::Infer(ty::FloatVar(v)) => {\n-                self.freshen(\n+                self.freshen_ty(\n                     self.infcx.float_unification_table.borrow_mut()\n                                                       .probe_value(v)\n                                                       .map(|v| v.to_type(tcx)),\n                     ty::FloatVar(v),\n                     ty::FreshFloatTy)\n             }\n \n-            ty::Infer(ty::FreshTy(c)) |\n-            ty::Infer(ty::FreshIntTy(c)) |\n-            ty::Infer(ty::FreshFloatTy(c)) => {\n-                if c >= self.freshen_count {\n+            ty::Infer(ty::FreshTy(ct)) |\n+            ty::Infer(ty::FreshIntTy(ct)) |\n+            ty::Infer(ty::FreshFloatTy(ct)) => {\n+                if ct >= self.ty_freshen_count {\n                     bug!(\"Encountered a freshend type with id {} \\\n                           but our counter is only at {}\",\n-                         c,\n-                         self.freshen_count);\n+                         ct,\n+                         self.ty_freshen_count);\n                 }\n                 t\n             }\n@@ -194,6 +227,43 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n     }\n \n     fn fold_const(&mut self, ct: &'tcx ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n-        ct // FIXME(const_generics)\n+        if let ty::LazyConst::Evaluated(ty::Const{ val, ty }) = ct {\n+            match val {\n+                ConstValue::Infer(ty::InferConst::Var(v)) => {\n+                    let opt_ct = self.infcx.const_unification_table\n+                        .borrow_mut()\n+                        .probe(*v)\n+                        .known();\n+                    return self.freshen_const(\n+                        opt_ct,\n+                        ty::InferConst::Var(*v),\n+                        ty::InferConst::Fresh,\n+                        ty,\n+                    );\n+                }\n+                ConstValue::Infer(ty::InferConst::Fresh(i)) => {\n+                    if *i >= self.const_freshen_count {\n+                        bug!(\n+                            \"Encountered a freshend const with id {} \\\n+                                but our counter is only at {}\",\n+                            i,\n+                            self.const_freshen_count,\n+                        );\n+                    }\n+                    return ct;\n+                }\n+\n+                ConstValue::Infer(ty::InferConst::Canonical(..)) => {\n+                    bug!(\"unexpected const {:?}\", ct)\n+                }\n+\n+                ConstValue::Param(_) |\n+                ConstValue::Scalar(_) |\n+                ConstValue::Slice(..) |\n+                ConstValue::ByRef(..) => {}\n+            }\n+        }\n+\n+        ct.super_fold_with(self)\n     }\n }"}]}