{"sha": "969a3743e6363ce526f5ec8577b7de95dfc1e984", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2OWEzNzQzZTYzNjNjZTUyNmY1ZWM4NTc3YjdkZTk1ZGZjMWU5ODQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-30T08:05:14Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-30T08:46:30Z"}, "message": "Subslice patterns: Test passing static & dynamic semantics.", "tree": {"sha": "f5cddcd79143afc7ced39d3d39c88c58379f7d76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5cddcd79143afc7ced39d3d39c88c58379f7d76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/969a3743e6363ce526f5ec8577b7de95dfc1e984", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/969a3743e6363ce526f5ec8577b7de95dfc1e984", "html_url": "https://github.com/rust-lang/rust/commit/969a3743e6363ce526f5ec8577b7de95dfc1e984", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/969a3743e6363ce526f5ec8577b7de95dfc1e984/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "url": "https://api.github.com/repos/rust-lang/rust/commits/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "html_url": "https://github.com/rust-lang/rust/commit/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37"}], "stats": {"total": 128, "additions": 128, "deletions": 0}, "files": [{"sha": "1ebf3def78876b5622c6713f2d4f00f660a7377c", "filename": "src/test/ui/array-slice-vec/subslice-patterns-pass.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/969a3743e6363ce526f5ec8577b7de95dfc1e984/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969a3743e6363ce526f5ec8577b7de95dfc1e984/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-pass.rs?ref=969a3743e6363ce526f5ec8577b7de95dfc1e984", "patch": "@@ -0,0 +1,128 @@\n+// This test comprehensively checks the passing static and dynamic semantics\n+// of subslice patterns `..`, `x @ ..`, `ref x @ ..`, and `ref mut @ ..`\n+// in slice patterns `[$($pat), $(,)?]` .\n+\n+// run-pass\n+\n+#![feature(slice_patterns)]\n+\n+#![allow(unreachable_patterns)]\n+\n+use std::convert::identity;\n+\n+#[derive(PartialEq, Debug, Clone)]\n+struct N(u8);\n+\n+macro_rules! n {\n+    ($($e:expr),* $(,)?) => {\n+        [$(N($e)),*]\n+    }\n+}\n+\n+macro_rules! c {\n+    ($inp:expr, $typ:ty, $out:expr $(,)?) => {\n+        assert_eq!($out, identity::<$typ>($inp));\n+    }\n+}\n+\n+macro_rules! m {\n+    ($e:expr, $p:pat => $b:expr) => {\n+        match $e {\n+            $p => $b,\n+            _ => panic!(),\n+        }\n+    }\n+}\n+\n+fn main() {\n+    slices();\n+    arrays();\n+}\n+\n+fn slices() {\n+    // Matching slices using `ref` patterns:\n+    let mut v = vec![N(0), N(1), N(2), N(3), N(4)];\n+    let mut vc = (0..=4).collect::<Vec<u8>>();\n+\n+    let [..] = v[..]; // Always matches.\n+    m!(v[..], [N(0), ref sub @ .., N(4)] => c!(sub, &[N], n![1, 2, 3]));\n+    m!(v[..], [N(0), ref sub @ ..] => c!(sub, &[N], n![1, 2, 3, 4]));\n+    m!(v[..], [ref sub @ .., N(4)] => c!(sub, &[N], n![0, 1, 2, 3]));\n+    m!(v[..], [ref sub @ .., _, _, _, _, _] => c!(sub, &[N], &n![] as &[N]));\n+    m!(v[..], [_, _, _, _, _, ref sub @ ..] => c!(sub, &[N], &n![] as &[N]));\n+    m!(vc[..], [x, .., y] => c!((x, y), (u8, u8), (0, 4)));\n+\n+    // Matching slices using `ref mut` patterns:\n+    let [..] = v[..]; // Always matches.\n+    m!(v[..], [N(0), ref mut sub @ .., N(4)] => c!(sub, &mut [N], n![1, 2, 3]));\n+    m!(v[..], [N(0), ref mut sub @ ..] => c!(sub, &mut [N], n![1, 2, 3, 4]));\n+    m!(v[..], [ref mut sub @ .., N(4)] => c!(sub, &mut [N], n![0, 1, 2, 3]));\n+    m!(v[..], [ref mut sub @ .., _, _, _, _, _] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n+    m!(v[..], [_, _, _, _, _, ref mut sub @ ..] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n+    m!(vc[..], [x, .., y] => c!((x, y), (u8, u8), (0, 4)));\n+\n+    // Matching slices using default binding modes (&):\n+    let [..] = &v[..]; // Always matches.\n+    m!(&v[..], [N(0), sub @ .., N(4)] => c!(sub, &[N], n![1, 2, 3]));\n+    m!(&v[..], [N(0), sub @ ..] => c!(sub, &[N], n![1, 2, 3, 4]));\n+    m!(&v[..], [sub @ .., N(4)] => c!(sub, &[N], n![0, 1, 2, 3]));\n+    m!(&v[..], [sub @ .., _, _, _, _, _] => c!(sub, &[N], &n![] as &[N]));\n+    m!(&v[..], [_, _, _, _, _, sub @ ..] => c!(sub, &[N], &n![] as &[N]));\n+    m!(&vc[..], [x, .., y] => c!((x, y), (&u8, &u8), (&0, &4)));\n+\n+    // Matching slices using default binding modes (&mut):\n+    let [..] = &mut v[..]; // Always matches.\n+    m!(&mut v[..], [N(0), sub @ .., N(4)] => c!(sub, &mut [N], n![1, 2, 3]));\n+    m!(&mut v[..], [N(0), sub @ ..] => c!(sub, &mut [N], n![1, 2, 3, 4]));\n+    m!(&mut v[..], [sub @ .., N(4)] => c!(sub, &mut [N], n![0, 1, 2, 3]));\n+    m!(&mut v[..], [sub @ .., _, _, _, _, _] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n+    m!(&mut v[..], [_, _, _, _, _, sub @ ..] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n+    m!(&mut vc[..], [x, .., y] => c!((x, y), (&mut u8, &mut u8), (&mut 0, &mut 4)));\n+}\n+\n+fn arrays() {\n+    let mut v = n![0, 1, 2, 3, 4];\n+    let vc = [0, 1, 2, 3, 4];\n+\n+    // Matching arrays by value:\n+    m!(v.clone(), [N(0), sub @ .., N(4)] => c!(sub, [N; 3], n![1, 2, 3]));\n+    m!(v.clone(), [N(0), sub @ ..] => c!(sub, [N; 4], n![1, 2, 3, 4]));\n+    m!(v.clone(), [sub @ .., N(4)] => c!(sub, [N; 4], n![0, 1, 2, 3]));\n+    m!(v.clone(), [sub @ .., _, _, _, _, _] => c!(sub, [N; 0], n![] as [N; 0]));\n+    m!(v.clone(), [_, _, _, _, _, sub @ ..] => c!(sub, [N; 0], n![] as [N; 0]));\n+    m!(v.clone(), [x, .., y] => c!((x, y), (N, N), (N(0), N(4))));\n+    m!(v.clone(), [..] => ());\n+\n+    // Matching arrays by ref patterns:\n+    m!(v, [N(0), ref sub @ .., N(4)] => c!(sub, &[N; 3], &n![1, 2, 3]));\n+    m!(v, [N(0), ref sub @ ..] => c!(sub, &[N; 4], &n![1, 2, 3, 4]));\n+    m!(v, [ref sub @ .., N(4)] => c!(sub, &[N; 4], &n![0, 1, 2, 3]));\n+    m!(v, [ref sub @ .., _, _, _, _, _] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n+    m!(v, [_, _, _, _, _, ref sub @ ..] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n+    m!(vc, [x, .., y] => c!((x, y), (u8, u8), (0, 4)));\n+\n+    // Matching arrays by ref mut patterns:\n+    m!(v, [N(0), ref mut sub @ .., N(4)] => c!(sub, &mut [N; 3], &mut n![1, 2, 3]));\n+    m!(v, [N(0), ref mut sub @ ..] => c!(sub, &mut [N; 4], &mut n![1, 2, 3, 4]));\n+    m!(v, [ref mut sub @ .., N(4)] => c!(sub, &mut [N; 4], &mut n![0, 1, 2, 3]));\n+    m!(v, [ref mut sub @ .., _, _, _, _, _] => c!(sub, &mut [N; 0], &mut n![] as &mut [N; 0]));\n+    m!(v, [_, _, _, _, _, ref mut sub @ ..] => c!(sub, &mut [N; 0], &mut n![] as &mut [N; 0]));\n+\n+    // Matching arrays by default binding modes (&):\n+    m!(&v, [N(0), sub @ .., N(4)] => c!(sub, &[N; 3], &n![1, 2, 3]));\n+    m!(&v, [N(0), sub @ ..] => c!(sub, &[N; 4], &n![1, 2, 3, 4]));\n+    m!(&v, [sub @ .., N(4)] => c!(sub, &[N; 4], &n![0, 1, 2, 3]));\n+    m!(&v, [sub @ .., _, _, _, _, _] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n+    m!(&v, [_, _, _, _, _, sub @ ..] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n+    m!(&v, [..] => ());\n+    m!(&v, [x, .., y] => c!((x, y), (&N, &N), (&N(0), &N(4))));\n+\n+    // Matching arrays by default binding modes (&mut):\n+    m!(&mut v, [N(0), sub @ .., N(4)] => c!(sub, &mut [N; 3], &mut n![1, 2, 3]));\n+    m!(&mut v, [N(0), sub @ ..] => c!(sub, &mut [N; 4], &mut n![1, 2, 3, 4]));\n+    m!(&mut v, [sub @ .., N(4)] => c!(sub, &mut [N; 4], &mut n![0, 1, 2, 3]));\n+    m!(&mut v, [sub @ .., _, _, _, _, _] => c!(sub, &mut [N; 0], &mut n![] as &[N; 0]));\n+    m!(&mut v, [_, _, _, _, _, sub @ ..] => c!(sub, &mut [N; 0], &mut n![] as &[N; 0]));\n+    m!(&mut v, [..] => ());\n+    m!(&mut v, [x, .., y] => c!((x, y), (&mut N, &mut N), (&mut N(0), &mut N(4))));\n+}"}]}