{"sha": "8c6421fb17841f5a7071ae691edc76e8b7286bc8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjNjQyMWZiMTc4NDFmNWE3MDcxYWU2OTFlZGM3NmU4YjcyODZiYzg=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-07-30T08:14:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-30T08:14:46Z"}, "message": "Rollup merge of #35063 - jseyfried:avoid_importing_inaccessible_names, r=nrc\n\nresolve: Exclude inaccessible names from single imports\n\nIf a single import resolves to an inaccessible name in some but not all namespaces, avoid importing the name in the inaccessible namespaces.\n\nCurrently, the inaccessible namespaces are imported but cause a privacy error when used.\n\nr? @nrc", "tree": {"sha": "944eb888327cb83be20b8918d10f2c38527a8b8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/944eb888327cb83be20b8918d10f2c38527a8b8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c6421fb17841f5a7071ae691edc76e8b7286bc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c6421fb17841f5a7071ae691edc76e8b7286bc8", "html_url": "https://github.com/rust-lang/rust/commit/8c6421fb17841f5a7071ae691edc76e8b7286bc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c6421fb17841f5a7071ae691edc76e8b7286bc8/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6234610252a1723467fd52527ffef3180a545ce5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6234610252a1723467fd52527ffef3180a545ce5", "html_url": "https://github.com/rust-lang/rust/commit/6234610252a1723467fd52527ffef3180a545ce5"}, {"sha": "8205691929bc545430f1fa73e61a4f5f77fbbdc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8205691929bc545430f1fa73e61a4f5f77fbbdc7", "html_url": "https://github.com/rust-lang/rust/commit/8205691929bc545430f1fa73e61a4f5f77fbbdc7"}], "stats": {"total": 101, "additions": 43, "deletions": 58}, "files": [{"sha": "8c8cf1da467388cc98c3bec6d88c8cfda283e077", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c6421fb17841f5a7071ae691edc76e8b7286bc8/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6421fb17841f5a7071ae691edc76e8b7286bc8/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8c6421fb17841f5a7071ae691edc76e8b7286bc8", "patch": "@@ -825,8 +825,6 @@ enum NameBindingKind<'a> {\n     Import {\n         binding: &'a NameBinding<'a>,\n         directive: &'a ImportDirective<'a>,\n-        // Some(error) if using this imported name causes the import to be a privacy error\n-        privacy_error: Option<Box<PrivacyError<'a>>>,\n     },\n }\n \n@@ -1206,16 +1204,11 @@ impl<'a> Resolver<'a> {\n             self.used_crates.insert(krate);\n         }\n \n-        let (directive, privacy_error) = match binding.kind {\n-            NameBindingKind::Import { directive, ref privacy_error, .. } =>\n-                (directive, privacy_error),\n+        let directive = match binding.kind {\n+            NameBindingKind::Import { directive, .. } => directive,\n             _ => return,\n         };\n \n-        if let Some(error) = privacy_error.as_ref() {\n-            self.privacy_errors.push((**error).clone());\n-        }\n-\n         if !self.make_glob_map {\n             return;\n         }"}, {"sha": "fc5e2a48e876ccc2eaf5391dd85a4e399f7ec2ee", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 33, "deletions": 41, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/8c6421fb17841f5a7071ae691edc76e8b7286bc8/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6421fb17841f5a7071ae691edc76e8b7286bc8/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=8c6421fb17841f5a7071ae691edc76e8b7286bc8", "patch": "@@ -73,13 +73,11 @@ pub struct ImportDirective<'a> {\n impl<'a> ImportDirective<'a> {\n     // Given the binding to which this directive resolves in a particular namespace,\n     // this returns the binding for the name this directive defines in that namespace.\n-    fn import(&'a self, binding: &'a NameBinding<'a>, privacy_error: Option<Box<PrivacyError<'a>>>)\n-              -> NameBinding<'a> {\n+    fn import(&'a self, binding: &'a NameBinding<'a>) -> NameBinding<'a> {\n         NameBinding {\n             kind: NameBindingKind::Import {\n                 binding: binding,\n                 directive: self,\n-                privacy_error: privacy_error,\n             },\n             span: self.span,\n             vis: self.vis,\n@@ -328,7 +326,7 @@ impl<'a> ::ModuleS<'a> {\n     fn define_in_glob_importers(&self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>) {\n         if !binding.is_importable() || !binding.is_pseudo_public() { return }\n         for &(importer, directive) in self.glob_importers.borrow_mut().iter() {\n-            let _ = importer.try_define_child(name, ns, directive.import(binding, None));\n+            let _ = importer.try_define_child(name, ns, directive.import(binding));\n         }\n     }\n }\n@@ -409,7 +407,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 span: DUMMY_SP,\n                 vis: ty::Visibility::Public,\n             });\n-            let dummy_binding = directive.import(dummy_binding, None);\n+            let dummy_binding = directive.import(dummy_binding);\n \n             let _ = source_module.try_define_child(target, ValueNS, dummy_binding.clone());\n             let _ = source_module.try_define_child(target, TypeNS, dummy_binding);\n@@ -494,38 +492,37 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             self.resolver.resolve_name_in_module(target_module, source, TypeNS, false, true);\n \n         let module_ = self.resolver.current_module;\n+        let mut privacy_error = true;\n         for &(ns, result, determined) in &[(ValueNS, &value_result, value_determined),\n                                            (TypeNS, &type_result, type_determined)] {\n-            if determined.get() { continue }\n-            if let Indeterminate = *result { continue }\n-\n-            determined.set(true);\n-            if let Success(binding) = *result {\n-                if !binding.is_importable() {\n+            match *result {\n+                Failed(..) if !determined.get() => {\n+                    determined.set(true);\n+                    module_.update_resolution(target, ns, |resolution| {\n+                        resolution.single_imports.directive_failed()\n+                    });\n+                }\n+                Success(binding) if !binding.is_importable() => {\n                     let msg = format!(\"`{}` is not directly importable\", target);\n                     span_err!(self.resolver.session, directive.span, E0253, \"{}\", &msg);\n                     // Do not import this illegal binding. Import a dummy binding and pretend\n                     // everything is fine\n                     self.import_dummy_binding(module_, directive);\n                     return Success(());\n                 }\n-\n-                let privacy_error = if !self.resolver.is_accessible(binding.vis) {\n-                    Some(Box::new(PrivacyError(directive.span, source, binding)))\n-                } else {\n-                    None\n-                };\n-\n-                let imported_binding = directive.import(binding, privacy_error);\n-                let conflict = module_.try_define_child(target, ns, imported_binding);\n-                if let Err(old_binding) = conflict {\n-                    let binding = &directive.import(binding, None);\n-                    self.resolver.report_conflict(module_, target, ns, binding, old_binding);\n+                Success(binding) if !self.resolver.is_accessible(binding.vis) => {}\n+                Success(binding) if !determined.get() => {\n+                    determined.set(true);\n+                    let imported_binding = directive.import(binding);\n+                    let conflict = module_.try_define_child(target, ns, imported_binding);\n+                    if let Err(old_binding) = conflict {\n+                        let binding = &directive.import(binding);\n+                        self.resolver.report_conflict(module_, target, ns, binding, old_binding);\n+                    }\n+                    privacy_error = false;\n                 }\n-            } else {\n-                module_.update_resolution(target, ns, |resolution| {\n-                    resolution.single_imports.directive_failed();\n-                });\n+                Success(_) => privacy_error = false,\n+                _ => {}\n             }\n         }\n \n@@ -556,6 +553,14 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             _ => (),\n         }\n \n+        if privacy_error {\n+            for &(ns, result) in &[(ValueNS, &value_result), (TypeNS, &type_result)] {\n+                let binding = match *result { Success(binding) => binding, _ => continue };\n+                self.resolver.privacy_errors.push(PrivacyError(directive.span, source, binding));\n+                let _ = module_.try_define_child(target, ns, directive.import(binding));\n+            }\n+        }\n+\n         match (&value_result, &type_result) {\n             (&Success(binding), _) if !binding.pseudo_vis()\n                                               .is_at_least(directive.vis, self.resolver) &&\n@@ -592,19 +597,6 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             _ => {}\n         }\n \n-        // Report a privacy error here if all successful namespaces are privacy errors.\n-        let mut privacy_error = None;\n-        for &ns in &[ValueNS, TypeNS] {\n-            privacy_error = match module_.resolve_name(target, ns, true) {\n-                Success(&NameBinding {\n-                    kind: NameBindingKind::Import { ref privacy_error, .. }, ..\n-                }) => privacy_error.as_ref().map(|error| (**error).clone()),\n-                _ => continue,\n-            };\n-            if privacy_error.is_none() { break }\n-        }\n-        privacy_error.map(|error| self.resolver.privacy_errors.push(error));\n-\n         // Record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n@@ -652,7 +644,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }).collect::<Vec<_>>();\n         for ((name, ns), binding) in bindings {\n             if binding.is_importable() && binding.is_pseudo_public() {\n-                let _ = module_.try_define_child(name, ns, directive.import(binding, None));\n+                let _ = module_.try_define_child(name, ns, directive.import(binding));\n             }\n         }\n "}, {"sha": "7accf0ca8201c27da5c21be4463c7fe765572dac", "filename": "src/test/compile-fail/privacy-ns2.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c6421fb17841f5a7071ae691edc76e8b7286bc8/src%2Ftest%2Fcompile-fail%2Fprivacy-ns2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6421fb17841f5a7071ae691edc76e8b7286bc8/src%2Ftest%2Fcompile-fail%2Fprivacy-ns2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy-ns2.rs?ref=8c6421fb17841f5a7071ae691edc76e8b7286bc8", "patch": "@@ -25,15 +25,15 @@ pub mod foo1 {\n }\n \n fn test_single1() {\n-    use foo1::Bar;  //~ ERROR function `Bar` is private\n+    use foo1::Bar;\n \n-    Bar();\n+    Bar(); //~ ERROR unresolved name `Bar`\n }\n \n fn test_list1() {\n-    use foo1::{Bar,Baz};  //~ ERROR `Bar` is private\n+    use foo1::{Bar,Baz};\n \n-    Bar();\n+    Bar(); //~ ERROR unresolved name `Bar`\n }\n \n // private type, public value\n@@ -46,15 +46,15 @@ pub mod foo2 {\n }\n \n fn test_single2() {\n-    use foo2::Bar;  //~ ERROR trait `Bar` is private\n+    use foo2::Bar;\n \n-    let _x : Box<Bar>;\n+    let _x : Box<Bar>; //~ ERROR type name `Bar` is undefined\n }\n \n fn test_list2() {\n-    use foo2::{Bar,Baz};  //~ ERROR `Bar` is private\n+    use foo2::{Bar,Baz};\n \n-    let _x: Box<Bar>;\n+    let _x: Box<Bar>; //~ ERROR type name `Bar` is undefined\n }\n \n // neither public"}]}