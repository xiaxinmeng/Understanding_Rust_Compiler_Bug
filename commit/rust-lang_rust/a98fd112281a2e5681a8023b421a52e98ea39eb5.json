{"sha": "a98fd112281a2e5681a8023b421a52e98ea39eb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5OGZkMTEyMjgxYTJlNTY4MWE4MDIzYjQyMWE1MmU5OGVhMzllYjU=", "commit": {"author": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2015-07-30T19:59:42Z"}, "committer": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2015-08-01T03:51:51Z"}, "message": "Split off `LocalCrateReader` from `CrateReader`", "tree": {"sha": "e009b444f7865da218b961c9f34f50661fcc89f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e009b444f7865da218b961c9f34f50661fcc89f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a98fd112281a2e5681a8023b421a52e98ea39eb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a98fd112281a2e5681a8023b421a52e98ea39eb5", "html_url": "https://github.com/rust-lang/rust/commit/a98fd112281a2e5681a8023b421a52e98ea39eb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a98fd112281a2e5681a8023b421a52e98ea39eb5/comments", "author": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "111fa82f35b45f5ce97cfcae64a349ceac46f3e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/111fa82f35b45f5ce97cfcae64a349ceac46f3e6", "html_url": "https://github.com/rust-lang/rust/commit/111fa82f35b45f5ce97cfcae64a349ceac46f3e6"}], "stats": {"total": 267, "additions": 142, "deletions": 125}, "files": [{"sha": "578507296fc13fddfa00735f6eda55719d86f500", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 140, "deletions": 123, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/a98fd112281a2e5681a8023b421a52e98ea39eb5/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a98fd112281a2e5681a8023b421a52e98ea39eb5/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=a98fd112281a2e5681a8023b421a52e98ea39eb5", "patch": "@@ -34,14 +34,21 @@ use syntax::codemap::{self, Span, mk_sp, Pos};\n use syntax::parse;\n use syntax::parse::token::InternedString;\n use syntax::visit;\n+use ast_map;\n use log;\n \n+pub struct LocalCrateReader<'a, 'b:'a> {\n+    sess: &'a Session,\n+    creader: CrateReader<'a>,\n+    ast_map: &'a ast_map::Map<'b>,\n+}\n+\n pub struct CrateReader<'a> {\n     sess: &'a Session,\n     next_crate_num: ast::CrateNum,\n }\n \n-impl<'a, 'v> visit::Visitor<'v> for CrateReader<'a> {\n+impl<'a, 'b, 'v> visit::Visitor<'v> for LocalCrateReader<'a, 'b> {\n     fn visit_item(&mut self, a: &ast::Item) {\n         self.process_item(a);\n         visit::walk_item(self, a);\n@@ -152,31 +159,6 @@ impl<'a> CrateReader<'a> {\n         }\n     }\n \n-    // Traverses an AST, reading all the information about use'd crates and\n-    // extern libraries necessary for later resolving, typechecking, linking,\n-    // etc.\n-    pub fn read_crates(&mut self, krate: &ast::Crate) {\n-        self.process_crate(krate);\n-        visit::walk_crate(self, krate);\n-\n-        if log_enabled!(log::DEBUG) {\n-            dump_crates(&self.sess.cstore);\n-        }\n-\n-        for &(ref name, kind) in &self.sess.opts.libs {\n-            register_native_lib(self.sess, None, name.clone(), kind);\n-        }\n-    }\n-\n-    fn process_crate(&self, c: &ast::Crate) {\n-        for a in c.attrs.iter().filter(|m| m.name() == \"link_args\") {\n-            match a.value_str() {\n-                Some(ref linkarg) => self.sess.cstore.add_used_link_args(&linkarg),\n-                None => { /* fallthrough */ }\n-            }\n-        }\n-    }\n-\n     fn extract_crate_info(&self, i: &ast::Item) -> Option<CrateInfo> {\n         match i.node {\n             ast::ItemExternCrate(ref path_opt) => {\n@@ -201,103 +183,6 @@ impl<'a> CrateReader<'a> {\n         }\n     }\n \n-    fn process_item(&mut self, i: &ast::Item) {\n-        match i.node {\n-            ast::ItemExternCrate(_) => {\n-                if !should_link(i) {\n-                    return;\n-                }\n-\n-                match self.extract_crate_info(i) {\n-                    Some(info) => {\n-                        let (cnum, _, _) = self.resolve_crate(&None,\n-                                                              &info.ident,\n-                                                              &info.name,\n-                                                              None,\n-                                                              i.span,\n-                                                              PathKind::Crate);\n-                        self.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n-                    }\n-                    None => ()\n-                }\n-            }\n-            ast::ItemForeignMod(ref fm) => {\n-                if fm.abi == abi::Rust || fm.abi == abi::RustIntrinsic {\n-                    return;\n-                }\n-\n-                // First, add all of the custom link_args attributes\n-                let link_args = i.attrs.iter()\n-                    .filter_map(|at| if at.name() == \"link_args\" {\n-                        Some(at)\n-                    } else {\n-                        None\n-                    })\n-                    .collect::<Vec<&ast::Attribute>>();\n-                for m in &link_args {\n-                    match m.value_str() {\n-                        Some(linkarg) => self.sess.cstore.add_used_link_args(&linkarg),\n-                        None => { /* fallthrough */ }\n-                    }\n-                }\n-\n-                // Next, process all of the #[link(..)]-style arguments\n-                let link_args = i.attrs.iter()\n-                    .filter_map(|at| if at.name() == \"link\" {\n-                        Some(at)\n-                    } else {\n-                        None\n-                    })\n-                    .collect::<Vec<&ast::Attribute>>();\n-                for m in &link_args {\n-                    match m.meta_item_list() {\n-                        Some(items) => {\n-                            let kind = items.iter().find(|k| {\n-                                k.name() == \"kind\"\n-                            }).and_then(|a| a.value_str());\n-                            let kind = match kind {\n-                                Some(k) => {\n-                                    if k == \"static\" {\n-                                        cstore::NativeStatic\n-                                    } else if self.sess.target.target.options.is_like_osx\n-                                              && k == \"framework\" {\n-                                        cstore::NativeFramework\n-                                    } else if k == \"framework\" {\n-                                        cstore::NativeFramework\n-                                    } else if k == \"dylib\" {\n-                                        cstore::NativeUnknown\n-                                    } else {\n-                                        self.sess.span_err(m.span,\n-                                            &format!(\"unknown kind: `{}`\",\n-                                                    k));\n-                                        cstore::NativeUnknown\n-                                    }\n-                                }\n-                                None => cstore::NativeUnknown\n-                            };\n-                            let n = items.iter().find(|n| {\n-                                n.name() == \"name\"\n-                            }).and_then(|a| a.value_str());\n-                            let n = match n {\n-                                Some(n) => n,\n-                                None => {\n-                                    self.sess.span_err(m.span,\n-                                        \"#[link(...)] specified without \\\n-                                         `name = \\\"foo\\\"`\");\n-                                    InternedString::new(\"foo\")\n-                                }\n-                            };\n-                            register_native_lib(self.sess, Some(m.span),\n-                                                n.to_string(), kind);\n-                        }\n-                        None => {}\n-                    }\n-                }\n-            }\n-            _ => { }\n-        }\n-    }\n-\n     fn existing_match(&self, name: &str, hash: Option<&Svh>, kind: PathKind)\n                       -> Option<ast::CrateNum> {\n         let mut ret = None;\n@@ -592,6 +477,138 @@ impl<'a> CrateReader<'a> {\n     }\n }\n \n+impl<'a, 'b> LocalCrateReader<'a, 'b> {\n+    pub fn new(sess: &'a Session, map: &'a ast_map::Map<'b>) -> LocalCrateReader<'a, 'b> {\n+        LocalCrateReader {\n+            sess: sess,\n+            creader: CrateReader::new(sess),\n+            ast_map: map,\n+        }\n+    }\n+\n+    // Traverses an AST, reading all the information about use'd crates and\n+    // extern libraries necessary for later resolving, typechecking, linking,\n+    // etc.\n+    pub fn read_crates(&mut self, krate: &ast::Crate) {\n+        self.process_crate(krate);\n+        visit::walk_crate(self, krate);\n+\n+        if log_enabled!(log::DEBUG) {\n+            dump_crates(&self.sess.cstore);\n+        }\n+\n+        for &(ref name, kind) in &self.sess.opts.libs {\n+            register_native_lib(self.sess, None, name.clone(), kind);\n+        }\n+    }\n+\n+    fn process_crate(&self, c: &ast::Crate) {\n+        for a in c.attrs.iter().filter(|m| m.name() == \"link_args\") {\n+            match a.value_str() {\n+                Some(ref linkarg) => self.sess.cstore.add_used_link_args(&linkarg),\n+                None => { /* fallthrough */ }\n+            }\n+        }\n+    }\n+\n+    fn process_item(&mut self, i: &ast::Item) {\n+        match i.node {\n+            ast::ItemExternCrate(_) => {\n+                if !should_link(i) {\n+                    return;\n+                }\n+\n+                match self.creader.extract_crate_info(i) {\n+                    Some(info) => {\n+                        let (cnum, _, _) = self.creader.resolve_crate(&None,\n+                                                              &info.ident,\n+                                                              &info.name,\n+                                                              None,\n+                                                              i.span,\n+                                                              PathKind::Crate);\n+                        self.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n+                    }\n+                    None => ()\n+                }\n+            }\n+            ast::ItemForeignMod(ref fm) => {\n+                if fm.abi == abi::Rust || fm.abi == abi::RustIntrinsic {\n+                    return;\n+                }\n+\n+                // First, add all of the custom link_args attributes\n+                let link_args = i.attrs.iter()\n+                    .filter_map(|at| if at.name() == \"link_args\" {\n+                        Some(at)\n+                    } else {\n+                        None\n+                    })\n+                    .collect::<Vec<&ast::Attribute>>();\n+                for m in &link_args {\n+                    match m.value_str() {\n+                        Some(linkarg) => self.sess.cstore.add_used_link_args(&linkarg),\n+                        None => { /* fallthrough */ }\n+                    }\n+                }\n+\n+                // Next, process all of the #[link(..)]-style arguments\n+                let link_args = i.attrs.iter()\n+                    .filter_map(|at| if at.name() == \"link\" {\n+                        Some(at)\n+                    } else {\n+                        None\n+                    })\n+                    .collect::<Vec<&ast::Attribute>>();\n+                for m in &link_args {\n+                    match m.meta_item_list() {\n+                        Some(items) => {\n+                            let kind = items.iter().find(|k| {\n+                                k.name() == \"kind\"\n+                            }).and_then(|a| a.value_str());\n+                            let kind = match kind {\n+                                Some(k) => {\n+                                    if k == \"static\" {\n+                                        cstore::NativeStatic\n+                                    } else if self.sess.target.target.options.is_like_osx\n+                                              && k == \"framework\" {\n+                                        cstore::NativeFramework\n+                                    } else if k == \"framework\" {\n+                                        cstore::NativeFramework\n+                                    } else if k == \"dylib\" {\n+                                        cstore::NativeUnknown\n+                                    } else {\n+                                        self.sess.span_err(m.span,\n+                                            &format!(\"unknown kind: `{}`\",\n+                                                    k));\n+                                        cstore::NativeUnknown\n+                                    }\n+                                }\n+                                None => cstore::NativeUnknown\n+                            };\n+                            let n = items.iter().find(|n| {\n+                                n.name() == \"name\"\n+                            }).and_then(|a| a.value_str());\n+                            let n = match n {\n+                                Some(n) => n,\n+                                None => {\n+                                    self.sess.span_err(m.span,\n+                                        \"#[link(...)] specified without \\\n+                                         `name = \\\"foo\\\"`\");\n+                                    InternedString::new(\"foo\")\n+                                }\n+                            };\n+                            register_native_lib(self.sess, Some(m.span),\n+                                                n.to_string(), kind);\n+                        }\n+                        None => {}\n+                    }\n+                }\n+            }\n+            _ => { }\n+        }\n+    }\n+}\n+\n /// Imports the codemap from an external crate into the codemap of the crate\n /// currently being compiled (the \"local crate\").\n ///"}, {"sha": "80db6426917e025d5ad8e97f8c1f8611ffec6a15", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a98fd112281a2e5681a8023b421a52e98ea39eb5/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a98fd112281a2e5681a8023b421a52e98ea39eb5/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=a98fd112281a2e5681a8023b421a52e98ea39eb5", "patch": "@@ -14,7 +14,7 @@ use rustc::session::search_paths::PathKind;\n use rustc::ast_map;\n use rustc::lint;\n use rustc::metadata;\n-use rustc::metadata::creader::CrateReader;\n+use rustc::metadata::creader::LocalCrateReader;\n use rustc::middle::{stability, ty, reachable};\n use rustc::middle::dependency_format;\n use rustc::middle;\n@@ -609,7 +609,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n     let krate = ast_map.krate();\n \n     time(time_passes, \"external crate/lib resolution\", (), |_|\n-         CrateReader::new(&sess).read_crates(krate));\n+         LocalCrateReader::new(&sess, &ast_map).read_crates(krate));\n \n     let lang_items = time(time_passes, \"language item collection\", (), |_|\n                           middle::lang_items::collect_language_items(krate, &sess));"}]}