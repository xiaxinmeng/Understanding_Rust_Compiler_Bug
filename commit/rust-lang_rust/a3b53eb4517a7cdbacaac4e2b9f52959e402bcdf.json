{"sha": "a3b53eb4517a7cdbacaac4e2b9f52959e402bcdf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzYjUzZWI0NTE3YTdjZGJhY2FhYzRlMmI5ZjUyOTU5ZTQwMmJjZGY=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-07-20T11:51:34Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-07-20T11:51:34Z"}, "message": "Better comment handling", "tree": {"sha": "2a7d17c637d1b797e8aab925ba29317a1e9615f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a7d17c637d1b797e8aab925ba29317a1e9615f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3b53eb4517a7cdbacaac4e2b9f52959e402bcdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3b53eb4517a7cdbacaac4e2b9f52959e402bcdf", "html_url": "https://github.com/rust-lang/rust/commit/a3b53eb4517a7cdbacaac4e2b9f52959e402bcdf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3b53eb4517a7cdbacaac4e2b9f52959e402bcdf/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b5e55fb17de690559a7f1343ea3d2e9f91d2fd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b5e55fb17de690559a7f1343ea3d2e9f91d2fd5", "html_url": "https://github.com/rust-lang/rust/commit/2b5e55fb17de690559a7f1343ea3d2e9f91d2fd5"}], "stats": {"total": 103, "additions": 47, "deletions": 56}, "files": [{"sha": "85210e8763849f09c98f8d2377867685197d4a59", "filename": "src/abi.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a3b53eb4517a7cdbacaac4e2b9f52959e402bcdf/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b53eb4517a7cdbacaac4e2b9f52959e402bcdf/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=a3b53eb4517a7cdbacaac4e2b9f52959e402bcdf", "patch": "@@ -149,7 +149,7 @@ pub fn codegen_call<'a, 'tcx: 'a>(\n     func: &Operand<'tcx>,\n     args: &[Operand<'tcx>],\n     destination: &Option<(Place<'tcx>, BasicBlock)>,\n-) -> Inst {\n+) {\n     let func = ::base::trans_operand(fx, func);\n     let return_place = if let Some((place, _)) = destination {\n         ::base::trans_place(fx, place).expect_addr()\n@@ -170,22 +170,21 @@ pub fn codegen_call<'a, 'tcx: 'a>(\n                     }\n                 })\n         ).collect::<Vec<_>>();\n-    let inst = match func {\n+    match func {\n         CValue::Func(func, _) => {\n-            fx.bcx.ins().call(func, &args)\n+            fx.bcx.ins().call(func, &args);\n         }\n         func => {\n             let func_ty = func.layout().ty;\n             let func = func.load_value(fx);\n             let sig = fx.bcx.import_signature(cton_sig_from_fn_ty(fx.tcx, func_ty));\n-            fx.bcx.ins().call_indirect(sig, func, &args)\n+            fx.bcx.ins().call_indirect(sig, func, &args);\n         }\n-    };\n+    }\n     if let Some((_, dest)) = *destination {\n         let ret_ebb = fx.get_ebb(dest);\n         fx.bcx.ins().jump(ret_ebb, &[]);\n     } else {\n         fx.bcx.ins().trap(TrapCode::User(!0));\n     }\n-    inst\n }"}, {"sha": "49a0b30919f21092ce51b2a9c52e441aef7d9e8c", "filename": "src/base.rs", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a3b53eb4517a7cdbacaac4e2b9f52959e402bcdf/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b53eb4517a7cdbacaac4e2b9f52959e402bcdf/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=a3b53eb4517a7cdbacaac4e2b9f52959e402bcdf", "patch": "@@ -106,28 +106,33 @@ pub fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &\n         let ebb = fx.get_ebb(bb);\n         fx.bcx.switch_to_block(ebb);\n \n+        fx.bcx.ins().nop();\n         for stmt in &bb_data.statements {\n-            trans_stmt(fx, stmt)?;\n+            trans_stmt(fx, ebb, stmt)?;\n         }\n \n-        let inst = match &bb_data.terminator().kind {\n+        let mut terminator_head = \"\\n\".to_string();\n+        bb_data.terminator().kind.fmt_head(&mut terminator_head).unwrap();\n+        let inst = fx.bcx.func.layout.last_inst(ebb).unwrap();\n+        fx.add_comment(inst, terminator_head);\n+\n+        match &bb_data.terminator().kind {\n             TerminatorKind::Goto { target } => {\n                 let ebb = fx.get_ebb(*target);\n-                fx.bcx.ins().jump(ebb, &[])\n+                fx.bcx.ins().jump(ebb, &[]);\n             }\n             TerminatorKind::Return => {\n-                fx.bcx.ins().return_(&[])\n+                fx.bcx.ins().return_(&[]);\n             }\n             TerminatorKind::Assert { cond, expected, msg: _, target, cleanup: _ } => {\n                 let cond = trans_operand(fx, cond).load_value(fx);\n                 let target = fx.get_ebb(*target);\n-                let inst = if *expected {\n-                    fx.bcx.ins().brz(cond, target, &[])\n+                if *expected {\n+                    fx.bcx.ins().brz(cond, target, &[]);\n                 } else {\n-                    fx.bcx.ins().brnz(cond, target, &[])\n+                    fx.bcx.ins().brnz(cond, target, &[]);\n                 };\n                 fx.bcx.ins().trap(TrapCode::User(!0));\n-                inst\n             }\n \n             TerminatorKind::SwitchInt { discr, switch_ty: _, values, targets } => {\n@@ -138,16 +143,15 @@ pub fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &\n                     jt_data.set_entry(*value as usize, ebb);\n                 }\n                 let mut jump_table = fx.bcx.create_jump_table(jt_data);\n-                let inst = fx.bcx.ins().br_table(discr, jump_table);\n+                fx.bcx.ins().br_table(discr, jump_table);\n                 let otherwise_ebb = fx.get_ebb(targets[targets.len() - 1]);\n                 fx.bcx.ins().jump(otherwise_ebb, &[]);\n-                inst\n             }\n             TerminatorKind::Call { func, args, destination, cleanup: _ } => {\n-                ::abi::codegen_call(fx, func, args, destination)\n+                ::abi::codegen_call(fx, func, args, destination);\n             }\n             TerminatorKind::Resume | TerminatorKind::Abort | TerminatorKind::Unreachable => {\n-                fx.bcx.ins().trap(TrapCode::User(!0))\n+                fx.bcx.ins().trap(TrapCode::User(!0));\n             }\n             TerminatorKind::Yield { .. } |\n             TerminatorKind::FalseEdges { .. } |\n@@ -158,16 +162,12 @@ pub fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &\n                 // TODO call drop impl\n                 // unimplemented!(\"terminator {:?}\", bb_data.terminator());\n                 let target_ebb = fx.get_ebb(*target);\n-                fx.bcx.ins().jump(target_ebb, &[])\n+                fx.bcx.ins().jump(target_ebb, &[]);\n             }\n             TerminatorKind::GeneratorDrop => {\n                 unimplemented!(\"terminator GeneratorDrop\");\n             }\n         };\n-\n-        let mut terminator_head = \"\\n\".to_string();\n-        bb_data.terminator().kind.fmt_head(&mut terminator_head).unwrap();\n-        fx.add_comment(inst, terminator_head);\n     }\n \n     fx.bcx.seal_all_blocks();\n@@ -176,10 +176,11 @@ pub fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &\n     Ok(fx.comments.clone())\n }\n \n-fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx>) -> Result<(), String> {\n+fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, cur_ebb: Ebb, stmt: &Statement<'tcx>) -> Result<(), String> {\n     fx.tcx.sess.warn(&format!(\"stmt {:?}\", stmt));\n \n-    let nop_inst = fx.bcx.ins().nop();\n+    let inst = fx.bcx.func.layout.last_inst(cur_ebb).unwrap();\n+    fx.add_comment(inst, format!(\"{:?}\", stmt));\n \n     match &stmt.kind {\n         StatementKind::SetDiscriminant { place, variant_index } => {\n@@ -191,7 +192,6 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n             match layout.variants {\n                 layout::Variants::Single { index } => {\n                     assert_eq!(index, *variant_index);\n-                    fx.bcx.ins().nop();\n                 }\n                 layout::Variants::Tagged { .. } => {\n                     let ptr = place.place_field(fx, mir::Field::new(0));\n@@ -219,8 +219,6 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n                             CValue::const_val(fx, niche.layout().ty, niche_value as u64 as i64)\n                         };\n                         niche.write_cvalue(fx, niche_llval);\n-                    } else {\n-                        fx.bcx.ins().nop();\n                     }\n                 }\n             }\n@@ -393,16 +391,10 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n                 Rvalue::Aggregate(_, _) => bug!(\"shouldn't exist at trans {:?}\", rval),\n             }\n         }\n-        StatementKind::StorageLive(_) | StatementKind::StorageDead(_) | StatementKind::Nop | StatementKind::ReadForMatch(_) | StatementKind::Validate(_, _) | StatementKind::EndRegion(_) | StatementKind::UserAssertTy(_, _) => {\n-            fx.bcx.ins().nop();\n-        }\n+        StatementKind::StorageLive(_) | StatementKind::StorageDead(_) | StatementKind::Nop | StatementKind::ReadForMatch(_) | StatementKind::Validate(_, _) | StatementKind::EndRegion(_) | StatementKind::UserAssertTy(_, _) => {}\n         StatementKind::InlineAsm { .. } => fx.tcx.sess.fatal(\"Inline assembly is not supported\"),\n     }\n \n-    let inst = fx.bcx.func.layout.next_inst(nop_inst).unwrap();\n-    fx.bcx.func.layout.remove_inst(nop_inst);\n-    fx.add_comment(inst, format!(\"{:?}\", stmt));\n-\n     Ok(())\n }\n "}, {"sha": "152166282412a43862c0abf3f041d351d5569911", "filename": "src/common.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a3b53eb4517a7cdbacaac4e2b9f52959e402bcdf/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b53eb4517a7cdbacaac4e2b9f52959e402bcdf/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=a3b53eb4517a7cdbacaac4e2b9f52959e402bcdf", "patch": "@@ -1,4 +1,3 @@\n-use std::borrow::Cow;\n use std::fmt;\n \n use syntax::ast::{IntTy, UintTy};\n@@ -259,7 +258,6 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n             let field_offset = fx.bcx.ins().iconst(types::I64, field_offset.bytes() as i64);\n             CPlace::Addr(fx.bcx.ins().iadd(base, field_offset), field_ty)\n         } else {\n-            fx.bcx.ins().nop();\n             CPlace::Addr(base, field_ty)\n         }\n     }\n@@ -376,17 +374,4 @@ impl<'a, 'tcx: 'a> FunctionCx<'a, 'tcx> {\n     pub fn get_local_place(&mut self, local: Local) -> CPlace<'tcx> {\n         *self.local_map.get(&local).unwrap()\n     }\n-\n-    pub fn add_comment<'s, S: Into<Cow<'s, str>>>(&mut self, inst: Inst, comment: S) {\n-        use std::collections::hash_map::Entry;\n-        match self.comments.entry(inst) {\n-            Entry::Occupied(mut occ) => {\n-                occ.get_mut().push('\\n');\n-                occ.get_mut().push_str(comment.into().as_ref());\n-            }\n-            Entry::Vacant(vac) => {\n-                vac.insert(comment.into().into_owned());\n-            }\n-        }\n-    }\n }"}, {"sha": "5c38f8af11924f1b0e580711ed7bcd822b97165c", "filename": "src/pretty_clif.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a3b53eb4517a7cdbacaac4e2b9f52959e402bcdf/src%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b53eb4517a7cdbacaac4e2b9f52959e402bcdf/src%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpretty_clif.rs?ref=a3b53eb4517a7cdbacaac4e2b9f52959e402bcdf", "patch": "@@ -1,11 +1,10 @@\n+use std::borrow::Cow;\n use std::collections::HashMap;\n use std::fmt;\n \n-use cranelift::codegen::{\n-    ir::{Function, Inst},\n-    write::{FuncWriter, PlainWriter},\n-};\n-use cranelift::prelude::*;\n+use cranelift::codegen::write::{FuncWriter, PlainWriter};\n+\n+use prelude::*;\n \n pub struct CommentWriter(pub HashMap<Inst, String>);\n \n@@ -18,10 +17,11 @@ impl FuncWriter for CommentWriter {\n         inst: Inst,\n         indent: usize,\n     ) -> fmt::Result {\n+        PlainWriter.write_instruction(w, func, isa, inst, indent)?;\n         if let Some(comment) = self.0.get(&inst) {\n             writeln!(w, \"; {}\", comment.replace('\\n', \"\\n; \"))?;\n         }\n-        PlainWriter.write_instruction(w, func, isa, inst, indent)\n+        Ok(())\n     }\n \n     fn write_preamble(\n@@ -33,3 +33,18 @@ impl FuncWriter for CommentWriter {\n         PlainWriter.write_preamble(w, func, reg_info)\n     }\n }\n+\n+impl<'a, 'tcx: 'a> FunctionCx<'a, 'tcx> {\n+    pub fn add_comment<'s, S: Into<Cow<'s, str>>>(&mut self, inst: Inst, comment: S) {\n+        use std::collections::hash_map::Entry;\n+        match self.comments.entry(inst) {\n+            Entry::Occupied(mut occ) => {\n+                occ.get_mut().push('\\n');\n+                occ.get_mut().push_str(comment.into().as_ref());\n+            }\n+            Entry::Vacant(vac) => {\n+                vac.insert(comment.into().into_owned());\n+            }\n+        }\n+    }\n+}"}]}