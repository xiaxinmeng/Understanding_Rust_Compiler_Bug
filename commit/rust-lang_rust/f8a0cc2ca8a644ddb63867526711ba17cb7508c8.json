{"sha": "f8a0cc2ca8a644ddb63867526711ba17cb7508c8", "node_id": "C_kwDOAAsO6NoAKGY4YTBjYzJjYThhNjQ0ZGRiNjM4Njc1MjY3MTFiYTE3Y2I3NTA4Yzg", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2022-10-14T23:11:28Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2022-10-30T00:58:02Z"}, "message": "compiletest: set the dylib path when gathering target cfg\n\nIf the compiler is built with `rpath = false`, then it won't find its\nown libraries unless the library search path is set. We already do that\nwhile running the actual compiletests, but #100260 added another rustc\ncommand for getting the target cfg.\n\n    Check compiletest suite=codegen mode=codegen (x86_64-unknown-linux-gnu -> x86_64-unknown-linux-gnu)\n    thread 'main' panicked at 'error: failed to get cfg info from \"[...]/build/x86_64-unknown-linux-gnu/stage1/bin/rustc\"\n    --- stdout\n\n    --- stderr\n    [...]/build/x86_64-unknown-linux-gnu/stage1/bin/rustc: error while loading shared libraries: librustc_driver-a2a76dc626cd02d2.so: cannot open shared object file: No such file or directory\n    ', src/tools/compiletest/src/common.rs:476:13\n\nNow the library path is set here as well, so it works without rpath.", "tree": {"sha": "92346ba9b77be9c75e7723dc3b0cf2c7004d1d84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92346ba9b77be9c75e7723dc3b0cf2c7004d1d84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8a0cc2ca8a644ddb63867526711ba17cb7508c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8a0cc2ca8a644ddb63867526711ba17cb7508c8", "html_url": "https://github.com/rust-lang/rust/commit/f8a0cc2ca8a644ddb63867526711ba17cb7508c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8a0cc2ca8a644ddb63867526711ba17cb7508c8/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e9772042948002f9c6f60c4c81603170035fffa", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e9772042948002f9c6f60c4c81603170035fffa", "html_url": "https://github.com/rust-lang/rust/commit/5e9772042948002f9c6f60c4c81603170035fffa"}], "stats": {"total": 70, "additions": 37, "deletions": 33}, "files": [{"sha": "9a432f11f82ffe4b228b4cdcaf2b434fbc434f44", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f8a0cc2ca8a644ddb63867526711ba17cb7508c8/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8a0cc2ca8a644ddb63867526711ba17cb7508c8/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=f8a0cc2ca8a644ddb63867526711ba17cb7508c8", "patch": "@@ -2,11 +2,12 @@ pub use self::Mode::*;\n \n use std::ffi::OsString;\n use std::fmt;\n+use std::iter;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::str::FromStr;\n \n-use crate::util::PathBufExt;\n+use crate::util::{add_dylib_path, PathBufExt};\n use lazycell::LazyCell;\n use test::ColorConfig;\n \n@@ -385,8 +386,7 @@ impl Config {\n     }\n \n     fn target_cfg(&self) -> &TargetCfg {\n-        self.target_cfg\n-            .borrow_with(|| TargetCfg::new(&self.rustc_path, &self.target, &self.target_rustcflags))\n+        self.target_cfg.borrow_with(|| TargetCfg::new(self))\n     }\n \n     pub fn matches_arch(&self, arch: &str) -> bool {\n@@ -457,21 +457,23 @@ pub enum Endian {\n }\n \n impl TargetCfg {\n-    fn new(rustc_path: &Path, target: &str, target_rustcflags: &Vec<String>) -> TargetCfg {\n-        let output = match Command::new(rustc_path)\n+    fn new(config: &Config) -> TargetCfg {\n+        let mut command = Command::new(&config.rustc_path);\n+        add_dylib_path(&mut command, iter::once(&config.compile_lib_path));\n+        let output = match command\n             .arg(\"--print=cfg\")\n             .arg(\"--target\")\n-            .arg(target)\n-            .args(target_rustcflags)\n+            .arg(&config.target)\n+            .args(&config.target_rustcflags)\n             .output()\n         {\n             Ok(output) => output,\n-            Err(e) => panic!(\"error: failed to get cfg info from {:?}: {e}\", rustc_path),\n+            Err(e) => panic!(\"error: failed to get cfg info from {:?}: {e}\", config.rustc_path),\n         };\n         if !output.status.success() {\n             panic!(\n                 \"error: failed to get cfg info from {:?}\\n--- stdout\\n{}\\n--- stderr\\n{}\",\n-                rustc_path,\n+                config.rustc_path,\n                 String::from_utf8(output.stdout).unwrap(),\n                 String::from_utf8(output.stderr).unwrap(),\n             );"}, {"sha": "f8903f754f09f4c304e54f29fccfff36188c7e9b", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f8a0cc2ca8a644ddb63867526711ba17cb7508c8/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8a0cc2ca8a644ddb63867526711ba17cb7508c8/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=f8a0cc2ca8a644ddb63867526711ba17cb7508c8", "patch": "@@ -13,7 +13,7 @@ use crate::errors::{self, Error, ErrorKind};\n use crate::header::TestProps;\n use crate::json;\n use crate::read2::read2_abbreviated;\n-use crate::util::{logv, PathBufExt};\n+use crate::util::{add_dylib_path, dylib_env_var, logv, PathBufExt};\n use crate::ColorConfig;\n use regex::{Captures, Regex};\n use rustfix::{apply_suggestions, get_suggestions_from_json, Filter};\n@@ -26,6 +26,7 @@ use std::fs::{self, create_dir_all, File, OpenOptions};\n use std::hash::{Hash, Hasher};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n+use std::iter;\n use std::path::{Path, PathBuf};\n use std::process::{Child, Command, ExitStatus, Output, Stdio};\n use std::str;\n@@ -72,19 +73,6 @@ fn disable_error_reporting<F: FnOnce() -> R, R>(f: F) -> R {\n     f()\n }\n \n-/// The name of the environment variable that holds dynamic library locations.\n-pub fn dylib_env_var() -> &'static str {\n-    if cfg!(windows) {\n-        \"PATH\"\n-    } else if cfg!(target_os = \"macos\") {\n-        \"DYLD_LIBRARY_PATH\"\n-    } else if cfg!(target_os = \"haiku\") {\n-        \"LIBRARY_PATH\"\n-    } else {\n-        \"LD_LIBRARY_PATH\"\n-    }\n-}\n-\n /// The platform-specific library name\n pub fn get_lib_name(lib: &str, dylib: bool) -> String {\n     // In some casess (e.g. MUSL), we build a static\n@@ -1811,16 +1799,7 @@ impl<'test> TestCx<'test> {\n \n         // Need to be sure to put both the lib_path and the aux path in the dylib\n         // search path for the child.\n-        let mut path =\n-            env::split_paths(&env::var_os(dylib_env_var()).unwrap_or_default()).collect::<Vec<_>>();\n-        if let Some(p) = aux_path {\n-            path.insert(0, PathBuf::from(p))\n-        }\n-        path.insert(0, PathBuf::from(lib_path));\n-\n-        // Add the new dylib search path var\n-        let newpath = env::join_paths(&path).unwrap();\n-        command.env(dylib_env_var(), newpath);\n+        add_dylib_path(&mut command, iter::once(lib_path).chain(aux_path));\n \n         let mut child = disable_error_reporting(|| command.spawn())\n             .unwrap_or_else(|_| panic!(\"failed to exec `{:?}`\", &command));"}, {"sha": "ec36f1e4fb72efd5beada293b800ad2aa4733404", "filename": "src/tools/compiletest/src/util.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f8a0cc2ca8a644ddb63867526711ba17cb7508c8/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8a0cc2ca8a644ddb63867526711ba17cb7508c8/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs?ref=f8a0cc2ca8a644ddb63867526711ba17cb7508c8", "patch": "@@ -2,6 +2,7 @@ use crate::common::Config;\n use std::env;\n use std::ffi::OsStr;\n use std::path::PathBuf;\n+use std::process::Command;\n \n use tracing::*;\n \n@@ -111,3 +112,25 @@ impl PathBufExt for PathBuf {\n         }\n     }\n }\n+\n+/// The name of the environment variable that holds dynamic library locations.\n+pub fn dylib_env_var() -> &'static str {\n+    if cfg!(windows) {\n+        \"PATH\"\n+    } else if cfg!(target_os = \"macos\") {\n+        \"DYLD_LIBRARY_PATH\"\n+    } else if cfg!(target_os = \"haiku\") {\n+        \"LIBRARY_PATH\"\n+    } else {\n+        \"LD_LIBRARY_PATH\"\n+    }\n+}\n+\n+/// Adds a list of lookup paths to `cmd`'s dynamic library lookup path.\n+/// If the dylib_path_var is already set for this cmd, the old value will be overwritten!\n+pub fn add_dylib_path(cmd: &mut Command, paths: impl Iterator<Item = impl Into<PathBuf>>) {\n+    let path_env = env::var_os(dylib_env_var());\n+    let old_paths = path_env.as_ref().map(env::split_paths);\n+    let new_paths = paths.map(Into::into).chain(old_paths.into_iter().flatten());\n+    cmd.env(dylib_env_var(), env::join_paths(new_paths).unwrap());\n+}"}]}