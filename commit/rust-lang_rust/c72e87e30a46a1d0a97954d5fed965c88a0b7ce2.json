{"sha": "c72e87e30a46a1d0a97954d5fed965c88a0b7ce2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3MmU4N2UzMGE0NmExZDBhOTc5NTRkNWZlZDk2NWM4OGEwYjdjZTI=", "commit": {"author": {"name": "Masaki Hara", "email": "ackie.h.gmai@gmail.com", "date": "2018-05-29T15:33:01Z"}, "committer": {"name": "Masaki Hara", "email": "ackie.h.gmai@gmail.com", "date": "2018-08-18T23:07:33Z"}, "message": "Add an unstable-book article about unsized_locals.", "tree": {"sha": "dd4259a69afa4817d426b1819a9cdee827ba547b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd4259a69afa4817d426b1819a9cdee827ba547b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c72e87e30a46a1d0a97954d5fed965c88a0b7ce2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c72e87e30a46a1d0a97954d5fed965c88a0b7ce2", "html_url": "https://github.com/rust-lang/rust/commit/c72e87e30a46a1d0a97954d5fed965c88a0b7ce2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c72e87e30a46a1d0a97954d5fed965c88a0b7ce2/comments", "author": {"login": "qnighy", "id": 41755, "node_id": "MDQ6VXNlcjQxNzU1", "avatar_url": "https://avatars.githubusercontent.com/u/41755?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qnighy", "html_url": "https://github.com/qnighy", "followers_url": "https://api.github.com/users/qnighy/followers", "following_url": "https://api.github.com/users/qnighy/following{/other_user}", "gists_url": "https://api.github.com/users/qnighy/gists{/gist_id}", "starred_url": "https://api.github.com/users/qnighy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qnighy/subscriptions", "organizations_url": "https://api.github.com/users/qnighy/orgs", "repos_url": "https://api.github.com/users/qnighy/repos", "events_url": "https://api.github.com/users/qnighy/events{/privacy}", "received_events_url": "https://api.github.com/users/qnighy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "qnighy", "id": 41755, "node_id": "MDQ6VXNlcjQxNzU1", "avatar_url": "https://avatars.githubusercontent.com/u/41755?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qnighy", "html_url": "https://github.com/qnighy", "followers_url": "https://api.github.com/users/qnighy/followers", "following_url": "https://api.github.com/users/qnighy/following{/other_user}", "gists_url": "https://api.github.com/users/qnighy/gists{/gist_id}", "starred_url": "https://api.github.com/users/qnighy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qnighy/subscriptions", "organizations_url": "https://api.github.com/users/qnighy/orgs", "repos_url": "https://api.github.com/users/qnighy/repos", "events_url": "https://api.github.com/users/qnighy/events{/privacy}", "received_events_url": "https://api.github.com/users/qnighy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "800f2c13a3f4213648f301dcd4e10d80b1e6ea38", "url": "https://api.github.com/repos/rust-lang/rust/commits/800f2c13a3f4213648f301dcd4e10d80b1e6ea38", "html_url": "https://github.com/rust-lang/rust/commit/800f2c13a3f4213648f301dcd4e10d80b1e6ea38"}], "stats": {"total": 199, "additions": 199, "deletions": 0}, "files": [{"sha": "ff5a6bcfbf73668739d2607f03110a1bd56150f2", "filename": "src/doc/unstable-book/src/language-features/unsized-locals.md", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/c72e87e30a46a1d0a97954d5fed965c88a0b7ce2/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md", "raw_url": "https://github.com/rust-lang/rust/raw/c72e87e30a46a1d0a97954d5fed965c88a0b7ce2/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md?ref=c72e87e30a46a1d0a97954d5fed965c88a0b7ce2", "patch": "@@ -0,0 +1,199 @@\n+# `unsized_locals`\n+\n+The tracking issue for this feature is: [#48055]\n+\n+[#48055]: https://github.com/rust-lang/rust/issues/48055\n+\n+------------------------\n+\n+This implements [RFC1909]. When turned on, you can have unsized arguments and locals:\n+\n+[RFC1909]: https://github.com/rust-lang/rfcs/blob/master/text/1909-coercions.md\n+\n+```rust\n+#![feature(unsized_locals)]\n+\n+use std::any::Any;\n+\n+fn main() {\n+    let x: Box<dyn Any> = Box::new(42);\n+    let x: dyn Any = *x;\n+    //  ^ unsized local variable\n+    //               ^^ unsized temporary\n+    foo(x);\n+}\n+\n+fn foo(_: dyn Any) {}\n+//     ^^^^^^ unsized argument\n+```\n+\n+The RFC still forbids the following unsized expressions:\n+\n+```rust,ignore\n+#![feature(unsized_locals)]\n+\n+use std::any::Any;\n+\n+struct MyStruct<T: ?Sized> {\n+    content: T,\n+}\n+\n+struct MyTupleStruct<T: ?Sized>(T);\n+\n+fn answer() -> Box<dyn Any> {\n+    Box::new(42)\n+}\n+\n+fn main() {\n+    // You CANNOT have unsized statics.\n+    static X: dyn Any = *answer();  // ERROR\n+    const Y: dyn Any = *answer();  // ERROR\n+\n+    // You CANNOT have struct initialized unsized.\n+    MyStruct { content: *answer() };  // ERROR\n+    MyTupleStruct(*answer());  // ERROR\n+    (42, *answer());  // ERROR\n+\n+    // You CANNOT have unsized return types.\n+    fn my_function() -> dyn Any { *answer() }  // ERROR\n+\n+    // You CAN have unsized local variables...\n+    let mut x: dyn Any = *answer();  // OK\n+    // ...but you CANNOT reassign to them.\n+    x = *answer();  // ERROR\n+\n+    // You CANNOT even initialize them separately.\n+    let y: dyn Any;  // OK\n+    y = *answer();  // ERROR\n+\n+    // Not mentioned in the RFC, but by-move captured variables are also Sized.\n+    let x: dyn Any = *answer();\n+    (move || {  // ERROR\n+        let y = x;\n+    })();\n+\n+    // You CAN create a closure with unsized arguments,\n+    // but you CANNOT call it.\n+    // This is an implementation detail and may be changed in the future.\n+    let f = |x: dyn Any| {};\n+    f(*answer());  // ERROR\n+}\n+```\n+\n+However, the current implementation allows `MyTupleStruct(..)` to be unsized. This will be fixed in the future.\n+\n+## By-value trait objects\n+\n+With this feature, you can have by-value `self` arguments without `Self: Sized` bounds.\n+\n+```rust\n+#![feature(unsized_locals)]\n+\n+trait Foo {\n+    fn foo(self) {}\n+}\n+\n+impl<T: ?Sized> Foo for T {}\n+\n+fn main() {\n+    let slice: Box<[i32]> = Box::new([1, 2, 3]);\n+    <[i32] as Foo>::foo(*slice);\n+}\n+```\n+\n+And `Foo` will also be object-safe. However, this object-safety is not yet implemented.\n+\n+```rust,ignore\n+#![feature(unsized_locals)]\n+\n+trait Foo {\n+    fn foo(self) {}\n+}\n+\n+impl<T: ?Sized> Foo for T {}\n+\n+fn main () {\n+    let slice: Box<dyn Foo> = Box::new([1, 2, 3]);\n+    // doesn't compile yet\n+    <dyn Foo as Foo>::foo(*slice);\n+}\n+```\n+\n+Unfortunately, this is not implemented yet.\n+\n+One of the objectives of this feature is to allow `Box<dyn FnOnce>`, instead of `Box<dyn FnBox>` in the future. See [#28796] for details.\n+\n+[#28796]: https://github.com/rust-lang/rust/issues/28796\n+\n+## Variable length arrays\n+\n+The RFC also describes an extension to the array literal syntax `[e; n]`: you'll be able to specify non-const `n` to allocate variable length arrays on the stack.\n+\n+```rust,ignore\n+#![feature(unsized_locals)]\n+\n+fn mergesort<T: Ord>(a: &mut [T]) {\n+    let mut tmp = [T; a.len()];\n+    // ...\n+}\n+\n+fn main() {\n+    let mut a = [3, 1, 5, 6];\n+    mergesort(&mut a);\n+    assert_eq!(a, [1, 3, 5, 6]);\n+}\n+```\n+\n+VLAs are not implemented yet.\n+\n+## Advisory on stack usage\n+\n+It's advised not to casually use the `#![feature(unsized_locals)]` feature. Typical use-cases are:\n+\n+- When you need a by-value trait objects.\n+- When you really need a fast allocation of small temporary arrays.\n+\n+Another pitfall is repetitive allocation and temporaries. Currently the compiler simply extends the stack frame every time it encounters an unsized assignment. So for example, the code\n+\n+```rust\n+#![feature(unsized_locals)]\n+\n+fn main() {\n+    let x: Box<[i32]> = Box::new([1, 2, 3, 4, 5]);\n+    let _x = {{{{{{{{{{*x}}}}}}}}}};\n+}\n+```\n+\n+and the code\n+\n+```rust\n+#![feature(unsized_locals)]\n+\n+fn main() {\n+    for _ in 0..10 {\n+        let x: Box<[i32]> = Box::new([1, 2, 3, 4, 5]);\n+        let _x = *x;\n+    }\n+}\n+```\n+\n+will unnecessarily extend the stack frame.\n+\n+Allocation will be improved in the future, but there are still examples that are difficult to optimize:\n+\n+```rust\n+#![feature(unsized_locals)]\n+\n+fn main() {\n+    let mut counter = 10;\n+    let x = loop {\n+        let x: Box<[i32]> = Box::new([1, 2, 3, 4, 5]);\n+        let x = *x;\n+        if counter > 0 {\n+            counter -= 1;\n+        } else {\n+            break x;\n+        }\n+    };\n+}\n+```"}]}