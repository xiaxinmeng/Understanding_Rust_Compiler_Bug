{"sha": "9ed4af89672a17306a87edf17c164a4e2c6786d9", "node_id": "C_kwDOAAsO6NoAKDllZDRhZjg5NjcyYTE3MzA2YTg3ZWRmMTdjMTY0YTRlMmM2Nzg2ZDk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-04T09:08:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-04T09:08:22Z"}, "message": "Auto merge of #12142 - WaffleLapkin:sort-items-by-trait-def, r=lnicola\n\nfeat: Sort items by trait definition assist\n\nThis PR replaces the \"Sort **methods** by trait definition\" assist with a \"Sort **items** by trait definition\" assist that sorts all items, not just methods.\n\n![sort-items-by-trait-def-showcase](https://user-images.githubusercontent.com/38225716/166491828-0bc10dbd-91be-408f-9fe0-636ef5e99377.gif)", "tree": {"sha": "d8a88d90ba7061777c6fd9881c5418aec9905a1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8a88d90ba7061777c6fd9881c5418aec9905a1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ed4af89672a17306a87edf17c164a4e2c6786d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ed4af89672a17306a87edf17c164a4e2c6786d9", "html_url": "https://github.com/rust-lang/rust/commit/9ed4af89672a17306a87edf17c164a4e2c6786d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ed4af89672a17306a87edf17c164a4e2c6786d9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ee4e6a22d79f58b6b459dbc874d6b90a4495d83", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ee4e6a22d79f58b6b459dbc874d6b90a4495d83", "html_url": "https://github.com/rust-lang/rust/commit/0ee4e6a22d79f58b6b459dbc874d6b90a4495d83"}, {"sha": "e3151247982f47a7fdcf225c066c18acea229d30", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3151247982f47a7fdcf225c066c18acea229d30", "html_url": "https://github.com/rust-lang/rust/commit/e3151247982f47a7fdcf225c066c18acea229d30"}], "stats": {"total": 183, "additions": 123, "deletions": 60}, "files": [{"sha": "2bda3a1817078fb49caadc994fe8fe962f61f41a", "filename": "crates/ide-assists/src/handlers/reorder_impl_items.rs", "status": "renamed", "additions": 108, "deletions": 44, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/9ed4af89672a17306a87edf17c164a4e2c6786d9/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_impl_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed4af89672a17306a87edf17c164a4e2c6786d9/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_impl_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_impl_items.rs?ref=9ed4af89672a17306a87edf17c164a4e2c6786d9", "patch": "@@ -6,46 +6,46 @@ use syntax::{\n     ted, AstNode,\n };\n \n-use crate::{utils::get_methods, AssistContext, AssistId, AssistKind, Assists};\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n-// Assist: reorder_impl\n+// Assist: reorder_impl_items\n //\n-// Reorder the methods of an `impl Trait`. The methods will be ordered\n+// Reorder the items of an `impl Trait`. The items will be ordered\n // in the same order as in the trait definition.\n //\n // ```\n // trait Foo {\n-//     fn a() {}\n-//     fn b() {}\n-//     fn c() {}\n+//     type A;\n+//     const B: u8;\n+//     fn c();\n // }\n //\n // struct Bar;\n // $0impl Foo for Bar {\n-//     fn b() {}\n+//     const B: u8 = 17;\n //     fn c() {}\n-//     fn a() {}\n+//     type A = String;\n // }\n // ```\n // ->\n // ```\n // trait Foo {\n-//     fn a() {}\n-//     fn b() {}\n-//     fn c() {}\n+//     type A;\n+//     const B: u8;\n+//     fn c();\n // }\n //\n // struct Bar;\n // impl Foo for Bar {\n-//     fn a() {}\n-//     fn b() {}\n+//     type A = String;\n+//     const B: u8 = 17;\n //     fn c() {}\n // }\n // ```\n-pub(crate) fn reorder_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn reorder_impl_items(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let impl_ast = ctx.find_node_at_offset::<ast::Impl>()?;\n     let items = impl_ast.assoc_item_list()?;\n-    let methods = get_methods(&items);\n+    let assoc_items = items.assoc_items().collect::<Vec<_>>();\n \n     let path = impl_ast\n         .trait_()\n@@ -55,48 +55,53 @@ pub(crate) fn reorder_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n         })?\n         .path()?;\n \n-    let ranks = compute_method_ranks(&path, ctx)?;\n-    let sorted: Vec<_> = methods\n+    let ranks = compute_item_ranks(&path, ctx)?;\n+    let sorted: Vec<_> = assoc_items\n         .iter()\n         .cloned()\n-        .sorted_by_key(|f| {\n-            f.name().and_then(|n| ranks.get(&n.to_string()).copied()).unwrap_or(usize::max_value())\n+        .sorted_by_key(|i| {\n+            let name = match i {\n+                ast::AssocItem::Const(c) => c.name(),\n+                ast::AssocItem::Fn(f) => f.name(),\n+                ast::AssocItem::TypeAlias(t) => t.name(),\n+                ast::AssocItem::MacroCall(_) => None,\n+            };\n+\n+            name.and_then(|n| ranks.get(&n.to_string()).copied()).unwrap_or(usize::max_value())\n         })\n         .collect();\n \n     // Don't edit already sorted methods:\n-    if methods == sorted {\n+    if assoc_items == sorted {\n         cov_mark::hit!(not_applicable_if_sorted);\n         return None;\n     }\n \n     let target = items.syntax().text_range();\n     acc.add(\n-        AssistId(\"reorder_impl\", AssistKind::RefactorRewrite),\n-        \"Sort methods by trait definition\",\n+        AssistId(\"reorder_impl_items\", AssistKind::RefactorRewrite),\n+        \"Sort items by trait definition\",\n         target,\n         |builder| {\n-            let methods = methods.into_iter().map(|fn_| builder.make_mut(fn_)).collect::<Vec<_>>();\n-            methods\n+            let assoc_items =\n+                assoc_items.into_iter().map(|item| builder.make_mut(item)).collect::<Vec<_>>();\n+            assoc_items\n                 .into_iter()\n                 .zip(sorted)\n                 .for_each(|(old, new)| ted::replace(old.syntax(), new.clone_for_update().syntax()));\n         },\n     )\n }\n \n-fn compute_method_ranks(path: &ast::Path, ctx: &AssistContext) -> Option<FxHashMap<String, usize>> {\n+fn compute_item_ranks(path: &ast::Path, ctx: &AssistContext) -> Option<FxHashMap<String, usize>> {\n     let td = trait_definition(path, &ctx.sema)?;\n \n     Some(\n         td.items(ctx.db())\n             .iter()\n-            .flat_map(|i| match i {\n-                hir::AssocItem::Function(f) => Some(f),\n-                _ => None,\n-            })\n+            .flat_map(|i| i.name(ctx.db()))\n             .enumerate()\n-            .map(|(idx, func)| (func.name(ctx.db()).to_string(), idx))\n+            .map(|(idx, name)| (name.to_string(), idx))\n             .collect(),\n     )\n }\n@@ -118,15 +123,19 @@ mod tests {\n     fn not_applicable_if_sorted() {\n         cov_mark::check!(not_applicable_if_sorted);\n         check_assist_not_applicable(\n-            reorder_impl,\n+            reorder_impl_items,\n             r#\"\n trait Bar {\n+    type T;\n+    const C: ();\n     fn a() {}\n     fn z() {}\n     fn b() {}\n }\n struct Foo;\n $0impl Bar for Foo {\n+    type T = ();\n+    const C: () = ();\n     fn a() {}\n     fn z() {}\n     fn b() {}\n@@ -135,10 +144,49 @@ $0impl Bar for Foo {\n         )\n     }\n \n+    #[test]\n+    fn reorder_impl_trait_functions() {\n+        check_assist(\n+            reorder_impl_items,\n+            r#\"\n+trait Bar {\n+    fn a() {}\n+    fn c() {}\n+    fn b() {}\n+    fn d() {}\n+}\n+\n+struct Foo;\n+$0impl Bar for Foo {\n+    fn d() {}\n+    fn b() {}\n+    fn c() {}\n+    fn a() {}\n+}\n+\"#,\n+            r#\"\n+trait Bar {\n+    fn a() {}\n+    fn c() {}\n+    fn b() {}\n+    fn d() {}\n+}\n+\n+struct Foo;\n+impl Bar for Foo {\n+    fn a() {}\n+    fn c() {}\n+    fn b() {}\n+    fn d() {}\n+}\n+\"#,\n+        )\n+    }\n+\n     #[test]\n     fn not_applicable_if_empty() {\n         check_assist_not_applicable(\n-            reorder_impl,\n+            reorder_impl_items,\n             r#\"\n trait Bar {};\n struct Foo;\n@@ -148,69 +196,85 @@ $0impl Bar for Foo {}\n     }\n \n     #[test]\n-    fn reorder_impl_trait_functions() {\n+    fn reorder_impl_trait_items() {\n         check_assist(\n-            reorder_impl,\n+            reorder_impl_items,\n             r#\"\n trait Bar {\n     fn a() {}\n+    type T0;\n     fn c() {}\n+    const C1: ();\n     fn b() {}\n+    type T1;\n     fn d() {}\n+    const C0: ();\n }\n \n struct Foo;\n $0impl Bar for Foo {\n+    type T1 = ();\n     fn d() {}\n     fn b() {}\n     fn c() {}\n+    const C1: () = ();\n     fn a() {}\n+    type T0 = ();\n+    const C0: () = ();\n }\n         \"#,\n             r#\"\n trait Bar {\n     fn a() {}\n+    type T0;\n     fn c() {}\n+    const C1: ();\n     fn b() {}\n+    type T1;\n     fn d() {}\n+    const C0: ();\n }\n \n struct Foo;\n impl Bar for Foo {\n     fn a() {}\n+    type T0 = ();\n     fn c() {}\n+    const C1: () = ();\n     fn b() {}\n+    type T1 = ();\n     fn d() {}\n+    const C0: () = ();\n }\n         \"#,\n         )\n     }\n \n     #[test]\n-    fn reorder_impl_trait_methods_uneven_ident_lengths() {\n+    fn reorder_impl_trait_items_uneven_ident_lengths() {\n         check_assist(\n-            reorder_impl,\n+            reorder_impl_items,\n             r#\"\n trait Bar {\n-    fn foo(&mut self) {}\n-    fn fooo(&mut self) {}\n+    type Foo;\n+    type Fooo;\n }\n \n struct Foo;\n impl Bar for Foo {\n-    fn fooo(&mut self) {}\n-    fn foo(&mut self) {$0}\n+    type Fooo = ();\n+    type Foo = ();$0\n }\"#,\n             r#\"\n trait Bar {\n-    fn foo(&mut self) {}\n-    fn fooo(&mut self) {}\n+    type Foo;\n+    type Fooo;\n }\n \n struct Foo;\n impl Bar for Foo {\n-    fn foo(&mut self) {}\n-    fn fooo(&mut self) {}\n+    type Foo = ();\n+    type Fooo = ();\n }\"#,\n         )\n     }", "previous_filename": "crates/ide-assists/src/handlers/reorder_impl.rs"}, {"sha": "42bbc70b5328ebc43c3f9ad877df0ba15072aa17", "filename": "crates/ide-assists/src/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9ed4af89672a17306a87edf17c164a4e2c6786d9/crates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed4af89672a17306a87edf17c164a4e2c6786d9/crates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Flib.rs?ref=9ed4af89672a17306a87edf17c164a4e2c6786d9", "patch": "@@ -37,7 +37,7 @@\n //!   should be available more or less everywhere, which isn't useful. So\n //!   instead we only show it if the user *selects* the items they want to sort.\n //! * Consider grouping related assists together (see [`Assists::add_group`]).\n-//! * Make assists robust. If the assist depends on results of type-inference to\n+//! * Make assists robust. If the assist depends on results of type-inference too\n //!   much, it might only fire in fully-correct code. This makes assist less\n //!   useful and (worse) less predictable. The user should have a clear\n //!   intuition when each particular assist is available.\n@@ -54,7 +54,6 @@\n //!   something. If something *could* be a diagnostic, it should be a\n //!   diagnostic. Conversely, it might be valuable to turn a diagnostic with a\n //!   lot of false errors into an assist.\n-//! *\n //!\n //! See also this post:\n //! <https://rust-analyzer.github.io/blog/2020/09/28/how-to-make-a-light-bulb.html>\n@@ -170,7 +169,7 @@ mod handlers {\n     mod remove_mut;\n     mod remove_unused_param;\n     mod reorder_fields;\n-    mod reorder_impl;\n+    mod reorder_impl_items;\n     mod replace_try_expr_with_match;\n     mod replace_derive_with_manual_impl;\n     mod replace_if_let_with_match;\n@@ -257,7 +256,7 @@ mod handlers {\n             remove_mut::remove_mut,\n             remove_unused_param::remove_unused_param,\n             reorder_fields::reorder_fields,\n-            reorder_impl::reorder_impl,\n+            reorder_impl_items::reorder_impl_items,\n             replace_try_expr_with_match::replace_try_expr_with_match,\n             replace_derive_with_manual_impl::replace_derive_with_manual_impl,\n             replace_if_let_with_match::replace_if_let_with_match,"}, {"sha": "eed50a8562db825d4c88d1aeca0b2cb797304cf1", "filename": "crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9ed4af89672a17306a87edf17c164a4e2c6786d9/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed4af89672a17306a87edf17c164a4e2c6786d9/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=9ed4af89672a17306a87edf17c164a4e2c6786d9", "patch": "@@ -1737,34 +1737,34 @@ const test: Foo = Foo {foo: 1, bar: 0}\n }\n \n #[test]\n-fn doctest_reorder_impl() {\n+fn doctest_reorder_impl_items() {\n     check_doc_test(\n-        \"reorder_impl\",\n+        \"reorder_impl_items\",\n         r#####\"\n trait Foo {\n-    fn a() {}\n-    fn b() {}\n-    fn c() {}\n+    type A;\n+    const B: u8;\n+    fn c();\n }\n \n struct Bar;\n $0impl Foo for Bar {\n-    fn b() {}\n+    const B: u8 = 17;\n     fn c() {}\n-    fn a() {}\n+    type A = String;\n }\n \"#####,\n         r#####\"\n trait Foo {\n-    fn a() {}\n-    fn b() {}\n-    fn c() {}\n+    type A;\n+    const B: u8;\n+    fn c();\n }\n \n struct Bar;\n impl Foo for Bar {\n-    fn a() {}\n-    fn b() {}\n+    type A = String;\n+    const B: u8 = 17;\n     fn c() {}\n }\n \"#####,"}]}