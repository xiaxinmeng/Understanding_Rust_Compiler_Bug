{"sha": "0d52b22e7bd554464144e0a037285f62ddbd9eb2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkNTJiMjJlN2JkNTU0NDY0MTQ0ZTBhMDM3Mjg1ZjYyZGRiZDllYjI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-23T00:58:50Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-27T04:29:33Z"}, "message": "libcore: Change `[const T]` to `const [T]` everywhere", "tree": {"sha": "310d55925f7b6d1f4df6f20bcff378dead8470e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/310d55925f7b6d1f4df6f20bcff378dead8470e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d52b22e7bd554464144e0a037285f62ddbd9eb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d52b22e7bd554464144e0a037285f62ddbd9eb2", "html_url": "https://github.com/rust-lang/rust/commit/0d52b22e7bd554464144e0a037285f62ddbd9eb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d52b22e7bd554464144e0a037285f62ddbd9eb2/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5df1aaab9835795bd0ef22d795d57039b703fb21", "url": "https://api.github.com/repos/rust-lang/rust/commits/5df1aaab9835795bd0ef22d795d57039b703fb21", "html_url": "https://github.com/rust-lang/rust/commit/5df1aaab9835795bd0ef22d795d57039b703fb21"}], "stats": {"total": 344, "additions": 85, "deletions": 259}, "files": [{"sha": "9a8645723a42fc8a69c8a515a35d7371396af9cc", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=0d52b22e7bd554464144e0a037285f62ddbd9eb2", "patch": "@@ -38,7 +38,7 @@ pub mod rustrt {\n \n /// Returns the number of elements the vector can hold without reallocating\n #[inline(always)]\n-pub fn capacity<T>(v: @[const T]) -> uint {\n+pub fn capacity<T>(v: @[T]) -> uint {\n     unsafe {\n         let repr: **raw::VecRepr =\n             ::cast::reinterpret_cast(&addr_of(&v));\n@@ -60,7 +60,7 @@ pub fn capacity<T>(v: @[const T]) -> uint {\n  */\n #[inline(always)]\n pub fn build_sized<A>(size: uint, builder: &fn(push: &fn(v: A))) -> @[A] {\n-    let mut vec: @[const A] = @[];\n+    let mut vec: @[A] = @[];\n     unsafe { raw::reserve(&mut vec, size); }\n     builder(|+x| unsafe { raw::push(&mut vec, x) });\n     return unsafe { transmute(vec) };\n@@ -102,7 +102,7 @@ pub fn build_sized_opt<A>(size: Option<uint>,\n \n // Appending\n #[inline(always)]\n-pub fn append<T:Copy>(lhs: @[T], rhs: &[const T]) -> @[T] {\n+pub fn append<T:Copy>(lhs: @[T], rhs: &const [T]) -> @[T] {\n     do build_sized(lhs.len() + rhs.len()) |push| {\n         for vec::each(lhs) |x| { push(*x); }\n         for uint::range(0, rhs.len()) |i| { push(rhs[i]); }\n@@ -174,9 +174,9 @@ pub mod traits {\n     use kinds::Copy;\n     use ops::Add;\n \n-    impl<T:Copy> Add<&'self [const T],@[T]> for @[T] {\n+    impl<T:Copy> Add<&'self const [T],@[T]> for @[T] {\n         #[inline(always)]\n-        fn add(&self, rhs: & &'self [const T]) -> @[T] {\n+        fn add(&self, rhs: & &'self const [T]) -> @[T] {\n             append(*self, (*rhs))\n         }\n     }\n@@ -207,13 +207,13 @@ pub mod raw {\n      * the vector is actually the specified size.\n      */\n     #[inline(always)]\n-    pub unsafe fn set_len<T>(v: @[const T], new_len: uint) {\n+    pub unsafe fn set_len<T>(v: @[T], new_len: uint) {\n         let repr: **VecRepr = ::cast::reinterpret_cast(&addr_of(&v));\n         (**repr).unboxed.fill = new_len * sys::size_of::<T>();\n     }\n \n     #[inline(always)]\n-    pub unsafe fn push<T>(v: &mut @[const T], initval: T) {\n+    pub unsafe fn push<T>(v: &mut @[T], initval: T) {\n         let repr: **VecRepr = ::cast::reinterpret_cast(&v);\n         let fill = (**repr).unboxed.fill;\n         if (**repr).unboxed.alloc > fill {\n@@ -225,7 +225,7 @@ pub mod raw {\n     }\n \n     #[inline(always)] // really pretty please\n-    pub unsafe fn push_fast<T>(v: &mut @[const T], initval: T) {\n+    pub unsafe fn push_fast<T>(v: &mut @[T], initval: T) {\n         let repr: **VecRepr = ::cast::reinterpret_cast(&v);\n         let fill = (**repr).unboxed.fill;\n         (**repr).unboxed.fill += sys::size_of::<T>();\n@@ -234,7 +234,7 @@ pub mod raw {\n         move_val_init(&mut(*p), initval);\n     }\n \n-    pub unsafe fn push_slow<T>(v: &mut @[const T], initval: T) {\n+    pub unsafe fn push_slow<T>(v: &mut @[T], initval: T) {\n         reserve_at_least(&mut *v, v.len() + 1u);\n         push_fast(v, initval);\n     }\n@@ -250,7 +250,7 @@ pub mod raw {\n      * * v - A vector\n      * * n - The number of elements to reserve space for\n      */\n-    pub unsafe fn reserve<T>(v: &mut @[const T], n: uint) {\n+    pub unsafe fn reserve<T>(v: &mut @[T], n: uint) {\n         // Only make the (slow) call into the runtime if we have to\n         if capacity(*v) < n {\n             let ptr: **VecRepr = transmute(v);\n@@ -274,7 +274,7 @@ pub mod raw {\n      * * v - A vector\n      * * n - The number of elements to reserve space for\n      */\n-    pub unsafe fn reserve_at_least<T>(v: &mut @[const T], n: uint) {\n+    pub unsafe fn reserve_at_least<T>(v: &mut @[T], n: uint) {\n         reserve(v, uint::next_power_of_two(n));\n     }\n "}, {"sha": "d1647ea36fd7825b42267f04a9cfd40e4154255b", "filename": "src/libcore/flate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Flibcore%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Flibcore%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fflate.rs?ref=0d52b22e7bd554464144e0a037285f62ddbd9eb2", "patch": "@@ -46,7 +46,7 @@ static lz_fast : c_int = 0x1;   // LZ with only one probe\n static lz_norm : c_int = 0x80;  // LZ with 128 probes, \"normal\"\n static lz_best : c_int = 0xfff; // LZ with 4095 probes, \"best\"\n \n-pub fn deflate_bytes(bytes: &[const u8]) -> ~[u8] {\n+pub fn deflate_bytes(bytes: &const [u8]) -> ~[u8] {\n     do vec::as_const_buf(bytes) |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n@@ -64,7 +64,7 @@ pub fn deflate_bytes(bytes: &[const u8]) -> ~[u8] {\n     }\n }\n \n-pub fn inflate_bytes(bytes: &[const u8]) -> ~[u8] {\n+pub fn inflate_bytes(bytes: &const [u8]) -> ~[u8] {\n     do vec::as_const_buf(bytes) |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;"}, {"sha": "c1e9e658df0c7705c977ec345ec99a8e53f689fe", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=0d52b22e7bd554464144e0a037285f62ddbd9eb2", "patch": "@@ -65,7 +65,7 @@ impl<A:Hash> HashUtil for A {\n \n /// Streaming hash-functions should implement this.\n pub trait Streaming {\n-    fn input(&self, (&[const u8]));\n+    fn input(&self, (&const [u8]));\n     // These can be refactored some when we have default methods.\n     fn result_bytes(&self) -> ~[u8];\n     fn result_str(&self) -> ~str;\n@@ -221,7 +221,7 @@ impl io::Writer for SipState {\n \n     // Methods for io::writer\n     #[inline(always)]\n-    fn write(&self, msg: &[const u8]) {\n+    fn write(&self, msg: &const [u8]) {\n \n         let length = msg.len();\n         self.length += length;\n@@ -299,7 +299,7 @@ impl io::Writer for SipState {\n impl Streaming for SipState {\n \n     #[inline(always)]\n-    fn input(&self, buf: &[const u8]) {\n+    fn input(&self, buf: &const [u8]) {\n         self.write(buf);\n     }\n "}, {"sha": "2b66fdb38ab11d881cceb5fb3aabf6d703c57030", "filename": "src/libcore/io.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=0d52b22e7bd554464144e0a037285f62ddbd9eb2", "patch": "@@ -667,7 +667,7 @@ pub enum WriterType { Screen, File }\n pub trait Writer {\n \n     /// Write all of the given bytes.\n-    fn write(&self, v: &[const u8]);\n+    fn write(&self, v: &const [u8]);\n \n     /// Move the current position within the stream. The second parameter\n     /// determines the position that the first parameter is relative to.\n@@ -684,23 +684,23 @@ pub trait Writer {\n }\n \n impl Writer for @Writer {\n-    fn write(&self, v: &[const u8]) { self.write(v) }\n+    fn write(&self, v: &const [u8]) { self.write(v) }\n     fn seek(&self, a: int, b: SeekStyle) { self.seek(a, b) }\n     fn tell(&self) -> uint { self.tell() }\n     fn flush(&self) -> int { self.flush() }\n     fn get_type(&self) -> WriterType { self.get_type() }\n }\n \n impl<W:Writer,C> Writer for Wrapper<W, C> {\n-    fn write(&self, bs: &[const u8]) { self.base.write(bs); }\n+    fn write(&self, bs: &const [u8]) { self.base.write(bs); }\n     fn seek(&self, off: int, style: SeekStyle) { self.base.seek(off, style); }\n     fn tell(&self) -> uint { self.base.tell() }\n     fn flush(&self) -> int { self.base.flush() }\n     fn get_type(&self) -> WriterType { File }\n }\n \n impl Writer for *libc::FILE {\n-    fn write(&self, v: &[const u8]) {\n+    fn write(&self, v: &const [u8]) {\n         unsafe {\n             do vec::as_const_buf(v) |vbuf, len| {\n                 let nout = libc::fwrite(vbuf as *c_void,\n@@ -750,7 +750,7 @@ pub fn FILE_writer(f: *libc::FILE, cleanup: bool) -> @Writer {\n }\n \n impl Writer for fd_t {\n-    fn write(&self, v: &[const u8]) {\n+    fn write(&self, v: &const [u8]) {\n         unsafe {\n             let mut count = 0u;\n             do vec::as_const_buf(v) |vbuf, len| {\n@@ -907,8 +907,10 @@ pub fn u64_to_be_bytes<T>(n: u64, size: uint,\n     }\n }\n \n-pub fn u64_from_be_bytes(data: &[const u8],\n-                         start: uint, size: uint) -> u64 {\n+pub fn u64_from_be_bytes(data: &const [u8],\n+                         start: uint,\n+                         size: uint)\n+                      -> u64 {\n     let mut sz = size;\n     fail_unless!((sz <= 8u));\n     let mut val = 0_u64;\n@@ -1140,7 +1142,7 @@ pub struct BytesWriter {\n }\n \n impl Writer for BytesWriter {\n-    fn write(&self, v: &[const u8]) {\n+    fn write(&self, v: &const [u8]) {\n         let v_len = v.len();\n         let bytes_len = vec::uniq_len(&const self.bytes);\n "}, {"sha": "4539b373e7016f6151876a5eba48a8494bc0dc6d", "filename": "src/libcore/str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=0d52b22e7bd554464144e0a037285f62ddbd9eb2", "patch": "@@ -44,7 +44,7 @@ Section: Creating a string\n  *\n  * Fails if invalid UTF-8\n  */\n-pub fn from_bytes(vv: &[const u8]) -> ~str {\n+pub fn from_bytes(vv: &const [u8]) -> ~str {\n     fail_unless!(is_utf8(vv));\n     return unsafe { raw::from_bytes(vv) };\n }\n@@ -1552,7 +1552,7 @@ Section: Misc\n */\n \n /// Determines if a vector of bytes contains valid UTF-8\n-pub fn is_utf8(v: &[const u8]) -> bool {\n+pub fn is_utf8(v: &const [u8]) -> bool {\n     let mut i = 0u;\n     let total = vec::len::<u8>(v);\n     while i < total {\n@@ -2099,7 +2099,7 @@ pub mod raw {\n     }\n \n     /// Converts a vector of bytes to a string.\n-    pub unsafe fn from_bytes(v: &[const u8]) -> ~str {\n+    pub unsafe fn from_bytes(v: &const [u8]) -> ~str {\n         do vec::as_const_buf(v) |buf, len| {\n             from_buf_len(buf, len)\n         }"}, {"sha": "32b123979cd5a4eeb7d2b4f25829678d42d5a720", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=0d52b22e7bd554464144e0a037285f62ddbd9eb2", "patch": "@@ -19,7 +19,7 @@ use io::Writer;\n use option::{None, Option, Some};\n use str;\n \n-pub type Cb = &'self fn(buf: &[const u8]) -> bool;\n+pub type Cb = &'self fn(buf: &const [u8]) -> bool;\n \n /**\n  * A trait to implement in order to make a type hashable;"}, {"sha": "afacffb92c9f9ac79337a76789e28354a498edc6", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=0d52b22e7bd554464144e0a037285f62ddbd9eb2", "patch": "@@ -47,12 +47,12 @@ pub mod rustrt {\n }\n \n /// Returns true if a vector contains no elements\n-pub fn is_empty<T>(v: &[const T]) -> bool {\n+pub fn is_empty<T>(v: &const [T]) -> bool {\n     as_const_buf(v, |_p, len| len == 0u)\n }\n \n /// Returns true if two vectors have the same length\n-pub fn same_length<T, U>(xs: &[const T], ys: &[const U]) -> bool {\n+pub fn same_length<T, U>(xs: &const [T], ys: &const [U]) -> bool {\n     xs.len() == ys.len()\n }\n \n@@ -114,7 +114,7 @@ pub fn capacity<T>(v: &const ~[T]) -> uint {\n \n /// Returns the length of a vector\n #[inline(always)]\n-pub fn len<T>(v: &[const T]) -> uint {\n+pub fn len<T>(v: &const [T]) -> uint {\n     as_const_buf(v, |_p, len| len)\n }\n \n@@ -292,8 +292,8 @@ pub fn mut_slice<T>(v: &'r mut [T], start: uint, end: uint) -> &'r mut [T] {\n \n /// Return a slice that points into another slice.\n #[inline(always)]\n-pub fn const_slice<T>(v: &'r [const T], start: uint, end: uint)\n-                   -> &'r [const T] {\n+pub fn const_slice<T>(v: &'r const [T], start: uint, end: uint)\n+                   -> &'r const [T] {\n     fail_unless!(start <= end);\n     fail_unless!(end <= len(v));\n     do as_const_buf(v) |p, _len| {\n@@ -624,7 +624,7 @@ fn push_slow<T>(v: &mut ~[T], initval: T) {\n }\n \n #[inline(always)]\n-pub fn push_all<T:Copy>(v: &mut ~[T], rhs: &[const T]) {\n+pub fn push_all<T:Copy>(v: &mut ~[T], rhs: &const [T]) {\n     let new_len = v.len() + rhs.len();\n     reserve(&mut *v, new_len);\n \n@@ -708,7 +708,7 @@ pub fn dedup<T:Eq>(v: &mut ~[T]) {\n \n // Appending\n #[inline(always)]\n-pub fn append<T:Copy>(lhs: ~[T], rhs: &[const T]) -> ~[T] {\n+pub fn append<T:Copy>(lhs: ~[T], rhs: &const [T]) -> ~[T] {\n     let mut v = lhs;\n     unsafe {\n         v.push_all(rhs);\n@@ -1242,7 +1242,7 @@ pub fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n /**\n  * Convert two vectors to a vector of pairs, by reference. As zip().\n  */\n-pub fn zip_slice<T:Copy,U:Copy>(v: &[const T], u: &[const U])\n+pub fn zip_slice<T:Copy,U:Copy>(v: &const [T], u: &const [U])\n         -> ~[(T, U)] {\n     let mut zipped = ~[];\n     let sz = len(v);\n@@ -1293,7 +1293,7 @@ pub fn reverse<T>(v: &mut [T]) {\n }\n \n /// Returns a vector with the order of elements reversed\n-pub fn reversed<T:Copy>(v: &[const T]) -> ~[T] {\n+pub fn reversed<T:Copy>(v: &const [T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n     let mut i = len::<T>(v);\n     if i == 0 { return (rs); } else { i -= 1; }\n@@ -1345,7 +1345,7 @@ pub fn reversed<T:Copy>(v: &[const T]) -> ~[T] {\n #[inline(always)]\n pub fn each<T>(v: &'r [T], f: &fn(&'r T) -> bool) {\n     //             ^^^^\n-    // NB---this CANNOT be &[const T]!  The reason\n+    // NB---this CANNOT be &const [T]!  The reason\n     // is that you are passing it to `f()` using\n     // an immutable.\n \n@@ -1381,7 +1381,7 @@ pub fn each_mut<T>(v: &'r mut [T], f: &fn(elem: &'r mut T) -> bool) {\n /// Like `each()`, but for the case where you have a vector that *may or may\n /// not* have mutable contents.\n #[inline(always)]\n-pub fn each_const<T>(v: &[const T], f: &fn(elem: &const T) -> bool) {\n+pub fn each_const<T>(v: &const [T], f: &fn(elem: &const T) -> bool) {\n     let mut i = 0;\n     let n = v.len();\n     while i < n {\n@@ -1508,7 +1508,7 @@ pub fn as_imm_buf<T,U>(s: &[T],\n                        /* NB---this CANNOT be const, see below */\n                        f: &fn(*T, uint) -> U) -> U {\n \n-    // NB---Do not change the type of s to `&[const T]`.  This is\n+    // NB---Do not change the type of s to `&const [T]`.  This is\n     // unsound.  The reason is that we are going to create immutable pointers\n     // into `s` and pass them to `f()`, but in fact they are potentially\n     // pointing at *mutable memory*.  Use `as_const_buf` or `as_mut_buf`\n@@ -1524,7 +1524,7 @@ pub fn as_imm_buf<T,U>(s: &[T],\n \n /// Similar to `as_imm_buf` but passing a `*const T`\n #[inline(always)]\n-pub fn as_const_buf<T,U>(s: &[const T], f: &fn(*const T, uint) -> U) -> U {\n+pub fn as_const_buf<T,U>(s: &const [T], f: &fn(*const T, uint) -> U) -> U {\n     unsafe {\n         let v : *(*const T,uint) =\n             ::cast::reinterpret_cast(&addr_of(&s));\n@@ -1685,15 +1685,15 @@ pub mod traits {\n     use ops::Add;\n     use vec::append;\n \n-    impl<T:Copy> Add<&'self [const T],~[T]> for ~[T] {\n+    impl<T:Copy> Add<&'self const [T],~[T]> for ~[T] {\n         #[inline(always)]\n-        fn add(&self, rhs: & &'self [const T]) -> ~[T] {\n+        fn add(&self, rhs: & &'self const [T]) -> ~[T] {\n             append(copy *self, (*rhs))\n         }\n     }\n }\n \n-impl<T> Container for &'self [const T] {\n+impl<T> Container for &'self const [T] {\n     /// Returns true if a vector contains no elements\n     #[inline]\n     fn is_empty(&const self) -> bool { is_empty(*self) }\n@@ -1708,7 +1708,7 @@ pub trait CopyableVector<T> {\n }\n \n /// Extension methods for vectors\n-impl<T: Copy> CopyableVector<T> for &'self [const T] {\n+impl<T: Copy> CopyableVector<T> for &'self const [T] {\n     /// Returns a copy of `v`.\n     #[inline]\n     fn to_owned(&self) -> ~[T] {\n@@ -2041,14 +2041,14 @@ impl<T> Mutable for ~[T] {\n }\n \n pub trait OwnedCopyableVector<T:Copy> {\n-    fn push_all(&mut self, rhs: &[const T]);\n+    fn push_all(&mut self, rhs: &const [T]);\n     fn grow(&mut self, n: uint, initval: &T);\n     fn grow_set(&mut self, index: uint, initval: &T, val: T);\n }\n \n impl<T:Copy> OwnedCopyableVector<T> for ~[T] {\n     #[inline]\n-    fn push_all(&mut self, rhs: &[const T]) {\n+    fn push_all(&mut self, rhs: &const [T]) {\n         push_all(self, rhs);\n     }\n \n@@ -2146,7 +2146,7 @@ pub mod raw {\n \n     /** see `to_ptr()` */\n     #[inline(always)]\n-    pub unsafe fn to_const_ptr<T>(v: &[const T]) -> *const T {\n+    pub unsafe fn to_const_ptr<T>(v: &const [T]) -> *const T {\n         let repr: **SliceRepr = ::cast::transmute(&v);\n         ::cast::reinterpret_cast(&addr_of(&((**repr).data)))\n     }\n@@ -2190,7 +2190,7 @@ pub mod raw {\n      * Unchecked vector indexing.\n      */\n     #[inline(always)]\n-    pub unsafe fn get<T:Copy>(v: &[const T], i: uint) -> T {\n+    pub unsafe fn get<T:Copy>(v: &const [T], i: uint) -> T {\n         as_const_buf(v, |p, _len| *ptr::const_offset(p, i))\n     }\n \n@@ -2234,7 +2234,7 @@ pub mod raw {\n       * may overlap.\n       */\n     #[inline(always)]\n-    pub unsafe fn copy_memory<T>(dst: &mut [T], src: &[const T],\n+    pub unsafe fn copy_memory<T>(dst: &mut [T], src: &const [T],\n                                  count: uint) {\n         fail_unless!(dst.len() >= count);\n         fail_unless!(src.len() >= count);\n@@ -2300,7 +2300,7 @@ pub mod bytes {\n       * may overlap.\n       */\n     #[inline(always)]\n-    pub fn copy_memory(dst: &mut [u8], src: &[const u8], count: uint) {\n+    pub fn copy_memory(dst: &mut [u8], src: &const [u8], count: uint) {\n         // Bound checks are done at vec::raw::copy_memory.\n         unsafe { vec::raw::copy_memory(dst, src, count) }\n     }"}, {"sha": "683e4a629756fa824f9276cd66da854d2072f12a", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=0d52b22e7bd554464144e0a037285f62ddbd9eb2", "patch": "@@ -101,7 +101,7 @@ impl Drop for Arena {\n }\n \n fn chunk(size: uint, is_pod: bool) -> Chunk {\n-    let mut v: @[const u8] = @[];\n+    let mut v: @[u8] = @[];\n     unsafe { at_vec::raw::reserve(&mut v, size); }\n     Chunk {\n         data: unsafe { cast::transmute(v) },"}, {"sha": "c1743c98c9bf14997109dd9fc5757acde3cfc5df", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=0d52b22e7bd554464144e0a037285f62ddbd9eb2", "patch": "@@ -972,7 +972,7 @@ impl io::Reader for TcpSocketBuf {\n \n /// Implementation of `io::Reader` trait for a buffered `net::tcp::TcpSocket`\n impl io::Writer for TcpSocketBuf {\n-    pub fn write(&self, data: &[const u8]) {\n+    pub fn write(&self, data: &const [u8]) {\n         unsafe {\n             let socket_data_ptr =\n                 ptr::addr_of(&(*((*(self.data)).sock).socket_data));"}, {"sha": "b603e2eb1cc668d9a68c0caef4056803a0377b9d", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=0d52b22e7bd554464144e0a037285f62ddbd9eb2", "patch": "@@ -35,7 +35,7 @@ use core::vec;\n /// The SHA-1 interface\n trait Sha1 {\n     /// Provide message input as bytes\n-    fn input(&mut self, &[const u8]);\n+    fn input(&mut self, &const [u8]);\n     /// Provide message input as string\n     fn input_str(&mut self, &str);\n     /**\n@@ -73,7 +73,7 @@ pub fn sha1() -> @Sha1 {\n           computed: bool,\n           work_buf: @mut ~[u32]};\n \n-    fn add_input(st: &mut Sha1State, msg: &[const u8]) {\n+    fn add_input(st: &mut Sha1State, msg: &const [u8]) {\n         fail_unless!((!st.computed));\n         for vec::each_const(msg) |element| {\n             st.msg_block[st.msg_block_idx] = *element;\n@@ -241,7 +241,7 @@ pub fn sha1() -> @Sha1 {\n             self.h[4] = 0xC3D2E1F0u32;\n             self.computed = false;\n         }\n-        fn input(&mut self, msg: &[const u8]) { add_input(self, msg); }\n+        fn input(&mut self, msg: &const [u8]) { add_input(self, msg); }\n         fn input_str(&mut self, msg: &str) {\n             let bs = str::to_bytes(msg);\n             add_input(self, bs);"}, {"sha": "2d83c4bd9d0dd4b89fe49cb5246ca0ae011b7c7a", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=0d52b22e7bd554464144e0a037285f62ddbd9eb2", "patch": "@@ -24,12 +24,12 @@ type Le<T> = &'self fn(v1: &T, v2: &T) -> bool;\n  * Has worst case O(n log n) performance, best case O(n), but\n  * is not space efficient. This is a stable sort.\n  */\n-pub fn merge_sort<T:Copy>(v: &[const T], le: Le<T>) -> ~[T] {\n+pub fn merge_sort<T:Copy>(v: &const [T], le: Le<T>) -> ~[T] {\n     type Slice = (uint, uint);\n \n     unsafe {return merge_sort_(v, (0u, len(v)), le);}\n \n-    fn merge_sort_<T:Copy>(v: &[const T], slice: Slice, le: Le<T>)\n+    fn merge_sort_<T:Copy>(v: &const [T], slice: Slice, le: Le<T>)\n         -> ~[T] {\n         let begin = slice.first();\n         let end = slice.second();\n@@ -290,8 +290,10 @@ fn count_run_ascending<T:Copy + Ord>(array: &mut [T]) -> uint {\n     return run;\n }\n \n-fn gallop_left<T:Copy + Ord>(key: &const T, array: &[const T],\n-                            hint: uint) -> uint {\n+fn gallop_left<T:Copy + Ord>(key: &const T,\n+                             array: &const [T],\n+                             hint: uint)\n+                          -> uint {\n     let size = array.len();\n     fail_unless!(size != 0 && hint < size);\n \n@@ -339,8 +341,10 @@ fn gallop_left<T:Copy + Ord>(key: &const T, array: &[const T],\n     return ofs;\n }\n \n-fn gallop_right<T:Copy + Ord>(key: &const T, array: &[const T],\n-                            hint: uint) -> uint {\n+fn gallop_right<T:Copy + Ord>(key: &const T,\n+                              array: &const [T],\n+                              hint: uint)\n+                           -> uint {\n     let size = array.len();\n     fail_unless!(size != 0 && hint < size);\n \n@@ -709,8 +713,11 @@ impl<T:Copy + Ord> MergeState<T> {\n }\n \n #[inline(always)]\n-fn copy_vec<T:Copy>(dest: &mut [T], s1: uint,\n-                    from: &[const T], s2: uint, len: uint) {\n+fn copy_vec<T:Copy>(dest: &mut [T],\n+                    s1: uint,\n+                    from: &const [T],\n+                    s2: uint,\n+                    len: uint) {\n     fail_unless!(s1+len <= dest.len() && s2+len <= from.len());\n \n     let mut slice = ~[];\n@@ -1022,7 +1029,7 @@ mod big_tests {\n         tabulate_managed(low, high);\n     }\n \n-    fn multiplyVec<T:Copy>(arr: &[const T], num: uint) -> ~[T] {\n+    fn multiplyVec<T:Copy>(arr: &const [T], num: uint) -> ~[T] {\n         let size = arr.len();\n         let res = do vec::from_fn(num) |i| {\n             arr[i % size]\n@@ -1038,7 +1045,7 @@ mod big_tests {\n     }\n \n     fn tabulate_unique(lo: uint, hi: uint) {\n-        fn isSorted<T:Ord>(arr: &[const T]) {\n+        fn isSorted<T:Ord>(arr: &const [T]) {\n             for uint::range(0, arr.len()-1) |i| {\n                 if arr[i] > arr[i+1] {\n                     fail!(~\"Array not sorted\");\n@@ -1110,7 +1117,7 @@ mod big_tests {\n     }\n \n     fn tabulate_managed(lo: uint, hi: uint) {\n-        fn isSorted<T:Ord>(arr: &[const @T]) {\n+        fn isSorted<T:Ord>(arr: &const [@T]) {\n             for uint::range(0, arr.len()-1) |i| {\n                 if arr[i] > arr[i+1] {\n                     fail!(~\"Array not sorted\");"}, {"sha": "1764ef48412ccf7d4ef9a939c1f658ef27f1f2bf", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=0d52b22e7bd554464144e0a037285f62ddbd9eb2", "patch": "@@ -101,7 +101,7 @@ fn chanmb(i: uint, size: uint, depth: uint) -> Line\n struct Devnull();\n \n impl io::Writer for Devnull {\n-    fn write(&self, _b: &[const u8]) {}\n+    fn write(&self, _b: &const [u8]) {}\n     fn seek(&self, _i: int, _s: io::SeekStyle) {}\n     fn tell(&self) -> uint {0_u}\n     fn flush(&self) -> int {0}"}, {"sha": "6e39b755b22afcfcfdbede9e4c41598cc0f5efde", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=0d52b22e7bd554464144e0a037285f62ddbd9eb2", "patch": "@@ -16,7 +16,7 @@ fn eval_A(i: uint, j: uint) -> float {\n     1.0/(((i+j)*(i+j+1u)/2u+i+1u) as float)\n }\n \n-fn eval_A_times_u(u: &[const float], Au: &mut [float]) {\n+fn eval_A_times_u(u: &const [float], Au: &mut [float]) {\n     let N = vec::len(u);\n     let mut i = 0u;\n     while i < N {\n@@ -30,7 +30,7 @@ fn eval_A_times_u(u: &[const float], Au: &mut [float]) {\n     }\n }\n \n-fn eval_At_times_u(u: &[const float], Au: &mut [float]) {\n+fn eval_At_times_u(u: &const [float], Au: &mut [float]) {\n     let N = vec::len(u);\n     let mut i = 0u;\n     while i < N {\n@@ -44,7 +44,7 @@ fn eval_At_times_u(u: &[const float], Au: &mut [float]) {\n     }\n }\n \n-fn eval_AtA_times_u(u: &[const float], AtAu: &mut [float]) {\n+fn eval_AtA_times_u(u: &const [float], AtAu: &mut [float]) {\n     let mut v = vec::from_elem(vec::len(u), 0.0);\n     eval_A_times_u(u, v);\n     eval_At_times_u(v, AtAu);"}, {"sha": "9f2f9a855ed52e6dc39e7c1644d651239929586d", "filename": "src/test/compile-fail/issue-2150.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs?ref=0d52b22e7bd554464144e0a037285f62ddbd9eb2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn fail_len(v: ~[const int]) -> uint {\n+fn fail_len(v: ~[int]) -> uint {\n     let mut i = fail!();\n     for v.each |x| { i += 1u; }\n     //~^ WARNING unreachable statement"}, {"sha": "83cfd2403563adddbe74b487150f67d0e4790c23", "filename": "src/test/compile-fail/mutable-huh-vec-assign.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5df1aaab9835795bd0ef22d795d57039b703fb21/src%2Ftest%2Fcompile-fail%2Fmutable-huh-vec-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5df1aaab9835795bd0ef22d795d57039b703fb21/src%2Ftest%2Fcompile-fail%2Fmutable-huh-vec-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-vec-assign.rs?ref=5df1aaab9835795bd0ef22d795d57039b703fb21", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    fn f(&&v: ~[const int]) {\n-        // This shouldn't be possible\n-        v[0] = 1 //~ ERROR assigning to const vec content\n-    }\n-\n-    let v = ~[0];\n-\n-    f(v);\n-}"}, {"sha": "af99c0e5f2953ff30786a92025914b5d19af35d6", "filename": "src/test/compile-fail/tag-that-dare-not-speak-its-name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs?ref=0d52b22e7bd554464144e0a037285f62ddbd9eb2", "patch": "@@ -15,7 +15,7 @@\n \n extern mod core;\n \n-fn last<T>(v: ~[const &T]) -> core::Option<T> {\n+fn last<T>(v: ~[&T]) -> core::Option<T> {\n     fail!();\n }\n "}, {"sha": "f30a050211ec694db529cdebb80efc6e52501972", "filename": "src/test/compile-fail/vec-add.rs", "status": "modified", "additions": 1, "deletions": 43, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Ftest%2Fcompile-fail%2Fvec-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Ftest%2Fcompile-fail%2Fvec-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-add.rs?ref=0d52b22e7bd554464144e0a037285f62ddbd9eb2", "patch": "@@ -14,7 +14,7 @@\n // the right hand side in all cases. We are getting compiler errors\n // about this now, so I'm xfailing the test for now. -eholk\n \n-fn add(i: ~[int], mut m: ~[int], c: ~[const int]) {\n+fn add(i: ~[int], mut m: ~[int]) {\n \n     // Check that:\n     //  (1) vectors of any two mutabilities can be added\n@@ -36,10 +36,6 @@ fn add(i: ~[int], mut m: ~[int], c: ~[const int]) {\n        m + m,\n        m);\n \n-   add(i + c,\n-       m + c,\n-       c);\n-\n    add(m + ~[3], //~ ERROR mismatched types\n        m + ~[3],\n        m + ~[3]);\n@@ -48,12 +44,6 @@ fn add(i: ~[int], mut m: ~[int], c: ~[const int]) {\n        i + ~[3], //~ ERROR mismatched types\n        i + ~[3]);\n \n-   add(c + ~[3], //~ ERROR mismatched types\n-                //~^ ERROR binary operation + cannot be applied\n-       c + ~[3], //~ ERROR binary operation + cannot be applied\n-                //~^ mismatched types\n-       ~[3]);\n-\n    add(m + ~[3], //~ ERROR mismatched types\n        m + ~[3],\n        m + ~[3]);\n@@ -62,12 +52,6 @@ fn add(i: ~[int], mut m: ~[int], c: ~[const int]) {\n        i + ~[3], //~ ERROR mismatched types\n        i + ~[3]);\n \n-   add(c + ~[3], //~ ERROR binary operation + cannot be applied\n-                    //~^ mismatched types\n-       c + ~[3], //~ ERROR binary operation + cannot be applied\n-                    //~^ mismatched types\n-       ~[3]);\n-\n    add(m + i, //~ ERROR mismatched types\n        m + i,\n        m + i);\n@@ -76,39 +60,13 @@ fn add(i: ~[int], mut m: ~[int], c: ~[const int]) {\n        i + i, //~ ERROR mismatched types\n        i + i);\n \n-   add(c + i, //~ ERROR binary operation + cannot be applied\n-              //~^ ERROR mismatched types\n-       c + i, //~ ERROR binary operation + cannot be applied\n-              //~^ ERROR mismatched types\n-       i);\n-\n    add(m + m, //~ ERROR mismatched types\n        m + m,\n        m + m);\n \n    add(i + m,\n        i + m, //~ ERROR mismatched types\n        i + m);\n-\n-   add(c + m, //~ ERROR binary operation + cannot be applied\n-              //~^ ERROR mismatched types\n-       c + m, //~ ERROR binary operation + cannot be applied\n-              //~^ ERROR mismatched types\n-       m);\n-\n-   add(m + c, //~ ERROR mismatched types\n-       m + c,\n-       m + c);\n-\n-   add(i + c,\n-       i + c, //~ ERROR mismatched types\n-       i + c);\n-\n-   add(c + c, //~ ERROR binary operation + cannot be applied\n-              //~^ ERROR mismatched types\n-       c + c, //~ ERROR binary operation + cannot be applied\n-              //~^ ERROR mismatched types\n-       c);\n }\n \n fn main() {"}, {"sha": "478e01ccd042eccf841eb81b7a0ef0ef608e9544", "filename": "src/test/compile-fail/vec-concat-bug.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5df1aaab9835795bd0ef22d795d57039b703fb21/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5df1aaab9835795bd0ef22d795d57039b703fb21/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs?ref=5df1aaab9835795bd0ef22d795d57039b703fb21", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn concat<T:Copy>(v: ~[const ~[const T]]) -> ~[T] {\n-    let mut r = ~[];\n-\n-    // Earlier versions of our type checker accepted this:\n-    vec::each(v, |inner: &~[T]| {\n-        //~^ ERROR values differ in mutability\n-        r += *inner; true\n-    });\n-\n-    return r;\n-}\n-\n-fn main() {}"}, {"sha": "3f12c0d6353119d10973d5509c973f1b8afc563b", "filename": "src/test/run-pass/coerce-reborrow-imm-vec-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs?ref=0d52b22e7bd554464144e0a037285f62ddbd9eb2", "patch": "@@ -14,7 +14,7 @@ fn sum_imm(y: &[int]) -> int {\n     sum(y)\n }\n \n-fn sum_const(y: &[const int]) -> int {\n+fn sum_const(y: &const [int]) -> int {\n     sum(y)\n }\n "}, {"sha": "7dcf49ef1ac44868c3b97c63cec53405e784749c", "filename": "src/test/run-pass/coerce-reborrow-imm-vec-rcvr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d52b22e7bd554464144e0a037285f62ddbd9eb2/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs?ref=0d52b22e7bd554464144e0a037285f62ddbd9eb2", "patch": "@@ -1,6 +1,6 @@\n // xfail-test\n \n-fn foo(v: &[const uint]) -> ~[uint] {\n+fn foo(v: &const [uint]) -> ~[uint] {\n     v.to_vec()\n }\n "}, {"sha": "31375edb5de042d967752fc8dee976fa1ac5cc9d", "filename": "src/test/run-pass/impl-variance.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5df1aaab9835795bd0ef22d795d57039b703fb21/src%2Ftest%2Frun-pass%2Fimpl-variance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5df1aaab9835795bd0ef22d795d57039b703fb21/src%2Ftest%2Frun-pass%2Fimpl-variance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-variance.rs?ref=5df1aaab9835795bd0ef22d795d57039b703fb21", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-trait foo {\n-    fn foo(&self) -> uint;\n-}\n-\n-impl<T> foo for ~[const T] {\n-    fn foo(&self) -> uint { vec::len(*self) }\n-}\n-\n-pub fn main() {\n-    let v = ~[const 0];\n-    fail_unless!(v.foo() == 1u);\n-    let v = ~[0];\n-    fail_unless!(v.foo() == 1u);\n-    let mut v = ~[0];\n-    fail_unless!(v.foo() == 1u);\n-}"}, {"sha": "155046bccccc67f9322c2bb914e72ccee8836b80", "filename": "src/test/run-pass/maybe-mutable.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5df1aaab9835795bd0ef22d795d57039b703fb21/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5df1aaab9835795bd0ef22d795d57039b703fb21/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs?ref=5df1aaab9835795bd0ef22d795d57039b703fb21", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-\n-\n-// -*- rust -*-\n-fn len(v: ~[const int]) -> uint {\n-    let mut i = 0u;\n-    while i < vec::len(v) { i += 1u; }\n-    return i;\n-}\n-\n-pub fn main() {\n-    let v0 = ~[1, 2, 3, 4, 5];\n-    debug!(len(v0));\n-    let mut v1 = ~[1, 2, 3, 4, 5];\n-    debug!(len(v1));\n-}"}, {"sha": "8db2705de2b4ed45ef2d48ccc96ae93a84bf8284", "filename": "src/test/run-pass/mutable-huh-variance-vec1.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5df1aaab9835795bd0ef22d795d57039b703fb21/src%2Ftest%2Frun-pass%2Fmutable-huh-variance-vec1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5df1aaab9835795bd0ef22d795d57039b703fb21/src%2Ftest%2Frun-pass%2Fmutable-huh-variance-vec1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutable-huh-variance-vec1.rs?ref=5df1aaab9835795bd0ef22d795d57039b703fb21", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: mismatched types\n-\n-pub fn main() {\n-    let v = ~[~[0]];\n-\n-    // This is ok because the outer vec is covariant with respect\n-    // to the inner vec. If the outer vec was mut then we\n-    // couldn't do this.\n-    fn f(&&v: ~[~[const int]]) {\n-    }\n-\n-    f(v);\n-}"}, {"sha": "7c48744000d4f7e945d61b309cb4dd489287127e", "filename": "src/test/run-pass/mutable-huh-variance-vec2.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5df1aaab9835795bd0ef22d795d57039b703fb21/src%2Ftest%2Frun-pass%2Fmutable-huh-variance-vec2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5df1aaab9835795bd0ef22d795d57039b703fb21/src%2Ftest%2Frun-pass%2Fmutable-huh-variance-vec2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutable-huh-variance-vec2.rs?ref=5df1aaab9835795bd0ef22d795d57039b703fb21", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: mismatched types\n-\n-pub fn main() {\n-    let v = ~[~[0]];\n-\n-    // This is ok because the outer vec is covariant with respect\n-    // to the inner vec. If the outer vec was mut then we\n-    // couldn't do this.\n-    fn f(&&v: ~[const ~[const int]]) {\n-    }\n-\n-    f(v);\n-}"}]}