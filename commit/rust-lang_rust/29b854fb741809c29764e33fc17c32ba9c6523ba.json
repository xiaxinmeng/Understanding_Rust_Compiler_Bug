{"sha": "29b854fb741809c29764e33fc17c32ba9c6523ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5Yjg1NGZiNzQxODA5YzI5NzY0ZTMzZmMxN2MzMmJhOWM2NTIzYmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-20T00:10:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-20T00:10:48Z"}, "message": "Auto merge of #68057 - Aaron1011:fix/marker-trait-selection, r=matthewjasper\n\nDon't discard marker trait impls when inference variables are present\n\nFixes #61651\n\nPreviously, we would unconditionally discard impl candidates for marker\ntraits during trait selection. However, if the predicate had inference\nvariables, this could have the effect of constrainting inference\nvariables (due to a successful trait selection) when we would have\notherwise failed due to mutliple applicable impls,\n\nThis commit prevents marker trait impls from being discarded while the\nobligation predicate has any inference variables, ensuring that\ndiscarding impls will never cause us to incorrectly constraint inference\nvariables.", "tree": {"sha": "dbb4a241356f69d26e238a65462724596b6cff8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbb4a241356f69d26e238a65462724596b6cff8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29b854fb741809c29764e33fc17c32ba9c6523ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29b854fb741809c29764e33fc17c32ba9c6523ba", "html_url": "https://github.com/rust-lang/rust/commit/29b854fb741809c29764e33fc17c32ba9c6523ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29b854fb741809c29764e33fc17c32ba9c6523ba/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7da653f669dcb97d40ca29b2937518bb8a12b775", "url": "https://api.github.com/repos/rust-lang/rust/commits/7da653f669dcb97d40ca29b2937518bb8a12b775", "html_url": "https://github.com/rust-lang/rust/commit/7da653f669dcb97d40ca29b2937518bb8a12b775"}, {"sha": "4840cd8117010e057109e0233f403e526d309d9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4840cd8117010e057109e0233f403e526d309d9f", "html_url": "https://github.com/rust-lang/rust/commit/4840cd8117010e057109e0233f403e526d309d9f"}], "stats": {"total": 94, "additions": 84, "deletions": 10}, "files": [{"sha": "3bfe542baabbf82a8e4245f545620d6d15cfab26", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 57, "deletions": 5, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/29b854fb741809c29764e33fc17c32ba9c6523ba/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b854fb741809c29764e33fc17c32ba9c6523ba/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=29b854fb741809c29764e33fc17c32ba9c6523ba", "patch": "@@ -1417,14 +1417,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(\"winnowed to {} candidates for {:?}: {:?}\", candidates.len(), stack, candidates);\n \n+        let needs_infer = stack.obligation.predicate.needs_infer();\n+\n         // If there are STILL multiple candidates, we can further\n         // reduce the list by dropping duplicates -- including\n         // resolving specializations.\n         if candidates.len() > 1 {\n             let mut i = 0;\n             while i < candidates.len() {\n                 let is_dup = (0..candidates.len()).filter(|&j| i != j).any(|j| {\n-                    self.candidate_should_be_dropped_in_favor_of(&candidates[i], &candidates[j])\n+                    self.candidate_should_be_dropped_in_favor_of(\n+                        &candidates[i],\n+                        &candidates[j],\n+                        needs_infer,\n+                    )\n                 });\n                 if is_dup {\n                     debug!(\"Dropping candidate #{}/{}: {:?}\", i, candidates.len(), candidates[i]);\n@@ -2258,6 +2264,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         victim: &EvaluatedCandidate<'tcx>,\n         other: &EvaluatedCandidate<'tcx>,\n+        needs_infer: bool,\n     ) -> bool {\n         if victim.candidate == other.candidate {\n             return true;\n@@ -2339,10 +2346,55 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     match victim.candidate {\n                         ImplCandidate(victim_def) => {\n                             let tcx = self.tcx();\n-                            return tcx.specializes((other_def, victim_def))\n-                                || tcx\n-                                    .impls_are_allowed_to_overlap(other_def, victim_def)\n-                                    .is_some();\n+                            if tcx.specializes((other_def, victim_def)) {\n+                                return true;\n+                            }\n+                            return match tcx.impls_are_allowed_to_overlap(other_def, victim_def) {\n+                                Some(ty::ImplOverlapKind::Permitted { marker: true }) => {\n+                                    // Subtle: If the predicate we are evaluating has inference\n+                                    // variables, do *not* allow discarding candidates due to\n+                                    // marker trait impls.\n+                                    //\n+                                    // Without this restriction, we could end up accidentally\n+                                    // constrainting inference variables based on an arbitrarily\n+                                    // chosen trait impl.\n+                                    //\n+                                    // Imagine we have the following code:\n+                                    //\n+                                    // ```rust\n+                                    // #[marker] trait MyTrait {}\n+                                    // impl MyTrait for u8 {}\n+                                    // impl MyTrait for bool {}\n+                                    // ```\n+                                    //\n+                                    // And we are evaluating the predicate `<_#0t as MyTrait>`.\n+                                    //\n+                                    // During selection, we will end up with one candidate for each\n+                                    // impl of `MyTrait`. If we were to discard one impl in favor\n+                                    // of the other, we would be left with one candidate, causing\n+                                    // us to \"successfully\" select the predicate, unifying\n+                                    // _#0t with (for example) `u8`.\n+                                    //\n+                                    // However, we have no reason to believe that this unification\n+                                    // is correct - we've essentially just picked an arbitrary\n+                                    // *possibility* for _#0t, and required that this be the *only*\n+                                    // possibility.\n+                                    //\n+                                    // Eventually, we will either:\n+                                    // 1) Unify all inference variables in the predicate through\n+                                    // some other means (e.g. type-checking of a function). We will\n+                                    // then be in a position to drop marker trait candidates\n+                                    // without constraining inference variables (since there are\n+                                    // none left to constrin)\n+                                    // 2) Be left with some unconstrained inference variables. We\n+                                    // will then correctly report an inference error, since the\n+                                    // existence of multiple marker trait impls tells us nothing\n+                                    // about which one should actually apply.\n+                                    !needs_infer\n+                                }\n+                                Some(_) => true,\n+                                None => false,\n+                            };\n                         }\n                         ParamCandidate(ref cand) => {\n                             // Prefer the impl to a global where clause candidate."}, {"sha": "9509b6220eb0ed15d6d49db5445686b7225545fe", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29b854fb741809c29764e33fc17c32ba9c6523ba/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b854fb741809c29764e33fc17c32ba9c6523ba/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=29b854fb741809c29764e33fc17c32ba9c6523ba", "patch": "@@ -163,7 +163,7 @@ impl<'tcx> Children {\n                         tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling)\n                     {\n                         match overlap_kind {\n-                            ty::ImplOverlapKind::Permitted => {}\n+                            ty::ImplOverlapKind::Permitted { marker: _ } => {}\n                             ty::ImplOverlapKind::Issue33140 => {\n                                 last_lint = Some(FutureCompatOverlapError {\n                                     error: overlap_error(overlap),"}, {"sha": "3040ecf90ed53b95925f8ed254c0c204067b80e4", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/29b854fb741809c29764e33fc17c32ba9c6523ba/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b854fb741809c29764e33fc17c32ba9c6523ba/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=29b854fb741809c29764e33fc17c32ba9c6523ba", "patch": "@@ -2591,7 +2591,12 @@ impl<'tcx> ::std::ops::Deref for Attributes<'tcx> {\n #[derive(Debug, PartialEq, Eq)]\n pub enum ImplOverlapKind {\n     /// These impls are always allowed to overlap.\n-    Permitted,\n+    Permitted {\n+        /// Whether or not the impl is permitted due to the trait being\n+        /// a marker trait (a trait with #[marker], or a trait with\n+        /// no associated items and #![feature(overlapping_marker_traits)] enabled)\n+        marker: bool,\n+    },\n     /// These impls are allowed to overlap, but that raises\n     /// an issue #33140 future-compatibility warning.\n     ///\n@@ -2711,7 +2716,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if self.impl_trait_ref(def_id1).map_or(false, |tr| tr.references_error())\n             || self.impl_trait_ref(def_id2).map_or(false, |tr| tr.references_error())\n         {\n-            return Some(ImplOverlapKind::Permitted);\n+            return Some(ImplOverlapKind::Permitted { marker: false });\n         }\n \n         match (self.impl_polarity(def_id1), self.impl_polarity(def_id2)) {\n@@ -2721,7 +2726,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     \"impls_are_allowed_to_overlap({:?}, {:?}) = Some(Permitted) (reservations)\",\n                     def_id1, def_id2\n                 );\n-                return Some(ImplOverlapKind::Permitted);\n+                return Some(ImplOverlapKind::Permitted { marker: false });\n             }\n             (ImplPolarity::Positive, ImplPolarity::Negative)\n             | (ImplPolarity::Negative, ImplPolarity::Positive) => {\n@@ -2757,7 +2762,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 \"impls_are_allowed_to_overlap({:?}, {:?}) = Some(Permitted) (marker overlap)\",\n                 def_id1, def_id2\n             );\n-            Some(ImplOverlapKind::Permitted)\n+            Some(ImplOverlapKind::Permitted { marker: true })\n         } else {\n             if let Some(self_ty1) = self.issue33140_self_ty(def_id1) {\n                 if let Some(self_ty2) = self.issue33140_self_ty(def_id2) {"}, {"sha": "0af706615e31ffb306ed0bcddc72d13ad5335ae1", "filename": "src/test/ui/marker_trait_attr/issue-61651-type-mismatch.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/29b854fb741809c29764e33fc17c32ba9c6523ba/src%2Ftest%2Fui%2Fmarker_trait_attr%2Fissue-61651-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b854fb741809c29764e33fc17c32ba9c6523ba/src%2Ftest%2Fui%2Fmarker_trait_attr%2Fissue-61651-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmarker_trait_attr%2Fissue-61651-type-mismatch.rs?ref=29b854fb741809c29764e33fc17c32ba9c6523ba", "patch": "@@ -0,0 +1,17 @@\n+// check-pass\n+// Regression test for issue #61651\n+// Verifies that we don't try to constrain inference\n+// variables due to the presence of multiple applicable\n+// marker trait impls\n+\n+#![feature(marker_trait_attr)]\n+\n+#[marker] // Remove this line and it works?!?\n+trait Foo<T> {}\n+impl Foo<u16> for u8 {}\n+impl Foo<[u8; 1]> for u8 {}\n+fn foo<T: Foo<U>, U>(_: T) -> U { unimplemented!() }\n+\n+fn main() {\n+    let _: u16 = foo(0_u8);\n+}"}]}