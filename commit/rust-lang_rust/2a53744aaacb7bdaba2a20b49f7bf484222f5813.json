{"sha": "2a53744aaacb7bdaba2a20b49f7bf484222f5813", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhNTM3NDRhYWFjYjdiZGFiYTJhMjBiNDlmN2JmNDg0MjIyZjU4MTM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-08-14T09:11:54Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-08-15T09:01:47Z"}, "message": "convert tydecode to use an impl, eliminating a lot of boilerplate", "tree": {"sha": "0d76325b5a5e362c07b722194c53e9a9feb8a09a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d76325b5a5e362c07b722194c53e9a9feb8a09a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a53744aaacb7bdaba2a20b49f7bf484222f5813", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a53744aaacb7bdaba2a20b49f7bf484222f5813", "html_url": "https://github.com/rust-lang/rust/commit/2a53744aaacb7bdaba2a20b49f7bf484222f5813", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a53744aaacb7bdaba2a20b49f7bf484222f5813/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9bb5a68f866a11a7507ccd4994978ad6d080eb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9bb5a68f866a11a7507ccd4994978ad6d080eb0", "html_url": "https://github.com/rust-lang/rust/commit/c9bb5a68f866a11a7507ccd4994978ad6d080eb0"}], "stats": {"total": 1239, "additions": 618, "deletions": 621}, "files": [{"sha": "2ddb0697c171bd692c4bc75de85144e23f8ff9c9", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 618, "deletions": 621, "changes": 1239, "blob_url": "https://github.com/rust-lang/rust/blob/2a53744aaacb7bdaba2a20b49f7bf484222f5813/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a53744aaacb7bdaba2a20b49f7bf484222f5813/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=2a53744aaacb7bdaba2a20b49f7bf484222f5813", "patch": "@@ -57,82 +57,6 @@ pub enum DefIdSource {\n     ClosureSource\n }\n \n-pub type DefIdConvert<'a> = &'a mut FnMut(DefIdSource, ast::DefId) -> ast::DefId;\n-\n-pub struct PState<'a, 'tcx: 'a> {\n-    data: &'a [u8],\n-    krate: ast::CrateNum,\n-    pos: usize,\n-    tcx: &'a ty::ctxt<'tcx>,\n-    conv_def_id: DefIdConvert<'a>,\n-}\n-\n-fn peek(st: &PState) -> char {\n-    st.data[st.pos] as char\n-}\n-\n-fn next(st: &mut PState) -> char {\n-    let ch = st.data[st.pos] as char;\n-    st.pos = st.pos + 1;\n-    return ch;\n-}\n-\n-fn next_byte(st: &mut PState) -> u8 {\n-    let b = st.data[st.pos];\n-    st.pos = st.pos + 1;\n-    return b;\n-}\n-\n-fn scan<'a, 'tcx, F>(st: &mut PState<'a,'tcx>, mut is_last: F) -> &'a [u8] where\n-    F: FnMut(char) -> bool,\n-{\n-    let start_pos = st.pos;\n-    debug!(\"scan: '{}' (start)\", st.data[st.pos] as char);\n-    while !is_last(st.data[st.pos] as char) {\n-        st.pos += 1;\n-        debug!(\"scan: '{}'\", st.data[st.pos] as char);\n-    }\n-    let end_pos = st.pos;\n-    st.pos += 1;\n-    return &st.data[start_pos..end_pos];\n-}\n-\n-pub fn parse_name(st: &mut PState, last: char) -> ast::Name {\n-    fn is_last(b: char, c: char) -> bool { return c == b; }\n-    let bytes = scan(st, |a| is_last(last, a));\n-    token::intern(str::from_utf8(bytes).unwrap())\n-}\n-\n-pub fn parse_state_from_data<'a, 'tcx>(data: &'a [u8],\n-                                       crate_num: ast::CrateNum,\n-                                       pos: usize,\n-                                       tcx: &'a ty::ctxt<'tcx>,\n-                                       conv: DefIdConvert<'a>)\n-                                       -> PState<'a, 'tcx> {\n-    PState {\n-        data: data,\n-        krate: crate_num,\n-        pos: pos,\n-        tcx: tcx,\n-        conv_def_id: conv,\n-    }\n-}\n-\n-fn data_log_string(data: &[u8], pos: usize) -> String {\n-    let mut buf = String::new();\n-    buf.push_str(\"<<\");\n-    for i in pos..data.len() {\n-        let c = data[i];\n-        if c > 0x20 && c <= 0x7F {\n-            buf.push(c as char);\n-        } else {\n-            buf.push('.');\n-        }\n-    }\n-    buf.push_str(\">>\");\n-    buf\n-}\n-\n pub fn parse_ty_closure_data<'tcx, F>(data: &[u8],\n                                       crate_num: ast::CrateNum,\n                                       pos: usize,\n@@ -141,26 +65,26 @@ pub fn parse_ty_closure_data<'tcx, F>(data: &[u8],\n                                       -> ty::ClosureTy<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n-    let mut st = parse_state_from_data(data, crate_num, pos, tcx, &mut conv);\n-    parse_closure_ty(&mut st)\n+    let mut st = PState::new(data, crate_num, pos, tcx, &mut conv);\n+    st.parse_closure_ty()\n }\n \n pub fn parse_ty_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: usize,\n                               tcx: &ty::ctxt<'tcx>, mut conv: F) -> Ty<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     debug!(\"parse_ty_data {}\", data_log_string(data, pos));\n-    let mut st = parse_state_from_data(data, crate_num, pos, tcx, &mut conv);\n-    parse_ty(&mut st)\n+    let mut st = PState::new(data, crate_num, pos, tcx, &mut conv);\n+    st.parse_ty()\n }\n \n pub fn parse_region_data<F>(data: &[u8], crate_num: ast::CrateNum, pos: usize, tcx: &ty::ctxt,\n                             mut conv: F) -> ty::Region where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     debug!(\"parse_region_data {}\", data_log_string(data, pos));\n-    let mut st = parse_state_from_data(data, crate_num, pos, tcx, &mut conv);\n-    parse_region(&mut st)\n+    let mut st = PState::new(data, crate_num, pos, tcx, &mut conv);\n+    st.parse_region()\n }\n \n pub fn parse_bare_fn_ty_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: usize,\n@@ -169,8 +93,8 @@ pub fn parse_bare_fn_ty_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     debug!(\"parse_bare_fn_ty_data {}\", data_log_string(data, pos));\n-    let mut st = parse_state_from_data(data, crate_num, pos, tcx, &mut conv);\n-    parse_bare_fn_ty(&mut st)\n+    let mut st = PState::new(data, crate_num, pos, tcx, &mut conv);\n+    st.parse_bare_fn_ty()\n }\n \n pub fn parse_trait_ref_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: usize,\n@@ -179,487 +103,684 @@ pub fn parse_trait_ref_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos:\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     debug!(\"parse_trait_ref_data {}\", data_log_string(data, pos));\n-    let mut st = parse_state_from_data(data, crate_num, pos, tcx, &mut conv);\n-    parse_trait_ref(&mut st)\n+    let mut st = PState::new(data, crate_num, pos, tcx, &mut conv);\n+    st.parse_trait_ref()\n }\n \n pub fn parse_substs_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: usize,\n                                   tcx: &ty::ctxt<'tcx>, mut conv: F) -> subst::Substs<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     debug!(\"parse_substs_data{}\", data_log_string(data, pos));\n-    let mut st = parse_state_from_data(data, crate_num, pos, tcx, &mut conv);\n-    parse_substs(&mut st)\n+    let mut st = PState::new(data, crate_num, pos, tcx, &mut conv);\n+    st.parse_substs()\n }\n \n pub fn parse_existential_bounds_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum,\n                                               pos: usize, tcx: &ty::ctxt<'tcx>, mut conv: F)\n                                               -> ty::ExistentialBounds<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n-    let mut st = parse_state_from_data(data, crate_num, pos, tcx, &mut conv);\n-    parse_existential_bounds(&mut st)\n+    let mut st = PState::new(data, crate_num, pos, tcx, &mut conv);\n+    st.parse_existential_bounds()\n }\n \n pub fn parse_builtin_bounds_data<F>(data: &[u8], crate_num: ast::CrateNum,\n                                     pos: usize, tcx: &ty::ctxt, mut conv: F)\n                                     -> ty::BuiltinBounds where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n-    let mut st = parse_state_from_data(data, crate_num, pos, tcx, &mut conv);\n-    parse_builtin_bounds(&mut st)\n+    let mut st = PState::new(data, crate_num, pos, tcx, &mut conv);\n+    st.parse_builtin_bounds()\n }\n \n-fn parse_size(st: &mut PState) -> Option<usize> {\n-    assert_eq!(next(st), '/');\n-\n-    if peek(st) == '|' {\n-        assert_eq!(next(st), '|');\n-        None\n-    } else {\n-        let n = parse_uint(st);\n-        assert_eq!(next(st), '|');\n-        Some(n)\n-    }\n+pub fn parse_type_param_def_data<'tcx, F>(data: &[u8], start: usize,\n+                                          crate_num: ast::CrateNum, tcx: &ty::ctxt<'tcx>,\n+                                          mut conv: F) -> ty::TypeParameterDef<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n+    let mut st = PState::new(data, crate_num, start, tcx, &mut conv);\n+    st.parse_type_param_def()\n }\n \n-fn parse_vec_per_param_space<'a, 'tcx, T, F>(st: &mut PState<'a, 'tcx>,\n-                                             mut f: F)\n-                                             -> VecPerParamSpace<T> where\n-    F: FnMut(&mut PState<'a, 'tcx>) -> T,\n+pub fn parse_predicate_data<'tcx, F>(data: &[u8],\n+                                     start: usize,\n+                                     crate_num: ast::CrateNum,\n+                                     tcx: &ty::ctxt<'tcx>,\n+                                     mut conv: F)\n+                                     -> ty::Predicate<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n-    let mut r = VecPerParamSpace::empty();\n-    for &space in &subst::ParamSpace::all() {\n-        assert_eq!(next(st), '[');\n-        while peek(st) != ']' {\n-            r.push(space, f(st));\n-        }\n-        assert_eq!(next(st), ']');\n-    }\n-    r\n+    let mut st = PState::new(data, crate_num, start, tcx, &mut conv);\n+    st.parse_predicate()\n }\n \n-fn parse_substs<'a, 'tcx>(st: &mut PState<'a, 'tcx>) -> subst::Substs<'tcx> {\n-    let regions = parse_region_substs(st);\n-    let types = parse_vec_per_param_space(st, |st| parse_ty(st));\n-    subst::Substs { types: types, regions: regions }\n+pub type DefIdConvert<'a> = &'a mut FnMut(DefIdSource, ast::DefId) -> ast::DefId;\n+\n+pub struct PState<'a, 'tcx: 'a> {\n+    data: &'a [u8],\n+    krate: ast::CrateNum,\n+    pos: usize,\n+    tcx: &'a ty::ctxt<'tcx>,\n+    conv_def_id: DefIdConvert<'a>,\n }\n \n-fn parse_region_substs(st: &mut PState) -> subst::RegionSubsts {\n-    match next(st) {\n-        'e' => subst::ErasedRegions,\n-        'n' => {\n-            subst::NonerasedRegions(\n-                parse_vec_per_param_space(\n-                    st, |st| parse_region(st)))\n+impl<'a,'tcx> PState<'a,'tcx> {\n+    pub fn new(data: &'a [u8],\n+               crate_num: ast::CrateNum,\n+               pos: usize,\n+               tcx: &'a ty::ctxt<'tcx>,\n+               conv: DefIdConvert<'a>)\n+               -> PState<'a, 'tcx> {\n+        PState {\n+            data: data,\n+            krate: crate_num,\n+            pos: pos,\n+            tcx: tcx,\n+            conv_def_id: conv,\n         }\n-        _ => panic!(\"parse_bound_region: bad input\")\n     }\n-}\n \n-fn parse_bound_region(st: &mut PState) -> ty::BoundRegion {\n-    match next(st) {\n-        'a' => {\n-            let id = parse_u32(st);\n-            assert_eq!(next(st), '|');\n-            ty::BrAnon(id)\n+    fn peek(&self) -> char {\n+        self.data[self.pos] as char\n+    }\n+\n+    fn next(&mut self) -> char {\n+        let ch = self.data[self.pos] as char;\n+        self.pos = self.pos + 1;\n+        return ch;\n+    }\n+\n+    fn next_byte(&mut self) -> u8 {\n+        let b = self.data[self.pos];\n+        self.pos = self.pos + 1;\n+        return b;\n+    }\n+\n+    fn scan<F>(&mut self, mut is_last: F) -> &'a [u8]\n+        where F: FnMut(char) -> bool,\n+    {\n+        let start_pos = self.pos;\n+        debug!(\"scan: '{}' (start)\", self.data[self.pos] as char);\n+        while !is_last(self.data[self.pos] as char) {\n+            self.pos += 1;\n+            debug!(\"scan: '{}'\", self.data[self.pos] as char);\n         }\n-        '[' => {\n-            let def = parse_def(st, RegionParameter);\n-            let ident = token::str_to_ident(&parse_str(st, ']'));\n-            ty::BrNamed(def, ident.name)\n+        let end_pos = self.pos;\n+        self.pos += 1;\n+        return &self.data[start_pos..end_pos];\n+    }\n+\n+    pub fn parse_name(&mut self, last: char) -> ast::Name {\n+        fn is_last(b: char, c: char) -> bool { return c == b; }\n+        let bytes = self.scan(|a| is_last(last, a));\n+        token::intern(str::from_utf8(bytes).unwrap())\n+    }\n+\n+    fn parse_size(&mut self) -> Option<usize> {\n+        assert_eq!(self.next(), '/');\n+\n+        if self.peek() == '|' {\n+            assert_eq!(self.next(), '|');\n+            None\n+        } else {\n+            let n = self.parse_uint();\n+            assert_eq!(self.next(), '|');\n+            Some(n)\n         }\n-        'f' => {\n-            let id = parse_u32(st);\n-            assert_eq!(next(st), '|');\n-            ty::BrFresh(id)\n+    }\n+\n+    fn parse_vec_per_param_space<T, F>(&mut self, mut f: F) -> VecPerParamSpace<T> where\n+        F: FnMut(&mut PState<'a, 'tcx>) -> T,\n+    {\n+        let mut r = VecPerParamSpace::empty();\n+        for &space in &subst::ParamSpace::all() {\n+            assert_eq!(self.next(), '[');\n+            while self.peek() != ']' {\n+                r.push(space, f(self));\n+            }\n+            assert_eq!(self.next(), ']');\n         }\n-        'e' => ty::BrEnv,\n-        _ => panic!(\"parse_bound_region: bad input\")\n+        r\n     }\n-}\n \n-fn parse_region(st: &mut PState) -> ty::Region {\n-    match next(st) {\n-      'b' => {\n-        assert_eq!(next(st), '[');\n-        let id = ty::DebruijnIndex::new(parse_u32(st));\n-        assert_eq!(next(st), '|');\n-        let br = parse_bound_region(st);\n-        assert_eq!(next(st), ']');\n-        ty::ReLateBound(id, br)\n-      }\n-      'B' => {\n-        assert_eq!(next(st), '[');\n-        let node_id = parse_uint(st) as ast::NodeId;\n-        assert_eq!(next(st), '|');\n-        let space = parse_param_space(st);\n-        assert_eq!(next(st), '|');\n-        let index = parse_u32(st);\n-        assert_eq!(next(st), '|');\n-        let nm = token::str_to_ident(&parse_str(st, ']'));\n-        ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            param_id: node_id,\n-            space: space,\n-            index: index,\n-            name: nm.name\n-        })\n-      }\n-      'f' => {\n-        assert_eq!(next(st), '[');\n-        let scope = parse_destruction_scope_data(st);\n-        assert_eq!(next(st), '|');\n-        let br = parse_bound_region(st);\n-        assert_eq!(next(st), ']');\n-        ty::ReFree(ty::FreeRegion { scope: scope,\n-                                    bound_region: br})\n-      }\n-      's' => {\n-        let scope = parse_scope(st);\n-        assert_eq!(next(st), '|');\n-        ty::ReScope(scope)\n-      }\n-      't' => {\n-        ty::ReStatic\n-      }\n-      'e' => {\n-        ty::ReStatic\n-      }\n-      _ => panic!(\"parse_region: bad input\")\n+    fn parse_substs(&mut self) -> subst::Substs<'tcx> {\n+        let regions = self.parse_region_substs();\n+        let types = self.parse_vec_per_param_space(|this| this.parse_ty());\n+        subst::Substs { types: types, regions: regions }\n     }\n-}\n \n-fn parse_scope(st: &mut PState) -> region::CodeExtent {\n-    match next(st) {\n-        'P' => {\n-            assert_eq!(next(st), '[');\n-            let fn_id = parse_uint(st) as ast::NodeId;\n-            assert_eq!(next(st), '|');\n-            let body_id = parse_uint(st) as ast::NodeId;\n-            assert_eq!(next(st), ']');\n-            region::CodeExtent::ParameterScope {\n-                fn_id: fn_id, body_id: body_id\n+    fn parse_region_substs(&mut self) -> subst::RegionSubsts {\n+        match self.next() {\n+            'e' => subst::ErasedRegions,\n+            'n' => {\n+                subst::NonerasedRegions(\n+                    self.parse_vec_per_param_space(|this| this.parse_region()))\n             }\n+            _ => panic!(\"parse_bound_region: bad input\")\n         }\n-        'M' => {\n-            let node_id = parse_uint(st) as ast::NodeId;\n-            region::CodeExtent::Misc(node_id)\n+    }\n+\n+    fn parse_bound_region(&mut self) -> ty::BoundRegion {\n+        match self.next() {\n+            'a' => {\n+                let id = self.parse_u32();\n+                assert_eq!(self.next(), '|');\n+                ty::BrAnon(id)\n+            }\n+            '[' => {\n+                let def = self.parse_def(RegionParameter);\n+                let ident = token::str_to_ident(&self.parse_str(']'));\n+                ty::BrNamed(def, ident.name)\n+            }\n+            'f' => {\n+                let id = self.parse_u32();\n+                assert_eq!(self.next(), '|');\n+                ty::BrFresh(id)\n+            }\n+            'e' => ty::BrEnv,\n+            _ => panic!(\"parse_bound_region: bad input\")\n         }\n-        'D' => {\n-            let node_id = parse_uint(st) as ast::NodeId;\n-            region::CodeExtent::DestructionScope(node_id)\n+    }\n+\n+    fn parse_region(&mut self) -> ty::Region {\n+        match self.next() {\n+            'b' => {\n+                assert_eq!(self.next(), '[');\n+                let id = ty::DebruijnIndex::new(self.parse_u32());\n+                assert_eq!(self.next(), '|');\n+                let br = self.parse_bound_region();\n+                assert_eq!(self.next(), ']');\n+                ty::ReLateBound(id, br)\n+            }\n+            'B' => {\n+                assert_eq!(self.next(), '[');\n+                let node_id = self.parse_uint() as ast::NodeId;\n+                assert_eq!(self.next(), '|');\n+                let space = self.parse_param_space();\n+                assert_eq!(self.next(), '|');\n+                let index = self.parse_u32();\n+                assert_eq!(self.next(), '|');\n+                let nm = token::str_to_ident(&self.parse_str(']'));\n+                ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                    param_id: node_id,\n+                    space: space,\n+                    index: index,\n+                    name: nm.name\n+                })\n+            }\n+            'f' => {\n+                assert_eq!(self.next(), '[');\n+                let scope = self.parse_destruction_scope_data();\n+                assert_eq!(self.next(), '|');\n+                let br = self.parse_bound_region();\n+                assert_eq!(self.next(), ']');\n+                ty::ReFree(ty::FreeRegion { scope: scope,\n+                                            bound_region: br})\n+            }\n+            's' => {\n+                let scope = self.parse_scope();\n+                assert_eq!(self.next(), '|');\n+                ty::ReScope(scope)\n+            }\n+            't' => {\n+                ty::ReStatic\n+            }\n+            'e' => {\n+                ty::ReStatic\n+            }\n+            _ => panic!(\"parse_region: bad input\")\n         }\n-        'B' => {\n-            assert_eq!(next(st), '[');\n-            let node_id = parse_uint(st) as ast::NodeId;\n-            assert_eq!(next(st), '|');\n-            let first_stmt_index = parse_uint(st);\n-            assert_eq!(next(st), ']');\n-            let block_remainder = region::BlockRemainder {\n-                block: node_id, first_statement_index: first_stmt_index,\n-            };\n-            region::CodeExtent::Remainder(block_remainder)\n+    }\n+\n+    fn parse_scope(&mut self) -> region::CodeExtent {\n+        match self.next() {\n+            'P' => {\n+                assert_eq!(self.next(), '[');\n+                let fn_id = self.parse_uint() as ast::NodeId;\n+                assert_eq!(self.next(), '|');\n+                let body_id = self.parse_uint() as ast::NodeId;\n+                assert_eq!(self.next(), ']');\n+                region::CodeExtent::ParameterScope {\n+                    fn_id: fn_id, body_id: body_id\n+                }\n+            }\n+            'M' => {\n+                let node_id = self.parse_uint() as ast::NodeId;\n+                region::CodeExtent::Misc(node_id)\n+            }\n+            'D' => {\n+                let node_id = self.parse_uint() as ast::NodeId;\n+                region::CodeExtent::DestructionScope(node_id)\n+            }\n+            'B' => {\n+                assert_eq!(self.next(), '[');\n+                let node_id = self.parse_uint() as ast::NodeId;\n+                assert_eq!(self.next(), '|');\n+                let first_stmt_index = self.parse_uint();\n+                assert_eq!(self.next(), ']');\n+                let block_remainder = region::BlockRemainder {\n+                    block: node_id, first_statement_index: first_stmt_index,\n+                };\n+                region::CodeExtent::Remainder(block_remainder)\n+            }\n+            _ => panic!(\"parse_scope: bad input\")\n         }\n-        _ => panic!(\"parse_scope: bad input\")\n     }\n-}\n \n-fn parse_destruction_scope_data(st: &mut PState) -> region::DestructionScopeData {\n-    let node_id = parse_uint(st) as ast::NodeId;\n-    region::DestructionScopeData::new(node_id)\n-}\n+    fn parse_destruction_scope_data(&mut self) -> region::DestructionScopeData {\n+        let node_id = self.parse_uint() as ast::NodeId;\n+        region::DestructionScopeData::new(node_id)\n+    }\n \n-fn parse_opt<'a, 'tcx, T, F>(st: &mut PState<'a, 'tcx>, f: F) -> Option<T> where\n-    F: FnOnce(&mut PState<'a, 'tcx>) -> T,\n-{\n-    match next(st) {\n-      'n' => None,\n-      's' => Some(f(st)),\n-      _ => panic!(\"parse_opt: bad input\")\n+    fn parse_opt<T, F>(&mut self, f: F) -> Option<T>\n+        where F: FnOnce(&mut PState<'a, 'tcx>) -> T,\n+    {\n+        match self.next() {\n+            'n' => None,\n+            's' => Some(f(self)),\n+            _ => panic!(\"parse_opt: bad input\")\n+        }\n     }\n-}\n \n-fn parse_str(st: &mut PState, term: char) -> String {\n-    let mut result = String::new();\n-    while peek(st) != term {\n-        unsafe {\n-            result.as_mut_vec().push_all(&[next_byte(st)])\n+    fn parse_str(&mut self, term: char) -> String {\n+        let mut result = String::new();\n+        while self.peek() != term {\n+            unsafe {\n+                result.as_mut_vec().push_all(&[self.next_byte()])\n+            }\n         }\n+        self.next();\n+        result\n     }\n-    next(st);\n-    result\n-}\n \n-fn parse_trait_ref<'a, 'tcx>(st: &mut PState<'a, 'tcx>) -> ty::TraitRef<'tcx> {\n-    let def = parse_def(st, NominalType);\n-    let substs = st.tcx.mk_substs(parse_substs(st));\n-    ty::TraitRef {def_id: def, substs: substs}\n-}\n+    fn parse_trait_ref(&mut self) -> ty::TraitRef<'tcx> {\n+        let def = self.parse_def(NominalType);\n+        let substs = self.tcx.mk_substs(self.parse_substs());\n+        ty::TraitRef {def_id: def, substs: substs}\n+    }\n \n-fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>) -> Ty<'tcx> {\n-    let tcx = st.tcx;\n-    match next(st) {\n-      'b' => return tcx.types.bool,\n-      'i' => { /* eat the s of is */ next(st); return tcx.types.isize },\n-      'u' => { /* eat the s of us */ next(st); return tcx.types.usize },\n-      'M' => {\n-        match next(st) {\n-          'b' => return tcx.types.u8,\n-          'w' => return tcx.types.u16,\n-          'l' => return tcx.types.u32,\n-          'd' => return tcx.types.u64,\n-          'B' => return tcx.types.i8,\n-          'W' => return tcx.types.i16,\n-          'L' => return tcx.types.i32,\n-          'D' => return tcx.types.i64,\n-          'f' => return tcx.types.f32,\n-          'F' => return tcx.types.f64,\n-          _ => panic!(\"parse_ty: bad numeric type\")\n-        }\n-      }\n-      'c' => return tcx.types.char,\n-      't' => {\n-        assert_eq!(next(st), '[');\n-        let did = parse_def(st, NominalType);\n-        let substs = parse_substs(st);\n-        assert_eq!(next(st), ']');\n-        let def = st.tcx.lookup_adt_def(did);\n-        return tcx.mk_enum(def, st.tcx.mk_substs(substs));\n-      }\n-      'x' => {\n-        assert_eq!(next(st), '[');\n-        let trait_ref = ty::Binder(parse_trait_ref(st));\n-        let bounds = parse_existential_bounds(st);\n-        assert_eq!(next(st), ']');\n-        return tcx.mk_trait(trait_ref, bounds);\n-      }\n-      'p' => {\n-        assert_eq!(next(st), '[');\n-        let index = parse_u32(st);\n-        assert_eq!(next(st), '|');\n-        let space = parse_param_space(st);\n-        assert_eq!(next(st), '|');\n-        let name = token::intern(&parse_str(st, ']'));\n-        return tcx.mk_param(space, index, name);\n-      }\n-      '~' => return tcx.mk_box(parse_ty(st)),\n-      '*' => return tcx.mk_ptr(parse_mt(st)),\n-      '&' => {\n-        let r = parse_region(st);\n-        let mt = parse_mt(st);\n-        return tcx.mk_ref(tcx.mk_region(r), mt);\n-      }\n-      'V' => {\n-        let t = parse_ty(st);\n-        return match parse_size(st) {\n-            Some(n) => tcx.mk_array(t, n),\n-            None => tcx.mk_slice(t)\n-        };\n-      }\n-      'v' => {\n-        return tcx.mk_str();\n-      }\n-      'T' => {\n-        assert_eq!(next(st), '[');\n-        let mut params = Vec::new();\n-        while peek(st) != ']' { params.push(parse_ty(st)); }\n-        st.pos = st.pos + 1;\n-        return tcx.mk_tup(params);\n-      }\n-      'F' => {\n-          let def_id = parse_def(st, NominalType);\n-          return tcx.mk_fn(Some(def_id), tcx.mk_bare_fn(parse_bare_fn_ty(st)));\n-      }\n-      'G' => {\n-          return tcx.mk_fn(None, tcx.mk_bare_fn(parse_bare_fn_ty(st)));\n-      }\n-      '#' => {\n-        // This is a hacky little caching scheme. The idea is that if we encode\n-        // the same type twice, the second (and third, and fourth...) time we will\n-        // just write `#123`, where `123` is the offset in the metadata of the\n-        // first appearance. Now when we are *decoding*, if we see a `#123`, we\n-        // can first check a cache (`tcx.rcache`) for that offset. If we find something,\n-        // we return it (modulo closure types, see below). But if not, then we\n-        // jump to offset 123 and read the type from there.\n-\n-        let pos = parse_hex(st);\n-        assert_eq!(next(st), ':');\n-        let len = parse_hex(st);\n-        assert_eq!(next(st), '#');\n-        let key = ty::CReaderCacheKey {cnum: st.krate, pos: pos, len: len };\n-        match tcx.rcache.borrow().get(&key).cloned() {\n-          Some(tt) => {\n-            // If there is a closure buried in the type some where, then we\n-            // need to re-convert any def ids (see case 'k', below). That means\n-            // we can't reuse the cached version.\n-            if !tt.has_closure_types() {\n+    fn parse_ty(&mut self) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+        match self.next() {\n+            'b' => return tcx.types.bool,\n+            'i' => { /* eat the s of is */ self.next(); return tcx.types.isize },\n+            'u' => { /* eat the s of us */ self.next(); return tcx.types.usize },\n+            'M' => {\n+                match self.next() {\n+                    'b' => return tcx.types.u8,\n+                    'w' => return tcx.types.u16,\n+                    'l' => return tcx.types.u32,\n+                    'd' => return tcx.types.u64,\n+                    'B' => return tcx.types.i8,\n+                    'W' => return tcx.types.i16,\n+                    'L' => return tcx.types.i32,\n+                    'D' => return tcx.types.i64,\n+                    'f' => return tcx.types.f32,\n+                    'F' => return tcx.types.f64,\n+                    _ => panic!(\"parse_ty: bad numeric type\")\n+                }\n+            }\n+            'c' => return tcx.types.char,\n+            't' => {\n+                assert_eq!(self.next(), '[');\n+                let did = self.parse_def(NominalType);\n+                let substs = self.parse_substs();\n+                assert_eq!(self.next(), ']');\n+                let def = self.tcx.lookup_adt_def(did);\n+                return tcx.mk_enum(def, self.tcx.mk_substs(substs));\n+            }\n+            'x' => {\n+                assert_eq!(self.next(), '[');\n+                let trait_ref = ty::Binder(self.parse_trait_ref());\n+                let bounds = self.parse_existential_bounds();\n+                assert_eq!(self.next(), ']');\n+                return tcx.mk_trait(trait_ref, bounds);\n+            }\n+            'p' => {\n+                assert_eq!(self.next(), '[');\n+                let index = self.parse_u32();\n+                assert_eq!(self.next(), '|');\n+                let space = self.parse_param_space();\n+                assert_eq!(self.next(), '|');\n+                let name = token::intern(&self.parse_str(']'));\n+                return tcx.mk_param(space, index, name);\n+            }\n+            '~' => return tcx.mk_box(self.parse_ty()),\n+            '*' => return tcx.mk_ptr(self.parse_mt()),\n+            '&' => {\n+                let r = self.parse_region();\n+                let mt = self.parse_mt();\n+                return tcx.mk_ref(tcx.mk_region(r), mt);\n+            }\n+            'V' => {\n+                let t = self.parse_ty();\n+                return match self.parse_size() {\n+                    Some(n) => tcx.mk_array(t, n),\n+                    None => tcx.mk_slice(t)\n+                };\n+            }\n+            'v' => {\n+                return tcx.mk_str();\n+            }\n+            'T' => {\n+                assert_eq!(self.next(), '[');\n+                let mut params = Vec::new();\n+                while self.peek() != ']' { params.push(self.parse_ty()); }\n+                self.pos = self.pos + 1;\n+                return tcx.mk_tup(params);\n+            }\n+            'F' => {\n+                let def_id = self.parse_def(NominalType);\n+                return tcx.mk_fn(Some(def_id), tcx.mk_bare_fn(self.parse_bare_fn_ty()));\n+            }\n+            'G' => {\n+                return tcx.mk_fn(None, tcx.mk_bare_fn(self.parse_bare_fn_ty()));\n+            }\n+            '#' => {\n+                // This is a hacky little caching scheme. The idea is that if we encode\n+                // the same type twice, the second (and third, and fourth...) time we will\n+                // just write `#123`, where `123` is the offset in the metadata of the\n+                // first appearance. Now when we are *decoding*, if we see a `#123`, we\n+                // can first check a cache (`tcx.rcache`) for that offset. If we find something,\n+                // we return it (modulo closure types, see below). But if not, then we\n+                // jump to offset 123 and read the type from there.\n+\n+                let pos = self.parse_hex();\n+                assert_eq!(self.next(), ':');\n+                let len = self.parse_hex();\n+                assert_eq!(self.next(), '#');\n+                let key = ty::CReaderCacheKey {cnum: self.krate, pos: pos, len: len };\n+                match tcx.rcache.borrow().get(&key).cloned() {\n+                    Some(tt) => {\n+                        // If there is a closure buried in the type some where, then we\n+                        // need to re-convert any def ids (see case 'k', below). That means\n+                        // we can't reuse the cached version.\n+                        if !tt.has_closure_types() {\n+                            return tt;\n+                        }\n+                    }\n+                    None => {}\n+                }\n+\n+                let mut substate = PState::new(self.data,\n+                                               self.krate,\n+                                               pos,\n+                                               self.tcx,\n+                                               self.conv_def_id);\n+                let tt = substate.parse_ty();\n+                tcx.rcache.borrow_mut().insert(key, tt);\n                 return tt;\n             }\n-          }\n-          None => {}\n+            '\\\"' => {\n+                let _ = self.parse_def(TypeWithId);\n+                let inner = self.parse_ty();\n+                inner\n+            }\n+            'a' => {\n+                assert_eq!(self.next(), '[');\n+                let did = self.parse_def(NominalType);\n+                let substs = self.parse_substs();\n+                assert_eq!(self.next(), ']');\n+                let def = self.tcx.lookup_adt_def(did);\n+                return self.tcx.mk_struct(def, self.tcx.mk_substs(substs));\n+            }\n+            'k' => {\n+                assert_eq!(self.next(), '[');\n+                let did = self.parse_def(ClosureSource);\n+                let substs = self.parse_substs();\n+                let mut tys = vec![];\n+                while self.peek() != '.' {\n+                    tys.push(self.parse_ty());\n+                }\n+                assert_eq!(self.next(), '.');\n+                assert_eq!(self.next(), ']');\n+                return self.tcx.mk_closure(did, self.tcx.mk_substs(substs), tys);\n+            }\n+            'P' => {\n+                assert_eq!(self.next(), '[');\n+                let trait_ref = self.parse_trait_ref();\n+                let name = token::intern(&self.parse_str(']'));\n+                return tcx.mk_projection(trait_ref, name);\n+            }\n+            'e' => {\n+                return tcx.types.err;\n+            }\n+            c => { panic!(\"unexpected char in type string: {}\", c);}\n         }\n+    }\n \n-        let mut ps = PState {\n-            pos: pos,\n-            conv_def_id: st.conv_def_id, // -+ Have to call out these fields specifically,\n-            tcx: st.tcx,                 //  | rather than writing `..*st`, so that we\n-            data: st.data,               //  | trigger reborrow coercions. Suboptimal,\n-            krate: st.krate,             // -+ I suppose.\n+    fn parse_mutability(&mut self) -> ast::Mutability {\n+        match self.peek() {\n+            'm' => { self.next(); ast::MutMutable }\n+            _ => { ast::MutImmutable }\n+        }\n+    }\n+\n+    fn parse_mt(&mut self) -> ty::TypeAndMut<'tcx> {\n+        let m = self.parse_mutability();\n+        ty::TypeAndMut { ty: self.parse_ty(), mutbl: m }\n+    }\n+\n+    fn parse_def(&mut self, source: DefIdSource) -> ast::DefId {\n+        let def_id = parse_defid(self.scan(|c| c == '|'));\n+        return (self.conv_def_id)(source, def_id);\n+    }\n+\n+    fn parse_uint(&mut self) -> usize {\n+        let mut n = 0;\n+        loop {\n+            let cur = self.peek();\n+            if cur < '0' || cur > '9' { return n; }\n+            self.pos = self.pos + 1;\n+            n *= 10;\n+            n += (cur as usize) - ('0' as usize);\n         };\n+    }\n \n-        let tt = parse_ty(&mut ps);\n-        tcx.rcache.borrow_mut().insert(key, tt);\n-        return tt;\n-      }\n-      '\\\"' => {\n-        let _ = parse_def(st, TypeWithId);\n-        let inner = parse_ty(st);\n-        inner\n-      }\n-      'a' => {\n-          assert_eq!(next(st), '[');\n-          let did = parse_def(st, NominalType);\n-          let substs = parse_substs(st);\n-          assert_eq!(next(st), ']');\n-          let def = st.tcx.lookup_adt_def(did);\n-          return st.tcx.mk_struct(def, st.tcx.mk_substs(substs));\n-      }\n-      'k' => {\n-          assert_eq!(next(st), '[');\n-          let did = parse_def(st, ClosureSource);\n-          let substs = parse_substs(st);\n-          let mut tys = vec![];\n-          while peek(st) != '.' {\n-              tys.push(parse_ty(st));\n-          }\n-          assert_eq!(next(st), '.');\n-          assert_eq!(next(st), ']');\n-          return st.tcx.mk_closure(did, st.tcx.mk_substs(substs), tys);\n-      }\n-      'P' => {\n-          assert_eq!(next(st), '[');\n-          let trait_ref = parse_trait_ref(st);\n-          let name = token::intern(&parse_str(st, ']'));\n-          return tcx.mk_projection(trait_ref, name);\n-      }\n-      'e' => {\n-          return tcx.types.err;\n-      }\n-      c => { panic!(\"unexpected char in type string: {}\", c);}\n+    fn parse_u32(&mut self) -> u32 {\n+        let n = self.parse_uint();\n+        let m = n as u32;\n+        assert_eq!(m as usize, n);\n+        m\n     }\n-}\n \n-fn parse_mutability(st: &mut PState) -> ast::Mutability {\n-    match peek(st) {\n-      'm' => { next(st); ast::MutMutable }\n-      _ => { ast::MutImmutable }\n+    fn parse_param_space(&mut self) -> subst::ParamSpace {\n+        subst::ParamSpace::from_uint(self.parse_uint())\n     }\n-}\n \n-fn parse_mt<'a, 'tcx>(st: &mut PState<'a, 'tcx>) -> ty::TypeAndMut<'tcx> {\n-    let m = parse_mutability(st);\n-    ty::TypeAndMut { ty: parse_ty(st), mutbl: m }\n-}\n+    fn parse_hex(&mut self) -> usize {\n+        let mut n = 0;\n+        loop {\n+            let cur = self.peek();\n+            if (cur < '0' || cur > '9') && (cur < 'a' || cur > 'f') { return n; }\n+            self.pos = self.pos + 1;\n+            n *= 16;\n+            if '0' <= cur && cur <= '9' {\n+                n += (cur as usize) - ('0' as usize);\n+            } else { n += 10 + (cur as usize) - ('a' as usize); }\n+        };\n+    }\n \n-fn parse_def(st: &mut PState, source: DefIdSource) -> ast::DefId {\n-    let def_id = parse_defid(scan(st, |c| c == '|'));\n-    return (st.conv_def_id)(source, def_id);\n-}\n+    fn parse_abi_set(&mut self) -> abi::Abi {\n+        assert_eq!(self.next(), '[');\n+        let bytes = self.scan(|c| c == ']');\n+        let abi_str = str::from_utf8(bytes).unwrap();\n+        abi::lookup(&abi_str[..]).expect(abi_str)\n+    }\n \n-fn parse_uint(st: &mut PState) -> usize {\n-    let mut n = 0;\n-    loop {\n-        let cur = peek(st);\n-        if cur < '0' || cur > '9' { return n; }\n-        st.pos = st.pos + 1;\n-        n *= 10;\n-        n += (cur as usize) - ('0' as usize);\n-    };\n-}\n+    fn parse_closure_ty(&mut self) -> ty::ClosureTy<'tcx> {\n+        let unsafety = parse_unsafety(self.next());\n+        let sig = self.parse_sig();\n+        let abi = self.parse_abi_set();\n+        ty::ClosureTy {\n+            unsafety: unsafety,\n+            sig: sig,\n+            abi: abi,\n+        }\n+    }\n \n-fn parse_u32(st: &mut PState) -> u32 {\n-    let n = parse_uint(st);\n-    let m = n as u32;\n-    assert_eq!(m as usize, n);\n-    m\n-}\n+    fn parse_bare_fn_ty(&mut self) -> ty::BareFnTy<'tcx> {\n+        let unsafety = parse_unsafety(self.next());\n+        let abi = self.parse_abi_set();\n+        let sig = self.parse_sig();\n+        ty::BareFnTy {\n+            unsafety: unsafety,\n+            abi: abi,\n+            sig: sig\n+        }\n+    }\n \n-fn parse_param_space(st: &mut PState) -> subst::ParamSpace {\n-    subst::ParamSpace::from_uint(parse_uint(st))\n-}\n+    fn parse_sig(&mut self) -> ty::PolyFnSig<'tcx> {\n+        assert_eq!(self.next(), '[');\n+        let mut inputs = Vec::new();\n+        while self.peek() != ']' {\n+            inputs.push(self.parse_ty());\n+        }\n+        self.pos += 1; // eat the ']'\n+        let variadic = match self.next() {\n+            'V' => true,\n+            'N' => false,\n+            r => panic!(format!(\"bad variadic: {}\", r)),\n+        };\n+        let output = match self.peek() {\n+            'z' => {\n+                self.pos += 1;\n+                ty::FnDiverging\n+            }\n+            _ => ty::FnConverging(self.parse_ty())\n+        };\n+        ty::Binder(ty::FnSig {inputs: inputs,\n+                              output: output,\n+                              variadic: variadic})\n+    }\n \n-fn parse_hex(st: &mut PState) -> usize {\n-    let mut n = 0;\n-    loop {\n-        let cur = peek(st);\n-        if (cur < '0' || cur > '9') && (cur < 'a' || cur > 'f') { return n; }\n-        st.pos = st.pos + 1;\n-        n *= 16;\n-        if '0' <= cur && cur <= '9' {\n-            n += (cur as usize) - ('0' as usize);\n-        } else { n += 10 + (cur as usize) - ('a' as usize); }\n-    };\n-}\n+    pub fn parse_predicate(&mut self) -> ty::Predicate<'tcx> {\n+        match self.next() {\n+            't' => ty::Binder(self.parse_trait_ref()).to_predicate(),\n+            'e' => ty::Binder(ty::EquatePredicate(self.parse_ty(),\n+                                                  self.parse_ty())).to_predicate(),\n+            'r' => ty::Binder(ty::OutlivesPredicate(self.parse_region(),\n+                                                    self.parse_region())).to_predicate(),\n+            'o' => ty::Binder(ty::OutlivesPredicate(self.parse_ty(),\n+                                                    self.parse_region())).to_predicate(),\n+            'p' => ty::Binder(self.parse_projection_predicate()).to_predicate(),\n+            'w' => ty::Predicate::WellFormed(self.parse_ty()),\n+            'O' => {\n+                let def_id = self.parse_def(NominalType);\n+                assert_eq!(self.next(), '|');\n+                ty::Predicate::ObjectSafe(def_id)\n+            }\n+            c => panic!(\"Encountered invalid character in metadata: {}\", c)\n+        }\n+    }\n \n-fn parse_unsafety(c: char) -> ast::Unsafety {\n-    match c {\n-        'u' => ast::Unsafety::Unsafe,\n-        'n' => ast::Unsafety::Normal,\n-        _ => panic!(\"parse_unsafety: bad unsafety {}\", c)\n+    fn parse_projection_predicate(&mut self) -> ty::ProjectionPredicate<'tcx> {\n+        ty::ProjectionPredicate {\n+            projection_ty: ty::ProjectionTy {\n+                trait_ref: self.parse_trait_ref(),\n+                item_name: token::str_to_ident(&self.parse_str('|')).name,\n+            },\n+            ty: self.parse_ty(),\n+        }\n     }\n-}\n \n-fn parse_abi_set(st: &mut PState) -> abi::Abi {\n-    assert_eq!(next(st), '[');\n-    let bytes = scan(st, |c| c == ']');\n-    let abi_str = str::from_utf8(bytes).unwrap();\n-    abi::lookup(&abi_str[..]).expect(abi_str)\n-}\n+    fn parse_type_param_def(&mut self) -> ty::TypeParameterDef<'tcx> {\n+        let name = self.parse_name(':');\n+        let def_id = self.parse_def(NominalType);\n+        let space = self.parse_param_space();\n+        assert_eq!(self.next(), '|');\n+        let index = self.parse_u32();\n+        assert_eq!(self.next(), '|');\n+        let default_def_id = self.parse_def(NominalType);\n+        let default = self.parse_opt(|this| this.parse_ty());\n+        let object_lifetime_default = self.parse_object_lifetime_default();\n+\n+        ty::TypeParameterDef {\n+            name: name,\n+            def_id: def_id,\n+            space: space,\n+            index: index,\n+            default_def_id: default_def_id,\n+            default: default,\n+            object_lifetime_default: object_lifetime_default,\n+        }\n+    }\n+\n+    fn parse_object_lifetime_default(&mut self) -> ty::ObjectLifetimeDefault {\n+        match self.next() {\n+            'a' => ty::ObjectLifetimeDefault::Ambiguous,\n+            'b' => ty::ObjectLifetimeDefault::BaseDefault,\n+            's' => {\n+                let region = self.parse_region();\n+                ty::ObjectLifetimeDefault::Specific(region)\n+            }\n+            _ => panic!(\"parse_object_lifetime_default: bad input\")\n+        }\n+    }\n+\n+    fn parse_existential_bounds(&mut self) -> ty::ExistentialBounds<'tcx> {\n+        let builtin_bounds = self.parse_builtin_bounds();\n+        let region_bound = self.parse_region();\n+        let mut projection_bounds = Vec::new();\n+\n+        loop {\n+            match self.next() {\n+                'P' => {\n+                    projection_bounds.push(ty::Binder(self.parse_projection_predicate()));\n+                }\n+                '.' => { break; }\n+                c => {\n+                    panic!(\"parse_bounds: bad bounds ('{}')\", c)\n+                }\n+            }\n+        }\n \n-fn parse_closure_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>) -> ty::ClosureTy<'tcx> {\n-    let unsafety = parse_unsafety(next(st));\n-    let sig = parse_sig(st);\n-    let abi = parse_abi_set(st);\n-    ty::ClosureTy {\n-        unsafety: unsafety,\n-        sig: sig,\n-        abi: abi,\n+        return ty::ExistentialBounds { region_bound: region_bound,\n+                                       builtin_bounds: builtin_bounds,\n+                                       projection_bounds: projection_bounds };\n     }\n-}\n \n-fn parse_bare_fn_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>) -> ty::BareFnTy<'tcx> {\n-    let unsafety = parse_unsafety(next(st));\n-    let abi = parse_abi_set(st);\n-    let sig = parse_sig(st);\n-    ty::BareFnTy {\n-        unsafety: unsafety,\n-        abi: abi,\n-        sig: sig\n+    fn parse_builtin_bounds(&mut self) -> ty::BuiltinBounds {\n+        let mut builtin_bounds = ty::BuiltinBounds::empty();\n+        loop {\n+            match self.next() {\n+                'S' => {\n+                    builtin_bounds.insert(ty::BoundSend);\n+                }\n+                'Z' => {\n+                    builtin_bounds.insert(ty::BoundSized);\n+                }\n+                'P' => {\n+                    builtin_bounds.insert(ty::BoundCopy);\n+                }\n+                'T' => {\n+                    builtin_bounds.insert(ty::BoundSync);\n+                }\n+                '.' => {\n+                    return builtin_bounds;\n+                }\n+                c => {\n+                    panic!(\"parse_bounds: bad builtin bounds ('{}')\", c)\n+                }\n+            }\n+        }\n     }\n }\n \n-fn parse_sig<'a, 'tcx>(st: &mut PState<'a, 'tcx>) -> ty::PolyFnSig<'tcx> {\n-    assert_eq!(next(st), '[');\n-    let mut inputs = Vec::new();\n-    while peek(st) != ']' {\n-        inputs.push(parse_ty(st));\n-    }\n-    st.pos += 1; // eat the ']'\n-    let variadic = match next(st) {\n-        'V' => true,\n-        'N' => false,\n-        r => panic!(format!(\"bad variadic: {}\", r)),\n-    };\n-    let output = match peek(st) {\n-        'z' => {\n-          st.pos += 1;\n-          ty::FnDiverging\n+fn data_log_string(data: &[u8], pos: usize) -> String {\n+    let mut buf = String::new();\n+    buf.push_str(\"<<\");\n+    for i in pos..data.len() {\n+        let c = data[i];\n+        if c > 0x20 && c <= 0x7F {\n+            buf.push(c as char);\n+        } else {\n+            buf.push('.');\n         }\n-        _ => ty::FnConverging(parse_ty(st))\n-    };\n-    ty::Binder(ty::FnSig {inputs: inputs,\n-                          output: output,\n-                          variadic: variadic})\n+    }\n+    buf.push_str(\">>\");\n+    buf\n }\n \n // Rust metadata parsing\n@@ -678,149 +799,25 @@ pub fn parse_defid(buf: &[u8]) -> ast::DefId {\n     let crate_num = match str::from_utf8(crate_part).ok().and_then(|s| {\n         s.parse::<usize>().ok()\n     }) {\n-       Some(cn) => cn as ast::CrateNum,\n-       None => panic!(\"internal error: parse_defid: crate number expected, found {:?}\",\n-                     crate_part)\n+        Some(cn) => cn as ast::CrateNum,\n+        None => panic!(\"internal error: parse_defid: crate number expected, found {:?}\",\n+                       crate_part)\n     };\n     let def_num = match str::from_utf8(def_part).ok().and_then(|s| {\n         s.parse::<usize>().ok()\n     }) {\n-       Some(dn) => dn as ast::NodeId,\n-       None => panic!(\"internal error: parse_defid: id expected, found {:?}\",\n-                     def_part)\n+        Some(dn) => dn as ast::NodeId,\n+        None => panic!(\"internal error: parse_defid: id expected, found {:?}\",\n+                       def_part)\n     };\n     ast::DefId { krate: crate_num, node: def_num }\n }\n \n-pub fn parse_predicate_data<'tcx, F>(data: &[u8],\n-                                     start: usize,\n-                                     crate_num: ast::CrateNum,\n-                                     tcx: &ty::ctxt<'tcx>,\n-                                     mut conv: F)\n-                                     -> ty::Predicate<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    let mut st = parse_state_from_data(data, crate_num, start, tcx, &mut conv);\n-    parse_predicate(&mut st)\n-}\n-\n-pub fn parse_predicate<'a,'tcx>(st: &mut PState<'a, 'tcx>) -> ty::Predicate<'tcx> {\n-    match next(st) {\n-        't' => ty::Binder(parse_trait_ref(st)).to_predicate(),\n-        'e' => ty::Binder(ty::EquatePredicate(parse_ty(st),\n-                                              parse_ty(st))).to_predicate(),\n-        'r' => ty::Binder(ty::OutlivesPredicate(parse_region(st),\n-                                                parse_region(st))).to_predicate(),\n-        'o' => ty::Binder(ty::OutlivesPredicate(parse_ty(st),\n-                                                parse_region(st))).to_predicate(),\n-        'p' => ty::Binder(parse_projection_predicate(st)).to_predicate(),\n-        'w' => ty::Predicate::WellFormed(parse_ty(st)),\n-        'O' => {\n-            let def_id = parse_def(st, NominalType);\n-            assert_eq!(next(st), '|');\n-            ty::Predicate::ObjectSafe(def_id)\n-        }\n-        c => panic!(\"Encountered invalid character in metadata: {}\", c)\n-    }\n-}\n-\n-fn parse_projection_predicate<'a,'tcx>(st: &mut PState<'a, 'tcx>) -> ty::ProjectionPredicate<'tcx> {\n-    ty::ProjectionPredicate {\n-        projection_ty: ty::ProjectionTy {\n-            trait_ref: parse_trait_ref(st),\n-            item_name: token::str_to_ident(&parse_str(st, '|')).name,\n-        },\n-        ty: parse_ty(st),\n-    }\n-}\n-\n-pub fn parse_type_param_def_data<'tcx, F>(data: &[u8], start: usize,\n-                                          crate_num: ast::CrateNum, tcx: &ty::ctxt<'tcx>,\n-                                          mut conv: F) -> ty::TypeParameterDef<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    let mut st = parse_state_from_data(data, crate_num, start, tcx, &mut conv);\n-    parse_type_param_def(&mut st)\n-}\n-\n-fn parse_type_param_def<'a, 'tcx>(st: &mut PState<'a, 'tcx>) -> ty::TypeParameterDef<'tcx> {\n-    let name = parse_name(st, ':');\n-    let def_id = parse_def(st, NominalType);\n-    let space = parse_param_space(st);\n-    assert_eq!(next(st), '|');\n-    let index = parse_u32(st);\n-    assert_eq!(next(st), '|');\n-    let default_def_id = parse_def(st, NominalType);\n-    let default = parse_opt(st, |st| parse_ty(st));\n-    let object_lifetime_default = parse_object_lifetime_default(st);\n-\n-    ty::TypeParameterDef {\n-        name: name,\n-        def_id: def_id,\n-        space: space,\n-        index: index,\n-        default_def_id: default_def_id,\n-        default: default,\n-        object_lifetime_default: object_lifetime_default,\n-    }\n-}\n-\n-fn parse_object_lifetime_default<'a,'tcx>(st: &mut PState<'a,'tcx>) -> ty::ObjectLifetimeDefault {\n-    match next(st) {\n-        'a' => ty::ObjectLifetimeDefault::Ambiguous,\n-        'b' => ty::ObjectLifetimeDefault::BaseDefault,\n-        's' => {\n-            let region = parse_region(st);\n-            ty::ObjectLifetimeDefault::Specific(region)\n-        }\n-        _ => panic!(\"parse_object_lifetime_default: bad input\")\n-    }\n-}\n-\n-fn parse_existential_bounds<'a,'tcx>(st: &mut PState<'a,'tcx>) -> ty::ExistentialBounds<'tcx> {\n-    let builtin_bounds = parse_builtin_bounds(st);\n-    let region_bound = parse_region(st);\n-    let mut projection_bounds = Vec::new();\n-\n-    loop {\n-        match next(st) {\n-            'P' => {\n-                projection_bounds.push(ty::Binder(parse_projection_predicate(st)));\n-                }\n-            '.' => { break; }\n-            c => {\n-                panic!(\"parse_bounds: bad bounds ('{}')\", c)\n-            }\n-        }\n+fn parse_unsafety(c: char) -> ast::Unsafety {\n+    match c {\n+        'u' => ast::Unsafety::Unsafe,\n+        'n' => ast::Unsafety::Normal,\n+        _ => panic!(\"parse_unsafety: bad unsafety {}\", c)\n     }\n-\n-    return ty::ExistentialBounds { region_bound: region_bound,\n-                                   builtin_bounds: builtin_bounds,\n-                                   projection_bounds: projection_bounds };\n }\n \n-fn parse_builtin_bounds(st: &mut PState) -> ty::BuiltinBounds {\n-    let mut builtin_bounds = ty::BuiltinBounds::empty();\n-    loop {\n-        match next(st) {\n-            'S' => {\n-                builtin_bounds.insert(ty::BoundSend);\n-            }\n-            'Z' => {\n-                builtin_bounds.insert(ty::BoundSized);\n-            }\n-            'P' => {\n-                builtin_bounds.insert(ty::BoundCopy);\n-            }\n-            'T' => {\n-                builtin_bounds.insert(ty::BoundSync);\n-            }\n-            '.' => {\n-                return builtin_bounds;\n-            }\n-            c => {\n-                panic!(\"parse_bounds: bad builtin bounds ('{}')\", c)\n-            }\n-        }\n-    }\n-}"}]}