{"sha": "4b2d9e60f41c11238d60ee9ca319136f61e72ca1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiMmQ5ZTYwZjQxYzExMjM4ZDYwZWU5Y2EzMTkxMzZmNjFlNzJjYTE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-06-26T03:34:43Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-07-02T13:51:07Z"}, "message": "Remove `TypeckTables::empty(None)` and make hir_owner non-optional.", "tree": {"sha": "8d5ed6c917c281ba3ca4d5318bd2435c592331d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d5ed6c917c281ba3ca4d5318bd2435c592331d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b2d9e60f41c11238d60ee9ca319136f61e72ca1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b2d9e60f41c11238d60ee9ca319136f61e72ca1", "html_url": "https://github.com/rust-lang/rust/commit/4b2d9e60f41c11238d60ee9ca319136f61e72ca1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b2d9e60f41c11238d60ee9ca319136f61e72ca1/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "547be8c2494dc534229e6f37cd619219aaaf4f34", "url": "https://api.github.com/repos/rust-lang/rust/commits/547be8c2494dc534229e6f37cd619219aaaf4f34", "html_url": "https://github.com/rust-lang/rust/commit/547be8c2494dc534229e6f37cd619219aaaf4f34"}], "stats": {"total": 219, "additions": 98, "deletions": 121}, "files": [{"sha": "b1ea222370742e893f50a91a93d23d2c6947ef2d", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b2d9e60f41c11238d60ee9ca319136f61e72ca1/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b2d9e60f41c11238d60ee9ca319136f61e72ca1/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=4b2d9e60f41c11238d60ee9ca319136f61e72ca1", "patch": "@@ -1684,7 +1684,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // Attempt to obtain the span of the parameter so we can\n         // suggest adding an explicit lifetime bound to it.\n         let generics =\n-            self.in_progress_tables.and_then(|table| table.borrow().hir_owner).map(|table_owner| {\n+            self.in_progress_tables.map(|table| table.borrow().hir_owner).map(|table_owner| {\n                 let hir_id = hir.as_local_hir_id(table_owner);\n                 let parent_id = hir.get_parent_item(hir_id);\n                 ("}, {"sha": "27da514a17f4d8e3b8dd24c24101b52bf4ec95cd", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b2d9e60f41c11238d60ee9ca319136f61e72ca1/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b2d9e60f41c11238d60ee9ca319136f61e72ca1/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=4b2d9e60f41c11238d60ee9ca319136f61e72ca1", "patch": "@@ -588,7 +588,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     /// Used only by `rustc_typeck` during body type-checking/inference,\n     /// will initialize `in_progress_tables` with fresh `TypeckTables`.\n     pub fn with_fresh_in_progress_tables(mut self, table_owner: LocalDefId) -> Self {\n-        self.fresh_tables = Some(RefCell::new(ty::TypeckTables::empty(Some(table_owner))));\n+        self.fresh_tables = Some(RefCell::new(ty::TypeckTables::new(table_owner)));\n         self\n     }\n "}, {"sha": "10bb788c9e9a6aac6834328f3ab17d62e1c7b1c4", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 27, "deletions": 42, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/4b2d9e60f41c11238d60ee9ca319136f61e72ca1/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b2d9e60f41c11238d60ee9ca319136f61e72ca1/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=4b2d9e60f41c11238d60ee9ca319136f61e72ca1", "patch": "@@ -188,7 +188,7 @@ pub struct CommonConsts<'tcx> {\n }\n \n pub struct LocalTableInContext<'a, V> {\n-    hir_owner: Option<LocalDefId>,\n+    hir_owner: LocalDefId,\n     data: &'a ItemLocalMap<V>,\n }\n \n@@ -199,42 +199,27 @@ pub struct LocalTableInContext<'a, V> {\n /// would be in a different frame of reference and using its `local_id`\n /// would result in lookup errors, or worse, in silently wrong data being\n /// stored/returned.\n-fn validate_hir_id_for_typeck_tables(\n-    hir_owner: Option<LocalDefId>,\n-    hir_id: hir::HirId,\n-    mut_access: bool,\n-) {\n-    if let Some(hir_owner) = hir_owner {\n-        if hir_id.owner != hir_owner {\n-            ty::tls::with(|tcx| {\n-                bug!(\n-                    \"node {} with HirId::owner {:?} cannot be placed in TypeckTables with hir_owner {:?}\",\n-                    tcx.hir().node_to_string(hir_id),\n-                    hir_id.owner,\n-                    hir_owner\n-                )\n-            });\n-        }\n-    } else {\n-        // We use \"Null Object\" TypeckTables in some of the analysis passes.\n-        // These are just expected to be empty and their `hir_owner` is\n-        // `None`. Therefore we cannot verify whether a given `HirId` would\n-        // be a valid key for the given table. Instead we make sure that\n-        // nobody tries to write to such a Null Object table.\n-        if mut_access {\n-            bug!(\"access to invalid TypeckTables\")\n-        }\n+fn validate_hir_id_for_typeck_tables(hir_owner: LocalDefId, hir_id: hir::HirId) {\n+    if hir_id.owner != hir_owner {\n+        ty::tls::with(|tcx| {\n+            bug!(\n+                \"node {} with HirId::owner {:?} cannot be placed in TypeckTables with hir_owner {:?}\",\n+                tcx.hir().node_to_string(hir_id),\n+                hir_id.owner,\n+                hir_owner\n+            )\n+        });\n     }\n }\n \n impl<'a, V> LocalTableInContext<'a, V> {\n     pub fn contains_key(&self, id: hir::HirId) -> bool {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n         self.data.contains_key(&id.local_id)\n     }\n \n     pub fn get(&self, id: hir::HirId) -> Option<&V> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n         self.data.get(&id.local_id)\n     }\n \n@@ -252,28 +237,28 @@ impl<'a, V> ::std::ops::Index<hir::HirId> for LocalTableInContext<'a, V> {\n }\n \n pub struct LocalTableInContextMut<'a, V> {\n-    hir_owner: Option<LocalDefId>,\n+    hir_owner: LocalDefId,\n     data: &'a mut ItemLocalMap<V>,\n }\n \n impl<'a, V> LocalTableInContextMut<'a, V> {\n     pub fn get_mut(&mut self, id: hir::HirId) -> Option<&mut V> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id, true);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n         self.data.get_mut(&id.local_id)\n     }\n \n     pub fn entry(&mut self, id: hir::HirId) -> Entry<'_, hir::ItemLocalId, V> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id, true);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n         self.data.entry(id.local_id)\n     }\n \n     pub fn insert(&mut self, id: hir::HirId, val: V) -> Option<V> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id, true);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n         self.data.insert(id.local_id, val)\n     }\n \n     pub fn remove(&mut self, id: hir::HirId) -> Option<V> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id, true);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n         self.data.remove(&id.local_id)\n     }\n }\n@@ -324,7 +309,7 @@ pub struct GeneratorInteriorTypeCause<'tcx> {\n #[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct TypeckTables<'tcx> {\n     /// The `HirId::owner` all `ItemLocalId`s in this table are relative to.\n-    pub hir_owner: Option<LocalDefId>,\n+    pub hir_owner: LocalDefId,\n \n     /// Resolved definitions for `<T>::X` associated paths and\n     /// method calls, including those of overloaded operators.\n@@ -432,7 +417,7 @@ pub struct TypeckTables<'tcx> {\n }\n \n impl<'tcx> TypeckTables<'tcx> {\n-    pub fn empty(hir_owner: Option<LocalDefId>) -> TypeckTables<'tcx> {\n+    pub fn new(hir_owner: LocalDefId) -> TypeckTables<'tcx> {\n         TypeckTables {\n             hir_owner,\n             type_dependent_defs: Default::default(),\n@@ -474,7 +459,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn type_dependent_def(&self, id: HirId) -> Option<(DefKind, DefId)> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n         self.type_dependent_defs.get(&id.local_id).cloned().and_then(|r| r.ok())\n     }\n \n@@ -521,7 +506,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn node_type_opt(&self, id: hir::HirId) -> Option<Ty<'tcx>> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n         self.node_types.get(&id.local_id).cloned()\n     }\n \n@@ -530,12 +515,12 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn node_substs(&self, id: hir::HirId) -> SubstsRef<'tcx> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n         self.node_substs.get(&id.local_id).cloned().unwrap_or_else(|| InternalSubsts::empty())\n     }\n \n     pub fn node_substs_opt(&self, id: hir::HirId) -> Option<SubstsRef<'tcx>> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n         self.node_substs.get(&id.local_id).cloned()\n     }\n \n@@ -578,7 +563,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn expr_adjustments(&self, expr: &hir::Expr<'_>) -> &[ty::adjustment::Adjustment<'tcx>] {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, expr.hir_id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, expr.hir_id);\n         self.adjustments.get(&expr.hir_id.local_id).map_or(&[], |a| &a[..])\n     }\n \n@@ -657,7 +642,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn is_coercion_cast(&self, hir_id: hir::HirId) -> bool {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, hir_id, true);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, hir_id);\n         self.coercion_casts.contains(&hir_id.local_id)\n     }\n \n@@ -710,7 +695,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n             hash_stable_hashmap(hcx, hasher, upvar_capture_map, |up_var_id, hcx| {\n                 let ty::UpvarId { var_path, closure_expr_id } = *up_var_id;\n \n-                assert_eq!(Some(var_path.hir_id.owner), hir_owner);\n+                assert_eq!(var_path.hir_id.owner, hir_owner);\n \n                 (\n                     hcx.local_def_path_hash(var_path.hir_id.owner),"}, {"sha": "cdfe5f9f92db04e9d369cf3b28c2b0450a374a12", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b2d9e60f41c11238d60ee9ca319136f61e72ca1/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b2d9e60f41c11238d60ee9ca319136f61e72ca1/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=4b2d9e60f41c11238d60ee9ca319136f61e72ca1", "patch": "@@ -1407,7 +1407,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         );\n         let query_tables;\n         let tables: &TypeckTables<'tcx> = match &in_progress_tables {\n-            Some(t) if t.hir_owner.map(|owner| owner.to_def_id()) == Some(generator_did_root) => t,\n+            Some(t) if t.hir_owner.to_def_id() == generator_did_root => t,\n             _ => {\n                 query_tables = self.tcx.typeck_tables_of(generator_did.expect_local());\n                 &query_tables"}, {"sha": "fbf81e94d03d550eed8628fb4a1c393b6e5f93a1", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 62, "deletions": 65, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/4b2d9e60f41c11238d60ee9ca319136f61e72ca1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b2d9e60f41c11238d60ee9ca319136f61e72ca1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=4b2d9e60f41c11238d60ee9ca319136f61e72ca1", "patch": "@@ -1039,22 +1039,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let mut suggested = false;\n             if let (Some(ref param), Some(ref table)) = (param_type, self.in_progress_tables) {\n                 let table_owner = table.borrow().hir_owner;\n-                if let Some(table_owner) = table_owner {\n-                    let generics = self.tcx.generics_of(table_owner.to_def_id());\n-                    let type_param = generics.type_param(param, self.tcx);\n-                    let hir = &self.tcx.hir();\n-                    if let Some(def_id) = type_param.def_id.as_local() {\n-                        let id = hir.as_local_hir_id(def_id);\n-                        // Get the `hir::Param` to verify whether it already has any bounds.\n-                        // We do this to avoid suggesting code that ends up as `T: FooBar`,\n-                        // instead we suggest `T: Foo + Bar` in that case.\n-                        match hir.get(id) {\n-                            Node::GenericParam(ref param) => {\n-                                let mut impl_trait = false;\n-                                let has_bounds = if let hir::GenericParamKind::Type {\n-                                    synthetic: Some(_),\n-                                    ..\n-                                } = &param.kind\n+                let generics = self.tcx.generics_of(table_owner.to_def_id());\n+                let type_param = generics.type_param(param, self.tcx);\n+                let hir = &self.tcx.hir();\n+                if let Some(def_id) = type_param.def_id.as_local() {\n+                    let id = hir.as_local_hir_id(def_id);\n+                    // Get the `hir::Param` to verify whether it already has any bounds.\n+                    // We do this to avoid suggesting code that ends up as `T: FooBar`,\n+                    // instead we suggest `T: Foo + Bar` in that case.\n+                    match hir.get(id) {\n+                        Node::GenericParam(ref param) => {\n+                            let mut impl_trait = false;\n+                            let has_bounds =\n+                                if let hir::GenericParamKind::Type { synthetic: Some(_), .. } =\n+                                    &param.kind\n                                 {\n                                     // We've found `fn foo(x: impl Trait)` instead of\n                                     // `fn foo<T>(x: T)`. We want to suggest the correct\n@@ -1065,64 +1063,63 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 } else {\n                                     param.bounds.get(0)\n                                 };\n-                                let sp = hir.span(id);\n-                                let sp = if let Some(first_bound) = has_bounds {\n-                                    // `sp` only covers `T`, change it so that it covers\n-                                    // `T:` when appropriate\n-                                    sp.until(first_bound.span())\n-                                } else {\n-                                    sp\n-                                };\n-                                let trait_def_ids: FxHashSet<DefId> = param\n-                                    .bounds\n-                                    .iter()\n-                                    .filter_map(|bound| Some(bound.trait_ref()?.trait_def_id()?))\n-                                    .collect();\n-                                if !candidates.iter().any(|t| trait_def_ids.contains(&t.def_id)) {\n-                                    err.span_suggestions(\n-                                        sp,\n-                                        &message(format!(\n-                                            \"restrict type parameter `{}` with\",\n-                                            param.name.ident(),\n-                                        )),\n-                                        candidates.iter().map(|t| {\n-                                            format!(\n-                                                \"{}{} {}{}\",\n-                                                param.name.ident(),\n-                                                if impl_trait { \" +\" } else { \":\" },\n-                                                self.tcx.def_path_str(t.def_id),\n-                                                if has_bounds.is_some() { \" + \" } else { \"\" },\n-                                            )\n-                                        }),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                }\n-                                suggested = true;\n-                            }\n-                            Node::Item(hir::Item {\n-                                kind: hir::ItemKind::Trait(.., bounds, _),\n-                                ident,\n-                                ..\n-                            }) => {\n-                                let (sp, sep, article) = if bounds.is_empty() {\n-                                    (ident.span.shrink_to_hi(), \":\", \"a\")\n-                                } else {\n-                                    (bounds.last().unwrap().span().shrink_to_hi(), \" +\", \"another\")\n-                                };\n+                            let sp = hir.span(id);\n+                            let sp = if let Some(first_bound) = has_bounds {\n+                                // `sp` only covers `T`, change it so that it covers\n+                                // `T:` when appropriate\n+                                sp.until(first_bound.span())\n+                            } else {\n+                                sp\n+                            };\n+                            let trait_def_ids: FxHashSet<DefId> = param\n+                                .bounds\n+                                .iter()\n+                                .filter_map(|bound| Some(bound.trait_ref()?.trait_def_id()?))\n+                                .collect();\n+                            if !candidates.iter().any(|t| trait_def_ids.contains(&t.def_id)) {\n                                 err.span_suggestions(\n                                     sp,\n-                                    &message(format!(\"add {} supertrait for\", article)),\n+                                    &message(format!(\n+                                        \"restrict type parameter `{}` with\",\n+                                        param.name.ident(),\n+                                    )),\n                                     candidates.iter().map(|t| {\n-                                        format!(\"{} {}\", sep, self.tcx.def_path_str(t.def_id),)\n+                                        format!(\n+                                            \"{}{} {}{}\",\n+                                            param.name.ident(),\n+                                            if impl_trait { \" +\" } else { \":\" },\n+                                            self.tcx.def_path_str(t.def_id),\n+                                            if has_bounds.is_some() { \" + \" } else { \"\" },\n+                                        )\n                                     }),\n                                     Applicability::MaybeIncorrect,\n                                 );\n-                                suggested = true;\n                             }\n-                            _ => {}\n+                            suggested = true;\n+                        }\n+                        Node::Item(hir::Item {\n+                            kind: hir::ItemKind::Trait(.., bounds, _),\n+                            ident,\n+                            ..\n+                        }) => {\n+                            let (sp, sep, article) = if bounds.is_empty() {\n+                                (ident.span.shrink_to_hi(), \":\", \"a\")\n+                            } else {\n+                                (bounds.last().unwrap().span().shrink_to_hi(), \" +\", \"another\")\n+                            };\n+                            err.span_suggestions(\n+                                sp,\n+                                &message(format!(\"add {} supertrait for\", article)),\n+                                candidates.iter().map(|t| {\n+                                    format!(\"{} {}\", sep, self.tcx.def_path_str(t.def_id),)\n+                                }),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                            suggested = true;\n                         }\n+                        _ => {}\n                     }\n-                };\n+                }\n             }\n \n             if !suggested {"}, {"sha": "58fd0f989c67897a44c8633af120764b713742ce", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b2d9e60f41c11238d60ee9ca319136f61e72ca1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b2d9e60f41c11238d60ee9ca319136f61e72ca1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4b2d9e60f41c11238d60ee9ca319136f61e72ca1", "patch": "@@ -1126,7 +1126,7 @@ fn typeck_tables_of_with_fallback<'tcx>(\n \n     // Consistency check our TypeckTables instance can hold all ItemLocalIds\n     // it will need to hold.\n-    assert_eq!(tables.hir_owner, Some(id.owner));\n+    assert_eq!(tables.hir_owner, id.owner);\n \n     tables\n }"}, {"sha": "fa17696e02b3021a226a4b8d406ebf2bdbb8dddb", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4b2d9e60f41c11238d60ee9ca319136f61e72ca1/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b2d9e60f41c11238d60ee9ca319136f61e72ca1/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=4b2d9e60f41c11238d60ee9ca319136f61e72ca1", "patch": "@@ -109,12 +109,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     ) -> WritebackCx<'cx, 'tcx> {\n         let owner = body.id().hir_id.owner;\n \n-        WritebackCx {\n-            fcx,\n-            tables: ty::TypeckTables::empty(Some(owner)),\n-            body,\n-            rustc_dump_user_substs,\n-        }\n+        WritebackCx { fcx, tables: ty::TypeckTables::new(owner), body, rustc_dump_user_substs }\n     }\n \n     fn tcx(&self) -> TyCtxt<'tcx> {\n@@ -342,7 +337,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     fn visit_closures(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n         assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n-        let common_hir_owner = fcx_tables.hir_owner.unwrap();\n+        let common_hir_owner = fcx_tables.hir_owner;\n \n         for (&id, &origin) in fcx_tables.closure_kind_origins().iter() {\n             let hir_id = hir::HirId { owner: common_hir_owner, local_id: id };\n@@ -363,7 +358,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     fn visit_user_provided_tys(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n         assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n-        let common_hir_owner = fcx_tables.hir_owner.unwrap();\n+        let common_hir_owner = fcx_tables.hir_owner;\n \n         let mut errors_buffer = Vec::new();\n         for (&local_id, c_ty) in fcx_tables.user_provided_types().iter() {\n@@ -561,7 +556,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     fn visit_liberated_fn_sigs(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n         assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n-        let common_hir_owner = fcx_tables.hir_owner.unwrap();\n+        let common_hir_owner = fcx_tables.hir_owner;\n \n         for (&local_id, fn_sig) in fcx_tables.liberated_fn_sigs().iter() {\n             let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n@@ -573,7 +568,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     fn visit_fru_field_types(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n         assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n-        let common_hir_owner = fcx_tables.hir_owner.unwrap();\n+        let common_hir_owner = fcx_tables.hir_owner;\n \n         for (&local_id, ftys) in fcx_tables.fru_field_types().iter() {\n             let hir_id = hir::HirId { owner: common_hir_owner, local_id };"}]}