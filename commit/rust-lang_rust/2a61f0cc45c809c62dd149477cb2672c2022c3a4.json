{"sha": "2a61f0cc45c809c62dd149477cb2672c2022c3a4", "node_id": "C_kwDOAAsO6NoAKDJhNjFmMGNjNDVjODA5YzYyZGQxNDk0NzdjYjI2NzJjMjAyMmMzYTQ", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-05-30T21:18:03Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-05-30T21:23:15Z"}, "message": "address comments", "tree": {"sha": "f3b77c7854f0f5bf8cbc9de04f04d7b6646c15aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3b77c7854f0f5bf8cbc9de04f04d7b6646c15aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a61f0cc45c809c62dd149477cb2672c2022c3a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a61f0cc45c809c62dd149477cb2672c2022c3a4", "html_url": "https://github.com/rust-lang/rust/commit/2a61f0cc45c809c62dd149477cb2672c2022c3a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a61f0cc45c809c62dd149477cb2672c2022c3a4/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aeb765b299640ee0674d2c01df600c296af7d691", "url": "https://api.github.com/repos/rust-lang/rust/commits/aeb765b299640ee0674d2c01df600c296af7d691", "html_url": "https://github.com/rust-lang/rust/commit/aeb765b299640ee0674d2c01df600c296af7d691"}], "stats": {"total": 164, "additions": 109, "deletions": 55}, "files": [{"sha": "0e198907c8d5092ed1a44e476cb0494621353581", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 23, "deletions": 35, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2a61f0cc45c809c62dd149477cb2672c2022c3a4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a61f0cc45c809c62dd149477cb2672c2022c3a4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=2a61f0cc45c809c62dd149477cb2672c2022c3a4", "patch": "@@ -1375,22 +1375,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let matching_variants: Vec<_> = kind\n             .variants()\n             .iter()\n-            .filter_map(|variant| {\n+            .flat_map(|variant| {\n                 let [field] = &variant.fields[..] else { return None; };\n                 let field_ty = field.ty(tcx, substs);\n \n                 // Skip `_`, since that'll just lead to ambiguity.\n-                if matches!(self.resolve_vars_if_possible(field_ty).kind(), ty::Infer(_)) {\n+                if self.resolve_vars_if_possible(field_ty).is_ty_var() {\n                     return None;\n                 }\n \n-                if let Ok(pick) =\n-                    self.lookup_probe(span, item_name, field_ty, call_expr, ProbeScope::AllTraits)\n-                {\n-                    Some((variant, field, pick))\n-                } else {\n-                    None\n-                }\n+                self.lookup_probe(span, item_name, field_ty, call_expr, ProbeScope::AllTraits)\n+                    .ok()\n+                    .map(|pick| (variant, field, pick))\n             })\n             .collect();\n \n@@ -1409,45 +1405,37 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         match &matching_variants[..] {\n-            [(_, field, pick)] if Some(kind.did()) == tcx.get_diagnostic_item(sym::Result) => {\n+            [(_, field, pick)] => {\n                 let self_ty = field.ty(tcx, substs);\n                 err.span_note(\n                     tcx.def_span(pick.item.def_id),\n                     &format!(\"the method `{item_name}` exists on the type `{self_ty}`\"),\n                 );\n-                if ret_ty_matches(sym::Result) {\n-                    err.span_suggestion_verbose(\n-                        expr.span.shrink_to_hi(),\n-                        format!(\"use the `?` operator to extract the `{self_ty}` value, propagating a `Result::Err` value to the caller\"),\n-                        \"?\".to_owned(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                } else {\n-                    err.span_suggestion_verbose(\n-                        expr.span.shrink_to_hi(),\n-                        format!(\"consider using `Result::expect` to unwrap the `{self_ty}` value, panicking if the value is an `Err`\"),\n-                        \".expect(\\\"REASON\\\")\".to_owned(),\n-                        Applicability::HasPlaceholders,\n-                    );\n-                }\n-            }\n-            [(_, field, pick)] if Some(kind.did()) == tcx.get_diagnostic_item(sym::Option) => {\n-                let self_ty = field.ty(tcx, substs);\n-                err.span_note(\n-                    tcx.def_span(pick.item.def_id),\n-                    &format!(\"the method `{item_name}` exists on the type `{self_ty}`\"),\n-                );\n-                if ret_ty_matches(sym::Option) {\n+                let (article, kind, variant, question) =\n+                    if Some(kind.did()) == tcx.get_diagnostic_item(sym::Result) {\n+                        (\"a\", \"Result\", \"Err\", ret_ty_matches(sym::Result))\n+                    } else if Some(kind.did()) == tcx.get_diagnostic_item(sym::Option) {\n+                        (\"an\", \"Option\", \"None\", ret_ty_matches(sym::Option))\n+                    } else {\n+                        return;\n+                    };\n+                if question {\n                     err.span_suggestion_verbose(\n                         expr.span.shrink_to_hi(),\n-                        format!(\"use the `?` operator to extract the `{self_ty}` value, propagating a `None` to the caller\"),\n+                        format!(\n+                            \"use the `?` operator to extract the `{self_ty}` value, propagating \\\n+                            {article} `{kind}::{variant}` value to the caller\"\n+                        ),\n                         \"?\".to_owned(),\n                         Applicability::MachineApplicable,\n                     );\n                 } else {\n                     err.span_suggestion_verbose(\n                         expr.span.shrink_to_hi(),\n-                        format!(\"consider using `Option::expect` to unwrap the `{self_ty}` value, panicking if the value is `None`\"),\n+                        format!(\n+                            \"consider using `{kind}::expect` to unwrap the `{self_ty}` value, \\\n+                             panicking if the value is {article} `{kind}::{variant}`\"\n+                        ),\n                         \".expect(\\\"REASON\\\")\".to_owned(),\n                         Applicability::HasPlaceholders,\n                     );"}, {"sha": "6499c92bc6f1545baeacbf6c66e696d6ff560139", "filename": "src/test/ui/suggestions/enum-method-probe.fixed", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2a61f0cc45c809c62dd149477cb2672c2022c3a4/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2a61f0cc45c809c62dd149477cb2672c2022c3a4/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.fixed?ref=2a61f0cc45c809c62dd149477cb2672c2022c3a4", "patch": "@@ -1,4 +1,6 @@\n+// compile-flags: --edition=2021\n // run-rustfix\n+\n #![allow(unused)]\n \n struct Foo;\n@@ -17,11 +19,26 @@ fn test_result_in_result() -> Result<(), ()> {\n     Ok(())\n }\n \n-fn test_result_in_plain() {\n+async fn async_test_result_in_result() -> Result<(), ()> {\n+    let res: Result<_, ()> = Ok(Foo);\n+    res?.get();\n+    //~^ ERROR no method named `get` found for enum `Result` in the current scope\n+    //~| HELP use the `?` operator\n+    Ok(())\n+}\n+\n+fn test_result_in_unit_return() {\n+    let res: Result<_, ()> = Ok(Foo);\n+    res.expect(\"REASON\").get();\n+    //~^ ERROR no method named `get` found for enum `Result` in the current scope\n+    //~| HELP consider using `Result::expect` to unwrap the `Foo` value, panicking if the value is a `Result::Err`\n+}\n+\n+async fn async_test_result_in_unit_return() {\n     let res: Result<_, ()> = Ok(Foo);\n     res.expect(\"REASON\").get();\n     //~^ ERROR no method named `get` found for enum `Result` in the current scope\n-    //~| HELP consider using `Result::expect` to unwrap the `Foo` value, panicking if the value is an `Err`\n+    //~| HELP consider using `Result::expect` to unwrap the `Foo` value, panicking if the value is a `Result::Err`\n }\n \n fn test_option_in_option() -> Option<()> {\n@@ -32,11 +49,11 @@ fn test_option_in_option() -> Option<()> {\n     Some(())\n }\n \n-fn test_option_in_plain() {\n+fn test_option_in_unit_return() {\n     let res: Option<_> = Some(Foo);\n     res.expect(\"REASON\").get();\n     //~^ ERROR no method named `get` found for enum `Option` in the current scope\n-    //~| HELP consider using `Option::expect` to unwrap the `Foo` value, panicking if the value is `None`\n+    //~| HELP consider using `Option::expect` to unwrap the `Foo` value, panicking if the value is an `Option::None`\n }\n \n fn main() {}"}, {"sha": "18ea8ed8a58ffd055a155094ba4b7aed555ca786", "filename": "src/test/ui/suggestions/enum-method-probe.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2a61f0cc45c809c62dd149477cb2672c2022c3a4/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a61f0cc45c809c62dd149477cb2672c2022c3a4/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.rs?ref=2a61f0cc45c809c62dd149477cb2672c2022c3a4", "patch": "@@ -1,4 +1,6 @@\n+// compile-flags: --edition=2021\n // run-rustfix\n+\n #![allow(unused)]\n \n struct Foo;\n@@ -17,11 +19,26 @@ fn test_result_in_result() -> Result<(), ()> {\n     Ok(())\n }\n \n-fn test_result_in_plain() {\n+async fn async_test_result_in_result() -> Result<(), ()> {\n+    let res: Result<_, ()> = Ok(Foo);\n+    res.get();\n+    //~^ ERROR no method named `get` found for enum `Result` in the current scope\n+    //~| HELP use the `?` operator\n+    Ok(())\n+}\n+\n+fn test_result_in_unit_return() {\n+    let res: Result<_, ()> = Ok(Foo);\n+    res.get();\n+    //~^ ERROR no method named `get` found for enum `Result` in the current scope\n+    //~| HELP consider using `Result::expect` to unwrap the `Foo` value, panicking if the value is a `Result::Err`\n+}\n+\n+async fn async_test_result_in_unit_return() {\n     let res: Result<_, ()> = Ok(Foo);\n     res.get();\n     //~^ ERROR no method named `get` found for enum `Result` in the current scope\n-    //~| HELP consider using `Result::expect` to unwrap the `Foo` value, panicking if the value is an `Err`\n+    //~| HELP consider using `Result::expect` to unwrap the `Foo` value, panicking if the value is a `Result::Err`\n }\n \n fn test_option_in_option() -> Option<()> {\n@@ -32,11 +49,11 @@ fn test_option_in_option() -> Option<()> {\n     Some(())\n }\n \n-fn test_option_in_plain() {\n+fn test_option_in_unit_return() {\n     let res: Option<_> = Some(Foo);\n     res.get();\n     //~^ ERROR no method named `get` found for enum `Option` in the current scope\n-    //~| HELP consider using `Option::expect` to unwrap the `Foo` value, panicking if the value is `None`\n+    //~| HELP consider using `Option::expect` to unwrap the `Foo` value, panicking if the value is an `Option::None`\n }\n \n fn main() {}"}, {"sha": "6ed14984f47478928e27837200a7ba96a1ab406c", "filename": "src/test/ui/suggestions/enum-method-probe.stderr", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2a61f0cc45c809c62dd149477cb2672c2022c3a4/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a61f0cc45c809c62dd149477cb2672c2022c3a4/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.stderr?ref=2a61f0cc45c809c62dd149477cb2672c2022c3a4", "patch": "@@ -1,11 +1,11 @@\n error[E0599]: no method named `get` found for enum `Result` in the current scope\n-  --> $DIR/enum-method-probe.rs:14:9\n+  --> $DIR/enum-method-probe.rs:24:9\n    |\n LL |     res.get();\n    |         ^^^ method not found in `Result<Foo, ()>`\n    |\n note: the method `get` exists on the type `Foo`\n-  --> $DIR/enum-method-probe.rs:7:5\n+  --> $DIR/enum-method-probe.rs:9:5\n    |\n LL |     fn get(&self) -> u8 {\n    |     ^^^^^^^^^^^^^^^^^^^\n@@ -15,53 +15,85 @@ LL |     res?.get();\n    |        +\n \n error[E0599]: no method named `get` found for enum `Result` in the current scope\n-  --> $DIR/enum-method-probe.rs:22:9\n+  --> $DIR/enum-method-probe.rs:39:9\n    |\n LL |     res.get();\n    |         ^^^ method not found in `Result<Foo, ()>`\n    |\n note: the method `get` exists on the type `Foo`\n-  --> $DIR/enum-method-probe.rs:7:5\n+  --> $DIR/enum-method-probe.rs:9:5\n    |\n LL |     fn get(&self) -> u8 {\n    |     ^^^^^^^^^^^^^^^^^^^\n-help: consider using `Result::expect` to unwrap the `Foo` value, panicking if the value is an `Err`\n+help: consider using `Result::expect` to unwrap the `Foo` value, panicking if the value is a `Result::Err`\n+   |\n+LL |     res.expect(\"REASON\").get();\n+   |        +++++++++++++++++\n+\n+error[E0599]: no method named `get` found for enum `Result` in the current scope\n+  --> $DIR/enum-method-probe.rs:16:9\n+   |\n+LL |     res.get();\n+   |         ^^^ method not found in `Result<Foo, ()>`\n+   |\n+note: the method `get` exists on the type `Foo`\n+  --> $DIR/enum-method-probe.rs:9:5\n+   |\n+LL |     fn get(&self) -> u8 {\n+   |     ^^^^^^^^^^^^^^^^^^^\n+help: use the `?` operator to extract the `Foo` value, propagating a `Result::Err` value to the caller\n+   |\n+LL |     res?.get();\n+   |        +\n+\n+error[E0599]: no method named `get` found for enum `Result` in the current scope\n+  --> $DIR/enum-method-probe.rs:32:9\n+   |\n+LL |     res.get();\n+   |         ^^^ method not found in `Result<Foo, ()>`\n+   |\n+note: the method `get` exists on the type `Foo`\n+  --> $DIR/enum-method-probe.rs:9:5\n+   |\n+LL |     fn get(&self) -> u8 {\n+   |     ^^^^^^^^^^^^^^^^^^^\n+help: consider using `Result::expect` to unwrap the `Foo` value, panicking if the value is a `Result::Err`\n    |\n LL |     res.expect(\"REASON\").get();\n    |        +++++++++++++++++\n \n error[E0599]: no method named `get` found for enum `Option` in the current scope\n-  --> $DIR/enum-method-probe.rs:29:9\n+  --> $DIR/enum-method-probe.rs:46:9\n    |\n LL |     res.get();\n    |         ^^^ method not found in `Option<Foo>`\n    |\n note: the method `get` exists on the type `Foo`\n-  --> $DIR/enum-method-probe.rs:7:5\n+  --> $DIR/enum-method-probe.rs:9:5\n    |\n LL |     fn get(&self) -> u8 {\n    |     ^^^^^^^^^^^^^^^^^^^\n-help: use the `?` operator to extract the `Foo` value, propagating a `None` to the caller\n+help: use the `?` operator to extract the `Foo` value, propagating an `Option::None` value to the caller\n    |\n LL |     res?.get();\n    |        +\n \n error[E0599]: no method named `get` found for enum `Option` in the current scope\n-  --> $DIR/enum-method-probe.rs:37:9\n+  --> $DIR/enum-method-probe.rs:54:9\n    |\n LL |     res.get();\n    |         ^^^ method not found in `Option<Foo>`\n    |\n note: the method `get` exists on the type `Foo`\n-  --> $DIR/enum-method-probe.rs:7:5\n+  --> $DIR/enum-method-probe.rs:9:5\n    |\n LL |     fn get(&self) -> u8 {\n    |     ^^^^^^^^^^^^^^^^^^^\n-help: consider using `Option::expect` to unwrap the `Foo` value, panicking if the value is `None`\n+help: consider using `Option::expect` to unwrap the `Foo` value, panicking if the value is an `Option::None`\n    |\n LL |     res.expect(\"REASON\").get();\n    |        +++++++++++++++++\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0599`."}]}