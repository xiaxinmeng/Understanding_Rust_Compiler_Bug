{"sha": "1326aed02c3010444a6452aa998bbe7162822df0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzMjZhZWQwMmMzMDEwNDQ0YTY0NTJhYTk5OGJiZTcxNjI4MjJkZjA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-08-10T15:48:38Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-08-10T15:48:41Z"}, "message": "rustfmt\n\nExcept for error.rs, the result there looks rather ugly", "tree": {"sha": "c7d81bcee62354ae91f716d7aa61b1d7f6d9f995", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7d81bcee62354ae91f716d7aa61b1d7f6d9f995"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1326aed02c3010444a6452aa998bbe7162822df0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1326aed02c3010444a6452aa998bbe7162822df0", "html_url": "https://github.com/rust-lang/rust/commit/1326aed02c3010444a6452aa998bbe7162822df0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1326aed02c3010444a6452aa998bbe7162822df0/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "url": "https://api.github.com/repos/rust-lang/rust/commits/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "html_url": "https://github.com/rust-lang/rust/commit/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f"}], "stats": {"total": 3928, "additions": 2663, "deletions": 1265}, "files": [{"sha": "90b231a32bfb045b84e3d3537cdf02225f950f23", "filename": "benches/fibonacci.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/benches%2Ffibonacci.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/benches%2Ffibonacci.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Ffibonacci.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -7,9 +7,7 @@ use helpers::*;\n \n #[bench]\n fn fib(bencher: &mut Bencher) {\n-    bencher.iter(|| {\n-        fibonacci_helper::main();\n-    })\n+    bencher.iter(|| { fibonacci_helper::main(); })\n }\n \n #[bench]\n@@ -19,9 +17,7 @@ fn fib_miri(bencher: &mut Bencher) {\n \n #[bench]\n fn fib_iter(bencher: &mut Bencher) {\n-    bencher.iter(|| {\n-        fibonacci_helper_iterative::main();\n-    })\n+    bencher.iter(|| { fibonacci_helper_iterative::main(); })\n }\n \n #[bench]"}, {"sha": "586f1ce7da4d4a122003dc7f75c4275e46da0993", "filename": "benches/helpers/fibonacci_helper.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/benches%2Fhelpers%2Ffibonacci_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/benches%2Fhelpers%2Ffibonacci_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fhelpers%2Ffibonacci_helper.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -4,9 +4,5 @@ pub fn main() {\n }\n \n fn fib(n: usize) -> usize {\n-    if n <= 2 {\n-        1\n-    } else {\n-        fib(n - 1) + fib(n - 2)\n-    }\n+    if n <= 2 { 1 } else { fib(n - 1) + fib(n - 2) }\n }"}, {"sha": "6657ba119976583e8acb0a5a72b4a51422d43120", "filename": "benches/helpers/miri_helper.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/benches%2Fhelpers%2Fmiri_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/benches%2Fhelpers%2Fmiri_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fhelpers%2Fmiri_helper.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -19,9 +19,13 @@ fn find_sysroot() -> String {\n     let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\").or(option_env!(\"MULTIRUST_TOOLCHAIN\"));\n     match (home, toolchain) {\n         (Some(home), Some(toolchain)) => format!(\"{}/toolchains/{}\", home, toolchain),\n-        _ => option_env!(\"RUST_SYSROOT\")\n-            .expect(\"need to specify RUST_SYSROOT env var or use rustup or multirust\")\n-            .to_owned(),\n+        _ => {\n+            option_env!(\"RUST_SYSROOT\")\n+                .expect(\n+                    \"need to specify RUST_SYSROOT env var or use rustup or multirust\",\n+                )\n+                .to_owned()\n+        }\n     }\n }\n \n@@ -30,7 +34,7 @@ pub fn run(filename: &str, bencher: &mut Bencher) {\n         \"miri\".to_string(),\n         format!(\"benches/helpers/{}.rs\", filename),\n         \"--sysroot\".to_string(),\n-        find_sysroot()\n+        find_sysroot(),\n     ];\n     let compiler_calls = &mut MiriCompilerCalls(Rc::new(RefCell::new(bencher)));\n     rustc_driver::run_compiler(args, compiler_calls, None, None);\n@@ -40,7 +44,7 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls<'a> {\n     fn build_controller(\n         &mut self,\n         _: &Session,\n-        _: &getopts::Matches\n+        _: &getopts::Matches,\n     ) -> driver::CompileController<'a> {\n         let mut control: driver::CompileController<'a> = driver::CompileController::basic();\n \n@@ -51,14 +55,17 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls<'a> {\n             state.session.abort_if_errors();\n \n             let tcx = state.tcx.unwrap();\n-            let (entry_node_id, _) = state.session.entry_fn.borrow()\n-                .expect(\"no main or start function found\");\n+            let (entry_node_id, _) = state.session.entry_fn.borrow().expect(\n+                \"no main or start function found\",\n+            );\n             let entry_def_id = tcx.map.local_def_id(entry_node_id);\n \n-            let memory_size = 100*1024*1024; // 100MB\n+            let memory_size = 100 * 1024 * 1024; // 100MB\n             let step_limit = 1000_000;\n             let stack_limit = 100;\n-            bencher.borrow_mut().iter(|| { eval_main(tcx, entry_def_id, memory_size, step_limit, stack_limit); });\n+            bencher.borrow_mut().iter(|| {\n+                eval_main(tcx, entry_def_id, memory_size, step_limit, stack_limit);\n+            });\n \n             state.session.abort_if_errors();\n         });"}, {"sha": "e81db817aeace2cedf47574cf93b9f64c84bb0d3", "filename": "benches/helpers/smoke_helper.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/benches%2Fhelpers%2Fsmoke_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/benches%2Fhelpers%2Fsmoke_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fhelpers%2Fsmoke_helper.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -1,3 +1,2 @@\n #[inline(never)]\n-pub fn main() {\n-}\n+pub fn main() {}"}, {"sha": "1dbc4fed82f1c252df0a7fe0119e2065e0666be4", "filename": "benches/smoke.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/benches%2Fsmoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/benches%2Fsmoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fsmoke.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -7,9 +7,7 @@ use helpers::*;\n \n #[bench]\n fn noop(bencher: &mut Bencher) {\n-    bencher.iter(|| {\n-        smoke_helper::main();\n-    })\n+    bencher.iter(|| { smoke_helper::main(); })\n }\n \n /*"}, {"sha": "06d5b3e9971fe10499f35e9a88b865ec73feb2c4", "filename": "miri/bin/cargo-miri.rs", "status": "modified", "additions": 49, "deletions": 17, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/miri%2Fbin%2Fcargo-miri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/miri%2Fbin%2Fcargo-miri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fbin%2Fcargo-miri.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -50,43 +50,68 @@ fn main() {\n         let test = std::env::args().nth(2).map_or(false, |text| text == \"test\");\n         let skip = if test { 3 } else { 2 };\n \n-        let manifest_path_arg = std::env::args().skip(skip).find(|val| val.starts_with(\"--manifest-path=\"));\n-\n-        let mut metadata = if let Ok(metadata) = cargo_metadata::metadata(manifest_path_arg.as_ref().map(AsRef::as_ref)) {\n+        let manifest_path_arg = std::env::args().skip(skip).find(|val| {\n+            val.starts_with(\"--manifest-path=\")\n+        });\n+\n+        let mut metadata = if let Ok(metadata) = cargo_metadata::metadata(\n+            manifest_path_arg.as_ref().map(AsRef::as_ref),\n+        )\n+        {\n             metadata\n         } else {\n-            let _ = std::io::stderr().write_fmt(format_args!(\"error: Could not obtain cargo metadata.\"));\n+            let _ = std::io::stderr().write_fmt(format_args!(\n+                \"error: Could not obtain cargo metadata.\"\n+            ));\n             std::process::exit(101);\n         };\n \n-        let manifest_path = manifest_path_arg.map(|arg| PathBuf::from(Path::new(&arg[\"--manifest-path=\".len()..])));\n+        let manifest_path = manifest_path_arg.map(|arg| {\n+            PathBuf::from(Path::new(&arg[\"--manifest-path=\".len()..]))\n+        });\n \n         let current_dir = std::env::current_dir();\n \n-        let package_index = metadata.packages\n+        let package_index = metadata\n+            .packages\n             .iter()\n             .position(|package| {\n                 let package_manifest_path = Path::new(&package.manifest_path);\n                 if let Some(ref manifest_path) = manifest_path {\n                     package_manifest_path == manifest_path\n                 } else {\n-                    let current_dir = current_dir.as_ref().expect(\"could not read current directory\");\n-                    let package_manifest_directory = package_manifest_path.parent()\n-                        .expect(\"could not find parent directory of package manifest\");\n+                    let current_dir = current_dir.as_ref().expect(\n+                        \"could not read current directory\",\n+                    );\n+                    let package_manifest_directory = package_manifest_path.parent().expect(\n+                        \"could not find parent directory of package manifest\",\n+                    );\n                     package_manifest_directory == current_dir\n                 }\n             })\n             .expect(\"could not find matching package\");\n         let package = metadata.packages.remove(package_index);\n         for target in package.targets {\n             let args = std::env::args().skip(skip);\n-            let kind = target.kind.get(0).expect(\"badly formatted cargo metadata: target::kind is an empty array\");\n+            let kind = target.kind.get(0).expect(\n+                \"badly formatted cargo metadata: target::kind is an empty array\",\n+            );\n             if test && kind == \"test\" {\n-                if let Err(code) = process(vec![\"--test\".to_string(), target.name].into_iter().chain(args)) {\n+                if let Err(code) = process(\n+                    vec![\"--test\".to_string(), target.name].into_iter().chain(\n+                        args,\n+                    ),\n+                )\n+                {\n                     std::process::exit(code);\n                 }\n             } else if !test && kind == \"bin\" {\n-                if let Err(code) = process(vec![\"--bin\".to_string(), target.name].into_iter().chain(args)) {\n+                if let Err(code) = process(\n+                    vec![\"--bin\".to_string(), target.name].into_iter().chain(\n+                        args,\n+                    ),\n+                )\n+                {\n                     std::process::exit(code);\n                 }\n             }\n@@ -118,7 +143,11 @@ fn main() {\n         let mut args: Vec<String> = if std::env::args().any(|s| s == \"--sysroot\") {\n             std::env::args().skip(1).collect()\n         } else {\n-            std::env::args().skip(1).chain(Some(\"--sysroot\".to_owned())).chain(Some(sys_root)).collect()\n+            std::env::args()\n+                .skip(1)\n+                .chain(Some(\"--sysroot\".to_owned()))\n+                .chain(Some(sys_root))\n+                .collect()\n         };\n \n         // this check ensures that dependencies are built but not interpreted and the final crate is\n@@ -137,17 +166,20 @@ fn main() {\n         args.extend_from_slice(&[\"--cfg\".to_owned(), r#\"feature=\"cargo-miri\"\"#.to_owned()]);\n \n         match command.args(&args).status() {\n-            Ok(exit) => if !exit.success() {\n-                std::process::exit(exit.code().unwrap_or(42));\n-            },\n+            Ok(exit) => {\n+                if !exit.success() {\n+                    std::process::exit(exit.code().unwrap_or(42));\n+                }\n+            }\n             Err(ref e) if miri_enabled => panic!(\"error during miri run: {:?}\", e),\n             Err(ref e) => panic!(\"error during rustc call: {:?}\", e),\n         }\n     }\n }\n \n fn process<I>(old_args: I) -> Result<(), i32>\n-    where I: Iterator<Item = String>\n+where\n+    I: Iterator<Item = String>,\n {\n     let mut args = vec![\"rustc\".to_owned()];\n "}, {"sha": "29c47e355703f5616bc574d4841fecdde1a0c7b9", "filename": "miri/bin/miri.rs", "status": "modified", "additions": 72, "deletions": 20, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/miri%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/miri%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fbin%2Fmiri.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -16,7 +16,7 @@ use rustc_driver::driver::{CompileState, CompileController};\n use rustc::session::config::{self, Input, ErrorOutputType};\n use rustc::hir::{self, itemlikevisit};\n use rustc::ty::TyCtxt;\n-use syntax::ast::{MetaItemKind, NestedMetaItemKind, self};\n+use syntax::ast::{self, MetaItemKind, NestedMetaItemKind};\n use std::path::PathBuf;\n \n struct MiriCompilerCalls(RustcDefaultCalls);\n@@ -28,9 +28,15 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n         sopts: &config::Options,\n         cfg: &ast::CrateConfig,\n         descriptions: &rustc_errors::registry::Registry,\n-        output: ErrorOutputType\n+        output: ErrorOutputType,\n     ) -> Compilation {\n-        self.0.early_callback(matches, sopts, cfg, descriptions, output)\n+        self.0.early_callback(\n+            matches,\n+            sopts,\n+            cfg,\n+            descriptions,\n+            output,\n+        )\n     }\n     fn no_input(\n         &mut self,\n@@ -39,21 +45,32 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n         cfg: &ast::CrateConfig,\n         odir: &Option<PathBuf>,\n         ofile: &Option<PathBuf>,\n-        descriptions: &rustc_errors::registry::Registry\n+        descriptions: &rustc_errors::registry::Registry,\n     ) -> Option<(Input, Option<PathBuf>)> {\n-        self.0.no_input(matches, sopts, cfg, odir, ofile, descriptions)\n+        self.0.no_input(\n+            matches,\n+            sopts,\n+            cfg,\n+            odir,\n+            ofile,\n+            descriptions,\n+        )\n     }\n     fn late_callback(\n         &mut self,\n         matches: &getopts::Matches,\n         sess: &Session,\n         input: &Input,\n         odir: &Option<PathBuf>,\n-        ofile: &Option<PathBuf>\n+        ofile: &Option<PathBuf>,\n     ) -> Compilation {\n         self.0.late_callback(matches, sess, input, odir, ofile)\n     }\n-    fn build_controller(&mut self, sess: &Session, matches: &getopts::Matches) -> CompileController<'a> {\n+    fn build_controller(\n+        &mut self,\n+        sess: &Session,\n+        matches: &getopts::Matches,\n+    ) -> CompileController<'a> {\n         let mut control = self.0.build_controller(sess, matches);\n         control.after_hir_lowering.callback = Box::new(after_hir_lowering);\n         control.after_analysis.callback = Box::new(after_analysis);\n@@ -66,7 +83,10 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n }\n \n fn after_hir_lowering(state: &mut CompileState) {\n-    let attr = (String::from(\"miri\"), syntax::feature_gate::AttributeType::Whitelisted);\n+    let attr = (\n+        String::from(\"miri\"),\n+        syntax::feature_gate::AttributeType::Whitelisted,\n+    );\n     state.session.plugin_attributes.borrow_mut().push(attr);\n }\n \n@@ -77,13 +97,23 @@ fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n     let limits = resource_limits_from_attributes(state);\n \n     if std::env::args().any(|arg| arg == \"--test\") {\n-        struct Visitor<'a, 'tcx: 'a>(miri::ResourceLimits, TyCtxt<'a, 'tcx, 'tcx>, &'a CompileState<'a, 'tcx>);\n+        struct Visitor<'a, 'tcx: 'a>(\n+            miri::ResourceLimits,\n+            TyCtxt<'a, 'tcx, 'tcx>,\n+            &'a CompileState<'a, 'tcx>\n+        );\n         impl<'a, 'tcx: 'a, 'hir> itemlikevisit::ItemLikeVisitor<'hir> for Visitor<'a, 'tcx> {\n             fn visit_item(&mut self, i: &'hir hir::Item) {\n                 if let hir::Item_::ItemFn(_, _, _, _, _, body_id) = i.node {\n-                    if i.attrs.iter().any(|attr| attr.name().map_or(false, |n| n == \"test\")) {\n+                    if i.attrs.iter().any(|attr| {\n+                        attr.name().map_or(false, |n| n == \"test\")\n+                    })\n+                    {\n                         let did = self.1.hir.body_owner_def_id(body_id);\n-                        println!(\"running test: {}\", self.1.hir.def_path(did).to_string(self.1));\n+                        println!(\n+                            \"running test: {}\",\n+                            self.1.hir.def_path(did).to_string(self.1)\n+                        );\n                         miri::eval_main(self.1, did, None, self.0);\n                         self.2.session.abort_if_errors();\n                     }\n@@ -92,11 +122,18 @@ fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n             fn visit_trait_item(&mut self, _trait_item: &'hir hir::TraitItem) {}\n             fn visit_impl_item(&mut self, _impl_item: &'hir hir::ImplItem) {}\n         }\n-        state.hir_crate.unwrap().visit_all_item_likes(&mut Visitor(limits, tcx, state));\n+        state.hir_crate.unwrap().visit_all_item_likes(\n+            &mut Visitor(limits, tcx, state),\n+        );\n     } else if let Some((entry_node_id, _)) = *state.session.entry_fn.borrow() {\n         let entry_def_id = tcx.hir.local_def_id(entry_node_id);\n-        let start_wrapper = tcx.lang_items.start_fn().and_then(|start_fn|\n-                                if tcx.is_mir_available(start_fn) { Some(start_fn) } else { None });\n+        let start_wrapper = tcx.lang_items.start_fn().and_then(|start_fn| {\n+            if tcx.is_mir_available(start_fn) {\n+                Some(start_fn)\n+            } else {\n+                None\n+            }\n+        });\n         miri::eval_main(tcx, entry_def_id, start_wrapper, limits);\n \n         state.session.abort_if_errors();\n@@ -112,11 +149,19 @@ fn resource_limits_from_attributes(state: &CompileState) -> miri::ResourceLimits\n     let extract_int = |lit: &syntax::ast::Lit| -> u128 {\n         match lit.node {\n             syntax::ast::LitKind::Int(i, _) => i,\n-            _ => state.session.span_fatal(lit.span, \"expected an integer literal\"),\n+            _ => {\n+                state.session.span_fatal(\n+                    lit.span,\n+                    \"expected an integer literal\",\n+                )\n+            }\n         }\n     };\n \n-    for attr in krate.attrs.iter().filter(|a| a.name().map_or(false, |n| n == \"miri\")) {\n+    for attr in krate.attrs.iter().filter(|a| {\n+        a.name().map_or(false, |n| n == \"miri\")\n+    })\n+    {\n         if let Some(items) = attr.meta_item_list() {\n             for item in items {\n                 if let NestedMetaItemKind::MetaItem(ref inner) = item.node {\n@@ -165,7 +210,10 @@ fn init_logger() {\n     };\n \n     let mut builder = env_logger::LogBuilder::new();\n-    builder.format(format).filter(None, log::LogLevelFilter::Info);\n+    builder.format(format).filter(\n+        None,\n+        log::LogLevelFilter::Info,\n+    );\n \n     if std::env::var(\"MIRI_LOG\").is_ok() {\n         builder.parse(&std::env::var(\"MIRI_LOG\").unwrap());\n@@ -184,9 +232,13 @@ fn find_sysroot() -> String {\n     let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\").or(option_env!(\"MULTIRUST_TOOLCHAIN\"));\n     match (home, toolchain) {\n         (Some(home), Some(toolchain)) => format!(\"{}/toolchains/{}\", home, toolchain),\n-        _ => option_env!(\"RUST_SYSROOT\")\n-            .expect(\"need to specify RUST_SYSROOT env var or use rustup or multirust\")\n-            .to_owned(),\n+        _ => {\n+            option_env!(\"RUST_SYSROOT\")\n+                .expect(\n+                    \"need to specify RUST_SYSROOT env var or use rustup or multirust\",\n+                )\n+                .to_owned()\n+        }\n     }\n }\n "}, {"sha": "3467322768cc44119bea7dee8afbe3b9bbc606ae", "filename": "miri/fn_call.rs", "status": "modified", "additions": 136, "deletions": 45, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/miri%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/miri%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ffn_call.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -9,10 +9,7 @@ use std::mem;\n \n use rustc_miri::interpret::*;\n \n-use super::{\n-    TlsKey,\n-    EvalContext,\n-};\n+use super::{TlsKey, EvalContext};\n \n use tls::MemoryExt;\n \n@@ -62,13 +59,19 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n \n         let mir = match self.load_mir(instance.def) {\n             Ok(mir) => mir,\n-            Err(EvalError{ kind: EvalErrorKind::NoMirFor(path), ..} ) => {\n-                self.call_missing_fn(instance, destination, arg_operands, sig, path)?;\n+            Err(EvalError { kind: EvalErrorKind::NoMirFor(path), .. }) => {\n+                self.call_missing_fn(\n+                    instance,\n+                    destination,\n+                    arg_operands,\n+                    sig,\n+                    path,\n+                )?;\n                 return Ok(true);\n-            },\n+            }\n             Err(other) => return Err(other),\n         };\n-        \n+\n         let (return_lvalue, return_to_block) = match destination {\n             Some((lvalue, block)) => (lvalue, StackPopCleanup::Goto(block)),\n             None => (Lvalue::undef(), StackPopCleanup::None),\n@@ -99,7 +102,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             .unwrap_or(name)\n             .as_str();\n \n-        let args_res: EvalResult<Vec<Value>> = arg_operands.iter()\n+        let args_res: EvalResult<Vec<Value>> = arg_operands\n+            .iter()\n             .map(|arg| self.eval_operand(arg))\n             .collect();\n         let args = args_res?;\n@@ -121,7 +125,11 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             \"free\" => {\n                 let ptr = args[0].into_ptr(&mut self.memory)?;\n                 if !ptr.is_null()? {\n-                    self.memory.deallocate(ptr.to_ptr()?, None, MemoryKind::C.into())?;\n+                    self.memory.deallocate(\n+                        ptr.to_ptr()?,\n+                        None,\n+                        MemoryKind::C.into(),\n+                    )?;\n                 }\n             }\n \n@@ -132,9 +140,16 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 // libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)\n                 // is called if a `HashMap` is created the regular way.\n                 match self.value_to_primval(args[0], usize)?.to_u64()? {\n-                    318 |\n-                    511 => return err!(Unimplemented(\"miri does not support random number generators\".to_owned())),\n-                    id => return err!(Unimplemented(format!(\"miri does not support syscall id {}\", id))),\n+                    318 | 511 => {\n+                        return err!(Unimplemented(\n+                            \"miri does not support random number generators\".to_owned(),\n+                        ))\n+                    }\n+                    id => {\n+                        return err!(Unimplemented(\n+                            format!(\"miri does not support syscall id {}\", id),\n+                        ))\n+                    }\n                 }\n             }\n \n@@ -144,7 +159,10 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let symbol_name = self.memory.read_c_str(symbol)?;\n                 let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n                 let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n-                return err!(Unimplemented(format!(\"miri does not support dynamically loading libraries (requested symbol: {})\", symbol_name)));\n+                return err!(Unimplemented(format!(\n+                    \"miri does not support dynamically loading libraries (requested symbol: {})\",\n+                    symbol_name\n+                )));\n             }\n \n             \"__rust_maybe_catch_panic\" => {\n@@ -167,7 +185,12 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                     StackPopCleanup::Goto(dest_block),\n                 )?;\n \n-                let arg_local = self.frame().mir.args_iter().next().ok_or(EvalErrorKind::AbiViolation(\"Argument to __rust_maybe_catch_panic does not take enough arguments.\".to_owned()))?;\n+                let arg_local = self.frame().mir.args_iter().next().ok_or(\n+                    EvalErrorKind::AbiViolation(\n+                        \"Argument to __rust_maybe_catch_panic does not take enough arguments.\"\n+                            .to_owned(),\n+                    ),\n+                )?;\n                 let arg_dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n                 self.write_ptr(arg_dest, data, u8_ptr_ty)?;\n \n@@ -199,14 +222,21 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                     }\n                 };\n \n-                self.write_primval(dest, PrimVal::Bytes(result as u128), dest_ty)?;\n+                self.write_primval(\n+                    dest,\n+                    PrimVal::Bytes(result as u128),\n+                    dest_ty,\n+                )?;\n             }\n \n             \"memrchr\" => {\n                 let ptr = args[0].into_ptr(&mut self.memory)?;\n                 let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n-                if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(|&c| c == val) {\n+                if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(\n+                    |&c| c == val,\n+                )\n+                {\n                     let new_ptr = ptr.offset(num - idx as u64 - 1, &self)?;\n                     self.write_ptr(dest, new_ptr, dest_ty)?;\n                 } else {\n@@ -218,7 +248,10 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let ptr = args[0].into_ptr(&mut self.memory)?;\n                 let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n-                if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(|&c| c == val) {\n+                if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(\n+                    |&c| c == val,\n+                )\n+                {\n                     let new_ptr = ptr.offset(idx as u64, &self)?;\n                     self.write_ptr(dest, new_ptr, dest_ty)?;\n                 } else {\n@@ -274,11 +307,19 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 }\n                 if let Some((name, value)) = new {\n                     // +1 for the null terminator\n-                    let value_copy = self.memory.allocate((value.len() + 1) as u64, 1, MemoryKind::Env.into())?;\n+                    let value_copy = self.memory.allocate(\n+                        (value.len() + 1) as u64,\n+                        1,\n+                        MemoryKind::Env.into(),\n+                    )?;\n                     self.memory.write_bytes(value_copy.into(), &value)?;\n                     let trailing_zero_ptr = value_copy.offset(value.len() as u64, &self)?.into();\n                     self.memory.write_bytes(trailing_zero_ptr, &[0])?;\n-                    if let Some(var) = self.machine_data.env_vars.insert(name.to_owned(), value_copy) {\n+                    if let Some(var) = self.machine_data.env_vars.insert(\n+                        name.to_owned(),\n+                        value_copy,\n+                    )\n+                    {\n                         self.memory.deallocate(var, None, MemoryKind::Env.into())?;\n                     }\n                     self.write_null(dest, dest_ty)?;\n@@ -292,17 +333,29 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let buf = args[1].into_ptr(&mut self.memory)?;\n                 let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n-                let result = if fd == 1 || fd == 2 { // stdout/stderr\n+                let result = if fd == 1 || fd == 2 {\n+                    // stdout/stderr\n                     use std::io::{self, Write};\n-                \n+\n                     let buf_cont = self.memory.read_bytes(buf, n)?;\n-                    let res = if fd == 1 { io::stdout().write(buf_cont) } else { io::stderr().write(buf_cont) };\n-                    match res { Ok(n) => n as isize, Err(_) => -1 }\n+                    let res = if fd == 1 {\n+                        io::stdout().write(buf_cont)\n+                    } else {\n+                        io::stderr().write(buf_cont)\n+                    };\n+                    match res {\n+                        Ok(n) => n as isize,\n+                        Err(_) => -1,\n+                    }\n                 } else {\n                     info!(\"Ignored output to FD {}\", fd);\n                     n as isize // pretend it all went well\n                 }; // now result is the value we return back to the program\n-                self.write_primval(dest, PrimVal::Bytes(result as u128), dest_ty)?;\n+                self.write_primval(\n+                    dest,\n+                    PrimVal::Bytes(result as u128),\n+                    dest_ty,\n+                )?;\n             }\n \n             \"strlen\" => {\n@@ -328,7 +381,10 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let mut result = None;\n                 for &(path, path_value) in paths {\n                     if let Ok(instance) = self.resolve_path(path) {\n-                        let cid = GlobalId { instance, promoted: None };\n+                        let cid = GlobalId {\n+                            instance,\n+                            promoted: None,\n+                        };\n                         // compute global if not cached\n                         let val = match self.globals.get(&cid).cloned() {\n                             Some(ptr) => self.value_to_primval(Value::ByRef(ptr), c_int)?.to_u64()?,\n@@ -343,7 +399,9 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 if let Some(result) = result {\n                     self.write_primval(dest, result, dest_ty)?;\n                 } else {\n-                    return err!(Unimplemented(format!(\"Unimplemented sysconf name: {}\", name)));\n+                    return err!(Unimplemented(\n+                        format!(\"Unimplemented sysconf name: {}\", name),\n+                    ));\n                 }\n             }\n \n@@ -373,7 +431,11 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                     return err!(OutOfTls);\n                 }\n                 // TODO: Does this need checking for alignment?\n-                self.memory.write_uint(key_ptr.to_ptr()?, key, key_size.bytes())?;\n+                self.memory.write_uint(\n+                    key_ptr.to_ptr()?,\n+                    key,\n+                    key_size.bytes(),\n+                )?;\n \n                 // Return success (0)\n                 self.write_null(dest, dest_ty)?;\n@@ -396,7 +458,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n                 let new_ptr = args[1].into_ptr(&mut self.memory)?;\n                 self.memory.store_tls(key, new_ptr)?;\n-                \n+\n                 // Return success (0)\n                 self.write_null(dest, dest_ty)?;\n             }\n@@ -405,10 +467,12 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             link_name if link_name.starts_with(\"pthread_\") => {\n                 warn!(\"ignoring C ABI call: {}\", link_name);\n                 self.write_null(dest, dest_ty)?;\n-            },\n+            }\n \n             _ => {\n-                return err!(Unimplemented(format!(\"can't call C ABI function: {}\", link_name)));\n+                return err!(Unimplemented(\n+                    format!(\"can't call C ABI function: {}\", link_name),\n+                ));\n             }\n         }\n \n@@ -425,7 +489,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n         let cstore = &self.tcx.sess.cstore;\n \n         let crates = cstore.crates();\n-        crates.iter()\n+        crates\n+            .iter()\n             .find(|&&krate| cstore.crate_name(krate) == path[0])\n             .and_then(|krate| {\n                 let krate = DefId {\n@@ -450,9 +515,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 None\n             })\n             .ok_or_else(|| {\n-                let path = path.iter()\n-                    .map(|&s| s.to_owned())\n-                    .collect();\n+                let path = path.iter().map(|&s| s.to_owned()).collect();\n                 EvalErrorKind::PathNotFound(path).into()\n             })\n     }\n@@ -469,27 +532,36 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n         match &path[..] {\n             \"std::panicking::rust_panic_with_hook\" |\n             \"std::rt::begin_panic_fmt\" => return err!(Panic),\n-            _ => {},\n+            _ => {}\n         }\n \n         let dest_ty = sig.output();\n-        let (dest, dest_block) = destination.ok_or_else(|| EvalErrorKind::NoMirFor(path.clone()))?;\n+        let (dest, dest_block) = destination.ok_or_else(\n+            || EvalErrorKind::NoMirFor(path.clone()),\n+        )?;\n \n         if sig.abi == Abi::C {\n             // An external C function\n             // TODO: That functions actually has a similar preamble to what follows here.  May make sense to\n             // unify these two mechanisms for \"hooking into missing functions\".\n-            self.call_c_abi(instance.def_id(), arg_operands, dest, dest_ty, dest_block)?;\n+            self.call_c_abi(\n+                instance.def_id(),\n+                arg_operands,\n+                dest,\n+                dest_ty,\n+                dest_block,\n+            )?;\n             return Ok(());\n         }\n \n-        let args_res: EvalResult<Vec<Value>> = arg_operands.iter()\n+        let args_res: EvalResult<Vec<Value>> = arg_operands\n+            .iter()\n             .map(|arg| self.eval_operand(arg))\n             .collect();\n         let args = args_res?;\n \n         let usize = self.tcx.types.usize;\n-    \n+\n         match &path[..] {\n             // Allocators are magic.  They have no MIR, even when the rest of libstd does.\n             \"alloc::heap::::__rust_alloc\" => {\n@@ -527,7 +599,11 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                self.memory.deallocate(ptr, Some((old_size, align)), MemoryKind::Rust.into())?;\n+                self.memory.deallocate(\n+                    ptr,\n+                    Some((old_size, align)),\n+                    MemoryKind::Rust.into(),\n+                )?;\n             }\n             \"alloc::heap::::__rust_realloc\" => {\n                 let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n@@ -544,17 +620,32 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 if !new_align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(new_align));\n                 }\n-                let new_ptr = self.memory.reallocate(ptr, old_size, old_align, new_size, new_align, MemoryKind::Rust.into())?;\n+                let new_ptr = self.memory.reallocate(\n+                    ptr,\n+                    old_size,\n+                    old_align,\n+                    new_size,\n+                    new_align,\n+                    MemoryKind::Rust.into(),\n+                )?;\n                 self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n             }\n \n             // A Rust function is missing, which means we are running with MIR missing for libstd (or other dependencies).\n             // Still, we can make many things mostly work by \"emulating\" or ignoring some functions.\n             \"std::io::_print\" => {\n-                trace!(\"Ignoring output.  To run programs that print, make sure you have a libstd with full MIR.\");\n+                trace!(\n+                    \"Ignoring output.  To run programs that print, make sure you have a libstd with full MIR.\"\n+                );\n+            }\n+            \"std::thread::Builder::new\" => {\n+                return err!(Unimplemented(\"miri does not support threading\".to_owned()))\n+            }\n+            \"std::env::args\" => {\n+                return err!(Unimplemented(\n+                    \"miri does not support program arguments\".to_owned(),\n+                ))\n             }\n-            \"std::thread::Builder::new\" => return err!(Unimplemented(\"miri does not support threading\".to_owned())),\n-            \"std::env::args\" => return err!(Unimplemented(\"miri does not support program arguments\".to_owned())),\n             \"std::panicking::panicking\" |\n             \"std::rt::panicking\" => {\n                 // we abort on panic -> `std::rt::panicking` always returns false"}, {"sha": "809e5ebfacdb01dcbff976b5230d1a54cfee414c", "filename": "miri/helpers.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/miri%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/miri%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fhelpers.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -1,9 +1,4 @@\n-use rustc_miri::interpret::{\n-    Pointer,\n-    EvalResult,\n-    PrimVal,\n-    EvalContext,\n-};\n+use rustc_miri::interpret::{Pointer, EvalResult, PrimVal, EvalContext};\n \n use rustc::ty::Ty;\n \n@@ -31,7 +26,9 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n         offset: i64,\n     ) -> EvalResult<'tcx, Pointer> {\n         // FIXME: assuming here that type size is < i64::max_value()\n-        let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n+        let pointee_size = self.type_size(pointee_ty)?.expect(\n+            \"cannot offset a pointer to an unsized type\",\n+        ) as i64;\n         let offset = offset.overflowing_mul(pointee_size).0;\n         ptr.wrapping_signed_offset(offset, self)\n     }\n@@ -47,11 +44,18 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n         // We also consider the NULL pointer its own separate allocation, and all the remaining integers pointers their own\n         // allocation.\n \n-        if ptr.is_null()? { // NULL pointers must only be offset by 0\n-            return if offset == 0 { Ok(ptr) } else { err!(InvalidNullPointerUsage) };\n+        if ptr.is_null()? {\n+            // NULL pointers must only be offset by 0\n+            return if offset == 0 {\n+                Ok(ptr)\n+            } else {\n+                err!(InvalidNullPointerUsage)\n+            };\n         }\n         // FIXME: assuming here that type size is < i64::max_value()\n-        let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n+        let pointee_size = self.type_size(pointee_ty)?.expect(\n+            \"cannot offset a pointer to an unsized type\",\n+        ) as i64;\n         return if let Some(offset) = offset.checked_mul(pointee_size) {\n             let ptr = ptr.signed_offset(offset, self)?;\n             // Do not do bounds-checking for integers; they can never alias a normal pointer anyway.\n@@ -64,6 +68,6 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             Ok(ptr)\n         } else {\n             err!(OverflowingMath)\n-        }\n+        };\n     }\n }"}, {"sha": "83c65a427c08221a38bce2bf731f28cce5d4fcde", "filename": "miri/intrinsic.rs", "status": "modified", "additions": 255, "deletions": 106, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/miri%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/miri%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fintrinsic.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -3,13 +3,8 @@ use rustc::traits::Reveal;\n use rustc::ty::layout::Layout;\n use rustc::ty::{self, Ty};\n \n-use rustc_miri::interpret::{\n-    EvalResult,\n-    Lvalue, LvalueExtra,\n-    PrimVal, PrimValKind, Value, Pointer,\n-    HasMemory,\n-    EvalContext, PtrAndAlign,\n-};\n+use rustc_miri::interpret::{EvalResult, Lvalue, LvalueExtra, PrimVal, PrimValKind, Value, Pointer,\n+                            HasMemory, EvalContext, PtrAndAlign};\n \n use helpers::EvalContextExt as HelperEvalContextExt;\n \n@@ -35,9 +30,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n         dest_layout: &'tcx Layout,\n         target: mir::BasicBlock,\n     ) -> EvalResult<'tcx> {\n-        let arg_vals: EvalResult<Vec<Value>> = args.iter()\n-            .map(|arg| self.eval_operand(arg))\n-            .collect();\n+        let arg_vals: EvalResult<Vec<Value>> =\n+            args.iter().map(|arg| self.eval_operand(arg)).collect();\n         let arg_vals = arg_vals?;\n         let i32 = self.tcx.types.i32;\n         let isize = self.tcx.types.isize;\n@@ -48,15 +42,35 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n \n         let intrinsic_name = &self.tcx.item_name(instance.def_id()).as_str()[..];\n         match intrinsic_name {\n-            \"add_with_overflow\" =>\n-                self.intrinsic_with_overflow(mir::BinOp::Add, &args[0], &args[1], dest, dest_ty)?,\n-\n-            \"sub_with_overflow\" =>\n-                self.intrinsic_with_overflow(mir::BinOp::Sub, &args[0], &args[1], dest, dest_ty)?,\n-\n-            \"mul_with_overflow\" =>\n-                self.intrinsic_with_overflow(mir::BinOp::Mul, &args[0], &args[1], dest, dest_ty)?,\n-\n+            \"add_with_overflow\" => {\n+                self.intrinsic_with_overflow(\n+                    mir::BinOp::Add,\n+                    &args[0],\n+                    &args[1],\n+                    dest,\n+                    dest_ty,\n+                )?\n+            }\n+\n+            \"sub_with_overflow\" => {\n+                self.intrinsic_with_overflow(\n+                    mir::BinOp::Sub,\n+                    &args[0],\n+                    &args[1],\n+                    dest,\n+                    dest_ty,\n+                )?\n+            }\n+\n+            \"mul_with_overflow\" => {\n+                self.intrinsic_with_overflow(\n+                    mir::BinOp::Mul,\n+                    &args[0],\n+                    &args[1],\n+                    dest,\n+                    dest_ty,\n+                )?\n+            }\n \n             \"arith_offset\" => {\n                 let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()? as i64;\n@@ -68,7 +82,9 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             \"assume\" => {\n                 let bool = self.tcx.types.bool;\n                 let cond = self.value_to_primval(arg_vals[0], bool)?.to_bool()?;\n-                if !cond { return err!(AssumptionNotHeld); }\n+                if !cond {\n+                    return err!(AssumptionNotHeld);\n+                }\n             }\n \n             \"atomic_load\" |\n@@ -104,7 +120,11 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                     Value::ByValPair(..) => bug!(\"atomic_xchg doesn't work with nonprimitives\"),\n                 };\n                 self.write_primval(dest, old, ty)?;\n-                self.write_primval(Lvalue::from_primval_ptr(ptr), change, ty)?;\n+                self.write_primval(\n+                    Lvalue::from_primval_ptr(ptr),\n+                    change,\n+                    ty,\n+                )?;\n             }\n \n             _ if intrinsic_name.starts_with(\"atomic_cxchg\") => {\n@@ -121,22 +141,48 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let (val, _) = self.binary_op(mir::BinOp::Eq, old, ty, expect_old, ty)?;\n                 let dest = self.force_allocation(dest)?.to_ptr()?;\n                 self.write_pair_to_ptr(old, val, dest, dest_ty)?;\n-                self.write_primval(Lvalue::from_primval_ptr(ptr), change, ty)?;\n-            }\n-\n-            \"atomic_or\" | \"atomic_or_acq\" | \"atomic_or_rel\" | \"atomic_or_acqrel\" | \"atomic_or_relaxed\" |\n-            \"atomic_xor\" | \"atomic_xor_acq\" | \"atomic_xor_rel\" | \"atomic_xor_acqrel\" | \"atomic_xor_relaxed\" |\n-            \"atomic_and\" | \"atomic_and_acq\" | \"atomic_and_rel\" | \"atomic_and_acqrel\" | \"atomic_and_relaxed\" |\n-            \"atomic_xadd\" | \"atomic_xadd_acq\" | \"atomic_xadd_rel\" | \"atomic_xadd_acqrel\" | \"atomic_xadd_relaxed\" |\n-            \"atomic_xsub\" | \"atomic_xsub_acq\" | \"atomic_xsub_rel\" | \"atomic_xsub_acqrel\" | \"atomic_xsub_relaxed\" => {\n+                self.write_primval(\n+                    Lvalue::from_primval_ptr(ptr),\n+                    change,\n+                    ty,\n+                )?;\n+            }\n+\n+            \"atomic_or\" |\n+            \"atomic_or_acq\" |\n+            \"atomic_or_rel\" |\n+            \"atomic_or_acqrel\" |\n+            \"atomic_or_relaxed\" |\n+            \"atomic_xor\" |\n+            \"atomic_xor_acq\" |\n+            \"atomic_xor_rel\" |\n+            \"atomic_xor_acqrel\" |\n+            \"atomic_xor_relaxed\" |\n+            \"atomic_and\" |\n+            \"atomic_and_acq\" |\n+            \"atomic_and_rel\" |\n+            \"atomic_and_acqrel\" |\n+            \"atomic_and_relaxed\" |\n+            \"atomic_xadd\" |\n+            \"atomic_xadd_acq\" |\n+            \"atomic_xadd_rel\" |\n+            \"atomic_xadd_acqrel\" |\n+            \"atomic_xadd_relaxed\" |\n+            \"atomic_xsub\" |\n+            \"atomic_xsub_acq\" |\n+            \"atomic_xsub_rel\" |\n+            \"atomic_xsub_acqrel\" |\n+            \"atomic_xsub_relaxed\" => {\n                 let ty = substs.type_at(0);\n                 let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 let change = self.value_to_primval(arg_vals[1], ty)?;\n                 let old = self.read_value(ptr, ty)?;\n                 let old = match old {\n                     Value::ByVal(val) => val,\n                     Value::ByRef { .. } => bug!(\"just read the value, can't be byref\"),\n-                    Value::ByValPair(..) => bug!(\"atomic_xadd_relaxed doesn't work with nonprimitives\"),\n+                    Value::ByValPair(..) => {\n+                        bug!(\"atomic_xadd_relaxed doesn't work with nonprimitives\")\n+                    }\n                 };\n                 self.write_primval(dest, old, ty)?;\n                 let op = match intrinsic_name.split('_').nth(1).unwrap() {\n@@ -150,7 +196,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 // FIXME: what do atomics do on overflow?\n                 let (val, _) = self.binary_op(op, old, ty, change, ty)?;\n                 self.write_primval(Lvalue::from_primval_ptr(ptr), val, ty)?;\n-            },\n+            }\n \n             \"breakpoint\" => unimplemented!(), // halt miri\n \n@@ -165,22 +211,23 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                     let elem_align = self.type_align(elem_ty)?;\n                     let src = arg_vals[0].into_ptr(&self.memory)?;\n                     let dest = arg_vals[1].into_ptr(&self.memory)?;\n-                    self.memory.copy(src, dest, count * elem_size, elem_align, intrinsic_name.ends_with(\"_nonoverlapping\"))?;\n+                    self.memory.copy(\n+                        src,\n+                        dest,\n+                        count * elem_size,\n+                        elem_align,\n+                        intrinsic_name.ends_with(\"_nonoverlapping\"),\n+                    )?;\n                 }\n             }\n \n-            \"ctpop\" |\n-            \"cttz\" |\n-            \"cttz_nonzero\" |\n-            \"ctlz\" |\n-            \"ctlz_nonzero\" |\n-            \"bswap\" => {\n+            \"ctpop\" | \"cttz\" | \"cttz_nonzero\" | \"ctlz\" | \"ctlz_nonzero\" | \"bswap\" => {\n                 let ty = substs.type_at(0);\n                 let num = self.value_to_primval(arg_vals[0], ty)?.to_bytes()?;\n                 let kind = self.ty_to_primval_kind(ty)?;\n                 let num = if intrinsic_name.ends_with(\"_nonzero\") {\n                     if num == 0 {\n-                        return err!(Intrinsic(format!(\"{} called on 0\", intrinsic_name)))\n+                        return err!(Intrinsic(format!(\"{} called on 0\", intrinsic_name)));\n                     }\n                     numeric_intrinsic(intrinsic_name.trim_right_matches(\"_nonzero\"), num, kind)?\n                 } else {\n@@ -196,10 +243,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 self.write_primval(dest, PrimVal::Bytes(discr_val), dest_ty)?;\n             }\n \n-            \"sinf32\" | \"fabsf32\" | \"cosf32\" |\n-            \"sqrtf32\" | \"expf32\" | \"exp2f32\" |\n-            \"logf32\" | \"log10f32\" | \"log2f32\" |\n-            \"floorf32\" | \"ceilf32\" | \"truncf32\" => {\n+            \"sinf32\" | \"fabsf32\" | \"cosf32\" | \"sqrtf32\" | \"expf32\" | \"exp2f32\" | \"logf32\" |\n+            \"log10f32\" | \"log2f32\" | \"floorf32\" | \"ceilf32\" | \"truncf32\" => {\n                 let f = self.value_to_primval(arg_vals[0], f32)?.to_f32()?;\n                 let f = match intrinsic_name {\n                     \"sinf32\" => f.sin(),\n@@ -219,10 +264,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 self.write_primval(dest, PrimVal::from_f32(f), dest_ty)?;\n             }\n \n-            \"sinf64\" | \"fabsf64\" | \"cosf64\" |\n-            \"sqrtf64\" | \"expf64\" | \"exp2f64\" |\n-            \"logf64\" | \"log10f64\" | \"log2f64\" |\n-            \"floorf64\" | \"ceilf64\" | \"truncf64\" => {\n+            \"sinf64\" | \"fabsf64\" | \"cosf64\" | \"sqrtf64\" | \"expf64\" | \"exp2f64\" | \"logf64\" |\n+            \"log10f64\" | \"log2f64\" | \"floorf64\" | \"ceilf64\" | \"truncf64\" => {\n                 let f = self.value_to_primval(arg_vals[0], f64)?.to_f64()?;\n                 let f = match intrinsic_name {\n                     \"sinf64\" => f.sin(),\n@@ -258,9 +301,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 self.write_primval(dest, result.0, dest_ty)?;\n             }\n \n-            \"likely\" |\n-            \"unlikely\" |\n-            \"forget\" => {}\n+            \"likely\" | \"unlikely\" | \"forget\" => {}\n \n             \"init\" => {\n                 let size = self.type_size(dest_ty)?.expect(\"cannot zero unsized value\");\n@@ -270,27 +311,35 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                             // These writes have no alignment restriction anyway.\n                             this.memory.write_repeat(ptr, 0, size)?;\n                             val\n-                        },\n+                        }\n                         // TODO(solson): Revisit this, it's fishy to check for Undef here.\n-                        Value::ByVal(PrimVal::Undef) => match this.ty_to_primval_kind(dest_ty) {\n-                            Ok(_) => Value::ByVal(PrimVal::Bytes(0)),\n-                            Err(_) => {\n-                                let ptr = this.alloc_ptr_with_substs(dest_ty, substs)?;\n-                                let ptr = Pointer::from(PrimVal::Ptr(ptr));\n-                                this.memory.write_repeat(ptr, 0, size)?;\n-                                Value::by_ref(ptr)\n+                        Value::ByVal(PrimVal::Undef) => {\n+                            match this.ty_to_primval_kind(dest_ty) {\n+                                Ok(_) => Value::ByVal(PrimVal::Bytes(0)),\n+                                Err(_) => {\n+                                    let ptr = this.alloc_ptr_with_substs(dest_ty, substs)?;\n+                                    let ptr = Pointer::from(PrimVal::Ptr(ptr));\n+                                    this.memory.write_repeat(ptr, 0, size)?;\n+                                    Value::by_ref(ptr)\n+                                }\n                             }\n-                        },\n+                        }\n                         Value::ByVal(_) => Value::ByVal(PrimVal::Bytes(0)),\n-                        Value::ByValPair(..) =>\n-                            Value::ByValPair(PrimVal::Bytes(0), PrimVal::Bytes(0)),\n+                        Value::ByValPair(..) => {\n+                            Value::ByValPair(PrimVal::Bytes(0), PrimVal::Bytes(0))\n+                        }\n                     };\n                     Ok(zero_val)\n                 };\n                 match dest {\n                     Lvalue::Local { frame, local } => self.modify_local(frame, local, init)?,\n-                    Lvalue::Ptr { ptr: PtrAndAlign { ptr, aligned: true }, extra: LvalueExtra::None } => self.memory.write_repeat(ptr, 0, size)?,\n-                    Lvalue::Ptr { .. } => bug!(\"init intrinsic tried to write to fat or unaligned ptr target\"),\n+                    Lvalue::Ptr {\n+                        ptr: PtrAndAlign { ptr, aligned: true },\n+                        extra: LvalueExtra::None,\n+                    } => self.memory.write_repeat(ptr, 0, size)?,\n+                    Lvalue::Ptr { .. } => {\n+                        bug!(\"init intrinsic tried to write to fat or unaligned ptr target\")\n+                    }\n                 }\n             }\n \n@@ -319,7 +368,11 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let ty = substs.type_at(0);\n                 let env = ty::ParamEnv::empty(Reveal::All);\n                 let needs_drop = ty.needs_drop(self.tcx, env);\n-                self.write_primval(dest, PrimVal::from_bool(needs_drop), dest_ty)?;\n+                self.write_primval(\n+                    dest,\n+                    PrimVal::from_bool(needs_drop),\n+                    dest_ty,\n+                )?;\n             }\n \n             \"offset\" => {\n@@ -330,72 +383,124 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             }\n \n             \"overflowing_sub\" => {\n-                self.intrinsic_overflowing(mir::BinOp::Sub, &args[0], &args[1], dest, dest_ty)?;\n+                self.intrinsic_overflowing(\n+                    mir::BinOp::Sub,\n+                    &args[0],\n+                    &args[1],\n+                    dest,\n+                    dest_ty,\n+                )?;\n             }\n \n             \"overflowing_mul\" => {\n-                self.intrinsic_overflowing(mir::BinOp::Mul, &args[0], &args[1], dest, dest_ty)?;\n+                self.intrinsic_overflowing(\n+                    mir::BinOp::Mul,\n+                    &args[0],\n+                    &args[1],\n+                    dest,\n+                    dest_ty,\n+                )?;\n             }\n \n             \"overflowing_add\" => {\n-                self.intrinsic_overflowing(mir::BinOp::Add, &args[0], &args[1], dest, dest_ty)?;\n+                self.intrinsic_overflowing(\n+                    mir::BinOp::Add,\n+                    &args[0],\n+                    &args[1],\n+                    dest,\n+                    dest_ty,\n+                )?;\n             }\n \n             \"powf32\" => {\n                 let f = self.value_to_primval(arg_vals[0], f32)?.to_f32()?;\n                 let f2 = self.value_to_primval(arg_vals[1], f32)?.to_f32()?;\n-                self.write_primval(dest, PrimVal::from_f32(f.powf(f2)), dest_ty)?;\n+                self.write_primval(\n+                    dest,\n+                    PrimVal::from_f32(f.powf(f2)),\n+                    dest_ty,\n+                )?;\n             }\n \n             \"powf64\" => {\n                 let f = self.value_to_primval(arg_vals[0], f64)?.to_f64()?;\n                 let f2 = self.value_to_primval(arg_vals[1], f64)?.to_f64()?;\n-                self.write_primval(dest, PrimVal::from_f64(f.powf(f2)), dest_ty)?;\n+                self.write_primval(\n+                    dest,\n+                    PrimVal::from_f64(f.powf(f2)),\n+                    dest_ty,\n+                )?;\n             }\n \n             \"fmaf32\" => {\n                 let a = self.value_to_primval(arg_vals[0], f32)?.to_f32()?;\n                 let b = self.value_to_primval(arg_vals[1], f32)?.to_f32()?;\n                 let c = self.value_to_primval(arg_vals[2], f32)?.to_f32()?;\n-                self.write_primval(dest, PrimVal::from_f32(a * b + c), dest_ty)?;\n+                self.write_primval(\n+                    dest,\n+                    PrimVal::from_f32(a * b + c),\n+                    dest_ty,\n+                )?;\n             }\n \n             \"fmaf64\" => {\n                 let a = self.value_to_primval(arg_vals[0], f64)?.to_f64()?;\n                 let b = self.value_to_primval(arg_vals[1], f64)?.to_f64()?;\n                 let c = self.value_to_primval(arg_vals[2], f64)?.to_f64()?;\n-                self.write_primval(dest, PrimVal::from_f64(a * b + c), dest_ty)?;\n+                self.write_primval(\n+                    dest,\n+                    PrimVal::from_f64(a * b + c),\n+                    dest_ty,\n+                )?;\n             }\n \n             \"powif32\" => {\n                 let f = self.value_to_primval(arg_vals[0], f32)?.to_f32()?;\n                 let i = self.value_to_primval(arg_vals[1], i32)?.to_i128()?;\n-                self.write_primval(dest, PrimVal::from_f32(f.powi(i as i32)), dest_ty)?;\n+                self.write_primval(\n+                    dest,\n+                    PrimVal::from_f32(f.powi(i as i32)),\n+                    dest_ty,\n+                )?;\n             }\n \n             \"powif64\" => {\n                 let f = self.value_to_primval(arg_vals[0], f64)?.to_f64()?;\n                 let i = self.value_to_primval(arg_vals[1], i32)?.to_i128()?;\n-                self.write_primval(dest, PrimVal::from_f64(f.powi(i as i32)), dest_ty)?;\n+                self.write_primval(\n+                    dest,\n+                    PrimVal::from_f64(f.powi(i as i32)),\n+                    dest_ty,\n+                )?;\n             }\n \n             \"size_of\" => {\n                 let ty = substs.type_at(0);\n-                let size = self.type_size(ty)?.expect(\"size_of intrinsic called on unsized value\") as u128;\n+                let size = self.type_size(ty)?.expect(\n+                    \"size_of intrinsic called on unsized value\",\n+                ) as u128;\n                 self.write_primval(dest, PrimVal::from_u128(size), dest_ty)?;\n             }\n \n             \"size_of_val\" => {\n                 let ty = substs.type_at(0);\n                 let (size, _) = self.size_and_align_of_dst(ty, arg_vals[0])?;\n-                self.write_primval(dest, PrimVal::from_u128(size as u128), dest_ty)?;\n+                self.write_primval(\n+                    dest,\n+                    PrimVal::from_u128(size as u128),\n+                    dest_ty,\n+                )?;\n             }\n \n             \"min_align_of_val\" |\n             \"align_of_val\" => {\n                 let ty = substs.type_at(0);\n                 let (_, align) = self.size_and_align_of_dst(ty, arg_vals[0])?;\n-                self.write_primval(dest, PrimVal::from_u128(align as u128), dest_ty)?;\n+                self.write_primval(\n+                    dest,\n+                    PrimVal::from_u128(align as u128),\n+                    dest_ty,\n+                )?;\n             }\n \n             \"type_name\" => {\n@@ -413,61 +518,103 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             \"transmute\" => {\n                 let src_ty = substs.type_at(0);\n                 let ptr = self.force_allocation(dest)?.to_ptr()?;\n-                self.write_maybe_aligned_mut(/*aligned*/false, |ectx| {\n-                    ectx.write_value_to_ptr(arg_vals[0], ptr.into(), src_ty)\n-                })?;\n+                self.write_maybe_aligned_mut(\n+                    /*aligned*/\n+                    false,\n+                    |ectx| {\n+                        ectx.write_value_to_ptr(arg_vals[0], ptr.into(), src_ty)\n+                    },\n+                )?;\n             }\n \n             \"unchecked_shl\" => {\n-                let bits = self.type_size(dest_ty)?.expect(\"intrinsic can't be called on unsized type\") as u128 * 8;\n-                let rhs = self.value_to_primval(arg_vals[1], substs.type_at(0))?.to_bytes()?;\n+                let bits = self.type_size(dest_ty)?.expect(\n+                    \"intrinsic can't be called on unsized type\",\n+                ) as u128 * 8;\n+                let rhs = self.value_to_primval(arg_vals[1], substs.type_at(0))?\n+                    .to_bytes()?;\n                 if rhs >= bits {\n-                    return err!(Intrinsic(format!(\"Overflowing shift by {} in unchecked_shl\", rhs)));\n+                    return err!(Intrinsic(\n+                        format!(\"Overflowing shift by {} in unchecked_shl\", rhs),\n+                    ));\n                 }\n-                self.intrinsic_overflowing(mir::BinOp::Shl, &args[0], &args[1], dest, dest_ty)?;\n+                self.intrinsic_overflowing(\n+                    mir::BinOp::Shl,\n+                    &args[0],\n+                    &args[1],\n+                    dest,\n+                    dest_ty,\n+                )?;\n             }\n \n             \"unchecked_shr\" => {\n-                let bits = self.type_size(dest_ty)?.expect(\"intrinsic can't be called on unsized type\") as u128 * 8;\n-                let rhs = self.value_to_primval(arg_vals[1], substs.type_at(0))?.to_bytes()?;\n+                let bits = self.type_size(dest_ty)?.expect(\n+                    \"intrinsic can't be called on unsized type\",\n+                ) as u128 * 8;\n+                let rhs = self.value_to_primval(arg_vals[1], substs.type_at(0))?\n+                    .to_bytes()?;\n                 if rhs >= bits {\n-                    return err!(Intrinsic(format!(\"Overflowing shift by {} in unchecked_shr\", rhs)));\n+                    return err!(Intrinsic(\n+                        format!(\"Overflowing shift by {} in unchecked_shr\", rhs),\n+                    ));\n                 }\n-                self.intrinsic_overflowing(mir::BinOp::Shr, &args[0], &args[1], dest, dest_ty)?;\n+                self.intrinsic_overflowing(\n+                    mir::BinOp::Shr,\n+                    &args[0],\n+                    &args[1],\n+                    dest,\n+                    dest_ty,\n+                )?;\n             }\n \n             \"unchecked_div\" => {\n-                let rhs = self.value_to_primval(arg_vals[1], substs.type_at(0))?.to_bytes()?;\n+                let rhs = self.value_to_primval(arg_vals[1], substs.type_at(0))?\n+                    .to_bytes()?;\n                 if rhs == 0 {\n                     return err!(Intrinsic(format!(\"Division by 0 in unchecked_div\")));\n                 }\n-                self.intrinsic_overflowing(mir::BinOp::Div, &args[0], &args[1], dest, dest_ty)?;\n+                self.intrinsic_overflowing(\n+                    mir::BinOp::Div,\n+                    &args[0],\n+                    &args[1],\n+                    dest,\n+                    dest_ty,\n+                )?;\n             }\n \n             \"unchecked_rem\" => {\n-                let rhs = self.value_to_primval(arg_vals[1], substs.type_at(0))?.to_bytes()?;\n+                let rhs = self.value_to_primval(arg_vals[1], substs.type_at(0))?\n+                    .to_bytes()?;\n                 if rhs == 0 {\n                     return err!(Intrinsic(format!(\"Division by 0 in unchecked_rem\")));\n                 }\n-                self.intrinsic_overflowing(mir::BinOp::Rem, &args[0], &args[1], dest, dest_ty)?;\n+                self.intrinsic_overflowing(\n+                    mir::BinOp::Rem,\n+                    &args[0],\n+                    &args[1],\n+                    dest,\n+                    dest_ty,\n+                )?;\n             }\n \n             \"uninit\" => {\n                 let size = dest_layout.size(&self.tcx.data_layout).bytes();\n-                let uninit = |this: &mut Self, val: Value| {\n-                    match val {\n-                        Value::ByRef(PtrAndAlign { ptr, .. }) => {\n-                            this.memory.mark_definedness(ptr, size, false)?;\n-                            Ok(val)\n-                        },\n-                        _ => Ok(Value::ByVal(PrimVal::Undef)),\n+                let uninit = |this: &mut Self, val: Value| match val {\n+                    Value::ByRef(PtrAndAlign { ptr, .. }) => {\n+                        this.memory.mark_definedness(ptr, size, false)?;\n+                        Ok(val)\n                     }\n+                    _ => Ok(Value::ByVal(PrimVal::Undef)),\n                 };\n                 match dest {\n                     Lvalue::Local { frame, local } => self.modify_local(frame, local, uninit)?,\n-                    Lvalue::Ptr { ptr: PtrAndAlign { ptr, aligned: true }, extra: LvalueExtra::None } =>\n-                        self.memory.mark_definedness(ptr, size, false)?,\n-                    Lvalue::Ptr { .. } => bug!(\"uninit intrinsic tried to write to fat or unaligned ptr target\"),\n+                    Lvalue::Ptr {\n+                        ptr: PtrAndAlign { ptr, aligned: true },\n+                        extra: LvalueExtra::None,\n+                    } => self.memory.mark_definedness(ptr, size, false)?,\n+                    Lvalue::Ptr { .. } => {\n+                        bug!(\"uninit intrinsic tried to write to fat or unaligned ptr target\")\n+                    }\n                 }\n             }\n \n@@ -476,7 +623,9 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let ty = substs.type_at(0);\n                 let ty_align = self.type_align(ty)?;\n                 let val_byte = self.value_to_primval(arg_vals[1], u8)?.to_u128()? as u8;\n-                let size = self.type_size(ty)?.expect(\"write_bytes() type must be sized\");\n+                let size = self.type_size(ty)?.expect(\n+                    \"write_bytes() type must be sized\",\n+                );\n                 let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 let count = self.value_to_primval(arg_vals[2], usize)?.to_u64()?;\n                 if count > 0 {\n@@ -502,7 +651,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n fn numeric_intrinsic<'tcx>(\n     name: &str,\n     bytes: u128,\n-    kind: PrimValKind\n+    kind: PrimValKind,\n ) -> EvalResult<'tcx, PrimVal> {\n     macro_rules! integer_intrinsic {\n         ($method:ident) => ({\n@@ -527,10 +676,10 @@ fn numeric_intrinsic<'tcx>(\n \n     let result_val = match name {\n         \"bswap\" => integer_intrinsic!(swap_bytes),\n-        \"ctlz\"  => integer_intrinsic!(leading_zeros),\n+        \"ctlz\" => integer_intrinsic!(leading_zeros),\n         \"ctpop\" => integer_intrinsic!(count_ones),\n-        \"cttz\"  => integer_intrinsic!(trailing_zeros),\n-        _       => bug!(\"not a numeric intrinsic: {}\", name),\n+        \"cttz\" => integer_intrinsic!(trailing_zeros),\n+        _ => bug!(\"not a numeric intrinsic: {}\", name),\n     };\n \n     Ok(result_val)"}, {"sha": "a26fbd5d3fc0b53924b5479f4a6a80bb3424f973", "filename": "miri/lib.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/miri%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/miri%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Flib.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -20,10 +20,7 @@ use rustc::mir;\n \n use syntax::codemap::Span;\n \n-use std::collections::{\n-    HashMap,\n-    BTreeMap,\n-};\n+use std::collections::{HashMap, BTreeMap};\n \n #[macro_use]\n extern crate rustc_miri;\n@@ -57,15 +54,21 @@ pub fn eval_main<'a, 'tcx: 'a>(\n         let mut cleanup_ptr = None; // Pointer to be deallocated when we are done\n \n         if !main_mir.return_ty.is_nil() || main_mir.arg_count != 0 {\n-            return err!(Unimplemented(\"miri does not support main functions without `fn()` type signatures\".to_owned()));\n+            return err!(Unimplemented(\n+                \"miri does not support main functions without `fn()` type signatures\"\n+                    .to_owned(),\n+            ));\n         }\n \n         if let Some(start_id) = start_wrapper {\n             let start_instance = ty::Instance::mono(ecx.tcx, start_id);\n             let start_mir = ecx.load_mir(start_instance.def)?;\n \n             if start_mir.arg_count != 3 {\n-                return err!(AbiViolation(format!(\"'start' lang item should have three arguments, but has {}\", start_mir.arg_count)));\n+                return err!(AbiViolation(format!(\n+                    \"'start' lang item should have three arguments, but has {}\",\n+                    start_mir.arg_count\n+                )));\n             }\n \n             // Return value\n@@ -90,7 +93,11 @@ pub fn eval_main<'a, 'tcx: 'a>(\n             let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n             let main_ty = main_instance.def.def_ty(ecx.tcx);\n             let main_ptr_ty = ecx.tcx.mk_fn_ptr(main_ty.fn_sig(ecx.tcx));\n-            ecx.write_value(Value::ByVal(PrimVal::Ptr(main_ptr)), dest, main_ptr_ty)?;\n+            ecx.write_value(\n+                Value::ByVal(PrimVal::Ptr(main_ptr)),\n+                dest,\n+                main_ptr_ty,\n+            )?;\n \n             // Second argument (argc): 0\n             let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n@@ -114,7 +121,11 @@ pub fn eval_main<'a, 'tcx: 'a>(\n         while ecx.step()? {}\n         ecx.run_tls_dtors()?;\n         if let Some(cleanup_ptr) = cleanup_ptr {\n-            ecx.memory_mut().deallocate(cleanup_ptr, None, MemoryKind::Stack)?;\n+            ecx.memory_mut().deallocate(\n+                cleanup_ptr,\n+                None,\n+                MemoryKind::Stack,\n+            )?;\n         }\n         Ok(())\n     }"}, {"sha": "6d68aadf96cc724b3dd3201fa01f00510c56dc1a", "filename": "miri/operator.rs", "status": "modified", "additions": 45, "deletions": 24, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/miri%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/miri%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Foperator.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -37,20 +37,28 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n         use rustc::mir::BinOp::*;\n         let usize = PrimValKind::from_uint_size(self.memory.pointer_size());\n         let isize = PrimValKind::from_int_size(self.memory.pointer_size());\n-        let left_kind  = self.ty_to_primval_kind(left_ty)?;\n+        let left_kind = self.ty_to_primval_kind(left_ty)?;\n         let right_kind = self.ty_to_primval_kind(right_ty)?;\n         match bin_op {\n             Offset if left_kind == Ptr && right_kind == usize => {\n-                let pointee_ty = left_ty.builtin_deref(true, ty::LvaluePreference::NoPreference).expect(\"Offset called on non-ptr type\").ty;\n-                let ptr = self.pointer_offset(left.into(), pointee_ty, right.to_bytes()? as i64)?;\n+                let pointee_ty = left_ty\n+                    .builtin_deref(true, ty::LvaluePreference::NoPreference)\n+                    .expect(\"Offset called on non-ptr type\")\n+                    .ty;\n+                let ptr = self.pointer_offset(\n+                    left.into(),\n+                    pointee_ty,\n+                    right.to_bytes()? as i64,\n+                )?;\n                 Ok(Some((ptr.into_inner_primval(), false)))\n-            },\n+            }\n             // These work on anything\n             Eq if left_kind == right_kind => {\n                 let result = match (left, right) {\n                     (PrimVal::Bytes(left), PrimVal::Bytes(right)) => left == right,\n                     (PrimVal::Ptr(left), PrimVal::Ptr(right)) => left == right,\n-                    (PrimVal::Undef, _) | (_, PrimVal::Undef) => return err!(ReadUndefBytes),\n+                    (PrimVal::Undef, _) |\n+                    (_, PrimVal::Undef) => return err!(ReadUndefBytes),\n                     _ => false,\n                 };\n                 Ok(Some((PrimVal::from_bool(result), false)))\n@@ -59,16 +67,17 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let result = match (left, right) {\n                     (PrimVal::Bytes(left), PrimVal::Bytes(right)) => left != right,\n                     (PrimVal::Ptr(left), PrimVal::Ptr(right)) => left != right,\n-                    (PrimVal::Undef, _) | (_, PrimVal::Undef) => return err!(ReadUndefBytes),\n+                    (PrimVal::Undef, _) |\n+                    (_, PrimVal::Undef) => return err!(ReadUndefBytes),\n                     _ => true,\n                 };\n                 Ok(Some((PrimVal::from_bool(result), false)))\n             }\n             // These need both pointers to be in the same allocation\n             Lt | Le | Gt | Ge | Sub\n-            if left_kind == right_kind\n-            && (left_kind == Ptr || left_kind == usize || left_kind == isize)\n-            && left.is_ptr() && right.is_ptr() => {\n+                if left_kind == right_kind &&\n+                       (left_kind == Ptr || left_kind == usize || left_kind == isize) &&\n+                       left.is_ptr() && right.is_ptr() => {\n                 let left = left.to_ptr()?;\n                 let right = right.to_ptr()?;\n                 if left.alloc_id == right.alloc_id {\n@@ -77,13 +86,15 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                         Le => left.offset <= right.offset,\n                         Gt => left.offset > right.offset,\n                         Ge => left.offset >= right.offset,\n-                        Sub => return self.binary_op(\n-                            Sub,\n-                            PrimVal::Bytes(left.offset as u128),\n-                            self.tcx.types.usize,\n-                            PrimVal::Bytes(right.offset as u128),\n-                            self.tcx.types.usize,\n-                        ).map(Some),\n+                        Sub => {\n+                            return self.binary_op(\n+                                Sub,\n+                                PrimVal::Bytes(left.offset as u128),\n+                                self.tcx.types.usize,\n+                                PrimVal::Bytes(right.offset as u128),\n+                                self.tcx.types.usize,\n+                            ).map(Some)\n+                        }\n                         _ => bug!(\"We already established it has to be one of these operators.\"),\n                     };\n                     Ok(Some((PrimVal::from_bool(res), false)))\n@@ -94,18 +105,28 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             }\n             // These work if one operand is a pointer, the other an integer\n             Add | BitAnd | Sub\n-            if left_kind == right_kind && (left_kind == usize || left_kind == isize)\n-            && left.is_ptr() && right.is_bytes() => {\n+                if left_kind == right_kind && (left_kind == usize || left_kind == isize) &&\n+                       left.is_ptr() && right.is_bytes() => {\n                 // Cast to i128 is fine as we checked the kind to be ptr-sized\n-                self.ptr_int_arithmetic(bin_op, left.to_ptr()?, right.to_bytes()? as i128, left_kind == isize).map(Some)\n+                self.ptr_int_arithmetic(\n+                    bin_op,\n+                    left.to_ptr()?,\n+                    right.to_bytes()? as i128,\n+                    left_kind == isize,\n+                ).map(Some)\n             }\n             Add | BitAnd\n-            if left_kind == right_kind && (left_kind == usize || left_kind == isize)\n-            && left.is_bytes() && right.is_ptr() => {\n+                if left_kind == right_kind && (left_kind == usize || left_kind == isize) &&\n+                       left.is_bytes() && right.is_ptr() => {\n                 // This is a commutative operation, just swap the operands\n-                self.ptr_int_arithmetic(bin_op, right.to_ptr()?, left.to_bytes()? as i128, left_kind == isize).map(Some)\n+                self.ptr_int_arithmetic(\n+                    bin_op,\n+                    right.to_ptr()?,\n+                    left.to_bytes()? as i128,\n+                    left_kind == isize,\n+                ).map(Some)\n             }\n-            _ => Ok(None)\n+            _ => Ok(None),\n         }\n     }\n \n@@ -118,7 +139,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n     ) -> EvalResult<'tcx, (PrimVal, bool)> {\n         use rustc::mir::BinOp::*;\n \n-        fn map_to_primval((res, over) : (MemoryPointer, bool)) -> (PrimVal, bool) {\n+        fn map_to_primval((res, over): (MemoryPointer, bool)) -> (PrimVal, bool) {\n             (PrimVal::Ptr(res), over)\n         }\n "}, {"sha": "e592478f6f9e69fa6cd1b1bea8deccfe1eb914b5", "filename": "miri/tls.rs", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/miri%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/miri%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ftls.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -1,21 +1,17 @@\n use rustc::{ty, mir};\n \n-use super::{\n-    TlsKey, TlsEntry,\n-    EvalResult, EvalErrorKind,\n-    Pointer,\n-    Memory,\n-    Evaluator,\n-    Lvalue,\n-    StackPopCleanup, EvalContext,\n-};\n+use super::{TlsKey, TlsEntry, EvalResult, EvalErrorKind, Pointer, Memory, Evaluator, Lvalue,\n+            StackPopCleanup, EvalContext};\n \n pub trait MemoryExt<'tcx> {\n     fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey;\n     fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx>;\n     fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Pointer>;\n     fn store_tls(&mut self, key: TlsKey, new_data: Pointer) -> EvalResult<'tcx>;\n-    fn fetch_tls_dtor(&mut self, key: Option<TlsKey>) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Pointer, TlsKey)>>;\n+    fn fetch_tls_dtor(\n+        &mut self,\n+        key: Option<TlsKey>,\n+    ) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Pointer, TlsKey)>>;\n }\n \n pub trait EvalContextExt<'tcx> {\n@@ -26,7 +22,13 @@ impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator> {\n     fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey {\n         let new_key = self.data.next_thread_local;\n         self.data.next_thread_local += 1;\n-        self.data.thread_local.insert(new_key, TlsEntry { data: Pointer::null(), dtor });\n+        self.data.thread_local.insert(\n+            new_key,\n+            TlsEntry {\n+                data: Pointer::null(),\n+                dtor,\n+            },\n+        );\n         trace!(\"New TLS key allocated: {} with dtor {:?}\", new_key, dtor);\n         return new_key;\n     }\n@@ -36,19 +38,19 @@ impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator> {\n             Some(_) => {\n                 trace!(\"TLS key {} removed\", key);\n                 Ok(())\n-            },\n-            None => err!(TlsOutOfBounds)\n-        }\n+            }\n+            None => err!(TlsOutOfBounds),\n+        };\n     }\n \n     fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Pointer> {\n         return match self.data.thread_local.get(&key) {\n             Some(&TlsEntry { data, .. }) => {\n                 trace!(\"TLS key {} loaded: {:?}\", key, data);\n                 Ok(data)\n-            },\n-            None => err!(TlsOutOfBounds)\n-        }\n+            }\n+            None => err!(TlsOutOfBounds),\n+        };\n     }\n \n     fn store_tls(&mut self, key: TlsKey, new_data: Pointer) -> EvalResult<'tcx> {\n@@ -57,11 +59,11 @@ impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator> {\n                 trace!(\"TLS key {} stored: {:?}\", key, new_data);\n                 *data = new_data;\n                 Ok(())\n-            },\n-            None => err!(TlsOutOfBounds)\n-        }\n+            }\n+            None => err!(TlsOutOfBounds),\n+        };\n     }\n-    \n+\n     /// Returns a dtor, its argument and its index, if one is supposed to run\n     ///\n     /// An optional destructor function may be associated with each key value.\n@@ -80,13 +82,18 @@ impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator> {\n     /// with associated destructors, implementations may stop calling destructors,\n     /// or they may continue calling destructors until no non-NULL values with\n     /// associated destructors exist, even though this might result in an infinite loop.\n-    fn fetch_tls_dtor(&mut self, key: Option<TlsKey>) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Pointer, TlsKey)>> {\n+    fn fetch_tls_dtor(\n+        &mut self,\n+        key: Option<TlsKey>,\n+    ) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Pointer, TlsKey)>> {\n         use std::collections::Bound::*;\n         let start = match key {\n             Some(key) => Excluded(key),\n             None => Unbounded,\n         };\n-        for (&key, &mut TlsEntry { ref mut data, dtor }) in self.data.thread_local.range_mut((start, Unbounded)) {\n+        for (&key, &mut TlsEntry { ref mut data, dtor }) in\n+            self.data.thread_local.range_mut((start, Unbounded))\n+        {\n             if !data.is_null()? {\n                 if let Some(dtor) = dtor {\n                     let ret = Some((dtor, *data, key));\n@@ -115,7 +122,9 @@ impl<'a, 'tcx: 'a> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, Evaluator> {\n                 Lvalue::undef(),\n                 StackPopCleanup::None,\n             )?;\n-            let arg_local = self.frame().mir.args_iter().next().ok_or(EvalErrorKind::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()))?;\n+            let arg_local = self.frame().mir.args_iter().next().ok_or(\n+                EvalErrorKind::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()),\n+            )?;\n             let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n             let ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n             self.write_ptr(dest, ptr, ty)?;"}, {"sha": "c6016509d2383cc83bcb2abe11fe774275547a0c", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -1,20 +1,14 @@\n use rustc::ty::{self, Ty};\n use syntax::ast::{FloatTy, IntTy, UintTy};\n \n-use super::{\n-    PrimVal,\n-    EvalContext,\n-    EvalResult,\n-    MemoryPointer, PointerArithmetic,\n-    Machine,\n-};\n+use super::{PrimVal, EvalContext, EvalResult, MemoryPointer, PointerArithmetic, Machine};\n \n impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub(super) fn cast_primval(\n         &self,\n         val: PrimVal,\n         src_ty: Ty<'tcx>,\n-        dest_ty: Ty<'tcx>\n+        dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, PrimVal> {\n         let src_kind = self.ty_to_primval_kind(src_ty)?;\n \n@@ -29,11 +23,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n                     I8 | I16 | I32 | I64 | I128 => {\n                         self.cast_from_signed_int(val.to_i128()?, dest_ty)\n-                    },\n+                    }\n \n                     Bool | Char | U8 | U16 | U32 | U64 | U128 | FnPtr | Ptr => {\n                         self.cast_from_int(val.to_u128()?, dest_ty, false)\n-                    },\n+                    }\n                 }\n             }\n         }\n@@ -43,18 +37,22 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         self.cast_from_int(val as u128, ty, val < 0)\n     }\n \n-    fn cast_from_int(&self, v: u128, ty: ty::Ty<'tcx>, negative: bool) -> EvalResult<'tcx, PrimVal> {\n+    fn cast_from_int(\n+        &self,\n+        v: u128,\n+        ty: ty::Ty<'tcx>,\n+        negative: bool,\n+    ) -> EvalResult<'tcx, PrimVal> {\n         use rustc::ty::TypeVariants::*;\n         match ty.sty {\n             // Casts to bool are not permitted by rustc, no need to handle them here.\n-\n-            TyInt(IntTy::I8)  => Ok(PrimVal::Bytes(v as i128 as i8  as u128)),\n+            TyInt(IntTy::I8) => Ok(PrimVal::Bytes(v as i128 as i8 as u128)),\n             TyInt(IntTy::I16) => Ok(PrimVal::Bytes(v as i128 as i16 as u128)),\n             TyInt(IntTy::I32) => Ok(PrimVal::Bytes(v as i128 as i32 as u128)),\n             TyInt(IntTy::I64) => Ok(PrimVal::Bytes(v as i128 as i64 as u128)),\n             TyInt(IntTy::I128) => Ok(PrimVal::Bytes(v as u128)),\n \n-            TyUint(UintTy::U8)  => Ok(PrimVal::Bytes(v as u8  as u128)),\n+            TyUint(UintTy::U8) => Ok(PrimVal::Bytes(v as u8 as u128)),\n             TyUint(UintTy::U16) => Ok(PrimVal::Bytes(v as u16 as u128)),\n             TyUint(UintTy::U32) => Ok(PrimVal::Bytes(v as u32 as u128)),\n             TyUint(UintTy::U64) => Ok(PrimVal::Bytes(v as u64 as u128)),\n@@ -73,9 +71,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n \n             TyFloat(FloatTy::F64) if negative => Ok(PrimVal::from_f64(v as i128 as f64)),\n-            TyFloat(FloatTy::F64)             => Ok(PrimVal::from_f64(v as f64)),\n+            TyFloat(FloatTy::F64) => Ok(PrimVal::from_f64(v as f64)),\n             TyFloat(FloatTy::F32) if negative => Ok(PrimVal::from_f32(v as i128 as f32)),\n-            TyFloat(FloatTy::F32)             => Ok(PrimVal::from_f32(v as f32)),\n+            TyFloat(FloatTy::F32) => Ok(PrimVal::from_f32(v as f32)),\n \n             TyChar if v as u8 as u128 == v => Ok(PrimVal::Bytes(v)),\n             TyChar => err!(InvalidChar(v)),\n@@ -92,7 +90,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         match ty.sty {\n             // Casting negative floats to unsigned integers yields zero.\n             TyUint(_) if val < 0.0 => self.cast_from_int(0, ty, false),\n-            TyInt(_)  if val < 0.0 => self.cast_from_int(val as i128 as u128, ty, true),\n+            TyInt(_) if val < 0.0 => self.cast_from_int(val as i128 as u128, ty, true),\n \n             TyInt(_) | ty::TyUint(_) => self.cast_from_int(val as u128, ty, false),\n \n@@ -106,8 +104,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         use rustc::ty::TypeVariants::*;\n         match ty.sty {\n             // Casting to a reference or fn pointer is not permitted by rustc, no need to support it here.\n-            TyRawPtr(_) | TyInt(IntTy::Is) | TyUint(UintTy::Us) =>\n-                Ok(PrimVal::Ptr(ptr)),\n+            TyRawPtr(_) |\n+            TyInt(IntTy::Is) |\n+            TyUint(UintTy::Us) => Ok(PrimVal::Ptr(ptr)),\n             TyInt(_) | TyUint(_) => err!(ReadPointerAsBytes),\n             _ => err!(Unimplemented(format!(\"ptr to {:?} cast\", ty))),\n         }"}, {"sha": "f66d3f65ff1955ef88ed2b94c86dbeab131ee748", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 68, "deletions": 33, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -5,13 +5,8 @@ use rustc::mir;\n use syntax::ast::Mutability;\n use syntax::codemap::Span;\n \n-use super::{\n-    EvalResult, EvalError, EvalErrorKind,\n-    GlobalId, Lvalue, Value,\n-    PrimVal,\n-    EvalContext, StackPopCleanup, PtrAndAlign,\n-    MemoryKind,\n-};\n+use super::{EvalResult, EvalError, EvalErrorKind, GlobalId, Lvalue, Value, PrimVal, EvalContext,\n+            StackPopCleanup, PtrAndAlign, MemoryKind};\n \n use rustc_const_math::ConstInt;\n \n@@ -24,22 +19,37 @@ pub fn eval_body_as_primval<'a, 'tcx>(\n ) -> EvalResult<'tcx, (PrimVal, Ty<'tcx>)> {\n     let limits = super::ResourceLimits::default();\n     let mut ecx = EvalContext::<CompileTimeFunctionEvaluator>::new(tcx, limits, (), ());\n-    let cid = GlobalId { instance, promoted: None };\n+    let cid = GlobalId {\n+        instance,\n+        promoted: None,\n+    };\n     if ecx.tcx.has_attr(instance.def_id(), \"linkage\") {\n         return Err(ConstEvalError::NotConst(\"extern global\".to_string()).into());\n     }\n-    \n+\n     let mir = ecx.load_mir(instance.def)?;\n     if !ecx.globals.contains_key(&cid) {\n-        let size = ecx.type_size_with_substs(mir.return_ty, instance.substs)?.expect(\"unsized global\");\n+        let size = ecx.type_size_with_substs(mir.return_ty, instance.substs)?\n+            .expect(\"unsized global\");\n         let align = ecx.type_align_with_substs(mir.return_ty, instance.substs)?;\n-        let ptr = ecx.memory.allocate(size, align, MemoryKind::UninitializedStatic)?;\n+        let ptr = ecx.memory.allocate(\n+            size,\n+            align,\n+            MemoryKind::UninitializedStatic,\n+        )?;\n         let aligned = !ecx.is_packed(mir.return_ty)?;\n-        ecx.globals.insert(cid, PtrAndAlign { ptr: ptr.into(), aligned });\n+        ecx.globals.insert(\n+            cid,\n+            PtrAndAlign {\n+                ptr: ptr.into(),\n+                aligned,\n+            },\n+        );\n         let mutable = !mir.return_ty.is_freeze(\n-                ecx.tcx,\n-                ty::ParamEnv::empty(Reveal::All),\n-                mir.span);\n+            ecx.tcx,\n+            ty::ParamEnv::empty(Reveal::All),\n+            mir.span,\n+        );\n         let mutability = if mutable {\n             Mutability::Mutable\n         } else {\n@@ -77,14 +87,26 @@ pub fn eval_body_as_integer<'a, 'tcx>(\n         TyInt(IntTy::I32) => ConstInt::I32(prim as i128 as i32),\n         TyInt(IntTy::I64) => ConstInt::I64(prim as i128 as i64),\n         TyInt(IntTy::I128) => ConstInt::I128(prim as i128),\n-        TyInt(IntTy::Is) => ConstInt::Isize(ConstIsize::new(prim as i128 as i64, tcx.sess.target.int_type).expect(\"miri should already have errored\")),\n+        TyInt(IntTy::Is) => ConstInt::Isize(\n+            ConstIsize::new(prim as i128 as i64, tcx.sess.target.int_type)\n+                .expect(\"miri should already have errored\"),\n+        ),\n         TyUint(UintTy::U8) => ConstInt::U8(prim as u8),\n         TyUint(UintTy::U16) => ConstInt::U16(prim as u16),\n         TyUint(UintTy::U32) => ConstInt::U32(prim as u32),\n         TyUint(UintTy::U64) => ConstInt::U64(prim as u64),\n         TyUint(UintTy::U128) => ConstInt::U128(prim),\n-        TyUint(UintTy::Us) => ConstInt::Usize(ConstUsize::new(prim as u64, tcx.sess.target.uint_type).expect(\"miri should already have errored\")),\n-        _ => return Err(ConstEvalError::NeedsRfc(\"evaluating anything other than isize/usize during typeck\".to_string()).into()),\n+        TyUint(UintTy::Us) => ConstInt::Usize(\n+            ConstUsize::new(prim as u64, tcx.sess.target.uint_type)\n+                .expect(\"miri should already have errored\"),\n+        ),\n+        _ => {\n+            return Err(\n+                ConstEvalError::NeedsRfc(\n+                    \"evaluating anything other than isize/usize during typeck\".to_string(),\n+                ).into(),\n+            )\n+        }\n     })\n }\n \n@@ -106,10 +128,14 @@ impl fmt::Display for ConstEvalError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         use self::ConstEvalError::*;\n         match *self {\n-            NeedsRfc(ref msg) =>\n-                write!(f, \"\\\"{}\\\" needs an rfc before being allowed inside constants\", msg),\n-            NotConst(ref msg) =>\n-                write!(f, \"Cannot evaluate within constants: \\\"{}\\\"\", msg),\n+            NeedsRfc(ref msg) => {\n+                write!(\n+                    f,\n+                    \"\\\"{}\\\" needs an rfc before being allowed inside constants\",\n+                    msg\n+                )\n+            }\n+            NotConst(ref msg) => write!(f, \"Cannot evaluate within constants: \\\"{}\\\"\", msg),\n         }\n     }\n }\n@@ -118,10 +144,8 @@ impl Error for ConstEvalError {\n     fn description(&self) -> &str {\n         use self::ConstEvalError::*;\n         match *self {\n-            NeedsRfc(_) =>\n-                \"this feature needs an rfc before being allowed inside constants\",\n-            NotConst(_) =>\n-                \"this feature is not compatible with constant evaluation\",\n+            NeedsRfc(_) => \"this feature needs an rfc before being allowed inside constants\",\n+            NotConst(_) => \"this feature is not compatible with constant evaluation\",\n         }\n     }\n \n@@ -143,14 +167,19 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeFunctionEvaluator {\n         _sig: ty::FnSig<'tcx>,\n     ) -> EvalResult<'tcx, bool> {\n         if !ecx.tcx.is_const_fn(instance.def_id()) {\n-            return Err(ConstEvalError::NotConst(format!(\"calling non-const fn `{}`\", instance)).into());\n+            return Err(\n+                ConstEvalError::NotConst(format!(\"calling non-const fn `{}`\", instance)).into(),\n+            );\n         }\n         let mir = match ecx.load_mir(instance.def) {\n             Ok(mir) => mir,\n-            Err(EvalError{ kind: EvalErrorKind::NoMirFor(path), ..} ) => {\n+            Err(EvalError { kind: EvalErrorKind::NoMirFor(path), .. }) => {\n                 // some simple things like `malloc` might get accepted in the future\n-                return Err(ConstEvalError::NeedsRfc(format!(\"calling extern function `{}`\", path)).into());\n-            },\n+                return Err(\n+                    ConstEvalError::NeedsRfc(format!(\"calling extern function `{}`\", path))\n+                        .into(),\n+                );\n+            }\n             Err(other) => return Err(other),\n         };\n         let (return_lvalue, return_to_block) = match destination {\n@@ -178,7 +207,9 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeFunctionEvaluator {\n         _dest_layout: &'tcx layout::Layout,\n         _target: mir::BasicBlock,\n     ) -> EvalResult<'tcx> {\n-        Err(ConstEvalError::NeedsRfc(\"calling intrinsics\".to_string()).into())\n+        Err(\n+            ConstEvalError::NeedsRfc(\"calling intrinsics\".to_string()).into(),\n+        )\n     }\n \n     fn try_ptr_op<'a>(\n@@ -192,7 +223,9 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeFunctionEvaluator {\n         if left.is_bytes() && right.is_bytes() {\n             Ok(None)\n         } else {\n-            Err(ConstEvalError::NeedsRfc(\"Pointer arithmetic or comparison\".to_string()).into())\n+            Err(\n+                ConstEvalError::NeedsRfc(\"Pointer arithmetic or comparison\".to_string()).into(),\n+            )\n         }\n     }\n \n@@ -204,6 +237,8 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeFunctionEvaluator {\n         _ecx: &mut EvalContext<'a, 'tcx, Self>,\n         _ty: ty::Ty<'tcx>,\n     ) -> EvalResult<'tcx, PrimVal> {\n-        Err(ConstEvalError::NeedsRfc(\"Heap allocations via `box` keyword\".to_string()).into())\n+        Err(\n+            ConstEvalError::NeedsRfc(\"Heap allocations via `box` keyword\".to_string()).into(),\n+        )\n     }\n }"}, {"sha": "a5f5072dc29098304f76ebdeddadc93fb2e939d8", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 558, "deletions": 285, "changes": 843, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -16,16 +16,9 @@ use syntax::codemap::{self, DUMMY_SP, Span};\n use syntax::ast::{self, Mutability};\n use syntax::abi::Abi;\n \n-use super::{\n-    EvalError, EvalResult, EvalErrorKind,\n-    GlobalId, Lvalue, LvalueExtra,\n-    Memory, MemoryPointer, HasMemory,\n-    MemoryKind,\n-    operator,\n-    PrimVal, PrimValKind, Value, Pointer,\n-    ValidationQuery,\n-    Machine,\n-};\n+use super::{EvalError, EvalResult, EvalErrorKind, GlobalId, Lvalue, LvalueExtra, Memory,\n+            MemoryPointer, HasMemory, MemoryKind, operator, PrimVal, PrimValKind, Value, Pointer,\n+            ValidationQuery, Machine};\n \n pub struct EvalContext<'a, 'tcx: 'a, M: Machine<'tcx>> {\n     /// Stores data required by the `Machine`\n@@ -60,7 +53,6 @@ pub struct Frame<'tcx> {\n     ////////////////////////////////////////////////////////////////////////////////\n     // Function and callsite information\n     ////////////////////////////////////////////////////////////////////////////////\n-\n     /// The MIR for the function called on this frame.\n     pub mir: &'tcx mir::Mir<'tcx>,\n \n@@ -73,7 +65,6 @@ pub struct Frame<'tcx> {\n     ////////////////////////////////////////////////////////////////////////////////\n     // Return lvalue and locals\n     ////////////////////////////////////////////////////////////////////////////////\n-\n     /// The block to return to when returning from the current stack frame\n     pub return_to_block: StackPopCleanup,\n \n@@ -91,7 +82,6 @@ pub struct Frame<'tcx> {\n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n     ////////////////////////////////////////////////////////////////////////////////\n-\n     /// The block that is currently executed (or will be executed after the above call stacks\n     /// return).\n     pub block: mir::BasicBlock,\n@@ -189,9 +179,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub fn alloc_ptr_with_substs(\n         &mut self,\n         ty: Ty<'tcx>,\n-        substs: &'tcx Substs<'tcx>\n+        substs: &'tcx Substs<'tcx>,\n     ) -> EvalResult<'tcx, MemoryPointer> {\n-        let size = self.type_size_with_substs(ty, substs)?.expect(\"cannot alloc memory for unsized type\");\n+        let size = self.type_size_with_substs(ty, substs)?.expect(\n+            \"cannot alloc memory for unsized type\",\n+        );\n         let align = self.type_align_with_substs(ty, substs)?;\n         self.memory.allocate(size, align, MemoryKind::Stack)\n     }\n@@ -216,7 +208,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     pub fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n         let ptr = self.memory.allocate_cached(s.as_bytes())?;\n-        Ok(Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::from_u128(s.len() as u128)))\n+        Ok(Value::ByValPair(\n+            PrimVal::Ptr(ptr),\n+            PrimVal::from_u128(s.len() as u128),\n+        ))\n     }\n \n     pub(super) fn const_to_value(&mut self, const_val: &ConstVal<'tcx>) -> EvalResult<'tcx, Value> {\n@@ -237,12 +232,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 PrimVal::Ptr(ptr)\n             }\n \n-            Variant(_)   => unimplemented!(),\n-            Struct(_)    => unimplemented!(),\n-            Tuple(_)     => unimplemented!(),\n+            Variant(_) => unimplemented!(),\n+            Struct(_) => unimplemented!(),\n+            Tuple(_) => unimplemented!(),\n             // function items are zero sized and thus have no readable value\n-            Function(..)  => PrimVal::Undef,\n-            Array(_)     => unimplemented!(),\n+            Function(..) => PrimVal::Undef,\n+            Array(_) => unimplemented!(),\n             Repeat(_, _) => unimplemented!(),\n         };\n \n@@ -255,10 +250,17 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         ty.is_sized(self.tcx, ty::ParamEnv::empty(Reveal::All), DUMMY_SP)\n     }\n \n-    pub fn load_mir(&self, instance: ty::InstanceDef<'tcx>) -> EvalResult<'tcx, &'tcx mir::Mir<'tcx>> {\n+    pub fn load_mir(\n+        &self,\n+        instance: ty::InstanceDef<'tcx>,\n+    ) -> EvalResult<'tcx, &'tcx mir::Mir<'tcx>> {\n         trace!(\"load mir {:?}\", instance);\n         match instance {\n-            ty::InstanceDef::Item(def_id) => self.tcx.maybe_optimized_mir(def_id).ok_or_else(|| EvalErrorKind::NoMirFor(self.tcx.item_path_str(def_id)).into()),\n+            ty::InstanceDef::Item(def_id) => {\n+                self.tcx.maybe_optimized_mir(def_id).ok_or_else(|| {\n+                    EvalErrorKind::NoMirFor(self.tcx.item_path_str(def_id)).into()\n+                })\n+            }\n             _ => Ok(self.tcx.instance_mir(instance)),\n         }\n     }\n@@ -272,7 +274,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     pub fn erase_lifetimes<T>(&self, value: &Binder<T>) -> T\n-        where T : TypeFoldable<'tcx>\n+    where\n+        T: TypeFoldable<'tcx>,\n     {\n         let value = self.tcx.erase_late_bound_regions(value);\n         self.tcx.erase_regions(&value)\n@@ -301,15 +304,25 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n                     let (sized_size, sized_align) = match *layout {\n                         ty::layout::Layout::Univariant { ref variant, .. } => {\n-                            (variant.offsets.last().map_or(0, |o| o.bytes()), variant.align)\n+                            (\n+                                variant.offsets.last().map_or(0, |o| o.bytes()),\n+                                variant.align,\n+                            )\n                         }\n                         _ => {\n-                            bug!(\"size_and_align_of_dst: expcted Univariant for `{}`, found {:#?}\",\n-                                 ty, layout);\n+                            bug!(\n+                                \"size_and_align_of_dst: expcted Univariant for `{}`, found {:#?}\",\n+                                ty,\n+                                layout\n+                            );\n                         }\n                     };\n-                    debug!(\"DST {} statically sized prefix size: {} align: {:?}\",\n-                           ty, sized_size, sized_align);\n+                    debug!(\n+                        \"DST {} statically sized prefix size: {} align: {:?}\",\n+                        ty,\n+                        sized_size,\n+                        sized_align\n+                    );\n \n                     // Recurse to get the size of the dynamically sized field (must be\n                     // the last field).\n@@ -339,7 +352,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n                     // Choose max of two known alignments (combined value must\n                     // be aligned according to more restrictive of the two).\n-                    let align = sized_align.max(Align::from_bytes(unsized_align, unsized_align).unwrap());\n+                    let align =\n+                        sized_align.max(Align::from_bytes(unsized_align, unsized_align).unwrap());\n \n                     // Issue #27023: must add any necessary padding to `size`\n                     // (to make it a multiple of `align`) before returning it.\n@@ -363,7 +377,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n                 ty::TySlice(_) | ty::TyStr => {\n                     let elem_ty = ty.sequence_element_type(self.tcx);\n-                    let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\") as u64;\n+                    let elem_size = self.type_size(elem_ty)?.expect(\n+                        \"slice element must be sized\",\n+                    ) as u64;\n                     let (_, len) = value.into_slice(&mut self.memory)?;\n                     let align = self.type_align(elem_ty)?;\n                     Ok((len * elem_size, align as u64))\n@@ -375,12 +391,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     /// Returns the normalized type of a struct field\n-    fn field_ty(\n-        &self,\n-        param_substs: &Substs<'tcx>,\n-        f: &ty::FieldDef,\n-    ) -> ty::Ty<'tcx> {\n-        self.tcx.normalize_associated_type(&f.ty(self.tcx, param_substs))\n+    fn field_ty(&self, param_substs: &Substs<'tcx>, f: &ty::FieldDef) -> ty::Ty<'tcx> {\n+        self.tcx.normalize_associated_type(\n+            &f.ty(self.tcx, param_substs),\n+        )\n     }\n \n     pub fn type_size(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<u64>> {\n@@ -404,19 +418,30 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n     }\n \n-    pub fn type_align_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, u64> {\n-        self.type_layout_with_substs(ty, substs).map(|layout| layout.align(&self.tcx.data_layout).abi())\n+    pub fn type_align_with_substs(\n+        &self,\n+        ty: Ty<'tcx>,\n+        substs: &'tcx Substs<'tcx>,\n+    ) -> EvalResult<'tcx, u64> {\n+        self.type_layout_with_substs(ty, substs).map(|layout| {\n+            layout.align(&self.tcx.data_layout).abi()\n+        })\n     }\n \n     pub fn type_layout(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, &'tcx Layout> {\n         self.type_layout_with_substs(ty, self.substs())\n     }\n \n-    fn type_layout_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, &'tcx Layout> {\n+    fn type_layout_with_substs(\n+        &self,\n+        ty: Ty<'tcx>,\n+        substs: &'tcx Substs<'tcx>,\n+    ) -> EvalResult<'tcx, &'tcx Layout> {\n         // TODO(solson): Is this inefficient? Needs investigation.\n         let ty = self.monomorphize(ty, substs);\n \n-        ty.layout(self.tcx, ty::ParamEnv::empty(Reveal::All)).map_err(|layout| EvalErrorKind::Layout(layout).into())\n+        ty.layout(self.tcx, ty::ParamEnv::empty(Reveal::All))\n+            .map_err(|layout| EvalErrorKind::Layout(layout).into())\n     }\n \n     pub fn push_stack_frame(\n@@ -437,13 +462,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             for block in mir.basic_blocks() {\n                 for stmt in block.statements.iter() {\n                     match stmt.kind {\n-                        StorageLive(mir::Lvalue::Local(local)) | StorageDead(mir::Lvalue::Local(local)) => {\n+                        StorageLive(mir::Lvalue::Local(local)) |\n+                        StorageDead(mir::Lvalue::Local(local)) => {\n                             set.insert(local);\n                         }\n                         _ => {}\n                     }\n                 }\n-            };\n+            }\n             set\n         }\n \n@@ -453,7 +479,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let num_locals = mir.local_decls.len() - 1;\n         let mut locals = vec![None; num_locals];\n         for i in 0..num_locals {\n-            let local = mir::Local::new(i+1);\n+            let local = mir::Local::new(i + 1);\n             if !annotated_locals.contains(&local) {\n                 locals[i] = Some(Value::ByVal(PrimVal::Undef));\n             }\n@@ -483,21 +509,28 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub(super) fn pop_stack_frame(&mut self) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation -= 1;\n         self.memory.locks_lifetime_ended(None);\n-        let frame = self.stack.pop().expect(\"tried to pop a stack frame, but there were none\");\n+        let frame = self.stack.pop().expect(\n+            \"tried to pop a stack frame, but there were none\",\n+        );\n         if !self.stack.is_empty() {\n             // TODO: IS this the correct time to start considering these accesses as originating from the returned-to stack frame?\n             let cur_frame = self.cur_frame();\n             self.memory.set_cur_frame(cur_frame);\n         }\n         match frame.return_to_block {\n-            StackPopCleanup::MarkStatic(mutable) => if let Lvalue::Ptr{ ptr, .. } = frame.return_lvalue {\n-                // FIXME: to_ptr()? might be too extreme here, static zsts might reach this under certain conditions\n-                self.memory.mark_static_initalized(ptr.to_ptr()?.alloc_id, mutable)?\n-            } else {\n-                bug!(\"StackPopCleanup::MarkStatic on: {:?}\", frame.return_lvalue);\n-            },\n+            StackPopCleanup::MarkStatic(mutable) => {\n+                if let Lvalue::Ptr { ptr, .. } = frame.return_lvalue {\n+                    // FIXME: to_ptr()? might be too extreme here, static zsts might reach this under certain conditions\n+                    self.memory.mark_static_initalized(\n+                        ptr.to_ptr()?.alloc_id,\n+                        mutable,\n+                    )?\n+                } else {\n+                    bug!(\"StackPopCleanup::MarkStatic on: {:?}\", frame.return_lvalue);\n+                }\n+            }\n             StackPopCleanup::Goto(target) => self.goto_block(target),\n-            StackPopCleanup::None => {},\n+            StackPopCleanup::None => {}\n         }\n         // deallocate all locals that are backed by an allocation\n         for local in frame.locals {\n@@ -597,7 +630,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n \n             BinaryOp(bin_op, ref left, ref right) => {\n-                if self.intrinsic_overflowing(bin_op, left, right, dest, dest_ty)? {\n+                if self.intrinsic_overflowing(\n+                    bin_op,\n+                    left,\n+                    right,\n+                    dest,\n+                    dest_ty,\n+                )?\n+                {\n                     // There was an overflow in an unchecked binop.  Right now, we consider this an error and bail out.\n                     // The rationale is that the reason rustc emits unchecked binops in release mode (vs. the checked binops\n                     // it emits in debug mode) is performance, but it doesn't cost us any performance in miri.\n@@ -608,13 +648,23 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n \n             CheckedBinaryOp(bin_op, ref left, ref right) => {\n-                self.intrinsic_with_overflow(bin_op, left, right, dest, dest_ty)?;\n+                self.intrinsic_with_overflow(\n+                    bin_op,\n+                    left,\n+                    right,\n+                    dest,\n+                    dest_ty,\n+                )?;\n             }\n \n             UnaryOp(un_op, ref operand) => {\n                 let val = self.eval_operand_to_primval(operand)?;\n                 let kind = self.ty_to_primval_kind(dest_ty)?;\n-                self.write_primval(dest, operator::unary_op(un_op, val, kind)?, dest_ty)?;\n+                self.write_primval(\n+                    dest,\n+                    operator::unary_op(un_op, val, kind)?,\n+                    dest_ty,\n+                )?;\n             }\n \n             // Skip everything for zsts\n@@ -634,9 +684,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         self.assign_fields(dest, dest_ty, operands)?;\n                     }\n \n-                    General { discr, ref variants, .. } => {\n+                    General {\n+                        discr,\n+                        ref variants,\n+                        ..\n+                    } => {\n                         if let mir::AggregateKind::Adt(adt_def, variant, _, _) = **kind {\n-                            let discr_val = adt_def.discriminants(self.tcx)\n+                            let discr_val = adt_def\n+                                .discriminants(self.tcx)\n                                 .nth(variant)\n                                 .expect(\"broken mir: Adt variant id invalid\")\n                                 .to_u128_unchecked();\n@@ -677,7 +732,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         }\n                     }\n \n-                    StructWrappedNullablePointer { nndiscr, ref discrfield_source, ref nonnull, .. } => {\n+                    StructWrappedNullablePointer {\n+                        nndiscr,\n+                        ref discrfield_source,\n+                        ref nonnull,\n+                        ..\n+                    } => {\n                         if let mir::AggregateKind::Adt(_, variant, _, _) = **kind {\n                             if nndiscr == variant as u64 {\n                                 self.write_maybe_aligned_mut(!nonnull.packed, |ecx| {\n@@ -688,18 +748,25 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                                     let operand_ty = self.operand_ty(operand);\n                                     assert_eq!(self.type_size(operand_ty)?, Some(0));\n                                 }\n-                                let (offset, TyAndPacked { ty, packed: _}) = self.nonnull_offset_and_ty(dest_ty, nndiscr, discrfield_source)?;\n+                                let (offset, TyAndPacked { ty, packed: _ }) =\n+                                    self.nonnull_offset_and_ty(\n+                                        dest_ty,\n+                                        nndiscr,\n+                                        discrfield_source,\n+                                    )?;\n                                 // TODO: The packed flag is ignored\n \n                                 // FIXME(solson)\n                                 let dest = self.force_allocation(dest)?.to_ptr()?;\n \n                                 let dest = dest.offset(offset.bytes(), &self)?;\n-                                let dest_size = self.type_size(ty)?\n-                                    .expect(\"bad StructWrappedNullablePointer discrfield\");\n-                                self.memory.write_maybe_aligned_mut(!nonnull.packed, |mem| {\n-                                    mem.write_int(dest, 0, dest_size)\n-                                })?;\n+                                let dest_size = self.type_size(ty)?.expect(\n+                                    \"bad StructWrappedNullablePointer discrfield\",\n+                                );\n+                                self.memory.write_maybe_aligned_mut(\n+                                    !nonnull.packed,\n+                                    |mem| mem.write_int(dest, 0, dest_size),\n+                                )?;\n                             }\n                         } else {\n                             bug!(\"tried to assign {:?} to Layout::RawNullablePointer\", kind);\n@@ -709,7 +776,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     CEnum { .. } => {\n                         assert_eq!(operands.len(), 0);\n                         if let mir::AggregateKind::Adt(adt_def, variant, _, _) = **kind {\n-                            let n = adt_def.discriminants(self.tcx)\n+                            let n = adt_def\n+                                .discriminants(self.tcx)\n                                 .nth(variant)\n                                 .expect(\"broken mir: Adt variant index invalid\")\n                                 .to_u128_unchecked();\n@@ -747,11 +815,17 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             Repeat(ref operand, _) => {\n                 let (elem_ty, length) = match dest_ty.sty {\n                     ty::TyArray(elem_ty, n) => (elem_ty, n as u64),\n-                    _ => bug!(\"tried to assign array-repeat to non-array type {:?}\", dest_ty),\n+                    _ => {\n+                        bug!(\n+                            \"tried to assign array-repeat to non-array type {:?}\",\n+                            dest_ty\n+                        )\n+                    }\n                 };\n                 self.inc_step_counter_and_check_limit(length)?;\n-                let elem_size = self.type_size(elem_ty)?\n-                    .expect(\"repeat element type must be sized\");\n+                let elem_size = self.type_size(elem_ty)?.expect(\n+                    \"repeat element type must be sized\",\n+                );\n                 let value = self.eval_operand(operand)?;\n \n                 // FIXME(solson)\n@@ -768,7 +842,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let src = self.eval_lvalue(lvalue)?;\n                 let ty = self.lvalue_ty(lvalue);\n                 let (_, len) = src.elem_ty_and_len(ty);\n-                self.write_primval(dest, PrimVal::from_u128(len as u128), dest_ty)?;\n+                self.write_primval(\n+                    dest,\n+                    PrimVal::from_u128(len as u128),\n+                    dest_ty,\n+                )?;\n             }\n \n             Ref(_, _, ref lvalue) => {\n@@ -781,8 +859,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     LvalueExtra::None => ptr.ptr.to_value(),\n                     LvalueExtra::Length(len) => ptr.ptr.to_value_with_len(len),\n                     LvalueExtra::Vtable(vtable) => ptr.ptr.to_value_with_vtable(vtable),\n-                    LvalueExtra::DowncastVariant(..) =>\n-                        bug!(\"attempted to take a reference to an enum downcast lvalue\"),\n+                    LvalueExtra::DowncastVariant(..) => {\n+                        bug!(\"attempted to take a reference to an enum downcast lvalue\")\n+                    }\n                 };\n                 self.write_value(val, dest, dest_ty)?;\n             }\n@@ -793,8 +872,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n \n             NullaryOp(mir::NullOp::SizeOf, ty) => {\n-                let size = self.type_size(ty)?.expect(\"SizeOf nullary MIR operator called for unsized type\");\n-                self.write_primval(dest, PrimVal::from_u128(size as u128), dest_ty)?;\n+                let size = self.type_size(ty)?.expect(\n+                    \"SizeOf nullary MIR operator called for unsized type\",\n+                );\n+                self.write_primval(\n+                    dest,\n+                    PrimVal::from_u128(size as u128),\n+                    dest_ty,\n+                )?;\n             }\n \n             Cast(kind, ref operand, cast_ty) => {\n@@ -812,13 +897,13 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         let src_ty = self.operand_ty(operand);\n                         if self.type_is_fat_ptr(src_ty) {\n                             match (src, self.type_is_fat_ptr(dest_ty)) {\n-                                (Value::ByRef{..}, _) |\n+                                (Value::ByRef { .. }, _) |\n                                 (Value::ByValPair(..), true) => {\n                                     self.write_value(src, dest, dest_ty)?;\n-                                },\n+                                }\n                                 (Value::ByValPair(data, _), false) => {\n                                     self.write_value(Value::ByVal(data), dest, dest_ty)?;\n-                                },\n+                                }\n                                 (Value::ByVal(_), _) => bug!(\"expected fat ptr\"),\n                             }\n                         } else {\n@@ -828,31 +913,50 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         }\n                     }\n \n-                    ReifyFnPointer => match self.operand_ty(operand).sty {\n-                        ty::TyFnDef(def_id, substs) => {\n-                            let instance = resolve(self.tcx, def_id, substs);\n-                            let fn_ptr = self.memory.create_fn_alloc(instance);\n-                            self.write_value(Value::ByVal(PrimVal::Ptr(fn_ptr)), dest, dest_ty)?;\n-                        },\n-                        ref other => bug!(\"reify fn pointer on {:?}\", other),\n-                    },\n-\n-                    UnsafeFnPointer => match dest_ty.sty {\n-                        ty::TyFnPtr(_) => {\n-                            let src = self.eval_operand(operand)?;\n-                            self.write_value(src, dest, dest_ty)?;\n-                        },\n-                        ref other => bug!(\"fn to unsafe fn cast on {:?}\", other),\n-                    },\n-\n-                    ClosureFnPointer => match self.operand_ty(operand).sty {\n-                        ty::TyClosure(def_id, substs) => {\n-                            let instance = resolve_closure(self.tcx, def_id, substs, ty::ClosureKind::FnOnce);\n-                            let fn_ptr = self.memory.create_fn_alloc(instance);\n-                            self.write_value(Value::ByVal(PrimVal::Ptr(fn_ptr)), dest, dest_ty)?;\n-                        },\n-                        ref other => bug!(\"closure fn pointer on {:?}\", other),\n-                    },\n+                    ReifyFnPointer => {\n+                        match self.operand_ty(operand).sty {\n+                            ty::TyFnDef(def_id, substs) => {\n+                                let instance = resolve(self.tcx, def_id, substs);\n+                                let fn_ptr = self.memory.create_fn_alloc(instance);\n+                                self.write_value(\n+                                    Value::ByVal(PrimVal::Ptr(fn_ptr)),\n+                                    dest,\n+                                    dest_ty,\n+                                )?;\n+                            }\n+                            ref other => bug!(\"reify fn pointer on {:?}\", other),\n+                        }\n+                    }\n+\n+                    UnsafeFnPointer => {\n+                        match dest_ty.sty {\n+                            ty::TyFnPtr(_) => {\n+                                let src = self.eval_operand(operand)?;\n+                                self.write_value(src, dest, dest_ty)?;\n+                            }\n+                            ref other => bug!(\"fn to unsafe fn cast on {:?}\", other),\n+                        }\n+                    }\n+\n+                    ClosureFnPointer => {\n+                        match self.operand_ty(operand).sty {\n+                            ty::TyClosure(def_id, substs) => {\n+                                let instance = resolve_closure(\n+                                    self.tcx,\n+                                    def_id,\n+                                    substs,\n+                                    ty::ClosureKind::FnOnce,\n+                                );\n+                                let fn_ptr = self.memory.create_fn_alloc(instance);\n+                                self.write_value(\n+                                    Value::ByVal(PrimVal::Ptr(fn_ptr)),\n+                                    dest,\n+                                    dest_ty,\n+                                )?;\n+                            }\n+                            ref other => bug!(\"closure fn pointer on {:?}\", other),\n+                        }\n+                    }\n                 }\n             }\n \n@@ -862,14 +966,17 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let ptr = self.force_allocation(lval)?.to_ptr()?;\n                 let discr_val = self.read_discriminant_value(ptr, ty)?;\n                 if let ty::TyAdt(adt_def, _) = ty.sty {\n-                    if adt_def.discriminants(self.tcx).all(|v| discr_val != v.to_u128_unchecked()) {\n+                    if adt_def.discriminants(self.tcx).all(|v| {\n+                        discr_val != v.to_u128_unchecked()\n+                    })\n+                    {\n                         return err!(InvalidDiscriminant);\n                     }\n                 } else {\n                     bug!(\"rustc only generates Rvalue::Discriminant for enums\");\n                 }\n                 self.write_primval(dest, PrimVal::Bytes(discr_val), dest_ty)?;\n-            },\n+            }\n         }\n \n         if log_enabled!(::log::LogLevel::Trace) {\n@@ -903,7 +1010,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let variant = &adt_def.variants[nndiscr as usize];\n                 let index = discrfield[1];\n                 let field = &variant.fields[index as usize];\n-                (self.get_field_offset(ty, index as usize)?, field.ty(self.tcx, substs))\n+                (\n+                    self.get_field_offset(ty, index as usize)?,\n+                    field.ty(self.tcx, substs),\n+                )\n             }\n             _ => bug!(\"non-enum for StructWrappedNullablePointer: {}\", ty),\n         };\n@@ -921,16 +1031,28 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let mut packed = false;\n         for field_index in path {\n             let field_offset = self.get_field_offset(ty, field_index)?;\n-            trace!(\"field_path_offset_and_ty: {}, {}, {:?}, {:?}\", field_index, ty, field_offset, offset);\n+            trace!(\n+                \"field_path_offset_and_ty: {}, {}, {:?}, {:?}\",\n+                field_index,\n+                ty,\n+                field_offset,\n+                offset\n+            );\n             let field_ty = self.get_field_ty(ty, field_index)?;\n             ty = field_ty.ty;\n             packed = packed || field_ty.packed;\n-            offset = offset.checked_add(field_offset, &self.tcx.data_layout).unwrap();\n+            offset = offset\n+                .checked_add(field_offset, &self.tcx.data_layout)\n+                .unwrap();\n         }\n \n         Ok((offset, TyAndPacked { ty, packed }))\n     }\n-    fn get_fat_field(&self, pointee_ty: Ty<'tcx>, field_index: usize) -> EvalResult<'tcx, Ty<'tcx>> {\n+    fn get_fat_field(\n+        &self,\n+        pointee_ty: Ty<'tcx>,\n+        field_index: usize,\n+    ) -> EvalResult<'tcx, Ty<'tcx>> {\n         match (field_index, &self.tcx.struct_tail(pointee_ty).sty) {\n             (1, &ty::TyStr) |\n             (1, &ty::TySlice(_)) => Ok(self.tcx.types.usize),\n@@ -941,42 +1063,92 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     /// Returns the field type and whether the field is packed\n-    pub fn get_field_ty(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<'tcx, TyAndPacked<'tcx>> {\n+    pub fn get_field_ty(\n+        &self,\n+        ty: Ty<'tcx>,\n+        field_index: usize,\n+    ) -> EvalResult<'tcx, TyAndPacked<'tcx>> {\n         match ty.sty {\n-            ty::TyAdt(adt_def, _) if adt_def.is_box() =>\n-                Ok(TyAndPacked { ty: self.get_fat_field(ty.boxed_ty(), field_index)?, packed: false }),\n+            ty::TyAdt(adt_def, _) if adt_def.is_box() => Ok(TyAndPacked {\n+                ty: self.get_fat_field(ty.boxed_ty(), field_index)?,\n+                packed: false,\n+            }),\n             ty::TyAdt(adt_def, substs) if adt_def.is_enum() => {\n                 use rustc::ty::layout::Layout::*;\n                 match *self.type_layout(ty)? {\n-                    RawNullablePointer { nndiscr, .. } =>\n-                        Ok(TyAndPacked { ty: adt_def.variants[nndiscr as usize].fields[field_index].ty(self.tcx, substs), packed: false }),\n-                    StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n-                        let ty = adt_def.variants[nndiscr as usize].fields[field_index].ty(self.tcx, substs);\n-                        Ok(TyAndPacked { ty, packed: nonnull.packed })\n-                    },\n-                    _ => err!(Unimplemented(format!(\"get_field_ty can't handle enum type: {:?}, {:?}\", ty, ty.sty))),\n+                    RawNullablePointer { nndiscr, .. } => Ok(TyAndPacked {\n+                        ty: adt_def.variants[nndiscr as usize].fields[field_index].ty(\n+                            self.tcx,\n+                            substs,\n+                        ),\n+                        packed: false,\n+                    }),\n+                    StructWrappedNullablePointer {\n+                        nndiscr,\n+                        ref nonnull,\n+                        ..\n+                    } => {\n+                        let ty = adt_def.variants[nndiscr as usize].fields[field_index].ty(\n+                            self.tcx,\n+                            substs,\n+                        );\n+                        Ok(TyAndPacked {\n+                            ty,\n+                            packed: nonnull.packed,\n+                        })\n+                    }\n+                    _ => {\n+                        err!(Unimplemented(format!(\n+                            \"get_field_ty can't handle enum type: {:?}, {:?}\",\n+                            ty,\n+                            ty.sty\n+                        )))\n+                    }\n                 }\n             }\n             ty::TyAdt(adt_def, substs) => {\n                 let variant_def = adt_def.struct_variant();\n                 use rustc::ty::layout::Layout::*;\n                 match *self.type_layout(ty)? {\n-                    UntaggedUnion { ref variants } => \n-                        Ok(TyAndPacked { ty: variant_def.fields[field_index].ty(self.tcx, substs), packed: variants.packed }),\n-                    Univariant { ref variant, .. } =>\n-                        Ok(TyAndPacked { ty: variant_def.fields[field_index].ty(self.tcx, substs), packed: variant.packed }),\n-                    _ => err!(Unimplemented(format!(\"get_field_ty can't handle struct type: {:?}, {:?}\", ty, ty.sty))),\n+                    UntaggedUnion { ref variants } => Ok(TyAndPacked {\n+                        ty: variant_def.fields[field_index].ty(self.tcx, substs),\n+                        packed: variants.packed,\n+                    }),\n+                    Univariant { ref variant, .. } => Ok(TyAndPacked {\n+                        ty: variant_def.fields[field_index].ty(self.tcx, substs),\n+                        packed: variant.packed,\n+                    }),\n+                    _ => {\n+                        err!(Unimplemented(format!(\n+                            \"get_field_ty can't handle struct type: {:?}, {:?}\",\n+                            ty,\n+                            ty.sty\n+                        )))\n+                    }\n                 }\n             }\n \n-            ty::TyTuple(fields, _) => Ok(TyAndPacked { ty: fields[field_index], packed: false }),\n+            ty::TyTuple(fields, _) => Ok(TyAndPacked {\n+                ty: fields[field_index],\n+                packed: false,\n+            }),\n \n             ty::TyRef(_, ref tam) |\n-            ty::TyRawPtr(ref tam) => Ok(TyAndPacked { ty: self.get_fat_field(tam.ty, field_index)?, packed: false }),\n+            ty::TyRawPtr(ref tam) => Ok(TyAndPacked {\n+                ty: self.get_fat_field(tam.ty, field_index)?,\n+                packed: false,\n+            }),\n \n-            ty::TyArray(ref inner, _) => Ok(TyAndPacked { ty: inner, packed: false }),\n+            ty::TyArray(ref inner, _) => Ok(TyAndPacked {\n+                ty: inner,\n+                packed: false,\n+            }),\n \n-            _ => err!(Unimplemented(format!(\"can't handle type: {:?}, {:?}\", ty, ty.sty))),\n+            _ => {\n+                err!(Unimplemented(\n+                    format!(\"can't handle type: {:?}, {:?}\", ty, ty.sty),\n+                ))\n+            }\n         }\n     }\n \n@@ -986,19 +1158,19 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n         use rustc::ty::layout::Layout::*;\n         match *layout {\n-            Univariant { ref variant, .. } => {\n-                Ok(variant.offsets[field_index])\n-            }\n+            Univariant { ref variant, .. } => Ok(variant.offsets[field_index]),\n             FatPointer { .. } => {\n                 let bytes = field_index as u64 * self.memory.pointer_size();\n                 Ok(Size::from_bytes(bytes))\n             }\n-            StructWrappedNullablePointer { ref nonnull, .. } => {\n-                Ok(nonnull.offsets[field_index])\n-            }\n+            StructWrappedNullablePointer { ref nonnull, .. } => Ok(nonnull.offsets[field_index]),\n             UntaggedUnion { .. } => Ok(Size::from_bytes(0)),\n             _ => {\n-                let msg = format!(\"get_field_offset: can't handle type: {:?}, with layout: {:?}\", ty, layout);\n+                let msg = format!(\n+                    \"get_field_offset: can't handle type: {:?}, with layout: {:?}\",\n+                    ty,\n+                    layout\n+                );\n                 err!(Unimplemented(msg))\n             }\n         }\n@@ -1012,18 +1184,25 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             Univariant { ref variant, .. } => Ok(variant.offsets.len() as u64),\n             FatPointer { .. } => Ok(2),\n             StructWrappedNullablePointer { ref nonnull, .. } => Ok(nonnull.offsets.len() as u64),\n-            Vector { count , .. } |\n+            Vector { count, .. } |\n             Array { count, .. } => Ok(count),\n             Scalar { .. } => Ok(0),\n             UntaggedUnion { .. } => Ok(1),\n             _ => {\n-                let msg = format!(\"get_field_count: can't handle type: {:?}, with layout: {:?}\", ty, layout);\n+                let msg = format!(\n+                    \"get_field_count: can't handle type: {:?}, with layout: {:?}\",\n+                    ty,\n+                    layout\n+                );\n                 err!(Unimplemented(msg))\n             }\n         }\n     }\n \n-    pub(super) fn eval_operand_to_primval(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+    pub(super) fn eval_operand_to_primval(\n+        &mut self,\n+        op: &mir::Operand<'tcx>,\n+    ) -> EvalResult<'tcx, PrimVal> {\n         let value = self.eval_operand(op)?;\n         let ty = self.operand_ty(op);\n         self.value_to_primval(value, ty)\n@@ -1042,7 +1221,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n                     Literal::Item { def_id, substs } => {\n                         let instance = self.resolve_associated_const(def_id, substs);\n-                        let cid = GlobalId { instance, promoted: None };\n+                        let cid = GlobalId {\n+                            instance,\n+                            promoted: None,\n+                        };\n                         Value::ByRef(*self.globals.get(&cid).expect(\"static/const not cached\"))\n                     }\n \n@@ -1069,7 +1251,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     fn copy(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx> {\n-        let size = self.type_size(ty)?.expect(\"cannot copy from an unsized type\");\n+        let size = self.type_size(ty)?.expect(\n+            \"cannot copy from an unsized type\",\n+        );\n         let align = self.type_align(ty)?;\n         self.memory.copy(src, dest, size, align, false)?;\n         Ok(())\n@@ -1090,24 +1274,25 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         })\n     }\n \n-    pub fn force_allocation(\n-        &mut self,\n-        lvalue: Lvalue,\n-    ) -> EvalResult<'tcx, Lvalue> {\n+    pub fn force_allocation(&mut self, lvalue: Lvalue) -> EvalResult<'tcx, Lvalue> {\n         let new_lvalue = match lvalue {\n             Lvalue::Local { frame, local } => {\n                 // -1 since we don't store the return value\n                 match self.stack[frame].locals[local.index() - 1] {\n                     None => return err!(DeadLocal),\n                     Some(Value::ByRef(ptr)) => {\n-                        Lvalue::Ptr { ptr, extra: LvalueExtra::None }\n-                    },\n+                        Lvalue::Ptr {\n+                            ptr,\n+                            extra: LvalueExtra::None,\n+                        }\n+                    }\n                     Some(val) => {\n                         let ty = self.stack[frame].mir.local_decls[local].ty;\n                         let ty = self.monomorphize(ty, self.stack[frame].instance.substs);\n                         let substs = self.stack[frame].instance.substs;\n                         let ptr = self.alloc_ptr_with_substs(ty, substs)?;\n-                        self.stack[frame].locals[local.index() - 1] = Some(Value::by_ref(ptr.into())); // it stays live\n+                        self.stack[frame].locals[local.index() - 1] =\n+                            Some(Value::by_ref(ptr.into())); // it stays live\n                         self.write_value_to_ptr(val, ptr.into(), ty)?;\n                         Lvalue::from_ptr(ptr)\n                     }\n@@ -1119,7 +1304,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     /// ensures this Value is not a ByRef\n-    pub(super) fn follow_by_ref_value(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub(super) fn follow_by_ref_value(\n+        &mut self,\n+        value: Value,\n+        ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Value> {\n         match value {\n             Value::ByRef(PtrAndAlign { ptr, aligned }) => {\n                 self.read_maybe_aligned(aligned, |ectx| ectx.read_value(ptr, ty))\n@@ -1130,7 +1319,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     pub fn value_to_primval(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         match self.follow_by_ref_value(value, ty)? {\n-            Value::ByRef{..} => bug!(\"follow_by_ref_value can't result in `ByRef`\"),\n+            Value::ByRef { .. } => bug!(\"follow_by_ref_value can't result in `ByRef`\"),\n \n             Value::ByVal(primval) => {\n                 self.ensure_valid_value(primval, ty)?;\n@@ -1141,20 +1330,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n     }\n \n-    pub fn write_null(\n-        &mut self,\n-        dest: Lvalue,\n-        dest_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx> {\n+    pub fn write_null(&mut self, dest: Lvalue, dest_ty: Ty<'tcx>) -> EvalResult<'tcx> {\n         self.write_primval(dest, PrimVal::Bytes(0), dest_ty)\n     }\n \n-    pub fn write_ptr(\n-        &mut self,\n-        dest: Lvalue,\n-        val: Pointer,\n-        dest_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx> {\n+    pub fn write_ptr(&mut self, dest: Lvalue, val: Pointer, dest_ty: Ty<'tcx>) -> EvalResult<'tcx> {\n         self.write_value(val.to_value(), dest, dest_ty)\n     }\n \n@@ -1179,10 +1359,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         // correct if we never look at this data with the wrong type.\n \n         match dest {\n-            Lvalue::Ptr { ptr: PtrAndAlign { ptr, aligned }, extra } => {\n+            Lvalue::Ptr {\n+                ptr: PtrAndAlign { ptr, aligned },\n+                extra,\n+            } => {\n                 assert_eq!(extra, LvalueExtra::None);\n-                self.write_maybe_aligned_mut(aligned,\n-                    |ectx| ectx.write_value_to_ptr(src_val, ptr, dest_ty))\n+                self.write_maybe_aligned_mut(\n+                    aligned,\n+                    |ectx| ectx.write_value_to_ptr(src_val, ptr, dest_ty),\n+                )\n             }\n \n             Lvalue::Local { frame, local } => {\n@@ -1205,18 +1390,27 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         old_dest_val: Value,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        if let Value::ByRef(PtrAndAlign { ptr: dest_ptr, aligned }) = old_dest_val {\n+        if let Value::ByRef(PtrAndAlign {\n+                                ptr: dest_ptr,\n+                                aligned,\n+                            }) = old_dest_val\n+        {\n             // If the value is already `ByRef` (that is, backed by an `Allocation`),\n             // then we must write the new value into this allocation, because there may be\n             // other pointers into the allocation. These other pointers are logically\n             // pointers into the local variable, and must be able to observe the change.\n             //\n             // Thus, it would be an error to replace the `ByRef` with a `ByVal`, unless we\n             // knew for certain that there were no outstanding pointers to this allocation.\n-            self.write_maybe_aligned_mut(aligned,\n-                |ectx| ectx.write_value_to_ptr(src_val, dest_ptr, dest_ty))?;\n+            self.write_maybe_aligned_mut(aligned, |ectx| {\n+                ectx.write_value_to_ptr(src_val, dest_ptr, dest_ty)\n+            })?;\n \n-        } else if let Value::ByRef(PtrAndAlign { ptr: src_ptr, aligned }) = src_val {\n+        } else if let Value::ByRef(PtrAndAlign {\n+                                       ptr: src_ptr,\n+                                       aligned,\n+                                   }) = src_val\n+        {\n             // If the value is not `ByRef`, then we know there are no pointers to it\n             // and we can simply overwrite the `Value` in the locals array directly.\n             //\n@@ -1256,7 +1450,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         match value {\n             Value::ByRef(PtrAndAlign { ptr, aligned }) => {\n                 self.read_maybe_aligned_mut(aligned, |ectx| ectx.copy(ptr, dest, dest_ty))\n-            },\n+            }\n             Value::ByVal(primval) => {\n                 let size = self.type_size(dest_ty)?.expect(\"dest type must be sized\");\n                 self.memory.write_primval(dest, primval, size)\n@@ -1270,7 +1464,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         a: PrimVal,\n         b: PrimVal,\n         ptr: MemoryPointer,\n-        mut ty: Ty<'tcx>\n+        mut ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         let mut packed = false;\n         while self.get_field_count(ty)? == 1 {\n@@ -1283,16 +1477,26 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let field_1 = self.get_field_offset(ty, 1)?;\n         let field_0_ty = self.get_field_ty(ty, 0)?;\n         let field_1_ty = self.get_field_ty(ty, 1)?;\n-        assert_eq!(field_0_ty.packed, field_1_ty.packed, \"the two fields must agree on being packed\");\n+        assert_eq!(\n+            field_0_ty.packed,\n+            field_1_ty.packed,\n+            \"the two fields must agree on being packed\"\n+        );\n         packed = packed || field_0_ty.packed;\n-        let field_0_size = self.type_size(field_0_ty.ty)?.expect(\"pair element type must be sized\");\n-        let field_1_size = self.type_size(field_1_ty.ty)?.expect(\"pair element type must be sized\");\n+        let field_0_size = self.type_size(field_0_ty.ty)?.expect(\n+            \"pair element type must be sized\",\n+        );\n+        let field_1_size = self.type_size(field_1_ty.ty)?.expect(\n+            \"pair element type must be sized\",\n+        );\n         let field_0_ptr = ptr.offset(field_0.bytes(), &self)?.into();\n         let field_1_ptr = ptr.offset(field_1.bytes(), &self)?.into();\n-        self.write_maybe_aligned_mut(!packed,\n-            |ectx| ectx.memory.write_primval(field_0_ptr, a, field_0_size))?;\n-        self.write_maybe_aligned_mut(!packed,\n-            |ectx| ectx.memory.write_primval(field_1_ptr, b, field_1_size))?;\n+        self.write_maybe_aligned_mut(!packed, |ectx| {\n+            ectx.memory.write_primval(field_0_ptr, a, field_0_size)\n+        })?;\n+        self.write_maybe_aligned_mut(!packed, |ectx| {\n+            ectx.memory.write_primval(field_1_ptr, b, field_1_size)\n+        })?;\n         Ok(())\n     }\n \n@@ -1388,8 +1592,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         match ty.sty {\n             ty::TyBool if val.to_bytes()? > 1 => err!(InvalidBool),\n \n-            ty::TyChar if ::std::char::from_u32(val.to_bytes()? as u32).is_none()\n-                => err!(InvalidChar(val.to_bytes()? as u32 as u128)),\n+            ty::TyChar if ::std::char::from_u32(val.to_bytes()? as u32).is_none() => {\n+                err!(InvalidChar(val.to_bytes()? as u32 as u128))\n+            }\n \n             _ => Ok(()),\n         }\n@@ -1403,17 +1608,24 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n     }\n \n-    pub(crate) fn read_ptr(&self, ptr: MemoryPointer, pointee_ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub(crate) fn read_ptr(\n+        &self,\n+        ptr: MemoryPointer,\n+        pointee_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Value> {\n         let p = self.memory.read_ptr(ptr)?;\n         if self.type_is_sized(pointee_ty) {\n             Ok(p.to_value())\n         } else {\n             trace!(\"reading fat pointer extra of type {}\", pointee_ty);\n             let extra = ptr.offset(self.memory.pointer_size(), self)?;\n             match self.tcx.struct_tail(pointee_ty).sty {\n-                ty::TyDynamic(..) => Ok(p.to_value_with_vtable(self.memory.read_ptr(extra)?.to_ptr()?)),\n-                ty::TySlice(..) |\n-                ty::TyStr => Ok(p.to_value_with_len(self.memory.read_usize(extra)?)),\n+                ty::TyDynamic(..) => Ok(p.to_value_with_vtable(\n+                    self.memory.read_ptr(extra)?.to_ptr()?,\n+                )),\n+                ty::TySlice(..) | ty::TyStr => Ok(\n+                    p.to_value_with_len(self.memory.read_usize(extra)?),\n+                ),\n                 _ => bug!(\"unsized primval ptr read from {:?}\", pointee_ty),\n             }\n         }\n@@ -1466,7 +1678,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 // if we transmute a ptr to an usize, reading it back into a primval shouldn't panic\n                 // for consistency's sake, we use the same code as above\n                 match self.memory.read_uint(ptr.to_ptr()?, size) {\n-                    Err(EvalError { kind: EvalErrorKind::ReadPointerAsBytes, .. }) if size == self.memory.pointer_size() => self.memory.read_ptr(ptr.to_ptr()?)?.into_inner_primval(),\n+                    Err(EvalError { kind: EvalErrorKind::ReadPointerAsBytes, .. })\n+                        if size == self.memory.pointer_size() => {\n+                        self.memory.read_ptr(ptr.to_ptr()?)?.into_inner_primval()\n+                    }\n                     other => PrimVal::from_u128(other?),\n                 }\n             }\n@@ -1493,7 +1708,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 } else {\n                     return Ok(None);\n                 }\n-            },\n+            }\n \n             _ => return Ok(None),\n         };\n@@ -1540,14 +1755,17 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 // traits, and hence never actually require an actual\n                 // change to the vtable.\n                 self.write_value(src, dest, dest_ty)\n-            },\n+            }\n             (_, &ty::TyDynamic(ref data, _)) => {\n-                let trait_ref = data.principal().unwrap().with_self_ty(self.tcx, src_pointee_ty);\n+                let trait_ref = data.principal().unwrap().with_self_ty(\n+                    self.tcx,\n+                    src_pointee_ty,\n+                );\n                 let trait_ref = self.tcx.erase_regions(&trait_ref);\n                 let vtable = self.get_vtable(src_pointee_ty, trait_ref)?;\n                 let ptr = src.into_ptr(&self.memory)?;\n                 self.write_value(ptr.to_value_with_vtable(vtable), dest, dest_ty)\n-            },\n+            }\n \n             _ => bug!(\"invalid unsizing {:?} -> {:?}\", src_ty, dest_ty),\n         }\n@@ -1563,13 +1781,22 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         match (&src_ty.sty, &dest_ty.sty) {\n             (&ty::TyRef(_, ref s), &ty::TyRef(_, ref d)) |\n             (&ty::TyRef(_, ref s), &ty::TyRawPtr(ref d)) |\n-            (&ty::TyRawPtr(ref s), &ty::TyRawPtr(ref d)) => self.unsize_into_ptr(src, src_ty, dest, dest_ty, s.ty, d.ty),\n+            (&ty::TyRawPtr(ref s), &ty::TyRawPtr(ref d)) => {\n+                self.unsize_into_ptr(src, src_ty, dest, dest_ty, s.ty, d.ty)\n+            }\n             (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b)) => {\n                 if def_a.is_box() || def_b.is_box() {\n                     if !def_a.is_box() || !def_b.is_box() {\n                         panic!(\"invalid unsizing between {:?} -> {:?}\", src_ty, dest_ty);\n                     }\n-                    return self.unsize_into_ptr(src, src_ty, dest, dest_ty, src_ty.boxed_ty(), dest_ty.boxed_ty());\n+                    return self.unsize_into_ptr(\n+                        src,\n+                        src_ty,\n+                        dest,\n+                        dest_ty,\n+                        src_ty.boxed_ty(),\n+                        dest_ty.boxed_ty(),\n+                    );\n                 }\n                 if self.ty_to_primval_kind(src_ty).is_ok() {\n                     // TODO: We ignore the packed flag here\n@@ -1610,12 +1837,23 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     if src_fty == dst_fty {\n                         self.copy(src_f_ptr, dst_f_ptr.into(), src_fty)?;\n                     } else {\n-                        self.unsize_into(Value::by_ref(src_f_ptr), src_fty, Lvalue::from_ptr(dst_f_ptr), dst_fty)?;\n+                        self.unsize_into(\n+                            Value::by_ref(src_f_ptr),\n+                            src_fty,\n+                            Lvalue::from_ptr(dst_f_ptr),\n+                            dst_fty,\n+                        )?;\n                     }\n                 }\n                 Ok(())\n             }\n-            _ => bug!(\"unsize_into: invalid conversion: {:?} -> {:?}\", src_ty, dest_ty),\n+            _ => {\n+                bug!(\n+                    \"unsize_into: invalid conversion: {:?} -> {:?}\",\n+                    src_ty,\n+                    dest_ty\n+                )\n+            }\n         }\n     }\n \n@@ -1631,27 +1869,36 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 write!(msg, \":\").unwrap();\n \n                 match self.stack[frame].get_local(local) {\n-                    Err(EvalError{ kind: EvalErrorKind::DeadLocal, ..} ) => {\n+                    Err(EvalError { kind: EvalErrorKind::DeadLocal, .. }) => {\n                         write!(msg, \" is dead\").unwrap();\n                     }\n                     Err(err) => {\n                         panic!(\"Failed to access local: {:?}\", err);\n                     }\n-                    Ok(Value::ByRef(PtrAndAlign{ ptr, aligned })) => match ptr.into_inner_primval() {\n-                        PrimVal::Ptr(ptr) => {\n-                            write!(msg, \" by {}ref:\", if aligned { \"\" } else { \"unaligned \" }).unwrap();\n-                            allocs.push(ptr.alloc_id);\n-                        },\n-                        ptr => write!(msg, \" integral by ref: {:?}\", ptr).unwrap(),\n-                    },\n+                    Ok(Value::ByRef(PtrAndAlign { ptr, aligned })) => {\n+                        match ptr.into_inner_primval() {\n+                            PrimVal::Ptr(ptr) => {\n+                                write!(msg, \" by {}ref:\", if aligned { \"\" } else { \"unaligned \" })\n+                                    .unwrap();\n+                                allocs.push(ptr.alloc_id);\n+                            }\n+                            ptr => write!(msg, \" integral by ref: {:?}\", ptr).unwrap(),\n+                        }\n+                    }\n                     Ok(Value::ByVal(val)) => {\n                         write!(msg, \" {:?}\", val).unwrap();\n-                        if let PrimVal::Ptr(ptr) = val { allocs.push(ptr.alloc_id); }\n+                        if let PrimVal::Ptr(ptr) = val {\n+                            allocs.push(ptr.alloc_id);\n+                        }\n                     }\n                     Ok(Value::ByValPair(val1, val2)) => {\n                         write!(msg, \" ({:?}, {:?})\", val1, val2).unwrap();\n-                        if let PrimVal::Ptr(ptr) = val1 { allocs.push(ptr.alloc_id); }\n-                        if let PrimVal::Ptr(ptr) = val2 { allocs.push(ptr.alloc_id); }\n+                        if let PrimVal::Ptr(ptr) = val1 {\n+                            allocs.push(ptr.alloc_id);\n+                        }\n+                        if let PrimVal::Ptr(ptr) = val2 {\n+                            allocs.push(ptr.alloc_id);\n+                        }\n                     }\n                 }\n \n@@ -1663,21 +1910,17 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     PrimVal::Ptr(ptr) => {\n                         trace!(\"by {}ref:\", if aligned { \"\" } else { \"unaligned \" });\n                         self.memory.dump_alloc(ptr.alloc_id);\n-                    },\n+                    }\n                     ptr => trace!(\" integral by ref: {:?}\", ptr),\n                 }\n             }\n         }\n     }\n \n     /// Convenience function to ensure correct usage of locals\n-    pub fn modify_local<F>(\n-        &mut self,\n-        frame: usize,\n-        local: mir::Local,\n-        f: F,\n-    ) -> EvalResult<'tcx>\n-        where F: FnOnce(&mut Self, Value) -> EvalResult<'tcx, Value>,\n+    pub fn modify_local<F>(&mut self, frame: usize, local: mir::Local, f: F) -> EvalResult<'tcx>\n+    where\n+        F: FnOnce(&mut Self, Value) -> EvalResult<'tcx, Value>,\n     {\n         let val = self.stack[frame].get_local(local)?;\n         let new_val = f(self, val)?;\n@@ -1704,7 +1947,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                             break 'frames;\n                         } else if name.starts_with(\"backtrace::capture::Backtrace::new\")\n                             // debug mode produces funky symbol names\n-                            || name.starts_with(\"backtrace::capture::{{impl}}::new\") {\n+                            || name.starts_with(\"backtrace::capture::{{impl}}::new\")\n+                        {\n                             // don't report backtrace internals\n                             skip_init = false;\n                             continue 'frames;\n@@ -1715,7 +1959,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     continue;\n                 }\n                 for symbol in frame.symbols() {\n-                    write!(trace_text, \"{}: \" , i).unwrap();\n+                    write!(trace_text, \"{}: \", i).unwrap();\n                     if let Some(name) = symbol.name() {\n                         write!(trace_text, \"{}\\n\", name).unwrap();\n                     } else {\n@@ -1745,7 +1989,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             };\n             let mut err = self.tcx.sess.struct_span_err(span, &e.to_string());\n             for &Frame { instance, span, .. } in self.stack().iter().rev() {\n-                if self.tcx.def_key(instance.def_id()).disambiguated_data.data == DefPathData::ClosureExpr {\n+                if self.tcx.def_key(instance.def_id()).disambiguated_data.data ==\n+                    DefPathData::ClosureExpr\n+                {\n                     err.span_note(span, \"inside call to closure\");\n                     continue;\n                 }\n@@ -1817,7 +2063,7 @@ pub fn is_inhabited<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) ->\n }\n \n /// FIXME: expose trans::monomorphize::resolve_closure\n-pub fn resolve_closure<'a, 'tcx> (\n+pub fn resolve_closure<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n     substs: ty::ClosureSubsts<'tcx>,\n@@ -1826,7 +2072,7 @@ pub fn resolve_closure<'a, 'tcx> (\n     let actual_kind = tcx.closure_kind(def_id);\n     match needs_fn_once_adapter_shim(actual_kind, requested_kind) {\n         Ok(true) => fn_once_adapter_instance(tcx, def_id, substs),\n-        _ => ty::Instance::new(def_id, substs.substs)\n+        _ => ty::Instance::new(def_id, substs.substs),\n     }\n }\n \n@@ -1835,40 +2081,39 @@ fn fn_once_adapter_instance<'a, 'tcx>(\n     closure_did: DefId,\n     substs: ty::ClosureSubsts<'tcx>,\n ) -> ty::Instance<'tcx> {\n-    debug!(\"fn_once_adapter_shim({:?}, {:?})\",\n-           closure_did,\n-           substs);\n+    debug!(\"fn_once_adapter_shim({:?}, {:?})\", closure_did, substs);\n     let fn_once = tcx.lang_items.fn_once_trait().unwrap();\n     let call_once = tcx.associated_items(fn_once)\n         .find(|it| it.kind == ty::AssociatedKind::Method)\n-        .unwrap().def_id;\n+        .unwrap()\n+        .def_id;\n     let def = ty::InstanceDef::ClosureOnceShim { call_once };\n \n-    let self_ty = tcx.mk_closure_from_closure_substs(\n-        closure_did, substs);\n+    let self_ty = tcx.mk_closure_from_closure_substs(closure_did, substs);\n \n     let sig = tcx.fn_sig(closure_did).subst(tcx, substs.substs);\n     let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n     assert_eq!(sig.inputs().len(), 1);\n-    let substs = tcx.mk_substs([\n-        Kind::from(self_ty),\n-        Kind::from(sig.inputs()[0]),\n-    ].iter().cloned());\n+    let substs = tcx.mk_substs(\n+        [Kind::from(self_ty), Kind::from(sig.inputs()[0])]\n+            .iter()\n+            .cloned(),\n+    );\n \n     debug!(\"fn_once_adapter_shim: self_ty={:?} sig={:?}\", self_ty, sig);\n     ty::Instance { def, substs }\n }\n \n-fn needs_fn_once_adapter_shim(actual_closure_kind: ty::ClosureKind,\n-                              trait_closure_kind: ty::ClosureKind)\n-                              -> Result<bool, ()>\n-{\n+fn needs_fn_once_adapter_shim(\n+    actual_closure_kind: ty::ClosureKind,\n+    trait_closure_kind: ty::ClosureKind,\n+) -> Result<bool, ()> {\n     match (actual_closure_kind, trait_closure_kind) {\n         (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n         (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n         (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) => {\n             // No adapter needed.\n-           Ok(false)\n+            Ok(false)\n         }\n         (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {\n             // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n@@ -1897,23 +2142,21 @@ fn needs_fn_once_adapter_shim(actual_closure_kind: ty::ClosureKind,\n pub fn resolve<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n-    substs: &'tcx Substs<'tcx>\n+    substs: &'tcx Substs<'tcx>,\n ) -> ty::Instance<'tcx> {\n-    debug!(\"resolve(def_id={:?}, substs={:?})\",\n-           def_id, substs);\n+    debug!(\"resolve(def_id={:?}, substs={:?})\", def_id, substs);\n     let result = if let Some(trait_def_id) = tcx.trait_of_item(def_id) {\n         debug!(\" => associated item, attempting to find impl\");\n         let item = tcx.associated_item(def_id);\n         resolve_associated_item(tcx, &item, trait_def_id, substs)\n     } else {\n         let item_type = def_ty(tcx, def_id, substs);\n         let def = match item_type.sty {\n-            ty::TyFnDef(..) if {\n-                    let f = item_type.fn_sig(tcx);\n-                    f.abi() == Abi::RustIntrinsic ||\n-                    f.abi() == Abi::PlatformIntrinsic\n-                } =>\n-            {\n+            ty::TyFnDef(..)\n+                if {\n+                       let f = item_type.fn_sig(tcx);\n+                       f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic\n+                   } => {\n                 debug!(\" => intrinsic\");\n                 ty::InstanceDef::Intrinsic(def_id)\n             }\n@@ -1935,8 +2178,12 @@ pub fn resolve<'a, 'tcx>(\n         };\n         ty::Instance { def, substs }\n     };\n-    debug!(\"resolve(def_id={:?}, substs={:?}) = {}\",\n-           def_id, substs, result);\n+    debug!(\n+        \"resolve(def_id={:?}, substs={:?}) = {}\",\n+        def_id,\n+        substs,\n+        result\n+    );\n     result\n }\n \n@@ -1969,21 +2216,25 @@ pub fn needs_drop_glue<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, t: Ty<'tcx>) -> bo\n                 true\n             }\n         }\n-        _ => true\n+        _ => true,\n     }\n }\n \n fn resolve_associated_item<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     trait_item: &ty::AssociatedItem,\n     trait_id: DefId,\n-    rcvr_substs: &'tcx Substs<'tcx>\n+    rcvr_substs: &'tcx Substs<'tcx>,\n ) -> ty::Instance<'tcx> {\n     let def_id = trait_item.def_id;\n-    debug!(\"resolve_associated_item(trait_item={:?}, \\\n+    debug!(\n+        \"resolve_associated_item(trait_item={:?}, \\\n                                     trait_id={:?}, \\\n                                     rcvr_substs={:?})\",\n-           def_id, trait_id, rcvr_substs);\n+        def_id,\n+        trait_id,\n+        rcvr_substs\n+    );\n \n     let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n     let vtbl = fulfill_obligation(tcx, DUMMY_SP, ty::Binder(trait_ref));\n@@ -1992,56 +2243,64 @@ fn resolve_associated_item<'a, 'tcx>(\n     // the actual function:\n     match vtbl {\n         ::rustc::traits::VtableImpl(impl_data) => {\n-            let (def_id, substs) = ::rustc::traits::find_associated_item(\n-                tcx, trait_item, rcvr_substs, &impl_data);\n+            let (def_id, substs) =\n+                ::rustc::traits::find_associated_item(tcx, trait_item, rcvr_substs, &impl_data);\n             let substs = tcx.erase_regions(&substs);\n             ty::Instance::new(def_id, substs)\n         }\n         ::rustc::traits::VtableClosure(closure_data) => {\n             let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n-            resolve_closure(tcx, closure_data.closure_def_id, closure_data.substs,\n-                            trait_closure_kind)\n+            resolve_closure(\n+                tcx,\n+                closure_data.closure_def_id,\n+                closure_data.substs,\n+                trait_closure_kind,\n+            )\n         }\n         ::rustc::traits::VtableFnPointer(ref data) => {\n             ty::Instance {\n                 def: ty::InstanceDef::FnPtrShim(trait_item.def_id, data.fn_ty),\n-                substs: rcvr_substs\n+                substs: rcvr_substs,\n             }\n         }\n         ::rustc::traits::VtableObject(ref data) => {\n             let index = tcx.get_vtable_index_of_object_method(data, def_id);\n             ty::Instance {\n                 def: ty::InstanceDef::Virtual(def_id, index),\n-                substs: rcvr_substs\n+                substs: rcvr_substs,\n             }\n         }\n-        _ => {\n-            bug!(\"static call to invalid vtable: {:?}\", vtbl)\n-        }\n+        _ => bug!(\"static call to invalid vtable: {:?}\", vtbl),\n     }\n }\n \n-pub fn def_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        def_id: DefId,\n-                        substs: &'tcx Substs<'tcx>)\n-                        -> Ty<'tcx>\n-{\n+pub fn def_ty<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+    substs: &'tcx Substs<'tcx>,\n+) -> Ty<'tcx> {\n     let ty = tcx.type_of(def_id);\n     apply_param_substs(tcx, substs, &ty)\n }\n \n /// Monomorphizes a type from the AST by first applying the in-scope\n /// substitutions and then normalizing any associated types.\n-pub fn apply_param_substs<'a, 'tcx, T>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       param_substs: &Substs<'tcx>,\n-                                       value: &T)\n-                                       -> T\n-    where T: ::rustc::infer::TransNormalize<'tcx>\n+pub fn apply_param_substs<'a, 'tcx, T>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    param_substs: &Substs<'tcx>,\n+    value: &T,\n+) -> T\n+where\n+    T: ::rustc::infer::TransNormalize<'tcx>,\n {\n-    debug!(\"apply_param_substs(param_substs={:?}, value={:?})\", param_substs, value);\n+    debug!(\n+        \"apply_param_substs(param_substs={:?}, value={:?})\",\n+        param_substs,\n+        value\n+    );\n     let substituted = value.subst(tcx, param_substs);\n     let substituted = tcx.erase_regions(&substituted);\n-    AssociatedTypeNormalizer{ tcx }.fold(&substituted)\n+    AssociatedTypeNormalizer { tcx }.fold(&substituted)\n }\n \n \n@@ -2082,27 +2341,31 @@ fn type_is_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n /// Attempts to resolve an obligation. The result is a shallow vtable resolution -- meaning that we\n /// do not (necessarily) resolve all nested obligations on the impl. Note that type check should\n /// guarantee to us that all nested obligations *could be* resolved if we wanted to.\n-fn fulfill_obligation<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                span: Span,\n-                                trait_ref: ty::PolyTraitRef<'tcx>)\n-                                -> traits::Vtable<'tcx, ()>\n-{\n+fn fulfill_obligation<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    span: Span,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> traits::Vtable<'tcx, ()> {\n     // Remove any references to regions; this helps improve caching.\n     let trait_ref = tcx.erase_regions(&trait_ref);\n \n-    debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n-            trait_ref, trait_ref.def_id());\n+    debug!(\n+        \"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n+        trait_ref,\n+        trait_ref.def_id()\n+    );\n \n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n     tcx.infer_ctxt().enter(|infcx| {\n         let mut selcx = traits::SelectionContext::new(&infcx);\n \n-        let obligation_cause = traits::ObligationCause::misc(span,\n-                                                            ast::DUMMY_NODE_ID);\n-        let obligation = traits::Obligation::new(obligation_cause,\n-                                                 ty::ParamEnv::empty(Reveal::All),\n-                                                 trait_ref.to_poly_trait_predicate());\n+        let obligation_cause = traits::ObligationCause::misc(span, ast::DUMMY_NODE_ID);\n+        let obligation = traits::Obligation::new(\n+            obligation_cause,\n+            ty::ParamEnv::empty(Reveal::All),\n+            trait_ref.to_poly_trait_predicate(),\n+        );\n \n         let selection = match selcx.select(&obligation) {\n             Ok(Some(selection)) => selection,\n@@ -2113,16 +2376,24 @@ fn fulfill_obligation<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 // leading to an ambiguous result. So report this as an\n                 // overflow bug, since I believe this is the only case\n                 // where ambiguity can result.\n-                debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n+                debug!(\n+                    \"Encountered ambiguity selecting `{:?}` during trans, \\\n                         presuming due to overflow\",\n-                        trait_ref);\n-                tcx.sess.span_fatal(span,\n+                    trait_ref\n+                );\n+                tcx.sess.span_fatal(\n+                    span,\n                     \"reached the recursion limit during monomorphization \\\n-                        (selection ambiguity)\");\n+                        (selection ambiguity)\",\n+                );\n             }\n             Err(e) => {\n-                span_bug!(span, \"Encountered error `{:?}` selecting `{:?}` during trans\",\n-                            e, trait_ref)\n+                span_bug!(\n+                    span,\n+                    \"Encountered error `{:?}` selecting `{:?}` during trans\",\n+                    e,\n+                    trait_ref\n+                )\n             }\n         };\n \n@@ -2133,7 +2404,10 @@ fn fulfill_obligation<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // inference of the impl's type parameters.\n         let mut fulfill_cx = traits::FulfillmentContext::new();\n         let vtable = selection.map(|predicate| {\n-            debug!(\"fulfill_obligation: register_predicate_obligation {:?}\", predicate);\n+            debug!(\n+                \"fulfill_obligation: register_predicate_obligation {:?}\",\n+                predicate\n+            );\n             fulfill_cx.register_predicate_obligation(&infcx, predicate);\n         });\n         let vtable = infcx.drain_fulfillment_cx_or_panic(span, &mut fulfill_cx, &vtable);\n@@ -2146,8 +2420,7 @@ fn fulfill_obligation<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub fn resolve_drop_in_place<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ty: Ty<'tcx>,\n-) -> ty::Instance<'tcx>\n-{\n+) -> ty::Instance<'tcx> {\n     let def_id = tcx.require_lang_item(::rustc::middle::lang_items::DropInPlaceFnLangItem);\n     let substs = tcx.intern_substs(&[Kind::from(ty)]);\n     resolve(tcx, def_id, substs)"}, {"sha": "86479acd2a4cd83745beff1ce688ee240ec5f3f1", "filename": "src/librustc_mir/interpret/lvalue.rs", "status": "modified", "additions": 126, "deletions": 59, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -3,14 +3,7 @@ use rustc::ty::layout::{Size, Align};\n use rustc::ty::{self, Ty};\n use rustc_data_structures::indexed_vec::Idx;\n \n-use super::{\n-    EvalResult,\n-    EvalContext,\n-    MemoryPointer,\n-    PrimVal, Value, Pointer,\n-    Machine,\n-    PtrAndAlign,\n-};\n+use super::{EvalResult, EvalContext, MemoryPointer, PrimVal, Value, Pointer, Machine, PtrAndAlign};\n \n #[derive(Copy, Clone, Debug)]\n pub enum Lvalue {\n@@ -25,10 +18,7 @@ pub enum Lvalue {\n \n     /// An lvalue referring to a value on the stack. Represented by a stack frame index paired with\n     /// a Mir local index.\n-    Local {\n-        frame: usize,\n-        local: mir::Local,\n-    },\n+    Local { frame: usize, local: mir::Local },\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -57,7 +47,10 @@ impl<'tcx> Lvalue {\n     }\n \n     pub fn from_primval_ptr(ptr: Pointer) -> Self {\n-        Lvalue::Ptr { ptr: PtrAndAlign { ptr, aligned: true }, extra: LvalueExtra::None }\n+        Lvalue::Ptr {\n+            ptr: PtrAndAlign { ptr, aligned: true },\n+            extra: LvalueExtra::None,\n+        }\n     }\n \n     pub fn from_ptr(ptr: MemoryPointer) -> Self {\n@@ -87,7 +80,12 @@ impl<'tcx> Lvalue {\n             ty::TySlice(elem) => {\n                 match self {\n                     Lvalue::Ptr { extra: LvalueExtra::Length(len), .. } => (elem, len),\n-                    _ => bug!(\"elem_ty_and_len of a TySlice given non-slice lvalue: {:?}\", self),\n+                    _ => {\n+                        bug!(\n+                            \"elem_ty_and_len of a TySlice given non-slice lvalue: {:?}\",\n+                            self\n+                        )\n+                    }\n                 }\n             }\n \n@@ -99,7 +97,10 @@ impl<'tcx> Lvalue {\n impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     /// Reads a value from the lvalue without going through the intermediate step of obtaining\n     /// a `miri::Lvalue`\n-    pub fn try_read_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n+    pub fn try_read_lvalue(\n+        &mut self,\n+        lvalue: &mir::Lvalue<'tcx>,\n+    ) -> EvalResult<'tcx, Option<Value>> {\n         use rustc::mir::Lvalue::*;\n         match *lvalue {\n             // Might allow this in the future, right now there's no way to do this from Rust code anyway\n@@ -109,14 +110,22 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             // Directly reading a static will always succeed\n             Static(ref static_) => {\n                 let instance = ty::Instance::mono(self.tcx, static_.def_id);\n-                let cid = GlobalId { instance, promoted: None };\n-                Ok(Some(Value::ByRef(*self.globals.get(&cid).expect(\"global not cached\"))))\n-            },\n+                let cid = GlobalId {\n+                    instance,\n+                    promoted: None,\n+                };\n+                Ok(Some(Value::ByRef(\n+                    *self.globals.get(&cid).expect(\"global not cached\"),\n+                )))\n+            }\n             Projection(ref proj) => self.try_read_lvalue_projection(proj),\n         }\n     }\n \n-    fn try_read_lvalue_projection(&mut self, proj: &mir::LvalueProjection<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n+    fn try_read_lvalue_projection(\n+        &mut self,\n+        proj: &mir::LvalueProjection<'tcx>,\n+    ) -> EvalResult<'tcx, Option<Value>> {\n         use rustc::mir::ProjectionElem::*;\n         let base = match self.try_read_lvalue(&proj.base)? {\n             Some(base) => base,\n@@ -147,7 +156,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     /// Returns a value and (in case of a ByRef) if we are supposed to use aligned accesses.\n-    pub(super) fn eval_and_read_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub(super) fn eval_and_read_lvalue(\n+        &mut self,\n+        lvalue: &mir::Lvalue<'tcx>,\n+    ) -> EvalResult<'tcx, Value> {\n         // Shortcut for things like accessing a fat pointer's field,\n         // which would otherwise (in the `eval_lvalue` path) require moving a `ByValPair` to memory\n         // and returning an `Lvalue::Ptr` to it\n@@ -164,21 +176,25 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 assert_eq!(extra, LvalueExtra::None);\n                 Ok(Value::ByRef(ptr))\n             }\n-            Lvalue::Local { frame, local } => {\n-                self.stack[frame].get_local(local)\n-            }\n+            Lvalue::Local { frame, local } => self.stack[frame].get_local(local),\n         }\n     }\n \n     pub fn eval_lvalue(&mut self, mir_lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue> {\n         use rustc::mir::Lvalue::*;\n         let lvalue = match *mir_lvalue {\n             Local(mir::RETURN_POINTER) => self.frame().return_lvalue,\n-            Local(local) => Lvalue::Local { frame: self.cur_frame(), local },\n+            Local(local) => Lvalue::Local {\n+                frame: self.cur_frame(),\n+                local,\n+            },\n \n             Static(ref static_) => {\n                 let instance = ty::Instance::mono(self.tcx, static_.def_id);\n-                let gid = GlobalId { instance, promoted: None };\n+                let gid = GlobalId {\n+                    instance,\n+                    promoted: None,\n+                };\n                 Lvalue::Ptr {\n                     ptr: *self.globals.get(&gid).expect(\"uncached global\"),\n                     extra: LvalueExtra::None,\n@@ -209,9 +225,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let base_layout = self.type_layout(base_ty)?;\n         use rustc::ty::layout::Layout::*;\n         let (offset, packed) = match *base_layout {\n-            Univariant { ref variant, .. } => {\n-                (variant.offsets[field_index], variant.packed)\n-            },\n+            Univariant { ref variant, .. } => (variant.offsets[field_index], variant.packed),\n \n             General { ref variants, .. } => {\n                 let (_, base_extra) = base.to_ptr_extra_aligned();\n@@ -249,8 +263,13 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     ty::TyArray(elem_ty, n) => {\n                         assert!(field < n as u64);\n                         self.type_size(elem_ty)?.expect(\"array elements are sized\") as u64\n-                    },\n-                    _ => bug!(\"lvalue_field: got Array layout but non-array type {:?}\", base_ty),\n+                    }\n+                    _ => {\n+                        bug!(\n+                            \"lvalue_field: got Array layout but non-array type {:?}\",\n+                            base_ty\n+                        )\n+                    }\n                 };\n                 (Size::from_bytes(field * elem_size), false)\n             }\n@@ -267,22 +286,36 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         // Do not allocate in trivial cases\n         let (base_ptr, base_extra) = match base {\n             Lvalue::Ptr { ptr, extra } => (ptr, extra),\n-            Lvalue::Local { frame, local } => match self.stack[frame].get_local(local)? {\n-                // in case the type has a single field, just return the value\n-                Value::ByVal(_) if self.get_field_count(base_ty).map(|c| c == 1).unwrap_or(false) => {\n-                    assert_eq!(offset.bytes(), 0, \"ByVal can only have 1 non zst field with offset 0\");\n-                    return Ok(base);\n-                },\n-                Value::ByRef{..} |\n-                Value::ByValPair(..) |\n-                Value::ByVal(_) => self.force_allocation(base)?.to_ptr_extra_aligned(),\n-            },\n+            Lvalue::Local { frame, local } => {\n+                match self.stack[frame].get_local(local)? {\n+                    // in case the type has a single field, just return the value\n+                    Value::ByVal(_)\n+                        if self.get_field_count(base_ty).map(|c| c == 1).unwrap_or(\n+                            false,\n+                        ) => {\n+                        assert_eq!(\n+                            offset.bytes(),\n+                            0,\n+                            \"ByVal can only have 1 non zst field with offset 0\"\n+                        );\n+                        return Ok(base);\n+                    }\n+                    Value::ByRef { .. } |\n+                    Value::ByValPair(..) |\n+                    Value::ByVal(_) => self.force_allocation(base)?.to_ptr_extra_aligned(),\n+                }\n+            }\n         };\n \n         let offset = match base_extra {\n             LvalueExtra::Vtable(tab) => {\n-                let (_, align) = self.size_and_align_of_dst(base_ty, base_ptr.ptr.to_value_with_vtable(tab))?;\n-                offset.abi_align(Align::from_bytes(align, align).unwrap()).bytes()\n+                let (_, align) = self.size_and_align_of_dst(\n+                    base_ty,\n+                    base_ptr.ptr.to_value_with_vtable(tab),\n+                )?;\n+                offset\n+                    .abi_align(Align::from_bytes(align, align).unwrap())\n+                    .bytes()\n             }\n             _ => offset.bytes(),\n         };\n@@ -299,41 +332,63 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         } else {\n             match base_extra {\n                 LvalueExtra::None => bug!(\"expected fat pointer\"),\n-                LvalueExtra::DowncastVariant(..) =>\n-                    bug!(\"Rust doesn't support unsized fields in enum variants\"),\n+                LvalueExtra::DowncastVariant(..) => {\n+                    bug!(\"Rust doesn't support unsized fields in enum variants\")\n+                }\n                 LvalueExtra::Vtable(_) |\n-                LvalueExtra::Length(_) => {},\n+                LvalueExtra::Length(_) => {}\n             }\n             base_extra\n         };\n \n-        Ok(Lvalue::Ptr { ptr, extra } )\n+        Ok(Lvalue::Ptr { ptr, extra })\n     }\n \n     pub(super) fn val_to_lvalue(&self, val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Lvalue> {\n         Ok(match self.tcx.struct_tail(ty).sty {\n             ty::TyDynamic(..) => {\n                 let (ptr, vtable) = val.into_ptr_vtable_pair(&self.memory)?;\n-                Lvalue::Ptr { ptr: PtrAndAlign { ptr, aligned: true }, extra: LvalueExtra::Vtable(vtable) }\n-            },\n+                Lvalue::Ptr {\n+                    ptr: PtrAndAlign { ptr, aligned: true },\n+                    extra: LvalueExtra::Vtable(vtable),\n+                }\n+            }\n             ty::TyStr | ty::TySlice(_) => {\n                 let (ptr, len) = val.into_slice(&self.memory)?;\n-                Lvalue::Ptr { ptr: PtrAndAlign { ptr, aligned: true }, extra: LvalueExtra::Length(len) }\n-            },\n+                Lvalue::Ptr {\n+                    ptr: PtrAndAlign { ptr, aligned: true },\n+                    extra: LvalueExtra::Length(len),\n+                }\n+            }\n             _ => Lvalue::from_primval_ptr(val.into_ptr(&self.memory)?),\n         })\n     }\n \n-    pub(super) fn lvalue_index(&mut self, base: Lvalue, outer_ty: Ty<'tcx>, n: u64) -> EvalResult<'tcx, Lvalue> {\n+    pub(super) fn lvalue_index(\n+        &mut self,\n+        base: Lvalue,\n+        outer_ty: Ty<'tcx>,\n+        n: u64,\n+    ) -> EvalResult<'tcx, Lvalue> {\n         // Taking the outer type here may seem odd; it's needed because for array types, the outer type gives away the length.\n         let base = self.force_allocation(base)?;\n         let (base_ptr, _) = base.to_ptr_extra_aligned();\n \n         let (elem_ty, len) = base.elem_ty_and_len(outer_ty);\n-        let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n-        assert!(n < len, \"Tried to access element {} of array/slice with length {}\", n, len);\n+        let elem_size = self.type_size(elem_ty)?.expect(\n+            \"slice element must be sized\",\n+        );\n+        assert!(\n+            n < len,\n+            \"Tried to access element {} of array/slice with length {}\",\n+            n,\n+            len\n+        );\n         let ptr = base_ptr.offset(n * elem_size, self.memory.layout)?;\n-        Ok(Lvalue::Ptr { ptr, extra: LvalueExtra::None })\n+        Ok(Lvalue::Ptr {\n+            ptr,\n+            extra: LvalueExtra::None,\n+        })\n     }\n \n     pub(super) fn eval_lvalue_projection(\n@@ -357,7 +412,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 use rustc::ty::layout::Layout::*;\n                 let extra = match *base_layout {\n                     General { .. } => LvalueExtra::DowncastVariant(variant),\n-                    RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => base_extra,\n+                    RawNullablePointer { .. } |\n+                    StructWrappedNullablePointer { .. } => base_extra,\n                     _ => bug!(\"variant downcast on non-aggregate: {:?}\", base_layout),\n                 };\n                 (base_ptr, extra)\n@@ -386,13 +442,19 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 return self.lvalue_index(base, base_ty, n);\n             }\n \n-            ConstantIndex { offset, min_length, from_end } => {\n+            ConstantIndex {\n+                offset,\n+                min_length,\n+                from_end,\n+            } => {\n                 // FIXME(solson)\n                 let base = self.force_allocation(base)?;\n                 let (base_ptr, _) = base.to_ptr_extra_aligned();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n-                let elem_size = self.type_size(elem_ty)?.expect(\"sequence element must be sized\");\n+                let elem_size = self.type_size(elem_ty)?.expect(\n+                    \"sequence element must be sized\",\n+                );\n                 assert!(n >= min_length as u64);\n \n                 let index = if from_end {\n@@ -411,7 +473,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let (base_ptr, _) = base.to_ptr_extra_aligned();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n-                let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n+                let elem_size = self.type_size(elem_ty)?.expect(\n+                    \"slice element must be sized\",\n+                );\n                 assert!(u64::from(from) <= n - u64::from(to));\n                 let ptr = base_ptr.offset(u64::from(from) * elem_size, &self)?;\n                 let extra = LvalueExtra::Length(n - u64::from(to) - u64::from(from));\n@@ -423,6 +487,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     pub(super) fn lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {\n-        self.monomorphize(lvalue.ty(self.mir(), self.tcx).to_ty(self.tcx), self.substs())\n+        self.monomorphize(\n+            lvalue.ty(self.mir(), self.tcx).to_ty(self.tcx),\n+            self.substs(),\n+        )\n     }\n }"}, {"sha": "dbe9f97dc1dc92aa374274b7bf059e46f353ceda", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -2,12 +2,7 @@\n //! This separation exists to ensure that no fancy miri features like\n //! interpreting common C functions leak into CTFE.\n \n-use super::{\n-    EvalResult,\n-    EvalContext,\n-    Lvalue,\n-    PrimVal\n-};\n+use super::{EvalResult, EvalContext, Lvalue, PrimVal};\n \n use rustc::{mir, ty};\n use syntax::codemap::Span;\n@@ -76,4 +71,3 @@ pub trait Machine<'tcx>: Sized {\n         ty: ty::Ty<'tcx>,\n     ) -> EvalResult<'tcx, PrimVal>;\n }\n-"}, {"sha": "56c051dcfad5d6a8d3396e5df0f6fdcc5c81e6f8", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 411, "deletions": 161, "changes": 572, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -8,13 +8,8 @@ use rustc::ty::layout::{self, TargetDataLayout, HasDataLayout};\n use syntax::ast::Mutability;\n use rustc::middle::region::CodeExtent;\n \n-use super::{\n-    EvalResult, EvalErrorKind,\n-    PrimVal, Pointer,\n-    EvalContext, DynamicLifetime,\n-    Machine,\n-    RangeMap,\n-};\n+use super::{EvalResult, EvalErrorKind, PrimVal, Pointer, EvalContext, DynamicLifetime, Machine,\n+            RangeMap};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Locks\n@@ -52,7 +47,10 @@ impl Default for LockInfo {\n \n impl LockInfo {\n     fn new(lock: Lock) -> LockInfo {\n-        LockInfo { suspended: HashMap::new(), active: lock }\n+        LockInfo {\n+            suspended: HashMap::new(),\n+            active: lock,\n+        }\n     }\n \n     fn access_permitted(&self, frame: Option<usize>, access: AccessKind) -> bool {\n@@ -63,11 +61,11 @@ impl LockInfo {\n                 assert!(!lfts.is_empty(), \"Someone left an empty read lock behind.\");\n                 // Read access to read-locked region is okay, no matter who's holding the read lock.\n                 true\n-            },\n+            }\n             (&WriteLock(ref lft), _) => {\n                 // All access is okay if we are the ones holding it\n                 Some(lft.frame) == frame\n-            },\n+            }\n             _ => false, // Nothing else is okay.\n         }\n     }\n@@ -152,9 +150,15 @@ pub struct Allocation<M> {\n }\n \n impl<M> Allocation<M> {\n-    fn check_locks<'tcx>(&self, frame: Option<usize>, offset: u64, len: u64, access: AccessKind) -> Result<(), LockInfo> {\n+    fn check_locks<'tcx>(\n+        &self,\n+        frame: Option<usize>,\n+        offset: u64,\n+        len: u64,\n+        access: AccessKind,\n+    ) -> Result<(), LockInfo> {\n         if len == 0 {\n-            return Ok(())\n+            return Ok(());\n         }\n         for lock in self.locks.iter(offset, len) {\n             // Check if the lock is in conflict with the access.\n@@ -193,7 +197,10 @@ impl<'tcx> MemoryPointer {\n     }\n \n     pub(crate) fn wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> Self {\n-        MemoryPointer::new(self.alloc_id, cx.data_layout().wrapping_signed_offset(self.offset, i))\n+        MemoryPointer::new(\n+            self.alloc_id,\n+            cx.data_layout().wrapping_signed_offset(self.offset, i),\n+        )\n     }\n \n     pub fn overflowing_signed_offset<C: HasDataLayout>(self, i: i128, cx: C) -> (Self, bool) {\n@@ -202,7 +209,10 @@ impl<'tcx> MemoryPointer {\n     }\n \n     pub(crate) fn signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n-        Ok(MemoryPointer::new(self.alloc_id, cx.data_layout().signed_offset(self.offset, i)?))\n+        Ok(MemoryPointer::new(\n+            self.alloc_id,\n+            cx.data_layout().signed_offset(self.offset, i)?,\n+        ))\n     }\n \n     pub fn overflowing_offset<C: HasDataLayout>(self, i: u64, cx: C) -> (Self, bool) {\n@@ -211,7 +221,10 @@ impl<'tcx> MemoryPointer {\n     }\n \n     pub fn offset<C: HasDataLayout>(self, i: u64, cx: C) -> EvalResult<'tcx, Self> {\n-        Ok(MemoryPointer::new(self.alloc_id, cx.data_layout().offset(self.offset, i)?))\n+        Ok(MemoryPointer::new(\n+            self.alloc_id,\n+            cx.data_layout().offset(self.offset, i)?,\n+        ))\n     }\n }\n \n@@ -276,8 +289,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         }\n     }\n \n-    pub fn allocations<'x>(&'x self) -> impl Iterator<Item = (AllocId, &'x Allocation<M::MemoryKinds>)> {\n-        self.alloc_map.iter().map(|(&id, alloc)| (AllocIdKind::Runtime(id).into_alloc_id(), alloc))\n+    pub fn allocations<'x>(\n+        &'x self,\n+    ) -> impl Iterator<Item = (AllocId, &'x Allocation<M::MemoryKinds>)> {\n+        self.alloc_map.iter().map(|(&id, alloc)| {\n+            (AllocIdKind::Runtime(id).into_alloc_id(), alloc)\n+        })\n     }\n \n     pub fn create_fn_alloc(&mut self, instance: ty::Instance<'tcx>) -> MemoryPointer {\n@@ -297,10 +314,20 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             return Ok(MemoryPointer::new(alloc_id, 0));\n         }\n \n-        let ptr = self.allocate(bytes.len() as u64, 1, MemoryKind::UninitializedStatic)?;\n+        let ptr = self.allocate(\n+            bytes.len() as u64,\n+            1,\n+            MemoryKind::UninitializedStatic,\n+        )?;\n         self.write_bytes(ptr.into(), bytes)?;\n-        self.mark_static_initalized(ptr.alloc_id, Mutability::Immutable)?;\n-        self.literal_alloc_cache.insert(bytes.to_vec(), ptr.alloc_id);\n+        self.mark_static_initalized(\n+            ptr.alloc_id,\n+            Mutability::Immutable,\n+        )?;\n+        self.literal_alloc_cache.insert(\n+            bytes.to_vec(),\n+            ptr.alloc_id,\n+        );\n         Ok(ptr)\n     }\n \n@@ -334,7 +361,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         let id = self.next_alloc_id;\n         self.next_alloc_id += 1;\n         self.alloc_map.insert(id, alloc);\n-        Ok(MemoryPointer::new(AllocIdKind::Runtime(id).into_alloc_id(), 0))\n+        Ok(MemoryPointer::new(\n+            AllocIdKind::Runtime(id).into_alloc_id(),\n+            0,\n+        ))\n     }\n \n     pub fn reallocate(\n@@ -353,13 +383,23 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         }\n         if let Ok(alloc) = self.get(ptr.alloc_id) {\n             if alloc.kind != kind {\n-                return err!(ReallocatedWrongMemoryKind(format!(\"{:?}\", alloc.kind), format!(\"{:?}\", kind)));\n+                return err!(ReallocatedWrongMemoryKind(\n+                    format!(\"{:?}\", alloc.kind),\n+                    format!(\"{:?}\", kind),\n+                ));\n             }\n         }\n \n         // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\"\n         let new_ptr = self.allocate(new_size, new_align, kind)?;\n-        self.copy(ptr.into(), new_ptr.into(), min(old_size, new_size), min(old_align, new_align), /*nonoverlapping*/true)?;\n+        self.copy(\n+            ptr.into(),\n+            new_ptr.into(),\n+            min(old_size, new_size),\n+            min(old_align, new_align),\n+            /*nonoverlapping*/\n+            true,\n+        )?;\n         self.deallocate(ptr, Some((old_size, old_align)), kind)?;\n \n         Ok(new_ptr)\n@@ -376,8 +416,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         }\n \n         let alloc_id = match ptr.alloc_id.into_alloc_id_kind() {\n-            AllocIdKind::Function(_) =>\n-                return err!(DeallocatedWrongMemoryKind(\"function\".to_string(), format!(\"{:?}\", kind))),\n+            AllocIdKind::Function(_) => {\n+                return err!(DeallocatedWrongMemoryKind(\n+                    \"function\".to_string(),\n+                    format!(\"{:?}\", kind),\n+                ))\n+            }\n             AllocIdKind::Runtime(id) => id,\n         };\n \n@@ -391,11 +435,25 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         // However, we should check *something*.  For now, we make sure that there is no conflicting write\n         // lock by another frame.  We *have* to permit deallocation if we hold a read lock.\n         // TODO: Figure out the exact rules here.\n-        alloc.check_locks(Some(self.cur_frame), 0, alloc.bytes.len() as u64, AccessKind::Read)\n-            .map_err(|lock| EvalErrorKind::DeallocatedLockedMemory { ptr, lock: lock.active })?;\n+        alloc\n+            .check_locks(\n+                Some(self.cur_frame),\n+                0,\n+                alloc.bytes.len() as u64,\n+                AccessKind::Read,\n+            )\n+            .map_err(|lock| {\n+                EvalErrorKind::DeallocatedLockedMemory {\n+                    ptr,\n+                    lock: lock.active,\n+                }\n+            })?;\n \n         if alloc.kind != kind {\n-            return err!(DeallocatedWrongMemoryKind(format!(\"{:?}\", alloc.kind), format!(\"{:?}\", kind)));\n+            return err!(DeallocatedWrongMemoryKind(\n+                format!(\"{:?}\", alloc.kind),\n+                format!(\"{:?}\", kind),\n+            ));\n         }\n         if let Some((size, align)) = size_and_align {\n             if size != alloc.bytes.len() as u64 || align != alloc.align {\n@@ -429,14 +487,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                     });\n                 }\n                 ptr.offset\n-            },\n+            }\n             PrimVal::Bytes(bytes) => {\n                 let v = ((bytes as u128) % (1 << self.pointer_size())) as u64;\n                 if v == 0 {\n                     return err!(InvalidNullPointerUsage);\n                 }\n                 v\n-            },\n+            }\n             PrimVal::Undef => return err!(ReadUndefBytes),\n         };\n         if offset % align == 0 {\n@@ -453,7 +511,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         let alloc = self.get(ptr.alloc_id)?;\n         let allocation_size = alloc.bytes.len() as u64;\n         if ptr.offset > allocation_size {\n-            return err!(PointerOutOfBounds { ptr, access, allocation_size });\n+            return err!(PointerOutOfBounds {\n+                ptr,\n+                access,\n+                allocation_size,\n+            });\n         }\n         Ok(())\n     }\n@@ -465,21 +527,48 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n /// Locking\n impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n-    pub(crate) fn check_locks(&self, ptr: MemoryPointer, len: u64, access: AccessKind) -> EvalResult<'tcx> {\n+    pub(crate) fn check_locks(\n+        &self,\n+        ptr: MemoryPointer,\n+        len: u64,\n+        access: AccessKind,\n+    ) -> EvalResult<'tcx> {\n         if len == 0 {\n-            return Ok(())\n+            return Ok(());\n         }\n         let alloc = self.get(ptr.alloc_id)?;\n         let frame = self.cur_frame;\n-        alloc.check_locks(Some(frame), ptr.offset, len, access)\n-            .map_err(|lock| EvalErrorKind::MemoryLockViolation { ptr, len, frame, access, lock: lock.active }.into())\n+        alloc\n+            .check_locks(Some(frame), ptr.offset, len, access)\n+            .map_err(|lock| {\n+                EvalErrorKind::MemoryLockViolation {\n+                    ptr,\n+                    len,\n+                    frame,\n+                    access,\n+                    lock: lock.active,\n+                }.into()\n+            })\n     }\n \n     /// Acquire the lock for the given lifetime\n-    pub(crate) fn acquire_lock(&mut self, ptr: MemoryPointer, len: u64, region: Option<CodeExtent>, kind: AccessKind) -> EvalResult<'tcx> {\n+    pub(crate) fn acquire_lock(\n+        &mut self,\n+        ptr: MemoryPointer,\n+        len: u64,\n+        region: Option<CodeExtent>,\n+        kind: AccessKind,\n+    ) -> EvalResult<'tcx> {\n         let frame = self.cur_frame;\n         assert!(len > 0);\n-        trace!(\"Frame {} acquiring {:?} lock at {:?}, size {} for region {:?}\", frame, kind, ptr, len, region);\n+        trace!(\n+            \"Frame {} acquiring {:?} lock at {:?}, size {} for region {:?}\",\n+            frame,\n+            kind,\n+            ptr,\n+            len,\n+            region\n+        );\n         self.check_bounds(ptr.offset(len, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get_mut_unchecked(ptr.alloc_id)?;\n \n@@ -488,7 +577,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         let lifetime = DynamicLifetime { frame, region };\n         for lock in alloc.locks.iter_mut(ptr.offset, len) {\n             if !lock.access_permitted(None, kind) {\n-                return err!(MemoryAcquireConflict { ptr, len, kind, lock: lock.active.clone() });\n+                return err!(MemoryAcquireConflict {\n+                    ptr,\n+                    len,\n+                    kind,\n+                    lock: lock.active.clone(),\n+                });\n             }\n             // See what we have to do\n             match (&mut lock.active, kind) {\n@@ -503,51 +597,65 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                 }\n                 _ => bug!(\"We already checked that there is no conflicting lock\"),\n             }\n-        };\n+        }\n         Ok(())\n     }\n \n     /// Release or suspend a write lock of the given lifetime prematurely.\n     /// When releasing, if there is a read lock or someone else's write lock, that's an error.\n     /// We *do* accept relasing a NoLock, as this can happen when a local is first acquired and later force_allocate'd.\n     /// When suspending, the same cases are fine; we just register an additional suspension.\n-    pub(crate) fn suspend_write_lock(&mut self, ptr: MemoryPointer, len: u64,\n-                                     lock_region: Option<CodeExtent>, suspend: Option<CodeExtent>) -> EvalResult<'tcx> {\n+    pub(crate) fn suspend_write_lock(\n+        &mut self,\n+        ptr: MemoryPointer,\n+        len: u64,\n+        lock_region: Option<CodeExtent>,\n+        suspend: Option<CodeExtent>,\n+    ) -> EvalResult<'tcx> {\n         assert!(len > 0);\n         let cur_frame = self.cur_frame;\n-        let lock_lft = DynamicLifetime { frame: cur_frame, region: lock_region };\n+        let lock_lft = DynamicLifetime {\n+            frame: cur_frame,\n+            region: lock_region,\n+        };\n         let alloc = self.get_mut_unchecked(ptr.alloc_id)?;\n \n         'locks: for lock in alloc.locks.iter_mut(ptr.offset, len) {\n             let is_our_lock = match lock.active {\n-                WriteLock(lft) => {\n-                    lft == lock_lft\n-                }\n-                ReadLock(_) | NoLock => {\n-                    false\n-                }\n+                WriteLock(lft) => lft == lock_lft,\n+                ReadLock(_) | NoLock => false,\n             };\n             if is_our_lock {\n                 trace!(\"Releasing {:?} at {:?}\", lock.active, lock_lft);\n                 // Disable the lock\n                 lock.active = NoLock;\n             } else {\n-                trace!(\"Not touching {:?} at {:?} as its not our lock\", lock.active, lock_lft);\n+                trace!(\n+                    \"Not touching {:?} at {:?} as its not our lock\",\n+                    lock.active,\n+                    lock_lft\n+                );\n             }\n             match suspend {\n                 Some(suspend_region) => {\n                     trace!(\"Adding suspension to {:?} at {:?}\", lock.active, lock_lft);\n                     // We just released this lock, so add a new suspension.\n                     // FIXME: Really, if there ever already is a suspension when is_our_lock, or if there is no suspension when !is_our_lock, something is amiss.\n                     // But this model is not good enough yet to prevent that.\n-                    lock.suspended.entry(lock_lft)\n+                    lock.suspended\n+                        .entry(lock_lft)\n                         .or_insert_with(|| Vec::new())\n                         .push(suspend_region);\n                 }\n                 None => {\n                     // Make sure we did not try to release someone else's lock.\n                     if !is_our_lock && lock.active != NoLock {\n-                        return err!(InvalidMemoryLockRelease { ptr, len, frame: cur_frame, lock: lock.active.clone() });\n+                        return err!(InvalidMemoryLockRelease {\n+                            ptr,\n+                            len,\n+                            frame: cur_frame,\n+                            lock: lock.active.clone(),\n+                        });\n                     }\n                 }\n             }\n@@ -557,13 +665,19 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     }\n \n     /// Release a suspension from the write lock.  If this is the last suspension or if there is no suspension, acquire the lock.\n-    pub(crate) fn recover_write_lock(&mut self, ptr: MemoryPointer, len: u64,\n-                                     lock_region: Option<CodeExtent>, suspended_region: CodeExtent, )\n-        -> EvalResult<'tcx>\n-    {\n+    pub(crate) fn recover_write_lock(\n+        &mut self,\n+        ptr: MemoryPointer,\n+        len: u64,\n+        lock_region: Option<CodeExtent>,\n+        suspended_region: CodeExtent,\n+    ) -> EvalResult<'tcx> {\n         assert!(len > 0);\n         let cur_frame = self.cur_frame;\n-        let lock_lft = DynamicLifetime { frame: cur_frame, region: lock_region };\n+        let lock_lft = DynamicLifetime {\n+            frame: cur_frame,\n+            region: lock_region,\n+        };\n         let alloc = self.get_mut_unchecked(ptr.alloc_id)?;\n \n         for lock in alloc.locks.iter_mut(ptr.offset, len) {\n@@ -591,7 +705,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                     (got_lock, got_lock)\n                 }\n             };\n-            if remove_suspension { // with NLL, we could do that up in the match above...\n+            if remove_suspension {\n+                // with NLL, we could do that up in the match above...\n                 assert!(got_the_lock);\n                 lock.suspended.remove(&lock_lft);\n             }\n@@ -601,7 +716,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                         *active = WriteLock(lock_lft);\n                     }\n                     _ => {\n-                        return err!(MemoryAcquireConflict { ptr, len, kind: AccessKind::Write, lock: lock.active.clone() })\n+                        return err!(MemoryAcquireConflict {\n+                            ptr,\n+                            len,\n+                            kind: AccessKind::Write,\n+                            lock: lock.active.clone(),\n+                        })\n                     }\n                 }\n             }\n@@ -612,15 +732,19 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n     pub(crate) fn locks_lifetime_ended(&mut self, ending_region: Option<CodeExtent>) {\n         let cur_frame = self.cur_frame;\n-        trace!(\"Releasing frame {} locks that expire at {:?}\", cur_frame, ending_region);\n-        let has_ended =  |lifetime: &DynamicLifetime| -> bool {\n+        trace!(\n+            \"Releasing frame {} locks that expire at {:?}\",\n+            cur_frame,\n+            ending_region\n+        );\n+        let has_ended = |lifetime: &DynamicLifetime| -> bool {\n             if lifetime.frame != cur_frame {\n                 return false;\n             }\n             match ending_region {\n                 None => true, // When a function ends, we end *all* its locks. It's okay for a function to still have lifetime-related locks\n-                              // when it returns, that can happen e.g. with NLL when a lifetime can, but does not have to, extend beyond the\n-                              // end of a function.  Same for a function still having recoveries.\n+                // when it returns, that can happen e.g. with NLL when a lifetime can, but does not have to, extend beyond the\n+                // end of a function.  Same for a function still having recoveries.\n                 Some(ending_region) => lifetime.region == Some(ending_region),\n             }\n         };\n@@ -629,9 +753,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             for lock in alloc.locks.iter_mut_all() {\n                 // Delete everything that ends now -- i.e., keep only all the other lifetimes.\n                 let lock_ended = match lock.active {\n-                    WriteLock(ref lft) => {\n-                        has_ended(lft)\n-                    }\n+                    WriteLock(ref lft) => has_ended(lft),\n                     ReadLock(ref mut lfts) => {\n                         lfts.retain(|lft| !has_ended(lft));\n                         lfts.is_empty()\n@@ -645,8 +767,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                 lock.suspended.retain(|lft, _suspensions| !has_ended(lft));\n             }\n             // Clean up the map\n-            alloc.locks.retain(|lock| {\n-                match lock.active { NoLock => lock.suspended.len() > 0, _ => true }\n+            alloc.locks.retain(|lock| match lock.active {\n+                NoLock => lock.suspended.len() > 0,\n+                _ => true,\n             });\n         }\n     }\n@@ -657,20 +780,27 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation<M::MemoryKinds>> {\n         match id.into_alloc_id_kind() {\n             AllocIdKind::Function(_) => err!(DerefFunctionPointer),\n-            AllocIdKind::Runtime(id) => match self.alloc_map.get(&id) {\n-                Some(alloc) => Ok(alloc),\n-                None => err!(DanglingPointerDeref),\n-            },\n+            AllocIdKind::Runtime(id) => {\n+                match self.alloc_map.get(&id) {\n+                    Some(alloc) => Ok(alloc),\n+                    None => err!(DanglingPointerDeref),\n+                }\n+            }\n         }\n     }\n-    \n-    fn get_mut_unchecked(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation<M::MemoryKinds>> {\n+\n+    fn get_mut_unchecked(\n+        &mut self,\n+        id: AllocId,\n+    ) -> EvalResult<'tcx, &mut Allocation<M::MemoryKinds>> {\n         match id.into_alloc_id_kind() {\n             AllocIdKind::Function(_) => err!(DerefFunctionPointer),\n-            AllocIdKind::Runtime(id) => match self.alloc_map.get_mut(&id) {\n-                Some(alloc) => Ok(alloc),\n-                None => err!(DanglingPointerDeref),\n-            },\n+            AllocIdKind::Runtime(id) => {\n+                match self.alloc_map.get_mut(&id) {\n+                    Some(alloc) => Ok(alloc),\n+                    None => err!(DanglingPointerDeref),\n+                }\n+            }\n         }\n     }\n \n@@ -716,14 +846,16 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                 AllocIdKind::Function(id) => {\n                     trace!(\"{} {}\", msg, self.functions[id]);\n                     continue;\n-                },\n-                AllocIdKind::Runtime(id) => match self.alloc_map.get(&id) {\n-                    Some(a) => a,\n-                    None => {\n-                        trace!(\"{} (deallocated)\", msg);\n-                        continue;\n+                }\n+                AllocIdKind::Runtime(id) => {\n+                    match self.alloc_map.get(&id) {\n+                        Some(a) => a,\n+                        None => {\n+                            trace!(\"{} (deallocated)\", msg);\n+                            continue;\n+                        }\n                     }\n-                },\n+                }\n             };\n \n             for i in 0..(alloc.bytes.len() as u64) {\n@@ -742,13 +874,21 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             }\n \n             let immutable = match (alloc.kind, alloc.mutable) {\n-                (MemoryKind::UninitializedStatic, _) => \" (static in the process of initialization)\".to_owned(),\n+                (MemoryKind::UninitializedStatic, _) => {\n+                    \" (static in the process of initialization)\".to_owned()\n+                }\n                 (MemoryKind::Static, Mutability::Mutable) => \" (static mut)\".to_owned(),\n                 (MemoryKind::Static, Mutability::Immutable) => \" (immutable)\".to_owned(),\n                 (MemoryKind::Machine(m), _) => format!(\" ({:?})\", m),\n                 (MemoryKind::Stack, _) => \" (stack)\".to_owned(),\n             };\n-            trace!(\"{}({} bytes, alignment {}){}\", msg, alloc.bytes.len(), alloc.align, immutable);\n+            trace!(\n+                \"{}({} bytes, alignment {}){}\",\n+                msg,\n+                alloc.bytes.len(),\n+                alloc.align,\n+                immutable\n+            );\n \n             if !relocations.is_empty() {\n                 msg.clear();\n@@ -772,12 +912,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         trace!(\"### LEAK REPORT ###\");\n         let leaks: Vec<_> = self.alloc_map\n             .iter()\n-            .filter_map(|(&key, val)| {\n-                if val.kind != MemoryKind::Static {\n-                    Some(AllocIdKind::Runtime(key).into_alloc_id())\n-                } else {\n-                    None\n-                }\n+            .filter_map(|(&key, val)| if val.kind != MemoryKind::Static {\n+                Some(AllocIdKind::Runtime(key).into_alloc_id())\n+            } else {\n+                None\n             })\n             .collect();\n         let n = leaks.len();\n@@ -788,7 +926,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n /// Byte accessors\n impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n-    fn get_bytes_unchecked(&self, ptr: MemoryPointer, size: u64, align: u64) -> EvalResult<'tcx, &[u8]> {\n+    fn get_bytes_unchecked(\n+        &self,\n+        ptr: MemoryPointer,\n+        size: u64,\n+        align: u64,\n+    ) -> EvalResult<'tcx, &[u8]> {\n         // Zero-sized accesses can use dangling pointers, but they still have to be aligned and non-NULL\n         if self.reads_are_aligned.get() {\n             self.check_align(ptr.into(), align)?;\n@@ -805,7 +948,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         Ok(&alloc.bytes[offset..offset + size as usize])\n     }\n \n-    fn get_bytes_unchecked_mut(&mut self, ptr: MemoryPointer, size: u64, align: u64) -> EvalResult<'tcx, &mut [u8]> {\n+    fn get_bytes_unchecked_mut(\n+        &mut self,\n+        ptr: MemoryPointer,\n+        size: u64,\n+        align: u64,\n+    ) -> EvalResult<'tcx, &mut [u8]> {\n         // Zero-sized accesses can use dangling pointers, but they still have to be aligned and non-NULL\n         if self.writes_are_aligned.get() {\n             self.check_align(ptr.into(), align)?;\n@@ -831,7 +979,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         self.get_bytes_unchecked(ptr, size, align)\n     }\n \n-    fn get_bytes_mut(&mut self, ptr: MemoryPointer, size: u64, align: u64) -> EvalResult<'tcx, &mut [u8]> {\n+    fn get_bytes_mut(\n+        &mut self,\n+        ptr: MemoryPointer,\n+        size: u64,\n+        align: u64,\n+    ) -> EvalResult<'tcx, &mut [u8]> {\n         assert_ne!(size, 0);\n         self.clear_relocations(ptr, size)?;\n         self.mark_definedness(ptr.into(), size, true)?;\n@@ -841,27 +994,46 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n /// Reading and writing\n impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n-\n     /// mark an allocation pointed to by a static as static and initialized\n-    pub fn mark_inner_allocation(&mut self, alloc: AllocId, mutability: Mutability) -> EvalResult<'tcx> {\n+    pub fn mark_inner_allocation(\n+        &mut self,\n+        alloc: AllocId,\n+        mutability: Mutability,\n+    ) -> EvalResult<'tcx> {\n         // relocations into other statics are not \"inner allocations\"\n-        if self.get(alloc).ok().map_or(false, |alloc| alloc.kind != MemoryKind::UninitializedStatic) {\n+        if self.get(alloc).ok().map_or(false, |alloc| {\n+            alloc.kind != MemoryKind::UninitializedStatic\n+        })\n+        {\n             self.mark_static_initalized(alloc, mutability)?;\n         }\n         Ok(())\n     }\n \n     /// mark an allocation as static and initialized, either mutable or not\n-    pub fn mark_static_initalized(&mut self, alloc_id: AllocId, mutability: Mutability) -> EvalResult<'tcx> {\n-        trace!(\"mark_static_initalized {:?}, mutability: {:?}\", alloc_id, mutability);\n+    pub fn mark_static_initalized(\n+        &mut self,\n+        alloc_id: AllocId,\n+        mutability: Mutability,\n+    ) -> EvalResult<'tcx> {\n+        trace!(\n+            \"mark_static_initalized {:?}, mutability: {:?}\",\n+            alloc_id,\n+            mutability\n+        );\n         // do not use `self.get_mut(alloc_id)` here, because we might have already marked a\n         // sub-element or have circular pointers (e.g. `Rc`-cycles)\n         let alloc_id = match alloc_id.into_alloc_id_kind() {\n             AllocIdKind::Function(_) => return Ok(()),\n             AllocIdKind::Runtime(id) => id,\n         };\n         let relocations = match self.alloc_map.get_mut(&alloc_id) {\n-            Some(&mut Allocation { ref mut relocations, ref mut kind, ref mut mutable, .. }) => {\n+            Some(&mut Allocation {\n+                     ref mut relocations,\n+                     ref mut kind,\n+                     ref mut mutable,\n+                     ..\n+                 }) => {\n                 match *kind {\n                     // const eval results can refer to \"locals\".\n                     // E.g. `const Foo: &u32 = &1;` refers to the temp local that stores the `1`\n@@ -879,19 +1051,29 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                 // take out the relocations vector to free the borrow on self, so we can call\n                 // mark recursively\n                 mem::replace(relocations, Default::default())\n-            },\n+            }\n             None => return err!(DanglingPointerDeref),\n         };\n         // recurse into inner allocations\n         for &alloc in relocations.values() {\n             self.mark_inner_allocation(alloc, mutability)?;\n         }\n         // put back the relocations\n-        self.alloc_map.get_mut(&alloc_id).expect(\"checked above\").relocations = relocations;\n+        self.alloc_map\n+            .get_mut(&alloc_id)\n+            .expect(\"checked above\")\n+            .relocations = relocations;\n         Ok(())\n     }\n \n-    pub fn copy(&mut self, src: Pointer, dest: Pointer, size: u64, align: u64, nonoverlapping: bool) -> EvalResult<'tcx> {\n+    pub fn copy(\n+        &mut self,\n+        src: Pointer,\n+        dest: Pointer,\n+        size: u64,\n+        align: u64,\n+        nonoverlapping: bool,\n+    ) -> EvalResult<'tcx> {\n         if size == 0 {\n             // Empty accesses don't need to be valid pointers, but they should still be aligned\n             if self.reads_are_aligned.get() {\n@@ -917,8 +1099,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             if src.alloc_id == dest.alloc_id {\n                 if nonoverlapping {\n                     if (src.offset <= dest.offset && src.offset + size > dest.offset) ||\n-                       (dest.offset <= src.offset && dest.offset + size > src.offset) {\n-                        return err!(Intrinsic(format!(\"copy_nonoverlapping called on overlapping ranges\")));\n+                        (dest.offset <= src.offset && dest.offset + size > src.offset)\n+                    {\n+                        return err!(Intrinsic(\n+                            format!(\"copy_nonoverlapping called on overlapping ranges\"),\n+                        ));\n                     }\n                 }\n                 ptr::copy(src_bytes, dest_bytes, size as usize);\n@@ -945,7 +1130,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                 self.check_defined(ptr, (size + 1) as u64)?;\n                 self.check_locks(ptr, (size + 1) as u64, AccessKind::Read)?;\n                 Ok(&alloc.bytes[offset..offset + size])\n-            },\n+            }\n             None => err!(UnterminatedCString(ptr)),\n         }\n     }\n@@ -983,7 +1168,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             return Ok(());\n         }\n         let bytes = self.get_bytes_mut(ptr.to_ptr()?, count, 1)?;\n-        for b in bytes { *b = val; }\n+        for b in bytes {\n+            *b = val;\n+        }\n         Ok(())\n     }\n \n@@ -1009,16 +1196,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n     pub fn write_ptr(&mut self, dest: MemoryPointer, ptr: MemoryPointer) -> EvalResult<'tcx> {\n         self.write_usize(dest, ptr.offset as u64)?;\n-        self.get_mut(dest.alloc_id)?.relocations.insert(dest.offset, ptr.alloc_id);\n+        self.get_mut(dest.alloc_id)?.relocations.insert(\n+            dest.offset,\n+            ptr.alloc_id,\n+        );\n         Ok(())\n     }\n \n-    pub fn write_primval(\n-        &mut self,\n-        dest: Pointer,\n-        val: PrimVal,\n-        size: u64,\n-    ) -> EvalResult<'tcx> {\n+    pub fn write_primval(&mut self, dest: Pointer, val: PrimVal, size: u64) -> EvalResult<'tcx> {\n         match val {\n             PrimVal::Ptr(ptr) => {\n                 assert_eq!(size, self.pointer_size());\n@@ -1054,8 +1239,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n     pub fn write_bool(&mut self, ptr: MemoryPointer, b: bool) -> EvalResult<'tcx> {\n         let align = self.layout.i1_align.abi();\n-        self.get_bytes_mut(ptr, 1, align)\n-            .map(|bytes| bytes[0] = b as u8)\n+        self.get_bytes_mut(ptr, 1, align).map(\n+            |bytes| bytes[0] = b as u8,\n+        )\n     }\n \n     fn int_align(&self, size: u64) -> EvalResult<'tcx, u64> {\n@@ -1071,7 +1257,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n     pub fn read_int(&self, ptr: MemoryPointer, size: u64) -> EvalResult<'tcx, i128> {\n         let align = self.int_align(size)?;\n-        self.get_bytes(ptr, size, align).map(|b| read_target_int(self.endianess(), b).unwrap())\n+        self.get_bytes(ptr, size, align).map(|b| {\n+            read_target_int(self.endianess(), b).unwrap()\n+        })\n     }\n \n     pub fn write_int(&mut self, ptr: MemoryPointer, n: i128, size: u64) -> EvalResult<'tcx> {\n@@ -1084,7 +1272,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n     pub fn read_uint(&self, ptr: MemoryPointer, size: u64) -> EvalResult<'tcx, u128> {\n         let align = self.int_align(size)?;\n-        self.get_bytes(ptr, size, align).map(|b| read_target_uint(self.endianess(), b).unwrap())\n+        self.get_bytes(ptr, size, align).map(|b| {\n+            read_target_uint(self.endianess(), b).unwrap()\n+        })\n     }\n \n     pub fn write_uint(&mut self, ptr: MemoryPointer, n: u128, size: u64) -> EvalResult<'tcx> {\n@@ -1130,21 +1320,29 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     }\n \n     pub fn read_f32(&self, ptr: MemoryPointer) -> EvalResult<'tcx, f32> {\n-        self.get_bytes(ptr, 4, self.layout.f32_align.abi())\n-            .map(|b| read_target_f32(self.endianess(), b).unwrap())\n+        self.get_bytes(ptr, 4, self.layout.f32_align.abi()).map(\n+            |b| {\n+                read_target_f32(self.endianess(), b).unwrap()\n+            },\n+        )\n     }\n \n     pub fn read_f64(&self, ptr: MemoryPointer) -> EvalResult<'tcx, f64> {\n-        self.get_bytes(ptr, 8, self.layout.f64_align.abi())\n-            .map(|b| read_target_f64(self.endianess(), b).unwrap())\n+        self.get_bytes(ptr, 8, self.layout.f64_align.abi()).map(\n+            |b| {\n+                read_target_f64(self.endianess(), b).unwrap()\n+            },\n+        )\n     }\n }\n \n /// Relocations\n impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n-    fn relocations(&self, ptr: MemoryPointer, size: u64)\n-        -> EvalResult<'tcx, btree_map::Range<u64, AllocId>>\n-    {\n+    fn relocations(\n+        &self,\n+        ptr: MemoryPointer,\n+        size: u64,\n+    ) -> EvalResult<'tcx, btree_map::Range<u64, AllocId>> {\n         let start = ptr.offset.saturating_sub(self.pointer_size() - 1);\n         let end = ptr.offset + size;\n         Ok(self.get(ptr.alloc_id)?.relocations.range(start..end))\n@@ -1153,7 +1351,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     fn clear_relocations(&mut self, ptr: MemoryPointer, size: u64) -> EvalResult<'tcx> {\n         // Find all relocations overlapping the given range.\n         let keys: Vec<_> = self.relocations(ptr, size)?.map(|(&k, _)| k).collect();\n-        if keys.is_empty() { return Ok(()); }\n+        if keys.is_empty() {\n+            return Ok(());\n+        }\n \n         // Find the start and end of the given range and its outermost relocations.\n         let start = ptr.offset;\n@@ -1165,11 +1365,17 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n         // Mark parts of the outermost relocations as undefined if they partially fall outside the\n         // given range.\n-        if first < start { alloc.undef_mask.set_range(first, start, false); }\n-        if last > end { alloc.undef_mask.set_range(end, last, false); }\n+        if first < start {\n+            alloc.undef_mask.set_range(first, start, false);\n+        }\n+        if last > end {\n+            alloc.undef_mask.set_range(end, last, false);\n+        }\n \n         // Forget all the relocations.\n-        for k in keys { alloc.relocations.remove(&k); }\n+        for k in keys {\n+            alloc.relocations.remove(&k);\n+        }\n \n         Ok(())\n     }\n@@ -1183,7 +1389,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         Ok(())\n     }\n \n-    fn copy_relocations(&mut self, src: MemoryPointer, dest: MemoryPointer, size: u64) -> EvalResult<'tcx> {\n+    fn copy_relocations(\n+        &mut self,\n+        src: MemoryPointer,\n+        dest: MemoryPointer,\n+        size: u64,\n+    ) -> EvalResult<'tcx> {\n         let relocations: Vec<_> = self.relocations(src, size)?\n             .map(|(&offset, &alloc_id)| {\n                 // Update relocation offsets for the new positions in the destination allocation.\n@@ -1198,7 +1409,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n /// Undefined bytes\n impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     // FIXME(solson): This is a very naive, slow version.\n-    fn copy_undef_mask(&mut self, src: MemoryPointer, dest: MemoryPointer, size: u64) -> EvalResult<'tcx> {\n+    fn copy_undef_mask(\n+        &mut self,\n+        src: MemoryPointer,\n+        dest: MemoryPointer,\n+        size: u64,\n+    ) -> EvalResult<'tcx> {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap.\n         assert_eq!(size as usize as u64, size);\n         let mut v = Vec::with_capacity(size as usize);\n@@ -1207,14 +1423,22 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             v.push(defined);\n         }\n         for (i, defined) in v.into_iter().enumerate() {\n-            self.get_mut(dest.alloc_id)?.undef_mask.set(dest.offset + i as u64, defined);\n+            self.get_mut(dest.alloc_id)?.undef_mask.set(\n+                dest.offset +\n+                    i as u64,\n+                defined,\n+            );\n         }\n         Ok(())\n     }\n \n     fn check_defined(&self, ptr: MemoryPointer, size: u64) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n-        if !alloc.undef_mask.is_range_defined(ptr.offset, ptr.offset + size) {\n+        if !alloc.undef_mask.is_range_defined(\n+            ptr.offset,\n+            ptr.offset + size,\n+        )\n+        {\n             return err!(ReadUndefBytes);\n         }\n         Ok(())\n@@ -1224,14 +1448,18 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         &mut self,\n         ptr: Pointer,\n         size: u64,\n-        new_state: bool\n+        new_state: bool,\n     ) -> EvalResult<'tcx> {\n         if size == 0 {\n-            return Ok(())\n+            return Ok(());\n         }\n         let ptr = ptr.to_ptr()?;\n         let mut alloc = self.get_mut(ptr.alloc_id)?;\n-        alloc.undef_mask.set_range(ptr.offset, ptr.offset + size, new_state);\n+        alloc.undef_mask.set_range(\n+            ptr.offset,\n+            ptr.offset + size,\n+            new_state,\n+        );\n         Ok(())\n     }\n }\n@@ -1240,14 +1468,22 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n // Methods to access integers in the target endianess\n ////////////////////////////////////////////////////////////////////////////////\n \n-fn write_target_uint(endianess: layout::Endian, mut target: &mut [u8], data: u128) -> Result<(), io::Error> {\n+fn write_target_uint(\n+    endianess: layout::Endian,\n+    mut target: &mut [u8],\n+    data: u128,\n+) -> Result<(), io::Error> {\n     let len = target.len();\n     match endianess {\n         layout::Endian::Little => target.write_uint128::<LittleEndian>(data, len),\n         layout::Endian::Big => target.write_uint128::<BigEndian>(data, len),\n     }\n }\n-fn write_target_int(endianess: layout::Endian, mut target: &mut [u8], data: i128) -> Result<(), io::Error> {\n+fn write_target_int(\n+    endianess: layout::Endian,\n+    mut target: &mut [u8],\n+    data: i128,\n+) -> Result<(), io::Error> {\n     let len = target.len();\n     match endianess {\n         layout::Endian::Little => target.write_int128::<LittleEndian>(data, len),\n@@ -1272,13 +1508,21 @@ fn read_target_int(endianess: layout::Endian, mut source: &[u8]) -> Result<i128,\n // Methods to access floats in the target endianess\n ////////////////////////////////////////////////////////////////////////////////\n \n-fn write_target_f32(endianess: layout::Endian, mut target: &mut [u8], data: f32) -> Result<(), io::Error> {\n+fn write_target_f32(\n+    endianess: layout::Endian,\n+    mut target: &mut [u8],\n+    data: f32,\n+) -> Result<(), io::Error> {\n     match endianess {\n         layout::Endian::Little => target.write_f32::<LittleEndian>(data),\n         layout::Endian::Big => target.write_f32::<BigEndian>(data),\n     }\n }\n-fn write_target_f64(endianess: layout::Endian, mut target: &mut [u8], data: f64) -> Result<(), io::Error> {\n+fn write_target_f64(\n+    endianess: layout::Endian,\n+    mut target: &mut [u8],\n+    data: f64,\n+) -> Result<(), io::Error> {\n     match endianess {\n         layout::Endian::Little => target.write_f64::<LittleEndian>(data),\n         layout::Endian::Big => target.write_f64::<BigEndian>(data),\n@@ -1323,21 +1567,29 @@ impl UndefMask {\n \n     /// Check whether the range `start..end` (end-exclusive) is entirely defined.\n     pub fn is_range_defined(&self, start: u64, end: u64) -> bool {\n-        if end > self.len { return false; }\n+        if end > self.len {\n+            return false;\n+        }\n         for i in start..end {\n-            if !self.get(i) { return false; }\n+            if !self.get(i) {\n+                return false;\n+            }\n         }\n         true\n     }\n \n     fn set_range(&mut self, start: u64, end: u64, new_state: bool) {\n         let len = self.len;\n-        if end > len { self.grow(end - len, new_state); }\n+        if end > len {\n+            self.grow(end - len, new_state);\n+        }\n         self.set_range_inbounds(start, end, new_state);\n     }\n \n     fn set_range_inbounds(&mut self, start: u64, end: u64, new_state: bool) {\n-        for i in start..end { self.set(i, new_state); }\n+        for i in start..end {\n+            self.set(i, new_state);\n+        }\n     }\n \n     fn get(&self, i: u64) -> bool {\n@@ -1359,7 +1611,9 @@ impl UndefMask {\n         if amount > unused_trailing_bits {\n             let additional_blocks = amount / BLOCK_SIZE + 1;\n             assert_eq!(additional_blocks as usize as u64, additional_blocks);\n-            self.blocks.extend(iter::repeat(0).take(additional_blocks as usize));\n+            self.blocks.extend(\n+                iter::repeat(0).take(additional_blocks as usize),\n+            );\n         }\n         let start = self.len;\n         self.len += amount;\n@@ -1385,7 +1639,8 @@ pub trait HasMemory<'a, 'tcx, M: Machine<'tcx>> {\n \n     // These are not supposed to be overriden.\n     fn read_maybe_aligned<F, T>(&self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n-        where F: FnOnce(&Self) -> EvalResult<'tcx, T>\n+    where\n+        F: FnOnce(&Self) -> EvalResult<'tcx, T>,\n     {\n         let old = self.memory().reads_are_aligned.get();\n         // Do alignment checking if *all* nested calls say it has to be aligned.\n@@ -1396,7 +1651,8 @@ pub trait HasMemory<'a, 'tcx, M: Machine<'tcx>> {\n     }\n \n     fn read_maybe_aligned_mut<F, T>(&mut self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n-        where F: FnOnce(&mut Self) -> EvalResult<'tcx, T>\n+    where\n+        F: FnOnce(&mut Self) -> EvalResult<'tcx, T>,\n     {\n         let old = self.memory().reads_are_aligned.get();\n         // Do alignment checking if *all* nested calls say it has to be aligned.\n@@ -1407,7 +1663,8 @@ pub trait HasMemory<'a, 'tcx, M: Machine<'tcx>> {\n     }\n \n     fn write_maybe_aligned_mut<F, T>(&mut self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n-        where F: FnOnce(&mut Self) -> EvalResult<'tcx, T>\n+    where\n+        F: FnOnce(&mut Self) -> EvalResult<'tcx, T>,\n     {\n         let old = self.memory().writes_are_aligned.get();\n         // Do alignment checking if *all* nested calls say it has to be aligned.\n@@ -1446,7 +1703,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> HasMemory<'a, 'tcx, M> for EvalContext<'a, 'tcx\n // Pointer arithmetic\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub trait PointerArithmetic : layout::HasDataLayout {\n+pub trait PointerArithmetic: layout::HasDataLayout {\n     // These are not supposed to be overriden.\n \n     //// Trunace the given value to the pointer size; also return whether there was an overflow\n@@ -1476,20 +1733,12 @@ pub trait PointerArithmetic : layout::HasDataLayout {\n \n     fn signed_offset<'tcx>(self, val: u64, i: i64) -> EvalResult<'tcx, u64> {\n         let (res, over) = self.overflowing_signed_offset(val, i as i128);\n-        if over {\n-            err!(OverflowingMath)\n-        } else {\n-            Ok(res)\n-        }\n+        if over { err!(OverflowingMath) } else { Ok(res) }\n     }\n \n     fn offset<'tcx>(self, val: u64, i: u64) -> EvalResult<'tcx, u64> {\n         let (res, over) = self.overflowing_offset(val, i);\n-        if over {\n-            err!(OverflowingMath)\n-        } else {\n-            Ok(res)\n-        }\n+        if over { err!(OverflowingMath) } else { Ok(res) }\n     }\n \n     fn wrapping_signed_offset(self, val: u64, i: i64) -> u64 {\n@@ -1512,7 +1761,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> layout::HasDataLayout for &'a EvalContext<'a, '\n     }\n }\n \n-impl<'c, 'b, 'a, 'tcx, M: Machine<'tcx>> layout::HasDataLayout for &'c &'b mut EvalContext<'a, 'tcx, M> {\n+impl<'c, 'b, 'a, 'tcx, M: Machine<'tcx>> layout::HasDataLayout\n+    for &'c &'b mut EvalContext<'a, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n         self.memory().layout"}, {"sha": "e3931444e6fc9979472f31a67a6fd4b6822f3961", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 11, "deletions": 50, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -20,62 +20,23 @@ mod terminator;\n mod traits;\n mod value;\n \n-pub use self::error::{\n-    EvalError,\n-    EvalResult,\n-    EvalErrorKind,\n-};\n+pub use self::error::{EvalError, EvalResult, EvalErrorKind};\n \n-pub use self::eval_context::{\n-    EvalContext,\n-    Frame,\n-    ResourceLimits,\n-    StackPopCleanup,\n-    DynamicLifetime,\n-    TyAndPacked,\n-    PtrAndAlign,\n-};\n+pub use self::eval_context::{EvalContext, Frame, ResourceLimits, StackPopCleanup, DynamicLifetime,\n+                             TyAndPacked, PtrAndAlign};\n \n-pub use self::lvalue::{\n-    Lvalue,\n-    LvalueExtra,\n-    GlobalId,\n-};\n+pub use self::lvalue::{Lvalue, LvalueExtra, GlobalId};\n \n-pub use self::memory::{\n-    AllocId,\n-    Memory,\n-    MemoryPointer,\n-    MemoryKind,\n-    HasMemory,\n-};\n+pub use self::memory::{AllocId, Memory, MemoryPointer, MemoryKind, HasMemory};\n \n-use self::memory::{\n-    PointerArithmetic,\n-    Lock,\n-    AccessKind,\n-};\n+use self::memory::{PointerArithmetic, Lock, AccessKind};\n \n-use self::range_map::{\n-    RangeMap\n-};\n+use self::range_map::RangeMap;\n \n-pub use self::value::{\n-    PrimVal,\n-    PrimValKind,\n-    Value,\n-    Pointer,\n-};\n+pub use self::value::{PrimVal, PrimValKind, Value, Pointer};\n \n-pub use self::const_eval::{\n-    eval_body_as_integer,\n-    eval_body_as_primval,\n-};\n+pub use self::const_eval::{eval_body_as_integer, eval_body_as_primval};\n \n-pub use self::machine::{\n-    Machine,\n-};\n+pub use self::machine::Machine;\n \n-pub use self::validation::{\n-    ValidationQuery,\n-};\n+pub use self::validation::ValidationQuery;"}, {"sha": "42d4538e9503eacd59cc6c31b4fd669e60276e31", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -1,22 +1,10 @@\n use rustc::mir;\n use rustc::ty::Ty;\n \n-use super::{\n-    EvalResult,\n-    EvalContext,\n-    Lvalue,\n-    Machine,\n-};\n-\n-use super::value::{\n-    PrimVal,\n-    PrimValKind,\n-    Value,\n-    bytes_to_f32,\n-    bytes_to_f64,\n-    f32_to_bytes,\n-    f64_to_bytes,\n-};\n+use super::{EvalResult, EvalContext, Lvalue, Machine};\n+\n+use super::value::{PrimVal, PrimValKind, Value, bytes_to_f32, bytes_to_f64, f32_to_bytes,\n+                   f64_to_bytes};\n \n impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     fn binop_with_overflow(\n@@ -25,10 +13,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         left: &mir::Operand<'tcx>,\n         right: &mir::Operand<'tcx>,\n     ) -> EvalResult<'tcx, (PrimVal, bool)> {\n-        let left_ty    = self.operand_ty(left);\n-        let right_ty   = self.operand_ty(right);\n-        let left_val   = self.eval_operand_to_primval(left)?;\n-        let right_val  = self.eval_operand_to_primval(right)?;\n+        let left_ty = self.operand_ty(left);\n+        let right_ty = self.operand_ty(right);\n+        let left_val = self.eval_operand_to_primval(left)?;\n+        let right_val = self.eval_operand_to_primval(right)?;\n         self.binary_op(op, left_val, left_ty, right_val, right_ty)\n     }\n \n@@ -147,7 +135,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         use rustc::mir::BinOp::*;\n         use super::PrimValKind::*;\n \n-        let left_kind  = self.ty_to_primval_kind(left_ty)?;\n+        let left_kind = self.ty_to_primval_kind(left_ty)?;\n         let right_kind = self.ty_to_primval_kind(right_ty)?;\n         //trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n \n@@ -172,23 +160,30 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n \n         if left_kind != right_kind {\n-            let msg = format!(\"unimplemented binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n+            let msg = format!(\n+                \"unimplemented binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n+                bin_op,\n+                left,\n+                left_kind,\n+                right,\n+                right_kind\n+            );\n             return err!(Unimplemented(msg));\n         }\n \n         let val = match (bin_op, left_kind) {\n             (Eq, F32) => PrimVal::from_bool(bytes_to_f32(l) == bytes_to_f32(r)),\n             (Ne, F32) => PrimVal::from_bool(bytes_to_f32(l) != bytes_to_f32(r)),\n-            (Lt, F32) => PrimVal::from_bool(bytes_to_f32(l) <  bytes_to_f32(r)),\n+            (Lt, F32) => PrimVal::from_bool(bytes_to_f32(l) < bytes_to_f32(r)),\n             (Le, F32) => PrimVal::from_bool(bytes_to_f32(l) <= bytes_to_f32(r)),\n-            (Gt, F32) => PrimVal::from_bool(bytes_to_f32(l) >  bytes_to_f32(r)),\n+            (Gt, F32) => PrimVal::from_bool(bytes_to_f32(l) > bytes_to_f32(r)),\n             (Ge, F32) => PrimVal::from_bool(bytes_to_f32(l) >= bytes_to_f32(r)),\n \n             (Eq, F64) => PrimVal::from_bool(bytes_to_f64(l) == bytes_to_f64(r)),\n             (Ne, F64) => PrimVal::from_bool(bytes_to_f64(l) != bytes_to_f64(r)),\n-            (Lt, F64) => PrimVal::from_bool(bytes_to_f64(l) <  bytes_to_f64(r)),\n+            (Lt, F64) => PrimVal::from_bool(bytes_to_f64(l) < bytes_to_f64(r)),\n             (Le, F64) => PrimVal::from_bool(bytes_to_f64(l) <= bytes_to_f64(r)),\n-            (Gt, F64) => PrimVal::from_bool(bytes_to_f64(l) >  bytes_to_f64(r)),\n+            (Gt, F64) => PrimVal::from_bool(bytes_to_f64(l) > bytes_to_f64(r)),\n             (Ge, F64) => PrimVal::from_bool(bytes_to_f64(l) >= bytes_to_f64(r)),\n \n             (Add, F32) => f32_arithmetic!(+, l, r),\n@@ -207,15 +202,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             (Ne, _) => PrimVal::from_bool(l != r),\n \n             (Lt, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) < (r as i128)),\n-            (Lt, _) => PrimVal::from_bool(l <  r),\n+            (Lt, _) => PrimVal::from_bool(l < r),\n             (Le, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) <= (r as i128)),\n             (Le, _) => PrimVal::from_bool(l <= r),\n             (Gt, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) > (r as i128)),\n-            (Gt, _) => PrimVal::from_bool(l >  r),\n+            (Gt, _) => PrimVal::from_bool(l > r),\n             (Ge, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) >= (r as i128)),\n             (Ge, _) => PrimVal::from_bool(l >= r),\n \n-            (BitOr,  _) => PrimVal::Bytes(l | r),\n+            (BitOr, _) => PrimVal::Bytes(l | r),\n             (BitAnd, _) => PrimVal::Bytes(l & r),\n             (BitXor, _) => PrimVal::Bytes(l ^ r),\n \n@@ -226,7 +221,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             (Rem, k) if k.is_int() => return int_arithmetic!(k, overflowing_rem, l, r),\n \n             _ => {\n-                let msg = format!(\"unimplemented binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n+                let msg = format!(\n+                    \"unimplemented binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n+                    bin_op,\n+                    left,\n+                    left_kind,\n+                    right,\n+                    right_kind\n+                );\n                 return err!(Unimplemented(msg));\n             }\n         };\n@@ -248,19 +250,19 @@ pub fn unary_op<'tcx>(\n     let result_bytes = match (un_op, val_kind) {\n         (Not, Bool) => !val.to_bool()? as u128,\n \n-        (Not, U8)  => !(bytes as u8) as u128,\n+        (Not, U8) => !(bytes as u8) as u128,\n         (Not, U16) => !(bytes as u16) as u128,\n         (Not, U32) => !(bytes as u32) as u128,\n         (Not, U64) => !(bytes as u64) as u128,\n         (Not, U128) => !bytes,\n \n-        (Not, I8)  => !(bytes as i8) as u128,\n+        (Not, I8) => !(bytes as i8) as u128,\n         (Not, I16) => !(bytes as i16) as u128,\n         (Not, I32) => !(bytes as i32) as u128,\n         (Not, I64) => !(bytes as i64) as u128,\n         (Not, I128) => !(bytes as i128) as u128,\n \n-        (Neg, I8)  => -(bytes as i8) as u128,\n+        (Neg, I8) => -(bytes as i8) as u128,\n         (Neg, I16) => -(bytes as i16) as u128,\n         (Neg, I32) => -(bytes as i32) as u128,\n         (Neg, I64) => -(bytes as i64) as u128,"}, {"sha": "5cdcbe35121a579e26b6d74c461b5cb64ece2676", "filename": "src/librustc_mir/interpret/range_map.rs", "status": "modified", "additions": 82, "deletions": 31, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Frange_map.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -4,12 +4,12 @@\n //! necessary (e.g. when [0,5) is first associated with X, and then [1,2) is mutated).\n //! Users must not depend on whether a range is coalesced or not, even though this is observable\n //! via the iteration APIs.\n-use std::collections::{BTreeMap};\n+use std::collections::BTreeMap;\n use std::ops;\n \n #[derive(Clone, Debug)]\n pub struct RangeMap<T> {\n-    map: BTreeMap<Range, T>\n+    map: BTreeMap<Range, T>,\n }\n \n // The derived `Ord` impl sorts first by the first field, then, if the fields are the same,\n@@ -31,11 +31,13 @@ impl Range {\n         // the range given by the offset into the allocation and the length.\n         // This is sound if all ranges that intersect with the argument range, are in the\n         // resulting range of ranges.\n-        let left = Range { // lowest range to include `offset`\n+        let left = Range {\n+            // lowest range to include `offset`\n             start: 0,\n             end: offset + 1,\n         };\n-        let right = Range { // lowest (valid) range not to include `offset+len`\n+        let right = Range {\n+            // lowest (valid) range not to include `offset+len`\n             start: offset + len,\n             end: offset + len + 1,\n         };\n@@ -45,7 +47,7 @@ impl Range {\n     /// Tests if all of [offset, offset+len) are contained in this range.\n     fn overlaps(&self, offset: u64, len: u64) -> bool {\n         assert!(len > 0);\n-        offset < self.end && offset+len >= self.start\n+        offset < self.end && offset + len >= self.start\n     }\n }\n \n@@ -54,82 +56,122 @@ impl<T> RangeMap<T> {\n         RangeMap { map: BTreeMap::new() }\n     }\n \n-    fn iter_with_range<'a>(&'a self, offset: u64, len: u64) -> impl Iterator<Item=(&'a Range, &'a T)> + 'a {\n+    fn iter_with_range<'a>(\n+        &'a self,\n+        offset: u64,\n+        len: u64,\n+    ) -> impl Iterator<Item = (&'a Range, &'a T)> + 'a {\n         assert!(len > 0);\n-        self.map.range(Range::range(offset, len))\n-            .filter_map(move |(range, data)| {\n+        self.map.range(Range::range(offset, len)).filter_map(\n+            move |(range,\n+                   data)| {\n                 if range.overlaps(offset, len) {\n                     Some((range, data))\n                 } else {\n                     None\n                 }\n-            })\n+            },\n+        )\n     }\n \n-    pub fn iter<'a>(&'a self, offset: u64, len: u64) -> impl Iterator<Item=&'a T> + 'a {\n+    pub fn iter<'a>(&'a self, offset: u64, len: u64) -> impl Iterator<Item = &'a T> + 'a {\n         self.iter_with_range(offset, len).map(|(_, data)| data)\n     }\n \n-    fn split_entry_at(&mut self, offset: u64) where T: Clone {\n+    fn split_entry_at(&mut self, offset: u64)\n+    where\n+        T: Clone,\n+    {\n         let range = match self.iter_with_range(offset, 1).next() {\n             Some((&range, _)) => range,\n             None => return,\n         };\n-        assert!(range.start <= offset && range.end > offset, \"We got a range that doesn't even contain what we asked for.\");\n+        assert!(\n+            range.start <= offset && range.end > offset,\n+            \"We got a range that doesn't even contain what we asked for.\"\n+        );\n         // There is an entry overlapping this position, see if we have to split it\n         if range.start < offset {\n             let data = self.map.remove(&range).unwrap();\n-            let old = self.map.insert(Range { start: range.start, end: offset }, data.clone());\n+            let old = self.map.insert(\n+                Range {\n+                    start: range.start,\n+                    end: offset,\n+                },\n+                data.clone(),\n+            );\n             assert!(old.is_none());\n-            let old = self.map.insert(Range { start: offset, end: range.end }, data);\n+            let old = self.map.insert(\n+                Range {\n+                    start: offset,\n+                    end: range.end,\n+                },\n+                data,\n+            );\n             assert!(old.is_none());\n         }\n     }\n \n-    pub fn iter_mut_all<'a>(&'a mut self) -> impl Iterator<Item=&'a mut T> + 'a {\n+    pub fn iter_mut_all<'a>(&'a mut self) -> impl Iterator<Item = &'a mut T> + 'a {\n         self.map.values_mut()\n     }\n \n     /// Provide mutable iteration over everything in the given range.  As a side-effect,\n     /// this will split entries in the map that are only partially hit by the given range,\n     /// to make sure that when they are mutated, the effect is constrained to the given range.\n-    pub fn iter_mut_with_gaps<'a>(&'a mut self, offset: u64, len: u64) -> impl Iterator<Item=&'a mut T> + 'a\n-        where T: Clone\n+    pub fn iter_mut_with_gaps<'a>(\n+        &'a mut self,\n+        offset: u64,\n+        len: u64,\n+    ) -> impl Iterator<Item = &'a mut T> + 'a\n+    where\n+        T: Clone,\n     {\n         assert!(len > 0);\n         // Preparation: Split first and last entry as needed.\n         self.split_entry_at(offset);\n-        self.split_entry_at(offset+len);\n+        self.split_entry_at(offset + len);\n         // Now we can provide a mutable iterator\n-        self.map.range_mut(Range::range(offset, len))\n-            .filter_map(move |(&range, data)| {\n+        self.map.range_mut(Range::range(offset, len)).filter_map(\n+            move |(&range, data)| {\n                 if range.overlaps(offset, len) {\n-                    assert!(offset <= range.start && offset+len >= range.end, \"The splitting went wrong\");\n+                    assert!(\n+                        offset <= range.start && offset + len >= range.end,\n+                        \"The splitting went wrong\"\n+                    );\n                     Some(data)\n                 } else {\n                     // Skip this one\n                     None\n                 }\n-            })\n+            },\n+        )\n     }\n \n     /// Provide a mutable iterator over everything in the given range, with the same side-effects as\n     /// iter_mut_with_gaps.  Furthermore, if there are gaps between ranges, fill them with the given default.\n     /// This is also how you insert.\n-    pub fn iter_mut<'a>(&'a mut self, offset: u64, len: u64) -> impl Iterator<Item=&'a mut T> + 'a\n-        where T: Clone + Default\n+    pub fn iter_mut<'a>(&'a mut self, offset: u64, len: u64) -> impl Iterator<Item = &'a mut T> + 'a\n+    where\n+        T: Clone + Default,\n     {\n         // Do a first iteration to collect the gaps\n         let mut gaps = Vec::new();\n         let mut last_end = offset;\n         for (range, _) in self.iter_with_range(offset, len) {\n             if last_end < range.start {\n-                gaps.push(Range { start: last_end, end: range.start });\n+                gaps.push(Range {\n+                    start: last_end,\n+                    end: range.start,\n+                });\n             }\n             last_end = range.end;\n         }\n-        if last_end < offset+len {\n-            gaps.push(Range { start: last_end, end: offset+len });\n+        if last_end < offset + len {\n+            gaps.push(Range {\n+                start: last_end,\n+                end: offset + len,\n+            });\n         }\n \n         // Add default for all gaps\n@@ -143,7 +185,8 @@ impl<T> RangeMap<T> {\n     }\n \n     pub fn retain<F>(&mut self, mut f: F)\n-        where F: FnMut(&T) -> bool\n+    where\n+        F: FnMut(&T) -> bool,\n     {\n         let mut remove = Vec::new();\n         for (range, data) in self.map.iter() {\n@@ -164,7 +207,10 @@ mod tests {\n \n     /// Query the map at every offset in the range and collect the results.\n     fn to_vec<T: Copy>(map: &RangeMap<T>, offset: u64, len: u64) -> Vec<T> {\n-        (offset..offset+len).into_iter().map(|i| *map.iter(i, 1).next().unwrap()).collect()\n+        (offset..offset + len)\n+            .into_iter()\n+            .map(|i| *map.iter(i, 1).next().unwrap())\n+            .collect()\n     }\n \n     #[test]\n@@ -190,10 +236,15 @@ mod tests {\n \n         // Now request a range that needs three gaps filled\n         for x in map.iter_mut(10, 10) {\n-            if *x != 42 { *x = 23; }\n+            if *x != 42 {\n+                *x = 23;\n+            }\n         }\n \n-        assert_eq!(to_vec(&map, 10, 10), vec![23, 42, 23, 23, 23, 42, 23, 23, 23, 23]);\n+        assert_eq!(\n+            to_vec(&map, 10, 10),\n+            vec![23, 42, 23, 23, 23, 42, 23, 23, 23, 23]\n+        );\n         assert_eq!(to_vec(&map, 13, 5), vec![23, 23, 42, 23, 23]);\n     }\n }"}, {"sha": "c43ad18e0d874a6f770aedf6e3c53b66d059fe8c", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 162, "deletions": 49, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -11,13 +11,8 @@ use rustc::ty;\n use rustc::ty::layout::Layout;\n use rustc::ty::subst::Substs;\n \n-use super::{\n-    EvalResult,\n-    EvalContext, StackPopCleanup, TyAndPacked, PtrAndAlign,\n-    GlobalId, Lvalue,\n-    HasMemory, MemoryKind,\n-    Machine,\n-};\n+use super::{EvalResult, EvalContext, StackPopCleanup, TyAndPacked, PtrAndAlign, GlobalId, Lvalue,\n+            HasMemory, MemoryKind, Machine};\n \n use syntax::codemap::Span;\n use syntax::ast::Mutability;\n@@ -52,7 +47,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 ecx: self,\n                 mir,\n                 new_constants: &mut new,\n-            }.visit_statement(block, stmt, mir::Location { block, statement_index: stmt_id });\n+            }.visit_statement(\n+                block,\n+                stmt,\n+                mir::Location {\n+                    block,\n+                    statement_index: stmt_id,\n+                },\n+            );\n             // if ConstantExtractor added new frames, we don't execute anything here\n             // but await the next call to step\n             if new? == 0 {\n@@ -69,7 +71,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             ecx: self,\n             mir,\n             new_constants: &mut new,\n-        }.visit_terminator(block, terminator, mir::Location { block, statement_index: stmt_id });\n+        }.visit_terminator(\n+            block,\n+            terminator,\n+            mir::Location {\n+                block,\n+                statement_index: stmt_id,\n+            },\n+        );\n         // if ConstantExtractor added new frames, we don't execute anything here\n         // but await the next call to step\n         if new? == 0 {\n@@ -85,7 +94,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         match stmt.kind {\n             Assign(ref lvalue, ref rvalue) => self.eval_rvalue_into_lvalue(rvalue, lvalue)?,\n \n-            SetDiscriminant { ref lvalue, variant_index } => {\n+            SetDiscriminant {\n+                ref lvalue,\n+                variant_index,\n+            } => {\n                 let dest = self.eval_lvalue(lvalue)?;\n                 let dest_ty = self.lvalue_ty(lvalue);\n                 let dest_layout = self.type_layout(dest_ty)?;\n@@ -94,7 +106,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     Layout::General { discr, .. } => {\n                         let discr_size = discr.size().bytes();\n                         let dest_ptr = self.force_allocation(dest)?.to_ptr()?;\n-                        self.memory.write_uint(dest_ptr, variant_index as u128, discr_size)?\n+                        self.memory.write_uint(\n+                            dest_ptr,\n+                            variant_index as u128,\n+                            discr_size,\n+                        )?\n                     }\n \n                     Layout::RawNullablePointer { nndiscr, .. } => {\n@@ -103,31 +119,57 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         }\n                     }\n \n-                    Layout::StructWrappedNullablePointer { nndiscr, ref discrfield_source, .. } => {\n+                    Layout::StructWrappedNullablePointer {\n+                        nndiscr,\n+                        ref discrfield_source,\n+                        ..\n+                    } => {\n                         if variant_index as u64 != nndiscr {\n-                            let (offset, TyAndPacked { ty, packed }) = self.nonnull_offset_and_ty(dest_ty, nndiscr, discrfield_source)?;\n-                            let nonnull = self.force_allocation(dest)?.to_ptr()?.offset(offset.bytes(), &self)?;\n+                            let (offset, TyAndPacked { ty, packed }) = self.nonnull_offset_and_ty(\n+                                dest_ty,\n+                                nndiscr,\n+                                discrfield_source,\n+                            )?;\n+                            let nonnull = self.force_allocation(dest)?.to_ptr()?.offset(\n+                                offset.bytes(),\n+                                &self,\n+                            )?;\n                             trace!(\"struct wrapped nullable pointer type: {}\", ty);\n                             // only the pointer part of a fat pointer is used for this space optimization\n-                            let discr_size = self.type_size(ty)?.expect(\"bad StructWrappedNullablePointer discrfield\");\n-                            self.write_maybe_aligned_mut(!packed, |ectx| ectx.memory.write_uint(nonnull, 0, discr_size))?;\n+                            let discr_size = self.type_size(ty)?.expect(\n+                                \"bad StructWrappedNullablePointer discrfield\",\n+                            );\n+                            self.write_maybe_aligned_mut(!packed, |ectx| {\n+                                ectx.memory.write_uint(nonnull, 0, discr_size)\n+                            })?;\n                         }\n-                    },\n+                    }\n \n-                    _ => bug!(\"SetDiscriminant on {} represented as {:#?}\", dest_ty, dest_layout),\n+                    _ => {\n+                        bug!(\n+                            \"SetDiscriminant on {} represented as {:#?}\",\n+                            dest_ty,\n+                            dest_layout\n+                        )\n+                    }\n                 }\n             }\n \n             // Mark locals as dead or alive.\n-            StorageLive(ref lvalue) | StorageDead(ref lvalue)=> {\n-                let (frame, local) = match self.eval_lvalue(lvalue)? {\n-                    Lvalue::Local{ frame, local } if self.cur_frame() == frame => (frame, local),\n-                    _ => return err!(Unimplemented(\"Storage annotations must refer to locals of the topmost stack frame.\".to_owned())) // FIXME maybe this should get its own error type\n-                };\n+            StorageLive(ref lvalue) |\n+            StorageDead(ref lvalue) => {\n+                let (frame, local) =\n+                    match self.eval_lvalue(lvalue)? {\n+                        Lvalue::Local { frame, local } if self.cur_frame() == frame => (\n+                            frame,\n+                            local,\n+                        ),\n+                        _ => return err!(Unimplemented(\"Storage annotations must refer to locals of the topmost stack frame.\".to_owned())), // FIXME maybe this should get its own error type\n+                    };\n                 let old_val = match stmt.kind {\n                     StorageLive(_) => self.stack[frame].storage_live(local)?,\n-                    StorageDead(_) =>  self.stack[frame].storage_dead(local)?,\n-                    _ => bug!(\"We already checked that we are a storage stmt\")\n+                    StorageDead(_) => self.stack[frame].storage_dead(local)?,\n+                    _ => bug!(\"We already checked that we are a storage stmt\"),\n                 };\n                 self.deallocate_local(old_val)?;\n             }\n@@ -171,30 +213,56 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         mutability: Mutability,\n     ) -> EvalResult<'tcx, bool> {\n         let instance = self.resolve_associated_const(def_id, substs);\n-        let cid = GlobalId { instance, promoted: None };\n+        let cid = GlobalId {\n+            instance,\n+            promoted: None,\n+        };\n         if self.globals.contains_key(&cid) {\n             return Ok(false);\n         }\n         if self.tcx.has_attr(def_id, \"linkage\") {\n             // FIXME: check that it's `#[linkage = \"extern_weak\"]`\n             trace!(\"Initializing an extern global with NULL\");\n             let ptr_size = self.memory.pointer_size();\n-            let ptr = self.memory.allocate(ptr_size, ptr_size, MemoryKind::UninitializedStatic)?;\n+            let ptr = self.memory.allocate(\n+                ptr_size,\n+                ptr_size,\n+                MemoryKind::UninitializedStatic,\n+            )?;\n             self.memory.write_usize(ptr, 0)?;\n             self.memory.mark_static_initalized(ptr.alloc_id, mutability)?;\n-            self.globals.insert(cid, PtrAndAlign { ptr: ptr.into(), aligned: true });\n+            self.globals.insert(\n+                cid,\n+                PtrAndAlign {\n+                    ptr: ptr.into(),\n+                    aligned: true,\n+                },\n+            );\n             return Ok(false);\n         }\n         let mir = self.load_mir(instance.def)?;\n-        let size = self.type_size_with_substs(mir.return_ty, substs)?.expect(\"unsized global\");\n+        let size = self.type_size_with_substs(mir.return_ty, substs)?.expect(\n+            \"unsized global\",\n+        );\n         let align = self.type_align_with_substs(mir.return_ty, substs)?;\n-        let ptr = self.memory.allocate(size, align, MemoryKind::UninitializedStatic)?;\n+        let ptr = self.memory.allocate(\n+            size,\n+            align,\n+            MemoryKind::UninitializedStatic,\n+        )?;\n         let aligned = !self.is_packed(mir.return_ty)?;\n-        self.globals.insert(cid, PtrAndAlign { ptr: ptr.into(), aligned });\n+        self.globals.insert(\n+            cid,\n+            PtrAndAlign {\n+                ptr: ptr.into(),\n+                aligned,\n+            },\n+        );\n         let internally_mutable = !mir.return_ty.is_freeze(\n-                self.tcx,\n-                ty::ParamEnv::empty(Reveal::All),\n-                span);\n+            self.tcx,\n+            ty::ParamEnv::empty(Reveal::All),\n+            span,\n+        );\n         let mutability = if mutability == Mutability::Mutable || internally_mutable {\n             Mutability::Mutable\n         } else {\n@@ -237,7 +305,7 @@ impl<'a, 'b, 'tcx, M: Machine<'tcx>> ConstantExtractor<'a, 'b, 'tcx, M> {\n             // everything ok + a new stackframe\n             Ok(true) => *self.new_constants = Ok(n + 1),\n             // constant correctly evaluated, but no new stackframe\n-            Ok(false) => {},\n+            Ok(false) => {}\n             // constant eval errored\n             Err(err) => *self.new_constants = Err(err),\n         }\n@@ -251,8 +319,15 @@ impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b,\n             // already computed by rustc\n             mir::Literal::Value { .. } => {}\n             mir::Literal::Item { def_id, substs } => {\n-                self.try(|this| this.ecx.global_item(def_id, substs, constant.span, Mutability::Immutable));\n-            },\n+                self.try(|this| {\n+                    this.ecx.global_item(\n+                        def_id,\n+                        substs,\n+                        constant.span,\n+                        Mutability::Immutable,\n+                    )\n+                });\n+            }\n             mir::Literal::Promoted { index } => {\n                 let cid = GlobalId {\n                     instance: self.instance,\n@@ -263,17 +338,33 @@ impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b,\n                 }\n                 let mir = &self.mir.promoted[index];\n                 self.try(|this| {\n-                    let size = this.ecx.type_size_with_substs(mir.return_ty, this.instance.substs)?.expect(\"unsized global\");\n-                    let align = this.ecx.type_align_with_substs(mir.return_ty, this.instance.substs)?;\n-                    let ptr = this.ecx.memory.allocate(size, align, MemoryKind::UninitializedStatic)?;\n+                    let size = this.ecx\n+                        .type_size_with_substs(mir.return_ty, this.instance.substs)?\n+                        .expect(\"unsized global\");\n+                    let align = this.ecx.type_align_with_substs(\n+                        mir.return_ty,\n+                        this.instance.substs,\n+                    )?;\n+                    let ptr = this.ecx.memory.allocate(\n+                        size,\n+                        align,\n+                        MemoryKind::UninitializedStatic,\n+                    )?;\n                     let aligned = !this.ecx.is_packed(mir.return_ty)?;\n-                    this.ecx.globals.insert(cid, PtrAndAlign { ptr: ptr.into(), aligned });\n+                    this.ecx.globals.insert(\n+                        cid,\n+                        PtrAndAlign {\n+                            ptr: ptr.into(),\n+                            aligned,\n+                        },\n+                    );\n                     trace!(\"pushing stack frame for {:?}\", index);\n-                    this.ecx.push_stack_frame(this.instance,\n-                                              constant.span,\n-                                              mir,\n-                                              Lvalue::from_ptr(ptr),\n-                                              StackPopCleanup::MarkStatic(Mutability::Immutable),\n+                    this.ecx.push_stack_frame(\n+                        this.instance,\n+                        constant.span,\n+                        mir,\n+                        Lvalue::from_ptr(ptr),\n+                        StackPopCleanup::MarkStatic(Mutability::Immutable),\n                     )?;\n                     Ok(true)\n                 });\n@@ -285,7 +376,7 @@ impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b,\n         &mut self,\n         lvalue: &mir::Lvalue<'tcx>,\n         context: LvalueContext<'tcx>,\n-        location: mir::Location\n+        location: mir::Location,\n     ) {\n         self.super_lvalue(lvalue, context, location);\n         if let mir::Lvalue::Static(ref static_) = *lvalue {\n@@ -295,7 +386,18 @@ impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b,\n             if let Some(node_item) = self.ecx.tcx.hir.get_if_local(def_id) {\n                 if let hir::map::Node::NodeItem(&hir::Item { ref node, .. }) = node_item {\n                     if let hir::ItemStatic(_, m, _) = *node {\n-                        self.try(|this| this.ecx.global_item(def_id, substs, span, if m == hir::MutMutable { Mutability::Mutable } else { Mutability::Immutable }));\n+                        self.try(|this| {\n+                            this.ecx.global_item(\n+                                def_id,\n+                                substs,\n+                                span,\n+                                if m == hir::MutMutable {\n+                                    Mutability::Mutable\n+                                } else {\n+                                    Mutability::Immutable\n+                                },\n+                            )\n+                        });\n                         return;\n                     } else {\n                         bug!(\"static def id doesn't point to static\");\n@@ -306,7 +408,18 @@ impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b,\n             } else {\n                 let def = self.ecx.tcx.describe_def(def_id).expect(\"static not found\");\n                 if let hir::def::Def::Static(_, mutable) = def {\n-                    self.try(|this| this.ecx.global_item(def_id, substs, span, if mutable { Mutability::Mutable } else { Mutability::Immutable }));\n+                    self.try(|this| {\n+                        this.ecx.global_item(\n+                            def_id,\n+                            substs,\n+                            span,\n+                            if mutable {\n+                                Mutability::Mutable\n+                            } else {\n+                                Mutability::Immutable\n+                            },\n+                        )\n+                    });\n                 } else {\n                     bug!(\"static found but isn't a static: {:?}\", def);\n                 }"}, {"sha": "334d23ef369fb130c9c238b2bc111261ce4e31bd", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -2,29 +2,45 @@ use rustc::mir;\n use rustc::ty::{self, Ty};\n use syntax::codemap::Span;\n \n-use interpret::{\n-    EvalResult,\n-    EvalContext, StackPopCleanup,\n-    Lvalue, LvalueExtra,\n-    PrimVal, Value,\n-    Machine,\n-};\n+use interpret::{EvalResult, EvalContext, StackPopCleanup, Lvalue, LvalueExtra, PrimVal, Value,\n+                Machine};\n \n impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n-    pub(crate) fn drop_lvalue(&mut self, lval: Lvalue, instance: ty::Instance<'tcx>, ty: Ty<'tcx>, span: Span) -> EvalResult<'tcx> {\n+    pub(crate) fn drop_lvalue(\n+        &mut self,\n+        lval: Lvalue,\n+        instance: ty::Instance<'tcx>,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> EvalResult<'tcx> {\n         trace!(\"drop_lvalue: {:#?}\", lval);\n         // We take the address of the object.  This may well be unaligned, which is fine for us here.\n         // However, unaligned accesses will probably make the actual drop implementation fail -- a problem shared\n         // by rustc.\n         let val = match self.force_allocation(lval)? {\n-            Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable) } => ptr.ptr.to_value_with_vtable(vtable),\n-            Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => ptr.ptr.to_value_with_len(len),\n-            Lvalue::Ptr { ptr, extra: LvalueExtra::None } => ptr.ptr.to_value(),\n+            Lvalue::Ptr {\n+                ptr,\n+                extra: LvalueExtra::Vtable(vtable),\n+            } => ptr.ptr.to_value_with_vtable(vtable),\n+            Lvalue::Ptr {\n+                ptr,\n+                extra: LvalueExtra::Length(len),\n+            } => ptr.ptr.to_value_with_len(len),\n+            Lvalue::Ptr {\n+                ptr,\n+                extra: LvalueExtra::None,\n+            } => ptr.ptr.to_value(),\n             _ => bug!(\"force_allocation broken\"),\n         };\n         self.drop(val, instance, ty, span)\n     }\n-    pub(crate) fn drop(&mut self, arg: Value, mut instance: ty::Instance<'tcx>, ty: Ty<'tcx>, span: Span) -> EvalResult<'tcx> {\n+    pub(crate) fn drop(\n+        &mut self,\n+        arg: Value,\n+        mut instance: ty::Instance<'tcx>,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> EvalResult<'tcx> {\n         trace!(\"drop: {:#?}, {:?}, {:?}\", arg, ty.sty, instance.def);\n \n         if let ty::InstanceDef::DropGlue(_, None) = instance.def {\n@@ -42,11 +58,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     Some(func) => {\n                         instance = func;\n                         self.load_mir(func.def)?\n-                    },\n+                    }\n                     // no drop fn -> bail out\n                     None => return Ok(()),\n                 }\n-            },\n+            }\n             _ => self.load_mir(instance.def)?,\n         };\n "}, {"sha": "dde541ed5f7dd9ddb0ac26751a971dd090063684", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 192, "deletions": 108, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -4,15 +4,8 @@ use rustc::ty::layout::Layout;\n use syntax::codemap::Span;\n use syntax::abi::Abi;\n \n-use super::{\n-    EvalError, EvalResult, EvalErrorKind,\n-    EvalContext, eval_context, TyAndPacked, PtrAndAlign,\n-    Lvalue,\n-    MemoryPointer,\n-    PrimVal, Value,\n-    Machine,\n-    HasMemory,\n-};\n+use super::{EvalError, EvalResult, EvalErrorKind, EvalContext, eval_context, TyAndPacked,\n+            PtrAndAlign, Lvalue, MemoryPointer, PrimVal, Value, Machine, HasMemory};\n use super::eval_context::IntegerExt;\n \n use rustc_data_structures::indexed_vec::Idx;\n@@ -38,7 +31,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n             Goto { target } => self.goto_block(target),\n \n-            SwitchInt { ref discr, ref values, ref targets, .. } => {\n+            SwitchInt {\n+                ref discr,\n+                ref values,\n+                ref targets,\n+                ..\n+            } => {\n                 // FIXME(CTFE): forbid branching\n                 let discr_val = self.eval_operand(discr)?;\n                 let discr_ty = self.operand_ty(discr);\n@@ -58,7 +56,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 self.goto_block(target_block);\n             }\n \n-            Call { ref func, ref args, ref destination, .. } => {\n+            Call {\n+                ref func,\n+                ref args,\n+                ref destination,\n+                ..\n+            } => {\n                 let destination = match *destination {\n                     Some((ref lv, target)) => Some((self.eval_lvalue(lv)?, target)),\n                     None => None,\n@@ -80,22 +83,35 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                                 if !self.check_sig_compat(sig, real_sig)? {\n                                     return err!(FunctionPointerTyMismatch(real_sig, sig));\n                                 }\n-                            },\n+                            }\n                             ref other => bug!(\"instance def ty: {:?}\", other),\n                         }\n                         (instance, sig)\n-                    },\n-                    ty::TyFnDef(def_id, substs) => (eval_context::resolve(self.tcx, def_id, substs), func_ty.fn_sig(self.tcx)),\n+                    }\n+                    ty::TyFnDef(def_id, substs) => (\n+                        eval_context::resolve(self.tcx, def_id, substs),\n+                        func_ty.fn_sig(self.tcx),\n+                    ),\n                     _ => {\n                         let msg = format!(\"can't handle callee of type {:?}\", func_ty);\n                         return err!(Unimplemented(msg));\n                     }\n                 };\n                 let sig = self.erase_lifetimes(&sig);\n-                self.eval_fn_call(fn_def, destination, args, terminator.source_info.span, sig)?;\n+                self.eval_fn_call(\n+                    fn_def,\n+                    destination,\n+                    args,\n+                    terminator.source_info.span,\n+                    sig,\n+                )?;\n             }\n \n-            Drop { ref location, target, .. } => {\n+            Drop {\n+                ref location,\n+                target,\n+                ..\n+            } => {\n                 trace!(\"TerminatorKind::drop: {:?}, {:?}\", location, self.substs());\n                 // FIXME(CTFE): forbid drop in const eval\n                 let lval = self.eval_lvalue(location)?;\n@@ -104,10 +120,21 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let ty = eval_context::apply_param_substs(self.tcx, self.substs(), &ty);\n \n                 let instance = eval_context::resolve_drop_in_place(self.tcx, ty);\n-                self.drop_lvalue(lval, instance, ty, terminator.source_info.span)?;\n+                self.drop_lvalue(\n+                    lval,\n+                    instance,\n+                    ty,\n+                    terminator.source_info.span,\n+                )?;\n             }\n \n-            Assert { ref cond, expected, ref msg, target, .. } => {\n+            Assert {\n+                ref cond,\n+                expected,\n+                ref msg,\n+                target,\n+                ..\n+            } => {\n                 let cond_val = self.eval_operand_to_primval(cond)?.to_bool()?;\n                 if expected == cond_val {\n                     self.goto_block(target);\n@@ -122,12 +149,13 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                                 .expect(\"can't eval index\")\n                                 .to_u64()?;\n                             err!(ArrayIndexOutOfBounds(span, len, index))\n-                        },\n-                        mir::AssertMessage::Math(ref err) =>\n-                            err!(Math(terminator.source_info.span, err.clone())),\n-                    }\n+                        }\n+                        mir::AssertMessage::Math(ref err) => {\n+                            err!(Math(terminator.source_info.span, err.clone()))\n+                        }\n+                    };\n                 }\n-            },\n+            }\n \n             DropAndReplace { .. } => unimplemented!(),\n             Resume => unimplemented!(),\n@@ -144,27 +172,30 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         sig: ty::FnSig<'tcx>,\n         real_sig: ty::FnSig<'tcx>,\n     ) -> EvalResult<'tcx, bool> {\n-        fn check_ty_compat<'tcx>(\n-            ty: ty::Ty<'tcx>,\n-            real_ty: ty::Ty<'tcx>,\n-        ) -> bool {\n-            if ty == real_ty { return true; } // This is actually a fast pointer comparison\n+        fn check_ty_compat<'tcx>(ty: ty::Ty<'tcx>, real_ty: ty::Ty<'tcx>) -> bool {\n+            if ty == real_ty {\n+                return true;\n+            } // This is actually a fast pointer comparison\n             return match (&ty.sty, &real_ty.sty) {\n                 // Permit changing the pointer type of raw pointers and references as well as\n                 // mutability of raw pointers.\n                 // TODO: Should not be allowed when fat pointers are involved.\n                 (&TypeVariants::TyRawPtr(_), &TypeVariants::TyRawPtr(_)) => true,\n-                (&TypeVariants::TyRef(_, _), &TypeVariants::TyRef(_, _)) =>\n-                    ty.is_mutable_pointer() == real_ty.is_mutable_pointer(),\n+                (&TypeVariants::TyRef(_, _), &TypeVariants::TyRef(_, _)) => {\n+                    ty.is_mutable_pointer() == real_ty.is_mutable_pointer()\n+                }\n                 // rule out everything else\n-                _ => false\n-            }\n+                _ => false,\n+            };\n         }\n \n-        if sig.abi == real_sig.abi &&\n-            sig.variadic == real_sig.variadic &&\n+        if sig.abi == real_sig.abi && sig.variadic == real_sig.variadic &&\n             sig.inputs_and_output.len() == real_sig.inputs_and_output.len() &&\n-            sig.inputs_and_output.iter().zip(real_sig.inputs_and_output).all(|(ty, real_ty)| check_ty_compat(ty, real_ty)) {\n+            sig.inputs_and_output\n+                .iter()\n+                .zip(real_sig.inputs_and_output)\n+                .all(|(ty, real_ty)| check_ty_compat(ty, real_ty))\n+        {\n             // Definitely good.\n             return Ok(true);\n         }\n@@ -224,22 +255,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 M::call_intrinsic(self, instance, arg_operands, ret, ty, layout, target)?;\n                 self.dump_local(ret);\n                 Ok(())\n-            },\n-            ty::InstanceDef::ClosureOnceShim{..} => {\n+            }\n+            ty::InstanceDef::ClosureOnceShim { .. } => {\n                 let mut args = Vec::new();\n                 for arg in arg_operands {\n                     let arg_val = self.eval_operand(arg)?;\n                     let arg_ty = self.operand_ty(arg);\n                     args.push((arg_val, arg_ty));\n                 }\n-                if M::eval_fn_call(\n-                    self,\n-                    instance,\n-                    destination,\n-                    arg_operands,\n-                    span,\n-                    sig,\n-                )? {\n+                if M::eval_fn_call(self, instance, destination, arg_operands, span, sig)? {\n                     return Ok(());\n                 }\n                 let mut arg_locals = self.frame().mir.args_iter();\n@@ -250,19 +274,25 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                             let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n                             self.write_value(arg_val, dest, arg_ty)?;\n                         }\n-                    },\n+                    }\n                     // non capture closure as fn ptr\n                     // need to inject zst ptr for closure object (aka do nothing)\n                     // and need to pack arguments\n                     Abi::Rust => {\n-                        trace!(\"arg_locals: {:?}\", self.frame().mir.args_iter().collect::<Vec<_>>());\n+                        trace!(\n+                            \"arg_locals: {:?}\",\n+                            self.frame().mir.args_iter().collect::<Vec<_>>()\n+                        );\n                         trace!(\"arg_operands: {:?}\", arg_operands);\n                         let local = arg_locals.nth(1).unwrap();\n                         for (i, (arg_val, arg_ty)) in args.into_iter().enumerate() {\n-                            let dest = self.eval_lvalue(&mir::Lvalue::Local(local).field(mir::Field::new(i), arg_ty))?;\n+                            let dest = self.eval_lvalue(&mir::Lvalue::Local(local).field(\n+                                mir::Field::new(i),\n+                                arg_ty,\n+                            ))?;\n                             self.write_value(arg_val, dest, arg_ty)?;\n                         }\n-                    },\n+                    }\n                     _ => bug!(\"bad ABI for ClosureOnceShim: {:?}\", sig.abi),\n                 }\n                 Ok(())\n@@ -276,27 +306,24 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 }\n \n                 // Push the stack frame, and potentially be entirely done if the call got hooked\n-                if M::eval_fn_call(\n-                    self,\n-                    instance,\n-                    destination,\n-                    arg_operands,\n-                    span,\n-                    sig,\n-                )? {\n+                if M::eval_fn_call(self, instance, destination, arg_operands, span, sig)? {\n                     return Ok(());\n                 }\n \n                 // Pass the arguments\n                 let mut arg_locals = self.frame().mir.args_iter();\n                 trace!(\"ABI: {:?}\", sig.abi);\n-                trace!(\"arg_locals: {:?}\", self.frame().mir.args_iter().collect::<Vec<_>>());\n+                trace!(\n+                    \"arg_locals: {:?}\",\n+                    self.frame().mir.args_iter().collect::<Vec<_>>()\n+                );\n                 trace!(\"arg_operands: {:?}\", arg_operands);\n                 match sig.abi {\n                     Abi::RustCall => {\n                         assert_eq!(args.len(), 2);\n \n-                        {   // write first argument\n+                        {\n+                            // write first argument\n                             let first_local = arg_locals.next().unwrap();\n                             let dest = self.eval_lvalue(&mir::Lvalue::Local(first_local))?;\n                             let (arg_val, arg_ty) = args.remove(0);\n@@ -306,37 +333,58 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         // unpack and write all other args\n                         let (arg_val, arg_ty) = args.remove(0);\n                         let layout = self.type_layout(arg_ty)?;\n-                        if let (&ty::TyTuple(fields, _), &Layout::Univariant { ref variant, .. }) = (&arg_ty.sty, layout) {\n+                        if let (&ty::TyTuple(fields, _),\n+                                &Layout::Univariant { ref variant, .. }) = (&arg_ty.sty, layout)\n+                        {\n                             trace!(\"fields: {:?}\", fields);\n                             if self.frame().mir.args_iter().count() == fields.len() + 1 {\n                                 let offsets = variant.offsets.iter().map(|s| s.bytes());\n                                 match arg_val {\n                                     Value::ByRef(PtrAndAlign { ptr, aligned }) => {\n-                                        assert!(aligned, \"Unaligned ByRef-values cannot occur as function arguments\");\n-                                        for ((offset, ty), arg_local) in offsets.zip(fields).zip(arg_locals) {\n+                                        assert!(\n+                                            aligned,\n+                                            \"Unaligned ByRef-values cannot occur as function arguments\"\n+                                        );\n+                                        for ((offset, ty), arg_local) in\n+                                            offsets.zip(fields).zip(arg_locals)\n+                                        {\n                                             let arg = Value::by_ref(ptr.offset(offset, &self)?);\n-                                            let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n-                                            trace!(\"writing arg {:?} to {:?} (type: {})\", arg, dest, ty);\n+                                            let dest =\n+                                                self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n+                                            trace!(\n+                                                \"writing arg {:?} to {:?} (type: {})\",\n+                                                arg,\n+                                                dest,\n+                                                ty\n+                                            );\n                                             self.write_value(arg, dest, ty)?;\n                                         }\n-                                    },\n-                                    Value::ByVal(PrimVal::Undef) => {},\n+                                    }\n+                                    Value::ByVal(PrimVal::Undef) => {}\n                                     other => {\n                                         assert_eq!(fields.len(), 1);\n-                                        let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_locals.next().unwrap()))?;\n+                                        let dest = self.eval_lvalue(&mir::Lvalue::Local(\n+                                            arg_locals.next().unwrap(),\n+                                        ))?;\n                                         self.write_value(other, dest, fields[0])?;\n                                     }\n                                 }\n                             } else {\n                                 trace!(\"manual impl of rust-call ABI\");\n                                 // called a manual impl of a rust-call function\n-                                let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_locals.next().unwrap()))?;\n+                                let dest = self.eval_lvalue(\n+                                    &mir::Lvalue::Local(arg_locals.next().unwrap()),\n+                                )?;\n                                 self.write_value(arg_val, dest, arg_ty)?;\n                             }\n                         } else {\n-                            bug!(\"rust-call ABI tuple argument was {:?}, {:?}\", arg_ty, layout);\n+                            bug!(\n+                                \"rust-call ABI tuple argument was {:?}, {:?}\",\n+                                arg_ty,\n+                                layout\n+                            );\n                         }\n-                    },\n+                    }\n                     _ => {\n                         for (arg_local, (arg_val, arg_ty)) in arg_locals.zip(args) {\n                             let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n@@ -345,7 +393,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     }\n                 }\n                 Ok(())\n-            },\n+            }\n             ty::InstanceDef::DropGlue(..) => {\n                 assert_eq!(arg_operands.len(), 1);\n                 assert_eq!(sig.abi, Abi::Rust);\n@@ -361,7 +409,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     _ => bug!(\"can only deref pointer types\"),\n                 };\n                 self.drop(val, instance, pointee_type, span)\n-            },\n+            }\n             ty::InstanceDef::FnPtrShim(..) => {\n                 trace!(\"ABI: {}\", sig.abi);\n                 let mut args = Vec::new();\n@@ -370,99 +418,135 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     let arg_ty = self.operand_ty(arg);\n                     args.push((arg_val, arg_ty));\n                 }\n-                if M::eval_fn_call(\n-                    self,\n-                    instance,\n-                    destination,\n-                    arg_operands,\n-                    span,\n-                    sig,\n-                )? {\n+                if M::eval_fn_call(self, instance, destination, arg_operands, span, sig)? {\n                     return Ok(());\n                 }\n                 let arg_locals = self.frame().mir.args_iter();\n                 match sig.abi {\n                     Abi::Rust => {\n                         args.remove(0);\n-                    },\n-                    Abi::RustCall => {},\n+                    }\n+                    Abi::RustCall => {}\n                     _ => unimplemented!(),\n                 };\n                 for (arg_local, (arg_val, arg_ty)) in arg_locals.zip(args) {\n                     let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n                     self.write_value(arg_val, dest, arg_ty)?;\n                 }\n                 Ok(())\n-            },\n+            }\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let ptr_size = self.memory.pointer_size();\n-                let (_, vtable) = self.eval_operand(&arg_operands[0])?.into_ptr_vtable_pair(&self.memory)?;\n-                let fn_ptr = self.memory.read_ptr(vtable.offset(ptr_size * (idx as u64 + 3), &self)?)?;\n+                let (_, vtable) = self.eval_operand(&arg_operands[0])?.into_ptr_vtable_pair(\n+                    &self.memory,\n+                )?;\n+                let fn_ptr = self.memory.read_ptr(\n+                    vtable.offset(ptr_size * (idx as u64 + 3), &self)?,\n+                )?;\n                 let instance = self.memory.get_fn(fn_ptr.to_ptr()?)?;\n                 let mut arg_operands = arg_operands.to_vec();\n                 let ty = self.operand_ty(&arg_operands[0]);\n                 let ty = self.get_field_ty(ty, 0)?.ty; // TODO: packed flag is ignored\n                 match arg_operands[0] {\n-                    mir::Operand::Consume(ref mut lval) => *lval = lval.clone().field(mir::Field::new(0), ty),\n+                    mir::Operand::Consume(ref mut lval) => {\n+                        *lval = lval.clone().field(mir::Field::new(0), ty)\n+                    }\n                     _ => bug!(\"virtual call first arg cannot be a constant\"),\n                 }\n                 // recurse with concrete function\n-                self.eval_fn_call(\n-                    instance,\n-                    destination,\n-                    &arg_operands,\n-                    span,\n-                    sig,\n-                )\n-            },\n+                self.eval_fn_call(instance, destination, &arg_operands, span, sig)\n+            }\n         }\n     }\n \n-    pub fn read_discriminant_value(&self, adt_ptr: MemoryPointer, adt_ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {\n+    pub fn read_discriminant_value(\n+        &self,\n+        adt_ptr: MemoryPointer,\n+        adt_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, u128> {\n         use rustc::ty::layout::Layout::*;\n         let adt_layout = self.type_layout(adt_ty)?;\n         //trace!(\"read_discriminant_value {:#?}\", adt_layout);\n \n         let discr_val = match *adt_layout {\n-            General { discr, .. } | CEnum { discr, signed: false, .. } => {\n+            General { discr, .. } |\n+            CEnum {\n+                discr,\n+                signed: false,\n+                ..\n+            } => {\n                 let discr_size = discr.size().bytes();\n                 self.memory.read_uint(adt_ptr, discr_size)?\n             }\n \n-            CEnum { discr, signed: true, .. } => {\n+            CEnum {\n+                discr,\n+                signed: true,\n+                ..\n+            } => {\n                 let discr_size = discr.size().bytes();\n                 self.memory.read_int(adt_ptr, discr_size)? as u128\n             }\n \n             RawNullablePointer { nndiscr, value } => {\n                 let discr_size = value.size(&self.tcx.data_layout).bytes();\n                 trace!(\"rawnullablepointer with size {}\", discr_size);\n-                self.read_nonnull_discriminant_value(adt_ptr, nndiscr as u128, discr_size)?\n+                self.read_nonnull_discriminant_value(\n+                    adt_ptr,\n+                    nndiscr as u128,\n+                    discr_size,\n+                )?\n             }\n \n-            StructWrappedNullablePointer { nndiscr, ref discrfield_source, .. } => {\n-                let (offset, TyAndPacked { ty, packed }) = self.nonnull_offset_and_ty(adt_ty, nndiscr, discrfield_source)?;\n+            StructWrappedNullablePointer {\n+                nndiscr,\n+                ref discrfield_source,\n+                ..\n+            } => {\n+                let (offset, TyAndPacked { ty, packed }) = self.nonnull_offset_and_ty(\n+                    adt_ty,\n+                    nndiscr,\n+                    discrfield_source,\n+                )?;\n                 let nonnull = adt_ptr.offset(offset.bytes(), &*self)?;\n                 trace!(\"struct wrapped nullable pointer type: {}\", ty);\n                 // only the pointer part of a fat pointer is used for this space optimization\n-                let discr_size = self.type_size(ty)?.expect(\"bad StructWrappedNullablePointer discrfield\");\n-                self.read_maybe_aligned(!packed,\n-                    |ectx| ectx.read_nonnull_discriminant_value(nonnull, nndiscr as u128, discr_size))?\n+                let discr_size = self.type_size(ty)?.expect(\n+                    \"bad StructWrappedNullablePointer discrfield\",\n+                );\n+                self.read_maybe_aligned(!packed, |ectx| {\n+                    ectx.read_nonnull_discriminant_value(nonnull, nndiscr as u128, discr_size)\n+                })?\n             }\n \n             // The discriminant_value intrinsic returns 0 for non-sum types.\n-            Array { .. } | FatPointer { .. } | Scalar { .. } | Univariant { .. } |\n-            Vector { .. } | UntaggedUnion { .. } => 0,\n+            Array { .. } |\n+            FatPointer { .. } |\n+            Scalar { .. } |\n+            Univariant { .. } |\n+            Vector { .. } |\n+            UntaggedUnion { .. } => 0,\n         };\n \n         Ok(discr_val)\n     }\n \n-    fn read_nonnull_discriminant_value(&self, ptr: MemoryPointer, nndiscr: u128, discr_size: u64) -> EvalResult<'tcx, u128> {\n-        trace!(\"read_nonnull_discriminant_value: {:?}, {}, {}\", ptr, nndiscr, discr_size);\n+    fn read_nonnull_discriminant_value(\n+        &self,\n+        ptr: MemoryPointer,\n+        nndiscr: u128,\n+        discr_size: u64,\n+    ) -> EvalResult<'tcx, u128> {\n+        trace!(\n+            \"read_nonnull_discriminant_value: {:?}, {}, {}\",\n+            ptr,\n+            nndiscr,\n+            discr_size\n+        );\n         let not_null = match self.memory.read_uint(ptr, discr_size) {\n             Ok(0) => false,\n-            Ok(_) | Err(EvalError{ kind: EvalErrorKind::ReadPointerAsBytes, .. }) => true,\n+            Ok(_) |\n+            Err(EvalError { kind: EvalErrorKind::ReadPointerAsBytes, .. }) => true,\n             Err(e) => return Err(e),\n         };\n         assert!(nndiscr == 0 || nndiscr == 1);"}, {"sha": "07d7de854b99e9ec1f295efedd245e52b817e437", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 39, "deletions": 17, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -5,16 +5,14 @@ use rustc::ty::{self, Ty};\n use syntax::codemap::DUMMY_SP;\n use syntax::ast::{self, Mutability};\n \n-use super::{\n-    EvalResult,\n-    EvalContext, eval_context,\n-    MemoryPointer, MemoryKind,\n-    Value, PrimVal,\n-    Machine,\n-};\n+use super::{EvalResult, EvalContext, eval_context, MemoryPointer, MemoryKind, Value, PrimVal,\n+            Machine};\n \n impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n-    pub(crate) fn fulfill_obligation(&self, trait_ref: ty::PolyTraitRef<'tcx>) -> traits::Vtable<'tcx, ()> {\n+    pub(crate) fn fulfill_obligation(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+    ) -> traits::Vtable<'tcx, ()> {\n         // Do the initial selection for the obligation. This yields the shallow result we are\n         // looking for -- that is, what specific impl.\n         self.tcx.infer_ctxt().enter(|infcx| {\n@@ -43,15 +41,25 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     /// The `trait_ref` encodes the erased self type. Hence if we are\n     /// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n     /// `trait_ref` would map `T:Trait`.\n-    pub fn get_vtable(&mut self, ty: Ty<'tcx>, trait_ref: ty::PolyTraitRef<'tcx>) -> EvalResult<'tcx, MemoryPointer> {\n+    pub fn get_vtable(\n+        &mut self,\n+        ty: Ty<'tcx>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+    ) -> EvalResult<'tcx, MemoryPointer> {\n         debug!(\"get_vtable(trait_ref={:?})\", trait_ref);\n \n-        let size = self.type_size(trait_ref.self_ty())?.expect(\"can't create a vtable for an unsized type\");\n+        let size = self.type_size(trait_ref.self_ty())?.expect(\n+            \"can't create a vtable for an unsized type\",\n+        );\n         let align = self.type_align(trait_ref.self_ty())?;\n \n         let ptr_size = self.memory.pointer_size();\n         let methods = ::rustc::traits::get_vtable_methods(self.tcx, trait_ref);\n-        let vtable = self.memory.allocate(ptr_size * (3 + methods.count() as u64), ptr_size, MemoryKind::UninitializedStatic)?;\n+        let vtable = self.memory.allocate(\n+            ptr_size * (3 + methods.count() as u64),\n+            ptr_size,\n+            MemoryKind::UninitializedStatic,\n+        )?;\n \n         let drop = eval_context::resolve_drop_in_place(self.tcx, ty);\n         let drop = self.memory.create_fn_alloc(drop);\n@@ -71,12 +79,18 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n         }\n \n-        self.memory.mark_static_initalized(vtable.alloc_id, Mutability::Mutable)?;\n+        self.memory.mark_static_initalized(\n+            vtable.alloc_id,\n+            Mutability::Mutable,\n+        )?;\n \n         Ok(vtable)\n     }\n \n-    pub fn read_drop_type_from_vtable(&self, vtable: MemoryPointer) -> EvalResult<'tcx, Option<ty::Instance<'tcx>>> {\n+    pub fn read_drop_type_from_vtable(\n+        &self,\n+        vtable: MemoryPointer,\n+    ) -> EvalResult<'tcx, Option<ty::Instance<'tcx>>> {\n         // we don't care about the pointee type, we just want a pointer\n         match self.read_ptr(vtable, self.tcx.mk_nil_ptr())? {\n             // some values don't need to call a drop impl, so the value is null\n@@ -86,10 +100,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n     }\n \n-    pub fn read_size_and_align_from_vtable(&self, vtable: MemoryPointer) -> EvalResult<'tcx, (u64, u64)> {\n+    pub fn read_size_and_align_from_vtable(\n+        &self,\n+        vtable: MemoryPointer,\n+    ) -> EvalResult<'tcx, (u64, u64)> {\n         let pointer_size = self.memory.pointer_size();\n         let size = self.memory.read_usize(vtable.offset(pointer_size, self)?)?;\n-        let align = self.memory.read_usize(vtable.offset(pointer_size * 2, self)?)?;\n+        let align = self.memory.read_usize(\n+            vtable.offset(pointer_size * 2, self)?,\n+        )?;\n         Ok((size, align))\n     }\n \n@@ -103,8 +122,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             let vtable = self.fulfill_obligation(trait_ref);\n             if let traits::VtableImpl(vtable_impl) = vtable {\n                 let name = self.tcx.item_name(def_id);\n-                let assoc_const_opt = self.tcx.associated_items(vtable_impl.impl_def_id)\n-                    .find(|item| item.kind == ty::AssociatedKind::Const && item.name == name);\n+                let assoc_const_opt = self.tcx.associated_items(vtable_impl.impl_def_id).find(\n+                    |item| {\n+                        item.kind == ty::AssociatedKind::Const && item.name == name\n+                    },\n+                );\n                 if let Some(assoc_const) = assoc_const_opt {\n                     return ty::Instance::new(assoc_const.def_id, vtable_impl.substs);\n                 }"}, {"sha": "20b601b538c4300960c5285a772efdb714ebe070", "filename": "src/librustc_mir/interpret/validation.rs", "status": "modified", "additions": 217, "deletions": 81, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -8,14 +8,8 @@ use rustc::infer::InferCtxt;\n use rustc::traits::Reveal;\n use rustc::middle::region::CodeExtent;\n \n-use super::{\n-    EvalError, EvalResult, EvalErrorKind,\n-    EvalContext, DynamicLifetime,\n-    AccessKind,\n-    Value,\n-    Lvalue, LvalueExtra,\n-    Machine,\n-};\n+use super::{EvalError, EvalResult, EvalErrorKind, EvalContext, DynamicLifetime, AccessKind, Value,\n+            Lvalue, LvalueExtra, Machine};\n \n pub type ValidationQuery<'tcx> = ValidationOperand<'tcx, Lvalue>;\n \n@@ -39,7 +33,11 @@ impl ValidationMode {\n \n // Validity checks\n impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n-    pub(crate) fn validation_op(&mut self, op: ValidationOp, operand: &ValidationOperand<'tcx, mir::Lvalue<'tcx>>) -> EvalResult<'tcx> {\n+    pub(crate) fn validation_op(\n+        &mut self,\n+        op: ValidationOp,\n+        operand: &ValidationOperand<'tcx, mir::Lvalue<'tcx>>,\n+    ) -> EvalResult<'tcx> {\n         // If mir-emit-validate is set to 0 (i.e., disabled), we may still see validation commands\n         // because other crates may have been compiled with mir-emit-validate > 0.  Ignore those\n         // commands.  This makes mir-emit-validate also a flag to control whether miri will do\n@@ -73,24 +71,34 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             // Now test\n             let name = self.stack[self.cur_frame()].instance.to_string();\n             if RE.is_match(&name) {\n-                return Ok(())\n+                return Ok(());\n             }\n         }\n \n         // We need to monomorphize ty *without* erasing lifetimes\n         let ty = operand.ty.subst(self.tcx, self.substs());\n         let lval = self.eval_lvalue(&operand.lval)?;\n-        let query = ValidationQuery { lval, ty, re: operand.re, mutbl: operand.mutbl };\n+        let query = ValidationQuery {\n+            lval,\n+            ty,\n+            re: operand.re,\n+            mutbl: operand.mutbl,\n+        };\n \n         // Check the mode, and also perform mode-specific operations\n         let mode = match op {\n             ValidationOp::Acquire => ValidationMode::Acquire,\n             ValidationOp::Release => ValidationMode::ReleaseUntil(None),\n             ValidationOp::Suspend(ce) => {\n                 if query.mutbl == MutMutable {\n-                    let lft = DynamicLifetime { frame: self.cur_frame(), region: Some(ce) };\n+                    let lft = DynamicLifetime {\n+                        frame: self.cur_frame(),\n+                        region: Some(ce),\n+                    };\n                     trace!(\"Suspending {:?} until {:?}\", query, ce);\n-                    self.suspended.entry(lft).or_insert_with(Vec::new).push(query.clone());\n+                    self.suspended.entry(lft).or_insert_with(Vec::new).push(\n+                        query.clone(),\n+                    );\n                 }\n                 ValidationMode::ReleaseUntil(Some(ce))\n             }\n@@ -101,7 +109,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub(crate) fn end_region(&mut self, ce: CodeExtent) -> EvalResult<'tcx> {\n         self.memory.locks_lifetime_ended(Some(ce));\n         // Recover suspended lvals\n-        let lft = DynamicLifetime { frame: self.cur_frame(), region: Some(ce) };\n+        let lft = DynamicLifetime {\n+            frame: self.cur_frame(),\n+            region: Some(ce),\n+        };\n         if let Some(queries) = self.suspended.remove(&lft) {\n             for query in queries {\n                 trace!(\"Recovering {:?} from suspension\", query);\n@@ -118,16 +129,19 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n         // We copy a bunch of stuff from rustc/infer/mod.rs to be able to tweak its behavior\n         fn normalize_projections_in<'a, 'gcx, 'tcx, T>(\n-                self_: &InferCtxt<'a, 'gcx, 'tcx>,\n-                param_env: ty::ParamEnv<'tcx>,\n-                value: &T)\n-                -> T::Lifted\n-            where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n+            self_: &InferCtxt<'a, 'gcx, 'tcx>,\n+            param_env: ty::ParamEnv<'tcx>,\n+            value: &T,\n+        ) -> T::Lifted\n+        where\n+            T: TypeFoldable<'tcx> + ty::Lift<'gcx>,\n         {\n             let mut selcx = traits::SelectionContext::new(self_);\n             let cause = traits::ObligationCause::dummy();\n-            let traits::Normalized { value: result, obligations } =\n-                traits::normalize(&mut selcx, param_env, cause, value);\n+            let traits::Normalized {\n+                value: result,\n+                obligations,\n+            } = traits::normalize(&mut selcx, param_env, cause, value);\n \n             let mut fulfill_cx = traits::FulfillmentContext::new();\n \n@@ -139,26 +153,37 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n \n         fn drain_fulfillment_cx_or_panic<'a, 'gcx, 'tcx, T>(\n-                                                self_: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                                span: Span,\n-                                                fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n-                                                result: &T)\n-                                                -> T::Lifted\n-            where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n+            self_: &InferCtxt<'a, 'gcx, 'tcx>,\n+            span: Span,\n+            fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n+            result: &T,\n+        ) -> T::Lifted\n+        where\n+            T: TypeFoldable<'tcx> + ty::Lift<'gcx>,\n         {\n             // In principle, we only need to do this so long as `result`\n             // contains unbound type parameters. It could be a slight\n             // optimization to stop iterating early.\n             match fulfill_cx.select_all_or_error(self_) {\n                 Ok(()) => { }\n                 Err(errors) => {\n-                    span_bug!(span, \"Encountered errors `{:?}` resolving bounds after type-checking\",\n-                                errors);\n+                    span_bug!(\n+                        span,\n+                        \"Encountered errors `{:?}` resolving bounds after type-checking\",\n+                        errors\n+                    );\n                 }\n             }\n \n             let result = self_.resolve_type_vars_if_possible(result);\n-            let result = self_.tcx.fold_regions(&result, &mut false, |r, _| match *r { ty::ReVar(_) => self_.tcx.types.re_erased, _ => r });\n+            let result = self_.tcx.fold_regions(\n+                &result,\n+                &mut false,\n+                |r, _| match *r {\n+                    ty::ReVar(_) => self_.tcx.types.re_erased,\n+                    _ => r,\n+                },\n+            );\n \n             match self_.tcx.lift_to_global(&result) {\n                 Some(result) => result,\n@@ -169,10 +194,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n \n         trait MyTransNormalize<'gcx>: TypeFoldable<'gcx> {\n-            fn my_trans_normalize<'a, 'tcx>(&self,\n-                                        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                        param_env: ty::ParamEnv<'tcx>)\n-                                        -> Self;\n+            fn my_trans_normalize<'a, 'tcx>(\n+                &self,\n+                infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                param_env: ty::ParamEnv<'tcx>,\n+            ) -> Self;\n         }\n \n         macro_rules! items { ($($item:item)+) => ($($item)+) }\n@@ -200,7 +226,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         );\n \n         fn normalize_associated_type<'a, 'tcx, T>(self_: TyCtxt<'a, 'tcx, 'tcx>, value: &T) -> T\n-            where T: MyTransNormalize<'tcx>\n+        where\n+            T: MyTransNormalize<'tcx>,\n         {\n             let param_env = ty::ParamEnv::empty(Reveal::All);\n \n@@ -225,43 +252,66 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         for (idx, field) in variant.fields.iter().enumerate() {\n             let field_ty = field.ty(self.tcx, subst);\n             let field_lvalue = self.lvalue_field(query.lval, idx, query.ty, field_ty)?;\n-            self.validate(ValidationQuery { lval: field_lvalue, ty: field_ty, ..query }, mode)?;\n+            self.validate(\n+                ValidationQuery {\n+                    lval: field_lvalue,\n+                    ty: field_ty,\n+                    ..query\n+                },\n+                mode,\n+            )?;\n         }\n         Ok(())\n     }\n \n-    fn validate_ptr(&mut self, val: Value, pointee_ty: Ty<'tcx>, re: Option<CodeExtent>, mutbl: Mutability, mode: ValidationMode) -> EvalResult<'tcx> {\n+    fn validate_ptr(\n+        &mut self,\n+        val: Value,\n+        pointee_ty: Ty<'tcx>,\n+        re: Option<CodeExtent>,\n+        mutbl: Mutability,\n+        mode: ValidationMode,\n+    ) -> EvalResult<'tcx> {\n         // Check alignment and non-NULLness\n         let (_, align) = self.size_and_align_of_dst(pointee_ty, val)?;\n         let ptr = val.into_ptr(&self.memory)?;\n         self.memory.check_align(ptr, align)?;\n \n         // Recurse\n         let pointee_lvalue = self.val_to_lvalue(val, pointee_ty)?;\n-        self.validate(ValidationQuery { lval: pointee_lvalue, ty: pointee_ty, re, mutbl }, mode)\n+        self.validate(\n+            ValidationQuery {\n+                lval: pointee_lvalue,\n+                ty: pointee_ty,\n+                re,\n+                mutbl,\n+            },\n+            mode,\n+        )\n     }\n \n     /// Validate the lvalue at the given type. If `acquire` is false, just do a release of all write locks\n     #[inline]\n-    fn validate(&mut self, query: ValidationQuery<'tcx>, mode: ValidationMode) -> EvalResult<'tcx>\n-    {\n+    fn validate(&mut self, query: ValidationQuery<'tcx>, mode: ValidationMode) -> EvalResult<'tcx> {\n         match self.try_validate(query, mode) {\n             // ReleaseUntil(None) of an uninitalized variable is a NOP.  This is needed because\n             // we have to release the return value of a function; due to destination-passing-style\n             // the callee may directly write there.\n             // TODO: Ideally we would know whether the destination is already initialized, and only\n             // release if it is.  But of course that can't even always be statically determined.\n-            Err(EvalError{ kind: EvalErrorKind::ReadUndefBytes, ..})\n-                if mode == ValidationMode::ReleaseUntil(None)\n-            => {\n+            Err(EvalError { kind: EvalErrorKind::ReadUndefBytes, .. })\n+                if mode == ValidationMode::ReleaseUntil(None) => {\n                 return Ok(());\n             }\n             res => res,\n         }\n     }\n \n-    fn try_validate(&mut self, mut query: ValidationQuery<'tcx>, mode: ValidationMode) -> EvalResult<'tcx>\n-    {\n+    fn try_validate(\n+        &mut self,\n+        mut query: ValidationQuery<'tcx>,\n+        mode: ValidationMode,\n+    ) -> EvalResult<'tcx> {\n         use rustc::ty::TypeVariants::*;\n         use rustc::ty::RegionKind::*;\n         use rustc::ty::AdtKind;\n@@ -284,12 +334,13 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             Lvalue::Local { frame, local } => {\n                 let res = self.stack[frame].get_local(local);\n                 match (res, mode) {\n-                    (Err(EvalError{ kind: EvalErrorKind::DeadLocal, ..}), ValidationMode::Recover(_)) => {\n+                    (Err(EvalError { kind: EvalErrorKind::DeadLocal, .. }),\n+                     ValidationMode::Recover(_)) => {\n                         return Ok(());\n                     }\n-                    _ => {},\n+                    _ => {}\n                 }\n-            },\n+            }\n             _ => {}\n         }\n \n@@ -300,12 +351,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         // just assembles pieces (that each own their memory) together to a larger whole.\n         // TODO: Currently, we don't acquire locks for padding and discriminants. We should.\n         let is_owning = match query.ty.sty {\n-            TyInt(_) | TyUint(_) | TyRawPtr(_) |\n-            TyBool | TyFloat(_) | TyChar | TyStr |\n+            TyInt(_) | TyUint(_) | TyRawPtr(_) | TyBool | TyFloat(_) | TyChar | TyStr |\n             TyRef(..) | TyFnPtr(..) | TyFnDef(..) | TyNever => true,\n             TyAdt(adt, _) if adt.is_box() => true,\n-            TySlice(_) | TyAdt(_, _) | TyTuple(..) | TyClosure(..) | TyArray(..) | TyDynamic(..) => false,\n-            TyParam(_) | TyInfer(_) | TyProjection(_) | TyAnon(..) | TyError => bug!(\"I got an incomplete/unnormalized type for validation\"),\n+            TySlice(_) | TyAdt(_, _) | TyTuple(..) | TyClosure(..) | TyArray(..) |\n+            TyDynamic(..) => false,\n+            TyParam(_) | TyInfer(_) | TyProjection(_) | TyAnon(..) | TyError => {\n+                bug!(\"I got an incomplete/unnormalized type for validation\")\n+            }\n         };\n         if is_owning {\n             // We need to lock.  So we need memory.  So we have to force_acquire.\n@@ -322,7 +375,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 }\n                 None => {\n                     // The only unsized typ we concider \"owning\" is TyStr.\n-                    assert_eq!(query.ty.sty, TyStr, \"Found a surprising unsized owning type\");\n+                    assert_eq!(\n+                        query.ty.sty,\n+                        TyStr,\n+                        \"Found a surprising unsized owning type\"\n+                    );\n                     // The extra must be the length, in bytes.\n                     match extra {\n                         LvalueExtra::Length(len) => len,\n@@ -334,20 +391,45 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             if len > 0 {\n                 let ptr = ptr.to_ptr()?;\n                 match query.mutbl {\n-                    MutImmutable =>\n+                    MutImmutable => {\n                         if mode.acquiring() {\n-                            self.memory.acquire_lock(ptr, len, query.re, AccessKind::Read)?;\n+                            self.memory.acquire_lock(\n+                                ptr,\n+                                len,\n+                                query.re,\n+                                AccessKind::Read,\n+                            )?;\n                         }\n-                        // No releasing of read locks, ever.\n-                    MutMutable =>\n+                    }\n+                    // No releasing of read locks, ever.\n+                    MutMutable => {\n                         match mode {\n-                            ValidationMode::Acquire =>\n-                                self.memory.acquire_lock(ptr, len, query.re, AccessKind::Write)?,\n-                            ValidationMode::Recover(ending_ce) =>\n-                                self.memory.recover_write_lock(ptr, len, query.re, ending_ce)?,\n-                            ValidationMode::ReleaseUntil(suspended_ce) =>\n-                                self.memory.suspend_write_lock(ptr, len, query.re, suspended_ce)?,\n+                            ValidationMode::Acquire => {\n+                                self.memory.acquire_lock(\n+                                    ptr,\n+                                    len,\n+                                    query.re,\n+                                    AccessKind::Write,\n+                                )?\n+                            }\n+                            ValidationMode::Recover(ending_ce) => {\n+                                self.memory.recover_write_lock(\n+                                    ptr,\n+                                    len,\n+                                    query.re,\n+                                    ending_ce,\n+                                )?\n+                            }\n+                            ValidationMode::ReleaseUntil(suspended_ce) => {\n+                                self.memory.suspend_write_lock(\n+                                    ptr,\n+                                    len,\n+                                    query.re,\n+                                    suspended_ce,\n+                                )?\n+                            }\n                         }\n+                    }\n                 }\n             }\n         }\n@@ -362,10 +444,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 // TODO: Check if these are valid bool/float/codepoint/UTF-8, respectively (and in particular, not undef).\n                 Ok(())\n             }\n-            TyNever => {\n-                err!(ValidationFailure(format!(\"The empty type is never valid.\")))\n-            }\n-            TyRef(region, ty::TypeAndMut { ty: pointee_ty, mutbl }) => {\n+            TyNever => err!(ValidationFailure(format!(\"The empty type is never valid.\"))),\n+            TyRef(region,\n+                  ty::TypeAndMut {\n+                      ty: pointee_ty,\n+                      mutbl,\n+                  }) => {\n                 let val = self.read_lvalue(query.lval)?;\n                 // Sharing restricts our context\n                 if mutbl == MutImmutable {\n@@ -378,7 +462,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         ReScope(ce) => query.re = Some(ce),\n                         // It is possible for us to encounter erased lifetimes here because the lifetimes in\n                         // this functions' Subst will be erased.\n-                        _ => {},\n+                        _ => {}\n                     }\n                 }\n                 self.validate_ptr(val, pointee_ty, query.re, query.mutbl, mode)\n@@ -388,7 +472,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 self.validate_ptr(val, query.ty.boxed_ty(), query.re, query.mutbl, mode)\n             }\n             TyFnPtr(_sig) => {\n-                let ptr = self.read_lvalue(query.lval)?.into_ptr(&self.memory)?.to_ptr()?;\n+                let ptr = self.read_lvalue(query.lval)?\n+                    .into_ptr(&self.memory)?\n+                    .to_ptr()?;\n                 self.memory.get_fn(ptr)?;\n                 // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n                 Ok(())\n@@ -403,26 +489,50 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             TySlice(elem_ty) => {\n                 let len = match query.lval {\n                     Lvalue::Ptr { extra: LvalueExtra::Length(len), .. } => len,\n-                    _ => bug!(\"acquire_valid of a TySlice given non-slice lvalue: {:?}\", query.lval),\n+                    _ => {\n+                        bug!(\n+                            \"acquire_valid of a TySlice given non-slice lvalue: {:?}\",\n+                            query.lval\n+                        )\n+                    }\n                 };\n                 for i in 0..len {\n                     let inner_lvalue = self.lvalue_index(query.lval, query.ty, i)?;\n-                    self.validate(ValidationQuery { lval: inner_lvalue, ty: elem_ty, ..query }, mode)?;\n+                    self.validate(\n+                        ValidationQuery {\n+                            lval: inner_lvalue,\n+                            ty: elem_ty,\n+                            ..query\n+                        },\n+                        mode,\n+                    )?;\n                 }\n                 Ok(())\n             }\n             TyArray(elem_ty, len) => {\n                 for i in 0..len {\n                     let inner_lvalue = self.lvalue_index(query.lval, query.ty, i as u64)?;\n-                    self.validate(ValidationQuery { lval: inner_lvalue, ty: elem_ty, ..query }, mode)?;\n+                    self.validate(\n+                        ValidationQuery {\n+                            lval: inner_lvalue,\n+                            ty: elem_ty,\n+                            ..query\n+                        },\n+                        mode,\n+                    )?;\n                 }\n                 Ok(())\n             }\n             TyDynamic(_data, _region) => {\n                 // Check that this is a valid vtable\n                 let vtable = match query.lval {\n                     Lvalue::Ptr { extra: LvalueExtra::Vtable(vtable), .. } => vtable,\n-                    _ => bug!(\"acquire_valid of a TyDynamic given non-trait-object lvalue: {:?}\", query.lval),\n+                    _ => {\n+                        bug!(\n+                            \"acquire_valid of a TyDynamic given non-trait-object lvalue: {:?}\",\n+                            query.lval\n+                        )\n+                    }\n                 };\n                 self.read_size_and_align_from_vtable(vtable)?;\n                 // TODO: Check that the vtable contains all the function pointers we expect it to have.\n@@ -433,7 +543,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 Ok(())\n             }\n             TyAdt(adt, subst) => {\n-                if Some(adt.did) == self.tcx.lang_items.unsafe_cell_type() && query.mutbl == MutImmutable {\n+                if Some(adt.did) == self.tcx.lang_items.unsafe_cell_type() &&\n+                    query.mutbl == MutImmutable\n+                {\n                     // No locks for shared unsafe cells.  Also no other validation, the only field is private anyway.\n                     return Ok(());\n                 }\n@@ -445,8 +557,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         let discr = self.read_discriminant_value(ptr, query.ty)?;\n \n                         // Get variant index for discriminant\n-                        let variant_idx = adt.discriminants(self.tcx)\n-                            .position(|variant_discr| variant_discr.to_u128_unchecked() == discr);\n+                        let variant_idx = adt.discriminants(self.tcx).position(|variant_discr| {\n+                            variant_discr.to_u128_unchecked() == discr\n+                        });\n                         let variant_idx = match variant_idx {\n                             Some(val) => val,\n                             None => return err!(InvalidDiscriminant),\n@@ -456,13 +569,22 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         if variant.fields.len() > 0 {\n                             // Downcast to this variant, if needed\n                             let lval = if adt.variants.len() > 1 {\n-                                self.eval_lvalue_projection(query.lval, query.ty, &mir::ProjectionElem::Downcast(adt, variant_idx))?\n+                                self.eval_lvalue_projection(\n+                                    query.lval,\n+                                    query.ty,\n+                                    &mir::ProjectionElem::Downcast(adt, variant_idx),\n+                                )?\n                             } else {\n                                 query.lval\n                             };\n \n                             // Recursively validate the fields\n-                            self.validate_variant(ValidationQuery { lval, ..query} , variant, subst, mode)\n+                            self.validate_variant(\n+                                ValidationQuery { lval, ..query },\n+                                variant,\n+                                subst,\n+                                mode,\n+                            )\n                         } else {\n                             // No fields, nothing left to check.  Downcasting may fail, e.g. in case of a CEnum.\n                             Ok(())\n@@ -481,20 +603,34 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             TyTuple(ref types, _) => {\n                 for (idx, field_ty) in types.iter().enumerate() {\n                     let field_lvalue = self.lvalue_field(query.lval, idx, query.ty, field_ty)?;\n-                    self.validate(ValidationQuery { lval: field_lvalue, ty: field_ty, ..query }, mode)?;\n+                    self.validate(\n+                        ValidationQuery {\n+                            lval: field_lvalue,\n+                            ty: field_ty,\n+                            ..query\n+                        },\n+                        mode,\n+                    )?;\n                 }\n                 Ok(())\n             }\n             TyClosure(def_id, ref closure_substs) => {\n                 for (idx, field_ty) in closure_substs.upvar_tys(def_id, self.tcx).enumerate() {\n                     let field_lvalue = self.lvalue_field(query.lval, idx, query.ty, field_ty)?;\n-                    self.validate(ValidationQuery { lval: field_lvalue, ty: field_ty, ..query }, mode)?;\n+                    self.validate(\n+                        ValidationQuery {\n+                            lval: field_lvalue,\n+                            ty: field_ty,\n+                            ..query\n+                        },\n+                        mode,\n+                    )?;\n                 }\n                 // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n                 // Is there other things we can/should check?  Like vtable pointers?\n                 Ok(())\n             }\n-            _ => bug!(\"We already establishd that this is a type we support.\")\n+            _ => bug!(\"We already establishd that this is a type we support.\"),\n         }\n     }\n }"}, {"sha": "8424e72fef02602860c52c779c37df6acf020796", "filename": "src/librustc_mir/interpret/value.rs", "status": "modified", "additions": 44, "deletions": 27, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -3,12 +3,7 @@\n \n use rustc::ty::layout::HasDataLayout;\n \n-use super::{\n-    EvalResult,\n-    Memory, MemoryPointer, HasMemory, PointerArithmetic,\n-    Machine,\n-    PtrAndAlign,\n-};\n+use super::{EvalResult, Memory, MemoryPointer, HasMemory, PointerArithmetic, Machine, PtrAndAlign};\n \n pub(super) fn bytes_to_f32(bytes: u128) -> f32 {\n     f32::from_bits(bytes as u32)\n@@ -70,8 +65,10 @@ impl<'tcx> Pointer {\n         match self.primval {\n             PrimVal::Bytes(b) => {\n                 assert_eq!(b as u64 as u128, b);\n-                Ok(Pointer::from(PrimVal::Bytes(layout.signed_offset(b as u64, i)? as u128)))\n-            },\n+                Ok(Pointer::from(\n+                    PrimVal::Bytes(layout.signed_offset(b as u64, i)? as u128),\n+                ))\n+            }\n             PrimVal::Ptr(ptr) => ptr.signed_offset(i, layout).map(Pointer::from),\n             PrimVal::Undef => err!(ReadUndefBytes),\n         }\n@@ -82,8 +79,10 @@ impl<'tcx> Pointer {\n         match self.primval {\n             PrimVal::Bytes(b) => {\n                 assert_eq!(b as u64 as u128, b);\n-                Ok(Pointer::from(PrimVal::Bytes(layout.offset(b as u64, i)? as u128)))\n-            },\n+                Ok(Pointer::from(\n+                    PrimVal::Bytes(layout.offset(b as u64, i)? as u128),\n+                ))\n+            }\n             PrimVal::Ptr(ptr) => ptr.offset(i, layout).map(Pointer::from),\n             PrimVal::Undef => err!(ReadUndefBytes),\n         }\n@@ -94,8 +93,10 @@ impl<'tcx> Pointer {\n         match self.primval {\n             PrimVal::Bytes(b) => {\n                 assert_eq!(b as u64 as u128, b);\n-                Ok(Pointer::from(PrimVal::Bytes(layout.wrapping_signed_offset(b as u64, i) as u128)))\n-            },\n+                Ok(Pointer::from(PrimVal::Bytes(\n+                    layout.wrapping_signed_offset(b as u64, i) as u128,\n+                )))\n+            }\n             PrimVal::Ptr(ptr) => Ok(Pointer::from(ptr.wrapping_signed_offset(i, layout))),\n             PrimVal::Undef => err!(ReadUndefBytes),\n         }\n@@ -158,10 +159,9 @@ pub enum PrimValKind {\n     I8, I16, I32, I64, I128,\n     U8, U16, U32, U64, U128,\n     F32, F64,\n+    Ptr, FnPtr,\n     Bool,\n     Char,\n-    Ptr,\n-    FnPtr,\n }\n \n impl<'a, 'tcx: 'a> Value {\n@@ -172,26 +172,35 @@ impl<'a, 'tcx: 'a> Value {\n \n     /// Convert the value into a pointer (or a pointer-sized integer).  If the value is a ByRef,\n     /// this may have to perform a load.\n-    pub fn into_ptr<M: Machine<'tcx>>(&self, mem: &Memory<'a, 'tcx, M>) -> EvalResult<'tcx, Pointer> {\n+    pub fn into_ptr<M: Machine<'tcx>>(\n+        &self,\n+        mem: &Memory<'a, 'tcx, M>,\n+    ) -> EvalResult<'tcx, Pointer> {\n         use self::Value::*;\n         match *self {\n             ByRef(PtrAndAlign { ptr, aligned }) => {\n-                mem.read_maybe_aligned(aligned, |mem| mem.read_ptr(ptr.to_ptr()?) )\n-            },\n-            ByVal(ptr) | ByValPair(ptr, _) => Ok(ptr.into()),\n+                mem.read_maybe_aligned(aligned, |mem| mem.read_ptr(ptr.to_ptr()?))\n+            }\n+            ByVal(ptr) |\n+            ByValPair(ptr, _) => Ok(ptr.into()),\n         }\n     }\n \n     pub(super) fn into_ptr_vtable_pair<M: Machine<'tcx>>(\n         &self,\n-        mem: &Memory<'a, 'tcx, M>\n+        mem: &Memory<'a, 'tcx, M>,\n     ) -> EvalResult<'tcx, (Pointer, MemoryPointer)> {\n         use self::Value::*;\n         match *self {\n-            ByRef(PtrAndAlign { ptr: ref_ptr, aligned }) => {\n+            ByRef(PtrAndAlign {\n+                      ptr: ref_ptr,\n+                      aligned,\n+                  }) => {\n                 mem.read_maybe_aligned(aligned, |mem| {\n                     let ptr = mem.read_ptr(ref_ptr.to_ptr()?)?;\n-                    let vtable = mem.read_ptr(ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?)?;\n+                    let vtable = mem.read_ptr(\n+                        ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?,\n+                    )?;\n                     Ok((ptr, vtable.to_ptr()?))\n                 })\n             }\n@@ -203,21 +212,29 @@ impl<'a, 'tcx: 'a> Value {\n         }\n     }\n \n-    pub(super) fn into_slice<M: Machine<'tcx>>(&self, mem: &Memory<'a, 'tcx, M>) -> EvalResult<'tcx, (Pointer, u64)> {\n+    pub(super) fn into_slice<M: Machine<'tcx>>(\n+        &self,\n+        mem: &Memory<'a, 'tcx, M>,\n+    ) -> EvalResult<'tcx, (Pointer, u64)> {\n         use self::Value::*;\n         match *self {\n-            ByRef(PtrAndAlign { ptr: ref_ptr, aligned } ) => {\n+            ByRef(PtrAndAlign {\n+                      ptr: ref_ptr,\n+                      aligned,\n+                  }) => {\n                 mem.read_maybe_aligned(aligned, |mem| {\n                     let ptr = mem.read_ptr(ref_ptr.to_ptr()?)?;\n-                    let len = mem.read_usize(ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?)?;\n+                    let len = mem.read_usize(\n+                        ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?,\n+                    )?;\n                     Ok((ptr, len))\n                 })\n-            },\n+            }\n             ByValPair(ptr, val) => {\n                 let len = val.to_u128()?;\n                 assert_eq!(len as u64 as u128, len);\n                 Ok((ptr.into(), len as u64))\n-            },\n+            }\n             ByVal(PrimVal::Undef) => err!(ReadUndefBytes),\n             ByVal(_) => bug!(\"expected ptr and length, got {:?}\", self),\n         }\n@@ -349,7 +366,7 @@ impl PrimValKind {\n         }\n     }\n \n-     pub fn is_float(self) -> bool {\n+    pub fn is_float(self) -> bool {\n         use self::PrimValKind::*;\n         match self {\n             F32 | F64 => true,"}, {"sha": "7493551ecf7bdb1113749589af20363fc8e9e017", "filename": "tests/compiletest.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1326aed02c3010444a6452aa998bbe7162822df0/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1326aed02c3010444a6452aa998bbe7162822df0/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=1326aed02c3010444a6452aa998bbe7162822df0", "patch": "@@ -16,7 +16,11 @@ macro_rules! eprintln {\n const MIRI_PATH: &'static str = concat!(\"target/\", env!(\"PROFILE\"), \"/miri\");\n \n fn compile_fail(sysroot: &Path, path: &str, target: &str, host: &str, fullmir: bool) {\n-    eprintln!(\"## Running compile-fail tests in {} against miri for target {}\", path, target);\n+    eprintln!(\n+        \"## Running compile-fail tests in {} against miri for target {}\",\n+        path,\n+        target\n+    );\n     let mut config = compiletest::default_config();\n     config.mode = \"compile-fail\".parse().expect(\"Invalid mode\");\n     config.rustc_path = MIRI_PATH.into();\n@@ -26,7 +30,9 @@ fn compile_fail(sysroot: &Path, path: &str, target: &str, host: &str, fullmir: b\n             // skip fullmir on nonhost\n             return;\n         }\n-        let sysroot = Path::new(&std::env::var(\"HOME\").unwrap()).join(\".xargo\").join(\"HOST\");\n+        let sysroot = Path::new(&std::env::var(\"HOME\").unwrap())\n+            .join(\".xargo\")\n+            .join(\"HOST\");\n         config.target_rustcflags = Some(format!(\"--sysroot {}\", sysroot.to_str().unwrap()));\n         config.src_base = PathBuf::from(path.to_string());\n     } else {\n@@ -50,12 +56,13 @@ fn run_pass(path: &str) {\n }\n \n fn miri_pass(path: &str, target: &str, host: &str, fullmir: bool, opt: bool) {\n-    let opt_str = if opt {\n-        \" with optimizations\"\n-    } else {\n-        \"\"\n-    };\n-    eprintln!(\"## Running run-pass tests in {} against miri for target {}{}\", path, target, opt_str);\n+    let opt_str = if opt { \" with optimizations\" } else { \"\" };\n+    eprintln!(\n+        \"## Running run-pass tests in {} against miri for target {}{}\",\n+        path,\n+        target,\n+        opt_str\n+    );\n     let mut config = compiletest::default_config();\n     config.mode = \"mir-opt\".parse().expect(\"Invalid mode\");\n     config.src_base = PathBuf::from(path);\n@@ -68,7 +75,9 @@ fn miri_pass(path: &str, target: &str, host: &str, fullmir: bool, opt: bool) {\n             // skip fullmir on nonhost\n             return;\n         }\n-        let sysroot = Path::new(&std::env::var(\"HOME\").unwrap()).join(\".xargo\").join(\"HOST\");\n+        let sysroot = Path::new(&std::env::var(\"HOME\").unwrap())\n+            .join(\".xargo\")\n+            .join(\"HOST\");\n         flags.push(format!(\"--sysroot {}\", sysroot.to_str().unwrap()));\n     }\n     if opt {\n@@ -99,7 +108,9 @@ fn for_all_targets<F: FnMut(String)>(sysroot: &Path, mut f: F) {\n     let target_dir = sysroot.join(\"lib\").join(\"rustlib\");\n     for entry in std::fs::read_dir(target_dir).expect(\"invalid sysroot\") {\n         let entry = entry.unwrap();\n-        if !is_target_dir(entry.path()) { continue; }\n+        if !is_target_dir(entry.path()) {\n+            continue;\n+        }\n         let target = entry.file_name().into_string().unwrap();\n         f(target);\n     }\n@@ -125,7 +136,9 @@ fn get_host() -> String {\n         .expect(\"rustc not found for -vV\")\n         .stdout;\n     let host = std::str::from_utf8(&host).expect(\"sysroot is not utf8\");\n-    let host = host.split(\"\\nhost: \").nth(1).expect(\"no host: part in rustc -vV\");\n+    let host = host.split(\"\\nhost: \").nth(1).expect(\n+        \"no host: part in rustc -vV\",\n+    );\n     let host = host.split('\\n').next().expect(\"no \\n after host\");\n     String::from(host)\n }"}]}