{"sha": "ee4d904cfb1b604bc8627491e05980ac43cd59e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlNGQ5MDRjZmIxYjYwNGJjODYyNzQ5MWUwNTk4MGFjNDNjZDU5ZTM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-25T07:57:55Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-25T13:25:40Z"}, "message": "Store all the data in the Salsa Database", "tree": {"sha": "54d1b937de544b8f6a8f2821ad9599aa82192375", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54d1b937de544b8f6a8f2821ad9599aa82192375"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee4d904cfb1b604bc8627491e05980ac43cd59e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee4d904cfb1b604bc8627491e05980ac43cd59e3", "html_url": "https://github.com/rust-lang/rust/commit/ee4d904cfb1b604bc8627491e05980ac43cd59e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee4d904cfb1b604bc8627491e05980ac43cd59e3/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cb2074c4b7219b32993abdcc7084637c0123d49", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cb2074c4b7219b32993abdcc7084637c0123d49", "html_url": "https://github.com/rust-lang/rust/commit/2cb2074c4b7219b32993abdcc7084637c0123d49"}], "stats": {"total": 536, "additions": 337, "deletions": 199}, "files": [{"sha": "04bb82c18dc087b6f3cc0c6100ad34febf37f585", "filename": "crates/ra_analysis/src/completion.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ee4d904cfb1b604bc8627491e05980ac43cd59e3/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4d904cfb1b604bc8627491e05980ac43cd59e3/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs?ref=ee4d904cfb1b604bc8627491e05980ac43cd59e3", "patch": "@@ -6,13 +6,14 @@ use ra_syntax::{\n \n use crate::{\n     FileId, Cancelable,\n-    db::{self, SyntaxDatabase},\n+    db::{self, SyntaxDatabase, input::FilesDatabase},\n     descriptors::module::{ModulesDatabase, ModuleTree, ModuleId},\n };\n \n pub(crate) fn resolve_based_completion(db: &db::RootDatabase, file_id: FileId, offset: TextUnit) -> Cancelable<Option<Vec<CompletionItem>>> {\n+    let source_root_id = db.file_source_root(file_id);\n     let file = db.file_syntax(file_id);\n-    let module_tree = db.module_tree()?;\n+    let module_tree = db.module_tree(source_root_id)?;\n     let file = {\n         let edit = AtomEdit::insert(offset, \"intellijRulezz\".to_string());\n         file.reparse(&edit)"}, {"sha": "957d082f9eea34a9efdd24ee492c982f78259932", "filename": "crates/ra_analysis/src/db/input.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/ee4d904cfb1b604bc8627491e05980ac43cd59e3/crates%2Fra_analysis%2Fsrc%2Fdb%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4d904cfb1b604bc8627491e05980ac43cd59e3/crates%2Fra_analysis%2Fsrc%2Fdb%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb%2Finput.rs?ref=ee4d904cfb1b604bc8627491e05980ac43cd59e3", "patch": "@@ -0,0 +1,83 @@\n+use std::{\n+    sync::Arc,\n+    hash::{Hasher, Hash},\n+};\n+\n+use salsa;\n+use rustc_hash::FxHashSet;\n+\n+use crate::{FileId, FileResolverImp, CrateGraph, symbol_index::SymbolIndex};\n+\n+salsa::query_group! {\n+    pub(crate) trait FilesDatabase: salsa::Database {\n+        fn file_text(file_id: FileId) -> Arc<String> {\n+            type FileTextQuery;\n+            storage input;\n+        }\n+        fn file_source_root(file_id: FileId) -> SourceRootId {\n+            type FileSourceRootQuery;\n+            storage input;\n+        }\n+        fn source_root(id: SourceRootId) -> Arc<SourceRoot> {\n+            type SourceRootQuery;\n+            storage input;\n+        }\n+        fn libraries() -> Arc<Vec<SourceRootId>> {\n+            type LibrarieseQuery;\n+            storage input;\n+        }\n+        fn library_symbols(id: SourceRootId) -> Arc<SymbolIndex> {\n+            type LibrarySymbolsQuery;\n+            storage input;\n+        }\n+        fn crate_graph() -> Arc<CrateGraph> {\n+            type CrateGraphQuery;\n+            storage input;\n+        }\n+    }\n+}\n+\n+#[derive(Default, Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub(crate) struct SourceRootId(pub(crate) u32);\n+\n+#[derive(Clone, Default, Debug, Eq)]\n+pub(crate) struct SourceRoot {\n+    pub(crate) file_resolver: FileResolverImp,\n+    pub(crate) files: FxHashSet<FileId>,\n+}\n+\n+impl PartialEq for SourceRoot {\n+    fn eq(&self, other: &SourceRoot) -> bool {\n+        self.file_resolver == other.file_resolver\n+    }\n+}\n+\n+impl Hash for SourceRoot {\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        self.file_resolver.hash(hasher);\n+    }\n+}\n+\n+pub(crate) const WORKSPACE: SourceRootId = SourceRootId(0);\n+\n+\n+#[derive(Default, Debug, Eq)]\n+pub(crate) struct FileSet {\n+    pub(crate) files: FxHashSet<FileId>,\n+    pub(crate) resolver: FileResolverImp,\n+}\n+\n+impl PartialEq for FileSet {\n+    fn eq(&self, other: &FileSet) -> bool {\n+        self.files == other.files && self.resolver == other.resolver\n+    }\n+}\n+\n+impl Hash for FileSet {\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        let mut files = self.files.iter().cloned().collect::<Vec<_>>();\n+        files.sort();\n+        files.hash(hasher);\n+    }\n+}\n+"}, {"sha": "8387118ad5b5b1356cfd777148a96a8f0073ae27", "filename": "crates/ra_analysis/src/db/mod.rs", "status": "renamed", "additions": 11, "deletions": 40, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ee4d904cfb1b604bc8627491e05980ac43cd59e3/crates%2Fra_analysis%2Fsrc%2Fdb%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4d904cfb1b604bc8627491e05980ac43cd59e3/crates%2Fra_analysis%2Fsrc%2Fdb%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb%2Fmod.rs?ref=ee4d904cfb1b604bc8627491e05980ac43cd59e3", "patch": "@@ -1,20 +1,20 @@\n+pub(crate) mod input;\n+\n use std::{\n     fmt,\n-    hash::{Hash, Hasher},\n     sync::Arc,\n };\n \n use ra_editor::LineIndex;\n use ra_syntax::File;\n-use rustc_hash::FxHashSet;\n use salsa;\n \n use crate::{\n     db,\n     Cancelable, Canceled,\n     descriptors::module::{SubmodulesQuery, ModuleTreeQuery, ModulesDatabase},\n     symbol_index::SymbolIndex,\n-    FileId, FileResolverImp,\n+    FileId,\n };\n \n #[derive(Default)]\n@@ -58,9 +58,13 @@ impl Clone for RootDatabase {\n \n salsa::database_storage! {\n     pub(crate) struct RootDatabaseStorage for RootDatabase {\n-        impl FilesDatabase {\n-            fn file_text() for FileTextQuery;\n-            fn file_set() for FileSetQuery;\n+        impl input::FilesDatabase {\n+            fn file_text() for input::FileTextQuery;\n+            fn file_source_root() for input::FileSourceRootQuery;\n+            fn source_root() for input::SourceRootQuery;\n+            fn libraries() for input::LibrarieseQuery;\n+            fn library_symbols() for input::LibrarySymbolsQuery;\n+            fn crate_graph() for input::CrateGraphQuery;\n         }\n         impl SyntaxDatabase {\n             fn file_syntax() for FileSyntaxQuery;\n@@ -75,40 +79,7 @@ salsa::database_storage! {\n }\n \n salsa::query_group! {\n-    pub(crate) trait FilesDatabase: salsa::Database {\n-        fn file_text(file_id: FileId) -> Arc<String> {\n-            type FileTextQuery;\n-            storage input;\n-        }\n-        fn file_set() -> Arc<FileSet> {\n-            type FileSetQuery;\n-            storage input;\n-        }\n-    }\n-}\n-\n-#[derive(Default, Debug, Eq)]\n-pub(crate) struct FileSet {\n-    pub(crate) files: FxHashSet<FileId>,\n-    pub(crate) resolver: FileResolverImp,\n-}\n-\n-impl PartialEq for FileSet {\n-    fn eq(&self, other: &FileSet) -> bool {\n-        self.files == other.files && self.resolver == other.resolver\n-    }\n-}\n-\n-impl Hash for FileSet {\n-    fn hash<H: Hasher>(&self, hasher: &mut H) {\n-        let mut files = self.files.iter().cloned().collect::<Vec<_>>();\n-        files.sort();\n-        files.hash(hasher);\n-    }\n-}\n-\n-salsa::query_group! {\n-    pub(crate) trait SyntaxDatabase: FilesDatabase {\n+    pub(crate) trait SyntaxDatabase: input::FilesDatabase {\n         fn file_syntax(file_id: FileId) -> File {\n             type FileSyntaxQuery;\n         }", "previous_filename": "crates/ra_analysis/src/db.rs"}, {"sha": "6a408dc894eb31f4975c27e858ecf6546608a162", "filename": "crates/ra_analysis/src/descriptors/module/imp.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ee4d904cfb1b604bc8627491e05980ac43cd59e3/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4d904cfb1b604bc8627491e05980ac43cd59e3/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs?ref=ee4d904cfb1b604bc8627491e05980ac43cd59e3", "patch": "@@ -9,7 +9,7 @@ use ra_syntax::{\n \n use crate::{\n     FileId, Cancelable, FileResolverImp,\n-    db,\n+    db::{self, input::{SourceRoot, SourceRootId}},\n };\n \n use super::{\n@@ -35,9 +35,12 @@ pub(super) fn modules(root: ast::Root<'_>) -> impl Iterator<Item = (SmolStr, ast\n     })\n }\n \n-pub(super) fn module_tree(db: &impl ModulesDatabase) -> Cancelable<Arc<ModuleTree>> {\n+pub(super) fn module_tree(\n+    db: &impl ModulesDatabase,\n+    source_root: SourceRootId,\n+) -> Cancelable<Arc<ModuleTree>> {\n     db::check_canceled(db)?;\n-    let res = create_module_tree(db)?;\n+    let res = create_module_tree(db, source_root)?;\n     Ok(Arc::new(res))\n }\n \n@@ -50,6 +53,7 @@ pub struct Submodule {\n \n fn create_module_tree<'a>(\n     db: &impl ModulesDatabase,\n+    source_root: SourceRootId,\n ) -> Cancelable<ModuleTree> {\n     let mut tree = ModuleTree {\n         mods: Vec::new(),\n@@ -59,19 +63,21 @@ fn create_module_tree<'a>(\n     let mut roots = FxHashMap::default();\n     let mut visited = FxHashSet::default();\n \n-    for &file_id in db.file_set().files.iter() {\n+    let source_root = db.source_root(source_root);\n+    for &file_id in source_root.files.iter() {\n         if visited.contains(&file_id) {\n             continue; // TODO: use explicit crate_roots here\n         }\n         assert!(!roots.contains_key(&file_id));\n-        let module_id = build_subtree(db, &mut tree, &mut visited, &mut roots, None, file_id)?;\n+        let module_id = build_subtree(db, &source_root, &mut tree, &mut visited, &mut roots, None, file_id)?;\n         roots.insert(file_id, module_id);\n     }\n     Ok(tree)\n }\n \n fn build_subtree(\n     db: &impl ModulesDatabase,\n+    source_root: &SourceRoot,\n     tree: &mut ModuleTree,\n     visited: &mut FxHashSet<FileId>,\n     roots: &mut FxHashMap<FileId, ModuleId>,\n@@ -84,10 +90,8 @@ fn build_subtree(\n         parent,\n         children: Vec::new(),\n     });\n-    let file_set = db.file_set();\n-    let file_resolver = &file_set.resolver;\n     for name in db.submodules(file_id)?.iter() {\n-        let (points_to, problem) = resolve_submodule(file_id, name, file_resolver);\n+        let (points_to, problem) = resolve_submodule(file_id, name, &source_root.file_resolver);\n         let link = tree.push_link(LinkData {\n             name: name.clone(),\n             owner: id,\n@@ -102,7 +106,7 @@ fn build_subtree(\n                     tree.module_mut(module_id).parent = Some(link);\n                     Ok(module_id)\n                 }\n-                None => build_subtree(db, tree, visited, roots, Some(link), file_id),\n+                None => build_subtree(db, source_root, tree, visited, roots, Some(link), file_id),\n             })\n             .collect::<Cancelable<Vec<_>>>()?;\n         tree.link_mut(link).points_to = points_to;"}, {"sha": "98024cc1572c4c9f3a022d972da264788385edba", "filename": "crates/ra_analysis/src/descriptors/module/mod.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ee4d904cfb1b604bc8627491e05980ac43cd59e3/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4d904cfb1b604bc8627491e05980ac43cd59e3/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs?ref=ee4d904cfb1b604bc8627491e05980ac43cd59e3", "patch": "@@ -7,12 +7,12 @@ use ra_syntax::{ast::{self, NameOwner, AstNode}, SmolStr, SyntaxNode};\n \n use crate::{\n     FileId, Cancelable,\n-    db::SyntaxDatabase,\n+    db::{SyntaxDatabase, input::SourceRootId},\n };\n \n salsa::query_group! {\n     pub(crate) trait ModulesDatabase: SyntaxDatabase {\n-        fn module_tree() -> Cancelable<Arc<ModuleTree>> {\n+        fn module_tree(source_root_id: SourceRootId) -> Cancelable<Arc<ModuleTree>> {\n             type ModuleTreeQuery;\n             use fn imp::module_tree;\n         }\n@@ -110,15 +110,9 @@ impl ModuleId {\n }\n \n impl LinkId {\n-    pub(crate) fn name(self, tree: &ModuleTree) -> SmolStr {\n-        tree.link(self).name.clone()\n-    }\n     pub(crate) fn owner(self, tree: &ModuleTree) -> ModuleId {\n         tree.link(self).owner\n     }\n-    fn points_to(self, tree: &ModuleTree) -> &[ModuleId] {\n-        &tree.link(self).points_to\n-    }\n     pub(crate) fn bind_source<'a>(\n         self,\n         tree: &ModuleTree,"}, {"sha": "97ed55465d8798648870e8c74d713e7f383d7545", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 98, "deletions": 81, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/ee4d904cfb1b604bc8627491e05980ac43cd59e3/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4d904cfb1b604bc8627491e05980ac43cd59e3/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=ee4d904cfb1b604bc8627491e05980ac43cd59e3", "patch": "@@ -1,7 +1,5 @@\n use std::{\n-    fmt,\n     hash::{Hash, Hasher},\n-    iter,\n     sync::Arc,\n };\n \n@@ -14,12 +12,16 @@ use ra_syntax::{\n };\n use relative_path::RelativePath;\n use rustc_hash::FxHashSet;\n+use salsa::{ParallelDatabase, Database};\n \n use crate::{\n-    db::SyntaxDatabase,\n+    AnalysisChange,\n+    db::{\n+        self, SyntaxDatabase,\n+        input::{SourceRootId, FilesDatabase, SourceRoot, WORKSPACE}\n+    },\n     descriptors::module::{ModulesDatabase, ModuleTree, Problem},\n     descriptors::{FnDescriptor},\n-    roots::{ReadonlySourceRoot, SourceRoot, WritableSourceRoot},\n     CrateGraph, CrateId, Diagnostic, FileId, FileResolver, FileSystemEdit, Position,\n     Query, SourceChange, SourceFileEdit, Cancelable,\n };\n@@ -80,96 +82,123 @@ impl Default for FileResolverImp {\n     }\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Default)]\n pub(crate) struct AnalysisHostImpl {\n-    data: WorldData,\n+    db: db::RootDatabase,\n }\n \n+\n impl AnalysisHostImpl {\n     pub fn new() -> AnalysisHostImpl {\n-        AnalysisHostImpl {\n-            data: WorldData::default(),\n-        }\n+        AnalysisHostImpl::default()\n     }\n     pub fn analysis(&self) -> AnalysisImpl {\n         AnalysisImpl {\n-            data: self.data.clone(),\n+            db: self.db.fork() // freeze revision here\n         }\n     }\n-    pub fn change_files(&mut self, changes: &mut dyn Iterator<Item = (FileId, Option<String>)>) {\n-        self.data_mut().root.apply_changes(changes, None);\n-    }\n-    pub fn set_file_resolver(&mut self, resolver: FileResolverImp) {\n-        self.data_mut()\n-            .root\n-            .apply_changes(&mut iter::empty(), Some(resolver));\n-    }\n-    pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n-        let mut visited = FxHashSet::default();\n-        for &file_id in graph.crate_roots.values() {\n-            if !visited.insert(file_id) {\n-                panic!(\"duplicate crate root: {:?}\", file_id);\n+    pub fn apply_change(&mut self, change: AnalysisChange) {\n+        for (file_id, text) in change.files_changed {\n+            self.db\n+                .query(db::input::FileTextQuery)\n+                .set(file_id, Arc::new(text))\n+        }\n+        if !(change.files_added.is_empty() && change.files_removed.is_empty()) {\n+            let file_resolver = change.file_resolver\n+                .expect(\"change resolver when changing set of files\");\n+            let mut source_root = SourceRoot::clone(&self.db.source_root(WORKSPACE));\n+            for (file_id, text) in change.files_added {\n+                self.db\n+                    .query(db::input::FileTextQuery)\n+                    .set(file_id, Arc::new(text));\n+                self.db\n+                    .query(db::input::FileSourceRootQuery)\n+                    .set(file_id, db::input::WORKSPACE);\n+                source_root.files.insert(file_id);\n+            }\n+            for file_id in change.files_removed {\n+                self.db\n+                    .query(db::input::FileTextQuery)\n+                    .set(file_id, Arc::new(String::new()));\n+                source_root.files.remove(&file_id);\n             }\n+            source_root.file_resolver = file_resolver;\n+            self.db\n+                .query(db::input::SourceRootQuery)\n+                .set(WORKSPACE, Arc::new(source_root))\n+        }\n+        if !change.libraries_added.is_empty() {\n+            let mut libraries = Vec::clone(&self.db.libraries());\n+            for library in change.libraries_added {\n+                let source_root_id = SourceRootId(1 + libraries.len() as u32);\n+                libraries.push(source_root_id);\n+                let mut files = FxHashSet::default();\n+                for (file_id, text) in library.files {\n+                    files.insert(file_id);\n+                    self.db\n+                        .query(db::input::FileSourceRootQuery)\n+                        .set_constant(file_id, source_root_id);\n+                    self.db\n+                        .query(db::input::FileTextQuery)\n+                        .set_constant(file_id, Arc::new(text));\n+                }\n+                let source_root = SourceRoot {\n+                    files,\n+                    file_resolver: library.file_resolver,\n+                };\n+                self.db\n+                    .query(db::input::SourceRootQuery)\n+                    .set(source_root_id, Arc::new(source_root));\n+                self.db\n+                    .query(db::input::LibrarySymbolsQuery)\n+                    .set(source_root_id, Arc::new(library.symbol_index));\n+            }\n+            self.db\n+                .query(db::input::LibrarieseQuery)\n+                .set((), Arc::new(libraries));\n+        }\n+        if let Some(crate_graph) = change.crate_graph {\n+            self.db.query(db::input::CrateGraphQuery)\n+                .set((), Arc::new(crate_graph))\n         }\n-        self.data_mut().crate_graph = graph;\n-    }\n-    pub fn add_library(&mut self, root: ReadonlySourceRoot) {\n-        self.data_mut().libs.push(root);\n-    }\n-    fn data_mut(&mut self) -> &mut WorldData {\n-        &mut self.data\n     }\n }\n \n+#[derive(Debug)]\n pub(crate) struct AnalysisImpl {\n-    data: WorldData,\n-}\n-\n-impl fmt::Debug for AnalysisImpl {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.data.fmt(f)\n-    }\n+    db: db::RootDatabase,\n }\n \n impl AnalysisImpl {\n-    fn root(&self, file_id: FileId) -> &SourceRoot {\n-        if self.data.root.contains(file_id) {\n-            return &self.data.root;\n-        }\n-        self\n-            .data\n-            .libs\n-            .iter()\n-            .find(|it| it.contains(file_id))\n-            .unwrap()\n-    }\n     pub fn file_syntax(&self, file_id: FileId) -> File {\n-        self.root(file_id).db().file_syntax(file_id)\n+        self.db.file_syntax(file_id)\n     }\n     pub fn file_line_index(&self, file_id: FileId) -> Arc<LineIndex> {\n-        self.root(file_id).db().file_lines(file_id)\n+        self.db.file_lines(file_id)\n     }\n     pub fn world_symbols(&self, query: Query) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n         let mut buf = Vec::new();\n-        if query.libs {\n-            for lib in self.data.libs.iter() {\n-                lib.symbols(&mut buf)?;\n-            }\n-        } else {\n-            self.data.root.symbols(&mut buf)?;\n+        for &lib_id in self.db.libraries().iter() {\n+            buf.push(self.db.library_symbols(lib_id));\n+        }\n+        for &file_id in self.db.source_root(WORKSPACE).files.iter() {\n+            buf.push(self.db.file_symbols(file_id)?);\n         }\n         Ok(query.search(&buf))\n     }\n+    fn module_tree(&self, file_id: FileId) -> Cancelable<Arc<ModuleTree>> {\n+        let source_root = self.db.file_source_root(file_id);\n+        self.db.module_tree(source_root)\n+    }\n     pub fn parent_module(&self, file_id: FileId) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n-        let root = self.root(file_id);\n-        let module_tree = root.db().module_tree()?;\n+        let module_tree = self.module_tree(file_id)?;\n \n         let res = module_tree.modules_for_file(file_id)\n             .into_iter()\n             .filter_map(|module_id| {\n                 let link = module_id.parent_link(&module_tree)?;\n                 let file_id = link.owner(&module_tree).file_id(&module_tree);\n-                let syntax = root.db().file_syntax(file_id);\n+                let syntax = self.db.file_syntax(file_id);\n                 let decl = link.bind_source(&module_tree, syntax.ast());\n \n                 let sym = FileSymbol {\n@@ -183,8 +212,8 @@ impl AnalysisImpl {\n         Ok(res)\n     }\n     pub fn crate_for(&self, file_id: FileId) -> Cancelable<Vec<CrateId>> {\n-        let module_tree = self.root(file_id).db().module_tree()?;\n-        let crate_graph = &self.data.crate_graph;\n+        let module_tree = self.module_tree(file_id)?;\n+        let crate_graph = self.db.crate_graph();\n         let res = module_tree.modules_for_file(file_id)\n             .into_iter()\n             .map(|it| it.root(&module_tree))\n@@ -195,7 +224,7 @@ impl AnalysisImpl {\n         Ok(res)\n     }\n     pub fn crate_root(&self, crate_id: CrateId) -> FileId {\n-        self.data.crate_graph.crate_roots[&crate_id]\n+        self.db.crate_graph().crate_roots[&crate_id]\n     }\n     pub fn completions(&self, file_id: FileId, offset: TextUnit) -> Cancelable<Option<Vec<CompletionItem>>> {\n         let mut res = Vec::new();\n@@ -205,8 +234,7 @@ impl AnalysisImpl {\n             res.extend(scope_based);\n             has_completions = true;\n         }\n-        let root = self.root(file_id);\n-        if let Some(scope_based) = crate::completion::resolve_based_completion(root.db(), file_id, offset)? {\n+        if let Some(scope_based) = crate::completion::resolve_based_completion(&self.db, file_id, offset)? {\n             res.extend(scope_based);\n             has_completions = true;\n         }\n@@ -222,9 +250,8 @@ impl AnalysisImpl {\n         file_id: FileId,\n         offset: TextUnit,\n     ) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n-        let root = self.root(file_id);\n-        let module_tree = root.db().module_tree()?;\n-        let file = root.db().file_syntax(file_id);\n+        let module_tree = self.module_tree(file_id)?;\n+        let file = self.db.file_syntax(file_id);\n         let syntax = file.syntax();\n         if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, offset) {\n             // First try to resolve the symbol locally\n@@ -273,8 +300,7 @@ impl AnalysisImpl {\n     }\n \n     pub fn find_all_refs(&self, file_id: FileId, offset: TextUnit) -> Vec<(FileId, TextRange)> {\n-        let root = self.root(file_id);\n-        let file = root.db().file_syntax(file_id);\n+        let file = self.db.file_syntax(file_id);\n         let syntax = file.syntax();\n \n         let mut ret = vec![];\n@@ -305,9 +331,8 @@ impl AnalysisImpl {\n     }\n \n     pub fn diagnostics(&self, file_id: FileId) -> Cancelable<Vec<Diagnostic>> {\n-        let root = self.root(file_id);\n-        let module_tree = root.db().module_tree()?;\n-        let syntax = root.db().file_syntax(file_id);\n+        let module_tree = self.module_tree(file_id)?;\n+        let syntax = self.db.file_syntax(file_id);\n \n         let mut res = ra_editor::diagnostics(&syntax)\n             .into_iter()\n@@ -396,8 +421,7 @@ impl AnalysisImpl {\n         file_id: FileId,\n         offset: TextUnit,\n     ) -> Cancelable<Option<(FnDescriptor, Option<usize>)>> {\n-        let root = self.root(file_id);\n-        let file = root.db().file_syntax(file_id);\n+        let file = self.db.file_syntax(file_id);\n         let syntax = file.syntax();\n \n         // Find the calling expression and it's NameRef\n@@ -491,13 +515,6 @@ impl AnalysisImpl {\n     }\n }\n \n-#[derive(Default, Clone, Debug)]\n-struct WorldData {\n-    crate_graph: CrateGraph,\n-    root: WritableSourceRoot,\n-    libs: Vec<ReadonlySourceRoot>,\n-}\n-\n impl SourceChange {\n     pub(crate) fn from_local_edit(file_id: FileId, label: &str, edit: LocalEdit) -> SourceChange {\n         let file_edit = SourceFileEdit {"}, {"sha": "4a1ae3b6472b6f4ea0f678b54e6b09b38dd92a08", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 57, "deletions": 24, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ee4d904cfb1b604bc8627491e05980ac43cd59e3/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4d904cfb1b604bc8627491e05980ac43cd59e3/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=ee4d904cfb1b604bc8627491e05980ac43cd59e3", "patch": "@@ -9,17 +9,23 @@ extern crate salsa;\n mod db;\n mod descriptors;\n mod imp;\n-mod roots;\n mod symbol_index;\n mod completion;\n \n-use std::{fmt::Debug, sync::Arc};\n+use std::{\n+    fmt::Debug,\n+    sync::Arc,\n+    collections::BTreeMap,\n+};\n \n use ra_syntax::{AtomEdit, File, TextRange, TextUnit};\n use relative_path::{RelativePath, RelativePathBuf};\n-use rustc_hash::FxHashMap;\n+use rayon::prelude::*;\n \n-use crate::imp::{AnalysisHostImpl, AnalysisImpl, FileResolverImp};\n+use crate::{\n+    imp::{AnalysisHostImpl, AnalysisImpl, FileResolverImp},\n+    symbol_index::SymbolIndex,\n+};\n \n pub use crate::{\n     descriptors::FnDescriptor,\n@@ -49,16 +55,51 @@ pub struct FileId(pub u32);\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct CrateId(pub u32);\n \n-#[derive(Debug, Clone, Default)]\n+#[derive(Debug, Clone, Default, PartialEq, Eq, Hash)]\n pub struct CrateGraph {\n-    pub crate_roots: FxHashMap<CrateId, FileId>,\n+    pub crate_roots: BTreeMap<CrateId, FileId>,\n }\n \n pub trait FileResolver: Debug + Send + Sync + 'static {\n     fn file_stem(&self, file_id: FileId) -> String;\n     fn resolve(&self, file_id: FileId, path: &RelativePath) -> Option<FileId>;\n }\n \n+#[derive(Debug, Default)]\n+pub struct AnalysisChange {\n+    files_added: Vec<(FileId, String)>,\n+    files_changed: Vec<(FileId, String)>,\n+    files_removed: Vec<(FileId)>,\n+    libraries_added: Vec<LibraryData>,\n+    crate_graph: Option<CrateGraph>,\n+    file_resolver: Option<FileResolverImp>,\n+}\n+\n+\n+impl AnalysisChange {\n+    pub fn new() -> AnalysisChange {\n+        AnalysisChange::default()\n+    }\n+    pub fn add_file(&mut self, file_id: FileId, text: String) {\n+        self.files_added.push((file_id, text))\n+    }\n+    pub fn change_file(&mut self, file_id: FileId, new_text: String) {\n+        self.files_changed.push((file_id, new_text))\n+    }\n+    pub fn remove_file(&mut self, file_id: FileId) {\n+        self.files_removed.push(file_id)\n+    }\n+    pub fn add_library(&mut self, data: LibraryData) {\n+        self.libraries_added.push(data)\n+    }\n+    pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n+        self.crate_graph = Some(graph);\n+    }\n+    pub fn set_file_resolver(&mut self, file_resolver: Arc<FileResolver>) {\n+        self.file_resolver = Some(FileResolverImp::new(file_resolver));\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct AnalysisHost {\n     imp: AnalysisHostImpl,\n@@ -75,20 +116,8 @@ impl AnalysisHost {\n             imp: self.imp.analysis(),\n         }\n     }\n-    pub fn change_file(&mut self, file_id: FileId, text: Option<String>) {\n-        self.change_files(::std::iter::once((file_id, text)));\n-    }\n-    pub fn change_files(&mut self, mut changes: impl Iterator<Item = (FileId, Option<String>)>) {\n-        self.imp.change_files(&mut changes)\n-    }\n-    pub fn set_file_resolver(&mut self, resolver: Arc<FileResolver>) {\n-        self.imp.set_file_resolver(FileResolverImp::new(resolver));\n-    }\n-    pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n-        self.imp.set_crate_graph(graph)\n-    }\n-    pub fn add_library(&mut self, data: LibraryData) {\n-        self.imp.add_library(data.root)\n+    pub fn apply_change(&mut self, change: AnalysisChange) {\n+        self.imp.apply_change(change)\n     }\n }\n \n@@ -266,14 +295,18 @@ impl Analysis {\n \n #[derive(Debug)]\n pub struct LibraryData {\n-    root: roots::ReadonlySourceRoot,\n+    files: Vec<(FileId, String)>,\n+    file_resolver: FileResolverImp,\n+    symbol_index: SymbolIndex,\n }\n \n impl LibraryData {\n     pub fn prepare(files: Vec<(FileId, String)>, file_resolver: Arc<FileResolver>) -> LibraryData {\n-        let file_resolver = FileResolverImp::new(file_resolver);\n-        let root = roots::ReadonlySourceRoot::new(files, file_resolver);\n-        LibraryData { root }\n+        let symbol_index = SymbolIndex::for_files(files.par_iter().map(|(file_id, text)| {\n+            let file = File::parse(text);\n+            (*file_id, file)\n+        }));\n+        LibraryData { files, file_resolver: FileResolverImp::new(file_resolver), symbol_index }\n     }\n }\n "}, {"sha": "5f302cbda4e4860ea55cb88c188811b7474f36ea", "filename": "crates/ra_analysis/src/symbol_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee4d904cfb1b604bc8627491e05980ac43cd59e3/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4d904cfb1b604bc8627491e05980ac43cd59e3/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs?ref=ee4d904cfb1b604bc8627491e05980ac43cd59e3", "patch": "@@ -13,7 +13,7 @@ use rayon::prelude::*;\n \n use crate::{FileId, Query};\n \n-#[derive(Debug)]\n+#[derive(Default, Debug)]\n pub(crate) struct SymbolIndex {\n     symbols: Vec<(FileId, FileSymbol)>,\n     map: fst::Map,"}, {"sha": "198d6a263e5a167f50dcaa9ff993eff263b68bd3", "filename": "crates/ra_analysis/tests/tests.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ee4d904cfb1b604bc8627491e05980ac43cd59e3/crates%2Fra_analysis%2Ftests%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4d904cfb1b604bc8627491e05980ac43cd59e3/crates%2Fra_analysis%2Ftests%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Ftests%2Ftests.rs?ref=ee4d904cfb1b604bc8627491e05980ac43cd59e3", "patch": "@@ -5,15 +5,17 @@ extern crate relative_path;\n extern crate rustc_hash;\n extern crate test_utils;\n \n-use std::sync::Arc;\n+use std::{\n+    sync::Arc,\n+    collections::BTreeMap,\n+};\n \n use ra_syntax::TextRange;\n use relative_path::{RelativePath, RelativePathBuf};\n-use rustc_hash::FxHashMap;\n use test_utils::{assert_eq_dbg, extract_offset};\n \n use ra_analysis::{\n-    Analysis, AnalysisHost, CrateGraph, CrateId, FileId, FileResolver, FnDescriptor,\n+    AnalysisChange, Analysis, AnalysisHost, CrateGraph, CrateId, FileId, FileResolver, FnDescriptor,\n };\n \n #[derive(Debug)]\n@@ -45,14 +47,16 @@ impl FileResolver for FileMap {\n fn analysis_host(files: &[(&str, &str)]) -> AnalysisHost {\n     let mut host = AnalysisHost::new();\n     let mut file_map = Vec::new();\n+    let mut change = AnalysisChange::new();\n     for (id, &(path, contents)) in files.iter().enumerate() {\n         let file_id = FileId((id + 1) as u32);\n         assert!(path.starts_with('/'));\n         let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n-        host.change_file(file_id, Some(contents.to_string()));\n+        change.add_file(file_id, contents.to_string());\n         file_map.push((file_id, path));\n     }\n-    host.set_file_resolver(Arc::new(FileMap(file_map)));\n+    change.set_file_resolver(Arc::new(FileMap(file_map)));\n+    host.apply_change(change);\n     host\n }\n \n@@ -128,12 +132,14 @@ fn test_resolve_crate_root() {\n \n     let crate_graph = CrateGraph {\n         crate_roots: {\n-            let mut m = FxHashMap::default();\n+            let mut m = BTreeMap::default();\n             m.insert(CrateId(1), FileId(1));\n             m\n         },\n     };\n-    host.set_crate_graph(crate_graph);\n+    let mut change = AnalysisChange::new();\n+    change.set_crate_graph(crate_graph);\n+    host.apply_change(change);\n     let snap = host.analysis();\n \n     assert_eq!(snap.crate_for(FileId(2)).unwrap(), vec![CrateId(1)],);"}, {"sha": "b3d1dc3db8bcd19fe743bd3090d399573e7d1272", "filename": "crates/ra_lsp_server/src/path_map.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ee4d904cfb1b604bc8627491e05980ac43cd59e3/crates%2Fra_lsp_server%2Fsrc%2Fpath_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4d904cfb1b604bc8627491e05980ac43cd59e3/crates%2Fra_lsp_server%2Fsrc%2Fpath_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fpath_map.rs?ref=ee4d904cfb1b604bc8627491e05980ac43cd59e3", "patch": "@@ -22,15 +22,18 @@ impl PathMap {\n     pub fn new() -> PathMap {\n         Default::default()\n     }\n-    pub fn get_or_insert(&mut self, path: PathBuf, root: Root) -> FileId {\n-        self.path2id\n+    pub fn get_or_insert(&mut self, path: PathBuf, root: Root) -> (bool, FileId) {\n+        let mut inserted = false;\n+        let file_id = self.path2id\n             .get(path.as_path())\n             .map(|&id| id)\n             .unwrap_or_else(|| {\n+                inserted = true;\n                 let id = self.new_file_id();\n                 self.insert(path, id, root);\n                 id\n-            })\n+            });\n+        (inserted, file_id)\n     }\n     pub fn get_id(&self, path: &Path) -> Option<FileId> {\n         self.path2id.get(path).map(|&id| id)\n@@ -105,8 +108,8 @@ mod test {\n     #[test]\n     fn test_resolve() {\n         let mut m = PathMap::new();\n-        let id1 = m.get_or_insert(PathBuf::from(\"/foo\"), Root::Workspace);\n-        let id2 = m.get_or_insert(PathBuf::from(\"/foo/bar.rs\"), Root::Workspace);\n+        let (_, id1) = m.get_or_insert(PathBuf::from(\"/foo\"), Root::Workspace);\n+        let (_, id2) = m.get_or_insert(PathBuf::from(\"/foo/bar.rs\"), Root::Workspace);\n         assert_eq!(m.resolve(id1, &RelativePath::new(\"bar.rs\")), Some(id2),)\n     }\n }"}, {"sha": "555de66ffc5ae1cf90e0a440bf8a6392653123b2", "filename": "crates/ra_lsp_server/src/server_world.rs", "status": "modified", "additions": 48, "deletions": 22, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ee4d904cfb1b604bc8627491e05980ac43cd59e3/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4d904cfb1b604bc8627491e05980ac43cd59e3/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs?ref=ee4d904cfb1b604bc8627491e05980ac43cd59e3", "patch": "@@ -2,10 +2,11 @@ use std::{\n     fs,\n     path::{Path, PathBuf},\n     sync::Arc,\n+    collections::BTreeMap,\n };\n \n use languageserver_types::Url;\n-use ra_analysis::{Analysis, AnalysisHost, CrateGraph, CrateId, FileId, FileResolver, LibraryData};\n+use ra_analysis::{Analysis, AnalysisHost, AnalysisChange, CrateGraph, CrateId, FileId, FileResolver, LibraryData};\n use rustc_hash::FxHashMap;\n \n use crate::{\n@@ -39,30 +40,40 @@ impl ServerWorldState {\n         }\n     }\n     pub fn apply_fs_changes(&mut self, events: Vec<FileEvent>) {\n+        let mut change = AnalysisChange::new();\n+        let mut inserted = false;\n         {\n             let pm = &mut self.path_map;\n             let mm = &mut self.mem_map;\n-            let changes = events\n+            events\n                 .into_iter()\n                 .map(|event| {\n                     let text = match event.kind {\n-                        FileEventKind::Add(text) => Some(text),\n+                        FileEventKind::Add(text) => text,\n                     };\n                     (event.path, text)\n                 })\n-                .map(|(path, text)| (pm.get_or_insert(path, Root::Workspace), text))\n-                .filter_map(|(id, text)| {\n-                    if mm.contains_key(&id) {\n-                        mm.insert(id, text);\n+                .map(|(path, text)| {\n+                    let (ins, file_id) = pm.get_or_insert(path, Root::Workspace);\n+                    inserted |= ins;\n+                    (file_id, text)\n+                })\n+                .filter_map(|(file_id, text)| {\n+                    if mm.contains_key(&file_id) {\n+                        mm.insert(file_id, Some(text));\n                         None\n                     } else {\n-                        Some((id, text))\n+                        Some((file_id, text))\n                     }\n+                })\n+                .for_each(|(file_id, text)| {\n+                    change.add_file(file_id, text)\n                 });\n-            self.analysis_host.change_files(changes);\n         }\n-        self.analysis_host\n-            .set_file_resolver(Arc::new(self.path_map.clone()));\n+        if inserted {\n+            change.set_file_resolver(Arc::new(self.path_map.clone()))\n+        }\n+        self.analysis_host.apply_change(change);\n     }\n     pub fn events_to_files(\n         &mut self,\n@@ -76,24 +87,31 @@ impl ServerWorldState {\n                     let FileEventKind::Add(text) = event.kind;\n                     (event.path, text)\n                 })\n-                .map(|(path, text)| (pm.get_or_insert(path, Root::Lib), text))\n+                .map(|(path, text)| (pm.get_or_insert(path, Root::Lib).1, text))\n                 .collect()\n         };\n         let resolver = Arc::new(self.path_map.clone());\n         (files, resolver)\n     }\n     pub fn add_lib(&mut self, data: LibraryData) {\n-        self.analysis_host.add_library(data);\n+        let mut change = AnalysisChange::new();\n+        change.add_library(data);\n+        self.analysis_host.apply_change(change);\n     }\n \n     pub fn add_mem_file(&mut self, path: PathBuf, text: String) -> FileId {\n-        let file_id = self.path_map.get_or_insert(path, Root::Workspace);\n-        self.analysis_host\n-            .set_file_resolver(Arc::new(self.path_map.clone()));\n-        self.mem_map.insert(file_id, None);\n+        let (inserted, file_id) = self.path_map.get_or_insert(path, Root::Workspace);\n         if self.path_map.get_root(file_id) != Root::Lib {\n-            self.analysis_host.change_file(file_id, Some(text));\n+            let mut change = AnalysisChange::new();\n+            if inserted {\n+                change.add_file(file_id, text);\n+                change.set_file_resolver(Arc::new(self.path_map.clone()));\n+            } else {\n+                change.change_file(file_id, text);\n+            }\n+            self.analysis_host.apply_change(change);\n         }\n+        self.mem_map.insert(file_id, None);\n         file_id\n     }\n \n@@ -103,7 +121,9 @@ impl ServerWorldState {\n             .get_id(path)\n             .ok_or_else(|| format_err!(\"change to unknown file: {}\", path.display()))?;\n         if self.path_map.get_root(file_id) != Root::Lib {\n-            self.analysis_host.change_file(file_id, Some(text));\n+            let mut change = AnalysisChange::new();\n+            change.change_file(file_id, text);\n+            self.analysis_host.apply_change(change);\n         }\n         Ok(())\n     }\n@@ -120,12 +140,16 @@ impl ServerWorldState {\n         // Do this via file watcher ideally.\n         let text = fs::read_to_string(path).ok();\n         if self.path_map.get_root(file_id) != Root::Lib {\n-            self.analysis_host.change_file(file_id, text);\n+            let mut change = AnalysisChange::new();\n+            if let Some(text) = text {\n+                change.change_file(file_id, text);\n+            }\n+            self.analysis_host.apply_change(change);\n         }\n         Ok(file_id)\n     }\n     pub fn set_workspaces(&mut self, ws: Vec<CargoWorkspace>) {\n-        let mut crate_roots = FxHashMap::default();\n+        let mut crate_roots = BTreeMap::default();\n         ws.iter()\n             .flat_map(|ws| {\n                 ws.packages()\n@@ -140,7 +164,9 @@ impl ServerWorldState {\n             });\n         let crate_graph = CrateGraph { crate_roots };\n         self.workspaces = Arc::new(ws);\n-        self.analysis_host.set_crate_graph(crate_graph);\n+        let mut change = AnalysisChange::new();\n+        change.set_crate_graph(crate_graph);\n+        self.analysis_host.apply_change(change);\n     }\n     pub fn snapshot(&self) -> ServerWorld {\n         ServerWorld {"}]}