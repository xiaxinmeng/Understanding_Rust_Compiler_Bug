{"sha": "58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4ZDZlYjUwNDgzYzQ0ZWNjNzJkYjZkNzdiNzFhZDVkNWE3YWNhNGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-28T00:05:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-28T00:05:46Z"}, "message": "auto merge of #8797 : nikomatsakis/rust/issue-8625-assign-to-andmut-in-borrowed-loc-2, r=pcwalton\n\nFixes for #8625 to prevent assigning to `&mut` in borrowed or aliasable locations. The old code was insufficient in that it failed to catch bizarre cases like `& &mut &mut`. \r\n\r\nr? @pnkfelix", "tree": {"sha": "a1930a85c3a7d212a45697678ceaee815dcdcff7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1930a85c3a7d212a45697678ceaee815dcdcff7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "html_url": "https://github.com/rust-lang/rust/commit/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5c144a4cd1713e14b0fccd6146648bf968522d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5c144a4cd1713e14b0fccd6146648bf968522d9", "html_url": "https://github.com/rust-lang/rust/commit/d5c144a4cd1713e14b0fccd6146648bf968522d9"}, {"sha": "8c09865b66f5e2865037e6ce1396ba0a653136e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c09865b66f5e2865037e6ce1396ba0a653136e0", "html_url": "https://github.com/rust-lang/rust/commit/8c09865b66f5e2865037e6ce1396ba0a653136e0"}], "stats": {"total": 245, "additions": 166, "deletions": 79}, "files": [{"sha": "857579b5bf025ff8a169c7c6bc9517993f0d51e5", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "patch": "@@ -383,7 +383,7 @@ impl tr for ast::def {\n             ast::def_method(did0.tr(xcx), did1.map(|did1| did1.tr(xcx)))\n           }\n           ast::def_self_ty(nid) => { ast::def_self_ty(xcx.tr_id(nid)) }\n-          ast::def_self(nid, i) => { ast::def_self(xcx.tr_id(nid), i) }\n+          ast::def_self(nid) => { ast::def_self(xcx.tr_id(nid)) }\n           ast::def_mod(did) => { ast::def_mod(did.tr(xcx)) }\n           ast::def_foreign_mod(did) => { ast::def_foreign_mod(did.tr(xcx)) }\n           ast::def_static(did, m) => { ast::def_static(did.tr(xcx), m) }"}, {"sha": "4991f75dc3e371ccb71e95f4c1cc8991d2c67cb4", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 58, "deletions": 13, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "patch": "@@ -367,7 +367,6 @@ impl<'self> CheckLoanCtxt<'self> {\n \n                     mc::cat_rvalue(*) |\n                     mc::cat_static_item |\n-                    mc::cat_implicit_self |\n                     mc::cat_copied_upvar(*) |\n                     mc::cat_deref(_, _, mc::unsafe_ptr(*)) |\n                     mc::cat_deref(_, _, mc::gc_ptr(*)) |\n@@ -406,15 +405,7 @@ impl<'self> CheckLoanCtxt<'self> {\n                 mc::cat_deref(b, _, mc::region_ptr(m_mutbl, _)) => {\n                     // Statically prohibit writes to `&mut` when aliasable\n \n-                    match b.freely_aliasable() {\n-                        None => {}\n-                        Some(cause) => {\n-                            this.bccx.report_aliasability_violation(\n-                                expr.span,\n-                                MutabilityViolation,\n-                                cause);\n-                        }\n-                    }\n+                    check_for_aliasability_violation(this, expr, b);\n                 }\n \n                 mc::cat_deref(_, deref_count, mc::gc_ptr(ast::m_mutbl)) => {\n@@ -434,6 +425,51 @@ impl<'self> CheckLoanCtxt<'self> {\n             return true; // no errors reported\n         }\n \n+        fn check_for_aliasability_violation(this: &CheckLoanCtxt,\n+                                            expr: @ast::expr,\n+                                            cmt: mc::cmt) -> bool {\n+            let mut cmt = cmt;\n+\n+            loop {\n+                match cmt.cat {\n+                    mc::cat_deref(b, _, mc::region_ptr(m_mutbl, _)) |\n+                    mc::cat_downcast(b) |\n+                    mc::cat_stack_upvar(b) |\n+                    mc::cat_deref(b, _, mc::uniq_ptr) |\n+                    mc::cat_interior(b, _) |\n+                    mc::cat_discr(b, _) => {\n+                        // Aliasability depends on base cmt\n+                        cmt = b;\n+                    }\n+\n+                    mc::cat_copied_upvar(_) |\n+                    mc::cat_rvalue(*) |\n+                    mc::cat_local(*) |\n+                    mc::cat_arg(_) |\n+                    mc::cat_self(*) |\n+                    mc::cat_deref(_, _, mc::unsafe_ptr(*)) |\n+                    mc::cat_static_item(*) |\n+                    mc::cat_deref(_, _, mc::gc_ptr(_)) |\n+                    mc::cat_deref(_, _, mc::region_ptr(m_const, _)) |\n+                    mc::cat_deref(_, _, mc::region_ptr(m_imm, _)) => {\n+                        // Aliasability is independent of base cmt\n+                        match cmt.freely_aliasable() {\n+                            None => {\n+                                return true;\n+                            }\n+                            Some(cause) => {\n+                                this.bccx.report_aliasability_violation(\n+                                    expr.span,\n+                                    MutabilityViolation,\n+                                    cause);\n+                                return false;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n         fn check_for_assignment_to_restricted_or_frozen_location(\n             this: &CheckLoanCtxt,\n             expr: @ast::expr,\n@@ -511,6 +547,12 @@ impl<'self> CheckLoanCtxt<'self> {\n             // path, and check that the super path was not lent out as\n             // mutable or immutable (a const loan is ok).\n             //\n+            // Mutability of a path can be dependent on the super path\n+            // in two ways. First, it might be inherited mutability.\n+            // Second, the pointee of an `&mut` pointer can only be\n+            // mutated if it is found in an unaliased location, so we\n+            // have to check that the owner location is not borrowed.\n+            //\n             // Note that we are *not* checking for any and all\n             // restrictions.  We are only interested in the pointers\n             // that the user created, whereas we add restrictions for\n@@ -528,9 +570,12 @@ impl<'self> CheckLoanCtxt<'self> {\n             let mut loan_path = loan_path;\n             loop {\n                 match *loan_path {\n-                    // Peel back one layer if `loan_path` has\n-                    // inherited mutability\n-                    LpExtend(lp_base, mc::McInherited, _) => {\n+                    // Peel back one layer if, for `loan_path` to be\n+                    // mutable, `lp_base` must be mutable. This occurs\n+                    // with inherited mutability and with `&mut`\n+                    // pointers.\n+                    LpExtend(lp_base, mc::McInherited, _) |\n+                    LpExtend(lp_base, _, LpDeref(mc::region_ptr(ast::m_mutbl, _))) => {\n                         loan_path = lp_base;\n                     }\n "}, {"sha": "d6f9d1db7df8830220d1b321f8366b2c63638709", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "patch": "@@ -100,7 +100,6 @@ fn check_is_legal_to_move_from(bccx: @BorrowckCtxt,\n                                cmt0: mc::cmt,\n                                cmt: mc::cmt) -> bool {\n     match cmt.cat {\n-        mc::cat_implicit_self(*) |\n         mc::cat_deref(_, _, mc::region_ptr(*)) |\n         mc::cat_deref(_, _, mc::gc_ptr(*)) |\n         mc::cat_deref(_, _, mc::unsafe_ptr(*)) => {"}, {"sha": "1dcfc515139bb7169c21f84fd0f0ce38f20946cb", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "patch": "@@ -68,7 +68,6 @@ impl GuaranteeLifetimeContext {\n \n         match cmt.cat {\n             mc::cat_rvalue(*) |\n-            mc::cat_implicit_self |\n             mc::cat_copied_upvar(*) |                  // L-Local\n             mc::cat_local(*) |                         // L-Local\n             mc::cat_arg(*) |                           // L-Local\n@@ -301,7 +300,6 @@ impl GuaranteeLifetimeContext {\n             }\n             mc::cat_rvalue(*) |\n             mc::cat_static_item |\n-            mc::cat_implicit_self |\n             mc::cat_copied_upvar(*) |\n             mc::cat_deref(*) => {\n                 false\n@@ -328,7 +326,6 @@ impl GuaranteeLifetimeContext {\n             mc::cat_rvalue(cleanup_scope_id) => {\n                 ty::re_scope(cleanup_scope_id)\n             }\n-            mc::cat_implicit_self |\n             mc::cat_copied_upvar(_) => {\n                 ty::re_scope(self.item_scope_id)\n             }"}, {"sha": "ccfef63d9bcba378224d8cdcb8cb407cd5edcd31", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "patch": "@@ -101,7 +101,7 @@ impl RestrictionsContext {\n                 self.extend(result, cmt.mutbl, LpInterior(i), restrictions)\n             }\n \n-            mc::cat_deref(cmt_base, _, mc::uniq_ptr) => {\n+            mc::cat_deref(cmt_base, _, pk @ mc::uniq_ptr) => {\n                 // R-Deref-Send-Pointer\n                 //\n                 // When we borrow the interior of an owned pointer, we\n@@ -110,12 +110,11 @@ impl RestrictionsContext {\n                 let result = self.restrict(\n                     cmt_base,\n                     restrictions | RESTR_MUTATE | RESTR_CLAIM);\n-                self.extend(result, cmt.mutbl, LpDeref, restrictions)\n+                self.extend(result, cmt.mutbl, LpDeref(pk), restrictions)\n             }\n \n             mc::cat_copied_upvar(*) | // FIXME(#2152) allow mutation of upvars\n             mc::cat_static_item(*) |\n-            mc::cat_implicit_self(*) |\n             mc::cat_deref(_, _, mc::region_ptr(m_imm, _)) |\n             mc::cat_deref(_, _, mc::gc_ptr(m_imm)) => {\n                 // R-Deref-Imm-Borrowed\n@@ -129,7 +128,7 @@ impl RestrictionsContext {\n                 Safe\n             }\n \n-            mc::cat_deref(cmt_base, _, mc::gc_ptr(m_mutbl)) => {\n+            mc::cat_deref(cmt_base, _, pk @ mc::gc_ptr(m_mutbl)) => {\n                 // R-Deref-Managed-Borrowed\n                 //\n                 // Technically, no restrictions are *necessary* here.\n@@ -170,14 +169,14 @@ impl RestrictionsContext {\n                 match opt_loan_path(cmt_base) {\n                     None => Safe,\n                     Some(lp_base) => {\n-                        let lp = @LpExtend(lp_base, cmt.mutbl, LpDeref);\n+                        let lp = @LpExtend(lp_base, cmt.mutbl, LpDeref(pk));\n                         SafeIf(lp, ~[Restriction {loan_path: lp,\n                                                   set: restrictions}])\n                     }\n                 }\n             }\n \n-            mc::cat_deref(cmt_base, _, mc::region_ptr(m_mutbl, _)) => {\n+            mc::cat_deref(cmt_base, _, pk @ mc::region_ptr(m_mutbl, _)) => {\n                 // Because an `&mut` pointer does not inherit its\n                 // mutability, we can only prevent mutation or prevent\n                 // freezing if it is not aliased. Therefore, in such\n@@ -187,7 +186,7 @@ impl RestrictionsContext {\n                     let result = self.restrict(\n                         cmt_base,\n                         RESTR_ALIAS | RESTR_MUTATE | RESTR_CLAIM);\n-                    self.extend(result, cmt.mutbl, LpDeref, restrictions)\n+                    self.extend(result, cmt.mutbl, LpDeref(pk), restrictions)\n                 } else {\n                     // R-Deref-Mut-Borrowed-2\n                     Safe"}, {"sha": "4490fe65d91817e5fde4c4b3f53d6cd1b20ffef8", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "patch": "@@ -261,7 +261,7 @@ pub enum LoanPath {\n \n #[deriving(Eq, IterBytes)]\n pub enum LoanPathElem {\n-    LpDeref,                     // `*LV` in doc.rs\n+    LpDeref(mc::PointerKind),    // `*LV` in doc.rs\n     LpInterior(mc::InteriorKind) // `LV.f` in doc.rs\n }\n \n@@ -284,8 +284,7 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n     match cmt.cat {\n         mc::cat_rvalue(*) |\n         mc::cat_static_item |\n-        mc::cat_copied_upvar(_) |\n-        mc::cat_implicit_self => {\n+        mc::cat_copied_upvar(_) => {\n             None\n         }\n \n@@ -295,9 +294,9 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n             Some(@LpVar(id))\n         }\n \n-        mc::cat_deref(cmt_base, _, _) => {\n+        mc::cat_deref(cmt_base, _, pk) => {\n             do opt_loan_path(cmt_base).map_move |lp| {\n-                @LpExtend(lp, cmt.mutbl, LpDeref)\n+                @LpExtend(lp, cmt.mutbl, LpDeref(pk))\n             }\n         }\n \n@@ -728,7 +727,7 @@ impl BorrowckCtxt {\n                                                  loan_path: &LoanPath,\n                                                  out: &mut ~str) {\n         match *loan_path {\n-            LpExtend(_, _, LpDeref) => {\n+            LpExtend(_, _, LpDeref(_)) => {\n                 out.push_char('(');\n                 self.append_loan_path_to_str(loan_path, out);\n                 out.push_char(')');\n@@ -776,7 +775,7 @@ impl BorrowckCtxt {\n                 out.push_str(\"[]\");\n             }\n \n-            LpExtend(lp_base, _, LpDeref) => {\n+            LpExtend(lp_base, _, LpDeref(_)) => {\n                 out.push_char('*');\n                 self.append_loan_path_to_str(lp_base, out);\n             }\n@@ -854,7 +853,7 @@ impl Repr for LoanPath {\n                 fmt!(\"$(%?)\", id)\n             }\n \n-            &LpExtend(lp, _, LpDeref) => {\n+            &LpExtend(lp, _, LpDeref(_)) => {\n                 fmt!(\"%s.*\", lp.repr(tcx))\n             }\n "}, {"sha": "8be9a5db8bbbb7df69777fad3cabc6045c4313c6", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 23, "deletions": 35, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "patch": "@@ -59,18 +59,17 @@ use syntax::print::pprust;\n \n #[deriving(Eq)]\n pub enum categorization {\n-    cat_rvalue(ast::NodeId),          // temporary val, argument is its scope\n+    cat_rvalue(ast::NodeId),           // temporary val, argument is its scope\n     cat_static_item,\n-    cat_implicit_self,\n     cat_copied_upvar(CopiedUpvar),     // upvar copied into @fn or ~fn env\n     cat_stack_upvar(cmt),              // by ref upvar from &fn\n-    cat_local(ast::NodeId),           // local variable\n-    cat_arg(ast::NodeId),             // formal argument\n-    cat_deref(cmt, uint, ptr_kind),    // deref of a ptr\n+    cat_local(ast::NodeId),            // local variable\n+    cat_arg(ast::NodeId),              // formal argument\n+    cat_deref(cmt, uint, PointerKind), // deref of a ptr\n     cat_interior(cmt, InteriorKind),   // something interior: field, tuple, etc\n     cat_downcast(cmt),                 // selects a particular enum variant (*)\n-    cat_discr(cmt, ast::NodeId),      // match discriminant (see preserve())\n-    cat_self(ast::NodeId),            // explicit `self`\n+    cat_discr(cmt, ast::NodeId),       // match discriminant (see preserve())\n+    cat_self(ast::NodeId),             // explicit `self`\n \n     // (*) downcast is only required if the enum has more than one variant\n }\n@@ -82,8 +81,8 @@ pub struct CopiedUpvar {\n }\n \n // different kinds of pointers:\n-#[deriving(Eq)]\n-pub enum ptr_kind {\n+#[deriving(Eq, IterBytes)]\n+pub enum PointerKind {\n     uniq_ptr,\n     gc_ptr(ast::mutability),\n     region_ptr(ast::mutability, ty::Region),\n@@ -147,7 +146,7 @@ pub type cmt = @cmt_;\n // We pun on *T to mean both actual deref of a ptr as well\n // as accessing of components:\n pub enum deref_kind {\n-    deref_ptr(ptr_kind),\n+    deref_ptr(PointerKind),\n     deref_interior(InteriorKind),\n }\n \n@@ -493,17 +492,11 @@ impl mem_categorization_ctxt {\n             }\n           }\n \n-          ast::def_self(self_id, is_implicit) => {\n-            let cat = if is_implicit {\n-                cat_implicit_self\n-            } else {\n-                cat_self(self_id)\n-            };\n-\n+          ast::def_self(self_id) => {\n             @cmt_ {\n                 id:id,\n                 span:span,\n-                cat:cat,\n+                cat:cat_self(self_id),\n                 mutbl: McImmutable,\n                 ty:expr_ty\n             }\n@@ -1016,9 +1009,6 @@ impl mem_categorization_ctxt {\n           cat_static_item => {\n               ~\"static item\"\n           }\n-          cat_implicit_self => {\n-              ~\"self reference\"\n-          }\n           cat_copied_upvar(_) => {\n               ~\"captured outer variable in a heap closure\"\n           }\n@@ -1121,7 +1111,6 @@ impl cmt_ {\n         match self.cat {\n             cat_rvalue(*) |\n             cat_static_item |\n-            cat_implicit_self |\n             cat_copied_upvar(*) |\n             cat_local(*) |\n             cat_self(*) |\n@@ -1146,9 +1135,10 @@ impl cmt_ {\n     }\n \n     pub fn freely_aliasable(&self) -> Option<AliasableReason> {\n-        //! True if this lvalue resides in an area that is\n-        //! freely aliasable, meaning that rustc cannot track\n-        //! the alias//es with precision.\n+        /*!\n+         * Returns `Some(_)` if this lvalue represents a freely aliasable\n+         * pointer type.\n+         */\n \n         // Maybe non-obvious: copied upvars can only be considered\n         // non-aliasable in once closures, since any other kind can be\n@@ -1166,8 +1156,7 @@ impl cmt_ {\n             }\n \n             cat_copied_upvar(CopiedUpvar {onceness: ast::Many, _}) |\n-            cat_static_item(*) |\n-            cat_implicit_self(*) => {\n+            cat_static_item(*) => {\n                 Some(AliasableOther)\n             }\n \n@@ -1180,12 +1169,12 @@ impl cmt_ {\n                 Some(AliasableBorrowed(m))\n             }\n \n-            cat_downcast(b) |\n-            cat_stack_upvar(b) |\n-            cat_deref(b, _, uniq_ptr) |\n-            cat_interior(b, _) |\n-            cat_discr(b, _) => {\n-                b.freely_aliasable()\n+            cat_downcast(*) |\n+            cat_stack_upvar(*) |\n+            cat_deref(_, _, uniq_ptr) |\n+            cat_interior(*) |\n+            cat_discr(*) => {\n+                None\n             }\n         }\n     }\n@@ -1205,7 +1194,6 @@ impl Repr for categorization {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {\n             cat_static_item |\n-            cat_implicit_self |\n             cat_rvalue(*) |\n             cat_copied_upvar(*) |\n             cat_local(*) |\n@@ -1233,7 +1221,7 @@ impl Repr for categorization {\n     }\n }\n \n-pub fn ptr_sigil(ptr: ptr_kind) -> ~str {\n+pub fn ptr_sigil(ptr: PointerKind) -> ~str {\n     match ptr {\n         uniq_ptr => ~\"~\",\n         gc_ptr(_) => ~\"@\","}, {"sha": "9f55e5e3509bcde0319aabc9f7fe12e8f06f7aef", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "patch": "@@ -228,7 +228,7 @@ pub fn moved_variable_node_id_from_def(def: def) -> Option<NodeId> {\n       def_binding(nid, _) |\n       def_arg(nid, _) |\n       def_local(nid, _) |\n-      def_self(nid, _) => Some(nid),\n+      def_self(nid) => Some(nid),\n \n       _ => None\n     }"}, {"sha": "d60d1e2b8450c3681ab26a8989aab99614ad5274", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "patch": "@@ -125,7 +125,7 @@ pub enum Mutability {\n \n pub enum SelfBinding {\n     NoSelfBinding,\n-    HasSelfBinding(NodeId, bool /* is implicit */)\n+    HasSelfBinding(NodeId)\n }\n \n struct ResolveVisitor {\n@@ -3771,9 +3771,8 @@ impl Resolver {\n                 NoSelfBinding => {\n                     // Nothing to do.\n                 }\n-                HasSelfBinding(self_node_id, is_implicit) => {\n-                    let def_like = dl_def(def_self(self_node_id,\n-                                                   is_implicit));\n+                HasSelfBinding(self_node_id) => {\n+                    let def_like = dl_def(def_self(self_node_id));\n                     *function_value_rib.self_binding = Some(def_like);\n                 }\n             }\n@@ -3917,7 +3916,7 @@ impl Resolver {\n         // we only have self ty if it is a non static method\n         let self_binding = match method.explicit_self.node {\n           sty_static => { NoSelfBinding }\n-          _ => { HasSelfBinding(method.self_id, false) }\n+          _ => { HasSelfBinding(method.self_id) }\n         };\n \n         self.resolve_function(rib_kind,"}, {"sha": "6f981123f5fc31ee13ed88a923cd2a7f7ea82c0b", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "patch": "@@ -1066,7 +1066,7 @@ pub fn trans_local_var(bcx: @mut Block, def: ast::def) -> Datum {\n         ast::def_local(nid, _) | ast::def_binding(nid, _) => {\n             take_local(bcx, bcx.fcx.lllocals, nid)\n         }\n-        ast::def_self(nid, _) => {\n+        ast::def_self(nid) => {\n             let self_info: ValSelfData = match bcx.fcx.llself {\n                 Some(ref self_info) => *self_info,\n                 None => {"}, {"sha": "0c8f22294244227cce9c8af3c097d2c6163aed61", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "patch": "@@ -3093,7 +3093,7 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n                                       defn: ast::def)\n                                    -> ty_param_bounds_and_ty {\n     match defn {\n-      ast::def_arg(nid, _) | ast::def_local(nid, _) | ast::def_self(nid, _) |\n+      ast::def_arg(nid, _) | ast::def_local(nid, _) | ast::def_self(nid) |\n       ast::def_binding(nid, _) => {\n           let typ = fcx.local_ty(sp, nid);\n           return no_params(typ);"}, {"sha": "b25d81056b0c06ffd7412ff8b8f85ec45909b707", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "patch": "@@ -58,7 +58,7 @@ fn encl_region_of_def(fcx: @mut FnCtxt, def: ast::def) -> ty::Region {\n     let tcx = fcx.tcx();\n     match def {\n         def_local(node_id, _) | def_arg(node_id, _) |\n-        def_self(node_id, _) | def_binding(node_id, _) => {\n+        def_self(node_id) | def_binding(node_id, _) => {\n             tcx.region_maps.encl_region(node_id)\n         }\n         def_upvar(_, subdef, closure_id, body_id) => {"}, {"sha": "f09c7427ecc7f1c1241f955842a220ab71bbce87", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "patch": "@@ -171,7 +171,7 @@ pub enum def {\n     def_static_method(/* method */ def_id,\n                       /* trait */  Option<def_id>,\n                       purity),\n-    def_self(NodeId, bool /* is_implicit */),\n+    def_self(NodeId),\n     def_self_ty(/* trait id */ NodeId),\n     def_mod(def_id),\n     def_foreign_mod(def_id),"}, {"sha": "a39da4301ba332a873a48edf2d58ef45eda3916c", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "patch": "@@ -64,7 +64,7 @@ pub fn def_id_of_def(d: def) -> def_id {\n       def_use(id) | def_struct(id) | def_trait(id) | def_method(id, _) => {\n         id\n       }\n-      def_arg(id, _) | def_local(id, _) | def_self(id, _) | def_self_ty(id)\n+      def_arg(id, _) | def_local(id, _) | def_self(id) | def_self_ty(id)\n       | def_upvar(id, _, _, _) | def_binding(id, _) | def_region(id)\n       | def_typaram_binder(id) | def_label(id) => {\n         local_def(id)"}, {"sha": "e4a23e74a12f2e2ada202eabff1d1828103eecc8", "filename": "src/test/compile-fail/borrowck-assign-to-andmut-in-aliasable-loc.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-andmut-in-aliasable-loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-andmut-in-aliasable-loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-andmut-in-aliasable-loc.rs?ref=58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that assignments to an `&mut` pointer which is found in a\n+// borrowed (but otherwise non-aliasable) location is illegal.\n+\n+struct S<'self> {\n+    pointer: &'self mut int\n+}\n+\n+fn a(s: &S) {\n+    *s.pointer += 1; //~ ERROR cannot assign\n+}\n+\n+fn b(s: &mut S) {\n+    *s.pointer += 1;\n+}\n+\n+fn c(s: & &mut S) {\n+    *s.pointer += 1; //~ ERROR cannot assign\n+}\n+\n+fn main() {}"}, {"sha": "dcef74b6c2bc28aad9e3a0c0be46653b7316d288", "filename": "src/test/compile-fail/borrowck-assign-to-andmut-in-borrowed-loc.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-andmut-in-borrowed-loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-andmut-in-borrowed-loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-andmut-in-borrowed-loc.rs?ref=58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that assignments to an `&mut` pointer which is found in a\n+// borrowed (but otherwise non-aliasable) location is illegal.\n+\n+struct S<'self> {\n+    pointer: &'self mut int\n+}\n+\n+fn copy_borrowed_ptr<'a>(p: &'a mut S<'a>) -> S<'a> {\n+    S { pointer: &mut *p.pointer }\n+}\n+\n+fn main() {\n+    let mut x = 1;\n+\n+    {\n+        let mut y = S { pointer: &mut x };\n+        let z = copy_borrowed_ptr(&mut y);\n+        *y.pointer += 1; //~ ERROR cannot assign\n+        *z.pointer += 1;\n+    }\n+}"}]}