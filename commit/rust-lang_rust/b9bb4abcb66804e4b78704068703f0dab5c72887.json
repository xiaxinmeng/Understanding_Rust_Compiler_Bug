{"sha": "b9bb4abcb66804e4b78704068703f0dab5c72887", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5YmI0YWJjYjY2ODA0ZTRiNzg3MDQwNjg3MDNmMGRhYjVjNzI4ODc=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-07-08T22:55:14Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-09-06T20:35:11Z"}, "message": "capturing macros now implemented", "tree": {"sha": "c422f4da5953db7897eb1526e735dd8c6545b1b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c422f4da5953db7897eb1526e735dd8c6545b1b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9bb4abcb66804e4b78704068703f0dab5c72887", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9bb4abcb66804e4b78704068703f0dab5c72887", "html_url": "https://github.com/rust-lang/rust/commit/b9bb4abcb66804e4b78704068703f0dab5c72887", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9bb4abcb66804e4b78704068703f0dab5c72887/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c51e262f367f0f079135a5a176706ea5ef78f78", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c51e262f367f0f079135a5a176706ea5ef78f78", "html_url": "https://github.com/rust-lang/rust/commit/2c51e262f367f0f079135a5a176706ea5ef78f78"}], "stats": {"total": 307, "additions": 222, "deletions": 85}, "files": [{"sha": "24f70bfeaa8bc5e315309a74443b867f9a86a961", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 60, "deletions": 32, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/b9bb4abcb66804e4b78704068703f0dab5c72887/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9bb4abcb66804e4b78704068703f0dab5c72887/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=b9bb4abcb66804e4b78704068703f0dab5c72887", "patch": "@@ -33,6 +33,10 @@ pub struct MacroDef {\n     ext: SyntaxExtension\n }\n \n+// No context arg for an Item Decorator macro, simply because\n+// adding it would require adding a ctxt field to all items.\n+// we could do this if it turns out to be useful.\n+\n pub type ItemDecoratorFun = @fn(@ExtCtxt,\n                              Span,\n                              @ast::MetaItem,\n@@ -41,15 +45,34 @@ pub type ItemDecoratorFun = @fn(@ExtCtxt,\n \n pub type SyntaxExpanderTTFun = @fn(@ExtCtxt,\n                                    Span,\n-                                   &[ast::token_tree])\n+                                   &[ast::token_tree],\n+                                   ast::SyntaxContext)\n                                 -> MacResult;\n \n pub type SyntaxExpanderTTItemFun = @fn(@ExtCtxt,\n+                                       Span,\n+                                       ast::Ident,\n+                                       ~[ast::token_tree],\n+                                       ast::SyntaxContext)\n+                                    -> MacResult;\n+\n+// oog... in order to make the presentation of builtin_normal_tt_no_ctxt\n+// and builtin_ident_tt_no_ctxt palatable, we need one-off types for\n+// functions that don't consume a ctxt:\n+\n+pub type SyntaxExpanderTTFunNoCtxt = @fn(@ExtCtxt,\n+                                   Span,\n+                                   &[ast::token_tree])\n+                                -> MacResult;\n+\n+pub type SyntaxExpanderTTItemFunNoCtxt = @fn(@ExtCtxt,\n                                        Span,\n                                        ast::Ident,\n                                        ~[ast::token_tree])\n                                     -> MacResult;\n \n+\n+\n pub enum MacResult {\n     MRExpr(@ast::Expr),\n     MRItem(@ast::item),\n@@ -78,6 +101,7 @@ pub enum SyntaxExtension {\n     IdentTT(SyntaxExpanderTTItemFun, Option<Span>),\n }\n \n+\n // The SyntaxEnv is the environment that's threaded through the expansion\n // of macros. It contains bindings for macros, and also a special binding\n // for \" block\" (not a legal identifier) that maps to a BlockInfo\n@@ -109,12 +133,16 @@ type RenameList = ~[(ast::Ident,Name)];\n // AST nodes into full ASTs\n pub fn syntax_expander_table() -> SyntaxEnv {\n     // utility function to simplify creating NormalTT syntax extensions\n-    fn builtin_normal_tt(f: SyntaxExpanderTTFun) -> @Transformer {\n-        @SE(NormalTT(f, None))\n+    // that ignore their contexts\n+    fn builtin_normal_tt_no_ctxt(f: SyntaxExpanderTTFunNoCtxt) -> @Transformer {\n+        let wrapped_expander : SyntaxExpanderTTFun = |a,b,c,d|{f(a,b,c)};\n+        @SE(NormalTT(wrapped_expander, None))\n     }\n     // utility function to simplify creating IdentTT syntax extensions\n-    fn builtin_item_tt(f: SyntaxExpanderTTItemFun) -> @Transformer {\n-        @SE(IdentTT(f, None))\n+    // that ignore their contexts\n+    fn builtin_item_tt_no_ctxt(f: SyntaxExpanderTTItemFunNoCtxt) -> @Transformer {\n+        let wrapped_expander : SyntaxExpanderTTItemFun = |a,b,c,d,e|{f(a,b,c,d)};\n+        @SE(IdentTT(wrapped_expander, None))\n     }\n     let mut syntax_expanders = HashMap::new();\n     // NB identifier starts with space, and can't conflict with legal idents\n@@ -124,83 +152,83 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n                                 pending_renames : @mut ~[]\n                             }));\n     syntax_expanders.insert(intern(&\"macro_rules\"),\n-                            builtin_item_tt(\n+                            builtin_item_tt_no_ctxt(\n                                 ext::tt::macro_rules::add_new_extension));\n     syntax_expanders.insert(intern(&\"fmt\"),\n-                            builtin_normal_tt(ext::fmt::expand_syntax_ext));\n+                            builtin_normal_tt_no_ctxt(ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(intern(&\"format\"),\n-                            builtin_normal_tt(ext::ifmt::expand_format));\n+                            builtin_normal_tt_no_ctxt(ext::ifmt::expand_format));\n     syntax_expanders.insert(intern(&\"write\"),\n-                            builtin_normal_tt(ext::ifmt::expand_write));\n+                            builtin_normal_tt_no_ctxt(ext::ifmt::expand_write));\n     syntax_expanders.insert(intern(&\"writeln\"),\n-                            builtin_normal_tt(ext::ifmt::expand_writeln));\n+                            builtin_normal_tt_no_ctxt(ext::ifmt::expand_writeln));\n     syntax_expanders.insert(\n         intern(&\"auto_encode\"),\n         @SE(ItemDecorator(ext::auto_encode::expand_auto_encode)));\n     syntax_expanders.insert(\n         intern(&\"auto_decode\"),\n         @SE(ItemDecorator(ext::auto_encode::expand_auto_decode)));\n     syntax_expanders.insert(intern(&\"env\"),\n-                            builtin_normal_tt(ext::env::expand_env));\n+                            builtin_normal_tt_no_ctxt(ext::env::expand_env));\n     syntax_expanders.insert(intern(&\"option_env\"),\n-                            builtin_normal_tt(ext::env::expand_option_env));\n+                            builtin_normal_tt_no_ctxt(ext::env::expand_option_env));\n     syntax_expanders.insert(intern(\"bytes\"),\n-                            builtin_normal_tt(ext::bytes::expand_syntax_ext));\n+                            builtin_normal_tt_no_ctxt(ext::bytes::expand_syntax_ext));\n     syntax_expanders.insert(intern(\"concat_idents\"),\n-                            builtin_normal_tt(\n+                            builtin_normal_tt_no_ctxt(\n                                 ext::concat_idents::expand_syntax_ext));\n     syntax_expanders.insert(intern(&\"log_syntax\"),\n-                            builtin_normal_tt(\n+                            builtin_normal_tt_no_ctxt(\n                                 ext::log_syntax::expand_syntax_ext));\n     syntax_expanders.insert(intern(&\"deriving\"),\n                             @SE(ItemDecorator(\n                                 ext::deriving::expand_meta_deriving)));\n \n     // Quasi-quoting expanders\n     syntax_expanders.insert(intern(&\"quote_tokens\"),\n-                       builtin_normal_tt(ext::quote::expand_quote_tokens));\n+        @SE(NormalTT(ext::quote::expand_quote_tokens, None)));\n     syntax_expanders.insert(intern(&\"quote_expr\"),\n-                       builtin_normal_tt(ext::quote::expand_quote_expr));\n+        @SE(NormalTT(ext::quote::expand_quote_expr, None)));\n     syntax_expanders.insert(intern(&\"quote_ty\"),\n-                       builtin_normal_tt(ext::quote::expand_quote_ty));\n+        @SE(NormalTT(ext::quote::expand_quote_ty, None)));\n     syntax_expanders.insert(intern(&\"quote_item\"),\n-                       builtin_normal_tt(ext::quote::expand_quote_item));\n+        @SE(NormalTT(ext::quote::expand_quote_item, None)));\n     syntax_expanders.insert(intern(&\"quote_pat\"),\n-                       builtin_normal_tt(ext::quote::expand_quote_pat));\n+        @SE(NormalTT(ext::quote::expand_quote_pat, None)));\n     syntax_expanders.insert(intern(&\"quote_stmt\"),\n-                       builtin_normal_tt(ext::quote::expand_quote_stmt));\n+        @SE(NormalTT(ext::quote::expand_quote_stmt, None)));\n \n     syntax_expanders.insert(intern(&\"line\"),\n-                            builtin_normal_tt(\n+                            builtin_normal_tt_no_ctxt(\n                                 ext::source_util::expand_line));\n     syntax_expanders.insert(intern(&\"col\"),\n-                            builtin_normal_tt(\n+                            builtin_normal_tt_no_ctxt(\n                                 ext::source_util::expand_col));\n     syntax_expanders.insert(intern(&\"file\"),\n-                            builtin_normal_tt(\n+                            builtin_normal_tt_no_ctxt(\n                                 ext::source_util::expand_file));\n     syntax_expanders.insert(intern(&\"stringify\"),\n-                            builtin_normal_tt(\n+                            builtin_normal_tt_no_ctxt(\n                                 ext::source_util::expand_stringify));\n     syntax_expanders.insert(intern(&\"include\"),\n-                            builtin_normal_tt(\n+                            builtin_normal_tt_no_ctxt(\n                                 ext::source_util::expand_include));\n     syntax_expanders.insert(intern(&\"include_str\"),\n-                            builtin_normal_tt(\n+                            builtin_normal_tt_no_ctxt(\n                                 ext::source_util::expand_include_str));\n     syntax_expanders.insert(intern(&\"include_bin\"),\n-                            builtin_normal_tt(\n+                            builtin_normal_tt_no_ctxt(\n                                 ext::source_util::expand_include_bin));\n     syntax_expanders.insert(intern(&\"module_path\"),\n-                            builtin_normal_tt(\n+                            builtin_normal_tt_no_ctxt(\n                                 ext::source_util::expand_mod));\n     syntax_expanders.insert(intern(&\"asm\"),\n-                            builtin_normal_tt(ext::asm::expand_asm));\n+                            builtin_normal_tt_no_ctxt(ext::asm::expand_asm));\n     syntax_expanders.insert(intern(&\"cfg\"),\n-                            builtin_normal_tt(ext::cfg::expand_cfg));\n+                            builtin_normal_tt_no_ctxt(ext::cfg::expand_cfg));\n     syntax_expanders.insert(\n         intern(&\"trace_macros\"),\n-        builtin_normal_tt(ext::trace_macros::expand_trace_macros));\n+        builtin_normal_tt_no_ctxt(ext::trace_macros::expand_trace_macros));\n     MapChain::new(~syntax_expanders)\n }\n "}, {"sha": "91a56590435d4c1f5201796e80fee8aa7e399087", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 116, "deletions": 35, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/b9bb4abcb66804e4b78704068703f0dab5c72887/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9bb4abcb66804e4b78704068703f0dab5c72887/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b9bb4abcb66804e4b78704068703f0dab5c72887", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Block, Crate, NodeId, DeclLocal, EMPTY_CTXT, Expr_, ExprMac};\n+use ast::{Block, Crate, NodeId, DeclLocal, EMPTY_CTXT, Expr_, ExprMac, SyntaxContext};\n use ast::{Local, Ident, mac_invoc_tt};\n use ast::{item_mac, Mrk, Stmt_, StmtDecl, StmtMac, StmtExpr, StmtSemi};\n use ast::{ILLEGAL_CTXT, SCTable, token_tree};\n@@ -42,6 +42,11 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n         // entry-point for all syntax extensions.\n         ExprMac(ref mac) => {\n             match (*mac).node {\n+                // it would almost certainly be cleaner to pass the whole\n+                // macro invocation in, rather than pulling it apart and\n+                // marking the tts and the ctxt separately. This also goes\n+                // for the other three macro invocation chunks of code\n+                // in this file.\n                 // Token-tree macros:\n                 mac_invoc_tt(ref pth, ref tts, ctxt) => {\n                     if (pth.segments.len() > 1u) {\n@@ -70,7 +75,8 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                             let fm = fresh_mark();\n                             // mark before:\n                             let marked_before = mark_tts(*tts,fm);\n-                            let expanded = match expandfun(cx, mac.span, marked_before) {\n+                            let marked_ctxt = new_mark(fm, ctxt);\n+                            let expanded = match expandfun(cx, mac.span, marked_before, marked_ctxt) {\n                                 MRExpr(e) => e,\n                                 MRAny(expr_maker,_,_) => expr_maker(),\n                                 _ => {\n@@ -367,9 +373,9 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n                        cx: @ExtCtxt, it: @ast::item,\n                        fld: @ast_fold)\n                     -> Option<@ast::item> {\n-    let (pth, tts) = match it.node {\n+    let (pth, tts, ctxt) = match it.node {\n         item_mac(codemap::Spanned { node: mac_invoc_tt(ref pth, ref tts, ctxt), _}) => {\n-            (pth, (*tts).clone())\n+            (pth, (*tts).clone(), ctxt)\n         }\n         _ => cx.span_bug(it.span, \"invalid item macro invocation\")\n     };\n@@ -396,10 +402,9 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n                 }\n             });\n             // mark before expansion:\n-            let marked_tts = mark_tts(tts,fm);\n-            // mark after expansion:\n-            // RIGHT HERE: can't apply mark_item to MacResult ... :(\n-            expander(cx, it.span, marked_tts)\n+            let marked_before = mark_tts(tts,fm);\n+            let marked_ctxt = new_mark(fm,ctxt);\n+            expander(cx, it.span, marked_before, marked_ctxt)\n         }\n         Some(@SE(IdentTT(expander, span))) => {\n             if it.ident.name == parse::token::special_idents::invalid.name {\n@@ -417,7 +422,8 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n             let fm = fresh_mark();\n             // mark before expansion:\n             let marked_tts = mark_tts(tts,fm);\n-        expander(cx, it.span, it.ident, marked_tts)\n+            let marked_ctxt = new_mark(fm,ctxt);\n+            expander(cx, it.span, it.ident, marked_tts, marked_ctxt)\n         }\n         _ => cx.span_fatal(\n             it.span, fmt!(\"%s! is not legal in item position\", extnamestr))\n@@ -468,11 +474,11 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                 -> (Option<Stmt_>, Span) {\n     // why the copying here and not in expand_expr?\n     // looks like classic changed-in-only-one-place\n-    let (mac, pth, tts, semi) = match *s {\n+    let (mac, pth, tts, semi, ctxt) = match *s {\n         StmtMac(ref mac, semi) => {\n             match mac.node {\n                 mac_invoc_tt(ref pth, ref tts, ctxt) => {\n-                    ((*mac).clone(), pth, (*tts).clone(), semi)\n+                    ((*mac).clone(), pth, (*tts).clone(), semi, ctxt)\n                 }\n             }\n         }\n@@ -498,7 +504,8 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n             let fm = fresh_mark();\n             // mark before expansion:\n             let marked_tts = mark_tts(tts,fm);\n-            let expanded = match expandfun(cx, mac.span, marked_tts) {\n+            let marked_ctxt = new_mark(fm,ctxt);\n+            let expanded = match expandfun(cx, mac.span, marked_tts, marked_ctxt) {\n                 MRExpr(e) =>\n                     @codemap::Spanned { node: StmtExpr(e, cx.next_id()),\n                                     span: e.span},\n@@ -893,25 +900,6 @@ pub fn new_path_finder(paths: @mut ~[ast::Path]) -> @mut Visitor<()> {\n     context as @mut Visitor<()>\n }\n \n-// given a mutable list of renames, return a tree-folder that applies those\n-// renames.\n-// FIXME #4536: currently pub to allow testing\n-pub fn renames_to_fold(renames : @mut ~[(ast::Ident,ast::Name)]) -> @ast_fold {\n-    let afp = default_ast_fold();\n-    let f_pre = @AstFoldFns {\n-        fold_ident: |id,_| {\n-            // the individual elements are memoized... it would\n-            // also be possible to memoize on the whole list at once.\n-            let new_ctxt = renames.iter().fold(id.ctxt,|ctxt,&(from,to)| {\n-                new_rename(from,to,ctxt)\n-            });\n-            ast::Ident{name:id.name,ctxt:new_ctxt}\n-        },\n-        .. *afp\n-    };\n-    make_fold(f_pre)\n-}\n-\n // expand a block. pushes a new exts_frame, then calls expand_block_elts\n pub fn expand_block(extsbox: @mut SyntaxEnv,\n                     _cx: @ExtCtxt,\n@@ -1427,6 +1415,7 @@ pub trait CtxtFn{\n     fn f(&self, ast::SyntaxContext) -> ast::SyntaxContext;\n }\n \n+// a renamer adds a rename to the syntax context\n pub struct Renamer {\n     from : ast::Ident,\n     to : ast::Name\n@@ -1438,6 +1427,22 @@ impl CtxtFn for Renamer {\n     }\n }\n \n+// a renamer that performs a whole bunch of renames\n+pub struct MultiRenamer {\n+    renames : @mut ~[(ast::Ident,ast::Name)]\n+}\n+\n+impl CtxtFn for MultiRenamer {\n+    fn f(&self, starting_ctxt : ast::SyntaxContext) -> ast::SyntaxContext {\n+        // the individual elements are memoized... it would\n+        // also be possible to memoize on the whole list at once.\n+        self.renames.iter().fold(starting_ctxt,|ctxt,&(from,to)| {\n+            new_rename(from,to,ctxt)\n+        })\n+    }\n+}\n+\n+// a marker adds the given mark to the syntax context\n pub struct Marker { mark : Mrk }\n \n impl CtxtFn for Marker {\n@@ -1446,6 +1451,15 @@ impl CtxtFn for Marker {\n     }\n }\n \n+// a repainter just replaces the given context with the one it's closed over\n+pub struct Repainter { ctxt : SyntaxContext }\n+\n+impl CtxtFn for Repainter {\n+    fn f(&self, ctxt : ast::SyntaxContext) -> ast::SyntaxContext {\n+        self.ctxt\n+    }\n+}\n+\n // given a function from ctxts to ctxts, produce\n // an ast_fold that applies that function to all ctxts:\n pub fn fun_to_ctxt_folder<T : 'static + CtxtFn>(cf: @T) -> @AstFoldFns {\n@@ -1454,7 +1468,7 @@ pub fn fun_to_ctxt_folder<T : 'static + CtxtFn>(cf: @T) -> @AstFoldFns {\n         |ast::Ident{name, ctxt}, _| {\n         ast::Ident{name:name,ctxt:cf.f(ctxt)}\n     };\n-    let fm : @fn(&ast::mac_, span, @ast_fold) -> (ast::mac_,span) =\n+    let fm : @fn(&ast::mac_, Span, @ast_fold) -> (ast::mac_,Span) =\n         |m, sp, fld| {\n         match *m {\n             mac_invoc_tt(ref path, ref tts, ctxt) =>\n@@ -1472,6 +1486,15 @@ pub fn fun_to_ctxt_folder<T : 'static + CtxtFn>(cf: @T) -> @AstFoldFns {\n     }\n }\n \n+\n+\n+// given a mutable list of renames, return a tree-folder that applies those\n+// renames.\n+// FIXME #4536: currently pub to allow testing\n+pub fn renames_to_fold(renames : @mut ~[(ast::Ident,ast::Name)]) -> @AstFoldFns {\n+    fun_to_ctxt_folder(@MultiRenamer{renames : renames})\n+}\n+\n // just a convenience:\n pub fn new_mark_folder(m : Mrk) -> @AstFoldFns { fun_to_ctxt_folder(@Marker{mark:m}) }\n pub fn new_rename_folder(from : ast::Ident, to : ast::Name) -> @AstFoldFns {\n@@ -1513,6 +1536,12 @@ fn mark_item(expr : @ast::item, m : Mrk) -> Option<@ast::item> {\n     new_mark_folder(m).fold_item(expr)\n }\n \n+// replace all contexts in a given expr with the given mark. Used\n+// for capturing macros\n+pub fn replace_ctxts(expr : @ast::Expr, ctxt : SyntaxContext) -> @ast::Expr {\n+    fun_to_ctxt_folder(@Repainter{ctxt:ctxt}).fold_expr(expr)\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::*;\n@@ -1522,7 +1551,7 @@ mod test {\n     use codemap;\n     use codemap::Spanned;\n     use parse;\n-    use parse::token::{gensym, intern, get_ident_interner};\n+    use parse::token::{gensym, intern, get_ident_interner, ident_to_str};\n     use print::pprust;\n     use std;\n     use std::vec;\n@@ -1656,8 +1685,9 @@ mod test {\n         }\n     }\n \n-    fn fake_print_crate(s: @pprust::ps, crate: &ast::Crate) {\n-        pprust::print_mod(s, &crate.module, crate.attrs);\n+    fn fake_print_crate(crate: @ast::Crate) {\n+        let s = pprust::rust_printer(std::io::stderr(),get_ident_interner());\n+        pprust::print_crate_(s, crate);\n     }\n \n     fn expand_crate_str(crate_str: @str) -> @ast::Crate {\n@@ -1784,6 +1814,57 @@ mod test {\n         }\n     }\n \n+    #[test] fn quote_expr_test() {\n+        quote_ext_cx_test(@\"fn main(){let ext_cx = 13; quote_expr!(dontcare);}\");\n+    }\n+    #[test] fn quote_item_test() {\n+        quote_ext_cx_test(@\"fn main(){let ext_cx = 13; quote_item!(dontcare);}\");\n+    }\n+    #[test] fn quote_pat_test() {\n+        quote_ext_cx_test(@\"fn main(){let ext_cx = 13; quote_pat!(dontcare);}\");\n+    }\n+    #[test] fn quote_ty_test() {\n+        quote_ext_cx_test(@\"fn main(){let ext_cx = 13; quote_ty!(dontcare);}\");\n+    }\n+    #[test] fn quote_tokens_test() {\n+        quote_ext_cx_test(@\"fn main(){let ext_cx = 13; quote_tokens!(dontcare);}\");\n+    }\n+\n+    fn quote_ext_cx_test(crate_str : @str) {\n+        let crate = expand_crate_str(crate_str);\n+        // find the ext_cx binding\n+        let bindings = @mut ~[];\n+        visit::walk_crate(&mut new_name_finder(bindings), crate, ());\n+        let cxbinds : ~[&ast::Ident] = bindings.iter().filter(|b|{@\"ext_cx\" == (ident_to_str(*b))}).collect();\n+        let cxbind = match cxbinds {\n+            [b] => b,\n+            _ => fail!(\"expected just one binding for ext_cx\")\n+        };\n+        let resolved_binding = mtwt_resolve(*cxbind);\n+        // find all the ext_cx varrefs:\n+        let varrefs = @mut ~[];\n+        visit::walk_crate(&mut new_path_finder(varrefs), crate, ());\n+        // the ext_cx binding should bind all of the ext_cx varrefs:\n+        for (idx,v) in varrefs.iter().filter(|p|{ p.segments.len() == 1\n+                    && (@\"ext_cx\" == (ident_to_str(&p.segments[0].identifier)))\n+            }).enumerate() {\n+            if (mtwt_resolve(v.segments[0].identifier) != resolved_binding) {\n+                std::io::println(\"uh oh, ext_cx binding didn't match ext_cx varref:\");\n+                std::io::println(fmt!(\"this is varref # %?\",idx));\n+                std::io::println(fmt!(\"binding: %?\",cxbind));\n+                std::io::println(fmt!(\"resolves to: %?\",resolved_binding));\n+                std::io::println(fmt!(\"varref: %?\",v.segments[0]));\n+                std::io::println(fmt!(\"resolves to: %?\",mtwt_resolve(v.segments[0].identifier)));\n+                let table = get_sctable();\n+                std::io::println(\"SC table:\");\n+                for (idx,val) in table.table.iter().enumerate() {\n+                    std::io::println(fmt!(\"%4u : %?\",idx,val));\n+                }\n+            }\n+            assert_eq!(mtwt_resolve(v.segments[0].identifier),resolved_binding);\n+        };\n+    }\n+\n     #[test]\n     fn pat_idents(){\n         let pat = string_to_pat(@\"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\");"}, {"sha": "d1299cf56cb0dc679e3ac42dd370a4badbb3e8cc", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b9bb4abcb66804e4b78704068703f0dab5c72887/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9bb4abcb66804e4b78704068703f0dab5c72887/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=b9bb4abcb66804e4b78704068703f0dab5c72887", "patch": "@@ -12,6 +12,7 @@ use ast;\n use codemap::{BytePos, Pos, Span};\n use ext::base::ExtCtxt;\n use ext::base;\n+use ext::expand;\n use ext::build::AstBuilder;\n use parse::token::*;\n use parse::token;\n@@ -291,47 +292,73 @@ pub mod rt {\n \n pub fn expand_quote_tokens(cx: @ExtCtxt,\n                            sp: Span,\n-                           tts: &[ast::token_tree]) -> base::MacResult {\n+                           tts: &[ast::token_tree],\n+                           ctxt: ast::SyntaxContext) -> base::MacResult {\n     let (cx_expr, expr) = expand_tts(cx, sp, tts);\n-    base::MRExpr(expand_wrapper(cx, sp, cx_expr, expr))\n+    let expanded = expand_wrapper(cx, sp, cx_expr, expr);\n+    // repaint the expanded code so it's as though it was the original text.\n+    let repainted = expand::replace_ctxts(expanded,ctxt);\n+    base::MRExpr(repainted)\n }\n \n pub fn expand_quote_expr(cx: @ExtCtxt,\n                          sp: Span,\n-                         tts: &[ast::token_tree]) -> base::MacResult {\n-    base::MRExpr(expand_parse_call(cx, sp, \"parse_expr\", ~[], tts))\n+                         tts: &[ast::token_tree],\n+                         ctxt: ast::SyntaxContext) -> base::MacResult {\n+    let expanded = expand_parse_call(cx, sp, \"parse_expr\", ~[], tts);\n+    // repaint the expanded code so it's as though it was the original text.\n+    let repainted = expand::replace_ctxts(expanded,ctxt);\n+    base::MRExpr(repainted)\n }\n \n+// these probably need to be capturing, too...\n+\n pub fn expand_quote_item(cx: @ExtCtxt,\n                          sp: Span,\n-                         tts: &[ast::token_tree]) -> base::MacResult {\n+                         tts: &[ast::token_tree],\n+                         ctxt: ast::SyntaxContext) -> base::MacResult {\n     let e_attrs = cx.expr_vec_uniq(sp, ~[]);\n-    base::MRExpr(expand_parse_call(cx, sp, \"parse_item\",\n-                                    ~[e_attrs], tts))\n+    let expanded = expand_parse_call(cx, sp, \"parse_item\",\n+                                    ~[e_attrs], tts);\n+    // repaint the expanded code so it's as though it was the original text.\n+    let repainted = expand::replace_ctxts(expanded,ctxt);\n+    base::MRExpr(repainted)\n }\n \n pub fn expand_quote_pat(cx: @ExtCtxt,\n                         sp: Span,\n-                        tts: &[ast::token_tree]) -> base::MacResult {\n+                        tts: &[ast::token_tree],\n+                        ctxt: ast::SyntaxContext) -> base::MacResult {\n     let e_refutable = cx.expr_lit(sp, ast::lit_bool(true));\n-    base::MRExpr(expand_parse_call(cx, sp, \"parse_pat\",\n-                                    ~[e_refutable], tts))\n+    let expanded = expand_parse_call(cx, sp, \"parse_pat\",\n+                                    ~[e_refutable], tts);\n+    // repaint the expanded code so it's as though it was the original text.\n+    let repainted = expand::replace_ctxts(expanded,ctxt);\n+    base::MRExpr(repainted)\n }\n \n pub fn expand_quote_ty(cx: @ExtCtxt,\n                        sp: Span,\n-                       tts: &[ast::token_tree]) -> base::MacResult {\n+                       tts: &[ast::token_tree],\n+                       ctxt: ast::SyntaxContext) -> base::MacResult {\n     let e_param_colons = cx.expr_lit(sp, ast::lit_bool(false));\n-    base::MRExpr(expand_parse_call(cx, sp, \"parse_ty\",\n-                                    ~[e_param_colons], tts))\n+    let expanded = expand_parse_call(cx, sp, \"parse_ty\",\n+                                     ~[e_param_colons], tts);\n+    // repaint the expanded code so it's as though it was the original text.\n+    let repainted = expand::replace_ctxts(expanded,ctxt);\n+    base::MRExpr(repainted)\n }\n \n pub fn expand_quote_stmt(cx: @ExtCtxt,\n                          sp: Span,\n-                         tts: &[ast::token_tree]) -> base::MacResult {\n+                         tts: &[ast::token_tree],\n+                         ctxt: ast::SyntaxContext) -> base::MacResult {\n     let e_attrs = cx.expr_vec_uniq(sp, ~[]);\n-    base::MRExpr(expand_parse_call(cx, sp, \"parse_stmt\",\n-                                    ~[e_attrs], tts))\n+    let expanded = expand_parse_call(cx, sp, \"parse_stmt\",\n+                                    ~[e_attrs], tts);\n+    // repaint the expanded code so it's as though it was the original text.\n+    let repainted = expand::replace_ctxts(expanded,ctxt);\n+    base::MRExpr(repainted)\n }\n \n fn ids_ext(strs: ~[~str]) -> ~[ast::Ident] {"}, {"sha": "074ec3cd195eced136e5f71b96a4bab10ba7967c", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9bb4abcb66804e4b78704068703f0dab5c72887/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9bb4abcb66804e4b78704068703f0dab5c72887/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=b9bb4abcb66804e4b78704068703f0dab5c72887", "patch": "@@ -150,8 +150,8 @@ pub fn add_new_extension(cx: @ExtCtxt,\n         cx.span_fatal(best_fail_spot, best_fail_msg);\n     }\n \n-    let exp: @fn(@ExtCtxt, Span, &[ast::token_tree]) -> MacResult =\n-        |cx, sp, arg| generic_extension(cx, sp, name, arg, *lhses, *rhses);\n+    let exp: @fn(@ExtCtxt, Span, &[ast::token_tree], ctxt: ast::SyntaxContext) -> MacResult =\n+        |cx, sp, arg, _ctxt| generic_extension(cx, sp, name, arg, *lhses, *rhses);\n \n     return MRDef(MacroDef{\n         name: ident_to_str(&name),"}, {"sha": "b805d55830f125ab6c1c46181ae70da735e27df8", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b9bb4abcb66804e4b78704068703f0dab5c72887/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9bb4abcb66804e4b78704068703f0dab5c72887/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=b9bb4abcb66804e4b78704068703f0dab5c72887", "patch": "@@ -209,6 +209,7 @@ pub fn noop_fold_crate(c: &Crate, fld: @ast_fold) -> Crate {\n }\n \n fn noop_fold_view_item(vi: &view_item_, _fld: @ast_fold) -> view_item_ {\n+    // FIXME #7654: doesn't iterate over idents in a view_item_use\n     return /* FIXME (#2543) */ (*vi).clone();\n }\n "}]}