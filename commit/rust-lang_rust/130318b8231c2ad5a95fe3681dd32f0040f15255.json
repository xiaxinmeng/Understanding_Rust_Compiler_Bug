{"sha": "130318b8231c2ad5a95fe3681dd32f0040f15255", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzMDMxOGI4MjMxYzJhZDVhOTVmZTM2ODFkZDMyZjAwNDBmMTUyNTU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-05-24T13:34:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-24T13:34:35Z"}, "message": "Merge pull request #4548 from bnjjj/fix_4464\n\nadd support of feature flag for runnables", "tree": {"sha": "8d67b9cbad2b5f64e4135e626b80646bed851ca6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d67b9cbad2b5f64e4135e626b80646bed851ca6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/130318b8231c2ad5a95fe3681dd32f0040f15255", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeynfrCRBK7hj4Ov3rIwAAdHIIAEMz4sJymoF0rwxr5/rySl3C\nlGR8QQzI7DLbrL0Uq1+8t4xq3rfY2D9LYaJ4lbFVXViM5d1jH+q2eKiMzLM/PHO4\nooXf8ZGKd6ChPkEktoHcbVJNXWIXcEHu6URcsGEp4hTRTlykbM8eMrsqSnhF1FGE\nGe9D0BVIWDoc1jHxgzIRZuqixaYhmMYXcu1fIQt0siFW9WYfhJzT2fePmRZInKcM\nD249wqODo4ur2Ey5Y8RH6ANBDLkoo35jTboWvAnskakcQzhFAgteXmLZ+SxWzG97\n7ZtsG4r1Yj9PLvOYzi/YJgHL2HJLZm86bxbYeEqFial7xhKfRl1ArEkNxuOEP0w=\n=h2Hx\n-----END PGP SIGNATURE-----\n", "payload": "tree 8d67b9cbad2b5f64e4135e626b80646bed851ca6\nparent f26b7928e065f067d7181d3425fe17526dc3bcd1\nparent 27ed376bc4dfed39295af650effe63007e443b6f\nauthor Aleksey Kladov <aleksey.kladov@gmail.com> 1590327275 +0200\ncommitter GitHub <noreply@github.com> 1590327275 +0200\n\nMerge pull request #4548 from bnjjj/fix_4464\n\nadd support of feature flag for runnables"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/130318b8231c2ad5a95fe3681dd32f0040f15255", "html_url": "https://github.com/rust-lang/rust/commit/130318b8231c2ad5a95fe3681dd32f0040f15255", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/130318b8231c2ad5a95fe3681dd32f0040f15255/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f26b7928e065f067d7181d3425fe17526dc3bcd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f26b7928e065f067d7181d3425fe17526dc3bcd1", "html_url": "https://github.com/rust-lang/rust/commit/f26b7928e065f067d7181d3425fe17526dc3bcd1"}, {"sha": "27ed376bc4dfed39295af650effe63007e443b6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/27ed376bc4dfed39295af650effe63007e443b6f", "html_url": "https://github.com/rust-lang/rust/commit/27ed376bc4dfed39295af650effe63007e443b6f"}], "stats": {"total": 253, "additions": 234, "deletions": 19}, "files": [{"sha": "ca6c64166317a08211ca0c9a341f61c144709a8b", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/130318b8231c2ad5a95fe3681dd32f0040f15255/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/130318b8231c2ad5a95fe3681dd32f0040f15255/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=130318b8231c2ad5a95fe3681dd32f0040f15255", "patch": "@@ -1372,17 +1372,20 @@ dependencies = [\n  \"lsp-types\",\n  \"parking_lot\",\n  \"pico-args\",\n+ \"ra_cfg\",\n  \"ra_db\",\n  \"ra_flycheck\",\n  \"ra_hir\",\n  \"ra_hir_def\",\n  \"ra_hir_ty\",\n  \"ra_ide\",\n+ \"ra_mbe\",\n  \"ra_proc_macro_srv\",\n  \"ra_prof\",\n  \"ra_project_model\",\n  \"ra_syntax\",\n  \"ra_text_edit\",\n+ \"ra_tt\",\n  \"ra_vfs\",\n  \"rand\",\n  \"relative-path\","}, {"sha": "85b100c6adfe6523c1e3cf5488815682ad90c05f", "filename": "crates/ra_cfg/src/cfg_expr.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/130318b8231c2ad5a95fe3681dd32f0040f15255/crates%2Fra_cfg%2Fsrc%2Fcfg_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130318b8231c2ad5a95fe3681dd32f0040f15255/crates%2Fra_cfg%2Fsrc%2Fcfg_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cfg%2Fsrc%2Fcfg_expr.rs?ref=130318b8231c2ad5a95fe3681dd32f0040f15255", "patch": "@@ -88,13 +88,17 @@ fn next_cfg_expr(it: &mut SliceIter<tt::TokenTree>) -> Option<CfgExpr> {\n mod tests {\n     use super::*;\n \n-    use mbe::ast_to_token_tree;\n+    use mbe::{ast_to_token_tree, TokenMap};\n     use ra_syntax::ast::{self, AstNode};\n \n-    fn assert_parse_result(input: &str, expected: CfgExpr) {\n+    fn get_token_tree_generated(input: &str) -> (tt::Subtree, TokenMap) {\n         let source_file = ast::SourceFile::parse(input).ok().unwrap();\n         let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n-        let (tt, _) = ast_to_token_tree(&tt).unwrap();\n+        ast_to_token_tree(&tt).unwrap()\n+    }\n+\n+    fn assert_parse_result(input: &str, expected: CfgExpr) {\n+        let (tt, _) = get_token_tree_generated(input);\n         assert_eq!(parse_cfg(&tt), expected);\n     }\n "}, {"sha": "3364a822f431cf3067589fe2f3824451802edd87", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/130318b8231c2ad5a95fe3681dd32f0040f15255/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130318b8231c2ad5a95fe3681dd32f0040f15255/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=130318b8231c2ad5a95fe3681dd32f0040f15255", "patch": "@@ -62,6 +62,7 @@ pub use crate::{\n \n pub use hir_def::{\n     adt::StructKind,\n+    attr::Attrs,\n     body::scope::ExprScopes,\n     builtin_type::BuiltinType,\n     docs::Documentation,"}, {"sha": "8b6c0bedee78bc8daf2ffb90af73bbaeca3fe6a9", "filename": "crates/ra_hir_def/src/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/130318b8231c2ad5a95fe3681dd32f0040f15255/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130318b8231c2ad5a95fe3681dd32f0040f15255/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fattr.rs?ref=130318b8231c2ad5a95fe3681dd32f0040f15255", "patch": "@@ -81,7 +81,7 @@ impl Attrs {\n         }\n     }\n \n-    fn from_attrs_owner(db: &dyn DefDatabase, owner: InFile<&dyn AttrsOwner>) -> Attrs {\n+    pub fn from_attrs_owner(db: &dyn DefDatabase, owner: InFile<&dyn AttrsOwner>) -> Attrs {\n         let hygiene = Hygiene::new(db.upcast(), owner.file_id);\n         Attrs::new(owner.value, &hygiene)\n     }"}, {"sha": "273036cee1cfec60fee9b4398055fdfc45731519", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/130318b8231c2ad5a95fe3681dd32f0040f15255/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130318b8231c2ad5a95fe3681dd32f0040f15255/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=130318b8231c2ad5a95fe3681dd32f0040f15255", "patch": "@@ -29,7 +29,7 @@ use crate::{\n     AsMacroCall, DefWithBodyId, HasModule, Lookup, ModuleId,\n };\n \n-/// A subset of Exander that only deals with cfg attributes. We only need it to\n+/// A subset of Expander that only deals with cfg attributes. We only need it to\n /// avoid cyclic queries in crate def map during enum processing.\n pub(crate) struct CfgExpander {\n     cfg_options: CfgOptions,"}, {"sha": "ed98e58e00ca4e0885e56d92f350e950213ed21d", "filename": "crates/ra_ide/src/runnables.rs", "status": "modified", "additions": 131, "deletions": 12, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/130318b8231c2ad5a95fe3681dd32f0040f15255/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130318b8231c2ad5a95fe3681dd32f0040f15255/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Frunnables.rs?ref=130318b8231c2ad5a95fe3681dd32f0040f15255", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use hir::{AsAssocItem, Semantics};\n+use hir::{AsAssocItem, Attrs, HirFileId, InFile, Semantics};\n use itertools::Itertools;\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n@@ -10,12 +10,14 @@ use ra_syntax::{\n \n use crate::FileId;\n use ast::DocCommentsOwner;\n+use ra_cfg::CfgExpr;\n use std::fmt::Display;\n \n #[derive(Debug)]\n pub struct Runnable {\n     pub range: TextRange,\n     pub kind: RunnableKind,\n+    pub cfg_exprs: Vec<CfgExpr>,\n }\n \n #[derive(Debug)]\n@@ -45,20 +47,24 @@ pub enum RunnableKind {\n pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {\n     let sema = Semantics::new(db);\n     let source_file = sema.parse(file_id);\n-    source_file.syntax().descendants().filter_map(|i| runnable(&sema, i)).collect()\n+    source_file.syntax().descendants().filter_map(|i| runnable(&sema, i, file_id)).collect()\n }\n \n-fn runnable(sema: &Semantics<RootDatabase>, item: SyntaxNode) -> Option<Runnable> {\n+fn runnable(sema: &Semantics<RootDatabase>, item: SyntaxNode, file_id: FileId) -> Option<Runnable> {\n     match_ast! {\n         match item {\n-            ast::FnDef(it) => runnable_fn(sema, it),\n-            ast::Module(it) => runnable_mod(sema, it),\n+            ast::FnDef(it) => runnable_fn(sema, it, file_id),\n+            ast::Module(it) => runnable_mod(sema, it, file_id),\n             _ => None,\n         }\n     }\n }\n \n-fn runnable_fn(sema: &Semantics<RootDatabase>, fn_def: ast::FnDef) -> Option<Runnable> {\n+fn runnable_fn(\n+    sema: &Semantics<RootDatabase>,\n+    fn_def: ast::FnDef,\n+    file_id: FileId,\n+) -> Option<Runnable> {\n     let name_string = fn_def.name()?.text().to_string();\n \n     let kind = if name_string == \"main\" {\n@@ -111,7 +117,12 @@ fn runnable_fn(sema: &Semantics<RootDatabase>, fn_def: ast::FnDef) -> Option<Run\n             return None;\n         }\n     };\n-    Some(Runnable { range: fn_def.syntax().text_range(), kind })\n+\n+    let attrs = Attrs::from_attrs_owner(sema.db, InFile::new(HirFileId::from(file_id), &fn_def));\n+    let cfg_exprs =\n+        attrs.by_key(\"cfg\").tt_values().map(|subtree| ra_cfg::parse_cfg(subtree)).collect();\n+\n+    Some(Runnable { range: fn_def.syntax().text_range(), kind, cfg_exprs })\n }\n \n #[derive(Debug)]\n@@ -147,7 +158,11 @@ fn has_doc_test(fn_def: &ast::FnDef) -> bool {\n     fn_def.doc_comment_text().map_or(false, |comment| comment.contains(\"```\"))\n }\n \n-fn runnable_mod(sema: &Semantics<RootDatabase>, module: ast::Module) -> Option<Runnable> {\n+fn runnable_mod(\n+    sema: &Semantics<RootDatabase>,\n+    module: ast::Module,\n+    file_id: FileId,\n+) -> Option<Runnable> {\n     let has_test_function = module\n         .item_list()?\n         .items()\n@@ -160,11 +175,20 @@ fn runnable_mod(sema: &Semantics<RootDatabase>, module: ast::Module) -> Option<R\n         return None;\n     }\n     let range = module.syntax().text_range();\n-    let module = sema.to_def(&module)?;\n+    let module_def = sema.to_def(&module)?;\n+\n+    let path = module_def\n+        .path_to_root(sema.db)\n+        .into_iter()\n+        .rev()\n+        .filter_map(|it| it.name(sema.db))\n+        .join(\"::\");\n+\n+    let attrs = Attrs::from_attrs_owner(sema.db, InFile::new(HirFileId::from(file_id), &module));\n+    let cfg_exprs =\n+        attrs.by_key(\"cfg\").tt_values().map(|subtree| ra_cfg::parse_cfg(subtree)).collect();\n \n-    let path =\n-        module.path_to_root(sema.db).into_iter().rev().filter_map(|it| it.name(sema.db)).join(\"::\");\n-    Some(Runnable { range, kind: RunnableKind::TestMod { path } })\n+    Some(Runnable { range, kind: RunnableKind::TestMod { path }, cfg_exprs })\n }\n \n #[cfg(test)]\n@@ -196,6 +220,7 @@ mod tests {\n             Runnable {\n                 range: 1..21,\n                 kind: Bin,\n+                cfg_exprs: [],\n             },\n             Runnable {\n                 range: 22..46,\n@@ -207,6 +232,7 @@ mod tests {\n                         ignore: false,\n                     },\n                 },\n+                cfg_exprs: [],\n             },\n             Runnable {\n                 range: 47..81,\n@@ -218,6 +244,7 @@ mod tests {\n                         ignore: true,\n                     },\n                 },\n+                cfg_exprs: [],\n             },\n         ]\n         \"###\n@@ -245,6 +272,7 @@ mod tests {\n             Runnable {\n                 range: 1..21,\n                 kind: Bin,\n+                cfg_exprs: [],\n             },\n             Runnable {\n                 range: 22..64,\n@@ -253,6 +281,7 @@ mod tests {\n                         \"foo\",\n                     ),\n                 },\n+                cfg_exprs: [],\n             },\n         ]\n         \"###\n@@ -283,6 +312,7 @@ mod tests {\n             Runnable {\n                 range: 1..21,\n                 kind: Bin,\n+                cfg_exprs: [],\n             },\n             Runnable {\n                 range: 51..105,\n@@ -291,6 +321,7 @@ mod tests {\n                         \"Data::foo\",\n                     ),\n                 },\n+                cfg_exprs: [],\n             },\n         ]\n         \"###\n@@ -318,6 +349,7 @@ mod tests {\n                 kind: TestMod {\n                     path: \"test_mod\",\n                 },\n+                cfg_exprs: [],\n             },\n             Runnable {\n                 range: 28..57,\n@@ -329,6 +361,7 @@ mod tests {\n                         ignore: false,\n                     },\n                 },\n+                cfg_exprs: [],\n             },\n         ]\n         \"###\n@@ -358,6 +391,7 @@ mod tests {\n                 kind: TestMod {\n                     path: \"foo::test_mod\",\n                 },\n+                cfg_exprs: [],\n             },\n             Runnable {\n                 range: 46..79,\n@@ -369,6 +403,7 @@ mod tests {\n                         ignore: false,\n                     },\n                 },\n+                cfg_exprs: [],\n             },\n         ]\n         \"###\n@@ -400,6 +435,7 @@ mod tests {\n                 kind: TestMod {\n                     path: \"foo::bar::test_mod\",\n                 },\n+                cfg_exprs: [],\n             },\n             Runnable {\n                 range: 68..105,\n@@ -411,6 +447,89 @@ mod tests {\n                         ignore: false,\n                     },\n                 },\n+                cfg_exprs: [],\n+            },\n+        ]\n+        \"###\n+                );\n+    }\n+\n+    #[test]\n+    fn test_runnables_with_feature() {\n+        let (analysis, pos) = analysis_and_position(\n+            r#\"\n+        //- /lib.rs crate:foo cfg:feature=foo\n+        <|> //empty\n+        #[test]\n+        #[cfg(feature = \"foo\")]\n+        fn test_foo1() {}\n+        \"#,\n+        );\n+        let runnables = analysis.runnables(pos.file_id).unwrap();\n+        assert_debug_snapshot!(&runnables,\n+        @r###\"\n+        [\n+            Runnable {\n+                range: 1..58,\n+                kind: Test {\n+                    test_id: Name(\n+                        \"test_foo1\",\n+                    ),\n+                    attr: TestAttr {\n+                        ignore: false,\n+                    },\n+                },\n+                cfg_exprs: [\n+                    KeyValue {\n+                        key: \"feature\",\n+                        value: \"foo\",\n+                    },\n+                ],\n+            },\n+        ]\n+        \"###\n+                );\n+    }\n+\n+    #[test]\n+    fn test_runnables_with_features() {\n+        let (analysis, pos) = analysis_and_position(\n+            r#\"\n+        //- /lib.rs crate:foo cfg:feature=foo,feature=bar\n+        <|> //empty\n+        #[test]\n+        #[cfg(all(feature = \"foo\", feature = \"bar\"))]\n+        fn test_foo1() {}\n+        \"#,\n+        );\n+        let runnables = analysis.runnables(pos.file_id).unwrap();\n+        assert_debug_snapshot!(&runnables,\n+        @r###\"\n+        [\n+            Runnable {\n+                range: 1..80,\n+                kind: Test {\n+                    test_id: Name(\n+                        \"test_foo1\",\n+                    ),\n+                    attr: TestAttr {\n+                        ignore: false,\n+                    },\n+                },\n+                cfg_exprs: [\n+                    All(\n+                        [\n+                            KeyValue {\n+                                key: \"feature\",\n+                                value: \"foo\",\n+                            },\n+                            KeyValue {\n+                                key: \"feature\",\n+                                value: \"bar\",\n+                            },\n+                        ],\n+                    ),\n+                ],\n             },\n         ]\n         \"###"}, {"sha": "65b487db3b98267547d659452b6553568dc41d67", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/130318b8231c2ad5a95fe3681dd32f0040f15255/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/130318b8231c2ad5a95fe3681dd32f0040f15255/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=130318b8231c2ad5a95fe3681dd32f0040f15255", "patch": "@@ -40,6 +40,7 @@ ra_project_model = { path = \"../ra_project_model\" }\n ra_syntax = { path = \"../ra_syntax\" }\n ra_text_edit = { path = \"../ra_text_edit\" }\n ra_vfs = \"0.6.0\"\n+ra_cfg = { path = \"../ra_cfg\"}\n \n # This should only be used in CLI\n ra_db = { path = \"../ra_db\" }\n@@ -55,6 +56,8 @@ winapi = \"0.3.8\"\n tempfile = \"3.1.0\"\n insta = \"0.16.0\"\n test_utils = { path = \"../test_utils\" }\n+mbe = { path = \"../ra_mbe\", package = \"ra_mbe\" }\n+tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n \n [features]\n jemalloc = [ \"ra_prof/jemalloc\" ]"}, {"sha": "441fb61df006185f0e69f003b329b853140e0e7d", "filename": "crates/rust-analyzer/src/cargo_target_spec.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/130318b8231c2ad5a95fe3681dd32f0040f15255/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130318b8231c2ad5a95fe3681dd32f0040f15255/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs?ref=130318b8231c2ad5a95fe3681dd32f0040f15255", "patch": "@@ -4,6 +4,7 @@ use ra_ide::{FileId, RunnableKind, TestId};\n use ra_project_model::{self, ProjectWorkspace, TargetKind};\n \n use crate::{world::WorldSnapshot, Result};\n+use ra_syntax::SmolStr;\n \n /// Abstract representation of Cargo target.\n ///\n@@ -20,6 +21,7 @@ impl CargoTargetSpec {\n     pub(crate) fn runnable_args(\n         spec: Option<CargoTargetSpec>,\n         kind: &RunnableKind,\n+        features_needed: &Vec<SmolStr>,\n     ) -> Result<(Vec<String>, Vec<String>)> {\n         let mut args = Vec::new();\n         let mut extra_args = Vec::new();\n@@ -73,6 +75,12 @@ impl CargoTargetSpec {\n                 }\n             }\n         }\n+\n+        features_needed.iter().for_each(|feature| {\n+            args.push(\"--features\".to_string());\n+            args.push(feature.to_string());\n+        });\n+\n         Ok((args, extra_args))\n     }\n "}, {"sha": "2aaff3ea48bab8e481c3595ab6af484d8e79e161", "filename": "crates/rust-analyzer/src/main_loop/handlers.rs", "status": "modified", "additions": 79, "deletions": 2, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/130318b8231c2ad5a95fe3681dd32f0040f15255/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130318b8231c2ad5a95fe3681dd32f0040f15255/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=130318b8231c2ad5a95fe3681dd32f0040f15255", "patch": "@@ -17,13 +17,14 @@ use lsp_types::{\n     SemanticTokensParams, SemanticTokensRangeParams, SemanticTokensRangeResult,\n     SemanticTokensResult, SymbolInformation, TextDocumentIdentifier, Url, WorkspaceEdit,\n };\n+use ra_cfg::CfgExpr;\n use ra_ide::{\n     FileId, FilePosition, FileRange, Query, RangeInfo, Runnable, RunnableKind, SearchScope,\n     TextEdit,\n };\n use ra_prof::profile;\n use ra_project_model::TargetKind;\n-use ra_syntax::{AstNode, SyntaxKind, TextRange, TextSize};\n+use ra_syntax::{AstNode, SmolStr, SyntaxKind, TextRange, TextSize};\n use rustc_hash::FxHashMap;\n use serde::{Deserialize, Serialize};\n use serde_json::to_value;\n@@ -978,7 +979,12 @@ fn to_lsp_runnable(\n ) -> Result<lsp_ext::Runnable> {\n     let spec = CargoTargetSpec::for_file(world, file_id)?;\n     let target = spec.as_ref().map(|s| s.target.clone());\n-    let (args, extra_args) = CargoTargetSpec::runnable_args(spec, &runnable.kind)?;\n+    let mut features_needed = vec![];\n+    for cfg_expr in &runnable.cfg_exprs {\n+        collect_minimal_features_needed(cfg_expr, &mut features_needed);\n+    }\n+    let (args, extra_args) =\n+        CargoTargetSpec::runnable_args(spec, &runnable.kind, &features_needed)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n     let label = match &runnable.kind {\n         RunnableKind::Test { test_id, .. } => format!(\"test {}\", test_id),\n@@ -1004,6 +1010,26 @@ fn to_lsp_runnable(\n     })\n }\n \n+/// Fill minimal features needed\n+fn collect_minimal_features_needed(cfg_expr: &CfgExpr, features: &mut Vec<SmolStr>) {\n+    match cfg_expr {\n+        CfgExpr::KeyValue { key, value } if key == \"feature\" => features.push(value.clone()),\n+        CfgExpr::All(preds) => {\n+            preds.iter().for_each(|cfg| collect_minimal_features_needed(cfg, features));\n+        }\n+        CfgExpr::Any(preds) => {\n+            for cfg in preds {\n+                let len_features = features.len();\n+                collect_minimal_features_needed(cfg, features);\n+                if len_features != features.len() {\n+                    break;\n+                }\n+            }\n+        }\n+        _ => {}\n+    }\n+}\n+\n pub fn handle_inlay_hints(\n     world: WorldSnapshot,\n     params: InlayHintsParams,\n@@ -1140,3 +1166,54 @@ pub fn handle_semantic_tokens_range(\n     let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n     Ok(Some(semantic_tokens.into()))\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use mbe::{ast_to_token_tree, TokenMap};\n+    use ra_cfg::parse_cfg;\n+    use ra_syntax::{\n+        ast::{self, AstNode},\n+        SmolStr,\n+    };\n+\n+    fn get_token_tree_generated(input: &str) -> (tt::Subtree, TokenMap) {\n+        let source_file = ast::SourceFile::parse(input).ok().unwrap();\n+        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+        ast_to_token_tree(&tt).unwrap()\n+    }\n+\n+    #[test]\n+    fn test_cfg_expr_minimal_features_needed() {\n+        let (subtree, _) = get_token_tree_generated(r#\"#![cfg(feature = \"baz\")]\"#);\n+        let cfg_expr = parse_cfg(&subtree);\n+        let mut min_features = vec![];\n+        collect_minimal_features_needed(&cfg_expr, &mut min_features);\n+\n+        assert_eq!(min_features, vec![SmolStr::new(\"baz\")]);\n+\n+        let (subtree, _) =\n+            get_token_tree_generated(r#\"#![cfg(all(feature = \"baz\", feature = \"foo\"))]\"#);\n+        let cfg_expr = parse_cfg(&subtree);\n+\n+        let mut min_features = vec![];\n+        collect_minimal_features_needed(&cfg_expr, &mut min_features);\n+        assert_eq!(min_features, vec![SmolStr::new(\"baz\"), SmolStr::new(\"foo\")]);\n+\n+        let (subtree, _) =\n+            get_token_tree_generated(r#\"#![cfg(any(feature = \"baz\", feature = \"foo\", unix))]\"#);\n+        let cfg_expr = parse_cfg(&subtree);\n+\n+        let mut min_features = vec![];\n+        collect_minimal_features_needed(&cfg_expr, &mut min_features);\n+        assert_eq!(min_features, vec![SmolStr::new(\"baz\")]);\n+\n+        let (subtree, _) = get_token_tree_generated(r#\"#![cfg(foo)]\"#);\n+        let cfg_expr = parse_cfg(&subtree);\n+\n+        let mut min_features = vec![];\n+        collect_minimal_features_needed(&cfg_expr, &mut min_features);\n+        assert!(min_features.is_empty());\n+    }\n+}"}]}