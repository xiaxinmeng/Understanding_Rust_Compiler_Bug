{"sha": "67528c4b3943a2027839a25770d079132a9ea130", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3NTI4YzRiMzk0M2EyMDI3ODM5YTI1NzcwZDA3OTEzMmE5ZWExMzA=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-24T14:39:38Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-24T14:39:38Z"}, "message": "Merge #891\n\n891: Field completion r=matklad a=matklad\n\nbors r+\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "571b1729dd66b3597736069834529ba88460f2fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/571b1729dd66b3597736069834529ba88460f2fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67528c4b3943a2027839a25770d079132a9ea130", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67528c4b3943a2027839a25770d079132a9ea130", "html_url": "https://github.com/rust-lang/rust/commit/67528c4b3943a2027839a25770d079132a9ea130", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67528c4b3943a2027839a25770d079132a9ea130/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "c52c8c2c5bd8b054eee5946ce5e5bd7ecfe9998a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c52c8c2c5bd8b054eee5946ce5e5bd7ecfe9998a", "html_url": "https://github.com/rust-lang/rust/commit/c52c8c2c5bd8b054eee5946ce5e5bd7ecfe9998a"}, {"sha": "6285fcc39b70bc92de5188a5eb64ee8d73fa8970", "url": "https://api.github.com/repos/rust-lang/rust/commits/6285fcc39b70bc92de5188a5eb64ee8d73fa8970", "html_url": "https://github.com/rust-lang/rust/commit/6285fcc39b70bc92de5188a5eb64ee8d73fa8970"}], "stats": {"total": 494, "additions": 494, "deletions": 0}, "files": [{"sha": "d92e01bfb2d78c044586ee5ae988085385bc4571", "filename": "crates/ra_ide_api/src/completion.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67528c4b3943a2027839a25770d079132a9ea130/crates%2Fra_ide_api%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67528c4b3943a2027839a25770d079132a9ea130/crates%2Fra_ide_api%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion.rs?ref=67528c4b3943a2027839a25770d079132a9ea130", "patch": "@@ -2,6 +2,7 @@ mod completion_item;\n mod completion_context;\n \n mod complete_dot;\n+mod complete_struct_literal;\n mod complete_fn_param;\n mod complete_keyword;\n mod complete_snippet;\n@@ -59,6 +60,7 @@ pub(crate) fn completions(db: &db::RootDatabase, position: FilePosition) -> Opti\n     complete_path::complete_path(&mut acc, &ctx);\n     complete_scope::complete_scope(&mut acc, &ctx);\n     complete_dot::complete_dot(&mut acc, &ctx);\n+    complete_struct_literal::complete_struct_literal(&mut acc, &ctx);\n     complete_postfix::complete_postfix(&mut acc, &ctx);\n     Some(acc)\n }"}, {"sha": "f8dd2baadf1fa0146cfb60e4516c9c702fab9591", "filename": "crates/ra_ide_api/src/completion/complete_struct_literal.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/67528c4b3943a2027839a25770d079132a9ea130/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_struct_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67528c4b3943a2027839a25770d079132a9ea130/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_struct_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_struct_literal.rs?ref=67528c4b3943a2027839a25770d079132a9ea130", "patch": "@@ -0,0 +1,73 @@\n+use hir::{Ty, AdtDef, Docs};\n+\n+use crate::completion::{CompletionContext, Completions, CompletionItem, CompletionItemKind};\n+use crate::completion::completion_item::CompletionKind;\n+\n+/// Complete fields in fields literals.\n+pub(super) fn complete_struct_literal(acc: &mut Completions, ctx: &CompletionContext) {\n+    let (function, struct_lit) = match (&ctx.function, ctx.struct_lit_syntax) {\n+        (Some(function), Some(struct_lit)) => (function, struct_lit),\n+        _ => return,\n+    };\n+    let infer_result = function.infer(ctx.db);\n+    let syntax_mapping = function.body_syntax_mapping(ctx.db);\n+    let expr = match syntax_mapping.node_expr(struct_lit.into()) {\n+        Some(expr) => expr,\n+        None => return,\n+    };\n+    let ty = infer_result[expr].clone();\n+    let (adt, substs) = match ty {\n+        Ty::Adt { def_id, ref substs, .. } => (def_id, substs),\n+        _ => return,\n+    };\n+    match adt {\n+        AdtDef::Struct(s) => {\n+            for field in s.fields(ctx.db) {\n+                CompletionItem::new(\n+                    CompletionKind::Reference,\n+                    ctx.source_range(),\n+                    field.name(ctx.db).to_string(),\n+                )\n+                .kind(CompletionItemKind::Field)\n+                .detail(field.ty(ctx.db).subst(substs).to_string())\n+                .set_documentation(field.docs(ctx.db))\n+                .add_to(acc);\n+            }\n+        }\n+\n+        // TODO unions\n+        AdtDef::Enum(_) => (),\n+    };\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use insta::assert_debug_snapshot_matches;\n+    use crate::completion::{CompletionItem, CompletionKind};\n+\n+    fn complete(code: &str) -> Vec<CompletionItem> {\n+        crate::completion::completion_item::do_completion(code, CompletionKind::Reference)\n+    }\n+\n+    #[test]\n+    fn test_struct_literal_field() {\n+        let completions = complete(\n+            r\"\n+            struct A { the_field: u32 }\n+            fn foo() {\n+               A { the<|> }\n+            }\n+            \",\n+        );\n+        assert_debug_snapshot_matches!(completions, @r###\"[\n+    CompletionItem {\n+        label: \"the_field\",\n+        source_range: [83; 86),\n+        delete: [83; 86),\n+        insert: \"the_field\",\n+        kind: Field,\n+        detail: \"u32\"\n+    }\n+]\"###);\n+    }\n+}"}, {"sha": "d351be054b4abce02fc984fc3f339a05e99d844d", "filename": "crates/ra_ide_api/src/completion/completion_context.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67528c4b3943a2027839a25770d079132a9ea130/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67528c4b3943a2027839a25770d079132a9ea130/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=67528c4b3943a2027839a25770d079132a9ea130", "patch": "@@ -21,6 +21,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) function: Option<hir::Function>,\n     pub(super) function_syntax: Option<&'a ast::FnDef>,\n     pub(super) use_item_syntax: Option<&'a ast::UseItem>,\n+    pub(super) struct_lit_syntax: Option<&'a ast::StructLit>,\n     pub(super) is_param: bool,\n     /// A single-indent path, like `foo`. `::foo` should not be considered a trivial path.\n     pub(super) is_trivial_path: bool,\n@@ -55,6 +56,7 @@ impl<'a> CompletionContext<'a> {\n             function: None,\n             function_syntax: None,\n             use_item_syntax: None,\n+            struct_lit_syntax: None,\n             is_param: false,\n             is_trivial_path: false,\n             path_prefix: None,\n@@ -108,6 +110,10 @@ impl<'a> CompletionContext<'a> {\n     }\n     fn classify_name_ref(&mut self, original_file: &'a SourceFile, name_ref: &ast::NameRef) {\n         let name_range = name_ref.syntax().range();\n+        if name_ref.syntax().parent().and_then(ast::NamedField::cast).is_some() {\n+            self.struct_lit_syntax = find_node_at_offset(original_file.syntax(), self.offset);\n+        }\n+\n         let top_node =\n             name_ref.syntax().ancestors().take_while(|it| it.range() == name_range).last().unwrap();\n "}, {"sha": "56fb7c20cfafea2e5c3839945294fa366eef521f", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67528c4b3943a2027839a25770d079132a9ea130/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67528c4b3943a2027839a25770d079132a9ea130/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=67528c4b3943a2027839a25770d079132a9ea130", "patch": "@@ -724,6 +724,12 @@ impl LiteralExpr {\n     }\n }\n \n+impl NamedField {\n+    pub fn parent_struct_lit(&self) -> &StructLit {\n+        self.syntax().ancestors().find_map(StructLit::cast).unwrap()\n+    }\n+}\n+\n impl BindPat {\n     pub fn is_mutable(&self) -> bool {\n         self.syntax().children().any(|n| n.kind() == MUT_KW)"}, {"sha": "aa88b1e283ec05722aa483ab001988b0d892ae1d", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 398, "deletions": 0, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/67528c4b3943a2027839a25770d079132a9ea130/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67528c4b3943a2027839a25770d079132a9ea130/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=67528c4b3943a2027839a25770d079132a9ea130", "patch": "@@ -834,6 +834,142 @@ pub enum ExprKind<'a> {\n     BinExpr(&'a BinExpr),\n     Literal(&'a Literal),\n }\n+impl<'a> From<&'a TupleExpr> for &'a Expr {\n+    fn from(n: &'a TupleExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ArrayExpr> for &'a Expr {\n+    fn from(n: &'a ArrayExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ParenExpr> for &'a Expr {\n+    fn from(n: &'a ParenExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a PathExpr> for &'a Expr {\n+    fn from(n: &'a PathExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a LambdaExpr> for &'a Expr {\n+    fn from(n: &'a LambdaExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a IfExpr> for &'a Expr {\n+    fn from(n: &'a IfExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a LoopExpr> for &'a Expr {\n+    fn from(n: &'a LoopExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ForExpr> for &'a Expr {\n+    fn from(n: &'a ForExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a WhileExpr> for &'a Expr {\n+    fn from(n: &'a WhileExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ContinueExpr> for &'a Expr {\n+    fn from(n: &'a ContinueExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a BreakExpr> for &'a Expr {\n+    fn from(n: &'a BreakExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a Label> for &'a Expr {\n+    fn from(n: &'a Label) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a BlockExpr> for &'a Expr {\n+    fn from(n: &'a BlockExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ReturnExpr> for &'a Expr {\n+    fn from(n: &'a ReturnExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a MatchExpr> for &'a Expr {\n+    fn from(n: &'a MatchExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a StructLit> for &'a Expr {\n+    fn from(n: &'a StructLit) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a CallExpr> for &'a Expr {\n+    fn from(n: &'a CallExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a IndexExpr> for &'a Expr {\n+    fn from(n: &'a IndexExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a MethodCallExpr> for &'a Expr {\n+    fn from(n: &'a MethodCallExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a FieldExpr> for &'a Expr {\n+    fn from(n: &'a FieldExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a TryExpr> for &'a Expr {\n+    fn from(n: &'a TryExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a CastExpr> for &'a Expr {\n+    fn from(n: &'a CastExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a RefExpr> for &'a Expr {\n+    fn from(n: &'a RefExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a PrefixExpr> for &'a Expr {\n+    fn from(n: &'a PrefixExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a RangeExpr> for &'a Expr {\n+    fn from(n: &'a RangeExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a BinExpr> for &'a Expr {\n+    fn from(n: &'a BinExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a Literal> for &'a Expr {\n+    fn from(n: &'a Literal) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+\n \n impl AstNode for Expr {\n     fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n@@ -1375,6 +1511,22 @@ pub enum ImplItemKind<'a> {\n     TypeDef(&'a TypeDef),\n     ConstDef(&'a ConstDef),\n }\n+impl<'a> From<&'a FnDef> for &'a ImplItem {\n+    fn from(n: &'a FnDef) -> &'a ImplItem {\n+        ImplItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a TypeDef> for &'a ImplItem {\n+    fn from(n: &'a TypeDef) -> &'a ImplItem {\n+        ImplItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ConstDef> for &'a ImplItem {\n+    fn from(n: &'a ConstDef) -> &'a ImplItem {\n+        ImplItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+\n \n impl AstNode for ImplItem {\n     fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n@@ -1778,6 +1930,57 @@ pub enum LiteralExprKind<'a> {\n     TrueKw(&'a TrueKw),\n     FalseKw(&'a FalseKw),\n }\n+impl<'a> From<&'a String> for &'a LiteralExpr {\n+    fn from(n: &'a String) -> &'a LiteralExpr {\n+        LiteralExpr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ByteString> for &'a LiteralExpr {\n+    fn from(n: &'a ByteString) -> &'a LiteralExpr {\n+        LiteralExpr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a RawString> for &'a LiteralExpr {\n+    fn from(n: &'a RawString) -> &'a LiteralExpr {\n+        LiteralExpr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a RawByteString> for &'a LiteralExpr {\n+    fn from(n: &'a RawByteString) -> &'a LiteralExpr {\n+        LiteralExpr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a Char> for &'a LiteralExpr {\n+    fn from(n: &'a Char) -> &'a LiteralExpr {\n+        LiteralExpr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a Byte> for &'a LiteralExpr {\n+    fn from(n: &'a Byte) -> &'a LiteralExpr {\n+        LiteralExpr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a IntNumber> for &'a LiteralExpr {\n+    fn from(n: &'a IntNumber) -> &'a LiteralExpr {\n+        LiteralExpr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a FloatNumber> for &'a LiteralExpr {\n+    fn from(n: &'a FloatNumber) -> &'a LiteralExpr {\n+        LiteralExpr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a TrueKw> for &'a LiteralExpr {\n+    fn from(n: &'a TrueKw) -> &'a LiteralExpr {\n+        LiteralExpr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a FalseKw> for &'a LiteralExpr {\n+    fn from(n: &'a FalseKw) -> &'a LiteralExpr {\n+        LiteralExpr::cast(&n.syntax).unwrap()\n+    }\n+}\n+\n \n impl AstNode for LiteralExpr {\n     fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n@@ -2164,6 +2367,62 @@ pub enum ModuleItemKind<'a> {\n     StaticDef(&'a StaticDef),\n     Module(&'a Module),\n }\n+impl<'a> From<&'a StructDef> for &'a ModuleItem {\n+    fn from(n: &'a StructDef) -> &'a ModuleItem {\n+        ModuleItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a EnumDef> for &'a ModuleItem {\n+    fn from(n: &'a EnumDef) -> &'a ModuleItem {\n+        ModuleItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a FnDef> for &'a ModuleItem {\n+    fn from(n: &'a FnDef) -> &'a ModuleItem {\n+        ModuleItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a TraitDef> for &'a ModuleItem {\n+    fn from(n: &'a TraitDef) -> &'a ModuleItem {\n+        ModuleItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a TypeDef> for &'a ModuleItem {\n+    fn from(n: &'a TypeDef) -> &'a ModuleItem {\n+        ModuleItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ImplBlock> for &'a ModuleItem {\n+    fn from(n: &'a ImplBlock) -> &'a ModuleItem {\n+        ModuleItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a UseItem> for &'a ModuleItem {\n+    fn from(n: &'a UseItem) -> &'a ModuleItem {\n+        ModuleItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ExternCrateItem> for &'a ModuleItem {\n+    fn from(n: &'a ExternCrateItem) -> &'a ModuleItem {\n+        ModuleItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ConstDef> for &'a ModuleItem {\n+    fn from(n: &'a ConstDef) -> &'a ModuleItem {\n+        ModuleItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a StaticDef> for &'a ModuleItem {\n+    fn from(n: &'a StaticDef) -> &'a ModuleItem {\n+        ModuleItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a Module> for &'a ModuleItem {\n+    fn from(n: &'a Module) -> &'a ModuleItem {\n+        ModuleItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+\n \n impl AstNode for ModuleItem {\n     fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n@@ -2446,6 +2705,17 @@ pub enum NominalDefKind<'a> {\n     StructDef(&'a StructDef),\n     EnumDef(&'a EnumDef),\n }\n+impl<'a> From<&'a StructDef> for &'a NominalDef {\n+    fn from(n: &'a StructDef) -> &'a NominalDef {\n+        NominalDef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a EnumDef> for &'a NominalDef {\n+    fn from(n: &'a EnumDef) -> &'a NominalDef {\n+        NominalDef::cast(&n.syntax).unwrap()\n+    }\n+}\n+\n \n impl AstNode for NominalDef {\n     fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n@@ -2637,6 +2907,57 @@ pub enum PatKind<'a> {\n     RangePat(&'a RangePat),\n     LiteralPat(&'a LiteralPat),\n }\n+impl<'a> From<&'a RefPat> for &'a Pat {\n+    fn from(n: &'a RefPat) -> &'a Pat {\n+        Pat::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a BindPat> for &'a Pat {\n+    fn from(n: &'a BindPat) -> &'a Pat {\n+        Pat::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a PlaceholderPat> for &'a Pat {\n+    fn from(n: &'a PlaceholderPat) -> &'a Pat {\n+        Pat::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a PathPat> for &'a Pat {\n+    fn from(n: &'a PathPat) -> &'a Pat {\n+        Pat::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a StructPat> for &'a Pat {\n+    fn from(n: &'a StructPat) -> &'a Pat {\n+        Pat::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a TupleStructPat> for &'a Pat {\n+    fn from(n: &'a TupleStructPat) -> &'a Pat {\n+        Pat::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a TuplePat> for &'a Pat {\n+    fn from(n: &'a TuplePat) -> &'a Pat {\n+        Pat::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a SlicePat> for &'a Pat {\n+    fn from(n: &'a SlicePat) -> &'a Pat {\n+        Pat::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a RangePat> for &'a Pat {\n+    fn from(n: &'a RangePat) -> &'a Pat {\n+        Pat::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a LiteralPat> for &'a Pat {\n+    fn from(n: &'a LiteralPat) -> &'a Pat {\n+        Pat::cast(&n.syntax).unwrap()\n+    }\n+}\n+\n \n impl AstNode for Pat {\n     fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n@@ -3520,6 +3841,17 @@ pub enum StmtKind<'a> {\n     ExprStmt(&'a ExprStmt),\n     LetStmt(&'a LetStmt),\n }\n+impl<'a> From<&'a ExprStmt> for &'a Stmt {\n+    fn from(n: &'a ExprStmt) -> &'a Stmt {\n+        Stmt::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a LetStmt> for &'a Stmt {\n+    fn from(n: &'a LetStmt) -> &'a Stmt {\n+        Stmt::cast(&n.syntax).unwrap()\n+    }\n+}\n+\n \n impl AstNode for Stmt {\n     fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n@@ -4142,6 +4474,72 @@ pub enum TypeRefKind<'a> {\n     ImplTraitType(&'a ImplTraitType),\n     DynTraitType(&'a DynTraitType),\n }\n+impl<'a> From<&'a ParenType> for &'a TypeRef {\n+    fn from(n: &'a ParenType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a TupleType> for &'a TypeRef {\n+    fn from(n: &'a TupleType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a NeverType> for &'a TypeRef {\n+    fn from(n: &'a NeverType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a PathType> for &'a TypeRef {\n+    fn from(n: &'a PathType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a PointerType> for &'a TypeRef {\n+    fn from(n: &'a PointerType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ArrayType> for &'a TypeRef {\n+    fn from(n: &'a ArrayType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a SliceType> for &'a TypeRef {\n+    fn from(n: &'a SliceType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ReferenceType> for &'a TypeRef {\n+    fn from(n: &'a ReferenceType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a PlaceholderType> for &'a TypeRef {\n+    fn from(n: &'a PlaceholderType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a FnPointerType> for &'a TypeRef {\n+    fn from(n: &'a FnPointerType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ForType> for &'a TypeRef {\n+    fn from(n: &'a ForType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ImplTraitType> for &'a TypeRef {\n+    fn from(n: &'a ImplTraitType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a DynTraitType> for &'a TypeRef {\n+    fn from(n: &'a DynTraitType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+\n \n impl AstNode for TypeRef {\n     fn cast(syntax: &SyntaxNode) -> Option<&Self> {"}, {"sha": "e2d4856cfee84c0d46a2a6119cb30ae3be59e431", "filename": "crates/ra_syntax/src/ast/generated.rs.tera", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/67528c4b3943a2027839a25770d079132a9ea130/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera", "raw_url": "https://github.com/rust-lang/rust/raw/67528c4b3943a2027839a25770d079132a9ea130/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera?ref=67528c4b3943a2027839a25770d079132a9ea130", "patch": "@@ -38,6 +38,15 @@ pub enum {{ node }}Kind<'a> {\n {%- endfor %}\n }\n \n+{%- for kind in methods.enum %}\n+impl<'a> From<&'a {{ kind }}> for &'a {{ node }} {\n+    fn from(n: &'a {{ kind }}) -> &'a {{ node }} {\n+        {{ node }}::cast(&n.syntax).unwrap()\n+    }\n+}\n+{%- endfor %}\n+\n+\n impl AstNode for {{ node }} {\n     fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n         match syntax.kind() {"}]}