{"sha": "4760b8fb886a3702ae11bfa7868d495b2675b5ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3NjBiOGZiODg2YTM3MDJhZTExYmZhNzg2OGQ0OTViMjY3NWI1ZWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-25T20:15:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-25T20:15:44Z"}, "message": "Auto merge of #78179 - RalfJung:miri-comments, r=oli-obk\n\nMiri engine: entirely skip interning of ZST, and improve some comments\n\nr? `@oli-obk`", "tree": {"sha": "74c0093e5bcc138a5d6a4ae15debe3732ba92b6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74c0093e5bcc138a5d6a4ae15debe3732ba92b6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4760b8fb886a3702ae11bfa7868d495b2675b5ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4760b8fb886a3702ae11bfa7868d495b2675b5ed", "html_url": "https://github.com/rust-lang/rust/commit/4760b8fb886a3702ae11bfa7868d495b2675b5ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4760b8fb886a3702ae11bfa7868d495b2675b5ed/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0dce3f606e05cffab7361c132a399d3550ab0df8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dce3f606e05cffab7361c132a399d3550ab0df8", "html_url": "https://github.com/rust-lang/rust/commit/0dce3f606e05cffab7361c132a399d3550ab0df8"}, {"sha": "fcaf2338da4456f2b3d1ccf3e127f9028c80a2cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcaf2338da4456f2b3d1ccf3e127f9028c80a2cc", "html_url": "https://github.com/rust-lang/rust/commit/fcaf2338da4456f2b3d1ccf3e127f9028c80a2cc"}], "stats": {"total": 48, "additions": 25, "deletions": 23}, "files": [{"sha": "846ca18990022470b82616b13a1241ebeac3f8ba", "filename": "compiler/rustc_mir/src/interpret/intern.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4760b8fb886a3702ae11bfa7868d495b2675b5ed/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4760b8fb886a3702ae11bfa7868d495b2675b5ed/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs?ref=4760b8fb886a3702ae11bfa7868d495b2675b5ed", "patch": "@@ -33,8 +33,9 @@ struct InternVisitor<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> {\n     /// A list of all encountered allocations. After type-based interning, we traverse this list to\n     /// also intern allocations that are only referenced by a raw pointer or inside a union.\n     leftover_allocations: &'rt mut FxHashSet<AllocId>,\n-    /// The root kind of the value that we're looking at. This field is never mutated and only used\n-    /// for sanity assertions that will ICE when `const_qualif` screws up.\n+    /// The root kind of the value that we're looking at. This field is never mutated for a\n+    /// particular allocation. It is primarily used to make as many allocations as possible\n+    /// read-only so LLVM can place them in const memory.\n     mode: InternMode,\n     /// This field stores whether we are *currently* inside an `UnsafeCell`. This can affect\n     /// the intern mode of references we encounter.\n@@ -113,8 +114,8 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n         // For this, we need to take into account `UnsafeCell`. When `ty` is `None`, we assume\n         // no interior mutability.\n         let frozen = ty.map_or(true, |ty| ty.is_freeze(ecx.tcx, ecx.param_env));\n-        // For statics, allocation mutability is the combination of the place mutability and\n-        // the type mutability.\n+        // For statics, allocation mutability is the combination of place mutability and\n+        // type mutability.\n         // The entire allocation needs to be mutable if it contains an `UnsafeCell` anywhere.\n         let immutable = mutability == Mutability::Not && frozen;\n         if immutable {\n@@ -188,8 +189,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n             }\n         }\n \n-        // ZSTs do not need validation unless they're uninhabited\n-        if mplace.layout.is_zst() && !mplace.layout.abi.is_uninhabited() {\n+        // ZSTs cannot contain pointers, so we can skip them.\n+        if mplace.layout.is_zst() {\n             return Ok(());\n         }\n \n@@ -209,13 +210,12 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n             if let ty::Dynamic(..) =\n                 tcx.struct_tail_erasing_lifetimes(referenced_ty, self.ecx.param_env).kind()\n             {\n-                // Validation will error (with a better message) on an invalid vtable pointer\n-                // so we can safely not do anything if this is not a real pointer.\n                 if let Scalar::Ptr(vtable) = mplace.meta.unwrap_meta() {\n                     // Explicitly choose const mode here, since vtables are immutable, even\n                     // if the reference of the fat pointer is mutable.\n                     self.intern_shallow(vtable.alloc_id, InternMode::ConstInner, None);\n                 } else {\n+                    // Validation will error (with a better message) on an invalid vtable pointer.\n                     // Let validation show the error message, but make sure it *does* error.\n                     tcx.sess\n                         .delay_span_bug(tcx.span, \"vtables pointers cannot be integer pointers\");\n@@ -224,7 +224,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n             // Check if we have encountered this pointer+layout combination before.\n             // Only recurse for allocation-backed pointers.\n             if let Scalar::Ptr(ptr) = mplace.ptr {\n-                // Compute the mode with which we intern this.\n+                // Compute the mode with which we intern this. Our goal here is to make as many\n+                // statics as we can immutable so they can be placed in const memory by LLVM.\n                 let ref_mode = match self.mode {\n                     InternMode::Static(mutbl) => {\n                         // In statics, merge outer mutability with reference mutability and\n@@ -243,8 +244,13 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n                             }\n                             Mutability::Not => {\n                                 // A shared reference, things become immutable.\n-                                // We do *not* consier `freeze` here -- that is done more precisely\n-                                // when traversing the referenced data (by tracking `UnsafeCell`).\n+                                // We do *not* consider `freeze` here: `intern_shallow` considers\n+                                // `freeze` for the actual mutability of this allocation; the intern\n+                                // mode for references contained in this allocation is tracked more\n+                                // precisely when traversing the referenced data (by tracking\n+                                // `UnsafeCell`). This makes sure that `&(&i32, &Cell<i32>)` still\n+                                // has the left inner reference interned into a read-only\n+                                // allocation.\n                                 InternMode::Static(Mutability::Not)\n                             }\n                             Mutability::Mut => {"}, {"sha": "c38f25564e8dd3707f3c043fe0388fde4432fc87", "filename": "compiler/rustc_mir/src/interpret/validity.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4760b8fb886a3702ae11bfa7868d495b2675b5ed/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4760b8fb886a3702ae11bfa7868d495b2675b5ed/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs?ref=4760b8fb886a3702ae11bfa7868d495b2675b5ed", "patch": "@@ -775,17 +775,13 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 );\n             }\n             ty::Array(tys, ..) | ty::Slice(tys)\n-                if {\n-                    // This optimization applies for types that can hold arbitrary bytes (such as\n-                    // integer and floating point types) or for structs or tuples with no fields.\n-                    // FIXME(wesleywiser) This logic could be extended further to arbitrary structs\n-                    // or tuples made up of integer/floating point types or inhabited ZSTs with no\n-                    // padding.\n-                    match tys.kind() {\n-                        ty::Int(..) | ty::Uint(..) | ty::Float(..) => true,\n-                        _ => false,\n-                    }\n-                } =>\n+                // This optimization applies for types that can hold arbitrary bytes (such as\n+                // integer and floating point types) or for structs or tuples with no fields.\n+                // FIXME(wesleywiser) This logic could be extended further to arbitrary structs\n+                // or tuples made up of integer/floating point types or inhabited ZSTs with no\n+                // padding.\n+                if matches!(tys.kind(), ty::Int(..) | ty::Uint(..) | ty::Float(..))\n+                =>\n             {\n                 // Optimized handling for arrays of integer/float type.\n \n@@ -853,7 +849,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n             // of an array and not all of them, because there's only a single value of a specific\n             // ZST type, so either validation fails for all elements or none.\n             ty::Array(tys, ..) | ty::Slice(tys) if self.ecx.layout_of(tys)?.is_zst() => {\n-                // Validate just the first element\n+                // Validate just the first element (if any).\n                 self.walk_aggregate(op, fields.take(1))?\n             }\n             _ => {"}]}