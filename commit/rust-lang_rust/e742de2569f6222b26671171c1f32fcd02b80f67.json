{"sha": "e742de2569f6222b26671171c1f32fcd02b80f67", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3NDJkZTI1NjlmNjIyMmIyNjY3MTE3MWMxZjMyZmNkMDJiODBmNjc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-11T13:24:37Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-11T13:24:37Z"}, "message": "parser: split into pat.rs", "tree": {"sha": "c5676b522e513d098c6c69d17c4cd9750fd36c43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5676b522e513d098c6c69d17c4cd9750fd36c43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e742de2569f6222b26671171c1f32fcd02b80f67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e742de2569f6222b26671171c1f32fcd02b80f67", "html_url": "https://github.com/rust-lang/rust/commit/e742de2569f6222b26671171c1f32fcd02b80f67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e742de2569f6222b26671171c1f32fcd02b80f67/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81e6b5094eb1c2fbf5184b6952a1a3ddf647bf7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/81e6b5094eb1c2fbf5184b6952a1a3ddf647bf7a", "html_url": "https://github.com/rust-lang/rust/commit/81e6b5094eb1c2fbf5184b6952a1a3ddf647bf7a"}], "stats": {"total": 1275, "additions": 642, "deletions": 633}, "files": [{"sha": "f7dced76b64da5ef89c3f464134bb44ae165e8bc", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 633, "changes": 641, "blob_url": "https://github.com/rust-lang/rust/blob/e742de2569f6222b26671171c1f32fcd02b80f67/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e742de2569f6222b26671171c1f32fcd02b80f67/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e742de2569f6222b26671171c1f32fcd02b80f67", "patch": "@@ -3,6 +3,8 @@\n mod expr;\n use expr::LhsExpr;\n \n+mod pat;\n+\n use crate::ast::{AngleBracketedArgs, ParenthesizedArgs, AttrStyle, BareFnTy};\n use crate::ast::{GenericBound, TraitBoundModifier};\n use crate::ast::Unsafety;\n@@ -16,13 +18,10 @@ use crate::ast::{FnDecl, FnHeader};\n use crate::ast::{ForeignItem, ForeignItemKind, FunctionRetTy};\n use crate::ast::{GenericParam, GenericParamKind};\n use crate::ast::GenericArg;\n-use crate::ast::{Ident, ImplItem, IsAsync, IsAuto, Item, ItemKind};\n-use crate::ast::{Lifetime};\n-use crate::ast::Local;\n-use crate::ast::MacStmtStyle;\n-use crate::ast::{Mac, Mac_, MacDelimiter};\n+use crate::ast::{Ident, ImplItem, IsAsync, IsAuto, Item, ItemKind, Local, Lifetime};\n+use crate::ast::{MacStmtStyle, Mac, Mac_, MacDelimiter};\n use crate::ast::{MutTy, Mutability};\n-use crate::ast::{Pat, PatKind, PathSegment};\n+use crate::ast::{PathSegment};\n use crate::ast::{PolyTraitRef, QSelf};\n use crate::ast::{Stmt, StmtKind};\n use crate::ast::{VariantData, StructField};\n@@ -32,7 +31,6 @@ use crate::ast::{TraitItem, TraitRef, TraitObjectSyntax};\n use crate::ast::{Ty, TyKind, AssocTyConstraint, AssocTyConstraintKind, GenericBounds};\n use crate::ast::{Visibility, VisibilityKind, WhereClause, CrateSugar};\n use crate::ast::{UseTree, UseTreeKind};\n-use crate::ast::{RangeEnd, RangeSyntax};\n use crate::{ast, attr};\n use crate::ext::base::DummyResult;\n use crate::ext::hygiene::SyntaxContext;\n@@ -116,6 +114,7 @@ crate enum BlockMode {\n }\n \n /// As maybe_whole_expr, but for things other than expressions\n+#[macro_export]\n macro_rules! maybe_whole {\n     ($p:expr, $constructor:ident, |$x:ident| $e:expr) => {\n         if let token::Interpolated(nt) = &$p.token.kind {\n@@ -1491,12 +1490,8 @@ impl<'a> Parser<'a> {\n             match ty {\n                 Ok(ty) => {\n                     let ident = Ident::new(kw::Invalid, self.prev_span);\n-                    let pat = P(Pat {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: PatKind::Ident(\n-                            BindingMode::ByValue(Mutability::Immutable), ident, None),\n-                        span: ty.span,\n-                    });\n+                    let bm = BindingMode::ByValue(Mutability::Immutable);\n+                    let pat = self.mk_pat_ident(ty.span, bm, ident);\n                     (pat, ty)\n                 }\n                 Err(mut err) => {\n@@ -1924,626 +1919,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parses patterns, separated by '|' s.\n-    fn parse_pats(&mut self) -> PResult<'a, Vec<P<Pat>>> {\n-        // Allow a '|' before the pats (RFC 1925 + RFC 2530)\n-        self.eat(&token::BinOp(token::Or));\n-\n-        let mut pats = Vec::new();\n-        loop {\n-            pats.push(self.parse_top_level_pat()?);\n-\n-            if self.token == token::OrOr {\n-                self.struct_span_err(self.token.span, \"unexpected token `||` after pattern\")\n-                    .span_suggestion(\n-                        self.token.span,\n-                        \"use a single `|` to specify multiple patterns\",\n-                        \"|\".to_owned(),\n-                        Applicability::MachineApplicable\n-                    )\n-                    .emit();\n-                self.bump();\n-            } else if self.eat(&token::BinOp(token::Or)) {\n-                // This is a No-op. Continue the loop to parse the next\n-                // pattern.\n-            } else {\n-                return Ok(pats);\n-            }\n-        };\n-    }\n-\n-    fn parse_pat_field(\n-        &mut self,\n-        lo: Span,\n-        attrs: Vec<Attribute>\n-    ) -> PResult<'a, source_map::Spanned<ast::FieldPat>> {\n-        // Check if a colon exists one ahead. This means we're parsing a fieldname.\n-        let hi;\n-        let (subpat, fieldname, is_shorthand) = if self.look_ahead(1, |t| t == &token::Colon) {\n-            // Parsing a pattern of the form \"fieldname: pat\"\n-            let fieldname = self.parse_field_name()?;\n-            self.bump();\n-            let pat = self.parse_pat(None)?;\n-            hi = pat.span;\n-            (pat, fieldname, false)\n-        } else {\n-            // Parsing a pattern of the form \"(box) (ref) (mut) fieldname\"\n-            let is_box = self.eat_keyword(kw::Box);\n-            let boxed_span = self.token.span;\n-            let is_ref = self.eat_keyword(kw::Ref);\n-            let is_mut = self.eat_keyword(kw::Mut);\n-            let fieldname = self.parse_ident()?;\n-            hi = self.prev_span;\n-\n-            let bind_type = match (is_ref, is_mut) {\n-                (true, true) => BindingMode::ByRef(Mutability::Mutable),\n-                (true, false) => BindingMode::ByRef(Mutability::Immutable),\n-                (false, true) => BindingMode::ByValue(Mutability::Mutable),\n-                (false, false) => BindingMode::ByValue(Mutability::Immutable),\n-            };\n-            let fieldpat = P(Pat {\n-                id: ast::DUMMY_NODE_ID,\n-                node: PatKind::Ident(bind_type, fieldname, None),\n-                span: boxed_span.to(hi),\n-            });\n-\n-            let subpat = if is_box {\n-                P(Pat {\n-                    id: ast::DUMMY_NODE_ID,\n-                    node: PatKind::Box(fieldpat),\n-                    span: lo.to(hi),\n-                })\n-            } else {\n-                fieldpat\n-            };\n-            (subpat, fieldname, true)\n-        };\n-\n-        Ok(source_map::Spanned {\n-            span: lo.to(hi),\n-            node: ast::FieldPat {\n-                ident: fieldname,\n-                pat: subpat,\n-                is_shorthand,\n-                attrs: attrs.into(),\n-           }\n-        })\n-    }\n-\n-    /// Parses the fields of a struct-like pattern.\n-    fn parse_pat_fields(&mut self) -> PResult<'a, (Vec<source_map::Spanned<ast::FieldPat>>, bool)> {\n-        let mut fields = Vec::new();\n-        let mut etc = false;\n-        let mut ate_comma = true;\n-        let mut delayed_err: Option<DiagnosticBuilder<'a>> = None;\n-        let mut etc_span = None;\n-\n-        while self.token != token::CloseDelim(token::Brace) {\n-            let attrs = match self.parse_outer_attributes() {\n-                Ok(attrs) => attrs,\n-                Err(err) => {\n-                    if let Some(mut delayed) = delayed_err {\n-                        delayed.emit();\n-                    }\n-                    return Err(err);\n-                },\n-            };\n-            let lo = self.token.span;\n-\n-            // check that a comma comes after every field\n-            if !ate_comma {\n-                let err = self.struct_span_err(self.prev_span, \"expected `,`\");\n-                if let Some(mut delayed) = delayed_err {\n-                    delayed.emit();\n-                }\n-                return Err(err);\n-            }\n-            ate_comma = false;\n-\n-            if self.check(&token::DotDot) || self.token == token::DotDotDot {\n-                etc = true;\n-                let mut etc_sp = self.token.span;\n-\n-                if self.token == token::DotDotDot { // Issue #46718\n-                    // Accept `...` as if it were `..` to avoid further errors\n-                    self.struct_span_err(self.token.span, \"expected field pattern, found `...`\")\n-                        .span_suggestion(\n-                            self.token.span,\n-                            \"to omit remaining fields, use one fewer `.`\",\n-                            \"..\".to_owned(),\n-                            Applicability::MachineApplicable\n-                        )\n-                        .emit();\n-                }\n-                self.bump();  // `..` || `...`\n-\n-                if self.token == token::CloseDelim(token::Brace) {\n-                    etc_span = Some(etc_sp);\n-                    break;\n-                }\n-                let token_str = self.this_token_descr();\n-                let mut err = self.fatal(&format!(\"expected `}}`, found {}\", token_str));\n-\n-                err.span_label(self.token.span, \"expected `}`\");\n-                let mut comma_sp = None;\n-                if self.token == token::Comma { // Issue #49257\n-                    let nw_span = self.sess.source_map().span_until_non_whitespace(self.token.span);\n-                    etc_sp = etc_sp.to(nw_span);\n-                    err.span_label(etc_sp,\n-                                   \"`..` must be at the end and cannot have a trailing comma\");\n-                    comma_sp = Some(self.token.span);\n-                    self.bump();\n-                    ate_comma = true;\n-                }\n-\n-                etc_span = Some(etc_sp.until(self.token.span));\n-                if self.token == token::CloseDelim(token::Brace) {\n-                    // If the struct looks otherwise well formed, recover and continue.\n-                    if let Some(sp) = comma_sp {\n-                        err.span_suggestion_short(\n-                            sp,\n-                            \"remove this comma\",\n-                            String::new(),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-                    err.emit();\n-                    break;\n-                } else if self.token.is_ident() && ate_comma {\n-                    // Accept fields coming after `..,`.\n-                    // This way we avoid \"pattern missing fields\" errors afterwards.\n-                    // We delay this error until the end in order to have a span for a\n-                    // suggested fix.\n-                    if let Some(mut delayed_err) = delayed_err {\n-                        delayed_err.emit();\n-                        return Err(err);\n-                    } else {\n-                        delayed_err = Some(err);\n-                    }\n-                } else {\n-                    if let Some(mut err) = delayed_err {\n-                        err.emit();\n-                    }\n-                    return Err(err);\n-                }\n-            }\n-\n-            fields.push(match self.parse_pat_field(lo, attrs) {\n-                Ok(field) => field,\n-                Err(err) => {\n-                    if let Some(mut delayed_err) = delayed_err {\n-                        delayed_err.emit();\n-                    }\n-                    return Err(err);\n-                }\n-            });\n-            ate_comma = self.eat(&token::Comma);\n-        }\n-\n-        if let Some(mut err) = delayed_err {\n-            if let Some(etc_span) = etc_span {\n-                err.multipart_suggestion(\n-                    \"move the `..` to the end of the field list\",\n-                    vec![\n-                        (etc_span, String::new()),\n-                        (self.token.span, format!(\"{}.. }}\", if ate_comma { \"\" } else { \", \" })),\n-                    ],\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-            err.emit();\n-        }\n-        return Ok((fields, etc));\n-    }\n-\n-    fn parse_pat_range_end(&mut self) -> PResult<'a, P<Expr>> {\n-        if self.token.is_path_start() {\n-            let lo = self.token.span;\n-            let (qself, path) = if self.eat_lt() {\n-                // Parse a qualified path\n-                let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n-                (Some(qself), path)\n-            } else {\n-                // Parse an unqualified path\n-                (None, self.parse_path(PathStyle::Expr)?)\n-            };\n-            let hi = self.prev_span;\n-            Ok(self.mk_expr(lo.to(hi), ExprKind::Path(qself, path), ThinVec::new()))\n-        } else {\n-            self.parse_literal_maybe_minus()\n-        }\n-    }\n-\n-    /// Is the current token suitable as the start of a range patterns end?\n-    fn is_pat_range_end_start(&self) -> bool {\n-        self.token.is_path_start() // e.g. `MY_CONST`;\n-            || self.token == token::Dot // e.g. `.5` for recovery;\n-            || self.token.can_begin_literal_or_bool() // e.g. `42`.\n-            || self.token.is_whole_expr()\n-    }\n-\n-    // Helper function to decide whether to parse as ident binding\n-    // or to try to do something more complex like range patterns.\n-    fn parse_as_ident(&mut self) -> bool {\n-        self.look_ahead(1, |t| match t.kind {\n-            token::OpenDelim(token::Paren) | token::OpenDelim(token::Brace) |\n-            token::DotDotDot | token::DotDotEq | token::DotDot |\n-            token::ModSep | token::Not => false,\n-            _ => true,\n-        })\n-    }\n-\n-    /// Parse and throw away a parentesized comma separated\n-    /// sequence of patterns until `)` is reached.\n-    fn skip_pat_list(&mut self) -> PResult<'a, ()> {\n-        while !self.check(&token::CloseDelim(token::Paren)) {\n-            self.parse_pat(None)?;\n-            if !self.eat(&token::Comma) {\n-                return Ok(())\n-            }\n-        }\n-        Ok(())\n-    }\n-\n-    /// A wrapper around `parse_pat` with some special error handling for the\n-    /// \"top-level\" patterns in a match arm, `for` loop, `let`, &c. (in contrast\n-    /// to subpatterns within such).\n-    fn parse_top_level_pat(&mut self) -> PResult<'a, P<Pat>> {\n-        let pat = self.parse_pat(None)?;\n-        if self.token == token::Comma {\n-            // An unexpected comma after a top-level pattern is a clue that the\n-            // user (perhaps more accustomed to some other language) forgot the\n-            // parentheses in what should have been a tuple pattern; return a\n-            // suggestion-enhanced error here rather than choking on the comma\n-            // later.\n-            let comma_span = self.token.span;\n-            self.bump();\n-            if let Err(mut err) = self.skip_pat_list() {\n-                // We didn't expect this to work anyway; we just wanted\n-                // to advance to the end of the comma-sequence so we know\n-                // the span to suggest parenthesizing\n-                err.cancel();\n-            }\n-            let seq_span = pat.span.to(self.prev_span);\n-            let mut err = self.struct_span_err(comma_span,\n-                                               \"unexpected `,` in pattern\");\n-            if let Ok(seq_snippet) = self.span_to_snippet(seq_span) {\n-                err.span_suggestion(\n-                    seq_span,\n-                    \"try adding parentheses to match on a tuple..\",\n-                    format!(\"({})\", seq_snippet),\n-                    Applicability::MachineApplicable\n-                ).span_suggestion(\n-                    seq_span,\n-                    \"..or a vertical bar to match on multiple alternatives\",\n-                    format!(\"{}\", seq_snippet.replace(\",\", \" |\")),\n-                    Applicability::MachineApplicable\n-                );\n-            }\n-            return Err(err);\n-        }\n-        Ok(pat)\n-    }\n-\n-    /// Parses a pattern.\n-    pub fn parse_pat(&mut self, expected: Option<&'static str>) -> PResult<'a, P<Pat>> {\n-        self.parse_pat_with_range_pat(true, expected)\n-    }\n-\n-    /// Parse a range-to pattern, e.g. `..X` and `..=X` for recovery.\n-    fn parse_pat_range_to(&mut self, re: RangeEnd, form: &str) -> PResult<'a, PatKind> {\n-        let lo = self.prev_span;\n-        let end = self.parse_pat_range_end()?;\n-        let range_span = lo.to(end.span);\n-        let begin = self.mk_expr(range_span, ExprKind::Err, ThinVec::new());\n-\n-        self.diagnostic()\n-            .struct_span_err(range_span, &format!(\"`{}X` range patterns are not supported\", form))\n-            .span_suggestion(\n-                range_span,\n-                \"try using the minimum value for the type\",\n-                format!(\"MIN{}{}\", form, pprust::expr_to_string(&end)),\n-                Applicability::HasPlaceholders,\n-            )\n-            .emit();\n-\n-        Ok(PatKind::Range(begin, end, respan(lo, re)))\n-    }\n-\n-    /// Parse the end of a `X..Y`, `X..=Y`, or `X...Y` range pattern  or recover\n-    /// if that end is missing treating it as `X..`, `X..=`, or `X...` respectively.\n-    fn parse_pat_range_end_opt(&mut self, begin: &Expr, form: &str) -> PResult<'a, P<Expr>> {\n-        if self.is_pat_range_end_start() {\n-            // Parsing e.g. `X..=Y`.\n-            self.parse_pat_range_end()\n-        } else {\n-            // Parsing e.g. `X..`.\n-            let range_span = begin.span.to(self.prev_span);\n-\n-            self.diagnostic()\n-                .struct_span_err(\n-                    range_span,\n-                    &format!(\"`X{}` range patterns are not supported\", form),\n-                )\n-                .span_suggestion(\n-                    range_span,\n-                    \"try using the maximum value for the type\",\n-                    format!(\"{}{}MAX\", pprust::expr_to_string(&begin), form),\n-                    Applicability::HasPlaceholders,\n-                )\n-                .emit();\n-\n-            Ok(self.mk_expr(range_span, ExprKind::Err, ThinVec::new()))\n-        }\n-    }\n-\n-    /// Parses a pattern, with a setting whether modern range patterns (e.g., `a..=b`, `a..b` are\n-    /// allowed).\n-    fn parse_pat_with_range_pat(\n-        &mut self,\n-        allow_range_pat: bool,\n-        expected: Option<&'static str>,\n-    ) -> PResult<'a, P<Pat>> {\n-        maybe_recover_from_interpolated_ty_qpath!(self, true);\n-        maybe_whole!(self, NtPat, |x| x);\n-\n-        let lo = self.token.span;\n-        let pat;\n-        match self.token.kind {\n-            token::BinOp(token::And) | token::AndAnd => {\n-                // Parse &pat / &mut pat\n-                self.expect_and()?;\n-                let mutbl = self.parse_mutability();\n-                if let token::Lifetime(name) = self.token.kind {\n-                    let mut err = self.fatal(&format!(\"unexpected lifetime `{}` in pattern\", name));\n-                    err.span_label(self.token.span, \"unexpected lifetime\");\n-                    return Err(err);\n-                }\n-                let subpat = self.parse_pat_with_range_pat(false, expected)?;\n-                pat = PatKind::Ref(subpat, mutbl);\n-            }\n-            token::OpenDelim(token::Paren) => {\n-                // Parse a tuple or parenthesis pattern.\n-                let (fields, trailing_comma) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n-\n-                // Here, `(pat,)` is a tuple pattern.\n-                // For backward compatibility, `(..)` is a tuple pattern as well.\n-                pat = if fields.len() == 1 && !(trailing_comma || fields[0].is_rest()) {\n-                    PatKind::Paren(fields.into_iter().nth(0).unwrap())\n-                } else {\n-                    PatKind::Tuple(fields)\n-                };\n-            }\n-            token::OpenDelim(token::Bracket) => {\n-                // Parse `[pat, pat,...]` as a slice pattern.\n-                let (slice, _) = self.parse_delim_comma_seq(token::Bracket, |p| p.parse_pat(None))?;\n-                pat = PatKind::Slice(slice);\n-            }\n-            token::DotDot => {\n-                self.bump();\n-                pat = if self.is_pat_range_end_start() {\n-                    // Parse `..42` for recovery.\n-                    self.parse_pat_range_to(RangeEnd::Excluded, \"..\")?\n-                } else {\n-                    // A rest pattern `..`.\n-                    PatKind::Rest\n-                };\n-            }\n-            token::DotDotEq => {\n-                // Parse `..=42` for recovery.\n-                self.bump();\n-                pat = self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")?;\n-            }\n-            token::DotDotDot => {\n-                // Parse `...42` for recovery.\n-                self.bump();\n-                pat = self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")?;\n-            }\n-            // At this point, token != &, &&, (, [\n-            _ => if self.eat_keyword(kw::Underscore) {\n-                // Parse _\n-                pat = PatKind::Wild;\n-            } else if self.eat_keyword(kw::Mut) {\n-                // Parse mut ident @ pat / mut ref ident @ pat\n-                let mutref_span = self.prev_span.to(self.token.span);\n-                let binding_mode = if self.eat_keyword(kw::Ref) {\n-                    self.diagnostic()\n-                        .struct_span_err(mutref_span, \"the order of `mut` and `ref` is incorrect\")\n-                        .span_suggestion(\n-                            mutref_span,\n-                            \"try switching the order\",\n-                            \"ref mut\".into(),\n-                            Applicability::MachineApplicable\n-                        ).emit();\n-                    BindingMode::ByRef(Mutability::Mutable)\n-                } else {\n-                    BindingMode::ByValue(Mutability::Mutable)\n-                };\n-                pat = self.parse_pat_ident(binding_mode)?;\n-            } else if self.eat_keyword(kw::Ref) {\n-                // Parse ref ident @ pat / ref mut ident @ pat\n-                let mutbl = self.parse_mutability();\n-                pat = self.parse_pat_ident(BindingMode::ByRef(mutbl))?;\n-            } else if self.eat_keyword(kw::Box) {\n-                // Parse box pat\n-                let subpat = self.parse_pat_with_range_pat(false, None)?;\n-                pat = PatKind::Box(subpat);\n-            } else if self.token.is_ident() && !self.token.is_reserved_ident() &&\n-                      self.parse_as_ident() {\n-                // Parse ident @ pat\n-                // This can give false positives and parse nullary enums,\n-                // they are dealt with later in resolve\n-                let binding_mode = BindingMode::ByValue(Mutability::Immutable);\n-                pat = self.parse_pat_ident(binding_mode)?;\n-            } else if self.token.is_path_start() {\n-                // Parse pattern starting with a path\n-                let (qself, path) = if self.eat_lt() {\n-                    // Parse a qualified path\n-                    let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n-                    (Some(qself), path)\n-                } else {\n-                    // Parse an unqualified path\n-                    (None, self.parse_path(PathStyle::Expr)?)\n-                };\n-                match self.token.kind {\n-                    token::Not if qself.is_none() => {\n-                        // Parse macro invocation\n-                        self.bump();\n-                        let (delim, tts) = self.expect_delimited_token_tree()?;\n-                        let mac = respan(lo.to(self.prev_span), Mac_ {\n-                            path,\n-                            tts,\n-                            delim,\n-                            prior_type_ascription: self.last_type_ascription,\n-                        });\n-                        pat = PatKind::Mac(mac);\n-                    }\n-                    token::DotDotDot | token::DotDotEq | token::DotDot => {\n-                        let (end_kind, form) = match self.token.kind {\n-                            token::DotDot => (RangeEnd::Excluded, \"..\"),\n-                            token::DotDotDot => (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\"),\n-                            token::DotDotEq => (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\"),\n-                            _ => panic!(\"can only parse `..`/`...`/`..=` for ranges \\\n-                                         (checked above)\"),\n-                        };\n-                        let op_span = self.token.span;\n-                        // Parse range\n-                        let span = lo.to(self.prev_span);\n-                        let begin = self.mk_expr(span, ExprKind::Path(qself, path), ThinVec::new());\n-                        self.bump();\n-                        let end = self.parse_pat_range_end_opt(&begin, form)?;\n-                        pat = PatKind::Range(begin, end, respan(op_span, end_kind));\n-                    }\n-                    token::OpenDelim(token::Brace) => {\n-                        if qself.is_some() {\n-                            let msg = \"unexpected `{` after qualified path\";\n-                            let mut err = self.fatal(msg);\n-                            err.span_label(self.token.span, msg);\n-                            return Err(err);\n-                        }\n-                        // Parse struct pattern\n-                        self.bump();\n-                        let (fields, etc) = self.parse_pat_fields().unwrap_or_else(|mut e| {\n-                            e.emit();\n-                            self.recover_stmt();\n-                            (vec![], true)\n-                        });\n-                        self.bump();\n-                        pat = PatKind::Struct(path, fields, etc);\n-                    }\n-                    token::OpenDelim(token::Paren) => {\n-                        if qself.is_some() {\n-                            let msg = \"unexpected `(` after qualified path\";\n-                            let mut err = self.fatal(msg);\n-                            err.span_label(self.token.span, msg);\n-                            return Err(err);\n-                        }\n-                        // Parse tuple struct or enum pattern\n-                        let (fields, _) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n-                        pat = PatKind::TupleStruct(path, fields)\n-                    }\n-                    _ => pat = PatKind::Path(qself, path),\n-                }\n-            } else {\n-                // Try to parse everything else as literal with optional minus\n-                match self.parse_literal_maybe_minus() {\n-                    Ok(begin) => {\n-                        let op_span = self.token.span;\n-                        if self.check(&token::DotDot) || self.check(&token::DotDotEq) ||\n-                                self.check(&token::DotDotDot) {\n-                            let (end_kind, form) = if self.eat(&token::DotDotDot) {\n-                                (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")\n-                            } else if self.eat(&token::DotDotEq) {\n-                                (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")\n-                            } else if self.eat(&token::DotDot) {\n-                                (RangeEnd::Excluded, \"..\")\n-                            } else {\n-                                panic!(\"impossible case: we already matched \\\n-                                        on a range-operator token\")\n-                            };\n-                            let end = self.parse_pat_range_end_opt(&begin, form)?;\n-                            pat = PatKind::Range(begin, end, respan(op_span, end_kind))\n-                        } else {\n-                            pat = PatKind::Lit(begin);\n-                        }\n-                    }\n-                    Err(mut err) => {\n-                        self.cancel(&mut err);\n-                        let expected = expected.unwrap_or(\"pattern\");\n-                        let msg = format!(\n-                            \"expected {}, found {}\",\n-                            expected,\n-                            self.this_token_descr(),\n-                        );\n-                        let mut err = self.fatal(&msg);\n-                        err.span_label(self.token.span, format!(\"expected {}\", expected));\n-                        let sp = self.sess.source_map().start_point(self.token.span);\n-                        if let Some(sp) = self.sess.ambiguous_block_expr_parse.borrow().get(&sp) {\n-                            self.sess.expr_parentheses_needed(&mut err, *sp, None);\n-                        }\n-                        return Err(err);\n-                    }\n-                }\n-            }\n-        }\n-\n-        let pat = P(Pat { node: pat, span: lo.to(self.prev_span), id: ast::DUMMY_NODE_ID });\n-        let pat = self.maybe_recover_from_bad_qpath(pat, true)?;\n-\n-        if !allow_range_pat {\n-            match pat.node {\n-                PatKind::Range(\n-                    _, _, Spanned { node: RangeEnd::Included(RangeSyntax::DotDotDot), .. }\n-                ) => {},\n-                PatKind::Range(..) => {\n-                    let mut err = self.struct_span_err(\n-                        pat.span,\n-                        \"the range pattern here has ambiguous interpretation\",\n-                    );\n-                    err.span_suggestion(\n-                        pat.span,\n-                        \"add parentheses to clarify the precedence\",\n-                        format!(\"({})\", pprust::pat_to_string(&pat)),\n-                        // \"ambiguous interpretation\" implies that we have to be guessing\n-                        Applicability::MaybeIncorrect\n-                    );\n-                    return Err(err);\n-                }\n-                _ => {}\n-            }\n-        }\n-\n-        Ok(pat)\n-    }\n-\n-    /// Parses `ident` or `ident @ pat`.\n-    /// used by the copy foo and ref foo patterns to give a good\n-    /// error message when parsing mistakes like `ref foo(a, b)`.\n-    fn parse_pat_ident(&mut self,\n-                       binding_mode: ast::BindingMode)\n-                       -> PResult<'a, PatKind> {\n-        let ident = self.parse_ident()?;\n-        let sub = if self.eat(&token::At) {\n-            Some(self.parse_pat(Some(\"binding pattern\"))?)\n-        } else {\n-            None\n-        };\n-\n-        // just to be friendly, if they write something like\n-        //   ref Some(i)\n-        // we end up here with ( as the current token.  This shortly\n-        // leads to a parse error.  Note that if there is no explicit\n-        // binding mode then we do not end up here, because the lookahead\n-        // will direct us over to parse_enum_variant()\n-        if self.token == token::OpenDelim(token::Paren) {\n-            return Err(self.span_fatal(\n-                self.prev_span,\n-                \"expected identifier, found enum pattern\"))\n-        }\n-\n-        Ok(PatKind::Ident(binding_mode, ident, sub))\n-    }\n-\n     /// Parses a local variable declaration.\n     fn parse_local(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Local>> {\n         let lo = self.prev_span;"}, {"sha": "5cc428a4df1dec91d40d64d71293857839f3947f", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "added", "additions": 634, "deletions": 0, "changes": 634, "blob_url": "https://github.com/rust-lang/rust/blob/e742de2569f6222b26671171c1f32fcd02b80f67/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e742de2569f6222b26671171c1f32fcd02b80f67/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=e742de2569f6222b26671171c1f32fcd02b80f67", "patch": "@@ -0,0 +1,634 @@\n+use super::{Parser, PResult, PathStyle};\n+\n+use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n+use crate::ptr::P;\n+use crate::ast::{self, Attribute, Pat, PatKind, FieldPat, RangeEnd, RangeSyntax, Mac_};\n+use crate::ast::{BindingMode, Ident, Mutability, Expr, ExprKind};\n+use crate::parse::token::{self};\n+use crate::print::pprust;\n+use crate::source_map::{respan, Span, Spanned};\n+use crate::symbol::kw;\n+use crate::ThinVec;\n+\n+use errors::{Applicability, DiagnosticBuilder};\n+\n+impl<'a> Parser<'a> {\n+    /// Parses a pattern.\n+    pub fn parse_pat(&mut self, expected: Option<&'static str>) -> PResult<'a, P<Pat>> {\n+        self.parse_pat_with_range_pat(true, expected)\n+    }\n+\n+    /// Parses patterns, separated by '|' s.\n+    pub(super) fn parse_pats(&mut self) -> PResult<'a, Vec<P<Pat>>> {\n+        // Allow a '|' before the pats (RFC 1925 + RFC 2530)\n+        self.eat(&token::BinOp(token::Or));\n+\n+        let mut pats = Vec::new();\n+        loop {\n+            pats.push(self.parse_top_level_pat()?);\n+\n+            if self.token == token::OrOr {\n+                self.struct_span_err(self.token.span, \"unexpected token `||` after pattern\")\n+                    .span_suggestion(\n+                        self.token.span,\n+                        \"use a single `|` to specify multiple patterns\",\n+                        \"|\".to_owned(),\n+                        Applicability::MachineApplicable\n+                    )\n+                    .emit();\n+                self.bump();\n+            } else if self.eat(&token::BinOp(token::Or)) {\n+                // This is a No-op. Continue the loop to parse the next\n+                // pattern.\n+            } else {\n+                return Ok(pats);\n+            }\n+        };\n+    }\n+\n+    /// A wrapper around `parse_pat` with some special error handling for the\n+    /// \"top-level\" patterns in a match arm, `for` loop, `let`, &c. (in contrast\n+    /// to subpatterns within such).\n+    pub(super) fn parse_top_level_pat(&mut self) -> PResult<'a, P<Pat>> {\n+        let pat = self.parse_pat(None)?;\n+        if self.token == token::Comma {\n+            // An unexpected comma after a top-level pattern is a clue that the\n+            // user (perhaps more accustomed to some other language) forgot the\n+            // parentheses in what should have been a tuple pattern; return a\n+            // suggestion-enhanced error here rather than choking on the comma\n+            // later.\n+            let comma_span = self.token.span;\n+            self.bump();\n+            if let Err(mut err) = self.skip_pat_list() {\n+                // We didn't expect this to work anyway; we just wanted\n+                // to advance to the end of the comma-sequence so we know\n+                // the span to suggest parenthesizing\n+                err.cancel();\n+            }\n+            let seq_span = pat.span.to(self.prev_span);\n+            let mut err = self.struct_span_err(comma_span, \"unexpected `,` in pattern\");\n+            if let Ok(seq_snippet) = self.span_to_snippet(seq_span) {\n+                err.span_suggestion(\n+                    seq_span,\n+                    \"try adding parentheses to match on a tuple..\",\n+                    format!(\"({})\", seq_snippet),\n+                    Applicability::MachineApplicable\n+                ).span_suggestion(\n+                    seq_span,\n+                    \"..or a vertical bar to match on multiple alternatives\",\n+                    format!(\"{}\", seq_snippet.replace(\",\", \" |\")),\n+                    Applicability::MachineApplicable\n+                );\n+            }\n+            return Err(err);\n+        }\n+        Ok(pat)\n+    }\n+\n+    /// Parse and throw away a parentesized comma separated\n+    /// sequence of patterns until `)` is reached.\n+    fn skip_pat_list(&mut self) -> PResult<'a, ()> {\n+        while !self.check(&token::CloseDelim(token::Paren)) {\n+            self.parse_pat(None)?;\n+            if !self.eat(&token::Comma) {\n+                return Ok(())\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Parses a pattern, with a setting whether modern range patterns (e.g., `a..=b`, `a..b` are\n+    /// allowed).\n+    fn parse_pat_with_range_pat(\n+        &mut self,\n+        allow_range_pat: bool,\n+        expected: Option<&'static str>,\n+    ) -> PResult<'a, P<Pat>> {\n+        maybe_recover_from_interpolated_ty_qpath!(self, true);\n+        maybe_whole!(self, NtPat, |x| x);\n+\n+        let lo = self.token.span;\n+        let pat;\n+        match self.token.kind {\n+            token::BinOp(token::And) | token::AndAnd => {\n+                // Parse &pat / &mut pat\n+                self.expect_and()?;\n+                let mutbl = self.parse_mutability();\n+                if let token::Lifetime(name) = self.token.kind {\n+                    let mut err = self.fatal(&format!(\"unexpected lifetime `{}` in pattern\", name));\n+                    err.span_label(self.token.span, \"unexpected lifetime\");\n+                    return Err(err);\n+                }\n+                let subpat = self.parse_pat_with_range_pat(false, expected)?;\n+                pat = PatKind::Ref(subpat, mutbl);\n+            }\n+            token::OpenDelim(token::Paren) => {\n+                // Parse a tuple or parenthesis pattern.\n+                let (fields, trailing_comma) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n+\n+                // Here, `(pat,)` is a tuple pattern.\n+                // For backward compatibility, `(..)` is a tuple pattern as well.\n+                pat = if fields.len() == 1 && !(trailing_comma || fields[0].is_rest()) {\n+                    PatKind::Paren(fields.into_iter().nth(0).unwrap())\n+                } else {\n+                    PatKind::Tuple(fields)\n+                };\n+            }\n+            token::OpenDelim(token::Bracket) => {\n+                // Parse `[pat, pat,...]` as a slice pattern.\n+                let (slice, _) = self.parse_delim_comma_seq(token::Bracket, |p| p.parse_pat(None))?;\n+                pat = PatKind::Slice(slice);\n+            }\n+            token::DotDot => {\n+                self.bump();\n+                pat = if self.is_pat_range_end_start() {\n+                    // Parse `..42` for recovery.\n+                    self.parse_pat_range_to(RangeEnd::Excluded, \"..\")?\n+                } else {\n+                    // A rest pattern `..`.\n+                    PatKind::Rest\n+                };\n+            }\n+            token::DotDotEq => {\n+                // Parse `..=42` for recovery.\n+                self.bump();\n+                pat = self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")?;\n+            }\n+            token::DotDotDot => {\n+                // Parse `...42` for recovery.\n+                self.bump();\n+                pat = self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")?;\n+            }\n+            // At this point, token != &, &&, (, [\n+            _ => if self.eat_keyword(kw::Underscore) {\n+                // Parse _\n+                pat = PatKind::Wild;\n+            } else if self.eat_keyword(kw::Mut) {\n+                // Parse mut ident @ pat / mut ref ident @ pat\n+                let mutref_span = self.prev_span.to(self.token.span);\n+                let binding_mode = if self.eat_keyword(kw::Ref) {\n+                    self.diagnostic()\n+                        .struct_span_err(mutref_span, \"the order of `mut` and `ref` is incorrect\")\n+                        .span_suggestion(\n+                            mutref_span,\n+                            \"try switching the order\",\n+                            \"ref mut\".into(),\n+                            Applicability::MachineApplicable\n+                        ).emit();\n+                    BindingMode::ByRef(Mutability::Mutable)\n+                } else {\n+                    BindingMode::ByValue(Mutability::Mutable)\n+                };\n+                pat = self.parse_pat_ident(binding_mode)?;\n+            } else if self.eat_keyword(kw::Ref) {\n+                // Parse ref ident @ pat / ref mut ident @ pat\n+                let mutbl = self.parse_mutability();\n+                pat = self.parse_pat_ident(BindingMode::ByRef(mutbl))?;\n+            } else if self.eat_keyword(kw::Box) {\n+                // Parse box pat\n+                let subpat = self.parse_pat_with_range_pat(false, None)?;\n+                pat = PatKind::Box(subpat);\n+            } else if self.token.is_ident() && !self.token.is_reserved_ident() &&\n+                      self.parse_as_ident() {\n+                // Parse ident @ pat\n+                // This can give false positives and parse nullary enums,\n+                // they are dealt with later in resolve\n+                let binding_mode = BindingMode::ByValue(Mutability::Immutable);\n+                pat = self.parse_pat_ident(binding_mode)?;\n+            } else if self.token.is_path_start() {\n+                // Parse pattern starting with a path\n+                let (qself, path) = if self.eat_lt() {\n+                    // Parse a qualified path\n+                    let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n+                    (Some(qself), path)\n+                } else {\n+                    // Parse an unqualified path\n+                    (None, self.parse_path(PathStyle::Expr)?)\n+                };\n+                match self.token.kind {\n+                    token::Not if qself.is_none() => {\n+                        // Parse macro invocation\n+                        self.bump();\n+                        let (delim, tts) = self.expect_delimited_token_tree()?;\n+                        let mac = respan(lo.to(self.prev_span), Mac_ {\n+                            path,\n+                            tts,\n+                            delim,\n+                            prior_type_ascription: self.last_type_ascription,\n+                        });\n+                        pat = PatKind::Mac(mac);\n+                    }\n+                    token::DotDotDot | token::DotDotEq | token::DotDot => {\n+                        let (end_kind, form) = match self.token.kind {\n+                            token::DotDot => (RangeEnd::Excluded, \"..\"),\n+                            token::DotDotDot => (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\"),\n+                            token::DotDotEq => (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\"),\n+                            _ => panic!(\"can only parse `..`/`...`/`..=` for ranges \\\n+                                         (checked above)\"),\n+                        };\n+                        let op_span = self.token.span;\n+                        // Parse range\n+                        let span = lo.to(self.prev_span);\n+                        let begin = self.mk_expr(span, ExprKind::Path(qself, path), ThinVec::new());\n+                        self.bump();\n+                        let end = self.parse_pat_range_end_opt(&begin, form)?;\n+                        pat = PatKind::Range(begin, end, respan(op_span, end_kind));\n+                    }\n+                    token::OpenDelim(token::Brace) => {\n+                        if qself.is_some() {\n+                            let msg = \"unexpected `{` after qualified path\";\n+                            let mut err = self.fatal(msg);\n+                            err.span_label(self.token.span, msg);\n+                            return Err(err);\n+                        }\n+                        // Parse struct pattern\n+                        self.bump();\n+                        let (fields, etc) = self.parse_pat_fields().unwrap_or_else(|mut e| {\n+                            e.emit();\n+                            self.recover_stmt();\n+                            (vec![], true)\n+                        });\n+                        self.bump();\n+                        pat = PatKind::Struct(path, fields, etc);\n+                    }\n+                    token::OpenDelim(token::Paren) => {\n+                        if qself.is_some() {\n+                            let msg = \"unexpected `(` after qualified path\";\n+                            let mut err = self.fatal(msg);\n+                            err.span_label(self.token.span, msg);\n+                            return Err(err);\n+                        }\n+                        // Parse tuple struct or enum pattern\n+                        let (fields, _) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n+                        pat = PatKind::TupleStruct(path, fields)\n+                    }\n+                    _ => pat = PatKind::Path(qself, path),\n+                }\n+            } else {\n+                // Try to parse everything else as literal with optional minus\n+                match self.parse_literal_maybe_minus() {\n+                    Ok(begin) => {\n+                        let op_span = self.token.span;\n+                        if self.check(&token::DotDot) || self.check(&token::DotDotEq) ||\n+                                self.check(&token::DotDotDot) {\n+                            let (end_kind, form) = if self.eat(&token::DotDotDot) {\n+                                (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")\n+                            } else if self.eat(&token::DotDotEq) {\n+                                (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")\n+                            } else if self.eat(&token::DotDot) {\n+                                (RangeEnd::Excluded, \"..\")\n+                            } else {\n+                                panic!(\"impossible case: we already matched \\\n+                                        on a range-operator token\")\n+                            };\n+                            let end = self.parse_pat_range_end_opt(&begin, form)?;\n+                            pat = PatKind::Range(begin, end, respan(op_span, end_kind))\n+                        } else {\n+                            pat = PatKind::Lit(begin);\n+                        }\n+                    }\n+                    Err(mut err) => {\n+                        self.cancel(&mut err);\n+                        let expected = expected.unwrap_or(\"pattern\");\n+                        let msg = format!(\n+                            \"expected {}, found {}\",\n+                            expected,\n+                            self.this_token_descr(),\n+                        );\n+                        let mut err = self.fatal(&msg);\n+                        err.span_label(self.token.span, format!(\"expected {}\", expected));\n+                        let sp = self.sess.source_map().start_point(self.token.span);\n+                        if let Some(sp) = self.sess.ambiguous_block_expr_parse.borrow().get(&sp) {\n+                            self.sess.expr_parentheses_needed(&mut err, *sp, None);\n+                        }\n+                        return Err(err);\n+                    }\n+                }\n+            }\n+        }\n+\n+        let pat = self.mk_pat(lo.to(self.prev_span), pat);\n+        let pat = self.maybe_recover_from_bad_qpath(pat, true)?;\n+\n+        if !allow_range_pat {\n+            match pat.node {\n+                PatKind::Range(\n+                    _, _, Spanned { node: RangeEnd::Included(RangeSyntax::DotDotDot), .. }\n+                ) => {},\n+                PatKind::Range(..) => {\n+                    let mut err = self.struct_span_err(\n+                        pat.span,\n+                        \"the range pattern here has ambiguous interpretation\",\n+                    );\n+                    err.span_suggestion(\n+                        pat.span,\n+                        \"add parentheses to clarify the precedence\",\n+                        format!(\"({})\", pprust::pat_to_string(&pat)),\n+                        // \"ambiguous interpretation\" implies that we have to be guessing\n+                        Applicability::MaybeIncorrect\n+                    );\n+                    return Err(err);\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        Ok(pat)\n+    }\n+\n+    // Helper function to decide whether to parse as ident binding\n+    // or to try to do something more complex like range patterns.\n+    fn parse_as_ident(&mut self) -> bool {\n+        self.look_ahead(1, |t| match t.kind {\n+            token::OpenDelim(token::Paren) | token::OpenDelim(token::Brace) |\n+            token::DotDotDot | token::DotDotEq | token::DotDot |\n+            token::ModSep | token::Not => false,\n+            _ => true,\n+        })\n+    }\n+\n+    /// Is the current token suitable as the start of a range patterns end?\n+    fn is_pat_range_end_start(&self) -> bool {\n+        self.token.is_path_start() // e.g. `MY_CONST`;\n+            || self.token == token::Dot // e.g. `.5` for recovery;\n+            || self.token.can_begin_literal_or_bool() // e.g. `42`.\n+            || self.token.is_whole_expr()\n+    }\n+\n+    /// Parse a range-to pattern, e.g. `..X` and `..=X` for recovery.\n+    fn parse_pat_range_to(&mut self, re: RangeEnd, form: &str) -> PResult<'a, PatKind> {\n+        let lo = self.prev_span;\n+        let end = self.parse_pat_range_end()?;\n+        let range_span = lo.to(end.span);\n+        let begin = self.mk_expr(range_span, ExprKind::Err, ThinVec::new());\n+\n+        self.diagnostic()\n+            .struct_span_err(range_span, &format!(\"`{}X` range patterns are not supported\", form))\n+            .span_suggestion(\n+                range_span,\n+                \"try using the minimum value for the type\",\n+                format!(\"MIN{}{}\", form, pprust::expr_to_string(&end)),\n+                Applicability::HasPlaceholders,\n+            )\n+            .emit();\n+\n+        Ok(PatKind::Range(begin, end, respan(lo, re)))\n+    }\n+\n+    /// Parse the end of a `X..Y`, `X..=Y`, or `X...Y` range pattern  or recover\n+    /// if that end is missing treating it as `X..`, `X..=`, or `X...` respectively.\n+    fn parse_pat_range_end_opt(&mut self, begin: &Expr, form: &str) -> PResult<'a, P<Expr>> {\n+        if self.is_pat_range_end_start() {\n+            // Parsing e.g. `X..=Y`.\n+            self.parse_pat_range_end()\n+        } else {\n+            // Parsing e.g. `X..`.\n+            let range_span = begin.span.to(self.prev_span);\n+\n+            self.diagnostic()\n+                .struct_span_err(\n+                    range_span,\n+                    &format!(\"`X{}` range patterns are not supported\", form),\n+                )\n+                .span_suggestion(\n+                    range_span,\n+                    \"try using the maximum value for the type\",\n+                    format!(\"{}{}MAX\", pprust::expr_to_string(&begin), form),\n+                    Applicability::HasPlaceholders,\n+                )\n+                .emit();\n+\n+            Ok(self.mk_expr(range_span, ExprKind::Err, ThinVec::new()))\n+        }\n+    }\n+\n+    fn parse_pat_range_end(&mut self) -> PResult<'a, P<Expr>> {\n+        if self.token.is_path_start() {\n+            let lo = self.token.span;\n+            let (qself, path) = if self.eat_lt() {\n+                // Parse a qualified path\n+                let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n+                (Some(qself), path)\n+            } else {\n+                // Parse an unqualified path\n+                (None, self.parse_path(PathStyle::Expr)?)\n+            };\n+            let hi = self.prev_span;\n+            Ok(self.mk_expr(lo.to(hi), ExprKind::Path(qself, path), ThinVec::new()))\n+        } else {\n+            self.parse_literal_maybe_minus()\n+        }\n+    }\n+\n+    /// Parses `ident` or `ident @ pat`.\n+    /// used by the copy foo and ref foo patterns to give a good\n+    /// error message when parsing mistakes like `ref foo(a, b)`.\n+    fn parse_pat_ident(&mut self,\n+                       binding_mode: ast::BindingMode)\n+                       -> PResult<'a, PatKind> {\n+        let ident = self.parse_ident()?;\n+        let sub = if self.eat(&token::At) {\n+            Some(self.parse_pat(Some(\"binding pattern\"))?)\n+        } else {\n+            None\n+        };\n+\n+        // just to be friendly, if they write something like\n+        //   ref Some(i)\n+        // we end up here with ( as the current token.  This shortly\n+        // leads to a parse error.  Note that if there is no explicit\n+        // binding mode then we do not end up here, because the lookahead\n+        // will direct us over to parse_enum_variant()\n+        if self.token == token::OpenDelim(token::Paren) {\n+            return Err(self.span_fatal(\n+                self.prev_span,\n+                \"expected identifier, found enum pattern\"))\n+        }\n+\n+        Ok(PatKind::Ident(binding_mode, ident, sub))\n+    }\n+\n+    /// Parses the fields of a struct-like pattern.\n+    fn parse_pat_fields(&mut self) -> PResult<'a, (Vec<Spanned<FieldPat>>, bool)> {\n+        let mut fields = Vec::new();\n+        let mut etc = false;\n+        let mut ate_comma = true;\n+        let mut delayed_err: Option<DiagnosticBuilder<'a>> = None;\n+        let mut etc_span = None;\n+\n+        while self.token != token::CloseDelim(token::Brace) {\n+            let attrs = match self.parse_outer_attributes() {\n+                Ok(attrs) => attrs,\n+                Err(err) => {\n+                    if let Some(mut delayed) = delayed_err {\n+                        delayed.emit();\n+                    }\n+                    return Err(err);\n+                },\n+            };\n+            let lo = self.token.span;\n+\n+            // check that a comma comes after every field\n+            if !ate_comma {\n+                let err = self.struct_span_err(self.prev_span, \"expected `,`\");\n+                if let Some(mut delayed) = delayed_err {\n+                    delayed.emit();\n+                }\n+                return Err(err);\n+            }\n+            ate_comma = false;\n+\n+            if self.check(&token::DotDot) || self.token == token::DotDotDot {\n+                etc = true;\n+                let mut etc_sp = self.token.span;\n+\n+                if self.token == token::DotDotDot { // Issue #46718\n+                    // Accept `...` as if it were `..` to avoid further errors\n+                    self.struct_span_err(self.token.span, \"expected field pattern, found `...`\")\n+                        .span_suggestion(\n+                            self.token.span,\n+                            \"to omit remaining fields, use one fewer `.`\",\n+                            \"..\".to_owned(),\n+                            Applicability::MachineApplicable\n+                        )\n+                        .emit();\n+                }\n+                self.bump();  // `..` || `...`\n+\n+                if self.token == token::CloseDelim(token::Brace) {\n+                    etc_span = Some(etc_sp);\n+                    break;\n+                }\n+                let token_str = self.this_token_descr();\n+                let mut err = self.fatal(&format!(\"expected `}}`, found {}\", token_str));\n+\n+                err.span_label(self.token.span, \"expected `}`\");\n+                let mut comma_sp = None;\n+                if self.token == token::Comma { // Issue #49257\n+                    let nw_span = self.sess.source_map().span_until_non_whitespace(self.token.span);\n+                    etc_sp = etc_sp.to(nw_span);\n+                    err.span_label(etc_sp,\n+                                   \"`..` must be at the end and cannot have a trailing comma\");\n+                    comma_sp = Some(self.token.span);\n+                    self.bump();\n+                    ate_comma = true;\n+                }\n+\n+                etc_span = Some(etc_sp.until(self.token.span));\n+                if self.token == token::CloseDelim(token::Brace) {\n+                    // If the struct looks otherwise well formed, recover and continue.\n+                    if let Some(sp) = comma_sp {\n+                        err.span_suggestion_short(\n+                            sp,\n+                            \"remove this comma\",\n+                            String::new(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                    err.emit();\n+                    break;\n+                } else if self.token.is_ident() && ate_comma {\n+                    // Accept fields coming after `..,`.\n+                    // This way we avoid \"pattern missing fields\" errors afterwards.\n+                    // We delay this error until the end in order to have a span for a\n+                    // suggested fix.\n+                    if let Some(mut delayed_err) = delayed_err {\n+                        delayed_err.emit();\n+                        return Err(err);\n+                    } else {\n+                        delayed_err = Some(err);\n+                    }\n+                } else {\n+                    if let Some(mut err) = delayed_err {\n+                        err.emit();\n+                    }\n+                    return Err(err);\n+                }\n+            }\n+\n+            fields.push(match self.parse_pat_field(lo, attrs) {\n+                Ok(field) => field,\n+                Err(err) => {\n+                    if let Some(mut delayed_err) = delayed_err {\n+                        delayed_err.emit();\n+                    }\n+                    return Err(err);\n+                }\n+            });\n+            ate_comma = self.eat(&token::Comma);\n+        }\n+\n+        if let Some(mut err) = delayed_err {\n+            if let Some(etc_span) = etc_span {\n+                err.multipart_suggestion(\n+                    \"move the `..` to the end of the field list\",\n+                    vec![\n+                        (etc_span, String::new()),\n+                        (self.token.span, format!(\"{}.. }}\", if ate_comma { \"\" } else { \", \" })),\n+                    ],\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            err.emit();\n+        }\n+        return Ok((fields, etc));\n+    }\n+\n+    fn parse_pat_field(\n+        &mut self,\n+        lo: Span,\n+        attrs: Vec<Attribute>\n+    ) -> PResult<'a, Spanned<FieldPat>> {\n+        // Check if a colon exists one ahead. This means we're parsing a fieldname.\n+        let hi;\n+        let (subpat, fieldname, is_shorthand) = if self.look_ahead(1, |t| t == &token::Colon) {\n+            // Parsing a pattern of the form \"fieldname: pat\"\n+            let fieldname = self.parse_field_name()?;\n+            self.bump();\n+            let pat = self.parse_pat(None)?;\n+            hi = pat.span;\n+            (pat, fieldname, false)\n+        } else {\n+            // Parsing a pattern of the form \"(box) (ref) (mut) fieldname\"\n+            let is_box = self.eat_keyword(kw::Box);\n+            let boxed_span = self.token.span;\n+            let is_ref = self.eat_keyword(kw::Ref);\n+            let is_mut = self.eat_keyword(kw::Mut);\n+            let fieldname = self.parse_ident()?;\n+            hi = self.prev_span;\n+\n+            let bind_type = match (is_ref, is_mut) {\n+                (true, true) => BindingMode::ByRef(Mutability::Mutable),\n+                (true, false) => BindingMode::ByRef(Mutability::Immutable),\n+                (false, true) => BindingMode::ByValue(Mutability::Mutable),\n+                (false, false) => BindingMode::ByValue(Mutability::Immutable),\n+            };\n+\n+            let fieldpat = self.mk_pat_ident(boxed_span.to(hi), bind_type, fieldname);\n+            let subpat = if is_box {\n+                self.mk_pat(lo.to(hi), PatKind::Box(fieldpat))\n+            } else {\n+                fieldpat\n+            };\n+            (subpat, fieldname, true)\n+        };\n+\n+        Ok(Spanned {\n+            span: lo.to(hi),\n+            node: FieldPat {\n+                ident: fieldname,\n+                pat: subpat,\n+                is_shorthand,\n+                attrs: attrs.into(),\n+           }\n+        })\n+    }\n+\n+    pub(super) fn mk_pat_ident(&self, span: Span, bm: BindingMode, ident: Ident) -> P<Pat> {\n+        self.mk_pat(span, PatKind::Ident(bm, ident, None))\n+    }\n+\n+    fn mk_pat(&self, span: Span, node: PatKind) -> P<Pat> {\n+        P(Pat { node, span, id: ast::DUMMY_NODE_ID })\n+    }\n+}"}]}