{"sha": "9423c4f0dda638ec2a925140850b85e8d3e6d455", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0MjNjNGYwZGRhNjM4ZWMyYTkyNTE0MDg1MGI4NWU4ZDNlNmQ0NTU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-23T09:29:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-23T09:29:13Z"}, "message": "Rollup merge of #70123 - cuviper:library-path, r=Mark-Simulacrum\n\nEnsure LLVM is in the link path for rustc tools\n\nThe build script for `rustc_llvm` outputs LLVM information in `cargo:rustc-link-lib` and `cargo:rustc-link-search` so the compiler can be linked correctly. However, while the lib is carried along in metadata, the search paths are not. So when cargo is invoked again later for rustc _tools_, they'll also try to link with LLVM, but the necessary paths may be left out.\n\nRustbuild can use the environment to set the LLVM link path for tools -- `LIB` for MSVC toolchains and `LIBRARY_PATH` for everyone else.\n\nFixes #68714.", "tree": {"sha": "5ad9435b593386812fce23709057863b0fd3ef19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ad9435b593386812fce23709057863b0fd3ef19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9423c4f0dda638ec2a925140850b85e8d3e6d455", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeeIFpCRBK7hj4Ov3rIwAAdHIIAHHW06LuCWmvGRaqZNy+ArpI\niSfrS+nJEuXqchpE3bIU3sZ6veklt5CwbyYl0OgLNYr0A8wfmfbaDLwaUT6EY9Vm\nQ41kndFTcgJpTbLK+YPpkFk7MbXzxoogsh9e9PRofEEXCxaVkixn22G3n0Lz++te\n/nzs9s+FrgqH+By8TaJ/pKTssquKEVo42GzNufYoJ5JK6dgu2duOyihNmOmPaNeY\n8U1h0G4KqSy3W+Zh1JI8TKv4FO4mIBaANLWKvxJIYmTLee2dH2ffjVFH0uuMvRjv\n+zPXVgxmOeU5e62XgRLfJ7+h531d1KuRT84S2kv4xI1RUVuqdfXjvcan0NzPETc=\n=/KSf\n-----END PGP SIGNATURE-----\n", "payload": "tree 5ad9435b593386812fce23709057863b0fd3ef19\nparent bee074f032970fd1b59650c04a70e75eeee9c63b\nparent 3a2a4429a288031e7810e84b35ff13b8dd4608a4\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1584955753 +0100\ncommitter GitHub <noreply@github.com> 1584955753 +0100\n\nRollup merge of #70123 - cuviper:library-path, r=Mark-Simulacrum\n\nEnsure LLVM is in the link path for rustc tools\n\nThe build script for `rustc_llvm` outputs LLVM information in `cargo:rustc-link-lib` and `cargo:rustc-link-search` so the compiler can be linked correctly. However, while the lib is carried along in metadata, the search paths are not. So when cargo is invoked again later for rustc _tools_, they'll also try to link with LLVM, but the necessary paths may be left out.\n\nRustbuild can use the environment to set the LLVM link path for tools -- `LIB` for MSVC toolchains and `LIBRARY_PATH` for everyone else.\n\nFixes #68714.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9423c4f0dda638ec2a925140850b85e8d3e6d455", "html_url": "https://github.com/rust-lang/rust/commit/9423c4f0dda638ec2a925140850b85e8d3e6d455", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9423c4f0dda638ec2a925140850b85e8d3e6d455/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bee074f032970fd1b59650c04a70e75eeee9c63b", "url": "https://api.github.com/repos/rust-lang/rust/commits/bee074f032970fd1b59650c04a70e75eeee9c63b", "html_url": "https://github.com/rust-lang/rust/commit/bee074f032970fd1b59650c04a70e75eeee9c63b"}, {"sha": "3a2a4429a288031e7810e84b35ff13b8dd4608a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a2a4429a288031e7810e84b35ff13b8dd4608a4", "html_url": "https://github.com/rust-lang/rust/commit/3a2a4429a288031e7810e84b35ff13b8dd4608a4"}], "stats": {"total": 102, "additions": 57, "deletions": 45}, "files": [{"sha": "dd519506d42a0f0973b7815c6ce339e998927ef3", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9423c4f0dda638ec2a925140850b85e8d3e6d455/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9423c4f0dda638ec2a925140850b85e8d3e6d455/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=9423c4f0dda638ec2a925140850b85e8d3e6d455", "patch": "@@ -11,7 +11,7 @@ use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::time::{Duration, Instant};\n \n-use build_helper::t;\n+use build_helper::{output, t};\n \n use crate::cache::{Cache, Interned, INTERNER};\n use crate::check;\n@@ -23,7 +23,7 @@ use crate::install;\n use crate::native;\n use crate::test;\n use crate::tool;\n-use crate::util::{self, add_lib_path, exe, libdir};\n+use crate::util::{self, add_dylib_path, add_link_lib_path, exe, libdir};\n use crate::{Build, DocTests, GitRepo, Mode};\n \n pub use crate::Compiler;\n@@ -660,7 +660,7 @@ impl<'a> Builder<'a> {\n             return;\n         }\n \n-        add_lib_path(vec![self.rustc_libdir(compiler)], &mut cmd.command);\n+        add_dylib_path(vec![self.rustc_libdir(compiler)], &mut cmd.command);\n     }\n \n     /// Gets a path to the compiler specified.\n@@ -698,6 +698,20 @@ impl<'a> Builder<'a> {\n         cmd\n     }\n \n+    /// Return the path to `llvm-config` for the target, if it exists.\n+    ///\n+    /// Note that this returns `None` if LLVM is disabled, or if we're in a\n+    /// check build or dry-run, where there's no need to build all of LLVM.\n+    fn llvm_config(&self, target: Interned<String>) -> Option<PathBuf> {\n+        if self.config.llvm_enabled() && self.kind != Kind::Check && !self.config.dry_run {\n+            let llvm_config = self.ensure(native::Llvm { target });\n+            if llvm_config.is_file() {\n+                return Some(llvm_config);\n+            }\n+        }\n+        None\n+    }\n+\n     /// Prepares an invocation of `cargo` to be run.\n     ///\n     /// This will create a `Command` that represents a pending execution of\n@@ -1034,6 +1048,17 @@ impl<'a> Builder<'a> {\n                 .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_libdir(compiler));\n         }\n \n+        // Tools that use compiler libraries may inherit the `-lLLVM` link\n+        // requirement, but the `-L` library path is not propagated across\n+        // separate Cargo projects. We can add LLVM's library path to the\n+        // platform-specific environment variable as a workaround.\n+        if mode == Mode::ToolRustc {\n+            if let Some(llvm_config) = self.llvm_config(target) {\n+                let llvm_libdir = output(Command::new(&llvm_config).arg(\"--libdir\"));\n+                add_link_lib_path(vec![llvm_libdir.trim().into()], &mut cargo);\n+            }\n+        }\n+\n         if self.config.incremental {\n             cargo.env(\"CARGO_INCREMENTAL\", \"1\");\n         } else {"}, {"sha": "ad494b88b3af217d3369cda061da0aad182647ef", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9423c4f0dda638ec2a925140850b85e8d3e6d455/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9423c4f0dda638ec2a925140850b85e8d3e6d455/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=9423c4f0dda638ec2a925140850b85e8d3e6d455", "patch": "@@ -451,44 +451,6 @@ impl Step for Rustc {\n             false,\n         );\n \n-        // We used to build librustc_codegen_llvm as a separate step,\n-        // which produced a dylib that the compiler would dlopen() at runtime.\n-        // This meant that we only needed to make sure that libLLVM.so was\n-        // installed by the time we went to run a tool using it - since\n-        // librustc_codegen_llvm was effectively a standalone artifact,\n-        // other crates were completely oblivious to its dependency\n-        // on `libLLVM.so` during build time.\n-        //\n-        // However, librustc_codegen_llvm is now built as an ordinary\n-        // crate during the same step as the rest of the compiler crates.\n-        // This means that any crates depending on it will see the fact\n-        // that it uses `libLLVM.so` as a native library, and will\n-        // cause us to pass `-llibLLVM.so` to the linker when we link\n-        // a binary.\n-        //\n-        // For `rustc` itself, this works out fine.\n-        // During the `Assemble` step, we call `dist::maybe_install_llvm_dylib`\n-        // to copy libLLVM.so into the `stage` directory. We then link\n-        // the compiler binary, which will find `libLLVM.so` in the correct place.\n-        //\n-        // However, this is insufficient for tools that are build against stage0\n-        // (e.g. stage1 rustdoc). Since `Assemble` for stage0 doesn't actually do anything,\n-        // we won't have `libLLVM.so` in the stage0 sysroot. In the past, this wasn't\n-        // a problem - we would copy the tool binary into its correct stage directory\n-        // (e.g. stage1 for a stage1 rustdoc built against a stage0 compiler).\n-        // Since libLLVM.so wasn't resolved until runtime, it was fine for it to\n-        // not exist while we were building it.\n-        //\n-        // To ensure that we can still build stage1 tools against a stage0 compiler,\n-        // we explicitly copy libLLVM.so into the stage0 sysroot when building\n-        // the stage0 compiler. This ensures that tools built against stage0\n-        // will see libLLVM.so at build time, making the linker happy.\n-        if compiler.stage == 0 {\n-            builder.info(&format!(\"Installing libLLVM.so to stage 0 ({})\", compiler.host));\n-            let sysroot = builder.sysroot(compiler);\n-            dist::maybe_install_llvm_dylib(builder, compiler.host, &sysroot);\n-        }\n-\n         builder.ensure(RustcLink {\n             compiler: builder.compiler(compiler.stage, builder.config.build),\n             target_compiler: compiler,"}, {"sha": "c8ccba467e5095c5ea3976633901bd91a0e2c19e", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9423c4f0dda638ec2a925140850b85e8d3e6d455/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9423c4f0dda638ec2a925140850b85e8d3e6d455/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=9423c4f0dda638ec2a925140850b85e8d3e6d455", "patch": "@@ -12,7 +12,7 @@ use crate::channel;\n use crate::channel::GitInfo;\n use crate::compile;\n use crate::toolstate::ToolState;\n-use crate::util::{add_lib_path, exe, CiEnv};\n+use crate::util::{add_dylib_path, exe, CiEnv};\n use crate::Compiler;\n use crate::Mode;\n \n@@ -388,7 +388,7 @@ pub struct ErrorIndex {\n impl ErrorIndex {\n     pub fn command(builder: &Builder<'_>, compiler: Compiler) -> Command {\n         let mut cmd = Command::new(builder.ensure(ErrorIndex { compiler }));\n-        add_lib_path(\n+        add_dylib_path(\n             vec![PathBuf::from(&builder.sysroot_libdir(compiler, compiler.host))],\n             &mut cmd,\n         );\n@@ -689,7 +689,7 @@ impl<'a> Builder<'a> {\n             }\n         }\n \n-        add_lib_path(lib_paths, &mut cmd);\n+        add_dylib_path(lib_paths, &mut cmd);\n         cmd\n     }\n }"}, {"sha": "2bc6f1939d97b5cc53b420e95e20f37710b27fd3", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9423c4f0dda638ec2a925140850b85e8d3e6d455/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9423c4f0dda638ec2a925140850b85e8d3e6d455/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=9423c4f0dda638ec2a925140850b85e8d3e6d455", "patch": "@@ -40,7 +40,7 @@ pub fn libdir(target: &str) -> &'static str {\n }\n \n /// Adds a list of lookup paths to `cmd`'s dynamic library lookup path.\n-pub fn add_lib_path(path: Vec<PathBuf>, cmd: &mut Command) {\n+pub fn add_dylib_path(path: Vec<PathBuf>, cmd: &mut Command) {\n     let mut list = dylib_path();\n     for path in path {\n         list.insert(0, path);\n@@ -72,6 +72,31 @@ pub fn dylib_path() -> Vec<PathBuf> {\n     env::split_paths(&var).collect()\n }\n \n+/// Adds a list of lookup paths to `cmd`'s link library lookup path.\n+pub fn add_link_lib_path(path: Vec<PathBuf>, cmd: &mut Command) {\n+    let mut list = link_lib_path();\n+    for path in path {\n+        list.insert(0, path);\n+    }\n+    cmd.env(link_lib_path_var(), t!(env::join_paths(list)));\n+}\n+\n+/// Returns the environment variable which the link library lookup path\n+/// resides in for this platform.\n+fn link_lib_path_var() -> &'static str {\n+    if cfg!(target_env = \"msvc\") { \"LIB\" } else { \"LIBRARY_PATH\" }\n+}\n+\n+/// Parses the `link_lib_path_var()` environment variable, returning a list of\n+/// paths that are members of this lookup path.\n+fn link_lib_path() -> Vec<PathBuf> {\n+    let var = match env::var_os(link_lib_path_var()) {\n+        Some(v) => v,\n+        None => return vec![],\n+    };\n+    env::split_paths(&var).collect()\n+}\n+\n /// `push` all components to `buf`. On windows, append `.exe` to the last component.\n pub fn push_exe_path(mut buf: PathBuf, components: &[&str]) -> PathBuf {\n     let (&file, components) = components.split_last().expect(\"at least one component required\");"}]}