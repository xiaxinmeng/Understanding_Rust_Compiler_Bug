{"sha": "6136381ed86189a027e641d233a1296ff8b60679", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxMzYzODFlZDg2MTg5YTAyN2U2NDFkMjMzYTEyOTZmZjhiNjA2Nzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-01T18:36:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-01T18:36:01Z"}, "message": "auto merge of #16102 : zwarich/rust/borrowck-unboxed, r=pcwalton\n\nThis removes the ability of the borrow checker to determine that repeated dereferences of a Box<T> refer to the same memory object.", "tree": {"sha": "62c2fa624ade926745630ae94cb12247cbb53da7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62c2fa624ade926745630ae94cb12247cbb53da7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6136381ed86189a027e641d233a1296ff8b60679", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6136381ed86189a027e641d233a1296ff8b60679", "html_url": "https://github.com/rust-lang/rust/commit/6136381ed86189a027e641d233a1296ff8b60679", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6136381ed86189a027e641d233a1296ff8b60679/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2fa55903e378368ed9173560f03a0ef16e371c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2fa55903e378368ed9173560f03a0ef16e371c2", "html_url": "https://github.com/rust-lang/rust/commit/f2fa55903e378368ed9173560f03a0ef16e371c2"}, {"sha": "5d4d09daf2e8e46839647d4e72b1cbefebad6ece", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d4d09daf2e8e46839647d4e72b1cbefebad6ece", "html_url": "https://github.com/rust-lang/rust/commit/5d4d09daf2e8e46839647d4e72b1cbefebad6ece"}], "stats": {"total": 248, "additions": 231, "deletions": 17}, "files": [{"sha": "6a29a9a75b8e10bf9d70ac3e63c7df65d3feed33", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6136381ed86189a027e641d233a1296ff8b60679/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6136381ed86189a027e641d233a1296ff8b60679/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=6136381ed86189a027e641d233a1296ff8b60679", "patch": "@@ -1564,7 +1564,8 @@ fn remove<K: Ord, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n                 save.level -= 1;\n \n                 if right_level > save.level {\n-                    for x in save.right.mut_iter() { x.level = save.level }\n+                    let save_level = save.level;\n+                    for x in save.right.mut_iter() { x.level = save_level }\n                 }\n \n                 skew(save);"}, {"sha": "ec7ed91917730d68141cd8a8e33e0b0e1d7b7edb", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6136381ed86189a027e641d233a1296ff8b60679/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6136381ed86189a027e641d233a1296ff8b60679/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=6136381ed86189a027e641d233a1296ff8b60679", "patch": "@@ -783,7 +783,7 @@ fn insert<T>(count: &mut uint, child: &mut Child<T>, key: uint, value: T,\n             *child = External(key, value);\n             return None;\n         }\n-        Internal(ref mut x) => {\n+        Internal(box ref mut x) => {\n             return insert(&mut x.count, &mut x.children[chunk(key, idx)], key, value, idx + 1);\n         }\n         External(stored_key, ref mut stored_value) if stored_key == key => {\n@@ -799,11 +799,17 @@ fn insert<T>(count: &mut uint, child: &mut Child<T>, key: uint, value: T,\n     match mem::replace(child, Nothing) {\n         External(stored_key, stored_value) => {\n             let mut new = box TrieNode::new();\n-            insert(&mut new.count,\n-                   &mut new.children[chunk(stored_key, idx)],\n-                   stored_key, stored_value, idx + 1);\n-            let ret = insert(&mut new.count, &mut new.children[chunk(key, idx)],\n-                         key, value, idx + 1);\n+\n+            let ret = {\n+                let new_interior = &mut *new;\n+                insert(&mut new_interior.count,\n+                       &mut new_interior.children[chunk(stored_key, idx)],\n+                       stored_key, stored_value, idx + 1);\n+                insert(&mut new_interior.count,\n+                       &mut new_interior.children[chunk(key, idx)],\n+                       key, value, idx + 1)\n+            };\n+\n             *child = Internal(new);\n             return ret;\n         }\n@@ -821,7 +827,7 @@ fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,\n         }\n       }\n       External(..) => (None, false),\n-      Internal(ref mut x) => {\n+      Internal(box ref mut x) => {\n           let ret = remove(&mut x.count, &mut x.children[chunk(key, idx)],\n                            key, idx + 1);\n           (ret, x.count == 0)"}, {"sha": "7dec42538cffb625a7a331e3c9a1d71fe21a43f8", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6136381ed86189a027e641d233a1296ff8b60679/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6136381ed86189a027e641d233a1296ff8b60679/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=6136381ed86189a027e641d233a1296ff8b60679", "patch": "@@ -28,6 +28,57 @@ use util::ppaux::Repr;\n \n use std::rc::Rc;\n \n+// FIXME (#16118): These functions are intended to allow the borrow checker to\n+// be less precise in its handling of Box while still allowing moves out of a\n+// Box. They should be removed when OwnedPtr is removed from LoanPath.\n+\n+fn owned_ptr_base_path<'a>(loan_path: &'a LoanPath) -> &'a LoanPath {\n+    //! Returns the base of the leftmost dereference of an OwnedPtr in\n+    //! `loan_path`. If there is no dereference of an OwnedPtr in `loan_path`,\n+    //! then it just returns `loan_path` itself.\n+\n+    return match owned_ptr_base_path_helper(loan_path) {\n+        Some(new_loan_path) => new_loan_path,\n+        None => loan_path.clone()\n+    };\n+\n+    fn owned_ptr_base_path_helper<'a>(loan_path: &'a LoanPath) -> Option<&'a LoanPath> {\n+        match *loan_path {\n+            LpVar(_) | LpUpvar(_) => None,\n+            LpExtend(ref lp_base, _, LpDeref(mc::OwnedPtr)) => {\n+                match owned_ptr_base_path_helper(&**lp_base) {\n+                    v @ Some(_) => v,\n+                    None => Some(&**lp_base)\n+                }\n+            }\n+            LpExtend(ref lp_base, _, _) => owned_ptr_base_path_helper(&**lp_base)\n+        }\n+    }\n+}\n+\n+fn owned_ptr_base_path_rc(loan_path: &Rc<LoanPath>) -> Rc<LoanPath> {\n+    //! The equivalent of `owned_ptr_base_path` for an &Rc<LoanPath> rather than\n+    //! a &LoanPath.\n+\n+    return match owned_ptr_base_path_helper(loan_path) {\n+        Some(new_loan_path) => new_loan_path,\n+        None => loan_path.clone()\n+    };\n+\n+    fn owned_ptr_base_path_helper(loan_path: &Rc<LoanPath>) -> Option<Rc<LoanPath>> {\n+        match **loan_path {\n+            LpVar(_) | LpUpvar(_) => None,\n+            LpExtend(ref lp_base, _, LpDeref(mc::OwnedPtr)) => {\n+                match owned_ptr_base_path_helper(lp_base) {\n+                    v @ Some(_) => v,\n+                    None => Some(lp_base.clone())\n+                }\n+            }\n+            LpExtend(ref lp_base, _, _) => owned_ptr_base_path_helper(lp_base)\n+        }\n+    }\n+}\n+\n struct CheckLoanCtxt<'a> {\n     bccx: &'a BorrowckCtxt<'a>,\n     dfcx_loans: &'a LoanDataFlow<'a>,\n@@ -210,6 +261,7 @@ impl<'a> CheckLoanCtxt<'a> {\n         //     let x = &mut a.b.c; // Restricts a, a.b, and a.b.c\n         //     let y = a;          // Conflicts with restriction\n \n+        let loan_path = owned_ptr_base_path(loan_path);\n         let cont = self.each_in_scope_loan(scope_id, |loan| {\n             let mut ret = true;\n             for restr_path in loan.restricted_paths.iter() {\n@@ -344,8 +396,9 @@ impl<'a> CheckLoanCtxt<'a> {\n             return true;\n         }\n \n+        let loan2_base_path = owned_ptr_base_path_rc(&loan2.loan_path);\n         for restr_path in loan1.restricted_paths.iter() {\n-            if *restr_path != loan2.loan_path { continue; }\n+            if *restr_path != loan2_base_path { continue; }\n \n             let old_pronoun = if new_loan.loan_path == old_loan.loan_path {\n                 \"it\".to_string()\n@@ -597,7 +650,8 @@ impl<'a> CheckLoanCtxt<'a> {\n \n         debug!(\"check_if_path_is_moved(id={:?}, use_kind={:?}, lp={})\",\n                id, use_kind, lp.repr(self.bccx.tcx));\n-        self.move_data.each_move_of(id, lp, |move, moved_lp| {\n+        let base_lp = owned_ptr_base_path_rc(lp);\n+        self.move_data.each_move_of(id, &base_lp, |move, moved_lp| {\n             self.bccx.report_use_of_moved_value(\n                 span,\n                 use_kind,"}, {"sha": "32a16053fffcf3b0de1d6a780a55ae79f70f1c42", "filename": "src/libstd/collections/lru_cache.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6136381ed86189a027e641d233a1296ff8b60679/src%2Flibstd%2Fcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6136381ed86189a027e641d233a1296ff8b60679/src%2Flibstd%2Fcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Flru_cache.rs?ref=6136381ed86189a027e641d233a1296ff8b60679", "patch": "@@ -331,7 +331,8 @@ impl<K, V> Drop for LruCache<K, V> {\n         unsafe {\n             let node: Box<LruEntry<K, V>> = mem::transmute(self.head);\n             // Prevent compiler from trying to drop the un-initialized field in the sigil node.\n-            let box LruEntry { key: k, value: v, .. } = node;\n+            let box internal_node = node;\n+            let LruEntry { next: _, prev: _, key: k, value: v } = internal_node;\n             mem::forget(k);\n             mem::forget(v);\n         }"}, {"sha": "208f58f6b54c1956b35d071ddfa2932bdd32a1c4", "filename": "src/test/compile-fail/borrowck-borrow-from-owned-ptr.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6136381ed86189a027e641d233a1296ff8b60679/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6136381ed86189a027e641d233a1296ff8b60679/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs?ref=6136381ed86189a027e641d233a1296ff8b60679", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -52,14 +52,15 @@ fn borrow_same_field_twice_imm_imm() {\n fn borrow_both_fields_mut() {\n     let mut foo = make_foo();\n     let bar1 = &mut foo.bar1;\n-    let _bar2 = &mut foo.bar2;\n+    let _bar2 = &mut foo.bar2; //~ ERROR cannot borrow\n     *bar1;\n }\n \n fn borrow_both_mut_pattern() {\n     let mut foo = make_foo();\n     match *foo {\n         Foo { bar1: ref mut _bar1, bar2: ref mut _bar2 } => {}\n+        //~^ ERROR cannot borrow\n     }\n }\n \n@@ -120,7 +121,7 @@ fn borrow_imm_and_base_imm() {\n fn borrow_mut_and_imm() {\n     let mut foo = make_foo();\n     let bar1 = &mut foo.bar1;\n-    let _foo1 = &foo.bar2;\n+    let _foo1 = &foo.bar2; //~ ERROR cannot borrow\n     *bar1;\n }\n \n@@ -133,7 +134,7 @@ fn borrow_mut_from_imm() {\n fn borrow_long_path_both_mut() {\n     let mut foo = make_foo();\n     let bar1 = &mut foo.bar1.int1;\n-    let foo1 = &mut foo.bar2.int2;\n+    let foo1 = &mut foo.bar2.int2; //~ ERROR cannot borrow\n     *bar1;\n     *foo1;\n }"}, {"sha": "c9b384e0b007d7c7edfbf792d5e902a4b4169eab", "filename": "src/test/compile-fail/borrowck-box-insensitivity.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/6136381ed86189a027e641d233a1296ff8b60679/src%2Ftest%2Fcompile-fail%2Fborrowck-box-insensitivity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6136381ed86189a027e641d233a1296ff8b60679/src%2Ftest%2Fcompile-fail%2Fborrowck-box-insensitivity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-box-insensitivity.rs?ref=6136381ed86189a027e641d233a1296ff8b60679", "patch": "@@ -0,0 +1,150 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct A {\n+    x: Box<int>,\n+    y: int,\n+}\n+\n+struct B {\n+    x: Box<int>,\n+    y: Box<int>,\n+}\n+\n+struct C {\n+    x: Box<A>,\n+    y: int,\n+}\n+\n+struct D {\n+    x: Box<A>,\n+    y: Box<int>,\n+}\n+\n+fn copy_after_move() {\n+    let a = box A { x: box 0, y: 1 };\n+    let _x = a.x;\n+    let _y = a.y; //~ ERROR use of partially moved\n+}\n+\n+fn move_after_move() {\n+    let a = box B { x: box 0, y: box 1 };\n+    let _x = a.x;\n+    let _y = a.y; //~ ERROR use of partially moved\n+}\n+\n+fn borrow_after_move() {\n+    let a = box A { x: box 0, y: 1 };\n+    let _x = a.x;\n+    let _y = &a.y; //~ ERROR use of partially moved\n+}\n+\n+fn move_after_borrow() {\n+    let a = box B { x: box 0, y: box 1 };\n+    let _x = &a.x;\n+    let _y = a.y; //~ ERROR cannot move\n+}\n+\n+fn copy_after_mut_borrow() {\n+    let mut a = box A { x: box 0, y: 1 };\n+    let _x = &mut a.x;\n+    let _y = a.y; //~ ERROR cannot use\n+}\n+\n+fn move_after_mut_borrow() {\n+    let mut a = box B { x: box 0, y: box 1 };\n+    let _x = &mut a.x;\n+    let _y = a.y; //~ ERROR cannot move\n+}\n+\n+fn borrow_after_mut_borrow() {\n+    let mut a = box A { x: box 0, y: 1 };\n+    let _x = &mut a.x;\n+    let _y = &a.y; //~ ERROR cannot borrow\n+}\n+\n+fn mut_borrow_after_borrow() {\n+    let mut a = box A { x: box 0, y: 1 };\n+    let _x = &a.x;\n+    let _y = &mut a.y; //~ ERROR cannot borrow\n+}\n+\n+fn copy_after_move_nested() {\n+    let a = box C { x: box A { x: box 0, y: 1 }, y: 2 };\n+    let _x = a.x.x;\n+    let _y = a.y; //~ ERROR use of partially moved\n+}\n+\n+fn move_after_move_nested() {\n+    let a = box D { x: box A { x: box 0, y: 1 }, y: box 2 };\n+    let _x = a.x.x;\n+    let _y = a.y; //~ ERROR use of partially moved\n+}\n+\n+fn borrow_after_move_nested() {\n+    let a = box C { x: box A { x: box 0, y: 1 }, y: 2 };\n+    let _x = a.x.x;\n+    let _y = &a.y; //~ ERROR use of partially moved\n+}\n+\n+fn move_after_borrow_nested() {\n+    let a = box D { x: box A { x: box 0, y: 1 }, y: box 2 };\n+    let _x = &a.x.x;\n+    let _y = a.y; //~ ERROR cannot move\n+}\n+\n+fn copy_after_mut_borrow_nested() {\n+    let mut a = box C { x: box A { x: box 0, y: 1 }, y: 2 };\n+    let _x = &mut a.x.x;\n+    let _y = a.y; //~ ERROR cannot use\n+}\n+\n+fn move_after_mut_borrow_nested() {\n+    let mut a = box D { x: box A { x: box 0, y: 1 }, y: box 2 };\n+    let _x = &mut a.x.x;\n+    let _y = a.y; //~ ERROR cannot move\n+}\n+\n+fn borrow_after_mut_borrow_nested() {\n+    let mut a = box C { x: box A { x: box 0, y: 1 }, y: 2 };\n+    let _x = &mut a.x.x;\n+    let _y = &a.y; //~ ERROR cannot borrow\n+}\n+\n+fn mut_borrow_after_borrow_nested() {\n+    let mut a = box C { x: box A { x: box 0, y: 1 }, y: 2 };\n+    let _x = &a.x.x;\n+    let _y = &mut a.y; //~ ERROR cannot borrow\n+}\n+\n+fn main() {\n+    copy_after_move();\n+    move_after_move();\n+    borrow_after_move();\n+\n+    move_after_borrow();\n+\n+    copy_after_mut_borrow();\n+    move_after_mut_borrow();\n+    borrow_after_mut_borrow();\n+    mut_borrow_after_borrow();\n+\n+    copy_after_move_nested();\n+    move_after_move_nested();\n+    borrow_after_move_nested();\n+\n+    move_after_borrow_nested();\n+\n+    copy_after_mut_borrow_nested();\n+    move_after_mut_borrow_nested();\n+    borrow_after_mut_borrow_nested();\n+    mut_borrow_after_borrow_nested();\n+}\n+"}, {"sha": "0e7c959d58c333a969ef72a3ff1e44e5e0988844", "filename": "src/test/run-pass/match-implicit-copy-unique.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6136381ed86189a027e641d233a1296ff8b60679/src%2Ftest%2Frun-pass%2Fmatch-implicit-copy-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6136381ed86189a027e641d233a1296ff8b60679/src%2Ftest%2Frun-pass%2Fmatch-implicit-copy-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-implicit-copy-unique.rs?ref=6136381ed86189a027e641d233a1296ff8b60679", "patch": "@@ -13,8 +13,9 @@ struct Pair { a: Box<int>, b: Box<int> }\n \n pub fn main() {\n     let mut x = box Pair {a: box 10, b: box 20};\n-    match x {\n-      box Pair {a: ref mut a, b: ref mut _b} => {\n+    let x_internal = &mut *x;\n+    match *x_internal {\n+      Pair {a: ref mut a, b: ref mut _b} => {\n         assert!(**a == 10); *a = box 30; assert!(**a == 30);\n       }\n     }"}]}