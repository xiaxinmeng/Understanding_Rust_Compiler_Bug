{"sha": "0d77084effdffaaa05983281717681652e62f9b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkNzcwODRlZmZkZmZhYWEwNTk4MzI4MTcxNzY4MTY1MmU2MmY5YjI=", "commit": {"author": {"name": "chansuke", "email": "chansuke@georepublic.de", "date": "2019-06-05T16:44:33Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-16T11:17:01Z"}, "message": "Separate librustc_data_structures module", "tree": {"sha": "6826111ffb619038a164c2c539c485cda25e5a66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6826111ffb619038a164c2c539c485cda25e5a66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d77084effdffaaa05983281717681652e62f9b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d77084effdffaaa05983281717681652e62f9b2", "html_url": "https://github.com/rust-lang/rust/commit/0d77084effdffaaa05983281717681652e62f9b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d77084effdffaaa05983281717681652e62f9b2/comments", "author": null, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e35995042cb350b84c0d2d1ea916970ad6e5934", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e35995042cb350b84c0d2d1ea916970ad6e5934", "html_url": "https://github.com/rust-lang/rust/commit/7e35995042cb350b84c0d2d1ea916970ad6e5934"}], "stats": {"total": 1828, "additions": 913, "deletions": 915}, "files": [{"sha": "a7af615fa5000fae1423c087d2ebb2311c4c783b", "filename": "src/librustc_data_structures/owning_ref/mod.rs", "status": "modified", "additions": 1, "deletions": 714, "changes": 715, "blob_url": "https://github.com/rust-lang/rust/blob/0d77084effdffaaa05983281717681652e62f9b2/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d77084effdffaaa05983281717681652e62f9b2/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs?ref=0d77084effdffaaa05983281717681652e62f9b2", "patch": "@@ -1221,717 +1221,4 @@ pub type ErasedArcRef<U> = OwningRef<Arc<dyn Erased>, U>;\n pub type ErasedBoxRefMut<U> = OwningRefMut<Box<dyn Erased>, U>;\n \n #[cfg(test)]\n-mod tests {\n-    mod owning_ref {\n-        use super::super::OwningRef;\n-        use super::super::{RcRef, BoxRef, Erased, ErasedBoxRef};\n-        use std::cmp::{PartialEq, Ord, PartialOrd, Ordering};\n-        use std::hash::{Hash, Hasher};\n-        use std::collections::hash_map::DefaultHasher;\n-        use std::collections::HashMap;\n-        use std::rc::Rc;\n-\n-        #[derive(Debug, PartialEq)]\n-        struct Example(u32, String, [u8; 3]);\n-        fn example() -> Example {\n-            Example(42, \"hello world\".to_string(), [1, 2, 3])\n-        }\n-\n-        #[test]\n-        fn new_deref() {\n-            let or: OwningRef<Box<()>, ()> = OwningRef::new(Box::new(()));\n-            assert_eq!(&*or, &());\n-        }\n-\n-        #[test]\n-        fn into() {\n-            let or: OwningRef<Box<()>, ()> = Box::new(()).into();\n-            assert_eq!(&*or, &());\n-        }\n-\n-        #[test]\n-        fn map_offset_ref() {\n-            let or: BoxRef<Example> = Box::new(example()).into();\n-            let or: BoxRef<_, u32> = or.map(|x| &x.0);\n-            assert_eq!(&*or, &42);\n-\n-            let or: BoxRef<Example> = Box::new(example()).into();\n-            let or: BoxRef<_, u8> = or.map(|x| &x.2[1]);\n-            assert_eq!(&*or, &2);\n-        }\n-\n-        #[test]\n-        fn map_heap_ref() {\n-            let or: BoxRef<Example> = Box::new(example()).into();\n-            let or: BoxRef<_, str> = or.map(|x| &x.1[..5]);\n-            assert_eq!(&*or, \"hello\");\n-        }\n-\n-        #[test]\n-        fn map_static_ref() {\n-            let or: BoxRef<()> = Box::new(()).into();\n-            let or: BoxRef<_, str> = or.map(|_| \"hello\");\n-            assert_eq!(&*or, \"hello\");\n-        }\n-\n-        #[test]\n-        fn map_chained() {\n-            let or: BoxRef<String> = Box::new(example().1).into();\n-            let or: BoxRef<_, str> = or.map(|x| &x[1..5]);\n-            let or: BoxRef<_, str> = or.map(|x| &x[..2]);\n-            assert_eq!(&*or, \"el\");\n-        }\n-\n-        #[test]\n-        fn map_chained_inference() {\n-            let or = BoxRef::new(Box::new(example().1))\n-                .map(|x| &x[..5])\n-                .map(|x| &x[1..3]);\n-            assert_eq!(&*or, \"el\");\n-        }\n-\n-        #[test]\n-        fn owner() {\n-            let or: BoxRef<String> = Box::new(example().1).into();\n-            let or = or.map(|x| &x[..5]);\n-            assert_eq!(&*or, \"hello\");\n-            assert_eq!(&**or.owner(), \"hello world\");\n-        }\n-\n-        #[test]\n-        fn into_inner() {\n-            let or: BoxRef<String> = Box::new(example().1).into();\n-            let or = or.map(|x| &x[..5]);\n-            assert_eq!(&*or, \"hello\");\n-            let s = *or.into_inner();\n-            assert_eq!(&s, \"hello world\");\n-        }\n-\n-        #[test]\n-        fn fmt_debug() {\n-            let or: BoxRef<String> = Box::new(example().1).into();\n-            let or = or.map(|x| &x[..5]);\n-            let s = format!(\"{:?}\", or);\n-            assert_eq!(&s, \"OwningRef { owner: \\\"hello world\\\", reference: \\\"hello\\\" }\");\n-        }\n-\n-        #[test]\n-        fn erased_owner() {\n-            let o1: BoxRef<Example, str> = BoxRef::new(Box::new(example()))\n-                .map(|x| &x.1[..]);\n-\n-            let o2: BoxRef<String, str> = BoxRef::new(Box::new(example().1))\n-                .map(|x| &x[..]);\n-\n-            let os: Vec<ErasedBoxRef<str>> = vec![o1.erase_owner(), o2.erase_owner()];\n-            assert!(os.iter().all(|e| &e[..] == \"hello world\"));\n-        }\n-\n-        #[test]\n-        fn raii_locks() {\n-            use super::super::{RefRef, RefMutRef};\n-            use std::cell::RefCell;\n-            use super::super::{MutexGuardRef, RwLockReadGuardRef, RwLockWriteGuardRef};\n-            use std::sync::{Mutex, RwLock};\n-\n-            {\n-                let a = RefCell::new(1);\n-                let a = {\n-                    let a = RefRef::new(a.borrow());\n-                    assert_eq!(*a, 1);\n-                    a\n-                };\n-                assert_eq!(*a, 1);\n-                drop(a);\n-            }\n-            {\n-                let a = RefCell::new(1);\n-                let a = {\n-                    let a = RefMutRef::new(a.borrow_mut());\n-                    assert_eq!(*a, 1);\n-                    a\n-                };\n-                assert_eq!(*a, 1);\n-                drop(a);\n-            }\n-            {\n-                let a = Mutex::new(1);\n-                let a = {\n-                    let a = MutexGuardRef::new(a.lock().unwrap());\n-                    assert_eq!(*a, 1);\n-                    a\n-                };\n-                assert_eq!(*a, 1);\n-                drop(a);\n-            }\n-            {\n-                let a = RwLock::new(1);\n-                let a = {\n-                    let a = RwLockReadGuardRef::new(a.read().unwrap());\n-                    assert_eq!(*a, 1);\n-                    a\n-                };\n-                assert_eq!(*a, 1);\n-                drop(a);\n-            }\n-            {\n-                let a = RwLock::new(1);\n-                let a = {\n-                    let a = RwLockWriteGuardRef::new(a.write().unwrap());\n-                    assert_eq!(*a, 1);\n-                    a\n-                };\n-                assert_eq!(*a, 1);\n-                drop(a);\n-            }\n-        }\n-\n-        #[test]\n-        fn eq() {\n-            let or1: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-            let or2: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-            assert_eq!(or1.eq(&or2), true);\n-        }\n-\n-        #[test]\n-        fn cmp() {\n-            let or1: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-            let or2: BoxRef<[u8]> = BoxRef::new(vec![4, 5, 6].into_boxed_slice());\n-            assert_eq!(or1.cmp(&or2), Ordering::Less);\n-        }\n-\n-        #[test]\n-        fn partial_cmp() {\n-            let or1: BoxRef<[u8]> = BoxRef::new(vec![4, 5, 6].into_boxed_slice());\n-            let or2: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-            assert_eq!(or1.partial_cmp(&or2), Some(Ordering::Greater));\n-        }\n-\n-        #[test]\n-        fn hash() {\n-            let mut h1 = DefaultHasher::new();\n-            let mut h2 = DefaultHasher::new();\n-\n-            let or1: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-            let or2: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-\n-            or1.hash(&mut h1);\n-            or2.hash(&mut h2);\n-\n-            assert_eq!(h1.finish(), h2.finish());\n-        }\n-\n-        #[test]\n-        fn borrow() {\n-            let mut hash = HashMap::new();\n-            let     key  = RcRef::<String>::new(Rc::new(\"foo-bar\".to_string())).map(|s| &s[..]);\n-\n-            hash.insert(key.clone().map(|s| &s[..3]), 42);\n-            hash.insert(key.clone().map(|s| &s[4..]), 23);\n-\n-            assert_eq!(hash.get(\"foo\"), Some(&42));\n-            assert_eq!(hash.get(\"bar\"), Some(&23));\n-        }\n-\n-        #[test]\n-        fn total_erase() {\n-            let a: OwningRef<Vec<u8>, [u8]>\n-                = OwningRef::new(vec![]).map(|x| &x[..]);\n-            let b: OwningRef<Box<[u8]>, [u8]>\n-                = OwningRef::new(vec![].into_boxed_slice()).map(|x| &x[..]);\n-\n-            let c: OwningRef<Rc<Vec<u8>>, [u8]> = unsafe {a.map_owner(Rc::new)};\n-            let d: OwningRef<Rc<Box<[u8]>>, [u8]> = unsafe {b.map_owner(Rc::new)};\n-\n-            let e: OwningRef<Rc<dyn Erased>, [u8]> = c.erase_owner();\n-            let f: OwningRef<Rc<dyn Erased>, [u8]> = d.erase_owner();\n-\n-            let _g = e.clone();\n-            let _h = f.clone();\n-        }\n-\n-        #[test]\n-        fn total_erase_box() {\n-            let a: OwningRef<Vec<u8>, [u8]>\n-                = OwningRef::new(vec![]).map(|x| &x[..]);\n-            let b: OwningRef<Box<[u8]>, [u8]>\n-                = OwningRef::new(vec![].into_boxed_slice()).map(|x| &x[..]);\n-\n-            let c: OwningRef<Box<Vec<u8>>, [u8]> = a.map_owner_box();\n-            let d: OwningRef<Box<Box<[u8]>>, [u8]> = b.map_owner_box();\n-\n-            let _e: OwningRef<Box<dyn Erased>, [u8]> = c.erase_owner();\n-            let _f: OwningRef<Box<dyn Erased>, [u8]> = d.erase_owner();\n-        }\n-\n-        #[test]\n-        fn try_map1() {\n-            use std::any::Any;\n-\n-            let x = Box::new(123_i32);\n-            let y: Box<dyn Any> = x;\n-\n-            assert!(OwningRef::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_ok());\n-        }\n-\n-        #[test]\n-        fn try_map2() {\n-            use std::any::Any;\n-\n-            let x = Box::new(123_i32);\n-            let y: Box<dyn Any> = x;\n-\n-            assert!(!OwningRef::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_err());\n-        }\n-    }\n-\n-    mod owning_handle {\n-        use super::super::OwningHandle;\n-        use super::super::RcRef;\n-        use std::rc::Rc;\n-        use std::cell::RefCell;\n-        use std::sync::Arc;\n-        use std::sync::RwLock;\n-\n-        #[test]\n-        fn owning_handle() {\n-            use std::cell::RefCell;\n-            let cell = Rc::new(RefCell::new(2));\n-            let cell_ref = RcRef::new(cell);\n-            let mut handle = OwningHandle::new_with_fn(cell_ref, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n-            assert_eq!(*handle, 2);\n-            *handle = 3;\n-            assert_eq!(*handle, 3);\n-        }\n-\n-        #[test]\n-        fn try_owning_handle_ok() {\n-            use std::cell::RefCell;\n-            let cell = Rc::new(RefCell::new(2));\n-            let cell_ref = RcRef::new(cell);\n-            let mut handle = OwningHandle::try_new::<_, ()>(cell_ref, |x| {\n-                Ok(unsafe {\n-                    x.as_ref()\n-                }.unwrap().borrow_mut())\n-            }).unwrap();\n-            assert_eq!(*handle, 2);\n-            *handle = 3;\n-            assert_eq!(*handle, 3);\n-        }\n-\n-        #[test]\n-        fn try_owning_handle_err() {\n-            use std::cell::RefCell;\n-            let cell = Rc::new(RefCell::new(2));\n-            let cell_ref = RcRef::new(cell);\n-            let handle = OwningHandle::try_new::<_, ()>(cell_ref, |x| {\n-                if false {\n-                    return Ok(unsafe {\n-                        x.as_ref()\n-                    }.unwrap().borrow_mut())\n-                }\n-                Err(())\n-            });\n-            assert!(handle.is_err());\n-        }\n-\n-        #[test]\n-        fn nested() {\n-            use std::cell::RefCell;\n-            use std::sync::{Arc, RwLock};\n-\n-            let result = {\n-                let complex = Rc::new(RefCell::new(Arc::new(RwLock::new(\"someString\"))));\n-                let curr = RcRef::new(complex);\n-                let curr = OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n-                let mut curr = OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().try_write().unwrap());\n-                assert_eq!(*curr, \"someString\");\n-                *curr = \"someOtherString\";\n-                curr\n-            };\n-            assert_eq!(*result, \"someOtherString\");\n-        }\n-\n-        #[test]\n-        fn owning_handle_safe() {\n-            use std::cell::RefCell;\n-            let cell = Rc::new(RefCell::new(2));\n-            let cell_ref = RcRef::new(cell);\n-            let handle = OwningHandle::new(cell_ref);\n-            assert_eq!(*handle, 2);\n-        }\n-\n-        #[test]\n-        fn owning_handle_mut_safe() {\n-            use std::cell::RefCell;\n-            let cell = Rc::new(RefCell::new(2));\n-            let cell_ref = RcRef::new(cell);\n-            let mut handle = OwningHandle::new_mut(cell_ref);\n-            assert_eq!(*handle, 2);\n-            *handle = 3;\n-            assert_eq!(*handle, 3);\n-        }\n-\n-        #[test]\n-        fn owning_handle_safe_2() {\n-            let result = {\n-                let complex = Rc::new(RefCell::new(Arc::new(RwLock::new(\"someString\"))));\n-                let curr = RcRef::new(complex);\n-                let curr = OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n-                let mut curr = OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().try_write().unwrap());\n-                assert_eq!(*curr, \"someString\");\n-                *curr = \"someOtherString\";\n-                curr\n-            };\n-            assert_eq!(*result, \"someOtherString\");\n-        }\n-    }\n-\n-    mod owning_ref_mut {\n-        use super::super::{OwningRefMut, BoxRefMut, Erased, ErasedBoxRefMut};\n-        use super::super::BoxRef;\n-        use std::cmp::{PartialEq, Ord, PartialOrd, Ordering};\n-        use std::hash::{Hash, Hasher};\n-        use std::collections::hash_map::DefaultHasher;\n-        use std::collections::HashMap;\n-\n-        #[derive(Debug, PartialEq)]\n-        struct Example(u32, String, [u8; 3]);\n-        fn example() -> Example {\n-            Example(42, \"hello world\".to_string(), [1, 2, 3])\n-        }\n-\n-        #[test]\n-        fn new_deref() {\n-            let or: OwningRefMut<Box<()>, ()> = OwningRefMut::new(Box::new(()));\n-            assert_eq!(&*or, &());\n-        }\n-\n-        #[test]\n-        fn new_deref_mut() {\n-            let mut or: OwningRefMut<Box<()>, ()> = OwningRefMut::new(Box::new(()));\n-            assert_eq!(&mut *or, &mut ());\n-        }\n-\n-        #[test]\n-        fn mutate() {\n-            let mut or: OwningRefMut<Box<usize>, usize> = OwningRefMut::new(Box::new(0));\n-            assert_eq!(&*or, &0);\n-            *or = 1;\n-            assert_eq!(&*or, &1);\n-        }\n-\n-        #[test]\n-        fn into() {\n-            let or: OwningRefMut<Box<()>, ()> = Box::new(()).into();\n-            assert_eq!(&*or, &());\n-        }\n-\n-        #[test]\n-        fn map_offset_ref() {\n-            let or: BoxRefMut<Example> = Box::new(example()).into();\n-            let or: BoxRef<_, u32> = or.map(|x| &mut x.0);\n-            assert_eq!(&*or, &42);\n-\n-            let or: BoxRefMut<Example> = Box::new(example()).into();\n-            let or: BoxRef<_, u8> = or.map(|x| &mut x.2[1]);\n-            assert_eq!(&*or, &2);\n-        }\n-\n-        #[test]\n-        fn map_heap_ref() {\n-            let or: BoxRefMut<Example> = Box::new(example()).into();\n-            let or: BoxRef<_, str> = or.map(|x| &mut x.1[..5]);\n-            assert_eq!(&*or, \"hello\");\n-        }\n-\n-        #[test]\n-        fn map_static_ref() {\n-            let or: BoxRefMut<()> = Box::new(()).into();\n-            let or: BoxRef<_, str> = or.map(|_| \"hello\");\n-            assert_eq!(&*or, \"hello\");\n-        }\n-\n-        #[test]\n-        fn map_mut_offset_ref() {\n-            let or: BoxRefMut<Example> = Box::new(example()).into();\n-            let or: BoxRefMut<_, u32> = or.map_mut(|x| &mut x.0);\n-            assert_eq!(&*or, &42);\n-\n-            let or: BoxRefMut<Example> = Box::new(example()).into();\n-            let or: BoxRefMut<_, u8> = or.map_mut(|x| &mut x.2[1]);\n-            assert_eq!(&*or, &2);\n-        }\n-\n-        #[test]\n-        fn map_mut_heap_ref() {\n-            let or: BoxRefMut<Example> = Box::new(example()).into();\n-            let or: BoxRefMut<_, str> = or.map_mut(|x| &mut x.1[..5]);\n-            assert_eq!(&*or, \"hello\");\n-        }\n-\n-        #[test]\n-        fn map_mut_static_ref() {\n-            static mut MUT_S: [u8; 5] = *b\"hello\";\n-\n-            let mut_s: &'static mut [u8] = unsafe { &mut MUT_S };\n-\n-            let or: BoxRefMut<()> = Box::new(()).into();\n-            let or: BoxRefMut<_, [u8]> = or.map_mut(move |_| mut_s);\n-            assert_eq!(&*or, b\"hello\");\n-        }\n-\n-        #[test]\n-        fn map_mut_chained() {\n-            let or: BoxRefMut<String> = Box::new(example().1).into();\n-            let or: BoxRefMut<_, str> = or.map_mut(|x| &mut x[1..5]);\n-            let or: BoxRefMut<_, str> = or.map_mut(|x| &mut x[..2]);\n-            assert_eq!(&*or, \"el\");\n-        }\n-\n-        #[test]\n-        fn map_chained_inference() {\n-            let or = BoxRefMut::new(Box::new(example().1))\n-                .map_mut(|x| &mut x[..5])\n-                .map_mut(|x| &mut x[1..3]);\n-            assert_eq!(&*or, \"el\");\n-        }\n-\n-        #[test]\n-        fn try_map_mut() {\n-            let or: BoxRefMut<String> = Box::new(example().1).into();\n-            let or: Result<BoxRefMut<_, str>, ()> = or.try_map_mut(|x| Ok(&mut x[1..5]));\n-            assert_eq!(&*or.unwrap(), \"ello\");\n-\n-            let or: BoxRefMut<String> = Box::new(example().1).into();\n-            let or: Result<BoxRefMut<_, str>, ()> = or.try_map_mut(|_| Err(()));\n-            assert!(or.is_err());\n-        }\n-\n-        #[test]\n-        fn owner() {\n-            let or: BoxRefMut<String> = Box::new(example().1).into();\n-            let or = or.map_mut(|x| &mut x[..5]);\n-            assert_eq!(&*or, \"hello\");\n-            assert_eq!(&**or.owner(), \"hello world\");\n-        }\n-\n-        #[test]\n-        fn into_inner() {\n-            let or: BoxRefMut<String> = Box::new(example().1).into();\n-            let or = or.map_mut(|x| &mut x[..5]);\n-            assert_eq!(&*or, \"hello\");\n-            let s = *or.into_inner();\n-            assert_eq!(&s, \"hello world\");\n-        }\n-\n-        #[test]\n-        fn fmt_debug() {\n-            let or: BoxRefMut<String> = Box::new(example().1).into();\n-            let or = or.map_mut(|x| &mut x[..5]);\n-            let s = format!(\"{:?}\", or);\n-            assert_eq!(&s,\n-                       \"OwningRefMut { owner: \\\"hello world\\\", reference: \\\"hello\\\" }\");\n-        }\n-\n-        #[test]\n-        fn erased_owner() {\n-            let o1: BoxRefMut<Example, str> = BoxRefMut::new(Box::new(example()))\n-                .map_mut(|x| &mut x.1[..]);\n-\n-            let o2: BoxRefMut<String, str> = BoxRefMut::new(Box::new(example().1))\n-                .map_mut(|x| &mut x[..]);\n-\n-            let os: Vec<ErasedBoxRefMut<str>> = vec![o1.erase_owner(), o2.erase_owner()];\n-            assert!(os.iter().all(|e| &e[..] == \"hello world\"));\n-        }\n-\n-        #[test]\n-        fn raii_locks() {\n-            use super::super::RefMutRefMut;\n-            use std::cell::RefCell;\n-            use super::super::{MutexGuardRefMut, RwLockWriteGuardRefMut};\n-            use std::sync::{Mutex, RwLock};\n-\n-            {\n-                let a = RefCell::new(1);\n-                let a = {\n-                    let a = RefMutRefMut::new(a.borrow_mut());\n-                    assert_eq!(*a, 1);\n-                    a\n-                };\n-                assert_eq!(*a, 1);\n-                drop(a);\n-            }\n-            {\n-                let a = Mutex::new(1);\n-                let a = {\n-                    let a = MutexGuardRefMut::new(a.lock().unwrap());\n-                    assert_eq!(*a, 1);\n-                    a\n-                };\n-                assert_eq!(*a, 1);\n-                drop(a);\n-            }\n-            {\n-                let a = RwLock::new(1);\n-                let a = {\n-                    let a = RwLockWriteGuardRefMut::new(a.write().unwrap());\n-                    assert_eq!(*a, 1);\n-                    a\n-                };\n-                assert_eq!(*a, 1);\n-                drop(a);\n-            }\n-        }\n-\n-        #[test]\n-        fn eq() {\n-            let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-            let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-            assert_eq!(or1.eq(&or2), true);\n-        }\n-\n-        #[test]\n-        fn cmp() {\n-            let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-            let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![4, 5, 6].into_boxed_slice());\n-            assert_eq!(or1.cmp(&or2), Ordering::Less);\n-        }\n-\n-        #[test]\n-        fn partial_cmp() {\n-            let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![4, 5, 6].into_boxed_slice());\n-            let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-            assert_eq!(or1.partial_cmp(&or2), Some(Ordering::Greater));\n-        }\n-\n-        #[test]\n-        fn hash() {\n-            let mut h1 = DefaultHasher::new();\n-            let mut h2 = DefaultHasher::new();\n-\n-            let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-            let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-\n-            or1.hash(&mut h1);\n-            or2.hash(&mut h2);\n-\n-            assert_eq!(h1.finish(), h2.finish());\n-        }\n-\n-        #[test]\n-        fn borrow() {\n-            let mut hash = HashMap::new();\n-            let     key1 = BoxRefMut::<String>::new(Box::new(\"foo\".to_string())).map(|s| &s[..]);\n-            let     key2 = BoxRefMut::<String>::new(Box::new(\"bar\".to_string())).map(|s| &s[..]);\n-\n-            hash.insert(key1, 42);\n-            hash.insert(key2, 23);\n-\n-            assert_eq!(hash.get(\"foo\"), Some(&42));\n-            assert_eq!(hash.get(\"bar\"), Some(&23));\n-        }\n-\n-        #[test]\n-        fn total_erase() {\n-            let a: OwningRefMut<Vec<u8>, [u8]>\n-                = OwningRefMut::new(vec![]).map_mut(|x| &mut x[..]);\n-            let b: OwningRefMut<Box<[u8]>, [u8]>\n-                = OwningRefMut::new(vec![].into_boxed_slice()).map_mut(|x| &mut x[..]);\n-\n-            let c: OwningRefMut<Box<Vec<u8>>, [u8]> = unsafe {a.map_owner(Box::new)};\n-            let d: OwningRefMut<Box<Box<[u8]>>, [u8]> = unsafe {b.map_owner(Box::new)};\n-\n-            let _e: OwningRefMut<Box<dyn Erased>, [u8]> = c.erase_owner();\n-            let _f: OwningRefMut<Box<dyn Erased>, [u8]> = d.erase_owner();\n-        }\n-\n-        #[test]\n-        fn total_erase_box() {\n-            let a: OwningRefMut<Vec<u8>, [u8]>\n-                = OwningRefMut::new(vec![]).map_mut(|x| &mut x[..]);\n-            let b: OwningRefMut<Box<[u8]>, [u8]>\n-                = OwningRefMut::new(vec![].into_boxed_slice()).map_mut(|x| &mut x[..]);\n-\n-            let c: OwningRefMut<Box<Vec<u8>>, [u8]> = a.map_owner_box();\n-            let d: OwningRefMut<Box<Box<[u8]>>, [u8]> = b.map_owner_box();\n-\n-            let _e: OwningRefMut<Box<dyn Erased>, [u8]> = c.erase_owner();\n-            let _f: OwningRefMut<Box<dyn Erased>, [u8]> = d.erase_owner();\n-        }\n-\n-        #[test]\n-        fn try_map1() {\n-            use std::any::Any;\n-\n-            let x = Box::new(123_i32);\n-            let y: Box<dyn Any> = x;\n-\n-            assert!(OwningRefMut::new(y).try_map_mut(|x| x.downcast_mut::<i32>().ok_or(())).is_ok());\n-        }\n-\n-        #[test]\n-        fn try_map2() {\n-            use std::any::Any;\n-\n-            let x = Box::new(123_i32);\n-            let y: Box<dyn Any> = x;\n-\n-            assert!(!OwningRefMut::new(y).try_map_mut(|x| x.downcast_mut::<i32>().ok_or(())).is_err());\n-        }\n-\n-        #[test]\n-        fn try_map3() {\n-            use std::any::Any;\n-\n-            let x = Box::new(123_i32);\n-            let y: Box<dyn Any> = x;\n-\n-            assert!(OwningRefMut::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_ok());\n-        }\n-\n-        #[test]\n-        fn try_map4() {\n-            use std::any::Any;\n-\n-            let x = Box::new(123_i32);\n-            let y: Box<dyn Any> = x;\n-\n-            assert!(!OwningRefMut::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_err());\n-        }\n-\n-        #[test]\n-        fn into_owning_ref() {\n-            use super::super::BoxRef;\n-\n-            let or: BoxRefMut<()> = Box::new(()).into();\n-            let or: BoxRef<()> = or.into();\n-            assert_eq!(&*or, &());\n-        }\n-\n-        struct Foo {\n-            u: u32,\n-        }\n-        struct Bar {\n-            f: Foo,\n-        }\n-\n-        #[test]\n-        fn ref_mut() {\n-            use std::cell::RefCell;\n-\n-            let a = RefCell::new(Bar { f: Foo { u: 42 } });\n-            let mut b = OwningRefMut::new(a.borrow_mut());\n-            assert_eq!(b.f.u, 42);\n-            b.f.u = 43;\n-            let mut c = b.map_mut(|x| &mut x.f);\n-            assert_eq!(c.u, 43);\n-            c.u = 44;\n-            let mut d = c.map_mut(|x| &mut x.u);\n-            assert_eq!(*d, 44);\n-            *d = 45;\n-            assert_eq!(*d, 45);\n-        }\n-    }\n-}\n+mod tests;"}, {"sha": "d368219cab3eb3fd090de5581bddfcb58a7b6f7d", "filename": "src/librustc_data_structures/owning_ref/tests.rs", "status": "added", "additions": 712, "deletions": 0, "changes": 712, "blob_url": "https://github.com/rust-lang/rust/blob/0d77084effdffaaa05983281717681652e62f9b2/src%2Flibrustc_data_structures%2Fowning_ref%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d77084effdffaaa05983281717681652e62f9b2/src%2Flibrustc_data_structures%2Fowning_ref%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fowning_ref%2Ftests.rs?ref=0d77084effdffaaa05983281717681652e62f9b2", "patch": "@@ -0,0 +1,712 @@\n+mod owning_ref {\n+    use super::super::OwningRef;\n+    use super::super::{RcRef, BoxRef, Erased, ErasedBoxRef};\n+    use std::cmp::{PartialEq, Ord, PartialOrd, Ordering};\n+    use std::hash::{Hash, Hasher};\n+    use std::collections::hash_map::DefaultHasher;\n+    use std::collections::HashMap;\n+    use std::rc::Rc;\n+\n+    #[derive(Debug, PartialEq)]\n+    struct Example(u32, String, [u8; 3]);\n+    fn example() -> Example {\n+        Example(42, \"hello world\".to_string(), [1, 2, 3])\n+    }\n+\n+    #[test]\n+    fn new_deref() {\n+        let or: OwningRef<Box<()>, ()> = OwningRef::new(Box::new(()));\n+        assert_eq!(&*or, &());\n+    }\n+\n+    #[test]\n+    fn into() {\n+        let or: OwningRef<Box<()>, ()> = Box::new(()).into();\n+        assert_eq!(&*or, &());\n+    }\n+\n+    #[test]\n+    fn map_offset_ref() {\n+        let or: BoxRef<Example> = Box::new(example()).into();\n+        let or: BoxRef<_, u32> = or.map(|x| &x.0);\n+        assert_eq!(&*or, &42);\n+\n+        let or: BoxRef<Example> = Box::new(example()).into();\n+        let or: BoxRef<_, u8> = or.map(|x| &x.2[1]);\n+        assert_eq!(&*or, &2);\n+    }\n+\n+    #[test]\n+    fn map_heap_ref() {\n+        let or: BoxRef<Example> = Box::new(example()).into();\n+        let or: BoxRef<_, str> = or.map(|x| &x.1[..5]);\n+        assert_eq!(&*or, \"hello\");\n+    }\n+\n+    #[test]\n+    fn map_static_ref() {\n+        let or: BoxRef<()> = Box::new(()).into();\n+        let or: BoxRef<_, str> = or.map(|_| \"hello\");\n+        assert_eq!(&*or, \"hello\");\n+    }\n+\n+    #[test]\n+    fn map_chained() {\n+        let or: BoxRef<String> = Box::new(example().1).into();\n+        let or: BoxRef<_, str> = or.map(|x| &x[1..5]);\n+        let or: BoxRef<_, str> = or.map(|x| &x[..2]);\n+        assert_eq!(&*or, \"el\");\n+    }\n+\n+    #[test]\n+    fn map_chained_inference() {\n+        let or = BoxRef::new(Box::new(example().1))\n+            .map(|x| &x[..5])\n+            .map(|x| &x[1..3]);\n+        assert_eq!(&*or, \"el\");\n+    }\n+\n+    #[test]\n+    fn owner() {\n+        let or: BoxRef<String> = Box::new(example().1).into();\n+        let or = or.map(|x| &x[..5]);\n+        assert_eq!(&*or, \"hello\");\n+        assert_eq!(&**or.owner(), \"hello world\");\n+    }\n+\n+    #[test]\n+    fn into_inner() {\n+        let or: BoxRef<String> = Box::new(example().1).into();\n+        let or = or.map(|x| &x[..5]);\n+        assert_eq!(&*or, \"hello\");\n+        let s = *or.into_inner();\n+        assert_eq!(&s, \"hello world\");\n+    }\n+\n+    #[test]\n+    fn fmt_debug() {\n+        let or: BoxRef<String> = Box::new(example().1).into();\n+        let or = or.map(|x| &x[..5]);\n+        let s = format!(\"{:?}\", or);\n+        assert_eq!(&s, \"OwningRef { owner: \\\"hello world\\\", reference: \\\"hello\\\" }\");\n+    }\n+\n+    #[test]\n+    fn erased_owner() {\n+        let o1: BoxRef<Example, str> = BoxRef::new(Box::new(example()))\n+            .map(|x| &x.1[..]);\n+\n+        let o2: BoxRef<String, str> = BoxRef::new(Box::new(example().1))\n+            .map(|x| &x[..]);\n+\n+        let os: Vec<ErasedBoxRef<str>> = vec![o1.erase_owner(), o2.erase_owner()];\n+        assert!(os.iter().all(|e| &e[..] == \"hello world\"));\n+    }\n+\n+    #[test]\n+    fn raii_locks() {\n+        use super::super::{RefRef, RefMutRef};\n+        use std::cell::RefCell;\n+        use super::super::{MutexGuardRef, RwLockReadGuardRef, RwLockWriteGuardRef};\n+        use std::sync::{Mutex, RwLock};\n+\n+        {\n+            let a = RefCell::new(1);\n+            let a = {\n+                let a = RefRef::new(a.borrow());\n+                assert_eq!(*a, 1);\n+                a\n+            };\n+            assert_eq!(*a, 1);\n+            drop(a);\n+        }\n+        {\n+            let a = RefCell::new(1);\n+            let a = {\n+                let a = RefMutRef::new(a.borrow_mut());\n+                assert_eq!(*a, 1);\n+                a\n+            };\n+            assert_eq!(*a, 1);\n+            drop(a);\n+        }\n+        {\n+            let a = Mutex::new(1);\n+            let a = {\n+                let a = MutexGuardRef::new(a.lock().unwrap());\n+                assert_eq!(*a, 1);\n+                a\n+            };\n+            assert_eq!(*a, 1);\n+            drop(a);\n+        }\n+        {\n+            let a = RwLock::new(1);\n+            let a = {\n+                let a = RwLockReadGuardRef::new(a.read().unwrap());\n+                assert_eq!(*a, 1);\n+                a\n+            };\n+            assert_eq!(*a, 1);\n+            drop(a);\n+        }\n+        {\n+            let a = RwLock::new(1);\n+            let a = {\n+                let a = RwLockWriteGuardRef::new(a.write().unwrap());\n+                assert_eq!(*a, 1);\n+                a\n+            };\n+            assert_eq!(*a, 1);\n+            drop(a);\n+        }\n+    }\n+\n+    #[test]\n+    fn eq() {\n+        let or1: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n+        let or2: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n+        assert_eq!(or1.eq(&or2), true);\n+    }\n+\n+    #[test]\n+    fn cmp() {\n+        let or1: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n+        let or2: BoxRef<[u8]> = BoxRef::new(vec![4, 5, 6].into_boxed_slice());\n+        assert_eq!(or1.cmp(&or2), Ordering::Less);\n+    }\n+\n+    #[test]\n+    fn partial_cmp() {\n+        let or1: BoxRef<[u8]> = BoxRef::new(vec![4, 5, 6].into_boxed_slice());\n+        let or2: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n+        assert_eq!(or1.partial_cmp(&or2), Some(Ordering::Greater));\n+    }\n+\n+    #[test]\n+    fn hash() {\n+        let mut h1 = DefaultHasher::new();\n+        let mut h2 = DefaultHasher::new();\n+\n+        let or1: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n+        let or2: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n+\n+        or1.hash(&mut h1);\n+        or2.hash(&mut h2);\n+\n+        assert_eq!(h1.finish(), h2.finish());\n+    }\n+\n+    #[test]\n+    fn borrow() {\n+        let mut hash = HashMap::new();\n+        let     key  = RcRef::<String>::new(Rc::new(\"foo-bar\".to_string())).map(|s| &s[..]);\n+\n+        hash.insert(key.clone().map(|s| &s[..3]), 42);\n+        hash.insert(key.clone().map(|s| &s[4..]), 23);\n+\n+        assert_eq!(hash.get(\"foo\"), Some(&42));\n+        assert_eq!(hash.get(\"bar\"), Some(&23));\n+    }\n+\n+    #[test]\n+    fn total_erase() {\n+        let a: OwningRef<Vec<u8>, [u8]>\n+            = OwningRef::new(vec![]).map(|x| &x[..]);\n+        let b: OwningRef<Box<[u8]>, [u8]>\n+            = OwningRef::new(vec![].into_boxed_slice()).map(|x| &x[..]);\n+\n+        let c: OwningRef<Rc<Vec<u8>>, [u8]> = unsafe {a.map_owner(Rc::new)};\n+        let d: OwningRef<Rc<Box<[u8]>>, [u8]> = unsafe {b.map_owner(Rc::new)};\n+\n+        let e: OwningRef<Rc<dyn Erased>, [u8]> = c.erase_owner();\n+        let f: OwningRef<Rc<dyn Erased>, [u8]> = d.erase_owner();\n+\n+        let _g = e.clone();\n+        let _h = f.clone();\n+    }\n+\n+    #[test]\n+    fn total_erase_box() {\n+        let a: OwningRef<Vec<u8>, [u8]>\n+            = OwningRef::new(vec![]).map(|x| &x[..]);\n+        let b: OwningRef<Box<[u8]>, [u8]>\n+            = OwningRef::new(vec![].into_boxed_slice()).map(|x| &x[..]);\n+\n+        let c: OwningRef<Box<Vec<u8>>, [u8]> = a.map_owner_box();\n+        let d: OwningRef<Box<Box<[u8]>>, [u8]> = b.map_owner_box();\n+\n+        let _e: OwningRef<Box<dyn Erased>, [u8]> = c.erase_owner();\n+        let _f: OwningRef<Box<dyn Erased>, [u8]> = d.erase_owner();\n+    }\n+\n+    #[test]\n+    fn try_map1() {\n+        use std::any::Any;\n+\n+        let x = Box::new(123_i32);\n+        let y: Box<dyn Any> = x;\n+\n+        assert!(OwningRef::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_ok());\n+    }\n+\n+    #[test]\n+    fn try_map2() {\n+        use std::any::Any;\n+\n+        let x = Box::new(123_i32);\n+        let y: Box<dyn Any> = x;\n+\n+        assert!(!OwningRef::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_err());\n+    }\n+}\n+\n+mod owning_handle {\n+    use super::super::OwningHandle;\n+    use super::super::RcRef;\n+    use std::rc::Rc;\n+    use std::cell::RefCell;\n+    use std::sync::Arc;\n+    use std::sync::RwLock;\n+\n+    #[test]\n+    fn owning_handle() {\n+        use std::cell::RefCell;\n+        let cell = Rc::new(RefCell::new(2));\n+        let cell_ref = RcRef::new(cell);\n+        let mut handle = OwningHandle::new_with_fn(cell_ref, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n+        assert_eq!(*handle, 2);\n+        *handle = 3;\n+        assert_eq!(*handle, 3);\n+    }\n+\n+    #[test]\n+    fn try_owning_handle_ok() {\n+        use std::cell::RefCell;\n+        let cell = Rc::new(RefCell::new(2));\n+        let cell_ref = RcRef::new(cell);\n+        let mut handle = OwningHandle::try_new::<_, ()>(cell_ref, |x| {\n+            Ok(unsafe {\n+                x.as_ref()\n+            }.unwrap().borrow_mut())\n+        }).unwrap();\n+        assert_eq!(*handle, 2);\n+        *handle = 3;\n+        assert_eq!(*handle, 3);\n+    }\n+\n+    #[test]\n+    fn try_owning_handle_err() {\n+        use std::cell::RefCell;\n+        let cell = Rc::new(RefCell::new(2));\n+        let cell_ref = RcRef::new(cell);\n+        let handle = OwningHandle::try_new::<_, ()>(cell_ref, |x| {\n+            if false {\n+                return Ok(unsafe {\n+                    x.as_ref()\n+                }.unwrap().borrow_mut())\n+            }\n+            Err(())\n+        });\n+        assert!(handle.is_err());\n+    }\n+\n+    #[test]\n+    fn nested() {\n+        use std::cell::RefCell;\n+        use std::sync::{Arc, RwLock};\n+\n+        let result = {\n+            let complex = Rc::new(RefCell::new(Arc::new(RwLock::new(\"someString\"))));\n+            let curr = RcRef::new(complex);\n+            let curr = OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n+            let mut curr = OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().try_write().unwrap());\n+            assert_eq!(*curr, \"someString\");\n+            *curr = \"someOtherString\";\n+            curr\n+        };\n+        assert_eq!(*result, \"someOtherString\");\n+    }\n+\n+    #[test]\n+    fn owning_handle_safe() {\n+        use std::cell::RefCell;\n+        let cell = Rc::new(RefCell::new(2));\n+        let cell_ref = RcRef::new(cell);\n+        let handle = OwningHandle::new(cell_ref);\n+        assert_eq!(*handle, 2);\n+    }\n+\n+    #[test]\n+    fn owning_handle_mut_safe() {\n+        use std::cell::RefCell;\n+        let cell = Rc::new(RefCell::new(2));\n+        let cell_ref = RcRef::new(cell);\n+        let mut handle = OwningHandle::new_mut(cell_ref);\n+        assert_eq!(*handle, 2);\n+        *handle = 3;\n+        assert_eq!(*handle, 3);\n+    }\n+\n+    #[test]\n+    fn owning_handle_safe_2() {\n+        let result = {\n+            let complex = Rc::new(RefCell::new(Arc::new(RwLock::new(\"someString\"))));\n+            let curr = RcRef::new(complex);\n+            let curr = OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n+            let mut curr = OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().try_write().unwrap());\n+            assert_eq!(*curr, \"someString\");\n+            *curr = \"someOtherString\";\n+            curr\n+        };\n+        assert_eq!(*result, \"someOtherString\");\n+    }\n+}\n+\n+mod owning_ref_mut {\n+    use super::super::{OwningRefMut, BoxRefMut, Erased, ErasedBoxRefMut};\n+    use super::super::BoxRef;\n+    use std::cmp::{PartialEq, Ord, PartialOrd, Ordering};\n+    use std::hash::{Hash, Hasher};\n+    use std::collections::hash_map::DefaultHasher;\n+    use std::collections::HashMap;\n+\n+    #[derive(Debug, PartialEq)]\n+    struct Example(u32, String, [u8; 3]);\n+    fn example() -> Example {\n+        Example(42, \"hello world\".to_string(), [1, 2, 3])\n+    }\n+\n+    #[test]\n+    fn new_deref() {\n+        let or: OwningRefMut<Box<()>, ()> = OwningRefMut::new(Box::new(()));\n+        assert_eq!(&*or, &());\n+    }\n+\n+    #[test]\n+    fn new_deref_mut() {\n+        let mut or: OwningRefMut<Box<()>, ()> = OwningRefMut::new(Box::new(()));\n+        assert_eq!(&mut *or, &mut ());\n+    }\n+\n+    #[test]\n+    fn mutate() {\n+        let mut or: OwningRefMut<Box<usize>, usize> = OwningRefMut::new(Box::new(0));\n+        assert_eq!(&*or, &0);\n+        *or = 1;\n+        assert_eq!(&*or, &1);\n+    }\n+\n+    #[test]\n+    fn into() {\n+        let or: OwningRefMut<Box<()>, ()> = Box::new(()).into();\n+        assert_eq!(&*or, &());\n+    }\n+\n+    #[test]\n+    fn map_offset_ref() {\n+        let or: BoxRefMut<Example> = Box::new(example()).into();\n+        let or: BoxRef<_, u32> = or.map(|x| &mut x.0);\n+        assert_eq!(&*or, &42);\n+\n+        let or: BoxRefMut<Example> = Box::new(example()).into();\n+        let or: BoxRef<_, u8> = or.map(|x| &mut x.2[1]);\n+        assert_eq!(&*or, &2);\n+    }\n+\n+    #[test]\n+    fn map_heap_ref() {\n+        let or: BoxRefMut<Example> = Box::new(example()).into();\n+        let or: BoxRef<_, str> = or.map(|x| &mut x.1[..5]);\n+        assert_eq!(&*or, \"hello\");\n+    }\n+\n+    #[test]\n+    fn map_static_ref() {\n+        let or: BoxRefMut<()> = Box::new(()).into();\n+        let or: BoxRef<_, str> = or.map(|_| \"hello\");\n+        assert_eq!(&*or, \"hello\");\n+    }\n+\n+    #[test]\n+    fn map_mut_offset_ref() {\n+        let or: BoxRefMut<Example> = Box::new(example()).into();\n+        let or: BoxRefMut<_, u32> = or.map_mut(|x| &mut x.0);\n+        assert_eq!(&*or, &42);\n+\n+        let or: BoxRefMut<Example> = Box::new(example()).into();\n+        let or: BoxRefMut<_, u8> = or.map_mut(|x| &mut x.2[1]);\n+        assert_eq!(&*or, &2);\n+    }\n+\n+    #[test]\n+    fn map_mut_heap_ref() {\n+        let or: BoxRefMut<Example> = Box::new(example()).into();\n+        let or: BoxRefMut<_, str> = or.map_mut(|x| &mut x.1[..5]);\n+        assert_eq!(&*or, \"hello\");\n+    }\n+\n+    #[test]\n+    fn map_mut_static_ref() {\n+        static mut MUT_S: [u8; 5] = *b\"hello\";\n+\n+        let mut_s: &'static mut [u8] = unsafe { &mut MUT_S };\n+\n+        let or: BoxRefMut<()> = Box::new(()).into();\n+        let or: BoxRefMut<_, [u8]> = or.map_mut(move |_| mut_s);\n+        assert_eq!(&*or, b\"hello\");\n+    }\n+\n+    #[test]\n+    fn map_mut_chained() {\n+        let or: BoxRefMut<String> = Box::new(example().1).into();\n+        let or: BoxRefMut<_, str> = or.map_mut(|x| &mut x[1..5]);\n+        let or: BoxRefMut<_, str> = or.map_mut(|x| &mut x[..2]);\n+        assert_eq!(&*or, \"el\");\n+    }\n+\n+    #[test]\n+    fn map_chained_inference() {\n+        let or = BoxRefMut::new(Box::new(example().1))\n+            .map_mut(|x| &mut x[..5])\n+            .map_mut(|x| &mut x[1..3]);\n+        assert_eq!(&*or, \"el\");\n+    }\n+\n+    #[test]\n+    fn try_map_mut() {\n+        let or: BoxRefMut<String> = Box::new(example().1).into();\n+        let or: Result<BoxRefMut<_, str>, ()> = or.try_map_mut(|x| Ok(&mut x[1..5]));\n+        assert_eq!(&*or.unwrap(), \"ello\");\n+\n+        let or: BoxRefMut<String> = Box::new(example().1).into();\n+        let or: Result<BoxRefMut<_, str>, ()> = or.try_map_mut(|_| Err(()));\n+        assert!(or.is_err());\n+    }\n+\n+    #[test]\n+    fn owner() {\n+        let or: BoxRefMut<String> = Box::new(example().1).into();\n+        let or = or.map_mut(|x| &mut x[..5]);\n+        assert_eq!(&*or, \"hello\");\n+        assert_eq!(&**or.owner(), \"hello world\");\n+    }\n+\n+    #[test]\n+    fn into_inner() {\n+        let or: BoxRefMut<String> = Box::new(example().1).into();\n+        let or = or.map_mut(|x| &mut x[..5]);\n+        assert_eq!(&*or, \"hello\");\n+        let s = *or.into_inner();\n+        assert_eq!(&s, \"hello world\");\n+    }\n+\n+    #[test]\n+    fn fmt_debug() {\n+        let or: BoxRefMut<String> = Box::new(example().1).into();\n+        let or = or.map_mut(|x| &mut x[..5]);\n+        let s = format!(\"{:?}\", or);\n+        assert_eq!(&s,\n+                   \"OwningRefMut { owner: \\\"hello world\\\", reference: \\\"hello\\\" }\");\n+    }\n+\n+    #[test]\n+    fn erased_owner() {\n+        let o1: BoxRefMut<Example, str> = BoxRefMut::new(Box::new(example()))\n+            .map_mut(|x| &mut x.1[..]);\n+\n+        let o2: BoxRefMut<String, str> = BoxRefMut::new(Box::new(example().1))\n+            .map_mut(|x| &mut x[..]);\n+\n+        let os: Vec<ErasedBoxRefMut<str>> = vec![o1.erase_owner(), o2.erase_owner()];\n+        assert!(os.iter().all(|e| &e[..] == \"hello world\"));\n+    }\n+\n+    #[test]\n+    fn raii_locks() {\n+        use super::super::RefMutRefMut;\n+        use std::cell::RefCell;\n+        use super::super::{MutexGuardRefMut, RwLockWriteGuardRefMut};\n+        use std::sync::{Mutex, RwLock};\n+\n+        {\n+            let a = RefCell::new(1);\n+            let a = {\n+                let a = RefMutRefMut::new(a.borrow_mut());\n+                assert_eq!(*a, 1);\n+                a\n+            };\n+            assert_eq!(*a, 1);\n+            drop(a);\n+        }\n+        {\n+            let a = Mutex::new(1);\n+            let a = {\n+                let a = MutexGuardRefMut::new(a.lock().unwrap());\n+                assert_eq!(*a, 1);\n+                a\n+            };\n+            assert_eq!(*a, 1);\n+            drop(a);\n+        }\n+        {\n+            let a = RwLock::new(1);\n+            let a = {\n+                let a = RwLockWriteGuardRefMut::new(a.write().unwrap());\n+                assert_eq!(*a, 1);\n+                a\n+            };\n+            assert_eq!(*a, 1);\n+            drop(a);\n+        }\n+    }\n+\n+    #[test]\n+    fn eq() {\n+        let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n+        let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n+        assert_eq!(or1.eq(&or2), true);\n+    }\n+\n+    #[test]\n+    fn cmp() {\n+        let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n+        let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![4, 5, 6].into_boxed_slice());\n+        assert_eq!(or1.cmp(&or2), Ordering::Less);\n+    }\n+\n+    #[test]\n+    fn partial_cmp() {\n+        let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![4, 5, 6].into_boxed_slice());\n+        let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n+        assert_eq!(or1.partial_cmp(&or2), Some(Ordering::Greater));\n+    }\n+\n+    #[test]\n+    fn hash() {\n+        let mut h1 = DefaultHasher::new();\n+        let mut h2 = DefaultHasher::new();\n+\n+        let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n+        let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n+\n+        or1.hash(&mut h1);\n+        or2.hash(&mut h2);\n+\n+        assert_eq!(h1.finish(), h2.finish());\n+    }\n+\n+    #[test]\n+    fn borrow() {\n+        let mut hash = HashMap::new();\n+        let     key1 = BoxRefMut::<String>::new(Box::new(\"foo\".to_string())).map(|s| &s[..]);\n+        let     key2 = BoxRefMut::<String>::new(Box::new(\"bar\".to_string())).map(|s| &s[..]);\n+\n+        hash.insert(key1, 42);\n+        hash.insert(key2, 23);\n+\n+        assert_eq!(hash.get(\"foo\"), Some(&42));\n+        assert_eq!(hash.get(\"bar\"), Some(&23));\n+    }\n+\n+    #[test]\n+    fn total_erase() {\n+        let a: OwningRefMut<Vec<u8>, [u8]>\n+            = OwningRefMut::new(vec![]).map_mut(|x| &mut x[..]);\n+        let b: OwningRefMut<Box<[u8]>, [u8]>\n+            = OwningRefMut::new(vec![].into_boxed_slice()).map_mut(|x| &mut x[..]);\n+\n+        let c: OwningRefMut<Box<Vec<u8>>, [u8]> = unsafe {a.map_owner(Box::new)};\n+        let d: OwningRefMut<Box<Box<[u8]>>, [u8]> = unsafe {b.map_owner(Box::new)};\n+\n+        let _e: OwningRefMut<Box<dyn Erased>, [u8]> = c.erase_owner();\n+        let _f: OwningRefMut<Box<dyn Erased>, [u8]> = d.erase_owner();\n+    }\n+\n+    #[test]\n+    fn total_erase_box() {\n+        let a: OwningRefMut<Vec<u8>, [u8]>\n+            = OwningRefMut::new(vec![]).map_mut(|x| &mut x[..]);\n+        let b: OwningRefMut<Box<[u8]>, [u8]>\n+            = OwningRefMut::new(vec![].into_boxed_slice()).map_mut(|x| &mut x[..]);\n+\n+        let c: OwningRefMut<Box<Vec<u8>>, [u8]> = a.map_owner_box();\n+        let d: OwningRefMut<Box<Box<[u8]>>, [u8]> = b.map_owner_box();\n+\n+        let _e: OwningRefMut<Box<dyn Erased>, [u8]> = c.erase_owner();\n+        let _f: OwningRefMut<Box<dyn Erased>, [u8]> = d.erase_owner();\n+    }\n+\n+    #[test]\n+    fn try_map1() {\n+        use std::any::Any;\n+\n+        let x = Box::new(123_i32);\n+        let y: Box<dyn Any> = x;\n+\n+        assert!(OwningRefMut::new(y).try_map_mut(|x| x.downcast_mut::<i32>().ok_or(())).is_ok());\n+    }\n+\n+    #[test]\n+    fn try_map2() {\n+        use std::any::Any;\n+\n+        let x = Box::new(123_i32);\n+        let y: Box<dyn Any> = x;\n+\n+        assert!(!OwningRefMut::new(y).try_map_mut(|x| x.downcast_mut::<i32>().ok_or(())).is_err());\n+    }\n+\n+    #[test]\n+    fn try_map3() {\n+        use std::any::Any;\n+\n+        let x = Box::new(123_i32);\n+        let y: Box<dyn Any> = x;\n+\n+        assert!(OwningRefMut::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_ok());\n+    }\n+\n+    #[test]\n+    fn try_map4() {\n+        use std::any::Any;\n+\n+        let x = Box::new(123_i32);\n+        let y: Box<dyn Any> = x;\n+\n+        assert!(!OwningRefMut::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_err());\n+    }\n+\n+    #[test]\n+    fn into_owning_ref() {\n+        use super::super::BoxRef;\n+\n+        let or: BoxRefMut<()> = Box::new(()).into();\n+        let or: BoxRef<()> = or.into();\n+        assert_eq!(&*or, &());\n+    }\n+\n+    struct Foo {\n+        u: u32,\n+    }\n+    struct Bar {\n+        f: Foo,\n+    }\n+\n+    #[test]\n+    fn ref_mut() {\n+        use std::cell::RefCell;\n+\n+        let a = RefCell::new(Bar { f: Foo { u: 42 } });\n+        let mut b = OwningRefMut::new(a.borrow_mut());\n+        assert_eq!(b.f.u, 42);\n+        b.f.u = 43;\n+        let mut c = b.map_mut(|x| &mut x.f);\n+        assert_eq!(c.u, 43);\n+        c.u = 44;\n+        let mut d = c.map_mut(|x| &mut x.u);\n+        assert_eq!(*d, 44);\n+        *d = 45;\n+        assert_eq!(*d, 45);\n+    }\n+}"}, {"sha": "fb819dd18a8d698a42e48f19d26ef169ac334849", "filename": "src/librustc_data_structures/sorted_map.rs", "status": "modified", "additions": 1, "deletions": 201, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/0d77084effdffaaa05983281717681652e62f9b2/src%2Flibrustc_data_structures%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d77084effdffaaa05983281717681652e62f9b2/src%2Flibrustc_data_structures%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsorted_map.rs?ref=0d77084effdffaaa05983281717681652e62f9b2", "patch": "@@ -305,204 +305,4 @@ impl<K: Ord, V> FromIterator<(K, V)> for SortedMap<K, V> {\n }\n \n #[cfg(test)]\n-mod tests {\n-    use super::SortedMap;\n-\n-    #[test]\n-    fn test_insert_and_iter() {\n-        let mut map = SortedMap::new();\n-        let mut expected = Vec::new();\n-\n-        for x in 0 .. 100 {\n-            assert_eq!(map.iter().cloned().collect::<Vec<_>>(), expected);\n-\n-            let x = 1000 - x * 2;\n-            map.insert(x, x);\n-            expected.insert(0, (x, x));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_get_and_index() {\n-        let mut map = SortedMap::new();\n-        let mut expected = Vec::new();\n-\n-        for x in 0 .. 100 {\n-            let x = 1000 - x;\n-            if x & 1 == 0 {\n-                map.insert(x, x);\n-            }\n-            expected.push(x);\n-        }\n-\n-        for mut x in expected {\n-            if x & 1 == 0 {\n-                assert_eq!(map.get(&x), Some(&x));\n-                assert_eq!(map.get_mut(&x), Some(&mut x));\n-                assert_eq!(map[&x], x);\n-                assert_eq!(&mut map[&x], &mut x);\n-            } else {\n-                assert_eq!(map.get(&x), None);\n-                assert_eq!(map.get_mut(&x), None);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_range() {\n-        let mut map = SortedMap::new();\n-        map.insert(1, 1);\n-        map.insert(3, 3);\n-        map.insert(6, 6);\n-        map.insert(9, 9);\n-\n-        let keys = |s: &[(_, _)]| {\n-            s.into_iter().map(|e| e.0).collect::<Vec<u32>>()\n-        };\n-\n-        for start in 0 .. 11 {\n-            for end in 0 .. 11 {\n-                if end < start {\n-                    continue\n-                }\n-\n-                let mut expected = vec![1, 3, 6, 9];\n-                expected.retain(|&x| x >= start && x < end);\n-\n-                assert_eq!(keys(map.range(start..end)), expected, \"range = {}..{}\", start, end);\n-            }\n-        }\n-    }\n-\n-\n-    #[test]\n-    fn test_offset_keys() {\n-        let mut map = SortedMap::new();\n-        map.insert(1, 1);\n-        map.insert(3, 3);\n-        map.insert(6, 6);\n-\n-        map.offset_keys(|k| *k += 1);\n-\n-        let mut expected = SortedMap::new();\n-        expected.insert(2, 1);\n-        expected.insert(4, 3);\n-        expected.insert(7, 6);\n-\n-        assert_eq!(map, expected);\n-    }\n-\n-    fn keys(s: SortedMap<u32, u32>) -> Vec<u32> {\n-        s.into_iter().map(|(k, _)| k).collect::<Vec<u32>>()\n-    }\n-\n-    fn elements(s: SortedMap<u32, u32>) -> Vec<(u32, u32)> {\n-        s.into_iter().collect::<Vec<(u32, u32)>>()\n-    }\n-\n-    #[test]\n-    fn test_remove_range() {\n-        let mut map = SortedMap::new();\n-        map.insert(1, 1);\n-        map.insert(3, 3);\n-        map.insert(6, 6);\n-        map.insert(9, 9);\n-\n-        for start in 0 .. 11 {\n-            for end in 0 .. 11 {\n-                if end < start {\n-                    continue\n-                }\n-\n-                let mut expected = vec![1, 3, 6, 9];\n-                expected.retain(|&x| x < start || x >= end);\n-\n-                let mut map = map.clone();\n-                map.remove_range(start .. end);\n-\n-                assert_eq!(keys(map), expected, \"range = {}..{}\", start, end);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_remove() {\n-        let mut map = SortedMap::new();\n-        let mut expected = Vec::new();\n-\n-        for x in 0..10 {\n-            map.insert(x, x);\n-            expected.push((x, x));\n-        }\n-\n-        for x in 0 .. 10 {\n-            let mut map = map.clone();\n-            let mut expected = expected.clone();\n-\n-            assert_eq!(map.remove(&x), Some(x));\n-            expected.remove(x as usize);\n-\n-            assert_eq!(map.iter().cloned().collect::<Vec<_>>(), expected);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_insert_presorted_non_overlapping() {\n-        let mut map = SortedMap::new();\n-        map.insert(2, 0);\n-        map.insert(8, 0);\n-\n-        map.insert_presorted(vec![(3, 0), (7, 0)]);\n-\n-        let expected = vec![2, 3, 7, 8];\n-        assert_eq!(keys(map), expected);\n-    }\n-\n-    #[test]\n-    fn test_insert_presorted_first_elem_equal() {\n-        let mut map = SortedMap::new();\n-        map.insert(2, 2);\n-        map.insert(8, 8);\n-\n-        map.insert_presorted(vec![(2, 0), (7, 7)]);\n-\n-        let expected = vec![(2, 0), (7, 7), (8, 8)];\n-        assert_eq!(elements(map), expected);\n-    }\n-\n-    #[test]\n-    fn test_insert_presorted_last_elem_equal() {\n-        let mut map = SortedMap::new();\n-        map.insert(2, 2);\n-        map.insert(8, 8);\n-\n-        map.insert_presorted(vec![(3, 3), (8, 0)]);\n-\n-        let expected = vec![(2, 2), (3, 3), (8, 0)];\n-        assert_eq!(elements(map), expected);\n-    }\n-\n-    #[test]\n-    fn test_insert_presorted_shuffle() {\n-        let mut map = SortedMap::new();\n-        map.insert(2, 2);\n-        map.insert(7, 7);\n-\n-        map.insert_presorted(vec![(1, 1), (3, 3), (8, 8)]);\n-\n-        let expected = vec![(1, 1), (2, 2), (3, 3), (7, 7), (8, 8)];\n-        assert_eq!(elements(map), expected);\n-    }\n-\n-    #[test]\n-    fn test_insert_presorted_at_end() {\n-        let mut map = SortedMap::new();\n-        map.insert(1, 1);\n-        map.insert(2, 2);\n-\n-        map.insert_presorted(vec![(3, 3), (8, 8)]);\n-\n-        let expected = vec![(1, 1), (2, 2), (3, 3), (8, 8)];\n-        assert_eq!(elements(map), expected);\n-    }\n-}\n+mod tests;"}, {"sha": "f970409cc3d587ae2953effbbf55cb5c219d9194", "filename": "src/librustc_data_structures/sorted_map/tests.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/0d77084effdffaaa05983281717681652e62f9b2/src%2Flibrustc_data_structures%2Fsorted_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d77084effdffaaa05983281717681652e62f9b2/src%2Flibrustc_data_structures%2Fsorted_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsorted_map%2Ftests.rs?ref=0d77084effdffaaa05983281717681652e62f9b2", "patch": "@@ -0,0 +1,199 @@\n+use super::SortedMap;\n+\n+#[test]\n+fn test_insert_and_iter() {\n+    let mut map = SortedMap::new();\n+    let mut expected = Vec::new();\n+\n+    for x in 0 .. 100 {\n+        assert_eq!(map.iter().cloned().collect::<Vec<_>>(), expected);\n+\n+        let x = 1000 - x * 2;\n+        map.insert(x, x);\n+        expected.insert(0, (x, x));\n+    }\n+}\n+\n+#[test]\n+fn test_get_and_index() {\n+    let mut map = SortedMap::new();\n+    let mut expected = Vec::new();\n+\n+    for x in 0 .. 100 {\n+        let x = 1000 - x;\n+        if x & 1 == 0 {\n+            map.insert(x, x);\n+        }\n+        expected.push(x);\n+    }\n+\n+    for mut x in expected {\n+        if x & 1 == 0 {\n+            assert_eq!(map.get(&x), Some(&x));\n+            assert_eq!(map.get_mut(&x), Some(&mut x));\n+            assert_eq!(map[&x], x);\n+            assert_eq!(&mut map[&x], &mut x);\n+        } else {\n+            assert_eq!(map.get(&x), None);\n+            assert_eq!(map.get_mut(&x), None);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_range() {\n+    let mut map = SortedMap::new();\n+    map.insert(1, 1);\n+    map.insert(3, 3);\n+    map.insert(6, 6);\n+    map.insert(9, 9);\n+\n+    let keys = |s: &[(_, _)]| {\n+        s.into_iter().map(|e| e.0).collect::<Vec<u32>>()\n+    };\n+\n+    for start in 0 .. 11 {\n+        for end in 0 .. 11 {\n+            if end < start {\n+                continue\n+            }\n+\n+            let mut expected = vec![1, 3, 6, 9];\n+            expected.retain(|&x| x >= start && x < end);\n+\n+            assert_eq!(keys(map.range(start..end)), expected, \"range = {}..{}\", start, end);\n+        }\n+    }\n+}\n+\n+\n+#[test]\n+fn test_offset_keys() {\n+    let mut map = SortedMap::new();\n+    map.insert(1, 1);\n+    map.insert(3, 3);\n+    map.insert(6, 6);\n+\n+    map.offset_keys(|k| *k += 1);\n+\n+    let mut expected = SortedMap::new();\n+    expected.insert(2, 1);\n+    expected.insert(4, 3);\n+    expected.insert(7, 6);\n+\n+    assert_eq!(map, expected);\n+}\n+\n+fn keys(s: SortedMap<u32, u32>) -> Vec<u32> {\n+    s.into_iter().map(|(k, _)| k).collect::<Vec<u32>>()\n+}\n+\n+fn elements(s: SortedMap<u32, u32>) -> Vec<(u32, u32)> {\n+    s.into_iter().collect::<Vec<(u32, u32)>>()\n+}\n+\n+#[test]\n+fn test_remove_range() {\n+    let mut map = SortedMap::new();\n+    map.insert(1, 1);\n+    map.insert(3, 3);\n+    map.insert(6, 6);\n+    map.insert(9, 9);\n+\n+    for start in 0 .. 11 {\n+        for end in 0 .. 11 {\n+            if end < start {\n+                continue\n+            }\n+\n+            let mut expected = vec![1, 3, 6, 9];\n+            expected.retain(|&x| x < start || x >= end);\n+\n+            let mut map = map.clone();\n+            map.remove_range(start .. end);\n+\n+            assert_eq!(keys(map), expected, \"range = {}..{}\", start, end);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_remove() {\n+    let mut map = SortedMap::new();\n+    let mut expected = Vec::new();\n+\n+    for x in 0..10 {\n+        map.insert(x, x);\n+        expected.push((x, x));\n+    }\n+\n+    for x in 0 .. 10 {\n+        let mut map = map.clone();\n+        let mut expected = expected.clone();\n+\n+        assert_eq!(map.remove(&x), Some(x));\n+        expected.remove(x as usize);\n+\n+        assert_eq!(map.iter().cloned().collect::<Vec<_>>(), expected);\n+    }\n+}\n+\n+#[test]\n+fn test_insert_presorted_non_overlapping() {\n+    let mut map = SortedMap::new();\n+    map.insert(2, 0);\n+    map.insert(8, 0);\n+\n+    map.insert_presorted(vec![(3, 0), (7, 0)]);\n+\n+    let expected = vec![2, 3, 7, 8];\n+    assert_eq!(keys(map), expected);\n+}\n+\n+#[test]\n+fn test_insert_presorted_first_elem_equal() {\n+    let mut map = SortedMap::new();\n+    map.insert(2, 2);\n+    map.insert(8, 8);\n+\n+    map.insert_presorted(vec![(2, 0), (7, 7)]);\n+\n+    let expected = vec![(2, 0), (7, 7), (8, 8)];\n+    assert_eq!(elements(map), expected);\n+}\n+\n+#[test]\n+fn test_insert_presorted_last_elem_equal() {\n+    let mut map = SortedMap::new();\n+    map.insert(2, 2);\n+    map.insert(8, 8);\n+\n+    map.insert_presorted(vec![(3, 3), (8, 0)]);\n+\n+    let expected = vec![(2, 2), (3, 3), (8, 0)];\n+    assert_eq!(elements(map), expected);\n+}\n+\n+#[test]\n+fn test_insert_presorted_shuffle() {\n+    let mut map = SortedMap::new();\n+    map.insert(2, 2);\n+    map.insert(7, 7);\n+\n+    map.insert_presorted(vec![(1, 1), (3, 3), (8, 8)]);\n+\n+    let expected = vec![(1, 1), (2, 2), (3, 3), (7, 7), (8, 8)];\n+    assert_eq!(elements(map), expected);\n+}\n+\n+#[test]\n+fn test_insert_presorted_at_end() {\n+    let mut map = SortedMap::new();\n+    map.insert(1, 1);\n+    map.insert(2, 2);\n+\n+    map.insert_presorted(vec![(3, 3), (8, 8)]);\n+\n+    let expected = vec![(1, 1), (2, 2), (3, 3), (8, 8)];\n+    assert_eq!(elements(map), expected);\n+}"}]}