{"sha": "29fb07d2451035cce7fbe99bc854cb3d71b5f1a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5ZmIwN2QyNDUxMDM1Y2NlN2ZiZTk5YmM4NTRjYjNkNzFiNWYxYTE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-14T14:47:12Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-14T15:08:13Z"}, "message": "syntax: add recovery for intersection patterns `p1 @ p2`", "tree": {"sha": "d32f3fb4aecff178bed4057dd355624fdcd453c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d32f3fb4aecff178bed4057dd355624fdcd453c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29fb07d2451035cce7fbe99bc854cb3d71b5f1a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29fb07d2451035cce7fbe99bc854cb3d71b5f1a1", "html_url": "https://github.com/rust-lang/rust/commit/29fb07d2451035cce7fbe99bc854cb3d71b5f1a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29fb07d2451035cce7fbe99bc854cb3d71b5f1a1/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa2ae564d391a3da10bca2a79ab529a9925fbe58", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa2ae564d391a3da10bca2a79ab529a9925fbe58", "html_url": "https://github.com/rust-lang/rust/commit/aa2ae564d391a3da10bca2a79ab529a9925fbe58"}], "stats": {"total": 60, "additions": 60, "deletions": 0}, "files": [{"sha": "c0e577bd58b1d8e132250e303596271ab10828c6", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/29fb07d2451035cce7fbe99bc854cb3d71b5f1a1/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29fb07d2451035cce7fbe99bc854cb3d71b5f1a1/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=29fb07d2451035cce7fbe99bc854cb3d71b5f1a1", "patch": "@@ -367,6 +367,7 @@ impl<'a> Parser<'a> {\n \n         let pat = self.mk_pat(lo.to(self.prev_span), pat);\n         let pat = self.maybe_recover_from_bad_qpath(pat, true)?;\n+        let pat = self.recover_intersection_pat(pat)?;\n \n         if !allow_range_pat {\n             self.ban_pat_range_if_ambiguous(&pat)?\n@@ -375,6 +376,65 @@ impl<'a> Parser<'a> {\n         Ok(pat)\n     }\n \n+    /// Try to recover the more general form `intersect ::= $pat_lhs @ $pat_rhs`.\n+    ///\n+    /// Allowed binding patterns generated by `binding ::= ref? mut? $ident @ $pat_rhs`\n+    /// should already have been parsed by now  at this point,\n+    /// if the next token is `@` then we can try to parse the more general form.\n+    ///\n+    /// Consult `parse_pat_ident` for the `binding` grammar.\n+    ///\n+    /// The notion of intersection patterns are found in\n+    /// e.g. [F#][and] where they are called AND-patterns.\n+    ///\n+    /// [and]: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/pattern-matching\n+    fn recover_intersection_pat(&mut self, lhs: P<Pat>) -> PResult<'a, P<Pat>> {\n+        if self.token.kind != token::At {\n+            // Next token is not `@` so it's not going to be an intersection pattern.\n+            return Ok(lhs);\n+        }\n+\n+        // At this point we attempt to parse `@ $pat_rhs` and emit an error.\n+        self.bump(); // `@`\n+        let mut rhs = self.parse_pat(None)?;\n+        let sp = lhs.span.to(rhs.span);\n+\n+        if let PatKind::Ident(_, _, ref mut sub @ None) = rhs.kind {\n+            // The user inverted the order, so help them fix that.\n+            let mut applicability = Applicability::MachineApplicable;\n+            lhs.walk(&mut |p| match p.kind {\n+                // `check_match` is unhappy if the subpattern has a binding anywhere.\n+                PatKind::Ident(..) => {\n+                    applicability = Applicability::MaybeIncorrect;\n+                    false // Short-circuit.\n+                },\n+                _ => true,\n+            });\n+\n+            let lhs_span = lhs.span;\n+            // Move the LHS into the RHS as a subpattern.\n+            // The RHS is now the full pattern.\n+            *sub = Some(lhs);\n+\n+            self.struct_span_err(sp, \"pattern on wrong side of `@`\")\n+                .span_label(lhs_span, \"pattern on the left, should be to the right\")\n+                .span_label(rhs.span, \"binding on the right, should be to the left\")\n+                .span_suggestion(sp, \"switch the order\", pprust::pat_to_string(&rhs), applicability)\n+                .emit();\n+\n+            rhs.span = sp;\n+            return Ok(rhs);\n+        }\n+\n+        // The special case above doesn't apply so we may have e.g. `A(x) @ B(y)`.\n+        let mut err = self.struct_span_err(sp, \"left-hand side of `@` must be a binding pattern\");\n+        err.span_label(lhs.span, \"interpreted as a pattern, not a binding\")\n+            .span_label(rhs.span, \"also a pattern\")\n+            .note(\"bindings are `x`, `mut x`, `ref x`, and `ref mut x`\");\n+        // FIXME(Centril): Introduce `PatKind::Err` and use that instead.\n+        Err(err)\n+    }\n+\n     /// Ban a range pattern if it has an ambiguous interpretation.\n     fn ban_pat_range_if_ambiguous(&self, pat: &Pat) -> PResult<'a, ()> {\n         match pat.kind {"}]}