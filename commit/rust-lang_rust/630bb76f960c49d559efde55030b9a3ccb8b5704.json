{"sha": "630bb76f960c49d559efde55030b9a3ccb8b5704", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzMGJiNzZmOTYwYzQ5ZDU1OWVmZGU1NTAzMGI5YTNjY2I4YjU3MDQ=", "commit": {"author": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-21T20:53:47Z"}, "committer": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-22T06:57:11Z"}, "message": "new lint: type complexity (fixes #93)\n\nStill very naive, but it's a start.", "tree": {"sha": "d865fd3cde0b287c9f35abcac3089c2e8d04dbfa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d865fd3cde0b287c9f35abcac3089c2e8d04dbfa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/630bb76f960c49d559efde55030b9a3ccb8b5704", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/630bb76f960c49d559efde55030b9a3ccb8b5704", "html_url": "https://github.com/rust-lang/rust/commit/630bb76f960c49d559efde55030b9a3ccb8b5704", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/630bb76f960c49d559efde55030b9a3ccb8b5704/comments", "author": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e92bf84a535b77c65127fadc2b82d762cff8ab66", "url": "https://api.github.com/repos/rust-lang/rust/commits/e92bf84a535b77c65127fadc2b82d762cff8ab66", "html_url": "https://github.com/rust-lang/rust/commit/e92bf84a535b77c65127fadc2b82d762cff8ab66"}], "stats": {"total": 172, "additions": 172, "deletions": 0}, "files": [{"sha": "5597610405883b6cb9b0b8da21749dfae2e40c87", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/630bb76f960c49d559efde55030b9a3ccb8b5704/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/630bb76f960c49d559efde55030b9a3ccb8b5704/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=630bb76f960c49d559efde55030b9a3ccb8b5704", "patch": "@@ -48,6 +48,7 @@ string_add               | allow   | using `x + ..` where x is a `String`; sugge\n string_add_assign        | allow   | using `x = x + ..` where x is a `String`; suggests using `push_str()` instead\n string_to_string         | warn    | calling `String.to_string()` which is a no-op\n toplevel_ref_arg         | warn    | a function argument is declared `ref` (i.e. `fn foo(ref x: u8)`, but not `fn foo((ref x, ref y): (u8, u8))`)\n+type_complexity          | warn    | usage of very complex types; recommends factoring out parts into `type` definitions\n unit_cmp                 | warn    | comparing unit values (which is always `true` or `false`, respectively)\n zero_width_space         | deny    | using a zero-width space in a string literal, which is confusing\n "}, {"sha": "b0f46ae45abbf7be906ba133534ef1e51b29df0b", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/630bb76f960c49d559efde55030b9a3ccb8b5704/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/630bb76f960c49d559efde55030b9a3ccb8b5704/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=630bb76f960c49d559efde55030b9a3ccb8b5704", "patch": "@@ -70,6 +70,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_lint_pass(box lifetimes::LifetimePass as LintPassObject);\n     reg.register_lint_pass(box ranges::StepByZero as LintPassObject);\n     reg.register_lint_pass(box types::CastPass as LintPassObject);\n+    reg.register_lint_pass(box types::TypeComplexityPass as LintPassObject);\n \n     reg.register_lint_group(\"clippy\", vec![\n         approx_const::APPROX_CONSTANT,\n@@ -111,6 +112,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         types::CAST_SIGN_LOSS,\n         types::LET_UNIT_VALUE,\n         types::LINKEDLIST,\n+        types::TYPE_COMPLEXITY,\n         types::UNIT_CMP,\n         unicode::NON_ASCII_LITERAL,\n         unicode::ZERO_WIDTH_SPACE,"}, {"sha": "54c365352869676a2c583a6bec31491bcfa38e63", "filename": "src/types.rs", "status": "modified", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/630bb76f960c49d559efde55030b9a3ccb8b5704/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/630bb76f960c49d559efde55030b9a3ccb8b5704/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=630bb76f960c49d559efde55030b9a3ccb8b5704", "patch": "@@ -2,6 +2,8 @@ use rustc::lint::*;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::ast_util::{is_comparison_binop, binop_to_string};\n+use syntax::codemap::Span;\n+use syntax::visit::{FnKind, Visitor, walk_ty};\n use rustc::middle::ty;\n use syntax::codemap::ExpnInfo;\n \n@@ -183,3 +185,126 @@ impl LintPass for CastPass {\n         }\n     }\n }\n+\n+declare_lint!(pub TYPE_COMPLEXITY, Warn,\n+              \"usage of very complex types; recommends factoring out parts into `type` definitions\");\n+\n+#[allow(missing_copy_implementations)]\n+pub struct TypeComplexityPass;\n+\n+impl LintPass for TypeComplexityPass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(TYPE_COMPLEXITY)\n+    }\n+\n+    fn check_fn(&mut self, cx: &Context, _: FnKind, decl: &FnDecl, _: &Block, _: Span, _: NodeId) {\n+        check_fndecl(cx, decl);\n+    }\n+\n+    fn check_struct_field(&mut self, cx: &Context, field: &StructField) {\n+        check_type(cx, &*field.node.ty);\n+    }\n+\n+    fn check_variant(&mut self, cx: &Context, var: &Variant, _: &Generics) {\n+        // StructVariant is covered by check_struct_field\n+        if let TupleVariantKind(ref args) = var.node.kind {\n+            for arg in args {\n+                check_type(cx, &*arg.ty);\n+            }\n+        }\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, item: &Item) {\n+        match item.node {\n+            ItemStatic(ref ty, _, _) |\n+            ItemConst(ref ty, _) => check_type(cx, ty),\n+            // functions, enums, structs, impls and traits are covered\n+            _ => ()\n+        }\n+    }\n+\n+    fn check_trait_item(&mut self, cx: &Context, item: &TraitItem) {\n+        match item.node {\n+            ConstTraitItem(ref ty, _) |\n+            TypeTraitItem(_, Some(ref ty)) => check_type(cx, ty),\n+            MethodTraitItem(MethodSig { ref decl, .. }, None) => check_fndecl(cx, decl),\n+            // methods with default impl are covered by check_fn\n+            _ => ()\n+        }\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &Context, item: &ImplItem) {\n+        match item.node {\n+            ConstImplItem(ref ty, _) |\n+            TypeImplItem(ref ty) => check_type(cx, ty),\n+            // methods are covered by check_fn\n+            _ => ()\n+        }\n+    }\n+\n+    fn check_local(&mut self, cx: &Context, local: &Local) {\n+        if let Some(ref ty) = local.ty {\n+            check_type(cx, ty);\n+        }\n+    }\n+}\n+\n+fn check_fndecl(cx: &Context, decl: &FnDecl) {\n+    for arg in &decl.inputs {\n+        check_type(cx, &*arg.ty);\n+    }\n+    if let Return(ref ty) = decl.output {\n+        check_type(cx, ty);\n+    }\n+}\n+\n+fn check_type(cx: &Context, ty: &ast::Ty) {\n+    let score = {\n+        let mut visitor = TypeComplexityVisitor { score: 0, nest: 1 };\n+        visitor.visit_ty(ty);\n+        visitor.score\n+    };\n+    // println!(\"{:?} --> {}\", ty, score);\n+    if score > 250 {\n+        span_lint(cx, TYPE_COMPLEXITY, ty.span, &format!(\n+            \"very complex type used. Consider factoring parts into `type` definitions\"));\n+    }\n+}\n+\n+/// Walks a type and assigns a complexity score to it.\n+struct TypeComplexityVisitor {\n+    /// total complexity score of the type\n+    score: u32,\n+    /// current nesting level\n+    nest: u32,\n+}\n+\n+impl<'v> Visitor<'v> for TypeComplexityVisitor {\n+    fn visit_ty(&mut self, ty: &'v ast::Ty) {\n+        let (add_score, sub_nest) = match ty.node {\n+            // _, &x and *x have only small overhead; don't mess with nesting level\n+            TyInfer |\n+            TyPtr(..) |\n+            TyRptr(..) => (1, 0),\n+\n+            // the \"normal\" components of a type: named types, arrays/tuples\n+            TyPath(..) |\n+            TyVec(..) |\n+            TyTup(..) |\n+            TyFixedLengthVec(..) => (10 * self.nest, 1),\n+\n+            // \"Sum\" of trait bounds\n+            TyObjectSum(..) => (20 * self.nest, 0),\n+\n+            // function types and \"for<...>\" bring a lot of overhead\n+            TyBareFn(..) |\n+            TyPolyTraitRef(..) => (50 * self.nest, 1),\n+\n+            _ => (0, 0)\n+        };\n+        self.score += add_score;\n+        self.nest += sub_nest;\n+        walk_ty(self, ty);\n+        self.nest -= sub_nest;\n+    }\n+}"}, {"sha": "995132ba88c9420961cd2d2cbaa33e8008110dfa", "filename": "tests/compile-fail/complex_types.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/630bb76f960c49d559efde55030b9a3ccb8b5704/tests%2Fcompile-fail%2Fcomplex_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/630bb76f960c49d559efde55030b9a3ccb8b5704/tests%2Fcompile-fail%2Fcomplex_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcomplex_types.rs?ref=630bb76f960c49d559efde55030b9a3ccb8b5704", "patch": "@@ -0,0 +1,44 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#![deny(clippy)]\n+#![allow(unused)]\n+#![feature(associated_consts, associated_type_defaults)]\n+\n+type Alias = Vec<Vec<Box<(u32, u32, u32, u32)>>>; // no warning here\n+\n+const CST: (u32, (u32, (u32, (u32, u32)))) = (0, (0, (0, (0, 0)))); //~ERROR very complex type\n+static ST: (u32, (u32, (u32, (u32, u32)))) = (0, (0, (0, (0, 0)))); //~ERROR very complex type\n+\n+struct S {\n+    f: Vec<Vec<Box<(u32, u32, u32, u32)>>>, //~ERROR very complex type\n+}\n+\n+struct TS(Vec<Vec<Box<(u32, u32, u32, u32)>>>); //~ERROR very complex type\n+\n+enum E {\n+    V1(Vec<Vec<Box<(u32, u32, u32, u32)>>>), //~ERROR very complex type\n+    V2 { f: Vec<Vec<Box<(u32, u32, u32, u32)>>> }, //~ERROR very complex type\n+}\n+\n+impl S {\n+    const A: (u32, (u32, (u32, (u32, u32)))) = (0, (0, (0, (0, 0)))); //~ERROR very complex type\n+    fn impl_method(&self, p: Vec<Vec<Box<(u32, u32, u32, u32)>>>) { } //~ERROR very complex type\n+}\n+\n+trait T {\n+    const A: Vec<Vec<Box<(u32, u32, u32, u32)>>>; //~ERROR very complex type\n+    type B = Vec<Vec<Box<(u32, u32, u32, u32)>>>; //~ERROR very complex type\n+    fn method(&self, p: Vec<Vec<Box<(u32, u32, u32, u32)>>>); //~ERROR very complex type\n+    fn def_method(&self, p: Vec<Vec<Box<(u32, u32, u32, u32)>>>) { } //~ERROR very complex type\n+}\n+\n+fn test1() -> Vec<Vec<Box<(u32, u32, u32, u32)>>> { vec![] } //~ERROR very complex type\n+\n+fn test2(_x: Vec<Vec<Box<(u32, u32, u32, u32)>>>) { } //~ERROR very complex type\n+\n+fn test3() {\n+    let _y: Vec<Vec<Box<(u32, u32, u32, u32)>>> = vec![]; //~ERROR very complex type\n+}\n+\n+fn main() {\n+}"}]}