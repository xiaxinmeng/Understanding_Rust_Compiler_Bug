{"sha": "94c300a4522f3386546ba77a21865bb78fe9bba8", "node_id": "C_kwDOAAsO6NoAKDk0YzMwMGE0NTIyZjMzODY1NDZiYTc3YTIxODY1YmI3OGZlOWJiYTg", "commit": {"author": {"name": "Rob Pilling", "email": "robpilling@gmail.com", "date": "2021-11-07T22:41:35Z"}, "committer": {"name": "Rob Pilling", "email": "robpilling@gmail.com", "date": "2022-01-25T22:51:14Z"}, "message": "Suggest tuple-parentheses when passing N arguments to an N-tuple argument", "tree": {"sha": "8a0443b44b7c7e9519885b05be1350a6934bc4de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a0443b44b7c7e9519885b05be1350a6934bc4de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94c300a4522f3386546ba77a21865bb78fe9bba8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94c300a4522f3386546ba77a21865bb78fe9bba8", "html_url": "https://github.com/rust-lang/rust/commit/94c300a4522f3386546ba77a21865bb78fe9bba8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94c300a4522f3386546ba77a21865bb78fe9bba8/comments", "author": {"login": "bobrippling", "id": 205673, "node_id": "MDQ6VXNlcjIwNTY3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/205673?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobrippling", "html_url": "https://github.com/bobrippling", "followers_url": "https://api.github.com/users/bobrippling/followers", "following_url": "https://api.github.com/users/bobrippling/following{/other_user}", "gists_url": "https://api.github.com/users/bobrippling/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobrippling/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobrippling/subscriptions", "organizations_url": "https://api.github.com/users/bobrippling/orgs", "repos_url": "https://api.github.com/users/bobrippling/repos", "events_url": "https://api.github.com/users/bobrippling/events{/privacy}", "received_events_url": "https://api.github.com/users/bobrippling/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bobrippling", "id": 205673, "node_id": "MDQ6VXNlcjIwNTY3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/205673?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobrippling", "html_url": "https://github.com/bobrippling", "followers_url": "https://api.github.com/users/bobrippling/followers", "following_url": "https://api.github.com/users/bobrippling/following{/other_user}", "gists_url": "https://api.github.com/users/bobrippling/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobrippling/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobrippling/subscriptions", "organizations_url": "https://api.github.com/users/bobrippling/orgs", "repos_url": "https://api.github.com/users/bobrippling/repos", "events_url": "https://api.github.com/users/bobrippling/events{/privacy}", "received_events_url": "https://api.github.com/users/bobrippling/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92ed8747f255b2695c33b64982e6959711a72cb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/92ed8747f255b2695c33b64982e6959711a72cb9", "html_url": "https://github.com/rust-lang/rust/commit/92ed8747f255b2695c33b64982e6959711a72cb9"}], "stats": {"total": 73, "additions": 67, "deletions": 6}, "files": [{"sha": "5f3507846ba9be59500e787c8d6aa68ae4c776a7", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 67, "deletions": 6, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/94c300a4522f3386546ba77a21865bb78fe9bba8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94c300a4522f3386546ba77a21865bb78fe9bba8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=94c300a4522f3386546ba77a21865bb78fe9bba8", "patch": "@@ -28,6 +28,11 @@ use crate::structured_errors::StructuredDiagnostic;\n use std::iter;\n use std::slice;\n \n+enum FnArgsAsTuple<'hir> {\n+    Single(&'hir hir::Expr<'hir>),\n+    Multi { first: &'hir hir::Expr<'hir>, last: &'hir hir::Expr<'hir> },\n+}\n+\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn check_casts(&self) {\n         let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n@@ -127,8 +132,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let expected_arg_count = formal_input_tys.len();\n \n-        // expected_count, arg_count, error_code, sugg_unit\n-        let mut error: Option<(usize, usize, &str, bool)> = None;\n+        // expected_count, arg_count, error_code, sugg_unit, sugg_tuple_wrap_args\n+        let mut error: Option<(usize, usize, &str, bool, Option<FnArgsAsTuple<'_>>)> = None;\n \n         // If the arguments should be wrapped in a tuple (ex: closures), unwrap them here\n         let (formal_input_tys, expected_input_tys) = if tuple_arguments == TupleArguments {\n@@ -138,7 +143,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 ty::Tuple(arg_types) => {\n                     // Argument length differs\n                     if arg_types.len() != provided_args.len() {\n-                        error = Some((arg_types.len(), provided_args.len(), \"E0057\", false));\n+                        error = Some((arg_types.len(), provided_args.len(), \"E0057\", false, None));\n                     }\n                     let expected_input_tys = match expected_input_tys.get(0) {\n                         Some(&ty) => match ty.kind() {\n@@ -169,7 +174,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if supplied_arg_count >= expected_arg_count {\n                 (formal_input_tys.to_vec(), expected_input_tys)\n             } else {\n-                error = Some((expected_arg_count, supplied_arg_count, \"E0060\", false));\n+                error = Some((expected_arg_count, supplied_arg_count, \"E0060\", false, None));\n                 (self.err_args(supplied_arg_count), vec![])\n             }\n         } else {\n@@ -181,7 +186,43 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             } else {\n                 false\n             };\n-            error = Some((expected_arg_count, supplied_arg_count, \"E0061\", sugg_unit));\n+\n+            // are we passing elements of a tuple without the tuple parentheses?\n+            let chosen_arg_tys = if expected_input_tys.is_empty() {\n+                // In most cases we can use expected_arg_tys, but some callers won't have the type\n+                // information, in which case we fall back to the types from the input expressions.\n+                formal_input_tys\n+            } else {\n+                &*expected_input_tys\n+            };\n+\n+            let sugg_tuple_wrap_args = chosen_arg_tys\n+                .get(0)\n+                .cloned()\n+                .map(|arg_ty| self.resolve_vars_if_possible(arg_ty))\n+                .and_then(|arg_ty| match arg_ty.kind() {\n+                    ty::Tuple(tup_elems) => Some(tup_elems),\n+                    _ => None,\n+                })\n+                .and_then(|tup_elems| {\n+                    if tup_elems.len() == supplied_arg_count && chosen_arg_tys.len() == 1 {\n+                        match provided_args {\n+                            [] => None,\n+                            [single] => Some(FnArgsAsTuple::Single(single)),\n+                            [first, .., last] => Some(FnArgsAsTuple::Multi { first, last }),\n+                        }\n+                    } else {\n+                        None\n+                    }\n+                });\n+\n+            error = Some((\n+                expected_arg_count,\n+                supplied_arg_count,\n+                \"E0061\",\n+                sugg_unit,\n+                sugg_tuple_wrap_args,\n+            ));\n             (self.err_args(supplied_arg_count), vec![])\n         };\n \n@@ -305,7 +346,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         // If there was an error in parameter count, emit that here\n-        if let Some((expected_count, arg_count, err_code, sugg_unit)) = error {\n+        if let Some((expected_count, arg_count, err_code, sugg_unit, sugg_tuple_wrap_args)) = error\n+        {\n             let (span, start_span, args, ctor_of) = match &call_expr.kind {\n                 hir::ExprKind::Call(\n                     hir::Expr {\n@@ -408,6 +450,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     String::from(\"()\"),\n                     Applicability::MachineApplicable,\n                 );\n+            } else if let Some(tuple_fn_arg) = sugg_tuple_wrap_args {\n+                use FnArgsAsTuple::*;\n+\n+                let spans = match tuple_fn_arg {\n+                    Multi { first, last } => vec![\n+                        (first.span.shrink_to_lo(), '('.to_string()),\n+                        (last.span.shrink_to_hi(), ')'.to_string()),\n+                    ],\n+                    Single(single) => vec![\n+                        (single.span.shrink_to_lo(), '('.to_string()),\n+                        (single.span.shrink_to_hi(), \",)\".to_string()),\n+                    ],\n+                };\n+\n+                err.multipart_suggestion(\n+                    \"use parentheses to construct a tuple\",\n+                    spans,\n+                    Applicability::MachineApplicable,\n+                );\n             } else {\n                 err.span_label(\n                     span,"}]}