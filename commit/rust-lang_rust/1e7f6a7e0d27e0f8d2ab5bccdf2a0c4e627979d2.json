{"sha": "1e7f6a7e0d27e0f8d2ab5bccdf2a0c4e627979d2", "node_id": "C_kwDOAAsO6NoAKDFlN2Y2YTdlMGQyN2UwZjhkMmFiNWJjY2RmMmEwYzRlNjI3OTc5ZDI", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-11-23T01:47:56Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-11-23T01:48:03Z"}, "message": "Pass InferCtxt to DropRangeVisitor so we can resolve vars", "tree": {"sha": "12062bb09f922724ae300dd81d3d3fe722b00192", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12062bb09f922724ae300dd81d3d3fe722b00192"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e7f6a7e0d27e0f8d2ab5bccdf2a0c4e627979d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e7f6a7e0d27e0f8d2ab5bccdf2a0c4e627979d2", "html_url": "https://github.com/rust-lang/rust/commit/1e7f6a7e0d27e0f8d2ab5bccdf2a0c4e627979d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e7f6a7e0d27e0f8d2ab5bccdf2a0c4e627979d2/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66ccf36f161f67b121290e2af2517ead7e695d3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/66ccf36f161f67b121290e2af2517ead7e695d3b", "html_url": "https://github.com/rust-lang/rust/commit/66ccf36f161f67b121290e2af2517ead7e695d3b"}], "stats": {"total": 224, "additions": 201, "deletions": 23}, "files": [{"sha": "8e7f58958456b2fcccde7f985f2ccada856c0a53", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1e7f6a7e0d27e0f8d2ab5bccdf2a0c4e627979d2/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e7f6a7e0d27e0f8d2ab5bccdf2a0c4e627979d2/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=1e7f6a7e0d27e0f8d2ab5bccdf2a0c4e627979d2", "patch": "@@ -9,9 +9,10 @@ use hir::{\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_index::vec::IndexVec;\n+use rustc_infer::infer::InferCtxt;\n use rustc_middle::{\n     hir::map::Map,\n-    ty::{TyCtxt, TypeckResults},\n+    ty::{TyCtxt, TypeVisitable, TypeckResults},\n };\n use std::mem::swap;\n \n@@ -21,20 +22,23 @@ use std::mem::swap;\n /// The resulting structure still needs to be iterated to a fixed point, which\n /// can be done with propagate_to_fixpoint in cfg_propagate.\n pub(super) fn build_control_flow_graph<'tcx>(\n-    hir: Map<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n     typeck_results: &TypeckResults<'tcx>,\n     consumed_borrowed_places: ConsumedAndBorrowedPlaces,\n     body: &'tcx Body<'tcx>,\n     num_exprs: usize,\n ) -> (DropRangesBuilder, FxHashSet<HirId>) {\n     let mut drop_range_visitor =\n-        DropRangeVisitor::new(hir, tcx, typeck_results, consumed_borrowed_places, num_exprs);\n+        DropRangeVisitor::new(infcx, typeck_results, consumed_borrowed_places, num_exprs);\n     intravisit::walk_body(&mut drop_range_visitor, body);\n \n     drop_range_visitor.drop_ranges.process_deferred_edges();\n-    if let Some(filename) = &tcx.sess.opts.unstable_opts.dump_drop_tracking_cfg {\n-        super::cfg_visualize::write_graph_to_file(&drop_range_visitor.drop_ranges, filename, tcx);\n+    if let Some(filename) = &infcx.tcx.sess.opts.unstable_opts.dump_drop_tracking_cfg {\n+        super::cfg_visualize::write_graph_to_file(\n+            &drop_range_visitor.drop_ranges,\n+            filename,\n+            infcx.tcx,\n+        );\n     }\n \n     (drop_range_visitor.drop_ranges, drop_range_visitor.places.borrowed_temporaries)\n@@ -82,40 +86,41 @@ pub(super) fn build_control_flow_graph<'tcx>(\n /// ```\n \n struct DropRangeVisitor<'a, 'tcx> {\n-    hir: Map<'tcx>,\n+    typeck_results: &'a TypeckResults<'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n     places: ConsumedAndBorrowedPlaces,\n     drop_ranges: DropRangesBuilder,\n     expr_index: PostOrderId,\n-    tcx: TyCtxt<'tcx>,\n-    typeck_results: &'a TypeckResults<'tcx>,\n     label_stack: Vec<(Option<rustc_ast::Label>, PostOrderId)>,\n }\n \n impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n     fn new(\n-        hir: Map<'tcx>,\n-        tcx: TyCtxt<'tcx>,\n+        infcx: &'a InferCtxt<'tcx>,\n         typeck_results: &'a TypeckResults<'tcx>,\n         places: ConsumedAndBorrowedPlaces,\n         num_exprs: usize,\n     ) -> Self {\n         debug!(\"consumed_places: {:?}\", places.consumed);\n         let drop_ranges = DropRangesBuilder::new(\n             places.consumed.iter().flat_map(|(_, places)| places.iter().cloned()),\n-            hir,\n+            infcx.tcx.hir(),\n             num_exprs,\n         );\n         Self {\n-            hir,\n+            infcx,\n+            typeck_results,\n             places,\n             drop_ranges,\n             expr_index: PostOrderId::from_u32(0),\n-            typeck_results,\n-            tcx,\n             label_stack: vec![],\n         }\n     }\n \n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n     fn record_drop(&mut self, value: TrackedValue) {\n         if self.places.borrowed.contains(&value) {\n             debug!(\"not marking {:?} as dropped because it is borrowed at some point\", value);\n@@ -137,7 +142,7 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n             .map_or(vec![], |places| places.iter().cloned().collect());\n         for place in places {\n             trace!(?place, \"consuming place\");\n-            for_each_consumable(self.hir, place, |value| self.record_drop(value));\n+            for_each_consumable(self.tcx().hir(), place, |value| self.record_drop(value));\n         }\n     }\n \n@@ -214,10 +219,16 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n     /// return.\n     fn handle_uninhabited_return(&mut self, expr: &Expr<'tcx>) {\n         let ty = self.typeck_results.expr_ty(expr);\n-        let ty = self.tcx.erase_regions(ty);\n-        let m = self.tcx.parent_module(expr.hir_id).to_def_id();\n-        let param_env = self.tcx.param_env(m.expect_local());\n-        if !ty.is_inhabited_from(self.tcx, m, param_env) {\n+        let ty = self.infcx.resolve_vars_if_possible(ty);\n+        let ty = self.tcx().erase_regions(ty);\n+        let m = self.tcx().parent_module(expr.hir_id).to_def_id();\n+        let param_env = self.tcx().param_env(m.expect_local());\n+        if ty.has_non_region_infer() {\n+            self.tcx()\n+                .sess\n+                .delay_span_bug(expr.span, format!(\"could not resolve infer vars in `{ty}`\"));\n+        }\n+        if !ty.is_inhabited_from(self.tcx(), m, param_env) {\n             // This function will not return. We model this fact as an infinite loop.\n             self.drop_ranges.add_control_edge(self.expr_index + 1, self.expr_index + 1);\n         }\n@@ -238,7 +249,7 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n         destination: hir::Destination,\n     ) -> Result<HirId, LoopIdError> {\n         destination.target_id.map(|target| {\n-            let node = self.hir.get(target);\n+            let node = self.tcx().hir().get(target);\n             match node {\n                 hir::Node::Expr(_) => target,\n                 hir::Node::Block(b) => find_last_block_expression(b),"}, {"sha": "d5a5bb7d5780264fdb60c661b5746ef0c6a24809", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1e7f6a7e0d27e0f8d2ab5bccdf2a0c4e627979d2/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e7f6a7e0d27e0f8d2ab5bccdf2a0c4e627979d2/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs?ref=1e7f6a7e0d27e0f8d2ab5bccdf2a0c4e627979d2", "patch": "@@ -43,8 +43,7 @@ pub fn compute_drop_ranges<'a, 'tcx>(\n         let typeck_results = &fcx.typeck_results.borrow();\n         let num_exprs = fcx.tcx.region_scope_tree(def_id).body_expr_count(body.id()).unwrap_or(0);\n         let (mut drop_ranges, borrowed_temporaries) = build_control_flow_graph(\n-            fcx.tcx.hir(),\n-            fcx.tcx,\n+            &fcx,\n             typeck_results,\n             consumed_borrowed_places,\n             body,"}, {"sha": "7f72942958141bf055d41db2272856dcd307ed7e", "filename": "src/test/ui/async-await/drop-tracking-unresolved-typeck-results.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/1e7f6a7e0d27e0f8d2ab5bccdf2a0c4e627979d2/src%2Ftest%2Fui%2Fasync-await%2Fdrop-tracking-unresolved-typeck-results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e7f6a7e0d27e0f8d2ab5bccdf2a0c4e627979d2/src%2Ftest%2Fui%2Fasync-await%2Fdrop-tracking-unresolved-typeck-results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-tracking-unresolved-typeck-results.rs?ref=1e7f6a7e0d27e0f8d2ab5bccdf2a0c4e627979d2", "patch": "@@ -0,0 +1,106 @@\n+// compile-flags: -Zdrop-tracking\n+// incremental\n+// edition: 2021\n+\n+use std::future::*;\n+use std::marker::PhantomData;\n+use std::pin::Pin;\n+use std::task::*;\n+\n+fn send<T: Send>(_: T) {}\n+\n+pub trait Stream {\n+    type Item;\n+\n+    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>>;\n+}\n+\n+struct Empty<T>(PhantomData<fn() -> T>);\n+\n+impl<T> Stream for Empty<T> {\n+    type Item = T;\n+\n+    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n+        todo!()\n+    }\n+}\n+\n+pub trait FnOnce1<A> {\n+    type Output;\n+    fn call_once(self, arg: A) -> Self::Output;\n+}\n+\n+impl<T, A, R> FnOnce1<A> for T\n+where\n+    T: FnOnce(A) -> R,\n+{\n+    type Output = R;\n+    fn call_once(self, arg: A) -> R {\n+        self(arg)\n+    }\n+}\n+\n+pub trait FnMut1<A>: FnOnce1<A> {\n+    fn call_mut(&mut self, arg: A) -> Self::Output;\n+}\n+\n+impl<T, A, R> FnMut1<A> for T\n+where\n+    T: FnMut(A) -> R,\n+{\n+    fn call_mut(&mut self, arg: A) -> R {\n+        self(arg)\n+    }\n+}\n+\n+struct Map<St, F>(St, F);\n+\n+impl<St, F> Stream for Map<St, F>\n+where\n+    St: Stream,\n+    F: FnMut1<St::Item>,\n+{\n+    type Item = F::Output;\n+\n+    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n+        todo!()\n+    }\n+}\n+\n+struct FuturesOrdered<T: Future>(PhantomData<fn() -> T::Output>);\n+\n+pub struct Buffered<St: Stream>(St, FuturesOrdered<St::Item>, usize)\n+where\n+    St::Item: Future;\n+\n+impl<St> Stream for Buffered<St>\n+where\n+    St: Stream,\n+    St::Item: Future,\n+{\n+    type Item = <St::Item as Future>::Output;\n+\n+    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n+        todo!()\n+    }\n+}\n+\n+struct Next<'a, T: ?Sized>(&'a T);\n+\n+impl<St: ?Sized + Stream + Unpin> Future for Next<'_, St> {\n+    type Output = Option<St::Item>;\n+\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+        todo!()\n+    }\n+}\n+\n+fn main() {\n+    send(async {\n+        //~^ ERROR implementation of `FnOnce` is not general enough\n+        //~| ERROR implementation of `FnOnce` is not general enough\n+        //~| ERROR implementation of `FnOnce` is not general enough\n+        //~| ERROR implementation of `FnOnce` is not general enough\n+        Next(&Buffered(Map(Empty(PhantomData), ready::<&()>), FuturesOrdered(PhantomData), 0)).await\n+    });\n+}"}, {"sha": "aa9a22e9e72ea53d4da1fc04f7c4a54635eed6a8", "filename": "src/test/ui/async-await/drop-tracking-unresolved-typeck-results.stderr", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1e7f6a7e0d27e0f8d2ab5bccdf2a0c4e627979d2/src%2Ftest%2Fui%2Fasync-await%2Fdrop-tracking-unresolved-typeck-results.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e7f6a7e0d27e0f8d2ab5bccdf2a0c4e627979d2/src%2Ftest%2Fui%2Fasync-await%2Fdrop-tracking-unresolved-typeck-results.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-tracking-unresolved-typeck-results.stderr?ref=1e7f6a7e0d27e0f8d2ab5bccdf2a0c4e627979d2", "patch": "@@ -0,0 +1,62 @@\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/drop-tracking-unresolved-typeck-results.rs:99:5\n+   |\n+LL | /     send(async {\n+LL | |\n+LL | |\n+LL | |\n+LL | |\n+LL | |         Next(&Buffered(Map(Empty(PhantomData), ready::<&()>), FuturesOrdered(PhantomData), 0)).await\n+LL | |     });\n+   | |______^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: `fn(&'0 ()) -> std::future::Ready<&'0 ()> {std::future::ready::<&'0 ()>}` must implement `FnOnce<(&'1 (),)>`, for any two lifetimes `'0` and `'1`...\n+   = note: ...but it actually implements `FnOnce<(&(),)>`\n+\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/drop-tracking-unresolved-typeck-results.rs:99:5\n+   |\n+LL | /     send(async {\n+LL | |\n+LL | |\n+LL | |\n+LL | |\n+LL | |         Next(&Buffered(Map(Empty(PhantomData), ready::<&()>), FuturesOrdered(PhantomData), 0)).await\n+LL | |     });\n+   | |______^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: `fn(&'0 ()) -> std::future::Ready<&'0 ()> {std::future::ready::<&'0 ()>}` must implement `FnOnce<(&'1 (),)>`, for any two lifetimes `'0` and `'1`...\n+   = note: ...but it actually implements `FnOnce<(&(),)>`\n+\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/drop-tracking-unresolved-typeck-results.rs:99:5\n+   |\n+LL | /     send(async {\n+LL | |\n+LL | |\n+LL | |\n+LL | |\n+LL | |         Next(&Buffered(Map(Empty(PhantomData), ready::<&()>), FuturesOrdered(PhantomData), 0)).await\n+LL | |     });\n+   | |______^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: `fn(&'0 ()) -> std::future::Ready<&'0 ()> {std::future::ready::<&'0 ()>}` must implement `FnOnce<(&'1 (),)>`, for any two lifetimes `'0` and `'1`...\n+   = note: ...but it actually implements `FnOnce<(&(),)>`\n+\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/drop-tracking-unresolved-typeck-results.rs:99:5\n+   |\n+LL | /     send(async {\n+LL | |\n+LL | |\n+LL | |\n+LL | |\n+LL | |         Next(&Buffered(Map(Empty(PhantomData), ready::<&()>), FuturesOrdered(PhantomData), 0)).await\n+LL | |     });\n+   | |______^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: `fn(&'0 ()) -> std::future::Ready<&'0 ()> {std::future::ready::<&'0 ()>}` must implement `FnOnce<(&'1 (),)>`, for any two lifetimes `'0` and `'1`...\n+   = note: ...but it actually implements `FnOnce<(&(),)>`\n+\n+error: aborting due to 4 previous errors\n+"}]}