{"sha": "1d1543d5667ef1dddf03aa1aeed77851b604f704", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkMTU0M2Q1NjY3ZWYxZGRkZjAzYWExYWVlZDc3ODUxYjYwNGY3MDQ=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-03-20T00:51:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-03-20T00:51:08Z"}, "message": "Rollup merge of #40521 - TimNN:panic-free-shift, r=alexcrichton\n\nImplemente overflowing_sh* with new unchecked_sh* intrinsics\n\nAlso update some 128 bit builtins to not rely on the constant evaluator to avoid checked operations.\n\nFixes #40508.\n\ncc @nagisa, @alexcrichton\n\nNote: I still have a build running to see if the 128 bit changes worked (unoptimized builds take *forever* to compile), however at least the overflowing builtins no longer reference `core::panicking::panic`.", "tree": {"sha": "7548bd62a31eb28093a67c4cfc3f626d0f5ace78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7548bd62a31eb28093a67c4cfc3f626d0f5ace78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d1543d5667ef1dddf03aa1aeed77851b604f704", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d1543d5667ef1dddf03aa1aeed77851b604f704", "html_url": "https://github.com/rust-lang/rust/commit/1d1543d5667ef1dddf03aa1aeed77851b604f704", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d1543d5667ef1dddf03aa1aeed77851b604f704/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6480a00222bf67f928e305bf9967302eb6ae6b3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6480a00222bf67f928e305bf9967302eb6ae6b3a", "html_url": "https://github.com/rust-lang/rust/commit/6480a00222bf67f928e305bf9967302eb6ae6b3a"}, {"sha": "e16d286b8170e76f8a725b507c6c8fa91c3a28bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/e16d286b8170e76f8a725b507c6c8fa91c3a28bf", "html_url": "https://github.com/rust-lang/rust/commit/e16d286b8170e76f8a725b507c6c8fa91c3a28bf"}], "stats": {"total": 155, "additions": 127, "deletions": 28}, "files": [{"sha": "58aba11e4394f6e619c60775d353cb0df68b35c8", "filename": "src/libcompiler_builtins/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1d1543d5667ef1dddf03aa1aeed77851b604f704/src%2Flibcompiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d1543d5667ef1dddf03aa1aeed77851b604f704/src%2Flibcompiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Flib.rs?ref=1d1543d5667ef1dddf03aa1aeed77851b604f704", "patch": "@@ -34,8 +34,8 @@ pub mod reimpls {\n     macro_rules! ashl {\n         ($a:expr, $b:expr, $ty:ty) => {{\n             let (a, b) = ($a, $b);\n-            let bits = (::core::mem::size_of::<$ty>() * 8) as $ty;\n-            let half_bits = bits >> 1;\n+            let bits = ::core::mem::size_of::<$ty>().wrapping_mul(8) as $ty;\n+            let half_bits = bits.wrapping_shr(1);\n             if b & half_bits != 0 {\n                 <$ty>::from_parts(0, a.low().wrapping_shl(\n                                         b.wrapping_sub(half_bits) as u32))\n@@ -58,8 +58,8 @@ pub mod reimpls {\n     macro_rules! ashr {\n         ($a: expr, $b: expr, $ty:ty) => {{\n             let (a, b) = ($a, $b);\n-            let bits = (::core::mem::size_of::<$ty>() * 8) as $ty;\n-            let half_bits = bits >> 1;\n+            let bits = ::core::mem::size_of::<$ty>().wrapping_mul(8) as $ty;\n+            let half_bits = bits.wrapping_shr(1);\n             if b & half_bits != 0 {\n                 <$ty>::from_parts(a.high().wrapping_shr(b.wrapping_sub(half_bits) as u32)\n                                   as <$ty as LargeInt>::LowHalf,\n@@ -83,8 +83,8 @@ pub mod reimpls {\n     macro_rules! lshr {\n         ($a: expr, $b: expr, $ty:ty) => {{\n             let (a, b) = ($a, $b);\n-            let bits = (::core::mem::size_of::<$ty>() * 8) as $ty;\n-            let half_bits = bits >> 1;\n+            let bits = ::core::mem::size_of::<$ty>().wrapping_mul(8) as $ty;\n+            let half_bits = bits.wrapping_shr(1);\n             if b & half_bits != 0 {\n                 <$ty>::from_parts(a.high().wrapping_shr(b.wrapping_sub(half_bits) as u32), 0)\n             } else if b == 0 {\n@@ -370,7 +370,7 @@ pub mod reimpls {\n     macro_rules! mul {\n         ($a:expr, $b:expr, $ty: ty, $tyh: ty) => {{\n             let (a, b) = ($a, $b);\n-            let half_bits = ((::core::mem::size_of::<$tyh>() * 8) / 2) as u32;\n+            let half_bits = ::core::mem::size_of::<$tyh>().wrapping_mul(4) as u32;\n             let lower_mask = (!0u64).wrapping_shr(half_bits);\n             let mut low = (a.low() & lower_mask).wrapping_mul(b.low() & lower_mask);\n             let mut t = low.wrapping_shr(half_bits);\n@@ -478,7 +478,7 @@ pub mod reimpls {\n             let mantissa_fraction = repr & <$fromty as FloatStuff>::MANTISSA_MASK;\n             let mantissa = mantissa_fraction | <$fromty as FloatStuff>::MANTISSA_LEAD_BIT;\n             if sign == -1.0 || exponent < 0 { return 0 as u128; }\n-            if exponent > ::core::mem::size_of::<$outty>() as i32 * 8 {\n+            if exponent > ::core::mem::size_of::<$outty>().wrapping_mul(8) as i32 {\n                 return !(0 as u128);\n             }\n             (if exponent < (<$fromty as FloatStuff>::MANTISSA_BITS) as i32 {\n@@ -503,7 +503,7 @@ pub mod reimpls {\n             let mantissa = mantissa_fraction | <$fromty as FloatStuff>::MANTISSA_LEAD_BIT;\n \n             if exponent < 0 { return 0 as i128; }\n-            if exponent > ::core::mem::size_of::<$outty>() as i32 * 8 {\n+            if exponent > ::core::mem::size_of::<$outty>().wrapping_mul(8) as i32 {\n                 let ret = if sign > 0.0 { <$outty>::max_value() } else { <$outty>::min_value() };\n                 return ret\n             }"}, {"sha": "f8d067e9696fd560cef0e8cc4cdc20b9bbce7339", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1d1543d5667ef1dddf03aa1aeed77851b604f704/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d1543d5667ef1dddf03aa1aeed77851b604f704/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=1d1543d5667ef1dddf03aa1aeed77851b604f704", "patch": "@@ -1238,6 +1238,15 @@ extern \"rust-intrinsic\" {\n     /// undefined behavior where y = 0 or x = `T::min_value()` and y = -1\n     pub fn unchecked_rem<T>(x: T, y: T) -> T;\n \n+    /// Performs an unchecked left shift, resulting in undefined behavior when\n+    /// y < 0 or y >= N, where N is the width of T in bits.\n+    #[cfg(not(stage0))]\n+    pub fn unchecked_shl<T>(x: T, y: T) -> T;\n+    /// Performs an unchecked right shift, resulting in undefined behavior when\n+    /// y < 0 or y >= N, where N is the width of T in bits.\n+    #[cfg(not(stage0))]\n+    pub fn unchecked_shr<T>(x: T, y: T) -> T;\n+\n     /// Returns (a + b) mod 2^N, where N is the width of T in bits.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_add` method. For example,"}, {"sha": "ccfe6364e6af6785061d76fd31c0b02edef62d39", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 99, "deletions": 18, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/1d1543d5667ef1dddf03aa1aeed77851b604f704/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d1543d5667ef1dddf03aa1aeed77851b604f704/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=1d1543d5667ef1dddf03aa1aeed77851b604f704", "patch": "@@ -177,7 +177,7 @@ macro_rules! checked_op {\n \n // `Int` + `SignedInt` implemented for signed integers\n macro_rules! int_impl {\n-    ($ActualT:ident, $UnsignedT:ty, $BITS:expr,\n+    ($SelfT:ty, $ActualT:ident, $UnsignedT:ty, $BITS:expr,\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n@@ -850,6 +850,17 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n+        #[cfg(not(stage0))]\n+        pub fn wrapping_shl(self, rhs: u32) -> Self {\n+            unsafe {\n+                intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n+            }\n+        }\n+\n+        /// Stage 0\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+        #[inline(always)]\n+        #[cfg(stage0)]\n         pub fn wrapping_shl(self, rhs: u32) -> Self {\n             self.overflowing_shl(rhs).0\n         }\n@@ -875,6 +886,17 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n+        #[cfg(not(stage0))]\n+        pub fn wrapping_shr(self, rhs: u32) -> Self {\n+            unsafe {\n+                intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n+            }\n+        }\n+\n+        /// Stage 0\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+        #[inline(always)]\n+        #[cfg(stage0)]\n         pub fn wrapping_shr(self, rhs: u32) -> Self {\n             self.overflowing_shr(rhs).0\n         }\n@@ -1089,6 +1111,15 @@ macro_rules! int_impl {\n         /// ```\n         #[inline]\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[cfg(not(stage0))]\n+        pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n+            (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n+        }\n+\n+        /// Stage 0\n+        #[inline]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[cfg(stage0)]\n         pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n             (self << (rhs & ($BITS - 1)), (rhs > ($BITS - 1)))\n         }\n@@ -1111,6 +1142,15 @@ macro_rules! int_impl {\n         /// ```\n         #[inline]\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[cfg(not(stage0))]\n+        pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n+            (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n+        }\n+\n+        /// Stage 0\n+        #[inline]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[cfg(stage0)]\n         pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n             (self >> (rhs & ($BITS - 1)), (rhs > ($BITS - 1)))\n         }\n@@ -1268,39 +1308,39 @@ macro_rules! int_impl {\n \n #[lang = \"i8\"]\n impl i8 {\n-    int_impl! { i8, u8, 8,\n+    int_impl! { i8, i8, u8, 8,\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n }\n \n #[lang = \"i16\"]\n impl i16 {\n-    int_impl! { i16, u16, 16,\n+    int_impl! { i16, i16, u16, 16,\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n }\n \n #[lang = \"i32\"]\n impl i32 {\n-    int_impl! { i32, u32, 32,\n+    int_impl! { i32, i32, u32, 32,\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n }\n \n #[lang = \"i64\"]\n impl i64 {\n-    int_impl! { i64, u64, 64,\n+    int_impl! { i64, i64, u64, 64,\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n }\n \n #[lang = \"i128\"]\n impl i128 {\n-    int_impl! { i128, u128, 128,\n+    int_impl! { i128, i128, u128, 128,\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n@@ -1309,7 +1349,7 @@ impl i128 {\n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { i16, u16, 16,\n+    int_impl! { isize, i16, u16, 16,\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n@@ -1318,7 +1358,7 @@ impl isize {\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { i32, u32, 32,\n+    int_impl! { isize, i32, u32, 32,\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n@@ -1327,15 +1367,15 @@ impl isize {\n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { i64, u64, 64,\n+    int_impl! { isize, i64, u64, 64,\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n }\n \n // `Int` + `UnsignedInt` implemented for unsigned integers\n macro_rules! uint_impl {\n-    ($ActualT:ty, $BITS:expr,\n+    ($SelfT:ty, $ActualT:ty, $BITS:expr,\n      $ctpop:path,\n      $ctlz:path,\n      $cttz:path,\n@@ -1978,6 +2018,17 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n+        #[cfg(not(stage0))]\n+        pub fn wrapping_shl(self, rhs: u32) -> Self {\n+            unsafe {\n+                intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n+            }\n+        }\n+\n+        /// Stage 0\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+        #[inline(always)]\n+        #[cfg(stage0)]\n         pub fn wrapping_shl(self, rhs: u32) -> Self {\n             self.overflowing_shl(rhs).0\n         }\n@@ -2003,6 +2054,17 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n+        #[cfg(not(stage0))]\n+        pub fn wrapping_shr(self, rhs: u32) -> Self {\n+            unsafe {\n+                intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n+            }\n+        }\n+\n+        /// Stage 0\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+        #[inline(always)]\n+        #[cfg(stage0)]\n         pub fn wrapping_shr(self, rhs: u32) -> Self {\n             self.overflowing_shr(rhs).0\n         }\n@@ -2170,6 +2232,15 @@ macro_rules! uint_impl {\n         /// ```\n         #[inline]\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[cfg(not(stage0))]\n+        pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n+            (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n+        }\n+\n+        /// Stage 0\n+        #[inline]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[cfg(stage0)]\n         pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n             (self << (rhs & ($BITS - 1)), (rhs > ($BITS - 1)))\n         }\n@@ -2192,6 +2263,16 @@ macro_rules! uint_impl {\n         /// ```\n         #[inline]\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[cfg(not(stage0))]\n+        pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n+            (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n+\n+        }\n+\n+        /// Stage 0\n+        #[inline]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[cfg(stage0)]\n         pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n             (self >> (rhs & ($BITS - 1)), (rhs > ($BITS - 1)))\n         }\n@@ -2292,7 +2373,7 @@ macro_rules! uint_impl {\n \n #[lang = \"u8\"]\n impl u8 {\n-    uint_impl! { u8, 8,\n+    uint_impl! { u8, u8, 8,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n         intrinsics::cttz,\n@@ -2304,7 +2385,7 @@ impl u8 {\n \n #[lang = \"u16\"]\n impl u16 {\n-    uint_impl! { u16, 16,\n+    uint_impl! { u16, u16, 16,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n         intrinsics::cttz,\n@@ -2316,7 +2397,7 @@ impl u16 {\n \n #[lang = \"u32\"]\n impl u32 {\n-    uint_impl! { u32, 32,\n+    uint_impl! { u32, u32, 32,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n         intrinsics::cttz,\n@@ -2328,7 +2409,7 @@ impl u32 {\n \n #[lang = \"u64\"]\n impl u64 {\n-    uint_impl! { u64, 64,\n+    uint_impl! { u64, u64, 64,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n         intrinsics::cttz,\n@@ -2340,7 +2421,7 @@ impl u64 {\n \n #[lang = \"u128\"]\n impl u128 {\n-    uint_impl! { u128, 128,\n+    uint_impl! { u128, u128, 128,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n         intrinsics::cttz,\n@@ -2353,7 +2434,7 @@ impl u128 {\n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { u16, 16,\n+    uint_impl! { usize, u16, 16,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n         intrinsics::cttz,\n@@ -2365,7 +2446,7 @@ impl usize {\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { u32, 32,\n+    uint_impl! { usize, u32, 32,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n         intrinsics::cttz,\n@@ -2378,7 +2459,7 @@ impl usize {\n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { u64, 64,\n+    uint_impl! { usize, u64, 64,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n         intrinsics::cttz,"}, {"sha": "762bf8592ffccf83049d8804013b8d00f437141d", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1d1543d5667ef1dddf03aa1aeed77851b604f704/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d1543d5667ef1dddf03aa1aeed77851b604f704/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=1d1543d5667ef1dddf03aa1aeed77851b604f704", "patch": "@@ -261,7 +261,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         \"ctlz\" | \"cttz\" | \"ctpop\" | \"bswap\" |\n         \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" |\n         \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n-        \"unchecked_div\" | \"unchecked_rem\" => {\n+        \"unchecked_div\" | \"unchecked_rem\" | \"unchecked_shl\" | \"unchecked_shr\" => {\n             let sty = &arg_tys[0].sty;\n             match int_type_width_signed(sty, ccx) {\n                 Some((width, signed)) =>\n@@ -311,6 +311,13 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             } else {\n                                 bcx.urem(llargs[0], llargs[1])\n                             },\n+                        \"unchecked_shl\" => bcx.shl(llargs[0], llargs[1]),\n+                        \"unchecked_shr\" =>\n+                            if signed {\n+                                bcx.ashr(llargs[0], llargs[1])\n+                            } else {\n+                                bcx.lshr(llargs[0], llargs[1])\n+                            },\n                         _ => bug!(),\n                     },\n                 None => {"}, {"sha": "2861fd288326b001f639e03bbf4fd7bb7f61a140", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d1543d5667ef1dddf03aa1aeed77851b604f704/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d1543d5667ef1dddf03aa1aeed77851b604f704/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=1d1543d5667ef1dddf03aa1aeed77851b604f704", "patch": "@@ -273,6 +273,8 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             \"unchecked_div\" | \"unchecked_rem\" =>\n                 (1, vec![param(0), param(0)], param(0)),\n+            \"unchecked_shl\" | \"unchecked_shr\" =>\n+                (1, vec![param(0), param(0)], param(0)),\n \n             \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" =>\n                 (1, vec![param(0), param(0)], param(0)),"}]}