{"sha": "41b7d6d74da54b80419ab093303dd356fae957ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxYjdkNmQ3NGRhNTRiODA0MTlhYjA5MzMwM2RkMzU2ZmFlOTU3ZWM=", "commit": {"author": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-01-18T20:23:11Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-18T23:43:13Z"}, "message": "One last refactoring of the import handling:\n\n* Create an import resolving stage. Currently this involves a copy of the ast,\n  we can probably revisit this once we revisit doing full copies of the ast in\n  general.\n\n* Don't repeat work. Once we resolve a import, put it on a hash table and use\n  it next time we are asked for it. This solves a O(n^2) behaviour in\n  degenerated cases.\n\n* Once import resolution is done, the target of an import is stored on the\n  import itself.", "tree": {"sha": "c382e32f867eae4b42aae8a9dcb8882e198211bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c382e32f867eae4b42aae8a9dcb8882e198211bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41b7d6d74da54b80419ab093303dd356fae957ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41b7d6d74da54b80419ab093303dd356fae957ec", "html_url": "https://github.com/rust-lang/rust/commit/41b7d6d74da54b80419ab093303dd356fae957ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41b7d6d74da54b80419ab093303dd356fae957ec/comments", "author": null, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e92298187bceb0cc1cf423dd37e0f5fe30359a17", "url": "https://api.github.com/repos/rust-lang/rust/commits/e92298187bceb0cc1cf423dd37e0f5fe30359a17", "html_url": "https://github.com/rust-lang/rust/commit/e92298187bceb0cc1cf423dd37e0f5fe30359a17"}], "stats": {"total": 209, "additions": 121, "deletions": 88}, "files": [{"sha": "1fad1c1ab313101c84fd0738ee054e86dad26c88", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41b7d6d74da54b80419ab093303dd356fae957ec/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41b7d6d74da54b80419ab093303dd356fae957ec/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=41b7d6d74da54b80419ab093303dd356fae957ec", "patch": "@@ -229,7 +229,7 @@ type variant = rec(str name, vec[variant_arg] args, def_id id, ann ann);\n type view_item = spanned[view_item_];\n tag view_item_ {\n     view_item_use(ident, vec[@meta_item], def_id);\n-    view_item_import(vec[ident], def_id);\n+    view_item_import(vec[ident], def_id, option.t[def]);\n }\n \n type item = spanned[item_];\n@@ -247,7 +247,7 @@ fn index_view_item(mod_index index, @view_item it) {\n         case(ast.view_item_use(?id, _, _)) {\n             index.insert(id, ast.mie_view_item(it));\n         }\n-        case(ast.view_item_import(?ids,_)) {\n+        case(ast.view_item_import(?ids,_,_)) {\n             auto len = _vec.len[ast.ident](ids);\n             auto last_id = ids.(len - 1u);\n             index.insert(last_id, ast.mie_view_item(it));"}, {"sha": "0e8d1dc75892c0eb253c2ebb9025f21a272e3466", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/41b7d6d74da54b80419ab093303dd356fae957ec/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41b7d6d74da54b80419ab093303dd356fae957ec/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=41b7d6d74da54b80419ab093303dd356fae957ec", "patch": "@@ -1704,7 +1704,8 @@ impure fn parse_rest_import_name(parser p, ast.ident id) -> @ast.view_item {\n         identifiers += i;\n     }\n     p.bump();\n-    auto import_decl = ast.view_item_import(identifiers, p.next_def_id());\n+    auto import_decl = ast.view_item_import(identifiers, p.next_def_id(),\n+                                            none[ast.def]);\n     ret @spanned(lo, hi, import_decl);\n }\n "}, {"sha": "f81b7a5225d795e469b027a34d00e8b0029c9fa2", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/41b7d6d74da54b80419ab093303dd356fae957ec/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41b7d6d74da54b80419ab093303dd356fae957ec/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=41b7d6d74da54b80419ab093303dd356fae957ec", "patch": "@@ -210,7 +210,7 @@ type ast_fold[ENV] =\n          def_id id) -> @view_item)                fold_view_item_use,\n \n      (fn(&ENV e, &span sp, vec[ident] idents,\n-         def_id id) -> @view_item)                fold_view_item_import,\n+         def_id id, option.t[def]) -> @view_item) fold_view_item_import,\n \n      // Additional nodes.\n      (fn(&ENV e, &span sp,\n@@ -705,9 +705,10 @@ fn fold_view_item[ENV](&ENV env, ast_fold[ENV] fld, @view_item vi)\n             ret fld.fold_view_item_use(env_, vi.span, ident, meta_items,\n                                        def_id);\n         }\n-        case (ast.view_item_import(?idents, ?def_id)) {\n+        case (ast.view_item_import(?idents, ?def_id, ?target_def)) {\n             // FIXME: what other folding should be done in here?\n-            ret fld.fold_view_item_import(env_, vi.span, idents, def_id);\n+            ret fld.fold_view_item_import(env_, vi.span, idents, def_id,\n+                                          target_def);\n         }\n     }\n \n@@ -1086,8 +1087,9 @@ fn identity_fold_view_item_use[ENV](&ENV e, &span sp, ident i,\n }\n \n fn identity_fold_view_item_import[ENV](&ENV e, &span sp, vec[ident] is,\n-                                       def_id id) -> @view_item {\n-    ret @respan(sp, ast.view_item_import(is, id));\n+                                       def_id id, option.t[def] target_def)\n+    -> @view_item {\n+    ret @respan(sp, ast.view_item_import(is, id, target_def));\n }\n \n // Additional identities.\n@@ -1236,7 +1238,7 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_view_item_use =\n              bind identity_fold_view_item_use[ENV](_,_,_,_,_),\n          fold_view_item_import =\n-             bind identity_fold_view_item_import[ENV](_,_,_,_),\n+             bind identity_fold_view_item_import[ENV](_,_,_,_,_),\n \n          fold_block = bind identity_fold_block[ENV](_,_,_),\n          fold_fn = bind identity_fold_fn[ENV](_,_,_,_,_),"}, {"sha": "7d4def4924aeb787884ca19dc199775acf719486", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 109, "deletions": 79, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/41b7d6d74da54b80419ab093303dd356fae957ec/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41b7d6d74da54b80419ab093303dd356fae957ec/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=41b7d6d74da54b80419ab093303dd356fae957ec", "patch": "@@ -25,7 +25,7 @@ tag scope {\n type env = rec(list[scope] scopes,\n                session.session sess);\n \n-type import_map = std.map.hashmap[ast.def_id,def];\n+type import_map = std.map.hashmap[ast.def_id,def_wrap];\n \n // A simple wrapper over defs that stores a bit more information about modules\n // and uses so that we can use the regular lookup_name when resolving imports.\n@@ -34,68 +34,74 @@ tag def_wrap {\n     def_wrap_import(@ast.view_item);\n     def_wrap_mod(@ast.item);\n     def_wrap_other(def);\n+    def_wrap_resolving;\n }\n \n-fn lookup_name(&env e, import_map index,\n-               ast.ident i) -> option.t[def] {\n-    auto d_ = lookup_name_wrapped(e, i);\n-    alt (d_) {\n-        case (none[tup(@env, def_wrap)]) {\n-            ret none[def];\n-        }\n-        case (some[tup(@env, def_wrap)](?d)) {\n-            alt (d._1) {\n-                case (def_wrap_use(?it)) {\n-                    alt (it.node) {\n-                        case (ast.view_item_use(_, _, ?id)) {\n-                            ret some[def](ast.def_use(id));\n-                        }\n-                    }\n+fn unwrap_def(def_wrap d) -> def {\n+    alt (d) {\n+        case (def_wrap_use(?it)) {\n+            alt (it.node) {\n+                case (ast.view_item_use(_, _, ?id)) {\n+                    ret ast.def_use(id);\n                 }\n-                case (def_wrap_import(?it)) {\n-                    alt (it.node) {\n-                        case (ast.view_item_import(_, ?id)) {\n-                            ret index.find(id);\n+            }\n+        }\n+        case (def_wrap_import(?it)) {\n+            alt (it.node) {\n+                case (ast.view_item_import(_, ?id, ?target_def)) {\n+                    alt (target_def) {\n+                        case (some[def](?d)) {\n+                            ret d;\n                         }\n-                    }\n-                }\n-                case (def_wrap_mod(?i)) {\n-                    alt (i.node) {\n-                        case (ast.item_mod(_, _, ?id)) {\n-                            ret some[def](ast.def_mod(id));\n+                        case (none[def]) {\n+                            fail;\n                         }\n                     }\n                 }\n-                case (def_wrap_other(?d)) {\n-                    ret some[def](d);\n+            }\n+        }\n+        case (def_wrap_mod(?m)) {\n+            alt (m.node) {\n+                case (ast.item_mod(_, _, ?id)) {\n+                    ret ast.def_mod(id);\n                 }\n             }\n         }\n+        case (def_wrap_other(?d)) {\n+            ret d;\n+        }\n+    }\n+}\n+\n+fn lookup_name(&env e, ast.ident i) -> option.t[def] {\n+    auto d_ = lookup_name_wrapped(e, i);\n+    alt (d_) {\n+        case (none[tup(@env, def_wrap)]) {\n+            ret none[def];\n+        }\n+        case (some[tup(@env, def_wrap)](?d)) {\n+            ret some(unwrap_def(d._1));\n+        }\n     }\n }\n \n // Follow the path of an import and return what it ultimately points to.\n \n-fn find_final_def(&env e, &span sp, vec[ident] idents) -> def_wrap {\n+fn find_final_def(&env e, import_map index,\n+                  &span sp, vec[ident] idents,\n+                  ast.def_id import_id) -> def_wrap {\n \n     // We are given a series of identifiers (a.b.c.d) and we know that\n     // in the environment 'e' the identifier 'a' was resolved to 'd'. We\n     // should return what a.b.c.d points to in the end.\n-    fn found_something(&env e, std.map.hashmap[ast.def_id, bool] pending,\n+    fn found_something(&env e, import_map index,\n                        &span sp, vec[ident] idents, def_wrap d) -> def_wrap {\n         alt (d) {\n             case (def_wrap_import(?imp)) {\n                 alt (imp.node) {\n-                    case (ast.view_item_import(?new_idents, ?d)) {\n-                        if (pending.contains_key(d)) {\n-                            e.sess.span_err(sp,\n-                                            \"cyclic import\");\n-                            fail;\n-                        }\n-                        pending.insert(d, true);\n-                        auto x = inner(e, pending, sp, new_idents);\n-                        pending.remove(d);\n-                        ret found_something(e, pending, sp, idents, x);\n+                    case (ast.view_item_import(?new_idents, ?d, _)) {\n+                        auto x = inner(e, index, sp, new_idents, d);\n+                        ret found_something(e, index, sp, idents, x);\n                     }\n                 }\n             }\n@@ -121,7 +127,7 @@ fn find_final_def(&env e, &span sp, vec[ident] idents) -> def_wrap {\n                     }\n                     case (some[tup(@env, def_wrap)](?next)) {\n                         auto combined_e = update_env_for_item(e, i);\n-                        ret found_something(combined_e, pending, sp,\n+                        ret found_something(combined_e, index, sp,\n                                             rest_idents, next._1);\n                     }\n                 }\n@@ -136,22 +142,40 @@ fn find_final_def(&env e, &span sp, vec[ident] idents) -> def_wrap {\n         }\n         fail;\n     }\n-    fn inner(&env e, std.map.hashmap[ast.def_id, bool] pending,\n-             &span sp, vec[ident] idents) -> def_wrap {\n+\n+    fn inner(&env e, import_map index, &span sp, vec[ident] idents,\n+             ast.def_id import_id) -> def_wrap {\n+        alt (index.find(import_id)) {\n+            case (some[def_wrap](?x)) {\n+                alt (x) {\n+                    case (def_wrap_resolving) {\n+                        e.sess.span_err(sp, \"cyclic import\");\n+                        fail;\n+                    }\n+                    case (_) {\n+                        ret x;\n+                    }\n+                }\n+            }\n+            case (none[def_wrap]) {\n+            }\n+        }\n         auto first = idents.(0);\n+        index.insert(import_id, def_wrap_resolving);\n         auto d_ = lookup_name_wrapped(e, first);\n         alt (d_) {\n             case (none[tup(@env, def_wrap)]) {\n                 e.sess.span_err(sp, \"unresolved name: \" + first);\n                 fail;\n             }\n             case (some[tup(@env, def_wrap)](?d)) {\n-                ret found_something(*d._0, pending, sp, idents, d._1);\n+                auto x = found_something(*d._0, index, sp, idents, d._1);\n+                index.insert(import_id, x);\n+                ret x;\n             }\n         }\n     }\n-    auto pending = new_def_hash[bool]();\n-    ret inner(e, pending, sp, idents);\n+    ret inner(e, index, sp, idents, import_id);\n }\n \n fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[tup(@env, def_wrap)] {\n@@ -203,7 +227,7 @@ fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[tup(@env, def_wrap)] {\n             case (ast.view_item_use(_, _, ?id)) {\n                 ret def_wrap_use(i);\n             }\n-            case (ast.view_item_import(?idents,?d)) {\n+            case (ast.view_item_import(?idents,?d, _)) {\n                 ret def_wrap_import(i);\n             }\n         }\n@@ -327,11 +351,11 @@ fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[tup(@env, def_wrap)] {\n     }\n }\n \n-fn fold_pat_tag(&env e, &span sp, import_map index, ident i,\n-                vec[@ast.pat] args, option.t[ast.variant_def] old_def,\n+fn fold_pat_tag(&env e, &span sp, ident i, vec[@ast.pat] args,\n+                option.t[ast.variant_def] old_def,\n                 ann a) -> @ast.pat {\n     auto new_def;\n-    alt (lookup_name(e, index, i)) {\n+    alt (lookup_name(e, i)) {\n         case (some[def](?d)) {\n             alt (d) {\n                 case (ast.def_variant(?did, ?vid)) {\n@@ -372,8 +396,8 @@ fn fold_pat_tag(&env e, &span sp, import_map index, ident i,\n // and split that off as the 'primary' expr_path, with secondary expr_field\n // expressions tacked on the end.\n \n-fn fold_expr_path(&env e, &span sp, import_map index,\n-                  &ast.path p, &option.t[def] d, ann a) -> @ast.expr {\n+fn fold_expr_path(&env e, &span sp, &ast.path p, &option.t[def] d,\n+                  ann a) -> @ast.expr {\n \n     if (_vec.len[@ast.ty](p.node.types) > 0u) {\n         e.sess.unimpl(\"resolving name expr with ty params\");\n@@ -384,7 +408,7 @@ fn fold_expr_path(&env e, &span sp, import_map index,\n     check (n_idents != 0u);\n     auto id0 = p.node.idents.(0);\n \n-    auto d_ = lookup_name(e, index, id0);\n+    auto d_ = lookup_name(e, id0);\n \n     alt (d_) {\n         case (some[def](_)) {\n@@ -413,30 +437,19 @@ fn fold_expr_path(&env e, &span sp, import_map index,\n \n fn fold_view_item_import(&env e, &span sp,\n                          import_map index,\n-                         vec[ident] is, ast.def_id id) -> @ast.view_item {\n+                         vec[ident] is, ast.def_id id,\n+                         option.t[def] target_id) -> @ast.view_item {\n     // Produce errors for invalid imports\n     auto len = _vec.len[ast.ident](is);\n     auto last_id = is.(len - 1u);\n-    auto d = find_final_def(e, sp, is);\n-    alt (d) {\n-        case (def_wrap_mod(?m)) {\n-            alt (m.node) {\n-                case (ast.item_mod(_, _, ?id)) {\n-                    index.insert(id, ast.def_mod(id));\n-                }\n-            }\n-        }\n-        case (def_wrap_other(?target_def)) {\n-            index.insert(id, target_def);\n-        }\n-    }\n-\n-    ret @fold.respan[ast.view_item_](sp, ast.view_item_import(is, id));\n+    auto d = find_final_def(e, index, sp, is, id);\n+    let option.t[def] target_def = some(unwrap_def(d));\n+    ret @fold.respan[ast.view_item_](sp, ast.view_item_import(is, id,\n+                                                              target_def));\n }\n \n \n-fn fold_ty_path(&env e, &span sp, import_map index, ast.path p,\n-                &option.t[def] d) -> @ast.ty {\n+fn fold_ty_path(&env e, &span sp, ast.path p, &option.t[def] d) -> @ast.ty {\n \n     let uint len = _vec.len[ast.ident](p.node.idents);\n     check (len != 0u);\n@@ -448,7 +461,7 @@ fn fold_ty_path(&env e, &span sp, import_map index, ast.path p,\n         e.sess.unimpl(\"resolving path ty with ty params\");\n     }\n \n-    auto d_ = lookup_name(e, index, p.node.idents.(0));\n+    auto d_ = lookup_name(e, p.node.idents.(0));\n \n     alt (d_) {\n         case (some[def](?d)) {\n@@ -478,16 +491,33 @@ fn update_env_for_arm(&env e, &ast.arm p) -> env {\n     ret rec(scopes = cons[scope](scope_arm(p), @e.scopes) with e);\n }\n \n+fn resolve_imports(session.session sess, @ast.crate crate) -> @ast.crate {\n+    let fold.ast_fold[env] fld = fold.new_identity_fold[env]();\n+\n+    auto import_index = new_def_hash[def_wrap]();\n+    fld = @rec( fold_view_item_import\n+                    = bind fold_view_item_import(_,_,import_index,_,_,_),\n+                update_env_for_crate = bind update_env_for_crate(_,_),\n+                update_env_for_item = bind update_env_for_item(_,_),\n+                update_env_for_block = bind update_env_for_block(_,_),\n+                update_env_for_arm = bind update_env_for_arm(_,_)\n+                with *fld );\n+\n+    auto e = rec(scopes = nil[scope],\n+                 sess = sess);\n+\n+    ret fold.fold_crate[env](e, fld, crate);\n+}\n+\n fn resolve_crate(session.session sess, @ast.crate crate) -> @ast.crate {\n \n     let fold.ast_fold[env] fld = fold.new_identity_fold[env]();\n \n-    auto import_index = new_def_hash[def]();\n-    fld = @rec( fold_pat_tag = bind fold_pat_tag(_,_,import_index,_,_,_,_),\n-                fold_expr_path = bind fold_expr_path(_,_,import_index,_,_,_),\n-                fold_view_item_import\n-                    = bind fold_view_item_import(_,_,import_index,_,_),\n-                fold_ty_path = bind fold_ty_path(_,_,import_index,_,_),\n+    auto new_crate = resolve_imports(sess, crate);\n+\n+    fld = @rec( fold_pat_tag = bind fold_pat_tag(_,_,_,_,_,_),\n+                fold_expr_path = bind fold_expr_path(_,_,_,_,_),\n+                fold_ty_path = bind fold_ty_path(_,_,_,_),\n                 update_env_for_crate = bind update_env_for_crate(_,_),\n                 update_env_for_item = bind update_env_for_item(_,_),\n                 update_env_for_block = bind update_env_for_block(_,_),\n@@ -497,7 +527,7 @@ fn resolve_crate(session.session sess, @ast.crate crate) -> @ast.crate {\n     auto e = rec(scopes = nil[scope],\n                  sess = sess);\n \n-    ret fold.fold_crate[env](e, fld, crate);\n+    ret fold.fold_crate[env](e, fld, new_crate);\n }\n \n // Local Variables:"}]}