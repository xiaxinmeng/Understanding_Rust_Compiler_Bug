{"sha": "99d84bacc8fd3cc6ca55bfcfe86714db6adb48a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5ZDg0YmFjYzhmZDNjYzZjYTU1YmZjZmU4NjcxNGRiNmFkYjQ4YTE=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-09-19T14:41:39Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-26T23:20:24Z"}, "message": "libsyntax: remove quasiquoter from auto_serialize2", "tree": {"sha": "6a5538fa987be53c55c3aeac7b44f84cbfd97d40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a5538fa987be53c55c3aeac7b44f84cbfd97d40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99d84bacc8fd3cc6ca55bfcfe86714db6adb48a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99d84bacc8fd3cc6ca55bfcfe86714db6adb48a1", "html_url": "https://github.com/rust-lang/rust/commit/99d84bacc8fd3cc6ca55bfcfe86714db6adb48a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99d84bacc8fd3cc6ca55bfcfe86714db6adb48a1/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2506a1787f27741dc9b577531d72db2b50ca446", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2506a1787f27741dc9b577531d72db2b50ca446", "html_url": "https://github.com/rust-lang/rust/commit/d2506a1787f27741dc9b577531d72db2b50ca446"}], "stats": {"total": 420, "additions": 288, "deletions": 132}, "files": [{"sha": "315a63a406eb8efc17ad0111ad38369176d6b502", "filename": "src/libsyntax/ext/auto_serialize2.rs", "status": "modified", "additions": 288, "deletions": 132, "changes": 420, "blob_url": "https://github.com/rust-lang/rust/blob/99d84bacc8fd3cc6ca55bfcfe86714db6adb48a1/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d84bacc8fd3cc6ca55bfcfe86714db6adb48a1/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs?ref=99d84bacc8fd3cc6ca55bfcfe86714db6adb48a1", "patch": "@@ -114,12 +114,46 @@ fn expand(cx: ext_ctxt,\n     }\n }\n \n+priv impl ext_ctxt {\n+    fn expr_path(span: span, strs: ~[ast::ident]) -> @ast::expr {\n+        self.expr(span, ast::expr_path(self.path(span, strs)))\n+    }\n+\n+    fn expr_var(span: span, var: ~str) -> @ast::expr {\n+        self.expr_path(span, ~[self.ident_of(var)])\n+    }\n+\n+    fn expr_field(\n+        span: span,\n+        expr: @ast::expr,\n+        ident: ast::ident\n+    ) -> @ast::expr {\n+        self.expr(span, ast::expr_field(expr, ident, ~[]))\n+    }\n+\n+    fn expr_call(\n+        span: span,\n+        expr: @ast::expr,\n+        args: ~[@ast::expr]\n+    ) -> @ast::expr {\n+        self.expr(span, ast::expr_call(expr, args, false))\n+    }\n+\n+    fn lambda_expr(expr: @ast::expr) -> @ast::expr {\n+        self.lambda(self.expr_blk(expr))\n+    }\n+\n+    fn lambda_stmts(span: span, stmts: ~[@ast::stmt]) -> @ast::expr {\n+        self.lambda(self.blk(span, stmts))\n+    }\n+}\n+\n fn mk_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n     tps: ~[ast::ty_param],\n-    ser_body: @ast::stmt,\n+    ser_body: @ast::expr,\n     deser_body: @ast::expr\n ) -> @ast::item {\n     // Make a path to the std::serialization2::Serializable trait.\n@@ -161,7 +195,7 @@ fn mk_impl(\n     );\n \n     let methods = ~[\n-        mk_ser_method(cx, span, cx.blk(span, ~[ser_body])),\n+        mk_ser_method(cx, span, cx.expr_blk(ser_body)),\n         mk_deser_method(cx, span, ty, cx.expr_blk(deser_body)),\n     ];\n \n@@ -302,7 +336,7 @@ fn mk_rec_impl(\n \n     let ser_body = mk_ser_fields(cx, span, fields);\n     let deser_body = do mk_deser_fields(cx, span, fields) |fields| {\n-         ast::expr_rec(fields, None)\n+         cx.expr(span, ast::expr_rec(fields, None))\n     };\n \n     mk_impl(cx, span, ident, tps, ser_body, deser_body)\n@@ -337,7 +371,7 @@ fn mk_struct_impl(\n \n     let ser_body = mk_ser_fields(cx, span, fields);\n     let deser_body = do mk_deser_fields(cx, span, fields) |fields| {\n-        ast::expr_struct(cx.path(span, ~[ident]), fields, None)\n+        cx.expr(span, ast::expr_struct(cx.path(span, ~[ident]), fields, None))\n     };\n \n     mk_impl(cx, span, ident, tps, ser_body, deser_body)\n@@ -347,80 +381,104 @@ fn mk_ser_fields(\n     cx: ext_ctxt,\n     span: span,\n     fields: ~[{ span: span, ident: ast::ident, mutbl: ast::mutability }]\n-) -> @ast::stmt {\n-    let ext_cx = cx; // required for #ast{}\n-\n+) -> @ast::expr {\n     let stmts = do fields.mapi |idx, field| {\n-        let name = cx.lit_str(field.span, @cx.str_of(field.ident));\n-        let idx = cx.lit_uint(field.span, idx);\n-\n-        // XXX: The next couple stanzas are just to write\n-        // `self.$(name).serialize(s)`. It'd be nice if the #ast macro could\n-        // write this for us, but it doesn't appear to support quaziquoting a\n-        // value inside a field chain.\n-        let expr_self = cx.expr(\n-            span,\n-            ast::expr_path(\n-                cx.path(span, ~[cx.ident_of(~\"self\")])\n+        // ast for `|| self.$(name).serialize(__s)`\n+        let expr_lambda = cx.lambda_expr(\n+            cx.expr_call(\n+                span,\n+                cx.expr_field(\n+                    span,\n+                    cx.expr_field(\n+                        span,\n+                        cx.expr_var(span, ~\"self\"),\n+                        field.ident\n+                    ),\n+                    cx.ident_of(~\"serialize\")\n+                ),\n+                ~[cx.expr_var(span, ~\"__s\")]\n             )\n         );\n \n-        let expr_name = cx.expr(\n-            span,\n-            ast::expr_field(expr_self, field.ident, ~[])\n-        );\n-\n-        let expr_serialize = cx.expr(\n-            span,\n-            ast::expr_field(expr_name, cx.ident_of(~\"serialize\"), ~[])\n-        );\n-\n-        let expr_arg = cx.expr(\n-            span,\n-            ast::expr_path(\n-                cx.path(span, ~[cx.ident_of(~\"__s\")])\n+        // ast for `__s.emit_rec_field($(name), $(idx), $(expr_lambda))`\n+        cx.stmt(\n+            cx.expr_call(\n+                span,\n+                cx.expr_field(\n+                    span,\n+                    cx.expr_var(span, ~\"__s\"),\n+                    cx.ident_of(~\"emit_rec_field\")\n+                ),\n+                ~[\n+                    cx.lit_str(span, @cx.str_of(field.ident)),\n+                    cx.lit_uint(span, idx),\n+                    expr_lambda,\n+                ]\n             )\n-        );\n-\n-        let expr = cx.expr(\n-            span,\n-            ast::expr_call(expr_serialize, ~[expr_arg], false)\n-        );\n-\n-        #ast[stmt]{ __s.emit_rec_field($(name), $(idx), || $(expr))) }\n+        )\n     };\n \n-    let fields_lambda = cx.lambda(cx.blk(span, stmts));\n-    #ast[stmt]{ __s.emit_rec($(fields_lambda)) }\n+    // ast for `__s.emit_rec(|| $(stmts))`\n+    cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__s\"),\n+            cx.ident_of(~\"emit_rec\")\n+        ),\n+        ~[cx.lambda_stmts(span, stmts)]\n+    )\n }\n \n fn mk_deser_fields(\n     cx: ext_ctxt,\n     span: span,\n     fields: ~[{ span: span, ident: ast::ident, mutbl: ast::mutability }],\n-    f: fn(~[ast::field]) -> ast::expr_\n+    f: fn(~[ast::field]) -> @ast::expr\n ) -> @ast::expr {\n-    let ext_cx = cx; // required for #ast{}\n-\n     let fields = do fields.mapi |idx, field| {\n-        let name = cx.lit_str(\n-            field.span,\n-            @cx.str_of(field.ident)\n+        // ast for `|| deserialize(__d)`\n+        let expr_lambda = cx.lambda(\n+            cx.expr_blk(\n+                cx.expr_call(\n+                    span,\n+                    cx.expr_var(span, ~\"deserialize\"),\n+                    ~[cx.expr_var(span, ~\"__d\")]\n+                )\n+            )\n+        );\n+\n+        // ast for `__d.read_rec_field($(name), $(idx), $(expr_lambda))`\n+        let expr: @ast::expr = cx.expr_call(\n+            span,\n+            cx.expr_field(\n+                span,\n+                cx.expr_var(span, ~\"__d\"),\n+                cx.ident_of(~\"read_rec_field\")\n+            ),\n+            ~[\n+                cx.lit_str(span, @cx.str_of(field.ident)),\n+                cx.lit_uint(span, idx),\n+                expr_lambda,\n+            ]\n         );\n-        let idx = cx.lit_uint(field.span, idx);\n-        let expr = #ast{\n-             __d.read_rec_field($(name), $(idx), || deserialize(__d))\n-        };\n \n         {\n             node: { mutbl: field.mutbl, ident: field.ident, expr: expr },\n-            span: field.span,\n+            span: span,\n         }\n     };\n \n-    let fields_expr = cx.expr(span, f(fields));\n-    let fields_lambda = cx.lambda(cx.expr_blk(fields_expr));\n-    #ast{ __d.read_rec($(fields_lambda)) }\n+    // ast for `__d.read_rec(|| $(fields_expr))`\n+    cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__d\"),\n+            cx.ident_of(~\"read_rec\")\n+        ),\n+        ~[cx.lambda_expr(f(fields))]\n+    )\n }\n \n fn mk_enum_impl(\n@@ -432,15 +490,15 @@ fn mk_enum_impl(\n ) -> @ast::item {\n     let ser_body = mk_enum_ser_body(\n         cx,\n-        ident,\n         span,\n+        ident,\n         enum_def.variants\n     );\n \n     let deser_body = mk_enum_deser_body(\n         cx,\n-        ident,\n         span,\n+        ident,\n         enum_def.variants\n     );\n \n@@ -449,13 +507,11 @@ fn mk_enum_impl(\n \n fn ser_variant(\n     cx: ext_ctxt,\n-    v_span: span,\n+    span: span,\n     v_name: ast::ident,\n-    v_idx: @ast::expr,\n+    v_idx: uint,\n     args: ~[ast::variant_arg]\n ) -> ast::arm {\n-    let ext_cx = cx; // required for #ast{}\n-\n     // Name the variant arguments.\n     let names = args.mapi(|i, _arg| cx.ident_of(fmt!(\"__v%u\", i)));\n \n@@ -465,112 +521,164 @@ fn ser_variant(\n     let pat_node = if pats.is_empty() {\n         ast::pat_ident(\n             ast::bind_by_implicit_ref,\n-            cx.path(v_span, ~[v_name]),\n+            cx.path(span, ~[v_name]),\n             None\n         )\n     } else {\n         ast::pat_enum(\n-            cx.path(v_span, ~[v_name]),\n+            cx.path(span, ~[v_name]),\n             Some(pats)\n         )\n     };\n \n     let pat = @{\n         id: cx.next_id(),\n         node: pat_node,\n-        span: v_span,\n+        span: span,\n     };\n \n-    // Create the s.emit_variant_arg statements.\n     let stmts = do args.mapi |a_idx, _arg| {\n-        let v = cx.var_ref(v_span, names[a_idx]);\n-        let a_idx = cx.lit_uint(v_span, a_idx);\n+        // ast for `__s.emit_enum_variant_arg`\n+        let expr_emit = cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__s\"),\n+            cx.ident_of(~\"emit_enum_variant_arg\")\n+        );\n \n-        #ast[stmt]{\n-            __s.emit_enum_variant_arg($(a_idx), || $(v).serialize(__s));\n-        }\n-    };\n+        // ast for `|| $(v).serialize(__s)`\n+        let expr_serialize = cx.lambda_expr(\n+             cx.expr_call(\n+                span,\n+                cx.expr_field(\n+                    span,\n+                    cx.expr_path(span, ~[names[a_idx]]),\n+                    cx.ident_of(~\"serialize\")\n+                ),\n+                ~[cx.expr_var(span, ~\"__s\")]\n+            )\n+        );\n \n-    let v_name = cx.lit_str(v_span, @cx.str_of(v_name));\n-    let v_sz = cx.lit_uint(v_span, stmts.len());\n-    let lambda = cx.lambda(cx.blk(v_span, stmts));\n-    let body = #ast{\n-         __s.emit_enum_variant($(v_name), $(v_idx), $(v_sz), $(lambda))\n+        // ast for `$(expr_emit)($(a_idx), $(expr_serialize))`\n+        cx.stmt(\n+            cx.expr_call(\n+                span,\n+                expr_emit,\n+                ~[cx.lit_uint(span, a_idx), expr_serialize]\n+            )\n+        )\n     };\n \n+    // ast for `__s.emit_enum_variant($(name), $(idx), $(sz), $(lambda))`\n+    let body = cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__s\"),\n+            cx.ident_of(~\"emit_enum_variant\")\n+        ),\n+        ~[\n+            cx.lit_str(span, @cx.str_of(v_name)),\n+            cx.lit_uint(span, v_idx),\n+            cx.lit_uint(span, stmts.len()),\n+            cx.lambda_stmts(span, stmts),\n+        ]\n+    );\n+\n     { pats: ~[pat], guard: None, body: cx.expr_blk(body) }\n }\n \n fn mk_enum_ser_body(\n     cx: ext_ctxt,\n-    e_name: ast::ident,\n-    e_span: span,\n+    span: span,\n+    name: ast::ident,\n     variants: ~[ast::variant]\n-) -> @ast::stmt {\n-    let ext_cx = cx; // required for #ast{}\n-\n+) -> @ast::expr {\n     let arms = do variants.mapi |v_idx, variant| {\n-        let v_span = variant.span;\n-        let v_name = variant.node.name;\n-        let v_idx = cx.lit_uint(v_span, v_idx);\n-\n         match variant.node.kind {\n             ast::tuple_variant_kind(args) =>\n-                ser_variant(cx, v_span, v_name, v_idx, args),\n+                ser_variant(cx, span, variant.node.name, v_idx, args),\n             ast::struct_variant_kind(*) =>\n                 fail ~\"struct variants unimplemented\",\n             ast::enum_variant_kind(*) =>\n                 fail ~\"enum variants unimplemented\",\n         }\n     };\n \n+    // ast for `match self { $(arms) }`\n     let match_expr = cx.expr(\n-        e_span,\n-        ast::expr_match(#ast{ self }, arms)\n+        span,\n+        ast::expr_match(\n+            cx.expr_var(span, ~\"self\"),\n+            arms\n+        )\n     );\n-    let e_name = cx.lit_str(e_span, @cx.str_of(e_name));\n \n-    #ast[stmt]{ __s.emit_enum($(e_name), || $(match_expr)) }\n+    // ast for `__s.emit_enum($(name), || $(match_expr))`\n+    cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__s\"),\n+            cx.ident_of(~\"emit_enum\")\n+        ),\n+        ~[\n+            cx.lit_str(span, @cx.str_of(name)),\n+            cx.lambda_expr(match_expr),\n+        ]\n+    )\n+}\n+\n+fn mk_enum_deser_variant_nary(\n+    cx: ext_ctxt,\n+    span: span,\n+    name: ast::ident,\n+    args: ~[ast::variant_arg]\n+) -> @ast::expr {\n+    let args = do args.mapi |idx, _arg| {\n+        // ast for `|| deserialize(__d)`\n+        let expr_lambda = cx.lambda_expr(\n+            cx.expr_call(\n+                span,\n+                cx.expr_var(span, ~\"deserialize\"),\n+                ~[cx.expr_var(span, ~\"__d\")]\n+            )\n+        );\n+\n+        // ast for `__d.read_enum_variant_arg($(a_idx), $(expr_lambda))`\n+        cx.expr_call(\n+            span,\n+            cx.expr_field(\n+                span,\n+                cx.expr_var(span, ~\"__d\"),\n+                cx.ident_of(~\"read_enum_variant_arg\")\n+            ),\n+            ~[cx.lit_uint(span, idx), expr_lambda]\n+        )\n+    };\n+\n+    // ast for `$(name)($(args))`\n+    cx.expr_call(span, cx.expr_path(span, ~[name]), args)\n }\n \n fn mk_enum_deser_body(\n     cx: ext_ctxt,\n-    e_name: ast::ident,\n-    e_span: span,\n+    span: span,\n+    name: ast::ident,\n     variants: ~[ast::variant]\n ) -> @ast::expr {\n-    let ext_cx = cx; // required for #ast{}\n-\n     let mut arms = do variants.mapi |v_idx, variant| {\n-        let v_span = variant.span;\n-        let v_name = variant.node.name;\n-\n         let body = match variant.node.kind {\n             ast::tuple_variant_kind(args) => {\n-                let tys = args.map(|a| a.ty);\n-\n-                if tys.is_empty() {\n+                if args.is_empty() {\n                     // for a nullary variant v, do \"v\"\n-                    cx.var_ref(v_span, v_name)\n+                    cx.expr_path(span, ~[variant.node.name])\n                 } else {\n                     // for an n-ary variant v, do \"v(a_1, ..., a_n)\"\n-\n-                    let arg_exprs = do tys.mapi |a_idx, _ty| {\n-                        let a_idx = cx.lit_uint(v_span, a_idx);\n-                        #ast{\n-                            __d.read_enum_variant_arg($(a_idx), || {\n-                                deserialize(__d)\n-                            })\n-                        }\n-                    };\n-\n-                    cx.expr(\n-                        v_span,\n-                        ast::expr_call(\n-                            cx.var_ref(v_span, v_name),\n-                            arg_exprs,\n-                            false\n-                        )\n+                    mk_enum_deser_variant_nary(\n+                        cx,\n+                        span,\n+                        variant.node.name,\n+                        args\n                     )\n                 }\n             },\n@@ -582,8 +690,8 @@ fn mk_enum_deser_body(\n \n         let pat = @{\n             id: cx.next_id(),\n-            node: ast::pat_lit(cx.lit_uint(v_span, v_idx)),\n-            span: v_span,\n+            node: ast::pat_lit(cx.lit_uint(span, v_idx)),\n+            span: span,\n         };\n \n         {\n@@ -594,23 +702,71 @@ fn mk_enum_deser_body(\n     };\n \n     let impossible_case = {\n-        pats: ~[@{ id: cx.next_id(), node: ast::pat_wild, span: e_span}],\n+        pats: ~[@{ id: cx.next_id(), node: ast::pat_wild, span: span}],\n         guard: None,\n \n         // FIXME(#3198): proper error message\n-        body: cx.expr_blk(cx.expr(e_span, ast::expr_fail(None))),\n+        body: cx.expr_blk(cx.expr(span, ast::expr_fail(None))),\n     };\n \n     vec::push(arms, impossible_case);\n \n-    let e_name = cx.lit_str(e_span, @cx.str_of(e_name));\n-    let alt_expr = cx.expr(e_span, ast::expr_match(#ast{ i }, arms));\n+    // ast for `|i| { match i { $(arms) } }`\n+    let expr_lambda = cx.expr(\n+        span,\n+        ast::expr_fn_block(\n+            {\n+                inputs: ~[{\n+                    mode: ast::infer(cx.next_id()),\n+                    ty: @{\n+                        id: cx.next_id(),\n+                        node: ast::ty_infer,\n+                        span: span\n+                    },\n+                    ident: cx.ident_of(~\"i\"),\n+                    id: cx.next_id(),\n+                }],\n+                output: @{\n+                    id: cx.next_id(),\n+                    node: ast::ty_infer,\n+                    span: span,\n+                },\n+                cf: ast::return_val,\n+            },\n+            cx.expr_blk(\n+                cx.expr(\n+                    span,\n+                    ast::expr_match(cx.expr_var(span, ~\"i\"), arms)\n+                )\n+            ),\n+            @~[]\n+        )\n+    );\n \n-    #ast{\n-        __d.read_enum($(e_name), || {\n-            __d.read_enum_variant(|i| {\n-                $(alt_expr)\n-            })\n-        })\n-    }\n+    // ast for `__d.read_enum_variant($(expr_lambda))`\n+    let expr_lambda = cx.lambda_expr(\n+        cx.expr_call(\n+            span,\n+            cx.expr_field(\n+                span,\n+                cx.expr_var(span, ~\"__d\"),\n+                cx.ident_of(~\"read_enum_variant\")\n+            ),\n+            ~[expr_lambda]\n+        )\n+    );\n+\n+    // ast for `__d.read_enum($(e_name), $(expr_lambda))`\n+    cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__d\"),\n+            cx.ident_of(~\"read_enum\")\n+        ),\n+        ~[\n+            cx.lit_str(span, @cx.str_of(name)),\n+            expr_lambda\n+        ]\n+    )\n }"}]}