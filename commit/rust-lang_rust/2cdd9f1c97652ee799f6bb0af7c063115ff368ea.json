{"sha": "2cdd9f1c97652ee799f6bb0af7c063115ff368ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjZGQ5ZjFjOTc2NTJlZTc5OWY2YmIwYWY3YzA2MzExNWZmMzY4ZWE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-06-11T15:47:47Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-07-08T09:42:57Z"}, "message": "Rewrite check_pat_enum, split it into check_pat_tuple_struct and check_pat_path\n\nUpdate definitions in def_map for associated types written in unqualified form (like `Self::Output`)\nCleanup finish_resolving_def_to_ty/resolve_ty_and_def_ufcs\nMake VariantDef's available through constructor IDs", "tree": {"sha": "5cae86f91ec97f62e2a20eab2216e76bb887901b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cae86f91ec97f62e2a20eab2216e76bb887901b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2cdd9f1c97652ee799f6bb0af7c063115ff368ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2cdd9f1c97652ee799f6bb0af7c063115ff368ea", "html_url": "https://github.com/rust-lang/rust/commit/2cdd9f1c97652ee799f6bb0af7c063115ff368ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb32440d4566346294cf2f10592d9657918245d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb32440d4566346294cf2f10592d9657918245d1", "html_url": "https://github.com/rust-lang/rust/commit/eb32440d4566346294cf2f10592d9657918245d1"}], "stats": {"total": 558, "additions": 230, "deletions": 328}, "files": [{"sha": "218681efb7dc167d033b1da220acc94b901bd215", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=2cdd9f1c97652ee799f6bb0af7c063115ff368ea", "patch": "@@ -137,15 +137,6 @@ impl Def {\n         }\n     }\n \n-    pub fn variant_def_ids(&self) -> Option<(DefId, DefId)> {\n-        match *self {\n-            Def::Variant(enum_id, var_id) => {\n-                Some((enum_id, var_id))\n-            }\n-            _ => None\n-        }\n-    }\n-\n     pub fn kind_name(&self) -> &'static str {\n         match *self {\n             Def::Fn(..) => \"function\","}, {"sha": "234edc647f0c83f3699cb4cbabb5bfe959b2dbba", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=2cdd9f1c97652ee799f6bb0af7c063115ff368ea", "patch": "@@ -12,15 +12,12 @@ use hir::def::*;\n use hir::def_id::DefId;\n use hir::{self, PatKind};\n use ty::TyCtxt;\n-use util::nodemap::FnvHashMap;\n use syntax::ast;\n use syntax::codemap::Spanned;\n use syntax_pos::{Span, DUMMY_SP};\n \n use std::iter::{Enumerate, ExactSizeIterator};\n \n-pub type PatIdMap = FnvHashMap<ast::Name, ast::NodeId>;\n-\n pub struct EnumerateAndAdjust<I> {\n     enumerate: Enumerate<I>,\n     gap_pos: usize,\n@@ -97,22 +94,6 @@ pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     }\n }\n \n-// Same as above, except that partially-resolved defs cause `false` to be\n-// returned instead of a panic.\n-pub fn pat_is_resolved_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n-    match pat.node {\n-        PatKind::Path(..) | PatKind::QPath(..) => {\n-            match dm.get(&pat.id)\n-                    .and_then(|d| if d.depth == 0 { Some(d.base_def) }\n-                                  else { None } ) {\n-                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => true,\n-                _ => false\n-            }\n-        }\n-        _ => false\n-    }\n-}\n-\n /// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n /// `match foo() { Some(a) => (), None => () }`\n pub fn pat_bindings<F>(pat: &hir::Pat, mut f: F)"}, {"sha": "4c8fa80dd0b9669acff4ea2d9c13422681943b10", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=2cdd9f1c97652ee799f6bb0af7c063115ff368ea", "patch": "@@ -591,17 +591,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.global_interners.arenas.trait_defs.alloc(def)\n     }\n \n+    pub fn insert_adt_def(self, did: DefId, adt_def: ty::AdtDefMaster<'gcx>) {\n+        // this will need a transmute when reverse-variance is removed\n+        if let Some(prev) = self.adt_defs.borrow_mut().insert(did, adt_def) {\n+            bug!(\"Tried to overwrite interned AdtDef: {:?}\", prev)\n+        }\n+    }\n+\n     pub fn intern_adt_def(self,\n                           did: DefId,\n                           kind: ty::AdtKind,\n                           variants: Vec<ty::VariantDefData<'gcx, 'gcx>>)\n                           -> ty::AdtDefMaster<'gcx> {\n         let def = ty::AdtDefData::new(self, did, kind, variants);\n         let interned = self.global_interners.arenas.adt_defs.alloc(def);\n-        // this will need a transmute when reverse-variance is removed\n-        if let Some(prev) = self.adt_defs.borrow_mut().insert(did, interned) {\n-            bug!(\"Tried to overwrite interned AdtDef: {:?}\", prev)\n-        }\n+        self.insert_adt_def(did, interned);\n         interned\n     }\n "}, {"sha": "93a4b1ac0f40337a18e1d846d3d8d1054d198acd", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=2cdd9f1c97652ee799f6bb0af7c063115ff368ea", "patch": "@@ -2454,6 +2454,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.def_map.borrow().get(&id).map(|resolution| resolution.full_def())\n     }\n \n+    // Returns `ty::VariantDef` if `def` refers to a struct,\n+    // or variant or their constructors, panics otherwise.\n+    pub fn expect_variant_def(self, def: Def) -> VariantDef<'tcx> {\n+        match def {\n+            Def::Variant(enum_did, did) => {\n+                self.lookup_adt_def(enum_did).variant_with_id(did)\n+            }\n+            Def::Struct(did) => {\n+                self.lookup_adt_def(did).struct_variant()\n+            }\n+            _ => bug!(\"expect_variant_def used with unexpected def {:?}\", def)\n+        }\n+    }\n+\n     pub fn def_key(self, id: DefId) -> ast_map::DefKey {\n         if id.is_local() {\n             self.map.def_key(id)"}, {"sha": "4ccfcd9e90356e1d43acee44a70578413bfc9d8f", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=2cdd9f1c97652ee799f6bb0af7c063115ff368ea", "patch": "@@ -471,23 +471,29 @@ pub fn get_adt_def<'a, 'tcx>(intr: &IdentInterner,\n \n     let doc = cdata.lookup_item(item_id);\n     let did = DefId { krate: cdata.cnum, index: item_id };\n+    let mut ctor_did = None;\n     let (kind, variants) = match item_family(doc) {\n         Enum => {\n             (ty::AdtKind::Enum,\n              get_enum_variants(intr, cdata, doc))\n         }\n         Struct(..) => {\n-            let ctor_did =\n-                reader::maybe_get_doc(doc, tag_items_data_item_struct_ctor).\n-                map_or(did, |ctor_doc| translated_def_id(cdata, ctor_doc));\n+            // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n+            ctor_did = reader::maybe_get_doc(doc, tag_items_data_item_struct_ctor).map(|ctor_doc| {\n+                translated_def_id(cdata, ctor_doc)\n+            });\n             (ty::AdtKind::Struct,\n-             vec![get_struct_variant(intr, cdata, doc, ctor_did)])\n+             vec![get_struct_variant(intr, cdata, doc, ctor_did.unwrap_or(did))])\n         }\n         _ => bug!(\"get_adt_def called on a non-ADT {:?} - {:?}\",\n                   item_family(doc), did)\n     };\n \n     let adt = tcx.intern_adt_def(did, kind, variants);\n+    if let Some(ctor_did) = ctor_did {\n+        // Make adt definition available through constructor id as well.\n+        tcx.insert_adt_def(ctor_did, adt);\n+    }\n \n     // this needs to be done *after* the variant is interned,\n     // to support recursive structures"}, {"sha": "9ff30f9ede26295d85f4e94c853d817ce3bf3d84", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=2cdd9f1c97652ee799f6bb0af7c063115ff368ea", "patch": "@@ -53,7 +53,7 @@ use rustc_const_eval::{eval_const_expr_partial, ConstEvalErr};\n use rustc_const_eval::EvalHint::UncheckedExprHint;\n use rustc_const_eval::ErrKind::ErroneousReferencedConstant;\n use hir::{self, SelfKind};\n-use hir::def::{self, Def};\n+use hir::def::{Def, PathResolution};\n use hir::def_id::DefId;\n use hir::print as pprust;\n use middle::resolve_lifetime as rl;\n@@ -1327,7 +1327,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 };\n \n                 if self.ensure_super_predicates(span, trait_did).is_err() {\n-                    return (tcx.types.err, ty_path_def);\n+                    return (tcx.types.err, Def::Err);\n                 }\n \n                 let candidates: Vec<ty::PolyTraitRef> =\n@@ -1341,7 +1341,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                     &assoc_name.as_str(),\n                                                     span) {\n                     Ok(bound) => bound,\n-                    Err(ErrorReported) => return (tcx.types.err, ty_path_def),\n+                    Err(ErrorReported) => return (tcx.types.err, Def::Err),\n                 }\n             }\n             (&ty::TyParam(_), Def::SelfTy(Some(trait_did), None)) => {\n@@ -1351,7 +1351,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                      assoc_name,\n                                                      span) {\n                     Ok(bound) => bound,\n-                    Err(ErrorReported) => return (tcx.types.err, ty_path_def),\n+                    Err(ErrorReported) => return (tcx.types.err, Def::Err),\n                 }\n             }\n             (&ty::TyParam(_), Def::TyParam(_, _, param_did, param_name)) => {\n@@ -1361,15 +1361,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                      assoc_name,\n                                                      span) {\n                     Ok(bound) => bound,\n-                    Err(ErrorReported) => return (tcx.types.err, ty_path_def),\n+                    Err(ErrorReported) => return (tcx.types.err, Def::Err),\n                 }\n             }\n             _ => {\n                 self.report_ambiguous_associated_type(span,\n                                                       &ty.to_string(),\n                                                       \"Trait\",\n                                                       &assoc_name.as_str());\n-                return (tcx.types.err, ty_path_def);\n+                return (tcx.types.err, Def::Err);\n             }\n         };\n \n@@ -1574,45 +1574,46 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n     }\n \n-    // Note that both base_segments and assoc_segments may be empty, although not at\n-    // the same time.\n+    // Resolve possibly associated type path into a type and final definition.\n+    // Note that both base_segments and assoc_segments may be empty, although not at same time.\n     pub fn finish_resolving_def_to_ty(&self,\n                                       rscope: &RegionScope,\n                                       span: Span,\n                                       param_mode: PathParamMode,\n-                                      mut def: Def,\n+                                      base_def: Def,\n                                       opt_self_ty: Option<Ty<'tcx>>,\n                                       base_path_ref_id: ast::NodeId,\n                                       base_segments: &[hir::PathSegment],\n                                       assoc_segments: &[hir::PathSegment])\n                                       -> (Ty<'tcx>, Def) {\n-        debug!(\"finish_resolving_def_to_ty(def={:?}, \\\n+        // Convert the base type.\n+        debug!(\"finish_resolving_def_to_ty(base_def={:?}, \\\n                 base_segments={:?}, \\\n                 assoc_segments={:?})\",\n-               def,\n+               base_def,\n                base_segments,\n                assoc_segments);\n-        let mut ty = self.base_def_to_ty(rscope,\n-                                         span,\n-                                         param_mode,\n-                                         def,\n-                                         opt_self_ty,\n-                                         base_path_ref_id,\n-                                         base_segments);\n-        debug!(\"finish_resolving_def_to_ty: base_def_to_ty returned {:?}\", ty);\n+        let base_ty = self.base_def_to_ty(rscope,\n+                                          span,\n+                                          param_mode,\n+                                          base_def,\n+                                          opt_self_ty,\n+                                          base_path_ref_id,\n+                                          base_segments);\n+        debug!(\"finish_resolving_def_to_ty: base_def_to_ty returned {:?}\", base_ty);\n+\n         // If any associated type segments remain, attempt to resolve them.\n+        let (mut ty, mut def) = (base_ty, base_def);\n         for segment in assoc_segments {\n             debug!(\"finish_resolving_def_to_ty: segment={:?}\", segment);\n-            if ty.sty == ty::TyError {\n+            // This is pretty bad (it will fail except for T::A and Self::A).\n+            let (new_ty, new_def) = self.associated_path_def_to_ty(span, ty, def, segment);\n+            ty = new_ty;\n+            def = new_def;\n+\n+            if def == Def::Err {\n                 break;\n             }\n-            // This is pretty bad (it will fail except for T::A and Self::A).\n-            let (a_ty, a_def) = self.associated_path_def_to_ty(span,\n-                                                               ty,\n-                                                               def,\n-                                                               segment);\n-            ty = a_ty;\n-            def = a_def;\n         }\n         (ty, def)\n     }\n@@ -1719,23 +1720,22 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::TyPath(ref maybe_qself, ref path) => {\n                 debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);\n                 let path_res = tcx.expect_resolution(ast_ty.id);\n-                let def = path_res.base_def;\n                 let base_ty_end = path.segments.len() - path_res.depth;\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n                     self.ast_ty_to_ty(rscope, &qself.ty)\n                 });\n-                let (ty, _def) = self.finish_resolving_def_to_ty(rscope,\n-                                                                 ast_ty.span,\n-                                                                 PathParamMode::Explicit,\n-                                                                 def,\n-                                                                 opt_self_ty,\n-                                                                 ast_ty.id,\n-                                                                 &path.segments[..base_ty_end],\n-                                                                 &path.segments[base_ty_end..]);\n-\n-                if path_res.depth != 0 && ty.sty != ty::TyError {\n-                    // Write back the new resolution.\n-                    tcx.def_map.borrow_mut().insert(ast_ty.id, def::PathResolution::new(def));\n+                let (ty, def) = self.finish_resolving_def_to_ty(rscope,\n+                                                                ast_ty.span,\n+                                                                PathParamMode::Explicit,\n+                                                                path_res.base_def,\n+                                                                opt_self_ty,\n+                                                                ast_ty.id,\n+                                                                &path.segments[..base_ty_end],\n+                                                                &path.segments[base_ty_end..]);\n+\n+                // Write back the new resolution.\n+                if path_res.depth != 0 {\n+                    tcx.def_map.borrow_mut().insert(ast_ty.id, PathResolution::new(def));\n                 }\n \n                 ty"}, {"sha": "82c676adc703d59606931e85984e3b7f97ecb598", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 105, "deletions": 165, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=2cdd9f1c97652ee799f6bb0af7c063115ff368ea", "patch": "@@ -10,13 +10,12 @@\n \n use hir::def::Def;\n use rustc::infer::{self, InferOk, TypeOrigin};\n-use hir::pat_util::{EnumerateAndAdjustIterator, pat_is_resolved_const};\n+use hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n+use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference, VariantKind};\n use check::{FnCtxt, Expectation};\n use lint;\n use util::nodemap::FnvHashMap;\n-use session::Session;\n \n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::cmp;\n@@ -28,20 +27,6 @@ use syntax_pos::Span;\n use rustc::hir::{self, PatKind};\n use rustc::hir::print as pprust;\n \n-// This function exists due to the warning \"diagnostic code E0164 already used\"\n-fn bad_struct_kind_err(sess: &Session, pat: &hir::Pat, path: &hir::Path, lint: bool) {\n-    let name = pprust::path_to_string(path);\n-    let msg = format!(\"`{}` does not name a tuple variant or a tuple struct\", name);\n-    if lint {\n-        sess.add_lint(lint::builtin::MATCH_OF_UNIT_VARIANT_VIA_PAREN_DOTDOT,\n-                      pat.id,\n-                      pat.span,\n-                      msg);\n-    } else {\n-        span_err!(sess, pat.span, E0164, \"{}\", msg);\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_pat(&self, pat: &'gcx hir::Pat, expected: Ty<'tcx>) {\n         let tcx = self.tcx;\n@@ -136,22 +121,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // subtyping doesn't matter here, as the value is some kind of scalar\n                 self.demand_eqtype(pat.span, expected, lhs_ty);\n             }\n-            PatKind::Path(..) if pat_is_resolved_const(&tcx.def_map.borrow(), pat) => {\n-                let const_did = tcx.expect_def(pat.id).def_id();\n-                let const_scheme = tcx.lookup_item_type(const_did);\n-                assert!(const_scheme.generics.is_empty());\n-                let const_ty = self.instantiate_type_scheme(pat.span,\n-                                                            &Substs::empty(),\n-                                                            &const_scheme.ty);\n-                self.write_ty(pat.id, const_ty);\n-\n-                // FIXME(#20489) -- we should limit the types here to scalars or something!\n-\n-                // As with PatKind::Lit, what we really want here is that there\n-                // exist a LUB, but for the cases that can occur, subtype\n-                // is good enough.\n-                self.demand_suptype(pat.span, expected, const_ty);\n-            }\n             PatKind::Binding(bm, _, ref sub) => {\n                 let typ = self.local_ty(pat.span, pat.id);\n                 match bm {\n@@ -197,33 +166,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             PatKind::TupleStruct(ref path, ref subpats, ddpos) => {\n-                self.check_pat_enum(pat, path, &subpats, ddpos, expected, true);\n+                self.check_pat_tuple_struct(pat, path, &subpats, ddpos, expected);\n             }\n             PatKind::Path(ref path) => {\n-                self.check_pat_enum(pat, path, &[], None, expected, false);\n+                self.check_pat_path(pat, None, path, expected);\n             }\n             PatKind::QPath(ref qself, ref path) => {\n-                let self_ty = self.to_ty(&qself.ty);\n-                let path_res = tcx.expect_resolution(pat.id);\n-                if path_res.base_def == Def::Err {\n-                    self.set_tainted_by_errors();\n-                    self.write_error(pat.id);\n-                    return;\n-                }\n-                if let Some((opt_ty, segments, def)) =\n-                        self.resolve_ty_and_def_ufcs(path_res, Some(self_ty),\n-                                                     path, pat.span, pat.id) {\n-                    if self.check_assoc_item_is_const(def, pat.span) {\n-                        let scheme = tcx.lookup_item_type(def.def_id());\n-                        let predicates = tcx.lookup_predicates(def.def_id());\n-                        self.instantiate_path(segments, scheme, &predicates,\n-                                              opt_ty, def, pat.span, pat.id);\n-                        let const_ty = self.node_ty(pat.id);\n-                        self.demand_suptype(pat.span, expected, const_ty);\n-                    } else {\n-                        self.write_error(pat.id)\n-                    }\n-                }\n+                self.check_pat_path(pat, Some(self.to_ty(&qself.ty)), path, expected);\n             }\n             PatKind::Struct(ref path, ref fields, etc) => {\n                 self.check_pat_struct(pat, path, fields, etc, expected);\n@@ -403,20 +352,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // subtyping.\n     }\n \n-    fn check_assoc_item_is_const(&self, def: Def, span: Span) -> bool {\n-        match def {\n-            Def::AssociatedConst(..) => true,\n-            Def::Method(..) => {\n-                span_err!(self.tcx.sess, span, E0327,\n-                          \"associated items in match patterns must be constants\");\n-                false\n-            }\n-            _ => {\n-                span_bug!(span, \"non-associated item in check_assoc_item_is_const\");\n-            }\n-        }\n-    }\n-\n     pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &hir::Pat) -> bool {\n         if let PatKind::Binding(..) = inner.node {\n             if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true, ty::NoPreference) {\n@@ -589,132 +524,137 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         });\n     }\n \n-    fn check_pat_enum(&self,\n+    fn check_pat_path(&self,\n                       pat: &hir::Pat,\n+                      opt_self_ty: Option<Ty<'tcx>>,\n                       path: &hir::Path,\n-                      subpats: &'gcx [P<hir::Pat>],\n-                      ddpos: Option<usize>,\n-                      expected: Ty<'tcx>,\n-                      is_tuple_struct_pat: bool)\n+                      expected: Ty<'tcx>)\n     {\n-        // Typecheck the path.\n         let tcx = self.tcx;\n-\n-        let path_res = tcx.expect_resolution(pat.id);\n-        if path_res.base_def == Def::Err {\n-            self.set_tainted_by_errors();\n+        let report_unexpected_def = || {\n+            span_err!(tcx.sess, pat.span, E0533,\n+                      \"`{}` does not name a unit variant, unit struct or a constant\",\n+                      pprust::path_to_string(path));\n             self.write_error(pat.id);\n-\n-            for pat in subpats {\n-                self.check_pat(&pat, tcx.types.err);\n-            }\n-            return;\n-        }\n-\n-        let (opt_ty, segments, def) = match self.resolve_ty_and_def_ufcs(path_res,\n-                                                                         None, path,\n-                                                                         pat.span, pat.id) {\n-            Some(resolution) => resolution,\n-            // Error handling done inside resolve_ty_and_def_ufcs, so if\n-            // resolution fails just return.\n-            None => {return;}\n         };\n \n-        // Items that were partially resolved before should have been resolved to\n-        // associated constants (i.e. not methods).\n-        if path_res.depth != 0 && !self.check_assoc_item_is_const(def, pat.span) {\n-            self.write_error(pat.id);\n-            return;\n+        // Resolve the path and check the definition for errors.\n+        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(tcx.expect_resolution(pat.id),\n+                                                            opt_self_ty, path, pat.span, pat.id);\n+        match def {\n+            Def::Err => {\n+                self.set_tainted_by_errors();\n+                self.write_error(pat.id);\n+                return;\n+            }\n+            Def::Method(..) => {\n+                report_unexpected_def();\n+                return;\n+            }\n+            Def::Variant(..) | Def::Struct(..) => {\n+                let variant = tcx.expect_variant_def(def);\n+                if variant.kind != VariantKind::Unit {\n+                    report_unexpected_def();\n+                    return;\n+                }\n+            }\n+            Def::Const(..) | Def::AssociatedConst(..) => {} // OK\n+            _ => bug!(\"unexpected pattern definition {:?}\", def)\n         }\n \n-        let enum_def = def.variant_def_ids()\n-            .map_or_else(|| def.def_id(), |(enum_def, _)| enum_def);\n+        // Type check the path.\n+        let scheme = tcx.lookup_item_type(def.def_id());\n+        let predicates = tcx.lookup_predicates(def.def_id());\n+        self.instantiate_path(segments, scheme, &predicates, opt_ty, def, pat.span, pat.id);\n+        let pat_ty = self.node_ty(pat.id);\n+        self.demand_suptype(pat.span, expected, pat_ty);\n+    }\n \n-        let ctor_scheme = tcx.lookup_item_type(enum_def);\n-        let ctor_predicates = tcx.lookup_predicates(enum_def);\n-        let path_scheme = if ctor_scheme.ty.is_fn() {\n-            let fn_ret = tcx.no_late_bound_regions(&ctor_scheme.ty.fn_ret()).unwrap();\n-            ty::TypeScheme {\n-                ty: fn_ret.unwrap(),\n-                generics: ctor_scheme.generics,\n-            }\n-        } else {\n-            ctor_scheme\n-        };\n-        self.instantiate_path(segments, path_scheme, &ctor_predicates,\n-                              opt_ty, def, pat.span, pat.id);\n-        let report_bad_struct_kind = |is_warning| {\n-            bad_struct_kind_err(tcx.sess, pat, path, is_warning);\n-            if is_warning { return; }\n+    fn check_pat_tuple_struct(&self,\n+                              pat: &hir::Pat,\n+                              path: &hir::Path,\n+                              subpats: &'gcx [P<hir::Pat>],\n+                              ddpos: Option<usize>,\n+                              expected: Ty<'tcx>)\n+    {\n+        let tcx = self.tcx;\n+        let on_error = || {\n             self.write_error(pat.id);\n             for pat in subpats {\n                 self.check_pat(&pat, tcx.types.err);\n             }\n         };\n-\n-        // If we didn't have a fully resolved path to start with, we had an\n-        // associated const, and we should quit now, since the rest of this\n-        // function uses checks specific to structs and enums.\n-        if path_res.depth != 0 {\n-            if is_tuple_struct_pat {\n-                report_bad_struct_kind(false);\n+        let report_unexpected_def = |is_lint| {\n+            let msg = format!(\"`{}` does not name a tuple variant or a tuple struct\",\n+                              pprust::path_to_string(path));\n+            if is_lint {\n+                tcx.sess.add_lint(lint::builtin::MATCH_OF_UNIT_VARIANT_VIA_PAREN_DOTDOT,\n+                                  pat.id, pat.span, msg);\n             } else {\n-                let pat_ty = self.node_ty(pat.id);\n-                self.demand_suptype(pat.span, expected, pat_ty);\n-            }\n-            return;\n-        }\n-\n-        let pat_ty = self.node_ty(pat.id);\n-        self.demand_eqtype(pat.span, expected, pat_ty);\n-\n-        let real_path_ty = self.node_ty(pat.id);\n-        let (kind_name, variant, expected_substs) = match real_path_ty.sty {\n-            ty::TyEnum(enum_def, expected_substs) => {\n-                let variant = enum_def.variant_of_def(def);\n-                (\"variant\", variant, expected_substs)\n-            }\n-            ty::TyStruct(struct_def, expected_substs) => {\n-                let variant = struct_def.struct_variant();\n-                (\"struct\", variant, expected_substs)\n-            }\n-            _ => {\n-                report_bad_struct_kind(false);\n-                return;\n+                span_err!(tcx.sess, pat.span, E0164, \"{}\", msg);\n+                on_error();\n             }\n         };\n \n-        match (is_tuple_struct_pat, variant.kind()) {\n-            (true, ty::VariantKind::Unit) if subpats.is_empty() && ddpos.is_some() => {\n-                // Matching unit structs with tuple variant patterns (`UnitVariant(..)`)\n-                // is allowed for backward compatibility.\n-                report_bad_struct_kind(true);\n+        // Resolve the path and check the definition for errors.\n+        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(tcx.expect_resolution(pat.id),\n+                                                                   None, path, pat.span, pat.id);\n+        match def {\n+            Def::Err => {\n+                self.set_tainted_by_errors();\n+                on_error();\n+                return;\n             }\n-            (true, ty::VariantKind::Unit) |\n-            (false, ty::VariantKind::Tuple) |\n-            (_, ty::VariantKind::Struct) => {\n-                report_bad_struct_kind(false);\n-                return\n+            Def::Const(..) | Def::AssociatedConst(..) | Def::Method(..) => {\n+                report_unexpected_def(false);\n+                return;\n             }\n-            _ => {}\n+            Def::Variant(..) | Def::Struct(..) => {} // OK\n+            _ => bug!(\"unexpected pattern definition {:?}\", def)\n+        }\n+        let variant = tcx.expect_variant_def(def);\n+        if variant.kind == VariantKind::Unit && subpats.is_empty() && ddpos.is_some() {\n+            // Matching unit structs with tuple variant patterns (`UnitVariant(..)`)\n+            // is allowed for backward compatibility.\n+            report_unexpected_def(true);\n+        } else if variant.kind != VariantKind::Tuple {\n+            report_unexpected_def(false);\n+            return;\n         }\n \n+        // Type check the path.\n+        let scheme = tcx.lookup_item_type(def.def_id());\n+        let scheme = if scheme.ty.is_fn() {\n+            // Replace constructor type with constructed type for tuple struct patterns.\n+            let fn_ret = tcx.no_late_bound_regions(&scheme.ty.fn_ret()).unwrap().unwrap();\n+            ty::TypeScheme { ty: fn_ret, generics: scheme.generics }\n+        } else {\n+            // Leave the type as is for unit structs (backward compatibility).\n+            scheme\n+        };\n+        let predicates = tcx.lookup_predicates(def.def_id());\n+        self.instantiate_path(segments, scheme, &predicates, opt_ty, def, pat.span, pat.id);\n+        let pat_ty = self.node_ty(pat.id);\n+        self.demand_eqtype(pat.span, expected, pat_ty);\n+\n+        // Type check subpatterns.\n         if subpats.len() == variant.fields.len() ||\n                 subpats.len() < variant.fields.len() && ddpos.is_some() {\n+            let expected_substs = match pat_ty.sty {\n+                ty::TyEnum(_, expected_substs) => expected_substs,\n+                ty::TyStruct(_, expected_substs) => expected_substs,\n+                ref ty => bug!(\"unexpected pattern type {:?}\", ty),\n+            };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n                 let field_ty = self.field_ty(subpat.span, &variant.fields[i], expected_substs);\n                 self.check_pat(&subpat, field_ty);\n             }\n         } else {\n             span_err!(tcx.sess, pat.span, E0023,\n-                      \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n-                      subpats.len(), if subpats.len() == 1 {\"\"} else {\"s\"},\n-                      kind_name,\n-                      variant.fields.len(), if variant.fields.len() == 1 {\"\"} else {\"s\"});\n-\n-            for pat in subpats {\n-                self.check_pat(&pat, tcx.types.err);\n-            }\n+                      \"this pattern has {} field{s}, but the corresponding {} has {} field{s}\",\n+                      subpats.len(), def.kind_name(), variant.fields.len(),\n+                      s = if variant.fields.len() == 1 {\"\"} else {\"s\"});\n+            on_error();\n         }\n     }\n "}, {"sha": "8ea32ebbcc65247908072d659c8ab7d1df0294b2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 27, "deletions": 36, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2cdd9f1c97652ee799f6bb0af7c063115ff368ea", "patch": "@@ -84,7 +84,7 @@ use astconv::{AstConv, ast_region_to_region, PathParamMode};\n use dep_graph::DepNode;\n use fmt_macros::{Parser, Piece, Position};\n use middle::cstore::LOCAL_CRATE;\n-use hir::def::{self, Def};\n+use hir::def::{Def, PathResolution};\n use hir::def_id::DefId;\n use hir::pat_util;\n use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin, TypeTrace, type_variable};\n@@ -3349,24 +3349,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n             self.write_ty(id, oprnd_t);\n           }\n-          hir::ExprPath(ref maybe_qself, ref path) => {\n-              let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n-                  self.to_ty(&qself.ty)\n-              });\n-\n-              let path_res = tcx.expect_resolution(id);\n-              if let Some((opt_ty, segments, def)) =\n-                      self.resolve_ty_and_def_ufcs(path_res, opt_self_ty, path,\n-                                                   expr.span, expr.id) {\n-                  if def != Def::Err {\n-                      let (scheme, predicates) = self.type_scheme_and_predicates_for_def(expr.span,\n-                                                                                         def);\n-                      self.instantiate_path(segments, scheme, &predicates,\n-                                            opt_ty, def, expr.span, id);\n-                  } else {\n-                      self.set_tainted_by_errors();\n-                      self.write_ty(id, self.tcx.types.err);\n-                  }\n+          hir::ExprPath(ref opt_qself, ref path) => {\n+              let opt_self_ty = opt_qself.as_ref().map(|qself| self.to_ty(&qself.ty));\n+              let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(tcx.expect_resolution(id),\n+                                                            opt_self_ty, path, expr.span, expr.id);\n+              if def != Def::Err {\n+                  let (scheme, predicates) = self.type_scheme_and_predicates_for_def(expr.span,\n+                                                                                     def);\n+                  self.instantiate_path(segments, scheme, &predicates, opt_ty, def, expr.span, id);\n+              } else {\n+                  self.set_tainted_by_errors();\n+                  self.write_error(id);\n               }\n \n               // We always require that the type provided as the value for\n@@ -3704,37 +3697,40 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                expected);\n     }\n \n+    // Resolve associated value path into a base type and associated constant or method definition.\n+    // The newly resolved definition is written into `def_map`.\n     pub fn resolve_ty_and_def_ufcs<'b>(&self,\n-                                       path_res: def::PathResolution,\n+                                       path_res: PathResolution,\n                                        opt_self_ty: Option<Ty<'tcx>>,\n                                        path: &'b hir::Path,\n                                        span: Span,\n                                        node_id: ast::NodeId)\n-                                       -> Option<(Option<Ty<'tcx>>, &'b [hir::PathSegment], Def)>\n+                                       -> (Def, Option<Ty<'tcx>>, &'b [hir::PathSegment])\n     {\n-\n         // If fully resolved already, we don't have to do anything.\n         if path_res.depth == 0 {\n-            Some((opt_self_ty, &path.segments, path_res.base_def))\n+            (path_res.base_def, opt_self_ty, &path.segments)\n         } else {\n-            let def = path_res.base_def;\n+            // Try to resolve everything except for the last segment as a type.\n             let ty_segments = path.segments.split_last().unwrap().1;\n             let base_ty_end = path.segments.len() - path_res.depth;\n             let (ty, _def) = AstConv::finish_resolving_def_to_ty(self, self, span,\n                                                                  PathParamMode::Optional,\n-                                                                 def,\n+                                                                 path_res.base_def,\n                                                                  opt_self_ty,\n                                                                  node_id,\n                                                                  &ty_segments[..base_ty_end],\n                                                                  &ty_segments[base_ty_end..]);\n+\n+            // Resolve an associated constant or method on the previously resolved type.\n             let item_segment = path.segments.last().unwrap();\n             let item_name = item_segment.name;\n             let def = match self.resolve_ufcs(span, item_name, ty, node_id) {\n-                Ok(def) => Some(def),\n+                Ok(def) => def,\n                 Err(error) => {\n                     let def = match error {\n-                        method::MethodError::PrivateMatch(def) => Some(def),\n-                        _ => None,\n+                        method::MethodError::PrivateMatch(def) => def,\n+                        _ => Def::Err,\n                     };\n                     if item_name != keywords::Invalid.name() {\n                         self.report_method_error(span, ty, item_name, None, error);\n@@ -3743,14 +3739,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             };\n \n-            if let Some(def) = def {\n-                // Write back the new resolution.\n-                self.tcx().def_map.borrow_mut().insert(node_id, def::PathResolution::new(def));\n-                Some((Some(ty), slice::ref_slice(item_segment), def))\n-            } else {\n-                self.write_error(node_id);\n-                None\n-            }\n+            // Write back the new resolution.\n+            self.tcx().def_map.borrow_mut().insert(node_id, PathResolution::new(def));\n+            (def, Some(ty), slice::ref_slice(item_segment))\n         }\n     }\n "}, {"sha": "cc5886f8bbf16b0b65435ff53eac512f3e94b00f", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=2cdd9f1c97652ee799f6bb0af7c063115ff368ea", "patch": "@@ -1040,15 +1040,17 @@ fn convert_struct_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 def: &hir::VariantData)\n                                 -> ty::AdtDefMaster<'tcx>\n {\n-\n     let did = ccx.tcx.map.local_def_id(it.id);\n-    let ctor_id = if !def.is_struct() {\n-        ccx.tcx.map.local_def_id(def.id())\n-    } else {\n-        did\n-    };\n-    ccx.tcx.intern_adt_def(did, ty::AdtKind::Struct,\n-        vec![convert_struct_variant(ccx, ctor_id, it.name, ConstInt::Infer(0), def)])\n+    // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n+    let ctor_id = if !def.is_struct() { Some(ccx.tcx.map.local_def_id(def.id())) } else { None };\n+    let variants = vec![convert_struct_variant(ccx, ctor_id.unwrap_or(did), it.name,\n+                                               ConstInt::Infer(0), def)];\n+    let adt = ccx.tcx.intern_adt_def(did, ty::AdtKind::Struct, variants);\n+    if let Some(ctor_id) = ctor_id {\n+        // Make adt definition available through constructor id as well.\n+        ccx.tcx.insert_adt_def(ctor_id, adt);\n+    }\n+    adt\n }\n \n     fn evaluate_disr_expr(ccx: &CrateCtxt, repr_ty: attr::IntType, e: &hir::Expr)"}, {"sha": "b4d1f710704c059bdb6874a456f9dded9949fe8e", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 36, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=2cdd9f1c97652ee799f6bb0af7c063115ff368ea", "patch": "@@ -3225,42 +3225,6 @@ impl Foo for Bar {\n ```\n \"##,\n \n-E0327: r##\"\n-You cannot use associated items other than constant items as patterns. This\n-includes method items. Example of erroneous code:\n-\n-```compile_fail\n-enum B {}\n-\n-impl B {\n-    fn bb() -> i32 { 0 }\n-}\n-\n-fn main() {\n-    match 0 {\n-        B::bb => {} // error: associated items in match patterns must\n-                    // be constants\n-    }\n-}\n-```\n-\n-Please check that you're not using a method as a pattern. Example:\n-\n-```\n-enum B {\n-    ba,\n-    bb\n-}\n-\n-fn main() {\n-    match B::ba {\n-        B::bb => {} // ok!\n-        _ => {}\n-    }\n-}\n-```\n-\"##,\n-\n E0329: r##\"\n An attempt was made to access an associated constant through either a generic\n type parameter or `Self`. This is not supported yet. An example causing this\n@@ -4162,4 +4126,5 @@ register_diagnostics! {\n     E0527, // expected {} elements, found {}\n     E0528, // expected at least {} elements, found {}\n     E0529, // slice pattern expects array or slice, not `{}`\n+    E0533, // `{}` does not name a unit variant, unit struct or a constant\n }"}, {"sha": "9404803a32dd863418a79f699f2dec93feaa945e", "filename": "src/test/compile-fail/associated-types/cache/project-fn-ret-contravariant.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.rs?ref=2cdd9f1c97652ee799f6bb0af7c063115ff368ea", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(fn_traits)]\n #![feature(unboxed_closures)]\n #![feature(rustc_attrs)]\n "}, {"sha": "99568213d99073db1e8eda5e3d17c4a166bb52fe", "filename": "src/test/compile-fail/associated-types/cache/project-fn-ret-invariant.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs?ref=2cdd9f1c97652ee799f6bb0af7c063115ff368ea", "patch": "@@ -18,6 +18,7 @@\n \n // revisions: ok oneuse transmute krisskross\n \n+#![feature(fn_traits)]\n #![allow(dead_code, unused_variables)]\n \n use std::marker::PhantomData;"}, {"sha": "74546152ca90fcf77b85c1742cd89768820c8e27", "filename": "src/test/compile-fail/empty-struct-braces-pat-1.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-1.rs?ref=2cdd9f1c97652ee799f6bb0af7c063115ff368ea", "patch": "@@ -31,12 +31,14 @@ fn main() {\n         Empty1 => () // Not an error, `Empty1` is interpreted as a new binding\n     }\n     match e3 {\n-        E::Empty3 => () //~ ERROR `E::Empty3` does not name a tuple variant or a tuple struct\n+        E::Empty3 => ()\n+        //~^ ERROR `E::Empty3` does not name a unit variant, unit struct or a constant\n     }\n     match xe1 {\n         XEmpty1 => () // Not an error, `XEmpty1` is interpreted as a new binding\n     }\n     match xe3 {\n-        XE::XEmpty3 => () //~ ERROR `XE::XEmpty3` does not name a tuple variant or a tuple struct\n+        XE::XEmpty3 => ()\n+        //~^ ERROR `XE::XEmpty3` does not name a unit variant, unit struct or a constant\n     }\n }"}, {"sha": "576451f7292a894c1b8606e94401e5893849723b", "filename": "src/test/compile-fail/issue-32004.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Ftest%2Fcompile-fail%2Fissue-32004.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Ftest%2Fcompile-fail%2Fissue-32004.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32004.rs?ref=2cdd9f1c97652ee799f6bb0af7c063115ff368ea", "patch": "@@ -18,7 +18,7 @@ struct S;\n fn main() {\n     match Foo::Baz {\n         Foo::Bar => {}\n-        //~^ ERROR `Foo::Bar` does not name a tuple variant or a tuple struct\n+        //~^ ERROR `Foo::Bar` does not name a unit variant, unit struct or a constant\n         _ => {}\n     }\n "}, {"sha": "ef011c89c622ba184eb6e986834946681cb8165e", "filename": "src/test/compile-fail/method-path-in-pattern.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Ftest%2Fcompile-fail%2Fmethod-path-in-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Ftest%2Fcompile-fail%2Fmethod-path-in-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-path-in-pattern.rs?ref=2cdd9f1c97652ee799f6bb0af7c063115ff368ea", "patch": "@@ -22,12 +22,13 @@ impl MyTrait for Foo {}\n \n fn main() {\n     match 0u32 {\n-        Foo::bar => {} //~ ERROR E0327\n+        Foo::bar => {} //~ ERROR `Foo::bar` does not name a unit variant, unit struct or a constant\n     }\n     match 0u32 {\n-        <Foo>::bar => {} //~ ERROR E0327\n+        <Foo>::bar => {} //~ ERROR `bar` does not name a unit variant, unit struct or a constant\n     }\n     match 0u32 {\n-        <Foo>::trait_bar => {} //~ ERROR E0327\n+        <Foo>::trait_bar => {}\n+        //~^ ERROR `trait_bar` does not name a unit variant, unit struct or a constant\n     }\n }"}, {"sha": "9034e24a6fee03fab57aa7f722658c8a72b806f5", "filename": "src/test/compile-fail/qualified-path-params.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs?ref=2cdd9f1c97652ee799f6bb0af7c063115ff368ea", "patch": "@@ -27,7 +27,8 @@ impl S {\n \n fn main() {\n     match 10 {\n-        <S as Tr>::A::f::<u8> => {} //~ ERROR associated items in match patterns must be constants\n+        <S as Tr>::A::f::<u8> => {}\n+        //~^ ERROR `Tr::A::f<u8>` does not name a unit variant, unit struct or a constant\n         0 ... <S as Tr>::A::f::<u8> => {} //~ ERROR only char and numeric types are allowed in range\n     }\n }"}, {"sha": "83e3e40b3a820a47bbb92a6889a150506efcb0f4", "filename": "src/test/run-pass/issue-28550.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Ftest%2Frun-pass%2Fissue-28550.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdd9f1c97652ee799f6bb0af7c063115ff368ea/src%2Ftest%2Frun-pass%2Fissue-28550.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-28550.rs?ref=2cdd9f1c97652ee799f6bb0af7c063115ff368ea", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(fn_traits)]\n+\n struct A<F: FnOnce()->T,T>(F::Output);\n struct B<F: FnOnce()->T,T>(A<F,T>);\n "}]}