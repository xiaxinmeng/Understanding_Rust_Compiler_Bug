{"sha": "2b3477d373603527d23cc578f3737857b7b253d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiMzQ3N2QzNzM2MDM1MjdkMjNjYzU3OGYzNzM3ODU3YjdiMjUzZDc=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-24T03:21:17Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-12-19T07:31:34Z"}, "message": "libs: merge librustrt into libstd\n\nThis commit merges the `rustrt` crate into `std`, undoing part of the\nfacade. This merger continues the paring down of the runtime system.\n\nCode relying on the public API of `rustrt` will break; some of this API\nis now available through `std::rt`, but is likely to change and/or be\nremoved very soon.\n\n[breaking-change]", "tree": {"sha": "56022ebf11d5d27a6ef15f15d00d014a84a35837", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56022ebf11d5d27a6ef15f15d00d014a84a35837"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b3477d373603527d23cc578f3737857b7b253d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b3477d373603527d23cc578f3737857b7b253d7", "html_url": "https://github.com/rust-lang/rust/commit/2b3477d373603527d23cc578f3737857b7b253d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b3477d373603527d23cc578f3737857b7b253d7/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "840de072085df360733c48396224e9966e2dc72c", "url": "https://api.github.com/repos/rust-lang/rust/commits/840de072085df360733c48396224e9966e2dc72c", "html_url": "https://github.com/rust-lang/rust/commit/840de072085df360733c48396224e9966e2dc72c"}], "stats": {"total": 3886, "additions": 2111, "deletions": 1775}, "files": [{"sha": "fafe77c78da4e514b8903180e7bc788284b94de9", "filename": "mk/crates.mk", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -51,7 +51,7 @@\n \n TARGET_CRATES := libc std flate arena term \\\n                  serialize getopts collections test time rand \\\n-                 log regex graphviz core rbml alloc rustrt \\\n+                 log regex graphviz core rbml alloc \\\n                  unicode\n RUSTC_CRATES := rustc rustc_typeck rustc_borrowck rustc_driver rustc_trans rustc_back rustc_llvm \n HOST_CRATES := syntax $(RUSTC_CRATES) rustdoc regex_macros fmt_macros\n@@ -62,9 +62,8 @@ DEPS_core :=\n DEPS_libc := core\n DEPS_unicode := core\n DEPS_alloc := core libc native:jemalloc\n-DEPS_rustrt := alloc core libc collections native:rustrt_native\n-DEPS_std := core libc rand alloc collections rustrt unicode \\\n-\tnative:rust_builtin native:backtrace\n+DEPS_std := core libc rand alloc collections unicode \\\n+\tnative:rust_builtin native:backtrace native:rustrt_native\n DEPS_graphviz := std\n DEPS_syntax := std term serialize log fmt_macros arena libc\n DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_borrowck \\"}, {"sha": "c2ed28d81df72d7d247652df6133d789c5babaa0", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -1344,8 +1344,6 @@ pub mod raw {\n \n #[cfg(test)]\n mod tests {\n-    extern crate rustrt;\n-\n     use std::cell::Cell;\n     use std::default::Default;\n     use std::mem;\n@@ -1629,9 +1627,9 @@ mod tests {\n     #[test]\n     fn test_swap_remove_noncopyable() {\n         // Tests that we don't accidentally run destructors twice.\n-        let mut v = vec![rustrt::exclusive::Exclusive::new(()),\n-                         rustrt::exclusive::Exclusive::new(()),\n-                         rustrt::exclusive::Exclusive::new(())];\n+        let mut v = vec![rt::exclusive::Exclusive::new(()),\n+                         rt::exclusive::Exclusive::new(()),\n+                         rt::exclusive::Exclusive::new(())];\n         let mut _e = v.swap_remove(0);\n         assert_eq!(v.len(), 2);\n         _e = v.swap_remove(1);\n@@ -1736,7 +1734,7 @@ mod tests {\n         v2.dedup();\n         /*\n          * If the boxed pointers were leaked or otherwise misused, valgrind\n-         * and/or rustrt should raise errors.\n+         * and/or rt should raise errors.\n          */\n     }\n \n@@ -1750,7 +1748,7 @@ mod tests {\n         v2.dedup();\n         /*\n          * If the pointers were leaked or otherwise misused, valgrind and/or\n-         * rustrt should raise errors.\n+         * rt should raise errors.\n          */\n     }\n "}, {"sha": "74f918b8ee3b46c8f6e6a2c49df91947d8483f44", "filename": "src/librustrt/util.rs", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/840de072085df360733c48396224e9966e2dc72c/src%2Flibrustrt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840de072085df360733c48396224e9966e2dc72c/src%2Flibrustrt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Futil.rs?ref=840de072085df360733c48396224e9966e2dc72c", "patch": "@@ -1,136 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-// ignore-lexer-test FIXME #15677\n-\n-use core::prelude::*;\n-\n-use core::cmp;\n-use core::fmt;\n-use core::intrinsics;\n-use core::slice;\n-use core::str;\n-use libc;\n-\n-// Indicates whether we should perform expensive sanity checks, including rtassert!\n-//\n-// FIXME: Once the runtime matures remove the `true` below to turn off rtassert,\n-//        etc.\n-pub const ENFORCE_SANITY: bool = true || !cfg!(rtopt) || cfg!(rtdebug) ||\n-                                  cfg!(rtassert);\n-\n-pub struct Stdio(libc::c_int);\n-\n-#[allow(non_upper_case_globals)]\n-impl Copy for Stdio {}\n-\n-#[allow(non_upper_case_globals)]\n-pub const Stdout: Stdio = Stdio(libc::STDOUT_FILENO);\n-#[allow(non_upper_case_globals)]\n-pub const Stderr: Stdio = Stdio(libc::STDERR_FILENO);\n-\n-impl fmt::FormatWriter for Stdio {\n-    fn write(&mut self, data: &[u8]) -> fmt::Result {\n-        #[cfg(unix)]\n-        type WriteLen = libc::size_t;\n-        #[cfg(windows)]\n-        type WriteLen = libc::c_uint;\n-        unsafe {\n-            let Stdio(fd) = *self;\n-            libc::write(fd,\n-                        data.as_ptr() as *const libc::c_void,\n-                        data.len() as WriteLen);\n-        }\n-        Ok(()) // yes, we're lying\n-    }\n-}\n-\n-pub fn dumb_print(args: &fmt::Arguments) {\n-    use core::fmt::FormatWriter;\n-    let mut w = Stderr;\n-    let _ = w.write_fmt(args);\n-}\n-\n-pub fn abort(args: &fmt::Arguments) -> ! {\n-    use core::fmt::FormatWriter;\n-\n-    struct BufWriter<'a> {\n-        buf: &'a mut [u8],\n-        pos: uint,\n-    }\n-    impl<'a> FormatWriter for BufWriter<'a> {\n-        fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n-            let left = self.buf[mut self.pos..];\n-            let to_write = bytes[..cmp::min(bytes.len(), left.len())];\n-            slice::bytes::copy_memory(left, to_write);\n-            self.pos += to_write.len();\n-            Ok(())\n-        }\n-    }\n-\n-    // Convert the arguments into a stack-allocated string\n-    let mut msg = [0u8, ..512];\n-    let mut w = BufWriter { buf: &mut msg, pos: 0 };\n-    let _ = write!(&mut w, \"{}\", args);\n-    let msg = str::from_utf8(w.buf[mut ..w.pos]).unwrap_or(\"aborted\");\n-    let msg = if msg.is_empty() {\"aborted\"} else {msg};\n-\n-    // Give some context to the message\n-    let hash = msg.bytes().fold(0, |accum, val| accum + (val as uint) );\n-    let quote = match hash % 10 {\n-        0 => \"\n-It was from the artists and poets that the pertinent answers came, and I\n-know that panic would have broken loose had they been able to compare notes.\n-As it was, lacking their original letters, I half suspected the compiler of\n-having asked leading questions, or of having edited the correspondence in\n-corroboration of what he had latently resolved to see.\",\n-        1 => \"\n-There are not many persons who know what wonders are opened to them in the\n-stories and visions of their youth; for when as children we listen and dream,\n-we think but half-formed thoughts, and when as men we try to remember, we are\n-dulled and prosaic with the poison of life. But some of us awake in the night\n-with strange phantasms of enchanted hills and gardens, of fountains that sing\n-in the sun, of golden cliffs overhanging murmuring seas, of plains that stretch\n-down to sleeping cities of bronze and stone, and of shadowy companies of heroes\n-that ride caparisoned white horses along the edges of thick forests; and then\n-we know that we have looked back through the ivory gates into that world of\n-wonder which was ours before we were wise and unhappy.\",\n-        2 => \"\n-Instead of the poems I had hoped for, there came only a shuddering blackness\n-and ineffable loneliness; and I saw at last a fearful truth which no one had\n-ever dared to breathe before \u2014 the unwhisperable secret of secrets \u2014 The fact\n-that this city of stone and stridor is not a sentient perpetuation of Old New\n-York as London is of Old London and Paris of Old Paris, but that it is in fact\n-quite dead, its sprawling body imperfectly embalmed and infested with queer\n-animate things which have nothing to do with it as it was in life.\",\n-        3 => \"\n-The ocean ate the last of the land and poured into the smoking gulf, thereby\n-giving up all it had ever conquered. From the new-flooded lands it flowed\n-again, uncovering death and decay; and from its ancient and immemorial bed it\n-trickled loathsomely, uncovering nighted secrets of the years when Time was\n-young and the gods unborn. Above the waves rose weedy remembered spires. The\n-moon laid pale lilies of light on dead London, and Paris stood up from its damp\n-grave to be sanctified with star-dust. Then rose spires and monoliths that were\n-weedy but not remembered; terrible spires and monoliths of lands that men never\n-knew were lands...\",\n-        4 => \"\n-There was a night when winds from unknown spaces whirled us irresistibly into\n-limitless vacuum beyond all thought and entity. Perceptions of the most\n-maddeningly untransmissible sort thronged upon us; perceptions of infinity\n-which at the time convulsed us with joy, yet which are now partly lost to my\n-memory and partly incapable of presentation to others.\",\n-        _ => \"You've met with a terrible fate, haven't you?\"\n-    };\n-    rterrln!(\"{}\", \"\");\n-    rterrln!(\"{}\", quote);\n-    rterrln!(\"{}\", \"\");\n-    rterrln!(\"fatal runtime error: {}\", msg);\n-    unsafe { intrinsics::abort(); }\n-}"}, {"sha": "27a139835c9804043b5dbf252b2f3f02a5b97db3", "filename": "src/libstd/c_str.rs", "status": "renamed", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -67,17 +67,17 @@\n //! }\n //! ```\n \n+use string::String;\n+use hash;\n+use fmt;\n+use kinds::marker;\n+use mem;\n use core::prelude::*;\n \n-use collections::string::String;\n-use core::hash;\n-use core::fmt;\n-use core::kinds::{Sized, marker};\n-use core::mem;\n-use core::ptr;\n-use core::raw::Slice;\n-use core::slice;\n-use core::str;\n+use ptr;\n+use raw::Slice;\n+use slice;\n+use str;\n use libc;\n \n /// The representation of a C String.\n@@ -534,9 +534,9 @@ pub unsafe fn from_c_multistring<F>(buf: *const libc::c_char,\n \n #[cfg(test)]\n mod tests {\n-    use std::prelude::*;\n-    use std::ptr;\n-    use std::task;\n+    use prelude::*;\n+    use ptr;\n+    use task;\n     use libc;\n \n     use super::*;\n@@ -726,9 +726,11 @@ mod tests {\n \n #[cfg(test)]\n mod bench {\n-    use test::Bencher;\n+    extern crate test;\n+\n+    use self::test::Bencher;\n     use libc;\n-    use std::prelude::*;\n+    use prelude::*;\n \n     #[inline]\n     fn check(s: &str, c_str: *const libc::c_char) {", "previous_filename": "src/librustrt/c_str.rs"}, {"sha": "dfbb09d26b5b42b27e486e73ed6cfb83bad8c601", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -327,7 +327,7 @@ use alloc::arc::Arc;\n use core::kinds::marker;\n use core::mem;\n use core::cell::UnsafeCell;\n-use rustrt::task::BlockedTask;\n+use rt::task::BlockedTask;\n \n pub use comm::select::{Select, Handle};\n \n@@ -336,9 +336,8 @@ macro_rules! test {\n         mod $name {\n             #![allow(unused_imports)]\n \n-            extern crate rustrt;\n-\n             use prelude::*;\n+            use rt;\n \n             use comm::*;\n             use super::*;\n@@ -1519,7 +1518,7 @@ mod test {\n     } }\n \n     test! { fn sends_off_the_runtime() {\n-        use rustrt::thread::Thread;\n+        use rt::thread::Thread;\n \n         let (tx, rx) = channel();\n         let t = Thread::start(move|| {\n@@ -1534,7 +1533,7 @@ mod test {\n     } }\n \n     test! { fn try_recvs_off_the_runtime() {\n-        use rustrt::thread::Thread;\n+        use rt::thread::Thread;\n \n         let (tx, rx) = channel();\n         let (cdone, pdone) = channel();\n@@ -1984,7 +1983,7 @@ mod sync_tests {\n     } }\n \n     test! { fn try_recvs_off_the_runtime() {\n-        use rustrt::thread::Thread;\n+        use rt::thread::Thread;\n \n         let (tx, rx) = sync_channel::<()>(0);\n         let (cdone, pdone) = channel();"}, {"sha": "2c5248c0897b26bde969966164b9ae6eed2f976e", "filename": "src/libstd/comm/oneshot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fcomm%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fcomm%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Foneshot.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -41,8 +41,8 @@ use core::prelude::*;\n \n use alloc::boxed::Box;\n use core::mem;\n-use rustrt::local::Local;\n-use rustrt::task::{Task, BlockedTask};\n+use rt::local::Local;\n+use rt::task::{Task, BlockedTask};\n \n use sync::atomic;\n use comm::Receiver;"}, {"sha": "4da9b4cfa369f77b87573ec5397374798b09f740", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -59,8 +59,8 @@ use core::cell::Cell;\n use core::kinds::marker;\n use core::mem;\n use core::uint;\n-use rustrt::local::Local;\n-use rustrt::task::{Task, BlockedTask};\n+use rt::local::Local;\n+use rt::task::{Task, BlockedTask};\n \n use comm::Receiver;\n "}, {"sha": "b3856e588e233dd3dcb3dca5f63b97ab803bc670", "filename": "src/libstd/comm/shared.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fshared.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -25,9 +25,9 @@ use core::prelude::*;\n use alloc::boxed::Box;\n use core::cmp;\n use core::int;\n-use rustrt::local::Local;\n-use rustrt::task::{Task, BlockedTask};\n-use rustrt::thread::Thread;\n+use rt::local::Local;\n+use rt::task::{Task, BlockedTask};\n+use rt::thread::Thread;\n \n use sync::{atomic, Mutex, MutexGuard};\n use comm::mpsc_queue as mpsc;"}, {"sha": "827b1d51ac48d2bff566aed715817be49bdc9cda", "filename": "src/libstd/comm/stream.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fcomm%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fcomm%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fstream.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -27,9 +27,9 @@ use core::prelude::*;\n use alloc::boxed::Box;\n use core::cmp;\n use core::int;\n-use rustrt::local::Local;\n-use rustrt::task::{Task, BlockedTask};\n-use rustrt::thread::Thread;\n+use rt::local::Local;\n+use rt::task::{Task, BlockedTask};\n+use rt::thread::Thread;\n \n use sync::atomic;\n use comm::spsc_queue as spsc;"}, {"sha": "933cd43c662aa86be83ac5bea1378d4347ed88c4", "filename": "src/libstd/comm/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fsync.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -42,9 +42,9 @@ use alloc::boxed::Box;\n use vec::Vec;\n use core::mem;\n use core::cell::UnsafeCell;\n-use rustrt::local::Local;\n-use rustrt::mutex::{NativeMutex, LockGuard};\n-use rustrt::task::{Task, BlockedTask};\n+use rt::local::Local;\n+use rt::mutex::{NativeMutex, LockGuard};\n+use rt::task::{Task, BlockedTask};\n \n use sync::atomic;\n "}, {"sha": "5438f1920d6f99423b9fede4fe49a1552d35bee8", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -20,9 +20,9 @@ use option::Option;\n use option::Option::{Some, None};\n use result::Result::Ok;\n use rt::backtrace;\n-use rustrt::{Stderr, Stdio};\n-use rustrt::local::Local;\n-use rustrt::task::Task;\n+use rt::util::{Stderr, Stdio};\n+use rt::local::Local;\n+use rt::task::Task;\n use str::Str;\n use string::String;\n "}, {"sha": "7b5cbf7d58f55170960977f2a0c06849c61ca6b5", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -42,9 +42,8 @@ use option::Option::{Some, None};\n use ops::{Deref, DerefMut, FnOnce};\n use result::Result::{Ok, Err};\n use rt;\n-use rustrt;\n-use rustrt::local::Local;\n-use rustrt::task::Task;\n+use rt::local::Local;\n+use rt::task::Task;\n use slice::SliceExt;\n use str::StrPrelude;\n use string::String;\n@@ -345,7 +344,7 @@ fn with_task_stdout<F>(f: F) where\n         });\n         result\n     } else {\n-        let mut io = rustrt::Stdout;\n+        let mut io = rt::util::Stdout;\n         f(&mut io as &mut Writer)\n     };\n     match result {"}, {"sha": "d7f331b6c230e7b9606d2f34d4007685d1c862cb", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -104,7 +104,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![allow(unknown_features)]\n-#![feature(macro_rules, globs, linkage)]\n+#![feature(macro_rules, globs, linkage, thread_local, asm)]\n #![feature(default_type_params, phase, lang_items, unsafe_destructor)]\n #![feature(import_shadowing, slicing_syntax)]\n #![feature(unboxed_closures)]\n@@ -124,7 +124,6 @@ extern crate core;\n extern crate \"collections\" as core_collections;\n extern crate \"rand\" as core_rand;\n extern crate libc;\n-extern crate rustrt;\n \n // Make std testable by not duplicating lang items. See #2912\n #[cfg(test)] extern crate \"std\" as realstd;\n@@ -167,12 +166,8 @@ pub use core_collections::str;\n pub use core_collections::string;\n pub use core_collections::vec;\n \n-pub use rustrt::c_str;\n-\n pub use unicode::char;\n \n-pub use rustrt::thunk;\n-\n /* Exported macros */\n \n pub mod macros;\n@@ -207,6 +202,7 @@ pub mod prelude;\n #[path = \"num/f64.rs\"]   pub mod f64;\n \n pub mod ascii;\n+pub mod thunk;\n \n /* Common traits */\n \n@@ -216,6 +212,7 @@ pub mod num;\n /* Runtime and platform support */\n \n pub mod thread_local;\n+pub mod c_str;\n pub mod c_vec;\n pub mod dynamic_lib;\n pub mod fmt;"}, {"sha": "6e02c03602f1c34b9f14de8d24d3de85a33e60f6", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -1042,9 +1042,9 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n           target_os = \"freebsd\",\n           target_os = \"dragonfly\"))]\n fn real_args_as_bytes() -> Vec<Vec<u8>> {\n-    use rustrt;\n+    use rt;\n \n-    match rustrt::args::clone() {\n+    match rt::args::clone() {\n         Some(args) => args,\n         None => panic!(\"process arguments not initialized\")\n     }"}, {"sha": "8b9dbf73c53b90a39255aba992a6238ec7cd3e2e", "filename": "src/libstd/rt/args.rs", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -20,7 +20,7 @@\n //! FIXME #7756: Would be nice for this to not exist.\n \n use core::prelude::*;\n-use collections::vec::Vec;\n+use vec::Vec;\n \n /// One-time global initialization.\n pub unsafe fn init(argc: int, argv: *const *const u8) { imp::init(argc, argv) }\n@@ -46,12 +46,12 @@ pub fn clone() -> Option<Vec<Vec<u8>>> { imp::clone() }\n mod imp {\n     use core::prelude::*;\n \n-    use alloc::boxed::Box;\n-    use collections::vec::Vec;\n-    use collections::string::String;\n-    use core::mem;\n+    use boxed::Box;\n+    use vec::Vec;\n+    use string::String;\n+    use mem;\n \n-    use mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+    use rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n     static mut GLOBAL_ARGS_PTR: uint = 0;\n     static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n@@ -145,7 +145,7 @@ mod imp {\n           target_os = \"windows\"))]\n mod imp {\n     use core::prelude::*;\n-    use collections::vec::Vec;\n+    use vec::Vec;\n \n     pub unsafe fn init(_argc: int, _argv: *const *const u8) {\n     }", "previous_filename": "src/librustrt/args.rs"}, {"sha": "086079c312ad4c3dc6b471fd098dafbc188c4076", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -14,13 +14,13 @@\n \n use core::prelude::*;\n \n-use alloc::boxed::Box;\n-use collections::vec::Vec;\n-use core::atomic;\n-use core::mem;\n-use thunk::{Thunk};\n+use boxed::Box;\n+use vec::Vec;\n+use sync::atomic;\n+use mem;\n+use thunk::Thunk;\n \n-use exclusive::Exclusive;\n+use rt::exclusive::Exclusive;\n \n type Queue = Exclusive<Vec<Thunk>>;\n ", "previous_filename": "src/librustrt/at_exit_imp.rs"}, {"sha": "40885823a0596f60e246efb8303501d38c8627a8", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 3, "deletions": 975, "changes": 978, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -19,9 +19,8 @@ use os;\n use result::Result::{Ok, Err};\n use str::{StrPrelude, from_str};\n use sync::atomic;\n-use unicode::char::UnicodeChar;\n \n-pub use self::imp::write;\n+pub use sys::backtrace::write;\n \n // For now logging is turned off by default, and this function checks to see\n // whether the magical environment variable is present to see if it's turned on.\n@@ -41,984 +40,13 @@ pub fn log_enabled() -> bool {\n     val == 2\n }\n \n-#[cfg(target_word_size = \"64\")] const HEX_WIDTH: uint = 18;\n-#[cfg(target_word_size = \"32\")] const HEX_WIDTH: uint = 10;\n-\n-// All rust symbols are in theory lists of \"::\"-separated identifiers. Some\n-// assemblers, however, can't handle these characters in symbol names. To get\n-// around this, we use C++-style mangling. The mangling method is:\n-//\n-// 1. Prefix the symbol with \"_ZN\"\n-// 2. For each element of the path, emit the length plus the element\n-// 3. End the path with \"E\"\n-//\n-// For example, \"_ZN4testE\" => \"test\" and \"_ZN3foo3bar\" => \"foo::bar\".\n-//\n-// We're the ones printing our backtraces, so we can't rely on anything else to\n-// demangle our symbols. It's *much* nicer to look at demangled symbols, so\n-// this function is implemented to give us nice pretty output.\n-//\n-// Note that this demangler isn't quite as fancy as it could be. We have lots\n-// of other information in our symbols like hashes, version, type information,\n-// etc. Additionally, this doesn't handle glue symbols at all.\n-fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n-    // First validate the symbol. If it doesn't look like anything we're\n-    // expecting, we just print it literally. Note that we must handle non-rust\n-    // symbols because we could have any function in the backtrace.\n-    let mut valid = true;\n-    let mut inner = s;\n-    if s.len() > 4 && s.starts_with(\"_ZN\") && s.ends_with(\"E\") {\n-        inner = s.slice(3, s.len() - 1);\n-    // On Windows, dbghelp strips leading underscores, so we accept \"ZN...E\" form too.\n-    } else if s.len() > 3 && s.starts_with(\"ZN\") && s.ends_with(\"E\") {\n-        inner = s.slice(2, s.len() - 1);\n-    } else {\n-        valid = false;\n-    }\n-\n-    if valid {\n-        let mut chars = inner.chars();\n-        while valid {\n-            let mut i = 0;\n-            for c in chars {\n-                if c.is_numeric() {\n-                    i = i * 10 + c as uint - '0' as uint;\n-                } else {\n-                    break\n-                }\n-            }\n-            if i == 0 {\n-                valid = chars.next().is_none();\n-                break\n-            } else if chars.by_ref().take(i - 1).count() != i - 1 {\n-                valid = false;\n-            }\n-        }\n-    }\n-\n-    // Alright, let's do this.\n-    if !valid {\n-        try!(writer.write_str(s));\n-    } else {\n-        let mut first = true;\n-        while inner.len() > 0 {\n-            if !first {\n-                try!(writer.write_str(\"::\"));\n-            } else {\n-                first = false;\n-            }\n-            let mut rest = inner;\n-            while rest.char_at(0).is_numeric() {\n-                rest = rest.slice_from(1);\n-            }\n-            let i: uint = from_str(inner.slice_to(inner.len() - rest.len())).unwrap();\n-            inner = rest.slice_from(i);\n-            rest = rest.slice_to(i);\n-            while rest.len() > 0 {\n-                if rest.starts_with(\"$\") {\n-                    macro_rules! demangle {\n-                        ($($pat:expr => $demangled:expr),*) => ({\n-                            $(if rest.starts_with($pat) {\n-                                try!(writer.write_str($demangled));\n-                                rest = rest.slice_from($pat.len());\n-                              } else)*\n-                            {\n-                                try!(writer.write_str(rest));\n-                                break;\n-                            }\n-\n-                        })\n-                    }\n-\n-                    // see src/librustc/back/link.rs for these mappings\n-                    demangle! (\n-                        \"$SP$\" => \"@\",\n-                        \"$UP$\" => \"Box\",\n-                        \"$RP$\" => \"*\",\n-                        \"$BP$\" => \"&\",\n-                        \"$LT$\" => \"<\",\n-                        \"$GT$\" => \">\",\n-                        \"$LP$\" => \"(\",\n-                        \"$RP$\" => \")\",\n-                        \"$C$\"  => \",\",\n-\n-                        // in theory we can demangle any Unicode code point, but\n-                        // for simplicity we just catch the common ones.\n-                        \"$x20\" => \" \",\n-                        \"$x27\" => \"'\",\n-                        \"$x5b\" => \"[\",\n-                        \"$x5d\" => \"]\"\n-                    )\n-                } else {\n-                    let idx = match rest.find('$') {\n-                        None => rest.len(),\n-                        Some(i) => i,\n-                    };\n-                    try!(writer.write_str(rest.slice_to(idx)));\n-                    rest = rest.slice_from(idx);\n-                }\n-            }\n-        }\n-    }\n-\n-    Ok(())\n-}\n-\n-/// Backtrace support built on libgcc with some extra OS-specific support\n-///\n-/// Some methods of getting a backtrace:\n-///\n-/// * The backtrace() functions on unix. It turns out this doesn't work very\n-///   well for green threads on OSX, and the address to symbol portion of it\n-///   suffers problems that are described below.\n-///\n-/// * Using libunwind. This is more difficult than it sounds because libunwind\n-///   isn't installed everywhere by default. It's also a bit of a hefty library,\n-///   so possibly not the best option. When testing, libunwind was excellent at\n-///   getting both accurate backtraces and accurate symbols across platforms.\n-///   This route was not chosen in favor of the next option, however.\n-///\n-/// * We're already using libgcc_s for exceptions in rust (triggering task\n-///   unwinding and running destructors on the stack), and it turns out that it\n-///   conveniently comes with a function that also gives us a backtrace. All of\n-///   these functions look like _Unwind_*, but it's not quite the full\n-///   repertoire of the libunwind API. Due to it already being in use, this was\n-///   the chosen route of getting a backtrace.\n-///\n-/// After choosing libgcc_s for backtraces, the sad part is that it will only\n-/// give us a stack trace of instruction pointers. Thankfully these instruction\n-/// pointers are accurate (they work for green and native threads), but it's\n-/// then up to us again to figure out how to translate these addresses to\n-/// symbols. As with before, we have a few options. Before, that, a little bit\n-/// of an interlude about symbols. This is my very limited knowledge about\n-/// symbol tables, and this information is likely slightly wrong, but the\n-/// general idea should be correct.\n-///\n-/// When talking about symbols, it's helpful to know a few things about where\n-/// symbols are located. Some symbols are located in the dynamic symbol table\n-/// of the executable which in theory means that they're available for dynamic\n-/// linking and lookup. Other symbols end up only in the local symbol table of\n-/// the file. This loosely corresponds to pub and priv functions in Rust.\n-///\n-/// Armed with this knowledge, we know that our solution for address to symbol\n-/// translation will need to consult both the local and dynamic symbol tables.\n-/// With that in mind, here's our options of translating an address to\n-/// a symbol.\n-///\n-/// * Use dladdr(). The original backtrace()-based idea actually uses dladdr()\n-///   behind the scenes to translate, and this is why backtrace() was not used.\n-///   Conveniently, this method works fantastically on OSX. It appears dladdr()\n-///   uses magic to consult the local symbol table, or we're putting everything\n-///   in the dynamic symbol table anyway. Regardless, for OSX, this is the\n-///   method used for translation. It's provided by the system and easy to do.o\n-///\n-///   Sadly, all other systems have a dladdr() implementation that does not\n-///   consult the local symbol table. This means that most functions are blank\n-///   because they don't have symbols. This means that we need another solution.\n-///\n-/// * Use unw_get_proc_name(). This is part of the libunwind api (not the\n-///   libgcc_s version of the libunwind api), but involves taking a dependency\n-///   to libunwind. We may pursue this route in the future if we bundle\n-///   libunwind, but libunwind was unwieldy enough that it was not chosen at\n-///   this time to provide this functionality.\n-///\n-/// * Shell out to a utility like `readelf`. Crazy though it may sound, it's a\n-///   semi-reasonable solution. The stdlib already knows how to spawn processes,\n-///   so in theory it could invoke readelf, parse the output, and consult the\n-///   local/dynamic symbol tables from there. This ended up not getting chosen\n-///   due to the craziness of the idea plus the advent of the next option.\n-///\n-/// * Use `libbacktrace`. It turns out that this is a small library bundled in\n-///   the gcc repository which provides backtrace and symbol translation\n-///   functionality. All we really need from it is the backtrace functionality,\n-///   and we only really need this on everything that's not OSX, so this is the\n-///   chosen route for now.\n-///\n-/// In summary, the current situation uses libgcc_s to get a trace of stack\n-/// pointers, and we use dladdr() or libbacktrace to translate these addresses\n-/// to symbols. This is a bit of a hokey implementation as-is, but it works for\n-/// all unix platforms we support right now, so it at least gets the job done.\n-#[cfg(unix)]\n-mod imp {\n-    use prelude::*;\n-\n-    use c_str::CString;\n-    use io::IoResult;\n-    use libc;\n-    use mem;\n-    use sync::{StaticMutex, MUTEX_INIT};\n-\n-    /// As always - iOS on arm uses SjLj exceptions and\n-    /// _Unwind_Backtrace is even not available there. Still,\n-    /// backtraces could be extracted using a backtrace function,\n-    /// which thanks god is public\n-    ///\n-    /// As mentioned in a huge comment block above, backtrace doesn't\n-    /// play well with green threads, so while it is extremely nice\n-    /// and simple to use it should be used only on iOS devices as the\n-    /// only viable option.\n-    #[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n-    #[inline(never)]\n-    pub fn write(w: &mut Writer) -> IoResult<()> {\n-        use result;\n-\n-        extern {\n-            fn backtrace(buf: *mut *mut libc::c_void,\n-                         sz: libc::c_int) -> libc::c_int;\n-        }\n-\n-        // while it doesn't requires lock for work as everything is\n-        // local, it still displays much nicer backtraces when a\n-        // couple of tasks panic simultaneously\n-        static LOCK: StaticMutex = MUTEX_INIT;\n-        let _g = LOCK.lock();\n-\n-        try!(writeln!(w, \"stack backtrace:\"));\n-        // 100 lines should be enough\n-        const SIZE: uint = 100;\n-        let mut buf: [*mut libc::c_void, ..SIZE] = unsafe {mem::zeroed()};\n-        let cnt = unsafe { backtrace(buf.as_mut_ptr(), SIZE as libc::c_int) as uint};\n-\n-        // skipping the first one as it is write itself\n-        let iter = range(1, cnt).map(|i| {\n-            print(w, i as int, buf[i])\n-        });\n-        result::fold(iter, (), |_, _| ())\n-    }\n-\n-    #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n-    #[inline(never)] // if we know this is a function call, we can skip it when\n-                     // tracing\n-    pub fn write(w: &mut Writer) -> IoResult<()> {\n-        use io::IoError;\n-\n-        struct Context<'a> {\n-            idx: int,\n-            writer: &'a mut (Writer+'a),\n-            last_error: Option<IoError>,\n-        }\n-\n-        // When using libbacktrace, we use some necessary global state, so we\n-        // need to prevent more than one thread from entering this block. This\n-        // is semi-reasonable in terms of printing anyway, and we know that all\n-        // I/O done here is blocking I/O, not green I/O, so we don't have to\n-        // worry about this being a native vs green mutex.\n-        static LOCK: StaticMutex = MUTEX_INIT;\n-        let _g = LOCK.lock();\n-\n-        try!(writeln!(w, \"stack backtrace:\"));\n-\n-        let mut cx = Context { writer: w, last_error: None, idx: 0 };\n-        return match unsafe {\n-            uw::_Unwind_Backtrace(trace_fn,\n-                                  &mut cx as *mut Context as *mut libc::c_void)\n-        } {\n-            uw::_URC_NO_REASON => {\n-                match cx.last_error {\n-                    Some(err) => Err(err),\n-                    None => Ok(())\n-                }\n-            }\n-            _ => Ok(()),\n-        };\n-\n-        extern fn trace_fn(ctx: *mut uw::_Unwind_Context,\n-                           arg: *mut libc::c_void) -> uw::_Unwind_Reason_Code {\n-            let cx: &mut Context = unsafe { mem::transmute(arg) };\n-            let ip = unsafe { uw::_Unwind_GetIP(ctx) as *mut libc::c_void };\n-            // dladdr() on osx gets whiny when we use FindEnclosingFunction, and\n-            // it appears to work fine without it, so we only use\n-            // FindEnclosingFunction on non-osx platforms. In doing so, we get a\n-            // slightly more accurate stack trace in the process.\n-            //\n-            // This is often because panic involves the last instruction of a\n-            // function being \"call std::rt::begin_unwind\", with no ret\n-            // instructions after it. This means that the return instruction\n-            // pointer points *outside* of the calling function, and by\n-            // unwinding it we go back to the original function.\n-            let ip = if cfg!(target_os = \"macos\") || cfg!(target_os = \"ios\") {\n-                ip\n-            } else {\n-                unsafe { uw::_Unwind_FindEnclosingFunction(ip) }\n-            };\n-\n-            // Don't print out the first few frames (they're not user frames)\n-            cx.idx += 1;\n-            if cx.idx <= 0 { return uw::_URC_NO_REASON }\n-            // Don't print ginormous backtraces\n-            if cx.idx > 100 {\n-                match write!(cx.writer, \" ... <frames omitted>\\n\") {\n-                    Ok(()) => {}\n-                    Err(e) => { cx.last_error = Some(e); }\n-                }\n-                return uw::_URC_FAILURE\n-            }\n-\n-            // Once we hit an error, stop trying to print more frames\n-            if cx.last_error.is_some() { return uw::_URC_FAILURE }\n-\n-            match print(cx.writer, cx.idx, ip) {\n-                Ok(()) => {}\n-                Err(e) => { cx.last_error = Some(e); }\n-            }\n-\n-            // keep going\n-            return uw::_URC_NO_REASON\n-        }\n-    }\n-\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-    fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n-        use intrinsics;\n-        #[repr(C)]\n-        struct Dl_info {\n-            dli_fname: *const libc::c_char,\n-            dli_fbase: *mut libc::c_void,\n-            dli_sname: *const libc::c_char,\n-            dli_saddr: *mut libc::c_void,\n-        }\n-        extern {\n-            fn dladdr(addr: *const libc::c_void,\n-                      info: *mut Dl_info) -> libc::c_int;\n-        }\n-\n-        let mut info: Dl_info = unsafe { intrinsics::init() };\n-        if unsafe { dladdr(addr as *const libc::c_void, &mut info) == 0 } {\n-            output(w, idx,addr, None)\n-        } else {\n-            output(w, idx, addr, Some(unsafe {\n-                CString::new(info.dli_sname, false)\n-            }))\n-        }\n-    }\n-\n-    #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n-    fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n-        use os;\n-        use ptr;\n-\n-        ////////////////////////////////////////////////////////////////////////\n-        // libbacktrace.h API\n-        ////////////////////////////////////////////////////////////////////////\n-        type backtrace_syminfo_callback =\n-            extern \"C\" fn(data: *mut libc::c_void,\n-                          pc: libc::uintptr_t,\n-                          symname: *const libc::c_char,\n-                          symval: libc::uintptr_t,\n-                          symsize: libc::uintptr_t);\n-        type backtrace_error_callback =\n-            extern \"C\" fn(data: *mut libc::c_void,\n-                          msg: *const libc::c_char,\n-                          errnum: libc::c_int);\n-        enum backtrace_state {}\n-        #[link(name = \"backtrace\", kind = \"static\")]\n-        #[cfg(not(test))]\n-        extern {}\n-\n-        extern {\n-            fn backtrace_create_state(filename: *const libc::c_char,\n-                                      threaded: libc::c_int,\n-                                      error: backtrace_error_callback,\n-                                      data: *mut libc::c_void)\n-                                            -> *mut backtrace_state;\n-            fn backtrace_syminfo(state: *mut backtrace_state,\n-                                 addr: libc::uintptr_t,\n-                                 cb: backtrace_syminfo_callback,\n-                                 error: backtrace_error_callback,\n-                                 data: *mut libc::c_void) -> libc::c_int;\n-        }\n-\n-        ////////////////////////////////////////////////////////////////////////\n-        // helper callbacks\n-        ////////////////////////////////////////////////////////////////////////\n-\n-        extern fn error_cb(_data: *mut libc::c_void, _msg: *const libc::c_char,\n-                           _errnum: libc::c_int) {\n-            // do nothing for now\n-        }\n-        extern fn syminfo_cb(data: *mut libc::c_void,\n-                             _pc: libc::uintptr_t,\n-                             symname: *const libc::c_char,\n-                             _symval: libc::uintptr_t,\n-                             _symsize: libc::uintptr_t) {\n-            let slot = data as *mut *const libc::c_char;\n-            unsafe { *slot = symname; }\n-        }\n-\n-        // The libbacktrace API supports creating a state, but it does not\n-        // support destroying a state. I personally take this to mean that a\n-        // state is meant to be created and then live forever.\n-        //\n-        // I would love to register an at_exit() handler which cleans up this\n-        // state, but libbacktrace provides no way to do so.\n-        //\n-        // With these constraints, this function has a statically cached state\n-        // that is calculated the first time this is requested. Remember that\n-        // backtracing all happens serially (one global lock).\n-        //\n-        // An additionally oddity in this function is that we initialize the\n-        // filename via self_exe_name() to pass to libbacktrace. It turns out\n-        // that on Linux libbacktrace seamlessly gets the filename of the\n-        // current executable, but this fails on freebsd. by always providing\n-        // it, we make sure that libbacktrace never has a reason to not look up\n-        // the symbols. The libbacktrace API also states that the filename must\n-        // be in \"permanent memory\", so we copy it to a static and then use the\n-        // static as the pointer.\n-        //\n-        // FIXME: We also call self_exe_name() on DragonFly BSD. I haven't\n-        //        tested if this is required or not.\n-        unsafe fn init_state() -> *mut backtrace_state {\n-            static mut STATE: *mut backtrace_state = 0 as *mut backtrace_state;\n-            static mut LAST_FILENAME: [libc::c_char, ..256] = [0, ..256];\n-            if !STATE.is_null() { return STATE }\n-            let selfname = if cfg!(target_os = \"freebsd\") ||\n-                              cfg!(target_os = \"dragonfly\") {\n-                os::self_exe_name()\n-            } else {\n-                None\n-            };\n-            let filename = match selfname {\n-                Some(path) => {\n-                    let bytes = path.as_vec();\n-                    if bytes.len() < LAST_FILENAME.len() {\n-                        let i = bytes.iter();\n-                        for (slot, val) in LAST_FILENAME.iter_mut().zip(i) {\n-                            *slot = *val as libc::c_char;\n-                        }\n-                        LAST_FILENAME.as_ptr()\n-                    } else {\n-                        ptr::null()\n-                    }\n-                }\n-                None => ptr::null(),\n-            };\n-            STATE = backtrace_create_state(filename, 0, error_cb,\n-                                           ptr::null_mut());\n-            return STATE\n-        }\n-\n-        ////////////////////////////////////////////////////////////////////////\n-        // translation\n-        ////////////////////////////////////////////////////////////////////////\n-\n-        // backtrace errors are currently swept under the rug, only I/O\n-        // errors are reported\n-        let state = unsafe { init_state() };\n-        if state.is_null() {\n-            return output(w, idx, addr, None)\n-        }\n-        let mut data = 0 as *const libc::c_char;\n-        let data_addr = &mut data as *mut *const libc::c_char;\n-        let ret = unsafe {\n-            backtrace_syminfo(state, addr as libc::uintptr_t,\n-                              syminfo_cb, error_cb,\n-                              data_addr as *mut libc::c_void)\n-        };\n-        if ret == 0 || data.is_null() {\n-            output(w, idx, addr, None)\n-        } else {\n-            output(w, idx, addr, Some(unsafe { CString::new(data, false) }))\n-        }\n-    }\n-\n-    // Finally, after all that work above, we can emit a symbol.\n-    fn output(w: &mut Writer, idx: int, addr: *mut libc::c_void,\n-              s: Option<CString>) -> IoResult<()> {\n-        try!(write!(w, \"  {:2}: {:2$} - \", idx, addr, super::HEX_WIDTH));\n-        match s.as_ref().and_then(|c| c.as_str()) {\n-            Some(string) => try!(super::demangle(w, string)),\n-            None => try!(write!(w, \"<unknown>\")),\n-        }\n-        w.write(&['\\n' as u8])\n-    }\n-\n-    /// Unwind library interface used for backtraces\n-    ///\n-    /// Note that the native libraries come from librustrt, not this\n-    /// module.\n-    /// Note that dead code is allowed as here are just bindings\n-    /// iOS doesn't use all of them it but adding more\n-    /// platform-specific configs pollutes the code too much\n-    #[allow(non_camel_case_types)]\n-    #[allow(non_snake_case)]\n-    #[allow(dead_code)]\n-    mod uw {\n-        pub use self::_Unwind_Reason_Code::*;\n-\n-        use libc;\n-\n-        #[repr(C)]\n-        pub enum _Unwind_Reason_Code {\n-            _URC_NO_REASON = 0,\n-            _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n-            _URC_FATAL_PHASE2_ERROR = 2,\n-            _URC_FATAL_PHASE1_ERROR = 3,\n-            _URC_NORMAL_STOP = 4,\n-            _URC_END_OF_STACK = 5,\n-            _URC_HANDLER_FOUND = 6,\n-            _URC_INSTALL_CONTEXT = 7,\n-            _URC_CONTINUE_UNWIND = 8,\n-            _URC_FAILURE = 9, // used only by ARM EABI\n-        }\n-\n-        pub enum _Unwind_Context {}\n-\n-        pub type _Unwind_Trace_Fn =\n-                extern fn(ctx: *mut _Unwind_Context,\n-                          arg: *mut libc::c_void) -> _Unwind_Reason_Code;\n-\n-        extern {\n-            // No native _Unwind_Backtrace on iOS\n-            #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n-            pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,\n-                                     trace_argument: *mut libc::c_void)\n-                        -> _Unwind_Reason_Code;\n-\n-            #[cfg(all(not(target_os = \"android\"),\n-                      not(all(target_os = \"linux\", target_arch = \"arm\"))))]\n-            pub fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t;\n-\n-            #[cfg(all(not(target_os = \"android\"),\n-                      not(all(target_os = \"linux\", target_arch = \"arm\"))))]\n-            pub fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)\n-                -> *mut libc::c_void;\n-        }\n-\n-        // On android, the function _Unwind_GetIP is a macro, and this is the\n-        // expansion of the macro. This is all copy/pasted directly from the\n-        // header file with the definition of _Unwind_GetIP.\n-        #[cfg(any(target_os = \"android\",\n-                  all(target_os = \"linux\", target_arch = \"arm\")))]\n-        pub unsafe fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t {\n-            #[repr(C)]\n-            enum _Unwind_VRS_Result {\n-                _UVRSR_OK = 0,\n-                _UVRSR_NOT_IMPLEMENTED = 1,\n-                _UVRSR_FAILED = 2,\n-            }\n-            #[repr(C)]\n-            enum _Unwind_VRS_RegClass {\n-                _UVRSC_CORE = 0,\n-                _UVRSC_VFP = 1,\n-                _UVRSC_FPA = 2,\n-                _UVRSC_WMMXD = 3,\n-                _UVRSC_WMMXC = 4,\n-            }\n-            #[repr(C)]\n-            enum _Unwind_VRS_DataRepresentation {\n-                _UVRSD_UINT32 = 0,\n-                _UVRSD_VFPX = 1,\n-                _UVRSD_FPAX = 2,\n-                _UVRSD_UINT64 = 3,\n-                _UVRSD_FLOAT = 4,\n-                _UVRSD_DOUBLE = 5,\n-            }\n-\n-            type _Unwind_Word = libc::c_uint;\n-            extern {\n-                fn _Unwind_VRS_Get(ctx: *mut _Unwind_Context,\n-                                   klass: _Unwind_VRS_RegClass,\n-                                   word: _Unwind_Word,\n-                                   repr: _Unwind_VRS_DataRepresentation,\n-                                   data: *mut libc::c_void)\n-                    -> _Unwind_VRS_Result;\n-            }\n-\n-            let mut val: _Unwind_Word = 0;\n-            let ptr = &mut val as *mut _Unwind_Word;\n-            let _ = _Unwind_VRS_Get(ctx, _Unwind_VRS_RegClass::_UVRSC_CORE, 15,\n-                                    _Unwind_VRS_DataRepresentation::_UVRSD_UINT32,\n-                                    ptr as *mut libc::c_void);\n-            (val & !1) as libc::uintptr_t\n-        }\n-\n-        // This function also doesn't exist on Android or ARM/Linux, so make it\n-        // a no-op\n-        #[cfg(any(target_os = \"android\",\n-                  all(target_os = \"linux\", target_arch = \"arm\")))]\n-        pub unsafe fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)\n-            -> *mut libc::c_void\n-        {\n-            pc\n-        }\n-    }\n-}\n-\n-/// As always, windows has something very different than unix, we mainly want\n-/// to avoid having to depend too much on libunwind for windows.\n-///\n-/// If you google around, you'll find a fair bit of references to built-in\n-/// functions to get backtraces on windows. It turns out that most of these are\n-/// in an external library called dbghelp. I was unable to find this library\n-/// via `-ldbghelp`, but it is apparently normal to do the `dlopen` equivalent\n-/// of it.\n-///\n-/// You'll also find that there's a function called CaptureStackBackTrace\n-/// mentioned frequently (which is also easy to use), but sadly I didn't have a\n-/// copy of that function in my mingw install (maybe it was broken?). Instead,\n-/// this takes the route of using StackWalk64 in order to walk the stack.\n-#[cfg(windows)]\n-#[allow(dead_code, non_snake_case)]\n-mod imp {\n-    use c_str::CString;\n-    use intrinsics;\n-    use io::{IoResult, Writer};\n-    use libc;\n-    use mem;\n-    use ops::Drop;\n-    use option::Option::{Some, None};\n-    use path::Path;\n-    use result::Result::{Ok, Err};\n-    use sync::{StaticMutex, MUTEX_INIT};\n-    use slice::SliceExt;\n-    use str::StrPrelude;\n-    use dynamic_lib::DynamicLibrary;\n-\n-    #[allow(non_snake_case)]\n-    extern \"system\" {\n-        fn GetCurrentProcess() -> libc::HANDLE;\n-        fn GetCurrentThread() -> libc::HANDLE;\n-        fn RtlCaptureContext(ctx: *mut arch::CONTEXT);\n-    }\n-\n-    type SymFromAddrFn =\n-        extern \"system\" fn(libc::HANDLE, u64, *mut u64,\n-                           *mut SYMBOL_INFO) -> libc::BOOL;\n-    type SymInitializeFn =\n-        extern \"system\" fn(libc::HANDLE, *mut libc::c_void,\n-                           libc::BOOL) -> libc::BOOL;\n-    type SymCleanupFn =\n-        extern \"system\" fn(libc::HANDLE) -> libc::BOOL;\n-\n-    type StackWalk64Fn =\n-        extern \"system\" fn(libc::DWORD, libc::HANDLE, libc::HANDLE,\n-                           *mut STACKFRAME64, *mut arch::CONTEXT,\n-                           *mut libc::c_void, *mut libc::c_void,\n-                           *mut libc::c_void, *mut libc::c_void) -> libc::BOOL;\n-\n-    const MAX_SYM_NAME: uint = 2000;\n-    const IMAGE_FILE_MACHINE_I386: libc::DWORD = 0x014c;\n-    const IMAGE_FILE_MACHINE_IA64: libc::DWORD = 0x0200;\n-    const IMAGE_FILE_MACHINE_AMD64: libc::DWORD = 0x8664;\n-\n-    #[repr(C)]\n-    struct SYMBOL_INFO {\n-        SizeOfStruct: libc::c_ulong,\n-        TypeIndex: libc::c_ulong,\n-        Reserved: [u64, ..2],\n-        Index: libc::c_ulong,\n-        Size: libc::c_ulong,\n-        ModBase: u64,\n-        Flags: libc::c_ulong,\n-        Value: u64,\n-        Address: u64,\n-        Register: libc::c_ulong,\n-        Scope: libc::c_ulong,\n-        Tag: libc::c_ulong,\n-        NameLen: libc::c_ulong,\n-        MaxNameLen: libc::c_ulong,\n-        // note that windows has this as 1, but it basically just means that\n-        // the name is inline at the end of the struct. For us, we just bump\n-        // the struct size up to MAX_SYM_NAME.\n-        Name: [libc::c_char, ..MAX_SYM_NAME],\n-    }\n-\n-\n-    #[repr(C)]\n-    enum ADDRESS_MODE {\n-        AddrMode1616,\n-        AddrMode1632,\n-        AddrModeReal,\n-        AddrModeFlat,\n-    }\n-\n-    struct ADDRESS64 {\n-        Offset: u64,\n-        Segment: u16,\n-        Mode: ADDRESS_MODE,\n-    }\n-\n-    struct STACKFRAME64 {\n-        AddrPC: ADDRESS64,\n-        AddrReturn: ADDRESS64,\n-        AddrFrame: ADDRESS64,\n-        AddrStack: ADDRESS64,\n-        AddrBStore: ADDRESS64,\n-        FuncTableEntry: *mut libc::c_void,\n-        Params: [u64, ..4],\n-        Far: libc::BOOL,\n-        Virtual: libc::BOOL,\n-        Reserved: [u64, ..3],\n-        KdHelp: KDHELP64,\n-    }\n-\n-    struct KDHELP64 {\n-        Thread: u64,\n-        ThCallbackStack: libc::DWORD,\n-        ThCallbackBStore: libc::DWORD,\n-        NextCallback: libc::DWORD,\n-        FramePointer: libc::DWORD,\n-        KiCallUserMode: u64,\n-        KeUserCallbackDispatcher: u64,\n-        SystemRangeStart: u64,\n-        KiUserExceptionDispatcher: u64,\n-        StackBase: u64,\n-        StackLimit: u64,\n-        Reserved: [u64, ..5],\n-    }\n-\n-    #[cfg(target_arch = \"x86\")]\n-    mod arch {\n-        use libc;\n-\n-        const MAXIMUM_SUPPORTED_EXTENSION: uint = 512;\n-\n-        #[repr(C)]\n-        pub struct CONTEXT {\n-            ContextFlags: libc::DWORD,\n-            Dr0: libc::DWORD,\n-            Dr1: libc::DWORD,\n-            Dr2: libc::DWORD,\n-            Dr3: libc::DWORD,\n-            Dr6: libc::DWORD,\n-            Dr7: libc::DWORD,\n-            FloatSave: FLOATING_SAVE_AREA,\n-            SegGs: libc::DWORD,\n-            SegFs: libc::DWORD,\n-            SegEs: libc::DWORD,\n-            SegDs: libc::DWORD,\n-            Edi: libc::DWORD,\n-            Esi: libc::DWORD,\n-            Ebx: libc::DWORD,\n-            Edx: libc::DWORD,\n-            Ecx: libc::DWORD,\n-            Eax: libc::DWORD,\n-            Ebp: libc::DWORD,\n-            Eip: libc::DWORD,\n-            SegCs: libc::DWORD,\n-            EFlags: libc::DWORD,\n-            Esp: libc::DWORD,\n-            SegSs: libc::DWORD,\n-            ExtendedRegisters: [u8, ..MAXIMUM_SUPPORTED_EXTENSION],\n-        }\n-\n-        #[repr(C)]\n-        pub struct FLOATING_SAVE_AREA {\n-            ControlWord: libc::DWORD,\n-            StatusWord: libc::DWORD,\n-            TagWord: libc::DWORD,\n-            ErrorOffset: libc::DWORD,\n-            ErrorSelector: libc::DWORD,\n-            DataOffset: libc::DWORD,\n-            DataSelector: libc::DWORD,\n-            RegisterArea: [u8, ..80],\n-            Cr0NpxState: libc::DWORD,\n-        }\n-\n-        pub fn init_frame(frame: &mut super::STACKFRAME64,\n-                          ctx: &CONTEXT) -> libc::DWORD {\n-            frame.AddrPC.Offset = ctx.Eip as u64;\n-            frame.AddrPC.Mode = super::ADDRESS_MODE::AddrModeFlat;\n-            frame.AddrStack.Offset = ctx.Esp as u64;\n-            frame.AddrStack.Mode = super::ADDRESS_MODE::AddrModeFlat;\n-            frame.AddrFrame.Offset = ctx.Ebp as u64;\n-            frame.AddrFrame.Mode = super::ADDRESS_MODE::AddrModeFlat;\n-            super::IMAGE_FILE_MACHINE_I386\n-        }\n-    }\n-\n-    #[cfg(target_arch = \"x86_64\")]\n-    mod arch {\n-        use libc::{c_longlong, c_ulonglong};\n-        use libc::types::os::arch::extra::{WORD, DWORD, DWORDLONG};\n-        use simd;\n-\n-        #[repr(C)]\n-        pub struct CONTEXT {\n-            _align_hack: [simd::u64x2, ..0], // FIXME align on 16-byte\n-            P1Home: DWORDLONG,\n-            P2Home: DWORDLONG,\n-            P3Home: DWORDLONG,\n-            P4Home: DWORDLONG,\n-            P5Home: DWORDLONG,\n-            P6Home: DWORDLONG,\n-\n-            ContextFlags: DWORD,\n-            MxCsr: DWORD,\n-\n-            SegCs: WORD,\n-            SegDs: WORD,\n-            SegEs: WORD,\n-            SegFs: WORD,\n-            SegGs: WORD,\n-            SegSs: WORD,\n-            EFlags: DWORD,\n-\n-            Dr0: DWORDLONG,\n-            Dr1: DWORDLONG,\n-            Dr2: DWORDLONG,\n-            Dr3: DWORDLONG,\n-            Dr6: DWORDLONG,\n-            Dr7: DWORDLONG,\n-\n-            Rax: DWORDLONG,\n-            Rcx: DWORDLONG,\n-            Rdx: DWORDLONG,\n-            Rbx: DWORDLONG,\n-            Rsp: DWORDLONG,\n-            Rbp: DWORDLONG,\n-            Rsi: DWORDLONG,\n-            Rdi: DWORDLONG,\n-            R8:  DWORDLONG,\n-            R9:  DWORDLONG,\n-            R10: DWORDLONG,\n-            R11: DWORDLONG,\n-            R12: DWORDLONG,\n-            R13: DWORDLONG,\n-            R14: DWORDLONG,\n-            R15: DWORDLONG,\n-\n-            Rip: DWORDLONG,\n-\n-            FltSave: FLOATING_SAVE_AREA,\n-\n-            VectorRegister: [M128A, .. 26],\n-            VectorControl: DWORDLONG,\n-\n-            DebugControl: DWORDLONG,\n-            LastBranchToRip: DWORDLONG,\n-            LastBranchFromRip: DWORDLONG,\n-            LastExceptionToRip: DWORDLONG,\n-            LastExceptionFromRip: DWORDLONG,\n-        }\n-\n-        #[repr(C)]\n-        pub struct M128A {\n-            _align_hack: [simd::u64x2, ..0], // FIXME align on 16-byte\n-            Low:  c_ulonglong,\n-            High: c_longlong\n-        }\n-\n-        #[repr(C)]\n-        pub struct FLOATING_SAVE_AREA {\n-            _align_hack: [simd::u64x2, ..0], // FIXME align on 16-byte\n-            _Dummy: [u8, ..512] // FIXME: Fill this out\n-        }\n-\n-        pub fn init_frame(frame: &mut super::STACKFRAME64,\n-                          ctx: &CONTEXT) -> DWORD {\n-            frame.AddrPC.Offset = ctx.Rip as u64;\n-            frame.AddrPC.Mode = super::ADDRESS_MODE::AddrModeFlat;\n-            frame.AddrStack.Offset = ctx.Rsp as u64;\n-            frame.AddrStack.Mode = super::ADDRESS_MODE::AddrModeFlat;\n-            frame.AddrFrame.Offset = ctx.Rbp as u64;\n-            frame.AddrFrame.Mode = super::ADDRESS_MODE::AddrModeFlat;\n-            super::IMAGE_FILE_MACHINE_AMD64\n-        }\n-    }\n-\n-    #[repr(C)]\n-    struct Cleanup {\n-        handle: libc::HANDLE,\n-        SymCleanup: SymCleanupFn,\n-    }\n-\n-    impl Drop for Cleanup {\n-        fn drop(&mut self) { (self.SymCleanup)(self.handle); }\n-    }\n-\n-    pub fn write(w: &mut Writer) -> IoResult<()> {\n-        // According to windows documentation, all dbghelp functions are\n-        // single-threaded.\n-        static LOCK: StaticMutex = MUTEX_INIT;\n-        let _g = LOCK.lock();\n-\n-        // Open up dbghelp.dll, we don't link to it explicitly because it can't\n-        // always be found. Additionally, it's nice having fewer dependencies.\n-        let path = Path::new(\"dbghelp.dll\");\n-        let lib = match DynamicLibrary::open(Some(&path)) {\n-            Ok(lib) => lib,\n-            Err(..) => return Ok(()),\n-        };\n-\n-        macro_rules! sym { ($e:expr, $t:ident) => (unsafe {\n-            match lib.symbol($e) {\n-                Ok(f) => mem::transmute::<*mut u8, $t>(f),\n-                Err(..) => return Ok(())\n-            }\n-        }) }\n-\n-        // Fetch the symbols necessary from dbghelp.dll\n-        let SymFromAddr = sym!(\"SymFromAddr\", SymFromAddrFn);\n-        let SymInitialize = sym!(\"SymInitialize\", SymInitializeFn);\n-        let SymCleanup = sym!(\"SymCleanup\", SymCleanupFn);\n-        let StackWalk64 = sym!(\"StackWalk64\", StackWalk64Fn);\n-\n-        // Allocate necessary structures for doing the stack walk\n-        let process = unsafe { GetCurrentProcess() };\n-        let thread = unsafe { GetCurrentThread() };\n-        let mut context: arch::CONTEXT = unsafe { intrinsics::init() };\n-        unsafe { RtlCaptureContext(&mut context); }\n-        let mut frame: STACKFRAME64 = unsafe { intrinsics::init() };\n-        let image = arch::init_frame(&mut frame, &context);\n-\n-        // Initialize this process's symbols\n-        let ret = SymInitialize(process, 0 as *mut libc::c_void, libc::TRUE);\n-        if ret != libc::TRUE { return Ok(()) }\n-        let _c = Cleanup { handle: process, SymCleanup: SymCleanup };\n-\n-        // And now that we're done with all the setup, do the stack walking!\n-        let mut i = 0i;\n-        try!(write!(w, \"stack backtrace:\\n\"));\n-        while StackWalk64(image, process, thread, &mut frame, &mut context,\n-                          0 as *mut libc::c_void,\n-                          0 as *mut libc::c_void,\n-                          0 as *mut libc::c_void,\n-                          0 as *mut libc::c_void) == libc::TRUE{\n-            let addr = frame.AddrPC.Offset;\n-            if addr == frame.AddrReturn.Offset || addr == 0 ||\n-               frame.AddrReturn.Offset == 0 { break }\n-\n-            i += 1;\n-            try!(write!(w, \"  {:2}: {:#2$x}\", i, addr, super::HEX_WIDTH));\n-            let mut info: SYMBOL_INFO = unsafe { intrinsics::init() };\n-            info.MaxNameLen = MAX_SYM_NAME as libc::c_ulong;\n-            // the struct size in C.  the value is different to\n-            // `size_of::<SYMBOL_INFO>() - MAX_SYM_NAME + 1` (== 81)\n-            // due to struct alignment.\n-            info.SizeOfStruct = 88;\n-\n-            let mut displacement = 0u64;\n-            let ret = SymFromAddr(process, addr as u64, &mut displacement,\n-                                  &mut info);\n-\n-            if ret == libc::TRUE {\n-                try!(write!(w, \" - \"));\n-                let cstr = unsafe { CString::new(info.Name.as_ptr(), false) };\n-                let bytes = cstr.as_bytes();\n-                match cstr.as_str() {\n-                    Some(s) => try!(super::demangle(w, s)),\n-                    None => try!(w.write(bytes[..bytes.len()-1])),\n-                }\n-                if displacement != 0 {\n-                    try!(write!(w, \"+{:#x}\", displacement));\n-                }\n-            }\n-            try!(w.write(&['\\n' as u8]));\n-        }\n-\n-        Ok(())\n-    }\n-}\n-\n #[cfg(test)]\n mod test {\n     use prelude::*;\n-    use io::MemWriter;\n-\n+    use sys_common;\n     macro_rules! t { ($a:expr, $b:expr) => ({\n         let mut m = Vec::new();\n-        super::demangle(&mut m, $a).unwrap();\n+        sys_common::backtrace::demangle(&mut m, $a).unwrap();\n         assert_eq!(String::from_utf8(m).unwrap(), $b);\n     }) }\n "}, {"sha": "aca520fc088f551c65b77de78eb7cad0a6b4187b", "filename": "src/libstd/rt/bookkeeping.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Fbookkeeping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Fbookkeeping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbookkeeping.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -18,10 +18,10 @@\n //! each respective runtime to make sure that they call increment() and\n //! decrement() manually.\n \n-use core::atomic;\n-use core::ops::Drop;\n+use sync::atomic;\n+use ops::Drop;\n \n-use mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+use rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n static TASK_COUNT: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n static TASK_LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;", "previous_filename": "src/librustrt/bookkeeping.rs"}, {"sha": "1d3082d1b4cc4d3465d675a56a56e89350b7dedd", "filename": "src/libstd/rt/exclusive.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Fexclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Fexclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fexclusive.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -10,8 +10,8 @@\n \n use core::prelude::*;\n \n-use core::cell::UnsafeCell;\n-use mutex;\n+use cell::UnsafeCell;\n+use rt::mutex;\n \n /// An OS mutex over some data.\n ///\n@@ -79,10 +79,10 @@ impl<'a, T: Send> DerefMut<T> for ExclusiveGuard<'a, T> {\n \n #[cfg(test)]\n mod tests {\n-    use std::prelude::*;\n-    use alloc::arc::Arc;\n+    use prelude::*;\n+    use sync::Arc;\n     use super::Exclusive;\n-    use std::task;\n+    use task;\n \n     #[test]\n     fn exclusive_new_arc() {", "previous_filename": "src/librustrt/exclusive.rs"}, {"sha": "2feea7fa0a4382df63156ec8a48880fd160c86dc", "filename": "src/libstd/rt/libunwind.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flibunwind.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "previous_filename": "src/librustrt/libunwind.rs"}, {"sha": "089960a6bc80b8b9a3221c229384e63b0d1f8b30", "filename": "src/libstd/rt/local.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -10,9 +10,9 @@\n \n use core::prelude::*;\n \n-use alloc::boxed::Box;\n-use local_ptr;\n-use task::Task;\n+use boxed::Box;\n+use rt::local_ptr;\n+use rt::task::Task;\n \n /// Encapsulates some task-local data.\n pub trait Local<Borrowed> {\n@@ -52,10 +52,10 @@ impl Local<local_ptr::Borrowed<Task>> for Task {\n \n #[cfg(test)]\n mod test {\n-    use std::prelude::*;\n-    use thread::Thread;\n+    use prelude::*;\n     use super::*;\n-    use task::Task;\n+    use super::super::thread::Thread;\n+    use super::super::task::Task;\n \n     #[test]\n     fn thread_local_task_smoke_test() {", "previous_filename": "src/librustrt/local.rs"}, {"sha": "a87bc3d27662e6c90c4197858e0c5cb14fb0f590", "filename": "src/libstd/rt/local_ptr.rs", "status": "renamed", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -19,8 +19,8 @@\n \n use core::prelude::*;\n \n-use core::mem;\n-use alloc::boxed::Box;\n+use mem;\n+use boxed::Box;\n \n #[cfg(any(windows, // mingw-w32 doesn't like thread_local things\n           target_os = \"android\", // see #10686\n@@ -86,11 +86,11 @@ pub unsafe fn borrow<T>() -> Borrowed<T> {\n pub mod compiled {\n     use core::prelude::*;\n \n-    use alloc::boxed::Box;\n-    use core::mem;\n+    use boxed::Box;\n+    use mem;\n \n     #[cfg(test)]\n-    pub use realrustrt::shouldnt_be_public::RT_TLS_PTR;\n+    pub use realstd::rt::shouldnt_be_public::RT_TLS_PTR;\n \n     #[cfg(not(test))]\n     #[thread_local]\n@@ -237,10 +237,10 @@ pub mod compiled {\n pub mod native {\n     use core::prelude::*;\n \n-    use alloc::boxed::Box;\n-    use core::mem;\n-    use core::ptr;\n-    use thread_local_storage as tls;\n+    use boxed::Box;\n+    use mem;\n+    use ptr;\n+    use rt::thread_local_storage as tls;\n \n     static mut RT_TLS_KEY: tls::Key = -1;\n \n@@ -396,9 +396,9 @@ pub mod native {\n \n     #[inline] #[cfg(test)]\n     pub fn maybe_tls_key() -> Option<tls::Key> {\n-        use realrustrt;\n+        use rt;\n         unsafe {\n-            mem::transmute(realrustrt::shouldnt_be_public::maybe_tls_key())\n+            mem::transmute(::realstd::rt::shouldnt_be_public::maybe_tls_key())\n         }\n     }\n }", "previous_filename": "src/librustrt/local_ptr.rs"}, {"sha": "bee8b5b82f48e18a29b1d678dca1268ea4e11519", "filename": "src/libstd/rt/macros.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmacros.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -17,7 +17,7 @@\n \n macro_rules! rterrln {\n     ($fmt:expr $($arg:tt)*) => ( {\n-        format_args!(::util::dumb_print, concat!($fmt, \"\\n\") $($arg)*)\n+        format_args!(::rt::util::dumb_print, concat!($fmt, \"\\n\") $($arg)*)\n     } )\n }\n \n@@ -32,15 +32,14 @@ macro_rules! rtdebug {\n \n macro_rules! rtassert {\n     ( $arg:expr ) => ( {\n-        if ::util::ENFORCE_SANITY {\n+        if ::rt::util::ENFORCE_SANITY {\n             if !$arg {\n                 rtabort!(\" assertion failed: {}\", stringify!($arg));\n             }\n         }\n     } )\n }\n \n-\n macro_rules! rtabort {\n-    ($($arg:tt)*) => (format_args!(::util::abort, $($arg)*))\n+    ($($arg:tt)*) => (format_args!(::rt::util::abort, $($arg)*))\n }", "previous_filename": "src/librustrt/macros.rs"}, {"sha": "21c8197ef05588f6468c68daa3cabacb77cdbc83", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 73, "deletions": 15, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -50,23 +50,43 @@\n \n use borrow::IntoCow;\n use failure;\n-use rustrt;\n use os;\n use thunk::Thunk;\n+use kinds::Send;\n+use sys_common;\n \n // Reexport some of our utilities which are expected by other crates.\n pub use self::util::{default_sched_threads, min_stack, running_on_valgrind};\n+pub use self::unwind::{begin_unwind, begin_unwind_fmt};\n \n-// Reexport functionality from librustrt and other crates underneath the\n-// standard library which work together to create the entire runtime.\n+// Reexport some functionality from liballoc.\n pub use alloc::heap;\n-pub use rustrt::{begin_unwind, begin_unwind_fmt, at_exit};\n \n // Simple backtrace functionality (to print on panic)\n pub mod backtrace;\n \n-// Just stuff\n-mod util;\n+// Internals\n+mod macros;\n+\n+// These should be refactored/moved/made private over time\n+pub mod mutex;\n+pub mod thread;\n+pub mod exclusive;\n+pub mod util;\n+pub mod bookkeeping;\n+pub mod local;\n+pub mod task;\n+pub mod unwind;\n+\n+mod args;\n+mod at_exit_imp;\n+mod libunwind;\n+mod local_ptr;\n+mod thread_local_storage;\n+\n+/// The default error code of the rust runtime if the main task panics instead\n+/// of exiting cleanly.\n+pub const DEFAULT_ERROR_CODE: int = 101;\n \n /// One-time runtime initialization.\n ///\n@@ -75,8 +95,15 @@ mod util;\n /// metadata, and storing the process arguments.\n #[allow(experimental)]\n pub fn init(argc: int, argv: *const *const u8) {\n-    rustrt::init(argc, argv);\n-    unsafe { rustrt::unwind::register(failure::on_fail); }\n+    // FIXME: Derefing these pointers is not safe.\n+    // Need to propagate the unsafety to `start`.\n+    unsafe {\n+        args::init(argc, argv);\n+        local_ptr::init();\n+        at_exit_imp::init();\n+        thread::init();\n+        unwind::register(failure::on_fail);\n+    }\n }\n \n #[cfg(any(windows, android))]\n@@ -106,7 +133,8 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n pub fn start(argc: int, argv: *const *const u8, main: Thunk) -> int {\n     use prelude::*;\n     use rt;\n-    use rustrt::task::Task;\n+    use rt::task::Task;\n+    use str;\n \n     let something_around_the_top_of_the_stack = 1;\n     let addr = &something_around_the_top_of_the_stack as *const int;\n@@ -139,18 +167,35 @@ pub fn start(argc: int, argv: *const *const u8, main: Thunk) -> int {\n     let mut exit_code = None;\n     let mut main = Some(main);\n     let mut task = box Task::new(Some((my_stack_bottom, my_stack_top)),\n-                                 Some(rustrt::thread::main_guard_page()));\n-    task.name = Some(\"<main>\".into_cow());\n+                                 Some(rt::thread::main_guard_page()));\n+    task.name = Some(str::Slice(\"<main>\"));\n     drop(task.run(|| {\n         unsafe {\n-            rustrt::stack::record_os_managed_stack_bounds(my_stack_bottom, my_stack_top);\n+            sys_common::stack::record_os_managed_stack_bounds(my_stack_bottom, my_stack_top);\n         }\n         (main.take().unwrap()).invoke(());\n         exit_code = Some(os::get_exit_status());\n     }).destroy());\n-    unsafe { rt::cleanup(); }\n+    unsafe { cleanup(); }\n     // If the exit code wasn't set, then the task block must have panicked.\n-    return exit_code.unwrap_or(rustrt::DEFAULT_ERROR_CODE);\n+    return exit_code.unwrap_or(rt::DEFAULT_ERROR_CODE);\n+}\n+\n+/// Enqueues a procedure to run when the runtime is cleaned up\n+///\n+/// The procedure passed to this function will be executed as part of the\n+/// runtime cleanup phase. For normal rust programs, this means that it will run\n+/// after all other tasks have exited.\n+///\n+/// The procedure is *not* executed with a local `Task` available to it, so\n+/// primitives like logging, I/O, channels, spawning, etc, are *not* available.\n+/// This is meant for \"bare bones\" usage to clean up runtime details, this is\n+/// not meant as a general-purpose \"let's clean everything up\" function.\n+///\n+/// It is forbidden for procedures to register more `at_exit` handlers when they\n+/// are running, and doing so will lead to a process abort.\n+pub fn at_exit(f: proc():Send) {\n+    at_exit_imp::push(f);\n }\n \n /// One-time runtime cleanup.\n@@ -163,5 +208,18 @@ pub fn start(argc: int, argv: *const *const u8, main: Thunk) -> int {\n /// Invoking cleanup while portions of the runtime are still in use may cause\n /// undefined behavior.\n pub unsafe fn cleanup() {\n-    rustrt::cleanup();\n+    bookkeeping::wait_for_other_tasks();\n+    args::cleanup();\n+    thread::cleanup();\n+    local_ptr::cleanup();\n+    at_exit_imp::run();\n+}\n+\n+// FIXME: these probably shouldn't be public...\n+#[doc(hidden)]\n+pub mod shouldnt_be_public {\n+    #[cfg(not(test))]\n+    pub use super::local_ptr::native::maybe_tls_key;\n+    #[cfg(all(not(windows), not(target_os = \"android\"), not(target_os = \"ios\")))]\n+    pub use super::local_ptr::compiled::RT_TLS_PTR;\n }"}, {"sha": "381f14570dfbca86316d3ec7bcb5e8f1701f74e3", "filename": "src/libstd/rt/mutex.rs", "status": "renamed", "additions": 8, "deletions": 329, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmutex.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -33,7 +33,7 @@\n //! # Example\n //!\n //! ```rust\n-//! use rustrt::mutex::{NativeMutex, StaticNativeMutex, NATIVE_MUTEX_INIT};\n+//! use rt::mutex::{NativeMutex, StaticNativeMutex, NATIVE_MUTEX_INIT};\n //!\n //! // Use a statically initialized mutex\n //! static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n@@ -60,6 +60,8 @@\n \n use core::prelude::*;\n \n+use sys::mutex as imp;\n+\n /// A native mutex suitable for storing in statics (that is, it has\n /// the `destroy` method rather than a destructor).\n ///\n@@ -108,7 +110,7 @@ impl StaticNativeMutex {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use rustrt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+    /// use rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n     /// static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n     /// unsafe {\n     ///     let _guard = LOCK.lock();\n@@ -225,7 +227,7 @@ impl NativeMutex {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use rustrt::mutex::NativeMutex;\n+    /// use rt::mutex::NativeMutex;\n     /// unsafe {\n     ///     let mut lock = NativeMutex::new();\n     ///\n@@ -336,336 +338,13 @@ impl<'a> Drop for LockGuard<'a> {\n     }\n }\n \n-#[cfg(unix)]\n-mod imp {\n-    use libc;\n-    use self::os::{PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER,\n-                   pthread_mutex_t, pthread_cond_t};\n-    use core::cell::UnsafeCell;\n-\n-    type pthread_mutexattr_t = libc::c_void;\n-    type pthread_condattr_t = libc::c_void;\n-\n-    #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n-    mod os {\n-        use libc;\n-\n-        pub type pthread_mutex_t = *mut libc::c_void;\n-        pub type pthread_cond_t = *mut libc::c_void;\n-\n-        pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t =\n-            0 as pthread_mutex_t;\n-        pub const PTHREAD_COND_INITIALIZER: pthread_cond_t =\n-            0 as pthread_cond_t;\n-    }\n-\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-    mod os {\n-        use core::kinds::Copy;\n-        use libc;\n-\n-        #[cfg(target_arch = \"x86_64\")]\n-        const __PTHREAD_MUTEX_SIZE__: uint = 56;\n-        #[cfg(target_arch = \"x86_64\")]\n-        const __PTHREAD_COND_SIZE__: uint = 40;\n-        #[cfg(target_arch = \"x86\")]\n-        const __PTHREAD_MUTEX_SIZE__: uint = 40;\n-        #[cfg(target_arch = \"x86\")]\n-        const __PTHREAD_COND_SIZE__: uint = 24;\n-        #[cfg(target_arch = \"arm\")]\n-        const __PTHREAD_MUTEX_SIZE__: uint = 40;\n-        #[cfg(target_arch = \"arm\")]\n-        const __PTHREAD_COND_SIZE__: uint = 24;\n-\n-        const _PTHREAD_MUTEX_SIG_INIT: libc::c_long = 0x32AAABA7;\n-        const _PTHREAD_COND_SIG_INIT: libc::c_long = 0x3CB0B1BB;\n-\n-        #[repr(C)]\n-        pub struct pthread_mutex_t {\n-            __sig: libc::c_long,\n-            __opaque: [u8, ..__PTHREAD_MUTEX_SIZE__],\n-        }\n-\n-        impl Copy for pthread_mutex_t {}\n-\n-        #[repr(C)]\n-        pub struct pthread_cond_t {\n-            __sig: libc::c_long,\n-            __opaque: [u8, ..__PTHREAD_COND_SIZE__],\n-        }\n-\n-        impl Copy for pthread_cond_t {}\n-\n-        pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n-            __sig: _PTHREAD_MUTEX_SIG_INIT,\n-            __opaque: [0, ..__PTHREAD_MUTEX_SIZE__],\n-        };\n-        pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n-            __sig: _PTHREAD_COND_SIG_INIT,\n-            __opaque: [0, ..__PTHREAD_COND_SIZE__],\n-        };\n-    }\n-\n-    #[cfg(target_os = \"linux\")]\n-    mod os {\n-        use core::kinds::Copy;\n-        use libc;\n-\n-        // minus 8 because we have an 'align' field\n-        #[cfg(target_arch = \"x86_64\")]\n-        const __SIZEOF_PTHREAD_MUTEX_T: uint = 40 - 8;\n-        #[cfg(target_arch = \"x86\")]\n-        const __SIZEOF_PTHREAD_MUTEX_T: uint = 24 - 8;\n-        #[cfg(target_arch = \"arm\")]\n-        const __SIZEOF_PTHREAD_MUTEX_T: uint = 24 - 8;\n-        #[cfg(target_arch = \"mips\")]\n-        const __SIZEOF_PTHREAD_MUTEX_T: uint = 24 - 8;\n-        #[cfg(target_arch = \"mipsel\")]\n-        const __SIZEOF_PTHREAD_MUTEX_T: uint = 24 - 8;\n-        #[cfg(target_arch = \"x86_64\")]\n-        const __SIZEOF_PTHREAD_COND_T: uint = 48 - 8;\n-        #[cfg(target_arch = \"x86\")]\n-        const __SIZEOF_PTHREAD_COND_T: uint = 48 - 8;\n-        #[cfg(target_arch = \"arm\")]\n-        const __SIZEOF_PTHREAD_COND_T: uint = 48 - 8;\n-        #[cfg(target_arch = \"mips\")]\n-        const __SIZEOF_PTHREAD_COND_T: uint = 48 - 8;\n-        #[cfg(target_arch = \"mipsel\")]\n-        const __SIZEOF_PTHREAD_COND_T: uint = 48 - 8;\n-\n-        #[repr(C)]\n-        pub struct pthread_mutex_t {\n-            __align: libc::c_longlong,\n-            size: [u8, ..__SIZEOF_PTHREAD_MUTEX_T],\n-        }\n-\n-        impl Copy for pthread_mutex_t {}\n-\n-        #[repr(C)]\n-        pub struct pthread_cond_t {\n-            __align: libc::c_longlong,\n-            size: [u8, ..__SIZEOF_PTHREAD_COND_T],\n-        }\n-\n-        impl Copy for pthread_cond_t {}\n-\n-        pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n-            __align: 0,\n-            size: [0, ..__SIZEOF_PTHREAD_MUTEX_T],\n-        };\n-        pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n-            __align: 0,\n-            size: [0, ..__SIZEOF_PTHREAD_COND_T],\n-        };\n-    }\n-    #[cfg(target_os = \"android\")]\n-    mod os {\n-        use libc;\n-\n-        #[repr(C)]\n-        pub struct pthread_mutex_t { value: libc::c_int }\n-        #[repr(C)]\n-        pub struct pthread_cond_t { value: libc::c_int }\n-\n-        pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n-            value: 0,\n-        };\n-        pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n-            value: 0,\n-        };\n-    }\n-\n-    pub struct Mutex {\n-        lock: UnsafeCell<pthread_mutex_t>,\n-        cond: UnsafeCell<pthread_cond_t>,\n-    }\n-\n-    pub const MUTEX_INIT: Mutex = Mutex {\n-        lock: UnsafeCell { value: PTHREAD_MUTEX_INITIALIZER },\n-        cond: UnsafeCell { value: PTHREAD_COND_INITIALIZER },\n-    };\n-\n-    impl Mutex {\n-        pub unsafe fn new() -> Mutex {\n-            // As mutex might be moved and address is changing it\n-            // is better to avoid initialization of potentially\n-            // opaque OS data before it landed\n-            let m = Mutex {\n-                lock: UnsafeCell::new(PTHREAD_MUTEX_INITIALIZER),\n-                cond: UnsafeCell::new(PTHREAD_COND_INITIALIZER),\n-            };\n-\n-            return m;\n-        }\n-\n-        pub unsafe fn lock(&self) { pthread_mutex_lock(self.lock.get()); }\n-        pub unsafe fn unlock(&self) { pthread_mutex_unlock(self.lock.get()); }\n-        pub unsafe fn signal(&self) { pthread_cond_signal(self.cond.get()); }\n-        pub unsafe fn wait(&self) {\n-            pthread_cond_wait(self.cond.get(), self.lock.get());\n-        }\n-        pub unsafe fn trylock(&self) -> bool {\n-            pthread_mutex_trylock(self.lock.get()) == 0\n-        }\n-        pub unsafe fn destroy(&self) {\n-            pthread_mutex_destroy(self.lock.get());\n-            pthread_cond_destroy(self.cond.get());\n-        }\n-    }\n-\n-    extern {\n-        fn pthread_mutex_destroy(lock: *mut pthread_mutex_t) -> libc::c_int;\n-        fn pthread_cond_destroy(cond: *mut pthread_cond_t) -> libc::c_int;\n-        fn pthread_mutex_lock(lock: *mut pthread_mutex_t) -> libc::c_int;\n-        fn pthread_mutex_trylock(lock: *mut pthread_mutex_t) -> libc::c_int;\n-        fn pthread_mutex_unlock(lock: *mut pthread_mutex_t) -> libc::c_int;\n-\n-        fn pthread_cond_wait(cond: *mut pthread_cond_t,\n-                             lock: *mut pthread_mutex_t) -> libc::c_int;\n-        fn pthread_cond_signal(cond: *mut pthread_cond_t) -> libc::c_int;\n-    }\n-}\n-\n-#[cfg(windows)]\n-mod imp {\n-    use alloc::heap;\n-    use core::atomic;\n-    use core::ptr;\n-    use core::ptr::RawPtr;\n-    use libc::{HANDLE, BOOL, LPSECURITY_ATTRIBUTES, c_void, DWORD, LPCSTR};\n-    use libc;\n-\n-    type LPCRITICAL_SECTION = *mut c_void;\n-    const SPIN_COUNT: DWORD = 4000;\n-    #[cfg(target_arch = \"x86\")]\n-    const CRIT_SECTION_SIZE: uint = 24;\n-    #[cfg(target_arch = \"x86_64\")]\n-    const CRIT_SECTION_SIZE: uint = 40;\n-\n-    pub struct Mutex {\n-        // pointers for the lock/cond handles, atomically updated\n-        lock: atomic::AtomicUint,\n-        cond: atomic::AtomicUint,\n-    }\n-\n-    pub const MUTEX_INIT: Mutex = Mutex {\n-        lock: atomic::INIT_ATOMIC_UINT,\n-        cond: atomic::INIT_ATOMIC_UINT,\n-    };\n-\n-    impl Mutex {\n-        pub unsafe fn new() -> Mutex {\n-            Mutex {\n-                lock: atomic::AtomicUint::new(init_lock()),\n-                cond: atomic::AtomicUint::new(init_cond()),\n-            }\n-        }\n-        pub unsafe fn lock(&self) {\n-            EnterCriticalSection(self.getlock() as LPCRITICAL_SECTION)\n-        }\n-        pub unsafe fn trylock(&self) -> bool {\n-            TryEnterCriticalSection(self.getlock() as LPCRITICAL_SECTION) != 0\n-        }\n-        pub unsafe fn unlock(&self) {\n-            LeaveCriticalSection(self.getlock() as LPCRITICAL_SECTION)\n-        }\n-\n-        pub unsafe fn wait(&self) {\n-            self.unlock();\n-            WaitForSingleObject(self.getcond() as HANDLE, libc::INFINITE);\n-            self.lock();\n-        }\n-\n-        pub unsafe fn signal(&self) {\n-            assert!(SetEvent(self.getcond() as HANDLE) != 0);\n-        }\n-\n-        /// This function is especially unsafe because there are no guarantees made\n-        /// that no other thread is currently holding the lock or waiting on the\n-        /// condition variable contained inside.\n-        pub unsafe fn destroy(&self) {\n-            let lock = self.lock.swap(0, atomic::SeqCst);\n-            let cond = self.cond.swap(0, atomic::SeqCst);\n-            if lock != 0 { free_lock(lock) }\n-            if cond != 0 { free_cond(cond) }\n-        }\n-\n-        unsafe fn getlock(&self) -> *mut c_void {\n-            match self.lock.load(atomic::SeqCst) {\n-                0 => {}\n-                n => return n as *mut c_void\n-            }\n-            let lock = init_lock();\n-            match self.lock.compare_and_swap(0, lock, atomic::SeqCst) {\n-                0 => return lock as *mut c_void,\n-                _ => {}\n-            }\n-            free_lock(lock);\n-            return self.lock.load(atomic::SeqCst) as *mut c_void;\n-        }\n-\n-        unsafe fn getcond(&self) -> *mut c_void {\n-            match self.cond.load(atomic::SeqCst) {\n-                0 => {}\n-                n => return n as *mut c_void\n-            }\n-            let cond = init_cond();\n-            match self.cond.compare_and_swap(0, cond, atomic::SeqCst) {\n-                0 => return cond as *mut c_void,\n-                _ => {}\n-            }\n-            free_cond(cond);\n-            return self.cond.load(atomic::SeqCst) as *mut c_void;\n-        }\n-    }\n-\n-    pub unsafe fn init_lock() -> uint {\n-        let block = heap::allocate(CRIT_SECTION_SIZE, 8) as *mut c_void;\n-        if block.is_null() { ::alloc::oom() }\n-        InitializeCriticalSectionAndSpinCount(block, SPIN_COUNT);\n-        return block as uint;\n-    }\n-\n-    pub unsafe fn init_cond() -> uint {\n-        return CreateEventA(ptr::null_mut(), libc::FALSE, libc::FALSE,\n-                            ptr::null()) as uint;\n-    }\n-\n-    pub unsafe fn free_lock(h: uint) {\n-        DeleteCriticalSection(h as LPCRITICAL_SECTION);\n-        heap::deallocate(h as *mut u8, CRIT_SECTION_SIZE, 8);\n-    }\n-\n-    pub unsafe fn free_cond(h: uint) {\n-        let block = h as HANDLE;\n-        libc::CloseHandle(block);\n-    }\n-\n-    #[allow(non_snake_case)]\n-    extern \"system\" {\n-        fn CreateEventA(lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n-                        bManualReset: BOOL,\n-                        bInitialState: BOOL,\n-                        lpName: LPCSTR) -> HANDLE;\n-        fn InitializeCriticalSectionAndSpinCount(\n-                        lpCriticalSection: LPCRITICAL_SECTION,\n-                        dwSpinCount: DWORD) -> BOOL;\n-        fn DeleteCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);\n-        fn EnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);\n-        fn LeaveCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);\n-        fn TryEnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION) -> BOOL;\n-        fn SetEvent(hEvent: HANDLE) -> BOOL;\n-        fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n-    }\n-}\n-\n #[cfg(test)]\n mod test {\n-    use std::prelude::*;\n+    use prelude::*;\n \n-    use std::mem::drop;\n+    use mem::drop;\n     use super::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-    use thread::Thread;\n+    use rt::thread::Thread;\n \n     #[test]\n     fn smoke_lock() {", "previous_filename": "src/librustrt/mutex.rs"}, {"sha": "babd111b3c221463364c5ec82e3a3c12bd8dfd96", "filename": "src/libstd/rt/task.rs", "status": "renamed", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -15,27 +15,28 @@\n pub use self::BlockedTask::*;\n use self::TaskState::*;\n \n-use alloc::arc::Arc;\n-use alloc::boxed::Box;\n-use core::any::Any;\n-use core::atomic::{AtomicUint, SeqCst};\n-use core::iter::{IteratorExt, Take};\n-use core::ops::FnOnce;\n-use core::mem;\n-use core::ops::FnMut;\n+use any::Any;\n+use boxed::Box;\n+use sync::Arc;\n+use sync::atomic::{AtomicUint, SeqCst};\n+use iter::{IteratorExt, Take};\n+use kinds::marker;\n+use mem;\n+use ops::FnMut;\n use core::prelude::{Clone, Drop, Err, Iterator, None, Ok, Option, Send, Some};\n use core::prelude::{drop};\n-\n-use bookkeeping;\n-use mutex::NativeMutex;\n-use local::Local;\n-use thread::{mod, Thread};\n-use stack;\n-use unwind;\n-use unwind::Unwinder;\n-use collections::str::SendStr;\n+use str::SendStr;\n use thunk::Thunk;\n \n+use rt;\n+use rt::bookkeeping;\n+use rt::mutex::NativeMutex;\n+use rt::local::Local;\n+use rt::thread::{mod, Thread};\n+use sys_common::stack;\n+use rt::unwind;\n+use rt::unwind::Unwinder;\n+\n /// State associated with Rust tasks.\n ///\n /// This structure is currently undergoing major changes, and is\n@@ -129,9 +130,7 @@ impl Task {\n         task.name = name;\n         task.death.on_exit = on_exit;\n \n-        // FIXME: change this back after moving rustrt into std\n-        // let stack = stack_size.unwrap_or(rt::min_stack());\n-        let stack = stack_size.unwrap_or(2 * 1024 * 1024);\n+        let stack = stack_size.unwrap_or(rt::min_stack());\n \n         // Note that this increment must happen *before* the spawn in order to\n         // guarantee that if this task exits it will always end up waiting for\n@@ -504,8 +503,9 @@ impl Death {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use std::prelude::*;\n-    use std::task;\n+    use prelude::*;\n+    use task;\n+    use rt::unwind;\n \n     #[test]\n     fn unwind() {\n@@ -519,7 +519,7 @@ mod test {\n \n     #[test]\n     fn rng() {\n-        use std::rand::{StdRng, Rng};\n+        use rand::{StdRng, Rng};\n         let mut r = StdRng::new().ok().unwrap();\n         let _ = r.next_u32();\n     }\n@@ -541,7 +541,7 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn test_begin_unwind() {\n-        use unwind::begin_unwind;\n+        use rt::unwind::begin_unwind;\n         begin_unwind(\"cause\", &(file!(), line!()))\n     }\n ", "previous_filename": "src/librustrt/task.rs"}, {"sha": "c10338b1bceb2f406084a6a1e002467f56874c39", "filename": "src/libstd/rt/thread.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -0,0 +1,171 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Native os-thread management\n+//!\n+//! This modules contains bindings necessary for managing OS-level threads.\n+//! These functions operate outside of the rust runtime, creating threads\n+//! which are not used for scheduling in any way.\n+\n+#![allow(non_camel_case_types)]\n+\n+use core::prelude::*;\n+\n+use boxed::Box;\n+use mem;\n+use sys::stack_overflow;\n+use sys::thread as imp;\n+\n+pub unsafe fn init() {\n+    imp::guard::init();\n+    stack_overflow::init();\n+}\n+\n+pub unsafe fn cleanup() {\n+    stack_overflow::cleanup();\n+}\n+\n+/// This struct represents a native thread's state. This is used to join on an\n+/// existing thread created in the join-able state.\n+pub struct Thread<T> {\n+    native: imp::rust_thread,\n+    joined: bool,\n+    packet: Box<Option<T>>,\n+}\n+\n+static DEFAULT_STACK_SIZE: uint = 1024 * 1024;\n+\n+/// Returns the last writable byte of the main thread's stack next to the guard\n+/// page. Must be called from the main thread.\n+pub fn main_guard_page() -> uint {\n+    unsafe {\n+        imp::guard::main()\n+    }\n+}\n+\n+/// Returns the last writable byte of the current thread's stack next to the\n+/// guard page. Must not be called from the main thread.\n+pub fn current_guard_page() -> uint {\n+    unsafe {\n+        imp::guard::current()\n+    }\n+}\n+\n+// There are two impl blocks b/c if T were specified at the top then it's just a\n+// pain to specify a type parameter on Thread::spawn (which doesn't need the\n+// type parameter).\n+impl Thread<()> {\n+\n+    /// Starts execution of a new OS thread.\n+    ///\n+    /// This function will not wait for the thread to join, but a handle to the\n+    /// thread will be returned.\n+    ///\n+    /// Note that the handle returned is used to acquire the return value of the\n+    /// procedure `main`. The `join` function will wait for the thread to finish\n+    /// and return the value that `main` generated.\n+    ///\n+    /// Also note that the `Thread` returned will *always* wait for the thread\n+    /// to finish executing. This means that even if `join` is not explicitly\n+    /// called, when the `Thread` falls out of scope its destructor will block\n+    /// waiting for the OS thread.\n+    pub fn start<T: Send>(main: proc():Send -> T) -> Thread<T> {\n+        Thread::start_stack(DEFAULT_STACK_SIZE, main)\n+    }\n+\n+    /// Performs the same functionality as `start`, but specifies an explicit\n+    /// stack size for the new thread.\n+    pub fn start_stack<T: Send>(stack: uint, main: proc():Send -> T) -> Thread<T> {\n+\n+        // We need the address of the packet to fill in to be stable so when\n+        // `main` fills it in it's still valid, so allocate an extra box to do\n+        // so.\n+        let packet = box None;\n+        let packet2: *mut Option<T> = unsafe {\n+            *mem::transmute::<&Box<Option<T>>, *const *mut Option<T>>(&packet)\n+        };\n+        let main = proc() unsafe { *packet2 = Some(main()); };\n+        let native = unsafe { imp::create(stack, box main) };\n+\n+        Thread {\n+            native: native,\n+            joined: false,\n+            packet: packet,\n+        }\n+    }\n+\n+    /// This will spawn a new thread, but it will not wait for the thread to\n+    /// finish, nor is it possible to wait for the thread to finish.\n+    ///\n+    /// This corresponds to creating threads in the 'detached' state on unix\n+    /// systems. Note that platforms may not keep the main program alive even if\n+    /// there are detached thread still running around.\n+    pub fn spawn(main: proc():Send) {\n+        Thread::spawn_stack(DEFAULT_STACK_SIZE, main)\n+    }\n+\n+    /// Performs the same functionality as `spawn`, but explicitly specifies a\n+    /// stack size for the new thread.\n+    pub fn spawn_stack(stack: uint, main: proc():Send) {\n+        unsafe {\n+            let handle = imp::create(stack, box main);\n+            imp::detach(handle);\n+        }\n+    }\n+\n+    /// Relinquishes the CPU slot that this OS-thread is currently using,\n+    /// allowing another thread to run for awhile.\n+    pub fn yield_now() {\n+        unsafe { imp::yield_now(); }\n+    }\n+}\n+\n+impl<T: Send> Thread<T> {\n+    /// Wait for this thread to finish, returning the result of the thread's\n+    /// calculation.\n+    pub fn join(mut self) -> T {\n+        assert!(!self.joined);\n+        unsafe { imp::join(self.native) };\n+        self.joined = true;\n+        assert!(self.packet.is_some());\n+        self.packet.take().unwrap()\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T: Send> Drop for Thread<T> {\n+    fn drop(&mut self) {\n+        // This is required for correctness. If this is not done then the thread\n+        // would fill in a return box which no longer exists.\n+        if !self.joined {\n+            unsafe { imp::join(self.native) };\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::Thread;\n+\n+    #[test]\n+    fn smoke() { Thread::start(proc (){}).join(); }\n+\n+    #[test]\n+    fn data() { assert_eq!(Thread::start(proc () { 1i }).join(), 1); }\n+\n+    #[test]\n+    fn detached() { Thread::spawn(proc () {}) }\n+\n+    #[test]\n+    fn small_stacks() {\n+        assert_eq!(42i, Thread::start_stack(0, proc () 42i).join());\n+        assert_eq!(42i, Thread::start_stack(1, proc () 42i).join());\n+    }\n+}"}, {"sha": "ee6ad8a4e08e80e42d52dc9597bc9360c24a739e", "filename": "src/libstd/rt/thread_local_storage.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread_local_storage.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -11,7 +11,7 @@\n #![allow(dead_code)]\n \n #[cfg(unix)] use libc::c_int;\n-#[cfg(unix)] use core::ptr::null;\n+#[cfg(unix)] use ptr::null;\n #[cfg(windows)] use libc::types::os::arch::extra::{DWORD, LPVOID, BOOL};\n \n #[cfg(unix)]\n@@ -93,12 +93,12 @@ extern \"system\" {\n \n #[cfg(test)]\n mod test {\n-    use std::prelude::*;\n+    use prelude::*;\n     use super::*;\n \n     #[test]\n     fn tls_smoke_test() {\n-        use std::mem::transmute;\n+        use mem::transmute;\n         unsafe {\n             let mut key = 0;\n             let value = box 20i;", "previous_filename": "src/librustrt/thread_local_storage.rs"}, {"sha": "1ac06270851c533cf1e4e109c3bcb175f4c63bed", "filename": "src/libstd/rt/unwind.rs", "status": "renamed", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -59,23 +59,23 @@\n \n use core::prelude::*;\n \n-use alloc::boxed::Box;\n-use collections::string::String;\n-use collections::str::StrAllocating;\n-use collections::vec::Vec;\n-use core::any::Any;\n-use core::atomic;\n-use core::cmp;\n-use core::fmt;\n-use core::intrinsics;\n-use core::mem;\n-use core::raw::Closure;\n+use boxed::Box;\n+use string::String;\n+use str::StrAllocating;\n+use vec::Vec;\n+use any::Any;\n+use sync::atomic;\n+use cmp;\n+use fmt;\n+use intrinsics;\n+use mem;\n+use raw::Closure;\n use libc::c_void;\n \n-use local::Local;\n-use task::Task;\n+use rt::local::Local;\n+use rt::task::Task;\n \n-use libunwind as uw;\n+use rt::libunwind as uw;\n \n #[allow(missing_copy_implementations)]\n pub struct Unwinder {\n@@ -241,7 +241,7 @@ fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n           not(test)))]\n #[doc(hidden)]\n pub mod eabi {\n-    use libunwind as uw;\n+    use rt::libunwind as uw;\n     use libc::c_int;\n \n     extern \"C\" {\n@@ -294,7 +294,7 @@ pub mod eabi {\n #[cfg(all(target_os = \"ios\", target_arch = \"arm\", not(test)))]\n #[doc(hidden)]\n pub mod eabi {\n-    use libunwind as uw;\n+    use rt::libunwind as uw;\n     use libc::c_int;\n \n     extern \"C\" {\n@@ -349,7 +349,7 @@ pub mod eabi {\n #[cfg(all(target_arch = \"arm\", not(target_os = \"ios\"), not(test)))]\n #[doc(hidden)]\n pub mod eabi {\n-    use libunwind as uw;\n+    use rt::libunwind as uw;\n     use libc::c_int;\n \n     extern \"C\" {\n@@ -400,8 +400,7 @@ pub mod eabi {\n #[allow(non_camel_case_types, non_snake_case)]\n pub mod eabi {\n     pub use self::EXCEPTION_DISPOSITION::*;\n-    use core::prelude::*;\n-    use libunwind as uw;\n+    use rt::libunwind as uw;\n     use libc::{c_void, c_int};\n \n     #[repr(C)]\n@@ -513,7 +512,7 @@ pub extern fn rust_begin_unwind(msg: &fmt::Arguments,\n /// the actual formatting into this shared place.\n #[inline(never)] #[cold]\n pub fn begin_unwind_fmt(msg: &fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n-    use core::fmt::FormatWriter;\n+    use fmt::FormatWriter;\n \n     // We do two allocations here, unfortunately. But (a) they're\n     // required with the current scheme, and (b) we don't handle", "previous_filename": "src/librustrt/unwind.rs"}, {"sha": "d3cfccab9d096b5ed7c608d4f4c0f4be6db1202d", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 144, "deletions": 3, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -7,10 +7,18 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+//\n+// ignore-lexer-test FIXME #15677\n+\n+use core::prelude::*;\n \n-use libc::uintptr_t;\n-use option::Option;\n-use option::Option::{Some, None};\n+use core::cmp;\n+use core::fmt;\n+use core::intrinsics;\n+use core::slice;\n+use core::str;\n+\n+use libc::{mod, uintptr_t};\n use os;\n use str::{FromStr, from_str, Str};\n use sync::atomic;\n@@ -73,3 +81,136 @@ pub fn default_sched_threads() -> uint {\n         }\n     }\n }\n+\n+// Indicates whether we should perform expensive sanity checks, including rtassert!\n+//\n+// FIXME: Once the runtime matures remove the `true` below to turn off rtassert,\n+//        etc.\n+pub const ENFORCE_SANITY: bool = true || !cfg!(rtopt) || cfg!(rtdebug) ||\n+                                  cfg!(rtassert);\n+\n+pub struct Stdio(libc::c_int);\n+\n+#[allow(non_upper_case_globals)]\n+pub const Stdout: Stdio = Stdio(libc::STDOUT_FILENO);\n+#[allow(non_upper_case_globals)]\n+pub const Stderr: Stdio = Stdio(libc::STDERR_FILENO);\n+\n+impl fmt::FormatWriter for Stdio {\n+    fn write(&mut self, data: &[u8]) -> fmt::Result {\n+        #[cfg(unix)]\n+        type WriteLen = libc::size_t;\n+        #[cfg(windows)]\n+        type WriteLen = libc::c_uint;\n+        unsafe {\n+            let Stdio(fd) = *self;\n+            libc::write(fd,\n+                        data.as_ptr() as *const libc::c_void,\n+                        data.len() as WriteLen);\n+        }\n+        Ok(()) // yes, we're lying\n+    }\n+}\n+\n+pub fn dumb_print(args: &fmt::Arguments) {\n+    use fmt::FormatWriter;\n+    let mut w = Stderr;\n+    let _ = w.write_fmt(args);\n+}\n+\n+pub fn abort(args: &fmt::Arguments) -> ! {\n+    use fmt::FormatWriter;\n+\n+    struct BufWriter<'a> {\n+        buf: &'a mut [u8],\n+        pos: uint,\n+    }\n+    impl<'a> FormatWriter for BufWriter<'a> {\n+        fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n+            let left = self.buf[mut self.pos..];\n+            let to_write = bytes[..cmp::min(bytes.len(), left.len())];\n+            slice::bytes::copy_memory(left, to_write);\n+            self.pos += to_write.len();\n+            Ok(())\n+        }\n+    }\n+\n+    // Convert the arguments into a stack-allocated string\n+    let mut msg = [0u8, ..512];\n+    let mut w = BufWriter { buf: &mut msg, pos: 0 };\n+    let _ = write!(&mut w, \"{}\", args);\n+    let msg = str::from_utf8(w.buf[mut ..w.pos]).unwrap_or(\"aborted\");\n+    let msg = if msg.is_empty() {\"aborted\"} else {msg};\n+\n+    // Give some context to the message\n+    let hash = msg.bytes().fold(0, |accum, val| accum + (val as uint) );\n+    let quote = match hash % 10 {\n+        0 => \"\n+It was from the artists and poets that the pertinent answers came, and I\n+know that panic would have broken loose had they been able to compare notes.\n+As it was, lacking their original letters, I half suspected the compiler of\n+having asked leading questions, or of having edited the correspondence in\n+corroboration of what he had latently resolved to see.\",\n+        1 => \"\n+There are not many persons who know what wonders are opened to them in the\n+stories and visions of their youth; for when as children we listen and dream,\n+we think but half-formed thoughts, and when as men we try to remember, we are\n+dulled and prosaic with the poison of life. But some of us awake in the night\n+with strange phantasms of enchanted hills and gardens, of fountains that sing\n+in the sun, of golden cliffs overhanging murmuring seas, of plains that stretch\n+down to sleeping cities of bronze and stone, and of shadowy companies of heroes\n+that ride caparisoned white horses along the edges of thick forests; and then\n+we know that we have looked back through the ivory gates into that world of\n+wonder which was ours before we were wise and unhappy.\",\n+        2 => \"\n+Instead of the poems I had hoped for, there came only a shuddering blackness\n+and ineffable loneliness; and I saw at last a fearful truth which no one had\n+ever dared to breathe before \u2014 the unwhisperable secret of secrets \u2014 The fact\n+that this city of stone and stridor is not a sentient perpetuation of Old New\n+York as London is of Old London and Paris of Old Paris, but that it is in fact\n+quite dead, its sprawling body imperfectly embalmed and infested with queer\n+animate things which have nothing to do with it as it was in life.\",\n+        3 => \"\n+The ocean ate the last of the land and poured into the smoking gulf, thereby\n+giving up all it had ever conquered. From the new-flooded lands it flowed\n+again, uncovering death and decay; and from its ancient and immemorial bed it\n+trickled loathsomely, uncovering nighted secrets of the years when Time was\n+young and the gods unborn. Above the waves rose weedy remembered spires. The\n+moon laid pale lilies of light on dead London, and Paris stood up from its damp\n+grave to be sanctified with star-dust. Then rose spires and monoliths that were\n+weedy but not remembered; terrible spires and monoliths of lands that men never\n+knew were lands...\",\n+        4 => \"\n+There was a night when winds from unknown spaces whirled us irresistibly into\n+limitless vacuum beyond all thought and entity. Perceptions of the most\n+maddeningly untransmissible sort thronged upon us; perceptions of infinity\n+which at the time convulsed us with joy, yet which are now partly lost to my\n+memory and partly incapable of presentation to others.\",\n+        _ => \"You've met with a terrible fate, haven't you?\"\n+    };\n+    rterrln!(\"{}\", \"\");\n+    rterrln!(\"{}\", quote);\n+    rterrln!(\"{}\", \"\");\n+    rterrln!(\"fatal runtime error: {}\", msg);\n+    unsafe { intrinsics::abort(); }\n+}\n+\n+pub unsafe fn report_overflow() {\n+    use rt::task::Task;\n+    use rt::local::Local;\n+\n+    // See the message below for why this is not emitted to the\n+    // ^ Where did the message below go?\n+    // task's logger. This has the additional conundrum of the\n+    // logger may not be initialized just yet, meaning that an FFI\n+    // call would happen to initialized it (calling out to libuv),\n+    // and the FFI call needs 2MB of stack when we just ran out.\n+\n+    let task: Option<*mut Task> = Local::try_unsafe_borrow();\n+\n+    let name = task.and_then(|task| {\n+        (*task).name.as_ref().map(|n| n.as_slice())\n+    });\n+\n+    rterrln!(\"\\ntask '{}' has overflowed its stack\", name.unwrap_or(\"<unknown>\"));\n+}"}, {"sha": "862808a9e3d90f4897cddd67f34a48c93c019b9f", "filename": "src/libstd/rtdeps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frtdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Frtdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frtdeps.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -22,7 +22,7 @@ extern {}\n // LLVM implements the `frem` instruction as a call to `fmod`, which lives in\n // libm. Hence, we must explicitly link to it.\n //\n-// On Linux, librt and libdl are indirect dependencies via rustrt,\n+// On Linux, librt and libdl are indirect dependencies via std,\n // and binutils 2.22+ won't add them automatically\n #[cfg(target_os = \"linux\")]\n #[link(name = \"dl\")]"}, {"sha": "0c03060b3142dd0a97f99bde4a6539980d17bfa1", "filename": "src/libstd/sys/common/backtrace.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -0,0 +1,131 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io::{IoResult, Writer};\n+use iter::Iterator;\n+use option::{Some, None};\n+use result::{Ok, Err};\n+use str::{StrPrelude, from_str};\n+use unicode::char::UnicodeChar;\n+\n+#[cfg(target_word_size = \"64\")] pub const HEX_WIDTH: uint = 18;\n+#[cfg(target_word_size = \"32\")] pub const HEX_WIDTH: uint = 10;\n+\n+// All rust symbols are in theory lists of \"::\"-separated identifiers. Some\n+// assemblers, however, can't handle these characters in symbol names. To get\n+// around this, we use C++-style mangling. The mangling method is:\n+//\n+// 1. Prefix the symbol with \"_ZN\"\n+// 2. For each element of the path, emit the length plus the element\n+// 3. End the path with \"E\"\n+//\n+// For example, \"_ZN4testE\" => \"test\" and \"_ZN3foo3bar\" => \"foo::bar\".\n+//\n+// We're the ones printing our backtraces, so we can't rely on anything else to\n+// demangle our symbols. It's *much* nicer to look at demangled symbols, so\n+// this function is implemented to give us nice pretty output.\n+//\n+// Note that this demangler isn't quite as fancy as it could be. We have lots\n+// of other information in our symbols like hashes, version, type information,\n+// etc. Additionally, this doesn't handle glue symbols at all.\n+pub fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n+    // First validate the symbol. If it doesn't look like anything we're\n+    // expecting, we just print it literally. Note that we must handle non-rust\n+    // symbols because we could have any function in the backtrace.\n+    let mut valid = true;\n+    if s.len() > 4 && s.starts_with(\"_ZN\") && s.ends_with(\"E\") {\n+        let mut chars = s.slice(3, s.len() - 1).chars();\n+        while valid {\n+            let mut i = 0;\n+            for c in chars {\n+                if c.is_numeric() {\n+                    i = i * 10 + c as uint - '0' as uint;\n+                } else {\n+                    break\n+                }\n+            }\n+            if i == 0 {\n+                valid = chars.next().is_none();\n+                break\n+            } else if chars.by_ref().take(i - 1).count() != i - 1 {\n+                valid = false;\n+            }\n+        }\n+    } else {\n+        valid = false;\n+    }\n+\n+    // Alright, let's do this.\n+    if !valid {\n+        try!(writer.write_str(s));\n+    } else {\n+        let mut s = s.slice_from(3);\n+        let mut first = true;\n+        while s.len() > 1 {\n+            if !first {\n+                try!(writer.write_str(\"::\"));\n+            } else {\n+                first = false;\n+            }\n+            let mut rest = s;\n+            while rest.char_at(0).is_numeric() {\n+                rest = rest.slice_from(1);\n+            }\n+            let i: uint = from_str(s.slice_to(s.len() - rest.len())).unwrap();\n+            s = rest.slice_from(i);\n+            rest = rest.slice_to(i);\n+            while rest.len() > 0 {\n+                if rest.starts_with(\"$\") {\n+                    macro_rules! demangle(\n+                        ($($pat:expr => $demangled:expr),*) => ({\n+                            $(if rest.starts_with($pat) {\n+                                try!(writer.write_str($demangled));\n+                                rest = rest.slice_from($pat.len());\n+                              } else)*\n+                            {\n+                                try!(writer.write_str(rest));\n+                                break;\n+                            }\n+\n+                        })\n+                    )\n+                    // see src/librustc/back/link.rs for these mappings\n+                    demangle! (\n+                        \"$SP$\" => \"@\",\n+                        \"$UP$\" => \"Box\",\n+                        \"$RP$\" => \"*\",\n+                        \"$BP$\" => \"&\",\n+                        \"$LT$\" => \"<\",\n+                        \"$GT$\" => \">\",\n+                        \"$LP$\" => \"(\",\n+                        \"$RP$\" => \")\",\n+                        \"$C$\"  => \",\",\n+\n+                        // in theory we can demangle any Unicode code point, but\n+                        // for simplicity we just catch the common ones.\n+                        \"$x20\" => \" \",\n+                        \"$x27\" => \"'\",\n+                        \"$x5b\" => \"[\",\n+                        \"$x5d\" => \"]\"\n+                    )\n+                } else {\n+                    let idx = match rest.find('$') {\n+                        None => rest.len(),\n+                        Some(i) => i,\n+                    };\n+                    try!(writer.write_str(rest.slice_to(idx)));\n+                    rest = rest.slice_from(idx);\n+                }\n+            }\n+        }\n+    }\n+\n+    Ok(())\n+}"}, {"sha": "ffb053e852efc6228f4bf0f4f19e3ca39c965a02", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -24,9 +24,8 @@ use prelude::*;\n \n use cell::UnsafeCell;\n use mem;\n-use rustrt::bookkeeping;\n-use rustrt;\n use sync::{StaticMutex, StaticCondvar};\n+use rt::{mod, bookkeeping};\n use sys::helper_signal;\n \n use task;\n@@ -91,7 +90,7 @@ impl<M: Send> Helper<M> {\n                     self.cond.notify_one()\n                 });\n \n-                rustrt::at_exit(move|:| { self.shutdown() });\n+                rt::at_exit(move|:| { self.shutdown() });\n                 *self.initialized.get() = true;\n             }\n         }"}, {"sha": "aeee4cf01cdd0acf4dc67b0343dac98f3e21704f", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -19,11 +19,14 @@ use num::Int;\n use path::BytesContainer;\n use collections;\n \n+pub mod backtrace;\n pub mod condvar;\n pub mod helper_thread;\n pub mod mutex;\n pub mod net;\n pub mod rwlock;\n+pub mod stack;\n+pub mod thread;\n pub mod thread_local;\n \n // common error constructors"}, {"sha": "2a88e20c8fa1f1e727cdc1546812e48fa30fde81", "filename": "src/libstd/sys/common/stack.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -55,7 +55,7 @@ pub const RED_ZONE: uint = 20 * 1024;\n #[cfg(not(test))] // in testing, use the original libstd's version\n #[lang = \"stack_exhausted\"]\n extern fn stack_exhausted() {\n-    use core::intrinsics;\n+    use intrinsics;\n \n     unsafe {\n         // We're calling this function because the stack just ran out. We need\n@@ -100,7 +100,7 @@ extern fn stack_exhausted() {\n         //  #9854 - unwinding on windows through __morestack has never worked\n         //  #2361 - possible implementation of not using landing pads\n \n-        ::stack_overflow::report();\n+        ::rt::util::report_overflow();\n \n         intrinsics::abort();\n     }", "previous_filename": "src/librustrt/stack.rs"}, {"sha": "5e1adfb87149f4f2e593b2352ea46f809e778a3e", "filename": "src/libstd/sys/common/thread.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use boxed::Box;\n+use mem;\n+use uint;\n+use libc;\n+use sys_common::stack;\n+use sys::{thread, stack_overflow};\n+\n+// This is the starting point of rust os threads. The first thing we do\n+// is make sure that we don't trigger __morestack (also why this has a\n+// no_stack_check annotation), and then we extract the main function\n+// and invoke it.\n+#[no_stack_check]\n+pub fn start_thread(main: *mut libc::c_void) -> thread::rust_thread_return {\n+    unsafe {\n+        stack::record_os_managed_stack_bounds(0, uint::MAX);\n+        let handler = stack_overflow::Handler::new();\n+        let f: Box<proc()> = mem::transmute(main);\n+        (*f)();\n+        drop(handler);\n+        mem::transmute(0 as thread::rust_thread_return)\n+    }\n+}"}, {"sha": "a8bc6bf9d0d6aedf575f3ef480e3df221754c1d4", "filename": "src/libstd/sys/common/thread_local.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -58,7 +58,8 @@\n \n use prelude::*;\n \n-use rustrt::exclusive::Exclusive;\n+use rt::exclusive::Exclusive;\n+use rt;\n use sync::atomic::{mod, AtomicUint};\n use sync::{Once, ONCE_INIT};\n \n@@ -283,4 +284,3 @@ mod tests {\n         }\n     }\n }\n-"}, {"sha": "c139dba2c460829877f7145ec12ee694857e1675", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "added", "additions": 493, "deletions": 0, "changes": 493, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -0,0 +1,493 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// Backtrace support built on libgcc with some extra OS-specific support\n+///\n+/// Some methods of getting a backtrace:\n+///\n+/// * The backtrace() functions on unix. It turns out this doesn't work very\n+///   well for green threads on OSX, and the address to symbol portion of it\n+///   suffers problems that are described below.\n+///\n+/// * Using libunwind. This is more difficult than it sounds because libunwind\n+///   isn't installed everywhere by default. It's also a bit of a hefty library,\n+///   so possibly not the best option. When testing, libunwind was excellent at\n+///   getting both accurate backtraces and accurate symbols across platforms.\n+///   This route was not chosen in favor of the next option, however.\n+///\n+/// * We're already using libgcc_s for exceptions in rust (triggering task\n+///   unwinding and running destructors on the stack), and it turns out that it\n+///   conveniently comes with a function that also gives us a backtrace. All of\n+///   these functions look like _Unwind_*, but it's not quite the full\n+///   repertoire of the libunwind API. Due to it already being in use, this was\n+///   the chosen route of getting a backtrace.\n+///\n+/// After choosing libgcc_s for backtraces, the sad part is that it will only\n+/// give us a stack trace of instruction pointers. Thankfully these instruction\n+/// pointers are accurate (they work for green and native threads), but it's\n+/// then up to us again to figure out how to translate these addresses to\n+/// symbols. As with before, we have a few options. Before, that, a little bit\n+/// of an interlude about symbols. This is my very limited knowledge about\n+/// symbol tables, and this information is likely slightly wrong, but the\n+/// general idea should be correct.\n+///\n+/// When talking about symbols, it's helpful to know a few things about where\n+/// symbols are located. Some symbols are located in the dynamic symbol table\n+/// of the executable which in theory means that they're available for dynamic\n+/// linking and lookup. Other symbols end up only in the local symbol table of\n+/// the file. This loosely corresponds to pub and priv functions in Rust.\n+///\n+/// Armed with this knowledge, we know that our solution for address to symbol\n+/// translation will need to consult both the local and dynamic symbol tables.\n+/// With that in mind, here's our options of translating an address to\n+/// a symbol.\n+///\n+/// * Use dladdr(). The original backtrace()-based idea actually uses dladdr()\n+///   behind the scenes to translate, and this is why backtrace() was not used.\n+///   Conveniently, this method works fantastically on OSX. It appears dladdr()\n+///   uses magic to consult the local symbol table, or we're putting everything\n+///   in the dynamic symbol table anyway. Regardless, for OSX, this is the\n+///   method used for translation. It's provided by the system and easy to do.o\n+///\n+///   Sadly, all other systems have a dladdr() implementation that does not\n+///   consult the local symbol table. This means that most functions are blank\n+///   because they don't have symbols. This means that we need another solution.\n+///\n+/// * Use unw_get_proc_name(). This is part of the libunwind api (not the\n+///   libgcc_s version of the libunwind api), but involves taking a dependency\n+///   to libunwind. We may pursue this route in the future if we bundle\n+///   libunwind, but libunwind was unwieldy enough that it was not chosen at\n+///   this time to provide this functionality.\n+///\n+/// * Shell out to a utility like `readelf`. Crazy though it may sound, it's a\n+///   semi-reasonable solution. The stdlib already knows how to spawn processes,\n+///   so in theory it could invoke readelf, parse the output, and consult the\n+///   local/dynamic symbol tables from there. This ended up not getting chosen\n+///   due to the craziness of the idea plus the advent of the next option.\n+///\n+/// * Use `libbacktrace`. It turns out that this is a small library bundled in\n+///   the gcc repository which provides backtrace and symbol translation\n+///   functionality. All we really need from it is the backtrace functionality,\n+///   and we only really need this on everything that's not OSX, so this is the\n+///   chosen route for now.\n+///\n+/// In summary, the current situation uses libgcc_s to get a trace of stack\n+/// pointers, and we use dladdr() or libbacktrace to translate these addresses\n+/// to symbols. This is a bit of a hokey implementation as-is, but it works for\n+/// all unix platforms we support right now, so it at least gets the job done.\n+\n+use c_str::CString;\n+use io::{IoResult, Writer};\n+use libc;\n+use mem;\n+use option::{Some, None, Option};\n+use result::{Ok, Err};\n+use rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+\n+use sys_common::backtrace::*;\n+\n+/// As always - iOS on arm uses SjLj exceptions and\n+/// _Unwind_Backtrace is even not available there. Still,\n+/// backtraces could be extracted using a backtrace function,\n+/// which thanks god is public\n+///\n+/// As mentioned in a huge comment block above, backtrace doesn't\n+/// play well with green threads, so while it is extremely nice\n+/// and simple to use it should be used only on iOS devices as the\n+/// only viable option.\n+#[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n+#[inline(never)]\n+pub fn write(w: &mut Writer) -> IoResult<()> {\n+    use iter::{Iterator, range};\n+    use result;\n+    use slice::SliceExt;\n+\n+    extern {\n+        fn backtrace(buf: *mut *mut libc::c_void,\n+                     sz: libc::c_int) -> libc::c_int;\n+    }\n+\n+    // while it doesn't requires lock for work as everything is\n+    // local, it still displays much nicer backtraces when a\n+    // couple of tasks panic simultaneously\n+    static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+    let _g = unsafe { LOCK.lock() };\n+\n+    try!(writeln!(w, \"stack backtrace:\"));\n+    // 100 lines should be enough\n+    const SIZE: uint = 100;\n+    let mut buf: [*mut libc::c_void, ..SIZE] = unsafe {mem::zeroed()};\n+    let cnt = unsafe { backtrace(buf.as_mut_ptr(), SIZE as libc::c_int) as uint};\n+\n+    // skipping the first one as it is write itself\n+    let iter = range(1, cnt).map(|i| {\n+        print(w, i as int, buf[i])\n+    });\n+    result::fold(iter, (), |_, _| ())\n+}\n+\n+#[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n+#[inline(never)] // if we know this is a function call, we can skip it when\n+                 // tracing\n+pub fn write(w: &mut Writer) -> IoResult<()> {\n+    use io::IoError;\n+\n+    struct Context<'a> {\n+        idx: int,\n+        writer: &'a mut Writer+'a,\n+        last_error: Option<IoError>,\n+    }\n+\n+    // When using libbacktrace, we use some necessary global state, so we\n+    // need to prevent more than one thread from entering this block. This\n+    // is semi-reasonable in terms of printing anyway, and we know that all\n+    // I/O done here is blocking I/O, not green I/O, so we don't have to\n+    // worry about this being a native vs green mutex.\n+    static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+    let _g = unsafe { LOCK.lock() };\n+\n+    try!(writeln!(w, \"stack backtrace:\"));\n+\n+    let mut cx = Context { writer: w, last_error: None, idx: 0 };\n+    return match unsafe {\n+        uw::_Unwind_Backtrace(trace_fn,\n+                              &mut cx as *mut Context as *mut libc::c_void)\n+    } {\n+        uw::_URC_NO_REASON => {\n+            match cx.last_error {\n+                Some(err) => Err(err),\n+                None => Ok(())\n+            }\n+        }\n+        _ => Ok(()),\n+    };\n+\n+    extern fn trace_fn(ctx: *mut uw::_Unwind_Context,\n+                       arg: *mut libc::c_void) -> uw::_Unwind_Reason_Code {\n+        let cx: &mut Context = unsafe { mem::transmute(arg) };\n+        let ip = unsafe { uw::_Unwind_GetIP(ctx) as *mut libc::c_void };\n+        // dladdr() on osx gets whiny when we use FindEnclosingFunction, and\n+        // it appears to work fine without it, so we only use\n+        // FindEnclosingFunction on non-osx platforms. In doing so, we get a\n+        // slightly more accurate stack trace in the process.\n+        //\n+        // This is often because panic involves the last instruction of a\n+        // function being \"call std::rt::begin_unwind\", with no ret\n+        // instructions after it. This means that the return instruction\n+        // pointer points *outside* of the calling function, and by\n+        // unwinding it we go back to the original function.\n+        let ip = if cfg!(target_os = \"macos\") || cfg!(target_os = \"ios\") {\n+            ip\n+        } else {\n+            unsafe { uw::_Unwind_FindEnclosingFunction(ip) }\n+        };\n+\n+        // Don't print out the first few frames (they're not user frames)\n+        cx.idx += 1;\n+        if cx.idx <= 0 { return uw::_URC_NO_REASON }\n+        // Don't print ginormous backtraces\n+        if cx.idx > 100 {\n+            match write!(cx.writer, \" ... <frames omitted>\\n\") {\n+                Ok(()) => {}\n+                Err(e) => { cx.last_error = Some(e); }\n+            }\n+            return uw::_URC_FAILURE\n+        }\n+\n+        // Once we hit an error, stop trying to print more frames\n+        if cx.last_error.is_some() { return uw::_URC_FAILURE }\n+\n+        match print(cx.writer, cx.idx, ip) {\n+            Ok(()) => {}\n+            Err(e) => { cx.last_error = Some(e); }\n+        }\n+\n+        // keep going\n+        return uw::_URC_NO_REASON\n+    }\n+}\n+\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n+    use intrinsics;\n+    #[repr(C)]\n+    struct Dl_info {\n+        dli_fname: *const libc::c_char,\n+        dli_fbase: *mut libc::c_void,\n+        dli_sname: *const libc::c_char,\n+        dli_saddr: *mut libc::c_void,\n+    }\n+    extern {\n+        fn dladdr(addr: *const libc::c_void,\n+                  info: *mut Dl_info) -> libc::c_int;\n+    }\n+\n+    let mut info: Dl_info = unsafe { intrinsics::init() };\n+    if unsafe { dladdr(addr as *const libc::c_void, &mut info) == 0 } {\n+        output(w, idx,addr, None)\n+    } else {\n+        output(w, idx, addr, Some(unsafe {\n+            CString::new(info.dli_sname, false)\n+        }))\n+    }\n+}\n+\n+#[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n+fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n+    use iter::Iterator;\n+    use os;\n+    use path::GenericPath;\n+    use ptr::RawPtr;\n+    use ptr;\n+    use slice::SliceExt;\n+\n+    ////////////////////////////////////////////////////////////////////////\n+    // libbacktrace.h API\n+    ////////////////////////////////////////////////////////////////////////\n+    type backtrace_syminfo_callback =\n+        extern \"C\" fn(data: *mut libc::c_void,\n+                      pc: libc::uintptr_t,\n+                      symname: *const libc::c_char,\n+                      symval: libc::uintptr_t,\n+                      symsize: libc::uintptr_t);\n+    type backtrace_error_callback =\n+        extern \"C\" fn(data: *mut libc::c_void,\n+                      msg: *const libc::c_char,\n+                      errnum: libc::c_int);\n+    enum backtrace_state {}\n+    #[link(name = \"backtrace\", kind = \"static\")]\n+    #[cfg(not(test))]\n+    extern {}\n+\n+    extern {\n+        fn backtrace_create_state(filename: *const libc::c_char,\n+                                  threaded: libc::c_int,\n+                                  error: backtrace_error_callback,\n+                                  data: *mut libc::c_void)\n+                                        -> *mut backtrace_state;\n+        fn backtrace_syminfo(state: *mut backtrace_state,\n+                             addr: libc::uintptr_t,\n+                             cb: backtrace_syminfo_callback,\n+                             error: backtrace_error_callback,\n+                             data: *mut libc::c_void) -> libc::c_int;\n+    }\n+\n+    ////////////////////////////////////////////////////////////////////////\n+    // helper callbacks\n+    ////////////////////////////////////////////////////////////////////////\n+\n+    extern fn error_cb(_data: *mut libc::c_void, _msg: *const libc::c_char,\n+                       _errnum: libc::c_int) {\n+        // do nothing for now\n+    }\n+    extern fn syminfo_cb(data: *mut libc::c_void,\n+                         _pc: libc::uintptr_t,\n+                         symname: *const libc::c_char,\n+                         _symval: libc::uintptr_t,\n+                         _symsize: libc::uintptr_t) {\n+        let slot = data as *mut *const libc::c_char;\n+        unsafe { *slot = symname; }\n+    }\n+\n+    // The libbacktrace API supports creating a state, but it does not\n+    // support destroying a state. I personally take this to mean that a\n+    // state is meant to be created and then live forever.\n+    //\n+    // I would love to register an at_exit() handler which cleans up this\n+    // state, but libbacktrace provides no way to do so.\n+    //\n+    // With these constraints, this function has a statically cached state\n+    // that is calculated the first time this is requested. Remember that\n+    // backtracing all happens serially (one global lock).\n+    //\n+    // An additionally oddity in this function is that we initialize the\n+    // filename via self_exe_name() to pass to libbacktrace. It turns out\n+    // that on Linux libbacktrace seamlessly gets the filename of the\n+    // current executable, but this fails on freebsd. by always providing\n+    // it, we make sure that libbacktrace never has a reason to not look up\n+    // the symbols. The libbacktrace API also states that the filename must\n+    // be in \"permanent memory\", so we copy it to a static and then use the\n+    // static as the pointer.\n+    //\n+    // FIXME: We also call self_exe_name() on DragonFly BSD. I haven't\n+    //        tested if this is required or not.\n+    unsafe fn init_state() -> *mut backtrace_state {\n+        static mut STATE: *mut backtrace_state = 0 as *mut backtrace_state;\n+        static mut LAST_FILENAME: [libc::c_char, ..256] = [0, ..256];\n+        if !STATE.is_null() { return STATE }\n+        let selfname = if cfg!(target_os = \"freebsd\") ||\n+                          cfg!(target_os = \"dragonfly\") {\n+            os::self_exe_name()\n+        } else {\n+            None\n+        };\n+        let filename = match selfname {\n+            Some(path) => {\n+                let bytes = path.as_vec();\n+                if bytes.len() < LAST_FILENAME.len() {\n+                    let i = bytes.iter();\n+                    for (slot, val) in LAST_FILENAME.iter_mut().zip(i) {\n+                        *slot = *val as libc::c_char;\n+                    }\n+                    LAST_FILENAME.as_ptr()\n+                } else {\n+                    ptr::null()\n+                }\n+            }\n+            None => ptr::null(),\n+        };\n+        STATE = backtrace_create_state(filename, 0, error_cb,\n+                                       ptr::null_mut());\n+        return STATE\n+    }\n+\n+    ////////////////////////////////////////////////////////////////////////\n+    // translation\n+    ////////////////////////////////////////////////////////////////////////\n+\n+    // backtrace errors are currently swept under the rug, only I/O\n+    // errors are reported\n+    let state = unsafe { init_state() };\n+    if state.is_null() {\n+        return output(w, idx, addr, None)\n+    }\n+    let mut data = 0 as *const libc::c_char;\n+    let data_addr = &mut data as *mut *const libc::c_char;\n+    let ret = unsafe {\n+        backtrace_syminfo(state, addr as libc::uintptr_t,\n+                          syminfo_cb, error_cb,\n+                          data_addr as *mut libc::c_void)\n+    };\n+    if ret == 0 || data.is_null() {\n+        output(w, idx, addr, None)\n+    } else {\n+        output(w, idx, addr, Some(unsafe { CString::new(data, false) }))\n+    }\n+}\n+\n+// Finally, after all that work above, we can emit a symbol.\n+fn output(w: &mut Writer, idx: int, addr: *mut libc::c_void,\n+          s: Option<CString>) -> IoResult<()> {\n+    try!(write!(w, \"  {:2}: {:2$} - \", idx, addr, HEX_WIDTH));\n+    match s.as_ref().and_then(|c| c.as_str()) {\n+        Some(string) => try!(demangle(w, string)),\n+        None => try!(write!(w, \"<unknown>\")),\n+    }\n+    w.write(&['\\n' as u8])\n+}\n+\n+/// Unwind library interface used for backtraces\n+///\n+/// Note that dead code is allowed as here are just bindings\n+/// iOS doesn't use all of them it but adding more\n+/// platform-specific configs pollutes the code too much\n+#[allow(non_camel_case_types)]\n+#[allow(non_snake_case)]\n+#[allow(dead_code)]\n+mod uw {\n+    pub use self::_Unwind_Reason_Code::*;\n+\n+    use libc;\n+\n+    #[repr(C)]\n+    pub enum _Unwind_Reason_Code {\n+        _URC_NO_REASON = 0,\n+        _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n+        _URC_FATAL_PHASE2_ERROR = 2,\n+        _URC_FATAL_PHASE1_ERROR = 3,\n+        _URC_NORMAL_STOP = 4,\n+        _URC_END_OF_STACK = 5,\n+        _URC_HANDLER_FOUND = 6,\n+        _URC_INSTALL_CONTEXT = 7,\n+        _URC_CONTINUE_UNWIND = 8,\n+        _URC_FAILURE = 9, // used only by ARM EABI\n+    }\n+\n+    pub enum _Unwind_Context {}\n+\n+    pub type _Unwind_Trace_Fn =\n+            extern fn(ctx: *mut _Unwind_Context,\n+                      arg: *mut libc::c_void) -> _Unwind_Reason_Code;\n+\n+    extern {\n+        // No native _Unwind_Backtrace on iOS\n+        #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n+        pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,\n+                                 trace_argument: *mut libc::c_void)\n+                    -> _Unwind_Reason_Code;\n+\n+        #[cfg(all(not(target_os = \"android\"),\n+                  not(all(target_os = \"linux\", target_arch = \"arm\"))))]\n+        pub fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t;\n+\n+        #[cfg(all(not(target_os = \"android\"),\n+                  not(all(target_os = \"linux\", target_arch = \"arm\"))))]\n+        pub fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)\n+            -> *mut libc::c_void;\n+    }\n+\n+    // On android, the function _Unwind_GetIP is a macro, and this is the\n+    // expansion of the macro. This is all copy/pasted directly from the\n+    // header file with the definition of _Unwind_GetIP.\n+    #[cfg(any(target_os = \"android\",\n+              all(target_os = \"linux\", target_arch = \"arm\")))]\n+    pub unsafe fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t {\n+        #[repr(C)]\n+        enum _Unwind_VRS_Result {\n+            _UVRSR_OK = 0,\n+            _UVRSR_NOT_IMPLEMENTED = 1,\n+            _UVRSR_FAILED = 2,\n+        }\n+        #[repr(C)]\n+        enum _Unwind_VRS_RegClass {\n+            _UVRSC_CORE = 0,\n+            _UVRSC_VFP = 1,\n+            _UVRSC_FPA = 2,\n+            _UVRSC_WMMXD = 3,\n+            _UVRSC_WMMXC = 4,\n+        }\n+        #[repr(C)]\n+        enum _Unwind_VRS_DataRepresentation {\n+            _UVRSD_UINT32 = 0,\n+            _UVRSD_VFPX = 1,\n+            _UVRSD_FPAX = 2,\n+            _UVRSD_UINT64 = 3,\n+            _UVRSD_FLOAT = 4,\n+            _UVRSD_DOUBLE = 5,\n+        }\n+\n+        type _Unwind_Word = libc::c_uint;\n+        extern {\n+            fn _Unwind_VRS_Get(ctx: *mut _Unwind_Context,\n+                               klass: _Unwind_VRS_RegClass,\n+                               word: _Unwind_Word,\n+                               repr: _Unwind_VRS_DataRepresentation,\n+                               data: *mut libc::c_void)\n+                -> _Unwind_VRS_Result;\n+        }\n+\n+        let mut val: _Unwind_Word = 0;\n+        let ptr = &mut val as *mut _Unwind_Word;\n+        let _ = _Unwind_VRS_Get(ctx, _Unwind_VRS_RegClass::_UVRSC_CORE, 15,\n+                                _Unwind_VRS_DataRepresentation::_UVRSD_UINT32,\n+                                ptr as *mut libc::c_void);\n+        (val & !1) as libc::uintptr_t\n+    }\n+\n+    // This function also doesn't exist on Android or ARM/Linux, so make it\n+    // a no-op\n+    #[cfg(any(target_os = \"android\",\n+              all(target_os = \"linux\", target_arch = \"arm\")))]\n+    pub unsafe fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)\n+        -> *mut libc::c_void\n+    {\n+        pc\n+    }\n+}"}, {"sha": "f3babca32871ae86d8b36da38c2ac4c899a63522", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -34,6 +34,7 @@ macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n     };\n ) }\n \n+pub mod backtrace;\n pub mod c;\n pub mod ext;\n pub mod condvar;\n@@ -44,8 +45,10 @@ pub mod os;\n pub mod pipe;\n pub mod process;\n pub mod rwlock;\n+pub mod stack_overflow;\n pub mod sync;\n pub mod tcp;\n+pub mod thread;\n pub mod thread_local;\n pub mod timer;\n pub mod tty;"}, {"sha": "73b98f762b479a5b66f1889ef5e164d9b49deffd", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "renamed", "additions": 25, "deletions": 141, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -8,170 +8,45 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_camel_case_types)]\n-\n-use core::prelude::*;\n use libc;\n-use local::Local;\n-use task::Task;\n-\n-pub unsafe fn init() {\n-    imp::init();\n-}\n+use core::prelude::*;\n+use self::imp::{make_handler, drop_handler};\n \n-pub unsafe fn cleanup() {\n-    imp::cleanup();\n-}\n+pub use self::imp::{init, cleanup};\n \n pub struct Handler {\n     _data: *mut libc::c_void\n }\n \n impl Handler {\n     pub unsafe fn new() -> Handler {\n-        imp::make_handler()\n+        make_handler()\n     }\n }\n \n impl Drop for Handler {\n     fn drop(&mut self) {\n         unsafe {\n-            imp::drop_handler(self);\n-        }\n-    }\n-}\n-\n-pub unsafe fn report() {\n-    // See the message below for why this is not emitted to the\n-    // ^ Where did the message below go?\n-    // task's logger. This has the additional conundrum of the\n-    // logger may not be initialized just yet, meaning that an FFI\n-    // call would happen to initialized it (calling out to libuv),\n-    // and the FFI call needs 2MB of stack when we just ran out.\n-\n-    let task: Option<*mut Task> = Local::try_unsafe_borrow();\n-\n-    let name = task.and_then(|task| {\n-        (*task).name.as_ref().map(|n| n.as_slice())\n-    });\n-\n-    rterrln!(\"\\ntask '{}' has overflowed its stack\", name.unwrap_or(\"<unknown>\"));\n-}\n-\n-// get_task_info is called from an exception / signal handler.\n-// It returns the guard page of the current task or 0 if that\n-// guard page doesn't exist. None is returned if there's currently\n-// no local task.\n-#[cfg(any(windows, target_os = \"linux\", target_os = \"macos\"))]\n-unsafe fn get_task_guard_page() -> Option<uint> {\n-    let task: Option<*mut Task> = Local::try_unsafe_borrow();\n-    task.map(|task| (&*task).stack_guard().unwrap_or(0))\n-}\n-\n-#[cfg(windows)]\n-#[allow(non_snake_case)]\n-mod imp {\n-    use core::ptr;\n-    use core::mem;\n-    use libc;\n-    use libc::types::os::arch::extra::{LPVOID, DWORD, LONG, BOOL};\n-    use stack;\n-    use super::{Handler, get_task_guard_page, report};\n-\n-    // This is initialized in init() and only read from after\n-    static mut PAGE_SIZE: uint = 0;\n-\n-    #[no_stack_check]\n-    extern \"system\" fn vectored_handler(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG {\n-        unsafe {\n-            let rec = &(*(*ExceptionInfo).ExceptionRecord);\n-            let code = rec.ExceptionCode;\n-\n-            if code != EXCEPTION_STACK_OVERFLOW {\n-                return EXCEPTION_CONTINUE_SEARCH;\n-            }\n-\n-            // We're calling into functions with stack checks,\n-            // however stack checks by limit should be disabled on Windows\n-            stack::record_sp_limit(0);\n-\n-            if get_task_guard_page().is_some() {\n-               report();\n-            }\n-\n-            EXCEPTION_CONTINUE_SEARCH\n-        }\n-    }\n-\n-    pub unsafe fn init() {\n-        let mut info = mem::zeroed();\n-        libc::GetSystemInfo(&mut info);\n-        PAGE_SIZE = info.dwPageSize as uint;\n-\n-        if AddVectoredExceptionHandler(0, vectored_handler) == ptr::null_mut() {\n-            panic!(\"failed to install exception handler\");\n+            drop_handler(self);\n         }\n-\n-        mem::forget(make_handler());\n-    }\n-\n-    pub unsafe fn cleanup() {\n-    }\n-\n-    pub unsafe fn make_handler() -> Handler {\n-        if SetThreadStackGuarantee(&mut 0x5000) == 0 {\n-            panic!(\"failed to reserve stack space for exception handling\");\n-        }\n-\n-        super::Handler { _data: 0i as *mut libc::c_void }\n-    }\n-\n-    pub unsafe fn drop_handler(_handler: &mut Handler) {\n-    }\n-\n-    pub struct EXCEPTION_RECORD {\n-        pub ExceptionCode: DWORD,\n-        pub ExceptionFlags: DWORD,\n-        pub ExceptionRecord: *mut EXCEPTION_RECORD,\n-        pub ExceptionAddress: LPVOID,\n-        pub NumberParameters: DWORD,\n-        pub ExceptionInformation: [LPVOID, ..EXCEPTION_MAXIMUM_PARAMETERS]\n-    }\n-\n-    pub struct EXCEPTION_POINTERS {\n-        pub ExceptionRecord: *mut EXCEPTION_RECORD,\n-        pub ContextRecord: LPVOID\n-    }\n-\n-    pub type PVECTORED_EXCEPTION_HANDLER = extern \"system\"\n-            fn(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG;\n-\n-    pub type ULONG = libc::c_ulong;\n-\n-    const EXCEPTION_CONTINUE_SEARCH: LONG = 0;\n-    const EXCEPTION_MAXIMUM_PARAMETERS: uint = 15;\n-    const EXCEPTION_STACK_OVERFLOW: DWORD = 0xc00000fd;\n-\n-    extern \"system\" {\n-        fn AddVectoredExceptionHandler(FirstHandler: ULONG,\n-                                       VectoredHandler: PVECTORED_EXCEPTION_HANDLER)\n-                                      -> LPVOID;\n-        fn SetThreadStackGuarantee(StackSizeInBytes: *mut ULONG) -> BOOL;\n     }\n }\n \n #[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n mod imp {\n     use core::prelude::*;\n-    use stack;\n+    use sys_common::stack;\n \n-    use super::{Handler, get_task_guard_page, report};\n-    use core::mem;\n-    use core::ptr;\n-    use core::intrinsics;\n+    use super::Handler;\n+    use rt::util::report_overflow;\n+    use mem;\n+    use ptr;\n+    use intrinsics;\n     use self::signal::{siginfo, sigaction, SIGBUS, SIG_DFL,\n                        SA_SIGINFO, SA_ONSTACK, sigaltstack,\n                        SIGSTKSZ};\n+    use rt::local::Local;\n+    use rt::task::Task;\n     use libc;\n     use libc::funcs::posix88::mman::{mmap, munmap};\n     use libc::consts::os::posix88::{SIGSEGV,\n@@ -185,6 +60,16 @@ mod imp {\n     // This is initialized in init() and only read from after\n     static mut PAGE_SIZE: uint = 0;\n \n+    // get_task_info is called from an exception / signal handler.\n+    // It returns the guard page of the current task or 0 if that\n+    // guard page doesn't exist. None is returned if there's currently\n+    // no local task.\n+    unsafe fn get_task_guard_page() -> Option<uint> {\n+        let task: Option<*mut Task> = Local::try_unsafe_borrow();\n+        task.map(|task| (&*task).stack_guard().unwrap_or(0))\n+    }\n+\n+\n     #[no_stack_check]\n     unsafe extern fn signal_handler(signum: libc::c_int,\n                                      info: *mut siginfo,\n@@ -212,7 +97,7 @@ mod imp {\n                     term(signum);\n                 }\n \n-                report();\n+                report_overflow();\n \n                 intrinsics::abort()\n             }\n@@ -387,8 +272,7 @@ mod imp {\n }\n \n #[cfg(not(any(target_os = \"linux\",\n-              target_os = \"macos\",\n-              windows)))]\n+              target_os = \"macos\")))]\n mod imp {\n     use libc;\n ", "previous_filename": "src/librustrt/stack_overflow.rs"}, {"sha": "02da3a1981837c61fab0b761d9d1c53bf78fb207", "filename": "src/libstd/sys/unix/thread.rs", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -0,0 +1,270 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use boxed::Box;\n+use cmp;\n+use mem;\n+use ptr;\n+use libc::consts::os::posix01::{PTHREAD_CREATE_JOINABLE, PTHREAD_STACK_MIN};\n+use libc;\n+\n+use sys_common::stack::RED_ZONE;\n+use sys_common::thread::*;\n+\n+pub type rust_thread = libc::pthread_t;\n+pub type rust_thread_return = *mut u8;\n+pub type StartFn = extern \"C\" fn(*mut libc::c_void) -> rust_thread_return;\n+\n+#[no_stack_check]\n+pub extern fn thread_start(main: *mut libc::c_void) -> rust_thread_return {\n+    return start_thread(main);\n+}\n+\n+#[cfg(all(not(target_os = \"linux\"), not(target_os = \"macos\")))]\n+pub mod guard {\n+    pub unsafe fn current() -> uint {\n+        0\n+    }\n+\n+    pub unsafe fn main() -> uint {\n+        0\n+    }\n+\n+    pub unsafe fn init() {\n+    }\n+}\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n+pub mod guard {\n+    use super::*;\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    use mem;\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    use ptr;\n+    use libc;\n+    use libc::funcs::posix88::mman::{mmap};\n+    use libc::consts::os::posix88::{PROT_NONE,\n+                                    MAP_PRIVATE,\n+                                    MAP_ANON,\n+                                    MAP_FAILED,\n+                                    MAP_FIXED};\n+\n+    // These are initialized in init() and only read from after\n+    static mut PAGE_SIZE: uint = 0;\n+    static mut GUARD_PAGE: uint = 0;\n+\n+    #[cfg(target_os = \"macos\")]\n+    unsafe fn get_stack_start() -> *mut libc::c_void {\n+        current() as *mut libc::c_void\n+    }\n+\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    unsafe fn get_stack_start() -> *mut libc::c_void {\n+        let mut attr: libc::pthread_attr_t = mem::zeroed();\n+        if pthread_getattr_np(pthread_self(), &mut attr) != 0 {\n+            panic!(\"failed to get thread attributes\");\n+        }\n+        let mut stackaddr = ptr::null_mut();\n+        let mut stacksize = 0;\n+        if pthread_attr_getstack(&attr, &mut stackaddr, &mut stacksize) != 0 {\n+            panic!(\"failed to get stack information\");\n+        }\n+        if pthread_attr_destroy(&mut attr) != 0 {\n+            panic!(\"failed to destroy thread attributes\");\n+        }\n+        stackaddr\n+    }\n+\n+    pub unsafe fn init() {\n+        let psize = libc::sysconf(libc::consts::os::sysconf::_SC_PAGESIZE);\n+        if psize == -1 {\n+            panic!(\"failed to get page size\");\n+        }\n+\n+        PAGE_SIZE = psize as uint;\n+\n+        let stackaddr = get_stack_start();\n+\n+        // Rellocate the last page of the stack.\n+        // This ensures SIGBUS will be raised on\n+        // stack overflow.\n+        let result = mmap(stackaddr,\n+                          PAGE_SIZE as libc::size_t,\n+                          PROT_NONE,\n+                          MAP_PRIVATE | MAP_ANON | MAP_FIXED,\n+                          -1,\n+                          0);\n+\n+        if result != stackaddr || result == MAP_FAILED {\n+            panic!(\"failed to allocate a guard page\");\n+        }\n+\n+        let offset = if cfg!(target_os = \"linux\") {\n+            2\n+        } else {\n+            1\n+        };\n+\n+        GUARD_PAGE = stackaddr as uint + offset * PAGE_SIZE;\n+    }\n+\n+    pub unsafe fn main() -> uint {\n+        GUARD_PAGE\n+    }\n+\n+    #[cfg(target_os = \"macos\")]\n+    pub unsafe fn current() -> uint {\n+        (pthread_get_stackaddr_np(pthread_self()) as libc::size_t -\n+         pthread_get_stacksize_np(pthread_self())) as uint\n+    }\n+\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    pub unsafe fn current() -> uint {\n+        let mut attr: libc::pthread_attr_t = mem::zeroed();\n+        if pthread_getattr_np(pthread_self(), &mut attr) != 0 {\n+            panic!(\"failed to get thread attributes\");\n+        }\n+        let mut guardsize = 0;\n+        if pthread_attr_getguardsize(&attr, &mut guardsize) != 0 {\n+            panic!(\"failed to get stack guard page\");\n+        }\n+        if guardsize == 0 {\n+            panic!(\"there is no guard page\");\n+        }\n+        let mut stackaddr = ptr::null_mut();\n+        let mut stacksize = 0;\n+        if pthread_attr_getstack(&attr, &mut stackaddr, &mut stacksize) != 0 {\n+            panic!(\"failed to get stack information\");\n+        }\n+        if pthread_attr_destroy(&mut attr) != 0 {\n+            panic!(\"failed to destroy thread attributes\");\n+        }\n+\n+        stackaddr as uint + guardsize as uint\n+    }\n+}\n+\n+pub unsafe fn create(stack: uint, p: Box<proc():Send>) -> rust_thread {\n+    let mut native: libc::pthread_t = mem::zeroed();\n+    let mut attr: libc::pthread_attr_t = mem::zeroed();\n+    assert_eq!(pthread_attr_init(&mut attr), 0);\n+    assert_eq!(pthread_attr_setdetachstate(&mut attr,\n+                                           PTHREAD_CREATE_JOINABLE), 0);\n+\n+    // Reserve room for the red zone, the runtime's stack of last resort.\n+    let stack_size = cmp::max(stack, RED_ZONE + min_stack_size(&attr) as uint);\n+    match pthread_attr_setstacksize(&mut attr, stack_size as libc::size_t) {\n+        0 => {\n+        },\n+        libc::EINVAL => {\n+            // EINVAL means |stack_size| is either too small or not a\n+            // multiple of the system page size.  Because it's definitely\n+            // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n+            // Round up to the nearest page and try again.\n+            let page_size = libc::sysconf(libc::_SC_PAGESIZE) as uint;\n+            let stack_size = (stack_size + page_size - 1) &\n+                             (-(page_size as int - 1) as uint - 1);\n+            assert_eq!(pthread_attr_setstacksize(&mut attr, stack_size as libc::size_t), 0);\n+        },\n+        errno => {\n+            // This cannot really happen.\n+            panic!(\"pthread_attr_setstacksize() error: {}\", errno);\n+        },\n+    };\n+\n+    let arg: *mut libc::c_void = mem::transmute(p);\n+    let ret = pthread_create(&mut native, &attr, thread_start, arg);\n+    assert_eq!(pthread_attr_destroy(&mut attr), 0);\n+\n+    if ret != 0 {\n+        // be sure to not leak the closure\n+        let _p: Box<proc():Send> = mem::transmute(arg);\n+        panic!(\"failed to spawn native thread: {}\", ret);\n+    }\n+    native\n+}\n+\n+pub unsafe fn join(native: rust_thread) {\n+    assert_eq!(pthread_join(native, ptr::null_mut()), 0);\n+}\n+\n+pub unsafe fn detach(native: rust_thread) {\n+    assert_eq!(pthread_detach(native), 0);\n+}\n+\n+pub unsafe fn yield_now() { assert_eq!(sched_yield(), 0); }\n+// glibc >= 2.15 has a __pthread_get_minstack() function that returns\n+// PTHREAD_STACK_MIN plus however many bytes are needed for thread-local\n+// storage.  We need that information to avoid blowing up when a small stack\n+// is created in an application with big thread-local storage requirements.\n+// See #6233 for rationale and details.\n+//\n+// Link weakly to the symbol for compatibility with older versions of glibc.\n+// Assumes that we've been dynamically linked to libpthread but that is\n+// currently always the case.  Note that you need to check that the symbol\n+// is non-null before calling it!\n+#[cfg(target_os = \"linux\")]\n+fn min_stack_size(attr: *const libc::pthread_attr_t) -> libc::size_t {\n+    type F = unsafe extern \"C\" fn(*const libc::pthread_attr_t) -> libc::size_t;\n+    extern {\n+        #[linkage = \"extern_weak\"]\n+        static __pthread_get_minstack: *const ();\n+    }\n+    if __pthread_get_minstack.is_null() {\n+        PTHREAD_STACK_MIN\n+    } else {\n+        unsafe { mem::transmute::<*const (), F>(__pthread_get_minstack)(attr) }\n+    }\n+}\n+\n+// __pthread_get_minstack() is marked as weak but extern_weak linkage is\n+// not supported on OS X, hence this kludge...\n+#[cfg(not(target_os = \"linux\"))]\n+fn min_stack_size(_: *const libc::pthread_attr_t) -> libc::size_t {\n+    PTHREAD_STACK_MIN\n+}\n+\n+#[cfg(any(target_os = \"linux\"))]\n+extern {\n+    pub fn pthread_self() -> libc::pthread_t;\n+    pub fn pthread_getattr_np(native: libc::pthread_t,\n+                              attr: *mut libc::pthread_attr_t) -> libc::c_int;\n+    pub fn pthread_attr_getguardsize(attr: *const libc::pthread_attr_t,\n+                                     guardsize: *mut libc::size_t) -> libc::c_int;\n+    pub fn pthread_attr_getstack(attr: *const libc::pthread_attr_t,\n+                                 stackaddr: *mut *mut libc::c_void,\n+                                 stacksize: *mut libc::size_t) -> libc::c_int;\n+}\n+\n+#[cfg(target_os = \"macos\")]\n+extern {\n+    pub fn pthread_self() -> libc::pthread_t;\n+    pub fn pthread_get_stackaddr_np(thread: libc::pthread_t) -> *mut libc::c_void;\n+    pub fn pthread_get_stacksize_np(thread: libc::pthread_t) -> libc::size_t;\n+}\n+\n+extern {\n+    fn pthread_create(native: *mut libc::pthread_t,\n+                      attr: *const libc::pthread_attr_t,\n+                      f: StartFn,\n+                      value: *mut libc::c_void) -> libc::c_int;\n+    fn pthread_join(native: libc::pthread_t,\n+                    value: *mut *mut libc::c_void) -> libc::c_int;\n+    fn pthread_attr_init(attr: *mut libc::pthread_attr_t) -> libc::c_int;\n+    pub fn pthread_attr_destroy(attr: *mut libc::pthread_attr_t) -> libc::c_int;\n+    fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,\n+                                 stack_size: libc::size_t) -> libc::c_int;\n+    fn pthread_attr_setdetachstate(attr: *mut libc::pthread_attr_t,\n+                                   state: libc::c_int) -> libc::c_int;\n+    fn pthread_detach(thread: libc::pthread_t) -> libc::c_int;\n+    fn sched_yield() -> libc::c_int;\n+}"}, {"sha": "833b69d6cbebb4d16ad92095858e3e0407fbee8b", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "added", "additions": 371, "deletions": 0, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -0,0 +1,371 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+/// As always, windows has something very different than unix, we mainly want\n+/// to avoid having to depend too much on libunwind for windows.\n+///\n+/// If you google around, you'll find a fair bit of references to built-in\n+/// functions to get backtraces on windows. It turns out that most of these are\n+/// in an external library called dbghelp. I was unable to find this library\n+/// via `-ldbghelp`, but it is apparently normal to do the `dlopen` equivalent\n+/// of it.\n+///\n+/// You'll also find that there's a function called CaptureStackBackTrace\n+/// mentioned frequently (which is also easy to use), but sadly I didn't have a\n+/// copy of that function in my mingw install (maybe it was broken?). Instead,\n+/// this takes the route of using StackWalk64 in order to walk the stack.\n+\n+use c_str::CString;\n+use intrinsics;\n+use io::{IoResult, Writer};\n+use libc;\n+use mem;\n+use ops::Drop;\n+use option::{Some, None};\n+use path::Path;\n+use result::{Ok, Err};\n+use rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+use slice::SliceExt;\n+use str::StrPrelude;\n+use dynamic_lib::DynamicLibrary;\n+\n+use sys_common::backtrace::*;\n+\n+#[allow(non_snake_case)]\n+extern \"system\" {\n+    fn GetCurrentProcess() -> libc::HANDLE;\n+    fn GetCurrentThread() -> libc::HANDLE;\n+    fn RtlCaptureContext(ctx: *mut arch::CONTEXT);\n+}\n+\n+type SymFromAddrFn =\n+    extern \"system\" fn(libc::HANDLE, u64, *mut u64,\n+                       *mut SYMBOL_INFO) -> libc::BOOL;\n+type SymInitializeFn =\n+    extern \"system\" fn(libc::HANDLE, *mut libc::c_void,\n+                       libc::BOOL) -> libc::BOOL;\n+type SymCleanupFn =\n+    extern \"system\" fn(libc::HANDLE) -> libc::BOOL;\n+\n+type StackWalk64Fn =\n+    extern \"system\" fn(libc::DWORD, libc::HANDLE, libc::HANDLE,\n+                       *mut STACKFRAME64, *mut arch::CONTEXT,\n+                       *mut libc::c_void, *mut libc::c_void,\n+                       *mut libc::c_void, *mut libc::c_void) -> libc::BOOL;\n+\n+const MAX_SYM_NAME: uint = 2000;\n+const IMAGE_FILE_MACHINE_I386: libc::DWORD = 0x014c;\n+const IMAGE_FILE_MACHINE_IA64: libc::DWORD = 0x0200;\n+const IMAGE_FILE_MACHINE_AMD64: libc::DWORD = 0x8664;\n+\n+#[repr(C)]\n+struct SYMBOL_INFO {\n+    SizeOfStruct: libc::c_ulong,\n+    TypeIndex: libc::c_ulong,\n+    Reserved: [u64, ..2],\n+    Index: libc::c_ulong,\n+    Size: libc::c_ulong,\n+    ModBase: u64,\n+    Flags: libc::c_ulong,\n+    Value: u64,\n+    Address: u64,\n+    Register: libc::c_ulong,\n+    Scope: libc::c_ulong,\n+    Tag: libc::c_ulong,\n+    NameLen: libc::c_ulong,\n+    MaxNameLen: libc::c_ulong,\n+    // note that windows has this as 1, but it basically just means that\n+    // the name is inline at the end of the struct. For us, we just bump\n+    // the struct size up to MAX_SYM_NAME.\n+    Name: [libc::c_char, ..MAX_SYM_NAME],\n+}\n+\n+\n+#[repr(C)]\n+enum ADDRESS_MODE {\n+    AddrMode1616,\n+    AddrMode1632,\n+    AddrModeReal,\n+    AddrModeFlat,\n+}\n+\n+struct ADDRESS64 {\n+    Offset: u64,\n+    Segment: u16,\n+    Mode: ADDRESS_MODE,\n+}\n+\n+struct STACKFRAME64 {\n+    AddrPC: ADDRESS64,\n+    AddrReturn: ADDRESS64,\n+    AddrFrame: ADDRESS64,\n+    AddrStack: ADDRESS64,\n+    AddrBStore: ADDRESS64,\n+    FuncTableEntry: *mut libc::c_void,\n+    Params: [u64, ..4],\n+    Far: libc::BOOL,\n+    Virtual: libc::BOOL,\n+    Reserved: [u64, ..3],\n+    KdHelp: KDHELP64,\n+}\n+\n+struct KDHELP64 {\n+    Thread: u64,\n+    ThCallbackStack: libc::DWORD,\n+    ThCallbackBStore: libc::DWORD,\n+    NextCallback: libc::DWORD,\n+    FramePointer: libc::DWORD,\n+    KiCallUserMode: u64,\n+    KeUserCallbackDispatcher: u64,\n+    SystemRangeStart: u64,\n+    KiUserExceptionDispatcher: u64,\n+    StackBase: u64,\n+    StackLimit: u64,\n+    Reserved: [u64, ..5],\n+}\n+\n+#[cfg(target_arch = \"x86\")]\n+mod arch {\n+    use libc;\n+\n+    const MAXIMUM_SUPPORTED_EXTENSION: uint = 512;\n+\n+    #[repr(C)]\n+    pub struct CONTEXT {\n+        ContextFlags: libc::DWORD,\n+        Dr0: libc::DWORD,\n+        Dr1: libc::DWORD,\n+        Dr2: libc::DWORD,\n+        Dr3: libc::DWORD,\n+        Dr6: libc::DWORD,\n+        Dr7: libc::DWORD,\n+        FloatSave: FLOATING_SAVE_AREA,\n+        SegGs: libc::DWORD,\n+        SegFs: libc::DWORD,\n+        SegEs: libc::DWORD,\n+        SegDs: libc::DWORD,\n+        Edi: libc::DWORD,\n+        Esi: libc::DWORD,\n+        Ebx: libc::DWORD,\n+        Edx: libc::DWORD,\n+        Ecx: libc::DWORD,\n+        Eax: libc::DWORD,\n+        Ebp: libc::DWORD,\n+        Eip: libc::DWORD,\n+        SegCs: libc::DWORD,\n+        EFlags: libc::DWORD,\n+        Esp: libc::DWORD,\n+        SegSs: libc::DWORD,\n+        ExtendedRegisters: [u8, ..MAXIMUM_SUPPORTED_EXTENSION],\n+    }\n+\n+    #[repr(C)]\n+    pub struct FLOATING_SAVE_AREA {\n+        ControlWord: libc::DWORD,\n+        StatusWord: libc::DWORD,\n+        TagWord: libc::DWORD,\n+        ErrorOffset: libc::DWORD,\n+        ErrorSelector: libc::DWORD,\n+        DataOffset: libc::DWORD,\n+        DataSelector: libc::DWORD,\n+        RegisterArea: [u8, ..80],\n+        Cr0NpxState: libc::DWORD,\n+    }\n+\n+    pub fn init_frame(frame: &mut super::STACKFRAME64,\n+                      ctx: &CONTEXT) -> libc::DWORD {\n+        frame.AddrPC.Offset = ctx.Eip as u64;\n+        frame.AddrPC.Mode = super::ADDRESS_MODE::AddrModeFlat;\n+        frame.AddrStack.Offset = ctx.Esp as u64;\n+        frame.AddrStack.Mode = super::ADDRESS_MODE::AddrModeFlat;\n+        frame.AddrFrame.Offset = ctx.Ebp as u64;\n+        frame.AddrFrame.Mode = super::ADDRESS_MODE::AddrModeFlat;\n+        super::IMAGE_FILE_MACHINE_I386\n+    }\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+mod arch {\n+    use libc::{c_longlong, c_ulonglong};\n+    use libc::types::os::arch::extra::{WORD, DWORD, DWORDLONG};\n+    use simd;\n+\n+    #[repr(C)]\n+    pub struct CONTEXT {\n+        _align_hack: [simd::u64x2, ..0], // FIXME align on 16-byte\n+        P1Home: DWORDLONG,\n+        P2Home: DWORDLONG,\n+        P3Home: DWORDLONG,\n+        P4Home: DWORDLONG,\n+        P5Home: DWORDLONG,\n+        P6Home: DWORDLONG,\n+\n+        ContextFlags: DWORD,\n+        MxCsr: DWORD,\n+\n+        SegCs: WORD,\n+        SegDs: WORD,\n+        SegEs: WORD,\n+        SegFs: WORD,\n+        SegGs: WORD,\n+        SegSs: WORD,\n+        EFlags: DWORD,\n+\n+        Dr0: DWORDLONG,\n+        Dr1: DWORDLONG,\n+        Dr2: DWORDLONG,\n+        Dr3: DWORDLONG,\n+        Dr6: DWORDLONG,\n+        Dr7: DWORDLONG,\n+\n+        Rax: DWORDLONG,\n+        Rcx: DWORDLONG,\n+        Rdx: DWORDLONG,\n+        Rbx: DWORDLONG,\n+        Rsp: DWORDLONG,\n+        Rbp: DWORDLONG,\n+        Rsi: DWORDLONG,\n+        Rdi: DWORDLONG,\n+        R8:  DWORDLONG,\n+        R9:  DWORDLONG,\n+        R10: DWORDLONG,\n+        R11: DWORDLONG,\n+        R12: DWORDLONG,\n+        R13: DWORDLONG,\n+        R14: DWORDLONG,\n+        R15: DWORDLONG,\n+\n+        Rip: DWORDLONG,\n+\n+        FltSave: FLOATING_SAVE_AREA,\n+\n+        VectorRegister: [M128A, .. 26],\n+        VectorControl: DWORDLONG,\n+\n+        DebugControl: DWORDLONG,\n+        LastBranchToRip: DWORDLONG,\n+        LastBranchFromRip: DWORDLONG,\n+        LastExceptionToRip: DWORDLONG,\n+        LastExceptionFromRip: DWORDLONG,\n+    }\n+\n+    #[repr(C)]\n+    pub struct M128A {\n+        _align_hack: [simd::u64x2, ..0], // FIXME align on 16-byte\n+        Low:  c_ulonglong,\n+        High: c_longlong\n+    }\n+\n+    #[repr(C)]\n+    pub struct FLOATING_SAVE_AREA {\n+        _align_hack: [simd::u64x2, ..0], // FIXME align on 16-byte\n+        _Dummy: [u8, ..512] // FIXME: Fill this out\n+    }\n+\n+    pub fn init_frame(frame: &mut super::STACKFRAME64,\n+                      ctx: &CONTEXT) -> DWORD {\n+        frame.AddrPC.Offset = ctx.Rip as u64;\n+        frame.AddrPC.Mode = super::ADDRESS_MODE::AddrModeFlat;\n+        frame.AddrStack.Offset = ctx.Rsp as u64;\n+        frame.AddrStack.Mode = super::ADDRESS_MODE::AddrModeFlat;\n+        frame.AddrFrame.Offset = ctx.Rbp as u64;\n+        frame.AddrFrame.Mode = super::ADDRESS_MODE::AddrModeFlat;\n+        super::IMAGE_FILE_MACHINE_AMD64\n+    }\n+}\n+\n+#[repr(C)]\n+struct Cleanup {\n+    handle: libc::HANDLE,\n+    SymCleanup: SymCleanupFn,\n+}\n+\n+impl Drop for Cleanup {\n+    fn drop(&mut self) { (self.SymCleanup)(self.handle); }\n+}\n+\n+pub fn write(w: &mut Writer) -> IoResult<()> {\n+    // According to windows documentation, all dbghelp functions are\n+    // single-threaded.\n+    static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+    let _g = unsafe { LOCK.lock() };\n+\n+    // Open up dbghelp.dll, we don't link to it explicitly because it can't\n+    // always be found. Additionally, it's nice having fewer dependencies.\n+    let path = Path::new(\"dbghelp.dll\");\n+    let lib = match DynamicLibrary::open(Some(&path)) {\n+        Ok(lib) => lib,\n+        Err(..) => return Ok(()),\n+    };\n+\n+    macro_rules! sym( ($e:expr, $t:ident) => (unsafe {\n+        match lib.symbol($e) {\n+            Ok(f) => mem::transmute::<*mut u8, $t>(f),\n+            Err(..) => return Ok(())\n+        }\n+    }) )\n+\n+    // Fetch the symbols necessary from dbghelp.dll\n+    let SymFromAddr = sym!(\"SymFromAddr\", SymFromAddrFn);\n+    let SymInitialize = sym!(\"SymInitialize\", SymInitializeFn);\n+    let SymCleanup = sym!(\"SymCleanup\", SymCleanupFn);\n+    let StackWalk64 = sym!(\"StackWalk64\", StackWalk64Fn);\n+\n+    // Allocate necessary structures for doing the stack walk\n+    let process = unsafe { GetCurrentProcess() };\n+    let thread = unsafe { GetCurrentThread() };\n+    let mut context: arch::CONTEXT = unsafe { intrinsics::init() };\n+    unsafe { RtlCaptureContext(&mut context); }\n+    let mut frame: STACKFRAME64 = unsafe { intrinsics::init() };\n+    let image = arch::init_frame(&mut frame, &context);\n+\n+    // Initialize this process's symbols\n+    let ret = SymInitialize(process, 0 as *mut libc::c_void, libc::TRUE);\n+    if ret != libc::TRUE { return Ok(()) }\n+    let _c = Cleanup { handle: process, SymCleanup: SymCleanup };\n+\n+    // And now that we're done with all the setup, do the stack walking!\n+    let mut i = 0i;\n+    try!(write!(w, \"stack backtrace:\\n\"));\n+    while StackWalk64(image, process, thread, &mut frame, &mut context,\n+                      0 as *mut libc::c_void,\n+                      0 as *mut libc::c_void,\n+                      0 as *mut libc::c_void,\n+                      0 as *mut libc::c_void) == libc::TRUE{\n+        let addr = frame.AddrPC.Offset;\n+        if addr == frame.AddrReturn.Offset || addr == 0 ||\n+           frame.AddrReturn.Offset == 0 { break }\n+\n+        i += 1;\n+        try!(write!(w, \"  {:2}: {:#2$x}\", i, addr, HEX_WIDTH));\n+        let mut info: SYMBOL_INFO = unsafe { intrinsics::init() };\n+        info.MaxNameLen = MAX_SYM_NAME as libc::c_ulong;\n+        // the struct size in C.  the value is different to\n+        // `size_of::<SYMBOL_INFO>() - MAX_SYM_NAME + 1` (== 81)\n+        // due to struct alignment.\n+        info.SizeOfStruct = 88;\n+\n+        let mut displacement = 0u64;\n+        let ret = SymFromAddr(process, addr as u64, &mut displacement,\n+                              &mut info);\n+\n+        if ret == libc::TRUE {\n+            try!(write!(w, \" - \"));\n+            let cstr = unsafe { CString::new(info.Name.as_ptr(), false) };\n+            let bytes = cstr.as_bytes();\n+            match cstr.as_str() {\n+                Some(s) => try!(demangle(w, s)),\n+                None => try!(w.write(bytes[..bytes.len()-1])),\n+            }\n+        }\n+        try!(w.write(&['\\n' as u8]));\n+    }\n+\n+    Ok(())\n+}"}, {"sha": "6924687d8c470235bed45caa3f5384fd07fe70db", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -35,6 +35,7 @@ macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n     };\n ) }\n \n+pub mod backtrace;\n pub mod c;\n pub mod ext;\n pub mod condvar;\n@@ -46,7 +47,9 @@ pub mod pipe;\n pub mod process;\n pub mod rwlock;\n pub mod sync;\n+pub mod stack_overflow;\n pub mod tcp;\n+pub mod thread;\n pub mod thread_local;\n pub mod timer;\n pub mod tty;"}, {"sha": "e3d96a054f4c678b7a27345ba5e672591b089ada", "filename": "src/libstd/sys/windows/stack_overflow.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -0,0 +1,120 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rt::local::Local;\n+use rt::task::Task;\n+use rt::util::report_overflow;\n+use core::prelude::*;\n+use ptr;\n+use mem;\n+use libc;\n+use libc::types::os::arch::extra::{LPVOID, DWORD, LONG, BOOL};\n+use sys_common::stack;\n+\n+pub struct Handler {\n+    _data: *mut libc::c_void\n+}\n+\n+impl Handler {\n+    pub unsafe fn new() -> Handler {\n+        make_handler()\n+    }\n+}\n+\n+impl Drop for Handler {\n+    fn drop(&mut self) {}\n+}\n+\n+// get_task_info is called from an exception / signal handler.\n+// It returns the guard page of the current task or 0 if that\n+// guard page doesn't exist. None is returned if there's currently\n+// no local task.\n+unsafe fn get_task_guard_page() -> Option<uint> {\n+    let task: Option<*mut Task> = Local::try_unsafe_borrow();\n+    task.map(|task| (&*task).stack_guard().unwrap_or(0))\n+}\n+\n+// This is initialized in init() and only read from after\n+static mut PAGE_SIZE: uint = 0;\n+\n+#[no_stack_check]\n+extern \"system\" fn vectored_handler(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG {\n+    unsafe {\n+        let rec = &(*(*ExceptionInfo).ExceptionRecord);\n+        let code = rec.ExceptionCode;\n+\n+        if code != EXCEPTION_STACK_OVERFLOW {\n+            return EXCEPTION_CONTINUE_SEARCH;\n+        }\n+\n+        // We're calling into functions with stack checks,\n+        // however stack checks by limit should be disabled on Windows\n+        stack::record_sp_limit(0);\n+\n+        if get_task_guard_page().is_some() {\n+           report_overflow();\n+        }\n+\n+        EXCEPTION_CONTINUE_SEARCH\n+    }\n+}\n+\n+pub unsafe fn init() {\n+    let mut info = mem::zeroed();\n+    libc::GetSystemInfo(&mut info);\n+    PAGE_SIZE = info.dwPageSize as uint;\n+\n+    if AddVectoredExceptionHandler(0, vectored_handler) == ptr::null_mut() {\n+        panic!(\"failed to install exception handler\");\n+    }\n+\n+    mem::forget(make_handler());\n+}\n+\n+pub unsafe fn cleanup() {\n+}\n+\n+pub unsafe fn make_handler() -> Handler {\n+    if SetThreadStackGuarantee(&mut 0x5000) == 0 {\n+        panic!(\"failed to reserve stack space for exception handling\");\n+    }\n+\n+    Handler { _data: 0i as *mut libc::c_void }\n+}\n+\n+pub struct EXCEPTION_RECORD {\n+    pub ExceptionCode: DWORD,\n+    pub ExceptionFlags: DWORD,\n+    pub ExceptionRecord: *mut EXCEPTION_RECORD,\n+    pub ExceptionAddress: LPVOID,\n+    pub NumberParameters: DWORD,\n+    pub ExceptionInformation: [LPVOID, ..EXCEPTION_MAXIMUM_PARAMETERS]\n+}\n+\n+pub struct EXCEPTION_POINTERS {\n+    pub ExceptionRecord: *mut EXCEPTION_RECORD,\n+    pub ContextRecord: LPVOID\n+}\n+\n+pub type PVECTORED_EXCEPTION_HANDLER = extern \"system\"\n+        fn(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG;\n+\n+pub type ULONG = libc::c_ulong;\n+\n+const EXCEPTION_CONTINUE_SEARCH: LONG = 0;\n+const EXCEPTION_MAXIMUM_PARAMETERS: uint = 15;\n+const EXCEPTION_STACK_OVERFLOW: DWORD = 0xc00000fd;\n+\n+extern \"system\" {\n+    fn AddVectoredExceptionHandler(FirstHandler: ULONG,\n+                                   VectoredHandler: PVECTORED_EXCEPTION_HANDLER)\n+                                  -> LPVOID;\n+    fn SetThreadStackGuarantee(StackSizeInBytes: *mut ULONG) -> BOOL;\n+}"}, {"sha": "00f1e9767f5faf88f16664fe946efa55a6ebdb11", "filename": "src/libstd/sys/windows/thread.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use boxed::Box;\n+use cmp;\n+use mem;\n+use ptr;\n+use libc;\n+use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, SIZE_T, BOOL,\n+                                   LPVOID, DWORD, LPDWORD, HANDLE};\n+use sys_common::stack::RED_ZONE;\n+use sys_common::thread::*;\n+\n+pub type rust_thread = HANDLE;\n+pub type rust_thread_return = DWORD;\n+\n+pub type StartFn = extern \"system\" fn(*mut libc::c_void) -> rust_thread_return;\n+\n+#[no_stack_check]\n+pub extern \"system\" fn thread_start(main: *mut libc::c_void) -> rust_thread_return {\n+    return start_thread(main);\n+}\n+\n+pub mod guard {\n+    pub unsafe fn main() -> uint {\n+        0\n+    }\n+\n+    pub unsafe fn current() -> uint {\n+        0\n+    }\n+\n+    pub unsafe fn init() {\n+    }\n+}\n+\n+pub unsafe fn create(stack: uint, p: Box<proc():Send>) -> rust_thread {\n+    let arg: *mut libc::c_void = mem::transmute(p);\n+    // FIXME On UNIX, we guard against stack sizes that are too small but\n+    // that's because pthreads enforces that stacks are at least\n+    // PTHREAD_STACK_MIN bytes big.  Windows has no such lower limit, it's\n+    // just that below a certain threshold you can't do anything useful.\n+    // That threshold is application and architecture-specific, however.\n+    // For now, the only requirement is that it's big enough to hold the\n+    // red zone.  Round up to the next 64 kB because that's what the NT\n+    // kernel does, might as well make it explicit.  With the current\n+    // 20 kB red zone, that makes for a 64 kB minimum stack.\n+    let stack_size = (cmp::max(stack, RED_ZONE) + 0xfffe) & (-0xfffe - 1);\n+    let ret = CreateThread(ptr::null_mut(), stack_size as libc::size_t,\n+                           thread_start, arg, 0, ptr::null_mut());\n+\n+    if ret as uint == 0 {\n+        // be sure to not leak the closure\n+        let _p: Box<proc():Send> = mem::transmute(arg);\n+        panic!(\"failed to spawn native thread: {}\", ret);\n+    }\n+    return ret;\n+}\n+\n+pub unsafe fn join(native: rust_thread) {\n+    use libc::consts::os::extra::INFINITE;\n+    WaitForSingleObject(native, INFINITE);\n+}\n+\n+pub unsafe fn detach(native: rust_thread) {\n+    assert!(libc::CloseHandle(native) != 0);\n+}\n+\n+pub unsafe fn yield_now() {\n+    // This function will return 0 if there are no other threads to execute,\n+    // but this also means that the yield was useless so this isn't really a\n+    // case that needs to be worried about.\n+    SwitchToThread();\n+}\n+\n+#[allow(non_snake_case)]\n+extern \"system\" {\n+    fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES,\n+                    dwStackSize: SIZE_T,\n+                    lpStartAddress: StartFn,\n+                    lpParameter: LPVOID,\n+                    dwCreationFlags: DWORD,\n+                    lpThreadId: LPDWORD) -> HANDLE;\n+    fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n+    fn SwitchToThread() -> BOOL;\n+}"}, {"sha": "6c8d9639d5c4c484e27b13c8ee349192e85aa42b", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -13,8 +13,8 @@ use prelude::*;\n use libc::types::os::arch::extra::{DWORD, LPVOID, BOOL};\n \n use mem;\n-use rustrt;\n-use rustrt::exclusive::Exclusive;\n+use rt;\n+use rt::exclusive::Exclusive;\n use sync::{ONCE_INIT, Once};\n \n pub type Key = DWORD;\n@@ -131,7 +131,7 @@ fn init_dtors() {\n         DTORS = mem::transmute(dtors);\n     }\n \n-    rustrt::at_exit(move|| unsafe {\n+    rt::at_exit(move|| unsafe {\n         mem::transmute::<_, Box<Exclusive<Vec<(Key, Dtor)>>>>(DTORS);\n         DTORS = 0 as *mut _;\n     });"}, {"sha": "127cad186f693d998e2c1ca5d3de46cdafed2c1f", "filename": "src/libstd/task.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -53,9 +53,9 @@ use kinds::Send;\n use option::Option;\n use option::Option::{None, Some};\n use result::Result;\n-use rustrt::local::Local;\n-use rustrt::task::Task;\n-use rustrt::task;\n+use rt::local::Local;\n+use rt::task;\n+use rt::task::Task;\n use str::SendStr;\n use string::{String, ToString};\n use thunk::{Thunk};\n@@ -252,7 +252,7 @@ pub fn try_future<T,F>(f: F) -> Future<Result<T, Box<Any + Send>>>\n /// Read the name of the current task.\n #[stable]\n pub fn name() -> Option<String> {\n-    use rustrt::task::Task;\n+    use rt::task::Task;\n \n     let task = Local::borrow(None::<Task>);\n     match task.name {\n@@ -264,15 +264,15 @@ pub fn name() -> Option<String> {\n /// Yield control to the task scheduler.\n #[unstable = \"Name will change.\"]\n pub fn deschedule() {\n-    use rustrt::task::Task;\n+    use rt::task::Task;\n     Task::yield_now();\n }\n \n /// True if the running task is currently panicking (e.g. will return `true` inside a\n /// destructor that is run while unwinding the stack after a call to `panic!()`).\n #[unstable = \"May move to a different module.\"]\n pub fn failing() -> bool {\n-    use rustrt::task::Task;\n+    use rt::task::Task;\n     Local::borrow(None::<Task>).unwinder.unwinding()\n }\n "}, {"sha": "b78428d69de2153a0f244ccb7bbeb7911af1b6f9", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -446,7 +446,7 @@ mod tests {\n     use prelude::*;\n \n     use cell::UnsafeCell;\n-    use rustrt::thread::Thread;\n+    use rt::thread::Thread;\n \n     struct Foo(Sender<()>);\n "}, {"sha": "42e784959909fab1fa561399b5ef5a3979191658", "filename": "src/libstd/thunk.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fthunk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Flibstd%2Fthunk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthunk.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "previous_filename": "src/librustrt/thunk.rs"}, {"sha": "18b23b4143a58430a02dfac512a7f10e7c986a77", "filename": "src/rt/rust_try.ll", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Frt%2Frust_try.ll", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Frt%2Frust_try.ll", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_try.ll?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -12,7 +12,7 @@\n ; When f(...) returns normally, the return value is null.\n ; When f(...) throws, the return value is a pointer to the caught exception object.\n \n-; See also: librustrt/unwind.rs\n+; See also: libstd/rt/unwind.rs\n \n define i8* @rust_try(void (i8*,i8*)* %f, i8* %fptr, i8* %env) {\n "}, {"sha": "0bfae8498e2a6f358c18ec49f389d1dc420fca94", "filename": "src/test/run-pass/foreign-call-no-runtime.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -9,10 +9,9 @@\n // except according to those terms.\n \n extern crate libc;\n-extern crate rustrt;\n \n use std::mem;\n-use rustrt::thread::Thread;\n+use std::rt::thread::Thread;\n \n #[link(name = \"rust_test_helpers\")]\n extern {"}, {"sha": "9a822ddbbcc5141b765526caafb8181865d752f1", "filename": "src/test/run-pass/match-ref-binding-in-guard-3256.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Ftest%2Frun-pass%2Fmatch-ref-binding-in-guard-3256.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Ftest%2Frun-pass%2Fmatch-ref-binding-in-guard-3256.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-ref-binding-in-guard-3256.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate rustrt;\n+use std::rt::exclusive;\n \n pub fn main() {\n     unsafe {\n-        let x = Some(::rustrt::exclusive::Exclusive::new(true));\n+        let x = Some(exclusive::Exclusive::new(true));\n         match x {\n             Some(ref z) if *z.lock() => {\n                 assert!(*z.lock());"}, {"sha": "067b0e8dfb4a29af83cf093eaf98261f46d7c3cf", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -8,15 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate rustrt;\n-\n use std::io::process::{Command, ProcessOutput};\n use std::os;\n use std::str;\n use std::rt;\n use std::thunk::Thunk;\n \n-use rustrt::unwind::try;\n+use std::rt::unwind::try;\n \n #[start]\n fn start(argc: int, argv: *const *const u8) -> int {"}, {"sha": "a86aedd757a30963640b86fc18fec5f20ad58662", "filename": "src/test/run-pass/writealias.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b3477d373603527d23cc578f3737857b7b253d7/src%2Ftest%2Frun-pass%2Fwritealias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3477d373603527d23cc578f3737857b7b253d7/src%2Ftest%2Frun-pass%2Fwritealias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwritealias.rs?ref=2b3477d373603527d23cc578f3737857b7b253d7", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate rustrt;\n+use std::rt::exclusive;\n \n struct Point {x: int, y: int, z: int}\n \n fn f(p: &mut Point) { p.z = 13; }\n \n pub fn main() {\n     unsafe {\n-        let x = Some(::rustrt::exclusive::Exclusive::new(true));\n+        let x = Some(exclusive::Exclusive::new(true));\n         match x {\n             Some(ref z) if *z.lock() => {\n                 assert!(*z.lock());"}]}