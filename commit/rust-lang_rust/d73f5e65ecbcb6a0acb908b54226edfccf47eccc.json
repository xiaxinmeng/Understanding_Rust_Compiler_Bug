{"sha": "d73f5e65ecbcb6a0acb908b54226edfccf47eccc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3M2Y1ZTY1ZWNiY2I2YTBhY2I5MDhiNTQyMjZlZGZjY2Y0N2VjY2M=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2016-05-25T04:44:28Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2016-06-02T12:31:01Z"}, "message": "Fix undefined behavior when re-locking a mutex from the same thread\n\nThe only applies to pthread mutexes. We solve this by creating the\nmutex with the PTHREAD_MUTEX_NORMAL type, which guarantees that\nre-locking from the same thread will deadlock.", "tree": {"sha": "b65444fe5785dbd66b4e04ff14c2575ad475407b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b65444fe5785dbd66b4e04ff14c2575ad475407b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d73f5e65ecbcb6a0acb908b54226edfccf47eccc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d73f5e65ecbcb6a0acb908b54226edfccf47eccc", "html_url": "https://github.com/rust-lang/rust/commit/d73f5e65ecbcb6a0acb908b54226edfccf47eccc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d73f5e65ecbcb6a0acb908b54226edfccf47eccc/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eea4f0c24893d3b5bffec067e6051eb0b5106748", "url": "https://api.github.com/repos/rust-lang/rust/commits/eea4f0c24893d3b5bffec067e6051eb0b5106748", "html_url": "https://github.com/rust-lang/rust/commit/eea4f0c24893d3b5bffec067e6051eb0b5106748"}], "stats": {"total": 47, "additions": 46, "deletions": 1}, "files": [{"sha": "e53a97eccdfca41e179ff3b2f73c1d7e4dab9901", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d73f5e65ecbcb6a0acb908b54226edfccf47eccc/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d73f5e65ecbcb6a0acb908b54226edfccf47eccc/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=d73f5e65ecbcb6a0acb908b54226edfccf47eccc", "patch": "@@ -190,10 +190,14 @@ impl<T> Mutex<T> {\n     /// Creates a new mutex in an unlocked state ready for use.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(t: T) -> Mutex<T> {\n-        Mutex {\n+        let mut m = Mutex {\n             inner: box StaticMutex::new(),\n             data: UnsafeCell::new(t),\n+        };\n+        unsafe {\n+            m.inner.lock.init();\n         }\n+        m\n     }\n }\n "}, {"sha": "7a2183c522f5b92154b198e55aea3cdc4455a5f4", "filename": "src/libstd/sys/common/mutex.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d73f5e65ecbcb6a0acb908b54226edfccf47eccc/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d73f5e65ecbcb6a0acb908b54226edfccf47eccc/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs?ref=d73f5e65ecbcb6a0acb908b54226edfccf47eccc", "patch": "@@ -27,6 +27,12 @@ impl Mutex {\n     /// first used with any of the functions below.\n     pub const fn new() -> Mutex { Mutex(imp::Mutex::new()) }\n \n+    /// Prepare the mutex for use.\n+    ///\n+    /// This should be called once the mutex is at a stable memory address.\n+    #[inline]\n+    pub unsafe fn init(&mut self) { self.0.init() }\n+\n     /// Locks the mutex blocking the current thread until it is available.\n     ///\n     /// Behavior is undefined if the mutex has been moved between this and any"}, {"sha": "52cf3f97c5c83ba49e12fb37a746710d87840160", "filename": "src/libstd/sys/unix/mutex.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d73f5e65ecbcb6a0acb908b54226edfccf47eccc/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d73f5e65ecbcb6a0acb908b54226edfccf47eccc/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs?ref=d73f5e65ecbcb6a0acb908b54226edfccf47eccc", "patch": "@@ -30,6 +30,39 @@ impl Mutex {\n         Mutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n     }\n     #[inline]\n+    pub unsafe fn init(&mut self) {\n+        // Issue #33770\n+        //\n+        // A pthread mutex initialized with PTHREAD_MUTEX_INITIALIZER will have\n+        // a type of PTHREAD_MUTEX_DEFAULT, which has undefined behavior if you\n+        // try to re-lock it from the same thread when you already hold a lock.\n+        //\n+        // In practice, glibc takes advantage of this undefined behavior to\n+        // implement hardware lock elision, which uses hardware transactional\n+        // memory to avoid acquiring the lock. While a transaction is in\n+        // progress, the lock appears to be unlocked. This isn't a problem for\n+        // other threads since the transactional memory will abort if a conflict\n+        // is detected, however no abort is generated if re-locking from the\n+        // same thread.\n+        //\n+        // Since locking the same mutex twice will result in two aliasing &mut\n+        // references, we instead create the mutex with type\n+        // PTHREAD_MUTEX_NORMAL which is guaranteed to deadlock if we try to\n+        // re-lock it from the same thread, thus avoiding undefined behavior.\n+        //\n+        // We can't do anything for StaticMutex, but that type is deprecated\n+        // anyways.\n+        let mut attr: libc::pthread_mutexattr_t = mem::uninitialized();\n+        let r = libc::pthread_mutexattr_init(&mut attr);\n+        debug_assert_eq!(r, 0);\n+        let r = libc::pthread_mutexattr_settype(&mut attr, libc::PTHREAD_MUTEX_NORMAL);\n+        debug_assert_eq!(r, 0);\n+        let r = libc::pthread_mutex_init(self.inner.get(), &attr);\n+        debug_assert_eq!(r, 0);\n+        let r = libc::pthread_mutexattr_destroy(&mut attr);\n+        debug_assert_eq!(r, 0);\n+    }\n+    #[inline]\n     pub unsafe fn lock(&self) {\n         let r = libc::pthread_mutex_lock(self.inner.get());\n         debug_assert_eq!(r, 0);"}, {"sha": "8762b34e3da484df7fbf49854f4ac57f754a8a1d", "filename": "src/libstd/sys/windows/mutex.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d73f5e65ecbcb6a0acb908b54226edfccf47eccc/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d73f5e65ecbcb6a0acb908b54226edfccf47eccc/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=d73f5e65ecbcb6a0acb908b54226edfccf47eccc", "patch": "@@ -64,6 +64,8 @@ impl Mutex {\n             held: UnsafeCell::new(false),\n         }\n     }\n+    #[inline]\n+    pub unsafe fn init(&mut self) {}\n     pub unsafe fn lock(&self) {\n         match kind() {\n             Kind::SRWLock => c::AcquireSRWLockExclusive(raw(self)),"}]}