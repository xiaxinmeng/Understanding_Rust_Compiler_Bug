{"sha": "144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0NGRhMGRmZGRkMmM1YmE0ZWE5ZGJiMzM0NDMzMTlkMmU4OGU4ZmE=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-09-18T00:41:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-09-18T00:41:54Z"}, "message": "Merge pull request #1964 from topecongiro/rfc/binop\n\nRFC: binop", "tree": {"sha": "14921dd3bf4524d9810e7bed689f2a850567ca5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14921dd3bf4524d9810e7bed689f2a850567ca5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "html_url": "https://github.com/rust-lang/rust/commit/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a97e37de54b4271bf702d7f64c8c8297d836826", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a97e37de54b4271bf702d7f64c8c8297d836826", "html_url": "https://github.com/rust-lang/rust/commit/5a97e37de54b4271bf702d7f64c8c8297d836826"}, {"sha": "bc56e7b710dda399d295a5d24053eff2aaf8f14d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc56e7b710dda399d295a5d24053eff2aaf8f14d", "html_url": "https://github.com/rust-lang/rust/commit/bc56e7b710dda399d295a5d24053eff2aaf8f14d"}], "stats": {"total": 643, "additions": 381, "deletions": 262}, "files": [{"sha": "923727d986b66456f2b65f70c848c23f584766e0", "filename": "Configurations.md", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/Configurations.md", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/Configurations.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Configurations.md?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -160,6 +160,43 @@ enum Lorem {\n }\n ```\n \n+## `binop_separator`\n+\n+Where to put a binary operator when a binary expression goes multiline.\n+\n+- **Default value**: `\"Front\"`\n+- **Possible values**: `\"Front\"`, `\"Back\"`\n+\n+#### `\"Front\"`\n+\n+```rust\n+let or = foo\n+    || bar\n+    || foobar;\n+\n+let sum = 1234\n+    + 5678\n+    + 910;\n+\n+let range = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+    ..bbbbbbbbbbbbbbbbbbbbbbbbbbbbb;\n+```\n+\n+#### `\"Back\"`\n+\n+```rust\n+let or = foo ||\n+    bar ||\n+    foobar;\n+\n+let sum = 1234 +\n+    5678 +\n+    910;\n+\n+let range = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa..\n+    bbbbbbbbbbbbbbbbbbbbbbbbbbbbb;\n+```\n+\n ## `chain_indent`\n \n Indentation of chain"}, {"sha": "f6055927f863c3facf3102eeaff69e2827694764", "filename": "src/chains.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -183,9 +183,9 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     } else {\n         min(shape.width, context.config.chain_one_line_max())\n     };\n-    let all_in_one_line = !parent_rewrite_contains_newline &&\n-        rewrites.iter().all(|s| !s.contains('\\n')) &&\n-        almost_total < one_line_budget;\n+    let all_in_one_line = !parent_rewrite_contains_newline\n+        && rewrites.iter().all(|s| !s.contains('\\n'))\n+        && almost_total < one_line_budget;\n     let rewrite_last = || rewrite_chain_subexpr(last_subexpr, total_span, context, nested_shape);\n     let (last_subexpr_str, fits_single_line) = try_opt!(if all_in_one_line || extend_last_subexr {\n         parent_shape.offset_left(almost_total).map(|shape| {\n@@ -224,9 +224,9 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         format!(\"\\n{}\", nested_shape.indent.to_string(context.config))\n     };\n \n-    let first_connector = if is_small_parent || fits_single_line ||\n-        last_line_extendable(&parent_rewrite) ||\n-        context.config.chain_indent() == IndentStyle::Visual\n+    let first_connector = if is_small_parent || fits_single_line\n+        || last_line_extendable(&parent_rewrite)\n+        || context.config.chain_indent() == IndentStyle::Visual\n     {\n         \"\"\n     } else {\n@@ -445,12 +445,12 @@ fn choose_first_connector<'a>(\n ) -> &'a str {\n     if subexpr_list.is_empty() {\n         \"\"\n-    } else if extend || subexpr_list.last().map_or(false, is_try) ||\n-        is_extendable_parent(context, parent_str)\n+    } else if extend || subexpr_list.last().map_or(false, is_try)\n+        || is_extendable_parent(context, parent_str)\n     {\n         // 1 = \";\", being conservative here.\n-        if last_line_width(parent_str) + first_line_width(first_child_str) + 1 <=\n-            context.config.max_width()\n+        if last_line_width(parent_str) + first_line_width(first_child_str) + 1\n+            <= context.config.max_width()\n         {\n             \"\"\n         } else {"}, {"sha": "32f46e195c13bc7dcc38ccc4604887414dc2a471", "filename": "src/comment.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -91,13 +91,13 @@ impl<'a> CommentStyle<'a> {\n     pub fn line_with_same_comment_style(&self, line: &str, normalize_comments: bool) -> bool {\n         match *self {\n             CommentStyle::DoubleSlash | CommentStyle::TripleSlash | CommentStyle::Doc => {\n-                line.trim_left().starts_with(self.line_start().trim_left()) ||\n-                    comment_style(line, normalize_comments) == *self\n+                line.trim_left().starts_with(self.line_start().trim_left())\n+                    || comment_style(line, normalize_comments) == *self\n             }\n             CommentStyle::DoubleBullet | CommentStyle::SingleBullet | CommentStyle::Exclamation => {\n-                line.trim_left().starts_with(self.closer().trim_left()) ||\n-                    line.trim_left().starts_with(self.line_start().trim_left()) ||\n-                    comment_style(line, normalize_comments) == *self\n+                line.trim_left().starts_with(self.closer().trim_left())\n+                    || line.trim_left().starts_with(self.line_start().trim_left())\n+                    || comment_style(line, normalize_comments) == *self\n             }\n             CommentStyle::Custom(opener) => line.trim_left().starts_with(opener.trim_right()),\n         }\n@@ -121,8 +121,8 @@ fn comment_style(orig: &str, normalize_comments: bool) -> CommentStyle {\n         } else {\n             CommentStyle::DoubleSlash\n         }\n-    } else if (orig.starts_with(\"///\") && orig.chars().nth(3).map_or(true, |c| c != '/')) ||\n-        (orig.starts_with(\"/**\") && !orig.starts_with(\"/**/\"))\n+    } else if (orig.starts_with(\"///\") && orig.chars().nth(3).map_or(true, |c| c != '/'))\n+        || (orig.starts_with(\"/**\") && !orig.starts_with(\"/**/\"))\n     {\n         CommentStyle::TripleSlash\n     } else if orig.starts_with(\"//!\") || orig.starts_with(\"/*!\") {\n@@ -424,8 +424,8 @@ fn light_rewrite_comment(orig: &str, offset: Indent, config: &Config) -> Option<\n /// Trims comment characters and possibly a single space from the left of a string.\n /// Does not trim all whitespace.\n fn left_trim_comment_line<'a>(line: &'a str, style: &CommentStyle) -> &'a str {\n-    if line.starts_with(\"//! \") || line.starts_with(\"/// \") || line.starts_with(\"/*! \") ||\n-        line.starts_with(\"/** \")\n+    if line.starts_with(\"//! \") || line.starts_with(\"/// \") || line.starts_with(\"/*! \")\n+        || line.starts_with(\"/** \")\n     {\n         &line[4..]\n     } else if let CommentStyle::Custom(opener) = *style {\n@@ -434,14 +434,14 @@ fn left_trim_comment_line<'a>(line: &'a str, style: &CommentStyle) -> &'a str {\n         } else {\n             &line[opener.trim_right().len()..]\n         }\n-    } else if line.starts_with(\"/* \") || line.starts_with(\"// \") || line.starts_with(\"//!\") ||\n-        line.starts_with(\"///\") || line.starts_with(\"** \") ||\n-        line.starts_with(\"/*!\") ||\n-        (line.starts_with(\"/**\") && !line.starts_with(\"/**/\"))\n+    } else if line.starts_with(\"/* \") || line.starts_with(\"// \") || line.starts_with(\"//!\")\n+        || line.starts_with(\"///\") || line.starts_with(\"** \")\n+        || line.starts_with(\"/*!\")\n+        || (line.starts_with(\"/**\") && !line.starts_with(\"/**/\"))\n     {\n         &line[3..]\n-    } else if line.starts_with(\"/*\") || line.starts_with(\"* \") || line.starts_with(\"//\") ||\n-        line.starts_with(\"**\")\n+    } else if line.starts_with(\"/*\") || line.starts_with(\"* \") || line.starts_with(\"//\")\n+        || line.starts_with(\"**\")\n     {\n         &line[2..]\n     } else if line.starts_with('*') {\n@@ -771,9 +771,9 @@ impl<'a> Iterator for CommentCodeSlices<'a> {\n         let mut iter = CharClasses::new(subslice.char_indices());\n \n         for (kind, (i, c)) in &mut iter {\n-            let is_comment_connector = self.last_slice_kind == CodeCharKind::Normal &&\n-                &subslice[..2] == \"//\" &&\n-                [' ', '\\t'].contains(&c);\n+            let is_comment_connector = self.last_slice_kind == CodeCharKind::Normal\n+                && &subslice[..2] == \"//\"\n+                && [' ', '\\t'].contains(&c);\n \n             if is_comment_connector && first_whitespace.is_none() {\n                 first_whitespace = Some(i);\n@@ -913,8 +913,8 @@ fn remove_comment_header(comment: &str) -> &str {\n         &comment[3..]\n     } else if comment.starts_with(\"//\") {\n         &comment[2..]\n-    } else if (comment.starts_with(\"/**\") && !comment.starts_with(\"/**/\")) ||\n-        comment.starts_with(\"/*!\")\n+    } else if (comment.starts_with(\"/**\") && !comment.starts_with(\"/**/\"))\n+        || comment.starts_with(\"/*!\")\n     {\n         &comment[3..comment.len() - 2]\n     } else {"}, {"sha": "f76d13e5dc74cb2164798c007e92353f38ecd733", "filename": "src/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -620,6 +620,8 @@ create_config! {\n     multiline_match_arm_forces_block: bool, false,\n         \"Force multiline match arm bodies to be wrapped in a block\";\n     merge_derives: bool, true, \"Merge multiple `#[derive(...)]` into a single one\";\n+    binop_separator: SeparatorPlace, SeparatorPlace::Front,\n+        \"Where to put a binary operator when a binary expression goes multiline.\";\n }\n \n #[cfg(test)]"}, {"sha": "7f8a9ecfa792e09cf2ea142d4eaa6b5ac327a929", "filename": "src/expr.rs", "status": "modified", "additions": 134, "deletions": 82, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -101,6 +101,7 @@ pub fn format_expr(\n                 \"\",\n                 context,\n                 shape,\n+                context.config.binop_separator(),\n             )\n         }\n         ast::ExprKind::Unary(ref op, ref subexpr) => rewrite_unary_op(context, op, subexpr, shape),\n@@ -213,12 +214,26 @@ pub fn format_expr(\n         ast::ExprKind::AddrOf(mutability, ref expr) => {\n             rewrite_expr_addrof(context, mutability, expr, shape)\n         }\n-        ast::ExprKind::Cast(ref expr, ref ty) => {\n-            rewrite_pair(&**expr, &**ty, \"\", \" as \", \"\", context, shape)\n-        }\n-        ast::ExprKind::Type(ref expr, ref ty) => {\n-            rewrite_pair(&**expr, &**ty, \"\", \": \", \"\", context, shape)\n-        }\n+        ast::ExprKind::Cast(ref expr, ref ty) => rewrite_pair(\n+            &**expr,\n+            &**ty,\n+            \"\",\n+            \" as \",\n+            \"\",\n+            context,\n+            shape,\n+            SeparatorPlace::Front,\n+        ),\n+        ast::ExprKind::Type(ref expr, ref ty) => rewrite_pair(\n+            &**expr,\n+            &**ty,\n+            \"\",\n+            \": \",\n+            \"\",\n+            context,\n+            shape,\n+            SeparatorPlace::Back,\n+        ),\n         ast::ExprKind::Index(ref expr, ref index) => {\n             rewrite_index(&**expr, &**index, context, shape)\n         }\n@@ -228,7 +243,16 @@ pub fn format_expr(\n             } else {\n                 (\"[\", \"]\")\n             };\n-            rewrite_pair(&**expr, &**repeats, lbr, \"; \", rbr, context, shape)\n+            rewrite_pair(\n+                &**expr,\n+                &**repeats,\n+                lbr,\n+                \"; \",\n+                rbr,\n+                context,\n+                shape,\n+                SeparatorPlace::Back,\n+            )\n         }\n         ast::ExprKind::Range(ref lhs, ref rhs, limits) => {\n             let delim = match limits {\n@@ -257,7 +281,16 @@ pub fn format_expr(\n                     } else {\n                         delim.into()\n                     };\n-                    rewrite_pair(&*lhs, &*rhs, \"\", &sp_delim, \"\", context, shape)\n+                    rewrite_pair(\n+                        &*lhs,\n+                        &*rhs,\n+                        \"\",\n+                        &sp_delim,\n+                        \"\",\n+                        context,\n+                        shape,\n+                        SeparatorPlace::Front,\n+                    )\n                 }\n                 (None, Some(rhs)) => {\n                     let sp_delim = if context.config.spaces_around_ranges() {\n@@ -323,26 +356,29 @@ pub fn rewrite_pair<LHS, RHS>(\n     suffix: &str,\n     context: &RewriteContext,\n     shape: Shape,\n+    separator_place: SeparatorPlace,\n ) -> Option<String>\n where\n     LHS: Rewrite,\n     RHS: Rewrite,\n {\n-    let sep = if infix.ends_with(' ') { \" \" } else { \"\" };\n-    let infix = infix.trim_right();\n-    let lhs_overhead = shape.used_width() + prefix.len() + infix.len();\n+    let lhs_overhead = match separator_place {\n+        SeparatorPlace::Back => shape.used_width() + prefix.len() + infix.trim_right().len(),\n+        SeparatorPlace::Front => shape.used_width(),\n+    };\n     let lhs_shape = Shape {\n-        width: try_opt!(context.config.max_width().checked_sub(lhs_overhead)),\n+        width: context.budget(lhs_overhead),\n         ..shape\n     };\n     let lhs_result = try_opt!(\n         lhs.rewrite(context, lhs_shape)\n-            .map(|lhs_str| format!(\"{}{}{}\", prefix, lhs_str, infix))\n+            .map(|lhs_str| format!(\"{}{}\", prefix, lhs_str))\n     );\n \n     // Try to the both lhs and rhs on the same line.\n     let rhs_orig_result = shape\n-        .offset_left(last_line_width(&lhs_result) + suffix.len() + sep.len())\n+        .offset_left(last_line_width(&lhs_result) + infix.len())\n+        .and_then(|s| s.sub_width(suffix.len()))\n         .and_then(|rhs_shape| rhs.rewrite(context, rhs_shape));\n     if let Some(ref rhs_result) = rhs_orig_result {\n         // If the rhs looks like block expression, we allow it to stay on the same line\n@@ -353,33 +389,49 @@ where\n             .map(|first_line| first_line.ends_with('{'))\n             .unwrap_or(false);\n         if !rhs_result.contains('\\n') || allow_same_line {\n-            return Some(format!(\"{}{}{}{}\", lhs_result, sep, rhs_result, suffix));\n+            return Some(format!(\"{}{}{}{}\", lhs_result, infix, rhs_result, suffix));\n         }\n     }\n \n     // We have to use multiple lines.\n     // Re-evaluate the rhs because we have more space now:\n-    let rhs_shape = match context.config.control_style() {\n-        Style::Legacy => {\n-            try_opt!(shape.sub_width(suffix.len() + prefix.len())).visual_indent(prefix.len())\n-        }\n+    let mut rhs_shape = try_opt!(match context.config.control_style() {\n+        Style::Legacy => shape\n+            .sub_width(suffix.len() + prefix.len())\n+            .map(|s| s.visual_indent(prefix.len())),\n         Style::Rfc => {\n             // Try to calculate the initial constraint on the right hand side.\n             let rhs_overhead = shape.rhs_overhead(context.config);\n-            try_opt!(\n-                Shape::indented(shape.indent.block_indent(context.config), context.config)\n-                    .sub_width(rhs_overhead)\n-            )\n+            Shape::indented(shape.indent.block_indent(context.config), context.config)\n+                .sub_width(rhs_overhead)\n         }\n+    });\n+    let infix = match separator_place {\n+        SeparatorPlace::Back => infix.trim_right(),\n+        SeparatorPlace::Front => infix.trim_left(),\n     };\n+    if separator_place == SeparatorPlace::Front {\n+        rhs_shape = try_opt!(rhs_shape.offset_left(infix.len()));\n+    }\n     let rhs_result = try_opt!(rhs.rewrite(context, rhs_shape));\n-    Some(format!(\n-        \"{}\\n{}{}{}\",\n-        lhs_result,\n-        rhs_shape.indent.to_string(context.config),\n-        rhs_result,\n-        suffix\n-    ))\n+    match separator_place {\n+        SeparatorPlace::Back => Some(format!(\n+            \"{}{}\\n{}{}{}\",\n+            lhs_result,\n+            infix,\n+            rhs_shape.indent.to_string(context.config),\n+            rhs_result,\n+            suffix\n+        )),\n+        SeparatorPlace::Front => Some(format!(\n+            \"{}\\n{}{}{}{}\",\n+            lhs_result,\n+            rhs_shape.indent.to_string(context.config),\n+            infix,\n+            rhs_result,\n+            suffix\n+        )),\n+    }\n }\n \n pub fn rewrite_array<'a, I>(\n@@ -461,8 +513,8 @@ where\n         },\n     };\n     let ends_with_newline = tactic.ends_with_newline(context.config.array_layout());\n-    if context.config.array_horizontal_layout_threshold() > 0 &&\n-        items.len() > context.config.array_horizontal_layout_threshold()\n+    if context.config.array_horizontal_layout_threshold() > 0\n+        && items.len() > context.config.array_horizontal_layout_threshold()\n     {\n         tactic = DefinitiveListTactic::Mixed;\n     }\n@@ -485,8 +537,8 @@ where\n     };\n     let list_str = try_opt!(write_list(&items, &fmt));\n \n-    let result = if context.config.array_layout() == IndentStyle::Visual ||\n-        tactic == DefinitiveListTactic::Horizontal\n+    let result = if context.config.array_layout() == IndentStyle::Visual\n+        || tactic == DefinitiveListTactic::Horizontal\n     {\n         if context.config.spaces_within_square_brackets() && !list_str.is_empty() {\n             format!(\"[ {} ]\", list_str)\n@@ -619,10 +671,10 @@ fn rewrite_closure(\n         }\n \n         // Figure out if the block is necessary.\n-        let needs_block = block.rules != ast::BlockCheckMode::Default || block.stmts.len() > 1 ||\n-            context.inside_macro ||\n-            block_contains_comment(block, context.codemap) ||\n-            prefix.contains('\\n');\n+        let needs_block = block.rules != ast::BlockCheckMode::Default || block.stmts.len() > 1\n+            || context.inside_macro\n+            || block_contains_comment(block, context.codemap)\n+            || prefix.contains('\\n');\n \n         let no_return_type = if let ast::FunctionRetTy::Default(_) = fn_decl.output {\n             true\n@@ -704,8 +756,8 @@ fn rewrite_closure_block(\n     let block_threshold = context.config.closure_block_indent_threshold();\n     if block_threshold >= 0 {\n         if let Some(block_str) = block.rewrite(context, shape) {\n-            if block_str.matches('\\n').count() <= block_threshold as usize &&\n-                !need_block_indent(&block_str, shape)\n+            if block_str.matches('\\n').count() <= block_threshold as usize\n+                && !need_block_indent(&block_str, shape)\n             {\n                 if let Some(block_str) = block_str.rewrite(context, shape) {\n                     return Some(format!(\"{} {}\", prefix, block_str));\n@@ -728,8 +780,8 @@ fn and_one_line(x: Option<String>) -> Option<String> {\n fn nop_block_collapse(block_str: Option<String>, budget: usize) -> Option<String> {\n     debug!(\"nop_block_collapse {:?} {}\", block_str, budget);\n     block_str.map(|block_str| {\n-        if block_str.starts_with('{') && budget >= 2 &&\n-            (block_str[1..].find(|c: char| !c.is_whitespace()).unwrap() == block_str.len() - 2)\n+        if block_str.starts_with('{') && budget >= 2\n+            && (block_str[1..].find(|c: char| !c.is_whitespace()).unwrap() == block_str.len() - 2)\n         {\n             \"{}\".to_owned()\n         } else {\n@@ -753,8 +805,8 @@ fn rewrite_empty_block(\n     let user_str = user_str.trim();\n     if user_str.starts_with('{') && user_str.ends_with('}') {\n         let comment_str = user_str[1..user_str.len() - 1].trim();\n-        if block.stmts.is_empty() && !comment_str.contains('\\n') &&\n-            !comment_str.starts_with(\"//\") && comment_str.len() + 4 <= shape.width\n+        if block.stmts.is_empty() && !comment_str.contains('\\n') && !comment_str.starts_with(\"//\")\n+            && comment_str.len() + 4 <= shape.width\n         {\n             return Some(format!(\"{{ {} }}\", comment_str));\n         }\n@@ -1066,9 +1118,9 @@ impl<'a> ControlFlow<'a> {\n         let fixed_cost = self.keyword.len() + \"  {  } else {  }\".len();\n \n         if let ast::ExprKind::Block(ref else_node) = else_block.node {\n-            if !is_simple_block(self.block, context.codemap) ||\n-                !is_simple_block(else_node, context.codemap) ||\n-                pat_expr_str.contains('\\n')\n+            if !is_simple_block(self.block, context.codemap)\n+                || !is_simple_block(else_node, context.codemap)\n+                || pat_expr_str.contains('\\n')\n             {\n                 return None;\n             }\n@@ -1164,9 +1216,9 @@ impl<'a> ControlFlow<'a> {\n             .max_width()\n             .checked_sub(constr_shape.used_width() + offset + brace_overhead)\n             .unwrap_or(0);\n-        let force_newline_brace = context.config.control_style() == Style::Rfc &&\n-            (pat_expr_string.contains('\\n') || pat_expr_string.len() > one_line_budget) &&\n-            !last_line_extendable(&pat_expr_string);\n+        let force_newline_brace = context.config.control_style() == Style::Rfc\n+            && (pat_expr_string.contains('\\n') || pat_expr_string.len() > one_line_budget)\n+            && !last_line_extendable(&pat_expr_string);\n \n         // Try to format if-else on single line.\n         if self.allow_single_line && context.config.single_line_if_else_max_width() > 0 {\n@@ -1207,8 +1259,8 @@ impl<'a> ControlFlow<'a> {\n \n         let block_sep = if self.cond.is_none() && between_kwd_cond_comment.is_some() {\n             \"\"\n-        } else if context.config.control_brace_style() == ControlBraceStyle::AlwaysNextLine ||\n-            force_newline_brace\n+        } else if context.config.control_brace_style() == ControlBraceStyle::AlwaysNextLine\n+            || force_newline_brace\n         {\n             alt_block_sep\n         } else {\n@@ -1391,8 +1443,8 @@ fn block_contains_comment(block: &ast::Block, codemap: &CodeMap) -> bool {\n // FIXME: incorrectly returns false when comment is contained completely within\n // the expression.\n pub fn is_simple_block(block: &ast::Block, codemap: &CodeMap) -> bool {\n-    (block.stmts.len() == 1 && stmt_is_expr(&block.stmts[0]) &&\n-        !block_contains_comment(block, codemap))\n+    (block.stmts.len() == 1 && stmt_is_expr(&block.stmts[0])\n+        && !block_contains_comment(block, codemap))\n }\n \n /// Checks whether a block contains at most one statement or expression, and no comments.\n@@ -1687,17 +1739,17 @@ fn flatten_arm_body<'a>(context: &'a RewriteContext, body: &'a ast::Expr) -> (bo\n         {\n             if let ast::StmtKind::Expr(ref expr) = block.stmts[0].node {\n                 (\n-                    !context.config.multiline_match_arm_forces_block() &&\n-                        expr.can_be_overflowed(context, 1),\n+                    !context.config.multiline_match_arm_forces_block()\n+                        && expr.can_be_overflowed(context, 1),\n                     &**expr,\n                 )\n             } else {\n                 (false, &*body)\n             }\n         }\n         _ => (\n-            !context.config.multiline_match_arm_forces_block() &&\n-                body.can_be_overflowed(context, 1),\n+            !context.config.multiline_match_arm_forces_block()\n+                && body.can_be_overflowed(context, 1),\n             &*body,\n         ),\n     }\n@@ -1789,9 +1841,9 @@ fn rewrite_match_body(\n \n         match rewrite {\n             Some(ref body_str)\n-                if !forbid_same_line &&\n-                    (is_block ||\n-                        (!body_str.contains('\\n') && body_str.len() <= body_shape.width)) =>\n+                if !forbid_same_line\n+                    && (is_block\n+                        || (!body_str.contains('\\n') && body_str.len() <= body_shape.width)) =>\n             {\n                 return combine_orig_body(body_str);\n             }\n@@ -1937,8 +1989,8 @@ fn rewrite_string_lit(context: &RewriteContext, span: Span, shape: Shape) -> Opt\n         }\n     }\n \n-    if !context.config.force_format_strings() &&\n-        !string_requires_rewrite(context, span, &string_lit, shape)\n+    if !context.config.force_format_strings()\n+        && !string_requires_rewrite(context, span, &string_lit, shape)\n     {\n         return Some(string_lit);\n     }\n@@ -2318,8 +2370,8 @@ where\n             ast::ExprKind::Closure(..) => {\n                 // If the argument consists of multiple closures, we do not overflow\n                 // the last closure.\n-                if args.len() > 1 &&\n-                    args.iter()\n+                if args.len() > 1\n+                    && args.iter()\n                         .rev()\n                         .skip(1)\n                         .filter_map(|arg| arg.to_expr())\n@@ -2358,8 +2410,8 @@ where\n pub fn can_be_overflowed_expr(context: &RewriteContext, expr: &ast::Expr, args_len: usize) -> bool {\n     match expr.node {\n         ast::ExprKind::Match(..) => {\n-            (context.use_block_indent() && args_len == 1) ||\n-                (context.config.fn_call_style() == IndentStyle::Visual && args_len > 1)\n+            (context.use_block_indent() && args_len == 1)\n+                || (context.config.fn_call_style() == IndentStyle::Visual && args_len > 1)\n         }\n         ast::ExprKind::If(..) |\n         ast::ExprKind::IfLet(..) |\n@@ -2370,8 +2422,8 @@ pub fn can_be_overflowed_expr(context: &RewriteContext, expr: &ast::Expr, args_l\n             context.config.combine_control_expr() && context.use_block_indent() && args_len == 1\n         }\n         ast::ExprKind::Block(..) | ast::ExprKind::Closure(..) => {\n-            context.use_block_indent() ||\n-                context.config.fn_call_style() == IndentStyle::Visual && args_len > 1\n+            context.use_block_indent()\n+                || context.config.fn_call_style() == IndentStyle::Visual && args_len > 1\n         }\n         ast::ExprKind::Array(..) |\n         ast::ExprKind::Call(..) |\n@@ -2395,9 +2447,9 @@ pub fn wrap_args_with_parens(\n     shape: Shape,\n     nested_shape: Shape,\n ) -> String {\n-    if !context.use_block_indent() ||\n-        (context.inside_macro && !args_str.contains('\\n') &&\n-            args_str.len() + paren_overhead(context) <= shape.width) || is_extendable\n+    if !context.use_block_indent()\n+        || (context.inside_macro && !args_str.contains('\\n')\n+            && args_str.len() + paren_overhead(context) <= shape.width) || is_extendable\n     {\n         if context.config.spaces_within_parens() && !args_str.is_empty() {\n             format!(\"( {} )\", args_str)\n@@ -2440,8 +2492,8 @@ fn rewrite_paren(context: &RewriteContext, subexpr: &ast::Expr, shape: Shape) ->\n     let subexpr_str = try_opt!(subexpr.rewrite(context, sub_shape));\n     debug!(\"rewrite_paren, subexpr_str: `{:?}`\", subexpr_str);\n \n-    if subexpr_str.contains('\\n') ||\n-        first_line_width(&subexpr_str) + total_paren_overhead <= shape.width\n+    if subexpr_str.contains('\\n')\n+        || first_line_width(&subexpr_str) + total_paren_overhead <= shape.width\n     {\n         Some(paren_wrapper(&subexpr_str))\n     } else {\n@@ -2551,8 +2603,8 @@ fn rewrite_struct_lit<'a>(\n \n     let one_line_width = h_shape.map_or(0, |shape| shape.width);\n     let body_lo = context.codemap.span_after(span, \"{\");\n-    let fields_str = if struct_lit_can_be_aligned(fields, &base) &&\n-        context.config.struct_field_align_threshold() > 0\n+    let fields_str = if struct_lit_can_be_aligned(fields, &base)\n+        && context.config.struct_field_align_threshold() > 0\n     {\n         try_opt!(rewrite_with_alignment(\n             fields,\n@@ -2626,10 +2678,10 @@ pub fn wrap_struct_field(\n     nested_shape: Shape,\n     one_line_width: usize,\n ) -> String {\n-    if context.config.struct_lit_style() == IndentStyle::Block &&\n-        (fields_str.contains('\\n') ||\n-            context.config.struct_lit_multiline_style() == MultilineStyle::ForceMulti ||\n-            fields_str.len() > one_line_width)\n+    if context.config.struct_lit_style() == IndentStyle::Block\n+        && (fields_str.contains('\\n')\n+            || context.config.struct_lit_multiline_style() == MultilineStyle::ForceMulti\n+            || fields_str.len() > one_line_width)\n     {\n         format!(\n             \"\\n{}{}\\n{}\",\n@@ -2940,8 +2992,8 @@ fn prefer_next_line(orig_rhs: &str, next_line_rhs: &str) -> bool {\n         src.chars().filter(|&x| x == '\\n').count()\n     }\n \n-    !next_line_rhs.contains('\\n') ||\n-        count_line_breaks(orig_rhs) > count_line_breaks(next_line_rhs) + 1\n+    !next_line_rhs.contains('\\n')\n+        || count_line_breaks(orig_rhs) > count_line_breaks(next_line_rhs) + 1\n }\n \n fn rewrite_expr_addrof("}, {"sha": "948ffac073157cac8bbce8bcf4b4e5cd0d8cb422", "filename": "src/file_lines.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Ffile_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Ffile_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffile_lines.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -51,8 +51,8 @@ impl Range {\n         if self.is_empty() || other.is_empty() {\n             false\n         } else {\n-            (self.lo <= other.hi && other.hi <= self.hi) ||\n-                (other.lo <= self.hi && self.hi <= other.hi)\n+            (self.lo <= other.hi && other.hi <= self.hi)\n+                || (other.lo <= self.hi && self.hi <= other.hi)\n         }\n     }\n "}, {"sha": "39446d1a97b9709370a7b5fa1b1d9471215c8001", "filename": "src/imports.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -132,8 +132,8 @@ fn rewrite_view_path_prefix(\n     context: &RewriteContext,\n     shape: Shape,\n ) -> Option<String> {\n-    let path_str = if path.segments.last().unwrap().identifier.to_string() == \"self\" &&\n-        path.segments.len() > 1\n+    let path_str = if path.segments.last().unwrap().identifier.to_string() == \"self\"\n+        && path.segments.len() > 1\n     {\n         let path = &ast::Path {\n             span: path.span,\n@@ -503,8 +503,8 @@ fn rewrite_use_list(\n         IndentStyle::Visual => Shape::legacy(remaining_width, nested_indent),\n     };\n \n-    let ends_with_newline = context.config.imports_indent() == IndentStyle::Block &&\n-        tactic != DefinitiveListTactic::Horizontal;\n+    let ends_with_newline = context.config.imports_indent() == IndentStyle::Block\n+        && tactic != DefinitiveListTactic::Horizontal;\n \n     let fmt = ListFormatting {\n         tactic: tactic,"}, {"sha": "21ff353ff413c530597e5f97c6b8ad7e51647bb4", "filename": "src/items.rs", "status": "modified", "additions": 51, "deletions": 48, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -228,8 +228,8 @@ impl<'a> FmtVisitor<'a> {\n         let context = self.get_context();\n \n         let block_snippet = self.snippet(mk_sp(block.span.lo(), block.span.hi()));\n-        let has_body = !block_snippet[1..block_snippet.len() - 1].trim().is_empty() ||\n-            !context.config.fn_empty_single_line();\n+        let has_body = !block_snippet[1..block_snippet.len() - 1].trim().is_empty()\n+            || !context.config.fn_empty_single_line();\n         let mut newline_brace = newline_for_brace(self.config, &generics.where_clause, has_body);\n \n         let (mut result, force_newline_brace) = try_opt!(rewrite_fn_base(\n@@ -251,8 +251,8 @@ impl<'a> FmtVisitor<'a> {\n \n         if force_newline_brace {\n             newline_brace = true;\n-        } else if self.config.fn_brace_style() != BraceStyle::AlwaysNextLine &&\n-            !result.contains('\\n')\n+        } else if self.config.fn_brace_style() != BraceStyle::AlwaysNextLine\n+            && !result.contains('\\n')\n         {\n             newline_brace = false;\n         }\n@@ -313,8 +313,8 @@ impl<'a> FmtVisitor<'a> {\n \n         let codemap = self.get_context().codemap;\n \n-        if self.config.fn_empty_single_line() && is_empty_block(block, codemap) &&\n-            self.block_indent.width() + fn_str.len() + 2 <= self.config.max_width()\n+        if self.config.fn_empty_single_line() && is_empty_block(block, codemap)\n+            && self.block_indent.width() + fn_str.len() + 2 <= self.config.max_width()\n         {\n             return Some(format!(\"{}{{}}\", fn_str));\n         }\n@@ -503,9 +503,9 @@ impl<'a> FmtVisitor<'a> {\n             },\n         };\n \n-        let attrs_extendable = attrs_str.is_empty() ||\n-            (context.config.attributes_on_same_line_as_variant() &&\n-                is_attributes_extendable(&attrs_str));\n+        let attrs_extendable = attrs_str.is_empty()\n+            || (context.config.attributes_on_same_line_as_variant()\n+                && is_attributes_extendable(&attrs_str));\n         combine_strs_with_missing_comments(\n             &context,\n             &attrs_str,\n@@ -650,9 +650,9 @@ fn is_impl_single_line(\n     let open_pos = try_opt!(snippet.find_uncommented(\"{\")) + 1;\n \n     Some(\n-        context.config.impl_empty_single_line() && items.is_empty() && !result.contains('\\n') &&\n-            result.len() + where_clause_str.len() <= context.config.max_width() &&\n-            !contains_comment(&snippet[open_pos..]),\n+        context.config.impl_empty_single_line() && items.is_empty() && !result.contains('\\n')\n+            && result.len() + where_clause_str.len() <= context.config.max_width()\n+            && !contains_comment(&snippet[open_pos..]),\n     )\n }\n \n@@ -895,8 +895,8 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         ));\n         // If the trait, generics, and trait bound cannot fit on the same line,\n         // put the trait bounds on an indented new line\n-        if offset.width() + last_line_width(&result) + trait_bound_str.len() >\n-            context.config.comment_width()\n+        if offset.width() + last_line_width(&result) + trait_bound_str.len()\n+            > context.config.comment_width()\n         {\n             result.push('\\n');\n             let trait_indent = offset.block_only().block_indent(context.config);\n@@ -906,11 +906,11 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n \n         let has_body = !trait_items.is_empty();\n \n-        let where_density = if (context.config.where_density() == Density::Compressed &&\n-            (!result.contains('\\n') || context.config.fn_args_layout() == IndentStyle::Block)) ||\n-            (context.config.fn_args_layout() == IndentStyle::Block && result.is_empty()) ||\n-            (context.config.where_density() == Density::CompressedIfEmpty && !has_body &&\n-                !result.contains('\\n'))\n+        let where_density = if (context.config.where_density() == Density::Compressed\n+            && (!result.contains('\\n') || context.config.fn_args_layout() == IndentStyle::Block))\n+            || (context.config.fn_args_layout() == IndentStyle::Block && result.is_empty())\n+            || (context.config.where_density() == Density::CompressedIfEmpty && !has_body\n+                && !result.contains('\\n'))\n         {\n             Density::Compressed\n         } else {\n@@ -937,9 +937,9 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         ));\n         // If the where clause cannot fit on the same line,\n         // put the where clause on a new line\n-        if !where_clause_str.contains('\\n') &&\n-            last_line_width(&result) + where_clause_str.len() + offset.width() >\n-                context.config.comment_width()\n+        if !where_clause_str.contains('\\n')\n+            && last_line_width(&result) + where_clause_str.len() + offset.width()\n+                > context.config.comment_width()\n         {\n             result.push('\\n');\n             let width = offset.block_indent + context.config.tab_spaces() - 1;\n@@ -980,8 +980,8 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n                 result.push_str(&offset.to_string(context.config));\n             }\n             BraceStyle::PreferSameLine => result.push(' '),\n-            BraceStyle::SameLineWhere => if !where_clause_str.is_empty() &&\n-                (!trait_items.is_empty() || result.contains('\\n'))\n+            BraceStyle::SameLineWhere => if !where_clause_str.is_empty()\n+                && (!trait_items.is_empty() || result.contains('\\n'))\n             {\n                 result.push('\\n');\n                 result.push_str(&offset.to_string(context.config));\n@@ -1061,9 +1061,9 @@ pub fn format_struct_struct(\n         None => {\n             // 3 = ` {}`, 2 = ` {`.\n             let overhead = if fields.is_empty() { 3 } else { 2 };\n-            if (context.config.item_brace_style() == BraceStyle::AlwaysNextLine &&\n-                !fields.is_empty()) ||\n-                context.config.max_width() < overhead + result.len()\n+            if (context.config.item_brace_style() == BraceStyle::AlwaysNextLine\n+                && !fields.is_empty())\n+                || context.config.max_width() < overhead + result.len()\n             {\n                 format!(\"\\n{}{{\", offset.block_only().to_string(context.config))\n             } else {\n@@ -1074,8 +1074,8 @@ pub fn format_struct_struct(\n     // 1 = `}`\n     let overhead = if fields.is_empty() { 1 } else { 0 };\n     let total_width = result.len() + generics_str.len() + overhead;\n-    if !generics_str.is_empty() && !generics_str.contains('\\n') &&\n-        total_width > context.config.max_width()\n+    if !generics_str.is_empty() && !generics_str.contains('\\n')\n+        && total_width > context.config.max_width()\n     {\n         result.push('\\n');\n         result.push_str(&offset.to_string(context.config));\n@@ -1224,10 +1224,10 @@ fn format_tuple_struct(\n         result.push_str(&body);\n     }\n \n-    if !where_clause_str.is_empty() && !where_clause_str.contains('\\n') &&\n-        (result.contains('\\n') ||\n-            offset.block_indent + result.len() + where_clause_str.len() + 1 >\n-                context.config.max_width())\n+    if !where_clause_str.is_empty() && !where_clause_str.contains('\\n')\n+        && (result.contains('\\n')\n+            || offset.block_indent + result.len() + where_clause_str.len() + 1\n+                > context.config.max_width())\n     {\n         // We need to put the where clause on a new line, but we didn't\n         // know that earlier, so the where clause will not be indented properly.\n@@ -1368,8 +1368,9 @@ pub fn rewrite_struct_field(\n     let prefix = try_opt!(rewrite_struct_field_prefix(context, field));\n \n     let attrs_str = try_opt!(field.attrs.rewrite(context, shape));\n-    let attrs_extendable = attrs_str.is_empty() ||\n-        (context.config.attributes_on_same_line_as_field() && is_attributes_extendable(&attrs_str));\n+    let attrs_extendable = attrs_str.is_empty()\n+        || (context.config.attributes_on_same_line_as_field()\n+            && is_attributes_extendable(&attrs_str));\n     let missing_span = if field.attrs.is_empty() {\n         mk_sp(field.span.lo(), field.span.lo())\n     } else {\n@@ -2154,8 +2155,9 @@ fn rewrite_args(\n         arg_items.extend(more_items);\n     }\n \n-    let fits_in_one_line = !generics_str_contains_newline &&\n-        (arg_items.is_empty() || arg_items.len() == 1 && arg_item_strs[0].len() <= one_line_budget);\n+    let fits_in_one_line = !generics_str_contains_newline\n+        && (arg_items.is_empty()\n+            || arg_items.len() == 1 && arg_item_strs[0].len() <= one_line_budget);\n \n     for (item, arg) in arg_items.iter_mut().zip(arg_item_strs) {\n         item.item = Some(arg);\n@@ -2419,8 +2421,8 @@ pub fn wrap_generics_with_angle_brackets(\n     list_str: &str,\n     list_offset: Indent,\n ) -> String {\n-    if context.config.generics_indent() == IndentStyle::Block &&\n-        (list_str.contains('\\n') || list_str.ends_with(','))\n+    if context.config.generics_indent() == IndentStyle::Block\n+        && (list_str.contains('\\n') || list_str.ends_with(','))\n     {\n         format!(\n             \"<\\n{}{}\\n{}>\",\n@@ -2528,9 +2530,9 @@ fn rewrite_where_clause_rfc_style(\n     let newline_after_where = comment_separator(&comment_after, clause_shape);\n \n     // 6 = `where `\n-    let clause_sep = if where_clause_option.compress_where && comment_before.is_empty() &&\n-        comment_after.is_empty() && !preds_str.contains('\\n') &&\n-        6 + preds_str.len() <= shape.width\n+    let clause_sep = if where_clause_option.compress_where && comment_before.is_empty()\n+        && comment_after.is_empty() && !preds_str.contains('\\n')\n+        && 6 + preds_str.len() <= shape.width\n     {\n         String::from(\" \")\n     } else {\n@@ -2643,8 +2645,8 @@ fn rewrite_where_clause(\n     } else {\n         terminator.len()\n     };\n-    if density == Density::Tall || preds_str.contains('\\n') ||\n-        shape.indent.width() + \" where \".len() + preds_str.len() + end_length > shape.width\n+    if density == Density::Tall || preds_str.contains('\\n')\n+        || shape.indent.width() + \" where \".len() + preds_str.len() + end_length > shape.width\n     {\n         Some(format!(\n             \"\\n{}where {}\",\n@@ -2715,11 +2717,12 @@ fn format_generics(\n             option,\n         ));\n         result.push_str(&where_clause_str);\n-        force_same_line_brace || brace_style == BraceStyle::PreferSameLine ||\n-            (generics.where_clause.predicates.is_empty() && trimmed_last_line_width(&result) == 1)\n+        force_same_line_brace || brace_style == BraceStyle::PreferSameLine\n+            || (generics.where_clause.predicates.is_empty()\n+                && trimmed_last_line_width(&result) == 1)\n     } else {\n-        force_same_line_brace || trimmed_last_line_width(&result) == 1 ||\n-            brace_style != BraceStyle::AlwaysNextLine\n+        force_same_line_brace || trimmed_last_line_width(&result) == 1\n+            || brace_style != BraceStyle::AlwaysNextLine\n     };\n     let total_used_width = last_line_used_width(&result, used_width);\n     let remaining_budget = context.budget(total_used_width);"}, {"sha": "d5ea44393ca221f17a7ad8af10e8d5f8c2d3675c", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -786,8 +786,8 @@ fn format_lines(text: &mut StringBuffer, name: &str, config: &Config, report: &m\n                 }\n \n                 // Check for any line width errors we couldn't correct.\n-                let report_error_on_line_overflow = config.error_on_line_overflow() &&\n-                    (config.error_on_line_overflow_comments() || !is_comment);\n+                let report_error_on_line_overflow = config.error_on_line_overflow()\n+                    && (config.error_on_line_overflow_comments() || !is_comment);\n                 if report_error_on_line_overflow && line_len > config.max_width() {\n                     errors.push(FormattingError {\n                         line: cur_line,"}, {"sha": "543e5296432e4fff1fe190a7aee846bc32baed22", "filename": "src/lists.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -118,27 +118,27 @@ impl ListItem {\n     }\n \n     pub fn is_different_group(&self) -> bool {\n-        self.inner_as_ref().contains('\\n') || self.pre_comment.is_some() ||\n-            self.post_comment\n+        self.inner_as_ref().contains('\\n') || self.pre_comment.is_some()\n+            || self.post_comment\n                 .as_ref()\n                 .map_or(false, |s| s.contains('\\n'))\n     }\n \n     pub fn is_multiline(&self) -> bool {\n-        self.inner_as_ref().contains('\\n') ||\n-            self.pre_comment\n+        self.inner_as_ref().contains('\\n')\n+            || self.pre_comment\n                 .as_ref()\n-                .map_or(false, |s| s.contains('\\n')) ||\n-            self.post_comment\n+                .map_or(false, |s| s.contains('\\n'))\n+            || self.post_comment\n                 .as_ref()\n                 .map_or(false, |s| s.contains('\\n'))\n     }\n \n     pub fn has_comment(&self) -> bool {\n         self.pre_comment\n             .as_ref()\n-            .map_or(false, |comment| comment.starts_with(\"//\")) ||\n-            self.post_comment\n+            .map_or(false, |comment| comment.starts_with(\"//\"))\n+            || self.post_comment\n                 .as_ref()\n                 .map_or(false, |comment| comment.starts_with(\"//\"))\n     }\n@@ -243,8 +243,8 @@ where\n     let total_sep_len = sep.len() * sep_count.checked_sub(1).unwrap_or(0);\n     let real_total = total_width + total_sep_len;\n \n-    if real_total <= limit && !pre_line_comments &&\n-        !items.into_iter().any(|item| item.as_ref().is_multiline())\n+    if real_total <= limit && !pre_line_comments\n+        && !items.into_iter().any(|item| item.as_ref().is_multiline())\n     {\n         DefinitiveListTactic::Horizontal\n     } else {\n@@ -346,8 +346,8 @@ where\n \n             if tactic == DefinitiveListTactic::Vertical {\n                 // We cannot keep pre-comments on the same line if the comment if normalized.\n-                let keep_comment = if formatting.config.normalize_comments() ||\n-                    item.pre_comment_style == ListItemCommentStyle::DifferentLine\n+                let keep_comment = if formatting.config.normalize_comments()\n+                    || item.pre_comment_style == ListItemCommentStyle::DifferentLine\n                 {\n                     false\n                 } else {\n@@ -416,9 +416,9 @@ where\n                 let comment_shape = Shape::legacy(width, offset);\n \n                 // Use block-style only for the last item or multiline comments.\n-                let block_style = !formatting.ends_with_newline && last ||\n-                    comment.trim().contains('\\n') ||\n-                    comment.trim().len() > width;\n+                let block_style = !formatting.ends_with_newline && last\n+                    || comment.trim().contains('\\n')\n+                    || comment.trim().len() > width;\n \n                 rewrite_comment(comment, block_style, comment_shape, formatting.config)\n             };\n@@ -428,8 +428,8 @@ where\n             if !formatted_comment.starts_with('\\n') {\n                 let mut comment_alignment =\n                     post_comment_alignment(item_max_width, inner_item.len());\n-                if first_line_width(&formatted_comment) + last_line_width(&result) +\n-                    comment_alignment + 1 > formatting.config.max_width()\n+                if first_line_width(&formatted_comment) + last_line_width(&result)\n+                    + comment_alignment + 1 > formatting.config.max_width()\n                 {\n                     item_max_width = None;\n                     formatted_comment = try_opt!(rewrite_post_comment(&mut item_max_width));\n@@ -452,8 +452,8 @@ where\n             item_max_width = None;\n         }\n \n-        if formatting.preserve_newline && !last && tactic == DefinitiveListTactic::Vertical &&\n-            item.new_lines\n+        if formatting.preserve_newline && !last && tactic == DefinitiveListTactic::Vertical\n+            && item.new_lines\n         {\n             item_max_width = None;\n             result.push('\\n');\n@@ -478,9 +478,9 @@ where\n     for item in items.clone().into_iter().skip(i) {\n         let item = item.as_ref();\n         let inner_item_width = item.inner_as_ref().len();\n-        if !first &&\n-            (item.is_different_group() || !item.post_comment.is_some() ||\n-                inner_item_width + overhead > max_budget)\n+        if !first\n+            && (item.is_different_group() || !item.post_comment.is_some()\n+                || inner_item_width + overhead > max_budget)\n         {\n             return max_width;\n         }\n@@ -714,9 +714,9 @@ where\n }\n \n fn total_item_width(item: &ListItem) -> usize {\n-    comment_len(item.pre_comment.as_ref().map(|x| &(*x)[..])) +\n-        comment_len(item.post_comment.as_ref().map(|x| &(*x)[..])) +\n-        item.item.as_ref().map_or(0, |str| str.len())\n+    comment_len(item.pre_comment.as_ref().map(|x| &(*x)[..]))\n+        + comment_len(item.post_comment.as_ref().map(|x| &(*x)[..]))\n+        + item.item.as_ref().map_or(0, |str| str.len())\n }\n \n fn comment_len(comment: Option<&str>) -> usize {\n@@ -800,8 +800,8 @@ pub fn struct_lit_formatting<'a>(\n     context: &'a RewriteContext,\n     force_no_trailing_comma: bool,\n ) -> ListFormatting<'a> {\n-    let ends_with_newline = context.config.struct_lit_style() != IndentStyle::Visual &&\n-        tactic == DefinitiveListTactic::Vertical;\n+    let ends_with_newline = context.config.struct_lit_style() != IndentStyle::Visual\n+        && tactic == DefinitiveListTactic::Vertical;\n     ListFormatting {\n         tactic: tactic,\n         separator: \",\","}, {"sha": "1e1bffaf995dfa6cbddbdf741a593dbaf28da6d7", "filename": "src/macros.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -230,8 +230,8 @@ pub fn rewrite_macro(\n                 let nested_shape = mac_shape.block_indent(context.config.tab_spaces());\n                 let lhs = try_opt!(arg_vec[0].rewrite(context, nested_shape));\n                 let rhs = try_opt!(arg_vec[1].rewrite(context, nested_shape));\n-                if !lhs.contains('\\n') && !rhs.contains('\\n') &&\n-                    lhs.len() + rhs.len() + total_overhead <= shape.width\n+                if !lhs.contains('\\n') && !rhs.contains('\\n')\n+                    && lhs.len() + rhs.len() + total_overhead <= shape.width\n                 {\n                     Some(format!(\"{}{}{}; {}{}\", macro_name, lbr, lhs, rhs, rbr))\n                 } else {\n@@ -373,13 +373,13 @@ fn indent_macro_snippet(\n     );\n \n     Some(\n-        String::from(first_line) + \"\\n\" +\n-            &trimmed_lines\n+        String::from(first_line) + \"\\n\"\n+            + &trimmed_lines\n                 .iter()\n                 .map(|&(line, prefix_space_width)| match prefix_space_width {\n                     Some(original_indent_width) => {\n-                        let new_indent_width = indent.width() +\n-                            original_indent_width\n+                        let new_indent_width = indent.width()\n+                            + original_indent_width\n                                 .checked_sub(min_prefix_space_width)\n                                 .unwrap_or(0);\n                         let new_indent = Indent::from_width(context.config, new_indent_width);"}, {"sha": "c6f3e66669a228d21055d485a1bd17eef7e8a58e", "filename": "src/missed_spans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -145,8 +145,8 @@ impl<'a> FmtVisitor<'a> {\n \n                 let subslice_num_lines = subslice.chars().filter(|c| *c == '\\n').count();\n \n-                if rewrite_next_comment &&\n-                    !self.config.file_lines().intersects_range(\n+                if rewrite_next_comment\n+                    && !self.config.file_lines().intersects_range(\n                         file_name,\n                         cur_line,\n                         cur_line + subslice_num_lines,"}, {"sha": "ab61df22b682f23ce52c7a689d5575458fa0095f", "filename": "src/patterns.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -18,7 +18,7 @@ use comment::FindUncommented;\n use expr::{can_be_overflowed_expr, rewrite_call_inner, rewrite_pair, rewrite_unary_prefix,\n            wrap_struct_field};\n use lists::{itemize_list, shape_for_tactic, struct_lit_formatting, struct_lit_shape,\n-            struct_lit_tactic, write_list, DefinitiveListTactic, SeparatorTactic};\n+            struct_lit_tactic, write_list, DefinitiveListTactic, SeparatorPlace, SeparatorTactic};\n use rewrite::{Rewrite, RewriteContext};\n use types::{rewrite_path, PathContext};\n use utils::{format_mutability, mk_sp, wrap_str};\n@@ -59,8 +59,26 @@ impl Rewrite for Pat {\n                 None\n             },\n             PatKind::Range(ref lhs, ref rhs, ref end_kind) => match *end_kind {\n-                RangeEnd::Included => rewrite_pair(&**lhs, &**rhs, \"\", \"...\", \"\", context, shape),\n-                RangeEnd::Excluded => rewrite_pair(&**lhs, &**rhs, \"\", \"..\", \"\", context, shape),\n+                RangeEnd::Included => rewrite_pair(\n+                    &**lhs,\n+                    &**rhs,\n+                    \"\",\n+                    \"...\",\n+                    \"\",\n+                    context,\n+                    shape,\n+                    SeparatorPlace::Front,\n+                ),\n+                RangeEnd::Excluded => rewrite_pair(\n+                    &**lhs,\n+                    &**rhs,\n+                    \"\",\n+                    \"..\",\n+                    \"\",\n+                    context,\n+                    shape,\n+                    SeparatorPlace::Front,\n+                ),\n             },\n             PatKind::Ref(ref pat, mutability) => {\n                 let prefix = format!(\"&{}\", format_mutability(mutability));"}, {"sha": "84271f20082656cae349905fe4e2f17f8781bdc8", "filename": "src/string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -82,8 +82,8 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n                     // If we can't break at whitespace or punctuation, grow the string instead.\n                     if cur_end < cur_start + MIN_STRING {\n                         cur_end = cur_start + max_chars;\n-                        while !(punctuation.contains(graphemes[cur_end - 1]) ||\n-                            graphemes[cur_end - 1].trim().is_empty())\n+                        while !(punctuation.contains(graphemes[cur_end - 1])\n+                            || graphemes[cur_end - 1].trim().is_empty())\n                         {\n                             if cur_end >= graphemes.len() {\n                                 let line = &graphemes[cur_start..].join(\"\");"}, {"sha": "cf034e7dff69516538c6d29a384efc7c07638d31", "filename": "src/summary.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fsummary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fsummary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsummary.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -44,8 +44,8 @@ impl Summary {\n     }\n \n     pub fn has_no_errors(&self) -> bool {\n-        !(self.has_operational_errors || self.has_parsing_errors || self.has_formatting_errors ||\n-            self.has_diff)\n+        !(self.has_operational_errors || self.has_parsing_errors || self.has_formatting_errors\n+            || self.has_diff)\n     }\n \n     pub fn add(&mut self, other: Summary) {"}, {"sha": "265ed723355bd0c405ad5e742de406d5ba67abe2", "filename": "src/types.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -208,8 +208,8 @@ fn rewrite_segment(\n     let params = if let Some(ref params) = segment.parameters {\n         match **params {\n             ast::PathParameters::AngleBracketed(ref data)\n-                if !data.lifetimes.is_empty() || !data.types.is_empty() ||\n-                    !data.bindings.is_empty() =>\n+                if !data.lifetimes.is_empty() || !data.types.is_empty()\n+                    || !data.bindings.is_empty() =>\n             {\n                 let param_list = data.lifetimes\n                     .iter()\n@@ -738,7 +738,16 @@ impl Rewrite for ast::Ty {\n                 let use_spaces = context.config.spaces_within_square_brackets();\n                 let lbr = if use_spaces { \"[ \" } else { \"[\" };\n                 let rbr = if use_spaces { \" ]\" } else { \"]\" };\n-                rewrite_pair(&**ty, &**repeats, lbr, \"; \", rbr, context, shape)\n+                rewrite_pair(\n+                    &**ty,\n+                    &**repeats,\n+                    lbr,\n+                    \"; \",\n+                    rbr,\n+                    context,\n+                    shape,\n+                    SeparatorPlace::Back,\n+                )\n             }\n             ast::TyKind::Infer => if shape.width >= 1 {\n                 Some(\"_\".to_owned())"}, {"sha": "d8c18034830eacaf08822bfc4acfbf62471fb18a", "filename": "src/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -165,8 +165,8 @@ pub fn trimmed_last_line_width(s: &str) -> usize {\n #[inline]\n pub fn last_line_extendable(s: &str) -> bool {\n     s.lines().last().map_or(false, |s| {\n-        s.ends_with(\"\\\"#\") ||\n-            s.trim()\n+        s.ends_with(\"\\\"#\")\n+            || s.trim()\n                 .chars()\n                 .all(|c| c == ')' || c == ']' || c == '}' || c == '?')\n     })"}, {"sha": "a120eb868e5d45fc043ec12a11e2a9ea28b26a87", "filename": "src/vertical.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fvertical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fvertical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvertical.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -53,8 +53,8 @@ impl AlignedItem for ast::StructField {\n         } else {\n             mk_sp(self.attrs.last().unwrap().span.hi(), self.span.lo())\n         };\n-        let attrs_extendable = context.config.attributes_on_same_line_as_field() &&\n-            is_attributes_extendable(&attrs_str);\n+        let attrs_extendable = context.config.attributes_on_same_line_as_field()\n+            && is_attributes_extendable(&attrs_str);\n         rewrite_struct_field_prefix(context, self).and_then(|field_str| {\n             combine_strs_with_missing_comments(\n                 context,\n@@ -184,8 +184,8 @@ pub fn rewrite_with_alignment<T: AlignedItem>(\n             one_line_width,\n         ));\n         Some(\n-            result + spaces + \"\\n\" +\n-                &shape\n+            result + spaces + \"\\n\"\n+                + &shape\n                     .indent\n                     .block_indent(context.config)\n                     .to_string(context.config) + &rest_str,"}, {"sha": "beb9ce108d2cd53b3e3a9ad76e791bb7ff2d955f", "filename": "src/visitor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -722,8 +722,8 @@ impl<'a> FmtVisitor<'a> {\n         // Decide whether this is an inline mod or an external mod.\n         let local_file_name = self.codemap.span_to_filename(s);\n         let inner_span = source!(self, m.inner);\n-        let is_internal = !(inner_span.lo().0 == 0 && inner_span.hi().0 == 0) &&\n-            local_file_name == self.codemap.span_to_filename(inner_span);\n+        let is_internal = !(inner_span.lo().0 == 0 && inner_span.hi().0 == 0)\n+            && local_file_name == self.codemap.span_to_filename(inner_span);\n \n         self.buffer.push_str(&*utils::format_visibility(vis));\n         self.buffer.push_str(\"mod \");\n@@ -883,8 +883,8 @@ impl<'a> Rewrite for [ast::Attribute] {\n                 // This particular horror show is to preserve line breaks in between doc\n                 // comments. An alternative would be to force such line breaks to start\n                 // with the usual doc comment token.\n-                let (multi_line_before, multi_line_after) = if a.is_sugared_doc ||\n-                    is_prev_sugared_doc\n+                let (multi_line_before, multi_line_after) = if a.is_sugared_doc\n+                    || is_prev_sugared_doc\n                 {\n                     // Look at before and after comment and see if there are any empty lines.\n                     let comment_begin = comment.chars().position(|c| c == '/');"}, {"sha": "8fbe99a1adcee26af75aef21f62790ba9f9e51d6", "filename": "tests/target/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/tests%2Ftarget%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/tests%2Ftarget%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fclosure.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -94,8 +94,8 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n     pub fn eq_expr(&self, left: &Expr, right: &Expr) -> bool {\n         match (&left.node, &right.node) {\n             (&ExprBinary(l_op, ref ll, ref lr), &ExprBinary(r_op, ref rl, ref rr)) => {\n-                l_op.node == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr) ||\n-                    swap_binop(l_op.node, ll, lr).map_or(false, |(l_op, ll, lr)| {\n+                l_op.node == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+                    || swap_binop(l_op.node, ll, lr).map_or(false, |(l_op, ll, lr)| {\n                         l_op == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n                     })\n             }"}, {"sha": "37da727b2a1d4fd4016d794bb74423c398bf9ec0", "filename": "tests/target/configs-control_style-rfc.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/tests%2Ftarget%2Fconfigs-control_style-rfc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/tests%2Ftarget%2Fconfigs-control_style-rfc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-control_style-rfc.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -4,10 +4,9 @@\n fn main() {\n     loop {\n         if foo {\n-            if ((right_paddle_speed < 0.) &&\n-                (right_paddle.position().y - paddle_size.y / 2. > 5.)) ||\n-                ((right_paddle_speed > 0.) &&\n-                    (right_paddle.position().y + paddle_size.y / 2. < game_height as f32 - 5.))\n+            if ((right_paddle_speed < 0.) && (right_paddle.position().y - paddle_size.y / 2. > 5.))\n+                || ((right_paddle_speed > 0.)\n+                    && (right_paddle.position().y + paddle_size.y / 2. < game_height as f32 - 5.))\n             {\n                 foo\n             }\n@@ -26,10 +25,10 @@ fn issue1656() {\n         {\n             match rewrite {\n                 Some(ref body_str)\n-                    if (!body_str.contains('\\n') && body_str.len() <= arm_shape.width) ||\n-                        !context.config.wrap_match_arms() ||\n-                        (extend && first_line_width(body_str) <= arm_shape.width) ||\n-                        is_block =>\n+                    if (!body_str.contains('\\n') && body_str.len() <= arm_shape.width)\n+                        || !context.config.wrap_match_arms()\n+                        || (extend && first_line_width(body_str) <= arm_shape.width)\n+                        || is_block =>\n                 {\n                     return None;\n                 }"}, {"sha": "6141ca8120e1f73d3c002cced1c65f1a2b231626", "filename": "tests/target/expr-block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/tests%2Ftarget%2Fexpr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/tests%2Ftarget%2Fexpr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr-block.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -197,8 +197,8 @@ fn issue_1450() {\n }\n \n fn foo() {\n-    if real_total <= limit && !pre_line_comments &&\n-        !items.into_iter().any(|item| item.as_ref().is_multiline())\n+    if real_total <= limit && !pre_line_comments\n+        && !items.into_iter().any(|item| item.as_ref().is_multiline())\n     {\n         DefinitiveListTactic::Horizontal\n     }"}, {"sha": "2e7463eef6beea671c8a5c44c21ddf4f1ff84607", "filename": "tests/target/expr.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/tests%2Ftarget%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/tests%2Ftarget%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -13,17 +13,17 @@ fn foo() -> bool {\n     let is_internalxxxx =\n         self.codemap.span_to_filename(s) == self.codemap.span_to_filename(m.inner);\n \n-    let some_val = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa * bbbb /\n-        (bbbbbb - function_call(x, *very_long_pointer, y)) + 1000;\n+    let some_val = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa * bbbb\n+        / (bbbbbb - function_call(x, *very_long_pointer, y)) + 1000;\n \n     some_ridiculously_loooooooooooooooooooooong_function(\n         10000 * 30000000000 + 40000 / 1002200000000 - 50000 * sqrt(-1),\n         trivial_value,\n     );\n-    (((((((((aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\n-        a +\n-        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\n-        aaaaa)))))))));\n+    (((((((((aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+        + a\n+        + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+        + aaaaa)))))))));\n \n     {\n         for _ in 0..10 {}\n@@ -78,8 +78,8 @@ fn foo() -> bool {\n         something_else();\n     } else {\n         // Check subformatting\n-        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\n-            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+            + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n     }\n }\n \n@@ -249,18 +249,18 @@ fn arrays() {\n }\n \n fn returns() {\n-    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &&\n-        return;\n+    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+        && return;\n \n-    return aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\n-        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;\n+    return aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+        + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;\n }\n \n fn addrof() {\n-    &mut (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\n-        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);\n-    &(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\n-        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);\n+    &mut (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+        + bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);\n+    &(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+        + bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);\n }\n \n fn casts() {"}, {"sha": "e1d506787af80aff6c4042bce259c1259e61ff33", "filename": "tests/target/hard-tabs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/tests%2Ftarget%2Fhard-tabs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/tests%2Ftarget%2Fhard-tabs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fhard-tabs.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -32,8 +32,8 @@ fn main() {\n \t} else if different_cond() {\n \t\tsomething_else();\n \t} else {\n-\t\taaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\n-\t\t\taaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+\t\taaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+\t\t\t+ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n \t}\n \n \tunsafe /* very looooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong"}, {"sha": "b10afb5cb6cd50971830885ba0ed6736601ec770", "filename": "tests/target/issue-1239.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/tests%2Ftarget%2Fissue-1239.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/tests%2Ftarget%2Fissue-1239.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-1239.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -1,11 +1,10 @@\n fn foo() {\n-    let with_alignment = if condition__uses_alignment_for_first_if__0 ||\n-        condition__uses_alignment_for_first_if__1 ||\n-        condition__uses_alignment_for_first_if__2\n+    let with_alignment = if condition__uses_alignment_for_first_if__0\n+        || condition__uses_alignment_for_first_if__1\n+        || condition__uses_alignment_for_first_if__2\n     {\n-    } else if condition__no_alignment_for_later_else__0 ||\n-        condition__no_alignment_for_later_else__1 ||\n-        condition__no_alignment_for_later_else__2\n+    } else if condition__no_alignment_for_later_else__0 || condition__no_alignment_for_later_else__1\n+        || condition__no_alignment_for_later_else__2\n     {\n     };\n }"}, {"sha": "e42b1e3428b727523c7ec793e48eb41815c80413", "filename": "tests/target/match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=144da0dfddd2c5ba4ea9dbb33443319d2e88e8fa", "patch": "@@ -324,9 +324,9 @@ fn guards() {\n         aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n             if foooooooooooooo && barrrrrrrrrrrr => {}\n         aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n-            if fooooooooooooooooooooo &&\n-                (bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb ||\n-                    cccccccccccccccccccccccccccccccccccccccc) => {}\n+            if fooooooooooooooooooooo\n+                && (bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n+                    || cccccccccccccccccccccccccccccccccccccccc) => {}\n     }\n }\n "}]}