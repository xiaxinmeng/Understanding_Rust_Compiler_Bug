{"sha": "f8be0737ea47a41097bba940ce5f9f9527fb2087", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4YmUwNzM3ZWE0N2E0MTA5N2JiYTk0MGNlNWY5Zjk1MjdmYjIwODc=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-19T04:04:48Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-19T04:04:48Z"}, "message": "progress", "tree": {"sha": "3f66265b8073e38cabaeb8137259f4b616e3ac1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f66265b8073e38cabaeb8137259f4b616e3ac1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8be0737ea47a41097bba940ce5f9f9527fb2087", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8be0737ea47a41097bba940ce5f9f9527fb2087", "html_url": "https://github.com/rust-lang/rust/commit/f8be0737ea47a41097bba940ce5f9f9527fb2087", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8be0737ea47a41097bba940ce5f9f9527fb2087/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3318e3d8edd4336021f4314a25618e77061f2684", "url": "https://api.github.com/repos/rust-lang/rust/commits/3318e3d8edd4336021f4314a25618e77061f2684", "html_url": "https://github.com/rust-lang/rust/commit/3318e3d8edd4336021f4314a25618e77061f2684"}], "stats": {"total": 846, "additions": 823, "deletions": 23}, "files": [{"sha": "c600644ba63e48d7789b27f4602ef306d793b8f2", "filename": "concurrency.md", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/f8be0737ea47a41097bba940ce5f9f9527fb2087/concurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/f8be0737ea47a41097bba940ce5f9f9527fb2087/concurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/concurrency.md?ref=f8be0737ea47a41097bba940ce5f9f9527fb2087", "patch": "@@ -0,0 +1,186 @@\n+% Concurrency and Paralellism\n+\n+```Not sure if I want this\n+Safe Rust features *a ton* of tooling to make concurrency and parallelism totally\n+safe, easy, and fearless. This is a case where we'll really just\n+[defer to TRPL][trpl-conc] for the basics.\n+\n+TL;DR: The `Send` and `Sync` traits in conjunction with Rust's ownership model and\n+normal generic bounds make using concurrent APIs really easy and painless for\n+a user of Safe Rust.\n+```\n+\n+## Data Races and Race Conditions\n+\n+Safe Rust guarantees an absence of data races, which are defined as:\n+\n+* two or more threads concurrently accessing a location of memory\n+* one of them is a write\n+* one of them is unsynchronized\n+\n+A data race has Undefined Behaviour, and is therefore impossible to perform\n+in Safe Rust. Data races are *mostly* prevented through rust's ownership system:\n+it's impossible to alias a mutable reference, so it's impossible to perform a\n+data race. Interior mutability makes this more complicated, which is largely why\n+we have the Send and Sync traits (see below).\n+\n+However Rust *does not* prevent general race conditions. This is\n+pretty fundamentally impossible, and probably honestly undesirable. Your hardware\n+is racy, your OS is racy, the other programs on your computer are racy, and the\n+world this all runs in is racy. Any system that could genuinely claim to prevent\n+*all* race conditions would be pretty awful to use, if not just incorrect.\n+\n+So it's perfectly \"fine\" for a Safe Rust program to get deadlocked or do\n+something incredibly stupid with incorrect synchronization. Obviously such a\n+program isn't very good, but Rust can only hold your hand so far. Still, a\n+race condition can't violate memory safety in a Rust program on\n+its own. Only in conjunction with some other unsafe code can a race condition\n+actually violate memory safety. For instance:\n+\n+```rust\n+use std::thread;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::sync::Arc;\n+\n+let data = vec![1, 2, 3, 4];\n+// Arc so that the memory the AtomicUsize is stored in still exists for\n+// the other thread to increment, even if we completely finish executing\n+// before it. Rust won't compile the program without it, because of the\n+// lifetime requirements of thread::spawn!\n+let idx = Arc::new(AtomicUsize::new(0));\n+let other_idx = idx.clone();\n+\n+// `move` captures other_idx by-value, moving it into this thread\n+thread::spawn(move || {\n+    // It's ok to mutate idx because this value\n+    // is an atomic, so it can't cause a Data Race.\n+    other_idx.fetch_add(10, Ordering::SeqCst);\n+});\n+\n+// Index with the value loaded from the atomic. This is safe because we\n+// read the atomic memory only once, and then pass a *copy* of that value\n+// to the Vec's indexing implementation. This indexing will be correctly\n+// bounds checked, and there's no chance of the value getting changed\n+// in the middle. However our program may panic if the thread we spawned\n+// managed to increment before this ran. A race condition because correct\n+// program execution (panicing is rarely correct) depends on order of\n+// thread execution.\n+println!(\"{}\", data[idx.load(Ordering::SeqCst)]);\n+\n+if idx.load(Ordering::SeqCst) < data.len() {\n+    unsafe {\n+        // Incorrectly loading the idx *after* we did the bounds check.\n+        // It could have changed. This is a race condition, *and dangerous*\n+        // because we decided to do `get_unchecked`, which is `unsafe`.\n+        println!(\"{}\", data.get_unchecked(idx.load(Ordering::SeqCst)));\n+    }\n+}\n+```\n+\n+## Send and Sync\n+\n+Not everything obeys inherited mutability, though. Some types allow you to multiply\n+alias a location in memory while mutating it. Unless these types use synchronization\n+to manage this access, they are absolutely not thread safe. Rust captures this with\n+through the `Send` and `Sync` traits.\n+\n+* A type is Send if it is safe to send it to another thread.\n+* A type is Sync if it is safe to share between threads (`&T` is Send).\n+\n+Send and Sync are *very* fundamental to Rust's concurrency story. As such, a\n+substantial amount of special tooling exists to make them work right. First and\n+foremost, they're *unsafe traits*. This means that they are unsafe *to implement*,\n+and other unsafe code can *trust* that they are correctly implemented. Since\n+they're *marker traits* (they have no associated items like methods), correctly\n+implemented simply means that they have the intrinsic properties an implementor\n+should have. Incorrectly implementing Send or Sync can cause Undefined Behaviour.\n+\n+Send and Sync are also what Rust calls *opt-in builtin traits*.\n+This means that, unlike every other trait, they are *automatically* derived:\n+if a type is composed entirely of Send or Sync types, then it is Send or Sync.\n+Almost all primitives are Send and Sync, and as a consequence pretty much\n+all types you'll ever interact with are Send and Sync.\n+\n+Major exceptions include:\n+* raw pointers are neither Send nor Sync (because they have no safety guards)\n+* `UnsafeCell` isn't Sync (and therefore `Cell` and `RefCell` aren't)\n+* `Rc` isn't Send or Sync (because the refcount is shared and unsynchronized)\n+\n+`Rc` and `UnsafeCell` are very fundamentally not thread-safe: they enable\n+unsynchronized shared mutable state. However raw pointers are, strictly speaking,\n+marked as thread-unsafe as more of a *lint*. Doing anything useful\n+with a raw pointer requires dereferencing it, which is already unsafe. In that\n+sense, one could argue that it would be \"fine\" for them to be marked as thread safe.\n+\n+However it's important that they aren't thread safe to prevent types that\n+*contain them* from being automatically marked as thread safe. These types have\n+non-trivial untracked ownership, and it's unlikely that their author was\n+necessarily thinking hard about thread safety. In the case of Rc, we have a nice\n+example of a type that contains a `*mut` that is *definitely* not thread safe.\n+\n+Types that aren't automatically derived can *opt-in* to Send and Sync by simply\n+implementing them:\n+\n+```rust\n+struct MyBox(*mut u8);\n+\n+unsafe impl Send for MyBox {}\n+unsafe impl Sync for MyBox {}\n+```\n+\n+In the *incredibly rare* case that a type is *inappropriately* automatically\n+derived to be Send or Sync, then one can also *unimplement* Send and Sync:\n+\n+```rust\n+struct SpecialThreadToken(u8);\n+\n+impl !Send for SpecialThreadToken {}\n+impl !Sync for SpecialThreadToken {}\n+```\n+\n+Note that *in and of itself* it is impossible to incorrectly derive Send and Sync.\n+Only types that are ascribed special meaning by other unsafe code can possible cause\n+trouble by being incorrectly Send or Sync.\n+\n+Most uses of raw pointers should be encapsulated behind a sufficient abstraction\n+that Send and Sync can be derived. For instance all of Rust's standard\n+collections are Send and Sync (when they contain Send and Sync types)\n+in spite of their pervasive use raw pointers to\n+manage allocations and complex ownership. Similarly, most iterators into these\n+collections are Send and Sync because they largely behave like an `&` or `&mut`\n+into the collection.\n+\n+TODO: better explain what can or can't be Send or Sync. Sufficient to appeal\n+only to data races?\n+\n+## Atomics\n+\n+Rust pretty blatantly just inherits LLVM's model for atomics, which in turn is\n+largely based off of the C11 model for atomics. This is not due these models\n+being particularly excellent or easy to understand. Indeed, these models are\n+quite complex and are known to have several flaws. Rather, it is a pragmatic\n+concession to the fact that *everyone* is pretty bad at modeling atomics. At very\n+least, we can benefit from existing tooling and research around C's model.\n+\n+Trying to fully explain these models is fairly hopeless, so we're just going to\n+drop that problem in LLVM's lap.\n+\n+## Actually Doing Things Concurrently\n+\n+Rust as a language doesn't *really* have an opinion on how to do concurrency or\n+parallelism. The standard library exposes OS threads and blocking sys-calls\n+because *everyone* has those and they're uniform enough that you can provide\n+an abstraction over them in a relatively uncontroversial way. Message passing,\n+green threads, and async APIs are all diverse enough that any abstraction over\n+them tends to involve trade-offs that we weren't willing to commit to for 1.0.\n+\n+However Rust's current design is setup so that you can set up your own\n+concurrent paradigm or library as you see fit. Just require the right\n+lifetimes and Send and Sync where appropriate and everything should Just Work\n+with everyone else's stuff.\n+\n+\n+\n+\n+[llvm-conc]: http://llvm.org/docs/Atomics.html\n+[trpl-conc]: https://doc.rust-lang.org/book/concurrency.html"}, {"sha": "4fe86284a31ef6bc7801cbeb1d838e667d42dad6", "filename": "conversions.md", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f8be0737ea47a41097bba940ce5f9f9527fb2087/conversions.md", "raw_url": "https://github.com/rust-lang/rust/raw/f8be0737ea47a41097bba940ce5f9f9527fb2087/conversions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/conversions.md?ref=f8be0737ea47a41097bba940ce5f9f9527fb2087", "patch": "@@ -13,18 +13,18 @@ parts and then build a new type out of them. e.g.\n \n ```rust\n struct Foo {\n-\tx: u32,\n-\ty: u16,\n+    x: u32,\n+    y: u16,\n }\n \n struct Bar {\n-\ta: u32,\n-\tb: u16,\n+    a: u32,\n+    b: u16,\n }\n \n fn reinterpret(foo: Foo) -> Bar {\n-\tlet Foo { x, y } = foo;\n-\tBar { a: x, b: y }\n+    let Foo { x, y } = foo;\n+    Bar { a: x, b: y }\n }\n ```\n \n@@ -57,18 +57,27 @@ but some changes require a cast. These \"true casts\" are generally regarded as da\n problematic actions. True casts revolves around raw pointers and the primitive numeric\n types. Here's an exhaustive list of all the true casts:\n \n-* rawptr -> rawptr (e.g. `*mut T as *const T` or `*mut T as *mut U`)\n-* rawptr <-> usize (e.g. `*mut T as usize` or `usize as *mut T`)\n-* number -> number (e.g. `u32 as i8` or `i16 as f64`)\n-* c-like enum -> integer/bool (e.g. `DaysOfWeek as u32`)\n-* `u8` -> `char`\n-* something about arrays?\n+TODO: gank the RFC for sweet casts\n \n For number -> number casts, there are quite a few cases to consider:\n \n-* unsigned to bigger unsigned will zero-extend losslessly\n-* unsigned to smaller unsigned will truncate via wrapping\n-* signed to unsigned will  ... TODO rest of this list\n+* casting between two integers of the same size (e.g. i32 -> u32) is a no-op\n+* casting from a smaller integer to a bigger integer (e.g. u32 -> u8) will truncate\n+* casting from a larger integer to a smaller integer (e.g. u8 -> u32) will\n+    * zero-extend if unsigned\n+    * sign-extend if signed\n+* casting from a float to an integer will round the float towards zero.\n+    * **NOTE: currently this will cause Undefined Behaviour if the rounded\n+      value cannot be represented by the target integer type**. This is a bug\n+      and will be fixed.\n+* casting from an integer to float will produce the floating point representation\n+  of the integer, rounded if necessary (rounding strategy unspecified).\n+* casting from an f32 to an f64 is perfect and lossless.\n+* casting from an f64 to an f32 will produce the closest possible value\n+  (rounding strategy unspecified).\n+    * **NOTE: currently this will cause Undefined Behaviour if the value\n+      is finite but larger or smaller than the largest or smallest finite\n+      value representable by f32**. This is a bug and will be fixed.\n \n The casts involving rawptrs also allow us to completely bypass type-safety\n by re-interpretting a pointer of T to a pointer of U for arbitrary types, as"}, {"sha": "bc0f6483baa4f7d43e70d0772aad79a49bd8c4be", "filename": "intro.md", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/f8be0737ea47a41097bba940ce5f9f9527fb2087/intro.md", "raw_url": "https://github.com/rust-lang/rust/raw/f8be0737ea47a41097bba940ce5f9f9527fb2087/intro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/intro.md?ref=f8be0737ea47a41097bba940ce5f9f9527fb2087", "patch": "@@ -0,0 +1,151 @@\n+% The Unsafe Rust Programming Language\n+\n+This document seeks to complement [The Rust Programming Language][] (TRPL).\n+Where TRPL introduces the language and teaches the basics, TURPL dives deep into\n+the specification of the language, and all the nasty bits necessary to write\n+Unsafe Rust. TURPL does not assume you have read TRPL, but does assume you know\n+the basics of the language and systems programming. We will not explain the\n+stack or heap, we will not explain the syntax.\n+\n+## A Tale Of Two Languages\n+\n+Rust can be thought of as two different languages: Safe Rust, and Unsafe Rust.\n+Any time someone opines the guarantees of Rust, they are almost surely talking about\n+Safe Rust. However Safe Rust is not sufficient to write every program. For that,\n+we need the Unsafe Rust superset.\n+\n+Most fundamentally, writing bindings to other languages\n+(such as the C exposed by your operating system) is never going to be safe. Rust\n+can't control what other languages do to program execution! However Unsafe Rust is\n+also necessary to construct fundamental abstractions where the type system is not\n+sufficient to automatically prove what you're doing is sound.\n+\n+Indeed, the Rust standard library is implemented in Rust, and it makes substantial\n+use of Unsafe Rust for implementing IO, memory allocation, collections,\n+synchronization, and other low-level computational primitives.\n+\n+Upon hearing this, many wonder why they would not simply just use C or C++ in place of\n+Rust (or just use a \"real\" safe language). If we're going to do unsafe things, why not\n+lean on these much more established languages?\n+\n+The most important difference between C++ and Rust is a matter of defaults:\n+Rust is 100% safe by default. Even when you *opt out* of safety in Rust, it is a modular\n+action. In deciding to work with unchecked uninitialized memory, this does not\n+suddenly make dangling or null pointers a problem. When using unchecked indexing on `x`,\n+one does not have to suddenly worry about indexing out of bounds on `y`.\n+\n+C and C++, by contrast, have pervasive unsafety baked into the language. Even the\n+modern best practices like `unique_ptr` have various safety pitfalls.\n+\n+It should also be noted that writing Unsafe Rust should be regarded as an exceptional\n+action. Unsafe Rust is often the domain of *fundamental libraries*. Anything that needs\n+to make FFI bindings or define core abstractions. These fundamental libraries then expose\n+a *safe* interface for intermediate libraries and applications to build upon. And these\n+safe interfaces make an important promise: if your application segfaults, it's not your\n+fault. *They* have a bug.\n+\n+And really, how is that different from *any* safe language? Python, Ruby, and Java libraries\n+can internally do all sorts of nasty things. The languages themselves are no\n+different. Safe languages regularly have bugs that cause critical vulnerabilities.\n+The fact that Rust is written with a healthy spoonful of Unsafe Rust is no different.\n+However it *does* mean that Rust doesn't need to fall back to the pervasive unsafety of\n+C to do the nasty things that need to get done.\n+\n+## What does `unsafe` mean?\n+\n+Rust tries to model memory safety through the `unsafe` keyword. Interestingly,\n+the meaning of `unsafe` largely revolves around what\n+its *absence* means. If the `unsafe` keyword is absent from a program, it should\n+not be possible to violate memory safety under *any* conditions. The presence\n+of `unsafe` means that there are conditions under which this code *could*\n+violate memory safety.\n+\n+To be more concrete, Rust cares about preventing the following things:\n+\n+* Dereferencing null/dangling pointers\n+* Reading uninitialized memory\n+* Breaking the pointer aliasing rules (TBD) (llvm rules + noalias on &mut and & w/o UnsafeCell)\n+* Invoking Undefined Behaviour (in e.g. compiler intrinsics)\n+* Producing invalid primitive values:\n+\t* dangling/null references\n+\t* a `bool` that isn't 0 or 1\n+\t* an undefined `enum` discriminant\n+\t* a `char` larger than char::MAX\n+\t* A non-utf8 `str`\n+* Unwinding into an FFI function\n+* Causing a data race\n+\n+However libraries are free to declare arbitrary requirements if they could transitively\n+cause memory safety issues. However Rust is otherwise quite permisive with respect to\n+other dubious operations. Rust considers it \"safe\" to:\n+\n+* Deadlock\n+* Leak memory\n+* Fail to call destructors\n+* Access private fields\n+* Overflow integers\n+* Delete the production database\n+\n+However any program that does such a thing is *probably* incorrect. Rust just isn't\n+interested in modeling these problems, as they are much harder to prevent in general,\n+and it's basically impossible to prevent incorrect programs from getting written.\n+\n+Their are several places `unsafe` can appear in Rust today, which can largely be\n+grouped into two categories:\n+\n+* There are unchecked contracts here. To declare you understand this, I require\n+you to write `unsafe` elsewhere:\n+    * On functions, `unsafe` is declaring the function to be unsafe to call. Users\n+    of the function must check the documentation to determine what this means,\n+    and then have to write `unsafe` somewhere to identify that they're aware of\n+    the danger.\n+    * On trait declarations, `unsafe` is declaring that *implementing* the trait\n+    is an unsafe operation, as it has contracts that other unsafe code is free to\n+    trust blindly.\n+\n+* I am declaring that I have, to the best of my knowledge, adhered to the\n+unchecked contracts:\n+    * On trait implementations, `unsafe` is declaring that the contract of the\n+    `unsafe` trait has been upheld.\n+    * On blocks, `unsafe` is declaring any unsafety from an unsafe\n+    operation to be handled, and therefore the parent function is safe.\n+\n+There is also `#[unsafe_no_drop_flag]`, which is a special case that exists for\n+historical reasons and is in the process of being phased out. See the section on\n+destructors for details.\n+\n+Some examples of unsafe functions:\n+\n+* `slice::get_unchecked` will perform unchecked indexing, allowing memory\n+safety to be freely violated.\n+* `ptr::offset` in an intrinsic that invokes Undefined Behaviour if it is\n+not \"in bounds\" as defined by LLVM (see the lifetimes section for details).\n+* `mem::transmute` reinterprets some value as having the given type,\n+bypassing type safety in arbitrary ways. (see the conversions section for details)\n+* All FFI functions are `unsafe` because they can do arbitrary things.\n+C being an obvious culprit, but generally any language can do something\n+that Rust isn't happy about. (see the FFI section for details)\n+\n+As of Rust 1.0 there are exactly two unsafe traits:\n+\n+* `Send` is a marker trait (it has no actual API) that promises implementors\n+are safe to send to another thread.\n+* `Sync` is a marker trait that promises that threads can safely share\n+implementors through a shared reference.\n+\n+All other traits that declare any kind of contract *really* can't be trusted\n+to adhere to their contract when memory-safety is at stake. For instance Rust has\n+`PartialOrd` and `Ord` to differentiate between types which can \"just\" be\n+compared and those that implement a total ordering. However you can't actually\n+trust an implementor of `Ord` to actually provide a total ordering if failing to\n+do so causes you to e.g. index out of bounds. But if it just makes your program\n+do a stupid thing, then it's \"fine\" to rely on `Ord`.\n+\n+The reason this is the case is that `Ord` is safe to implement, and it should be\n+impossible for bad *safe* code to violate memory safety. Rust has traditionally\n+avoided making traits unsafe because it makes `unsafe` pervasive in the language,\n+which is not desirable. The only reason `Send` and `Sync` are unsafe is because\n+thread safety is a sort of fundamental thing that a program can't really guard\n+against locally (even by-value message passing still requires a notion Send).\n+\n+"}, {"sha": "42304681c206eac512e50de1e2b0556254fc6b41", "filename": "lifetimes.md", "status": "modified", "additions": 462, "deletions": 8, "changes": 470, "blob_url": "https://github.com/rust-lang/rust/blob/f8be0737ea47a41097bba940ce5f9f9527fb2087/lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/f8be0737ea47a41097bba940ce5f9f9527fb2087/lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lifetimes.md?ref=f8be0737ea47a41097bba940ce5f9f9527fb2087", "patch": "@@ -1,13 +1,467 @@\n-% Advanced Lifetimes\n+% Ownership\n \n-Lifetimes are the breakout feature of Rust.\n+Ownership is the breakout feature of Rust. It allows Rust to be completely\n+memory-safe and efficient, while avoiding garbage collection. Before getting\n+into the ownership system in detail, we will consider a simple but *fundamental*\n+language-design problem.\n \n-# Safe Rust\n \n-* no aliasing of &mut\n \n-# Unsafe Rust\n+## The Tagged Union Problem\n+\n+The core of the lifetime and mutability system derives from a simple problem:\n+internal pointers to tagged unions. For instance, consider the following code:\n+\n+```rust\n+enum Foo {\n+    A(u32),\n+    B(f64),\n+}\n+\n+let mut x = B(2.0);\n+if let B(ref mut y) = x {\n+    *x = A(7);\n+    // OH NO! a u32 has been interpretted as an f64! Type-safety hole!\n+    // (this does not actually compile)\n+    println!(\"{}\", y);\n+\n+}\n+```\n+\n+The problem here is an intersection of 3 choices:\n+\n+* data in a tagged union is inline with the tag\n+* tagged unions are mutable\n+* being able to take a pointer into a tagged union\n+\n+Remove *any* of these 3 and the problem goes away. Traditionally, functional\n+languages have avoided this problem by removing the mutable\n+option. This means that they can in principle keep their data inline (ghc has\n+a pragma for this). A garbage collected imperative language like Java could alternatively\n+solve this problem by just keeping all variants elsewhere, so that changing the\n+variant of a tagged union just overwrites a pointer, and anyone with an outstanding\n+pointer to the inner data is unaffected thanks to The Magic Of Garbage Collection.\n+\n+Rust, by contrast, takes a subtler approach. Rust allows mutation,\n+allows pointers to inner data, and its enums have their data allocated inline.\n+However it prevents anything from being mutated while there are outstanding\n+pointers to it! And this is all done at compile time.\n+\n+Interestingly, Rust's `std::cell` module exposes two types that offer an alternative\n+approach to this problem:\n+\n+* The `Cell` type allows mutation of aliased data, but\n+instead forbids internal pointers to that data. The only way to read or write\n+a Cell is to copy the bits in or out.\n+\n+* The `RefCell` type allows mutation of aliased data *and* internal pointers, but\n+manages this through *runtime* checks. It is effectively a thread-unsafe\n+read-write lock.\n+\n+\n+\n+## Lifetimes\n+\n+Rust's static checks are managed by the *borrow checker* (borrowck), which tracks\n+mutability and outstanding loans. This analysis can in principle be done without\n+any help locally. However as soon as data starts crossing the function boundary,\n+we have some serious trouble. In principle, borrowck could be a massive\n+whole-program analysis engine to handle this problem, but this would be an\n+atrocious solution. It would be terribly slow, and errors would be horribly\n+non-local.\n+\n+Instead, Rust tracks ownership through *lifetimes*. Every single reference and value\n+in Rust is tagged with a lifetime that indicates the scope it is valid for.\n+Rust has two kinds of reference:\n+\n+* Shared reference: `&`\n+* Mutable reference: `&mut`\n+\n+The main rules are as follows:\n+\n+* A shared reference can be aliased\n+* A mutable reference cannot be aliased\n+* A reference cannot outlive its referrent (`&'a T -> T: 'a`)\n+\n+However non-mutable variables have some special rules:\n+\n+* You cannot mutate or mutably borrow a non-mut variable,\n+\n+Only variables marked as mutable can be borrowed mutably, though this is little\n+more than a local lint against incorrect usage of a value.\n+\n+\n+\n+\n+## Weird Lifetimes\n+\n+Almost always, the mutability of a lifetime can be derived from the mutability\n+of the reference it is attached to. However this is not necessarily the case.\n+For instance in the following code:\n+\n+```rust\n+fn foo<'a>(input: &'a mut u8) -> &'a u8 { &* input }\n+```\n+\n+One would expect the output of foo to be an immutable lifetime. However we have\n+derived it from the input, which is a mutable lifetime. So although we have a\n+shared reference, it will have the much more limited aliasing rules of a mutable\n+reference. As a consequence, there is no expressive benefit in a method that\n+mutates returning a shared reference.\n+\n+\n+\n+\n+## Lifetime Elision\n+\n+In order to make common patterns more ergonomic, Rust allows lifetimes to be\n+*elided* in function, impl, and type signatures.\n+\n+A *lifetime position* is anywhere you can write a lifetime in a type:\n+\n+```rust\n+&'a T\n+&'a mut T\n+T<'a>\n+```\n+\n+Lifetime positions can appear as either \"input\" or \"output\":\n+\n+* For `fn` definitions, input refers to the types of the formal arguments\n+  in the `fn` definition, while output refers to\n+  result types. So `fn foo(s: &str) -> (&str, &str)` has elided one lifetime in\n+  input position and two lifetimes in output position.\n+  Note that the input positions of a `fn` method definition do not\n+  include the lifetimes that occur in the method's `impl` header\n+  (nor lifetimes that occur in the trait header, for a default method).\n+\n+* In the future, it should be possible to elide `impl` headers in the same manner.\n+\n+Elision rules are as follows:\n+\n+* Each elided lifetime in input position becomes a distinct lifetime\n+  parameter.\n+\n+* If there is exactly one input lifetime position (elided or not), that lifetime\n+  is assigned to *all* elided output lifetimes.\n+\n+* If there are multiple input lifetime positions, but one of them is `&self` or\n+  `&mut self`, the lifetime of `self` is assigned to *all* elided output lifetimes.\n+\n+* Otherwise, it is an error to elide an output lifetime.\n+\n+Examples:\n+\n+```rust\n+fn print(s: &str);                                      // elided\n+fn print<'a>(s: &'a str);                               // expanded\n+\n+fn debug(lvl: uint, s: &str);                           // elided\n+fn debug<'a>(lvl: uint, s: &'a str);                    // expanded\n+\n+fn substr(s: &str, until: uint) -> &str;                // elided\n+fn substr<'a>(s: &'a str, until: uint) -> &'a str;      // expanded\n+\n+fn get_str() -> &str;                                   // ILLEGAL\n+\n+fn frob(s: &str, t: &str) -> &str;                      // ILLEGAL\n+\n+fn get_mut(&mut self) -> &mut T;                        // elided\n+fn get_mut<'a>(&'a mut self) -> &'a mut T;              // expanded\n+\n+fn args<T:ToCStr>(&mut self, args: &[T]) -> &mut Command                  // elided\n+fn args<'a, 'b, T:ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command // expanded\n+\n+fn new(buf: &mut [u8]) -> BufWriter;                    // elided\n+fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a>          // expanded\n+\n+```\n+\n+\n+\n+## Unbounded Lifetimes\n+\n+Unsafe code can often end up producing references or lifetimes out of thin air.\n+Such lifetimes come into the world as *unbounded*. The most common source of this\n+is derefencing a raw pointer, which produces a reference with an unbounded lifetime.\n+Such a lifetime becomes as big as context demands. This is in fact more powerful\n+than simply becoming `'static`, because for instance `&'static &'a T`\n+will fail to typecheck, but the unbound lifetime will perfectly mold into\n+`&'a &'a T` as needed. However for most intents and purposes, such an unbounded\n+lifetime can be regarded as `'static`.\n+\n+Almost no reference is `'static`, so this is probably wrong. `transmute` and\n+`transmute_copy` are the two other primary offenders. One should endeavour to\n+bound an unbounded lifetime as quick as possible, especially across function\n+boundaries.\n+\n+Given a function, any output lifetimes that don't derive from inputs are\n+unbounded. For instance:\n+\n+```\n+fn get_str<'a>() -> &'a str;\n+```\n+\n+will produce an `&str` with an unbounded lifetime. The easiest way to avoid\n+unbounded lifetimes is to use lifetime elision at the function boundary.\n+If an output lifetime is elided, then it *must* be bounded by an input lifetime.\n+Of course, it might be bounded by the *wrong* lifetime, but this will usually\n+just cause a compiler error, rather than allow memory safety to be trivially\n+violated.\n+\n+Within a function, bounding lifetimes is more error-prone. The safest route\n+is to just use a small function to ensure the lifetime is bound. However if\n+this is unacceptable, the reference can be placed in a location with a specific\n+lifetime. Unfortunately it's impossible to name all lifetimes involved in a\n+function. To get around this, you can in principle use `copy_lifetime`, though\n+these are unstable due to their awkward nature and questionable utility.\n+\n+\n+\n+\n+## Subtyping and Variance\n+\n+Although Rust doesn't have any notion of inheritance, it *does* include subtyping.\n+In Rust, subtyping derives entirely from *lifetimes*. Since lifetimes are derived\n+from scopes, we can partially order them based on an *outlives* relationship. We\n+can even express this as a generic bound: `T: 'a` specifies that `T` *outlives* `'a`.\n+\n+We can then define subtyping on lifetimes in terms of lifetimes: `'a : 'b` implies\n+`'a <: b` -- if `'a' outlives `'b`, then `'a` is a subtype of `'b`. This is a very\n+large source of confusion, because a bigger scope is a *sub type* of a smaller scope.\n+This does in fact make sense. The intuitive reason for this is that if you expect an\n+`&'a u8`, then it's totally fine for me to hand you an `&'static u8`, in the same way\n+that if you expect an Animal in Java, it's totally fine for me to hand you a Cat.\n+\n+Variance is where things get really harsh.\n+\n+Variance is a property that *type constructors* have. A type constructor in Rust\n+is a generic type with unbound arguments. For instance `Vec` is a type constructor\n+that takes a `T` and returns a `Vec<T>`. `&` and `&mut` are type constructors that\n+take a lifetime and a type.\n+\n+A type constructor's *variance* is how the subtypes of its inputs affects the\n+subtypes of its outputs. There are three kinds of variance:\n+\n+* F is *covariant* if `T <: U` implies `F<T> <: F<U>`\n+* F is *contravariant* if `T <: U` implies `F<U> <: F<T>`\n+* F is *invariant* otherwise (no subtyping relation can be derived)\n+\n+Some important variances:\n+\n+* `&` is covariant (as is *const by metaphor)\n+* `&mut` is invariant (as is *mut by metaphor)\n+* `Fn(T)` is contravariant with respect to `T`\n+* `Box`, `Vec`, and all other collections are covariant\n+* `UnsafeCell`, `Cell`, `RefCell`, `Mutex` and all \"interior mutability\"\n+  types are invariant\n+\n+To understand why these variances are correct and desirable, we will consider several\n+examples. We have already covered why `&` should be covariant.\n+\n+To see why `&mut` should be invariant, consider the following code:\n+\n+```rust\n+fn main() {\n+    let mut forever_str: &'static str = \"hello\";\n+    {\n+        let string = String::from(\"world\");\n+        overwrite(&mut forever_str, &mut &*string);\n+    }\n+    println!(\"{}\", forever_str);\n+}\n+\n+fn overwrite<T: Copy>(input: &mut T, new: &mut T) {\n+    *input = *new;\n+}\n+```\n+\n+The signature of `overwrite` is clearly valid: it takes mutable references to two values\n+of the same type, and replaces one with the other. We have seen already that `&` is\n+covariant, and `'static` is a subtype of *any* `'a', so `&'static str` is a\n+subtype of `&'a str`. Therefore, if `&mut` was\n+*also* covariant, then the lifetime of the `&'static str` would successfully be\n+\"shrunk\" down to the shorter lifetime of the string, and `replace` would be\n+called successfully. The string would subsequently be dropped, and `forever_str`\n+would point to freed memory when we print it!\n+\n+Therefore `&mut` should be invariant. This is the general theme of covariance vs\n+invariance: if covariance would allow you to *store* a short-lived value in a\n+longer-lived slot, then you must be invariant.\n+\n+`Box` and `Vec` are interesting cases because they're covariant, but you can\n+definitely store values in them! This is fine because *you can only store values\n+in them through a mutable reference*! The mutable reference makes the whole type\n+invariant, and therefore prevents you from getting in trouble.\n+\n+Being covariant allows them to be covariant when shared immutably (so you can pass\n+a `&Box<&'static str>` where a `&Box<&'a str>` is expected). It also allows you to\n+forever weaken the type by moving it into a weaker slot. That is, you can do:\n+\n+```rust\n+fn get_box<'a>(&'a u8) -> Box<&'a str> {\n+    Box::new(\"hello\")\n+}\n+```\n+\n+which is fine because unlike the mutable borrow case, there's no one else who\n+\"remembers\" the old lifetime in the box.\n+\n+The variance of the cell types similarly follows. `&` is like an `&mut` for a\n+cell, because you can still store values in them through an `&`. Therefore cells\n+must be invariant to avoid lifetime smuggling.\n+\n+`Fn` is the most confusing case, largely because contravariance is easily the\n+most confusing kind of variance, and basically never comes up. To understand it,\n+consider a function that *takes* a function `len` that takes a function `F`.\n+\n+```rust\n+fn len<F>(func: F) -> usize\n+    where F: Fn(&'static str) -> usize\n+{\n+    func(\"hello\")\n+}\n+```\n+\n+We require that F is a Fn that can take an `&'static str` and print a usize. Now\n+say we have a function that can take an `&'a str` (for *some* 'a). Such a function actually\n+accepts *more* inputs, since `&'static str` is a subtype of `&'a str`. Therefore\n+`len` should happily accept such a function!\n+\n+So a `Fn(&'a str)` is a subtype of a `Fn(&'static str)` because\n+`&'static str` is a subtype of `&'a str`. Exactly contravariance.\n+\n+The variance of `*const` and `*mut` is basically arbitrary as they're not at all\n+type or memory safe, so their variance is determined in analogy to & and &mut\n+respectively.\n+\n+\n+\n+\n+## PhantomData and PhantomFn\n+\n+This is all well and good for the types the standard library provides, but\n+how is variance determined for type that *you* define? The variance of a type\n+over its generic arguments is determined by how they're stored.\n+\n+```rust\n+struct Foo<'a, 'b, A, B, C, D, E, F, G, H> {\n+    a: &'a A,     // covariant over 'a and A\n+    b: &'b mut B, // invariant over 'b and B\n+    c: *const C,  // covariant over C\n+    d: *mut D,    // invariant over D\n+    e: Vec<E>,    // covariant over E\n+    f: Cell<F>,   // invariant over F\n+    g: G          // covariant over G\n+    h1: H         // would also be covariant over H except...\n+    h2: Cell<H>   // invariant over H, because invariance wins\n+}\n+```\n+\n+However when working with unsafe code, we can often end up in a situation where\n+types or lifetimes are logically associated with a struct, but not actually\n+reachable. This most commonly occurs with lifetimes. For instance, the `Iter`\n+for `&'a [T]` is (approximately) defined as follows:\n+\n+```\n+pub struct Iter<'a, T: 'a> {\n+    ptr: *const T,\n+    end: *const T,\n+}\n+```\n+\n+However because `'a` is unused within the struct's body, it's *unbound*.\n+Because of the troubles this has historically caused, unbound lifetimes and\n+types are *illegal* in struct definitions. Therefore we must somehow refer\n+to these types in the body.\n+\n+We do this using *PhantomData*, which is a special marker type. PhantomData\n+consumes no space, but simulates a field of the given type for the purpose of\n+variance. This was deemed to be less error-prone than explicitly telling the\n+type-system the kind of variance that you want.\n+\n+Iter logically contains `&'a T`, so this is exactly what we tell\n+the PhantomData to simulate:\n+\n+```\n+pub struct Iter<'a, T: 'a> {\n+    ptr: *const T,\n+    end: *const T,\n+    _marker: marker::PhantomData<&'a T>,\n+}\n+```\n+\n+\n+## Splitting Lifetimes\n+\n+The mutual exclusion property of mutable references can be very limiting when\n+working with a composite structure. Borrowck understands some basic stuff, but\n+will fall over pretty easily. Borrowck understands structs sufficiently to\n+understand that it's possible to borrow disjoint fields of a struct simultaneously.\n+So this works today:\n+\n+```rust\n+struct Foo {\n+    a: i32,\n+    b: i32,\n+    c: i32,\n+}\n+\n+let mut x = Foo {a: 0, b: 0, c: 0};\n+let a = &mut x.a;\n+let b = &mut x.b;\n+let c = &x.c;\n+*b += 1;\n+let c2 = &x.c;\n+*a += 10;\n+println!(\"{} {} {} {}\", a, b, c, c2);\n+```\n+\n+However borrowck doesn't understand arrays or slices in any way, so this doesn't\n+work:\n+\n+```rust\n+let x = [1, 2, 3];\n+let a = &mut x[0];\n+let b = &mut x[1];\n+println!(\"{} {}\", a, b);\n+```\n+\n+```text\n+<anon>:3:18: 3:22 error: cannot borrow immutable indexed content `x[..]` as mutable\n+<anon>:3     let a = &mut x[0];\n+                          ^~~~\n+<anon>:4:18: 4:22 error: cannot borrow immutable indexed content `x[..]` as mutable\n+<anon>:4     let b = &mut x[1];\n+                          ^~~~\n+error: aborting due to 2 previous errors\n+```\n+\n+While it was plausible that borrowck could understand this simple case, it's\n+pretty clearly hopeless for borrowck to understand disjointness in general\n+container types like a tree, especially if distinct keys actually *do* map\n+to the same value.\n+\n+In order to \"teach\" borrowck that what we're doing is ok, we need to drop down\n+to unsafe code. For instance, mutable slices expose a `split_at_mut` function that\n+consumes the slice and returns *two* mutable slices. One for everything to the\n+left of the index, and one for everything to the right. Intuitively we know this\n+is safe because the slices don't alias. However the implementation requires some\n+unsafety:\n+\n+```rust\n+fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n+    unsafe {\n+        let self2: &mut [T] = mem::transmute_copy(&self);\n+\n+        (ops::IndexMut::index_mut(self, ops::RangeTo { end: mid } ),\n+         ops::IndexMut::index_mut(self2, ops::RangeFrom { start: mid } ))\n+    }\n+}\n+```\n+\n+This is pretty plainly dangerous. We use transmute to duplicate the slice with an\n+*unbounded* lifetime, so that it\n+\n+\n \n-* Splitting lifetimes into disjoint regions\n-* Creating lifetimes from raw pointers\n-*\n\\ No newline at end of file"}]}