{"sha": "e3c8433ebb4a1acf125cae34ebd910869c894ebd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzYzg0MzNlYmI0YTFhY2YxMjVjYWUzNGViZDkxMDg2OWM4OTRlYmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-21T02:24:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-21T02:24:18Z"}, "message": "Auto merge of #43183 - michaelwoerister:internalize-symbols-without-llvm, r=eddyb\n\ntrans: Internalize symbols without relying on LLVM\n\nThis PR makes the compiler use the information gather by the trans collector in order to determine which symbols/trans-items can be made internal. This has the advantages:\n+ of being LLVM independent,\n+ of also working in incremental mode, and\n+ of allowing to not keep all LLVM modules in memory at the same time.\n\nThis is in preparation for fixing issue #39280.\n\ncc @rust-lang/compiler", "tree": {"sha": "ab2ce1c933c3b175b0dab5508f2d89022a2b5eea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab2ce1c933c3b175b0dab5508f2d89022a2b5eea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3c8433ebb4a1acf125cae34ebd910869c894ebd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3c8433ebb4a1acf125cae34ebd910869c894ebd", "html_url": "https://github.com/rust-lang/rust/commit/e3c8433ebb4a1acf125cae34ebd910869c894ebd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3c8433ebb4a1acf125cae34ebd910869c894ebd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc800531cc79b76b37a1e0f1f58f807ea7aee68b", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc800531cc79b76b37a1e0f1f58f807ea7aee68b", "html_url": "https://github.com/rust-lang/rust/commit/cc800531cc79b76b37a1e0f1f58f807ea7aee68b"}, {"sha": "f6e5416a2f98685870ca6912beea42c00a446802", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6e5416a2f98685870ca6912beea42c00a446802", "html_url": "https://github.com/rust-lang/rust/commit/f6e5416a2f98685870ca6912beea42c00a446802"}], "stats": {"total": 924, "additions": 559, "deletions": 365}, "files": [{"sha": "0541fbe15ec5b830c6dd92daa63f2b0b5f7c0f9f", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=e3c8433ebb4a1acf125cae34ebd910869c894ebd", "patch": "@@ -19,7 +19,7 @@ use std::process::Command;\n use context::SharedCrateContext;\n \n use back::archive;\n-use back::symbol_export::{self, ExportedSymbols};\n+use back::symbol_export::ExportedSymbols;\n use rustc::middle::dependency_format::Linkage;\n use rustc::hir::def_id::{LOCAL_CRATE, CrateNum};\n use rustc_back::LinkerFlavor;\n@@ -707,10 +707,8 @@ fn exported_symbols(scx: &SharedCrateContext,\n                     exported_symbols: &ExportedSymbols,\n                     crate_type: CrateType)\n                     -> Vec<String> {\n-    let export_threshold = symbol_export::crate_export_threshold(crate_type);\n-\n     let mut symbols = Vec::new();\n-    exported_symbols.for_each_exported_symbol(LOCAL_CRATE, export_threshold, |name, _| {\n+    exported_symbols.for_each_exported_symbol(LOCAL_CRATE, |name, _, _| {\n         symbols.push(name.to_owned());\n     });\n \n@@ -722,7 +720,7 @@ fn exported_symbols(scx: &SharedCrateContext,\n         // For each dependency that we are linking to statically ...\n         if *dep_format == Linkage::Static {\n             // ... we add its symbol list to our export list.\n-            exported_symbols.for_each_exported_symbol(cnum, export_threshold, |name, _| {\n+            exported_symbols.for_each_exported_symbol(cnum, |name, _, _| {\n                 symbols.push(name.to_owned());\n             })\n         }"}, {"sha": "feed127b0b60b690d51df6b1ec2770812df31e14", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=e3c8433ebb4a1acf125cae34ebd910869c894ebd", "patch": "@@ -66,7 +66,7 @@ pub fn run(cgcx: &CodegenContext,\n     let export_threshold =\n         symbol_export::crates_export_threshold(&cgcx.crate_types);\n \n-    let symbol_filter = &|&(ref name, level): &(String, _)| {\n+    let symbol_filter = &|&(ref name, _, level): &(String, _, _)| {\n         if symbol_export::is_below_threshold(level, export_threshold) {\n             let mut bytes = Vec::with_capacity(name.len() + 1);\n             bytes.extend(name.bytes());"}, {"sha": "72071f8cec99006793a4a5df09d9c7f246fa95d7", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 72, "deletions": 40, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=e3c8433ebb4a1acf125cae34ebd910869c894ebd", "patch": "@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use context::SharedCrateContext;\n use monomorphize::Instance;\n-use rustc::util::nodemap::FxHashMap;\n-use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n+use rustc::util::nodemap::{FxHashMap, NodeSet};\n+use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE, INVALID_CRATE, CRATE_DEF_INDEX};\n use rustc::session::config;\n use rustc::ty::TyCtxt;\n use syntax::attr;\n@@ -28,59 +27,87 @@ pub enum SymbolExportLevel {\n }\n \n /// The set of symbols exported from each crate in the crate graph.\n+#[derive(Debug)]\n pub struct ExportedSymbols {\n-    exports: FxHashMap<CrateNum, Vec<(String, SymbolExportLevel)>>,\n+    pub export_threshold: SymbolExportLevel,\n+    exports: FxHashMap<CrateNum, Vec<(String, DefId, SymbolExportLevel)>>,\n+    local_exports: NodeSet,\n }\n \n impl ExportedSymbols {\n     pub fn empty() -> ExportedSymbols {\n         ExportedSymbols {\n+            export_threshold: SymbolExportLevel::C,\n             exports: FxHashMap(),\n+            local_exports: NodeSet(),\n         }\n     }\n \n-    pub fn compute<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>) -> ExportedSymbols {\n-        let mut local_crate: Vec<_> = scx\n-            .exported_symbols()\n+    pub fn compute<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             local_exported_symbols: &NodeSet)\n+                             -> ExportedSymbols {\n+        let export_threshold = crates_export_threshold(&tcx.sess.crate_types.borrow());\n+\n+        let mut local_crate: Vec<_> = local_exported_symbols\n             .iter()\n             .map(|&node_id| {\n-                scx.tcx().hir.local_def_id(node_id)\n+                tcx.hir.local_def_id(node_id)\n             })\n             .map(|def_id| {\n-                let name = scx.tcx().symbol_name(Instance::mono(scx.tcx(), def_id));\n-                let export_level = export_level(scx, def_id);\n+                let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n+                let export_level = export_level(tcx, def_id);\n                 debug!(\"EXPORTED SYMBOL (local): {} ({:?})\", name, export_level);\n-                (str::to_owned(&name), export_level)\n+                (str::to_owned(&name), def_id, export_level)\n             })\n             .collect();\n \n-        if scx.sess().entry_fn.borrow().is_some() {\n-            local_crate.push((\"main\".to_string(), SymbolExportLevel::C));\n+        let mut local_exports = local_crate\n+            .iter()\n+            .filter_map(|&(_, def_id, level)| {\n+                if is_below_threshold(level, export_threshold) {\n+                    tcx.hir.as_local_node_id(def_id)\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect::<NodeSet>();\n+\n+        const INVALID_DEF_ID: DefId = DefId {\n+            krate: INVALID_CRATE,\n+            index: CRATE_DEF_INDEX,\n+        };\n+\n+        if let Some(_) = *tcx.sess.entry_fn.borrow() {\n+            local_crate.push((\"main\".to_string(),\n+                              INVALID_DEF_ID,\n+                              SymbolExportLevel::C));\n         }\n \n-        if let Some(id) = scx.sess().derive_registrar_fn.get() {\n-            let def_id = scx.tcx().hir.local_def_id(id);\n+        if let Some(id) = tcx.sess.derive_registrar_fn.get() {\n+            let def_id = tcx.hir.local_def_id(id);\n             let idx = def_id.index;\n-            let disambiguator = scx.sess().local_crate_disambiguator();\n-            let registrar = scx.sess().generate_derive_registrar_symbol(disambiguator, idx);\n-            local_crate.push((registrar, SymbolExportLevel::C));\n+            let disambiguator = tcx.sess.local_crate_disambiguator();\n+            let registrar = tcx.sess.generate_derive_registrar_symbol(disambiguator, idx);\n+            local_crate.push((registrar, def_id, SymbolExportLevel::C));\n+            local_exports.insert(id);\n         }\n \n-        if scx.sess().crate_types.borrow().contains(&config::CrateTypeDylib) {\n-            local_crate.push((metadata_symbol_name(scx.tcx()),\n+        if tcx.sess.crate_types.borrow().contains(&config::CrateTypeDylib) {\n+            local_crate.push((metadata_symbol_name(tcx),\n+                              INVALID_DEF_ID,\n                               SymbolExportLevel::Rust));\n         }\n \n         let mut exports = FxHashMap();\n         exports.insert(LOCAL_CRATE, local_crate);\n \n-        for cnum in scx.sess().cstore.crates() {\n+        for cnum in tcx.sess.cstore.crates() {\n             debug_assert!(cnum != LOCAL_CRATE);\n \n             // If this crate is a plugin and/or a custom derive crate, then\n             // we're not even going to link those in so we skip those crates.\n-            if scx.sess().cstore.plugin_registrar_fn(cnum).is_some() ||\n-               scx.sess().cstore.derive_registrar_fn(cnum).is_some() {\n+            if tcx.sess.cstore.plugin_registrar_fn(cnum).is_some() ||\n+               tcx.sess.cstore.derive_registrar_fn(cnum).is_some() {\n                 continue;\n             }\n \n@@ -92,16 +119,16 @@ impl ExportedSymbols {\n             // Down below we'll hardwire all of the symbols to the `Rust` export\n             // level instead.\n             let special_runtime_crate =\n-                scx.tcx().is_panic_runtime(cnum.as_def_id()) ||\n-                scx.sess().cstore.is_compiler_builtins(cnum);\n+                tcx.is_panic_runtime(cnum.as_def_id()) ||\n+                tcx.sess.cstore.is_compiler_builtins(cnum);\n \n-            let crate_exports = scx\n-                .sess()\n+            let crate_exports = tcx\n+                .sess\n                 .cstore\n                 .exported_symbols(cnum)\n                 .iter()\n                 .map(|&def_id| {\n-                    let name = scx.tcx().symbol_name(Instance::mono(scx.tcx(), def_id));\n+                    let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n                     let export_level = if special_runtime_crate {\n                         // We can probably do better here by just ensuring that\n                         // it has hidden visibility rather than public\n@@ -118,35 +145,41 @@ impl ExportedSymbols {\n                             SymbolExportLevel::Rust\n                         }\n                     } else {\n-                        export_level(scx, def_id)\n+                        export_level(tcx, def_id)\n                     };\n                     debug!(\"EXPORTED SYMBOL (re-export): {} ({:?})\", name, export_level);\n-                    (str::to_owned(&name), export_level)\n+                    (str::to_owned(&name), def_id, export_level)\n                 })\n                 .collect();\n \n             exports.insert(cnum, crate_exports);\n         }\n \n         return ExportedSymbols {\n-            exports: exports\n+            export_threshold,\n+            exports,\n+            local_exports,\n         };\n \n-        fn export_level(scx: &SharedCrateContext,\n+        fn export_level(tcx: TyCtxt,\n                         sym_def_id: DefId)\n                         -> SymbolExportLevel {\n-            let attrs = scx.tcx().get_attrs(sym_def_id);\n-            if attr::contains_extern_indicator(scx.sess().diagnostic(), &attrs) {\n+            let attrs = tcx.get_attrs(sym_def_id);\n+            if attr::contains_extern_indicator(tcx.sess.diagnostic(), &attrs) {\n                 SymbolExportLevel::C\n             } else {\n                 SymbolExportLevel::Rust\n             }\n         }\n     }\n \n+    pub fn local_exports(&self) -> &NodeSet {\n+        &self.local_exports\n+    }\n+\n     pub fn exported_symbols(&self,\n                             cnum: CrateNum)\n-                            -> &[(String, SymbolExportLevel)] {\n+                            -> &[(String, DefId, SymbolExportLevel)] {\n         match self.exports.get(&cnum) {\n             Some(exports) => exports,\n             None => &[]\n@@ -155,13 +188,12 @@ impl ExportedSymbols {\n \n     pub fn for_each_exported_symbol<F>(&self,\n                                        cnum: CrateNum,\n-                                       export_threshold: SymbolExportLevel,\n                                        mut f: F)\n-        where F: FnMut(&str, SymbolExportLevel)\n+        where F: FnMut(&str, DefId, SymbolExportLevel)\n     {\n-        for &(ref name, export_level) in self.exported_symbols(cnum) {\n-            if is_below_threshold(export_level, export_threshold) {\n-                f(&name, export_level)\n+        for &(ref name, def_id, export_level) in self.exported_symbols(cnum) {\n+            if is_below_threshold(export_level, self.export_threshold) {\n+                f(&name, def_id, export_level)\n             }\n         }\n     }"}, {"sha": "7b836399f9cb5ec4528b756b218c5e73b51fff0c", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 30, "deletions": 163, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=e3c8433ebb4a1acf125cae34ebd910869c894ebd", "patch": "@@ -77,6 +77,7 @@ use rustc::util::nodemap::{NodeSet, FxHashMap, FxHashSet};\n use libc::c_uint;\n use std::ffi::{CStr, CString};\n use std::str;\n+use std::sync::Arc;\n use std::i32;\n use syntax_pos::Span;\n use syntax::attr;\n@@ -796,131 +797,6 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     return (metadata_llcx, metadata_llmod, metadata);\n }\n \n-/// Find any symbols that are defined in one compilation unit, but not declared\n-/// in any other compilation unit.  Give these symbols internal linkage.\n-fn internalize_symbols<'a, 'tcx>(sess: &Session,\n-                                 scx: &SharedCrateContext<'a, 'tcx>,\n-                                 translation_items: &FxHashSet<TransItem<'tcx>>,\n-                                 llvm_modules: &[ModuleLlvm],\n-                                 exported_symbols: &ExportedSymbols) {\n-    let export_threshold =\n-        symbol_export::crates_export_threshold(&sess.crate_types.borrow());\n-\n-    let exported_symbols = exported_symbols\n-        .exported_symbols(LOCAL_CRATE)\n-        .iter()\n-        .filter(|&&(_, export_level)| {\n-            symbol_export::is_below_threshold(export_level, export_threshold)\n-        })\n-        .map(|&(ref name, _)| &name[..])\n-        .collect::<FxHashSet<&str>>();\n-\n-    let tcx = scx.tcx();\n-\n-    let incr_comp = sess.opts.debugging_opts.incremental.is_some();\n-\n-    // 'unsafe' because we are holding on to CStr's from the LLVM module within\n-    // this block.\n-    unsafe {\n-        let mut referenced_somewhere = FxHashSet();\n-\n-        // Collect all symbols that need to stay externally visible because they\n-        // are referenced via a declaration in some other codegen unit. In\n-        // incremental compilation, we don't need to collect. See below for more\n-        // information.\n-        if !incr_comp {\n-            for ll in llvm_modules {\n-                for val in iter_globals(ll.llmod).chain(iter_functions(ll.llmod)) {\n-                    let linkage = llvm::LLVMRustGetLinkage(val);\n-                    // We only care about external declarations (not definitions)\n-                    // and available_externally definitions.\n-                    let is_available_externally =\n-                        linkage == llvm::Linkage::AvailableExternallyLinkage;\n-                    let is_decl = llvm::LLVMIsDeclaration(val) == llvm::True;\n-\n-                    if is_decl || is_available_externally {\n-                        let symbol_name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n-                        referenced_somewhere.insert(symbol_name);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Also collect all symbols for which we cannot adjust linkage, because\n-        // it is fixed by some directive in the source code.\n-        let (locally_defined_symbols, linkage_fixed_explicitly) = {\n-            let mut locally_defined_symbols = FxHashSet();\n-            let mut linkage_fixed_explicitly = FxHashSet();\n-\n-            for trans_item in translation_items {\n-                let symbol_name = str::to_owned(&trans_item.symbol_name(tcx));\n-                if trans_item.explicit_linkage(tcx).is_some() {\n-                    linkage_fixed_explicitly.insert(symbol_name.clone());\n-                }\n-                locally_defined_symbols.insert(symbol_name);\n-            }\n-\n-            (locally_defined_symbols, linkage_fixed_explicitly)\n-        };\n-\n-        // Examine each external definition.  If the definition is not used in\n-        // any other compilation unit, and is not reachable from other crates,\n-        // then give it internal linkage.\n-        for ll in llvm_modules {\n-            for val in iter_globals(ll.llmod).chain(iter_functions(ll.llmod)) {\n-                let linkage = llvm::LLVMRustGetLinkage(val);\n-\n-                let is_externally_visible = (linkage == llvm::Linkage::ExternalLinkage) ||\n-                                            (linkage == llvm::Linkage::LinkOnceODRLinkage) ||\n-                                            (linkage == llvm::Linkage::WeakODRLinkage);\n-\n-                if !is_externally_visible {\n-                    // This symbol is not visible outside of its codegen unit,\n-                    // so there is nothing to do for it.\n-                    continue;\n-                }\n-\n-                let name_cstr = CStr::from_ptr(llvm::LLVMGetValueName(val));\n-                let name_str = name_cstr.to_str().unwrap();\n-\n-                if exported_symbols.contains(&name_str) {\n-                    // This symbol is explicitly exported, so we can't\n-                    // mark it as internal or hidden.\n-                    continue;\n-                }\n-\n-                let is_declaration = llvm::LLVMIsDeclaration(val) == llvm::True;\n-\n-                if is_declaration {\n-                    if locally_defined_symbols.contains(name_str) {\n-                        // Only mark declarations from the current crate as hidden.\n-                        // Otherwise we would mark things as hidden that are\n-                        // imported from other crates or native libraries.\n-                        llvm::LLVMRustSetVisibility(val, llvm::Visibility::Hidden);\n-                    }\n-                } else {\n-                    let has_fixed_linkage = linkage_fixed_explicitly.contains(name_str);\n-\n-                    if !has_fixed_linkage {\n-                        // In incremental compilation mode, we can't be sure that\n-                        // we saw all references because we don't know what's in\n-                        // cached compilation units, so we always assume that the\n-                        // given item has been referenced.\n-                        if incr_comp || referenced_somewhere.contains(&name_cstr) {\n-                            llvm::LLVMRustSetVisibility(val, llvm::Visibility::Hidden);\n-                        } else {\n-                            llvm::LLVMRustSetLinkage(val, llvm::Linkage::InternalLinkage);\n-                        }\n-\n-                        llvm::LLVMSetDLLStorageClass(val, llvm::DLLStorageClass::Default);\n-                        llvm::UnsetComdat(val);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n // Create a `__imp_<symbol> = &symbol` global for every public static `symbol`.\n // This is required to satisfy `dllimport` references to static data in .rlibs\n // when using MSVC linker.  We do this only for data, as linker can fix up\n@@ -992,15 +868,6 @@ fn iter_globals(llmod: llvm::ModuleRef) -> ValueIter {\n     }\n }\n \n-fn iter_functions(llmod: llvm::ModuleRef) -> ValueIter {\n-    unsafe {\n-        ValueIter {\n-            cur: llvm::LLVMGetFirstFunction(llmod),\n-            step: llvm::LLVMGetNextFunction,\n-        }\n-    }\n-}\n-\n /// The context provided lists a set of reachable ids as calculated by\n /// middle::reachable, but this contains far more ids and symbols than we're\n /// actually exposing from the object file. This function will filter the set in\n@@ -1063,20 +930,19 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let krate = tcx.hir.krate();\n \n     let ty::CrateAnalysis { reachable, .. } = analysis;\n-    let exported_symbols = find_exported_symbols(tcx, &reachable);\n \n     let check_overflow = tcx.sess.overflow_checks();\n \n     let link_meta = link::build_link_meta(incremental_hashes_map);\n \n+    let exported_symbol_node_ids = find_exported_symbols(tcx, &reachable);\n     let shared_ccx = SharedCrateContext::new(tcx,\n-                                             exported_symbols,\n                                              check_overflow,\n                                              output_filenames);\n     // Translate the metadata.\n     let (metadata_llcx, metadata_llmod, metadata) =\n         time(tcx.sess.time_passes(), \"write metadata\", || {\n-            write_metadata(tcx, &link_meta, shared_ccx.exported_symbols())\n+            write_metadata(tcx, &link_meta, &exported_symbol_node_ids)\n         });\n \n     let metadata_module = ModuleTranslation {\n@@ -1090,7 +956,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n \n-\n     // Skip crate items and just output metadata in -Z no-trans mode.\n     if tcx.sess.opts.debugging_opts.no_trans ||\n        !tcx.sess.opts.output_types.should_trans() {\n@@ -1110,10 +975,15 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         };\n     }\n \n+    let exported_symbols = Arc::new(ExportedSymbols::compute(tcx,\n+                                                             &exported_symbol_node_ids));\n+\n     // Run the translation item collector and partition the collected items into\n     // codegen units.\n     let (translation_items, codegen_units) =\n-        collect_and_partition_translation_items(&shared_ccx);\n+        collect_and_partition_translation_items(&shared_ccx, &exported_symbols);\n+\n+    let translation_items = Arc::new(translation_items);\n \n     let mut all_stats = Stats::default();\n     let modules: Vec<ModuleTranslation> = codegen_units\n@@ -1123,7 +993,9 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let ((stats, module), _) =\n                 tcx.dep_graph.with_task(dep_node,\n                                         AssertDepGraphSafe(&shared_ccx),\n-                                        AssertDepGraphSafe(cgu),\n+                                        AssertDepGraphSafe((cgu,\n+                                                            translation_items.clone(),\n+                                                            exported_symbols.clone())),\n                                         module_translation);\n             all_stats.extend(stats);\n             module\n@@ -1132,16 +1004,18 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     fn module_translation<'a, 'tcx>(\n         scx: AssertDepGraphSafe<&SharedCrateContext<'a, 'tcx>>,\n-        args: AssertDepGraphSafe<CodegenUnit<'tcx>>)\n+        args: AssertDepGraphSafe<(CodegenUnit<'tcx>,\n+                                  Arc<FxHashSet<TransItem<'tcx>>>,\n+                                  Arc<ExportedSymbols>)>)\n         -> (Stats, ModuleTranslation)\n     {\n         // FIXME(#40304): We ought to be using the id as a key and some queries, I think.\n         let AssertDepGraphSafe(scx) = scx;\n-        let AssertDepGraphSafe(cgu) = args;\n+        let AssertDepGraphSafe((cgu, crate_trans_items, exported_symbols)) = args;\n \n         let cgu_name = String::from(cgu.name());\n         let cgu_id = cgu.work_product_id();\n-        let symbol_name_hash = cgu.compute_symbol_name_hash(scx);\n+        let symbol_name_hash = cgu.compute_symbol_name_hash(scx, &exported_symbols);\n \n         // Check whether there is a previous work-product we can\n         // re-use.  Not only must the file exist, and the inputs not\n@@ -1176,13 +1050,13 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         // Instantiate translation items without filling out definitions yet...\n-        let lcx = LocalCrateContext::new(scx, cgu);\n+        let lcx = LocalCrateContext::new(scx, cgu, crate_trans_items, exported_symbols);\n         let module = {\n             let ccx = CrateContext::new(scx, &lcx);\n             let trans_items = ccx.codegen_unit()\n                                  .items_in_deterministic_order(ccx.tcx());\n-            for &(trans_item, linkage) in &trans_items {\n-                trans_item.predefine(&ccx, linkage);\n+            for &(trans_item, (linkage, visibility)) in &trans_items {\n+                trans_item.predefine(&ccx, linkage, visibility);\n             }\n \n             // ... and now that we have everything pre-defined, fill out those definitions.\n@@ -1272,8 +1146,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let sess = shared_ccx.sess();\n \n-    let exported_symbols = ExportedSymbols::compute(&shared_ccx);\n-\n     // Get the list of llvm modules we created. We'll do a few wacky\n     // transforms on them now.\n \n@@ -1285,16 +1157,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                })\n                .collect();\n \n-    // Now that we have all symbols that are exported from the CGUs of this\n-    // crate, we can run the `internalize_symbols` pass.\n-    time(shared_ccx.sess().time_passes(), \"internalize symbols\", || {\n-        internalize_symbols(sess,\n-                            &shared_ccx,\n-                            &translation_items,\n-                            &llvm_modules,\n-                            &exported_symbols);\n-    });\n-\n     if sess.target.target.options.is_like_msvc &&\n        sess.crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib) {\n         create_imps(sess, &llvm_modules);\n@@ -1355,7 +1217,8 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         allocator_module: allocator_module,\n         link: link_meta,\n         metadata: metadata,\n-        exported_symbols: exported_symbols,\n+        exported_symbols: Arc::try_unwrap(exported_symbols)\n+            .expect(\"There's still a reference to exported_symbols?\"),\n         no_builtins: no_builtins,\n         linker_info: linker_info,\n         windows_subsystem: windows_subsystem,\n@@ -1410,7 +1273,8 @@ fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trans_i\n     }\n }\n \n-fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>)\n+fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+                                                     exported_symbols: &ExportedSymbols)\n                                                      -> (FxHashSet<TransItem<'tcx>>,\n                                                          Vec<CodegenUnit<'tcx>>) {\n     let time_passes = scx.sess().time_passes();\n@@ -1437,7 +1301,9 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n \n     let (items, inlining_map) =\n         time(time_passes, \"translation item collection\", || {\n-            collector::collect_crate_translation_items(&scx, collection_mode)\n+            collector::collect_crate_translation_items(&scx,\n+                                                       exported_symbols,\n+                                                       collection_mode)\n     });\n \n     assert_symbols_are_distinct(scx.tcx(), items.iter());\n@@ -1452,7 +1318,8 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         partitioning::partition(scx,\n                                 items.iter().cloned(),\n                                 strategy,\n-                                &inlining_map)\n+                                &inlining_map,\n+                                exported_symbols)\n     });\n \n     assert!(scx.tcx().sess.opts.cg.codegen_units == codegen_units.len() ||\n@@ -1480,7 +1347,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n                 let mut cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);\n                 cgus.as_mut_slice().sort_by_key(|&(ref name, _)| name.clone());\n                 cgus.dedup();\n-                for &(ref cgu_name, linkage) in cgus.iter() {\n+                for &(ref cgu_name, (linkage, _)) in cgus.iter() {\n                     output.push_str(\" \");\n                     output.push_str(&cgu_name);\n "}, {"sha": "76f94565bae515cebdad2e6550c827cc908f8de1", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=e3c8433ebb4a1acf125cae34ebd910869c894ebd", "patch": "@@ -23,6 +23,7 @@ use monomorphize::{self, Instance};\n use rustc::hir::def_id::DefId;\n use rustc::ty::TypeFoldable;\n use rustc::ty::subst::Substs;\n+use trans_item::TransItem;\n use type_of;\n \n /// Translates a reference to a fn/method item, monomorphizing and\n@@ -99,19 +100,32 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let attrs = instance.def.attrs(ccx.tcx());\n         attributes::from_fn_attrs(ccx, &attrs, llfn);\n \n+        let instance_def_id = instance.def_id();\n+\n         // Perhaps questionable, but we assume that anything defined\n         // *in Rust code* may unwind. Foreign items like `extern \"C\" {\n         // fn foo(); }` are assumed not to unwind **unless** they have\n         // a `#[unwind]` attribute.\n-        if !tcx.is_foreign_item(instance.def_id()) {\n+        if !tcx.is_foreign_item(instance_def_id) {\n             attributes::unwind(llfn, true);\n-            unsafe {\n-                llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::ExternalLinkage);\n+        }\n+\n+        unsafe {\n+            llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::ExternalLinkage);\n+\n+            if ccx.crate_trans_items().contains(&TransItem::Fn(instance)) {\n+                if let Some(node_id) = tcx.hir.as_local_node_id(instance_def_id) {\n+                    if !ccx.exported_symbols().local_exports().contains(&node_id) {\n+                        llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n+                    }\n+                } else {\n+                    llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n+                }\n             }\n         }\n \n         if ccx.use_dll_storage_attrs() &&\n-            ccx.sess().cstore.is_dllimport_foreign_item(instance.def_id())\n+            ccx.sess().cstore.is_dllimport_foreign_item(instance_def_id)\n         {\n             unsafe {\n                 llvm::LLVMSetDLLStorageClass(llfn, llvm::DLLStorageClass::DllImport);"}, {"sha": "b31295f4022ed3580b333b8c0682712e413d537a", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 125, "deletions": 52, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=e3c8433ebb4a1acf125cae34ebd910869c894ebd", "patch": "@@ -208,6 +208,9 @@ use rustc::util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n \n use trans_item::{TransItem, DefPathBasedNames, InstantiationMode};\n \n+use rustc_data_structures::bitvec::BitVector;\n+use back::symbol_export::ExportedSymbols;\n+\n #[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n pub enum TransItemCollectionMode {\n     Eager,\n@@ -217,12 +220,16 @@ pub enum TransItemCollectionMode {\n /// Maps every translation item to all translation items it references in its\n /// body.\n pub struct InliningMap<'tcx> {\n-    // Maps a source translation item to a range of target translation items\n-    // that are potentially inlined by LLVM into the source.\n+    // Maps a source translation item to the range of translation items\n+    // accessed by it.\n     // The two numbers in the tuple are the start (inclusive) and\n     // end index (exclusive) within the `targets` vecs.\n     index: FxHashMap<TransItem<'tcx>, (usize, usize)>,\n     targets: Vec<TransItem<'tcx>>,\n+\n+    // Contains one bit per translation item in the `targets` field. That bit\n+    // is true if that translation item needs to be inlined into every CGU.\n+    inlines: BitVector,\n }\n \n impl<'tcx> InliningMap<'tcx> {\n@@ -231,43 +238,70 @@ impl<'tcx> InliningMap<'tcx> {\n         InliningMap {\n             index: FxHashMap(),\n             targets: Vec::new(),\n+            inlines: BitVector::new(1024),\n         }\n     }\n \n-    fn record_inlining_canditates<I>(&mut self,\n-                                     source: TransItem<'tcx>,\n-                                     targets: I)\n-        where I: Iterator<Item=TransItem<'tcx>>\n+    fn record_accesses<I>(&mut self,\n+                          source: TransItem<'tcx>,\n+                          new_targets: I)\n+        where I: Iterator<Item=(TransItem<'tcx>, bool)> + ExactSizeIterator\n     {\n         assert!(!self.index.contains_key(&source));\n \n         let start_index = self.targets.len();\n-        self.targets.extend(targets);\n+        let new_items_count = new_targets.len();\n+        let new_items_count_total = new_items_count + self.targets.len();\n+\n+        self.targets.reserve(new_items_count);\n+        self.inlines.grow(new_items_count_total);\n+\n+        for (i, (target, inline)) in new_targets.enumerate() {\n+            self.targets.push(target);\n+            if inline {\n+                self.inlines.insert(i + start_index);\n+            }\n+        }\n+\n         let end_index = self.targets.len();\n         self.index.insert(source, (start_index, end_index));\n     }\n \n     // Internally iterate over all items referenced by `source` which will be\n     // made available for inlining.\n     pub fn with_inlining_candidates<F>(&self, source: TransItem<'tcx>, mut f: F)\n-        where F: FnMut(TransItem<'tcx>) {\n-        if let Some(&(start_index, end_index)) = self.index.get(&source)\n-        {\n-            for candidate in &self.targets[start_index .. end_index] {\n-                f(*candidate)\n+        where F: FnMut(TransItem<'tcx>)\n+    {\n+        if let Some(&(start_index, end_index)) = self.index.get(&source) {\n+            for (i, candidate) in self.targets[start_index .. end_index]\n+                                      .iter()\n+                                      .enumerate() {\n+                if self.inlines.contains(start_index + i) {\n+                    f(*candidate);\n+                }\n             }\n         }\n     }\n+\n+    // Internally iterate over all items and the things each accesses.\n+    pub fn iter_accesses<F>(&self, mut f: F)\n+        where F: FnMut(TransItem<'tcx>, &[TransItem<'tcx>])\n+    {\n+        for (&accessor, &(start_index, end_index)) in &self.index {\n+            f(accessor, &self.targets[start_index .. end_index])\n+        }\n+    }\n }\n \n pub fn collect_crate_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+                                                 exported_symbols: &ExportedSymbols,\n                                                  mode: TransItemCollectionMode)\n                                                  -> (FxHashSet<TransItem<'tcx>>,\n                                                      InliningMap<'tcx>) {\n     // We are not tracking dependencies of this pass as it has to be re-executed\n     // every time no matter what.\n     scx.tcx().dep_graph.with_ignore(|| {\n-        let roots = collect_roots(scx, mode);\n+        let roots = collect_roots(scx, exported_symbols, mode);\n \n         debug!(\"Building translation item graph, beginning at roots\");\n         let mut visited = FxHashSet();\n@@ -289,6 +323,7 @@ pub fn collect_crate_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 't\n // Find all non-generic items by walking the HIR. These items serve as roots to\n // start monomorphizing from.\n fn collect_roots<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+                           exported_symbols: &ExportedSymbols,\n                            mode: TransItemCollectionMode)\n                            -> Vec<TransItem<'tcx>> {\n     debug!(\"Collecting roots\");\n@@ -298,6 +333,7 @@ fn collect_roots<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         let mut visitor = RootCollector {\n             scx: scx,\n             mode: mode,\n+            exported_symbols,\n             output: &mut roots,\n         };\n \n@@ -340,7 +376,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n \n             recursion_depth_reset = None;\n \n-            collect_neighbours(scx, instance, &mut neighbors);\n+            collect_neighbours(scx, instance, true, &mut neighbors);\n         }\n         TransItem::Fn(instance) => {\n             // Sanity check whether this ended up being collected accidentally\n@@ -352,14 +388,14 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n                                                                recursion_depths));\n             check_type_length_limit(scx.tcx(), instance);\n \n-            collect_neighbours(scx, instance, &mut neighbors);\n+            collect_neighbours(scx, instance, false, &mut neighbors);\n         }\n         TransItem::GlobalAsm(..) => {\n             recursion_depth_reset = None;\n         }\n     }\n \n-    record_inlining_canditates(scx.tcx(), starting_point, &neighbors[..], inlining_map);\n+    record_accesses(scx.tcx(), starting_point, &neighbors[..], inlining_map);\n \n     for neighbour in neighbors {\n         collect_items_rec(scx, neighbour, visited, recursion_depths, inlining_map);\n@@ -372,19 +408,20 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n     debug!(\"END collect_items_rec({})\", starting_point.to_string(scx.tcx()));\n }\n \n-fn record_inlining_canditates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn record_accesses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         caller: TransItem<'tcx>,\n                                         callees: &[TransItem<'tcx>],\n                                         inlining_map: &mut InliningMap<'tcx>) {\n     let is_inlining_candidate = |trans_item: &TransItem<'tcx>| {\n         trans_item.instantiation_mode(tcx) == InstantiationMode::LocalCopy\n     };\n \n-    let inlining_candidates = callees.into_iter()\n-                                     .map(|x| *x)\n-                                     .filter(is_inlining_candidate);\n+    let accesses = callees.into_iter()\n+                          .map(|trans_item| {\n+                             (*trans_item, is_inlining_candidate(trans_item))\n+                          });\n \n-    inlining_map.record_inlining_canditates(caller, inlining_candidates);\n+    inlining_map.record_accesses(caller, accesses);\n }\n \n fn check_recursion_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -459,7 +496,8 @@ struct MirNeighborCollector<'a, 'tcx: 'a> {\n     scx: &'a SharedCrateContext<'a, 'tcx>,\n     mir: &'a mir::Mir<'tcx>,\n     output: &'a mut Vec<TransItem<'tcx>>,\n-    param_substs: &'tcx Substs<'tcx>\n+    param_substs: &'tcx Substs<'tcx>,\n+    const_context: bool,\n }\n \n impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n@@ -540,7 +578,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             let substs = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n                                                                  &substs);\n             let instance = monomorphize::resolve(self.scx, def_id, substs);\n-            collect_neighbours(self.scx, instance, self.output);\n+            collect_neighbours(self.scx, instance, true, self.output);\n         }\n \n         self.super_constant(constant, location);\n@@ -557,7 +595,26 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             mir::TerminatorKind::Call { ref func, .. } => {\n                 let callee_ty = func.ty(self.mir, tcx);\n                 let callee_ty = tcx.trans_apply_param_substs(self.param_substs, &callee_ty);\n-                visit_fn_use(self.scx, callee_ty, true, &mut self.output);\n+\n+                let constness = match (self.const_context, &callee_ty.sty) {\n+                    (true, &ty::TyFnDef(def_id, substs)) if self.scx.tcx().is_const_fn(def_id) => {\n+                        let instance = monomorphize::resolve(self.scx, def_id, substs);\n+                        Some(instance)\n+                    }\n+                    _ => None\n+                };\n+\n+                if let Some(const_fn_instance) = constness {\n+                    // If this is a const fn, called from a const context, we\n+                    // have to visit its body in order to find any fn reifications\n+                    // it might contain.\n+                    collect_neighbours(self.scx,\n+                                       const_fn_instance,\n+                                       true,\n+                                       self.output);\n+                } else {\n+                    visit_fn_use(self.scx, callee_ty, true, &mut self.output);\n+                }\n             }\n             mir::TerminatorKind::Drop { ref location, .. } |\n             mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n@@ -576,6 +633,22 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n \n         self.super_terminator_kind(block, kind, location);\n     }\n+\n+    fn visit_static(&mut self,\n+                    static_: &mir::Static<'tcx>,\n+                    context: mir::visit::LvalueContext<'tcx>,\n+                    location: Location) {\n+        debug!(\"visiting static {:?} @ {:?}\", static_.def_id, location);\n+\n+        let tcx = self.scx.tcx();\n+        let instance = Instance::mono(tcx, static_.def_id);\n+        if should_trans_locally(tcx, &instance) {\n+            let node_id = tcx.hir.as_local_node_id(static_.def_id).unwrap();\n+            self.output.push(TransItem::Static(node_id));\n+        }\n+\n+        self.super_static(static_, context, location);\n+    }\n }\n \n fn visit_drop_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n@@ -795,6 +868,7 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n \n struct RootCollector<'b, 'a: 'b, 'tcx: 'a + 'b> {\n     scx: &'b SharedCrateContext<'a, 'tcx>,\n+    exported_symbols: &'b ExportedSymbols,\n     mode: TransItemCollectionMode,\n     output: &'b mut Vec<TransItem<'tcx>>,\n }\n@@ -850,14 +924,19 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                 // const items only generate translation items if they are\n                 // actually used somewhere. Just declaring them is insufficient.\n             }\n-            hir::ItemFn(.., ref generics, _) => {\n-                if !generics.is_type_parameterized() {\n-                    let def_id = self.scx.tcx().hir.local_def_id(item.id);\n+            hir::ItemFn(..) => {\n+                let tcx = self.scx.tcx();\n+                let def_id = tcx.hir.local_def_id(item.id);\n+\n+                if (self.mode == TransItemCollectionMode::Eager ||\n+                    !tcx.is_const_fn(def_id) ||\n+                    self.exported_symbols.local_exports().contains(&item.id)) &&\n+                   !item_has_type_parameters(tcx, def_id) {\n \n                     debug!(\"RootCollector: ItemFn({})\",\n-                           def_id_to_string(self.scx.tcx(), def_id));\n+                           def_id_to_string(tcx, def_id));\n \n-                    let instance = Instance::mono(self.scx.tcx(), def_id);\n+                    let instance = Instance::mono(tcx, def_id);\n                     self.output.push(TransItem::Fn(instance));\n                 }\n             }\n@@ -871,31 +950,18 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n \n     fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n         match ii.node {\n-            hir::ImplItemKind::Method(hir::MethodSig {\n-                ref generics,\n-                ..\n-            }, _) => {\n-                let hir_map = &self.scx.tcx().hir;\n-                let parent_node_id = hir_map.get_parent_node(ii.id);\n-                let is_impl_generic = match hir_map.expect_item(parent_node_id) {\n-                    &hir::Item {\n-                        node: hir::ItemImpl(_, _, _, ref generics, ..),\n-                        ..\n-                    } => {\n-                        generics.is_type_parameterized()\n-                    }\n-                    _ => {\n-                        bug!()\n-                    }\n-                };\n-\n-                if !generics.is_type_parameterized() && !is_impl_generic {\n-                    let def_id = self.scx.tcx().hir.local_def_id(ii.id);\n+            hir::ImplItemKind::Method(hir::MethodSig { .. }, _) => {\n+                let tcx = self.scx.tcx();\n+                let def_id = tcx.hir.local_def_id(ii.id);\n \n+                if (self.mode == TransItemCollectionMode::Eager ||\n+                    !tcx.is_const_fn(def_id) ||\n+                    self.exported_symbols.local_exports().contains(&ii.id)) &&\n+                   !item_has_type_parameters(tcx, def_id) {\n                     debug!(\"RootCollector: MethodImplItem({})\",\n-                           def_id_to_string(self.scx.tcx(), def_id));\n+                           def_id_to_string(tcx, def_id));\n \n-                    let instance = Instance::mono(self.scx.tcx(), def_id);\n+                    let instance = Instance::mono(tcx, def_id);\n                     self.output.push(TransItem::Fn(instance));\n                 }\n             }\n@@ -904,6 +970,11 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n     }\n }\n \n+fn item_has_type_parameters<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n+    let generics = tcx.generics_of(def_id);\n+    generics.parent_types as usize + generics.types.len() > 0\n+}\n+\n fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                                   item: &'tcx hir::Item,\n                                                   output: &mut Vec<TransItem<'tcx>>) {\n@@ -958,6 +1029,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n /// Scan the MIR in order to find function calls, closures, and drop-glue\n fn collect_neighbours<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                 instance: Instance<'tcx>,\n+                                const_context: bool,\n                                 output: &mut Vec<TransItem<'tcx>>)\n {\n     let mir = scx.tcx().instance_mir(instance.def);\n@@ -966,7 +1038,8 @@ fn collect_neighbours<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         scx: scx,\n         mir: &mir,\n         output: output,\n-        param_substs: instance.substs\n+        param_substs: instance.substs,\n+        const_context,\n     };\n \n     visitor.visit_mir(&mir);"}, {"sha": "da2a58398634e05c26dc03ae2aae09dc551afa35", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=e3c8433ebb4a1acf125cae34ebd910869c894ebd", "patch": "@@ -104,6 +104,12 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n \n                 let g = declare::define_global(ccx, &sym[..], llty).unwrap();\n \n+                if !ccx.exported_symbols().local_exports().contains(&id) {\n+                    unsafe {\n+                        llvm::LLVMRustSetVisibility(g, llvm::Visibility::Hidden);\n+                    }\n+                }\n+\n                 (g, attrs)\n             }\n \n@@ -243,8 +249,16 @@ pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let name_str_ref = CStr::from_ptr(llvm::LLVMGetValueName(g));\n             let name_string = CString::new(name_str_ref.to_bytes()).unwrap();\n             llvm::LLVMSetValueName(g, empty_string.as_ptr());\n+\n+            let linkage = llvm::LLVMRustGetLinkage(g);\n+            let visibility = llvm::LLVMRustGetVisibility(g);\n+\n             let new_g = llvm::LLVMRustGetOrInsertGlobal(\n                 ccx.llmod(), name_string.as_ptr(), val_llty.to_ref());\n+\n+            llvm::LLVMRustSetLinkage(new_g, linkage);\n+            llvm::LLVMRustSetVisibility(new_g, visibility);\n+\n             // To avoid breaking any invariants, we leave around the old\n             // global for the moment; we'll replace all references to it\n             // with the new global later. (See base::trans_crate.)"}, {"sha": "bec39e3cde6d0d2f935d3b7f063222389288c49c", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=e3c8433ebb4a1acf125cae34ebd910869c894ebd", "patch": "@@ -16,25 +16,28 @@ use rustc::hir::def_id::DefId;\n use rustc::traits;\n use debuginfo;\n use callee;\n+use back::symbol_export::ExportedSymbols;\n use base;\n use declare;\n use monomorphize::Instance;\n \n use partitioning::CodegenUnit;\n+use trans_item::TransItem;\n use type_::Type;\n use rustc_data_structures::base_n;\n use rustc::session::config::{self, NoDebugInfo, OutputFilenames};\n use rustc::session::Session;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{LayoutCx, LayoutError, LayoutTyper, TyLayout};\n-use rustc::util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n+use rustc::util::nodemap::{DefIdMap, FxHashMap, FxHashSet};\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n use std::ptr;\n use std::iter;\n use std::str;\n+use std::sync::Arc;\n use std::marker::PhantomData;\n use syntax::ast;\n use syntax::symbol::InternedString;\n@@ -76,7 +79,6 @@ impl Stats {\n /// crate, so it must not contain references to any LLVM data structures\n /// (aside from metadata-related ones).\n pub struct SharedCrateContext<'a, 'tcx: 'a> {\n-    exported_symbols: NodeSet,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     check_overflow: bool,\n \n@@ -94,6 +96,13 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     llcx: ContextRef,\n     stats: Stats,\n     codegen_unit: CodegenUnit<'tcx>,\n+\n+    /// The translation items of the whole crate.\n+    crate_trans_items: Arc<FxHashSet<TransItem<'tcx>>>,\n+\n+    /// Information about which symbols are exported from the crate.\n+    exported_symbols: Arc<ExportedSymbols>,\n+\n     /// Cache instances of monomorphic and polymorphic items\n     instances: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n     /// Cache generated vtables\n@@ -265,7 +274,6 @@ pub unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (Cont\n \n impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     pub fn new(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-               exported_symbols: NodeSet,\n                check_overflow: bool,\n                output_filenames: &'b OutputFilenames)\n                -> SharedCrateContext<'b, 'tcx> {\n@@ -315,7 +323,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         let use_dll_storage_attrs = tcx.sess.target.target.options.is_like_msvc;\n \n         SharedCrateContext {\n-            exported_symbols: exported_symbols,\n             tcx: tcx,\n             check_overflow: check_overflow,\n             use_dll_storage_attrs: use_dll_storage_attrs,\n@@ -335,10 +342,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         ty.is_freeze(self.tcx, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP)\n     }\n \n-    pub fn exported_symbols<'a>(&'a self) -> &'a NodeSet {\n-        &self.exported_symbols\n-    }\n-\n     pub fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.tcx\n     }\n@@ -362,7 +365,9 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n \n impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n     pub fn new(shared: &SharedCrateContext<'a, 'tcx>,\n-               codegen_unit: CodegenUnit<'tcx>)\n+               codegen_unit: CodegenUnit<'tcx>,\n+               crate_trans_items: Arc<FxHashSet<TransItem<'tcx>>>,\n+               exported_symbols: Arc<ExportedSymbols>,)\n                -> LocalCrateContext<'a, 'tcx> {\n         unsafe {\n             // Append \".rs\" to LLVM module identifier.\n@@ -394,6 +399,8 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                 llcx: llcx,\n                 stats: Stats::default(),\n                 codegen_unit: codegen_unit,\n+                crate_trans_items,\n+                exported_symbols,\n                 instances: RefCell::new(FxHashMap()),\n                 vtables: RefCell::new(FxHashMap()),\n                 const_cstr_cache: RefCell::new(FxHashMap()),\n@@ -504,6 +511,14 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().codegen_unit\n     }\n \n+    pub fn crate_trans_items(&self) -> &FxHashSet<TransItem<'tcx>> {\n+        &self.local().crate_trans_items\n+    }\n+\n+    pub fn exported_symbols(&self) -> &ExportedSymbols {\n+        &self.local().exported_symbols\n+    }\n+\n     pub fn td(&self) -> llvm::TargetDataRef {\n         unsafe { llvm::LLVMRustGetModuleDataLayout(self.llmod()) }\n     }"}, {"sha": "6df509f34a472d16a93dbb5572f6aa16ee52ac85", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=e3c8433ebb4a1acf125cae34ebd910869c894ebd", "patch": "@@ -37,7 +37,7 @@ pub fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n     // visible). It might better to use the `exported_items` set from\n     // `driver::CrateAnalysis` in the future, but (atm) this set is not\n     // available in the translation pass.\n-    !cx.shared().exported_symbols().contains(&node_id)\n+    !cx.exported_symbols().local_exports().contains(&node_id)\n }\n \n #[allow(non_snake_case)]"}, {"sha": "7518948323b8b487987739ad4ece074f92ac5572", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 204, "deletions": 33, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=e3c8433ebb4a1acf125cae34ebd910869c894ebd", "patch": "@@ -102,6 +102,7 @@\n //! source-level module, functions from the same module will be available for\n //! inlining, even when they are not marked #[inline].\n \n+use back::symbol_export::ExportedSymbols;\n use collector::InliningMap;\n use common;\n use context::SharedCrateContext;\n@@ -110,14 +111,15 @@ use rustc::dep_graph::{DepNode, WorkProductId};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use rustc::session::config::NUMBERED_CODEGEN_UNIT_MARKER;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, InstanceDef};\n use rustc::ty::item_path::characteristic_def_id_of_type;\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_incremental::IchHasher;\n+use std::collections::hash_map::Entry;\n use std::hash::Hash;\n use syntax::ast::NodeId;\n use syntax::symbol::{Symbol, InternedString};\n use trans_item::{TransItem, InstantiationMode};\n-use rustc::util::nodemap::{FxHashMap, FxHashSet};\n \n pub enum PartitioningStrategy {\n     /// Generate one codegen unit per source-level module.\n@@ -134,16 +136,16 @@ pub struct CodegenUnit<'tcx> {\n     /// as well as the crate name and disambiguator.\n     name: InternedString,\n \n-    items: FxHashMap<TransItem<'tcx>, llvm::Linkage>,\n+    items: FxHashMap<TransItem<'tcx>, (llvm::Linkage, llvm::Visibility)>,\n }\n \n impl<'tcx> CodegenUnit<'tcx> {\n     pub fn new(name: InternedString,\n-               items: FxHashMap<TransItem<'tcx>, llvm::Linkage>)\n+               items: FxHashMap<TransItem<'tcx>, (llvm::Linkage, llvm::Visibility)>)\n                -> Self {\n         CodegenUnit {\n-            name: name,\n-            items: items,\n+            name,\n+            items,\n         }\n     }\n \n@@ -159,7 +161,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n         &self.name\n     }\n \n-    pub fn items(&self) -> &FxHashMap<TransItem<'tcx>, llvm::Linkage> {\n+    pub fn items(&self) -> &FxHashMap<TransItem<'tcx>, (llvm::Linkage, llvm::Visibility)> {\n         &self.items\n     }\n \n@@ -172,10 +174,11 @@ impl<'tcx> CodegenUnit<'tcx> {\n     }\n \n     pub fn compute_symbol_name_hash<'a>(&self,\n-                                        scx: &SharedCrateContext<'a, 'tcx>)\n+                                        scx: &SharedCrateContext<'a, 'tcx>,\n+                                        exported_symbols: &ExportedSymbols)\n                                         -> u64 {\n         let mut state = IchHasher::new();\n-        let exported_symbols = scx.exported_symbols();\n+        let exported_symbols = exported_symbols.local_exports();\n         let all_items = self.items_in_deterministic_order(scx.tcx());\n         for (item, _) in all_items {\n             let symbol_name = item.symbol_name(scx.tcx());\n@@ -200,7 +203,8 @@ impl<'tcx> CodegenUnit<'tcx> {\n \n     pub fn items_in_deterministic_order<'a>(&self,\n                                             tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                            -> Vec<(TransItem<'tcx>, llvm::Linkage)> {\n+                                            -> Vec<(TransItem<'tcx>,\n+                                                   (llvm::Linkage, llvm::Visibility))> {\n         // The codegen tests rely on items being process in the same order as\n         // they appear in the file, so for local items, we sort by node_id first\n         #[derive(PartialEq, Eq, PartialOrd, Ord)]\n@@ -233,7 +237,8 @@ const FALLBACK_CODEGEN_UNIT: &'static str = \"__rustc_fallback_codegen_unit\";\n pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n                               trans_items: I,\n                               strategy: PartitioningStrategy,\n-                              inlining_map: &InliningMap<'tcx>)\n+                              inlining_map: &InliningMap<'tcx>,\n+                              exported_symbols: &ExportedSymbols)\n                               -> Vec<CodegenUnit<'tcx>>\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n@@ -243,6 +248,7 @@ pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     // respective 'home' codegen unit. Regular translation items are all\n     // functions and statics defined in the local crate.\n     let mut initial_partitioning = place_root_translation_items(scx,\n+                                                                exported_symbols,\n                                                                 trans_items);\n \n     debug_dump(tcx, \"INITIAL PARTITONING:\", initial_partitioning.codegen_units.iter());\n@@ -259,13 +265,22 @@ pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     // translation items have to go into each codegen unit. These additional\n     // translation items can be drop-glue, functions from external crates, and\n     // local functions the definition of which is marked with #[inline].\n-    let post_inlining = place_inlined_translation_items(initial_partitioning,\n-                                                        inlining_map);\n+    let mut post_inlining = place_inlined_translation_items(initial_partitioning,\n+                                                            inlining_map);\n+\n+    debug_dump(tcx, \"POST INLINING:\", post_inlining.codegen_units.iter());\n \n-    debug_dump(tcx, \"POST INLINING:\", post_inlining.0.iter());\n+    // Next we try to make as many symbols \"internal\" as possible, so LLVM has\n+    // more freedom to optimize.\n+    internalize_symbols(tcx, &mut post_inlining, inlining_map);\n \n     // Finally, sort by codegen unit name, so that we get deterministic results\n-    let mut result = post_inlining.0;\n+    let PostInliningPartitioning {\n+        codegen_units: mut result,\n+        trans_item_placements: _,\n+        internalization_candidates: _,\n+    } = post_inlining;\n+\n     result.sort_by(|cgu1, cgu2| {\n         (&cgu1.name[..]).cmp(&cgu2.name[..])\n     });\n@@ -284,19 +299,37 @@ pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n struct PreInliningPartitioning<'tcx> {\n     codegen_units: Vec<CodegenUnit<'tcx>>,\n     roots: FxHashSet<TransItem<'tcx>>,\n+    internalization_candidates: FxHashSet<TransItem<'tcx>>,\n }\n \n-struct PostInliningPartitioning<'tcx>(Vec<CodegenUnit<'tcx>>);\n+/// For symbol internalization, we need to know whether a symbol/trans-item is\n+/// accessed from outside the codegen unit it is defined in. This type is used\n+/// to keep track of that.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+enum TransItemPlacement {\n+    SingleCgu { cgu_name: InternedString },\n+    MultipleCgus,\n+}\n+\n+struct PostInliningPartitioning<'tcx> {\n+    codegen_units: Vec<CodegenUnit<'tcx>>,\n+    trans_item_placements: FxHashMap<TransItem<'tcx>, TransItemPlacement>,\n+    internalization_candidates: FxHashSet<TransItem<'tcx>>,\n+}\n \n fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n+                                             exported_symbols: &ExportedSymbols,\n                                              trans_items: I)\n                                              -> PreInliningPartitioning<'tcx>\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n     let tcx = scx.tcx();\n+    let exported_symbols = exported_symbols.local_exports();\n+\n     let mut roots = FxHashSet();\n     let mut codegen_units = FxHashMap();\n     let is_incremental_build = tcx.sess.opts.incremental.is_some();\n+    let mut internalization_candidates = FxHashSet();\n \n     for trans_item in trans_items {\n         let is_root = trans_item.instantiation_mode(tcx) == InstantiationMode::GloballyShared;\n@@ -318,18 +351,52 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n             let mut codegen_unit = codegen_units.entry(codegen_unit_name.clone())\n                                                 .or_insert_with(make_codegen_unit);\n \n-            let linkage = match trans_item.explicit_linkage(tcx) {\n-                Some(explicit_linkage) => explicit_linkage,\n+            let (linkage, visibility) = match trans_item.explicit_linkage(tcx) {\n+                Some(explicit_linkage) => (explicit_linkage, llvm::Visibility::Default),\n                 None => {\n                     match trans_item {\n-                        TransItem::Fn(..) |\n-                        TransItem::Static(..) |\n-                        TransItem::GlobalAsm(..) => llvm::ExternalLinkage,\n+                        TransItem::Fn(ref instance) => {\n+                            let visibility = match instance.def {\n+                                InstanceDef::Item(def_id) => {\n+                                    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n+                                        if exported_symbols.contains(&node_id) {\n+                                            llvm::Visibility::Default\n+                                        } else {\n+                                            internalization_candidates.insert(trans_item);\n+                                            llvm::Visibility::Hidden\n+                                        }\n+                                    } else {\n+                                        internalization_candidates.insert(trans_item);\n+                                        llvm::Visibility::Hidden\n+                                    }\n+                                }\n+                                InstanceDef::FnPtrShim(..) |\n+                                InstanceDef::Virtual(..) |\n+                                InstanceDef::Intrinsic(..) |\n+                                InstanceDef::ClosureOnceShim { .. } |\n+                                InstanceDef::DropGlue(..) => {\n+                                    bug!(\"partitioning: Encountered unexpected\n+                                          root translation item: {:?}\",\n+                                          trans_item)\n+                                }\n+                            };\n+                            (llvm::ExternalLinkage, visibility)\n+                        }\n+                        TransItem::Static(node_id) |\n+                        TransItem::GlobalAsm(node_id) => {\n+                            let visibility = if exported_symbols.contains(&node_id) {\n+                                llvm::Visibility::Default\n+                            } else {\n+                                internalization_candidates.insert(trans_item);\n+                                llvm::Visibility::Hidden\n+                            };\n+                            (llvm::ExternalLinkage, visibility)\n+                        }\n                     }\n                 }\n             };\n \n-            codegen_unit.items.insert(trans_item, linkage);\n+            codegen_unit.items.insert(trans_item, (linkage, visibility));\n             roots.insert(trans_item);\n         }\n     }\n@@ -338,15 +405,16 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     // crate with just types (for example), we could wind up with no CGU\n     if codegen_units.is_empty() {\n         let codegen_unit_name = Symbol::intern(FALLBACK_CODEGEN_UNIT).as_str();\n-        codegen_units.entry(codegen_unit_name.clone())\n-                     .or_insert_with(|| CodegenUnit::empty(codegen_unit_name.clone()));\n+        codegen_units.insert(codegen_unit_name.clone(),\n+                             CodegenUnit::empty(codegen_unit_name.clone()));\n     }\n \n     PreInliningPartitioning {\n         codegen_units: codegen_units.into_iter()\n                                     .map(|(_, codegen_unit)| codegen_unit)\n                                     .collect(),\n-        roots: roots,\n+        roots,\n+        internalization_candidates,\n     }\n }\n \n@@ -388,37 +456,75 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n                                          inlining_map: &InliningMap<'tcx>)\n                                          -> PostInliningPartitioning<'tcx> {\n     let mut new_partitioning = Vec::new();\n+    let mut trans_item_placements = FxHashMap();\n+\n+    let PreInliningPartitioning {\n+        codegen_units: initial_cgus,\n+        roots,\n+        internalization_candidates,\n+    } = initial_partitioning;\n \n-    for codegen_unit in &initial_partitioning.codegen_units[..] {\n+    let single_codegen_unit = initial_cgus.len() == 1;\n+\n+    for old_codegen_unit in initial_cgus {\n         // Collect all items that need to be available in this codegen unit\n         let mut reachable = FxHashSet();\n-        for root in codegen_unit.items.keys() {\n+        for root in old_codegen_unit.items.keys() {\n             follow_inlining(*root, inlining_map, &mut reachable);\n         }\n \n-        let mut new_codegen_unit =\n-            CodegenUnit::empty(codegen_unit.name.clone());\n+        let mut new_codegen_unit = CodegenUnit {\n+            name: old_codegen_unit.name,\n+            items: FxHashMap(),\n+        };\n \n         // Add all translation items that are not already there\n         for trans_item in reachable {\n-            if let Some(linkage) = codegen_unit.items.get(&trans_item) {\n+            if let Some(linkage) = old_codegen_unit.items.get(&trans_item) {\n                 // This is a root, just copy it over\n                 new_codegen_unit.items.insert(trans_item, *linkage);\n             } else {\n-                if initial_partitioning.roots.contains(&trans_item) {\n+                if roots.contains(&trans_item) {\n                     bug!(\"GloballyShared trans-item inlined into other CGU: \\\n                           {:?}\", trans_item);\n                 }\n \n                 // This is a cgu-private copy\n-                new_codegen_unit.items.insert(trans_item, llvm::InternalLinkage);\n+                new_codegen_unit.items.insert(trans_item,\n+                                              (llvm::InternalLinkage, llvm::Visibility::Default));\n+            }\n+\n+            if !single_codegen_unit {\n+                // If there is more than one codegen unit, we need to keep track\n+                // in which codegen units each translation item is placed:\n+                match trans_item_placements.entry(trans_item) {\n+                    Entry::Occupied(e) => {\n+                        let placement = e.into_mut();\n+                        debug_assert!(match *placement {\n+                            TransItemPlacement::SingleCgu { ref cgu_name } => {\n+                                *cgu_name != new_codegen_unit.name\n+                            }\n+                            TransItemPlacement::MultipleCgus => true,\n+                        });\n+                        *placement = TransItemPlacement::MultipleCgus;\n+                    }\n+                    Entry::Vacant(e) => {\n+                        e.insert(TransItemPlacement::SingleCgu {\n+                            cgu_name: new_codegen_unit.name.clone()\n+                        });\n+                    }\n+                }\n             }\n         }\n \n         new_partitioning.push(new_codegen_unit);\n     }\n \n-    return PostInliningPartitioning(new_partitioning);\n+    return PostInliningPartitioning {\n+        codegen_units: new_partitioning,\n+        trans_item_placements,\n+        internalization_candidates,\n+    };\n \n     fn follow_inlining<'tcx>(trans_item: TransItem<'tcx>,\n                              inlining_map: &InliningMap<'tcx>,\n@@ -433,6 +539,71 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n     }\n }\n \n+fn internalize_symbols<'a, 'tcx>(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 partitioning: &mut PostInliningPartitioning<'tcx>,\n+                                 inlining_map: &InliningMap<'tcx>) {\n+    if partitioning.codegen_units.len() == 1 {\n+        // Fast path for when there is only one codegen unit. In this case we\n+        // can internalize all candidates, since there is nowhere else they\n+        // could be accessed from.\n+        for cgu in &mut partitioning.codegen_units {\n+            for candidate in &partitioning.internalization_candidates {\n+                cgu.items.insert(*candidate, (llvm::InternalLinkage,\n+                                              llvm::Visibility::Default));\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    // Build a map from every translation item to all the translation items that\n+    // reference it.\n+    let mut accessor_map: FxHashMap<TransItem<'tcx>, Vec<TransItem<'tcx>>> = FxHashMap();\n+    inlining_map.iter_accesses(|accessor, accessees| {\n+        for accessee in accessees {\n+            accessor_map.entry(*accessee)\n+                        .or_insert(Vec::new())\n+                        .push(accessor);\n+        }\n+    });\n+\n+    let trans_item_placements = &partitioning.trans_item_placements;\n+\n+    // For each internalization candidates in each codegen unit, check if it is\n+    // accessed from outside its defining codegen unit.\n+    for cgu in &mut partitioning.codegen_units {\n+        let home_cgu = TransItemPlacement::SingleCgu {\n+            cgu_name: cgu.name.clone()\n+        };\n+\n+        for (accessee, linkage_and_visibility) in &mut cgu.items {\n+            if !partitioning.internalization_candidates.contains(accessee) {\n+                // This item is no candidate for internalizing, so skip it.\n+                continue\n+            }\n+            debug_assert_eq!(trans_item_placements[accessee], home_cgu);\n+\n+            if let Some(accessors) = accessor_map.get(accessee) {\n+                if accessors.iter()\n+                            .filter_map(|accessor| {\n+                                // Some accessors might not have been\n+                                // instantiated. We can safely ignore those.\n+                                trans_item_placements.get(accessor)\n+                            })\n+                            .any(|placement| *placement != home_cgu) {\n+                    // Found an accessor from another CGU, so skip to the next\n+                    // item without marking this one as internal.\n+                    continue\n+                }\n+            }\n+\n+            // If we got here, we did not find any accesses from other CGUs,\n+            // so it's fine to make this translation item internal.\n+            *linkage_and_visibility = (llvm::InternalLinkage, llvm::Visibility::Default);\n+        }\n+    }\n+}\n+\n fn characteristic_def_id_of_trans_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                                  trans_item: TransItem<'tcx>)\n                                                  -> Option<DefId> {"}, {"sha": "b94fd13c3a4a29e84f7fdcfd8d5451a732338601", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=e3c8433ebb4a1acf125cae34ebd910869c894ebd", "patch": "@@ -99,7 +99,8 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n     pub fn predefine(&self,\n                      ccx: &CrateContext<'a, 'tcx>,\n-                     linkage: llvm::Linkage) {\n+                     linkage: llvm::Linkage,\n+                     visibility: llvm::Visibility) {\n         debug!(\"BEGIN PREDEFINING '{} ({})' in cgu {}\",\n                self.to_string(ccx.tcx()),\n                self.to_raw_string(),\n@@ -111,10 +112,10 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n         match *self {\n             TransItem::Static(node_id) => {\n-                TransItem::predefine_static(ccx, node_id, linkage, &symbol_name);\n+                TransItem::predefine_static(ccx, node_id, linkage, visibility, &symbol_name);\n             }\n             TransItem::Fn(instance) => {\n-                TransItem::predefine_fn(ccx, instance, linkage, &symbol_name);\n+                TransItem::predefine_fn(ccx, instance, linkage, visibility, &symbol_name);\n             }\n             TransItem::GlobalAsm(..) => {}\n         }\n@@ -128,6 +129,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n     fn predefine_static(ccx: &CrateContext<'a, 'tcx>,\n                         node_id: ast::NodeId,\n                         linkage: llvm::Linkage,\n+                        visibility: llvm::Visibility,\n                         symbol_name: &str) {\n         let def_id = ccx.tcx().hir.local_def_id(node_id);\n         let instance = Instance::mono(ccx.tcx(), def_id);\n@@ -139,7 +141,10 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                 &format!(\"symbol `{}` is already defined\", symbol_name))\n         });\n \n-        unsafe { llvm::LLVMRustSetLinkage(g, linkage) };\n+        unsafe {\n+            llvm::LLVMRustSetLinkage(g, linkage);\n+            llvm::LLVMRustSetVisibility(g, visibility);\n+        }\n \n         ccx.instances().borrow_mut().insert(instance, g);\n         ccx.statics().borrow_mut().insert(g, def_id);\n@@ -148,6 +153,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n     fn predefine_fn(ccx: &CrateContext<'a, 'tcx>,\n                     instance: Instance<'tcx>,\n                     linkage: llvm::Linkage,\n+                    visibility: llvm::Visibility,\n                     symbol_name: &str) {\n         assert!(!instance.substs.needs_infer() &&\n                 !instance.substs.has_param_types());\n@@ -172,6 +178,10 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             unsafe {\n                 llvm::LLVMRustSetVisibility(lldecl, llvm::Visibility::Hidden);\n             }\n+        } else {\n+            unsafe {\n+                llvm::LLVMRustSetVisibility(lldecl, visibility);\n+            }\n         }\n \n         debug!(\"predefine_fn: mono_ty = {:?} instance = {:?}\", mono_ty, instance);"}, {"sha": "4e6ae167024e3986560328c39142ab9143364004", "filename": "src/test/codegen-units/partitioning/extern-drop-glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs?ref=e3c8433ebb4a1acf125cae34ebd910869c894ebd", "patch": "@@ -24,7 +24,7 @@ extern crate cgu_extern_drop_glue;\n \n struct LocalStruct(cgu_extern_drop_glue::Struct);\n \n-//~ TRANS_ITEM fn extern_drop_glue::user[0] @@ extern_drop_glue[External]\n+//~ TRANS_ITEM fn extern_drop_glue::user[0] @@ extern_drop_glue[Internal]\n fn user()\n {\n     //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<extern_drop_glue::LocalStruct[0]> @@ extern_drop_glue[Internal]\n@@ -36,7 +36,7 @@ mod mod1 {\n \n     struct LocalStruct(cgu_extern_drop_glue::Struct);\n \n-    //~ TRANS_ITEM fn extern_drop_glue::mod1[0]::user[0] @@ extern_drop_glue-mod1[External]\n+    //~ TRANS_ITEM fn extern_drop_glue::mod1[0]::user[0] @@ extern_drop_glue-mod1[Internal]\n     fn user()\n     {\n         //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<extern_drop_glue::mod1[0]::LocalStruct[0]> @@ extern_drop_glue-mod1[Internal]"}, {"sha": "bdb31265e2fb2e14692fad0d841def04eaac321e", "filename": "src/test/codegen-units/partitioning/extern-generic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs?ref=e3c8433ebb4a1acf125cae34ebd910869c894ebd", "patch": "@@ -19,23 +19,23 @@\n // aux-build:cgu_generic_function.rs\n extern crate cgu_generic_function;\n \n-//~ TRANS_ITEM fn extern_generic::user[0] @@ extern_generic[External]\n+//~ TRANS_ITEM fn extern_generic::user[0] @@ extern_generic[Internal]\n fn user() {\n     let _ = cgu_generic_function::foo(\"abc\");\n }\n \n mod mod1 {\n     use cgu_generic_function;\n \n-    //~ TRANS_ITEM fn extern_generic::mod1[0]::user[0] @@ extern_generic-mod1[External]\n+    //~ TRANS_ITEM fn extern_generic::mod1[0]::user[0] @@ extern_generic-mod1[Internal]\n     fn user() {\n         let _ = cgu_generic_function::foo(\"abc\");\n     }\n \n     mod mod1 {\n         use cgu_generic_function;\n \n-        //~ TRANS_ITEM fn extern_generic::mod1[0]::mod1[0]::user[0] @@ extern_generic-mod1-mod1[External]\n+        //~ TRANS_ITEM fn extern_generic::mod1[0]::mod1[0]::user[0] @@ extern_generic-mod1-mod1[Internal]\n         fn user() {\n             let _ = cgu_generic_function::foo(\"abc\");\n         }\n@@ -45,18 +45,18 @@ mod mod1 {\n mod mod2 {\n     use cgu_generic_function;\n \n-    //~ TRANS_ITEM fn extern_generic::mod2[0]::user[0] @@ extern_generic-mod2[External]\n+    //~ TRANS_ITEM fn extern_generic::mod2[0]::user[0] @@ extern_generic-mod2[Internal]\n     fn user() {\n         let _ = cgu_generic_function::foo(\"abc\");\n     }\n }\n \n mod mod3 {\n-    //~ TRANS_ITEM fn extern_generic::mod3[0]::non_user[0] @@ extern_generic-mod3[External]\n+    //~ TRANS_ITEM fn extern_generic::mod3[0]::non_user[0] @@ extern_generic-mod3[Internal]\n     fn non_user() {}\n }\n \n // Make sure the two generic functions from the extern crate get instantiated\n // once for the current crate\n //~ TRANS_ITEM fn cgu_generic_function::foo[0]<&str> @@ cgu_generic_function.volatile[External]\n-//~ TRANS_ITEM fn cgu_generic_function::bar[0]<&str> @@ cgu_generic_function.volatile[External]\n+//~ TRANS_ITEM fn cgu_generic_function::bar[0]<&str> @@ cgu_generic_function.volatile[Internal]"}, {"sha": "20920c9ebe432d63ff0d8d0da52d1f2f232d542e", "filename": "src/test/codegen-units/partitioning/inlining-from-extern-crate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Finlining-from-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Finlining-from-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Finlining-from-extern-crate.rs?ref=e3c8433ebb4a1acf125cae34ebd910869c894ebd", "patch": "@@ -37,7 +37,7 @@ pub fn user()\n mod mod1 {\n     use cgu_explicit_inlining;\n \n-    //~ TRANS_ITEM fn inlining_from_extern_crate::mod1[0]::user[0] @@ inlining_from_extern_crate-mod1[External]\n+    //~ TRANS_ITEM fn inlining_from_extern_crate::mod1[0]::user[0] @@ inlining_from_extern_crate-mod1[Internal]\n     pub fn user()\n     {\n         cgu_explicit_inlining::inlined();\n@@ -50,7 +50,7 @@ mod mod1 {\n mod mod2 {\n     use cgu_explicit_inlining;\n \n-    //~ TRANS_ITEM fn inlining_from_extern_crate::mod2[0]::user[0] @@ inlining_from_extern_crate-mod2[External]\n+    //~ TRANS_ITEM fn inlining_from_extern_crate::mod2[0]::user[0] @@ inlining_from_extern_crate-mod2[Internal]\n     pub fn user()\n     {\n         cgu_explicit_inlining::always_inlined();"}, {"sha": "d2ce847e108f0bf0345d6d57c917c3f4f0ef7f01", "filename": "src/test/codegen-units/partitioning/local-drop-glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs?ref=e3c8433ebb4a1acf125cae34ebd910869c894ebd", "patch": "@@ -31,7 +31,7 @@ struct Outer {\n     _a: Struct\n }\n \n-//~ TRANS_ITEM fn local_drop_glue::user[0] @@ local_drop_glue[External]\n+//~ TRANS_ITEM fn local_drop_glue::user[0] @@ local_drop_glue[Internal]\n fn user()\n {\n     let _ = Outer {\n@@ -52,7 +52,7 @@ mod mod1\n         _b: (u32, Struct),\n     }\n \n-    //~ TRANS_ITEM fn local_drop_glue::mod1[0]::user[0] @@ local_drop_glue-mod1[External]\n+    //~ TRANS_ITEM fn local_drop_glue::mod1[0]::user[0] @@ local_drop_glue-mod1[Internal]\n     fn user()\n     {\n         let _ = Struct2 {"}, {"sha": "33e3745502fcf2259e97eaee0bf9bf077fe356b7", "filename": "src/test/codegen-units/partitioning/local-generic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs?ref=e3c8433ebb4a1acf125cae34ebd910869c894ebd", "patch": "@@ -22,23 +22,23 @@\n //~ TRANS_ITEM fn local_generic::generic[0]<&str> @@ local_generic.volatile[External]\n pub fn generic<T>(x: T) -> T { x }\n \n-//~ TRANS_ITEM fn local_generic::user[0] @@ local_generic[External]\n+//~ TRANS_ITEM fn local_generic::user[0] @@ local_generic[Internal]\n fn user() {\n     let _ = generic(0u32);\n }\n \n mod mod1 {\n     pub use super::generic;\n \n-    //~ TRANS_ITEM fn local_generic::mod1[0]::user[0] @@ local_generic-mod1[External]\n+    //~ TRANS_ITEM fn local_generic::mod1[0]::user[0] @@ local_generic-mod1[Internal]\n     fn user() {\n         let _ = generic(0u64);\n     }\n \n     mod mod1 {\n         use super::generic;\n \n-        //~ TRANS_ITEM fn local_generic::mod1[0]::mod1[0]::user[0] @@ local_generic-mod1-mod1[External]\n+        //~ TRANS_ITEM fn local_generic::mod1[0]::mod1[0]::user[0] @@ local_generic-mod1-mod1[Internal]\n         fn user() {\n             let _ = generic('c');\n         }\n@@ -48,7 +48,7 @@ mod mod1 {\n mod mod2 {\n     use super::generic;\n \n-    //~ TRANS_ITEM fn local_generic::mod2[0]::user[0] @@ local_generic-mod2[External]\n+    //~ TRANS_ITEM fn local_generic::mod2[0]::user[0] @@ local_generic-mod2[Internal]\n     fn user() {\n         let _ = generic(\"abc\");\n     }"}, {"sha": "a4d9e60d2280cc62a585a23ddd18abd5437ef239", "filename": "src/test/codegen-units/partitioning/local-inlining.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs?ref=e3c8433ebb4a1acf125cae34ebd910869c894ebd", "patch": "@@ -30,7 +30,7 @@ mod inline {\n mod user1 {\n     use super::inline;\n \n-    //~ TRANS_ITEM fn local_inlining::user1[0]::foo[0] @@ local_inlining-user1[External]\n+    //~ TRANS_ITEM fn local_inlining::user1[0]::foo[0] @@ local_inlining-user1[Internal]\n     fn foo() {\n         inline::inlined_function();\n     }\n@@ -39,15 +39,15 @@ mod user1 {\n mod user2 {\n     use super::inline;\n \n-    //~ TRANS_ITEM fn local_inlining::user2[0]::bar[0] @@ local_inlining-user2[External]\n+    //~ TRANS_ITEM fn local_inlining::user2[0]::bar[0] @@ local_inlining-user2[Internal]\n     fn bar() {\n         inline::inlined_function();\n     }\n }\n \n mod non_user {\n \n-    //~ TRANS_ITEM fn local_inlining::non_user[0]::baz[0] @@ local_inlining-non_user[External]\n+    //~ TRANS_ITEM fn local_inlining::non_user[0]::baz[0] @@ local_inlining-non_user[Internal]\n     fn baz() {\n \n     }"}, {"sha": "1beaa186d9ee5815e9d4deca113b4ab0d19ebdec", "filename": "src/test/codegen-units/partitioning/local-transitive-inlining.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs?ref=e3c8433ebb4a1acf125cae34ebd910869c894ebd", "patch": "@@ -39,15 +39,15 @@ mod direct_user {\n mod indirect_user {\n     use super::direct_user;\n \n-    //~ TRANS_ITEM fn local_transitive_inlining::indirect_user[0]::bar[0] @@ local_transitive_inlining-indirect_user[External]\n+    //~ TRANS_ITEM fn local_transitive_inlining::indirect_user[0]::bar[0] @@ local_transitive_inlining-indirect_user[Internal]\n     fn bar() {\n         direct_user::foo();\n     }\n }\n \n mod non_user {\n \n-    //~ TRANS_ITEM fn local_transitive_inlining::non_user[0]::baz[0] @@ local_transitive_inlining-non_user[External]\n+    //~ TRANS_ITEM fn local_transitive_inlining::non_user[0]::baz[0] @@ local_transitive_inlining-non_user[Internal]\n     fn baz() {\n \n     }"}, {"sha": "9bdbc8b85e8b8a9bd2d45fc8381180825a75ad60", "filename": "src/test/codegen-units/partitioning/regular-modules.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fregular-modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fregular-modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fregular-modules.rs?ref=e3c8433ebb4a1acf125cae34ebd910869c894ebd", "patch": "@@ -16,67 +16,67 @@\n #![allow(dead_code)]\n #![crate_type=\"lib\"]\n \n-//~ TRANS_ITEM fn regular_modules::foo[0] @@ regular_modules[External]\n+//~ TRANS_ITEM fn regular_modules::foo[0] @@ regular_modules[Internal]\n fn foo() {}\n \n-//~ TRANS_ITEM fn regular_modules::bar[0] @@ regular_modules[External]\n+//~ TRANS_ITEM fn regular_modules::bar[0] @@ regular_modules[Internal]\n fn bar() {}\n \n-//~ TRANS_ITEM static regular_modules::BAZ[0] @@ regular_modules[External]\n+//~ TRANS_ITEM static regular_modules::BAZ[0] @@ regular_modules[Internal]\n static BAZ: u64 = 0;\n \n mod mod1 {\n \n-    //~ TRANS_ITEM fn regular_modules::mod1[0]::foo[0] @@ regular_modules-mod1[External]\n+    //~ TRANS_ITEM fn regular_modules::mod1[0]::foo[0] @@ regular_modules-mod1[Internal]\n     fn foo() {}\n-    //~ TRANS_ITEM fn regular_modules::mod1[0]::bar[0] @@ regular_modules-mod1[External]\n+    //~ TRANS_ITEM fn regular_modules::mod1[0]::bar[0] @@ regular_modules-mod1[Internal]\n     fn bar() {}\n-    //~ TRANS_ITEM static regular_modules::mod1[0]::BAZ[0] @@ regular_modules-mod1[External]\n+    //~ TRANS_ITEM static regular_modules::mod1[0]::BAZ[0] @@ regular_modules-mod1[Internal]\n     static BAZ: u64 = 0;\n \n     mod mod1 {\n-        //~ TRANS_ITEM fn regular_modules::mod1[0]::mod1[0]::foo[0] @@ regular_modules-mod1-mod1[External]\n+        //~ TRANS_ITEM fn regular_modules::mod1[0]::mod1[0]::foo[0] @@ regular_modules-mod1-mod1[Internal]\n         fn foo() {}\n-        //~ TRANS_ITEM fn regular_modules::mod1[0]::mod1[0]::bar[0] @@ regular_modules-mod1-mod1[External]\n+        //~ TRANS_ITEM fn regular_modules::mod1[0]::mod1[0]::bar[0] @@ regular_modules-mod1-mod1[Internal]\n         fn bar() {}\n-        //~ TRANS_ITEM static regular_modules::mod1[0]::mod1[0]::BAZ[0] @@ regular_modules-mod1-mod1[External]\n+        //~ TRANS_ITEM static regular_modules::mod1[0]::mod1[0]::BAZ[0] @@ regular_modules-mod1-mod1[Internal]\n         static BAZ: u64 = 0;\n     }\n \n     mod mod2 {\n-        //~ TRANS_ITEM fn regular_modules::mod1[0]::mod2[0]::foo[0] @@ regular_modules-mod1-mod2[External]\n+        //~ TRANS_ITEM fn regular_modules::mod1[0]::mod2[0]::foo[0] @@ regular_modules-mod1-mod2[Internal]\n         fn foo() {}\n-        //~ TRANS_ITEM fn regular_modules::mod1[0]::mod2[0]::bar[0] @@ regular_modules-mod1-mod2[External]\n+        //~ TRANS_ITEM fn regular_modules::mod1[0]::mod2[0]::bar[0] @@ regular_modules-mod1-mod2[Internal]\n         fn bar() {}\n-        //~ TRANS_ITEM static regular_modules::mod1[0]::mod2[0]::BAZ[0] @@ regular_modules-mod1-mod2[External]\n+        //~ TRANS_ITEM static regular_modules::mod1[0]::mod2[0]::BAZ[0] @@ regular_modules-mod1-mod2[Internal]\n         static BAZ: u64 = 0;\n     }\n }\n \n mod mod2 {\n \n-    //~ TRANS_ITEM fn regular_modules::mod2[0]::foo[0] @@ regular_modules-mod2[External]\n+    //~ TRANS_ITEM fn regular_modules::mod2[0]::foo[0] @@ regular_modules-mod2[Internal]\n     fn foo() {}\n-    //~ TRANS_ITEM fn regular_modules::mod2[0]::bar[0] @@ regular_modules-mod2[External]\n+    //~ TRANS_ITEM fn regular_modules::mod2[0]::bar[0] @@ regular_modules-mod2[Internal]\n     fn bar() {}\n-    //~ TRANS_ITEM static regular_modules::mod2[0]::BAZ[0] @@ regular_modules-mod2[External]\n+    //~ TRANS_ITEM static regular_modules::mod2[0]::BAZ[0] @@ regular_modules-mod2[Internal]\n     static BAZ: u64 = 0;\n \n     mod mod1 {\n-        //~ TRANS_ITEM fn regular_modules::mod2[0]::mod1[0]::foo[0] @@ regular_modules-mod2-mod1[External]\n+        //~ TRANS_ITEM fn regular_modules::mod2[0]::mod1[0]::foo[0] @@ regular_modules-mod2-mod1[Internal]\n         fn foo() {}\n-        //~ TRANS_ITEM fn regular_modules::mod2[0]::mod1[0]::bar[0] @@ regular_modules-mod2-mod1[External]\n+        //~ TRANS_ITEM fn regular_modules::mod2[0]::mod1[0]::bar[0] @@ regular_modules-mod2-mod1[Internal]\n         fn bar() {}\n-        //~ TRANS_ITEM static regular_modules::mod2[0]::mod1[0]::BAZ[0] @@ regular_modules-mod2-mod1[External]\n+        //~ TRANS_ITEM static regular_modules::mod2[0]::mod1[0]::BAZ[0] @@ regular_modules-mod2-mod1[Internal]\n         static BAZ: u64 = 0;\n     }\n \n     mod mod2 {\n-        //~ TRANS_ITEM fn regular_modules::mod2[0]::mod2[0]::foo[0] @@ regular_modules-mod2-mod2[External]\n+        //~ TRANS_ITEM fn regular_modules::mod2[0]::mod2[0]::foo[0] @@ regular_modules-mod2-mod2[Internal]\n         fn foo() {}\n-        //~ TRANS_ITEM fn regular_modules::mod2[0]::mod2[0]::bar[0] @@ regular_modules-mod2-mod2[External]\n+        //~ TRANS_ITEM fn regular_modules::mod2[0]::mod2[0]::bar[0] @@ regular_modules-mod2-mod2[Internal]\n         fn bar() {}\n-        //~ TRANS_ITEM static regular_modules::mod2[0]::mod2[0]::BAZ[0] @@ regular_modules-mod2-mod2[External]\n+        //~ TRANS_ITEM static regular_modules::mod2[0]::mod2[0]::BAZ[0] @@ regular_modules-mod2-mod2[Internal]\n         static BAZ: u64 = 0;\n     }\n }"}, {"sha": "8cbce12b52cad5256de4bbb35d33ebd722ab1360", "filename": "src/test/codegen-units/partitioning/statics.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fstatics.rs?ref=e3c8433ebb4a1acf125cae34ebd910869c894ebd", "patch": "@@ -15,34 +15,34 @@\n \n #![crate_type=\"lib\"]\n \n-//~ TRANS_ITEM static statics::FOO[0] @@ statics[External]\n+//~ TRANS_ITEM static statics::FOO[0] @@ statics[Internal]\n static FOO: u32 = 0;\n \n-//~ TRANS_ITEM static statics::BAR[0] @@ statics[External]\n+//~ TRANS_ITEM static statics::BAR[0] @@ statics[Internal]\n static BAR: u32 = 0;\n \n-//~ TRANS_ITEM fn statics::function[0] @@ statics[External]\n+//~ TRANS_ITEM fn statics::function[0] @@ statics[Internal]\n fn function() {\n-    //~ TRANS_ITEM static statics::function[0]::FOO[0] @@ statics[External]\n+    //~ TRANS_ITEM static statics::function[0]::FOO[0] @@ statics[Internal]\n     static FOO: u32 = 0;\n \n-    //~ TRANS_ITEM static statics::function[0]::BAR[0] @@ statics[External]\n+    //~ TRANS_ITEM static statics::function[0]::BAR[0] @@ statics[Internal]\n     static BAR: u32 = 0;\n }\n \n mod mod1 {\n-    //~ TRANS_ITEM static statics::mod1[0]::FOO[0] @@ statics-mod1[External]\n+    //~ TRANS_ITEM static statics::mod1[0]::FOO[0] @@ statics-mod1[Internal]\n     static FOO: u32 = 0;\n \n-    //~ TRANS_ITEM static statics::mod1[0]::BAR[0] @@ statics-mod1[External]\n+    //~ TRANS_ITEM static statics::mod1[0]::BAR[0] @@ statics-mod1[Internal]\n     static BAR: u32 = 0;\n \n-    //~ TRANS_ITEM fn statics::mod1[0]::function[0] @@ statics-mod1[External]\n+    //~ TRANS_ITEM fn statics::mod1[0]::function[0] @@ statics-mod1[Internal]\n     fn function() {\n-        //~ TRANS_ITEM static statics::mod1[0]::function[0]::FOO[0] @@ statics-mod1[External]\n+        //~ TRANS_ITEM static statics::mod1[0]::function[0]::FOO[0] @@ statics-mod1[Internal]\n         static FOO: u32 = 0;\n \n-        //~ TRANS_ITEM static statics::mod1[0]::function[0]::BAR[0] @@ statics-mod1[External]\n+        //~ TRANS_ITEM static statics::mod1[0]::function[0]::BAR[0] @@ statics-mod1[Internal]\n         static BAR: u32 = 0;\n     }\n }"}, {"sha": "74f2f8435670110c528988473020e683242e648e", "filename": "src/test/codegen-units/partitioning/vtable-through-const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c8433ebb4a1acf125cae34ebd910869c894ebd/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs?ref=e3c8433ebb4a1acf125cae34ebd910869c894ebd", "patch": "@@ -67,7 +67,7 @@ mod mod1 {\n     pub const ID_I64: fn(i64) -> i64 = id::<i64>;\n }\n \n-//~ TRANS_ITEM fn vtable_through_const::main[0] @@ vtable_through_const[External]\n+//~ TRANS_ITEM fn vtable_through_const::main[0] @@ vtable_through_const[Internal]\n fn main() {\n     //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<u32> @@ vtable_through_const[Internal]\n "}]}