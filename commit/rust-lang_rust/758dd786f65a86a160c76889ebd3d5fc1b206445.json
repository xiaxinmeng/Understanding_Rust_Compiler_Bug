{"sha": "758dd786f65a86a160c76889ebd3d5fc1b206445", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1OGRkNzg2ZjY1YTg2YTE2MGM3Njg4OWViZDNkNWZjMWIyMDY0NDU=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-10T02:07:37Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-10T02:07:59Z"}, "message": "Make rwlocks fail-proof", "tree": {"sha": "d46cb47469e93a9638df04f2dbaf4c1d0553eaf1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d46cb47469e93a9638df04f2dbaf4c1d0553eaf1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/758dd786f65a86a160c76889ebd3d5fc1b206445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/758dd786f65a86a160c76889ebd3d5fc1b206445", "html_url": "https://github.com/rust-lang/rust/commit/758dd786f65a86a160c76889ebd3d5fc1b206445", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/758dd786f65a86a160c76889ebd3d5fc1b206445/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b2d91c79da93461563428d25ae09bbeb59ed292", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b2d91c79da93461563428d25ae09bbeb59ed292", "html_url": "https://github.com/rust-lang/rust/commit/1b2d91c79da93461563428d25ae09bbeb59ed292"}], "stats": {"total": 156, "additions": 106, "deletions": 50}, "files": [{"sha": "3d5699890bd8b8b683a25d279779f7cd3c3ee3e1", "filename": "src/libcore/sync.rs", "status": "modified", "additions": 106, "deletions": 50, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/758dd786f65a86a160c76889ebd3d5fc1b206445/src%2Flibcore%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758dd786f65a86a160c76889ebd3d5fc1b206445/src%2Flibcore%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync.rs?ref=758dd786f65a86a160c76889ebd3d5fc1b206445", "patch": "@@ -148,19 +148,6 @@ enum condvar = &sem<waitqueue>;\n impl condvar {\n     /// Atomically drop the associated lock, and block until a signal is sent.\n     fn wait() {\n-        // This is needed for a failing condition variable to reacquire the\n-        // mutex during unwinding. As long as the wrapper (mutex, etc) is\n-        // bounded in when it gets released, this shouldn't hang forever.\n-        struct sem_and_signal_reacquire {\n-            sem: &sem<waitqueue>;\n-            new(sem: &sem<waitqueue>) { self.sem = sem; }\n-            drop unsafe {\n-                do task::unkillable {\n-                    self.sem.acquire();\n-                }\n-            }\n-        }\n-\n         // Create waiter nobe.\n         let (signal_end, wait_end) = pipes::stream();\n         let mut signal_end = some(signal_end);\n@@ -190,9 +177,20 @@ impl condvar {\n         // Unconditionally \"block\". (Might not actually block if a signaller\n         // did send -- I mean 'unconditionally' in contrast with acquire().)\n         let _ = wait_end.recv();\n-        // 'reacquire' will pick up the lock again in its destructor - it must\n-        // happen whether or not we are killed, and it needs to succeed at\n-        // reacquiring instead of itself dying.\n+\n+        // This is needed for a failing condition variable to reacquire the\n+        // mutex during unwinding. As long as the wrapper (mutex, etc) is\n+        // bounded in when it gets released, this shouldn't hang forever.\n+        struct sem_and_signal_reacquire {\n+            sem: &sem<waitqueue>;\n+            new(sem: &sem<waitqueue>) { self.sem = sem; }\n+            drop unsafe {\n+                // Needs to succeed, instead of itself dying.\n+                do task::unkillable {\n+                    self.sem.acquire();\n+                }\n+            }\n+        }\n     }\n \n     /// Wake up a blocked task. Returns false if there was no blocked task.\n@@ -297,14 +295,15 @@ struct rwlock {\n     state:       arc::exclusive<rwlock_inner>;\n }\n \n+/// Create a new rwlock.\n fn rwlock() -> rwlock {\n     rwlock { order_lock: new_semaphore(1), access_lock: new_sem_and_signal(1),\n              state: arc::exclusive(rwlock_inner { read_mode:  false,\n                                                   read_count: 0 }) }\n }\n \n impl &rwlock {\n-    // Create a new handle to the rwlock.\n+    /// Create a new handle to the rwlock.\n     fn clone() -> rwlock {\n         rwlock { order_lock:  (&(self.order_lock)).clone(),\n                  access_lock: sem((*self.access_lock).clone()),\n@@ -316,40 +315,39 @@ impl &rwlock {\n      * tasks may run concurrently with this one.\n      */\n     fn read<U>(blk: fn() -> U) -> U {\n-        do (&self.order_lock).access {\n-            let mut first_reader = false;\n-            do self.state.with |state| {\n-                state.read_mode = true;\n-                first_reader = (state.read_count == 0);\n-                state.read_count += 1;\n-            }\n-            if first_reader {\n-                (&self.access_lock).acquire();\n+        unsafe {\n+            do task::unkillable {\n+                do (&self.order_lock).access {\n+                    let mut first_reader = false;\n+                    do self.state.with |state| {\n+                        state.read_mode = true;\n+                        first_reader = (state.read_count == 0);\n+                        state.read_count += 1;\n+                    }\n+                    if first_reader {\n+                        (&self.access_lock).acquire();\n+                    }\n+                }\n             }\n         }\n-        let result = blk();\n-        let mut last_reader = false;\n-        do self.state.with |state| {\n-            assert state.read_mode;\n-            state.read_count -= 1;\n-            last_reader = (state.read_count == 0);\n-        }\n-        if last_reader {\n-            (&self.access_lock).release();\n-        }\n-        result\n+        let _z = rwlock_release_read(self);\n+        blk()\n     }\n \n     /**\n      * Run a function with the rwlock in write mode. No calls to 'read' or\n      * 'write' from other tasks will run concurrently with this one.\n      */\n     fn write<U>(blk: fn() -> U) -> U {\n-        (&self.order_lock).acquire();\n-        do (&self.access_lock).access {\n-            (&self.order_lock).release();\n-            blk()\n+        unsafe {\n+            do task::unkillable {\n+                (&self.order_lock).acquire();\n+                (&self.access_lock).acquire();\n+                (&self.order_lock).release();\n+            }\n         }\n+        let _z = rwlock_release_write(self);\n+        blk()\n     }\n \n     /**\n@@ -364,12 +362,41 @@ impl &rwlock {\n     // to-do implement downgrade\n }\n \n+// FIXME(#3136) should go inside of write() and read() respectively\n+struct rwlock_release_write {\n+    lock: &rwlock;\n+    new(lock: &rwlock) { self.lock = lock; }\n+    drop unsafe {\n+        do task::unkillable { (&self.lock.access_lock).release(); }\n+    }\n+}\n+struct rwlock_release_read {\n+    lock: &rwlock;\n+    new(lock: &rwlock) { self.lock = lock; }\n+    drop unsafe {\n+        do task::unkillable {\n+            let mut last_reader = false;\n+            do self.lock.state.with |state| {\n+                assert state.read_mode;\n+                state.read_count -= 1;\n+                last_reader = (state.read_count == 0);\n+            }\n+            if last_reader {\n+                (&self.lock.access_lock).release();\n+            }\n+        }\n+    }\n+}\n+\n /****************************************************************************\n  * Tests\n  ****************************************************************************/\n \n #[cfg(test)]\n mod tests {\n+    /************************************************************************\n+     * Semaphore tests\n+     ************************************************************************/\n     #[test]\n     fn test_sem_acquire_release() {\n         let s = ~new_semaphore(1);\n@@ -462,6 +489,9 @@ mod tests {\n             let _ = p.recv(); // wait for child to be done\n         }\n     }\n+    /************************************************************************\n+     * Mutex tests\n+     ************************************************************************/\n     #[test]\n     fn test_mutex_lock() {\n         // Unsafely achieve shared state, and do the textbook\n@@ -613,32 +643,36 @@ mod tests {\n             // assert !woken;\n         }\n     }\n+    /************************************************************************\n+     * Reader/writer lock tests\n+     ************************************************************************/\n+    #[cfg(test)]\n+    fn lock_rwlock_in_mode(x: &rwlock, reader: bool, blk: fn()) {\n+        if reader { x.read(blk); } else { x.write(blk); }\n+    }\n     #[cfg(test)]\n     fn test_rwlock_exclusion(reader1: bool, reader2: bool) {\n         // Test mutual exclusion between readers and writers. Just like the\n         // mutex mutual exclusion test, a ways above.\n         let (c,p) = pipes::stream();\n-        let m = ~rwlock();\n-        let m2 = ~m.clone();\n+        let x = ~rwlock();\n+        let x2 = ~x.clone();\n         let sharedstate = ~0;\n         let ptr = ptr::addr_of(*sharedstate);\n         do task::spawn {\n             let sharedstate = unsafe { unsafe::reinterpret_cast(ptr) };\n-            access_shared(sharedstate, m2, reader1, 10);\n+            access_shared(sharedstate, x2, reader1, 10);\n             c.send(());\n         }\n-        access_shared(sharedstate, m, reader2, 10);\n+        access_shared(sharedstate, x, reader2, 10);\n         let _ = p.recv();\n \n         assert *sharedstate == 20;\n \n-        fn access_shared(sharedstate: &mut int, m: &rwlock, reader: bool,\n+        fn access_shared(sharedstate: &mut int, x: &rwlock, reader: bool,\n                          n: uint) {\n-            let lock_fn = fn@(m: &rwlock, blk: fn()) {\n-                if reader { m.read(blk); } else { m.write(blk); }\n-            };\n             for n.times {\n-                do lock_fn(m) {\n+                do lock_rwlock_in_mode(x, reader) {\n                     let oldval = *sharedstate;\n                     task::yield();\n                     *sharedstate = oldval + 1;\n@@ -672,6 +706,28 @@ mod tests {\n             c2.send(());\n             let _ = p1.recv();\n         }\n+    }\n+    #[cfg(test)] #[ignore(cfg(windows))]\n+    fn rwlock_kill_helper(reader1: bool, reader2: bool) {\n+        // Mutex must get automatically unlocked if failed/killed within.\n+        let x = ~rwlock();\n+        let x2 = ~x.clone();\n \n+        let result: result::result<(),()> = do task::try {\n+            do lock_rwlock_in_mode(x2, reader1) {\n+                fail;\n+            }\n+        };\n+        assert result.is_err();\n+        // child task must have finished by the time try returns\n+        do lock_rwlock_in_mode(x, reader2) { }\n     }\n+    #[test] #[ignore(cfg(windows))]\n+    fn test_rwlock_reader_killed_writer() { rwlock_kill_helper(true, false); }\n+    #[test] #[ignore(cfg(windows))]\n+    fn test_rwlock_writer_killed_reader() { rwlock_kill_helper(false,true ); }\n+    #[test] #[ignore(cfg(windows))]\n+    fn test_rwlock_reader_killed_reader() { rwlock_kill_helper(true, true ); }\n+    #[test] #[ignore(cfg(windows))]\n+    fn test_rwlock_writer_killed_writer() { rwlock_kill_helper(false,false); }\n }"}]}