{"sha": "c39a95da90a3d8247e011f6a42f0c53ced34de97", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzOWE5NWRhOTBhM2Q4MjQ3ZTAxMWY2YTQyZjBjNTNjZWQzNGRlOTc=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-04-29T11:34:30Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-04-29T19:19:50Z"}, "message": "Implement destructors in rustc\n\nUnlike rustboot, rustc keeps it destructors in vtables. Entry 0 holds\neither the destructor for the obj or a NULL pointer. The method\noffsets start at 1.", "tree": {"sha": "322d42c461f63623937d1a034df0b61e494b3463", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/322d42c461f63623937d1a034df0b61e494b3463"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c39a95da90a3d8247e011f6a42f0c53ced34de97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c39a95da90a3d8247e011f6a42f0c53ced34de97", "html_url": "https://github.com/rust-lang/rust/commit/c39a95da90a3d8247e011f6a42f0c53ced34de97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c39a95da90a3d8247e011f6a42f0c53ced34de97/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9aeb67987c93c611be7e74b39630dd81c57acefb", "url": "https://api.github.com/repos/rust-lang/rust/commits/9aeb67987c93c611be7e74b39630dd81c57acefb", "html_url": "https://github.com/rust-lang/rust/commit/9aeb67987c93c611be7e74b39630dd81c57acefb"}], "stats": {"total": 101, "additions": 61, "deletions": 40}, "files": [{"sha": "39c176dce640dd376d749461b7ff23ca7373a369", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c39a95da90a3d8247e011f6a42f0c53ced34de97/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39a95da90a3d8247e011f6a42f0c53ced34de97/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=c39a95da90a3d8247e011f6a42f0c53ced34de97", "patch": "@@ -38,6 +38,7 @@ const int tydesc_field_drop_glue = 4;\n const int tydesc_field_free_glue = 5;\n const int tydesc_field_sever_glue = 6;\n const int tydesc_field_mark_glue = 7;\n+// FIXME no longer used in rustc, drop when rustboot is gone\n const int tydesc_field_obj_drop_glue = 8;\n const int tydesc_field_is_stateful = 9;\n const int tydesc_field_cmp_glue = 10;"}, {"sha": "aea6b8e9433daee2cc20f3af94774e533ac87c8b", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 60, "deletions": 40, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/c39a95da90a3d8247e011f6a42f0c53ced34de97/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39a95da90a3d8247e011f6a42f0c53ced34de97/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c39a95da90a3d8247e011f6a42f0c53ced34de97", "patch": "@@ -359,6 +359,11 @@ fn T_glue_fn(type_names tn) -> TypeRef {\n     ret t;\n }\n \n+fn T_dtor(@crate_ctxt ccx, TypeRef llself_ty) -> TypeRef {\n+    ret type_of_fn_full(ccx, ast.proto_fn, some[TypeRef](llself_ty),\n+                        _vec.empty[ty.arg](), ty.mk_nil(ccx.tcx), 0u);\n+}\n+\n fn T_cmp_glue_fn(type_names tn) -> TypeRef {\n     auto s = \"cmp_glue_fn\";\n     if (tn.name_has_type(s)) {\n@@ -763,7 +768,7 @@ fn type_of_inner(@crate_ctxt cx, ty.t t) -> TypeRef {\n             auto th = mk_type_handle();\n             auto self_ty = llvm.LLVMResolveTypeHandle(th.llth);\n \n-            let vec[TypeRef] mtys = vec();\n+            let vec[TypeRef] mtys = vec(T_ptr(T_i8()));\n             for (ty.method m in meths) {\n                 let TypeRef mty =\n                     type_of_fn_full(cx, m.proto,\n@@ -1618,7 +1623,8 @@ fn get_tydesc(&@block_ctxt cx, ty.t t) -> result {\n \n     // Otherwise, generate a tydesc if necessary, and return it.\n     let vec[uint] tps = vec();\n-    ret res(cx, get_static_tydesc(cx, t, tps).tydesc);\n+    auto st = get_static_tydesc(cx, t, tps).tydesc;\n+    ret res(cx, st);\n }\n \n fn get_static_tydesc(&@block_ctxt cx,\n@@ -1901,25 +1907,26 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v0, ty.t t) {\n         }\n \n         case (ty.ty_obj(_)) {\n-            fn hit_zero(@block_ctxt cx, ValueRef v) -> result {\n-\n-                // Call through the obj's own fields-drop glue first.\n+            fn hit_zero(@block_ctxt cx, ValueRef b, ValueRef o) -> result {\n                 auto body =\n-                    cx.build.GEP(v,\n+                    cx.build.GEP(b,\n                                  vec(C_int(0),\n                                      C_int(abi.box_rc_field_body)));\n-\n                 auto tydescptr =\n                     cx.build.GEP(body,\n                                  vec(C_int(0),\n                                      C_int(abi.obj_body_elt_tydesc)));\n+                auto tydesc = cx.build.Load(tydescptr);\n \n-                call_tydesc_glue_full(cx, body, cx.build.Load(tydescptr),\n+                auto cx_ = maybe_call_dtor(cx, o);\n+\n+                // Call through the obj's own fields-drop glue first.\n+                call_tydesc_glue_full(cx_, body, tydesc,\n                                       abi.tydesc_field_drop_glue);\n \n                 // Then free the body.\n                 // FIXME: switch gc/non-gc on layer of the type.\n-                ret trans_non_gc_free(cx, v);\n+                ret trans_non_gc_free(cx_, b);\n             }\n             auto box_cell =\n                 cx.build.GEP(v0,\n@@ -1929,7 +1936,7 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v0, ty.t t) {\n             auto boxptr = cx.build.Load(box_cell);\n \n             rslt = decr_refcnt_and_if_zero(cx, boxptr,\n-                                           bind hit_zero(_, boxptr),\n+                                           bind hit_zero(_, boxptr, v0),\n                                            \"free obj\",\n                                            T_int(), C_int(0));\n         }\n@@ -2704,6 +2711,27 @@ fn call_tydesc_glue(@block_ctxt cx, ValueRef v,\n     ret res(td.bcx, C_nil());\n }\n \n+fn maybe_call_dtor(@block_ctxt cx, ValueRef v) -> @block_ctxt {\n+    auto vtbl = cx.build.GEP(v, vec(C_int(0), C_int(abi.obj_field_vtbl)));\n+    vtbl = cx.build.Load(vtbl);\n+    auto dtor_ptr = cx.build.GEP(vtbl, vec(C_int(0), C_int(0)));\n+    dtor_ptr = cx.build.Load(dtor_ptr);\n+    dtor_ptr = cx.build.BitCast(dtor_ptr,\n+                                T_ptr(T_dtor(cx.fcx.lcx.ccx, val_ty(v))));\n+    \n+    auto dtor_cx = new_sub_block_ctxt(cx, \"dtor\");\n+    auto after_cx = new_sub_block_ctxt(cx, \"after_dtor\");\n+    auto test = cx.build.ICmp(lib.llvm.LLVMIntNE, dtor_ptr,\n+                              C_null(val_ty(dtor_ptr)));\n+    cx.build.CondBr(test, dtor_cx.llbb, after_cx.llbb);\n+\n+    // FIXME need to pass type params (?)\n+    dtor_cx.build.FastCall(dtor_ptr, vec(C_null(T_ptr(T_nil())),\n+                                        cx.fcx.lltaskptr, v));\n+    dtor_cx.build.Br(after_cx.llbb);\n+    ret after_cx;\n+}\n+\n fn call_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs, ty.t t,\n                  ValueRef llop) -> result {\n     // We can't use call_tydesc_glue_full() and friends here because compare\n@@ -4110,12 +4138,13 @@ fn trans_field(@block_ctxt cx, &ast.span sp, ValueRef v, ty.t t0,\n                                         vec(C_int(0),\n                                             C_int(abi.obj_field_vtbl)));\n             vtbl = r.bcx.build.Load(vtbl);\n+            // +1 because slot #0 contains the destructor\n             auto v =  r.bcx.build.GEP(vtbl, vec(C_int(0),\n-                                                C_int(ix as int)));\n+                                                C_int((ix + 1u) as int)));\n \n             auto lvo = lval_mem(r.bcx, v);\n             let ty.t fn_ty = ty.method_ty_to_fn_ty(cx.fcx.lcx.ccx.tcx,\n-                                                    methods.(ix));\n+                                                   methods.(ix));\n             ret rec(llobj = some[ValueRef](r.val),\n                     method_ty = some[ty.t](fn_ty)\n                     with lvo);\n@@ -6102,7 +6131,6 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n fn trans_fn(@local_ctxt cx, &ast._fn f, ast.def_id fid,\n             option.t[tup(TypeRef, ty.t)] ty_self,\n             &vec[ast.ty_param] ty_params, &ast.ann ann) {\n-\n     auto llfndecl = cx.ccx.item_ids.get(fid);\n \n     auto fcx = new_fn_ctxt(cx, llfndecl);\n@@ -6145,7 +6173,15 @@ fn trans_vtbl(@local_ctxt cx,\n               ty.t self_ty,\n               &ast._obj ob,\n               &vec[ast.ty_param] ty_params) -> ValueRef {\n-    let vec[ValueRef] methods = vec();\n+    auto dtor = C_null(T_ptr(T_i8()));\n+    alt (ob.dtor) {\n+        case (some[@ast.method](?d)) {\n+            auto dtor_1 = trans_dtor(cx, llself_ty, self_ty, ty_params, d);\n+            dtor = llvm.LLVMConstBitCast(dtor_1, val_ty(dtor));\n+        }\n+        case (none[@ast.method]) {}\n+    }\n+    let vec[ValueRef] methods = vec(dtor);\n \n     fn meth_lteq(&@ast.method a, &@ast.method b) -> bool {\n         ret _str.lteq(a.node.ident, b.node.ident);\n@@ -6195,16 +6231,7 @@ fn trans_dtor(@local_ctxt cx,\n               &vec[ast.ty_param] ty_params,\n               &@ast.method dtor) -> ValueRef {\n \n-    auto llfnty = T_nil();\n-    alt (ty.struct(cx.ccx.tcx, node_ann_type(cx.ccx, dtor.node.ann))) {\n-        case (ty.ty_fn(?proto, ?inputs, ?output)) {\n-            llfnty = type_of_fn_full(cx.ccx, proto,\n-                                     some[TypeRef](llself_ty),\n-                                     inputs, output,\n-                                     _vec.len[ast.ty_param](ty_params));\n-        }\n-    }\n-\n+    auto llfnty = T_dtor(cx.ccx, llself_ty);\n     let @local_ctxt dcx = extend_path(cx, \"drop\");\n     let str s = mangle_name_by_seq(dcx.ccx, dcx.path, \"drop\");\n     let ValueRef llfn = decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n@@ -6235,18 +6262,19 @@ fn trans_obj(@local_ctxt cx, &ast._obj ob, ast.def_id oid,\n     auto fcx = new_fn_ctxt(cx, llctor_decl);\n     create_llargs_for_fn_args(fcx, ast.proto_fn,\n                               none[tup(TypeRef, ty.t)],\n-                              ret_ty_of_fn(cx.ccx, ann),\n+                              ret_ty_of_fn(ccx, ann),\n                               fn_args, ty_params);\n \n-    let vec[ty.arg] arg_tys = arg_tys_of_fn(cx.ccx, ann);\n+    let vec[ty.arg] arg_tys = arg_tys_of_fn(ccx, ann);\n     copy_args_to_allocas(fcx, fn_args, arg_tys);\n \n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n \n-    auto self_ty = ret_ty_of_fn(cx.ccx, ann);\n+    auto self_ty = ret_ty_of_fn(ccx, ann);\n     auto llself_ty = type_of(ccx, self_ty);\n     auto pair = bcx.fcx.llretptr;\n+\n     auto vtbl = trans_vtbl(cx, llself_ty, self_ty, ob, ty_params);\n     auto pair_vtbl = bcx.build.GEP(pair,\n                                    vec(C_int(0),\n@@ -6270,19 +6298,19 @@ fn trans_obj(@local_ctxt cx, &ast._obj ob, ast.def_id oid,\n         }\n \n         // Synthesize an obj body type.\n-        auto tydesc_ty = ty.mk_type(cx.ccx.tcx);\n+        auto tydesc_ty = ty.mk_type(ccx.tcx);\n         let vec[ty.t] tps = vec();\n         for (ast.ty_param tp in ty_params) {\n             _vec.push[ty.t](tps, tydesc_ty);\n         }\n \n-        let ty.t typarams_ty = ty.mk_imm_tup(cx.ccx.tcx, tps);\n-        let ty.t fields_ty = ty.mk_imm_tup(cx.ccx.tcx, obj_fields);\n-        let ty.t body_ty = ty.mk_imm_tup(cx.ccx.tcx,\n+        let ty.t typarams_ty = ty.mk_imm_tup(ccx.tcx, tps);\n+        let ty.t fields_ty = ty.mk_imm_tup(ccx.tcx, obj_fields);\n+        let ty.t body_ty = ty.mk_imm_tup(ccx.tcx,\n                                           vec(tydesc_ty,\n                                               typarams_ty,\n                                               fields_ty));\n-        let ty.t boxed_body_ty = ty.mk_imm_box(cx.ccx.tcx, body_ty);\n+        let ty.t boxed_body_ty = ty.mk_imm_box(ccx.tcx, body_ty);\n \n         // Malloc a box for the body.\n         auto box = trans_malloc_boxed(bcx, body_ty);\n@@ -6301,14 +6329,6 @@ fn trans_obj(@local_ctxt cx, &ast._obj ob, ast.def_id oid,\n                          vec(0, abi.obj_body_elt_tydesc));\n         bcx = body_tydesc.bcx;\n \n-        auto dtor = C_null(T_ptr(T_glue_fn(ccx.tn)));\n-        alt (ob.dtor) {\n-            case (some[@ast.method](?d)) {\n-                dtor = trans_dtor(cx, llself_ty, self_ty, ty_params, d);\n-            }\n-            case (none[@ast.method]) {}\n-        }\n-\n         auto body_td = get_tydesc(bcx, body_ty);\n         bcx = body_td.bcx;\n         bcx.build.Store(body_td.val, body_tydesc.val);"}]}