{"sha": "8d8c25b825f109c9ae33ff0e52a061b62ae9f434", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkOGMyNWI4MjVmMTA5YzlhZTMzZmYwZTUyYTA2MWI2MmFlOWY0MzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-16T21:03:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-16T21:03:25Z"}, "message": "auto merge of #4980 : pcwalton/rust/sizing-type-of, r=pcwalton\n\n...locking-servo\r\n\r\n`simplify_type` was bogus, as there was no way for it to handle enums\r\nproperly. It was also slow, because it created many Rust types at runtime. In\r\ngeneral creating Rust types during trans is a source of slowness, and I'd like\r\nto avoid doing it as much as possible. (It is probably not possible to\r\neliminate it entirely, due to `subst`, but we should get rid of as much of it\r\nas we can.) So this patch replaces `simplify_type` with `sizing_type_of`,\r\nwhich creates a size-equivalent LLVM type directly without going through a\r\nRust type first.\r\n\r\nBecause this is causing an ICE in Servo, I'm rubber stamping it.", "tree": {"sha": "f63a9b0d37d893b9c7fad11697e3679c4a1d92bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f63a9b0d37d893b9c7fad11697e3679c4a1d92bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d8c25b825f109c9ae33ff0e52a061b62ae9f434", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d8c25b825f109c9ae33ff0e52a061b62ae9f434", "html_url": "https://github.com/rust-lang/rust/commit/8d8c25b825f109c9ae33ff0e52a061b62ae9f434", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d8c25b825f109c9ae33ff0e52a061b62ae9f434/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65aa2594c00ed319ae0f3ba5dfbf4613a0274872", "url": "https://api.github.com/repos/rust-lang/rust/commits/65aa2594c00ed319ae0f3ba5dfbf4613a0274872", "html_url": "https://github.com/rust-lang/rust/commit/65aa2594c00ed319ae0f3ba5dfbf4613a0274872"}, {"sha": "548c0982cabe12fba5ee106e542f615f750af6e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/548c0982cabe12fba5ee106e542f615f750af6e6", "html_url": "https://github.com/rust-lang/rust/commit/548c0982cabe12fba5ee106e542f615f750af6e6"}], "stats": {"total": 226, "additions": 139, "deletions": 87}, "files": [{"sha": "13f29724ba80ec09cdee61806b9b4780c22627d7", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d8c25b825f109c9ae33ff0e52a061b62ae9f434/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8c25b825f109c9ae33ff0e52a061b62ae9f434/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8d8c25b825f109c9ae33ff0e52a061b62ae9f434", "patch": "@@ -3030,6 +3030,7 @@ pub fn trans_crate(sess: session::Session,\n               const_values: HashMap(),\n               module_data: HashMap(),\n               lltypes: ty::new_ty_hash(),\n+              llsizingtypes: ty::new_ty_hash(),\n               names: new_namegen(sess.parse_sess.interner),\n               next_addrspace: new_addrspace_gen(),\n               symbol_hasher: symbol_hasher,"}, {"sha": "b0ec0e1b907387c4d84fbea909b80f5ee10da746", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d8c25b825f109c9ae33ff0e52a061b62ae9f434/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8c25b825f109c9ae33ff0e52a061b62ae9f434/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=8d8c25b825f109c9ae33ff0e52a061b62ae9f434", "patch": "@@ -202,6 +202,7 @@ pub struct crate_ctxt {\n      const_values: HashMap<ast::node_id, ValueRef>,\n      module_data: HashMap<~str, ValueRef>,\n      lltypes: HashMap<ty::t, TypeRef>,\n+     llsizingtypes: HashMap<ty::t, TypeRef>,\n      names: namegen,\n      next_addrspace: addrspace_gen,\n      symbol_hasher: @hash::State,"}, {"sha": "58a53cd878a7078d6c35c72e0c7d2e9920153045", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 33, "deletions": 72, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/8d8c25b825f109c9ae33ff0e52a061b62ae9f434/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8c25b825f109c9ae33ff0e52a061b62ae9f434/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=8d8c25b825f109c9ae33ff0e52a061b62ae9f434", "patch": "@@ -13,60 +13,8 @@\n \n use middle::trans::common::*;\n use middle::trans::type_of;\n-use middle::ty::field;\n use middle::ty;\n-\n-use syntax::parse::token::special_idents;\n-\n-// Creates a simpler, size-equivalent type. The resulting type is guaranteed\n-// to have (a) the same size as the type that was passed in; (b) to be non-\n-// recursive. This is done by replacing all boxes in a type with boxed unit\n-// types.\n-// This should reduce all pointers to some simple pointer type, to\n-// ensure that we don't recurse endlessly when computing the size of a\n-// nominal type that has pointers to itself in it.\n-pub fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n-    fn nilptr(tcx: ty::ctxt) -> ty::t {\n-        ty::mk_ptr(tcx, ty::mt {ty: ty::mk_nil(tcx), mutbl: ast::m_imm})\n-    }\n-    fn simplifier(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n-        match ty::get(typ).sty {\n-          ty::ty_box(_) | ty::ty_opaque_box | ty::ty_uniq(_) |\n-          ty::ty_evec(_, ty::vstore_uniq) | ty::ty_evec(_, ty::vstore_box) |\n-          ty::ty_estr(ty::vstore_uniq) | ty::ty_estr(ty::vstore_box) |\n-          ty::ty_ptr(_) | ty::ty_rptr(*) => nilptr(tcx),\n-\n-          ty::ty_bare_fn(*) | // FIXME(#4804) Bare fn repr\n-          ty::ty_closure(*) => ty::mk_tup(tcx, ~[nilptr(tcx), nilptr(tcx)]),\n-\n-          ty::ty_evec(_, ty::vstore_slice(_)) |\n-          ty::ty_estr(ty::vstore_slice(_)) => {\n-            ty::mk_tup(tcx, ~[nilptr(tcx), ty::mk_int(tcx)])\n-          }\n-          // Reduce a class type to a record type in which all the fields are\n-          // simplified\n-          ty::ty_struct(did, ref substs) => {\n-            let simpl_fields = (if ty::ty_dtor(tcx, did).is_present() {\n-                // remember the drop flag\n-                  ~[field {\n-                    ident: special_idents::dtor,\n-                    mt: ty::mt {ty: ty::mk_u8(tcx), mutbl: ast::m_mutbl}\n-                   }] }\n-                else { ~[] }) +\n-                do ty::lookup_struct_fields(tcx, did).map |f| {\n-                 let t = ty::lookup_field_type(tcx, did, f.id, substs);\n-                 field {\n-                    ident: f.ident,\n-                    mt: ty::mt {ty: simplify_type(tcx, t), mutbl: ast::m_const\n-                 }}\n-            };\n-            ty::mk_rec(tcx, simpl_fields)\n-          }\n-          _ => typ\n-        }\n-    }\n-    ty::fold_ty(tcx, typ, |t| simplifier(tcx, t))\n-}\n+use util::ppaux::ty_to_str;\n \n // ______________________________________________________________________\n // compute sizeof / alignof\n@@ -180,27 +128,40 @@ pub fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n \n // Computes the size of the data part of an enum.\n pub fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n-    if cx.enum_sizes.contains_key(&t) { return cx.enum_sizes.get(&t); }\n+    if cx.enum_sizes.contains_key(&t) {\n+        return cx.enum_sizes.get(&t);\n+    }\n+\n+    debug!(\"static_size_of_enum %s\", ty_to_str(cx.tcx, t));\n+\n     match ty::get(t).sty {\n-      ty::ty_enum(tid, ref substs) => {\n-        // Compute max(variant sizes).\n-        let mut max_size = 0u;\n-        let variants = ty::enum_variants(cx.tcx, tid);\n-        for vec::each(*variants) |variant| {\n-            let tup_ty = simplify_type(\n-                cx.tcx,\n-                ty::mk_tup(cx.tcx, /*bad*/copy variant.args));\n-            // Perform any type parameter substitutions.\n-            let tup_ty = ty::subst(cx.tcx, substs, tup_ty);\n-            // Here we possibly do a recursive call.\n-            let this_size =\n-                llsize_of_real(cx, type_of::type_of(cx, tup_ty));\n-            if max_size < this_size { max_size = this_size; }\n+        ty::ty_enum(tid, ref substs) => {\n+            // Compute max(variant sizes).\n+            let mut max_size = 0;\n+            let variants = ty::enum_variants(cx.tcx, tid);\n+            for variants.each |variant| {\n+                if variant.args.len() == 0 {\n+                    loop;\n+                }\n+\n+                let lltypes = variant.args.map(|&variant_arg| {\n+                    let substituted = ty::subst(cx.tcx, substs, variant_arg);\n+                    type_of::sizing_type_of(cx, substituted)\n+                });\n+\n+                debug!(\"static_size_of_enum: variant %s type %s\",\n+                       cx.tcx.sess.str_of(variant.name),\n+                       ty_str(cx.tn, T_struct(lltypes)));\n+\n+                let this_size = llsize_of_real(cx, T_struct(lltypes));\n+                if max_size < this_size {\n+                    max_size = this_size;\n+                }\n+            }\n+            cx.enum_sizes.insert(t, max_size);\n+            return max_size;\n         }\n-        cx.enum_sizes.insert(t, max_size);\n-        return max_size;\n-      }\n-      _ => cx.sess.bug(~\"static_size_of_enum called on non-enum\")\n+        _ => cx.sess.bug(~\"static_size_of_enum called on non-enum\")\n     }\n }\n "}, {"sha": "d87674f6b6e84863c842bc75056184409f15446c", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 104, "deletions": 15, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/8d8c25b825f109c9ae33ff0e52a061b62ae9f434/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8c25b825f109c9ae33ff0e52a061b62ae9f434/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=8d8c25b825f109c9ae33ff0e52a061b62ae9f434", "patch": "@@ -89,6 +89,95 @@ pub fn type_of_non_gc_box(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     }\n }\n \n+// A \"sizing type\" is an LLVM type, the size and alignment of which are\n+// guaranteed to be equivalent to what you would get out of `type_of()`. It's\n+// useful because:\n+//\n+// (1) It may be cheaper to compute the sizing type than the full type if all\n+//     you're interested in is the size and/or alignment;\n+//\n+// (2) It won't make any recursive calls to determine the structure of the\n+//     type behind pointers. This can help prevent infinite loops for\n+//     recursive types. For example, `static_size_of_enum()` relies on this\n+//     behavior.\n+\n+pub fn sizing_type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n+    if cx.llsizingtypes.contains_key(&t) {\n+        return cx.llsizingtypes.get(&t);\n+    }\n+\n+    let llsizingty = match ty::get(t).sty {\n+        ty::ty_nil | ty::ty_bot => T_nil(),\n+        ty::ty_bool => T_bool(),\n+        ty::ty_int(t) => T_int_ty(cx, t),\n+        ty::ty_uint(t) => T_uint_ty(cx, t),\n+        ty::ty_float(t) => T_float_ty(cx, t),\n+\n+        ty::ty_estr(ty::vstore_uniq) |\n+        ty::ty_estr(ty::vstore_box) |\n+        ty::ty_evec(_, ty::vstore_uniq) |\n+        ty::ty_evec(_, ty::vstore_box) |\n+        ty::ty_box(*) |\n+        ty::ty_opaque_box |\n+        ty::ty_uniq(*) |\n+        ty::ty_ptr(*) |\n+        ty::ty_rptr(*) |\n+        ty::ty_type |\n+        ty::ty_opaque_closure_ptr(*) => T_ptr(T_i8()),\n+\n+        ty::ty_estr(ty::vstore_slice(*)) |\n+        ty::ty_evec(_, ty::vstore_slice(*)) => {\n+            T_struct(~[T_ptr(T_i8()), T_ptr(T_i8())])\n+        }\n+\n+        // FIXME(#4804) Bare fn repr\n+        ty::ty_bare_fn(*) => T_struct(~[T_ptr(T_i8()), T_ptr(T_i8())]),\n+        ty::ty_closure(*) => T_struct(~[T_ptr(T_i8()), T_ptr(T_i8())]),\n+        ty::ty_trait(_, _, vstore) => T_opaque_trait(cx, vstore),\n+\n+        ty::ty_estr(ty::vstore_fixed(size)) => T_array(T_i8(), size),\n+        ty::ty_evec(mt, ty::vstore_fixed(size)) => {\n+            T_array(sizing_type_of(cx, mt.ty), size)\n+        }\n+\n+        ty::ty_unboxed_vec(mt) => T_vec(cx, sizing_type_of(cx, mt.ty)),\n+\n+        ty::ty_tup(ref elems) => {\n+            T_struct(elems.map(|&t| sizing_type_of(cx, t)))\n+        }\n+\n+        ty::ty_rec(ref fields) => {\n+            T_struct(fields.map(|f| sizing_type_of(cx, f.mt.ty)))\n+        }\n+\n+        ty::ty_struct(def_id, ref substs) => {\n+            let fields = ty::lookup_struct_fields(cx.tcx, def_id);\n+            let lltype = T_struct(fields.map(|field| {\n+                let field_type = ty::lookup_field_type(cx.tcx,\n+                                                       def_id,\n+                                                       field.id,\n+                                                       substs);\n+                sizing_type_of(cx, field_type)\n+            }));\n+            if ty::ty_dtor(cx.tcx, def_id).is_present() {\n+                T_struct(~[lltype, T_i8()])\n+            } else {\n+                lltype\n+            }\n+        }\n+\n+        ty::ty_enum(def_id, _) => T_struct(enum_body_types(cx, def_id, t)),\n+\n+        ty::ty_self | ty::ty_infer(*) | ty::ty_param(*) | ty::ty_err(*) => {\n+            cx.tcx.sess.bug(~\"fictitious type in sizing_type_of()\")\n+        }\n+    };\n+\n+    cx.llsizingtypes.insert(t, llsizingty);\n+    llsizingty\n+}\n+\n+// NB: If you update this, be sure to update `sizing_type_of()` as well.\n pub fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     debug!(\"type_of %?: %?\", t, ty::get(t));\n \n@@ -236,23 +325,23 @@ pub fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     return llty;\n }\n \n-pub fn fill_type_of_enum(cx: @crate_ctxt, did: ast::def_id, t: ty::t,\n-                         llty: TypeRef) {\n+pub fn enum_body_types(cx: @crate_ctxt, did: ast::def_id, t: ty::t)\n+                    -> ~[TypeRef] {\n+    let univar = ty::enum_is_univariant(cx.tcx, did);\n+    let size = machine::static_size_of_enum(cx, t);\n+    if !univar {\n+        ~[T_enum_discrim(cx), T_array(T_i8(), size)]\n+    } else {\n+        ~[T_array(T_i8(), size)]\n+    }\n+}\n \n+pub fn fill_type_of_enum(cx: @crate_ctxt,\n+                         did: ast::def_id,\n+                         t: ty::t,\n+                         llty: TypeRef) {\n     debug!(\"type_of_enum %?: %?\", t, ty::get(t));\n-\n-    let lltys = {\n-        let univar = ty::enum_is_univariant(cx.tcx, did);\n-        let size = machine::static_size_of_enum(cx, t);\n-        if !univar {\n-            ~[T_enum_discrim(cx), T_array(T_i8(), size)]\n-        }\n-        else {\n-            ~[T_array(T_i8(), size)]\n-        }\n-    };\n-\n-    common::set_struct_body(llty, lltys);\n+    common::set_struct_body(llty, enum_body_types(cx, did, t));\n }\n \n // Want refinements! (Or case classes, I guess"}]}