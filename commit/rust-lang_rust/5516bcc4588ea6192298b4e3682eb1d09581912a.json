{"sha": "5516bcc4588ea6192298b4e3682eb1d09581912a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1MTZiY2M0NTg4ZWE2MTkyMjk4YjRlMzY4MmViMWQwOTU4MTkxMmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-17T17:56:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-17T17:56:29Z"}, "message": "Auto merge of #41345 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 3 pull requests\n\n- Successful merges: #41012, #41280, #41290\n- Failed merges:", "tree": {"sha": "9b392d0f56be959b8b36d24e645c6ed5150d867c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b392d0f56be959b8b36d24e645c6ed5150d867c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5516bcc4588ea6192298b4e3682eb1d09581912a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5516bcc4588ea6192298b4e3682eb1d09581912a", "html_url": "https://github.com/rust-lang/rust/commit/5516bcc4588ea6192298b4e3682eb1d09581912a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5516bcc4588ea6192298b4e3682eb1d09581912a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "011f240b898899644039bae4933ee8bd03efd609", "url": "https://api.github.com/repos/rust-lang/rust/commits/011f240b898899644039bae4933ee8bd03efd609", "html_url": "https://github.com/rust-lang/rust/commit/011f240b898899644039bae4933ee8bd03efd609"}, {"sha": "07c6295137753cb2a060d53e04b688dac3ced751", "url": "https://api.github.com/repos/rust-lang/rust/commits/07c6295137753cb2a060d53e04b688dac3ced751", "html_url": "https://github.com/rust-lang/rust/commit/07c6295137753cb2a060d53e04b688dac3ced751"}], "stats": {"total": 785, "additions": 742, "deletions": 43}, "files": [{"sha": "9003f0750a23145ef721e720da7c0c7fbdf2ff82", "filename": ".gitmodules", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5516bcc4588ea6192298b4e3682eb1d09581912a/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/5516bcc4588ea6192298b4e3682eb1d09581912a/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=5516bcc4588ea6192298b4e3682eb1d09581912a", "patch": "@@ -5,6 +5,10 @@\n [submodule \"src/compiler-rt\"]\n \tpath = src/compiler-rt\n \turl = https://github.com/rust-lang/compiler-rt.git\n+[submodule \"src/rt/hoedown\"]\n+\tpath = src/rt/hoedown\n+\turl = https://github.com/rust-lang/hoedown.git\n+\tbranch = rust-2015-09-21-do-not-delete\n [submodule \"src/jemalloc\"]\n \tpath = src/jemalloc\n \turl = https://github.com/rust-lang/jemalloc.git"}, {"sha": "abe899803087120379021a1b88dd85ca4533cca0", "filename": "COPYRIGHT", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5516bcc4588ea6192298b4e3682eb1d09581912a/COPYRIGHT", "raw_url": "https://github.com/rust-lang/rust/raw/5516bcc4588ea6192298b4e3682eb1d09581912a/COPYRIGHT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/COPYRIGHT?ref=5516bcc4588ea6192298b4e3682eb1d09581912a", "patch": "@@ -197,6 +197,28 @@ their own copyright notices and license terms:\n     USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\n     OF SUCH DAMAGE.\n \n+* Hoedown, the markdown parser, under src/rt/hoedown, is\n+  licensed as follows.\n+\n+    Copyright (c) 2008, Natacha Port\u00e9\n+    Copyright (c) 2011, Vicent Mart\u00ed\n+    Copyright (c) 2013, Devin Torres and the Hoedown authors\n+\n+    Permission to use, copy, modify, and distribute this\n+    software for any purpose with or without fee is hereby\n+    granted, provided that the above copyright notice and\n+    this permission notice appear in all copies.\n+\n+    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR\n+    DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE\n+    INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+    FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n+    SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR\n+    ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA\n+    OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n+    OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\n+    CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+\n * libbacktrace, under src/libbacktrace:\n \n     Copyright (C) 2012-2014 Free Software Foundation, Inc."}, {"sha": "42af79b8bb07fe112e1b8ad385c276eedd4e918e", "filename": "src/doc/unstable-book/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md?ref=5516bcc4588ea6192298b4e3682eb1d09581912a", "patch": "@@ -114,6 +114,7 @@\n - [lookup_host](lookup-host.md)\n - [loop_break_value](loop-break-value.md)\n - [macro_reexport](macro-reexport.md)\n+- [macro_vis_matcher](macro-vis-matcher.md)\n - [main](main.md)\n - [manually_drop](manually-drop.md)\n - [map_entry_recover_keys](map-entry-recover-keys.md)"}, {"sha": "7918a356843298d34cc458ed40d1b9e5fc075478", "filename": "src/doc/unstable-book/src/macro-vis-matcher.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Fdoc%2Funstable-book%2Fsrc%2Fmacro-vis-matcher.md", "raw_url": "https://github.com/rust-lang/rust/raw/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Fdoc%2Funstable-book%2Fsrc%2Fmacro-vis-matcher.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fmacro-vis-matcher.md?ref=5516bcc4588ea6192298b4e3682eb1d09581912a", "patch": "@@ -0,0 +1,14 @@\n+# `macro_vis_matcher`\n+\n+The tracking issue for this feature is: [#41022]\n+\n+With this feature gate enabled, the [list of fragment specifiers][frags] gains one more entry:\n+\n+* `vis`: a visibility qualifier. Examples: nothing (default visibility); `pub`; `pub(crate)`.\n+\n+A `vis` variable may be followed by a comma, ident, type, or path.\n+\n+[#41022]: https://github.com/rust-lang/rust/issues/41022\n+[frags]: ../book/first-edition/macros.html#syntactic-requirements\n+\n+------------------------"}, {"sha": "c797c151de67c602f2a71a1cd302a8e3d5da6933", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=5516bcc4588ea6192298b4e3682eb1d09581912a", "patch": "@@ -521,7 +521,9 @@ impl<'a> Resolver<'a> {\n             LoadedMacro::ProcMacro(ext) => return ext,\n         };\n \n-        let ext = Rc::new(macro_rules::compile(&self.session.parse_sess, &macro_def));\n+        let ext = Rc::new(macro_rules::compile(&self.session.parse_sess,\n+                                               &self.session.features,\n+                                               &macro_def));\n         self.macro_map.insert(def_id, ext.clone());\n         ext\n     }"}, {"sha": "030e3936de994fb24c436b5bb389e209855afd75", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=5516bcc4588ea6192298b4e3682eb1d09581912a", "patch": "@@ -671,7 +671,9 @@ impl<'a> Resolver<'a> {\n         }\n \n         let def_id = self.definitions.local_def_id(item.id);\n-        let ext = Rc::new(macro_rules::compile(&self.session.parse_sess, item));\n+        let ext = Rc::new(macro_rules::compile(&self.session.parse_sess,\n+                                               &self.session.features,\n+                                               item));\n         self.macro_map.insert(def_id, ext);\n         *legacy_scope = LegacyScope::Binding(self.arenas.alloc_legacy_binding(LegacyBinding {\n             parent: Cell::new(*legacy_scope), name: ident.name, def_id: def_id, span: item.span,"}, {"sha": "d1c98a5c6f16566b4b8c96bb00c53bcf30e01a8c", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=5516bcc4588ea6192298b4e3682eb1d09581912a", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"rustdoc\"\n version = \"0.0.0\"\n+build = \"build.rs\"\n \n [lib]\n name = \"rustdoc\""}, {"sha": "4189e3d2ac7073f3cb23f5219aafc18eafd8b4ee", "filename": "src/librustdoc/build.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibrustdoc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibrustdoc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fbuild.rs?ref=5516bcc4588ea6192298b4e3682eb1d09581912a", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate build_helper;\n+extern crate gcc;\n+\n+fn main() {\n+    let src_dir = std::path::Path::new(\"../rt/hoedown/src\");\n+    build_helper::rerun_if_changed_anything_in_dir(src_dir);\n+    let mut cfg = gcc::Config::new();\n+    cfg.file(\"../rt/hoedown/src/autolink.c\")\n+       .file(\"../rt/hoedown/src/buffer.c\")\n+       .file(\"../rt/hoedown/src/document.c\")\n+       .file(\"../rt/hoedown/src/escape.c\")\n+       .file(\"../rt/hoedown/src/html.c\")\n+       .file(\"../rt/hoedown/src/html_blocks.c\")\n+       .file(\"../rt/hoedown/src/html_smartypants.c\")\n+       .file(\"../rt/hoedown/src/stack.c\")\n+       .file(\"../rt/hoedown/src/version.c\")\n+       .include(src_dir)\n+       .compile(\"libhoedown.a\");\n+}\n+"}, {"sha": "998386353561ebc8b6b2ad8f4f436fe67ad08797", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5516bcc4588ea6192298b4e3682eb1d09581912a", "patch": "@@ -292,7 +292,7 @@ impl Item {\n         self.type_() == ItemType::Struct\n     }\n     pub fn is_enum(&self) -> bool {\n-        self.type_() == ItemType::Module\n+        self.type_() == ItemType::Enum\n     }\n     pub fn is_fn(&self) -> bool {\n         self.type_() == ItemType::Function\n@@ -312,6 +312,9 @@ impl Item {\n     pub fn is_primitive(&self) -> bool {\n         self.type_() == ItemType::Primitive\n     }\n+    pub fn is_union(&self) -> bool {\n+        self.type_() == ItemType::Union\n+    }\n     pub fn is_stripped(&self) -> bool {\n         match self.inner { StrippedItem(..) => true, _ => false }\n     }"}, {"sha": "b02b60531d108dc41a7da893e09a03be59cb9aed", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=5516bcc4588ea6192298b4e3682eb1d09581912a", "patch": "@@ -25,6 +25,9 @@\n \n #![allow(non_camel_case_types)]\n \n+use libc;\n+use std::slice;\n+\n use std::ascii::AsciiExt;\n use std::cell::RefCell;\n use std::collections::{HashMap, VecDeque};\n@@ -357,6 +360,194 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for Footnotes<'a, I> {\n     }\n }\n \n+const DEF_OUNIT: libc::size_t = 64;\n+const HOEDOWN_EXT_NO_INTRA_EMPHASIS: libc::c_uint = 1 << 11;\n+const HOEDOWN_EXT_TABLES: libc::c_uint = 1 << 0;\n+const HOEDOWN_EXT_FENCED_CODE: libc::c_uint = 1 << 1;\n+const HOEDOWN_EXT_AUTOLINK: libc::c_uint = 1 << 3;\n+const HOEDOWN_EXT_STRIKETHROUGH: libc::c_uint = 1 << 4;\n+const HOEDOWN_EXT_SUPERSCRIPT: libc::c_uint = 1 << 8;\n+const HOEDOWN_EXT_FOOTNOTES: libc::c_uint = 1 << 2;\n+\n+const HOEDOWN_EXTENSIONS: libc::c_uint =\n+    HOEDOWN_EXT_NO_INTRA_EMPHASIS | HOEDOWN_EXT_TABLES |\n+    HOEDOWN_EXT_FENCED_CODE | HOEDOWN_EXT_AUTOLINK |\n+    HOEDOWN_EXT_STRIKETHROUGH | HOEDOWN_EXT_SUPERSCRIPT |\n+    HOEDOWN_EXT_FOOTNOTES;\n+\n+enum hoedown_document {}\n+\n+type blockcodefn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n+                                 *const hoedown_buffer, *const hoedown_renderer_data,\n+                                 libc::size_t);\n+\n+type blockquotefn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n+                                  *const hoedown_renderer_data, libc::size_t);\n+\n+type headerfn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n+                              libc::c_int, *const hoedown_renderer_data,\n+                              libc::size_t);\n+\n+type blockhtmlfn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n+                                 *const hoedown_renderer_data, libc::size_t);\n+\n+type codespanfn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n+                                *const hoedown_renderer_data, libc::size_t) -> libc::c_int;\n+\n+type linkfn = extern \"C\" fn (*mut hoedown_buffer, *const hoedown_buffer,\n+                             *const hoedown_buffer, *const hoedown_buffer,\n+                             *const hoedown_renderer_data, libc::size_t) -> libc::c_int;\n+\n+type entityfn = extern \"C\" fn (*mut hoedown_buffer, *const hoedown_buffer,\n+                               *const hoedown_renderer_data, libc::size_t);\n+\n+type normaltextfn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n+                                  *const hoedown_renderer_data, libc::size_t);\n+\n+#[repr(C)]\n+struct hoedown_renderer_data {\n+    opaque: *mut libc::c_void,\n+}\n+\n+#[repr(C)]\n+struct hoedown_renderer {\n+    opaque: *mut libc::c_void,\n+\n+    blockcode: Option<blockcodefn>,\n+    blockquote: Option<blockquotefn>,\n+    header: Option<headerfn>,\n+\n+    other_block_level_callbacks: [libc::size_t; 11],\n+\n+    blockhtml: Option<blockhtmlfn>,\n+\n+    /* span level callbacks - NULL or return 0 prints the span verbatim */\n+    autolink: libc::size_t, // unused\n+    codespan: Option<codespanfn>,\n+    other_span_level_callbacks_1: [libc::size_t; 7],\n+    link: Option<linkfn>,\n+    other_span_level_callbacks_2: [libc::size_t; 6],\n+\n+    /* low level callbacks - NULL copies input directly into the output */\n+    entity: Option<entityfn>,\n+    normal_text: Option<normaltextfn>,\n+\n+    /* header and footer */\n+    other_callbacks: [libc::size_t; 2],\n+}\n+\n+#[repr(C)]\n+struct hoedown_html_renderer_state {\n+    opaque: *mut libc::c_void,\n+    toc_data: html_toc_data,\n+    flags: libc::c_uint,\n+    link_attributes: Option<extern \"C\" fn(*mut hoedown_buffer,\n+                                          *const hoedown_buffer,\n+                                          *const hoedown_renderer_data)>,\n+}\n+\n+#[repr(C)]\n+struct html_toc_data {\n+    header_count: libc::c_int,\n+    current_level: libc::c_int,\n+    level_offset: libc::c_int,\n+    nesting_level: libc::c_int,\n+}\n+\n+#[repr(C)]\n+struct hoedown_buffer {\n+    data: *const u8,\n+    size: libc::size_t,\n+    asize: libc::size_t,\n+    unit: libc::size_t,\n+}\n+\n+extern {\n+    fn hoedown_html_renderer_new(render_flags: libc::c_uint,\n+                                 nesting_level: libc::c_int)\n+        -> *mut hoedown_renderer;\n+    fn hoedown_html_renderer_free(renderer: *mut hoedown_renderer);\n+\n+    fn hoedown_document_new(rndr: *const hoedown_renderer,\n+                            extensions: libc::c_uint,\n+                            max_nesting: libc::size_t) -> *mut hoedown_document;\n+    fn hoedown_document_render(doc: *mut hoedown_document,\n+                               ob: *mut hoedown_buffer,\n+                               document: *const u8,\n+                               doc_size: libc::size_t);\n+    fn hoedown_document_free(md: *mut hoedown_document);\n+\n+    fn hoedown_buffer_new(unit: libc::size_t) -> *mut hoedown_buffer;\n+    fn hoedown_buffer_free(b: *mut hoedown_buffer);\n+}\n+\n+impl hoedown_buffer {\n+    fn as_bytes(&self) -> &[u8] {\n+        unsafe { slice::from_raw_parts(self.data, self.size as usize) }\n+    }\n+}\n+\n+pub fn old_find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Span) {\n+    extern fn block(_ob: *mut hoedown_buffer,\n+                    text: *const hoedown_buffer,\n+                    lang: *const hoedown_buffer,\n+                    data: *const hoedown_renderer_data,\n+                    line: libc::size_t) {\n+        unsafe {\n+            if text.is_null() { return }\n+            let block_info = if lang.is_null() {\n+                LangString::all_false()\n+            } else {\n+                let lang = (*lang).as_bytes();\n+                let s = str::from_utf8(lang).unwrap();\n+                LangString::parse(s)\n+            };\n+            if !block_info.rust { return }\n+            let opaque = (*data).opaque as *mut hoedown_html_renderer_state;\n+            let tests = &mut *((*opaque).opaque as *mut ::test::Collector);\n+            let line = tests.get_line() + line;\n+            let filename = tests.get_filename();\n+            tests.add_old_test(line, filename);\n+        }\n+    }\n+\n+    extern fn header(_ob: *mut hoedown_buffer,\n+                     text: *const hoedown_buffer,\n+                     level: libc::c_int, data: *const hoedown_renderer_data,\n+                     _: libc::size_t) {\n+        unsafe {\n+            let opaque = (*data).opaque as *mut hoedown_html_renderer_state;\n+            let tests = &mut *((*opaque).opaque as *mut ::test::Collector);\n+            if text.is_null() {\n+                tests.register_header(\"\", level as u32);\n+            } else {\n+                let text = (*text).as_bytes();\n+                let text = str::from_utf8(text).unwrap();\n+                tests.register_header(text, level as u32);\n+            }\n+        }\n+    }\n+\n+    tests.set_position(position);\n+\n+    unsafe {\n+        let ob = hoedown_buffer_new(DEF_OUNIT);\n+        let renderer = hoedown_html_renderer_new(0, 0);\n+        (*renderer).blockcode = Some(block);\n+        (*renderer).header = Some(header);\n+        (*((*renderer).opaque as *mut hoedown_html_renderer_state)).opaque\n+                = tests as *mut _ as *mut libc::c_void;\n+\n+        let document = hoedown_document_new(renderer, HOEDOWN_EXTENSIONS, 16);\n+        hoedown_document_render(document, ob, doc.as_ptr(),\n+                                doc.len() as libc::size_t);\n+        hoedown_document_free(document);\n+\n+        hoedown_html_renderer_free(renderer);\n+        hoedown_buffer_free(ob);\n+    }\n+}\n+\n pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Span) {\n     tests.set_position(position);\n "}, {"sha": "d55a0640562aee2c336d089a2e72f7608d9aaf58", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 221, "deletions": 3, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=5516bcc4588ea6192298b4e3682eb1d09581912a", "patch": "@@ -2430,7 +2430,7 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     }).peekable();\n     if let doctree::Plain = s.struct_type {\n         if fields.peek().is_some() {\n-            write!(w, \"<h2 class='fields'>Fields</h2>\")?;\n+            write!(w, \"<h2 id='fields' class='fields'>Fields</h2>\")?;\n             for (field, ty) in fields {\n                 let id = derive_id(format!(\"{}.{}\",\n                                            ItemType::StructField,\n@@ -2478,7 +2478,7 @@ fn item_union(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         }\n     }).peekable();\n     if fields.peek().is_some() {\n-        write!(w, \"<h2 class='fields'>Fields</h2>\")?;\n+        write!(w, \"<h2 id='fields' class='fields'>Fields</h2>\")?;\n         for (field, ty) in fields {\n             write!(w, \"<span id='{shortty}.{name}' class=\\\"{shortty}\\\"><code>{name}: {ty}</code>\n                        </span>\",\n@@ -2550,7 +2550,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n \n     document(w, cx, it)?;\n     if !e.variants.is_empty() {\n-        write!(w, \"<h2 class='variants'>Variants</h2>\\n\")?;\n+        write!(w, \"<h2 id='variants' class='variants'>Variants</h2>\\n\")?;\n         for variant in &e.variants {\n             let id = derive_id(format!(\"{}.{}\",\n                                        ItemType::Variant,\n@@ -3074,6 +3074,37 @@ impl<'a> fmt::Display for Sidebar<'a> {\n         let it = self.item;\n         let parentlen = cx.current.len() - if it.is_mod() {1} else {0};\n \n+        if it.is_struct() || it.is_trait() || it.is_primitive() || it.is_union()\n+            || it.is_enum() || it.is_mod()\n+        {\n+            write!(fmt, \"<p class='location'>\")?;\n+            match it.inner {\n+                clean::StructItem(..) => write!(fmt, \"Struct \")?,\n+                clean::TraitItem(..) => write!(fmt, \"Trait \")?,\n+                clean::PrimitiveItem(..) => write!(fmt, \"Primitive Type \")?,\n+                clean::UnionItem(..) => write!(fmt, \"Union \")?,\n+                clean::EnumItem(..) => write!(fmt, \"Enum \")?,\n+                clean::ModuleItem(..) => if it.is_crate() {\n+                    write!(fmt, \"Crate \")?;\n+                } else {\n+                    write!(fmt, \"Module \")?;\n+                },\n+                _ => (),\n+            }\n+            write!(fmt, \"{}\", it.name.as_ref().unwrap())?;\n+            write!(fmt, \"</p>\")?;\n+\n+            match it.inner {\n+                clean::StructItem(ref s) => sidebar_struct(fmt, it, s)?,\n+                clean::TraitItem(ref t) => sidebar_trait(fmt, it, t)?,\n+                clean::PrimitiveItem(ref p) => sidebar_primitive(fmt, it, p)?,\n+                clean::UnionItem(ref u) => sidebar_union(fmt, it, u)?,\n+                clean::EnumItem(ref e) => sidebar_enum(fmt, it, e)?,\n+                clean::ModuleItem(ref m) => sidebar_module(fmt, it, &m.items)?,\n+                _ => (),\n+            }\n+        }\n+\n         // The sidebar is designed to display sibling functions, modules and\n         // other miscellaneous information. since there are lots of sibling\n         // items (and that causes quadratic growth in large modules),\n@@ -3116,6 +3147,193 @@ impl<'a> fmt::Display for Sidebar<'a> {\n     }\n }\n \n+fn sidebar_assoc_items(it: &clean::Item) -> String {\n+    let mut out = String::new();\n+    let c = cache();\n+    if let Some(v) = c.impls.get(&it.def_id) {\n+        if v.iter().any(|i| i.inner_impl().trait_.is_none()) {\n+            out.push_str(\"<li><a href=\\\"#methods\\\">Methods</a></li>\");\n+        }\n+\n+        if v.iter().any(|i| i.inner_impl().trait_.is_some()) {\n+            if let Some(impl_) = v.iter()\n+                                  .filter(|i| i.inner_impl().trait_.is_some())\n+                                  .find(|i| i.inner_impl().trait_.def_id() == c.deref_trait_did) {\n+                if let Some(target) = impl_.inner_impl().items.iter().filter_map(|item| {\n+                    match item.inner {\n+                        clean::TypedefItem(ref t, true) => Some(&t.type_),\n+                        _ => None,\n+                    }\n+                }).next() {\n+                    let inner_impl = target.def_id().or(target.primitive_type().and_then(|prim| {\n+                        c.primitive_locations.get(&prim).cloned()\n+                    })).and_then(|did| c.impls.get(&did));\n+                    if inner_impl.is_some() {\n+                        out.push_str(\"<li><a href=\\\"#deref-methods\\\">\");\n+                        out.push_str(&format!(\"Methods from {:#}&lt;Target={:#}&gt;\",\n+                                                  impl_.inner_impl().trait_.as_ref().unwrap(),\n+                                                  target));\n+                        out.push_str(\"</a></li>\");\n+                    }\n+                }\n+            }\n+            out.push_str(\"<li><a href=\\\"#implementations\\\">Trait Implementations</a></li>\");\n+        }\n+    }\n+\n+    out\n+}\n+\n+fn sidebar_struct(fmt: &mut fmt::Formatter, it: &clean::Item,\n+                  s: &clean::Struct) -> fmt::Result {\n+    let mut sidebar = String::new();\n+\n+    if s.fields.iter()\n+               .any(|f| if let clean::StructFieldItem(..) = f.inner { true } else { false }) {\n+        if let doctree::Plain = s.struct_type {\n+            sidebar.push_str(\"<li><a href=\\\"#fields\\\">Fields</a></li>\");\n+        }\n+    }\n+\n+    sidebar.push_str(&sidebar_assoc_items(it));\n+\n+    if !sidebar.is_empty() {\n+        write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)?;\n+    }\n+    Ok(())\n+}\n+\n+fn sidebar_trait(fmt: &mut fmt::Formatter, it: &clean::Item,\n+                 t: &clean::Trait) -> fmt::Result {\n+    let mut sidebar = String::new();\n+\n+    let has_types = t.items.iter().any(|m| m.is_associated_type());\n+    let has_consts = t.items.iter().any(|m| m.is_associated_const());\n+    let has_required = t.items.iter().any(|m| m.is_ty_method());\n+    let has_provided = t.items.iter().any(|m| m.is_method());\n+\n+    if has_types {\n+        sidebar.push_str(\"<li><a href=\\\"#associated-types\\\">Associated Types</a></li>\");\n+    }\n+    if has_consts {\n+        sidebar.push_str(\"<li><a href=\\\"#associated-const\\\">Associated Constants</a></li>\");\n+    }\n+    if has_required {\n+        sidebar.push_str(\"<li><a href=\\\"#required-methods\\\">Required Methods</a></li>\");\n+    }\n+    if has_provided {\n+        sidebar.push_str(\"<li><a href=\\\"#provided-methods\\\">Provided Methods</a></li>\");\n+    }\n+\n+    sidebar.push_str(&sidebar_assoc_items(it));\n+\n+    sidebar.push_str(\"<li><a href=\\\"#implementors\\\">Implementors</a></li>\");\n+\n+    write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)\n+}\n+\n+fn sidebar_primitive(fmt: &mut fmt::Formatter, it: &clean::Item,\n+                     _p: &clean::PrimitiveType) -> fmt::Result {\n+    let sidebar = sidebar_assoc_items(it);\n+\n+    if !sidebar.is_empty() {\n+        write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)?;\n+    }\n+    Ok(())\n+}\n+\n+fn sidebar_union(fmt: &mut fmt::Formatter, it: &clean::Item,\n+                 u: &clean::Union) -> fmt::Result {\n+    let mut sidebar = String::new();\n+\n+    if u.fields.iter()\n+               .any(|f| if let clean::StructFieldItem(..) = f.inner { true } else { false }) {\n+        sidebar.push_str(\"<li><a href=\\\"#fields\\\">Fields</a></li>\");\n+    }\n+\n+    sidebar.push_str(&sidebar_assoc_items(it));\n+\n+    if !sidebar.is_empty() {\n+        write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)?;\n+    }\n+    Ok(())\n+}\n+\n+fn sidebar_enum(fmt: &mut fmt::Formatter, it: &clean::Item,\n+                e: &clean::Enum) -> fmt::Result {\n+    let mut sidebar = String::new();\n+\n+    if !e.variants.is_empty() {\n+        sidebar.push_str(\"<li><a href=\\\"#variants\\\">Variants</a></li>\");\n+    }\n+\n+    sidebar.push_str(&sidebar_assoc_items(it));\n+\n+    if !sidebar.is_empty() {\n+        write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)?;\n+    }\n+    Ok(())\n+}\n+\n+fn sidebar_module(fmt: &mut fmt::Formatter, _it: &clean::Item,\n+                  items: &[clean::Item]) -> fmt::Result {\n+    let mut sidebar = String::new();\n+\n+    if items.iter().any(|it| it.type_() == ItemType::ExternCrate ||\n+                             it.type_() == ItemType::Import) {\n+        sidebar.push_str(&format!(\"<li><a href=\\\"#{id}\\\">{name}</a></li>\",\n+                                  id = \"reexports\",\n+                                  name = \"Reexports\"));\n+    }\n+\n+    // ordering taken from item_module, reorder, where it prioritized elements in a certain order\n+    // to print its headings\n+    for &myty in &[ItemType::Primitive, ItemType::Module, ItemType::Macro, ItemType::Struct,\n+                   ItemType::Enum, ItemType::Constant, ItemType::Static, ItemType::Trait,\n+                   ItemType::Function, ItemType::Typedef, ItemType::Union, ItemType::Impl,\n+                   ItemType::TyMethod, ItemType::Method, ItemType::StructField, ItemType::Variant,\n+                   ItemType::AssociatedType, ItemType::AssociatedConst] {\n+        if items.iter().any(|it| {\n+            if let clean::DefaultImplItem(..) = it.inner {\n+                false\n+            } else {\n+                !maybe_ignore_item(it) && !it.is_stripped() && it.type_() == myty\n+            }\n+        }) {\n+            let (short, name) = match myty {\n+                ItemType::ExternCrate |\n+                ItemType::Import          => (\"reexports\", \"Reexports\"),\n+                ItemType::Module          => (\"modules\", \"Modules\"),\n+                ItemType::Struct          => (\"structs\", \"Structs\"),\n+                ItemType::Union           => (\"unions\", \"Unions\"),\n+                ItemType::Enum            => (\"enums\", \"Enums\"),\n+                ItemType::Function        => (\"functions\", \"Functions\"),\n+                ItemType::Typedef         => (\"types\", \"Type Definitions\"),\n+                ItemType::Static          => (\"statics\", \"Statics\"),\n+                ItemType::Constant        => (\"constants\", \"Constants\"),\n+                ItemType::Trait           => (\"traits\", \"Traits\"),\n+                ItemType::Impl            => (\"impls\", \"Implementations\"),\n+                ItemType::TyMethod        => (\"tymethods\", \"Type Methods\"),\n+                ItemType::Method          => (\"methods\", \"Methods\"),\n+                ItemType::StructField     => (\"fields\", \"Struct Fields\"),\n+                ItemType::Variant         => (\"variants\", \"Variants\"),\n+                ItemType::Macro           => (\"macros\", \"Macros\"),\n+                ItemType::Primitive       => (\"primitives\", \"Primitive Types\"),\n+                ItemType::AssociatedType  => (\"associated-types\", \"Associated Types\"),\n+                ItemType::AssociatedConst => (\"associated-consts\", \"Associated Constants\"),\n+            };\n+            sidebar.push_str(&format!(\"<li><a href=\\\"#{id}\\\">{name}</a></li>\",\n+                                      id = short,\n+                                      name = name));\n+        }\n+    }\n+\n+    if !sidebar.is_empty() {\n+        write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)?;\n+    }\n+    Ok(())\n+}\n+\n impl<'a> fmt::Display for Source<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let Source(s) = *self;"}, {"sha": "f75144c23aca9dac01277c17964809c10d6af225", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=5516bcc4588ea6192298b4e3682eb1d09581912a", "patch": "@@ -25,7 +25,7 @@ use externalfiles::{ExternalHtml, LoadStringError, load_string};\n use html::render::reset_ids;\n use html::escape::Escape;\n use html::markdown;\n-use html::markdown::{Markdown, MarkdownWithToc, find_testable_code};\n+use html::markdown::{Markdown, MarkdownWithToc, find_testable_code, old_find_testable_code};\n use test::{TestOptions, Collector};\n \n /// Separate any lines at the start of the file that begin with `# ` or `%`.\n@@ -159,6 +159,7 @@ pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n     let mut collector = Collector::new(input.to_string(), cfgs, libs, externs,\n                                        true, opts, maybe_sysroot, None,\n                                        Some(input.to_owned()));\n+    old_find_testable_code(&input_str, &mut collector, DUMMY_SP);\n     find_testable_code(&input_str, &mut collector, DUMMY_SP);\n     test_args.insert(0, \"rustdoctest\".to_string());\n     testing::test_main(&test_args, collector.tests);"}, {"sha": "fb681b20065fa3a9d70434aa59a92dc9657edf94", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=5516bcc4588ea6192298b4e3682eb1d09581912a", "patch": "@@ -380,6 +380,8 @@ fn partition_source(s: &str) -> (String, String) {\n \n pub struct Collector {\n     pub tests: Vec<testing::TestDescAndFn>,\n+    // to be removed when hoedown will be definitely gone\n+    pub old_tests: Vec<String>,\n     names: Vec<String>,\n     cfgs: Vec<String>,\n     libs: SearchPaths,\n@@ -401,6 +403,7 @@ impl Collector {\n                codemap: Option<Rc<CodeMap>>, filename: Option<String>) -> Collector {\n         Collector {\n             tests: Vec::new(),\n+            old_tests: Vec::new(),\n             names: Vec::new(),\n             cfgs: cfgs,\n             libs: libs,\n@@ -417,19 +420,36 @@ impl Collector {\n         }\n     }\n \n-    pub fn add_test(&mut self, test: String,\n-                    should_panic: bool, no_run: bool, should_ignore: bool,\n-                    as_test_harness: bool, compile_fail: bool, error_codes: Vec<String>,\n-                    line: usize, filename: String) {\n-        let name = if self.use_headers {\n+    fn generate_name(&self, line: usize, filename: &str) -> String {\n+        if self.use_headers {\n             if let Some(ref header) = self.current_header {\n                 format!(\"{} - {} (line {})\", filename, header, line)\n             } else {\n                 format!(\"{} - (line {})\", filename, line)\n             }\n         } else {\n             format!(\"{} - {} (line {})\", filename, self.names.join(\"::\"), line)\n-        };\n+        }\n+    }\n+\n+    pub fn add_old_test(&mut self, line: usize, filename: String) {\n+        let name = self.generate_name(line, &filename);\n+        self.old_tests.push(name);\n+    }\n+\n+    pub fn add_test(&mut self, test: String,\n+                    should_panic: bool, no_run: bool, should_ignore: bool,\n+                    as_test_harness: bool, compile_fail: bool, error_codes: Vec<String>,\n+                    line: usize, filename: String) {\n+        let name = self.generate_name(line, &filename);\n+        if self.old_tests.iter().find(|&x| x == &name).is_none() {\n+            let _ = writeln!(&mut io::stderr(),\n+                             \"WARNING: {} Code block is not currently run as a test, but will in \\\n+                              future versions of rustdoc. Please ensure this code block is a \\\n+                              runnable test, or use the `ignore` directive.\",\n+                             name);\n+            return\n+        }\n         let cfgs = self.cfgs.clone();\n         let libs = self.libs.clone();\n         let externs = self.externs.clone();\n@@ -544,6 +564,8 @@ impl<'a, 'hir> HirCollector<'a, 'hir> {\n         attrs.unindent_doc_comments();\n         if let Some(doc) = attrs.doc_value() {\n             self.collector.cnt = 0;\n+            markdown::old_find_testable_code(doc, self.collector,\n+                                             attrs.span.unwrap_or(DUMMY_SP));\n             markdown::find_testable_code(doc, self.collector,\n                                          attrs.span.unwrap_or(DUMMY_SP));\n         }"}, {"sha": "eb0b7c29f8d9ad8d74aa15a283c7b12f5ea1c608", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=5516bcc4588ea6192298b4e3682eb1d09581912a", "patch": "@@ -529,6 +529,7 @@ fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n             token::NtPath(panictry!(p.parse_path(PathStyle::Type)))\n         },\n         \"meta\" => token::NtMeta(panictry!(p.parse_meta_item())),\n+        \"vis\" => token::NtVis(panictry!(p.parse_visibility(true))),\n         // this is not supposed to happen, since it has been checked\n         // when compiling the macro.\n         _ => p.span_bug(sp, \"invalid fragment specifier\")"}, {"sha": "be979960725a91cfe6c7786ee0eb1d9150b9c2fb", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 58, "deletions": 21, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=5516bcc4588ea6192298b4e3682eb1d09581912a", "patch": "@@ -18,13 +18,15 @@ use ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use ext::tt::macro_parser::{parse, parse_failure_msg};\n use ext::tt::quoted;\n use ext::tt::transcribe::transcribe;\n+use feature_gate::{self, emit_feature_err, Features, GateIssue};\n use parse::{Directory, ParseSess};\n use parse::parser::Parser;\n use parse::token::{self, NtTT};\n use parse::token::Token::*;\n use symbol::Symbol;\n use tokenstream::{TokenStream, TokenTree};\n \n+use std::cell::RefCell;\n use std::collections::{HashMap};\n use std::collections::hash_map::{Entry};\n use std::rc::Rc;\n@@ -154,7 +156,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n // Holy self-referential!\n \n /// Converts a `macro_rules!` invocation into a syntax extension.\n-pub fn compile(sess: &ParseSess, def: &ast::Item) -> SyntaxExtension {\n+pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item) -> SyntaxExtension {\n     let lhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"lhs\"));\n     let rhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"rhs\"));\n \n@@ -208,7 +210,7 @@ pub fn compile(sess: &ParseSess, def: &ast::Item) -> SyntaxExtension {\n                 if let MatchedNonterminal(ref nt) = **m {\n                     if let NtTT(ref tt) = **nt {\n                         let tt = quoted::parse(tt.clone().into(), true, sess).pop().unwrap();\n-                        valid &= check_lhs_nt_follows(sess, &tt);\n+                        valid &= check_lhs_nt_follows(sess, features, &tt);\n                         return tt;\n                     }\n                 }\n@@ -251,11 +253,13 @@ pub fn compile(sess: &ParseSess, def: &ast::Item) -> SyntaxExtension {\n     NormalTT(exp, Some(def.span), attr::contains_name(&def.attrs, \"allow_internal_unstable\"))\n }\n \n-fn check_lhs_nt_follows(sess: &ParseSess, lhs: &quoted::TokenTree) -> bool {\n+fn check_lhs_nt_follows(sess: &ParseSess,\n+                        features: &RefCell<Features>,\n+                        lhs: &quoted::TokenTree) -> bool {\n     // lhs is going to be like TokenTree::Delimited(...), where the\n     // entire lhs is those tts. Or, it can be a \"bare sequence\", not wrapped in parens.\n     match lhs {\n-        &quoted::TokenTree::Delimited(_, ref tts) => check_matcher(sess, &tts.tts),\n+        &quoted::TokenTree::Delimited(_, ref tts) => check_matcher(sess, features, &tts.tts),\n         _ => {\n             let msg = \"invalid macro matcher; matchers must be contained in balanced delimiters\";\n             sess.span_diagnostic.span_err(lhs.span(), msg);\n@@ -307,11 +311,13 @@ fn check_rhs(sess: &ParseSess, rhs: &quoted::TokenTree) -> bool {\n     false\n }\n \n-fn check_matcher(sess: &ParseSess, matcher: &[quoted::TokenTree]) -> bool {\n+fn check_matcher(sess: &ParseSess,\n+                 features: &RefCell<Features>,\n+                 matcher: &[quoted::TokenTree]) -> bool {\n     let first_sets = FirstSets::new(matcher);\n     let empty_suffix = TokenSet::empty();\n     let err = sess.span_diagnostic.err_count();\n-    check_matcher_core(sess, &first_sets, matcher, &empty_suffix);\n+    check_matcher_core(sess, features, &first_sets, matcher, &empty_suffix);\n     err == sess.span_diagnostic.err_count()\n }\n \n@@ -553,6 +559,7 @@ impl TokenSet {\n // Requires that `first_sets` is pre-computed for `matcher`;\n // see `FirstSets::new`.\n fn check_matcher_core(sess: &ParseSess,\n+                      features: &RefCell<Features>,\n                       first_sets: &FirstSets,\n                       matcher: &[quoted::TokenTree],\n                       follow: &TokenSet) -> TokenSet {\n@@ -583,12 +590,11 @@ fn check_matcher_core(sess: &ParseSess,\n         match *token {\n             TokenTree::Token(..) | TokenTree::MetaVarDecl(..) => {\n                 let can_be_followed_by_any;\n-                if let Err(bad_frag) = has_legal_fragment_specifier(token) {\n+                if let Err(bad_frag) = has_legal_fragment_specifier(sess, features, token) {\n                     let msg = format!(\"invalid fragment specifier `{}`\", bad_frag);\n                     sess.span_diagnostic.struct_span_err(token.span(), &msg)\n-                        .help(\"valid fragment specifiers are `ident`, `block`, \\\n-                               `stmt`, `expr`, `pat`, `ty`, `path`, `meta`, `tt` \\\n-                               and `item`\")\n+                        .help(\"valid fragment specifiers are `ident`, `block`, `stmt`, `expr`, \\\n+                              `pat`, `ty`, `path`, `meta`, `tt`, `item` and `vis`\")\n                         .emit();\n                     // (This eliminates false positives and duplicates\n                     // from error messages.)\n@@ -610,7 +616,7 @@ fn check_matcher_core(sess: &ParseSess,\n             }\n             TokenTree::Delimited(span, ref d) => {\n                 let my_suffix = TokenSet::singleton(d.close_tt(span));\n-                check_matcher_core(sess, first_sets, &d.tts, &my_suffix);\n+                check_matcher_core(sess, features, first_sets, &d.tts, &my_suffix);\n                 // don't track non NT tokens\n                 last.replace_with_irrelevant();\n \n@@ -642,7 +648,7 @@ fn check_matcher_core(sess: &ParseSess,\n                 // At this point, `suffix_first` is built, and\n                 // `my_suffix` is some TokenSet that we can use\n                 // for checking the interior of `seq_rep`.\n-                let next = check_matcher_core(sess, first_sets, &seq_rep.tts, my_suffix);\n+                let next = check_matcher_core(sess, features, first_sets, &seq_rep.tts, my_suffix);\n                 if next.maybe_empty {\n                     last.add_all(&next);\n                 } else {\n@@ -790,30 +796,61 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> Result<bool, (String, &'\n                 // harmless\n                 Ok(true)\n             },\n+            \"vis\" => {\n+                // Explicitly disallow `priv`, on the off chance it comes back.\n+                match *tok {\n+                    TokenTree::Token(_, ref tok) => match *tok {\n+                        Comma => Ok(true),\n+                        Ident(i) if i.name != \"priv\" => Ok(true),\n+                        ref tok => Ok(tok.can_begin_type())\n+                    },\n+                    TokenTree::MetaVarDecl(_, _, frag) if frag.name == \"ident\"\n+                                                       || frag.name == \"ty\"\n+                                                       || frag.name == \"path\" => Ok(true),\n+                    _ => Ok(false)\n+                }\n+            },\n             \"\" => Ok(true), // keywords::Invalid\n             _ => Err((format!(\"invalid fragment specifier `{}`\", frag),\n                      \"valid fragment specifiers are `ident`, `block`, \\\n-                      `stmt`, `expr`, `pat`, `ty`, `path`, `meta`, `tt` \\\n-                      and `item`\"))\n+                      `stmt`, `expr`, `pat`, `ty`, `path`, `meta`, `tt`, \\\n+                      `item` and `vis`\"))\n         }\n     }\n }\n \n-fn has_legal_fragment_specifier(tok: &quoted::TokenTree) -> Result<(), String> {\n+fn has_legal_fragment_specifier(sess: &ParseSess,\n+                                features: &RefCell<Features>,\n+                                tok: &quoted::TokenTree) -> Result<(), String> {\n     debug!(\"has_legal_fragment_specifier({:?})\", tok);\n-    if let quoted::TokenTree::MetaVarDecl(_, _, frag_spec) = *tok {\n-        let s = &frag_spec.name.as_str();\n-        if !is_legal_fragment_specifier(s) {\n-            return Err(s.to_string());\n+    if let quoted::TokenTree::MetaVarDecl(_, _, ref frag_spec) = *tok {\n+        let frag_name = frag_spec.name.as_str();\n+        let frag_span = tok.span();\n+        if !is_legal_fragment_specifier(sess, features, &frag_name, frag_span) {\n+            return Err(frag_name.to_string());\n         }\n     }\n     Ok(())\n }\n \n-fn is_legal_fragment_specifier(frag: &str) -> bool {\n-    match frag {\n+fn is_legal_fragment_specifier(sess: &ParseSess,\n+                               features: &RefCell<Features>,\n+                               frag_name: &str,\n+                               frag_span: Span) -> bool {\n+    match frag_name {\n         \"item\" | \"block\" | \"stmt\" | \"expr\" | \"pat\" |\n         \"path\" | \"ty\" | \"ident\" | \"meta\" | \"tt\" | \"\" => true,\n+        \"vis\" => {\n+            if !features.borrow().macro_vis_matcher {\n+                let explain = feature_gate::EXPLAIN_VIS_MATCHER;\n+                emit_feature_err(sess,\n+                                 \"macro_vis_matcher\",\n+                                 frag_span,\n+                                 GateIssue::Language,\n+                                 explain);\n+            }\n+            true\n+        },\n         _ => false,\n     }\n }"}, {"sha": "129674b74769c154d9b4f11a568f5e9acce7fa00", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=5516bcc4588ea6192298b4e3682eb1d09581912a", "patch": "@@ -352,6 +352,9 @@ declare_features! (\n \n     // Allows overlapping impls of marker traits\n     (active, overlapping_marker_traits, \"1.18.0\", Some(29864)),\n+\n+    // Allows use of the :vis macro fragment specifier\n+    (active, macro_vis_matcher, \"1.18.0\", Some(41022)),\n );\n \n declare_features! (\n@@ -1012,6 +1015,9 @@ pub const EXPLAIN_DEPR_CUSTOM_DERIVE: &'static str =\n pub const EXPLAIN_DERIVE_UNDERSCORE: &'static str =\n     \"attributes of the form `#[derive_*]` are reserved for the compiler\";\n \n+pub const EXPLAIN_VIS_MATCHER: &'static str =\n+    \":vis fragment specifier is experimental and subject to change\";\n+\n pub const EXPLAIN_PLACEMENT_IN: &'static str =\n     \"placement-in expression syntax is experimental and subject to change.\";\n "}, {"sha": "f39399a62e856c366fb62d73361cc8c68b3b6121", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=5516bcc4588ea6192298b4e3682eb1d09581912a", "patch": "@@ -636,6 +636,7 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n         token::NtWhereClause(where_clause) =>\n             token::NtWhereClause(fld.fold_where_clause(where_clause)),\n         token::NtArg(arg) => token::NtArg(fld.fold_arg(arg)),\n+        token::NtVis(vis) => token::NtVis(fld.fold_vis(vis)),\n     }\n }\n "}, {"sha": "3e71c0f0f68e3c63bc01da9d4df91aaa9824a5ef", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5516bcc4588ea6192298b4e3682eb1d09581912a", "patch": "@@ -5056,7 +5056,9 @@ impl<'a> Parser<'a> {\n     /// and `pub(super)` for `pub(in super)`.  If the following element can't be a tuple (i.e. it's\n     /// a function definition, it's not a tuple struct field) and the contents within the parens\n     /// isn't valid, emit a proper diagnostic.\n-    fn parse_visibility(&mut self, can_take_tuple: bool) -> PResult<'a, Visibility> {\n+    pub fn parse_visibility(&mut self, can_take_tuple: bool) -> PResult<'a, Visibility> {\n+        maybe_whole!(self, NtVis, |x| x);\n+\n         if !self.eat_keyword(keywords::Pub) {\n             return Ok(Visibility::Inherited)\n         }"}, {"sha": "25cabef70c15b5765b89a916db34a457a62a6e95", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=5516bcc4588ea6192298b4e3682eb1d09581912a", "patch": "@@ -363,6 +363,7 @@ pub enum Nonterminal {\n     /// Stuff inside brackets for attributes\n     NtMeta(ast::MetaItem),\n     NtPath(ast::Path),\n+    NtVis(ast::Visibility),\n     NtTT(TokenTree),\n     // These are not exposed to macros, but are used by quasiquote.\n     NtArm(ast::Arm),\n@@ -392,6 +393,7 @@ impl fmt::Debug for Nonterminal {\n             NtGenerics(..) => f.pad(\"NtGenerics(..)\"),\n             NtWhereClause(..) => f.pad(\"NtWhereClause(..)\"),\n             NtArg(..) => f.pad(\"NtArg(..)\"),\n+            NtVis(..) => f.pad(\"NtVis(..)\"),\n         }\n     }\n }"}, {"sha": "be1d26f8fe4872c5f82346707883d50141ee3c2c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5516bcc4588ea6192298b4e3682eb1d09581912a", "patch": "@@ -293,6 +293,7 @@ pub fn token_to_string(tok: &Token) -> String {\n             token::NtGenerics(ref e)    => generics_to_string(&e),\n             token::NtWhereClause(ref e) => where_clause_to_string(&e),\n             token::NtArg(ref e)         => arg_to_string(&e),\n+            token::NtVis(ref e)         => vis_to_string(&e),\n         }\n     }\n }\n@@ -373,6 +374,10 @@ pub fn ident_to_string(id: ast::Ident) -> String {\n     to_string(|s| s.print_ident(id))\n }\n \n+pub fn vis_to_string(v: &ast::Visibility) -> String {\n+    to_string(|s| s.print_visibility(v))\n+}\n+\n pub fn fun_to_string(decl: &ast::FnDecl,\n                      unsafety: ast::Unsafety,\n                      constness: ast::Constness,\n@@ -427,13 +432,7 @@ pub fn mac_to_string(arg: &ast::Mac) -> String {\n }\n \n pub fn visibility_qualified(vis: &ast::Visibility, s: &str) -> String {\n-    match *vis {\n-        ast::Visibility::Public => format!(\"pub {}\", s),\n-        ast::Visibility::Crate(_) => format!(\"pub(crate) {}\", s),\n-        ast::Visibility::Restricted { ref path, .. } =>\n-            format!(\"pub({}) {}\", to_string(|s| s.print_path(path, false, 0, true)), s),\n-        ast::Visibility::Inherited => s.to_string()\n-    }\n+    format!(\"{}{}\", to_string(|s| s.print_visibility(vis)), s)\n }\n \n fn needs_parentheses(expr: &ast::Expr) -> bool {\n@@ -1468,7 +1467,11 @@ impl<'a> State<'a> {\n             ast::Visibility::Crate(_) => self.word_nbsp(\"pub(crate)\"),\n             ast::Visibility::Restricted { ref path, .. } => {\n                 let path = to_string(|s| s.print_path(path, false, 0, true));\n-                self.word_nbsp(&format!(\"pub({})\", path))\n+                if path == \"self\" || path == \"super\" {\n+                    self.word_nbsp(&format!(\"pub({})\", path))\n+                } else {\n+                    self.word_nbsp(&format!(\"pub(in {})\", path))\n+                }\n             }\n             ast::Visibility::Inherited => Ok(())\n         }"}, {"sha": "da282f1bb7277b4d30fa1599ee29ad8eb4dd2a92", "filename": "src/rt/hoedown", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fhoedown?ref=5516bcc4588ea6192298b4e3682eb1d09581912a", "patch": "@@ -0,0 +1 @@\n+Subproject commit da282f1bb7277b4d30fa1599ee29ad8eb4dd2a92"}, {"sha": "5d6f2acea83cea7c31da88f4f36a91de4b8988f1", "filename": "src/test/compile-fail/feature-gate-macro-vis-matcher.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Ftest%2Fcompile-fail%2Ffeature-gate-macro-vis-matcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Ftest%2Fcompile-fail%2Ffeature-gate-macro-vis-matcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-macro-vis-matcher.rs?ref=5516bcc4588ea6192298b4e3682eb1d09581912a", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the MSP430 interrupt ABI cannot be used when msp430_interrupt\n+// feature gate is not used.\n+\n+macro_rules! m { ($v:vis) => {} }\n+//~^ ERROR :vis fragment specifier is experimental and subject to change\n+\n+fn main() {\n+    m!(pub);\n+}"}, {"sha": "d79f4b65b69e1579da65ccfd8379da143eae648c", "filename": "src/test/run-pass/macro-pub-matcher.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Ftest%2Frun-pass%2Fmacro-pub-matcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Ftest%2Frun-pass%2Fmacro-pub-matcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-pub-matcher.rs?ref=5516bcc4588ea6192298b4e3682eb1d09581912a", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code, unused_imports)]\n+#![feature(macro_vis_matcher)]\n+\n+/**\n+Ensure that `:vis` matches can be captured in existing positions, and passed\n+through without the need for reparse tricks.\n+*/\n+macro_rules! vis_passthru {\n+    ($vis:vis const $name:ident: $ty:ty = $e:expr;) => { $vis const $name: $ty = $e; };\n+    ($vis:vis enum $name:ident {}) => { $vis struct $name {} };\n+    ($vis:vis extern \"C\" fn $name:ident() {}) => { $vis extern \"C\" fn $name() {} };\n+    ($vis:vis fn $name:ident() {}) => { $vis fn $name() {} };\n+    ($vis:vis mod $name:ident {}) => { $vis mod $name {} };\n+    ($vis:vis static $name:ident: $ty:ty = $e:expr;) => { $vis static $name: $ty = $e; };\n+    ($vis:vis struct $name:ident;) => { $vis struct $name; };\n+    ($vis:vis trait $name:ident {}) => { $vis trait $name {} };\n+    ($vis:vis type $name:ident = $ty:ty;) => { $vis type $name = $ty; };\n+    ($vis:vis use $path:ident as $name:ident;) => { $vis use self::$path as $name; };\n+}\n+\n+mod with_pub {\n+    vis_passthru! { pub const A: i32 = 0; }\n+    vis_passthru! { pub enum B {} }\n+    vis_passthru! { pub extern \"C\" fn c() {} }\n+    vis_passthru! { pub mod d {} }\n+    vis_passthru! { pub static E: i32 = 0; }\n+    vis_passthru! { pub struct F; }\n+    vis_passthru! { pub trait G {} }\n+    vis_passthru! { pub type H = i32; }\n+    vis_passthru! { pub use A as I; }\n+}\n+\n+mod without_pub {\n+    vis_passthru! { const A: i32 = 0; }\n+    vis_passthru! { enum B {} }\n+    vis_passthru! { extern \"C\" fn c() {} }\n+    vis_passthru! { mod d {} }\n+    vis_passthru! { static E: i32 = 0; }\n+    vis_passthru! { struct F; }\n+    vis_passthru! { trait G {} }\n+    vis_passthru! { type H = i32; }\n+    vis_passthru! { use A as I; }\n+}\n+\n+mod with_pub_restricted {\n+    vis_passthru! { pub(crate) const A: i32 = 0; }\n+    vis_passthru! { pub(crate) enum B {} }\n+    vis_passthru! { pub(crate) extern \"C\" fn c() {} }\n+    vis_passthru! { pub(crate) mod d {} }\n+    vis_passthru! { pub(crate) static E: i32 = 0; }\n+    vis_passthru! { pub(crate) struct F; }\n+    vis_passthru! { pub(crate) trait G {} }\n+    vis_passthru! { pub(crate) type H = i32; }\n+    vis_passthru! { pub(crate) use A as I; }\n+}\n+\n+mod garden {\n+    mod with_pub_restricted_path {\n+        vis_passthru! { pub(in garden) const A: i32 = 0; }\n+        vis_passthru! { pub(in garden) enum B {} }\n+        vis_passthru! { pub(in garden) extern \"C\" fn c() {} }\n+        vis_passthru! { pub(in garden) mod d {} }\n+        vis_passthru! { pub(in garden) static E: i32 = 0; }\n+        vis_passthru! { pub(in garden) struct F; }\n+        vis_passthru! { pub(in garden) trait G {} }\n+        vis_passthru! { pub(in garden) type H = i32; }\n+        vis_passthru! { pub(in garden) use A as I; }\n+    }\n+}\n+\n+/*\n+Ensure that the `:vis` matcher works in a more complex situation: parsing a\n+struct definition.\n+*/\n+macro_rules! vis_parse_struct {\n+    ($(#[$($attrs:tt)*])* $vis:vis struct $name:ident {$($body:tt)*}) => {\n+        vis_parse_struct! { @parse_fields $(#[$($attrs)*])*, $vis, $name, $($body)* }\n+    };\n+\n+    ($(#[$($attrs:tt)*])* $vis:vis struct $name:ident ($($body:tt)*);) => {\n+        vis_parse_struct! { @parse_tuple $(#[$($attrs)*])*, $vis, $name, $($body)* }\n+    };\n+\n+    (@parse_fields\n+     $(#[$attrs:meta])*, $vis:vis, $name:ident, $($fvis:vis $fname:ident: $fty:ty),* $(,)*) => {\n+        $(#[$attrs])* $vis struct $name { $($fvis $fname: $fty,)* }\n+    };\n+\n+    (@parse_tuple\n+     $(#[$attrs:meta])*, $vis:vis, $name:ident, $($fvis:vis $fty:ty),* $(,)*) => {\n+        $(#[$attrs])* $vis struct $name ( $($fvis $fty,)* );\n+    };\n+}\n+\n+mod test_struct {\n+    vis_parse_struct! { pub(crate) struct A { pub a: i32, b: i32, pub(crate) c: i32 } }\n+    vis_parse_struct! { pub struct B { a: i32, pub(crate) b: i32, pub c: i32 } }\n+    vis_parse_struct! { struct C { pub(crate) a: i32, pub b: i32, c: i32 } }\n+\n+    vis_parse_struct! { pub(crate) struct D (pub i32, i32, pub(crate) i32); }\n+    vis_parse_struct! { pub struct E (i32, pub(crate) i32, pub i32); }\n+    vis_parse_struct! { struct F (pub(crate) i32, pub i32, i32); }\n+}\n+\n+fn main() {}"}, {"sha": "44063e627a362837e141bd0ad1940dfa5c94de05", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5516bcc4588ea6192298b4e3682eb1d09581912a/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=5516bcc4588ea6192298b4e3682eb1d09581912a", "patch": "@@ -86,6 +86,7 @@ fn filter_dirs(path: &Path) -> bool {\n         \"src/rust-installer\",\n         \"src/liblibc\",\n         \"src/vendor\",\n+        \"src/rt/hoedown\",\n     ];\n     skip.iter().any(|p| path.ends_with(p))\n }"}]}