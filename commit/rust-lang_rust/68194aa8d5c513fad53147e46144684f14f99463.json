{"sha": "68194aa8d5c513fad53147e46144684f14f99463", "node_id": "C_kwDOAAsO6NoAKDY4MTk0YWE4ZDVjNTEzZmFkNTMxNDdlNDYxNDQ2ODRmMTRmOTk0NjM", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-11-09T00:04:10Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-11-16T04:46:39Z"}, "message": "Use `&mut Bx` more.\n\nFor the next commit, `FunctionCx::codegen_*_terminator` need to take a\n`&mut Bx` instead of consuming a `Bx`. This triggers a cascade of\nsimilar changes across multiple functions. The resulting code is more\nconcise and replaces many `&mut bx` expressions with `bx`.", "tree": {"sha": "570ca2a062c4f3938e2f4df15e384005e8d384a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/570ca2a062c4f3938e2f4df15e384005e8d384a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68194aa8d5c513fad53147e46144684f14f99463", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68194aa8d5c513fad53147e46144684f14f99463", "html_url": "https://github.com/rust-lang/rust/commit/68194aa8d5c513fad53147e46144684f14f99463", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68194aa8d5c513fad53147e46144684f14f99463/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "html_url": "https://github.com/rust-lang/rust/commit/a00f8ba7fcac1b27341679c51bf5a3271fa82df3"}], "stats": {"total": 394, "additions": 176, "deletions": 218}, "files": [{"sha": "782f6856654a6f974f8043c72e6a4e543a8b9410", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/68194aa8d5c513fad53147e46144684f14f99463/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68194aa8d5c513fad53147e46144684f14f99463/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=68194aa8d5c513fad53147e46144684f14f99463", "patch": "@@ -755,11 +755,11 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         OperandRef { val, layout: place.layout }\n     }\n \n-    fn write_operand_repeatedly(mut self, cg_elem: OperandRef<'tcx, RValue<'gcc>>, count: u64, dest: PlaceRef<'tcx, RValue<'gcc>>) -> Self {\n+    fn write_operand_repeatedly(&mut self, cg_elem: OperandRef<'tcx, RValue<'gcc>>, count: u64, dest: PlaceRef<'tcx, RValue<'gcc>>) {\n         let zero = self.const_usize(0);\n         let count = self.const_usize(count);\n-        let start = dest.project_index(&mut self, zero).llval;\n-        let end = dest.project_index(&mut self, count).llval;\n+        let start = dest.project_index(self, zero).llval;\n+        let end = dest.project_index(self, count).llval;\n \n         let header_bb = self.append_sibling_block(\"repeat_loop_header\");\n         let body_bb = self.append_sibling_block(\"repeat_loop_body\");\n@@ -778,14 +778,13 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n         self.switch_to_block(body_bb);\n         let align = dest.align.restrict_for_offset(dest.layout.field(self.cx(), 0).size);\n-        cg_elem.val.store(&mut self, PlaceRef::new_sized_aligned(current_val, cg_elem.layout, align));\n+        cg_elem.val.store(self, PlaceRef::new_sized_aligned(current_val, cg_elem.layout, align));\n \n         let next = self.inbounds_gep(self.backend_type(cg_elem.layout), current.to_rvalue(), &[self.const_usize(1)]);\n         self.llbb().add_assignment(None, current, next);\n         self.br(header_bb);\n \n         self.switch_to_block(next_bb);\n-        self\n     }\n \n     fn range_metadata(&mut self, _load: RValue<'gcc>, _range: WrappingRange) {"}, {"sha": "77dd15ef4d8078e8c37162776318f6068b272687", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/68194aa8d5c513fad53147e46144684f14f99463/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68194aa8d5c513fad53147e46144684f14f99463/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=68194aa8d5c513fad53147e46144684f14f99463", "patch": "@@ -556,15 +556,15 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn write_operand_repeatedly(\n-        mut self,\n+        &mut self,\n         cg_elem: OperandRef<'tcx, &'ll Value>,\n         count: u64,\n         dest: PlaceRef<'tcx, &'ll Value>,\n-    ) -> Self {\n+    ) {\n         let zero = self.const_usize(0);\n         let count = self.const_usize(count);\n-        let start = dest.project_index(&mut self, zero).llval;\n-        let end = dest.project_index(&mut self, count).llval;\n+        let start = dest.project_index(self, zero).llval;\n+        let end = dest.project_index(self, count).llval;\n \n         let header_bb = self.append_sibling_block(\"repeat_loop_header\");\n         let body_bb = self.append_sibling_block(\"repeat_loop_body\");\n@@ -592,7 +592,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         body_bx.br(header_bb);\n         header_bx.add_incoming_to_phi(current, next, body_bb);\n \n-        Self::build(self.cx, next_bb)\n+        *self = Self::build(self.cx, next_bb);\n     }\n \n     fn range_metadata(&mut self, load: &'ll Value, range: WrappingRange) {"}, {"sha": "c7334e19838bdb5acd2a95a9c7b237e828091446", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 73, "deletions": 78, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/68194aa8d5c513fad53147e46144684f14f99463/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68194aa8d5c513fad53147e46144684f14f99463/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=68194aa8d5c513fad53147e46144684f14f99463", "patch": "@@ -256,16 +256,16 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n /// Codegen implementations for some terminator variants.\n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     /// Generates code for a `Resume` terminator.\n-    fn codegen_resume_terminator(&mut self, helper: TerminatorCodegenHelper<'tcx>, mut bx: Bx) {\n+    fn codegen_resume_terminator(&mut self, helper: TerminatorCodegenHelper<'tcx>, bx: &mut Bx) {\n         if let Some(funclet) = helper.funclet(self) {\n             bx.cleanup_ret(funclet, None);\n         } else {\n-            let slot = self.get_personality_slot(&mut bx);\n-            let lp0 = slot.project_field(&mut bx, 0);\n+            let slot = self.get_personality_slot(bx);\n+            let lp0 = slot.project_field(bx, 0);\n             let lp0 = bx.load_operand(lp0).immediate();\n-            let lp1 = slot.project_field(&mut bx, 1);\n+            let lp1 = slot.project_field(bx, 1);\n             let lp1 = bx.load_operand(lp1).immediate();\n-            slot.storage_dead(&mut bx);\n+            slot.storage_dead(bx);\n \n             let mut lp = bx.const_undef(self.landing_pad_type());\n             lp = bx.insert_value(lp, lp0, 0);\n@@ -277,12 +277,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     fn codegen_switchint_terminator(\n         &mut self,\n         helper: TerminatorCodegenHelper<'tcx>,\n-        mut bx: Bx,\n+        bx: &mut Bx,\n         discr: &mir::Operand<'tcx>,\n         switch_ty: Ty<'tcx>,\n         targets: &SwitchTargets,\n     ) {\n-        let discr = self.codegen_operand(&mut bx, &discr);\n+        let discr = self.codegen_operand(bx, &discr);\n         // `switch_ty` is redundant, sanity-check that.\n         assert_eq!(discr.layout.ty, switch_ty);\n         let mut target_iter = targets.iter();\n@@ -338,7 +338,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n     }\n \n-    fn codegen_return_terminator(&mut self, mut bx: Bx) {\n+    fn codegen_return_terminator(&mut self, bx: &mut Bx) {\n         // Call `va_end` if this is the definition of a C-variadic function.\n         if self.fn_abi.c_variadic {\n             // The `VaList` \"spoofed\" argument is just after all the real arguments.\n@@ -368,11 +368,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             PassMode::Direct(_) | PassMode::Pair(..) => {\n-                let op = self.codegen_consume(&mut bx, mir::Place::return_place().as_ref());\n+                let op = self.codegen_consume(bx, mir::Place::return_place().as_ref());\n                 if let Ref(llval, _, align) = op.val {\n                     bx.load(bx.backend_type(op.layout), llval, align)\n                 } else {\n-                    op.immediate_or_packed_pair(&mut bx)\n+                    op.immediate_or_packed_pair(bx)\n                 }\n             }\n \n@@ -388,8 +388,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 };\n                 let llslot = match op.val {\n                     Immediate(_) | Pair(..) => {\n-                        let scratch = PlaceRef::alloca(&mut bx, self.fn_abi.ret.layout);\n-                        op.val.store(&mut bx, scratch);\n+                        let scratch = PlaceRef::alloca(bx, self.fn_abi.ret.layout);\n+                        op.val.store(bx, scratch);\n                         scratch.llval\n                     }\n                     Ref(llval, _, align) => {\n@@ -409,7 +409,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     fn codegen_drop_terminator(\n         &mut self,\n         helper: TerminatorCodegenHelper<'tcx>,\n-        mut bx: Bx,\n+        bx: &mut Bx,\n         location: mir::Place<'tcx>,\n         target: mir::BasicBlock,\n         unwind: Option<mir::BasicBlock>,\n@@ -420,11 +420,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n             // we don't actually need to drop anything.\n-            helper.funclet_br(self, &mut bx, target);\n+            helper.funclet_br(self, bx, target);\n             return;\n         }\n \n-        let place = self.codegen_place(&mut bx, location.as_ref());\n+        let place = self.codegen_place(bx, location.as_ref());\n         let (args1, args2);\n         let mut args = if let Some(llextra) = place.llextra {\n             args2 = [place.llval, llextra];\n@@ -462,7 +462,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 args = &args[..1];\n                 (\n                     meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_DROPINPLACE)\n-                        .get_fn(&mut bx, vtable, ty, &fn_abi),\n+                        .get_fn(bx, vtable, ty, &fn_abi),\n                     fn_abi,\n                 )\n             }\n@@ -507,15 +507,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 debug!(\"args' = {:?}\", args);\n                 (\n                     meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_DROPINPLACE)\n-                        .get_fn(&mut bx, vtable, ty, &fn_abi),\n+                        .get_fn(bx, vtable, ty, &fn_abi),\n                     fn_abi,\n                 )\n             }\n             _ => (bx.get_fn_addr(drop_fn), bx.fn_abi_of_instance(drop_fn, ty::List::empty())),\n         };\n         helper.do_call(\n             self,\n-            &mut bx,\n+            bx,\n             fn_abi,\n             drop_fn,\n             args,\n@@ -528,7 +528,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     fn codegen_assert_terminator(\n         &mut self,\n         helper: TerminatorCodegenHelper<'tcx>,\n-        mut bx: Bx,\n+        bx: &mut Bx,\n         terminator: &mir::Terminator<'tcx>,\n         cond: &mir::Operand<'tcx>,\n         expected: bool,\n@@ -537,7 +537,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         cleanup: Option<mir::BasicBlock>,\n     ) {\n         let span = terminator.source_info.span;\n-        let cond = self.codegen_operand(&mut bx, cond).immediate();\n+        let cond = self.codegen_operand(bx, cond).immediate();\n         let mut const_cond = bx.const_to_opt_u128(cond, false).map(|c| c == 1);\n \n         // This case can currently arise only from functions marked\n@@ -555,7 +555,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // Don't codegen the panic block if success if known.\n         if const_cond == Some(expected) {\n-            helper.funclet_br(self, &mut bx, target);\n+            helper.funclet_br(self, bx, target);\n             return;\n         }\n \n@@ -573,16 +573,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // After this point, bx is the block for the call to panic.\n         bx.switch_to_block(panic_block);\n-        self.set_debug_loc(&mut bx, terminator.source_info);\n+        self.set_debug_loc(bx, terminator.source_info);\n \n         // Get the location information.\n-        let location = self.get_caller_location(&mut bx, terminator.source_info).immediate();\n+        let location = self.get_caller_location(bx, terminator.source_info).immediate();\n \n         // Put together the arguments to the panic entry point.\n         let (lang_item, args) = match msg {\n             AssertKind::BoundsCheck { ref len, ref index } => {\n-                let len = self.codegen_operand(&mut bx, len).immediate();\n-                let index = self.codegen_operand(&mut bx, index).immediate();\n+                let len = self.codegen_operand(bx, len).immediate();\n+                let index = self.codegen_operand(bx, index).immediate();\n                 // It's `fn panic_bounds_check(index: usize, len: usize)`,\n                 // and `#[track_caller]` adds an implicit third argument.\n                 (LangItem::PanicBoundsCheck, vec![index, len, location])\n@@ -595,26 +595,26 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n         };\n \n-        let (fn_abi, llfn) = common::build_langcall(&bx, Some(span), lang_item);\n+        let (fn_abi, llfn) = common::build_langcall(bx, Some(span), lang_item);\n \n         // Codegen the actual panic invoke/call.\n-        helper.do_call(self, &mut bx, fn_abi, llfn, &args, None, cleanup, &[]);\n+        helper.do_call(self, bx, fn_abi, llfn, &args, None, cleanup, &[]);\n     }\n \n     fn codegen_abort_terminator(\n         &mut self,\n         helper: TerminatorCodegenHelper<'tcx>,\n-        mut bx: Bx,\n+        bx: &mut Bx,\n         terminator: &mir::Terminator<'tcx>,\n     ) {\n         let span = terminator.source_info.span;\n-        self.set_debug_loc(&mut bx, terminator.source_info);\n+        self.set_debug_loc(bx, terminator.source_info);\n \n         // Obtain the panic entry point.\n-        let (fn_abi, llfn) = common::build_langcall(&bx, Some(span), LangItem::PanicNoUnwind);\n+        let (fn_abi, llfn) = common::build_langcall(bx, Some(span), LangItem::PanicNoUnwind);\n \n         // Codegen the actual panic invoke/call.\n-        helper.do_call(self, &mut bx, fn_abi, llfn, &[], None, None, &[]);\n+        helper.do_call(self, bx, fn_abi, llfn, &[], None, None, &[]);\n     }\n \n     /// Returns `true` if this is indeed a panic intrinsic and codegen is done.\n@@ -701,7 +701,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     fn codegen_call_terminator(\n         &mut self,\n         helper: TerminatorCodegenHelper<'tcx>,\n-        mut bx: Bx,\n+        bx: &mut Bx,\n         terminator: &mir::Terminator<'tcx>,\n         func: &mir::Operand<'tcx>,\n         args: &[mir::Operand<'tcx>],\n@@ -714,7 +714,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let span = source_info.span;\n \n         // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n-        let callee = self.codegen_operand(&mut bx, func);\n+        let callee = self.codegen_operand(bx, func);\n \n         let (instance, mut llfn) = match *callee.layout.ty.kind() {\n             ty::FnDef(def_id, substs) => (\n@@ -734,7 +734,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         if let Some(ty::InstanceDef::DropGlue(_, None)) = def {\n             // Empty drop glue; a no-op.\n             let target = target.unwrap();\n-            helper.funclet_br(self, &mut bx, target);\n+            helper.funclet_br(self, bx, target);\n             return;\n         }\n \n@@ -763,8 +763,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         if intrinsic == Some(sym::transmute) {\n             if let Some(target) = target {\n-                self.codegen_transmute(&mut bx, &args[0], destination);\n-                helper.funclet_br(self, &mut bx, target);\n+                self.codegen_transmute(bx, &args[0], destination);\n+                helper.funclet_br(self, bx, target);\n             } else {\n                 // If we are trying to transmute to an uninhabited type,\n                 // it is likely there is no allotted destination. In fact,\n@@ -780,7 +780,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         if self.codegen_panic_intrinsic(\n             &helper,\n-            &mut bx,\n+            bx,\n             intrinsic,\n             instance,\n             source_info,\n@@ -797,21 +797,21 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // Prepare the return value destination\n         let ret_dest = if target.is_some() {\n             let is_intrinsic = intrinsic.is_some();\n-            self.make_return_dest(&mut bx, destination, &fn_abi.ret, &mut llargs, is_intrinsic)\n+            self.make_return_dest(bx, destination, &fn_abi.ret, &mut llargs, is_intrinsic)\n         } else {\n             ReturnDest::Nothing\n         };\n \n         if intrinsic == Some(sym::caller_location) {\n             if let Some(target) = target {\n-                let location = self\n-                    .get_caller_location(&mut bx, mir::SourceInfo { span: fn_span, ..source_info });\n+                let location =\n+                    self.get_caller_location(bx, mir::SourceInfo { span: fn_span, ..source_info });\n \n                 if let ReturnDest::IndirectOperand(tmp, _) = ret_dest {\n-                    location.val.store(&mut bx, tmp);\n+                    location.val.store(bx, tmp);\n                 }\n-                self.store_return(&mut bx, ret_dest, &fn_abi.ret, location.immediate());\n-                helper.funclet_br(self, &mut bx, target);\n+                self.store_return(bx, ret_dest, &fn_abi.ret, location.immediate());\n+                helper.funclet_br(self, bx, target);\n             }\n             return;\n         }\n@@ -857,12 +857,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             }\n                         }\n \n-                        self.codegen_operand(&mut bx, arg)\n+                        self.codegen_operand(bx, arg)\n                     })\n                     .collect();\n \n                 Self::codegen_intrinsic_call(\n-                    &mut bx,\n+                    bx,\n                     *instance.as_ref().unwrap(),\n                     &fn_abi,\n                     &args,\n@@ -871,11 +871,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 );\n \n                 if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n-                    self.store_return(&mut bx, ret_dest, &fn_abi.ret, dst.llval);\n+                    self.store_return(bx, ret_dest, &fn_abi.ret, dst.llval);\n                 }\n \n                 if let Some(target) = target {\n-                    helper.funclet_br(self, &mut bx, target);\n+                    helper.funclet_br(self, bx, target);\n                 } else {\n                     bx.unreachable();\n                 }\n@@ -894,7 +894,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         let mut copied_constant_arguments = vec![];\n         'make_args: for (i, arg) in first_args.iter().enumerate() {\n-            let mut op = self.codegen_operand(&mut bx, arg);\n+            let mut op = self.codegen_operand(bx, arg);\n \n             if let (0, Some(ty::InstanceDef::Virtual(_, idx))) = (i, def) {\n                 match op.val {\n@@ -909,7 +909,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             && !op.layout.ty.is_region_ptr()\n                         {\n                             for i in 0..op.layout.fields.count() {\n-                                let field = op.extract_field(&mut bx, i);\n+                                let field = op.extract_field(bx, i);\n                                 if !field.layout.is_zst() {\n                                     // we found the one non-zero-sized field that is allowed\n                                     // now find *its* non-zero-sized field, or stop if it's a\n@@ -926,7 +926,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         // data pointer and vtable. Look up the method in the vtable, and pass\n                         // the data pointer as the first argument\n                         llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n-                            &mut bx,\n+                            bx,\n                             meta,\n                             op.layout.ty,\n                             &fn_abi,\n@@ -937,7 +937,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     Ref(data_ptr, Some(meta), _) => {\n                         // by-value dynamic dispatch\n                         llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n-                            &mut bx,\n+                            bx,\n                             meta,\n                             op.layout.ty,\n                             &fn_abi,\n@@ -954,11 +954,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         }\n                         // FIXME(dyn-star): Make sure this is done on a &dyn* receiver\n                         let place = op.deref(bx.cx());\n-                        let data_ptr = place.project_field(&mut bx, 0);\n-                        let meta_ptr = place.project_field(&mut bx, 1);\n+                        let data_ptr = place.project_field(bx, 0);\n+                        let meta_ptr = place.project_field(bx, 1);\n                         let meta = bx.load_operand(meta_ptr);\n                         llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n-                            &mut bx,\n+                            bx,\n                             meta.immediate(),\n                             op.layout.ty,\n                             &fn_abi,\n@@ -977,24 +977,19 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             match (arg, op.val) {\n                 (&mir::Operand::Copy(_), Ref(_, None, _))\n                 | (&mir::Operand::Constant(_), Ref(_, None, _)) => {\n-                    let tmp = PlaceRef::alloca(&mut bx, op.layout);\n+                    let tmp = PlaceRef::alloca(bx, op.layout);\n                     bx.lifetime_start(tmp.llval, tmp.layout.size);\n-                    op.val.store(&mut bx, tmp);\n+                    op.val.store(bx, tmp);\n                     op.val = Ref(tmp.llval, None, tmp.align);\n                     copied_constant_arguments.push(tmp);\n                 }\n                 _ => {}\n             }\n \n-            self.codegen_argument(&mut bx, op, &mut llargs, &fn_abi.args[i]);\n+            self.codegen_argument(bx, op, &mut llargs, &fn_abi.args[i]);\n         }\n         let num_untupled = untuple.map(|tup| {\n-            self.codegen_arguments_untupled(\n-                &mut bx,\n-                tup,\n-                &mut llargs,\n-                &fn_abi.args[first_args.len()..],\n-            )\n+            self.codegen_arguments_untupled(bx, tup, &mut llargs, &fn_abi.args[first_args.len()..])\n         });\n \n         let needs_location =\n@@ -1014,14 +1009,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 fn_abi,\n             );\n             let location =\n-                self.get_caller_location(&mut bx, mir::SourceInfo { span: fn_span, ..source_info });\n+                self.get_caller_location(bx, mir::SourceInfo { span: fn_span, ..source_info });\n             debug!(\n                 \"codegen_call_terminator({:?}): location={:?} (fn_span {:?})\",\n                 terminator, location, fn_span\n             );\n \n             let last_arg = fn_abi.args.last().unwrap();\n-            self.codegen_argument(&mut bx, location, &mut llargs, last_arg);\n+            self.codegen_argument(bx, location, &mut llargs, last_arg);\n         }\n \n         let (is_indirect_call, fn_ptr) = match (llfn, instance) {\n@@ -1048,7 +1043,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             bx.switch_to_block(bb_pass);\n             helper.do_call(\n                 self,\n-                &mut bx,\n+                bx,\n                 fn_abi,\n                 fn_ptr,\n                 &llargs,\n@@ -1066,7 +1061,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         helper.do_call(\n             self,\n-            &mut bx,\n+            bx,\n             fn_abi,\n             fn_ptr,\n             &llargs,\n@@ -1079,7 +1074,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     fn codegen_asm_terminator(\n         &mut self,\n         helper: TerminatorCodegenHelper<'tcx>,\n-        mut bx: Bx,\n+        bx: &mut Bx,\n         terminator: &mir::Terminator<'tcx>,\n         template: &[ast::InlineAsmTemplatePiece],\n         operands: &[mir::InlineAsmOperand<'tcx>],\n@@ -1095,17 +1090,17 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             .iter()\n             .map(|op| match *op {\n                 mir::InlineAsmOperand::In { reg, ref value } => {\n-                    let value = self.codegen_operand(&mut bx, value);\n+                    let value = self.codegen_operand(bx, value);\n                     InlineAsmOperandRef::In { reg, value }\n                 }\n                 mir::InlineAsmOperand::Out { reg, late, ref place } => {\n-                    let place = place.map(|place| self.codegen_place(&mut bx, place.as_ref()));\n+                    let place = place.map(|place| self.codegen_place(bx, place.as_ref()));\n                     InlineAsmOperandRef::Out { reg, late, place }\n                 }\n                 mir::InlineAsmOperand::InOut { reg, late, ref in_value, ref out_place } => {\n-                    let in_value = self.codegen_operand(&mut bx, in_value);\n+                    let in_value = self.codegen_operand(bx, in_value);\n                     let out_place =\n-                        out_place.map(|out_place| self.codegen_place(&mut bx, out_place.as_ref()));\n+                        out_place.map(|out_place| self.codegen_place(bx, out_place.as_ref()));\n                     InlineAsmOperandRef::InOut { reg, late, in_value, out_place }\n                 }\n                 mir::InlineAsmOperand::Const { ref value } => {\n@@ -1143,7 +1138,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         helper.do_inlineasm(\n             self,\n-            &mut bx,\n+            bx,\n             template,\n             &operands,\n             options,\n@@ -1158,22 +1153,22 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn codegen_block(&mut self, bb: mir::BasicBlock) {\n         let llbb = self.llbb(bb);\n-        let mut bx = Bx::build(self.cx, llbb);\n+        let bx = &mut Bx::build(self.cx, llbb);\n         let mir = self.mir;\n         let data = &mir[bb];\n \n         debug!(\"codegen_block({:?}={:?})\", bb, data);\n \n         for statement in &data.statements {\n-            bx = self.codegen_statement(bx, statement);\n+            self.codegen_statement(bx, statement);\n         }\n \n         self.codegen_terminator(bx, bb, data.terminator());\n     }\n \n     fn codegen_terminator(\n         &mut self,\n-        mut bx: Bx,\n+        bx: &mut Bx,\n         bb: mir::BasicBlock,\n         terminator: &'tcx mir::Terminator<'tcx>,\n     ) {\n@@ -1183,7 +1178,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let funclet_bb = self.cleanup_kinds[bb].funclet_bb(bb);\n         let helper = TerminatorCodegenHelper { bb, terminator, funclet_bb };\n \n-        self.set_debug_loc(&mut bx, terminator.source_info);\n+        self.set_debug_loc(bx, terminator.source_info);\n         match terminator.kind {\n             mir::TerminatorKind::Resume => self.codegen_resume_terminator(helper, bx),\n \n@@ -1192,7 +1187,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::TerminatorKind::Goto { target } => {\n-                helper.funclet_br(self, &mut bx, target);\n+                helper.funclet_br(self, bx, target);\n             }\n \n             mir::TerminatorKind::SwitchInt { ref discr, switch_ty, ref targets } => {"}, {"sha": "9ad96f7a44742f87d227114f102f388b5c110e01", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 73, "deletions": 100, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/68194aa8d5c513fad53147e46144684f14f99463/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68194aa8d5c513fad53147e46144684f14f99463/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=68194aa8d5c513fad53147e46144684f14f99463", "patch": "@@ -18,17 +18,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     #[instrument(level = \"trace\", skip(self, bx))]\n     pub fn codegen_rvalue(\n         &mut self,\n-        mut bx: Bx,\n+        bx: &mut Bx,\n         dest: PlaceRef<'tcx, Bx::Value>,\n         rvalue: &mir::Rvalue<'tcx>,\n-    ) -> Bx {\n+    ) {\n         match *rvalue {\n             mir::Rvalue::Use(ref operand) => {\n-                let cg_operand = self.codegen_operand(&mut bx, operand);\n+                let cg_operand = self.codegen_operand(bx, operand);\n                 // FIXME: consider not copying constants through stack. (Fixable by codegen'ing\n                 // constants into `OperandValue::Ref`; why don\u2019t we do that yet if we don\u2019t?)\n-                cg_operand.val.store(&mut bx, dest);\n-                bx\n+                cg_operand.val.store(bx, dest);\n             }\n \n             mir::Rvalue::Cast(mir::CastKind::Pointer(PointerCast::Unsize), ref source, _) => {\n@@ -37,16 +36,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 if bx.cx().is_backend_scalar_pair(dest.layout) {\n                     // Into-coerce of a thin pointer to a fat pointer -- just\n                     // use the operand path.\n-                    let (mut bx, temp) = self.codegen_rvalue_operand(bx, rvalue);\n-                    temp.val.store(&mut bx, dest);\n-                    return bx;\n+                    let temp = self.codegen_rvalue_operand(bx, rvalue);\n+                    temp.val.store(bx, dest);\n+                    return;\n                 }\n \n                 // Unsize of a nontrivial struct. I would prefer for\n                 // this to be eliminated by MIR building, but\n                 // `CoerceUnsized` can be passed by a where-clause,\n                 // so the (generic) MIR may not be able to expand it.\n-                let operand = self.codegen_operand(&mut bx, source);\n+                let operand = self.codegen_operand(bx, source);\n                 match operand.val {\n                     OperandValue::Pair(..) | OperandValue::Immediate(_) => {\n                         // Unsize from an immediate structure. We don't\n@@ -56,111 +55,107 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         // index into the struct, and this case isn't\n                         // important enough for it.\n                         debug!(\"codegen_rvalue: creating ugly alloca\");\n-                        let scratch = PlaceRef::alloca(&mut bx, operand.layout);\n-                        scratch.storage_live(&mut bx);\n-                        operand.val.store(&mut bx, scratch);\n-                        base::coerce_unsized_into(&mut bx, scratch, dest);\n-                        scratch.storage_dead(&mut bx);\n+                        let scratch = PlaceRef::alloca(bx, operand.layout);\n+                        scratch.storage_live(bx);\n+                        operand.val.store(bx, scratch);\n+                        base::coerce_unsized_into(bx, scratch, dest);\n+                        scratch.storage_dead(bx);\n                     }\n                     OperandValue::Ref(llref, None, align) => {\n                         let source = PlaceRef::new_sized_aligned(llref, operand.layout, align);\n-                        base::coerce_unsized_into(&mut bx, source, dest);\n+                        base::coerce_unsized_into(bx, source, dest);\n                     }\n                     OperandValue::Ref(_, Some(_), _) => {\n                         bug!(\"unsized coercion on an unsized rvalue\");\n                     }\n                 }\n-                bx\n             }\n \n             mir::Rvalue::Repeat(ref elem, count) => {\n-                let cg_elem = self.codegen_operand(&mut bx, elem);\n+                let cg_elem = self.codegen_operand(bx, elem);\n \n                 // Do not generate the loop for zero-sized elements or empty arrays.\n                 if dest.layout.is_zst() {\n-                    return bx;\n+                    return;\n                 }\n \n                 if let OperandValue::Immediate(v) = cg_elem.val {\n                     let zero = bx.const_usize(0);\n-                    let start = dest.project_index(&mut bx, zero).llval;\n+                    let start = dest.project_index(bx, zero).llval;\n                     let size = bx.const_usize(dest.layout.size.bytes());\n \n                     // Use llvm.memset.p0i8.* to initialize all zero arrays\n                     if bx.cx().const_to_opt_u128(v, false) == Some(0) {\n                         let fill = bx.cx().const_u8(0);\n                         bx.memset(start, fill, size, dest.align, MemFlags::empty());\n-                        return bx;\n+                        return;\n                     }\n \n                     // Use llvm.memset.p0i8.* to initialize byte arrays\n                     let v = bx.from_immediate(v);\n                     if bx.cx().val_ty(v) == bx.cx().type_i8() {\n                         bx.memset(start, v, size, dest.align, MemFlags::empty());\n-                        return bx;\n+                        return;\n                     }\n                 }\n \n                 let count =\n                     self.monomorphize(count).eval_usize(bx.cx().tcx(), ty::ParamEnv::reveal_all());\n \n-                bx.write_operand_repeatedly(cg_elem, count, dest)\n+                bx.write_operand_repeatedly(cg_elem, count, dest);\n             }\n \n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n                 let (dest, active_field_index) = match **kind {\n                     mir::AggregateKind::Adt(adt_did, variant_index, _, _, active_field_index) => {\n-                        dest.codegen_set_discr(&mut bx, variant_index);\n+                        dest.codegen_set_discr(bx, variant_index);\n                         if bx.tcx().adt_def(adt_did).is_enum() {\n-                            (dest.project_downcast(&mut bx, variant_index), active_field_index)\n+                            (dest.project_downcast(bx, variant_index), active_field_index)\n                         } else {\n                             (dest, active_field_index)\n                         }\n                     }\n                     _ => (dest, None),\n                 };\n                 for (i, operand) in operands.iter().enumerate() {\n-                    let op = self.codegen_operand(&mut bx, operand);\n+                    let op = self.codegen_operand(bx, operand);\n                     // Do not generate stores and GEPis for zero-sized fields.\n                     if !op.layout.is_zst() {\n                         let field_index = active_field_index.unwrap_or(i);\n                         let field = if let mir::AggregateKind::Array(_) = **kind {\n                             let llindex = bx.cx().const_usize(field_index as u64);\n-                            dest.project_index(&mut bx, llindex)\n+                            dest.project_index(bx, llindex)\n                         } else {\n-                            dest.project_field(&mut bx, field_index)\n+                            dest.project_field(bx, field_index)\n                         };\n-                        op.val.store(&mut bx, field);\n+                        op.val.store(bx, field);\n                     }\n                 }\n-                bx\n             }\n \n             _ => {\n                 assert!(self.rvalue_creates_operand(rvalue, DUMMY_SP));\n-                let (mut bx, temp) = self.codegen_rvalue_operand(bx, rvalue);\n-                temp.val.store(&mut bx, dest);\n-                bx\n+                let temp = self.codegen_rvalue_operand(bx, rvalue);\n+                temp.val.store(bx, dest);\n             }\n         }\n     }\n \n     pub fn codegen_rvalue_unsized(\n         &mut self,\n-        mut bx: Bx,\n+        bx: &mut Bx,\n         indirect_dest: PlaceRef<'tcx, Bx::Value>,\n         rvalue: &mir::Rvalue<'tcx>,\n-    ) -> Bx {\n+    ) {\n         debug!(\n             \"codegen_rvalue_unsized(indirect_dest.llval={:?}, rvalue={:?})\",\n             indirect_dest.llval, rvalue\n         );\n \n         match *rvalue {\n             mir::Rvalue::Use(ref operand) => {\n-                let cg_operand = self.codegen_operand(&mut bx, operand);\n-                cg_operand.val.store_unsized(&mut bx, indirect_dest);\n-                bx\n+                let cg_operand = self.codegen_operand(bx, operand);\n+                cg_operand.val.store_unsized(bx, indirect_dest);\n             }\n \n             _ => bug!(\"unsized assignment other than `Rvalue::Use`\"),\n@@ -169,9 +164,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n     pub fn codegen_rvalue_operand(\n         &mut self,\n-        mut bx: Bx,\n+        bx: &mut Bx,\n         rvalue: &mir::Rvalue<'tcx>,\n-    ) -> (Bx, OperandRef<'tcx, Bx::Value>) {\n+    ) -> OperandRef<'tcx, Bx::Value> {\n         assert!(\n             self.rvalue_creates_operand(rvalue, DUMMY_SP),\n             \"cannot codegen {:?} to operand\",\n@@ -180,7 +175,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         match *rvalue {\n             mir::Rvalue::Cast(ref kind, ref source, mir_cast_ty) => {\n-                let operand = self.codegen_operand(&mut bx, source);\n+                let operand = self.codegen_operand(bx, source);\n                 debug!(\"cast operand is {:?}\", operand);\n                 let cast = bx.cx().layout_of(self.monomorphize(mir_cast_ty));\n \n@@ -245,7 +240,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             }\n                         };\n                         let (lldata, llextra) =\n-                            base::unsize_ptr(&mut bx, lldata, operand.layout.ty, cast.ty, llextra);\n+                            base::unsize_ptr(bx, lldata, operand.layout.ty, cast.ty, llextra);\n                         OperandValue::Pair(lldata, llextra)\n                     }\n                     mir::CastKind::Pointer(PointerCast::MutToConstPointer)\n@@ -278,7 +273,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             OperandValue::Pair(v, l) => (v, Some(l)),\n                         };\n                         let (lldata, llextra) =\n-                            base::cast_to_dyn_star(&mut bx, lldata, operand.layout, cast.ty, llextra);\n+                            base::cast_to_dyn_star(bx, lldata, operand.layout, cast.ty, llextra);\n                         OperandValue::Pair(lldata, llextra)\n                     }\n                     mir::CastKind::Pointer(\n@@ -299,7 +294,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         let ll_t_out = bx.cx().immediate_backend_type(cast);\n                         if operand.layout.abi.is_uninhabited() {\n                             let val = OperandValue::Immediate(bx.cx().const_undef(ll_t_out));\n-                            return (bx, OperandRef { val, layout: cast });\n+                            return OperandRef { val, layout: cast };\n                         }\n                         let r_t_in =\n                             CastTy::from_ty(operand.layout.ty).expect(\"bad input type for cast\");\n@@ -348,7 +343,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         OperandValue::Immediate(newval)\n                     }\n                 };\n-                (bx, OperandRef { val, layout: cast })\n+                OperandRef { val, layout: cast }\n             }\n \n             mir::Rvalue::Ref(_, bk, place) => {\n@@ -361,10 +356,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 self.codegen_place_to_pointer(bx, place, mk_ref)\n             }\n \n-            mir::Rvalue::CopyForDeref(place) => {\n-                let operand = self.codegen_operand(&mut bx, &Operand::Copy(place));\n-                (bx, operand)\n-            }\n+            mir::Rvalue::CopyForDeref(place) => self.codegen_operand(bx, &Operand::Copy(place)),\n             mir::Rvalue::AddressOf(mutability, place) => {\n                 let mk_ptr = move |tcx: TyCtxt<'tcx>, ty: Ty<'tcx>| {\n                     tcx.mk_ptr(ty::TypeAndMut { ty, mutbl: mutability })\n@@ -373,23 +365,22 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::Rvalue::Len(place) => {\n-                let size = self.evaluate_array_len(&mut bx, place);\n-                let operand = OperandRef {\n+                let size = self.evaluate_array_len(bx, place);\n+                OperandRef {\n                     val: OperandValue::Immediate(size),\n                     layout: bx.cx().layout_of(bx.tcx().types.usize),\n-                };\n-                (bx, operand)\n+                }\n             }\n \n             mir::Rvalue::BinaryOp(op, box (ref lhs, ref rhs)) => {\n-                let lhs = self.codegen_operand(&mut bx, lhs);\n-                let rhs = self.codegen_operand(&mut bx, rhs);\n+                let lhs = self.codegen_operand(bx, lhs);\n+                let rhs = self.codegen_operand(bx, rhs);\n                 let llresult = match (lhs.val, rhs.val) {\n                     (\n                         OperandValue::Pair(lhs_addr, lhs_extra),\n                         OperandValue::Pair(rhs_addr, rhs_extra),\n                     ) => self.codegen_fat_ptr_binop(\n-                        &mut bx,\n+                        bx,\n                         op,\n                         lhs_addr,\n                         lhs_extra,\n@@ -399,36 +390,33 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     ),\n \n                     (OperandValue::Immediate(lhs_val), OperandValue::Immediate(rhs_val)) => {\n-                        self.codegen_scalar_binop(&mut bx, op, lhs_val, rhs_val, lhs.layout.ty)\n+                        self.codegen_scalar_binop(bx, op, lhs_val, rhs_val, lhs.layout.ty)\n                     }\n \n                     _ => bug!(),\n                 };\n-                let operand = OperandRef {\n+                OperandRef {\n                     val: OperandValue::Immediate(llresult),\n                     layout: bx.cx().layout_of(op.ty(bx.tcx(), lhs.layout.ty, rhs.layout.ty)),\n-                };\n-                (bx, operand)\n+                }\n             }\n             mir::Rvalue::CheckedBinaryOp(op, box (ref lhs, ref rhs)) => {\n-                let lhs = self.codegen_operand(&mut bx, lhs);\n-                let rhs = self.codegen_operand(&mut bx, rhs);\n+                let lhs = self.codegen_operand(bx, lhs);\n+                let rhs = self.codegen_operand(bx, rhs);\n                 let result = self.codegen_scalar_checked_binop(\n-                    &mut bx,\n+                    bx,\n                     op,\n                     lhs.immediate(),\n                     rhs.immediate(),\n                     lhs.layout.ty,\n                 );\n                 let val_ty = op.ty(bx.tcx(), lhs.layout.ty, rhs.layout.ty);\n                 let operand_ty = bx.tcx().intern_tup(&[val_ty, bx.tcx().types.bool]);\n-                let operand = OperandRef { val: result, layout: bx.cx().layout_of(operand_ty) };\n-\n-                (bx, operand)\n+                OperandRef { val: result, layout: bx.cx().layout_of(operand_ty) }\n             }\n \n             mir::Rvalue::UnaryOp(op, ref operand) => {\n-                let operand = self.codegen_operand(&mut bx, operand);\n+                let operand = self.codegen_operand(bx, operand);\n                 let lloperand = operand.immediate();\n                 let is_float = operand.layout.ty.is_floating_point();\n                 let llval = match op {\n@@ -441,22 +429,17 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         }\n                     }\n                 };\n-                (bx, OperandRef { val: OperandValue::Immediate(llval), layout: operand.layout })\n+                OperandRef { val: OperandValue::Immediate(llval), layout: operand.layout }\n             }\n \n             mir::Rvalue::Discriminant(ref place) => {\n                 let discr_ty = rvalue.ty(self.mir, bx.tcx());\n                 let discr_ty = self.monomorphize(discr_ty);\n-                let discr = self\n-                    .codegen_place(&mut bx, place.as_ref())\n-                    .codegen_get_discr(&mut bx, discr_ty);\n-                (\n-                    bx,\n-                    OperandRef {\n-                        val: OperandValue::Immediate(discr),\n-                        layout: self.cx.layout_of(discr_ty),\n-                    },\n-                )\n+                let discr = self.codegen_place(bx, place.as_ref()).codegen_get_discr(bx, discr_ty);\n+                OperandRef {\n+                    val: OperandValue::Immediate(discr),\n+                    layout: self.cx.layout_of(discr_ty),\n+                }\n             }\n \n             mir::Rvalue::NullaryOp(null_op, ty) => {\n@@ -469,45 +452,35 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 };\n                 let val = bx.cx().const_usize(val);\n                 let tcx = self.cx.tcx();\n-                (\n-                    bx,\n-                    OperandRef {\n-                        val: OperandValue::Immediate(val),\n-                        layout: self.cx.layout_of(tcx.types.usize),\n-                    },\n-                )\n+                OperandRef {\n+                    val: OperandValue::Immediate(val),\n+                    layout: self.cx.layout_of(tcx.types.usize),\n+                }\n             }\n \n             mir::Rvalue::ThreadLocalRef(def_id) => {\n                 assert!(bx.cx().tcx().is_static(def_id));\n                 let static_ = bx.get_static(def_id);\n                 let layout = bx.layout_of(bx.cx().tcx().static_ptr_ty(def_id));\n-                let operand = OperandRef::from_immediate_or_packed_pair(&mut bx, static_, layout);\n-                (bx, operand)\n-            }\n-            mir::Rvalue::Use(ref operand) => {\n-                let operand = self.codegen_operand(&mut bx, operand);\n-                (bx, operand)\n+                OperandRef::from_immediate_or_packed_pair(bx, static_, layout)\n             }\n+            mir::Rvalue::Use(ref operand) => self.codegen_operand(bx, operand),\n             mir::Rvalue::Repeat(..) | mir::Rvalue::Aggregate(..) => {\n                 // According to `rvalue_creates_operand`, only ZST\n                 // aggregate rvalues are allowed to be operands.\n                 let ty = rvalue.ty(self.mir, self.cx.tcx());\n-                let operand =\n-                    OperandRef::new_zst(&mut bx, self.cx.layout_of(self.monomorphize(ty)));\n-                (bx, operand)\n+                OperandRef::new_zst(bx, self.cx.layout_of(self.monomorphize(ty)))\n             }\n             mir::Rvalue::ShallowInitBox(ref operand, content_ty) => {\n-                let operand = self.codegen_operand(&mut bx, operand);\n+                let operand = self.codegen_operand(bx, operand);\n                 let lloperand = operand.immediate();\n \n                 let content_ty = self.monomorphize(content_ty);\n                 let box_layout = bx.cx().layout_of(bx.tcx().mk_box(content_ty));\n                 let llty_ptr = bx.cx().backend_type(box_layout);\n \n                 let val = bx.pointercast(lloperand, llty_ptr);\n-                let operand = OperandRef { val: OperandValue::Immediate(val), layout: box_layout };\n-                (bx, operand)\n+                OperandRef { val: OperandValue::Immediate(val), layout: box_layout }\n             }\n         }\n     }\n@@ -531,11 +504,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     /// Codegen an `Rvalue::AddressOf` or `Rvalue::Ref`\n     fn codegen_place_to_pointer(\n         &mut self,\n-        mut bx: Bx,\n+        bx: &mut Bx,\n         place: mir::Place<'tcx>,\n         mk_ptr_ty: impl FnOnce(TyCtxt<'tcx>, Ty<'tcx>) -> Ty<'tcx>,\n-    ) -> (Bx, OperandRef<'tcx, Bx::Value>) {\n-        let cg_place = self.codegen_place(&mut bx, place.as_ref());\n+    ) -> OperandRef<'tcx, Bx::Value> {\n+        let cg_place = self.codegen_place(bx, place.as_ref());\n \n         let ty = cg_place.layout.ty;\n \n@@ -546,7 +519,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         } else {\n             OperandValue::Pair(cg_place.llval, cg_place.llextra.unwrap())\n         };\n-        (bx, OperandRef { val, layout: self.cx.layout_of(mk_ptr_ty(self.cx.tcx(), ty)) })\n+        OperandRef { val, layout: self.cx.layout_of(mk_ptr_ty(self.cx.tcx(), ty)) }\n     }\n \n     pub fn codegen_scalar_binop("}, {"sha": "19452c8cdc805da6068a7b37f8a871368961588b", "filename": "compiler/rustc_codegen_ssa/src/mir/statement.rs", "status": "modified", "additions": 19, "deletions": 28, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/68194aa8d5c513fad53147e46144684f14f99463/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68194aa8d5c513fad53147e46144684f14f99463/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs?ref=68194aa8d5c513fad53147e46144684f14f99463", "patch": "@@ -8,8 +8,8 @@ use crate::traits::*;\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     #[instrument(level = \"debug\", skip(self, bx))]\n-    pub fn codegen_statement(&mut self, mut bx: Bx, statement: &mir::Statement<'tcx>) -> Bx {\n-        self.set_debug_loc(&mut bx, statement.source_info);\n+    pub fn codegen_statement(&mut self, bx: &mut Bx, statement: &mir::Statement<'tcx>) {\n+        self.set_debug_loc(bx, statement.source_info);\n         match statement.kind {\n             mir::StatementKind::Assign(box (ref place, ref rvalue)) => {\n                 if let Some(index) = place.as_local() {\n@@ -19,10 +19,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             self.codegen_rvalue_unsized(bx, cg_indirect_dest, rvalue)\n                         }\n                         LocalRef::Operand(None) => {\n-                            let (mut bx, operand) = self.codegen_rvalue_operand(bx, rvalue);\n+                            let operand = self.codegen_rvalue_operand(bx, rvalue);\n                             self.locals[index] = LocalRef::Operand(Some(operand));\n-                            self.debug_introduce_local(&mut bx, index);\n-                            bx\n+                            self.debug_introduce_local(bx, index);\n                         }\n                         LocalRef::Operand(Some(op)) => {\n                             if !op.layout.is_zst() {\n@@ -35,72 +34,64 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n                             // If the type is zero-sized, it's already been set here,\n                             // but we still need to make sure we codegen the operand\n-                            self.codegen_rvalue_operand(bx, rvalue).0\n+                            self.codegen_rvalue_operand(bx, rvalue);\n                         }\n                     }\n                 } else {\n-                    let cg_dest = self.codegen_place(&mut bx, place.as_ref());\n-                    self.codegen_rvalue(bx, cg_dest, rvalue)\n+                    let cg_dest = self.codegen_place(bx, place.as_ref());\n+                    self.codegen_rvalue(bx, cg_dest, rvalue);\n                 }\n             }\n             mir::StatementKind::SetDiscriminant { box ref place, variant_index } => {\n-                self.codegen_place(&mut bx, place.as_ref())\n-                    .codegen_set_discr(&mut bx, variant_index);\n-                bx\n+                self.codegen_place(bx, place.as_ref()).codegen_set_discr(bx, variant_index);\n             }\n             mir::StatementKind::Deinit(..) => {\n                 // For now, don't codegen this to anything. In the future it may be worth\n                 // experimenting with what kind of information we can emit to LLVM without hurting\n                 // perf here\n-                bx\n             }\n             mir::StatementKind::StorageLive(local) => {\n                 if let LocalRef::Place(cg_place) = self.locals[local] {\n-                    cg_place.storage_live(&mut bx);\n+                    cg_place.storage_live(bx);\n                 } else if let LocalRef::UnsizedPlace(cg_indirect_place) = self.locals[local] {\n-                    cg_indirect_place.storage_live(&mut bx);\n+                    cg_indirect_place.storage_live(bx);\n                 }\n-                bx\n             }\n             mir::StatementKind::StorageDead(local) => {\n                 if let LocalRef::Place(cg_place) = self.locals[local] {\n-                    cg_place.storage_dead(&mut bx);\n+                    cg_place.storage_dead(bx);\n                 } else if let LocalRef::UnsizedPlace(cg_indirect_place) = self.locals[local] {\n-                    cg_indirect_place.storage_dead(&mut bx);\n+                    cg_indirect_place.storage_dead(bx);\n                 }\n-                bx\n             }\n             mir::StatementKind::Coverage(box ref coverage) => {\n-                self.codegen_coverage(&mut bx, coverage.clone(), statement.source_info.scope);\n-                bx\n+                self.codegen_coverage(bx, coverage.clone(), statement.source_info.scope);\n             }\n             mir::StatementKind::Intrinsic(box NonDivergingIntrinsic::Assume(ref op)) => {\n-                let op_val = self.codegen_operand(&mut bx, op);\n+                let op_val = self.codegen_operand(bx, op);\n                 bx.assume(op_val.immediate());\n-                bx\n             }\n             mir::StatementKind::Intrinsic(box NonDivergingIntrinsic::CopyNonOverlapping(\n                 mir::CopyNonOverlapping { ref count, ref src, ref dst },\n             )) => {\n-                let dst_val = self.codegen_operand(&mut bx, dst);\n-                let src_val = self.codegen_operand(&mut bx, src);\n-                let count = self.codegen_operand(&mut bx, count).immediate();\n+                let dst_val = self.codegen_operand(bx, dst);\n+                let src_val = self.codegen_operand(bx, src);\n+                let count = self.codegen_operand(bx, count).immediate();\n                 let pointee_layout = dst_val\n                     .layout\n-                    .pointee_info_at(&bx, rustc_target::abi::Size::ZERO)\n+                    .pointee_info_at(bx, rustc_target::abi::Size::ZERO)\n                     .expect(\"Expected pointer\");\n                 let bytes = bx.mul(count, bx.const_usize(pointee_layout.size.bytes()));\n \n                 let align = pointee_layout.align;\n                 let dst = dst_val.immediate();\n                 let src = src_val.immediate();\n                 bx.memcpy(dst, align, src, align, bytes, crate::MemFlags::empty());\n-                bx\n             }\n             mir::StatementKind::FakeRead(..)\n             | mir::StatementKind::Retag { .. }\n             | mir::StatementKind::AscribeUserType(..)\n-            | mir::StatementKind::Nop => bx,\n+            | mir::StatementKind::Nop => {}\n         }\n     }\n }"}, {"sha": "bc679a5dc87b122a4fcc7ea8111216f8b871b8f3", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68194aa8d5c513fad53147e46144684f14f99463/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68194aa8d5c513fad53147e46144684f14f99463/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=68194aa8d5c513fad53147e46144684f14f99463", "patch": "@@ -151,11 +151,11 @@ pub trait BuilderMethods<'a, 'tcx>:\n \n     /// Called for Rvalue::Repeat when the elem is neither a ZST nor optimizable using memset.\n     fn write_operand_repeatedly(\n-        self,\n+        &mut self,\n         elem: OperandRef<'tcx, Self::Value>,\n         count: u64,\n         dest: PlaceRef<'tcx, Self::Value>,\n-    ) -> Self;\n+    );\n \n     fn range_metadata(&mut self, load: Self::Value, range: WrappingRange);\n     fn nonnull_metadata(&mut self, load: Self::Value);"}]}