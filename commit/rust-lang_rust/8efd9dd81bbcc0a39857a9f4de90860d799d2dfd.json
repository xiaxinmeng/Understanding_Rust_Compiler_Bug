{"sha": "8efd9dd81bbcc0a39857a9f4de90860d799d2dfd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlZmQ5ZGQ4MWJiY2MwYTM5ODU3YTlmNGRlOTA4NjBkNzk5ZDJkZmQ=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-10-09T13:13:11Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-10-09T13:13:11Z"}, "message": "codegen_llvm/misc: whitespace & formatting improvements", "tree": {"sha": "c05f1719829079ac0df58db8d1b32742a33779a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c05f1719829079ac0df58db8d1b32742a33779a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8efd9dd81bbcc0a39857a9f4de90860d799d2dfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8efd9dd81bbcc0a39857a9f4de90860d799d2dfd", "html_url": "https://github.com/rust-lang/rust/commit/8efd9dd81bbcc0a39857a9f4de90860d799d2dfd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8efd9dd81bbcc0a39857a9f4de90860d799d2dfd/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1a137d0159543d5a295ce86a9b7475c486efeac", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1a137d0159543d5a295ce86a9b7475c486efeac", "html_url": "https://github.com/rust-lang/rust/commit/b1a137d0159543d5a295ce86a9b7475c486efeac"}], "stats": {"total": 91, "additions": 46, "deletions": 45}, "files": [{"sha": "c90dd53aa3582ea17097d2f7ac68a0332c6a219a", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8efd9dd81bbcc0a39857a9f4de90860d799d2dfd/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8efd9dd81bbcc0a39857a9f4de90860d799d2dfd/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=8efd9dd81bbcc0a39857a9f4de90860d799d2dfd", "patch": "@@ -582,12 +582,12 @@ pub fn type_metadata(\n         }\n         ty::Dynamic(..) => {\n             MetadataCreationResult::new(\n-                        trait_pointer_metadata(cx, t, None, unique_type_id),\n-            false)\n+                trait_pointer_metadata(cx, t, None, unique_type_id),\n+                false)\n         }\n         ty::Foreign(..) => {\n             MetadataCreationResult::new(\n-                        foreign_type_metadata(cx, t, unique_type_id),\n+            foreign_type_metadata(cx, t, unique_type_id),\n             false)\n         }\n         ty::RawPtr(ty::TypeAndMut{ty, ..}) |\n@@ -646,16 +646,16 @@ pub fn type_metadata(\n             }\n             AdtKind::Union => {\n                 prepare_union_metadata(cx,\n-                                    t,\n-                                    unique_type_id,\n-                                    usage_site_span).finalize(cx)\n+                                       t,\n+                                       unique_type_id,\n+                                       usage_site_span).finalize(cx)\n             }\n             AdtKind::Enum => {\n                 prepare_enum_metadata(cx,\n-                                    t,\n-                                    def.did,\n-                                    unique_type_id,\n-                                    usage_site_span).finalize(cx)\n+                                      t,\n+                                      def.did,\n+                                      unique_type_id,\n+                                      usage_site_span).finalize(cx)\n             }\n         },\n         ty::Tuple(ref elements) => {\n@@ -943,7 +943,7 @@ enum MemberDescriptionFactory<'ll, 'tcx> {\n \n impl MemberDescriptionFactory<'ll, 'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n-                                      -> Vec<MemberDescription<'ll>> {\n+                                  -> Vec<MemberDescription<'ll>> {\n         match *self {\n             StructMDF(ref this) => {\n                 this.create_member_descriptions(cx)\n@@ -977,7 +977,7 @@ struct StructMemberDescriptionFactory<'tcx> {\n \n impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n-                                      -> Vec<MemberDescription<'ll>> {\n+                                  -> Vec<MemberDescription<'ll>> {\n         let layout = cx.layout_of(self.ty);\n         self.variant.fields.iter().enumerate().map(|(i, f)| {\n             let name = if self.variant.ctor_kind == CtorKind::Fn {\n@@ -1047,7 +1047,7 @@ struct TupleMemberDescriptionFactory<'tcx> {\n \n impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n-                                      -> Vec<MemberDescription<'ll>> {\n+                                  -> Vec<MemberDescription<'ll>> {\n         let layout = cx.layout_of(self.ty);\n         self.component_types.iter().enumerate().map(|(i, &component_type)| {\n             let (size, align) = cx.size_and_align_of(component_type);\n@@ -1101,7 +1101,7 @@ struct UnionMemberDescriptionFactory<'tcx> {\n \n impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n-                                      -> Vec<MemberDescription<'ll>> {\n+                                  -> Vec<MemberDescription<'ll>> {\n         self.variant.fields.iter().enumerate().map(|(i, f)| {\n             let field = self.layout.field(cx, i);\n             let (size, align) = field.size_and_align();\n@@ -1170,7 +1170,7 @@ struct EnumMemberDescriptionFactory<'ll, 'tcx> {\n \n impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n-                                      -> Vec<MemberDescription<'ll>> {\n+                                  -> Vec<MemberDescription<'ll>> {\n         let adt = &self.enum_type.ty_adt_def().unwrap();\n         match self.layout.variants {\n             layout::Variants::Single { .. } if adt.variants.is_empty() => vec![],"}, {"sha": "68b1f0c33d065423578517ea8a4f0dd0b0724281", "filename": "src/librustc_codegen_llvm/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8efd9dd81bbcc0a39857a9f4de90860d799d2dfd/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8efd9dd81bbcc0a39857a9f4de90860d799d2dfd/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs?ref=8efd9dd81bbcc0a39857a9f4de90860d799d2dfd", "patch": "@@ -179,7 +179,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         ty::GeneratorWitness(..) |\n         ty::Param(_) => {\n             bug!(\"debuginfo: Trying to create type name for \\\n-                unexpected type: {:?}\", t);\n+                  unexpected type: {:?}\", t);\n         }\n     }\n "}, {"sha": "a0d6cc4629589da5572e08bfac18c963e6e1ab70", "filename": "src/librustc_codegen_llvm/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8efd9dd81bbcc0a39857a9f4de90860d799d2dfd/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8efd9dd81bbcc0a39857a9f4de90860d799d2dfd/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs?ref=8efd9dd81bbcc0a39857a9f4de90860d799d2dfd", "patch": "@@ -151,9 +151,9 @@ impl Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n     }\n \n     fn visit_place(&mut self,\n-                    place: &mir::Place<'tcx>,\n-                    context: PlaceContext<'tcx>,\n-                    location: Location) {\n+                   place: &mir::Place<'tcx>,\n+                   context: PlaceContext<'tcx>,\n+                   location: Location) {\n         debug!(\"visit_place(place={:?}, context={:?})\", place, context);\n         let cx = self.fx.cx;\n "}, {"sha": "68e30227185c0ba68c22ca50b705fb6c8d671432", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8efd9dd81bbcc0a39857a9f4de90860d799d2dfd/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8efd9dd81bbcc0a39857a9f4de90860d799d2dfd/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=8efd9dd81bbcc0a39857a9f4de90860d799d2dfd", "patch": "@@ -49,9 +49,9 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     }\n \n     fn codegen_terminator(&mut self,\n-                        mut bx: Builder<'a, 'll, 'tcx>,\n-                        bb: mir::BasicBlock,\n-                        terminator: &mir::Terminator<'tcx>)\n+                          mut bx: Builder<'a, 'll, 'tcx>,\n+                          bb: mir::BasicBlock,\n+                          terminator: &mir::Terminator<'tcx>)\n     {\n         debug!(\"codegen_terminator: {:?}\", terminator);\n \n@@ -125,10 +125,10 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     this.unreachable_block()\n                 };\n                 let invokeret = bx.invoke(fn_ptr,\n-                                           &llargs,\n-                                           ret_bx,\n-                                           llblock(this, cleanup),\n-                                           cleanup_bundle);\n+                                          &llargs,\n+                                          ret_bx,\n+                                          llblock(this, cleanup),\n+                                          cleanup_bundle);\n                 fn_ty.apply_attrs_callsite(&bx, invokeret);\n \n                 if let Some((ret_dest, target)) = destination {\n@@ -213,7 +213,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 } else {\n                     let (otherwise, targets) = targets.split_last().unwrap();\n                     let switch = bx.switch(discr.immediate(),\n-                                            llblock(self, *otherwise), values.len());\n+                                           llblock(self, *otherwise),\n+                                           values.len());\n                     let switch_llty = bx.cx.layout_of(switch_ty).immediate_llvm_type(bx.cx);\n                     for (&value, target) in values.iter().zip(targets) {\n                         let llval = C_uint_big(switch_llty, value);\n@@ -387,8 +388,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                         let msg_str = Symbol::intern(str).as_str();\n                         let msg_str = C_str_slice(bx.cx, msg_str);\n                         let msg_file_line_col = C_struct(bx.cx,\n-                                                     &[msg_str, filename, line, col],\n-                                                     false);\n+                                                         &[msg_str, filename, line, col],\n+                                                         false);\n                         let msg_file_line_col = consts::addr_of(bx.cx,\n                                                                 msg_file_line_col,\n                                                                 align,\n@@ -509,8 +510,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     let msg_str = Symbol::intern(&str).as_str();\n                     let msg_str = C_str_slice(bx.cx, msg_str);\n                     let msg_file_line_col = C_struct(bx.cx,\n-                                                    &[msg_str, filename, line, col],\n-                                                    false);\n+                                                     &[msg_str, filename, line, col],\n+                                                     false);\n                     let msg_file_line_col = consts::addr_of(bx.cx,\n                                                             msg_file_line_col,\n                                                             align,\n@@ -619,7 +620,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n \n                     let callee_ty = instance.as_ref().unwrap().ty(bx.cx.tcx);\n                     codegen_intrinsic_call(&bx, callee_ty, &fn_ty, &args, dest,\n-                                         terminator.source_info.span);\n+                                           terminator.source_info.span);\n \n                     if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n                         self.store_return(&bx, ret_dest, &fn_ty.ret, dst.llval);\n@@ -756,7 +757,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n             // Have to load the argument, maybe while casting it.\n             if let PassMode::Cast(ty) = arg.mode {\n                 llval = bx.load(bx.pointercast(llval, ty.llvm_type(bx.cx).ptr_to()),\n-                                 align.min(arg.layout.align));\n+                                align.min(arg.layout.align));\n             } else {\n                 // We can't use `PlaceRef::load` here because the argument\n                 // may have a type we don't treat as immediate, but the ABI\n@@ -778,10 +779,10 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     }\n \n     fn codegen_arguments_untupled(&mut self,\n-                                bx: &Builder<'a, 'll, 'tcx>,\n-                                operand: &mir::Operand<'tcx>,\n-                                llargs: &mut Vec<&'ll Value>,\n-                                args: &[ArgType<'tcx, Ty<'tcx>>]) {\n+                                  bx: &Builder<'a, 'll, 'tcx>,\n+                                  operand: &mir::Operand<'tcx>,\n+                                  llargs: &mut Vec<&'ll Value>,\n+                                  args: &[ArgType<'tcx, Ty<'tcx>>]) {\n         let tuple = self.codegen_operand(bx, operand);\n \n         // Handle both by-ref and immediate tuples.\n@@ -933,8 +934,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     }\n \n     fn codegen_transmute(&mut self, bx: &Builder<'a, 'll, 'tcx>,\n-                       src: &mir::Operand<'tcx>,\n-                       dst: &mir::Place<'tcx>) {\n+                         src: &mir::Operand<'tcx>,\n+                         dst: &mir::Place<'tcx>) {\n         if let mir::Place::Local(index) = *dst {\n             match self.locals[index] {\n                 LocalRef::Place(place) => self.codegen_transmute_into(bx, src, place),\n@@ -961,8 +962,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     }\n \n     fn codegen_transmute_into(&mut self, bx: &Builder<'a, 'll, 'tcx>,\n-                            src: &mir::Operand<'tcx>,\n-                            dst: PlaceRef<'ll, 'tcx>) {\n+                              src: &mir::Operand<'tcx>,\n+                              dst: PlaceRef<'ll, 'tcx>) {\n         let src = self.codegen_operand(bx, src);\n         let llty = src.layout.llvm_type(bx.cx);\n         let cast_ptr = bx.pointercast(dst.llval, llty.ptr_to());"}, {"sha": "a6e2ccf92e4e3fd416a028c1950679fb0fce14a0", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8efd9dd81bbcc0a39857a9f4de90860d799d2dfd/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8efd9dd81bbcc0a39857a9f4de90860d799d2dfd/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=8efd9dd81bbcc0a39857a9f4de90860d799d2dfd", "patch": "@@ -162,16 +162,16 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     // corresponding to span's containing source scope.  If so, we need to create a DIScope\n     // \"extension\" into that file.\n     fn scope_metadata_for_loc(&self, scope_id: mir::SourceScope, pos: BytePos)\n-                               -> Option<&'ll DIScope> {\n+                              -> Option<&'ll DIScope> {\n         let scope_metadata = self.scopes[scope_id].scope_metadata;\n         if pos < self.scopes[scope_id].file_start_pos ||\n            pos >= self.scopes[scope_id].file_end_pos {\n             let cm = self.cx.sess().source_map();\n             let defining_crate = self.debug_context.get_ref(DUMMY_SP).defining_crate;\n             Some(debuginfo::extend_scope_to_file(self.cx,\n-                                            scope_metadata.unwrap(),\n-                                            &cm.lookup_char_pos(pos).file,\n-                                            defining_crate))\n+                                                 scope_metadata.unwrap(),\n+                                                 &cm.lookup_char_pos(pos).file,\n+                                                 defining_crate))\n         } else {\n             scope_metadata\n         }"}]}