{"sha": "18be88f64a9e8ed398843431783230dc5f076799", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4YmU4OGY2NGE5ZThlZDM5ODg0MzQzMTc4MzIzMGRjNWYwNzY3OTk=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-08-13T11:21:45Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-08-15T02:09:18Z"}, "message": "Port privacy.rs from oldvisit to <V:Visitor> trait.", "tree": {"sha": "4db251105df86843f4c8a7bc38d28569be184679", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4db251105df86843f4c8a7bc38d28569be184679"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18be88f64a9e8ed398843431783230dc5f076799", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18be88f64a9e8ed398843431783230dc5f076799", "html_url": "https://github.com/rust-lang/rust/commit/18be88f64a9e8ed398843431783230dc5f076799", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18be88f64a9e8ed398843431783230dc5f076799/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b97cc955c2b2d9494607434352e0898ee0eca0b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b97cc955c2b2d9494607434352e0898ee0eca0b8", "html_url": "https://github.com/rust-lang/rust/commit/b97cc955c2b2d9494607434352e0898ee0eca0b8"}], "stats": {"total": 279, "additions": 146, "deletions": 133}, "files": [{"sha": "6a566f10f1e60b0a4a669a9d7cdce8324f1fe0b9", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 146, "deletions": 133, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/18be88f64a9e8ed398843431783230dc5f076799/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18be88f64a9e8ed398843431783230dc5f076799/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=18be88f64a9e8ed398843431783230dc5f076799", "patch": "@@ -34,54 +34,57 @@ use syntax::ast_util::{variant_visibility_to_privacy, visibility_to_privacy};\n use syntax::attr;\n use syntax::codemap::span;\n use syntax::parse::token;\n-use syntax::oldvisit;\n+use syntax::visit;\n+use syntax::visit::Visitor;\n+use syntax::ast::{_mod,expr,item,Block,pat};\n \n-pub fn check_crate<'mm>(tcx: ty::ctxt,\n-                   method_map: &'mm method_map,\n-                   crate: &ast::Crate) {\n-    let privileged_items = @mut ~[];\n+struct PrivacyVisitor {\n+    tcx: ty::ctxt,\n+    privileged_items: @mut ~[NodeId],\n+}\n \n+impl PrivacyVisitor {\n     // Adds an item to its scope.\n-    let add_privileged_item: @fn(@ast::item, &mut uint) = |item, count| {\n+    fn add_privileged_item(&mut self, item: @ast::item, count: &mut uint) {\n         match item.node {\n             item_struct(*) | item_trait(*) | item_enum(*) |\n             item_fn(*) => {\n-                privileged_items.push(item.id);\n+                self.privileged_items.push(item.id);\n                 *count += 1;\n             }\n             item_impl(_, _, _, ref methods) => {\n                 for method in methods.iter() {\n-                    privileged_items.push(method.id);\n+                    self.privileged_items.push(method.id);\n                     *count += 1;\n                 }\n-                privileged_items.push(item.id);\n+                self.privileged_items.push(item.id);\n                 *count += 1;\n             }\n             item_foreign_mod(ref foreign_mod) => {\n                 for foreign_item in foreign_mod.items.iter() {\n-                    privileged_items.push(foreign_item.id);\n+                    self.privileged_items.push(foreign_item.id);\n                     *count += 1;\n                 }\n             }\n             _ => {}\n         }\n-    };\n+    }\n \n     // Adds items that are privileged to this scope.\n-    let add_privileged_items: @fn(&[@ast::item]) -> uint = |items| {\n+    fn add_privileged_items(&mut self, items: &[@ast::item]) -> uint {\n         let mut count = 0;\n         for &item in items.iter() {\n-            add_privileged_item(item, &mut count);\n+            self.add_privileged_item(item, &mut count);\n         }\n         count\n-    };\n+    }\n \n     // Checks that an enum variant is in scope\n-    let check_variant: @fn(span: span, enum_id: ast::def_id) =\n-            |span, enum_id| {\n-        let variant_info = ty::enum_variants(tcx, enum_id)[0];\n+    fn check_variant(&mut self, span: span, enum_id: ast::def_id) {\n+        let variant_info = ty::enum_variants(self.tcx, enum_id)[0];\n         let parental_privacy = if is_local(enum_id) {\n-            let parent_vis = ast_map::node_item_query(tcx.items, enum_id.node,\n+            let parent_vis = ast_map::node_item_query(self.tcx.items,\n+                                                      enum_id.node,\n                                    |it| { it.vis },\n                                    ~\"unbound enum parent when checking \\\n                                     dereference of enum type\");\n@@ -99,15 +102,14 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n         if variant_visibility_to_privacy(variant_info.vis,\n                                          parental_privacy == Public)\n                                          == Private {\n-            tcx.sess.span_err(span,\n+            self.tcx.sess.span_err(span,\n                 \"can only dereference enums \\\n                  with a single, public variant\");\n         }\n-    };\n+    }\n \n     // Returns true if a crate-local method is private and false otherwise.\n-    let method_is_private: @fn(span: span, method_id: NodeId) -> bool =\n-            |span, method_id| {\n+    fn method_is_private(&mut self, span: span, method_id: NodeId) -> bool {\n         let check = |vis: visibility, container_id: def_id| {\n             let mut is_private = false;\n             if vis == private {\n@@ -117,12 +119,12 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n             } else {\n                 // Look up the enclosing impl.\n                 if container_id.crate != LOCAL_CRATE {\n-                    tcx.sess.span_bug(span,\n+                    self.tcx.sess.span_bug(span,\n                                       \"local method isn't in local \\\n                                        impl?!\");\n                 }\n \n-                match tcx.items.find(&container_id.node) {\n+                match self.tcx.items.find(&container_id.node) {\n                     Some(&node_item(item, _)) => {\n                         match item.node {\n                             item_impl(_, None, _, _)\n@@ -133,18 +135,18 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                         }\n                     }\n                     Some(_) => {\n-                        tcx.sess.span_bug(span, \"impl wasn't an item?!\");\n+                        self.tcx.sess.span_bug(span, \"impl wasn't an item?!\");\n                     }\n                     None => {\n-                        tcx.sess.span_bug(span, \"impl wasn't in AST map?!\");\n+                        self.tcx.sess.span_bug(span, \"impl wasn't in AST map?!\");\n                     }\n                 }\n             }\n \n             is_private\n         };\n \n-        match tcx.items.find(&method_id) {\n+        match self.tcx.items.find(&method_id) {\n             Some(&node_method(method, impl_id, _)) => {\n                 check(method.vis, impl_id)\n             }\n@@ -155,26 +157,25 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                 }\n             }\n             Some(_) => {\n-                tcx.sess.span_bug(span,\n+                self.tcx.sess.span_bug(span,\n                                   fmt!(\"method_is_private: method was a %s?!\",\n                                        ast_map::node_id_to_str(\n-                                            tcx.items,\n+                                            self.tcx.items,\n                                             method_id,\n                                            token::get_ident_interner())));\n             }\n             None => {\n-                tcx.sess.span_bug(span, \"method not found in \\\n+                self.tcx.sess.span_bug(span, \"method not found in \\\n                                          AST map?!\");\n             }\n         }\n-    };\n+    }\n \n     // Returns true if the given local item is private and false otherwise.\n-    let local_item_is_private: @fn(span: span, item_id: NodeId) -> bool =\n-            |span, item_id| {\n+    fn local_item_is_private(&mut self, span: span, item_id: NodeId) -> bool {\n         let mut f: &fn(NodeId) -> bool = |_| false;\n         f = |item_id| {\n-            match tcx.items.find(&item_id) {\n+            match self.tcx.items.find(&item_id) {\n                 Some(&node_item(item, _)) => item.vis != public,\n                 Some(&node_foreign_item(*)) => false,\n                 Some(&node_method(method, impl_did, _)) => {\n@@ -186,104 +187,96 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                 }\n                 Some(&node_trait_method(_, trait_did, _)) => f(trait_did.node),\n                 Some(_) => {\n-                    tcx.sess.span_bug(span,\n+                    self.tcx.sess.span_bug(span,\n                                       fmt!(\"local_item_is_private: item was \\\n                                             a %s?!\",\n                                            ast_map::node_id_to_str(\n-                                                tcx.items,\n+                                                self.tcx.items,\n                                                 item_id,\n                                                token::get_ident_interner())));\n                 }\n                 None => {\n-                    tcx.sess.span_bug(span, \"item not found in AST map?!\");\n+                    self.tcx.sess.span_bug(span, \"item not found in AST map?!\");\n                 }\n             }\n         };\n         f(item_id)\n-    };\n+    }\n \n     // Checks that a private field is in scope.\n-    let check_field: @fn(span: span, id: ast::def_id, ident: ast::ident) =\n-            |span, id, ident| {\n-        let fields = ty::lookup_struct_fields(tcx, id);\n+    fn check_field(&mut self, span: span, id: ast::def_id, ident: ast::ident) {\n+        let fields = ty::lookup_struct_fields(self.tcx, id);\n         for field in fields.iter() {\n             if field.ident != ident { loop; }\n             if field.vis == private {\n-                tcx.sess.span_err(span, fmt!(\"field `%s` is private\",\n+                self.tcx.sess.span_err(span, fmt!(\"field `%s` is private\",\n                                              token::ident_to_str(&ident)));\n             }\n             break;\n         }\n-    };\n+    }\n \n     // Given the ID of a method, checks to ensure it's in scope.\n-    let check_method_common: @fn(span: span,\n-                                 method_id: def_id,\n-                                 name: &ident) =\n-            |span, method_id, name| {\n+    fn check_method_common(&mut self, span: span, method_id: def_id, name: &ident) {\n         // If the method is a default method, we need to use the def_id of\n         // the default implementation.\n         // Having to do this this is really unfortunate.\n-        let method_id = ty::method(tcx, method_id).provided_source\n+        let method_id = ty::method(self.tcx, method_id).provided_source\n             .unwrap_or_default(method_id);\n \n         if method_id.crate == LOCAL_CRATE {\n-            let is_private = method_is_private(span, method_id.node);\n-            let container_id = ty::method(tcx, method_id).container_id;\n+            let is_private = self.method_is_private(span, method_id.node);\n+            let container_id = ty::method(self.tcx, method_id).container_id;\n             if is_private &&\n                     (container_id.crate != LOCAL_CRATE ||\n-                     !privileged_items.iter().any(|x| x == &(container_id.node))) {\n-                tcx.sess.span_err(span,\n+                     !self.privileged_items.iter().any(|x| x == &(container_id.node))) {\n+                self.tcx.sess.span_err(span,\n                                   fmt!(\"method `%s` is private\",\n                                        token::ident_to_str(name)));\n             }\n         } else {\n             let visibility =\n-                csearch::get_item_visibility(tcx.sess.cstore, method_id);\n+                csearch::get_item_visibility(self.tcx.sess.cstore, method_id);\n             if visibility != public {\n-                tcx.sess.span_err(span,\n+                self.tcx.sess.span_err(span,\n                                   fmt!(\"method `%s` is private\",\n                                        token::ident_to_str(name)));\n             }\n         }\n-    };\n+    }\n \n     // Checks that a private path is in scope.\n-    let check_path: @fn(span: span, def: def, path: &Path) =\n-            |span, def, path| {\n+    fn check_path(&mut self, span: span, def: def, path: &Path) {\n         debug!(\"checking path\");\n         match def {\n             def_static_method(method_id, _, _) => {\n                 debug!(\"found static method def, checking it\");\n-                check_method_common(span, method_id, path.idents.last())\n+                self.check_method_common(span, method_id, path.idents.last())\n             }\n             def_fn(def_id, _) => {\n                 if def_id.crate == LOCAL_CRATE {\n-                    if local_item_is_private(span, def_id.node) &&\n-                            !privileged_items.iter().any(|x| x == &def_id.node) {\n-                        tcx.sess.span_err(span,\n+                    if self.local_item_is_private(span, def_id.node) &&\n+                            !self.privileged_items.iter().any(|x| x == &def_id.node) {\n+                        self.tcx.sess.span_err(span,\n                                           fmt!(\"function `%s` is private\",\n                                                token::ident_to_str(path.idents.last())));\n                     }\n-                } else if csearch::get_item_visibility(tcx.sess.cstore,\n+                } else if csearch::get_item_visibility(self.tcx.sess.cstore,\n                                                        def_id) != public {\n-                    tcx.sess.span_err(span,\n+                    self.tcx.sess.span_err(span,\n                                       fmt!(\"function `%s` is private\",\n                                            token::ident_to_str(path.idents.last())));\n                 }\n             }\n             _ => {}\n         }\n-    };\n+    }\n \n     // Checks that a private method is in scope.\n-    let check_method: @fn(span: span,\n-                          origin: &method_origin,\n-                          ident: ast::ident) =\n-            |span, origin, ident| {\n+    fn check_method(&mut self, span: span, origin: &method_origin, ident: ast::ident) {\n         match *origin {\n             method_static(method_id) => {\n-                check_method_common(span, method_id, &ident)\n+                self.check_method_common(span, method_id, &ident)\n             }\n             method_param(method_param {\n                 trait_id: trait_id,\n@@ -292,19 +285,20 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n             }) |\n             method_trait(trait_id, method_num) => {\n                 if trait_id.crate == LOCAL_CRATE {\n-                    match tcx.items.find(&trait_id.node) {\n+                    match self.tcx.items.find(&trait_id.node) {\n                         Some(&node_item(item, _)) => {\n                             match item.node {\n                                 item_trait(_, _, ref methods) => {\n                                     if method_num >= (*methods).len() {\n-                                        tcx.sess.span_bug(span, \"method number out of range?!\");\n+                                        self.tcx.sess.span_bug(span,\n+                                                               \"method number out of range?!\");\n                                     }\n                                     match (*methods)[method_num] {\n                                         provided(method)\n                                              if method.vis == private &&\n-                                             !privileged_items.iter()\n+                                             !self.privileged_items.iter()\n                                              .any(|x| x == &(trait_id.node)) => {\n-                                            tcx.sess.span_err(span,\n+                                            self.tcx.sess.span_err(span,\n                                                               fmt!(\"method `%s` is private\",\n                                                                    token::ident_to_str(&method\n                                                                                         .ident)));\n@@ -316,54 +310,60 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                                     }\n                                 }\n                                 _ => {\n-                                    tcx.sess.span_bug(span, \"trait wasn't actually a trait?!\");\n+                                    self.tcx.sess.span_bug(span, \"trait wasn't actually a trait?!\");\n                                 }\n                             }\n                         }\n                         Some(_) => {\n-                            tcx.sess.span_bug(span, \"trait wasn't an item?!\");\n+                            self.tcx.sess.span_bug(span, \"trait wasn't an item?!\");\n                         }\n                         None => {\n-                            tcx.sess.span_bug(span, \"trait item wasn't found in the AST map?!\");\n+                            self.tcx.sess.span_bug(span,\n+                                                   \"trait item wasn't found in the AST map?!\");\n                         }\n                     }\n                 } else {\n                     // FIXME #4732: External crates.\n                 }\n             }\n         }\n-    };\n+    }\n+}\n+\n+impl<'self> Visitor<&'self method_map> for PrivacyVisitor {\n \n-    let visitor = oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_mod: |the_module, span, node_id, (method_map, visitor)| {\n-            let n_added = add_privileged_items(the_module.items);\n+    fn visit_mod<'mm>(&mut self, the_module:&_mod, _:span, _:NodeId,\n+                      method_map:&'mm method_map) {\n \n-            oldvisit::visit_mod(the_module,\n-                                span,\n-                                node_id,\n-                                (method_map, visitor));\n+            let n_added = self.add_privileged_items(the_module.items);\n+\n+            visit::walk_mod(self, the_module, method_map);\n \n             do n_added.times {\n-                ignore(privileged_items.pop());\n+                ignore(self.privileged_items.pop());\n             }\n-        },\n-        visit_item: |item, (method_map, visitor)| {\n+    }\n+\n+    fn visit_item<'mm>(&mut self, item:@item, method_map:&'mm method_map) {\n+\n             // Do not check privacy inside items with the resolve_unexported\n             // attribute. This is used for the test runner.\n             if !attr::contains_name(item.attrs, \"!resolve_unexported\") {\n-                check_sane_privacy(tcx, item);\n-                oldvisit::visit_item(item, (method_map, visitor));\n+                check_sane_privacy(self.tcx, item);\n+                visit::walk_item(self, item, method_map);\n             }\n-        },\n-        visit_block: |block, (method_map, visitor)| {\n+    }\n+\n+    fn visit_block<'mm>(&mut self, block:&Block, method_map:&'mm method_map) {\n+\n             // Gather up all the privileged items.\n             let mut n_added = 0;\n             for stmt in block.stmts.iter() {\n                 match stmt.node {\n                     stmt_decl(decl, _) => {\n                         match decl.node {\n                             decl_item(item) => {\n-                                add_privileged_item(item, &mut n_added);\n+                                self.add_privileged_item(item, &mut n_added);\n                             }\n                             _ => {}\n                         }\n@@ -372,15 +372,16 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                 }\n             }\n \n-            oldvisit::visit_block(block, (method_map, visitor));\n+            visit::walk_block(self, block, method_map);\n \n             do n_added.times {\n-                ignore(privileged_items.pop());\n+                ignore(self.privileged_items.pop());\n             }\n-        },\n-        visit_expr: |expr,\n-                     (method_map, visitor):\n-                        (&'mm method_map, oldvisit::vt<&'mm method_map>)| {\n+\n+    }\n+\n+    fn visit_expr<'mm>(&mut self, expr:@expr, method_map:&'mm method_map) {\n+\n             match expr.node {\n                 expr_field(base, ident, _) => {\n                     // Method calls are now a special syntactic form,\n@@ -389,71 +390,71 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n \n                     // With type_autoderef, make sure we don't\n                     // allow pointers to violate privacy\n-                    match ty::get(ty::type_autoderef(tcx, ty::expr_ty(tcx,\n+                    match ty::get(ty::type_autoderef(self.tcx, ty::expr_ty(self.tcx,\n                                                           base))).sty {\n                         ty_struct(id, _)\n-                        if id.crate != LOCAL_CRATE || !privileged_items.iter()\n+                        if id.crate != LOCAL_CRATE || !self.privileged_items.iter()\n                                 .any(|x| x == &(id.node)) => {\n                             debug!(\"(privacy checking) checking field access\");\n-                            check_field(expr.span, id, ident);\n+                            self.check_field(expr.span, id, ident);\n                         }\n                         _ => {}\n                     }\n                 }\n                 expr_method_call(_, base, ident, _, _, _) => {\n                     // Ditto\n-                    match ty::get(ty::type_autoderef(tcx, ty::expr_ty(tcx,\n+                    match ty::get(ty::type_autoderef(self.tcx, ty::expr_ty(self.tcx,\n                                                           base))).sty {\n                         ty_enum(id, _) |\n                         ty_struct(id, _)\n                         if id.crate != LOCAL_CRATE ||\n-                           !privileged_items.iter().any(|x| x == &(id.node)) => {\n+                           !self.privileged_items.iter().any(|x| x == &(id.node)) => {\n                             match method_map.find(&expr.id) {\n                                 None => {\n-                                    tcx.sess.span_bug(expr.span,\n+                                    self.tcx.sess.span_bug(expr.span,\n                                                       \"method call not in \\\n                                                        method map\");\n                                 }\n                                 Some(ref entry) => {\n                                     debug!(\"(privacy checking) checking \\\n                                             impl method\");\n-                                    check_method(expr.span, &entry.origin, ident);\n+                                    self.check_method(expr.span, &entry.origin, ident);\n                                 }\n                             }\n                         }\n                         _ => {}\n                     }\n                 }\n                 expr_path(ref path) => {\n-                    check_path(expr.span, tcx.def_map.get_copy(&expr.id), path);\n+                    self.check_path(expr.span, self.tcx.def_map.get_copy(&expr.id), path);\n                 }\n                 expr_struct(_, ref fields, _) => {\n-                    match ty::get(ty::expr_ty(tcx, expr)).sty {\n+                    match ty::get(ty::expr_ty(self.tcx, expr)).sty {\n                         ty_struct(id, _) => {\n                             if id.crate != LOCAL_CRATE ||\n-                                    !privileged_items.iter().any(|x| x == &(id.node)) {\n+                                    !self.privileged_items.iter().any(|x| x == &(id.node)) {\n                                 for field in (*fields).iter() {\n                                         debug!(\"(privacy checking) checking \\\n                                                 field in struct literal\");\n-                                    check_field(expr.span, id, field.ident);\n+                                    self.check_field(expr.span, id, field.ident);\n                                 }\n                             }\n                         }\n                         ty_enum(id, _) => {\n                             if id.crate != LOCAL_CRATE ||\n-                                    !privileged_items.iter().any(|x| x == &(id.node)) {\n-                                match tcx.def_map.get_copy(&expr.id) {\n+                                    !self.privileged_items.iter().any(|x| x == &(id.node)) {\n+                                match self.tcx.def_map.get_copy(&expr.id) {\n                                     def_variant(_, variant_id) => {\n                                         for field in (*fields).iter() {\n                                                 debug!(\"(privacy checking) \\\n                                                         checking field in \\\n                                                         struct variant \\\n                                                         literal\");\n-                                            check_field(expr.span, variant_id, field.ident);\n+                                            self.check_field(expr.span, variant_id, field.ident);\n                                         }\n                                     }\n                                     _ => {\n-                                        tcx.sess.span_bug(expr.span,\n+                                        self.tcx.sess.span_bug(expr.span,\n                                                           \"resolve didn't \\\n                                                            map enum struct \\\n                                                            constructor to a \\\n@@ -463,7 +464,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                             }\n                         }\n                         _ => {\n-                            tcx.sess.span_bug(expr.span, \"struct expr \\\n+                            self.tcx.sess.span_bug(expr.span, \"struct expr \\\n                                                           didn't have \\\n                                                           struct type?!\");\n                         }\n@@ -474,11 +475,11 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                     // enum type t, then t's first variant is public or\n                     // privileged. (We can assume it has only one variant\n                     // since typeck already happened.)\n-                    match ty::get(ty::expr_ty(tcx, operand)).sty {\n+                    match ty::get(ty::expr_ty(self.tcx, operand)).sty {\n                         ty_enum(id, _) => {\n                             if id.crate != LOCAL_CRATE ||\n-                                !privileged_items.iter().any(|x| x == &(id.node)) {\n-                                check_variant(expr.span, id);\n+                                !self.privileged_items.iter().any(|x| x == &(id.node)) {\n+                                self.check_variant(expr.span, id);\n                             }\n                         }\n                         _ => { /* No check needed */ }\n@@ -487,36 +488,39 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                 _ => {}\n             }\n \n-            oldvisit::visit_expr(expr, (method_map, visitor));\n-        },\n-        visit_pat: |pattern, (method_map, visitor)| {\n+            visit::walk_expr(self, expr, method_map);\n+\n+    }\n+\n+    fn visit_pat<'mm>(&mut self, pattern:@pat, method_map:&'mm method_map) {\n+\n             match pattern.node {\n                 pat_struct(_, ref fields, _) => {\n-                    match ty::get(ty::pat_ty(tcx, pattern)).sty {\n+                    match ty::get(ty::pat_ty(self.tcx, pattern)).sty {\n                         ty_struct(id, _) => {\n                             if id.crate != LOCAL_CRATE ||\n-                                    !privileged_items.iter().any(|x| x == &(id.node)) {\n+                                    !self.privileged_items.iter().any(|x| x == &(id.node)) {\n                                 for field in fields.iter() {\n                                         debug!(\"(privacy checking) checking \\\n                                                 struct pattern\");\n-                                    check_field(pattern.span, id, field.ident);\n+                                    self.check_field(pattern.span, id, field.ident);\n                                 }\n                             }\n                         }\n                         ty_enum(enum_id, _) => {\n                             if enum_id.crate != LOCAL_CRATE ||\n-                                    !privileged_items.iter().any(|x| x == &enum_id.node) {\n-                                match tcx.def_map.find(&pattern.id) {\n+                                    !self.privileged_items.iter().any(|x| x == &enum_id.node) {\n+                                match self.tcx.def_map.find(&pattern.id) {\n                                     Some(&def_variant(_, variant_id)) => {\n                                         for field in fields.iter() {\n                                             debug!(\"(privacy checking) \\\n                                                     checking field in \\\n                                                     struct variant pattern\");\n-                                            check_field(pattern.span, variant_id, field.ident);\n+                                            self.check_field(pattern.span, variant_id, field.ident);\n                                         }\n                                     }\n                                     _ => {\n-                                        tcx.sess.span_bug(pattern.span,\n+                                        self.tcx.sess.span_bug(pattern.span,\n                                                           \"resolve didn't \\\n                                                            map enum struct \\\n                                                            pattern to a \\\n@@ -526,7 +530,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                             }\n                         }\n                         _ => {\n-                            tcx.sess.span_bug(pattern.span,\n+                            self.tcx.sess.span_bug(pattern.span,\n                                               \"struct pattern didn't have \\\n                                                struct type?!\");\n                         }\n@@ -535,11 +539,20 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                 _ => {}\n             }\n \n-            oldvisit::visit_pat(pattern, (method_map, visitor));\n-        },\n-        .. *oldvisit::default_visitor()\n-    });\n-    oldvisit::visit_crate(crate, (method_map, visitor));\n+            visit::walk_pat(self, pattern, method_map);\n+    }\n+}\n+\n+pub fn check_crate<'mm>(tcx: ty::ctxt,\n+                        method_map: &'mm method_map,\n+                        crate: &ast::Crate) {\n+    let privileged_items = @mut ~[];\n+\n+    let mut visitor = PrivacyVisitor {\n+        tcx: tcx,\n+        privileged_items: privileged_items,\n+    };\n+    visit::walk_crate(&mut visitor, crate, method_map);\n }\n \n /// Validates all of the visibility qualifers placed on the item given. This"}]}