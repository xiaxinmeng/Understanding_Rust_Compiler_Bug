{"sha": "55c07678cd80772be719416427f2986dd3524022", "node_id": "C_kwDOAAsO6NoAKDU1YzA3Njc4Y2Q4MDc3MmJlNzE5NDE2NDI3ZjI5ODZkZDM1MjQwMjI", "commit": {"author": {"name": "Pietro Albini", "email": "pietro.albini@ferrous-systems.com", "date": "2023-04-14T09:57:22Z"}, "committer": {"name": "Pietro Albini", "email": "pietro.albini@ferrous-systems.com", "date": "2023-04-14T09:57:22Z"}, "message": "refactor ignore- and only- to use decisions", "tree": {"sha": "ac2d88c8bc6c7c28cd6ebd86477116db915f55fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac2d88c8bc6c7c28cd6ebd86477116db915f55fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55c07678cd80772be719416427f2986dd3524022", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEMycKYjxLY0eb13b7zXazX3c0dp4FAmQ5I40ACgkQzXazX3c0\ndp4/kg//Uj5snXCdrKUngmwtQhxEO7l9/RpdSbcajVoyxiSbL9COh5v53FZVK2lM\nWOBafmLG/Qk1YMTE8fKQMZliDmE7pQ65aSovz5+Gn+Tj/Qw5Dzt0eX0NXHWZG9XK\nO2oHHnluQtf/0QM88AJSsFiT9HQrE913mbvc5Z3UHaflb3vJbUoT6FluqBp9QZf/\n+uWS/T2EVEUAEymRksHsp3J2f1Bkls1+MmBrj2SZAqI3T5nOoICNCGmJULPDJEAR\nGynUFTKhN3lz/1+FcJDGSVKKbngz+BfkBtyg03PJuzSKPgbNzzkOUf1DnAhGnPWL\nU5ACM5NDCivjItxRl4qgG0qSpLr5HtUJ3YGWnzzVA+vVaTMbT6QmGTJecQwgInfi\nyXItPQwuJpy0SFeqd7MtLzPKBKuWwFXka+/f8UWMwmqDY0mOCKtTQgML/NANCJJ9\nAxqk9/RNFPy4RlRhGSDCeCOwxS3ifjoiT86toN1gmQd42YoL0B3G65CXtUJJu7bb\nDsNzRfLrOCiBjls78skv1GgS9CZsyl3LJqeC3+LdxnUYG4SjJm7OXHIxG5mlr0np\nkFMT0Y/nrHgN2n+BKrHhYK891u8S4sFIcLtUd6PTrg7oMieKNYaf9AxHagVbAcLa\ntQylDQjrTqLwGUm2/PD5zD0mIaf9df9BtzaIwKMu8Ddi90+nRPA=\n=lRIn\n-----END PGP SIGNATURE-----", "payload": "tree ac2d88c8bc6c7c28cd6ebd86477116db915f55fa\nparent ffe4ccd4ad1a96239b82b700a626a3644ddc364d\nauthor Pietro Albini <pietro.albini@ferrous-systems.com> 1681466242 +0200\ncommitter Pietro Albini <pietro.albini@ferrous-systems.com> 1681466242 +0200\n\nrefactor ignore- and only- to use decisions\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55c07678cd80772be719416427f2986dd3524022", "html_url": "https://github.com/rust-lang/rust/commit/55c07678cd80772be719416427f2986dd3524022", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55c07678cd80772be719416427f2986dd3524022/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffe4ccd4ad1a96239b82b700a626a3644ddc364d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffe4ccd4ad1a96239b82b700a626a3644ddc364d", "html_url": "https://github.com/rust-lang/rust/commit/ffe4ccd4ad1a96239b82b700a626a3644ddc364d"}], "stats": {"total": 103, "additions": 50, "deletions": 53}, "files": [{"sha": "8d2fd881d26ab291f6081bb6459475a801a536a2", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 3, "deletions": 48, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/55c07678cd80772be719416427f2986dd3524022/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55c07678cd80772be719416427f2986dd3524022/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=55c07678cd80772be719416427f2986dd3524022", "patch": "@@ -660,13 +660,6 @@ impl Config {\n         }\n     }\n \n-    fn has_cfg_prefix(&self, line: &str, prefix: &str) -> bool {\n-        // returns whether this line contains this prefix or not. For prefix\n-        // \"ignore\", returns true if line says \"ignore-x86_64\", \"ignore-arch\",\n-        // \"ignore-android\" etc.\n-        line.starts_with(prefix) && line.as_bytes().get(prefix.len()) == Some(&b'-')\n-    }\n-\n     fn parse_name_directive(&self, line: &str, directive: &str) -> bool {\n         // Ensure the directive is a whole word. Do not match \"ignore-x86\" when\n         // the line says \"ignore-x86_64\".\n@@ -878,7 +871,7 @@ pub fn make_test_description<R: Read>(\n                         // The ignore reason must be a &'static str, so we have to leak memory to\n                         // create it. This is fine, as the header is parsed only at the start of\n                         // compiletest so it won't grow indefinitely.\n-                        ignore_message = Some(Box::leak(Box::<str>::from(reason)));\n+                        ignore_message = Some(&*Box::leak(Box::<str>::from(reason)));\n                     }\n                     IgnoreDecision::Error { message } => {\n                         eprintln!(\"error: {}: {message}\", path.display());\n@@ -889,46 +882,8 @@ pub fn make_test_description<R: Read>(\n             };\n         }\n \n-        {\n-            let parsed = parse_cfg_name_directive(config, ln, \"ignore\");\n-            ignore = match parsed.outcome {\n-                MatchOutcome::Match => {\n-                    let reason = parsed.pretty_reason.unwrap();\n-                    // The ignore reason must be a &'static str, so we have to leak memory to\n-                    // create it. This is fine, as the header is parsed only at the start of\n-                    // compiletest so it won't grow indefinitely.\n-                    ignore_message = Some(Box::leak(Box::<str>::from(match parsed.comment {\n-                        Some(comment) => format!(\"ignored {reason} ({comment})\"),\n-                        None => format!(\"ignored {reason}\"),\n-                    })) as &str);\n-                    true\n-                }\n-                MatchOutcome::NoMatch => ignore,\n-                MatchOutcome::External => ignore,\n-                MatchOutcome::Invalid => panic!(\"invalid line in {}: {ln}\", path.display()),\n-            };\n-        }\n-\n-        if config.has_cfg_prefix(ln, \"only\") {\n-            let parsed = parse_cfg_name_directive(config, ln, \"only\");\n-            ignore = match parsed.outcome {\n-                MatchOutcome::Match => ignore,\n-                MatchOutcome::NoMatch => {\n-                    let reason = parsed.pretty_reason.unwrap();\n-                    // The ignore reason must be a &'static str, so we have to leak memory to\n-                    // create it. This is fine, as the header is parsed only at the start of\n-                    // compiletest so it won't grow indefinitely.\n-                    ignore_message = Some(Box::leak(Box::<str>::from(match parsed.comment {\n-                        Some(comment) => format!(\"only executed {reason} ({comment})\"),\n-                        None => format!(\"only executed {reason}\"),\n-                    })) as &str);\n-                    true\n-                }\n-                MatchOutcome::External => ignore,\n-                MatchOutcome::Invalid => panic!(\"invalid line in {}: {ln}\", path.display()),\n-            };\n-        }\n-\n+        decision!(cfg::handle_ignore(config, ln));\n+        decision!(cfg::handle_only(config, ln));\n         decision!(needs::handle_needs(&needs_cache, config, ln));\n         decision!(ignore_llvm(config, ln));\n         decision!(ignore_cdb(config, ln));"}, {"sha": "a9694d4d52c883206ce2ff2bd93d43f6ae627e95", "filename": "src/tools/compiletest/src/header/cfg.rs", "status": "modified", "additions": 47, "deletions": 5, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/55c07678cd80772be719416427f2986dd3524022/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55c07678cd80772be719416427f2986dd3524022/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Fcfg.rs?ref=55c07678cd80772be719416427f2986dd3524022", "patch": "@@ -1,8 +1,43 @@\n use crate::common::{CompareMode, Config, Debugger};\n+use crate::header::IgnoreDecision;\n use std::collections::HashSet;\n \n const EXTRA_ARCHS: &[&str] = &[\"spirv\"];\n \n+pub(super) fn handle_ignore(config: &Config, line: &str) -> IgnoreDecision {\n+    let parsed = parse_cfg_name_directive(config, line, \"ignore\");\n+    match parsed.outcome {\n+        MatchOutcome::NoMatch => IgnoreDecision::Continue,\n+        MatchOutcome::Match => IgnoreDecision::Ignore {\n+            reason: match parsed.comment {\n+                Some(comment) => format!(\"ignored {} ({comment})\", parsed.pretty_reason.unwrap()),\n+                None => format!(\"ignored {}\", parsed.pretty_reason.unwrap()),\n+            },\n+        },\n+        MatchOutcome::Invalid => IgnoreDecision::Error { message: format!(\"invalid line: {line}\") },\n+        MatchOutcome::External => IgnoreDecision::Continue,\n+        MatchOutcome::NotADirective => IgnoreDecision::Continue,\n+    }\n+}\n+\n+pub(super) fn handle_only(config: &Config, line: &str) -> IgnoreDecision {\n+    let parsed = parse_cfg_name_directive(config, line, \"only\");\n+    match parsed.outcome {\n+        MatchOutcome::Match => IgnoreDecision::Continue,\n+        MatchOutcome::NoMatch => IgnoreDecision::Ignore {\n+            reason: match parsed.comment {\n+                Some(comment) => {\n+                    format!(\"only executed {} ({comment})\", parsed.pretty_reason.unwrap())\n+                }\n+                None => format!(\"only executed {}\", parsed.pretty_reason.unwrap()),\n+            },\n+        },\n+        MatchOutcome::Invalid => IgnoreDecision::Error { message: format!(\"invalid line: {line}\") },\n+        MatchOutcome::External => IgnoreDecision::Continue,\n+        MatchOutcome::NotADirective => IgnoreDecision::Continue,\n+    }\n+}\n+\n /// Parses a name-value directive which contains config-specific information, e.g., `ignore-x86`\n /// or `normalize-stderr-32bit`.\n pub(super) fn parse_cfg_name_directive<'a>(\n@@ -11,10 +46,10 @@ pub(super) fn parse_cfg_name_directive<'a>(\n     prefix: &str,\n ) -> ParsedNameDirective<'a> {\n     if !line.as_bytes().starts_with(prefix.as_bytes()) {\n-        return ParsedNameDirective::invalid();\n+        return ParsedNameDirective::not_a_directive();\n     }\n     if line.as_bytes().get(prefix.len()) != Some(&b'-') {\n-        return ParsedNameDirective::invalid();\n+        return ParsedNameDirective::not_a_directive();\n     }\n     let line = &line[prefix.len() + 1..];\n \n@@ -24,7 +59,7 @@ pub(super) fn parse_cfg_name_directive<'a>(\n     // Some of the matchers might be \"\" depending on what the target information is. To avoid\n     // problems we outright reject empty directives.\n     if name == \"\" {\n-        return ParsedNameDirective::invalid();\n+        return ParsedNameDirective::not_a_directive();\n     }\n \n     let mut outcome = MatchOutcome::Invalid;\n@@ -218,8 +253,13 @@ pub(super) struct ParsedNameDirective<'a> {\n }\n \n impl ParsedNameDirective<'_> {\n-    fn invalid() -> Self {\n-        Self { name: None, pretty_reason: None, comment: None, outcome: MatchOutcome::NoMatch }\n+    fn not_a_directive() -> Self {\n+        Self {\n+            name: None,\n+            pretty_reason: None,\n+            comment: None,\n+            outcome: MatchOutcome::NotADirective,\n+        }\n     }\n }\n \n@@ -233,6 +273,8 @@ pub(super) enum MatchOutcome {\n     Invalid,\n     /// The directive is handled by other parts of our tooling.\n     External,\n+    /// The line is not actually a directive.\n+    NotADirective,\n }\n \n trait CustomContains {"}]}