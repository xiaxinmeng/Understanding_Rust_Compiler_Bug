{"sha": "ecbef77bd71c2a4b4ad8dbb0b0ffa67affe29cc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjYmVmNzdiZDcxYzJhNGI0YWQ4ZGJiMGIwZmZhNjdhZmZlMjljYzM=", "commit": {"author": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-12T03:04:44Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-16T02:25:46Z"}, "message": "Extract lints of unit_types group from types group", "tree": {"sha": "33b871d5945bbea4148528d2b3564721746c5b05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33b871d5945bbea4148528d2b3564721746c5b05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecbef77bd71c2a4b4ad8dbb0b0ffa67affe29cc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecbef77bd71c2a4b4ad8dbb0b0ffa67affe29cc3", "html_url": "https://github.com/rust-lang/rust/commit/ecbef77bd71c2a4b4ad8dbb0b0ffa67affe29cc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecbef77bd71c2a4b4ad8dbb0b0ffa67affe29cc3/comments", "author": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99ecb6189d1347f4be1552f33fb4b7b2295a3769", "url": "https://api.github.com/repos/rust-lang/rust/commits/99ecb6189d1347f4be1552f33fb4b7b2295a3769", "html_url": "https://github.com/rust-lang/rust/commit/99ecb6189d1347f4be1552f33fb4b7b2295a3769"}], "stats": {"total": 817, "additions": 415, "deletions": 402}, "files": [{"sha": "f80aee182e22e12d18e8799f94206a733848fd01", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ecbef77bd71c2a4b4ad8dbb0b0ffa67affe29cc3/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecbef77bd71c2a4b4ad8dbb0b0ffa67affe29cc3/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=ecbef77bd71c2a4b4ad8dbb0b0ffa67affe29cc3", "patch": "@@ -350,6 +350,7 @@ mod types;\n mod undropped_manually_drops;\n mod unicode;\n mod unit_return_expecting_ord;\n+mod unit_types;\n mod unnamed_address;\n mod unnecessary_sort_by;\n mod unnecessary_wraps;\n@@ -960,20 +961,20 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &types::BOX_VEC,\n         &types::IMPLICIT_HASHER,\n         &types::INVALID_UPCAST_COMPARISONS,\n-        &types::LET_UNIT_VALUE,\n         &types::LINKEDLIST,\n         &types::OPTION_OPTION,\n         &types::RC_BUFFER,\n         &types::REDUNDANT_ALLOCATION,\n         &types::TYPE_COMPLEXITY,\n-        &types::UNIT_ARG,\n-        &types::UNIT_CMP,\n         &types::VEC_BOX,\n         &undropped_manually_drops::UNDROPPED_MANUALLY_DROPS,\n         &unicode::INVISIBLE_CHARACTERS,\n         &unicode::NON_ASCII_LITERAL,\n         &unicode::UNICODE_NOT_NFC,\n         &unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD,\n+        &unit_types::LET_UNIT_VALUE,\n+        &unit_types::UNIT_ARG,\n+        &unit_types::UNIT_CMP,\n         &unnamed_address::FN_ADDRESS_COMPARISONS,\n         &unnamed_address::VTABLE_ADDRESS_COMPARISONS,\n         &unnecessary_sort_by::UNNECESSARY_SORT_BY,\n@@ -1084,8 +1085,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box map_clone::MapClone);\n     store.register_late_pass(|| box map_err_ignore::MapErrIgnore);\n     store.register_late_pass(|| box shadow::Shadow);\n-    store.register_late_pass(|| box types::LetUnitValue);\n-    store.register_late_pass(|| box types::UnitCmp);\n+    store.register_late_pass(|| box unit_types::LetUnitValue);\n+    store.register_late_pass(|| box unit_types::UnitCmp);\n     store.register_late_pass(|| box loops::Loops);\n     store.register_late_pass(|| box main_recursion::MainRecursion::default());\n     store.register_late_pass(|| box lifetimes::Lifetimes);\n@@ -1160,7 +1161,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box useless_conversion::UselessConversion::default());\n     store.register_late_pass(|| box types::ImplicitHasher);\n     store.register_late_pass(|| box fallible_impl_from::FallibleImplFrom);\n-    store.register_late_pass(|| box types::UnitArg);\n+    store.register_late_pass(|| box unit_types::UnitArg);\n     store.register_late_pass(|| box double_comparison::DoubleComparisons);\n     store.register_late_pass(|| box question_mark::QuestionMark);\n     store.register_early_pass(|| box suspicious_operation_groupings::SuspiciousOperationGroupings);\n@@ -1415,11 +1416,11 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&trait_bounds::TYPE_REPETITION_IN_BOUNDS),\n         LintId::of(&types::IMPLICIT_HASHER),\n         LintId::of(&types::INVALID_UPCAST_COMPARISONS),\n-        LintId::of(&types::LET_UNIT_VALUE),\n         LintId::of(&types::LINKEDLIST),\n         LintId::of(&types::OPTION_OPTION),\n         LintId::of(&unicode::NON_ASCII_LITERAL),\n         LintId::of(&unicode::UNICODE_NOT_NFC),\n+        LintId::of(&unit_types::LET_UNIT_VALUE),\n         LintId::of(&unnecessary_wraps::UNNECESSARY_WRAPS),\n         LintId::of(&unnested_or_patterns::UNNESTED_OR_PATTERNS),\n         LintId::of(&unused_self::UNUSED_SELF),\n@@ -1708,12 +1709,12 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&types::BOX_VEC),\n         LintId::of(&types::REDUNDANT_ALLOCATION),\n         LintId::of(&types::TYPE_COMPLEXITY),\n-        LintId::of(&types::UNIT_ARG),\n-        LintId::of(&types::UNIT_CMP),\n         LintId::of(&types::VEC_BOX),\n         LintId::of(&undropped_manually_drops::UNDROPPED_MANUALLY_DROPS),\n         LintId::of(&unicode::INVISIBLE_CHARACTERS),\n         LintId::of(&unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD),\n+        LintId::of(&unit_types::UNIT_ARG),\n+        LintId::of(&unit_types::UNIT_CMP),\n         LintId::of(&unnamed_address::FN_ADDRESS_COMPARISONS),\n         LintId::of(&unnamed_address::VTABLE_ADDRESS_COMPARISONS),\n         LintId::of(&unnecessary_sort_by::UNNECESSARY_SORT_BY),\n@@ -1934,8 +1935,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&transmute::TRANSMUTE_PTR_TO_REF),\n         LintId::of(&types::BORROWED_BOX),\n         LintId::of(&types::TYPE_COMPLEXITY),\n-        LintId::of(&types::UNIT_ARG),\n         LintId::of(&types::VEC_BOX),\n+        LintId::of(&unit_types::UNIT_ARG),\n         LintId::of(&unnecessary_sort_by::UNNECESSARY_SORT_BY),\n         LintId::of(&unwrap::UNNECESSARY_UNWRAP),\n         LintId::of(&useless_conversion::USELESS_CONVERSION),\n@@ -2005,10 +2006,10 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&transmute::WRONG_TRANSMUTE),\n         LintId::of(&transmuting_null::TRANSMUTING_NULL),\n         LintId::of(&types::ABSURD_EXTREME_COMPARISONS),\n-        LintId::of(&types::UNIT_CMP),\n         LintId::of(&undropped_manually_drops::UNDROPPED_MANUALLY_DROPS),\n         LintId::of(&unicode::INVISIBLE_CHARACTERS),\n         LintId::of(&unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD),\n+        LintId::of(&unit_types::UNIT_CMP),\n         LintId::of(&unnamed_address::FN_ADDRESS_COMPARISONS),\n         LintId::of(&unnamed_address::VTABLE_ADDRESS_COMPARISONS),\n         LintId::of(&unused_io_amount::UNUSED_IO_AMOUNT),"}, {"sha": "5103a259559b018f723b5a355aa511e858c66d5e", "filename": "clippy_lints/src/types/mod.rs", "status": "modified", "additions": 5, "deletions": 391, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/ecbef77bd71c2a4b4ad8dbb0b0ffa67affe29cc3/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecbef77bd71c2a4b4ad8dbb0b0ffa67affe29cc3/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=ecbef77bd71c2a4b4ad8dbb0b0ffa67affe29cc3", "patch": "@@ -14,23 +14,21 @@ use std::cmp::Ordering;\n use std::collections::BTreeMap;\n \n use clippy_utils::diagnostics::{multispan_sugg, span_lint, span_lint_and_help, span_lint_and_then};\n-use clippy_utils::source::{indent_of, reindent_multiline, snippet, snippet_opt, snippet_with_macro_callsite};\n+use clippy_utils::source::{snippet, snippet_opt};\n use clippy_utils::ty::{is_isize_or_usize, is_type_diagnostic_item};\n use if_chain::if_chain;\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{\n-    BinOpKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericParamKind, HirId, ImplItem,\n-    ImplItemKind, Item, ItemKind, Local, MatchSource, MutTy, Node, QPath, Stmt, StmtKind, TraitFn, TraitItem,\n-    TraitItemKind, TyKind,\n+    BinOpKind, Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericParamKind, HirId, ImplItem,\n+    ImplItemKind, Item, ItemKind, Local, MutTy, QPath, TraitFn, TraitItem, TraitItemKind, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, IntTy, Ty, TyS, TypeckResults, UintTy};\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n-use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::sym;\n use rustc_target::abi::LayoutOf;\n@@ -39,7 +37,7 @@ use rustc_typeck::hir_ty_to_ty;\n \n use crate::consts::{constant, Constant};\n use crate::utils::paths;\n-use crate::utils::{clip, comparisons, differing_macro_contexts, higher, int_bits, match_path, sext, unsext};\n+use crate::utils::{clip, comparisons, differing_macro_contexts, int_bits, match_path, sext, unsext};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for use of `Box<Vec<_>>` anywhere in the code.\n@@ -389,390 +387,6 @@ impl Types {\n     }\n }\n \n-declare_clippy_lint! {\n-    /// **What it does:** Checks for binding a unit value.\n-    ///\n-    /// **Why is this bad?** A unit value cannot usefully be used anywhere. So\n-    /// binding one is kind of pointless.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// let x = {\n-    ///     1;\n-    /// };\n-    /// ```\n-    pub LET_UNIT_VALUE,\n-    pedantic,\n-    \"creating a `let` binding to a value of unit type, which usually can't be used afterwards\"\n-}\n-\n-declare_lint_pass!(LetUnitValue => [LET_UNIT_VALUE]);\n-\n-impl<'tcx> LateLintPass<'tcx> for LetUnitValue {\n-    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n-        if let StmtKind::Local(ref local) = stmt.kind {\n-            if is_unit(cx.typeck_results().pat_ty(&local.pat)) {\n-                if in_external_macro(cx.sess(), stmt.span) || local.pat.span.from_expansion() {\n-                    return;\n-                }\n-                if higher::is_from_for_desugar(local) {\n-                    return;\n-                }\n-                span_lint_and_then(\n-                    cx,\n-                    LET_UNIT_VALUE,\n-                    stmt.span,\n-                    \"this let-binding has unit value\",\n-                    |diag| {\n-                        if let Some(expr) = &local.init {\n-                            let snip = snippet_with_macro_callsite(cx, expr.span, \"()\");\n-                            diag.span_suggestion(\n-                                stmt.span,\n-                                \"omit the `let` binding\",\n-                                format!(\"{};\", snip),\n-                                Applicability::MachineApplicable, // snippet\n-                            );\n-                        }\n-                    },\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for comparisons to unit. This includes all binary\n-    /// comparisons (like `==` and `<`) and asserts.\n-    ///\n-    /// **Why is this bad?** Unit is always equal to itself, and thus is just a\n-    /// clumsily written constant. Mostly this happens when someone accidentally\n-    /// adds semicolons at the end of the operands.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// # fn foo() {};\n-    /// # fn bar() {};\n-    /// # fn baz() {};\n-    /// if {\n-    ///     foo();\n-    /// } == {\n-    ///     bar();\n-    /// } {\n-    ///     baz();\n-    /// }\n-    /// ```\n-    /// is equal to\n-    /// ```rust\n-    /// # fn foo() {};\n-    /// # fn bar() {};\n-    /// # fn baz() {};\n-    /// {\n-    ///     foo();\n-    ///     bar();\n-    ///     baz();\n-    /// }\n-    /// ```\n-    ///\n-    /// For asserts:\n-    /// ```rust\n-    /// # fn foo() {};\n-    /// # fn bar() {};\n-    /// assert_eq!({ foo(); }, { bar(); });\n-    /// ```\n-    /// will always succeed\n-    pub UNIT_CMP,\n-    correctness,\n-    \"comparing unit values\"\n-}\n-\n-declare_lint_pass!(UnitCmp => [UNIT_CMP]);\n-\n-impl<'tcx> LateLintPass<'tcx> for UnitCmp {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if expr.span.from_expansion() {\n-            if let Some(callee) = expr.span.source_callee() {\n-                if let ExpnKind::Macro(MacroKind::Bang, symbol) = callee.kind {\n-                    if let ExprKind::Binary(ref cmp, ref left, _) = expr.kind {\n-                        let op = cmp.node;\n-                        if op.is_comparison() && is_unit(cx.typeck_results().expr_ty(left)) {\n-                            let result = match &*symbol.as_str() {\n-                                \"assert_eq\" | \"debug_assert_eq\" => \"succeed\",\n-                                \"assert_ne\" | \"debug_assert_ne\" => \"fail\",\n-                                _ => return,\n-                            };\n-                            span_lint(\n-                                cx,\n-                                UNIT_CMP,\n-                                expr.span,\n-                                &format!(\n-                                    \"`{}` of unit values detected. This will always {}\",\n-                                    symbol.as_str(),\n-                                    result\n-                                ),\n-                            );\n-                        }\n-                    }\n-                }\n-            }\n-            return;\n-        }\n-        if let ExprKind::Binary(ref cmp, ref left, _) = expr.kind {\n-            let op = cmp.node;\n-            if op.is_comparison() && is_unit(cx.typeck_results().expr_ty(left)) {\n-                let result = match op {\n-                    BinOpKind::Eq | BinOpKind::Le | BinOpKind::Ge => \"true\",\n-                    _ => \"false\",\n-                };\n-                span_lint(\n-                    cx,\n-                    UNIT_CMP,\n-                    expr.span,\n-                    &format!(\n-                        \"{}-comparison of unit values detected. This will always be {}\",\n-                        op.as_str(),\n-                        result\n-                    ),\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for passing a unit value as an argument to a function without using a\n-    /// unit literal (`()`).\n-    ///\n-    /// **Why is this bad?** This is likely the result of an accidental semicolon.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust,ignore\n-    /// foo({\n-    ///     let a = bar();\n-    ///     baz(a);\n-    /// })\n-    /// ```\n-    pub UNIT_ARG,\n-    complexity,\n-    \"passing unit to a function\"\n-}\n-\n-declare_lint_pass!(UnitArg => [UNIT_ARG]);\n-\n-impl<'tcx> LateLintPass<'tcx> for UnitArg {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if expr.span.from_expansion() {\n-            return;\n-        }\n-\n-        // apparently stuff in the desugaring of `?` can trigger this\n-        // so check for that here\n-        // only the calls to `Try::from_error` is marked as desugared,\n-        // so we need to check both the current Expr and its parent.\n-        if is_questionmark_desugar_marked_call(expr) {\n-            return;\n-        }\n-        if_chain! {\n-            let map = &cx.tcx.hir();\n-            let opt_parent_node = map.find(map.get_parent_node(expr.hir_id));\n-            if let Some(hir::Node::Expr(parent_expr)) = opt_parent_node;\n-            if is_questionmark_desugar_marked_call(parent_expr);\n-            then {\n-                return;\n-            }\n-        }\n-\n-        match expr.kind {\n-            ExprKind::Call(_, args) | ExprKind::MethodCall(_, _, args, _) => {\n-                let args_to_recover = args\n-                    .iter()\n-                    .filter(|arg| {\n-                        if is_unit(cx.typeck_results().expr_ty(arg)) && !is_unit_literal(arg) {\n-                            !matches!(\n-                                &arg.kind,\n-                                ExprKind::Match(.., MatchSource::TryDesugar) | ExprKind::Path(..)\n-                            )\n-                        } else {\n-                            false\n-                        }\n-                    })\n-                    .collect::<Vec<_>>();\n-                if !args_to_recover.is_empty() {\n-                    lint_unit_args(cx, expr, &args_to_recover);\n-                }\n-            },\n-            _ => (),\n-        }\n-    }\n-}\n-\n-fn fmt_stmts_and_call(\n-    cx: &LateContext<'_>,\n-    call_expr: &Expr<'_>,\n-    call_snippet: &str,\n-    args_snippets: &[impl AsRef<str>],\n-    non_empty_block_args_snippets: &[impl AsRef<str>],\n-) -> String {\n-    let call_expr_indent = indent_of(cx, call_expr.span).unwrap_or(0);\n-    let call_snippet_with_replacements = args_snippets\n-        .iter()\n-        .fold(call_snippet.to_owned(), |acc, arg| acc.replacen(arg.as_ref(), \"()\", 1));\n-\n-    let mut stmts_and_call = non_empty_block_args_snippets\n-        .iter()\n-        .map(|it| it.as_ref().to_owned())\n-        .collect::<Vec<_>>();\n-    stmts_and_call.push(call_snippet_with_replacements);\n-    stmts_and_call = stmts_and_call\n-        .into_iter()\n-        .map(|v| reindent_multiline(v.into(), true, Some(call_expr_indent)).into_owned())\n-        .collect();\n-\n-    let mut stmts_and_call_snippet = stmts_and_call.join(&format!(\"{}{}\", \";\\n\", \" \".repeat(call_expr_indent)));\n-    // expr is not in a block statement or result expression position, wrap in a block\n-    let parent_node = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(call_expr.hir_id));\n-    if !matches!(parent_node, Some(Node::Block(_))) && !matches!(parent_node, Some(Node::Stmt(_))) {\n-        let block_indent = call_expr_indent + 4;\n-        stmts_and_call_snippet =\n-            reindent_multiline(stmts_and_call_snippet.into(), true, Some(block_indent)).into_owned();\n-        stmts_and_call_snippet = format!(\n-            \"{{\\n{}{}\\n{}}}\",\n-            \" \".repeat(block_indent),\n-            &stmts_and_call_snippet,\n-            \" \".repeat(call_expr_indent)\n-        );\n-    }\n-    stmts_and_call_snippet\n-}\n-\n-fn lint_unit_args(cx: &LateContext<'_>, expr: &Expr<'_>, args_to_recover: &[&Expr<'_>]) {\n-    let mut applicability = Applicability::MachineApplicable;\n-    let (singular, plural) = if args_to_recover.len() > 1 {\n-        (\"\", \"s\")\n-    } else {\n-        (\"a \", \"\")\n-    };\n-    span_lint_and_then(\n-        cx,\n-        UNIT_ARG,\n-        expr.span,\n-        &format!(\"passing {}unit value{} to a function\", singular, plural),\n-        |db| {\n-            let mut or = \"\";\n-            args_to_recover\n-                .iter()\n-                .filter_map(|arg| {\n-                    if_chain! {\n-                        if let ExprKind::Block(block, _) = arg.kind;\n-                        if block.expr.is_none();\n-                        if let Some(last_stmt) = block.stmts.iter().last();\n-                        if let StmtKind::Semi(last_expr) = last_stmt.kind;\n-                        if let Some(snip) = snippet_opt(cx, last_expr.span);\n-                        then {\n-                            Some((\n-                                last_stmt.span,\n-                                snip,\n-                            ))\n-                        }\n-                        else {\n-                            None\n-                        }\n-                    }\n-                })\n-                .for_each(|(span, sugg)| {\n-                    db.span_suggestion(\n-                        span,\n-                        \"remove the semicolon from the last statement in the block\",\n-                        sugg,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                    or = \"or \";\n-                    applicability = Applicability::MaybeIncorrect;\n-                });\n-\n-            let arg_snippets: Vec<String> = args_to_recover\n-                .iter()\n-                .filter_map(|arg| snippet_opt(cx, arg.span))\n-                .collect();\n-            let arg_snippets_without_empty_blocks: Vec<String> = args_to_recover\n-                .iter()\n-                .filter(|arg| !is_empty_block(arg))\n-                .filter_map(|arg| snippet_opt(cx, arg.span))\n-                .collect();\n-\n-            if let Some(call_snippet) = snippet_opt(cx, expr.span) {\n-                let sugg = fmt_stmts_and_call(\n-                    cx,\n-                    expr,\n-                    &call_snippet,\n-                    &arg_snippets,\n-                    &arg_snippets_without_empty_blocks,\n-                );\n-\n-                if arg_snippets_without_empty_blocks.is_empty() {\n-                    db.multipart_suggestion(\n-                        &format!(\"use {}unit literal{} instead\", singular, plural),\n-                        args_to_recover\n-                            .iter()\n-                            .map(|arg| (arg.span, \"()\".to_string()))\n-                            .collect::<Vec<_>>(),\n-                        applicability,\n-                    );\n-                } else {\n-                    let plural = arg_snippets_without_empty_blocks.len() > 1;\n-                    let empty_or_s = if plural { \"s\" } else { \"\" };\n-                    let it_or_them = if plural { \"them\" } else { \"it\" };\n-                    db.span_suggestion(\n-                        expr.span,\n-                        &format!(\n-                            \"{}move the expression{} in front of the call and replace {} with the unit literal `()`\",\n-                            or, empty_or_s, it_or_them\n-                        ),\n-                        sugg,\n-                        applicability,\n-                    );\n-                }\n-            }\n-        },\n-    );\n-}\n-\n-fn is_empty_block(expr: &Expr<'_>) -> bool {\n-    matches!(\n-        expr.kind,\n-        ExprKind::Block(\n-            Block {\n-                stmts: &[],\n-                expr: None,\n-                ..\n-            },\n-            _,\n-        )\n-    )\n-}\n-\n-fn is_questionmark_desugar_marked_call(expr: &Expr<'_>) -> bool {\n-    use rustc_span::hygiene::DesugaringKind;\n-    if let ExprKind::Call(ref callee, _) = expr.kind {\n-        callee.span.is_desugaring(DesugaringKind::QuestionMark)\n-    } else {\n-        false\n-    }\n-}\n-\n-fn is_unit(ty: Ty<'_>) -> bool {\n-    matches!(ty.kind(), ty::Tuple(slice) if slice.is_empty())\n-}\n-\n-fn is_unit_literal(expr: &Expr<'_>) -> bool {\n-    matches!(expr.kind, ExprKind::Tup(ref slice) if slice.is_empty())\n-}\n-\n declare_clippy_lint! {\n     /// **What it does:** Checks for types used in structs, parameters and `let`\n     /// declarations above a certain complexity threshold."}, {"sha": "6450ef600ca2ba29f0af385959a7317b6f954081", "filename": "clippy_lints/src/unit_types/mod.rs", "status": "added", "additions": 398, "deletions": 0, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/ecbef77bd71c2a4b4ad8dbb0b0ffa67affe29cc3/clippy_lints%2Fsrc%2Funit_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecbef77bd71c2a4b4ad8dbb0b0ffa67affe29cc3/clippy_lints%2Fsrc%2Funit_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Fmod.rs?ref=ecbef77bd71c2a4b4ad8dbb0b0ffa67affe29cc3", "patch": "@@ -0,0 +1,398 @@\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::{BinOpKind, Block, Expr, ExprKind, MatchSource, Node, Stmt, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::hygiene::{ExpnKind, MacroKind};\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::diagnostics::{span_lint, span_lint_and_then};\n+use crate::utils::higher;\n+use crate::utils::source::{indent_of, reindent_multiline, snippet_opt, snippet_with_macro_callsite};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for binding a unit value.\n+    ///\n+    /// **Why is this bad?** A unit value cannot usefully be used anywhere. So\n+    /// binding one is kind of pointless.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = {\n+    ///     1;\n+    /// };\n+    /// ```\n+    pub LET_UNIT_VALUE,\n+    pedantic,\n+    \"creating a `let` binding to a value of unit type, which usually can't be used afterwards\"\n+}\n+\n+declare_lint_pass!(LetUnitValue => [LET_UNIT_VALUE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for LetUnitValue {\n+    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n+        if let StmtKind::Local(ref local) = stmt.kind {\n+            if is_unit(cx.typeck_results().pat_ty(&local.pat)) {\n+                if in_external_macro(cx.sess(), stmt.span) || local.pat.span.from_expansion() {\n+                    return;\n+                }\n+                if higher::is_from_for_desugar(local) {\n+                    return;\n+                }\n+                span_lint_and_then(\n+                    cx,\n+                    LET_UNIT_VALUE,\n+                    stmt.span,\n+                    \"this let-binding has unit value\",\n+                    |diag| {\n+                        if let Some(expr) = &local.init {\n+                            let snip = snippet_with_macro_callsite(cx, expr.span, \"()\");\n+                            diag.span_suggestion(\n+                                stmt.span,\n+                                \"omit the `let` binding\",\n+                                format!(\"{};\", snip),\n+                                Applicability::MachineApplicable, // snippet\n+                            );\n+                        }\n+                    },\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for comparisons to unit. This includes all binary\n+    /// comparisons (like `==` and `<`) and asserts.\n+    ///\n+    /// **Why is this bad?** Unit is always equal to itself, and thus is just a\n+    /// clumsily written constant. Mostly this happens when someone accidentally\n+    /// adds semicolons at the end of the operands.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # fn foo() {};\n+    /// # fn bar() {};\n+    /// # fn baz() {};\n+    /// if {\n+    ///     foo();\n+    /// } == {\n+    ///     bar();\n+    /// } {\n+    ///     baz();\n+    /// }\n+    /// ```\n+    /// is equal to\n+    /// ```rust\n+    /// # fn foo() {};\n+    /// # fn bar() {};\n+    /// # fn baz() {};\n+    /// {\n+    ///     foo();\n+    ///     bar();\n+    ///     baz();\n+    /// }\n+    /// ```\n+    ///\n+    /// For asserts:\n+    /// ```rust\n+    /// # fn foo() {};\n+    /// # fn bar() {};\n+    /// assert_eq!({ foo(); }, { bar(); });\n+    /// ```\n+    /// will always succeed\n+    pub UNIT_CMP,\n+    correctness,\n+    \"comparing unit values\"\n+}\n+\n+declare_lint_pass!(UnitCmp => [UNIT_CMP]);\n+\n+impl<'tcx> LateLintPass<'tcx> for UnitCmp {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n+        if expr.span.from_expansion() {\n+            if let Some(callee) = expr.span.source_callee() {\n+                if let ExpnKind::Macro(MacroKind::Bang, symbol) = callee.kind {\n+                    if let ExprKind::Binary(ref cmp, ref left, _) = expr.kind {\n+                        let op = cmp.node;\n+                        if op.is_comparison() && is_unit(cx.typeck_results().expr_ty(left)) {\n+                            let result = match &*symbol.as_str() {\n+                                \"assert_eq\" | \"debug_assert_eq\" => \"succeed\",\n+                                \"assert_ne\" | \"debug_assert_ne\" => \"fail\",\n+                                _ => return,\n+                            };\n+                            span_lint(\n+                                cx,\n+                                UNIT_CMP,\n+                                expr.span,\n+                                &format!(\n+                                    \"`{}` of unit values detected. This will always {}\",\n+                                    symbol.as_str(),\n+                                    result\n+                                ),\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+            return;\n+        }\n+        if let ExprKind::Binary(ref cmp, ref left, _) = expr.kind {\n+            let op = cmp.node;\n+            if op.is_comparison() && is_unit(cx.typeck_results().expr_ty(left)) {\n+                let result = match op {\n+                    BinOpKind::Eq | BinOpKind::Le | BinOpKind::Ge => \"true\",\n+                    _ => \"false\",\n+                };\n+                span_lint(\n+                    cx,\n+                    UNIT_CMP,\n+                    expr.span,\n+                    &format!(\n+                        \"{}-comparison of unit values detected. This will always be {}\",\n+                        op.as_str(),\n+                        result\n+                    ),\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for passing a unit value as an argument to a function without using a\n+    /// unit literal (`()`).\n+    ///\n+    /// **Why is this bad?** This is likely the result of an accidental semicolon.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// foo({\n+    ///     let a = bar();\n+    ///     baz(a);\n+    /// })\n+    /// ```\n+    pub UNIT_ARG,\n+    complexity,\n+    \"passing unit to a function\"\n+}\n+\n+declare_lint_pass!(UnitArg => [UNIT_ARG]);\n+\n+impl<'tcx> LateLintPass<'tcx> for UnitArg {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if expr.span.from_expansion() {\n+            return;\n+        }\n+\n+        // apparently stuff in the desugaring of `?` can trigger this\n+        // so check for that here\n+        // only the calls to `Try::from_error` is marked as desugared,\n+        // so we need to check both the current Expr and its parent.\n+        if is_questionmark_desugar_marked_call(expr) {\n+            return;\n+        }\n+        if_chain! {\n+            let map = &cx.tcx.hir();\n+            let opt_parent_node = map.find(map.get_parent_node(expr.hir_id));\n+            if let Some(hir::Node::Expr(parent_expr)) = opt_parent_node;\n+            if is_questionmark_desugar_marked_call(parent_expr);\n+            then {\n+                return;\n+            }\n+        }\n+\n+        match expr.kind {\n+            ExprKind::Call(_, args) | ExprKind::MethodCall(_, _, args, _) => {\n+                let args_to_recover = args\n+                    .iter()\n+                    .filter(|arg| {\n+                        if is_unit(cx.typeck_results().expr_ty(arg)) && !is_unit_literal(arg) {\n+                            !matches!(\n+                                &arg.kind,\n+                                ExprKind::Match(.., MatchSource::TryDesugar) | ExprKind::Path(..)\n+                            )\n+                        } else {\n+                            false\n+                        }\n+                    })\n+                    .collect::<Vec<_>>();\n+                if !args_to_recover.is_empty() {\n+                    lint_unit_args(cx, expr, &args_to_recover);\n+                }\n+            },\n+            _ => (),\n+        }\n+    }\n+}\n+\n+fn is_questionmark_desugar_marked_call(expr: &Expr<'_>) -> bool {\n+    use rustc_span::hygiene::DesugaringKind;\n+    if let ExprKind::Call(ref callee, _) = expr.kind {\n+        callee.span.is_desugaring(DesugaringKind::QuestionMark)\n+    } else {\n+        false\n+    }\n+}\n+\n+fn is_unit(ty: Ty<'_>) -> bool {\n+    matches!(ty.kind(), ty::Tuple(slice) if slice.is_empty())\n+}\n+\n+fn is_unit_literal(expr: &Expr<'_>) -> bool {\n+    matches!(expr.kind, ExprKind::Tup(ref slice) if slice.is_empty())\n+}\n+\n+fn lint_unit_args(cx: &LateContext<'_>, expr: &Expr<'_>, args_to_recover: &[&Expr<'_>]) {\n+    let mut applicability = Applicability::MachineApplicable;\n+    let (singular, plural) = if args_to_recover.len() > 1 {\n+        (\"\", \"s\")\n+    } else {\n+        (\"a \", \"\")\n+    };\n+    span_lint_and_then(\n+        cx,\n+        UNIT_ARG,\n+        expr.span,\n+        &format!(\"passing {}unit value{} to a function\", singular, plural),\n+        |db| {\n+            let mut or = \"\";\n+            args_to_recover\n+                .iter()\n+                .filter_map(|arg| {\n+                    if_chain! {\n+                        if let ExprKind::Block(block, _) = arg.kind;\n+                        if block.expr.is_none();\n+                        if let Some(last_stmt) = block.stmts.iter().last();\n+                        if let StmtKind::Semi(last_expr) = last_stmt.kind;\n+                        if let Some(snip) = snippet_opt(cx, last_expr.span);\n+                        then {\n+                            Some((\n+                                last_stmt.span,\n+                                snip,\n+                            ))\n+                        }\n+                        else {\n+                            None\n+                        }\n+                    }\n+                })\n+                .for_each(|(span, sugg)| {\n+                    db.span_suggestion(\n+                        span,\n+                        \"remove the semicolon from the last statement in the block\",\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    or = \"or \";\n+                    applicability = Applicability::MaybeIncorrect;\n+                });\n+\n+            let arg_snippets: Vec<String> = args_to_recover\n+                .iter()\n+                .filter_map(|arg| snippet_opt(cx, arg.span))\n+                .collect();\n+            let arg_snippets_without_empty_blocks: Vec<String> = args_to_recover\n+                .iter()\n+                .filter(|arg| !is_empty_block(arg))\n+                .filter_map(|arg| snippet_opt(cx, arg.span))\n+                .collect();\n+\n+            if let Some(call_snippet) = snippet_opt(cx, expr.span) {\n+                let sugg = fmt_stmts_and_call(\n+                    cx,\n+                    expr,\n+                    &call_snippet,\n+                    &arg_snippets,\n+                    &arg_snippets_without_empty_blocks,\n+                );\n+\n+                if arg_snippets_without_empty_blocks.is_empty() {\n+                    db.multipart_suggestion(\n+                        &format!(\"use {}unit literal{} instead\", singular, plural),\n+                        args_to_recover\n+                            .iter()\n+                            .map(|arg| (arg.span, \"()\".to_string()))\n+                            .collect::<Vec<_>>(),\n+                        applicability,\n+                    );\n+                } else {\n+                    let plural = arg_snippets_without_empty_blocks.len() > 1;\n+                    let empty_or_s = if plural { \"s\" } else { \"\" };\n+                    let it_or_them = if plural { \"them\" } else { \"it\" };\n+                    db.span_suggestion(\n+                        expr.span,\n+                        &format!(\n+                            \"{}move the expression{} in front of the call and replace {} with the unit literal `()`\",\n+                            or, empty_or_s, it_or_them\n+                        ),\n+                        sugg,\n+                        applicability,\n+                    );\n+                }\n+            }\n+        },\n+    );\n+}\n+\n+fn is_empty_block(expr: &Expr<'_>) -> bool {\n+    matches!(\n+        expr.kind,\n+        ExprKind::Block(\n+            Block {\n+                stmts: &[],\n+                expr: None,\n+                ..\n+            },\n+            _,\n+        )\n+    )\n+}\n+\n+fn fmt_stmts_and_call(\n+    cx: &LateContext<'_>,\n+    call_expr: &Expr<'_>,\n+    call_snippet: &str,\n+    args_snippets: &[impl AsRef<str>],\n+    non_empty_block_args_snippets: &[impl AsRef<str>],\n+) -> String {\n+    let call_expr_indent = indent_of(cx, call_expr.span).unwrap_or(0);\n+    let call_snippet_with_replacements = args_snippets\n+        .iter()\n+        .fold(call_snippet.to_owned(), |acc, arg| acc.replacen(arg.as_ref(), \"()\", 1));\n+\n+    let mut stmts_and_call = non_empty_block_args_snippets\n+        .iter()\n+        .map(|it| it.as_ref().to_owned())\n+        .collect::<Vec<_>>();\n+    stmts_and_call.push(call_snippet_with_replacements);\n+    stmts_and_call = stmts_and_call\n+        .into_iter()\n+        .map(|v| reindent_multiline(v.into(), true, Some(call_expr_indent)).into_owned())\n+        .collect();\n+\n+    let mut stmts_and_call_snippet = stmts_and_call.join(&format!(\"{}{}\", \";\\n\", \" \".repeat(call_expr_indent)));\n+    // expr is not in a block statement or result expression position, wrap in a block\n+    let parent_node = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(call_expr.hir_id));\n+    if !matches!(parent_node, Some(Node::Block(_))) && !matches!(parent_node, Some(Node::Stmt(_))) {\n+        let block_indent = call_expr_indent + 4;\n+        stmts_and_call_snippet =\n+            reindent_multiline(stmts_and_call_snippet.into(), true, Some(block_indent)).into_owned();\n+        stmts_and_call_snippet = format!(\n+            \"{{\\n{}{}\\n{}}}\",\n+            \" \".repeat(block_indent),\n+            &stmts_and_call_snippet,\n+            \" \".repeat(call_expr_indent)\n+        );\n+    }\n+    stmts_and_call_snippet\n+}"}]}