{"sha": "e549b80e3c214f93fc6ab9d7ead3f49b585faa23", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1NDliODBlM2MyMTRmOTNmYzZhYjlkN2VhZDNmNDliNTg1ZmFhMjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-28T09:36:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-28T09:36:49Z"}, "message": "auto merge of #5587 : thestinger/rust/total, r=pcwalton\n\nThis is needed so that hash tables can require strict equality but not require types to be ordered. It's a subset of the functionality of `TotalOrd` so I made that inherit from `TotalEq`.", "tree": {"sha": "2510c02dfa74370f1f5cc12b7f0592ba6fb689b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2510c02dfa74370f1f5cc12b7f0592ba6fb689b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e549b80e3c214f93fc6ab9d7ead3f49b585faa23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e549b80e3c214f93fc6ab9d7ead3f49b585faa23", "html_url": "https://github.com/rust-lang/rust/commit/e549b80e3c214f93fc6ab9d7ead3f49b585faa23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e549b80e3c214f93fc6ab9d7ead3f49b585faa23/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d31053277aa8ced6778334d49de150b1393073eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/d31053277aa8ced6778334d49de150b1393073eb", "html_url": "https://github.com/rust-lang/rust/commit/d31053277aa8ced6778334d49de150b1393073eb"}, {"sha": "d2b267bcb5ac1adbc20bca0c170106ae3b3538ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2b267bcb5ac1adbc20bca0c170106ae3b3538ab", "html_url": "https://github.com/rust-lang/rust/commit/d2b267bcb5ac1adbc20bca0c170106ae3b3538ab"}], "stats": {"total": 208, "additions": 134, "deletions": 74}, "files": [{"sha": "95f6f9bc1b51091868aece549776938c18fcb604", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 63, "deletions": 61, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/e549b80e3c214f93fc6ab9d7ead3f49b585faa23/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e549b80e3c214f93fc6ab9d7ead3f49b585faa23/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=e549b80e3c214f93fc6ab9d7ead3f49b585faa23", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -21,86 +21,82 @@ and `Eq` to overload the `==` and `!=` operators.\n */\n \n /**\n-* Trait for values that can be compared for equality\n-* and inequality.\n+* Trait for values that can be compared for equality and inequality.\n *\n-* Eventually this may be simplified to only require\n-* an `eq` method, with the other generated from\n-* a default implementation. However it should\n-* remain possible to implement `ne` separately, for\n-* compatibility with floating-point NaN semantics\n-* (cf. IEEE 754-2008 section 5.11).\n+* This trait allows partial equality, where types can be unordered instead of strictly equal or\n+* unequal. For example, with the built-in floating-point types `a == b` and `a != b` will both\n+* evaluate to false if either `a` or `b` is NaN (cf. IEEE 754-2008 section 5.11).\n+*\n+* Eventually, this will be implemented by default for types that implement `TotalEq`.\n */\n #[lang=\"eq\"]\n pub trait Eq {\n     fn eq(&self, other: &Self) -> bool;\n     fn ne(&self, other: &Self) -> bool;\n }\n \n-#[deriving(Eq)]\n-pub enum Ordering { Less, Equal, Greater }\n-\n-/// Trait for types that form a total order\n-pub trait TotalOrd {\n-    fn cmp(&self, other: &Self) -> Ordering;\n+/// Trait for equality comparisons where `a == b` and `a != b` are strict inverses.\n+pub trait TotalEq {\n+    fn equals(&self, other: &Self) -> bool;\n }\n \n-#[inline(always)]\n-fn icmp<T: Ord>(a: &T, b: &T) -> Ordering {\n-    if *a < *b { Less }\n-    else if *a > *b { Greater }\n-    else { Equal }\n-}\n+macro_rules! totaleq_impl(\n+    ($t:ty) => {\n+        impl TotalEq for $t {\n+            #[inline(always)]\n+            fn equals(&self, other: &$t) -> bool { *self == *other }\n+        }\n+    }\n+)\n \n-impl TotalOrd for u8 {\n-    #[inline(always)]\n-    fn cmp(&self, other: &u8) -> Ordering { icmp(self, other) }\n-}\n+totaleq_impl!(bool)\n \n-impl TotalOrd for u16 {\n-    #[inline(always)]\n-    fn cmp(&self, other: &u16) -> Ordering { icmp(self, other) }\n-}\n+totaleq_impl!(u8)\n+totaleq_impl!(u16)\n+totaleq_impl!(u32)\n+totaleq_impl!(u64)\n \n-impl TotalOrd for u32 {\n-    #[inline(always)]\n-    fn cmp(&self, other: &u32) -> Ordering { icmp(self, other) }\n-}\n+totaleq_impl!(i8)\n+totaleq_impl!(i16)\n+totaleq_impl!(i32)\n+totaleq_impl!(i64)\n \n-impl TotalOrd for u64 {\n-    #[inline(always)]\n-    fn cmp(&self, other: &u64) -> Ordering { icmp(self, other) }\n-}\n+totaleq_impl!(int)\n+totaleq_impl!(uint)\n \n-impl TotalOrd for i8 {\n-    #[inline(always)]\n-    fn cmp(&self, other: &i8) -> Ordering { icmp(self, other) }\n-}\n+#[deriving(Eq)]\n+pub enum Ordering { Less, Equal, Greater }\n \n-impl TotalOrd for i16 {\n-    #[inline(always)]\n-    fn cmp(&self, other: &i16) -> Ordering { icmp(self, other) }\n+/// Trait for types that form a total order\n+pub trait TotalOrd: TotalEq {\n+    fn cmp(&self, other: &Self) -> Ordering;\n }\n \n-impl TotalOrd for i32 {\n-    #[inline(always)]\n-    fn cmp(&self, other: &i32) -> Ordering { icmp(self, other) }\n-}\n+macro_rules! totalord_impl(\n+    ($t:ty) => {\n+        impl TotalOrd for $t {\n+            #[inline(always)]\n+            fn cmp(&self, other: &$t) -> Ordering {\n+                if *self < *other { Less }\n+                else if *self > *other { Greater }\n+                else { Equal }\n+            }\n+        }\n+    }\n+)\n \n-impl TotalOrd for i64 {\n-    #[inline(always)]\n-    fn cmp(&self, other: &i64) -> Ordering { icmp(self, other) }\n-}\n+totalord_impl!(u8)\n+totalord_impl!(u16)\n+totalord_impl!(u32)\n+totalord_impl!(u64)\n \n-impl TotalOrd for int {\n-    #[inline(always)]\n-    fn cmp(&self, other: &int) -> Ordering { icmp(self, other) }\n-}\n+totalord_impl!(i8)\n+totalord_impl!(i16)\n+totalord_impl!(i32)\n+totalord_impl!(i64)\n \n-impl TotalOrd for uint {\n-    #[inline(always)]\n-    fn cmp(&self, other: &uint) -> Ordering { icmp(self, other) }\n-}\n+totalord_impl!(int)\n+totalord_impl!(uint)\n \n /**\n * Trait for values that can be compared for a sort-order.\n@@ -171,11 +167,17 @@ pub fn max<T:Ord>(v1: T, v2: T) -> T {\n #[cfg(test)]\n mod test {\n     #[test]\n-    fn test_int() {\n+    fn test_int_totalord() {\n         assert_eq!(5.cmp(&10), Less);\n         assert_eq!(10.cmp(&5), Greater);\n         assert_eq!(5.cmp(&5), Equal);\n         assert_eq!((-5).cmp(&12), Less);\n         assert_eq!(12.cmp(-5), Greater);\n     }\n+\n+    #[test]\n+    fn test_int_totaleq() {\n+        fail_unless!(5.equals(&5));\n+        fail_unless!(!2.equals(&17));\n+    }\n }"}, {"sha": "6b8c390fc25752506cc319f3d43cb1cb56184796", "filename": "src/libcore/nil.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e549b80e3c214f93fc6ab9d7ead3f49b585faa23/src%2Flibcore%2Fnil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e549b80e3c214f93fc6ab9d7ead3f49b585faa23/src%2Flibcore%2Fnil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnil.rs?ref=e549b80e3c214f93fc6ab9d7ead3f49b585faa23", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -15,7 +15,7 @@ Functions for the unit type.\n */\n \n #[cfg(notest)]\n-use cmp::{Eq, Ord, TotalOrd, Ordering, Equal};\n+use prelude::*;\n \n #[cfg(notest)]\n impl Eq for () {\n@@ -42,3 +42,9 @@ impl TotalOrd for () {\n     #[inline(always)]\n     fn cmp(&self, _other: &()) -> Ordering { Equal }\n }\n+\n+#[cfg(notest)]\n+impl TotalEq for () {\n+    #[inline(always)]\n+    fn equals(&self, _other: &()) -> bool { true }\n+}"}, {"sha": "0194e8f009c6a5222d3068240480a5294d54ba2a", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e549b80e3c214f93fc6ab9d7ead3f49b585faa23/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e549b80e3c214f93fc6ab9d7ead3f49b585faa23/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=e549b80e3c214f93fc6ab9d7ead3f49b585faa23", "patch": "@@ -24,7 +24,7 @@ pub use result::{Result, Ok, Err};\n /* Reexported types and traits */\n \n pub use clone::Clone;\n-pub use cmp::{Eq, Ord, TotalOrd, Ordering, Less, Equal, Greater};\n+pub use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n pub use container::{Container, Mutable, Map, Set};\n pub use hash::Hash;\n pub use iter::{BaseIter, ReverseIter, MutableIter, ExtendedIter, EqIter};"}, {"sha": "a6f9ae84f44299fa7e139d6344e2673f2a86a8cb", "filename": "src/libcore/str.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e549b80e3c214f93fc6ab9d7ead3f49b585faa23/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e549b80e3c214f93fc6ab9d7ead3f49b585faa23/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=e549b80e3c214f93fc6ab9d7ead3f49b585faa23", "patch": "@@ -21,7 +21,7 @@ use at_vec;\n use cast;\n use char;\n use clone::Clone;\n-use cmp::{Equiv, TotalOrd, Ordering, Less, Equal, Greater};\n+use cmp::{Equiv, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use libc;\n use option::{None, Option, Some};\n use ptr;\n@@ -930,6 +930,30 @@ impl Eq for @str {\n     fn ne(&self, other: &@str) -> bool { !(*self).eq(other) }\n }\n \n+#[cfg(notest)]\n+impl<'self> TotalEq for &'self str {\n+    #[inline(always)]\n+    fn equals(&self, other: & &'self str) -> bool {\n+        eq_slice((*self), (*other))\n+    }\n+}\n+\n+#[cfg(notest)]\n+impl TotalEq for ~str {\n+    #[inline(always)]\n+    fn equals(&self, other: &~str) -> bool {\n+        eq_slice((*self), (*other))\n+    }\n+}\n+\n+#[cfg(notest)]\n+impl TotalEq for @str {\n+    #[inline(always)]\n+    fn equals(&self, other: &@str) -> bool {\n+        eq_slice((*self), (*other))\n+    }\n+}\n+\n #[cfg(notest)]\n impl Ord for ~str {\n     #[inline(always)]"}, {"sha": "174960560dfd6baad347b829e882ea8128f5cc96", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 37, "deletions": 9, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e549b80e3c214f93fc6ab9d7ead3f49b585faa23/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e549b80e3c214f93fc6ab9d7ead3f49b585faa23/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=e549b80e3c214f93fc6ab9d7ead3f49b585faa23", "patch": "@@ -14,7 +14,7 @@\n \n use container::{Container, Mutable};\n use cast;\n-use cmp::{Eq, Equiv, Ord, TotalOrd, Ordering, Less, Equal, Greater};\n+use cmp::{Eq, Equiv, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use clone::Clone;\n use iter::BaseIter;\n use iter;\n@@ -1547,7 +1547,7 @@ pub fn as_mut_buf<T,U>(s: &mut [T], f: &fn(*mut T, uint) -> U) -> U {\n \n // Equality\n \n-fn eq<T:Eq>(a: &[T], b: &[T]) -> bool {\n+fn eq<T: Eq>(a: &[T], b: &[T]) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n     if a_len != b_len { return false; }\n \n@@ -1556,33 +1556,61 @@ fn eq<T:Eq>(a: &[T], b: &[T]) -> bool {\n         if a[i] != b[i] { return false; }\n         i += 1;\n     }\n+    true\n+}\n+\n+fn equals<T: TotalEq>(a: &[T], b: &[T]) -> bool {\n+    let (a_len, b_len) = (a.len(), b.len());\n+    if a_len != b_len { return false; }\n \n+    let mut i = 0;\n+    while i < a_len {\n+        if !a[i].equals(&b[i]) { return false; }\n+        i += 1;\n+    }\n     true\n }\n \n #[cfg(notest)]\n impl<'self,T:Eq> Eq for &'self [T] {\n     #[inline(always)]\n-    fn eq(&self, other: & &'self [T]) -> bool { eq((*self), (*other)) }\n+    fn eq(&self, other: & &'self [T]) -> bool { eq(*self, *other) }\n     #[inline(always)]\n-    fn ne(&self, other: & &'self [T]) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: & &'self [T]) -> bool { !self.eq(other) }\n }\n \n-\n #[cfg(notest)]\n impl<T:Eq> Eq for ~[T] {\n     #[inline(always)]\n-    fn eq(&self, other: &~[T]) -> bool { eq((*self), (*other)) }\n+    fn eq(&self, other: &~[T]) -> bool { eq(*self, *other) }\n     #[inline(always)]\n-    fn ne(&self, other: &~[T]) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &~[T]) -> bool { !self.eq(other) }\n }\n \n #[cfg(notest)]\n impl<T:Eq> Eq for @[T] {\n     #[inline(always)]\n-    fn eq(&self, other: &@[T]) -> bool { eq((*self), (*other)) }\n+    fn eq(&self, other: &@[T]) -> bool { eq(*self, *other) }\n+    #[inline(always)]\n+    fn ne(&self, other: &@[T]) -> bool { !self.eq(other) }\n+}\n+\n+#[cfg(notest)]\n+impl<'self,T:TotalEq> TotalEq for &'self [T] {\n+    #[inline(always)]\n+    fn equals(&self, other: & &'self [T]) -> bool { equals(*self, *other) }\n+}\n+\n+#[cfg(notest)]\n+impl<T:TotalEq> TotalEq for ~[T] {\n+    #[inline(always)]\n+    fn equals(&self, other: &~[T]) -> bool { equals(*self, *other) }\n+}\n+\n+#[cfg(notest)]\n+impl<T:TotalEq> TotalEq for @[T] {\n     #[inline(always)]\n-    fn ne(&self, other: &@[T]) -> bool { !(*self).eq(other) }\n+    fn equals(&self, other: &@[T]) -> bool { equals(*self, *other) }\n }\n \n #[cfg(notest)]"}]}