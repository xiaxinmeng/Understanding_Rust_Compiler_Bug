{"sha": "20831d394ac5488ba28cd0370d7ec03cd908fcae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwODMxZDM5NGFjNTQ4OGJhMjhjZDAzNzBkN2VjMDNjZDkwOGZjYWU=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-19T00:56:37Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-19T01:57:56Z"}, "message": "Linked failure: unidirectional failure with parented() (soon to be renamed)", "tree": {"sha": "2600a7ebf34b9f37598d2f1a5062a42f779e6681", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2600a7ebf34b9f37598d2f1a5062a42f779e6681"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20831d394ac5488ba28cd0370d7ec03cd908fcae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20831d394ac5488ba28cd0370d7ec03cd908fcae", "html_url": "https://github.com/rust-lang/rust/commit/20831d394ac5488ba28cd0370d7ec03cd908fcae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20831d394ac5488ba28cd0370d7ec03cd908fcae/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35bd579f6686d6ba7c8c01206e14870ed2b45584", "url": "https://api.github.com/repos/rust-lang/rust/commits/35bd579f6686d6ba7c8c01206e14870ed2b45584", "html_url": "https://github.com/rust-lang/rust/commit/35bd579f6686d6ba7c8c01206e14870ed2b45584"}], "stats": {"total": 126, "additions": 95, "deletions": 31}, "files": [{"sha": "3f7f855ee94525eff35e46315b4a8444546fd3ea", "filename": "src/libcore/task.rs", "status": "modified", "additions": 95, "deletions": 31, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/20831d394ac5488ba28cd0370d7ec03cd908fcae/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20831d394ac5488ba28cd0370d7ec03cd908fcae/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=20831d394ac5488ba28cd0370d7ec03cd908fcae", "patch": "@@ -46,6 +46,7 @@ export run;\n export future_result;\n export future_task;\n export unsupervise;\n+export parent;\n export run_listener;\n export run_with;\n \n@@ -169,6 +170,7 @@ type sched_opts = {\n  */\n type task_opts = {\n     supervise: bool,\n+    parented: bool,\n     notify_chan: option<comm::chan<notification>>,\n     sched: option<sched_opts>,\n };\n@@ -206,6 +208,7 @@ fn default_task_opts() -> task_opts {\n \n     {\n         supervise: true,\n+        parented: false,\n         notify_chan: none,\n         sched: none\n     }\n@@ -362,6 +365,11 @@ fn unsupervise(builder: builder) {\n     });\n }\n \n+fn parent(builder: builder) {\n+    //! Configures the new task to be killed if the parent group is killed.\n+    set_opts(builder, { parented: true with get_opts(builder) });\n+}\n+\n fn run_with<A:send>(-builder: builder,\n                     +arg: A,\n                     +f: fn~(+A)) {\n@@ -591,15 +599,19 @@ class taskgroup {\n     // FIXME (#2816): Change dvec to an O(1) data structure (and change 'me'\n     // to a node-handle or somesuch when so done (or remove the field entirely\n     // if keyed by *rust_task)).\n-    let tasks:      taskgroup_arc; // 'none' means the group already failed.\n     let me:         *rust_task;\n-    let my_pos:     uint;\n-    // let parent_group: taskgroup_arc; // FIXME (#1868) (bblum)\n+    // List of tasks with whose fates this one's is intertwined.\n+    let tasks:      taskgroup_arc; // 'none' means the group already failed.\n+    let my_pos:     uint;          // Index into above for this task's slot.\n+    // Lists of tasks who will kill us if they fail, but whom we won't kill.\n+    let parents:    option<(taskgroup_arc,uint)>;\n     let is_main:    bool;\n-    new(-tasks: taskgroup_arc, me: *rust_task, my_pos: uint, is_main: bool) {\n-        self.tasks   = tasks;\n+    new(me: *rust_task, -tasks: taskgroup_arc, my_pos: uint,\n+        -parents: option<(taskgroup_arc,uint)>, is_main: bool) {\n         self.me      = me;\n+        self.tasks   = tasks;\n         self.my_pos  = my_pos;\n+        self.parents = parents;\n         self.is_main = is_main;\n     }\n     // Runs on task exit.\n@@ -609,9 +621,17 @@ class taskgroup {\n             // Take everybody down with us.\n             kill_taskgroup(self.tasks, self.me, self.my_pos, self.is_main);\n         } else {\n-            // Remove ourselves from the group.\n+            // Remove ourselves from the group(s).\n             leave_taskgroup(self.tasks, self.me, self.my_pos);\n         }\n+        // It doesn't matter whether this happens before or after dealing with\n+        // our own taskgroup, so long as both happen before we die.\n+        alt self.parents {\n+            some((parent_group,pos_in_group)) {\n+                leave_taskgroup(parent_group, self.me, pos_in_group);\n+            }\n+            none { }\n+        }\n     }\n }\n \n@@ -714,7 +734,8 @@ fn share_parent_taskgroup() -> (taskgroup_arc, bool) {\n             // Main task, doing first spawn ever.\n             let tasks = arc::exclusive(some((dvec::from_elem(some(me)),\n                                              dvec::dvec())));\n-            let group = @taskgroup(tasks.clone(), me, 0, true);\n+            // Main group has no parent group.\n+            let group = @taskgroup(me, tasks.clone(), 0, none, true);\n             unsafe { local_set(me, taskgroup_key(), group); }\n             // Tell child task it's also in the main group.\n             (tasks, true)\n@@ -724,21 +745,29 @@ fn share_parent_taskgroup() -> (taskgroup_arc, bool) {\n \n fn spawn_raw(opts: task_opts, +f: fn~()) {\n     // Decide whether the child needs to be in a new linked failure group.\n-    let (child_tg, is_main) = if opts.supervise {\n-        share_parent_taskgroup()\n+    let ((child_tg, is_main), parent_tg) = if opts.supervise {\n+        // It doesn't mean anything for a linked-spawned-task to have a parent\n+        // group. The spawning task is already bidirectionally linked to it.\n+        (share_parent_taskgroup(), none)\n     } else {\n         // Detached from the parent group; create a new (non-main) one.\n-        (arc::exclusive(some((dvec::dvec(),dvec::dvec()))), false)\n+        ((arc::exclusive(some((dvec::dvec(),dvec::dvec()))), false),\n+         // Allow the parent to unidirectionally fail the child?\n+         if opts.parented { // FIXME(#1868) rename to unsupervise.\n+             let (pg,_) = share_parent_taskgroup(); some(pg)\n+         } else {\n+             none\n+         })\n     };\n \n     unsafe {\n-        let child_data_ptr = ~mut some((child_tg, f));\n+        let child_data_ptr = ~mut some((child_tg, parent_tg, f));\n         // Being killed with the unsafe task/closure pointers would leak them.\n         do unkillable {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n             let mut child_data = none;\n             *child_data_ptr <-> child_data;\n-            let (child_tg, f) = option::unwrap(child_data);\n+            let (child_tg, parent_tg, f) = option::unwrap(child_data);\n             // Create child task.\n             let new_task = alt opts.sched {\n               none             { rustrt::new_task() }\n@@ -748,7 +777,7 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n             // Getting killed after here would leak the task.\n \n             let child_wrapper =\n-                make_child_wrapper(new_task, child_tg, is_main, f);\n+                make_child_wrapper(new_task, child_tg, parent_tg, is_main, f);\n             let fptr = ptr::addr_of(child_wrapper);\n             let closure: *rust_closure = unsafe::reinterpret_cast(fptr);\n \n@@ -765,28 +794,63 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n         }\n     }\n \n-    fn make_child_wrapper(child_task: *rust_task, -child_tg: taskgroup_arc,\n-                          is_main: bool, -f: fn~()) -> fn~() {\n-        let child_tg_ptr = ~mut some(child_tg);\n+    // This function returns a closure-wrapper that we pass to the child task.\n+    // In brief, it does the following:\n+    //     if enlist_in_group(child_group) {\n+    //         if parent_group {\n+    //             if !enlist_in_group(parent_group) {\n+    //                 leave_group(child_group); // Roll back\n+    //                 ret; // Parent group failed. Don't run child's f().\n+    //             }\n+    //         }\n+    //         stash_taskgroup_data_in_TLS(child_group, parent_group);\n+    //         f();\n+    //     } else {\n+    //         // My group failed. Don't run chid's f().\n+    //     }\n+    fn make_child_wrapper(child: *rust_task, -child_tg: taskgroup_arc,\n+                          -parent_tg: option<taskgroup_arc>, is_main: bool,\n+                          -f: fn~()) -> fn~() {\n+        let child_tg_ptr = ~mut some((child_tg, parent_tg));\n         fn~() {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n-            let mut child_tg_opt = none;\n-            *child_tg_ptr <-> child_tg_opt;\n-            let child_tg = option::unwrap(child_tg_opt);\n+            let mut tg_data_opt = none;\n+            *child_tg_ptr <-> tg_data_opt;\n+            let (child_tg, parent_tg) = option::unwrap(tg_data_opt);\n             // Child task runs this code.\n-            // Set up membership in taskgroup. If this returns none, the\n-            // parent was already failing, so don't bother doing anything.\n-            alt enlist_in_taskgroup(child_tg, child_task) {\n-                some(my_index) {\n-                    let group =\n-                        @taskgroup(child_tg, child_task, my_index, is_main);\n-                    unsafe { local_set(child_task, taskgroup_key(), group); }\n-                    // Run the child's body.\n-                    f();\n-                    // TLS cleanup code will exit the taskgroup.\n-                }\n-                none {\n+            // Set up membership in taskgroup. If this returns none, some\n+            // task was already failing, so don't bother doing anything.\n+            alt enlist_in_taskgroup(child_tg, child) {\n+                some(my_pos) {\n+                    // Enlist in parent group too. If enlist returns none, a\n+                    // parent was failing: don't spawn; leave this group too.\n+                    let (pg, enlist_ok) = if parent_tg.is_some() {\n+                        let parent_group = option::unwrap(parent_tg);\n+                        alt enlist_in_taskgroup(parent_group, child) {\n+                            some(my_p_index) {\n+                                // Successful enlist.\n+                                (some((parent_group, my_p_index)), true)\n+                            }\n+                            none {\n+                                // Couldn't enlist. Have to quit here too.\n+                                leave_taskgroup(child_tg, child, my_pos);\n+                                (none, false)\n+                            }\n+                        }\n+                    } else {\n+                        // No parent group to enlist in. No worry.\n+                        (none, true)\n+                    };\n+                    if enlist_ok {\n+                        let group = @taskgroup(child, child_tg, my_pos,\n+                                               pg, is_main);\n+                        unsafe { local_set(child, taskgroup_key(), group); }\n+                        // Run the child's body.\n+                        f();\n+                        // TLS cleanup code will exit the taskgroup.\n+                    }\n                 }\n+                none { }\n             }\n         }\n     }"}]}