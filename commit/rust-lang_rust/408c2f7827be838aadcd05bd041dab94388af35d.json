{"sha": "408c2f7827be838aadcd05bd041dab94388af35d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwOGMyZjc4MjdiZTgzOGFhZGNkMDViZDA0MWRhYjk0Mzg4YWYzNWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-12T05:14:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-12T05:14:50Z"}, "message": "Auto merge of #37926 - bluss:from-utf8-small-simplification, r=sfackler\n\nUTF-8 validation: Compute block end upfront\n\nSimplify the conditional used for ensuring that the whole word loop is\nonly used if there are at least two whole words left to read.\n\nThis makes the function slightly smaller and simpler, a 0-5% reduction\nin runtime for various test cases.", "tree": {"sha": "126ddcb037133d76473c23f43218d267c5284d53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/126ddcb037133d76473c23f43218d267c5284d53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/408c2f7827be838aadcd05bd041dab94388af35d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/408c2f7827be838aadcd05bd041dab94388af35d", "html_url": "https://github.com/rust-lang/rust/commit/408c2f7827be838aadcd05bd041dab94388af35d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/408c2f7827be838aadcd05bd041dab94388af35d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2782e8f8fcefdce77c5e0dd0846c15c4c5103d84", "url": "https://api.github.com/repos/rust-lang/rust/commits/2782e8f8fcefdce77c5e0dd0846c15c4c5103d84", "html_url": "https://github.com/rust-lang/rust/commit/2782e8f8fcefdce77c5e0dd0846c15c4c5103d84"}, {"sha": "0dffc1e193f11392ba49b033a0d1c21ab4863b3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dffc1e193f11392ba49b033a0d1c21ab4863b3d", "html_url": "https://github.com/rust-lang/rust/commit/0dffc1e193f11392ba49b033a0d1c21ab4863b3d"}], "stats": {"total": 53, "additions": 26, "deletions": 27}, "files": [{"sha": "49a6b1b5fceb77a417309ee15bf9c4489790f07b", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/408c2f7827be838aadcd05bd041dab94388af35d/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/408c2f7827be838aadcd05bd041dab94388af35d/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=408c2f7827be838aadcd05bd041dab94388af35d", "patch": "@@ -1232,26 +1232,31 @@ fn contains_nonascii(x: usize) -> bool {\n /// invalid sequence.\n #[inline(always)]\n fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n-    let mut offset = 0;\n+    let mut index = 0;\n     let len = v.len();\n-    while offset < len {\n-        let old_offset = offset;\n+\n+    let usize_bytes = mem::size_of::<usize>();\n+    let ascii_block_size = 2 * usize_bytes;\n+    let blocks_end = if len >= ascii_block_size { len - ascii_block_size + 1 } else { 0 };\n+\n+    while index < len {\n+        let old_offset = index;\n         macro_rules! err { () => {{\n             return Err(Utf8Error {\n                 valid_up_to: old_offset\n             })\n         }}}\n \n         macro_rules! next { () => {{\n-            offset += 1;\n+            index += 1;\n             // we needed data, but there was none: error!\n-            if offset >= len {\n+            if index >= len {\n                 err!()\n             }\n-            v[offset]\n+            v[index]\n         }}}\n \n-        let first = v[offset];\n+        let first = v[index];\n         if first >= 128 {\n             let w = UTF8_CHAR_WIDTH[first as usize];\n             let second = next!();\n@@ -1294,38 +1299,32 @@ fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n                 }\n                 _ => err!()\n             }\n-            offset += 1;\n+            index += 1;\n         } else {\n             // Ascii case, try to skip forward quickly.\n             // When the pointer is aligned, read 2 words of data per iteration\n             // until we find a word containing a non-ascii byte.\n-            let usize_bytes = mem::size_of::<usize>();\n-            let bytes_per_iteration = 2 * usize_bytes;\n             let ptr = v.as_ptr();\n-            let align = (ptr as usize + offset) & (usize_bytes - 1);\n+            let align = (ptr as usize + index) & (usize_bytes - 1);\n             if align == 0 {\n-                if len >= bytes_per_iteration {\n-                    while offset <= len - bytes_per_iteration {\n-                        unsafe {\n-                            let u = *(ptr.offset(offset as isize) as *const usize);\n-                            let v = *(ptr.offset((offset + usize_bytes) as isize) as *const usize);\n-\n-                            // break if there is a nonascii byte\n-                            let zu = contains_nonascii(u);\n-                            let zv = contains_nonascii(v);\n-                            if zu || zv {\n-                                break;\n-                            }\n+                while index < blocks_end {\n+                    unsafe {\n+                        let block = ptr.offset(index as isize) as *const usize;\n+                        // break if there is a nonascii byte\n+                        let zu = contains_nonascii(*block);\n+                        let zv = contains_nonascii(*block.offset(1));\n+                        if zu | zv {\n+                            break;\n                         }\n-                        offset += bytes_per_iteration;\n                     }\n+                    index += ascii_block_size;\n                 }\n                 // step from the point where the wordwise loop stopped\n-                while offset < len && v[offset] < 128 {\n-                    offset += 1;\n+                while index < len && v[index] < 128 {\n+                    index += 1;\n                 }\n             } else {\n-                offset += 1;\n+                index += 1;\n             }\n         }\n     }"}]}