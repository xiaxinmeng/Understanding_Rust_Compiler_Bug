{"sha": "48a339ddbbc1e1c364d1cb39d3fef8aad9105345", "node_id": "C_kwDOAAsO6NoAKDQ4YTMzOWRkYmJjMWUxYzM2NGQxY2IzOWQzZmVmOGFhZDkxMDUzNDU", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-16T12:42:26Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-10-09T09:56:29Z"}, "message": "Store lowering outputs per owner.", "tree": {"sha": "026c4e1fc303359720147fc83487223925fc484d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/026c4e1fc303359720147fc83487223925fc484d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48a339ddbbc1e1c364d1cb39d3fef8aad9105345", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48a339ddbbc1e1c364d1cb39d3fef8aad9105345", "html_url": "https://github.com/rust-lang/rust/commit/48a339ddbbc1e1c364d1cb39d3fef8aad9105345", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9e1de979db1e19acad5c2785057e0f2c25ee1f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9e1de979db1e19acad5c2785057e0f2c25ee1f5", "html_url": "https://github.com/rust-lang/rust/commit/f9e1de979db1e19acad5c2785057e0f2c25ee1f5"}], "stats": {"total": 293, "additions": 169, "deletions": 124}, "files": [{"sha": "00d470017bb7f5be481aa107fbe2ab5404b17e22", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=48a339ddbbc1e1c364d1cb39d3fef8aad9105345", "patch": "@@ -4088,6 +4088,7 @@ dependencies = [\n  \"polonius-engine\",\n  \"rand 0.8.4\",\n  \"rand_xoshiro 0.6.0\",\n+ \"rustc-rayon\",\n  \"rustc-rayon-core\",\n  \"rustc_apfloat\",\n  \"rustc_arena\","}, {"sha": "22f93f5078817cbcec8856c57f92bced0a148349", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=48a339ddbbc1e1c364d1cb39d3fef8aad9105345", "patch": "@@ -252,9 +252,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     }\n                     // Merge attributes into the inner expression.\n                     if !e.attrs.is_empty() {\n-                        let old_attrs = self.attrs.get(&ex.hir_id).map(|la| *la).unwrap_or(&[]);\n+                        let old_attrs =\n+                            self.attrs.get(&ex.hir_id.local_id).map(|la| *la).unwrap_or(&[]);\n                         self.attrs.insert(\n-                            ex.hir_id,\n+                            ex.hir_id.local_id,\n                             &*self.arena.alloc_from_iter(\n                                 e.attrs\n                                     .iter()"}, {"sha": "c6572b19d1d1d771a58dfdc01e82201c031ab2ec", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=48a339ddbbc1e1c364d1cb39d3fef8aad9105345", "patch": "@@ -10,6 +10,7 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::LocalDefId;\n+use rustc_index::vec::Idx;\n use rustc_span::source_map::{respan, DesugaringKind};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n@@ -99,11 +100,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> T {\n         let old_len = self.in_scope_lifetimes.len();\n \n-        let parent_generics = match self.owners[parent_hir_id].unwrap().expect_item().kind {\n-            hir::ItemKind::Impl(hir::Impl { ref generics, .. })\n-            | hir::ItemKind::Trait(_, _, ref generics, ..) => generics.params,\n-            _ => &[],\n-        };\n+        let parent_generics =\n+            match self.owners[parent_hir_id].as_ref().unwrap().node.expect_item().kind {\n+                hir::ItemKind::Impl(hir::Impl { ref generics, .. })\n+                | hir::ItemKind::Trait(_, _, ref generics, ..) => generics.params,\n+                _ => &[],\n+            };\n         let lt_def_names = parent_generics.iter().filter_map(|param| match param.kind {\n             hir::GenericParamKind::Lifetime { .. } => Some(param.name.normalize_to_macros_2_0()),\n             _ => None,\n@@ -493,7 +495,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         let kind = hir::ItemKind::Use(path, hir::UseKind::Single);\n                         let vis = this.rebuild_vis(&vis);\n                         if let Some(attrs) = attrs {\n-                            this.attrs.insert(hir::HirId::make_owner(new_id), attrs);\n+                            this.attrs.insert(hir::ItemLocalId::new(0), attrs);\n                         }\n \n                         let item = hir::Item {\n@@ -568,7 +570,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         let kind =\n                             this.lower_use_tree(use_tree, &prefix, id, &mut vis, &mut ident, attrs);\n                         if let Some(attrs) = attrs {\n-                            this.attrs.insert(hir::HirId::make_owner(new_hir_id), attrs);\n+                            this.attrs.insert(hir::ItemLocalId::new(0), attrs);\n                         }\n \n                         let item = hir::Item {\n@@ -971,7 +973,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> hir::BodyId {\n         let body = hir::Body { generator_kind: self.generator_kind, params, value };\n         let id = body.id();\n-        self.bodies.insert(id, body);\n+        debug_assert_eq!(id.hir_id.owner, self.current_hir_id_owner);\n+        self.bodies.insert(id.hir_id.local_id, body);\n         id\n     }\n \n@@ -1124,7 +1127,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 //\n                 // If this is the simple case, this parameter will end up being the same as the\n                 // original parameter, but with a different pattern id.\n-                let stmt_attrs = this.attrs.get(&parameter.hir_id).copied();\n+                let stmt_attrs = this.attrs.get(&parameter.hir_id.local_id).copied();\n                 let (new_parameter_pat, new_parameter_id) = this.pat_ident(desugared_span, ident);\n                 let new_parameter = hir::Param {\n                     hir_id: parameter.hir_id,"}, {"sha": "1b82ac68e159d375209316c09183d1e02720d401", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 57, "deletions": 35, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=48a339ddbbc1e1c364d1cb39d3fef8aad9105345", "patch": "@@ -35,14 +35,13 @@\n #![feature(iter_zip)]\n #![recursion_limit = \"256\"]\n \n-use rustc_ast::node_id::NodeMap;\n use rustc_ast::token::{self, Token};\n use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, TokenStream, TokenTree};\n use rustc_ast::visit;\n use rustc_ast::{self as ast, *};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n@@ -97,13 +96,12 @@ struct LoweringContext<'a, 'hir: 'a> {\n     arena: &'hir Arena<'hir>,\n \n     /// The items being lowered are collected here.\n-    owners: IndexVec<LocalDefId, Option<hir::OwnerNode<'hir>>>,\n-    bodies: BTreeMap<hir::BodyId, hir::Body<'hir>>,\n+    owners: IndexVec<LocalDefId, Option<hir::OwnerInfo<'hir>>>,\n+    bodies: BTreeMap<hir::ItemLocalId, hir::Body<'hir>>,\n+    attrs: BTreeMap<hir::ItemLocalId, &'hir [Attribute]>,\n \n     generator_kind: Option<hir::GeneratorKind>,\n \n-    attrs: BTreeMap<hir::HirId, &'hir [Attribute]>,\n-\n     /// When inside an `async` context, this is the `HirId` of the\n     /// `task_context` local bound to the resume argument of the generator.\n     task_context: Option<hir::HirId>,\n@@ -152,6 +150,9 @@ struct LoweringContext<'a, 'hir: 'a> {\n     item_local_id_counter: hir::ItemLocalId,\n     node_id_to_hir_id: IndexVec<NodeId, Option<hir::HirId>>,\n \n+    /// NodeIds that are lowered inside the current HIR owner.\n+    local_node_ids: Vec<NodeId>,\n+\n     allow_try_trait: Option<Lrc<[Symbol]>>,\n     allow_gen_future: Option<Lrc<[Symbol]>>,\n }\n@@ -182,7 +183,7 @@ pub trait ResolverAstLowering {\n \n     fn next_node_id(&mut self) -> NodeId;\n \n-    fn take_trait_map(&mut self) -> NodeMap<Vec<hir::TraitCandidate>>;\n+    fn take_trait_map(&mut self, node: NodeId) -> Option<Vec<hir::TraitCandidate>>;\n \n     fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId>;\n \n@@ -314,12 +315,13 @@ pub fn lower_crate<'a, 'hir>(\n ) -> &'hir hir::Crate<'hir> {\n     let _prof_timer = sess.prof.verbose_generic_activity(\"hir_lowering\");\n \n+    let owners = IndexVec::from_fn_n(|_| None, resolver.definitions().def_index_count());\n     LoweringContext {\n         sess,\n         resolver,\n         nt_to_tokenstream,\n         arena,\n-        owners: IndexVec::default(),\n+        owners,\n         bodies: BTreeMap::new(),\n         attrs: BTreeMap::default(),\n         catch_scope: None,\n@@ -331,6 +333,7 @@ pub fn lower_crate<'a, 'hir>(\n         current_hir_id_owner: CRATE_DEF_ID,\n         item_local_id_counter: hir::ItemLocalId::new(0),\n         node_id_to_hir_id: IndexVec::new(),\n+        local_node_ids: Vec::new(),\n         generator_kind: None,\n         task_context: None,\n         current_item: None,\n@@ -420,14 +423,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             hir::OwnerNode::Crate(lctx.arena.alloc(module))\n         });\n \n-        let mut trait_map: FxHashMap<_, FxHashMap<_, _>> = FxHashMap::default();\n-        for (k, v) in self.resolver.take_trait_map().into_iter() {\n-            if let Some(Some(hir_id)) = self.node_id_to_hir_id.get(k) {\n-                let map = trait_map.entry(hir_id.owner).or_default();\n-                map.insert(hir_id.local_id, v.into_boxed_slice());\n-            }\n-        }\n-\n         let mut def_id_to_hir_id = IndexVec::default();\n \n         for (node_id, hir_id) in self.node_id_to_hir_id.into_iter_enumerated() {\n@@ -441,16 +436,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         self.resolver.definitions().init_def_id_to_hir_id_mapping(def_id_to_hir_id);\n \n-        #[cfg(debug_assertions)]\n-        for (&id, attrs) in self.attrs.iter() {\n-            // Verify that we do not store empty slices in the map.\n-            if attrs.is_empty() {\n-                panic!(\"Stored empty attributes for {:?}\", id);\n-            }\n-        }\n-\n-        let krate =\n-            hir::Crate { owners: self.owners, bodies: self.bodies, trait_map, attrs: self.attrs };\n+        let krate = hir::Crate { owners: self.owners };\n         self.arena.alloc(krate)\n     }\n \n@@ -468,25 +454,57 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> LocalDefId {\n         let def_id = self.resolver.local_def_id(owner);\n \n-        // Always allocate the first `HirId` for the owner itself.\n-        let _old = self.node_id_to_hir_id.insert(owner, hir::HirId::make_owner(def_id));\n-        debug_assert_eq!(_old, None);\n-\n+        let current_attrs = std::mem::take(&mut self.attrs);\n+        let current_bodies = std::mem::take(&mut self.bodies);\n+        let current_node_ids = std::mem::take(&mut self.local_node_ids);\n         let current_owner = std::mem::replace(&mut self.current_hir_id_owner, def_id);\n         let current_local_counter =\n             std::mem::replace(&mut self.item_local_id_counter, hir::ItemLocalId::new(1));\n \n+        // Always allocate the first `HirId` for the owner itself.\n+        let _old = self.node_id_to_hir_id.insert(owner, hir::HirId::make_owner(def_id));\n+        debug_assert_eq!(_old, None);\n+        self.local_node_ids.push(owner);\n+\n         let item = f(self);\n+        let info = self.make_owner_info(item);\n \n+        self.attrs = current_attrs;\n+        self.bodies = current_bodies;\n+        self.local_node_ids = current_node_ids;\n         self.current_hir_id_owner = current_owner;\n         self.item_local_id_counter = current_local_counter;\n \n-        let _old = self.owners.insert(def_id, item);\n+        let _old = self.owners.insert(def_id, info);\n         debug_assert!(_old.is_none());\n \n         def_id\n     }\n \n+    fn make_owner_info(&mut self, node: hir::OwnerNode<'hir>) -> hir::OwnerInfo<'hir> {\n+        let attrs = std::mem::take(&mut self.attrs);\n+        let bodies = std::mem::take(&mut self.bodies);\n+        let local_node_ids = std::mem::take(&mut self.local_node_ids);\n+        let trait_map = local_node_ids\n+            .into_iter()\n+            .filter_map(|node_id| {\n+                let hir_id = self.node_id_to_hir_id[node_id]?;\n+                let traits = self.resolver.take_trait_map(node_id)?;\n+                Some((hir_id.local_id, traits.into_boxed_slice()))\n+            })\n+            .collect();\n+\n+        #[cfg(debug_assertions)]\n+        for (&id, attrs) in attrs.iter() {\n+            // Verify that we do not store empty slices in the map.\n+            if attrs.is_empty() {\n+                panic!(\"Stored empty attributes for {:?}\", id);\n+            }\n+        }\n+\n+        hir::OwnerInfo { node, attrs, bodies, trait_map }\n+    }\n+\n     /// This method allocates a new `HirId` for the given `NodeId` and stores it in\n     /// the `LoweringContext`'s `NodeId => HirId` map.\n     /// Take care not to call this method if the resulting `HirId` is then not\n@@ -501,6 +519,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             let owner = self.current_hir_id_owner;\n             let local_id = self.item_local_id_counter;\n             self.item_local_id_counter.increment_by(1);\n+            self.local_node_ids.push(ast_node_id);\n             hir::HirId { owner, local_id }\n         })\n     }\n@@ -791,9 +810,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         if attrs.is_empty() {\n             None\n         } else {\n+            debug_assert_eq!(id.owner, self.current_hir_id_owner);\n             let ret = self.arena.alloc_from_iter(attrs.iter().map(|a| self.lower_attr(a)));\n             debug_assert!(!ret.is_empty());\n-            self.attrs.insert(id, ret);\n+            self.attrs.insert(id.local_id, ret);\n             Some(ret)\n         }\n     }\n@@ -819,9 +839,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn alias_attrs(&mut self, id: hir::HirId, target_id: hir::HirId) {\n-        if let Some(&a) = self.attrs.get(&target_id) {\n+        debug_assert_eq!(id.owner, self.current_hir_id_owner);\n+        debug_assert_eq!(target_id.owner, self.current_hir_id_owner);\n+        if let Some(&a) = self.attrs.get(&target_id.local_id) {\n             debug_assert!(!a.is_empty());\n-            self.attrs.insert(id, a);\n+            self.attrs.insert(id.local_id, a);\n         }\n     }\n \n@@ -2066,7 +2088,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let hir_id = self.next_id();\n         if let Some(a) = attrs {\n             debug_assert!(!a.is_empty());\n-            self.attrs.insert(hir_id, a);\n+            self.attrs.insert(hir_id.local_id, a);\n         }\n         let local = hir::Local { hir_id, init, pat, source, span: self.lower_span(span), ty: None };\n         self.stmt(span, hir::StmtKind::Local(self.arena.alloc(local)))"}, {"sha": "a24d92d0c01b74c80a8326bc8288f5339e10c8ea", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=48a339ddbbc1e1c364d1cb39d3fef8aad9105345", "patch": "@@ -662,6 +662,16 @@ pub struct WhereEqPredicate<'hir> {\n     pub rhs_ty: &'hir Ty<'hir>,\n }\n \n+#[derive(Debug)]\n+pub struct OwnerInfo<'hir> {\n+    pub node: OwnerNode<'hir>,\n+    pub attrs: BTreeMap<ItemLocalId, &'hir [Attribute]>,\n+    pub bodies: BTreeMap<ItemLocalId, Body<'hir>>,\n+    /// Map indicating what traits are in scope for places where this\n+    /// is relevant; generated by resolve.\n+    pub trait_map: FxHashMap<ItemLocalId, Box<[TraitCandidate]>>,\n+}\n+\n /// The top-level data structure that stores the entire contents of\n /// the crate currently being compiled.\n ///\n@@ -670,40 +680,39 @@ pub struct WhereEqPredicate<'hir> {\n /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/hir.html\n #[derive(Debug)]\n pub struct Crate<'hir> {\n-    pub owners: IndexVec<LocalDefId, Option<OwnerNode<'hir>>>,\n-    pub bodies: BTreeMap<BodyId, Body<'hir>>,\n-\n-    /// Map indicating what traits are in scope for places where this\n-    /// is relevant; generated by resolve.\n-    pub trait_map: FxHashMap<LocalDefId, FxHashMap<ItemLocalId, Box<[TraitCandidate]>>>,\n-\n-    /// Collected attributes from HIR nodes.\n-    pub attrs: BTreeMap<HirId, &'hir [Attribute]>,\n+    pub owners: IndexVec<LocalDefId, Option<OwnerInfo<'hir>>>,\n }\n \n impl Crate<'hir> {\n     pub fn module(&self) -> &'hir Mod<'hir> {\n-        if let Some(OwnerNode::Crate(m)) = self.owners[CRATE_DEF_ID] { m } else { panic!() }\n+        let i = self.owners[CRATE_DEF_ID].as_ref().unwrap().node;\n+        if let OwnerNode::Crate(m) = i { m } else { panic!() }\n     }\n \n     pub fn item(&self, id: ItemId) -> &'hir Item<'hir> {\n-        self.owners[id.def_id].as_ref().unwrap().expect_item()\n+        self.owners[id.def_id].as_ref().unwrap().node.expect_item()\n     }\n \n     pub fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem<'hir> {\n-        self.owners[id.def_id].as_ref().unwrap().expect_trait_item()\n+        self.owners[id.def_id].as_ref().unwrap().node.expect_trait_item()\n     }\n \n     pub fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem<'hir> {\n-        self.owners[id.def_id].as_ref().unwrap().expect_impl_item()\n+        self.owners[id.def_id].as_ref().unwrap().node.expect_impl_item()\n     }\n \n     pub fn foreign_item(&self, id: ForeignItemId) -> &'hir ForeignItem<'hir> {\n-        self.owners[id.def_id].as_ref().unwrap().expect_foreign_item()\n+        self.owners[id.def_id].as_ref().unwrap().node.expect_foreign_item()\n     }\n \n     pub fn body(&self, id: BodyId) -> &Body<'hir> {\n-        &self.bodies[&id]\n+        let HirId { owner, local_id } = id.hir_id;\n+        &self.owners[owner].as_ref().unwrap().bodies[&local_id]\n+    }\n+\n+    pub fn attrs(&self, id: HirId) -> &'hir [Attribute] {\n+        let HirId { owner, local_id } = id;\n+        &self.owners[owner].as_ref().unwrap().attrs.get(&local_id).map(|la| *la).unwrap_or(&[])\n     }\n }\n "}, {"sha": "daeccde6024e66340d8e741c5c419bc843d5daa8", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=48a339ddbbc1e1c364d1cb39d3fef8aad9105345", "patch": "@@ -12,6 +12,7 @@ bitflags = \"1.2.1\"\n either = \"1.5.0\"\n gsgdt = \"0.1.2\"\n tracing = \"0.1\"\n+rustc-rayon = \"0.3.1\"\n rustc-rayon-core = \"0.3.1\"\n polonius-engine = \"0.13.0\"\n rustc_apfloat = { path = \"../rustc_apfloat\" }"}, {"sha": "1e405d0d7fc12e1a0617d48ce9e72ae818e45fa7", "filename": "compiler/rustc_middle/src/hir/map/collector.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs?ref=48a339ddbbc1e1c364d1cb39d3fef8aad9105345", "patch": "@@ -86,12 +86,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         collector\n     }\n \n-    pub(super) fn finalize_and_compute_crate_hash(mut self) -> IndexedHir<'hir> {\n-        // Insert bodies into the map\n-        for (id, body) in self.krate.bodies.iter() {\n-            let bodies = &mut self.map[id.hir_id.owner].as_mut().unwrap().bodies;\n-            assert!(bodies.insert(id.hir_id.local_id, body).is_none());\n-        }\n+    pub(super) fn finalize_and_compute_crate_hash(self) -> IndexedHir<'hir> {\n         IndexedHir { map: self.map, parenting: self.parenting }\n     }\n \n@@ -101,9 +96,14 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         let mut nodes = IndexVec::new();\n         nodes.push(Some(ParentedNode { parent: ItemLocalId::new(0), node: node.into() }));\n \n+        let mut bodies = FxHashMap::default();\n+        for (id, body) in self.krate.owners[owner].as_ref().unwrap().bodies.iter() {\n+            let _old = bodies.insert(*id, body);\n+            debug_assert!(_old.is_none());\n+        }\n+\n         debug_assert!(self.map[owner].is_none());\n-        self.map[owner] =\n-            Some(self.arena.alloc(OwnerNodes { hash, nodes, bodies: FxHashMap::default() }));\n+        self.map[owner] = Some(self.arena.alloc(OwnerNodes { hash, nodes, bodies }));\n     }\n \n     fn insert(&mut self, span: Span, hir_id: HirId, node: Node<'hir>) {"}, {"sha": "9a1bdba824e1d4a7c11a6fb3759cd787c45ddbfd", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=48a339ddbbc1e1c364d1cb39d3fef8aad9105345", "patch": "@@ -1,6 +1,6 @@\n use self::collector::NodeCollector;\n \n-use crate::hir::{AttributeMap, IndexedHir, ModuleItems, Owner};\n+use crate::hir::{IndexedHir, ModuleItems, Owner};\n use crate::ty::TyCtxt;\n use rustc_ast as ast;\n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -166,8 +166,8 @@ impl<'hir> Map<'hir> {\n \n     pub fn items(&self) -> impl Iterator<Item = &'hir Item<'hir>> + 'hir {\n         let krate = self.krate();\n-        krate.owners.iter().filter_map(|owner| match owner.as_ref()? {\n-            OwnerNode::Item(item) => Some(*item),\n+        krate.owners.iter().filter_map(|owner| match owner.as_ref()?.node {\n+            OwnerNode::Item(item) => Some(item),\n             _ => None,\n         })\n     }\n@@ -495,11 +495,35 @@ impl<'hir> Map<'hir> {\n     /// crate. If you would prefer to iterate over the bodies\n     /// themselves, you can do `self.hir().krate().body_ids.iter()`.\n     pub fn body_owners(self) -> impl Iterator<Item = LocalDefId> + 'hir {\n-        self.krate().bodies.keys().map(move |&body_id| self.body_owner_def_id(body_id))\n+        self.krate()\n+            .owners\n+            .iter_enumerated()\n+            .flat_map(move |(owner, owner_info)| {\n+                let bodies = &owner_info.as_ref()?.bodies;\n+                Some(bodies.keys().map(move |&local_id| {\n+                    let hir_id = HirId { owner, local_id };\n+                    let body_id = BodyId { hir_id };\n+                    self.body_owner_def_id(body_id)\n+                }))\n+            })\n+            .flatten()\n     }\n \n     pub fn par_body_owners<F: Fn(LocalDefId) + Sync + Send>(self, f: F) {\n-        par_for_each_in(&self.krate().bodies, |(&body_id, _)| f(self.body_owner_def_id(body_id)));\n+        use rustc_data_structures::sync::{par_iter, ParallelIterator};\n+        #[cfg(parallel_compiler)]\n+        use rustc_rayon::iter::IndexedParallelIterator;\n+\n+        par_iter(&self.krate().owners.raw).enumerate().for_each(|(owner, owner_info)| {\n+            let owner = LocalDefId::new(owner);\n+            if let Some(owner_info) = owner_info {\n+                par_iter(&owner_info.bodies).for_each(|(&local_id, _)| {\n+                    let hir_id = HirId { owner, local_id };\n+                    let body_id = BodyId { hir_id };\n+                    f(self.body_owner_def_id(body_id))\n+                })\n+            }\n+        });\n     }\n \n     pub fn ty_param_owner(&self, id: HirId) -> HirId {\n@@ -551,9 +575,14 @@ impl<'hir> Map<'hir> {\n     /// Walks the attributes in a crate.\n     pub fn walk_attributes(self, visitor: &mut impl Visitor<'hir>) {\n         let krate = self.krate();\n-        for (&id, attrs) in krate.attrs.iter() {\n-            for a in *attrs {\n-                visitor.visit_attribute(id, a)\n+        for (owner, info) in krate.owners.iter_enumerated() {\n+            if let Some(info) = info {\n+                for (&local_id, attrs) in info.attrs.iter() {\n+                    let id = HirId { owner, local_id };\n+                    for a in *attrs {\n+                        visitor.visit_attribute(id, a)\n+                    }\n+                }\n             }\n         }\n     }\n@@ -572,7 +601,7 @@ impl<'hir> Map<'hir> {\n     {\n         let krate = self.krate();\n         for owner in krate.owners.iter().filter_map(Option::as_ref) {\n-            match owner {\n+            match owner.node {\n                 OwnerNode::Item(item) => visitor.visit_item(item),\n                 OwnerNode::ForeignItem(item) => visitor.visit_foreign_item(item),\n                 OwnerNode::ImplItem(item) => visitor.visit_impl_item(item),\n@@ -588,7 +617,7 @@ impl<'hir> Map<'hir> {\n         V: itemlikevisit::ParItemLikeVisitor<'hir> + Sync + Send,\n     {\n         let krate = self.krate();\n-        par_for_each_in(&krate.owners.raw, |owner| match owner.as_ref() {\n+        par_for_each_in(&krate.owners.raw, |owner| match owner.as_ref().map(|o| o.node) {\n             Some(OwnerNode::Item(item)) => visitor.visit_item(item),\n             Some(OwnerNode::ForeignItem(item)) => visitor.visit_foreign_item(item),\n             Some(OwnerNode::ImplItem(item)) => visitor.visit_impl_item(item),\n@@ -1091,7 +1120,10 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n     for (def_path_hash, fingerprint, def_id) in hir_body_nodes.iter() {\n         def_path_hash.0.hash_stable(&mut hcx, &mut stable_hasher);\n         fingerprint.hash_stable(&mut hcx, &mut stable_hasher);\n-        AttributeMap { map: &tcx.untracked_crate.attrs, prefix: *def_id }\n+        tcx.untracked_crate.owners[*def_id]\n+            .as_ref()\n+            .unwrap()\n+            .attrs\n             .hash_stable(&mut hcx, &mut stable_hasher);\n         if tcx.sess.opts.debugging_opts.incremental_relative_spans {\n             let span = tcx.untracked_resolutions.definitions.def_span(*def_id);"}, {"sha": "9f2ee9f341c3c1320ced4048e2ba44c0b69496fa", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 10, "deletions": 36, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=48a339ddbbc1e1c364d1cb39d3fef8aad9105345", "patch": "@@ -77,47 +77,21 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for OwnerNodes<'tcx> {\n     }\n }\n \n-/// Attributes owner by a HIR owner. It is build as a slice inside the attributes map, restricted\n-/// to the nodes whose `HirId::owner` is `prefix`.\n-#[derive(Copy, Clone)]\n+/// Attributes owner by a HIR owner.\n+#[derive(Copy, Clone, Debug, HashStable)]\n pub struct AttributeMap<'tcx> {\n-    map: &'tcx BTreeMap<HirId, &'tcx [Attribute]>,\n-    prefix: LocalDefId,\n-}\n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for AttributeMap<'tcx> {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let range = self.range();\n-\n-        range.clone().count().hash_stable(hcx, hasher);\n-        for (key, value) in range {\n-            key.hash_stable(hcx, hasher);\n-            value.hash_stable(hcx, hasher);\n-        }\n-    }\n-}\n-\n-impl<'tcx> std::fmt::Debug for AttributeMap<'tcx> {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        f.debug_struct(\"AttributeMap\")\n-            .field(\"prefix\", &self.prefix)\n-            .field(\"range\", &&self.range().collect::<Vec<_>>()[..])\n-            .finish()\n-    }\n+    map: &'tcx BTreeMap<ItemLocalId, &'tcx [Attribute]>,\n }\n \n impl<'tcx> AttributeMap<'tcx> {\n-    fn get(&self, id: ItemLocalId) -> &'tcx [Attribute] {\n-        self.map.get(&HirId { owner: self.prefix, local_id: id }).copied().unwrap_or(&[])\n+    fn new(owner_info: &'tcx Option<OwnerInfo<'tcx>>) -> AttributeMap<'tcx> {\n+        const FALLBACK: &'static BTreeMap<ItemLocalId, &'static [Attribute]> = &BTreeMap::new();\n+        let map = owner_info.as_ref().map_or(FALLBACK, |info| &info.attrs);\n+        AttributeMap { map }\n     }\n \n-    fn range(&self) -> std::collections::btree_map::Range<'_, rustc_hir::HirId, &[Attribute]> {\n-        let local_zero = ItemLocalId::from_u32(0);\n-        let range = HirId { owner: self.prefix, local_id: local_zero }..HirId {\n-            owner: LocalDefId { local_def_index: self.prefix.local_def_index + 1 },\n-            local_id: local_zero,\n-        };\n-        self.map.range(range)\n+    fn get(&self, id: ItemLocalId) -> &'tcx [Attribute] {\n+        self.map.get(&id).copied().unwrap_or(&[])\n     }\n }\n \n@@ -163,7 +137,7 @@ pub fn provide(providers: &mut Providers) {\n         let index = tcx.index_hir(());\n         index.parenting.get(&id).copied().unwrap_or(CRATE_HIR_ID)\n     };\n-    providers.hir_attrs = |tcx, id| AttributeMap { map: &tcx.hir_crate(()).attrs, prefix: id };\n+    providers.hir_attrs = |tcx, id| AttributeMap::new(&tcx.hir_crate(()).owners[id]);\n     providers.source_span = |tcx, def_id| tcx.resolutions(()).definitions.def_span(def_id);\n     providers.def_span = |tcx, def_id| tcx.hir().span_if_local(def_id).unwrap_or(DUMMY_SP);\n     providers.fn_arg_names = |tcx, id| {"}, {"sha": "e7219cc58a18ab3ee00e584ac6bf38a07bf44e1d", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=48a339ddbbc1e1c364d1cb39d3fef8aad9105345", "patch": "@@ -30,6 +30,7 @@\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(core_intrinsics)]\n+#![feature(const_btree_new)]\n #![feature(discriminant_kind)]\n #![feature(exhaustive_patterns)]\n #![feature(if_let_guard)]"}, {"sha": "cbbd89e903335f10dcbdfd7e5bd2e11d9ab893e4", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=48a339ddbbc1e1c364d1cb39d3fef8aad9105345", "patch": "@@ -2828,7 +2828,8 @@ fn ptr_eq<T, U>(t: *const T, u: *const U) -> bool {\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {\n-    providers.in_scope_traits_map = |tcx, id| tcx.hir_crate(()).trait_map.get(&id);\n+    providers.in_scope_traits_map =\n+        |tcx, id| tcx.hir_crate(()).owners[id].as_ref().map(|owner_info| &owner_info.trait_map);\n     providers.resolutions = |tcx, ()| &tcx.untracked_resolutions;\n     providers.module_exports = |tcx, id| tcx.resolutions(()).export_map.get(&id).map(|v| &v[..]);\n     providers.crate_name = |tcx, id| {"}, {"sha": "0a24e00ee4bf5137b88eadef81b20a09266b4ebb", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=48a339ddbbc1e1c364d1cb39d3fef8aad9105345", "patch": "@@ -1994,7 +1994,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 if ns == ValueNS {\n                     let item_name = path.last().unwrap().ident;\n                     let traits = self.traits_in_scope(item_name, ns);\n-                    self.r.trait_map.as_mut().unwrap().insert(id, traits);\n+                    self.r.trait_map.insert(id, traits);\n                 }\n \n                 if PrimTy::from_name(path[0].ident.name).is_some() {\n@@ -2479,12 +2479,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // the field name so that we can do some nice error reporting\n                 // later on in typeck.\n                 let traits = self.traits_in_scope(ident, ValueNS);\n-                self.r.trait_map.as_mut().unwrap().insert(expr.id, traits);\n+                self.r.trait_map.insert(expr.id, traits);\n             }\n             ExprKind::MethodCall(ref segment, ..) => {\n                 debug!(\"(recording candidate traits for expr) recording traits for {}\", expr.id);\n                 let traits = self.traits_in_scope(segment.ident, ValueNS);\n-                self.r.trait_map.as_mut().unwrap().insert(expr.id, traits);\n+                self.r.trait_map.insert(expr.id, traits);\n             }\n             _ => {\n                 // Nothing to do."}, {"sha": "28fe365fb584b3302ee9c3b640ae96e69ca9cb39", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a339ddbbc1e1c364d1cb39d3fef8aad9105345/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=48a339ddbbc1e1c364d1cb39d3fef8aad9105345", "patch": "@@ -930,7 +930,7 @@ pub struct Resolver<'a> {\n     /// `CrateNum` resolutions of `extern crate` items.\n     extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n     export_map: ExportMap,\n-    trait_map: Option<NodeMap<Vec<TraitCandidate>>>,\n+    trait_map: NodeMap<Vec<TraitCandidate>>,\n \n     /// A map from nodes to anonymous modules.\n     /// Anonymous modules are pseudo-modules that are implicitly created around items\n@@ -1185,8 +1185,8 @@ impl ResolverAstLowering for Resolver<'_> {\n         self.next_node_id()\n     }\n \n-    fn take_trait_map(&mut self) -> NodeMap<Vec<TraitCandidate>> {\n-        std::mem::replace(&mut self.trait_map, None).unwrap()\n+    fn take_trait_map(&mut self, node: NodeId) -> Option<Vec<TraitCandidate>> {\n+        self.trait_map.remove(&node)\n     }\n \n     fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId> {\n@@ -1363,7 +1363,7 @@ impl<'a> Resolver<'a> {\n             label_res_map: Default::default(),\n             extern_crate_map: Default::default(),\n             export_map: FxHashMap::default(),\n-            trait_map: Some(NodeMap::default()),\n+            trait_map: NodeMap::default(),\n             underscore_disambiguator: 0,\n             empty_module,\n             module_map,"}]}