{"sha": "30fca57f17dea0b32500937bf80ab1039c50f9f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZmNhNTdmMTdkZWEwYjMyNTAwOTM3YmY4MGFiMTAzOWM1MGY5ZjE=", "commit": {"author": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2013-07-04T11:48:45Z"}, "committer": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2013-07-05T04:03:25Z"}, "message": "Change spans for sugary call expressions", "tree": {"sha": "5e715467d4e45f91871cbede5666d02eaa552487", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e715467d4e45f91871cbede5666d02eaa552487"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30fca57f17dea0b32500937bf80ab1039c50f9f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30fca57f17dea0b32500937bf80ab1039c50f9f1", "html_url": "https://github.com/rust-lang/rust/commit/30fca57f17dea0b32500937bf80ab1039c50f9f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30fca57f17dea0b32500937bf80ab1039c50f9f1/comments", "author": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20458899d53074c2b503ec08a5c1ec4decb2b28f", "url": "https://api.github.com/repos/rust-lang/rust/commits/20458899d53074c2b503ec08a5c1ec4decb2b28f", "html_url": "https://github.com/rust-lang/rust/commit/20458899d53074c2b503ec08a5c1ec4decb2b28f"}], "stats": {"total": 17, "additions": 8, "deletions": 9}, "files": [{"sha": "ae87fd8774a9ace0c2ebb0e37bf1657ad25abc2b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/30fca57f17dea0b32500937bf80ab1039c50f9f1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30fca57f17dea0b32500937bf80ab1039c50f9f1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=30fca57f17dea0b32500937bf80ab1039c50f9f1", "patch": "@@ -1549,10 +1549,10 @@ impl Parser {\n         } else if self.eat_keyword(keywords::If) {\n             return self.parse_if_expr();\n         } else if self.eat_keyword(keywords::For) {\n-            return self.parse_sugary_call_expr(~\"for\", ForSugar,\n+            return self.parse_sugary_call_expr(lo, ~\"for\", ForSugar,\n                                                expr_loop_body);\n         } else if self.eat_keyword(keywords::Do) {\n-            return self.parse_sugary_call_expr(~\"do\", DoSugar,\n+            return self.parse_sugary_call_expr(lo, ~\"do\", DoSugar,\n                                                expr_do_body);\n         } else if self.eat_keyword(keywords::While) {\n             return self.parse_while_expr();\n@@ -2264,12 +2264,11 @@ impl Parser {\n     // parse a 'for' or 'do'.\n     // the 'for' and 'do' expressions parse as calls, but look like\n     // function calls followed by a closure expression.\n-    pub fn parse_sugary_call_expr(&self,\n+    pub fn parse_sugary_call_expr(&self, lo: BytePos,\n                                   keyword: ~str,\n                                   sugar: CallSugar,\n                                   ctor: &fn(v: @expr) -> expr_)\n                                   -> @expr {\n-        let lo = self.last_span;\n         // Parse the callee `foo` in\n         //    for foo || {\n         //    for foo.bar || {\n@@ -2286,21 +2285,21 @@ impl Parser {\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 let args = vec::append(copy *args, [last_arg]);\n-                self.mk_expr(lo.lo, block.span.hi, expr_call(f, args, sugar))\n+                self.mk_expr(lo, block.span.hi, expr_call(f, args, sugar))\n             }\n             expr_method_call(_, f, i, ref tps, ref args, NoSugar) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 let args = vec::append(copy *args, [last_arg]);\n-                self.mk_expr(lo.lo, block.span.hi,\n+                self.mk_expr(lo, block.span.hi,\n                              self.mk_method_call(f, i, copy *tps, args, sugar))\n             }\n             expr_field(f, i, ref tps) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n-                self.mk_expr(lo.lo, block.span.hi,\n+                self.mk_expr(lo, block.span.hi,\n                              self.mk_method_call(f, i, copy *tps, ~[last_arg], sugar))\n             }\n             expr_path(*) | expr_call(*) | expr_method_call(*) |\n@@ -2309,7 +2308,7 @@ impl Parser {\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 self.mk_expr(\n-                    lo.lo,\n+                    lo,\n                     last_arg.span.hi,\n                     self.mk_call(e, ~[last_arg], sugar))\n             }\n@@ -2319,7 +2318,7 @@ impl Parser {\n                 // but they aren't represented by tests\n                 debug!(\"sugary call on %?\", e.node);\n                 self.span_fatal(\n-                    *lo,\n+                    e.span,\n                     fmt!(\"`%s` must be followed by a block call\", keyword));\n             }\n         }"}]}