{"sha": "7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "node_id": "C_kwDOAAsO6NoAKDdiZGRhOGY4MDE4MThjMWU5NDU1NzI1YTk2NGEzZmE0ZjAyYzJiYjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-14T09:33:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-14T09:33:57Z"}, "message": "Auto merge of #105686 - matthiaskrgr:rollup-bedfk3j, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #103644 (Add docs for question mark operator for Option)\n - #105161 (Refine when invalid prefix case error arises)\n - #105491 (Illegal sized bounds: only suggest mutability change if needed)\n - #105502 (Suggest impl in the scenario of typo with fn)\n - #105523 (Suggest `collect`ing into `Vec<_>`)\n - #105595 (Suggest dereferencing receiver arguments properly)\n - #105611 (fold instead of obliterating args)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "f268342a5b1928e4db7774273cbce7be199e45e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f268342a5b1928e4db7774273cbce7be199e45e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "html_url": "https://github.com/rust-lang/rust/commit/7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc30b92cc576ed9e097db7fece0af13662de8d8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc30b92cc576ed9e097db7fece0af13662de8d8d", "html_url": "https://github.com/rust-lang/rust/commit/dc30b92cc576ed9e097db7fece0af13662de8d8d"}, {"sha": "01469693de40f8318766904278f3ad21f7a7db75", "url": "https://api.github.com/repos/rust-lang/rust/commits/01469693de40f8318766904278f3ad21f7a7db75", "html_url": "https://github.com/rust-lang/rust/commit/01469693de40f8318766904278f3ad21f7a7db75"}], "stats": {"total": 826, "additions": 637, "deletions": 189}, "files": [{"sha": "b53550e5fd556c02e58acd21fbae26252bb2b69a", "filename": "compiler/rustc_error_messages/locales/en-US/parse.ftl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -362,3 +362,6 @@ parse_fn_ptr_with_generics = function pointer types may not have generic paramet\n \n parse_invalid_identifier_with_leading_number = expected identifier, found number literal\n     .label = identifiers cannot start with a number\n+\n+parse_maybe_fn_typo_with_impl = you might have meant to write `impl` instead of `fn`\n+    .suggestion = replace `fn` with `impl` here"}, {"sha": "a7eae392de1dd1fccefb6d46a0b3ecd1c27795ec", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -209,7 +209,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ProbeScope::TraitsInScope,\n                 ) {\n                     Ok(ref new_pick) if pick.differs_from(new_pick) => {\n-                        needs_mut = true;\n+                        needs_mut = new_pick.self_ty.ref_mutability() != self_ty.ref_mutability();\n                     }\n                     _ => {}\n                 }"}, {"sha": "a4c36b4c9cd59db580517b60f8d887ca2bcd40eb", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 66, "deletions": 38, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -20,7 +20,7 @@ use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter, Print, Printer};\n use rustc_middle::ty::{self, DefIdTree, InferConst};\n use rustc_middle::ty::{GenericArg, GenericArgKind, SubstsRef};\n use rustc_middle::ty::{IsSuggestable, Ty, TyCtxt, TypeckResults};\n-use rustc_span::symbol::{kw, Ident};\n+use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{BytePos, Span};\n use std::borrow::Cow;\n use std::iter;\n@@ -79,7 +79,7 @@ impl InferenceDiagnosticsData {\n \n     fn where_x_is_kind(&self, in_type: Ty<'_>) -> &'static str {\n         if in_type.is_ty_infer() {\n-            \"empty\"\n+            \"\"\n         } else if self.name == \"_\" {\n             // FIXME: Consider specializing this message if there is a single `_`\n             // in the type.\n@@ -183,13 +183,24 @@ fn fmt_printer<'a, 'tcx>(infcx: &'a InferCtxt<'tcx>, ns: Namespace) -> FmtPrinte\n     printer\n }\n \n-fn ty_to_string<'tcx>(infcx: &InferCtxt<'tcx>, ty: Ty<'tcx>) -> String {\n+fn ty_to_string<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+    called_method_def_id: Option<DefId>,\n+) -> String {\n     let printer = fmt_printer(infcx, Namespace::TypeNS);\n     let ty = infcx.resolve_vars_if_possible(ty);\n-    match ty.kind() {\n+    match (ty.kind(), called_method_def_id) {\n         // We don't want the regular output for `fn`s because it includes its path in\n         // invalid pseudo-syntax, we want the `fn`-pointer output instead.\n-        ty::FnDef(..) => ty.fn_sig(infcx.tcx).print(printer).unwrap().into_buffer(),\n+        (ty::FnDef(..), _) => ty.fn_sig(infcx.tcx).print(printer).unwrap().into_buffer(),\n+        (_, Some(def_id))\n+            if ty.is_ty_infer()\n+                && infcx.tcx.get_diagnostic_item(sym::iterator_collect_fn) == Some(def_id) =>\n+        {\n+            \"Vec<_>\".to_string()\n+        }\n+        _ if ty.is_ty_infer() => \"/* Type */\".to_string(),\n         // FIXME: The same thing for closures, but this only works when the closure\n         // does not capture anything.\n         //\n@@ -213,15 +224,15 @@ fn closure_as_fn_str<'tcx>(infcx: &InferCtxt<'tcx>, ty: Ty<'tcx>) -> String {\n         .map(|args| {\n             args.tuple_fields()\n                 .iter()\n-                .map(|arg| ty_to_string(infcx, arg))\n+                .map(|arg| ty_to_string(infcx, arg, None))\n                 .collect::<Vec<_>>()\n                 .join(\", \")\n         })\n         .unwrap_or_default();\n     let ret = if fn_sig.output().skip_binder().is_unit() {\n         String::new()\n     } else {\n-        format!(\" -> {}\", ty_to_string(infcx, fn_sig.output().skip_binder()))\n+        format!(\" -> {}\", ty_to_string(infcx, fn_sig.output().skip_binder(), None))\n     };\n     format!(\"fn({}){}\", args, ret)\n }\n@@ -368,6 +379,7 @@ impl<'tcx> InferCtxt<'tcx> {\n }\n \n impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n+    #[instrument(level = \"debug\", skip(self, error_code))]\n     pub fn emit_inference_failure_err(\n         &self,\n         body_id: Option<hir::BodyId>,\n@@ -406,7 +418,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         let mut infer_subdiags = Vec::new();\n         let mut multi_suggestions = Vec::new();\n         match kind {\n-            InferSourceKind::LetBinding { insert_span, pattern_name, ty } => {\n+            InferSourceKind::LetBinding { insert_span, pattern_name, ty, def_id } => {\n                 infer_subdiags.push(SourceKindSubdiag::LetLike {\n                     span: insert_span,\n                     name: pattern_name.map(|name| name.to_string()).unwrap_or_else(String::new),\n@@ -415,7 +427,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     prefix: arg_data.kind.try_get_prefix().unwrap_or_default(),\n                     arg_name: arg_data.name,\n                     kind: if pattern_name.is_some() { \"with_pattern\" } else { \"other\" },\n-                    type_name: ty_to_string(self, ty),\n+                    type_name: ty_to_string(self, ty, def_id),\n                 });\n             }\n             InferSourceKind::ClosureArg { insert_span, ty } => {\n@@ -427,7 +439,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     prefix: arg_data.kind.try_get_prefix().unwrap_or_default(),\n                     arg_name: arg_data.name,\n                     kind: \"closure\",\n-                    type_name: ty_to_string(self, ty),\n+                    type_name: ty_to_string(self, ty, None),\n                 });\n             }\n             InferSourceKind::GenericArg {\n@@ -456,33 +468,39 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     parent_name,\n                 });\n \n-                let args = fmt_printer(self, Namespace::TypeNS)\n-                    .comma_sep(generic_args.iter().copied().map(|arg| {\n-                        if arg.is_suggestable(self.tcx, true) {\n-                            return arg;\n-                        }\n+                let args = if self.infcx.tcx.get_diagnostic_item(sym::iterator_collect_fn)\n+                    == Some(generics_def_id)\n+                {\n+                    \"Vec<_>\".to_string()\n+                } else {\n+                    fmt_printer(self, Namespace::TypeNS)\n+                        .comma_sep(generic_args.iter().copied().map(|arg| {\n+                            if arg.is_suggestable(self.tcx, true) {\n+                                return arg;\n+                            }\n \n-                        match arg.unpack() {\n-                            GenericArgKind::Lifetime(_) => bug!(\"unexpected lifetime\"),\n-                            GenericArgKind::Type(_) => self\n-                                .next_ty_var(TypeVariableOrigin {\n-                                    span: rustc_span::DUMMY_SP,\n-                                    kind: TypeVariableOriginKind::MiscVariable,\n-                                })\n-                                .into(),\n-                            GenericArgKind::Const(arg) => self\n-                                .next_const_var(\n-                                    arg.ty(),\n-                                    ConstVariableOrigin {\n+                            match arg.unpack() {\n+                                GenericArgKind::Lifetime(_) => bug!(\"unexpected lifetime\"),\n+                                GenericArgKind::Type(_) => self\n+                                    .next_ty_var(TypeVariableOrigin {\n                                         span: rustc_span::DUMMY_SP,\n-                                        kind: ConstVariableOriginKind::MiscVariable,\n-                                    },\n-                                )\n-                                .into(),\n-                        }\n-                    }))\n-                    .unwrap()\n-                    .into_buffer();\n+                                        kind: TypeVariableOriginKind::MiscVariable,\n+                                    })\n+                                    .into(),\n+                                GenericArgKind::Const(arg) => self\n+                                    .next_const_var(\n+                                        arg.ty(),\n+                                        ConstVariableOrigin {\n+                                            span: rustc_span::DUMMY_SP,\n+                                            kind: ConstVariableOriginKind::MiscVariable,\n+                                        },\n+                                    )\n+                                    .into(),\n+                            }\n+                        }))\n+                        .unwrap()\n+                        .into_buffer()\n+                };\n \n                 if !have_turbofish {\n                     infer_subdiags.push(SourceKindSubdiag::GenericSuggestion {\n@@ -520,7 +538,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 ));\n             }\n             InferSourceKind::ClosureReturn { ty, data, should_wrap_expr } => {\n-                let ty_info = ty_to_string(self, ty);\n+                let ty_info = ty_to_string(self, ty, None);\n                 multi_suggestions.push(SourceKindMultiSuggestion::new_closure_return(\n                     ty_info,\n                     data,\n@@ -608,6 +626,7 @@ enum InferSourceKind<'tcx> {\n         insert_span: Span,\n         pattern_name: Option<Ident>,\n         ty: Ty<'tcx>,\n+        def_id: Option<DefId>,\n     },\n     ClosureArg {\n         insert_span: Span,\n@@ -662,7 +681,7 @@ impl<'tcx> InferSourceKind<'tcx> {\n                 if ty.is_closure() {\n                     (\"closure\", closure_as_fn_str(infcx, ty))\n                 } else if !ty.is_ty_infer() {\n-                    (\"normal\", ty_to_string(infcx, ty))\n+                    (\"normal\", ty_to_string(infcx, ty, None))\n                 } else {\n                     (\"other\", String::new())\n                 }\n@@ -788,10 +807,18 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n     /// Uses `fn source_cost` to determine whether this inference source is preferable to\n     /// previous sources. We generally prefer earlier sources.\n     #[instrument(level = \"debug\", skip(self))]\n-    fn update_infer_source(&mut self, new_source: InferSource<'tcx>) {\n+    fn update_infer_source(&mut self, mut new_source: InferSource<'tcx>) {\n         let cost = self.source_cost(&new_source) + self.attempt;\n         debug!(?cost);\n         self.attempt += 1;\n+        if let Some(InferSource { kind: InferSourceKind::GenericArg { def_id: did, ..}, .. }) = self.infer_source\n+            && let InferSourceKind::LetBinding { ref ty, ref mut def_id, ..} = new_source.kind\n+            && ty.is_ty_infer()\n+        {\n+            // Customize the output so we talk about `let x: Vec<_> = iter.collect();` instead of\n+            // `let x: _ = iter.collect();`, as this is a very common case.\n+            *def_id = Some(did);\n+        }\n         if cost < self.infer_source_cost {\n             self.infer_source_cost = cost;\n             self.infer_source = Some(new_source);\n@@ -1092,6 +1119,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindInferSourceVisitor<'a, 'tcx> {\n                                 insert_span: local.pat.span.shrink_to_hi(),\n                                 pattern_name: local.pat.simple_ident(),\n                                 ty,\n+                                def_id: None,\n                             },\n                         })\n                     }"}, {"sha": "996148a709087161775337d9945aa262c7888749", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 38, "deletions": 15, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -2014,31 +2014,54 @@ fn replace_param_and_infer_substs_with_placeholder<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     substs: SubstsRef<'tcx>,\n ) -> SubstsRef<'tcx> {\n-    tcx.mk_substs(substs.iter().enumerate().map(|(idx, arg)| {\n-        match arg.unpack() {\n-            GenericArgKind::Type(_) if arg.has_non_region_param() || arg.has_non_region_infer() => {\n-                tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n+    struct ReplaceParamAndInferWithPlaceholder<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        idx: usize,\n+    }\n+\n+    impl<'tcx> TypeFolder<'tcx> for ReplaceParamAndInferWithPlaceholder<'tcx> {\n+        fn tcx(&self) -> TyCtxt<'tcx> {\n+            self.tcx\n+        }\n+\n+        fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+            if let ty::Infer(_) = t.kind() {\n+                self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n                     universe: ty::UniverseIndex::ROOT,\n-                    name: ty::BoundVar::from_usize(idx),\n+                    name: ty::BoundVar::from_usize({\n+                        let idx = self.idx;\n+                        self.idx += 1;\n+                        idx\n+                    }),\n                 }))\n-                .into()\n+            } else {\n+                t.super_fold_with(self)\n             }\n-            GenericArgKind::Const(ct) if ct.has_non_region_infer() || ct.has_non_region_param() => {\n-                let ty = ct.ty();\n-                // If the type references param or infer, replace that too...\n+        }\n+\n+        fn fold_const(&mut self, c: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+            if let ty::ConstKind::Infer(_) = c.kind() {\n+                let ty = c.ty();\n+                // If the type references param or infer then ICE ICE ICE\n                 if ty.has_non_region_param() || ty.has_non_region_infer() {\n-                    bug!(\"const `{ct}`'s type should not reference params or types\");\n+                    bug!(\"const `{c}`'s type should not reference params or types\");\n                 }\n-                tcx.mk_const(\n+                self.tcx.mk_const(\n                     ty::PlaceholderConst {\n                         universe: ty::UniverseIndex::ROOT,\n-                        name: ty::BoundVar::from_usize(idx),\n+                        name: ty::BoundVar::from_usize({\n+                            let idx = self.idx;\n+                            self.idx += 1;\n+                            idx\n+                        }),\n                     },\n                     ty,\n                 )\n-                .into()\n+            } else {\n+                c.super_fold_with(self)\n             }\n-            _ => arg,\n         }\n-    }))\n+    }\n+\n+    substs.fold_with(&mut ReplaceParamAndInferWithPlaceholder { tcx, idx: 0 })\n }"}, {"sha": "18a0bee9c2e5ee83ba98e4543fdc54b2befb3d8d", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -1221,3 +1221,11 @@ pub(crate) struct UnexpectedIfWithIf(\n     #[suggestion(applicability = \"machine-applicable\", code = \" \", style = \"verbose\")]\n     pub Span,\n );\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_maybe_fn_typo_with_impl)]\n+pub(crate) struct FnTypoWithImpl {\n+    #[primary_span]\n+    #[suggestion(applicability = \"maybe-incorrect\", code = \"impl\", style = \"verbose\")]\n+    pub fn_span: Span,\n+}"}, {"sha": "7c2d01509de417b100c281abf1a6863106d05ee0", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -3,6 +3,7 @@ use crate::errors::{DocCommentDoesNotDocumentAnything, UseEmptyBlockNotSemi};\n use super::diagnostics::{dummy_arg, ConsumeClosingDelim};\n use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n use super::{AttrWrapper, FollowedByType, ForceCollect, Parser, PathStyle, TrailingToken};\n+use crate::errors::FnTypoWithImpl;\n use rustc_ast::ast::*;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, TokenKind};\n@@ -2131,11 +2132,26 @@ impl<'a> Parser<'a> {\n         vis: &Visibility,\n         case: Case,\n     ) -> PResult<'a, (Ident, FnSig, Generics, Option<P<Block>>)> {\n+        let fn_span = self.token.span;\n         let header = self.parse_fn_front_matter(vis, case)?; // `const ... fn`\n         let ident = self.parse_ident()?; // `foo`\n         let mut generics = self.parse_generics()?; // `<'a, T, ...>`\n-        let decl =\n-            self.parse_fn_decl(fn_parse_mode.req_name, AllowPlus::Yes, RecoverReturnSign::Yes)?; // `(p: u8, ...)`\n+        let decl = match self.parse_fn_decl(\n+            fn_parse_mode.req_name,\n+            AllowPlus::Yes,\n+            RecoverReturnSign::Yes,\n+        ) {\n+            Ok(decl) => decl,\n+            Err(old_err) => {\n+                // If we see `for Ty ...` then user probably meant `impl` item.\n+                if self.token.is_keyword(kw::For) {\n+                    old_err.cancel();\n+                    return Err(self.sess.create_err(FnTypoWithImpl { fn_span }));\n+                } else {\n+                    return Err(old_err);\n+                }\n+            }\n+        };\n         generics.where_clause = self.parse_where_clause()?; // `where T: Ord`\n \n         let mut sig_hi = self.prev_token.span;"}, {"sha": "4266430c4c68067788d1f2af53e96f2ed4d88fd1", "filename": "compiler/rustc_session/src/errors.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -291,20 +291,33 @@ pub fn report_lit_error(sess: &ParseSess, err: LitError, lit: token::Lit, span:\n         s.len() > 1 && s.starts_with(first_chars) && s[1..].chars().all(|c| c.is_ascii_digit())\n     }\n \n-    // Try to lowercase the prefix if it's a valid base prefix.\n-    fn fix_base_capitalisation(s: &str) -> Option<String> {\n-        if let Some(stripped) = s.strip_prefix('B') {\n-            Some(format!(\"0b{stripped}\"))\n-        } else if let Some(stripped) = s.strip_prefix('O') {\n-            Some(format!(\"0o{stripped}\"))\n-        } else if let Some(stripped) = s.strip_prefix('X') {\n-            Some(format!(\"0x{stripped}\"))\n+    // Try to lowercase the prefix if the prefix and suffix are valid.\n+    fn fix_base_capitalisation(prefix: &str, suffix: &str) -> Option<String> {\n+        let mut chars = suffix.chars();\n+\n+        let base_char = chars.next().unwrap();\n+        let base = match base_char {\n+            'B' => 2,\n+            'O' => 8,\n+            'X' => 16,\n+            _ => return None,\n+        };\n+\n+        // check that the suffix contains only base-appropriate characters\n+        let valid = prefix == \"0\"\n+            && chars\n+                .filter(|c| *c != '_')\n+                .take_while(|c| *c != 'i' && *c != 'u')\n+                .all(|c| c.to_digit(base).is_some());\n+\n+        if valid {\n+            Some(format!(\"0{}{}\", base_char.to_ascii_lowercase(), &suffix[1..]))\n         } else {\n             None\n         }\n     }\n \n-    let token::Lit { kind, suffix, .. } = lit;\n+    let token::Lit { kind, symbol, suffix, .. } = lit;\n     match err {\n         // `LexerError` is an error, but it was already reported\n         // by lexer, so here we don't report it the second time.\n@@ -320,7 +333,7 @@ pub fn report_lit_error(sess: &ParseSess, err: LitError, lit: token::Lit, span:\n             if looks_like_width_suffix(&['i', 'u'], suf) {\n                 // If it looks like a width, try to be helpful.\n                 sess.emit_err(InvalidIntLiteralWidth { span, width: suf[1..].into() });\n-            } else if let Some(fixed) = fix_base_capitalisation(suf) {\n+            } else if let Some(fixed) = fix_base_capitalisation(symbol.as_str(), suf) {\n                 sess.emit_err(InvalidNumLiteralBasePrefix { span, fixed });\n             } else {\n                 sess.emit_err(InvalidNumLiteralSuffix { span, suffix: suf.to_string() });"}, {"sha": "ace095736c92fd8a1a2e2b39c91b4c08b1ed6115", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -827,6 +827,7 @@ symbols! {\n         item_like_imports,\n         iter,\n         iter_repeat,\n+        iterator_collect_fn,\n         kcfi,\n         keyword,\n         kind,"}, {"sha": "c68da3e24a19002fd02bd4549dbe2b44516fcb23", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 23, "deletions": 56, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -42,7 +42,7 @@ use rustc_middle::ty::{\n };\n use rustc_session::Limit;\n use rustc_span::def_id::LOCAL_CRATE;\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::sym;\n use rustc_span::{ExpnKind, Span, DUMMY_SP};\n use std::fmt;\n use std::iter;\n@@ -980,6 +980,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 trait_ref,\n                                 obligation.cause.body_id,\n                                 &mut err,\n+                                true,\n                             ) {\n                                 // This is *almost* equivalent to\n                                 // `obligation.cause.code().peel_derives()`, but it gives us the\n@@ -1015,6 +1016,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                         trait_ref,\n                                         obligation.cause.body_id,\n                                         &mut err,\n+                                        true,\n                                     );\n                                 }\n                             }\n@@ -1434,6 +1436,7 @@ trait InferCtxtPrivExt<'tcx> {\n         trait_ref: ty::PolyTraitRef<'tcx>,\n         body_id: hir::HirId,\n         err: &mut Diagnostic,\n+        other: bool,\n     ) -> bool;\n \n     /// Gets the parent trait chain start\n@@ -1888,7 +1891,9 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         trait_ref: ty::PolyTraitRef<'tcx>,\n         body_id: hir::HirId,\n         err: &mut Diagnostic,\n+        other: bool,\n     ) -> bool {\n+        let other = if other { \"other \" } else { \"\" };\n         let report = |mut candidates: Vec<TraitRef<'tcx>>, err: &mut Diagnostic| {\n             candidates.sort();\n             candidates.dedup();\n@@ -1939,7 +1944,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             candidates.dedup();\n             let end = if candidates.len() <= 9 { candidates.len() } else { 8 };\n             err.help(&format!(\n-                \"the following other types implement trait `{}`:{}{}\",\n+                \"the following {other}types implement trait `{}`:{}{}\",\n                 trait_ref.print_only_trait_path(),\n                 candidates[..end].join(\"\"),\n                 if len > 9 { format!(\"\\nand {} others\", len - 8) } else { String::new() }\n@@ -2180,14 +2185,26 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             trait_ref.skip_binder().substs.types().any(|t| !t.is_ty_infer());\n                         // It doesn't make sense to talk about applicable impls if there are more\n                         // than a handful of them.\n-                        if impls.len() > 1 && impls.len() < 5 && has_non_region_infer {\n+                        if impls.len() > 1 && impls.len() < 10 && has_non_region_infer {\n                             self.annotate_source_of_ambiguity(&mut err, &impls, predicate);\n                         } else {\n                             if self.tainted_by_errors().is_some() {\n                                 err.cancel();\n                                 return;\n                             }\n                             err.note(&format!(\"cannot satisfy `{}`\", predicate));\n+                            let impl_candidates = self.find_similar_impl_candidates(\n+                                predicate.to_opt_poly_trait_pred().unwrap(),\n+                            );\n+                            if impl_candidates.len() < 10 {\n+                                self.report_similar_impl_candidates(\n+                                    impl_candidates,\n+                                    trait_ref,\n+                                    body_id.map(|id| id.hir_id).unwrap_or(obligation.cause.body_id),\n+                                    &mut err,\n+                                    false,\n+                                );\n+                            }\n                         }\n                     }\n                     _ => {\n@@ -2199,60 +2216,10 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     }\n                 }\n \n-                if let ObligationCauseCode::ItemObligation(def_id) | ObligationCauseCode::ExprItemObligation(def_id, ..) = *obligation.cause.code() {\n-                    self.suggest_fully_qualified_path(&mut err, def_id, span, trait_ref.def_id());\n-                } else if let Ok(snippet) = &self.tcx.sess.source_map().span_to_snippet(span)\n-                    && let ObligationCauseCode::BindingObligation(def_id, _) | ObligationCauseCode::ExprBindingObligation(def_id, ..)\n-                        = *obligation.cause.code()\n+                if let ObligationCauseCode::ItemObligation(def_id)\n+                | ObligationCauseCode::ExprItemObligation(def_id, ..) = *obligation.cause.code()\n                 {\n-                    let generics = self.tcx.generics_of(def_id);\n-                    if generics.params.iter().any(|p| p.name != kw::SelfUpper)\n-                        && !snippet.ends_with('>')\n-                        && !generics.has_impl_trait()\n-                        && !self.tcx.is_fn_trait(def_id)\n-                    {\n-                        // FIXME: To avoid spurious suggestions in functions where type arguments\n-                        // where already supplied, we check the snippet to make sure it doesn't\n-                        // end with a turbofish. Ideally we would have access to a `PathSegment`\n-                        // instead. Otherwise we would produce the following output:\n-                        //\n-                        // error[E0283]: type annotations needed\n-                        //   --> $DIR/issue-54954.rs:3:24\n-                        //    |\n-                        // LL | const ARR_LEN: usize = Tt::const_val::<[i8; 123]>();\n-                        //    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-                        //    |                        |\n-                        //    |                        cannot infer type\n-                        //    |                        help: consider specifying the type argument\n-                        //    |                        in the function call:\n-                        //    |                        `Tt::const_val::<[i8; 123]>::<T>`\n-                        // ...\n-                        // LL |     const fn const_val<T: Sized>() -> usize {\n-                        //    |                        - required by this bound in `Tt::const_val`\n-                        //    |\n-                        //    = note: cannot satisfy `_: Tt`\n-\n-                        // Clear any more general suggestions in favor of our specific one\n-                        err.clear_suggestions();\n-\n-                        err.span_suggestion_verbose(\n-                            span.shrink_to_hi(),\n-                            &format!(\n-                                \"consider specifying the type argument{} in the function call\",\n-                                pluralize!(generics.params.len()),\n-                            ),\n-                            format!(\n-                                \"::<{}>\",\n-                                generics\n-                                    .params\n-                                    .iter()\n-                                    .map(|p| p.name.to_string())\n-                                    .collect::<Vec<String>>()\n-                                    .join(\", \")\n-                            ),\n-                            Applicability::HasPlaceholders,\n-                        );\n-                    }\n+                    self.suggest_fully_qualified_path(&mut err, def_id, span, trait_ref.def_id());\n                 }\n \n                 if let (Some(body_id), Some(ty::subst::GenericArgKind::Type(_))) ="}, {"sha": "55a05df763fe621b73b54a91c9b32af1054481bf", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -696,7 +696,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool {\n         // It only make sense when suggesting dereferences for arguments\n-        let ObligationCauseCode::FunctionArgumentObligation { arg_hir_id, .. } = obligation.cause.code()\n+        let ObligationCauseCode::FunctionArgumentObligation { arg_hir_id, call_hir_id, .. } = obligation.cause.code()\n             else { return false; };\n         let Some(typeck_results) = &self.typeck_results\n             else { return false; };\n@@ -775,12 +775,33 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         real_trait_pred_and_base_ty,\n                     );\n                     if self.predicate_may_hold(&obligation) {\n-                        err.span_suggestion_verbose(\n-                            span.shrink_to_lo(),\n-                            \"consider dereferencing here\",\n-                            \"*\",\n-                            Applicability::MachineApplicable,\n+                        let call_node = self.tcx.hir().get(*call_hir_id);\n+                        let msg = \"consider dereferencing here\";\n+                        let is_receiver = matches!(\n+                            call_node,\n+                            Node::Expr(hir::Expr {\n+                                kind: hir::ExprKind::MethodCall(_, receiver_expr, ..),\n+                                ..\n+                            })\n+                            if receiver_expr.hir_id == *arg_hir_id\n                         );\n+                        if is_receiver {\n+                            err.multipart_suggestion_verbose(\n+                                msg,\n+                                vec![\n+                                    (span.shrink_to_lo(), \"(*\".to_string()),\n+                                    (span.shrink_to_hi(), \")\".to_string()),\n+                                ],\n+                                Applicability::MachineApplicable,\n+                            )\n+                        } else {\n+                            err.span_suggestion_verbose(\n+                                span.shrink_to_lo(),\n+                                msg,\n+                                '*',\n+                                Applicability::MachineApplicable,\n+                            )\n+                        };\n                         return true;\n                     }\n                 }\n@@ -2854,6 +2875,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 arg_hir_id,\n                 call_hir_id,\n                 ref parent_code,\n+                ..\n             } => {\n                 self.function_argument_obligation(\n                     arg_hir_id,"}, {"sha": "1cdee992137daebebe8cafa38c4786400d46e9fe", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -1829,6 +1829,7 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use = \"if you really need to exhaust the iterator, consider `.for_each(drop)` instead\"]\n+    #[cfg_attr(not(test), rustc_diagnostic_item = \"iterator_collect_fn\")]\n     fn collect<B: FromIterator<Self::Item>>(self) -> B\n     where\n         Self: Sized,"}, {"sha": "39462dca4ff3ea46b1f7c8ecf7216eb9b34b624a", "filename": "library/core/src/option.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -72,6 +72,50 @@\n //! }\n //! ```\n //!\n+//! # The question mark operator, `?`\n+//!\n+//! Similar to the [`Result`] type, when writing code that calls many functions that return the\n+//! [`Option`] type, handling `Some`/`None` can be tedious. The question mark\n+//! operator, [`?`], hides some of the boilerplate of propagating values\n+//! up the call stack.\n+//!\n+//! It replaces this:\n+//!\n+//! ```\n+//! # #![allow(dead_code)]\n+//! fn add_last_numbers(stack: &mut Vec<i32>) -> Option<i32> {\n+//!     let a = stack.pop();\n+//!     let b = stack.pop();\n+//!\n+//!     match (a, b) {\n+//!         (Some(x), Some(y)) => Some(x + y),\n+//!         _ => None,\n+//!     }\n+//! }\n+//!\n+//! ```\n+//!\n+//! With this:\n+//!\n+//! ```\n+//! # #![allow(dead_code)]\n+//! fn add_last_numbers(stack: &mut Vec<i32>) -> Option<i32> {\n+//!     Some(stack.pop()? + stack.pop()?)\n+//! }\n+//! ```\n+//!\n+//! *It's much nicer!*\n+//!\n+//! Ending the expression with [`?`] will result in the [`Some`]'s unwrapped value, unless the\n+//! result is [`None`], in which case [`None`] is returned early from the enclosing function.\n+//!\n+//! [`?`] can be used in functions that return [`Option`] because of the\n+//! early return of [`None`] that it provides.\n+//!\n+//! [`?`]: crate::ops::Try\n+//! [`Some`]: Some\n+//! [`None`]: None\n+//!\n //! # Representation\n //!\n //! Rust guarantees to optimize the following types `T` such that"}, {"sha": "f00c40f35d584765176c7c46a708d993bb240326", "filename": "library/core/src/result.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -209,11 +209,10 @@\n //!\n //! *It's much nicer!*\n //!\n-//! Ending the expression with [`?`] will result in the unwrapped\n-//! success ([`Ok`]) value, unless the result is [`Err`], in which case\n-//! [`Err`] is returned early from the enclosing function.\n+//! Ending the expression with [`?`] will result in the [`Ok`]'s unwrapped value, unless the result\n+//! is [`Err`], in which case [`Err`] is returned early from the enclosing function.\n //!\n-//! [`?`] can only be used in functions that return [`Result`] because of the\n+//! [`?`] can be used in functions that return [`Result`] because of the\n //! early return of [`Err`] that it provides.\n //!\n //! [`expect`]: Result::expect"}, {"sha": "c2a509a196344b910131329e9e49d6de0971d92b", "filename": "src/test/ui/array-slice-vec/infer_array_len.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Farray-slice-vec%2Finfer_array_len.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Farray-slice-vec%2Finfer_array_len.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Finfer_array_len.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -6,8 +6,8 @@ LL |     let [_, _] = a.into();\n    |\n help: consider giving this pattern a type\n    |\n-LL |     let [_, _]: _ = a.into();\n-   |               +++\n+LL |     let [_, _]: /* Type */ = a.into();\n+   |               ++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "7a04ed7381e66d198123edeacbee33379f1eb7dc", "filename": "src/test/ui/closure-expected-type/expect-two-infer-vars-supply-ty-with-bound-region.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-two-infer-vars-supply-ty-with-bound-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-two-infer-vars-supply-ty-with-bound-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-two-infer-vars-supply-ty-with-bound-region.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -6,8 +6,8 @@ LL |     with_closure(|x: u32, y| {});\n    |\n help: consider giving this closure parameter an explicit type\n    |\n-LL |     with_closure(|x: u32, y: _| {});\n-   |                            +++\n+LL |     with_closure(|x: u32, y: /* Type */| {});\n+   |                            ++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "9ba24c7a886958ab32b9d2ddfae01774d4438ea0", "filename": "src/test/ui/closures/issue-52437.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fclosures%2Fissue-52437.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fclosures%2Fissue-52437.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-52437.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -12,8 +12,8 @@ LL |     [(); &(&'static: loop { |x| {}; }) as *const _ as usize]\n    |\n help: consider giving this closure parameter an explicit type\n    |\n-LL |     [(); &(&'static: loop { |x: _| {}; }) as *const _ as usize]\n-   |                               +++\n+LL |     [(); &(&'static: loop { |x: /* Type */| {}; }) as *const _ as usize]\n+   |                               ++++++++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "13ea4a295afd75dbc4ee43c746c528e9b6c4ea5b", "filename": "src/test/ui/const-generics/generic_arg_infer/issue-91614.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fissue-91614.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fissue-91614.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fissue-91614.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -5,6 +5,12 @@ LL |     let y = Mask::<_, _>::splat(false);\n    |         ^   ------------------- type must be known at this point\n    |\n    = note: cannot satisfy `_: MaskElement`\n+   = help: the following types implement trait `MaskElement`:\n+             i16\n+             i32\n+             i64\n+             i8\n+             isize\n note: required by a bound in `Mask::<T, LANES>::splat`\n   --> $SRC_DIR/core/src/../../portable-simd/crates/core_simd/src/masks.rs:LL:COL\n help: consider giving `y` an explicit type, where the type for type parameter `T` is specified"}, {"sha": "e28ba3b1adab692e13109fd0570177963ef21843", "filename": "src/test/ui/const-generics/generic_const_exprs/issue-105608.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-105608.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-105608.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-105608.rs?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -0,0 +1,15 @@\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+struct Combination<const STRATEGIES: usize>;\n+\n+impl<const STRATEGIES: usize> Combination<STRATEGIES> {\n+    fn and<M>(self) -> Combination<{ STRATEGIES + 1 }> {\n+        Combination\n+    }\n+}\n+\n+pub fn main() {\n+    Combination::<0>.and::<_>().and::<_>();\n+    //~^ ERROR: type annotations needed\n+}"}, {"sha": "0be4c43daacf8c89a2981605820396d5fe65caf5", "filename": "src/test/ui/const-generics/generic_const_exprs/issue-105608.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-105608.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-105608.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-105608.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -0,0 +1,14 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-105608.rs:13:22\n+   |\n+LL |     Combination::<0>.and::<_>().and::<_>();\n+   |                      ^^^ cannot infer type of the type parameter `M` declared on the associated function `and`\n+   |\n+help: consider specifying the generic argument\n+   |\n+LL |     Combination::<0>.and::<_>().and::<_>();\n+   |                         ~~~~~\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "e0444042614bb683f4a6d0cd8c213b8d4f95977a", "filename": "src/test/ui/const-generics/generic_const_exprs/issue-72787.min.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-72787.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-72787.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-72787.min.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -41,6 +41,7 @@ LL |     IsLessOrEqual<I, 8>: True,\n    |                          ^^^^\n    |\n    = note: cannot satisfy `IsLessOrEqual<I, 8>: True`\n+   = help: the trait `True` is implemented for `IsLessOrEqual<LHS, RHS>`\n \n error[E0283]: type annotations needed: cannot satisfy `IsLessOrEqual<I, 8>: True`\n   --> $DIR/issue-72787.rs:21:26\n@@ -49,6 +50,7 @@ LL |     IsLessOrEqual<I, 8>: True,\n    |                          ^^^^\n    |\n    = note: cannot satisfy `IsLessOrEqual<I, 8>: True`\n+   = help: the trait `True` is implemented for `IsLessOrEqual<LHS, RHS>`\n \n error: aborting due to 6 previous errors\n "}, {"sha": "7491fdc8a693e413a79937c04443cdad93df9995", "filename": "src/test/ui/const-generics/issues/issue-83249.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83249.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83249.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83249.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -6,8 +6,8 @@ LL |     let _ = foo([0; 1]);\n    |\n help: consider giving this pattern a type\n    |\n-LL |     let _: _ = foo([0; 1]);\n-   |          +++\n+LL |     let _: /* Type */ = foo([0; 1]);\n+   |          ++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "892d3a81f27f9543e5b87663e64dcb3e2894cb21", "filename": "src/test/ui/error-codes/E0282.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Ferror-codes%2FE0282.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Ferror-codes%2FE0282.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0282.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -6,8 +6,8 @@ LL |     let x = \"hello\".chars().rev().collect();\n    |\n help: consider giving `x` an explicit type\n    |\n-LL |     let x: _ = \"hello\".chars().rev().collect();\n-   |          +++\n+LL |     let x: Vec<_> = \"hello\".chars().rev().collect();\n+   |          ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "fa4b91cacef7261c169b3692128daa38199f88af", "filename": "src/test/ui/error-codes/E0401.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -59,7 +59,7 @@ note: required by a bound in `bfnr`\n    |\n LL |     fn bfnr<U, V: Baz<U>, W: Fn()>(y: T) {\n    |                              ^^^^ required by this bound in `bfnr`\n-help: consider specifying the type arguments in the function call\n+help: consider specifying the generic arguments\n    |\n LL |     bfnr::<U, V, W>(x);\n    |         +++++++++++"}, {"sha": "deb84f6fe97cfd5d4d2560ec586c2d16f772847b", "filename": "src/test/ui/illegal-sized-bound/mutability-mismatch.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fillegal-sized-bound%2Fmutability-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fillegal-sized-bound%2Fmutability-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fillegal-sized-bound%2Fmutability-mismatch.rs?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -0,0 +1,34 @@\n+struct MutType;\n+\n+pub trait MutTrait {\n+    fn function(&mut self)\n+    where\n+        Self: Sized;\n+    //~^ this has a `Sized` requirement\n+}\n+\n+impl MutTrait for MutType {\n+    fn function(&mut self) {}\n+}\n+\n+struct Type;\n+\n+pub trait Trait {\n+    fn function(&self)\n+    where\n+        Self: Sized;\n+    //~^ this has a `Sized` requirement\n+}\n+\n+impl Trait for Type {\n+    fn function(&self) {}\n+}\n+\n+fn main() {\n+    (&MutType as &dyn MutTrait).function();\n+    //~^ ERROR the `function` method cannot be invoked on a trait object\n+    //~| NOTE you need `&mut dyn MutTrait` instead of `&dyn MutTrait`\n+    (&mut Type as &mut dyn Trait).function();\n+    //~^ ERROR the `function` method cannot be invoked on a trait object\n+    //~| NOTE you need `&dyn Trait` instead of `&mut dyn Trait`\n+}"}, {"sha": "dbbf79a4f1a034f08b771dc12e1af7b34e0b7532", "filename": "src/test/ui/illegal-sized-bound/mutability-mismatch.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fillegal-sized-bound%2Fmutability-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fillegal-sized-bound%2Fmutability-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fillegal-sized-bound%2Fmutability-mismatch.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -0,0 +1,24 @@\n+error: the `function` method cannot be invoked on a trait object\n+  --> $DIR/mutability-mismatch.rs:28:33\n+   |\n+LL |         Self: Sized;\n+   |               ----- this has a `Sized` requirement\n+...\n+LL |     (&MutType as &dyn MutTrait).function();\n+   |                                 ^^^^^^^^\n+   |\n+   = note: you need `&mut dyn MutTrait` instead of `&dyn MutTrait`\n+\n+error: the `function` method cannot be invoked on a trait object\n+  --> $DIR/mutability-mismatch.rs:31:35\n+   |\n+LL |         Self: Sized;\n+   |               ----- this has a `Sized` requirement\n+...\n+LL |     (&mut Type as &mut dyn Trait).function();\n+   |                                   ^^^^^^^^\n+   |\n+   = note: you need `&dyn Trait` instead of `&mut dyn Trait`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "7abd27ef98318b1117790aebf4f486c53937e930", "filename": "src/test/ui/illegal-sized-bound/regular.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fillegal-sized-bound%2Fregular.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fillegal-sized-bound%2Fregular.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fillegal-sized-bound%2Fregular.rs?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -0,0 +1,32 @@\n+struct MutType;\n+\n+pub trait MutTrait {\n+    fn function(&mut self)\n+    where\n+        Self: Sized;\n+    //~^ this has a `Sized` requirement\n+}\n+\n+impl MutTrait for MutType {\n+    fn function(&mut self) {}\n+}\n+\n+struct Type;\n+\n+pub trait Trait {\n+    fn function(&self)\n+    where\n+        Self: Sized;\n+    //~^ this has a `Sized` requirement\n+}\n+\n+impl Trait for Type {\n+    fn function(&self) {}\n+}\n+\n+fn main() {\n+    (&mut MutType as &mut dyn MutTrait).function();\n+    //~^ ERROR the `function` method cannot be invoked on a trait object\n+    (&Type as &dyn Trait).function();\n+    //~^ ERROR the `function` method cannot be invoked on a trait object\n+}"}, {"sha": "7f3744145d92723c22d903d4cb097c6a98b9a6bb", "filename": "src/test/ui/illegal-sized-bound/regular.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fillegal-sized-bound%2Fregular.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fillegal-sized-bound%2Fregular.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fillegal-sized-bound%2Fregular.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -0,0 +1,20 @@\n+error: the `function` method cannot be invoked on a trait object\n+  --> $DIR/regular.rs:28:41\n+   |\n+LL |         Self: Sized;\n+   |               ----- this has a `Sized` requirement\n+...\n+LL |     (&mut MutType as &mut dyn MutTrait).function();\n+   |                                         ^^^^^^^^\n+\n+error: the `function` method cannot be invoked on a trait object\n+  --> $DIR/regular.rs:30:27\n+   |\n+LL |         Self: Sized;\n+   |               ----- this has a `Sized` requirement\n+...\n+LL |     (&Type as &dyn Trait).function();\n+   |                           ^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "7592418fdfd62f412eeef998debec2ea78919c30", "filename": "src/test/ui/impl-trait/issues/issue-86719.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86719.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86719.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86719.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -20,8 +20,8 @@ LL |         |_| true\n    |\n help: consider giving this closure parameter an explicit type\n    |\n-LL |         |_: _| true\n-   |           +++\n+LL |         |_: /* Type */| true\n+   |           ++++++++++++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "9be18286480113cb04682887824884706c221faf", "filename": "src/test/ui/inference/erase-type-params-in-label.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Finference%2Ferase-type-params-in-label.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Finference%2Ferase-type-params-in-label.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Ferase-type-params-in-label.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -10,10 +10,10 @@ note: required by a bound in `foo`\n    |\n LL | fn foo<T, K, W: Default, Z: Default>(t: T, k: K) -> Foo<T, K, W, Z> {\n    |                 ^^^^^^^ required by this bound in `foo`\n-help: consider specifying the type arguments in the function call\n+help: consider giving `foo` an explicit type, where the type for type parameter `W` is specified\n    |\n-LL |     let foo = foo::<T, K, W, Z>(1, \"\");\n-   |                  ++++++++++++++\n+LL |     let foo: Foo<i32, &str, W, Z> = foo(1, \"\");\n+   |            ++++++++++++++++++++++\n \n error[E0283]: type annotations needed for `Bar<i32, &str, Z>`\n   --> $DIR/erase-type-params-in-label.rs:5:9\n@@ -27,10 +27,10 @@ note: required by a bound in `bar`\n    |\n LL | fn bar<T, K, Z: Default>(t: T, k: K) -> Bar<T, K, Z> {\n    |                 ^^^^^^^ required by this bound in `bar`\n-help: consider specifying the type arguments in the function call\n+help: consider giving `bar` an explicit type, where the type for type parameter `Z` is specified\n    |\n-LL |     let bar = bar::<T, K, Z>(1, \"\");\n-   |                  +++++++++++\n+LL |     let bar: Bar<i32, &str, Z> = bar(1, \"\");\n+   |            +++++++++++++++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "8eda71ec09bd3bf1410fb293eb00232808ea7508", "filename": "src/test/ui/inference/issue-72690.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Finference%2Fissue-72690.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Finference%2Fissue-72690.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fissue-72690.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -32,8 +32,8 @@ LL |     |x| String::from(\"x\".as_ref());\n    |\n help: consider giving this closure parameter an explicit type\n    |\n-LL |     |x: _| String::from(\"x\".as_ref());\n-   |       +++\n+LL |     |x: /* Type */| String::from(\"x\".as_ref());\n+   |       ++++++++++++\n \n error[E0283]: type annotations needed\n   --> $DIR/issue-72690.rs:12:26"}, {"sha": "5e0589eed435d0240aefb3f4eddf4f34506f326e", "filename": "src/test/ui/issues/issue-18159.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fissues%2Fissue-18159.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fissues%2Fissue-18159.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18159.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -6,8 +6,8 @@ LL |     let x;\n    |\n help: consider giving `x` an explicit type\n    |\n-LL |     let x: _;\n-   |          +++\n+LL |     let x: /* Type */;\n+   |          ++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "c75038b6169c0a227995a7c9de27ff581ca6d42a", "filename": "src/test/ui/issues/issue-2151.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fissues%2Fissue-2151.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fissues%2Fissue-2151.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-2151.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -8,8 +8,8 @@ LL |     x.clone();\n    |\n help: consider giving `x` an explicit type\n    |\n-LL |     let x: _ = panic!();\n-   |          +++\n+LL |     let x: /* Type */ = panic!();\n+   |          ++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "0e73a51faed9ac8bf07d4e299f465ab11f114fa3", "filename": "src/test/ui/issues/issue-24036.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fissues%2Fissue-24036.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fissues%2Fissue-24036.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24036.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -19,8 +19,8 @@ LL |         1 => |c| c + 1,\n    |\n help: consider giving this closure parameter an explicit type\n    |\n-LL |         1 => |c: _| c + 1,\n-   |                +++\n+LL |         1 => |c: /* Type */| c + 1,\n+   |                ++++++++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "fe2631f9474205a617c9398f0cfb5709aa8875f4", "filename": "src/test/ui/lazy-type-alias-impl-trait/branches3.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches3.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -6,8 +6,8 @@ LL |         |s| s.len()\n    |\n help: consider giving this closure parameter an explicit type\n    |\n-LL |         |s: _| s.len()\n-   |           +++\n+LL |         |s: /* Type */| s.len()\n+   |           ++++++++++++\n \n error[E0282]: type annotations needed\n   --> $DIR/branches3.rs:15:10\n@@ -17,8 +17,8 @@ LL |         |s| s.len()\n    |\n help: consider giving this closure parameter an explicit type\n    |\n-LL |         |s: _| s.len()\n-   |           +++\n+LL |         |s: /* Type */| s.len()\n+   |           ++++++++++++\n \n error[E0282]: type annotations needed\n   --> $DIR/branches3.rs:23:10\n@@ -28,8 +28,8 @@ LL |         |s| s.len()\n    |\n help: consider giving this closure parameter an explicit type\n    |\n-LL |         |s: _| s.len()\n-   |           +++\n+LL |         |s: /* Type */| s.len()\n+   |           ++++++++++++\n \n error[E0282]: type annotations needed\n   --> $DIR/branches3.rs:30:10\n@@ -39,8 +39,8 @@ LL |         |s| s.len()\n    |\n help: consider giving this closure parameter an explicit type\n    |\n-LL |         |s: _| s.len()\n-   |           +++\n+LL |         |s: /* Type */| s.len()\n+   |           ++++++++++++\n \n error: aborting due to 4 previous errors\n "}, {"sha": "a332c6547b8390c36268abff095edfc39bbf8ee4", "filename": "src/test/ui/lifetimes/issue-34979.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Flifetimes%2Fissue-34979.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Flifetimes%2Fissue-34979.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fissue-34979.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -5,6 +5,7 @@ LL |     &'a (): Foo,\n    |             ^^^\n    |\n    = note: cannot satisfy `&'a (): Foo`\n+   = help: the trait `Foo` is implemented for `&'a T`\n \n error: aborting due to previous error\n "}, {"sha": "e3b501b2fd558c42ad720ba709aac0abf2d327d1", "filename": "src/test/ui/match/match-unresolved-one-arm.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fmatch%2Fmatch-unresolved-one-arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fmatch%2Fmatch-unresolved-one-arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-unresolved-one-arm.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -6,8 +6,8 @@ LL |     let x = match () {\n    |\n help: consider giving `x` an explicit type\n    |\n-LL |     let x: _ = match () {\n-   |          +++\n+LL |     let x: /* Type */ = match () {\n+   |          ++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "f00cde4a74c02980fb69454ce12a175f68880fe8", "filename": "src/test/ui/numeric/uppercase-base-prefix-invalid-no-fix.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fnumeric%2Fuppercase-base-prefix-invalid-no-fix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fnumeric%2Fuppercase-base-prefix-invalid-no-fix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumeric%2Fuppercase-base-prefix-invalid-no-fix.rs?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -0,0 +1,34 @@\n+// Checks that integers with seeming uppercase base prefixes do not get bogus capitalization\n+// suggestions.\n+\n+fn main() {\n+    _ = 123X1a3;\n+    //~^ ERROR invalid suffix `X1a3` for number literal\n+    //~| NOTE invalid suffix `X1a3`\n+    //~| HELP the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n+\n+    _ = 456O123;\n+    //~^ ERROR invalid suffix `O123` for number literal\n+    //~| NOTE invalid suffix `O123`\n+    //~| HELP the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n+\n+    _ = 789B101;\n+    //~^ ERROR invalid suffix `B101` for number literal\n+    //~| NOTE invalid suffix `B101`\n+    //~| HELP the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n+\n+    _ = 0XYZ;\n+    //~^ ERROR invalid suffix `XYZ` for number literal\n+    //~| NOTE invalid suffix `XYZ`\n+    //~| HELP the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n+\n+    _ = 0OPQ;\n+    //~^ ERROR invalid suffix `OPQ` for number literal\n+    //~| NOTE invalid suffix `OPQ`\n+    //~| HELP the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n+\n+    _ = 0BCD;\n+    //~^ ERROR invalid suffix `BCD` for number literal\n+    //~| NOTE invalid suffix `BCD`\n+    //~| HELP the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n+}"}, {"sha": "380c16ca789f4ed395fac22de5f91f3eeb5b4973", "filename": "src/test/ui/numeric/uppercase-base-prefix-invalid-no-fix.stderr", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fnumeric%2Fuppercase-base-prefix-invalid-no-fix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fnumeric%2Fuppercase-base-prefix-invalid-no-fix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumeric%2Fuppercase-base-prefix-invalid-no-fix.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -0,0 +1,50 @@\n+error: invalid suffix `X1a3` for number literal\n+  --> $DIR/uppercase-base-prefix-invalid-no-fix.rs:5:9\n+   |\n+LL |     _ = 123X1a3;\n+   |         ^^^^^^^ invalid suffix `X1a3`\n+   |\n+   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n+\n+error: invalid suffix `O123` for number literal\n+  --> $DIR/uppercase-base-prefix-invalid-no-fix.rs:10:9\n+   |\n+LL |     _ = 456O123;\n+   |         ^^^^^^^ invalid suffix `O123`\n+   |\n+   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n+\n+error: invalid suffix `B101` for number literal\n+  --> $DIR/uppercase-base-prefix-invalid-no-fix.rs:15:9\n+   |\n+LL |     _ = 789B101;\n+   |         ^^^^^^^ invalid suffix `B101`\n+   |\n+   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n+\n+error: invalid suffix `XYZ` for number literal\n+  --> $DIR/uppercase-base-prefix-invalid-no-fix.rs:20:9\n+   |\n+LL |     _ = 0XYZ;\n+   |         ^^^^ invalid suffix `XYZ`\n+   |\n+   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n+\n+error: invalid suffix `OPQ` for number literal\n+  --> $DIR/uppercase-base-prefix-invalid-no-fix.rs:25:9\n+   |\n+LL |     _ = 0OPQ;\n+   |         ^^^^ invalid suffix `OPQ`\n+   |\n+   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n+\n+error: invalid suffix `BCD` for number literal\n+  --> $DIR/uppercase-base-prefix-invalid-no-fix.rs:30:9\n+   |\n+LL |     _ = 0BCD;\n+   |         ^^^^ invalid suffix `BCD`\n+   |\n+   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "ad26643c327945ab2bca04fcae23d0651edf19b4", "filename": "src/test/ui/parser/issue-105366.fixed", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fparser%2Fissue-105366.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fparser%2Fissue-105366.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-105366.fixed?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -0,0 +1,12 @@\n+// run-rustfix\n+\n+struct Foo;\n+\n+impl From<i32> for Foo {\n+    //~^ ERROR you might have meant to write `impl` instead of `fn`\n+    fn from(_a: i32) -> Self {\n+        Foo\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "311b6a60f1a27b23ced853fc38178b582bf6bd48", "filename": "src/test/ui/parser/issue-105366.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fparser%2Fissue-105366.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fparser%2Fissue-105366.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-105366.rs?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -0,0 +1,12 @@\n+// run-rustfix\n+\n+struct Foo;\n+\n+fn From<i32> for Foo {\n+    //~^ ERROR you might have meant to write `impl` instead of `fn`\n+    fn from(_a: i32) -> Self {\n+        Foo\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "0a7408e2c173f0fc00f111e4323136d97bb4c257", "filename": "src/test/ui/parser/issue-105366.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fparser%2Fissue-105366.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fparser%2Fissue-105366.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-105366.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -0,0 +1,13 @@\n+error: you might have meant to write `impl` instead of `fn`\n+  --> $DIR/issue-105366.rs:5:1\n+   |\n+LL | fn From<i32> for Foo {\n+   | ^^\n+   |\n+help: replace `fn` with `impl` here\n+   |\n+LL | impl From<i32> for Foo {\n+   | ~~~~\n+\n+error: aborting due to previous error\n+"}, {"sha": "da369d33397fc0c5df6f2b6739a727b920d9e86c", "filename": "src/test/ui/pattern/pat-tuple-bad-type.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-bad-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-bad-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-bad-type.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -9,8 +9,8 @@ LL |         (..) => {}\n    |\n help: consider giving `x` an explicit type\n    |\n-LL |     let x: _;\n-   |          +++\n+LL |     let x: /* Type */;\n+   |          ++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/pat-tuple-bad-type.rs:10:9"}, {"sha": "beba7def96f5236034d546819979f3e0f4b7eb17", "filename": "src/test/ui/pattern/rest-pat-semantic-disallowed.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fpattern%2Frest-pat-semantic-disallowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fpattern%2Frest-pat-semantic-disallowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Frest-pat-semantic-disallowed.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -193,8 +193,8 @@ LL |     let x @ ..;\n    |\n help: consider giving this pattern a type\n    |\n-LL |     let x @ ..: _;\n-   |               +++\n+LL |     let x @ ..: /* Type */;\n+   |               ++++++++++++\n \n error: aborting due to 23 previous errors\n "}, {"sha": "42b43f825d10c28711b7f3f450da977f855124fe", "filename": "src/test/ui/resolve/issue-85348.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fresolve%2Fissue-85348.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fresolve%2Fissue-85348.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-85348.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -21,8 +21,8 @@ LL |         let mut N;\n    |\n help: consider giving `N` an explicit type\n    |\n-LL |         let mut N: _;\n-   |                  +++\n+LL |         let mut N: /* Type */;\n+   |                  ++++++++++++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "f6efbe40bc23457047427cfc5a90cb9af723d3f6", "filename": "src/test/ui/span/method-and-field-eager-resolution.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fspan%2Fmethod-and-field-eager-resolution.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Fspan%2Fmethod-and-field-eager-resolution.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmethod-and-field-eager-resolution.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -9,8 +9,8 @@ LL |     x.0;\n    |\n help: consider giving `x` an explicit type\n    |\n-LL |     let mut x: _ = Default::default();\n-   |              +++\n+LL |     let mut x: /* Type */ = Default::default();\n+   |              ++++++++++++\n \n error[E0282]: type annotations needed\n   --> $DIR/method-and-field-eager-resolution.rs:11:9\n@@ -23,8 +23,8 @@ LL |     x[0];\n    |\n help: consider giving `x` an explicit type\n    |\n-LL |     let mut x: _ = Default::default();\n-   |              +++\n+LL |     let mut x: /* Type */ = Default::default();\n+   |              ++++++++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0b57a8212bdc63495ca6cb6ee4b0a08d0056b067", "filename": "src/test/ui/traits/issue-77982.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Ftraits%2Fissue-77982.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Ftraits%2Fissue-77982.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-77982.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -43,7 +43,15 @@ LL |     let ips: Vec<_> = (0..100_000).map(|_| u32::from(0u32.into())).collect(\n    |                                            |\n    |                                            required by a bound introduced by this call\n    |\n-   = note: cannot satisfy `u32: From<_>`\n+   = note: multiple `impl`s satisfying `u32: From<_>` found in the following crates: `core`, `std`:\n+           - impl From<Ipv4Addr> for u32;\n+           - impl From<NonZeroU32> for u32;\n+           - impl From<bool> for u32;\n+           - impl From<char> for u32;\n+           - impl From<u16> for u32;\n+           - impl From<u8> for u32;\n+           - impl<T> From<!> for T;\n+           - impl<T> From<T> for T;\n help: try using a fully qualified path to specify the expected types\n    |\n LL |     let ips: Vec<_> = (0..100_000).map(|_| u32::from(<u32 as Into<T>>::into(0u32))).collect();"}, {"sha": "930708f9ad80c7d35ed8a153a869331f826a831e", "filename": "src/test/ui/traits/issue-85735.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Ftraits%2Fissue-85735.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Ftraits%2Fissue-85735.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-85735.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -5,6 +5,9 @@ LL |     T: FnMut(&'a ()),\n    |        ^^^^^^^^^^^^^\n    |\n    = note: cannot satisfy `T: FnMut<(&'a (),)>`\n+   = help: the following types implement trait `FnMut<Args>`:\n+             &F\n+             &mut F\n \n error: aborting due to previous error\n "}, {"sha": "ea3d1bf853a491b31c5da0cb6b089a7c33f9f83f", "filename": "src/test/ui/traits/suggest-deferences/suggest-dereferencing-receiver-argument.fixed", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fsuggest-dereferencing-receiver-argument.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fsuggest-dereferencing-receiver-argument.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fsuggest-dereferencing-receiver-argument.fixed?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -0,0 +1,14 @@\n+// run-rustfix\n+\n+struct TargetStruct;\n+\n+impl From<usize> for TargetStruct {\n+    fn from(_unchecked: usize) -> Self {\n+        TargetStruct\n+    }\n+}\n+\n+fn main() {\n+    let a = &3;\n+    let _b: TargetStruct = (*a).into(); //~ ERROR the trait bound `TargetStruct: From<&{integer}>` is not satisfied\n+}"}, {"sha": "9eda68027b23ec5f28144eba12f03d0f5d4093b4", "filename": "src/test/ui/traits/suggest-deferences/suggest-dereferencing-receiver-argument.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fsuggest-dereferencing-receiver-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fsuggest-dereferencing-receiver-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fsuggest-dereferencing-receiver-argument.rs?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -0,0 +1,14 @@\n+// run-rustfix\n+\n+struct TargetStruct;\n+\n+impl From<usize> for TargetStruct {\n+    fn from(_unchecked: usize) -> Self {\n+        TargetStruct\n+    }\n+}\n+\n+fn main() {\n+    let a = &3;\n+    let _b: TargetStruct = a.into(); //~ ERROR the trait bound `TargetStruct: From<&{integer}>` is not satisfied\n+}"}, {"sha": "ede31a2c7bcf1be8835dcc8fb33b7d19ef002165", "filename": "src/test/ui/traits/suggest-deferences/suggest-dereferencing-receiver-argument.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fsuggest-dereferencing-receiver-argument.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fsuggest-dereferencing-receiver-argument.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fsuggest-dereferencing-receiver-argument.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `TargetStruct: From<&{integer}>` is not satisfied\n+  --> $DIR/suggest-dereferencing-receiver-argument.rs:13:30\n+   |\n+LL |     let _b: TargetStruct = a.into();\n+   |                              ^^^^ the trait `From<&{integer}>` is not implemented for `TargetStruct`\n+   |\n+   = note: required for `&{integer}` to implement `Into<TargetStruct>`\n+help: consider dereferencing here\n+   |\n+LL |     let _b: TargetStruct = (*a).into();\n+   |                            ++ +\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "9cc15f14a991d5516050b277133921024cfbd0cd", "filename": "src/test/ui/type-alias-impl-trait/closures_in_branches.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fclosures_in_branches.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fclosures_in_branches.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fclosures_in_branches.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -6,8 +6,8 @@ LL |         |x| x.len()\n    |\n help: consider giving this closure parameter an explicit type\n    |\n-LL |         |x: _| x.len()\n-   |           +++\n+LL |         |x: /* Type */| x.len()\n+   |           ++++++++++++\n \n error[E0282]: type annotations needed\n   --> $DIR/closures_in_branches.rs:21:10\n@@ -17,8 +17,8 @@ LL |         |x| x.len()\n    |\n help: consider giving this closure parameter an explicit type\n    |\n-LL |         |x: _| x.len()\n-   |           +++\n+LL |         |x: /* Type */| x.len()\n+   |           ++++++++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "87bba3166be6a3cde426e54f1b4f57c8023bd791", "filename": "src/test/ui/type/type-annotation-needed.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Ftype%2Ftype-annotation-needed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Ftype%2Ftype-annotation-needed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-annotation-needed.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -10,7 +10,7 @@ note: required by a bound in `foo`\n    |\n LL | fn foo<T: Into<String>>(x: i32) {}\n    |           ^^^^^^^^^^^^ required by this bound in `foo`\n-help: consider specifying the type argument in the function call\n+help: consider specifying the generic argument\n    |\n LL |     foo::<T>(42);\n    |        +++++"}, {"sha": "e5e29aabf374b03d7609c70f75b12fd2dd40322c", "filename": "src/test/ui/type/type-check/unknown_type_for_closure.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Funknown_type_for_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Funknown_type_for_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Funknown_type_for_closure.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -12,8 +12,8 @@ LL |     let x = |_| {};\n    |\n help: consider giving this closure parameter an explicit type\n    |\n-LL |     let x = |_: _| {};\n-   |               +++\n+LL |     let x = |_: /* Type */| {};\n+   |               ++++++++++++\n \n error[E0282]: type annotations needed\n   --> $DIR/unknown_type_for_closure.rs:10:14"}, {"sha": "1aed1dbe4babd21662ce83308a7bcdc0f1e66983", "filename": "src/test/ui/type/type-path-err-node-types.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Ftype%2Ftype-path-err-node-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdda8f801818c1e9455725a964a3fa4f02c2bb8/src%2Ftest%2Fui%2Ftype%2Ftype-path-err-node-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-path-err-node-types.stderr?ref=7bdda8f801818c1e9455725a964a3fa4f02c2bb8", "patch": "@@ -30,8 +30,8 @@ LL |     let _ = |a, b: _| -> _ { 0 };\n    |\n help: consider giving this closure parameter an explicit type\n    |\n-LL |     let _ = |a: _, b: _| -> _ { 0 };\n-   |               +++\n+LL |     let _ = |a: /* Type */, b: _| -> _ { 0 };\n+   |               ++++++++++++\n \n error: aborting due to 5 previous errors\n "}]}