{"sha": "ed3ddb375bf18099a885605efba94dc1e50379d7", "node_id": "C_kwDOAAsO6NoAKGVkM2RkYjM3NWJmMTgwOTlhODg1NjA1ZWZiYTk0ZGMxZTUwMzc5ZDc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-25T04:58:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-25T04:58:54Z"}, "message": "Auto merge of #110789 - matthiaskrgr:rollup-92e764u, r=matthiaskrgr\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #110563 (Break up long function in trait selection error reporting + clean up nearby code)\n - #110755 ([LLVM17] Adapt to `ExplicitEmulatedTLS` removal.)\n - #110775 (Update books)\n - #110779 (configure.py: add flag for riscv{64,32}gc musl-root)\n - #110782 (Revert panic oom)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "66afe302b8efddeef9f8a787ab8c97f1e7d74102", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66afe302b8efddeef9f8a787ab8c97f1e7d74102"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed3ddb375bf18099a885605efba94dc1e50379d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed3ddb375bf18099a885605efba94dc1e50379d7", "html_url": "https://github.com/rust-lang/rust/commit/ed3ddb375bf18099a885605efba94dc1e50379d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed3ddb375bf18099a885605efba94dc1e50379d7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6830a212973ced91a047cee86cb79cee4f23868", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6830a212973ced91a047cee86cb79cee4f23868", "html_url": "https://github.com/rust-lang/rust/commit/f6830a212973ced91a047cee86cb79cee4f23868"}, {"sha": "2d72abc8f24d0af3b0344cbee14130eaaf90f75f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d72abc8f24d0af3b0344cbee14130eaaf90f75f", "html_url": "https://github.com/rust-lang/rust/commit/2d72abc8f24d0af3b0344cbee14130eaaf90f75f"}], "stats": {"total": 2152, "additions": 1570, "deletions": 582}, "files": [{"sha": "fca6012a408c1d0223791027c28ed5348aae64aa", "filename": "compiler/rustc_builtin_macros/messages.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fmessages.ftl?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -4,6 +4,8 @@ builtin_macros_requires_cfg_pattern =\n \n builtin_macros_expected_one_cfg_pattern = expected 1 cfg-pattern\n \n+builtin_macros_alloc_error_must_be_fn = alloc_error_handler must be a function\n+\n builtin_macros_assert_requires_boolean = macro requires a boolean expression as an argument\n     .label = boolean expression required\n "}, {"sha": "82bae9157e79d173e760a685968bafa4fa090a72", "filename": "compiler/rustc_builtin_macros/src/alloc_error_handler.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -0,0 +1,97 @@\n+use crate::errors;\n+use crate::util::check_builtin_macro_attribute;\n+\n+use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, FnHeader, FnSig, Generics, StmtKind};\n+use rustc_ast::{Fn, ItemKind, Stmt, TyKind, Unsafe};\n+use rustc_expand::base::{Annotatable, ExtCtxt};\n+use rustc_span::symbol::{kw, sym, Ident};\n+use rustc_span::Span;\n+use thin_vec::{thin_vec, ThinVec};\n+\n+pub fn expand(\n+    ecx: &mut ExtCtxt<'_>,\n+    _span: Span,\n+    meta_item: &ast::MetaItem,\n+    item: Annotatable,\n+) -> Vec<Annotatable> {\n+    check_builtin_macro_attribute(ecx, meta_item, sym::alloc_error_handler);\n+\n+    let orig_item = item.clone();\n+\n+    // Allow using `#[alloc_error_handler]` on an item statement\n+    // FIXME - if we get deref patterns, use them to reduce duplication here\n+    let (item, is_stmt, sig_span) =\n+        if let Annotatable::Item(item) = &item\n+            && let ItemKind::Fn(fn_kind) = &item.kind\n+        {\n+            (item, false, ecx.with_def_site_ctxt(fn_kind.sig.span))\n+        } else if let Annotatable::Stmt(stmt) = &item\n+            && let StmtKind::Item(item) = &stmt.kind\n+            && let ItemKind::Fn(fn_kind) = &item.kind\n+        {\n+            (item, true, ecx.with_def_site_ctxt(fn_kind.sig.span))\n+        } else {\n+            ecx.sess.parse_sess.span_diagnostic.emit_err(errors::AllocErrorMustBeFn {span: item.span() });\n+            return vec![orig_item];\n+        };\n+\n+    // Generate a bunch of new items using the AllocFnFactory\n+    let span = ecx.with_def_site_ctxt(item.span);\n+\n+    // Generate item statements for the allocator methods.\n+    let stmts = thin_vec![generate_handler(ecx, item.ident, span, sig_span)];\n+\n+    // Generate anonymous constant serving as container for the allocator methods.\n+    let const_ty = ecx.ty(sig_span, TyKind::Tup(ThinVec::new()));\n+    let const_body = ecx.expr_block(ecx.block(span, stmts));\n+    let const_item = ecx.item_const(span, Ident::new(kw::Underscore, span), const_ty, const_body);\n+    let const_item = if is_stmt {\n+        Annotatable::Stmt(P(ecx.stmt_item(span, const_item)))\n+    } else {\n+        Annotatable::Item(const_item)\n+    };\n+\n+    // Return the original item and the new methods.\n+    vec![orig_item, const_item]\n+}\n+\n+// #[rustc_std_internal_symbol]\n+// unsafe fn __rg_oom(size: usize, align: usize) -> ! {\n+//     handler(core::alloc::Layout::from_size_align_unchecked(size, align))\n+// }\n+fn generate_handler(cx: &ExtCtxt<'_>, handler: Ident, span: Span, sig_span: Span) -> Stmt {\n+    let usize = cx.path_ident(span, Ident::new(sym::usize, span));\n+    let ty_usize = cx.ty_path(usize);\n+    let size = Ident::from_str_and_span(\"size\", span);\n+    let align = Ident::from_str_and_span(\"align\", span);\n+\n+    let layout_new = cx.std_path(&[sym::alloc, sym::Layout, sym::from_size_align_unchecked]);\n+    let layout_new = cx.expr_path(cx.path(span, layout_new));\n+    let layout = cx.expr_call(\n+        span,\n+        layout_new,\n+        thin_vec![cx.expr_ident(span, size), cx.expr_ident(span, align)],\n+    );\n+\n+    let call = cx.expr_call_ident(sig_span, handler, thin_vec![layout]);\n+\n+    let never = ast::FnRetTy::Ty(cx.ty(span, TyKind::Never));\n+    let params = thin_vec![cx.param(span, size, ty_usize.clone()), cx.param(span, align, ty_usize)];\n+    let decl = cx.fn_decl(params, never);\n+    let header = FnHeader { unsafety: Unsafe::Yes(span), ..FnHeader::default() };\n+    let sig = FnSig { decl, header, span: span };\n+\n+    let body = Some(cx.block_expr(call));\n+    let kind = ItemKind::Fn(Box::new(Fn {\n+        defaultness: ast::Defaultness::Final,\n+        sig,\n+        generics: Generics::default(),\n+        body,\n+    }));\n+\n+    let attrs = thin_vec![cx.attr_word(sym::rustc_std_internal_symbol, span)];\n+\n+    let item = cx.item(span, Ident::from_str_and_span(\"__rg_oom\", span), attrs, kind);\n+    cx.stmt_item(sig_span, item)\n+}"}, {"sha": "630f9b87bc3ea0bc37f79a488a2854e148619121", "filename": "compiler/rustc_builtin_macros/src/errors.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_builtin_macros%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_builtin_macros%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ferrors.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -19,6 +19,13 @@ pub(crate) struct OneCfgPattern {\n     pub(crate) span: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_alloc_error_must_be_fn)]\n+pub(crate) struct AllocErrorMustBeFn {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(builtin_macros_assert_requires_boolean)]\n pub(crate) struct AssertRequiresBoolean {"}, {"sha": "8f86ef44aa3ab8f6d07d8a1f19680e27b9d17ebc", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -27,6 +27,7 @@ use rustc_expand::proc_macro::BangProcMacro;\n use rustc_fluent_macro::fluent_messages;\n use rustc_span::symbol::sym;\n \n+mod alloc_error_handler;\n mod assert;\n mod cfg;\n mod cfg_accessible;\n@@ -103,6 +104,7 @@ pub fn register_builtin_macros(resolver: &mut dyn ResolverExpand) {\n     }\n \n     register_attr! {\n+        alloc_error_handler: alloc_error_handler::expand,\n         bench: test::expand_bench,\n         cfg_accessible: cfg_accessible::Expander,\n         cfg_eval: cfg_eval::expand,"}, {"sha": "4ede2fe4efe82777918ed7cebcefbfe13137872d", "filename": "compiler/rustc_codegen_cranelift/example/alloc_example.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -1,4 +1,4 @@\n-#![feature(start, core_intrinsics)]\n+#![feature(start, core_intrinsics, alloc_error_handler)]\n #![no_std]\n \n extern crate alloc;\n@@ -22,6 +22,11 @@ fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n     core::intrinsics::abort();\n }\n \n+#[alloc_error_handler]\n+fn alloc_error_handler(_: alloc::alloc::Layout) -> ! {\n+    core::intrinsics::abort();\n+}\n+\n #[start]\n fn main(_argc: isize, _argv: *const *const u8) -> isize {\n     let world: Box<&str> = Box::new(\"Hello World!\\0\");"}, {"sha": "2c246ceb37d54fa43940774b79a359f39c346da3", "filename": "compiler/rustc_codegen_cranelift/src/allocator.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -6,6 +6,7 @@ use crate::prelude::*;\n use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n use rustc_codegen_ssa::base::allocator_kind_for_codegen;\n use rustc_session::config::OomStrategy;\n+use rustc_span::symbol::sym;\n \n /// Returns whether an allocator shim was created\n pub(crate) fn codegen(\n@@ -14,14 +15,21 @@ pub(crate) fn codegen(\n     unwind_context: &mut UnwindContext,\n ) -> bool {\n     let Some(kind) = allocator_kind_for_codegen(tcx) else { return false };\n-    codegen_inner(module, unwind_context, kind, tcx.sess.opts.unstable_opts.oom);\n+    codegen_inner(\n+        module,\n+        unwind_context,\n+        kind,\n+        tcx.alloc_error_handler_kind(()).unwrap(),\n+        tcx.sess.opts.unstable_opts.oom,\n+    );\n     true\n }\n \n fn codegen_inner(\n     module: &mut impl Module,\n     unwind_context: &mut UnwindContext,\n     kind: AllocatorKind,\n+    alloc_error_handler_kind: AllocatorKind,\n     oom_strategy: OomStrategy,\n ) {\n     let usize_ty = module.target_config().pointer_type();\n@@ -63,6 +71,19 @@ fn codegen_inner(\n         );\n     }\n \n+    let sig = Signature {\n+        call_conv: module.target_config().default_call_conv,\n+        params: vec![AbiParam::new(usize_ty), AbiParam::new(usize_ty)],\n+        returns: vec![],\n+    };\n+    crate::common::create_wrapper_function(\n+        module,\n+        unwind_context,\n+        sig,\n+        \"__rust_alloc_error_handler\",\n+        &alloc_error_handler_kind.fn_name(sym::oom),\n+    );\n+\n     let data_id = module.declare_data(OomStrategy::SYMBOL, Linkage::Export, false, false).unwrap();\n     let mut data_ctx = DataContext::new();\n     data_ctx.set_align(1);"}, {"sha": "754e7931412daa8fe46632a74b3a27b13e2a639b", "filename": "compiler/rustc_codegen_gcc/example/alloc_example.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_example.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -1,4 +1,4 @@\n-#![feature(start, core_intrinsics, lang_items)]\n+#![feature(start, core_intrinsics, alloc_error_handler, lang_items)]\n #![no_std]\n \n extern crate alloc;\n@@ -21,6 +21,11 @@ fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n     core::intrinsics::abort();\n }\n \n+#[alloc_error_handler]\n+fn alloc_error_handler(_: alloc::alloc::Layout) -> ! {\n+    core::intrinsics::abort();\n+}\n+\n #[lang = \"eh_personality\"]\n fn eh_personality() -> ! {\n     loop {}"}, {"sha": "4bad33ee879ee4f1c27ba1c2e1352f98c483d9e1", "filename": "compiler/rustc_codegen_gcc/src/allocator.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -5,10 +5,11 @@ use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS\n use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::OomStrategy;\n+use rustc_span::symbol::sym;\n \n use crate::GccContext;\n \n-pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_name: &str, kind: AllocatorKind) {\n+pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_name: &str, kind: AllocatorKind, alloc_error_handler_kind: AllocatorKind) {\n     let context = &mods.context;\n     let usize =\n         match tcx.sess.target.pointer_width {\n@@ -86,6 +87,37 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n         // as described in https://github.com/rust-lang/rust/commit/77a96ed5646f7c3ee8897693decc4626fe380643\n     }\n \n+    let types = [usize, usize];\n+    let name = \"__rust_alloc_error_handler\".to_string();\n+    let args: Vec<_> = types.iter().enumerate()\n+        .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n+        .collect();\n+    let func = context.new_function(None, FunctionType::Exported, void, &args, name, false);\n+\n+    if tcx.sess.target.default_hidden_visibility {\n+        #[cfg(feature=\"master\")]\n+        func.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n+    }\n+\n+    let callee = alloc_error_handler_kind.fn_name(sym::oom);\n+    let args: Vec<_> = types.iter().enumerate()\n+        .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n+        .collect();\n+    let callee = context.new_function(None, FunctionType::Extern, void, &args, callee, false);\n+    #[cfg(feature=\"master\")]\n+    callee.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n+\n+    let block = func.new_block(\"entry\");\n+\n+    let args = args\n+        .iter()\n+        .enumerate()\n+        .map(|(i, _)| func.get_param(i as i32).to_rvalue())\n+        .collect::<Vec<_>>();\n+    let _ret = context.new_call(None, callee, &args);\n+    //llvm::LLVMSetTailCall(ret, True);\n+    block.end_with_void_return(None);\n+\n     let name = OomStrategy::SYMBOL.to_string();\n     let global = context.new_global(None, GlobalKind::Exported, i8, name);\n     let value = tcx.sess.opts.unstable_opts.oom.should_panic();"}, {"sha": "1cabb05de975b0fec950fb6ae965ed4de35ade46", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -163,11 +163,11 @@ impl CodegenBackend for GccCodegenBackend {\n }\n \n impl ExtraBackendMethods for GccCodegenBackend {\n-    fn codegen_allocator<'tcx>(&self, tcx: TyCtxt<'tcx>, module_name: &str, kind: AllocatorKind) -> Self::Module {\n+    fn codegen_allocator<'tcx>(&self, tcx: TyCtxt<'tcx>, module_name: &str, kind: AllocatorKind, alloc_error_handler_kind: AllocatorKind) -> Self::Module {\n         let mut mods = GccContext {\n             context: Context::default(),\n         };\n-        unsafe { allocator::codegen(tcx, &mut mods, module_name, kind); }\n+        unsafe { allocator::codegen(tcx, &mut mods, module_name, kind, alloc_error_handler_kind); }\n         mods\n     }\n "}, {"sha": "668d929270530023e08c94352b9d7522b3871e75", "filename": "compiler/rustc_codegen_llvm/src/allocator.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -4,6 +4,7 @@ use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS\n use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::{DebugInfo, OomStrategy};\n+use rustc_span::symbol::sym;\n \n use crate::debuginfo;\n use crate::llvm::{self, False, True};\n@@ -14,6 +15,7 @@ pub(crate) unsafe fn codegen(\n     module_llvm: &mut ModuleLlvm,\n     module_name: &str,\n     kind: AllocatorKind,\n+    alloc_error_handler_kind: AllocatorKind,\n ) {\n     let llcx = &*module_llvm.llcx;\n     let llmod = module_llvm.llmod();\n@@ -98,6 +100,52 @@ pub(crate) unsafe fn codegen(\n         llvm::LLVMDisposeBuilder(llbuilder);\n     }\n \n+    // rust alloc error handler\n+    let args = [usize, usize]; // size, align\n+\n+    let ty = llvm::LLVMFunctionType(void, args.as_ptr(), args.len() as c_uint, False);\n+    let name = \"__rust_alloc_error_handler\";\n+    let llfn = llvm::LLVMRustGetOrInsertFunction(llmod, name.as_ptr().cast(), name.len(), ty);\n+    // -> ! DIFlagNoReturn\n+    let no_return = llvm::AttributeKind::NoReturn.create_attr(llcx);\n+    attributes::apply_to_llfn(llfn, llvm::AttributePlace::Function, &[no_return]);\n+\n+    if tcx.sess.target.default_hidden_visibility {\n+        llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n+    }\n+    if tcx.sess.must_emit_unwind_tables() {\n+        let uwtable = attributes::uwtable_attr(llcx);\n+        attributes::apply_to_llfn(llfn, llvm::AttributePlace::Function, &[uwtable]);\n+    }\n+\n+    let callee = alloc_error_handler_kind.fn_name(sym::oom);\n+    let callee = llvm::LLVMRustGetOrInsertFunction(llmod, callee.as_ptr().cast(), callee.len(), ty);\n+    // -> ! DIFlagNoReturn\n+    attributes::apply_to_llfn(callee, llvm::AttributePlace::Function, &[no_return]);\n+    llvm::LLVMRustSetVisibility(callee, llvm::Visibility::Hidden);\n+\n+    let llbb = llvm::LLVMAppendBasicBlockInContext(llcx, llfn, \"entry\\0\".as_ptr().cast());\n+\n+    let llbuilder = llvm::LLVMCreateBuilderInContext(llcx);\n+    llvm::LLVMPositionBuilderAtEnd(llbuilder, llbb);\n+    let args = args\n+        .iter()\n+        .enumerate()\n+        .map(|(i, _)| llvm::LLVMGetParam(llfn, i as c_uint))\n+        .collect::<Vec<_>>();\n+    let ret = llvm::LLVMRustBuildCall(\n+        llbuilder,\n+        ty,\n+        callee,\n+        args.as_ptr(),\n+        args.len() as c_uint,\n+        [].as_ptr(),\n+        0 as c_uint,\n+    );\n+    llvm::LLVMSetTailCall(ret, True);\n+    llvm::LLVMBuildRetVoid(llbuilder);\n+    llvm::LLVMDisposeBuilder(llbuilder);\n+\n     // __rust_alloc_error_handler_should_panic\n     let name = OomStrategy::SYMBOL;\n     let ll_g = llvm::LLVMRustGetOrInsertGlobal(llmod, name.as_ptr().cast(), name.len(), i8);"}, {"sha": "8305a0a4c286df2c091c91db271c8953c4ca7f5c", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -115,10 +115,11 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n         tcx: TyCtxt<'tcx>,\n         module_name: &str,\n         kind: AllocatorKind,\n+        alloc_error_handler_kind: AllocatorKind,\n     ) -> ModuleLlvm {\n         let mut module_llvm = ModuleLlvm::new_metadata(tcx, module_name);\n         unsafe {\n-            allocator::codegen(tcx, &mut module_llvm, module_name, kind);\n+            allocator::codegen(tcx, &mut module_llvm, module_name, kind, alloc_error_handler_kind);\n         }\n         module_llvm\n     }"}, {"sha": "8f2f829c17c1cd76110180d80c3b2b9331d0eeee", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -219,7 +219,7 @@ fn exported_symbols_provider_local(\n         for symbol_name in ALLOCATOR_METHODS\n             .iter()\n             .map(|method| format!(\"__rust_{}\", method.name))\n-            .chain([OomStrategy::SYMBOL.to_string()])\n+            .chain([\"__rust_alloc_error_handler\".to_string(), OomStrategy::SYMBOL.to_string()])\n         {\n             let exported_symbol = ExportedSymbol::NoDefId(SymbolName::new(tcx, &symbol_name));\n "}, {"sha": "c5ca7936a2b458cbb9aa5af2d5f71c94c7d7c934", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -635,9 +635,16 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     if let Some(kind) = allocator_kind_for_codegen(tcx) {\n         let llmod_id =\n             cgu_name_builder.build_cgu_name(LOCAL_CRATE, &[\"crate\"], Some(\"allocator\")).to_string();\n-        let module_llvm = tcx\n-            .sess\n-            .time(\"write_allocator_module\", || backend.codegen_allocator(tcx, &llmod_id, kind));\n+        let module_llvm = tcx.sess.time(\"write_allocator_module\", || {\n+            backend.codegen_allocator(\n+                tcx,\n+                &llmod_id,\n+                kind,\n+                // If allocator_kind is Some then alloc_error_handler_kind must\n+                // also be Some.\n+                tcx.alloc_error_handler_kind(()).unwrap(),\n+            )\n+        });\n \n         ongoing_codegen.submit_pre_codegened_module_to_llvm(\n             tcx,"}, {"sha": "64bebe50ddbf23b17a26f5ad3af725a23f803a21", "filename": "compiler/rustc_codegen_ssa/src/traits/backend.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -123,6 +123,7 @@ pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Se\n         tcx: TyCtxt<'tcx>,\n         module_name: &str,\n         kind: AllocatorKind,\n+        alloc_error_handler_kind: AllocatorKind,\n     ) -> Self::Module;\n     /// This generates the codegen unit and returns it along with\n     /// a `u64` giving an estimate of the unit's processing cost."}, {"sha": "48f5bd1cb50488c4085ae32965ea4d0764699da4", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -291,6 +291,8 @@ declare_features! (\n     (active, abi_x86_interrupt, \"1.17.0\", Some(40180), None),\n     /// Allows additional const parameter types, such as `&'static str` or user defined types\n     (incomplete, adt_const_params, \"1.56.0\", Some(95174), None),\n+    /// Allows defining an `#[alloc_error_handler]`.\n+    (active, alloc_error_handler, \"1.29.0\", Some(51540), None),\n     /// Allows trait methods with arbitrary self types.\n     (active, arbitrary_self_types, \"1.23.0\", Some(44874), None),\n     /// Allows using `const` operands in inline assembly."}, {"sha": "876a31abdf882b29f0ce4fd898127026379c61f4", "filename": "compiler/rustc_feature/src/removed.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -47,8 +47,6 @@ declare_features! (\n \n     (removed, advanced_slice_patterns, \"1.0.0\", Some(62254), None,\n      Some(\"merged into `#![feature(slice_patterns)]`\")),\n-    /// Allows defining an `#[alloc_error_handler]`.\n-    (removed, alloc_error_handler, \"CURRENT_RUSTC_VERSION\", Some(51540), None, Some(\"now handled by panic handler\")),\n     (removed, allocator, \"1.0.0\", None, None, None),\n     /// Allows a test to fail without failing the whole suite.\n     (removed, allow_fail, \"1.19.0\", Some(46488), None, Some(\"removed due to no clear use cases\")),"}, {"sha": "fab9a8a5f4fbf430cd1da0de3f0de0b193f75f4d", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -300,8 +300,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n         opt_input_types: Option<&[Ty<'tcx>]>,\n-    ) -> (traits::Obligation<'tcx, ty::Predicate<'tcx>>, &'tcx ty::List<ty::subst::GenericArg<'tcx>>)\n-    {\n+    ) -> (traits::PredicateObligation<'tcx>, &'tcx ty::List<ty::subst::GenericArg<'tcx>>) {\n         // Construct a trait-reference `self_ty : Trait<input_tys>`\n         let substs = InternalSubsts::for_item(self.tcx, trait_def_id, |param, _| {\n             match param.kind {"}, {"sha": "8ce8b4e2024eb2686cefc5e6c4af5cb4b6b1da9c", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -123,7 +123,7 @@ pub struct FulfillmentError<'tcx> {\n #[derive(Clone)]\n pub enum FulfillmentErrorCode<'tcx> {\n     /// Inherently impossible to fulfill; this trait is implemented if and only if it is already implemented.\n-    CodeCycle(Vec<Obligation<'tcx, ty::Predicate<'tcx>>>),\n+    CodeCycle(Vec<PredicateObligation<'tcx>>),\n     CodeSelectionError(SelectionError<'tcx>),\n     CodeProjectionError(MismatchedProjectionTypes<'tcx>),\n     CodeSubtypeError(ExpectedFound<Ty<'tcx>>, TypeError<'tcx>), // always comes from a SubtypePredicate"}, {"sha": "7b0b5102c2db655a8c0c7fbdcf6eb222ee1b59c0", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -777,7 +777,7 @@ fn test_unstable_options_tracking_hash() {\n     tracked!(no_link, true);\n     tracked!(no_profiler_runtime, true);\n     tracked!(no_unique_section_names, true);\n-    tracked!(oom, OomStrategy::Unwind);\n+    tracked!(oom, OomStrategy::Panic);\n     tracked!(osx_rpath_install_name, true);\n     tracked!(packed_bundled_libs, true);\n     tracked!(panic_abort_tests, true);"}, {"sha": "1acdc95ca8d2dbfed253245a985a288eb97463be", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -410,10 +410,15 @@ extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n   }\n   Options.RelaxELFRelocations = RelaxELFRelocations;\n   Options.UseInitArray = UseInitArray;\n+\n+#if LLVM_VERSION_LT(17, 0)\n   if (ForceEmulatedTls) {\n     Options.ExplicitEmulatedTLS = true;\n     Options.EmulatedTLS = true;\n   }\n+#else\n+  Options.EmulatedTLS = ForceEmulatedTls || Trip.hasDefaultEmulatedTLS();\n+#endif\n \n   if (TrapUnreachable) {\n     // Tell LLVM to codegen `unreachable` into an explicit trap instruction."}, {"sha": "79b8b417257045a6b60f244acf4f4a0f7acc35d5", "filename": "compiler/rustc_metadata/messages.ftl", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_metadata%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_metadata%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fmessages.ftl?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -155,9 +155,19 @@ metadata_no_multiple_global_alloc =\n metadata_prev_global_alloc =\n     previous global allocator defined here\n \n+metadata_no_multiple_alloc_error_handler =\n+    cannot define multiple allocation error handlers\n+    .label = cannot define a new allocation error handler\n+\n+metadata_prev_alloc_error_handler =\n+    previous allocation error handler defined here\n+\n metadata_conflicting_global_alloc =\n     the `#[global_allocator]` in {$other_crate_name} conflicts with global allocator in: {$crate_name}\n \n+metadata_conflicting_alloc_error_handler =\n+    the `#[alloc_error_handler]` in {$other_crate_name} conflicts with allocation error handler in: {$crate_name}\n+\n metadata_global_alloc_required =\n     no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait\n "}, {"sha": "179453238f2ccf776305b4dfee33d827f04ad79a", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -38,8 +38,13 @@ pub struct CStore {\n     /// This crate needs an allocator and either provides it itself, or finds it in a dependency.\n     /// If the above is true, then this field denotes the kind of the found allocator.\n     allocator_kind: Option<AllocatorKind>,\n+    /// This crate needs an allocation error handler and either provides it itself, or finds it in a dependency.\n+    /// If the above is true, then this field denotes the kind of the found allocator.\n+    alloc_error_handler_kind: Option<AllocatorKind>,\n     /// This crate has a `#[global_allocator]` item.\n     has_global_allocator: bool,\n+    /// This crate has a `#[alloc_error_handler]` item.\n+    has_alloc_error_handler: bool,\n \n     /// The interned [StableCrateId]s.\n     pub(crate) stable_crate_ids: StableCrateIdMap,\n@@ -216,10 +221,18 @@ impl CStore {\n         self.allocator_kind\n     }\n \n+    pub(crate) fn alloc_error_handler_kind(&self) -> Option<AllocatorKind> {\n+        self.alloc_error_handler_kind\n+    }\n+\n     pub(crate) fn has_global_allocator(&self) -> bool {\n         self.has_global_allocator\n     }\n \n+    pub(crate) fn has_alloc_error_handler(&self) -> bool {\n+        self.has_alloc_error_handler\n+    }\n+\n     pub fn report_unused_deps(&self, tcx: TyCtxt<'_>) {\n         let json_unused_externs = tcx.sess.opts.json_unused_externs;\n \n@@ -255,7 +268,9 @@ impl CStore {\n             metas: IndexVec::from_iter(iter::once(None)),\n             injected_panic_runtime: None,\n             allocator_kind: None,\n+            alloc_error_handler_kind: None,\n             has_global_allocator: false,\n+            has_alloc_error_handler: false,\n             stable_crate_ids,\n             unused_externs: Vec::new(),\n         }\n@@ -761,6 +776,14 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n             }\n             spans => !spans.is_empty(),\n         };\n+        self.cstore.has_alloc_error_handler = match &*alloc_error_handler_spans(krate) {\n+            [span1, span2, ..] => {\n+                self.sess\n+                    .emit_err(errors::NoMultipleAllocErrorHandler { span2: *span2, span1: *span1 });\n+                true\n+            }\n+            spans => !spans.is_empty(),\n+        };\n \n         // Check to see if we actually need an allocator. This desire comes\n         // about through the `#![needs_allocator]` attribute and is typically\n@@ -801,6 +824,21 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n                 }\n             }\n         }\n+        let mut alloc_error_handler =\n+            self.cstore.has_alloc_error_handler.then(|| Symbol::intern(\"this crate\"));\n+        for (_, data) in self.cstore.iter_crate_data() {\n+            if data.has_alloc_error_handler() {\n+                match alloc_error_handler {\n+                    Some(other_crate) => {\n+                        self.sess.emit_err(errors::ConflictingAllocErrorHandler {\n+                            crate_name: data.name(),\n+                            other_crate_name: other_crate,\n+                        });\n+                    }\n+                    None => alloc_error_handler = Some(data.name()),\n+                }\n+            }\n+        }\n \n         if global_allocator.is_some() {\n             self.cstore.allocator_kind = Some(AllocatorKind::Global);\n@@ -816,6 +854,14 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n             }\n             self.cstore.allocator_kind = Some(AllocatorKind::Default);\n         }\n+\n+        if alloc_error_handler.is_some() {\n+            self.cstore.alloc_error_handler_kind = Some(AllocatorKind::Global);\n+        } else {\n+            // The alloc crate provides a default allocation error handler if\n+            // one isn't specified.\n+            self.cstore.alloc_error_handler_kind = Some(AllocatorKind::Default);\n+        }\n     }\n \n     fn inject_dependency_if(\n@@ -991,6 +1037,28 @@ fn global_allocator_spans(krate: &ast::Crate) -> Vec<Span> {\n     f.spans\n }\n \n+fn alloc_error_handler_spans(krate: &ast::Crate) -> Vec<Span> {\n+    struct Finder {\n+        name: Symbol,\n+        spans: Vec<Span>,\n+    }\n+    impl<'ast> visit::Visitor<'ast> for Finder {\n+        fn visit_item(&mut self, item: &'ast ast::Item) {\n+            if item.ident.name == self.name\n+                && attr::contains_name(&item.attrs, sym::rustc_std_internal_symbol)\n+            {\n+                self.spans.push(item.span);\n+            }\n+            visit::walk_item(self, item)\n+        }\n+    }\n+\n+    let name = Symbol::intern(&AllocatorKind::Global.fn_name(sym::oom));\n+    let mut f = Finder { name, spans: Vec::new() };\n+    visit::walk_crate(&mut f, krate);\n+    f.spans\n+}\n+\n // On Windows the compiler would sometimes intermittently fail to open the\n // proc-macro DLL with `Error::LoadLibraryExW`. It is suspected that something in the\n // system still holds a lock on the file, so we retry a few times before calling it"}, {"sha": "51b41b5f6a2148c90e3d81d1e01941ef44b9315b", "filename": "compiler/rustc_metadata/src/errors.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -352,13 +352,30 @@ pub struct NoMultipleGlobalAlloc {\n     pub span1: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(metadata_no_multiple_alloc_error_handler)]\n+pub struct NoMultipleAllocErrorHandler {\n+    #[primary_span]\n+    #[label]\n+    pub span2: Span,\n+    #[label(metadata_prev_alloc_error_handler)]\n+    pub span1: Span,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(metadata_conflicting_global_alloc)]\n pub struct ConflictingGlobalAlloc {\n     pub crate_name: Symbol,\n     pub other_crate_name: Symbol,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(metadata_conflicting_alloc_error_handler)]\n+pub struct ConflictingAllocErrorHandler {\n+    pub crate_name: Symbol,\n+    pub other_crate_name: Symbol,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(metadata_global_alloc_required)]\n pub struct GlobalAllocRequired;"}, {"sha": "64245a0460d8f2422b85cd7cd35f43e654e8c811", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -1683,6 +1683,10 @@ impl CrateMetadata {\n         self.root.has_global_allocator\n     }\n \n+    pub(crate) fn has_alloc_error_handler(&self) -> bool {\n+        self.root.has_alloc_error_handler\n+    }\n+\n     pub(crate) fn has_default_lib_allocator(&self) -> bool {\n         self.root.has_default_lib_allocator\n     }"}, {"sha": "141980912b1d6dbaf5085685687ec1280580b28e", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -290,6 +290,7 @@ provide! { tcx, def_id, other, cdata,\n     is_panic_runtime => { cdata.root.panic_runtime }\n     is_compiler_builtins => { cdata.root.compiler_builtins }\n     has_global_allocator => { cdata.root.has_global_allocator }\n+    has_alloc_error_handler => { cdata.root.has_alloc_error_handler }\n     has_panic_handler => { cdata.root.has_panic_handler }\n     is_profiler_runtime => { cdata.root.profiler_runtime }\n     required_panic_strategy => { cdata.root.required_panic_strategy }\n@@ -378,6 +379,7 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n     // resolve! Does this work? Unsure! That's what the issue is about\n     *providers = Providers {\n         allocator_kind: |tcx, ()| CStore::from_tcx(tcx).allocator_kind(),\n+        alloc_error_handler_kind: |tcx, ()| CStore::from_tcx(tcx).alloc_error_handler_kind(),\n         is_private_dep: |_tcx, LocalCrate| false,\n         native_library: |tcx, id| {\n             tcx.native_libraries(id.krate)\n@@ -494,6 +496,7 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n \n         dependency_formats: |tcx, ()| Lrc::new(crate::dependency_format::calculate(tcx)),\n         has_global_allocator: |tcx, LocalCrate| CStore::from_tcx(tcx).has_global_allocator(),\n+        has_alloc_error_handler: |tcx, LocalCrate| CStore::from_tcx(tcx).has_alloc_error_handler(),\n         postorder_cnums: |tcx, ()| {\n             tcx.arena\n                 .alloc_slice(&CStore::from_tcx(tcx).crate_dependencies_in_postorder(LOCAL_CRATE))"}, {"sha": "17a9daee7d03811d3e531d699e80f6c05628f829", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -676,6 +676,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 panic_in_drop_strategy: tcx.sess.opts.unstable_opts.panic_in_drop,\n                 edition: tcx.sess.edition(),\n                 has_global_allocator: tcx.has_global_allocator(LOCAL_CRATE),\n+                has_alloc_error_handler: tcx.has_alloc_error_handler(LOCAL_CRATE),\n                 has_panic_handler: tcx.has_panic_handler(LOCAL_CRATE),\n                 has_default_lib_allocator: attr::contains_name(&attrs, sym::default_lib_allocator),\n                 proc_macro_data,"}, {"sha": "dd02463e16a077410d96eaefde78649d4f1eb6ee", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -225,6 +225,7 @@ pub(crate) struct CrateRoot {\n     panic_in_drop_strategy: PanicStrategy,\n     edition: Edition,\n     has_global_allocator: bool,\n+    has_alloc_error_handler: bool,\n     has_panic_handler: bool,\n     has_default_lib_allocator: bool,\n "}, {"sha": "7109ff95b871060d41b2632d52971162ecb82f99", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -1351,6 +1351,13 @@ rustc_queries! {\n         desc { \"checking if the crate has_global_allocator\" }\n         separate_provide_extern\n     }\n+    query has_alloc_error_handler(_: CrateNum) -> bool {\n+        // This query depends on untracked global state in CStore\n+        eval_always\n+        fatal_cycle\n+        desc { \"checking if the crate has_alloc_error_handler\" }\n+        separate_provide_extern\n+    }\n     query has_panic_handler(_: CrateNum) -> bool {\n         fatal_cycle\n         desc { \"checking if the crate has_panic_handler\" }\n@@ -1723,6 +1730,10 @@ rustc_queries! {\n         eval_always\n         desc { \"getting the allocator kind for the current crate\" }\n     }\n+    query alloc_error_handler_kind(_: ()) -> Option<AllocatorKind> {\n+        eval_always\n+        desc { \"alloc error handler kind for the current crate\" }\n+    }\n \n     query upvars_mentioned(def_id: DefId) -> Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>> {\n         desc { |tcx| \"collecting upvars mentioned in `{}`\", tcx.def_path_str(def_id) }"}, {"sha": "79eb31bb1050e18dde6b355bd64cef3751fe1b3a", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -3048,9 +3048,9 @@ pub(crate) mod dep_tracking {\n #[derive(Clone, Copy, PartialEq, Hash, Debug, Encodable, Decodable, HashStable_Generic)]\n pub enum OomStrategy {\n     /// Generate a panic that can be caught by `catch_unwind`.\n-    Unwind,\n+    Panic,\n \n-    /// Calls the panic hook as normal but aborts instead of unwinding.\n+    /// Abort the process immediately.\n     Abort,\n }\n \n@@ -3059,7 +3059,7 @@ impl OomStrategy {\n \n     pub fn should_panic(self) -> u8 {\n         match self {\n-            OomStrategy::Unwind => 1,\n+            OomStrategy::Panic => 1,\n             OomStrategy::Abort => 0,\n         }\n     }"}, {"sha": "d9f03fe14072ee9ca13971c44b870ebe7fb196cb", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -662,7 +662,7 @@ mod parse {\n \n     pub(crate) fn parse_oom_strategy(slot: &mut OomStrategy, v: Option<&str>) -> bool {\n         match v {\n-            Some(\"unwind\") => *slot = OomStrategy::Unwind,\n+            Some(\"panic\") => *slot = OomStrategy::Panic,\n             Some(\"abort\") => *slot = OomStrategy::Abort,\n             _ => return false,\n         }"}, {"sha": "e82672e83687080eabc730df335dbaeeded1fd4b", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -591,7 +591,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n     fn evaluate_nested_obligations(\n         &self,\n         ty: Ty<'_>,\n-        nested: impl Iterator<Item = Obligation<'tcx, ty::Predicate<'tcx>>>,\n+        nested: impl Iterator<Item = PredicateObligation<'tcx>>,\n         computed_preds: &mut FxIndexSet<ty::Predicate<'tcx>>,\n         fresh_preds: &mut FxHashSet<ty::Predicate<'tcx>>,\n         predicates: &mut VecDeque<ty::PolyTraitPredicate<'tcx>>,"}, {"sha": "ce187fbdf8424ee69eb337d2065556abb08dac26", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 657, "deletions": 427, "changes": 1084, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -15,8 +15,7 @@ use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use crate::traits::query::normalize::QueryNormalizeExt as _;\n use crate::traits::specialize::to_pretty_impl_header;\n use crate::traits::NormalizeExt;\n-use on_unimplemented::OnUnimplementedNote;\n-use on_unimplemented::TypeErrCtxtExt as _;\n+use on_unimplemented::{AppendConstMessage, OnUnimplementedNote, TypeErrCtxtExt as _};\n use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n use rustc_errors::{\n     pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n@@ -706,35 +705,19 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                      conversion on the error value using the `From` trait\"\n                                         .to_owned(),\n                                 ),\n-                                Some(None),\n+                                Some(AppendConstMessage::Default),\n                             )\n                         } else {\n                             (message, note, append_const_msg)\n                         };\n \n-                        let err_msg = message\n-                            .and_then(|cannot_do_this| {\n-                                match (predicate_is_const, append_const_msg) {\n-                                    // do nothing if predicate is not const\n-                                    (false, _) => Some(cannot_do_this),\n-                                    // suggested using default post message\n-                                    (true, Some(None)) => {\n-                                        Some(format!(\"{cannot_do_this} in const contexts\"))\n-                                    }\n-                                    // overridden post message\n-                                    (true, Some(Some(post_message))) => {\n-                                        Some(format!(\"{cannot_do_this}{post_message}\"))\n-                                    }\n-                                    // fallback to generic message\n-                                    (true, None) => None,\n-                                }\n-                            })\n-                            .unwrap_or_else(|| {\n-                                format!(\n-                                    \"the trait bound `{}` is not satisfied{}\",\n-                                    trait_predicate, post_message,\n-                                )\n-                            });\n+                        let err_msg = self.get_standard_error_message(\n+                            &trait_predicate,\n+                            message,\n+                            predicate_is_const,\n+                            append_const_msg,\n+                            post_message,\n+                        );\n \n                         let (err_msg, safe_transmute_explanation) = if Some(trait_ref.def_id())\n                             == self.tcx.lang_items().transmute_trait()\n@@ -762,22 +745,10 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         }\n \n                         if Some(trait_ref.def_id()) == tcx.lang_items().tuple_trait() {\n-                            match obligation.cause.code().peel_derives() {\n-                                ObligationCauseCode::RustCall => {\n-                                    err.set_primary_message(\"functions with the \\\"rust-call\\\" ABI must take a single non-self tuple argument\");\n-                                }\n-                                ObligationCauseCode::BindingObligation(def_id, _)\n-                                | ObligationCauseCode::ItemObligation(def_id)\n-                                    if tcx.is_fn_trait(*def_id) =>\n-                                {\n-                                    err.code(rustc_errors::error_code!(E0059));\n-                                    err.set_primary_message(format!(\n-                                        \"type parameter to bare `{}` trait must be a tuple\",\n-                                        tcx.def_path_str(*def_id)\n-                                    ));\n-                                }\n-                                _ => {}\n-                            }\n+                            self.add_tuple_trait_message(\n+                                &obligation.cause.code().peel_derives(),\n+                                &mut err,\n+                            );\n                         }\n \n                         if Some(trait_ref.def_id()) == tcx.lang_items().drop_trait()\n@@ -787,33 +758,13 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             err.note(\"See <https://github.com/rust-lang/rust/pull/94901> for more details\");\n                         }\n \n-                        let explanation = if let ObligationCauseCode::MainFunctionType =\n-                            obligation.cause.code()\n-                        {\n-                            \"consider using `()`, or a `Result`\".to_owned()\n-                        } else {\n-                            let ty_desc = match trait_ref.skip_binder().self_ty().kind() {\n-                                ty::FnDef(_, _) => Some(\"fn item\"),\n-                                ty::Closure(_, _) => Some(\"closure\"),\n-                                _ => None,\n-                            };\n+                        let explanation = get_explanation_based_on_obligation(\n+                            &obligation,\n+                            trait_ref,\n+                            &trait_predicate,\n+                            pre_message,\n+                        );\n \n-                            match ty_desc {\n-                                Some(desc) => format!(\n-                                    \"{}the trait `{}` is not implemented for {} `{}`\",\n-                                    pre_message,\n-                                    trait_predicate.print_modifiers_and_trait_path(),\n-                                    desc,\n-                                    trait_ref.skip_binder().self_ty(),\n-                                ),\n-                                None => format!(\n-                                    \"{}the trait `{}` is not implemented for `{}`\",\n-                                    pre_message,\n-                                    trait_predicate.print_modifiers_and_trait_path(),\n-                                    trait_ref.skip_binder().self_ty(),\n-                                ),\n-                            }\n-                        };\n                         self.check_for_binding_assigned_block_without_tail_expression(\n                             &obligation,\n                             &mut err,\n@@ -850,28 +801,14 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             self.suggest_borrowing_for_object_cast(&mut err, &root_obligation, *concrete_ty, *obj_ty);\n                         }\n \n-                        let mut unsatisfied_const = false;\n-                        if trait_predicate.is_const_if_const() && obligation.param_env.is_const() {\n-                            let non_const_predicate = trait_ref.without_const();\n-                            let non_const_obligation = Obligation {\n-                                cause: obligation.cause.clone(),\n-                                param_env: obligation.param_env.without_const(),\n-                                predicate: non_const_predicate.to_predicate(tcx),\n-                                recursion_depth: obligation.recursion_depth,\n-                            };\n-                            if self.predicate_may_hold(&non_const_obligation) {\n-                                unsatisfied_const = true;\n-                                err.span_note(\n-                                    span,\n-                                    &format!(\n-                                        \"the trait `{}` is implemented for `{}`, \\\n-                                        but that implementation is not `const`\",\n-                                        non_const_predicate.print_modifiers_and_trait_path(),\n-                                        trait_ref.skip_binder().self_ty(),\n-                                    ),\n-                                );\n-                            }\n-                        }\n+                        let UnsatisfiedConst(unsatisfied_const) = self\n+                            .maybe_add_note_for_unsatisfied_const(\n+                                &obligation,\n+                                trait_ref,\n+                                &trait_predicate,\n+                                &mut err,\n+                                span,\n+                            );\n \n                         if let Some((msg, span)) = type_def {\n                             err.span_label(span, &msg);\n@@ -969,137 +906,16 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             );\n                         }\n \n-                        let body_def_id = obligation.cause.body_id;\n-                        // Try to report a help message\n-                        if is_fn_trait\n-                            && let Ok((implemented_kind, params)) = self.type_implements_fn_trait(\n-                            obligation.param_env,\n-                            trait_ref.self_ty(),\n-                            trait_predicate.skip_binder().constness,\n-                            trait_predicate.skip_binder().polarity,\n-                        )\n-                        {\n-                            // If the type implements `Fn`, `FnMut`, or `FnOnce`, suppress the following\n-                            // suggestion to add trait bounds for the type, since we only typically implement\n-                            // these traits once.\n-\n-                            // Note if the `FnMut` or `FnOnce` is less general than the trait we're trying\n-                            // to implement.\n-                            let selected_kind =\n-                                self.tcx.fn_trait_kind_from_def_id(trait_ref.def_id())\n-                                    .expect(\"expected to map DefId to ClosureKind\");\n-                            if !implemented_kind.extends(selected_kind) {\n-                                err.note(\n-                                    &format!(\n-                                        \"`{}` implements `{}`, but it must implement `{}`, which is more general\",\n-                                        trait_ref.skip_binder().self_ty(),\n-                                        implemented_kind,\n-                                        selected_kind\n-                                    )\n-                                );\n-                            }\n-\n-                            // Note any argument mismatches\n-                            let given_ty = params.skip_binder();\n-                            let expected_ty = trait_ref.skip_binder().substs.type_at(1);\n-                            if let ty::Tuple(given) = given_ty.kind()\n-                                && let ty::Tuple(expected) = expected_ty.kind()\n-                            {\n-                                if expected.len() != given.len() {\n-                                    // Note number of types that were expected and given\n-                                    err.note(\n-                                        &format!(\n-                                            \"expected a closure taking {} argument{}, but one taking {} argument{} was given\",\n-                                            given.len(),\n-                                            pluralize!(given.len()),\n-                                            expected.len(),\n-                                            pluralize!(expected.len()),\n-                                        )\n-                                    );\n-                                } else if !self.same_type_modulo_infer(given_ty, expected_ty) {\n-                                    // Print type mismatch\n-                                    let (expected_args, given_args) =\n-                                        self.cmp(given_ty, expected_ty);\n-                                    err.note_expected_found(\n-                                        &\"a closure with arguments\",\n-                                        expected_args,\n-                                        &\"a closure with arguments\",\n-                                        given_args,\n-                                    );\n-                                }\n-                            }\n-                        } else if !trait_ref.has_non_region_infer()\n-                            && self.predicate_can_apply(obligation.param_env, trait_predicate)\n-                        {\n-                            // If a where-clause may be useful, remind the\n-                            // user that they can add it.\n-                            //\n-                            // don't display an on-unimplemented note, as\n-                            // these notes will often be of the form\n-                            //     \"the type `T` can't be frobnicated\"\n-                            // which is somewhat confusing.\n-                            self.suggest_restricting_param_bound(\n-                                &mut err,\n-                                trait_predicate,\n-                                None,\n-                                obligation.cause.body_id,\n-                            );\n-                        } else if !suggested && !unsatisfied_const {\n-                            // Can't show anything else useful, try to find similar impls.\n-                            let impl_candidates = self.find_similar_impl_candidates(trait_predicate);\n-                            if !self.report_similar_impl_candidates(\n-                                &impl_candidates,\n-                                trait_ref,\n-                                body_def_id,\n-                                &mut err,\n-                                true,\n-                            ) {\n-                                // This is *almost* equivalent to\n-                                // `obligation.cause.code().peel_derives()`, but it gives us the\n-                                // trait predicate for that corresponding root obligation. This\n-                                // lets us get a derived obligation from a type parameter, like\n-                                // when calling `string.strip_suffix(p)` where `p` is *not* an\n-                                // implementer of `Pattern<'_>`.\n-                                let mut code = obligation.cause.code();\n-                                let mut trait_pred = trait_predicate;\n-                                let mut peeled = false;\n-                                while let Some((parent_code, parent_trait_pred)) = code.parent() {\n-                                    code = parent_code;\n-                                    if let Some(parent_trait_pred) = parent_trait_pred {\n-                                        trait_pred = parent_trait_pred;\n-                                        peeled = true;\n-                                    }\n-                                }\n-                                let def_id = trait_pred.def_id();\n-                                // Mention *all* the `impl`s for the *top most* obligation, the\n-                                // user might have meant to use one of them, if any found. We skip\n-                                // auto-traits or fundamental traits that might not be exactly what\n-                                // the user might expect to be presented with. Instead this is\n-                                // useful for less general traits.\n-                                if peeled\n-                                    && !self.tcx.trait_is_auto(def_id)\n-                                    && !self.tcx.lang_items().iter().any(|(_, id)| id == def_id)\n-                                {\n-                                    let trait_ref = trait_pred.to_poly_trait_ref();\n-                                    let impl_candidates =\n-                                        self.find_similar_impl_candidates(trait_pred);\n-                                    self.report_similar_impl_candidates(\n-                                        &impl_candidates,\n-                                        trait_ref,\n-                                        body_def_id,\n-                                        &mut err,\n-                                        true,\n-                                    );\n-                                }\n-                            }\n-\n-                            self.maybe_suggest_convert_to_slice(\n-                                &mut err,\n-                                trait_ref,\n-                                impl_candidates.as_slice(),\n-                                span,\n-                            );\n-                        }\n+                        self.try_to_add_help_message(\n+                            &obligation,\n+                            trait_ref,\n+                            &trait_predicate,\n+                            &mut err,\n+                            span,\n+                            is_fn_trait,\n+                            suggested,\n+                            unsatisfied_const,\n+                        );\n \n                         // Changing mutability doesn't make a difference to whether we have\n                         // an `Unsize` impl (Fixes ICE in #71036)\n@@ -1194,59 +1010,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n                     ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n                         let found_kind = self.closure_kind(closure_substs).unwrap();\n-                        let closure_span = self.tcx.def_span(closure_def_id);\n-                        let mut err = struct_span_err!(\n-                            self.tcx.sess,\n-                            closure_span,\n-                            E0525,\n-                            \"expected a closure that implements the `{}` trait, \\\n-                             but this closure only implements `{}`\",\n-                            kind,\n-                            found_kind\n-                        );\n-\n-                        err.span_label(\n-                            closure_span,\n-                            format!(\"this closure implements `{}`, not `{}`\", found_kind, kind),\n-                        );\n-                        err.span_label(\n-                            obligation.cause.span,\n-                            format!(\"the requirement to implement `{}` derives from here\", kind),\n-                        );\n-\n-                        // Additional context information explaining why the closure only implements\n-                        // a particular trait.\n-                        if let Some(typeck_results) = &self.typeck_results {\n-                            let hir_id = self\n-                                .tcx\n-                                .hir()\n-                                .local_def_id_to_hir_id(closure_def_id.expect_local());\n-                            match (found_kind, typeck_results.closure_kind_origins().get(hir_id)) {\n-                                (ty::ClosureKind::FnOnce, Some((span, place))) => {\n-                                    err.span_label(\n-                                        *span,\n-                                        format!(\n-                                            \"closure is `FnOnce` because it moves the \\\n-                                         variable `{}` out of its environment\",\n-                                            ty::place_to_string_for_capture(tcx, place)\n-                                        ),\n-                                    );\n-                                }\n-                                (ty::ClosureKind::FnMut, Some((span, place))) => {\n-                                    err.span_label(\n-                                        *span,\n-                                        format!(\n-                                            \"closure is `FnMut` because it mutates the \\\n-                                         variable `{}` here\",\n-                                            ty::place_to_string_for_capture(tcx, place)\n-                                        ),\n-                                    );\n-                                }\n-                                _ => {}\n-                            }\n-                        }\n-\n-                        err\n+                        self.report_closure_error(&obligation, closure_def_id, found_kind, kind)\n                     }\n \n                     ty::PredicateKind::WellFormed(ty) => {\n@@ -1327,117 +1091,21 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 found_trait_ref,\n                 expected_trait_ref,\n                 terr @ TypeError::CyclicTy(_),\n-            ) => {\n-                let self_ty = found_trait_ref.self_ty().skip_binder();\n-                let (cause, terr) = if let ty::Closure(def_id, _) = self_ty.kind() {\n-                    (\n-                        ObligationCause::dummy_with_span(tcx.def_span(def_id)),\n-                        TypeError::CyclicTy(self_ty),\n-                    )\n-                } else {\n-                    (obligation.cause.clone(), terr)\n-                };\n-                self.report_and_explain_type_error(\n-                    TypeTrace::poly_trait_refs(&cause, true, expected_trait_ref, found_trait_ref),\n-                    terr,\n-                )\n-            }\n+            ) => self.report_type_parameter_mismatch_cyclic_type_error(\n+                &obligation,\n+                found_trait_ref,\n+                expected_trait_ref,\n+                terr,\n+            ),\n             OutputTypeParameterMismatch(found_trait_ref, expected_trait_ref, _) => {\n-                let found_trait_ref = self.resolve_vars_if_possible(found_trait_ref);\n-                let expected_trait_ref = self.resolve_vars_if_possible(expected_trait_ref);\n-\n-                if expected_trait_ref.self_ty().references_error() {\n-                    return;\n-                }\n-\n-                let Some(found_trait_ty) = found_trait_ref.self_ty().no_bound_vars() else {\n-                    return;\n-                };\n-\n-                let found_did = match *found_trait_ty.kind() {\n-                    ty::Closure(did, _)\n-                    | ty::Foreign(did)\n-                    | ty::FnDef(did, _)\n-                    | ty::Generator(did, ..) => Some(did),\n-                    ty::Adt(def, _) => Some(def.did()),\n-                    _ => None,\n-                };\n-\n-                let found_node = found_did.and_then(|did| self.tcx.hir().get_if_local(did));\n-                let found_span = found_did.and_then(|did| self.tcx.hir().span_if_local(did));\n-\n-                if self.reported_closure_mismatch.borrow().contains(&(span, found_span)) {\n-                    // We check closures twice, with obligations flowing in different directions,\n-                    // but we want to complain about them only once.\n-                    return;\n-                }\n-\n-                self.reported_closure_mismatch.borrow_mut().insert((span, found_span));\n-\n-                let mut not_tupled = false;\n-\n-                let found = match found_trait_ref.skip_binder().substs.type_at(1).kind() {\n-                    ty::Tuple(ref tys) => vec![ArgKind::empty(); tys.len()],\n-                    _ => {\n-                        not_tupled = true;\n-                        vec![ArgKind::empty()]\n-                    }\n-                };\n-\n-                let expected_ty = expected_trait_ref.skip_binder().substs.type_at(1);\n-                let expected = match expected_ty.kind() {\n-                    ty::Tuple(ref tys) => {\n-                        tys.iter().map(|t| ArgKind::from_expected_ty(t, Some(span))).collect()\n-                    }\n-                    _ => {\n-                        not_tupled = true;\n-                        vec![ArgKind::Arg(\"_\".to_owned(), expected_ty.to_string())]\n-                    }\n-                };\n-\n-                // If this is a `Fn` family trait and either the expected or found\n-                // is not tupled, then fall back to just a regular mismatch error.\n-                // This shouldn't be common unless manually implementing one of the\n-                // traits manually, but don't make it more confusing when it does\n-                // happen.\n-                if Some(expected_trait_ref.def_id()) != tcx.lang_items().gen_trait() && not_tupled {\n-                    self.report_and_explain_type_error(\n-                        TypeTrace::poly_trait_refs(\n-                            &obligation.cause,\n-                            true,\n-                            expected_trait_ref,\n-                            found_trait_ref,\n-                        ),\n-                        ty::error::TypeError::Mismatch,\n-                    )\n-                } else if found.len() == expected.len() {\n-                    self.report_closure_arg_mismatch(\n-                        span,\n-                        found_span,\n-                        found_trait_ref,\n-                        expected_trait_ref,\n-                        obligation.cause.code(),\n-                        found_node,\n-                        obligation.param_env,\n-                    )\n-                } else {\n-                    let (closure_span, closure_arg_span, found) = found_did\n-                        .and_then(|did| {\n-                            let node = self.tcx.hir().get_if_local(did)?;\n-                            let (found_span, closure_arg_span, found) =\n-                                self.get_fn_like_arguments(node)?;\n-                            Some((Some(found_span), closure_arg_span, found))\n-                        })\n-                        .unwrap_or((found_span, None, found));\n-\n-                    self.report_arg_count_mismatch(\n-                        span,\n-                        closure_span,\n-                        expected,\n-                        found,\n-                        found_trait_ty.is_closure(),\n-                        closure_arg_span,\n-                    )\n+                match self.report_type_parameter_mismatch_error(\n+                    &obligation,\n+                    span,\n+                    found_trait_ref,\n+                    expected_trait_ref,\n+                ) {\n+                    Some(err) => err,\n+                    None => return,\n                 }\n             }\n \n@@ -1452,45 +1120,9 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 )\n             }\n             SelectionError::NotConstEvaluatable(NotConstEvaluatable::MentionsParam) => {\n-                if !self.tcx.features().generic_const_exprs {\n-                    let mut err = self.tcx.sess.struct_span_err(\n-                        span,\n-                        \"constant expression depends on a generic parameter\",\n-                    );\n-                    // FIXME(const_generics): we should suggest to the user how they can resolve this\n-                    // issue. However, this is currently not actually possible\n-                    // (see https://github.com/rust-lang/rust/issues/66962#issuecomment-575907083).\n-                    //\n-                    // Note that with `feature(generic_const_exprs)` this case should not\n-                    // be reachable.\n-                    err.note(\"this may fail depending on what value the parameter takes\");\n-                    err.emit();\n-                    return;\n-                }\n-\n-                match obligation.predicate.kind().skip_binder() {\n-                    ty::PredicateKind::ConstEvaluatable(ct) => {\n-                        let ty::ConstKind::Unevaluated(uv) = ct.kind() else {\n-                            bug!(\"const evaluatable failed for non-unevaluated const `{ct:?}`\");\n-                        };\n-                        let mut err =\n-                            self.tcx.sess.struct_span_err(span, \"unconstrained generic constant\");\n-                        let const_span = self.tcx.def_span(uv.def);\n-                        match self.tcx.sess.source_map().span_to_snippet(const_span) {\n-                            Ok(snippet) => err.help(&format!(\n-                                \"try adding a `where` bound using this expression: `where [(); {}]:`\",\n-                                snippet\n-                            )),\n-                            _ => err.help(\"consider adding a `where` bound using this expression\"),\n-                        };\n-                        err\n-                    }\n-                    _ => {\n-                        span_bug!(\n-                            span,\n-                            \"unexpected non-ConstEvaluatable predicate, this should not be reachable\"\n-                        )\n-                    }\n+                match self.report_not_const_evaluatable_error(&obligation, span) {\n+                    Some(err) => err,\n+                    None => return,\n                 }\n             }\n \n@@ -1562,6 +1194,14 @@ trait InferCtxtPrivExt<'tcx> {\n         other: bool,\n     ) -> bool;\n \n+    fn report_similar_impl_candidates_for_root_obligation(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        trait_predicate: ty::Binder<'tcx, ty::TraitPredicate<'tcx>>,\n+        body_def_id: LocalDefId,\n+        err: &mut Diagnostic,\n+    );\n+\n     /// Gets the parent trait chain start\n     fn get_parent_trait_ref(\n         &self,\n@@ -1625,12 +1265,86 @@ trait InferCtxtPrivExt<'tcx> {\n         cause_code: &ObligationCauseCode<'tcx>,\n     ) -> bool;\n \n+    fn get_standard_error_message(\n+        &self,\n+        trait_predicate: &ty::PolyTraitPredicate<'tcx>,\n+        message: Option<String>,\n+        predicate_is_const: bool,\n+        append_const_msg: Option<AppendConstMessage>,\n+        post_message: String,\n+    ) -> String;\n+\n     fn get_safe_transmute_error_and_reason(\n         &self,\n-        obligation: Obligation<'tcx, ty::Predicate<'tcx>>,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        obligation: PredicateObligation<'tcx>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n         span: Span,\n     ) -> (String, Option<String>);\n+\n+    fn add_tuple_trait_message(\n+        &self,\n+        obligation_cause_code: &ObligationCauseCode<'tcx>,\n+        err: &mut Diagnostic,\n+    );\n+\n+    fn try_to_add_help_message(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        trait_predicate: &ty::PolyTraitPredicate<'tcx>,\n+        err: &mut Diagnostic,\n+        span: Span,\n+        is_fn_trait: bool,\n+        suggested: bool,\n+        unsatisfied_const: bool,\n+    );\n+\n+    fn add_help_message_for_fn_trait(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        err: &mut Diagnostic,\n+        implemented_kind: ty::ClosureKind,\n+        params: ty::Binder<'tcx, Ty<'tcx>>,\n+    );\n+\n+    fn maybe_add_note_for_unsatisfied_const(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        trait_predicate: &ty::PolyTraitPredicate<'tcx>,\n+        err: &mut Diagnostic,\n+        span: Span,\n+    ) -> UnsatisfiedConst;\n+\n+    fn report_closure_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        closure_def_id: DefId,\n+        found_kind: ty::ClosureKind,\n+        kind: ty::ClosureKind,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed>;\n+\n+    fn report_type_parameter_mismatch_cyclic_type_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        found_trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        expected_trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        terr: TypeError<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed>;\n+\n+    fn report_type_parameter_mismatch_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        span: Span,\n+        found_trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        expected_trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+    ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>>;\n+\n+    fn report_not_const_evaluatable_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        span: Span,\n+    ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>>;\n }\n \n impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n@@ -2198,6 +1912,51 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         report(normalized_impl_candidates, err)\n     }\n \n+    fn report_similar_impl_candidates_for_root_obligation(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        trait_predicate: ty::Binder<'tcx, ty::TraitPredicate<'tcx>>,\n+        body_def_id: LocalDefId,\n+        err: &mut Diagnostic,\n+    ) {\n+        // This is *almost* equivalent to\n+        // `obligation.cause.code().peel_derives()`, but it gives us the\n+        // trait predicate for that corresponding root obligation. This\n+        // lets us get a derived obligation from a type parameter, like\n+        // when calling `string.strip_suffix(p)` where `p` is *not* an\n+        // implementer of `Pattern<'_>`.\n+        let mut code = obligation.cause.code();\n+        let mut trait_pred = trait_predicate;\n+        let mut peeled = false;\n+        while let Some((parent_code, parent_trait_pred)) = code.parent() {\n+            code = parent_code;\n+            if let Some(parent_trait_pred) = parent_trait_pred {\n+                trait_pred = parent_trait_pred;\n+                peeled = true;\n+            }\n+        }\n+        let def_id = trait_pred.def_id();\n+        // Mention *all* the `impl`s for the *top most* obligation, the\n+        // user might have meant to use one of them, if any found. We skip\n+        // auto-traits or fundamental traits that might not be exactly what\n+        // the user might expect to be presented with. Instead this is\n+        // useful for less general traits.\n+        if peeled\n+            && !self.tcx.trait_is_auto(def_id)\n+            && !self.tcx.lang_items().iter().any(|(_, id)| id == def_id)\n+        {\n+            let trait_ref = trait_pred.to_poly_trait_ref();\n+            let impl_candidates = self.find_similar_impl_candidates(trait_pred);\n+            self.report_similar_impl_candidates(\n+                &impl_candidates,\n+                trait_ref,\n+                body_def_id,\n+                err,\n+                true,\n+            );\n+        }\n+    }\n+\n     /// Gets the parent trait chain start\n     fn get_parent_trait_ref(\n         &self,\n@@ -2930,10 +2689,40 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         false\n     }\n \n+    fn get_standard_error_message(\n+        &self,\n+        trait_predicate: &ty::PolyTraitPredicate<'tcx>,\n+        message: Option<String>,\n+        predicate_is_const: bool,\n+        append_const_msg: Option<AppendConstMessage>,\n+        post_message: String,\n+    ) -> String {\n+        message\n+            .and_then(|cannot_do_this| {\n+                match (predicate_is_const, append_const_msg) {\n+                    // do nothing if predicate is not const\n+                    (false, _) => Some(cannot_do_this),\n+                    // suggested using default post message\n+                    (true, Some(AppendConstMessage::Default)) => {\n+                        Some(format!(\"{cannot_do_this} in const contexts\"))\n+                    }\n+                    // overridden post message\n+                    (true, Some(AppendConstMessage::Custom(custom_msg))) => {\n+                        Some(format!(\"{cannot_do_this}{custom_msg}\"))\n+                    }\n+                    // fallback to generic message\n+                    (true, None) => None,\n+                }\n+            })\n+            .unwrap_or_else(|| {\n+                format!(\"the trait bound `{}` is not satisfied{}\", trait_predicate, post_message)\n+            })\n+    }\n+\n     fn get_safe_transmute_error_and_reason(\n         &self,\n-        obligation: Obligation<'tcx, ty::Predicate<'tcx>>,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        obligation: PredicateObligation<'tcx>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n         span: Span,\n     ) -> (String, Option<String>) {\n         // Erase regions because layout code doesn't particularly care about regions.\n@@ -2991,8 +2780,449 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             _ => span_bug!(span, \"Unsupported rustc_transmute::Reason variant\"),\n         }\n     }\n+\n+    fn add_tuple_trait_message(\n+        &self,\n+        obligation_cause_code: &ObligationCauseCode<'tcx>,\n+        err: &mut Diagnostic,\n+    ) {\n+        match obligation_cause_code {\n+            ObligationCauseCode::RustCall => {\n+                err.set_primary_message(\"functions with the \\\"rust-call\\\" ABI must take a single non-self tuple argument\");\n+            }\n+            ObligationCauseCode::BindingObligation(def_id, _)\n+            | ObligationCauseCode::ItemObligation(def_id)\n+                if self.tcx.is_fn_trait(*def_id) =>\n+            {\n+                err.code(rustc_errors::error_code!(E0059));\n+                err.set_primary_message(format!(\n+                    \"type parameter to bare `{}` trait must be a tuple\",\n+                    self.tcx.def_path_str(*def_id)\n+                ));\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn try_to_add_help_message(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        trait_predicate: &ty::PolyTraitPredicate<'tcx>,\n+        err: &mut Diagnostic,\n+        span: Span,\n+        is_fn_trait: bool,\n+        suggested: bool,\n+        unsatisfied_const: bool,\n+    ) {\n+        let body_def_id = obligation.cause.body_id;\n+        // Try to report a help message\n+        if is_fn_trait\n+            && let Ok((implemented_kind, params)) = self.type_implements_fn_trait(\n+            obligation.param_env,\n+            trait_ref.self_ty(),\n+            trait_predicate.skip_binder().constness,\n+            trait_predicate.skip_binder().polarity,\n+        )\n+        {\n+            self.add_help_message_for_fn_trait(trait_ref, err, implemented_kind, params);\n+        } else if !trait_ref.has_non_region_infer()\n+            && self.predicate_can_apply(obligation.param_env, *trait_predicate)\n+        {\n+            // If a where-clause may be useful, remind the\n+            // user that they can add it.\n+            //\n+            // don't display an on-unimplemented note, as\n+            // these notes will often be of the form\n+            //     \"the type `T` can't be frobnicated\"\n+            // which is somewhat confusing.\n+            self.suggest_restricting_param_bound(\n+                err,\n+                *trait_predicate,\n+                None,\n+                obligation.cause.body_id,\n+            );\n+        } else if !suggested && !unsatisfied_const {\n+            // Can't show anything else useful, try to find similar impls.\n+            let impl_candidates = self.find_similar_impl_candidates(*trait_predicate);\n+            if !self.report_similar_impl_candidates(\n+                &impl_candidates,\n+                trait_ref,\n+                body_def_id,\n+                err,\n+                true,\n+            ) {\n+                self.report_similar_impl_candidates_for_root_obligation(&obligation, *trait_predicate, body_def_id, err);\n+            }\n+\n+            self.maybe_suggest_convert_to_slice(\n+                err,\n+                trait_ref,\n+                impl_candidates.as_slice(),\n+                span,\n+            );\n+        }\n+    }\n+\n+    fn add_help_message_for_fn_trait(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        err: &mut Diagnostic,\n+        implemented_kind: ty::ClosureKind,\n+        params: ty::Binder<'tcx, Ty<'tcx>>,\n+    ) {\n+        // If the type implements `Fn`, `FnMut`, or `FnOnce`, suppress the following\n+        // suggestion to add trait bounds for the type, since we only typically implement\n+        // these traits once.\n+\n+        // Note if the `FnMut` or `FnOnce` is less general than the trait we're trying\n+        // to implement.\n+        let selected_kind = self\n+            .tcx\n+            .fn_trait_kind_from_def_id(trait_ref.def_id())\n+            .expect(\"expected to map DefId to ClosureKind\");\n+        if !implemented_kind.extends(selected_kind) {\n+            err.note(&format!(\n+                \"`{}` implements `{}`, but it must implement `{}`, which is more general\",\n+                trait_ref.skip_binder().self_ty(),\n+                implemented_kind,\n+                selected_kind\n+            ));\n+        }\n+\n+        // Note any argument mismatches\n+        let given_ty = params.skip_binder();\n+        let expected_ty = trait_ref.skip_binder().substs.type_at(1);\n+        if let ty::Tuple(given) = given_ty.kind()\n+            && let ty::Tuple(expected) = expected_ty.kind()\n+        {\n+            if expected.len() != given.len() {\n+                // Note number of types that were expected and given\n+                err.note(\n+                    &format!(\n+                        \"expected a closure taking {} argument{}, but one taking {} argument{} was given\",\n+                        given.len(),\n+                        pluralize!(given.len()),\n+                        expected.len(),\n+                        pluralize!(expected.len()),\n+                    )\n+                );\n+            } else if !self.same_type_modulo_infer(given_ty, expected_ty) {\n+                // Print type mismatch\n+                let (expected_args, given_args) =\n+                    self.cmp(given_ty, expected_ty);\n+                err.note_expected_found(\n+                    &\"a closure with arguments\",\n+                    expected_args,\n+                    &\"a closure with arguments\",\n+                    given_args,\n+                );\n+            }\n+        }\n+    }\n+\n+    fn maybe_add_note_for_unsatisfied_const(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        trait_predicate: &ty::PolyTraitPredicate<'tcx>,\n+        err: &mut Diagnostic,\n+        span: Span,\n+    ) -> UnsatisfiedConst {\n+        let mut unsatisfied_const = UnsatisfiedConst(false);\n+        if trait_predicate.is_const_if_const() && obligation.param_env.is_const() {\n+            let non_const_predicate = trait_ref.without_const();\n+            let non_const_obligation = Obligation {\n+                cause: obligation.cause.clone(),\n+                param_env: obligation.param_env.without_const(),\n+                predicate: non_const_predicate.to_predicate(self.tcx),\n+                recursion_depth: obligation.recursion_depth,\n+            };\n+            if self.predicate_may_hold(&non_const_obligation) {\n+                unsatisfied_const = UnsatisfiedConst(true);\n+                err.span_note(\n+                    span,\n+                    &format!(\n+                        \"the trait `{}` is implemented for `{}`, \\\n+                        but that implementation is not `const`\",\n+                        non_const_predicate.print_modifiers_and_trait_path(),\n+                        trait_ref.skip_binder().self_ty(),\n+                    ),\n+                );\n+            }\n+        }\n+        unsatisfied_const\n+    }\n+\n+    fn report_closure_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        closure_def_id: DefId,\n+        found_kind: ty::ClosureKind,\n+        kind: ty::ClosureKind,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        let closure_span = self.tcx.def_span(closure_def_id);\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            closure_span,\n+            E0525,\n+            \"expected a closure that implements the `{}` trait, \\\n+                but this closure only implements `{}`\",\n+            kind,\n+            found_kind\n+        );\n+\n+        err.span_label(\n+            closure_span,\n+            format!(\"this closure implements `{}`, not `{}`\", found_kind, kind),\n+        );\n+        err.span_label(\n+            obligation.cause.span,\n+            format!(\"the requirement to implement `{}` derives from here\", kind),\n+        );\n+\n+        // Additional context information explaining why the closure only implements\n+        // a particular trait.\n+        if let Some(typeck_results) = &self.typeck_results {\n+            let hir_id = self.tcx.hir().local_def_id_to_hir_id(closure_def_id.expect_local());\n+            match (found_kind, typeck_results.closure_kind_origins().get(hir_id)) {\n+                (ty::ClosureKind::FnOnce, Some((span, place))) => {\n+                    err.span_label(\n+                        *span,\n+                        format!(\n+                            \"closure is `FnOnce` because it moves the \\\n+                            variable `{}` out of its environment\",\n+                            ty::place_to_string_for_capture(self.tcx, place)\n+                        ),\n+                    );\n+                }\n+                (ty::ClosureKind::FnMut, Some((span, place))) => {\n+                    err.span_label(\n+                        *span,\n+                        format!(\n+                            \"closure is `FnMut` because it mutates the \\\n+                            variable `{}` here\",\n+                            ty::place_to_string_for_capture(self.tcx, place)\n+                        ),\n+                    );\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        err\n+    }\n+\n+    fn report_type_parameter_mismatch_cyclic_type_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        found_trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        expected_trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        terr: TypeError<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        let self_ty = found_trait_ref.self_ty().skip_binder();\n+        let (cause, terr) = if let ty::Closure(def_id, _) = self_ty.kind() {\n+            (\n+                ObligationCause::dummy_with_span(self.tcx.def_span(def_id)),\n+                TypeError::CyclicTy(self_ty),\n+            )\n+        } else {\n+            (obligation.cause.clone(), terr)\n+        };\n+        self.report_and_explain_type_error(\n+            TypeTrace::poly_trait_refs(&cause, true, expected_trait_ref, found_trait_ref),\n+            terr,\n+        )\n+    }\n+\n+    fn report_type_parameter_mismatch_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        span: Span,\n+        found_trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        expected_trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+    ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n+        let found_trait_ref = self.resolve_vars_if_possible(found_trait_ref);\n+        let expected_trait_ref = self.resolve_vars_if_possible(expected_trait_ref);\n+\n+        if expected_trait_ref.self_ty().references_error() {\n+            return None;\n+        }\n+\n+        let Some(found_trait_ty) = found_trait_ref.self_ty().no_bound_vars() else {\n+            return None;\n+        };\n+\n+        let found_did = match *found_trait_ty.kind() {\n+            ty::Closure(did, _) | ty::Foreign(did) | ty::FnDef(did, _) | ty::Generator(did, ..) => {\n+                Some(did)\n+            }\n+            ty::Adt(def, _) => Some(def.did()),\n+            _ => None,\n+        };\n+\n+        let found_node = found_did.and_then(|did| self.tcx.hir().get_if_local(did));\n+        let found_span = found_did.and_then(|did| self.tcx.hir().span_if_local(did));\n+\n+        if self.reported_closure_mismatch.borrow().contains(&(span, found_span)) {\n+            // We check closures twice, with obligations flowing in different directions,\n+            // but we want to complain about them only once.\n+            return None;\n+        }\n+\n+        self.reported_closure_mismatch.borrow_mut().insert((span, found_span));\n+\n+        let mut not_tupled = false;\n+\n+        let found = match found_trait_ref.skip_binder().substs.type_at(1).kind() {\n+            ty::Tuple(ref tys) => vec![ArgKind::empty(); tys.len()],\n+            _ => {\n+                not_tupled = true;\n+                vec![ArgKind::empty()]\n+            }\n+        };\n+\n+        let expected_ty = expected_trait_ref.skip_binder().substs.type_at(1);\n+        let expected = match expected_ty.kind() {\n+            ty::Tuple(ref tys) => {\n+                tys.iter().map(|t| ArgKind::from_expected_ty(t, Some(span))).collect()\n+            }\n+            _ => {\n+                not_tupled = true;\n+                vec![ArgKind::Arg(\"_\".to_owned(), expected_ty.to_string())]\n+            }\n+        };\n+\n+        // If this is a `Fn` family trait and either the expected or found\n+        // is not tupled, then fall back to just a regular mismatch error.\n+        // This shouldn't be common unless manually implementing one of the\n+        // traits manually, but don't make it more confusing when it does\n+        // happen.\n+        Some(\n+            if Some(expected_trait_ref.def_id()) != self.tcx.lang_items().gen_trait() && not_tupled\n+            {\n+                self.report_and_explain_type_error(\n+                    TypeTrace::poly_trait_refs(\n+                        &obligation.cause,\n+                        true,\n+                        expected_trait_ref,\n+                        found_trait_ref,\n+                    ),\n+                    ty::error::TypeError::Mismatch,\n+                )\n+            } else if found.len() == expected.len() {\n+                self.report_closure_arg_mismatch(\n+                    span,\n+                    found_span,\n+                    found_trait_ref,\n+                    expected_trait_ref,\n+                    obligation.cause.code(),\n+                    found_node,\n+                    obligation.param_env,\n+                )\n+            } else {\n+                let (closure_span, closure_arg_span, found) = found_did\n+                    .and_then(|did| {\n+                        let node = self.tcx.hir().get_if_local(did)?;\n+                        let (found_span, closure_arg_span, found) =\n+                            self.get_fn_like_arguments(node)?;\n+                        Some((Some(found_span), closure_arg_span, found))\n+                    })\n+                    .unwrap_or((found_span, None, found));\n+\n+                self.report_arg_count_mismatch(\n+                    span,\n+                    closure_span,\n+                    expected,\n+                    found,\n+                    found_trait_ty.is_closure(),\n+                    closure_arg_span,\n+                )\n+            },\n+        )\n+    }\n+\n+    fn report_not_const_evaluatable_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        span: Span,\n+    ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n+        if !self.tcx.features().generic_const_exprs {\n+            let mut err = self\n+                .tcx\n+                .sess\n+                .struct_span_err(span, \"constant expression depends on a generic parameter\");\n+            // FIXME(const_generics): we should suggest to the user how they can resolve this\n+            // issue. However, this is currently not actually possible\n+            // (see https://github.com/rust-lang/rust/issues/66962#issuecomment-575907083).\n+            //\n+            // Note that with `feature(generic_const_exprs)` this case should not\n+            // be reachable.\n+            err.note(\"this may fail depending on what value the parameter takes\");\n+            err.emit();\n+            return None;\n+        }\n+\n+        match obligation.predicate.kind().skip_binder() {\n+            ty::PredicateKind::ConstEvaluatable(ct) => {\n+                let ty::ConstKind::Unevaluated(uv) = ct.kind() else {\n+                    bug!(\"const evaluatable failed for non-unevaluated const `{ct:?}`\");\n+                };\n+                let mut err = self.tcx.sess.struct_span_err(span, \"unconstrained generic constant\");\n+                let const_span = self.tcx.def_span(uv.def);\n+                match self.tcx.sess.source_map().span_to_snippet(const_span) {\n+                    Ok(snippet) => err.help(&format!(\n+                        \"try adding a `where` bound using this expression: `where [(); {}]:`\",\n+                        snippet\n+                    )),\n+                    _ => err.help(\"consider adding a `where` bound using this expression\"),\n+                };\n+                Some(err)\n+            }\n+            _ => {\n+                span_bug!(\n+                    span,\n+                    \"unexpected non-ConstEvaluatable predicate, this should not be reachable\"\n+                )\n+            }\n+        }\n+    }\n }\n \n+struct UnsatisfiedConst(pub bool);\n+\n+fn get_explanation_based_on_obligation<'tcx>(\n+    obligation: &PredicateObligation<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+    trait_predicate: &ty::PolyTraitPredicate<'tcx>,\n+    pre_message: String,\n+) -> String {\n+    if let ObligationCauseCode::MainFunctionType = obligation.cause.code() {\n+        \"consider using `()`, or a `Result`\".to_owned()\n+    } else {\n+        let ty_desc = match trait_ref.skip_binder().self_ty().kind() {\n+            ty::FnDef(_, _) => Some(\"fn item\"),\n+            ty::Closure(_, _) => Some(\"closure\"),\n+            _ => None,\n+        };\n+\n+        match ty_desc {\n+            Some(desc) => format!(\n+                \"{}the trait `{}` is not implemented for {} `{}`\",\n+                pre_message,\n+                trait_predicate.print_modifiers_and_trait_path(),\n+                desc,\n+                trait_ref.skip_binder().self_ty(),\n+            ),\n+            None => format!(\n+                \"{}the trait `{}` is not implemented for `{}`\",\n+                pre_message,\n+                trait_predicate.print_modifiers_and_trait_path(),\n+                trait_ref.skip_binder().self_ty(),\n+            ),\n+        }\n+    }\n+}\n /// Crude way of getting back an `Expr` from a `Span`.\n pub struct FindExprBySpan<'hir> {\n     pub span: Span,"}, {"sha": "88525e1b720af580315aa982d4dd1848a579ab22", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -327,7 +327,7 @@ pub struct OnUnimplementedDirective {\n     pub label: Option<OnUnimplementedFormatString>,\n     pub note: Option<OnUnimplementedFormatString>,\n     pub parent_label: Option<OnUnimplementedFormatString>,\n-    pub append_const_msg: Option<Option<Symbol>>,\n+    pub append_const_msg: Option<AppendConstMessage>,\n }\n \n /// For the `#[rustc_on_unimplemented]` attribute\n@@ -337,11 +337,21 @@ pub struct OnUnimplementedNote {\n     pub label: Option<String>,\n     pub note: Option<String>,\n     pub parent_label: Option<String>,\n-    /// Append a message for `~const Trait` errors. `None` means not requested and\n-    /// should fallback to a generic message, `Some(None)` suggests using the default\n-    /// appended message, `Some(Some(s))` suggests use the `s` message instead of the\n-    /// default one..\n-    pub append_const_msg: Option<Option<Symbol>>,\n+    // If none, should fall back to a generic message\n+    pub append_const_msg: Option<AppendConstMessage>,\n+}\n+\n+/// Append a message for `~const Trait` errors.\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+pub enum AppendConstMessage {\n+    Default,\n+    Custom(Symbol),\n+}\n+\n+impl Default for AppendConstMessage {\n+    fn default() -> Self {\n+        AppendConstMessage::Default\n+    }\n }\n \n impl<'tcx> OnUnimplementedDirective {\n@@ -419,10 +429,10 @@ impl<'tcx> OnUnimplementedDirective {\n                 }\n             } else if item.has_name(sym::append_const_msg) && append_const_msg.is_none() {\n                 if let Some(msg) = item.value_str() {\n-                    append_const_msg = Some(Some(msg));\n+                    append_const_msg = Some(AppendConstMessage::Custom(msg));\n                     continue;\n                 } else if item.is_word() {\n-                    append_const_msg = Some(None);\n+                    append_const_msg = Some(AppendConstMessage::Default);\n                     continue;\n                 }\n             }"}, {"sha": "c969e5d4975fc705aa6f405323395b0d7137cda2", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -386,7 +386,7 @@ pub trait TypeErrCtxtExt<'tcx> {\n     fn maybe_suggest_convert_to_slice(\n         &self,\n         err: &mut Diagnostic,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n         candidate_impls: &[ImplCandidate<'tcx>],\n         span: Span,\n     );\n@@ -3848,7 +3848,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     fn maybe_suggest_convert_to_slice(\n         &self,\n         err: &mut Diagnostic,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n         candidate_impls: &[ImplCandidate<'tcx>],\n         span: Span,\n     ) {"}, {"sha": "95c07abf73106647bc3a6c3f3909caff11cce0ed", "filename": "library/alloc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/library%2Falloc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/library%2Falloc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2FCargo.toml?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -35,6 +35,3 @@ compiler-builtins-mem = ['compiler_builtins/mem']\n compiler-builtins-c = [\"compiler_builtins/c\"]\n compiler-builtins-no-asm = [\"compiler_builtins/no-asm\"]\n compiler-builtins-mangled-names = [\"compiler_builtins/mangled-names\"]\n-\n-# Make panics and failed asserts immediately abort without formatting any message\n-panic_immediate_abort = [\"core/panic_immediate_abort\"]"}, {"sha": "6f2ba957bcda0995ac98952ae60666991d7df76b", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 17, "deletions": 77, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -14,11 +14,6 @@ use core::ptr::{self, NonNull};\n #[doc(inline)]\n pub use core::alloc::*;\n \n-#[cfg(not(no_global_oom_handling))]\n-use core::any::Any;\n-#[cfg(not(no_global_oom_handling))]\n-use core::panic::BoxMeUp;\n-\n #[cfg(test)]\n mod tests;\n \n@@ -348,84 +343,28 @@ pub(crate) unsafe fn box_free<T: ?Sized, A: Allocator>(ptr: Unique<T>, alloc: A)\n     }\n }\n \n-/// Payload passed to the panic handler when `handle_alloc_error` is called.\n-#[unstable(feature = \"panic_oom_payload\", issue = \"none\")]\n-#[derive(Debug)]\n-pub struct AllocErrorPanicPayload {\n-    layout: Layout,\n-}\n-\n-impl AllocErrorPanicPayload {\n-    /// Internal function for the standard library to clone a payload.\n-    #[unstable(feature = \"std_internals\", issue = \"none\")]\n-    #[doc(hidden)]\n-    pub fn internal_clone(&self) -> Self {\n-        AllocErrorPanicPayload { layout: self.layout }\n-    }\n-\n-    /// Returns the [`Layout`] of the allocation attempt that caused the error.\n-    #[unstable(feature = \"panic_oom_payload\", issue = \"none\")]\n-    pub fn layout(&self) -> Layout {\n-        self.layout\n-    }\n-}\n-\n-#[unstable(feature = \"std_internals\", issue = \"none\")]\n-#[cfg(not(no_global_oom_handling))]\n-unsafe impl BoxMeUp for AllocErrorPanicPayload {\n-    fn take_box(&mut self) -> *mut (dyn Any + Send) {\n-        use crate::boxed::Box;\n-        Box::into_raw(Box::new(self.internal_clone()))\n-    }\n-\n-    fn get(&mut self) -> &(dyn Any + Send) {\n-        self\n-    }\n-}\n-\n // # Allocation error handler\n \n-#[cfg(all(not(no_global_oom_handling), not(test)))]\n-fn rust_oom(layout: Layout) -> ! {\n-    if cfg!(feature = \"panic_immediate_abort\") {\n-        core::intrinsics::abort()\n-    }\n-\n-    extern \"Rust\" {\n-        // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n-        // that gets resolved to the `#[panic_handler]` function.\n-        #[lang = \"panic_impl\"]\n-        fn panic_impl(pi: &core::panic::PanicInfo<'_>) -> !;\n-\n-        // This symbol is emitted by rustc .\n-        // Its value depends on the -Zoom={unwind,abort} compiler option.\n-        static __rust_alloc_error_handler_should_panic: u8;\n-    }\n-\n-    // Hack to work around issues with the lifetime of Arguments.\n-    match format_args!(\"memory allocation of {} bytes failed\", layout.size()) {\n-        fmt => {\n-            // Create a PanicInfo with a custom payload for the panic handler.\n-            let can_unwind = unsafe { __rust_alloc_error_handler_should_panic != 0 };\n-            let mut pi = core::panic::PanicInfo::internal_constructor(\n-                Some(&fmt),\n-                core::panic::Location::caller(),\n-                can_unwind,\n-            );\n-            let payload = AllocErrorPanicPayload { layout };\n-            pi.set_payload(&payload);\n-\n-            // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n-            unsafe { panic_impl(&pi) }\n-        }\n-    }\n+#[cfg(not(no_global_oom_handling))]\n+extern \"Rust\" {\n+    // This is the magic symbol to call the global alloc error handler. rustc generates\n+    // it to call `__rg_oom` if there is a `#[alloc_error_handler]`, or to call the\n+    // default implementations below (`__rdl_oom`) otherwise.\n+    fn __rust_alloc_error_handler(size: usize, align: usize) -> !;\n }\n \n /// Abort on memory allocation error or failure.\n ///\n /// Callers of memory allocation APIs wishing to abort computation\n /// in response to an allocation error are encouraged to call this function,\n /// rather than directly invoking `panic!` or similar.\n+///\n+/// The default behavior of this function is to print a message to standard error\n+/// and abort the process.\n+/// It can be replaced with [`set_alloc_error_hook`] and [`take_alloc_error_hook`].\n+///\n+/// [`set_alloc_error_hook`]: ../../std/alloc/fn.set_alloc_error_hook.html\n+/// [`take_alloc_error_hook`]: ../../std/alloc/fn.take_alloc_error_hook.html\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[rustc_const_unstable(feature = \"const_alloc_error\", issue = \"92523\")]\n #[cfg(all(not(no_global_oom_handling), not(test)))]\n@@ -436,7 +375,9 @@ pub const fn handle_alloc_error(layout: Layout) -> ! {\n     }\n \n     fn rt_error(layout: Layout) -> ! {\n-        rust_oom(layout);\n+        unsafe {\n+            __rust_alloc_error_handler(layout.size(), layout.align());\n+        }\n     }\n \n     unsafe { core::intrinsics::const_eval_select((layout,), ct_error, rt_error) }\n@@ -446,7 +387,6 @@ pub const fn handle_alloc_error(layout: Layout) -> ! {\n #[cfg(all(not(no_global_oom_handling), test))]\n pub use std::alloc::handle_alloc_error;\n \n-#[cfg(bootstrap)]\n #[cfg(all(not(no_global_oom_handling), not(test)))]\n #[doc(hidden)]\n #[allow(unused_attributes)]\n@@ -458,7 +398,7 @@ pub mod __alloc_error_handler {\n     pub unsafe fn __rdl_oom(size: usize, _align: usize) -> ! {\n         extern \"Rust\" {\n             // This symbol is emitted by rustc next to __rust_alloc_error_handler.\n-            // Its value depends on the -Zoom={unwind,abort} compiler option.\n+            // Its value depends on the -Zoom={panic,abort} compiler option.\n             static __rust_alloc_error_handler_should_panic: u8;\n         }\n "}, {"sha": "a002421aeef3a472d1cb2cf544b8104338518154", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -135,7 +135,6 @@\n #![feature(maybe_uninit_slice)]\n #![feature(maybe_uninit_uninit_array)]\n #![feature(maybe_uninit_uninit_array_transpose)]\n-#![feature(panic_internals)]\n #![feature(pattern)]\n #![feature(pointer_byte_offsets)]\n #![feature(provide_any)]"}, {"sha": "7c93c93b4a0199de1473dc2ab6a7196e70fa0a60", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -1531,6 +1531,16 @@ pub(crate) mod builtin {\n         /* compiler built-in */\n     }\n \n+    /// Attribute macro applied to a function to register it as a handler for allocation failure.\n+    ///\n+    /// See also [`std::alloc::handle_alloc_error`](../../../std/alloc/fn.handle_alloc_error.html).\n+    #[unstable(feature = \"alloc_error_handler\", issue = \"51540\")]\n+    #[allow_internal_unstable(rustc_attrs)]\n+    #[rustc_builtin_macro]\n+    pub macro alloc_error_handler($item:item) {\n+        /* compiler built-in */\n+    }\n+\n     /// Keeps the item it's applied to if the passed path is accessible, and removes it otherwise.\n     #[unstable(\n         feature = \"cfg_accessible\","}, {"sha": "10525a16f3a66ebd8970cf8a13afb23351c6d22a", "filename": "library/core/src/prelude/v1.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -76,7 +76,9 @@ pub use crate::macros::builtin::{RustcDecodable, RustcEncodable};\n // Do not `doc(no_inline)` so that they become doc items on their own\n // (no public module for them to be re-exported from).\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n-pub use crate::macros::builtin::{bench, derive, global_allocator, test, test_case};\n+pub use crate::macros::builtin::{\n+    alloc_error_handler, bench, derive, global_allocator, test, test_case,\n+};\n \n #[unstable(feature = \"derive_const\", issue = \"none\")]\n pub use crate::macros::builtin::derive_const;"}, {"sha": "f2fda64a1ee72f7e31e5c723ada4abf1800a1976", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -67,7 +67,7 @@ llvm-libunwind = [\"unwind/llvm-libunwind\"]\n system-llvm-libunwind = [\"unwind/system-llvm-libunwind\"]\n \n # Make panics and failed asserts immediately abort without formatting any message\n-panic_immediate_abort = [\"alloc/panic_immediate_abort\"]\n+panic_immediate_abort = [\"core/panic_immediate_abort\"]\n \n # Enable std_detect default features for stdarch/crates/std_detect:\n # https://github.com/rust-lang/stdarch/blob/master/crates/std_detect/Cargo.toml"}, {"sha": "c5a5991cc81c47d340a3b7b113c56339671acd7e", "filename": "library/std/src/alloc.rs", "status": "modified", "additions": 72, "deletions": 1, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/library%2Fstd%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/library%2Fstd%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Falloc.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -57,8 +57,9 @@\n #![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n \n use core::intrinsics;\n-use core::ptr;\n use core::ptr::NonNull;\n+use core::sync::atomic::{AtomicPtr, Ordering};\n+use core::{mem, ptr};\n \n #[stable(feature = \"alloc_module\", since = \"1.28.0\")]\n #[doc(inline)]\n@@ -285,6 +286,76 @@ unsafe impl Allocator for System {\n     }\n }\n \n+static HOOK: AtomicPtr<()> = AtomicPtr::new(ptr::null_mut());\n+\n+/// Registers a custom allocation error hook, replacing any that was previously registered.\n+///\n+/// The allocation error hook is invoked when an infallible memory allocation fails, before\n+/// the runtime aborts. The default hook prints a message to standard error,\n+/// but this behavior can be customized with the [`set_alloc_error_hook`] and\n+/// [`take_alloc_error_hook`] functions.\n+///\n+/// The hook is provided with a `Layout` struct which contains information\n+/// about the allocation that failed.\n+///\n+/// The allocation error hook is a global resource.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(alloc_error_hook)]\n+///\n+/// use std::alloc::{Layout, set_alloc_error_hook};\n+///\n+/// fn custom_alloc_error_hook(layout: Layout) {\n+///    panic!(\"memory allocation of {} bytes failed\", layout.size());\n+/// }\n+///\n+/// set_alloc_error_hook(custom_alloc_error_hook);\n+/// ```\n+#[unstable(feature = \"alloc_error_hook\", issue = \"51245\")]\n+pub fn set_alloc_error_hook(hook: fn(Layout)) {\n+    HOOK.store(hook as *mut (), Ordering::SeqCst);\n+}\n+\n+/// Unregisters the current allocation error hook, returning it.\n+///\n+/// *See also the function [`set_alloc_error_hook`].*\n+///\n+/// If no custom hook is registered, the default hook will be returned.\n+#[unstable(feature = \"alloc_error_hook\", issue = \"51245\")]\n+pub fn take_alloc_error_hook() -> fn(Layout) {\n+    let hook = HOOK.swap(ptr::null_mut(), Ordering::SeqCst);\n+    if hook.is_null() { default_alloc_error_hook } else { unsafe { mem::transmute(hook) } }\n+}\n+\n+fn default_alloc_error_hook(layout: Layout) {\n+    extern \"Rust\" {\n+        // This symbol is emitted by rustc next to __rust_alloc_error_handler.\n+        // Its value depends on the -Zoom={panic,abort} compiler option.\n+        static __rust_alloc_error_handler_should_panic: u8;\n+    }\n+\n+    #[allow(unused_unsafe)]\n+    if unsafe { __rust_alloc_error_handler_should_panic != 0 } {\n+        panic!(\"memory allocation of {} bytes failed\", layout.size());\n+    } else {\n+        rtprintpanic!(\"memory allocation of {} bytes failed\\n\", layout.size());\n+    }\n+}\n+\n+#[cfg(not(test))]\n+#[doc(hidden)]\n+#[alloc_error_handler]\n+#[unstable(feature = \"alloc_internals\", issue = \"none\")]\n+pub fn rust_oom(layout: Layout) -> ! {\n+    let hook = HOOK.load(Ordering::SeqCst);\n+    let hook: fn(Layout) =\n+        if hook.is_null() { default_alloc_error_hook } else { unsafe { mem::transmute(hook) } };\n+    hook(layout);\n+    crate::process::abort()\n+}\n+\n #[cfg(not(test))]\n #[doc(hidden)]\n #[allow(unused_attributes)]"}, {"sha": "318a46d1b637e53eddfd56779bf76853265bc814", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -236,6 +236,7 @@\n //\n // Language features:\n // tidy-alphabetical-start\n+#![feature(alloc_error_handler)]\n #![feature(allocator_internals)]\n #![feature(allow_internal_unsafe)]\n #![feature(allow_internal_unstable)]\n@@ -319,7 +320,6 @@\n #![feature(get_mut_unchecked)]\n #![feature(map_try_insert)]\n #![feature(new_uninit)]\n-#![feature(panic_oom_payload)]\n #![feature(slice_concat_trait)]\n #![feature(thin_box)]\n #![feature(try_reserve_kind)]"}, {"sha": "a46a29cbad6081400329485378ea87808bbc2512", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -245,24 +245,19 @@ fn default_hook(info: &PanicInfo<'_>) {\n \n     // The current implementation always returns `Some`.\n     let location = info.location().unwrap();\n+\n+    let msg = match info.payload().downcast_ref::<&'static str>() {\n+        Some(s) => *s,\n+        None => match info.payload().downcast_ref::<String>() {\n+            Some(s) => &s[..],\n+            None => \"Box<dyn Any>\",\n+        },\n+    };\n     let thread = thread_info::current_thread();\n     let name = thread.as_ref().and_then(|t| t.name()).unwrap_or(\"<unnamed>\");\n \n     let write = |err: &mut dyn crate::io::Write| {\n-        // Use the panic message directly if available, otherwise take it from\n-        // the payload.\n-        if let Some(msg) = info.message() {\n-            let _ = writeln!(err, \"thread '{name}' panicked at '{msg}', {location}\");\n-        } else {\n-            let msg = if let Some(s) = info.payload().downcast_ref::<&'static str>() {\n-                *s\n-            } else if let Some(s) = info.payload().downcast_ref::<String>() {\n-                &s[..]\n-            } else {\n-                \"Box<dyn Any>\"\n-            };\n-            let _ = writeln!(err, \"thread '{name}' panicked at '{msg}', {location}\");\n-        }\n+        let _ = writeln!(err, \"thread '{name}' panicked at '{msg}', {location}\");\n \n         static FIRST_PANIC: AtomicBool = AtomicBool::new(true);\n \n@@ -529,8 +524,6 @@ pub fn panicking() -> bool {\n #[cfg(not(test))]\n #[panic_handler]\n pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n-    use alloc::alloc::AllocErrorPanicPayload;\n-\n     struct PanicPayload<'a> {\n         inner: &'a fmt::Arguments<'a>,\n         string: Option<String>,\n@@ -557,7 +550,8 @@ pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n     unsafe impl<'a> BoxMeUp for PanicPayload<'a> {\n         fn take_box(&mut self) -> *mut (dyn Any + Send) {\n             // We do two allocations here, unfortunately. But (a) they're required with the current\n-            // scheme, and (b) OOM uses its own separate payload type which doesn't allocate.\n+            // scheme, and (b) we don't handle panic + OOM properly anyway (see comment in\n+            // begin_panic below).\n             let contents = mem::take(self.fill());\n             Box::into_raw(Box::new(contents))\n         }\n@@ -582,14 +576,7 @@ pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n     let loc = info.location().unwrap(); // The current implementation always returns Some\n     let msg = info.message().unwrap(); // The current implementation always returns Some\n     crate::sys_common::backtrace::__rust_end_short_backtrace(move || {\n-        if let Some(payload) = info.payload().downcast_ref::<AllocErrorPanicPayload>() {\n-            rust_panic_with_hook(\n-                &mut payload.internal_clone(),\n-                info.message(),\n-                loc,\n-                info.can_unwind(),\n-            );\n-        } else if let Some(msg) = msg.as_str() {\n+        if let Some(msg) = msg.as_str() {\n             rust_panic_with_hook(&mut StrPanicPayload(msg), info.message(), loc, info.can_unwind());\n         } else {\n             rust_panic_with_hook(\n@@ -636,7 +623,11 @@ pub const fn begin_panic<M: Any + Send>(msg: M) -> ! {\n \n     unsafe impl<A: Send + 'static> BoxMeUp for PanicPayload<A> {\n         fn take_box(&mut self) -> *mut (dyn Any + Send) {\n-            // Note that this should be the only allocation performed in this code path.\n+            // Note that this should be the only allocation performed in this code path. Currently\n+            // this means that panic!() on OOM will invoke this code path, but then again we're not\n+            // really ready for panic on OOM anyway. If we do start doing this, then we should\n+            // propagate this allocation to be performed in the parent of this thread instead of the\n+            // thread that's panicking.\n             let data = match self.inner.take() {\n                 Some(a) => Box::new(a) as Box<dyn Any + Send>,\n                 None => process::abort(),"}, {"sha": "2aefd7c513dc8d88421600a69b408a23a5b10aa7", "filename": "library/std/src/prelude/v1.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -60,7 +60,9 @@ pub use core::prelude::v1::{RustcDecodable, RustcEncodable};\n // Do not `doc(no_inline)` so that they become doc items on their own\n // (no public module for them to be re-exported from).\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n-pub use core::prelude::v1::{bench, derive, global_allocator, test, test_case};\n+pub use core::prelude::v1::{\n+    alloc_error_handler, bench, derive, global_allocator, test, test_case,\n+};\n \n #[unstable(feature = \"derive_const\", issue = \"none\")]\n pub use core::prelude::v1::derive_const;"}, {"sha": "dd1851e29a93024244738d2cfdc6db7972aa6fb8", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -139,6 +139,10 @@ def v(*args):\n   \"mips64-unknown-linux-muslabi64 install directory\")\n v(\"musl-root-mips64el\", \"target.mips64el-unknown-linux-muslabi64.musl-root\",\n   \"mips64el-unknown-linux-muslabi64 install directory\")\n+v(\"musl-root-riscv32gc\", \"target.riscv32gc-unknown-linux-musl.musl-root\",\n+  \"riscv32gc-unknown-linux-musl install directory\")\n+v(\"musl-root-riscv64gc\", \"target.riscv64gc-unknown-linux-musl.musl-root\",\n+  \"riscv64gc-unknown-linux-musl install directory\")\n v(\"qemu-armhf-rootfs\", \"target.arm-unknown-linux-gnueabihf.qemu-rootfs\",\n   \"rootfs in qemu testing, you probably don't want to use this\")\n v(\"qemu-aarch64-rootfs\", \"target.aarch64-unknown-linux-gnu.qemu-rootfs\","}, {"sha": "8fa6b854d515506d825390fe0d817f5ef0c89350", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -1 +1 @@\n-Subproject commit c06006157b14b3d47b5c716fc392b77f3b2e21ce\n+Subproject commit 8fa6b854d515506d825390fe0d817f5ef0c89350"}, {"sha": "897fcf566f16bf87bf37199bdddec1801fd00532", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -1 +1 @@\n-Subproject commit 701d1551429da4cb609082c0ac99df569e336710\n+Subproject commit 897fcf566f16bf87bf37199bdddec1801fd00532"}, {"sha": "2a5eb92197e9cf8fe91164dcbf4f9b88c0d7e73d", "filename": "src/doc/rustc-dev-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-dev-guide?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -1 +1 @@\n-Subproject commit 6337ed17fb8dcd918d78b7d97d213e923530337c\n+Subproject commit 2a5eb92197e9cf8fe91164dcbf4f9b88c0d7e73d"}, {"sha": "f7c1e683d0d20366df5ba7e87c910934deadca89", "filename": "src/tools/rust-analyzer/crates/hir-def/src/builtin_attr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbuiltin_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbuiltin_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbuiltin_attr.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -381,6 +381,10 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n \n     rustc_attr!(rustc_allocator, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n     rustc_attr!(rustc_nounwind, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n+    gated!(\n+        alloc_error_handler, Normal, template!(Word), WarnFollowing,\n+        experimental!(alloc_error_handler)\n+    ),\n     gated!(\n         default_lib_allocator, Normal, template!(Word), WarnFollowing, allocator_internals,\n         experimental!(default_lib_allocator),"}, {"sha": "4a60432c14c18592e1f6c2c8799ee21bae7e32fd", "filename": "tests/run-make/coverage-reports/expected_show_coverage.issue-84561.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.issue-84561.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.issue-84561.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.issue-84561.txt?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -136,10 +136,10 @@\n   134|       |\n   135|       |impl std::fmt::Debug for Foo {\n   136|       |    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-  137|      9|        write!(f, \"try and succeed\")?;\n+  137|      7|        write!(f, \"try and succeed\")?;\n                                                   ^0\n-  138|      9|        Ok(())\n-  139|      9|    }\n+  138|      7|        Ok(())\n+  139|      7|    }\n   140|       |}\n   141|       |\n   142|       |static mut DEBUG_LEVEL_ENABLED: bool = false;"}, {"sha": "c93645369928c4dce0ac7dd2399b456687a54f3b", "filename": "tests/run-make/issue-51671/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Frun-make%2Fissue-51671%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Frun-make%2Fissue-51671%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fissue-51671%2FMakefile?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -6,3 +6,4 @@ all:\n \t$(RUSTC) --emit=obj app.rs\n \tnm $(TMPDIR)/app.o | $(CGREP) rust_begin_unwind\n \tnm $(TMPDIR)/app.o | $(CGREP) rust_eh_personality\n+\tnm $(TMPDIR)/app.o | $(CGREP) __rg_oom"}, {"sha": "e9dc1e9744fb143a2c406f72de9425a33fde97b8", "filename": "tests/run-make/issue-51671/app.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Frun-make%2Fissue-51671%2Fapp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Frun-make%2Fissue-51671%2Fapp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fissue-51671%2Fapp.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -1,5 +1,5 @@\n #![crate_type = \"bin\"]\n-#![feature(lang_items)]\n+#![feature(lang_items, alloc_error_handler)]\n #![no_main]\n #![no_std]\n \n@@ -13,3 +13,8 @@ fn panic(_: &PanicInfo) -> ! {\n \n #[lang = \"eh_personality\"]\n fn eh() {}\n+\n+#[alloc_error_handler]\n+fn oom(_: Layout) -> ! {\n+    loop {}\n+}"}, {"sha": "b1229d1b07fc725f4a9bcc5cf8e6166b9d8932c9", "filename": "tests/run-make/issue-69368/Makefile", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Frun-make%2Fissue-69368%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Frun-make%2Fissue-69368%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fissue-69368%2FMakefile?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -0,0 +1,19 @@\n+# ignore-cross-compile\n+include ../tools.mk\n+\n+# Test that previously triggered a linker failure with root cause\n+# similar to one found in the issue #69368.\n+#\n+# The crate that provides oom lang item is missing some other lang\n+# items. Necessary to prevent the use of start-group / end-group.\n+#\n+# The weak lang items are defined in a separate compilation units,\n+# so that linker could omit them if not used.\n+#\n+# The crates that need those weak lang items are dependencies of\n+# crates that provide them.\n+\n+all:\n+\t$(RUSTC) a.rs\n+\t$(RUSTC) b.rs\n+\t$(RUSTC) c.rs"}, {"sha": "a54f429550e7435ed53fd6bc9f6361efceb9ee07", "filename": "tests/run-make/issue-69368/a.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Frun-make%2Fissue-69368%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Frun-make%2Fissue-69368%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fissue-69368%2Fa.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -0,0 +1,26 @@\n+#![crate_type = \"rlib\"]\n+#![feature(lang_items)]\n+#![feature(panic_unwind)]\n+#![no_std]\n+\n+extern crate panic_unwind;\n+\n+#[panic_handler]\n+pub fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n+    loop {}\n+}\n+\n+#[no_mangle]\n+extern \"C\" fn __rust_drop_panic() -> ! {\n+    loop {}\n+}\n+\n+#[no_mangle]\n+extern \"C\" fn __rust_foreign_exception() -> ! {\n+    loop {}\n+}\n+\n+#[lang = \"eh_personality\"]\n+fn eh_personality() {\n+    loop {}\n+}"}, {"sha": "4d6af0266563bddc124cb1e5710bd744ce027e4d", "filename": "tests/run-make/issue-69368/b.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Frun-make%2Fissue-69368%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Frun-make%2Fissue-69368%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fissue-69368%2Fb.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -0,0 +1,8 @@\n+#![crate_type = \"rlib\"]\n+#![feature(alloc_error_handler)]\n+#![no_std]\n+\n+#[alloc_error_handler]\n+pub fn error_handler(_: core::alloc::Layout) -> ! {\n+    panic!();\n+}"}, {"sha": "729c4249a053a8324b3688223b882284af798e16", "filename": "tests/run-make/issue-69368/c.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Frun-make%2Fissue-69368%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Frun-make%2Fissue-69368%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fissue-69368%2Fc.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -0,0 +1,34 @@\n+#![crate_type = \"bin\"]\n+#![feature(start)]\n+#![no_std]\n+\n+extern crate alloc;\n+extern crate a;\n+extern crate b;\n+\n+use alloc::vec::Vec;\n+use core::alloc::*;\n+\n+struct Allocator;\n+\n+unsafe impl GlobalAlloc for Allocator {\n+    unsafe fn alloc(&self, _: Layout) -> *mut u8 {\n+        loop {}\n+    }\n+\n+    unsafe fn dealloc(&self, _: *mut u8, _: Layout) {\n+        loop {}\n+    }\n+}\n+\n+#[global_allocator]\n+static ALLOCATOR: Allocator = Allocator;\n+\n+#[start]\n+fn main(argc: isize, _argv: *const *const u8) -> isize {\n+    let mut v = Vec::new();\n+    for i in 0..argc {\n+        v.push(i);\n+    }\n+    v.iter().sum()\n+}"}, {"sha": "6ffbd3ec6900dc3e1f97255ef1f9b5f508975f1f", "filename": "tests/run-make/wasm-symbols-not-exported/bar.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Frun-make%2Fwasm-symbols-not-exported%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Frun-make%2Fwasm-symbols-not-exported%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fwasm-symbols-not-exported%2Fbar.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -1,4 +1,4 @@\n-#![feature(panic_handler)]\n+#![feature(panic_handler, alloc_error_handler)]\n #![crate_type = \"cdylib\"]\n #![no_std]\n \n@@ -24,6 +24,11 @@ pub extern fn foo(a: u32) -> u32 {\n     a * 2\n }\n \n+#[alloc_error_handler]\n+fn a(_: core::alloc::Layout) -> ! {\n+    loop {}\n+}\n+\n #[panic_handler]\n fn b(_: &core::panic::PanicInfo) -> ! {\n     loop {}"}, {"sha": "cd06423e3a557279ebb5fe61522922fdf3a0f126", "filename": "tests/ui/alloc-error/alloc-error-handler-bad-signature-1.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-1.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -0,0 +1,18 @@\n+// compile-flags:-C panic=abort\n+\n+#![feature(alloc_error_handler)]\n+#![no_std]\n+#![no_main]\n+\n+use core::alloc::Layout;\n+\n+#[alloc_error_handler]\n+fn oom(\n+    info: &Layout, //~^ ERROR mismatched types\n+) -> () //~^^ ERROR mismatched types\n+{\n+    loop {}\n+}\n+\n+#[panic_handler]\n+fn panic(_: &core::panic::PanicInfo) -> ! { loop {} }"}, {"sha": "de92841d7f18e835699495ea9f5e8744ea74cebb", "filename": "tests/ui/alloc-error/alloc-error-handler-bad-signature-1.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-1.stderr?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -0,0 +1,44 @@\n+error[E0308]: mismatched types\n+  --> $DIR/alloc-error-handler-bad-signature-1.rs:10:1\n+   |\n+LL |    #[alloc_error_handler]\n+   |    ---------------------- in this procedural macro expansion\n+LL | // fn oom(\n+LL | ||     info: &Layout,\n+LL | || ) -> ()\n+   | ||_______- arguments to this function are incorrect\n+LL | |  {\n+LL | |      loop {}\n+LL | |  }\n+   | |__^ expected `&Layout`, found `Layout`\n+   |\n+note: function defined here\n+  --> $DIR/alloc-error-handler-bad-signature-1.rs:10:4\n+   |\n+LL | fn oom(\n+   |    ^^^\n+LL |     info: &Layout,\n+   |     -------------\n+   = note: this error originates in the attribute macro `alloc_error_handler` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0308]: mismatched types\n+  --> $DIR/alloc-error-handler-bad-signature-1.rs:10:1\n+   |\n+LL |    #[alloc_error_handler]\n+   |    ---------------------- in this procedural macro expansion\n+LL | // fn oom(\n+LL | ||     info: &Layout,\n+LL | || ) -> ()\n+   | ||_______^ expected `!`, found `()`\n+LL | |  {\n+LL | |      loop {}\n+LL | |  }\n+   | |__- expected `!` because of return type\n+   |\n+   = note:   expected type `!`\n+           found unit type `()`\n+   = note: this error originates in the attribute macro `alloc_error_handler` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "4f76257fc726769df8d21c61816611337c032be8", "filename": "tests/ui/alloc-error/alloc-error-handler-bad-signature-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-2.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -0,0 +1,17 @@\n+// compile-flags:-C panic=abort\n+\n+#![feature(alloc_error_handler)]\n+#![no_std]\n+#![no_main]\n+\n+struct Layout;\n+\n+#[alloc_error_handler]\n+fn oom(\n+    info: Layout, //~^ ERROR mismatched types\n+) { //~^^ ERROR mismatched types\n+    loop {}\n+}\n+\n+#[panic_handler]\n+fn panic(_: &core::panic::PanicInfo) -> ! { loop {} }"}, {"sha": "7a495380f2ba17376e5bf75bdf2e1f387b8035cf", "filename": "tests/ui/alloc-error/alloc-error-handler-bad-signature-2.stderr", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-2.stderr?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -0,0 +1,50 @@\n+error[E0308]: mismatched types\n+  --> $DIR/alloc-error-handler-bad-signature-2.rs:10:1\n+   |\n+LL |    #[alloc_error_handler]\n+   |    ---------------------- in this procedural macro expansion\n+LL | // fn oom(\n+LL | ||     info: Layout,\n+LL | || ) {\n+   | ||_- arguments to this function are incorrect\n+LL | |      loop {}\n+LL | |  }\n+   | |__^ expected `Layout`, found `core::alloc::Layout`\n+   |\n+   = note: `core::alloc::Layout` and `Layout` have similar names, but are actually distinct types\n+note: `core::alloc::Layout` is defined in crate `core`\n+  --> $SRC_DIR/core/src/alloc/layout.rs:LL:COL\n+note: `Layout` is defined in the current crate\n+  --> $DIR/alloc-error-handler-bad-signature-2.rs:7:1\n+   |\n+LL | struct Layout;\n+   | ^^^^^^^^^^^^^\n+note: function defined here\n+  --> $DIR/alloc-error-handler-bad-signature-2.rs:10:4\n+   |\n+LL | fn oom(\n+   |    ^^^\n+LL |     info: Layout,\n+   |     ------------\n+   = note: this error originates in the attribute macro `alloc_error_handler` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0308]: mismatched types\n+  --> $DIR/alloc-error-handler-bad-signature-2.rs:10:1\n+   |\n+LL |    #[alloc_error_handler]\n+   |    ---------------------- in this procedural macro expansion\n+LL | // fn oom(\n+LL | ||     info: Layout,\n+LL | || ) {\n+   | ||_^ expected `!`, found `()`\n+LL | |      loop {}\n+LL | |  }\n+   | |__- expected `!` because of return type\n+   |\n+   = note:   expected type `!`\n+           found unit type `()`\n+   = note: this error originates in the attribute macro `alloc_error_handler` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "ea9ad39a70d81d2b6db694dcc56d406a2dcca461", "filename": "tests/ui/alloc-error/alloc-error-handler-bad-signature-3.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-3.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags:-C panic=abort\n+\n+#![feature(alloc_error_handler)]\n+#![no_std]\n+#![no_main]\n+\n+struct Layout;\n+\n+#[alloc_error_handler]\n+fn oom() -> ! { //~ ERROR function takes 0 arguments but 1 argument was supplied\n+    loop {}\n+}\n+\n+#[panic_handler]\n+fn panic(_: &core::panic::PanicInfo) -> ! { loop {} }"}, {"sha": "eb739b149a1030083d4727c837f0126cf473fa09", "filename": "tests/ui/alloc-error/alloc-error-handler-bad-signature-3.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-3.stderr?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -0,0 +1,21 @@\n+error[E0061]: this function takes 0 arguments but 1 argument was supplied\n+  --> $DIR/alloc-error-handler-bad-signature-3.rs:10:1\n+   |\n+LL |   #[alloc_error_handler]\n+   |   ---------------------- in this procedural macro expansion\n+LL |   fn oom() -> ! {\n+   |  _-^^^^^^^^^^^^\n+LL | |     loop {}\n+LL | | }\n+   | |_- unexpected argument of type `core::alloc::Layout`\n+   |\n+note: function defined here\n+  --> $DIR/alloc-error-handler-bad-signature-3.rs:10:4\n+   |\n+LL | fn oom() -> ! {\n+   |    ^^^\n+   = note: this error originates in the attribute macro `alloc_error_handler` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0061`."}, {"sha": "8be09500f4e4ed0ab22a588430abb58f6409a8fe", "filename": "tests/ui/alloc-error/default-alloc-error-hook.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Fui%2Falloc-error%2Fdefault-alloc-error-hook.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Fui%2Falloc-error%2Fdefault-alloc-error-hook.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Falloc-error%2Fdefault-alloc-error-hook.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -2,7 +2,7 @@\n // ignore-emscripten no processes\n // ignore-sgx no processes\n \n-use std::alloc::{handle_alloc_error, Layout};\n+use std::alloc::{Layout, handle_alloc_error};\n use std::env;\n use std::process::Command;\n use std::str;\n@@ -24,5 +24,5 @@ fn main() {\n         .strip_suffix(\"qemu: uncaught target signal 6 (Aborted) - core dumped\\n\")\n         .unwrap_or(stderr);\n \n-    assert!(stderr.contains(\"memory allocation of 42 bytes failed\"));\n+    assert_eq!(stderr, \"memory allocation of 42 bytes failed\\n\");\n }"}, {"sha": "28926243390932390a6873f0c85fea9b707e6493", "filename": "tests/ui/allocator/no_std-alloc-error-handler-custom.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Fui%2Fallocator%2Fno_std-alloc-error-handler-custom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Fui%2Fallocator%2Fno_std-alloc-error-handler-custom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fallocator%2Fno_std-alloc-error-handler-custom.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -0,0 +1,84 @@\n+// run-pass\n+// ignore-android no libc\n+// ignore-emscripten no libc\n+// ignore-sgx no libc\n+// ignore-wasm32 no libc\n+// only-linux\n+// compile-flags:-C panic=abort\n+// aux-build:helper.rs\n+\n+#![feature(rustc_private, lang_items)]\n+#![feature(alloc_error_handler)]\n+#![no_std]\n+#![no_main]\n+\n+extern crate alloc;\n+extern crate libc;\n+\n+// ARM targets need these symbols\n+#[no_mangle]\n+pub fn __aeabi_unwind_cpp_pr0() {}\n+\n+#[no_mangle]\n+pub fn __aeabi_unwind_cpp_pr1() {}\n+\n+use alloc::boxed::Box;\n+use alloc::string::ToString;\n+use core::alloc::{GlobalAlloc, Layout};\n+use core::ptr::null_mut;\n+\n+extern crate helper;\n+\n+struct MyAllocator;\n+\n+#[alloc_error_handler]\n+fn my_oom(layout: Layout) -> ! {\n+    use alloc::fmt::write;\n+    unsafe {\n+        let size = layout.size();\n+        let mut s = alloc::string::String::new();\n+        write(&mut s, format_args!(\"My OOM: failed to allocate {} bytes!\\n\", size)).unwrap();\n+        libc::write(libc::STDERR_FILENO, s.as_ptr() as *const _, s.len());\n+        libc::exit(0)\n+    }\n+}\n+\n+unsafe impl GlobalAlloc for MyAllocator {\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+        if layout.size() < 4096 { libc::malloc(layout.size()) as _ } else { null_mut() }\n+    }\n+    unsafe fn dealloc(&self, _ptr: *mut u8, _layout: Layout) {}\n+}\n+\n+#[global_allocator]\n+static A: MyAllocator = MyAllocator;\n+\n+#[panic_handler]\n+fn panic(panic_info: &core::panic::PanicInfo) -> ! {\n+    unsafe {\n+        let s = panic_info.to_string();\n+        const PSTR: &str = \"panic occurred: \";\n+        const CR: &str = \"\\n\";\n+        libc::write(libc::STDERR_FILENO, PSTR.as_ptr() as *const _, PSTR.len());\n+        libc::write(libc::STDERR_FILENO, s.as_ptr() as *const _, s.len());\n+        libc::write(libc::STDERR_FILENO, CR.as_ptr() as *const _, CR.len());\n+        libc::exit(1)\n+    }\n+}\n+\n+// Because we are compiling this code with `-C panic=abort`, this wouldn't normally be needed.\n+// However, `core` and `alloc` are both compiled with `-C panic=unwind`, which means that functions\n+// in these libraries will refer to `rust_eh_personality` if LLVM can not *prove* the contents won't\n+// unwind. So, for this test case we will define the symbol.\n+#[lang = \"eh_personality\"]\n+extern \"C\" fn rust_eh_personality() {}\n+\n+#[derive(Default, Debug)]\n+struct Page(#[allow(unused_tuple_struct_fields)] [[u64; 32]; 16]);\n+\n+#[no_mangle]\n+fn main(_argc: i32, _argv: *const *const u8) -> isize {\n+    let zero = Box::<Page>::new(Default::default());\n+    helper::work_with(&zero);\n+    1\n+}"}, {"sha": "78d189d20b64d4d9393595cf46190a976404fa9d", "filename": "tests/ui/feature-gates/feature-gate-alloc-error-handler.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Fui%2Ffeature-gates%2Ffeature-gate-alloc-error-handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Fui%2Ffeature-gates%2Ffeature-gate-alloc-error-handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-alloc-error-handler.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -0,0 +1,16 @@\n+// compile-flags:-C panic=abort\n+\n+#![no_std]\n+#![no_main]\n+\n+use core::alloc::Layout;\n+\n+#[alloc_error_handler] //~ ERROR use of unstable library feature 'alloc_error_handler'\n+fn oom(info: Layout) -> ! {\n+    loop {}\n+}\n+\n+#[panic_handler]\n+fn panic(_: &core::panic::PanicInfo) -> ! {\n+    loop {}\n+}"}, {"sha": "f414eb463dfbcc1f5747aaa70f060a3453dc92c4", "filename": "tests/ui/feature-gates/feature-gate-alloc-error-handler.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Fui%2Ffeature-gates%2Ffeature-gate-alloc-error-handler.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Fui%2Ffeature-gates%2Ffeature-gate-alloc-error-handler.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-alloc-error-handler.stderr?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: use of unstable library feature 'alloc_error_handler'\n+  --> $DIR/feature-gate-alloc-error-handler.rs:8:3\n+   |\n+LL | #[alloc_error_handler]\n+   |   ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #51540 <https://github.com/rust-lang/rust/issues/51540> for more information\n+   = help: add `#![feature(alloc_error_handler)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "2dc509f2c632da0b599b2be0beacc1a39c0f4594", "filename": "tests/ui/missing/missing-allocator.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Fui%2Fmissing%2Fmissing-allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Fui%2Fmissing%2Fmissing-allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing%2Fmissing-allocator.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -3,10 +3,16 @@\n \n #![no_std]\n #![crate_type = \"staticlib\"]\n+#![feature(alloc_error_handler)]\n \n #[panic_handler]\n fn panic(_: &core::panic::PanicInfo) -> ! {\n     loop {}\n }\n \n+#[alloc_error_handler]\n+fn oom(_: core::alloc::Layout) -> ! {\n+    loop {}\n+}\n+\n extern crate alloc;"}, {"sha": "21a8fb2b22bee306e833a193493f66efcb2a2756", "filename": "tests/ui/oom_unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Fui%2Foom_unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3ddb375bf18099a885605efba94dc1e50379d7/tests%2Fui%2Foom_unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foom_unwind.rs?ref=ed3ddb375bf18099a885605efba94dc1e50379d7", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -Z oom=unwind\n+// compile-flags: -Z oom=panic\n // run-pass\n // no-prefer-dynamic\n // needs-unwind"}]}