{"sha": "c07a6ae77cd4ceb3cf591d34c5608ca91d1f75d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwN2E2YWU3N2NkNGNlYjNjZjU5MWQzNGM1NjA4Y2E5MWQxZjc1ZDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-17T21:52:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-17T21:52:03Z"}, "message": "Auto merge of #37972 - bluss:iter-find-is-on-a-roll, r=sfackler\n\nImprove the slice iterator's searching methods\n\nImprove all, any, find, position, rposition by explicitly unrolling the loop for the slice iterators.\n\n- Introduce a few extension methods and functions for raw pointers make the new code easy to express\n- Introduce helper methods `search_while, rsearch_while` that generalize all the searching methods\n\nLLVM doesn't unroll the loop in `.find()` by default (clang is the same), so performance benefits a lot from explicit unrolling here. An iterator method without conditional exits (like `.fold()`) does not need this on the other hand.\n\nOne of the raw pointer extension methods is `fn post_inc(&mut self) -> Self` which is the rustic equivalent of \u201c`ptr++`\u201d, and it is a nice way to express the raw pointer loop (see commit 3).\n\nSpecific development notes about `search_while`: I tried both computing an end pointer \"rounded\" to 4, as well as the `ptrdistance >= 4` loop condition, ptrdistance was better. I tried handling the last 0-3 elements unrolled or with a while loop, the loop was better.", "tree": {"sha": "23b49663e71486df7f582fd55c09fad56ee1aef7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23b49663e71486df7f582fd55c09fad56ee1aef7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c07a6ae77cd4ceb3cf591d34c5608ca91d1f75d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c07a6ae77cd4ceb3cf591d34c5608ca91d1f75d4", "html_url": "https://github.com/rust-lang/rust/commit/c07a6ae77cd4ceb3cf591d34c5608ca91d1f75d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c07a6ae77cd4ceb3cf591d34c5608ca91d1f75d4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd8e9b0c828bce489eb948853a6cf86b69b26799", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd8e9b0c828bce489eb948853a6cf86b69b26799", "html_url": "https://github.com/rust-lang/rust/commit/bd8e9b0c828bce489eb948853a6cf86b69b26799"}, {"sha": "a54ddfb676c59bcf0dd3dc8ef869a6e5ac4afc0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a54ddfb676c59bcf0dd3dc8ef869a6e5ac4afc0b", "html_url": "https://github.com/rust-lang/rust/commit/a54ddfb676c59bcf0dd3dc8ef869a6e5ac4afc0b"}], "stats": {"total": 199, "additions": 185, "deletions": 14}, "files": [{"sha": "b942d85f9808bd8147b8dd5d79ecf36c3559bde4", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 185, "deletions": 14, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/c07a6ae77cd4ceb3cf591d34c5608ca91d1f75d4/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07a6ae77cd4ceb3cf591d34c5608ca91d1f75d4/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=c07a6ae77cd4ceb3cf591d34c5608ca91d1f75d4", "patch": "@@ -172,21 +172,35 @@ macro_rules! slice_offset {\n     ($ptr:expr, $by:expr) => {{\n         let ptr = $ptr;\n         if size_from_ptr(ptr) == 0 {\n-            ::intrinsics::arith_offset(ptr as *mut i8, $by) as *mut _\n+            (ptr as *mut i8).wrapping_offset($by) as _\n         } else {\n             ptr.offset($by)\n         }\n     }};\n }\n \n-macro_rules! slice_ref {\n+// make a &T from a *const T\n+macro_rules! make_ref {\n+    ($ptr:expr) => {{\n+        let ptr = $ptr;\n+        if size_from_ptr(ptr) == 0 {\n+            // Use a non-null pointer value\n+            &*(1 as *mut _)\n+        } else {\n+            &*ptr\n+        }\n+    }};\n+}\n+\n+// make a &mut T from a *mut T\n+macro_rules! make_ref_mut {\n     ($ptr:expr) => {{\n         let ptr = $ptr;\n         if size_from_ptr(ptr) == 0 {\n             // Use a non-null pointer value\n             &mut *(1 as *mut _)\n         } else {\n-            mem::transmute(ptr)\n+            &mut *ptr\n         }\n     }};\n }\n@@ -963,7 +977,7 @@ fn size_from_ptr<T>(_: *const T) -> usize {\n \n // The shared definition of the `Iter` and `IterMut` iterators\n macro_rules! iterator {\n-    (struct $name:ident -> $ptr:ty, $elem:ty) => {\n+    (struct $name:ident -> $ptr:ty, $elem:ty, $mkref:ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, T> Iterator for $name<'a, T> {\n             type Item = $elem;\n@@ -979,18 +993,14 @@ macro_rules! iterator {\n                     if self.ptr == self.end {\n                         None\n                     } else {\n-                        let old = self.ptr;\n-                        self.ptr = slice_offset!(self.ptr, 1);\n-                        Some(slice_ref!(old))\n+                        Some($mkref!(self.ptr.post_inc()))\n                     }\n                 }\n             }\n \n             #[inline]\n             fn size_hint(&self) -> (usize, Option<usize>) {\n-                let diff = (self.end as usize).wrapping_sub(self.ptr as usize);\n-                let size = mem::size_of::<T>();\n-                let exact = diff / (if size == 0 {1} else {size});\n+                let exact = ptrdistance(self.ptr, self.end);\n                 (exact, Some(exact))\n             }\n \n@@ -1009,6 +1019,64 @@ macro_rules! iterator {\n             fn last(mut self) -> Option<$elem> {\n                 self.next_back()\n             }\n+\n+            fn all<F>(&mut self, mut predicate: F) -> bool\n+                where F: FnMut(Self::Item) -> bool,\n+            {\n+                self.search_while(true, move |elt| {\n+                    if predicate(elt) {\n+                        SearchWhile::Continue\n+                    } else {\n+                        SearchWhile::Done(false)\n+                    }\n+                })\n+            }\n+\n+            fn any<F>(&mut self, mut predicate: F) -> bool\n+                where F: FnMut(Self::Item) -> bool,\n+            {\n+                !self.all(move |elt| !predicate(elt))\n+            }\n+\n+            fn find<F>(&mut self, mut predicate: F) -> Option<Self::Item>\n+                where F: FnMut(&Self::Item) -> bool,\n+            {\n+                self.search_while(None, move |elt| {\n+                    if predicate(&elt) {\n+                        SearchWhile::Done(Some(elt))\n+                    } else {\n+                        SearchWhile::Continue\n+                    }\n+                })\n+            }\n+\n+            fn position<F>(&mut self, mut predicate: F) -> Option<usize>\n+                where F: FnMut(Self::Item) -> bool,\n+            {\n+                let mut index = 0;\n+                self.search_while(None, move |elt| {\n+                    if predicate(elt) {\n+                        SearchWhile::Done(Some(index))\n+                    } else {\n+                        index += 1;\n+                        SearchWhile::Continue\n+                    }\n+                })\n+            }\n+\n+            fn rposition<F>(&mut self, mut predicate: F) -> Option<usize>\n+                where F: FnMut(Self::Item) -> bool,\n+            {\n+                let mut index = self.len();\n+                self.rsearch_while(None, move |elt| {\n+                    index -= 1;\n+                    if predicate(elt) {\n+                        SearchWhile::Done(Some(index))\n+                    } else {\n+                        SearchWhile::Continue\n+                    }\n+                })\n+            }\n         }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1024,10 +1092,51 @@ macro_rules! iterator {\n                     if self.end == self.ptr {\n                         None\n                     } else {\n-                        self.end = slice_offset!(self.end, -1);\n-                        Some(slice_ref!(self.end))\n+                        Some($mkref!(self.end.pre_dec()))\n+                    }\n+                }\n+            }\n+        }\n+\n+        // search_while is a generalization of the internal iteration methods.\n+        impl<'a, T> $name<'a, T> {\n+            // search through the iterator's element using the closure `g`.\n+            // if no element was found, return `default`.\n+            fn search_while<Acc, G>(&mut self, default: Acc, mut g: G) -> Acc\n+                where Self: Sized,\n+                      G: FnMut($elem) -> SearchWhile<Acc>\n+            {\n+                // manual unrolling is needed when there are conditional exits from the loop\n+                unsafe {\n+                    while ptrdistance(self.ptr, self.end) >= 4 {\n+                        search_while!(g($mkref!(self.ptr.post_inc())));\n+                        search_while!(g($mkref!(self.ptr.post_inc())));\n+                        search_while!(g($mkref!(self.ptr.post_inc())));\n+                        search_while!(g($mkref!(self.ptr.post_inc())));\n+                    }\n+                    while self.ptr != self.end {\n+                        search_while!(g($mkref!(self.ptr.post_inc())));\n+                    }\n+                }\n+                default\n+            }\n+\n+            fn rsearch_while<Acc, G>(&mut self, default: Acc, mut g: G) -> Acc\n+                where Self: Sized,\n+                      G: FnMut($elem) -> SearchWhile<Acc>\n+            {\n+                unsafe {\n+                    while ptrdistance(self.ptr, self.end) >= 4 {\n+                        search_while!(g($mkref!(self.end.pre_dec())));\n+                        search_while!(g($mkref!(self.end.pre_dec())));\n+                        search_while!(g($mkref!(self.end.pre_dec())));\n+                        search_while!(g($mkref!(self.end.pre_dec())));\n+                    }\n+                    while self.ptr != self.end {\n+                        search_while!(g($mkref!(self.end.pre_dec())));\n                     }\n                 }\n+                default\n             }\n         }\n     }\n@@ -1061,6 +1170,24 @@ macro_rules! make_mut_slice {\n     }}\n }\n \n+// An enum used for controlling the execution of `.search_while()`.\n+enum SearchWhile<T> {\n+    // Continue searching\n+    Continue,\n+    // Fold is complete and will return this value\n+    Done(T),\n+}\n+\n+// helper macro for search while's control flow\n+macro_rules! search_while {\n+    ($e:expr) => {\n+        match $e {\n+            SearchWhile::Continue => { }\n+            SearchWhile::Done(done) => return done,\n+        }\n+    }\n+}\n+\n /// Immutable slice iterator\n ///\n /// This struct is created by the [`iter`] method on [slices].\n@@ -1147,7 +1274,7 @@ impl<'a, T> Iter<'a, T> {\n     }\n }\n \n-iterator!{struct Iter -> *const T, &'a T}\n+iterator!{struct Iter -> *const T, &'a T, make_ref}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {\n@@ -1275,7 +1402,7 @@ impl<'a, T> IterMut<'a, T> {\n     }\n }\n \n-iterator!{struct IterMut -> *mut T, &'a mut T}\n+iterator!{struct IterMut -> *mut T, &'a mut T, make_ref_mut}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {\n@@ -1290,6 +1417,50 @@ impl<'a, T> FusedIterator for IterMut<'a, T> {}\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<'a, T> TrustedLen for IterMut<'a, T> {}\n \n+\n+// Return the number of elements of `T` from `start` to `end`.\n+// Return the arithmetic difference if `T` is zero size.\n+#[inline(always)]\n+fn ptrdistance<T>(start: *const T, end: *const T) -> usize {\n+    let diff = (end as usize).wrapping_sub(start as usize);\n+    let size = mem::size_of::<T>();\n+    diff / (if size == 0 { 1 } else { size })\n+}\n+\n+// Extension methods for raw pointers, used by the iterators\n+trait PointerExt : Copy {\n+    unsafe fn slice_offset(self, i: isize) -> Self;\n+\n+    /// Increment self by 1, but return the old value\n+    #[inline(always)]\n+    unsafe fn post_inc(&mut self) -> Self {\n+        let current = *self;\n+        *self = self.slice_offset(1);\n+        current\n+    }\n+\n+    /// Decrement self by 1, and return the new value\n+    #[inline(always)]\n+    unsafe fn pre_dec(&mut self) -> Self {\n+        *self = self.slice_offset(-1);\n+        *self\n+    }\n+}\n+\n+impl<T> PointerExt for *const T {\n+    #[inline(always)]\n+    unsafe fn slice_offset(self, i: isize) -> Self {\n+        slice_offset!(self, i)\n+    }\n+}\n+\n+impl<T> PointerExt for *mut T {\n+    #[inline(always)]\n+    unsafe fn slice_offset(self, i: isize) -> Self {\n+        slice_offset!(self, i)\n+    }\n+}\n+\n /// An internal abstraction over the splitting iterators, so that\n /// splitn, splitn_mut etc can be implemented once.\n #[doc(hidden)]"}]}