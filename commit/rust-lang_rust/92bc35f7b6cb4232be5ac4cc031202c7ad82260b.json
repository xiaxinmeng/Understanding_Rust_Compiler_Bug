{"sha": "92bc35f7b6cb4232be5ac4cc031202c7ad82260b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyYmMzNWY3YjZjYjQyMzJiZTVhYzRjYzAzMTIwMmM3YWQ4MjI2MGI=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2019-12-05T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2019-12-05T00:00:00Z"}, "message": "Simplify {IoSlice, IoSliceMut}::advance examples and tests\n\nRemove unnecessary calls to `std::mem::replace` and make variables immutable.", "tree": {"sha": "e2dd6a7dbc4c89a7cca164618230e8e16570df21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2dd6a7dbc4c89a7cca164618230e8e16570df21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92bc35f7b6cb4232be5ac4cc031202c7ad82260b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92bc35f7b6cb4232be5ac4cc031202c7ad82260b", "html_url": "https://github.com/rust-lang/rust/commit/92bc35f7b6cb4232be5ac4cc031202c7ad82260b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92bc35f7b6cb4232be5ac4cc031202c7ad82260b/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d77e45f01079fe3d40180b3e256e414ab379f63", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d77e45f01079fe3d40180b3e256e414ab379f63", "html_url": "https://github.com/rust-lang/rust/commit/6d77e45f01079fe3d40180b3e256e414ab379f63"}], "stats": {"total": 55, "additions": 26, "deletions": 29}, "files": [{"sha": "a1a33bade0d7c610632cf0ce839520c520fb289a", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/92bc35f7b6cb4232be5ac4cc031202c7ad82260b/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bc35f7b6cb4232be5ac4cc031202c7ad82260b/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=92bc35f7b6cb4232be5ac4cc031202c7ad82260b", "patch": "@@ -987,7 +987,6 @@ impl<'a> IoSliceMut<'a> {\n     /// #![feature(io_slice_advance)]\n     ///\n     /// use std::io::IoSliceMut;\n-    /// use std::mem;\n     /// use std::ops::Deref;\n     ///\n     /// let mut buf1 = [1; 8];\n@@ -1000,7 +999,7 @@ impl<'a> IoSliceMut<'a> {\n     /// ][..];\n     ///\n     /// // Mark 10 bytes as read.\n-    /// bufs = IoSliceMut::advance(mem::replace(&mut bufs, &mut []), 10);\n+    /// bufs = IoSliceMut::advance(bufs, 10);\n     /// assert_eq!(bufs[0].deref(), [2; 14].as_ref());\n     /// assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n     /// ```\n@@ -1090,20 +1089,19 @@ impl<'a> IoSlice<'a> {\n     /// #![feature(io_slice_advance)]\n     ///\n     /// use std::io::IoSlice;\n-    /// use std::mem;\n     /// use std::ops::Deref;\n     ///\n-    /// let mut buf1 = [1; 8];\n-    /// let mut buf2 = [2; 16];\n-    /// let mut buf3 = [3; 8];\n+    /// let buf1 = [1; 8];\n+    /// let buf2 = [2; 16];\n+    /// let buf3 = [3; 8];\n     /// let mut bufs = &mut [\n-    ///     IoSlice::new(&mut buf1),\n-    ///     IoSlice::new(&mut buf2),\n-    ///     IoSlice::new(&mut buf3),\n+    ///     IoSlice::new(&buf1),\n+    ///     IoSlice::new(&buf2),\n+    ///     IoSlice::new(&buf3),\n     /// ][..];\n     ///\n     /// // Mark 10 bytes as written.\n-    /// bufs = IoSlice::advance(mem::replace(&mut bufs, &mut []), 10);\n+    /// bufs = IoSlice::advance(bufs, 10);\n     /// assert_eq!(bufs[0].deref(), [2; 14].as_ref());\n     /// assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n     #[unstable(feature = \"io_slice_advance\", issue = \"62726\")]\n@@ -2415,7 +2413,6 @@ mod tests {\n     use crate::cmp;\n     use crate::io::prelude::*;\n     use crate::io::{self, IoSlice, IoSliceMut};\n-    use crate::mem;\n     use crate::ops::Deref;\n \n     #[test]\n@@ -2731,26 +2728,26 @@ mod tests {\n         ][..];\n \n         // Only in a single buffer..\n-        bufs = IoSliceMut::advance(mem::replace(&mut bufs, &mut []), 1);\n+        bufs = IoSliceMut::advance(bufs, 1);\n         assert_eq!(bufs[0].deref(), [1; 7].as_ref());\n         assert_eq!(bufs[1].deref(), [2; 16].as_ref());\n         assert_eq!(bufs[2].deref(), [3; 8].as_ref());\n \n         // Removing a buffer, leaving others as is.\n-        bufs = IoSliceMut::advance(mem::replace(&mut bufs, &mut []), 7);\n+        bufs = IoSliceMut::advance(bufs, 7);\n         assert_eq!(bufs[0].deref(), [2; 16].as_ref());\n         assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n \n         // Removing a buffer and removing from the next buffer.\n-        bufs = IoSliceMut::advance(mem::replace(&mut bufs, &mut []), 18);\n+        bufs = IoSliceMut::advance(bufs, 18);\n         assert_eq!(bufs[0].deref(), [3; 6].as_ref());\n     }\n \n     #[test]\n     fn io_slice_mut_advance_empty_slice() {\n-        let mut empty_bufs = &mut [][..];\n+        let empty_bufs = &mut [][..];\n         // Shouldn't panic.\n-        IoSliceMut::advance(&mut empty_bufs, 1);\n+        IoSliceMut::advance(empty_bufs, 1);\n     }\n \n     #[test]\n@@ -2759,48 +2756,48 @@ mod tests {\n         let mut bufs = &mut [IoSliceMut::new(&mut buf1)][..];\n \n         // Going beyond the total length should be ok.\n-        bufs = IoSliceMut::advance(mem::replace(&mut bufs, &mut []), 9);\n+        bufs = IoSliceMut::advance(bufs, 9);\n         assert!(bufs.is_empty());\n     }\n \n     #[test]\n     fn io_slice_advance() {\n-        let mut buf1 = [1; 8];\n-        let mut buf2 = [2; 16];\n-        let mut buf3 = [3; 8];\n+        let buf1 = [1; 8];\n+        let buf2 = [2; 16];\n+        let buf3 = [3; 8];\n         let mut bufs =\n-            &mut [IoSlice::new(&mut buf1), IoSlice::new(&mut buf2), IoSlice::new(&mut buf3)][..];\n+            &mut [IoSlice::new(&buf1), IoSlice::new(&buf2), IoSlice::new(&buf3)][..];\n \n         // Only in a single buffer..\n-        bufs = IoSlice::advance(mem::replace(&mut bufs, &mut []), 1);\n+        bufs = IoSlice::advance(bufs, 1);\n         assert_eq!(bufs[0].deref(), [1; 7].as_ref());\n         assert_eq!(bufs[1].deref(), [2; 16].as_ref());\n         assert_eq!(bufs[2].deref(), [3; 8].as_ref());\n \n         // Removing a buffer, leaving others as is.\n-        bufs = IoSlice::advance(mem::replace(&mut bufs, &mut []), 7);\n+        bufs = IoSlice::advance(bufs, 7);\n         assert_eq!(bufs[0].deref(), [2; 16].as_ref());\n         assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n \n         // Removing a buffer and removing from the next buffer.\n-        bufs = IoSlice::advance(mem::replace(&mut bufs, &mut []), 18);\n+        bufs = IoSlice::advance(bufs, 18);\n         assert_eq!(bufs[0].deref(), [3; 6].as_ref());\n     }\n \n     #[test]\n     fn io_slice_advance_empty_slice() {\n-        let mut empty_bufs = &mut [][..];\n+        let empty_bufs = &mut [][..];\n         // Shouldn't panic.\n-        IoSlice::advance(&mut empty_bufs, 1);\n+        IoSlice::advance(empty_bufs, 1);\n     }\n \n     #[test]\n     fn io_slice_advance_beyond_total_length() {\n-        let mut buf1 = [1; 8];\n-        let mut bufs = &mut [IoSlice::new(&mut buf1)][..];\n+        let buf1 = [1; 8];\n+        let mut bufs = &mut [IoSlice::new(&buf1)][..];\n \n         // Going beyond the total length should be ok.\n-        bufs = IoSlice::advance(mem::replace(&mut bufs, &mut []), 9);\n+        bufs = IoSlice::advance(bufs, 9);\n         assert!(bufs.is_empty());\n     }\n }"}]}