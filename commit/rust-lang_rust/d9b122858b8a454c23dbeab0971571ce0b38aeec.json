{"sha": "d9b122858b8a454c23dbeab0971571ce0b38aeec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5YjEyMjg1OGI4YTQ1NGMyM2RiZWFiMDk3MTU3MWNlMGIzOGFlZWM=", "commit": {"author": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-04T21:35:28Z"}, "committer": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-04T21:35:28Z"}, "message": " split extract_function into pieces and order them", "tree": {"sha": "daa10cb553b1c47c6230b42d4dad887a7c91c597", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/daa10cb553b1c47c6230b42d4dad887a7c91c597"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9b122858b8a454c23dbeab0971571ce0b38aeec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9b122858b8a454c23dbeab0971571ce0b38aeec", "html_url": "https://github.com/rust-lang/rust/commit/d9b122858b8a454c23dbeab0971571ce0b38aeec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9b122858b8a454c23dbeab0971571ce0b38aeec/comments", "author": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff77c5e68fefcf525c2aa449cff5e0c52e7d3a0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff77c5e68fefcf525c2aa449cff5e0c52e7d3a0d", "html_url": "https://github.com/rust-lang/rust/commit/ff77c5e68fefcf525c2aa449cff5e0c52e7d3a0d"}], "stats": {"total": 892, "additions": 511, "deletions": 381}, "files": [{"sha": "93ff66b246b9cf1e046716f2ab69fc34b45dfcc7", "filename": "crates/assists/src/handlers/extract_function.rs", "status": "modified", "additions": 511, "deletions": 381, "changes": 892, "blob_url": "https://github.com/rust-lang/rust/blob/d9b122858b8a454c23dbeab0971571ce0b38aeec/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9b122858b8a454c23dbeab0971571ce0b38aeec/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=d9b122858b8a454c23dbeab0971571ce0b38aeec", "patch": "@@ -60,115 +60,21 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         return None;\n     }\n \n-    let node = match node {\n-        syntax::NodeOrToken::Node(n) => n,\n-        syntax::NodeOrToken::Token(t) => t.parent(),\n-    };\n+    let node = element_to_node(node);\n \n-    let mut body = None;\n-    if node.text_range() == ctx.frange.range {\n-        body = FunctionBody::from_whole_node(node.clone());\n-    }\n-    if body.is_none() && node.kind() == BLOCK_EXPR {\n-        body = FunctionBody::from_range(&node, ctx.frange.range);\n-    }\n-    if let Some(parent) = node.parent() {\n-        if body.is_none() && parent.kind() == BLOCK_EXPR {\n-            body = FunctionBody::from_range(&parent, ctx.frange.range);\n-        }\n-    }\n-    if body.is_none() {\n-        body = FunctionBody::from_whole_node(node.clone());\n-    }\n-    if body.is_none() {\n-        body = node.ancestors().find_map(FunctionBody::from_whole_node);\n-    }\n-    let body = body?;\n+    let body = extraction_target(&node, ctx.frange.range)?;\n \n     let vars_used_in_body = vars_used_in_body(&body, &ctx);\n-    let mut self_param = None;\n-    let param_pats: Vec<_> = vars_used_in_body\n-        .iter()\n-        .map(|node| (node, node.source(ctx.db())))\n-        .filter(|(_, src)| {\n-            src.file_id.original_file(ctx.db()) == ctx.frange.file_id\n-                && !body.contains_node(&either_syntax(&src.value))\n-        })\n-        .filter_map(|(&node, src)| match src.value {\n-            Either::Left(_) => Some(node),\n-            Either::Right(it) => {\n-                // we filter self param, as there can only be one\n-                self_param = Some((node, it));\n-                None\n-            }\n-        })\n-        .collect();\n+    let self_param = self_param_from_usages(ctx, &body, &vars_used_in_body);\n \n     let anchor = if self_param.is_some() { Anchor::Method } else { Anchor::Freestanding };\n-    let insert_after = body.scope_for_fn_insertion(anchor)?;\n+    let insert_after = scope_for_fn_insertion(&body, anchor)?;\n     let module = ctx.sema.scope(&insert_after).module()?;\n \n-    let vars_defined_in_body = vars_defined_in_body(&body, ctx);\n-\n-    let vars_defined_in_body_and_outlive: Vec<_> = vars_defined_in_body\n-        .iter()\n-        .copied()\n-        .filter(|node| {\n-            let usages = Definition::Local(*node)\n-                .usages(&ctx.sema)\n-                .in_scope(SearchScope::single_file(ctx.frange.file_id))\n-                .all();\n-            let mut usages = usages.iter().flat_map(|(_, rs)| rs.iter());\n-\n-            usages.any(|reference| body.preceedes_range(reference.range))\n-        })\n-        .collect();\n-\n-    let params: Vec<_> = param_pats\n-        .into_iter()\n-        .map(|node| {\n-            let usages = Definition::Local(node)\n-                .usages(&ctx.sema)\n-                .in_scope(SearchScope::single_file(ctx.frange.file_id))\n-                .all();\n-\n-            let has_usages_afterwards = usages\n-                .iter()\n-                .flat_map(|(_, rs)| rs.iter())\n-                .any(|reference| body.preceedes_range(reference.range));\n-            let has_mut_inside_body = usages\n-                .iter()\n-                .flat_map(|(_, rs)| rs.iter())\n-                .filter(|reference| body.contains_range(reference.range))\n-                .any(|reference| {\n-                    if reference.access == Some(ReferenceAccess::Write) {\n-                        return true;\n-                    }\n-\n-                    let path = path_at_offset(&body, reference);\n-                    if is_mut_ref_expr(path.as_ref()).unwrap_or(false) {\n-                        return true;\n-                    }\n-\n-                    if is_mut_method_call(ctx, path.as_ref()).unwrap_or(false) {\n-                        return true;\n-                    }\n-\n-                    false\n-                });\n-\n-            Param { node, has_usages_afterwards, has_mut_inside_body, is_copy: true }\n-        })\n-        .collect();\n-\n-    let expr = body.tail_expr();\n-    let ret_ty = match expr {\n-        Some(expr) => Some(ctx.sema.type_of_expr(&expr)?),\n-        None => None,\n-    };\n+    let vars_defined_in_body_and_outlive = vars_defined_in_body_and_outlive(ctx, &body);\n+    let ret_ty = body_return_ty(ctx, &body)?;\n \n-    let has_unit_ret = ret_ty.as_ref().map_or(true, |it| it.is_unit());\n-    if stdx::never!(!vars_defined_in_body_and_outlive.is_empty() && !has_unit_ret) {\n+    if stdx::never!(!vars_defined_in_body_and_outlive.is_empty() && !ret_ty.is_unit()) {\n         // We should not have variables that outlive body if we have expression block\n         return None;\n     }\n@@ -183,6 +89,8 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         \"Extract into function\",\n         target_range,\n         move |builder| {\n+            let params = extracted_function_params(ctx, &body, &vars_used_in_body);\n+\n             let fun = Function {\n                 name: \"fun_name\".to_string(),\n                 self_param: self_param.map(|(_, pat)| pat),\n@@ -203,65 +111,19 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n     )\n }\n \n-fn format_replacement(ctx: &AssistContext, fun: &Function) -> String {\n-    let mut buf = String::new();\n-\n-    match fun.vars_defined_in_body_and_outlive.as_slice() {\n-        [] => {}\n-        [var] => format_to!(buf, \"let {} = \", var.name(ctx.db()).unwrap()),\n-        [v0, vs @ ..] => {\n-            buf.push_str(\"let (\");\n-            format_to!(buf, \"{}\", v0.name(ctx.db()).unwrap());\n-            for local in vs {\n-                format_to!(buf, \", {}\", local.name(ctx.db()).unwrap());\n-            }\n-            buf.push_str(\") = \");\n-        }\n-    }\n-\n-    if fun.self_param.is_some() {\n-        format_to!(buf, \"self.\");\n-    }\n-    format_to!(buf, \"{}(\", fun.name);\n-    {\n-        let mut it = fun.params.iter();\n-        if let Some(param) = it.next() {\n-            format_to!(buf, \"{}{}\", param.value_prefix(), param.node.name(ctx.db()).unwrap());\n-        }\n-        for param in it {\n-            format_to!(buf, \", {}{}\", param.value_prefix(), param.node.name(ctx.db()).unwrap());\n-        }\n-    }\n-    format_to!(buf, \")\");\n-\n-    if fun.has_unit_ret() {\n-        format_to!(buf, \";\");\n-    }\n-\n-    buf\n-}\n-\n+#[derive(Debug)]\n struct Function {\n     name: String,\n     self_param: Option<ast::SelfParam>,\n     params: Vec<Param>,\n-    ret_ty: Option<hir::Type>,\n+    ret_ty: RetType,\n     body: FunctionBody,\n     vars_defined_in_body_and_outlive: Vec<Local>,\n }\n \n-impl Function {\n-    fn has_unit_ret(&self) -> bool {\n-        match &self.ret_ty {\n-            Some(ty) => ty.is_unit(),\n-            None => true,\n-        }\n-    }\n-}\n-\n #[derive(Debug)]\n struct Param {\n-    node: Local,\n+    var: Local,\n     has_usages_afterwards: bool,\n     has_mut_inside_body: bool,\n     is_copy: bool,\n@@ -293,17 +155,15 @@ impl Param {\n \n     fn value_prefix(&self) -> &'static str {\n         match self.kind() {\n-            ParamKind::Value => \"\",\n-            ParamKind::MutValue => \"\",\n+            ParamKind::Value | ParamKind::MutValue => \"\",\n             ParamKind::SharedRef => \"&\",\n             ParamKind::MutRef => \"&mut \",\n         }\n     }\n \n     fn type_prefix(&self) -> &'static str {\n         match self.kind() {\n-            ParamKind::Value => \"\",\n-            ParamKind::MutValue => \"\",\n+            ParamKind::Value | ParamKind::MutValue => \"\",\n             ParamKind::SharedRef => \"&\",\n             ParamKind::MutRef => \"&mut \",\n         }\n@@ -317,186 +177,27 @@ impl Param {\n     }\n }\n \n-fn format_function(\n-    ctx: &AssistContext,\n-    module: hir::Module,\n-    fun: &Function,\n-    indent: IndentLevel,\n-) -> String {\n-    let mut fn_def = String::new();\n-    format_to!(fn_def, \"\\n\\n{}fn $0{}(\", indent, fun.name);\n-    {\n-        let mut it = fun.params.iter();\n-        if let Some(self_param) = &fun.self_param {\n-            format_to!(fn_def, \"{}\", self_param);\n-        } else if let Some(param) = it.next() {\n-            format_to!(\n-                fn_def,\n-                \"{}{}: {}{}\",\n-                param.mut_pattern(),\n-                param.node.name(ctx.db()).unwrap(),\n-                param.type_prefix(),\n-                format_type(&param.node.ty(ctx.db()), ctx, module)\n-            );\n-        }\n-        for param in it {\n-            format_to!(\n-                fn_def,\n-                \", {}{}: {}{}\",\n-                param.mut_pattern(),\n-                param.node.name(ctx.db()).unwrap(),\n-                param.type_prefix(),\n-                format_type(&param.node.ty(ctx.db()), ctx, module)\n-            );\n-        }\n-    }\n-\n-    format_to!(fn_def, \")\");\n-    if !fun.has_unit_ret() {\n-        if let Some(ty) = &fun.ret_ty {\n-            format_to!(fn_def, \" -> {}\", format_type(ty, ctx, module));\n-        }\n-    } else {\n-        match fun.vars_defined_in_body_and_outlive.as_slice() {\n-            [] => {}\n-            [var] => {\n-                format_to!(fn_def, \" -> {}\", format_type(&var.ty(ctx.db()), ctx, module));\n-            }\n-            [v0, vs @ ..] => {\n-                format_to!(fn_def, \" -> ({}\", format_type(&v0.ty(ctx.db()), ctx, module));\n-                for var in vs {\n-                    format_to!(fn_def, \", {}\", format_type(&var.ty(ctx.db()), ctx, module));\n-                }\n-                fn_def.push(')');\n-            }\n-        }\n-    }\n-    fn_def.push_str(\" {\");\n-\n-    match &fun.body {\n-        FunctionBody::Expr(expr) => {\n-            fn_def.push('\\n');\n-            let expr = expr.indent(indent);\n-            let expr = fix_param_usages(ctx, &fun.params, expr.syntax());\n-            format_to!(fn_def, \"{}{}\", indent + 1, expr);\n-            fn_def.push('\\n');\n-        }\n-        FunctionBody::Span { elements, leading_indent } => {\n-            format_to!(fn_def, \"{}\", leading_indent);\n-            for element in elements {\n-                match element {\n-                    syntax::NodeOrToken::Node(node) => {\n-                        format_to!(fn_def, \"{}\", fix_param_usages(ctx, &fun.params, node));\n-                    }\n-                    syntax::NodeOrToken::Token(token) => {\n-                        format_to!(fn_def, \"{}\", token);\n-                    }\n-                }\n-            }\n-            if !fn_def.ends_with('\\n') {\n-                fn_def.push('\\n');\n-            }\n-        }\n-    }\n-\n-    match fun.vars_defined_in_body_and_outlive.as_slice() {\n-        [] => {}\n-        [var] => format_to!(fn_def, \"{}{}\\n\", indent + 1, var.name(ctx.db()).unwrap()),\n-        [v0, vs @ ..] => {\n-            format_to!(fn_def, \"{}({}\", indent + 1, v0.name(ctx.db()).unwrap());\n-            for var in vs {\n-                format_to!(fn_def, \", {}\", var.name(ctx.db()).unwrap());\n-            }\n-            fn_def.push_str(\")\\n\");\n-        }\n-    }\n-\n-    format_to!(fn_def, \"{}}}\", indent);\n-\n-    fn_def\n-}\n-\n-fn format_type(ty: &hir::Type, ctx: &AssistContext, module: hir::Module) -> String {\n-    ty.display_source_code(ctx.db(), module.into()).ok().unwrap_or_else(|| \"()\".to_string())\n-}\n-\n-fn path_at_offset(body: &FunctionBody, reference: &FileReference) -> Option<ast::Expr> {\n-    let var = body.token_at_offset(reference.range.start()).right_biased()?;\n-    let path = var.ancestors().find_map(ast::Expr::cast)?;\n-    stdx::always!(matches!(path, ast::Expr::PathExpr(_)));\n-    Some(path)\n-}\n-\n-fn is_mut_ref_expr(path: Option<&ast::Expr>) -> Option<bool> {\n-    let path = path?;\n-    let ref_expr = path.syntax().parent().and_then(ast::RefExpr::cast)?;\n-    Some(ref_expr.mut_token().is_some())\n-}\n-\n-fn is_mut_method_call(ctx: &AssistContext, path: Option<&ast::Expr>) -> Option<bool> {\n-    let path = path?;\n-    let method_call = path.syntax().parent().and_then(ast::MethodCallExpr::cast)?;\n-\n-    let func = ctx.sema.resolve_method_call(&method_call)?;\n-    let self_param = func.self_param(ctx.db())?;\n-    let access = self_param.access(ctx.db());\n-\n-    Some(matches!(access, hir::Access::Exclusive))\n+#[derive(Debug)]\n+enum RetType {\n+    Expr(hir::Type),\n+    Stmt,\n }\n \n-fn fix_param_usages(ctx: &AssistContext, params: &[Param], syntax: &SyntaxNode) -> SyntaxNode {\n-    let mut rewriter = SyntaxRewriter::default();\n-    for param in params {\n-        if !param.kind().is_ref() {\n-            continue;\n+impl RetType {\n+    fn is_unit(&self) -> bool {\n+        match self {\n+            RetType::Expr(ty) => ty.is_unit(),\n+            RetType::Stmt => true,\n         }\n+    }\n \n-        let usages = Definition::Local(param.node)\n-            .usages(&ctx.sema)\n-            .in_scope(SearchScope::single_file(ctx.frange.file_id))\n-            .all();\n-        let usages = usages\n-            .iter()\n-            .flat_map(|(_, rs)| rs.iter())\n-            .filter(|reference| syntax.text_range().contains_range(reference.range));\n-        for reference in usages {\n-            let token = match syntax.token_at_offset(reference.range.start()).right_biased() {\n-                Some(a) => a,\n-                None => {\n-                    stdx::never!(false, \"cannot find token at variable usage: {:?}\", reference);\n-                    continue;\n-                }\n-            };\n-            let path = match token.ancestors().find_map(ast::Expr::cast) {\n-                Some(n) => n,\n-                None => {\n-                    stdx::never!(false, \"cannot find path parent of variable usage: {:?}\", token);\n-                    continue;\n-                }\n-            };\n-            stdx::always!(matches!(path, ast::Expr::PathExpr(_)));\n-            match path.syntax().ancestors().skip(1).find_map(ast::Expr::cast) {\n-                Some(ast::Expr::MethodCallExpr(_)) => {\n-                    // do nothing\n-                }\n-                Some(ast::Expr::RefExpr(node))\n-                    if param.kind() == ParamKind::MutRef && node.mut_token().is_some() =>\n-                {\n-                    rewriter.replace_ast(&node.clone().into(), &node.expr().unwrap());\n-                }\n-                Some(ast::Expr::RefExpr(node))\n-                    if param.kind() == ParamKind::SharedRef && node.mut_token().is_none() =>\n-                {\n-                    rewriter.replace_ast(&node.clone().into(), &node.expr().unwrap());\n-                }\n-                Some(_) | None => {\n-                    rewriter.replace_ast(&path, &ast::make::expr_prefix(T![*], path.clone()));\n-                }\n-            };\n+    fn as_fn_ret(&self) -> Option<&hir::Type> {\n+        match self {\n+            RetType::Stmt => None,\n+            RetType::Expr(ty) if ty.is_unit() => None,\n+            RetType::Expr(ty) => Some(ty),\n         }\n     }\n-\n-    rewriter.rewrite(syntax)\n }\n \n #[derive(Debug)]\n@@ -505,11 +206,6 @@ enum FunctionBody {\n     Span { elements: Vec<SyntaxElement>, leading_indent: String },\n }\n \n-enum Anchor {\n-    Freestanding,\n-    Method,\n-}\n-\n impl FunctionBody {\n     fn from_whole_node(node: SyntaxNode) -> Option<Self> {\n         match node.kind() {\n@@ -568,16 +264,6 @@ impl FunctionBody {\n         }\n     }\n \n-    fn scope_for_fn_insertion(&self, anchor: Anchor) -> Option<SyntaxNode> {\n-        match self {\n-            FunctionBody::Expr(e) => scope_for_fn_insertion(e.syntax(), anchor),\n-            FunctionBody::Span { elements, .. } => {\n-                let node = elements.iter().find_map(|e| e.as_node())?;\n-                scope_for_fn_insertion(&node, anchor)\n-            }\n-        }\n-    }\n-\n     fn descendants(&self) -> impl Iterator<Item = SyntaxNode> + '_ {\n         match self {\n             FunctionBody::Expr(expr) => Either::Right(expr.syntax().descendants()),\n@@ -590,6 +276,30 @@ impl FunctionBody {\n         }\n     }\n \n+    fn text_range(&self) -> TextRange {\n+        match self {\n+            FunctionBody::Expr(expr) => expr.syntax().text_range(),\n+            FunctionBody::Span { elements, .. } => TextRange::new(\n+                elements.first().unwrap().text_range().start(),\n+                elements.last().unwrap().text_range().end(),\n+            ),\n+        }\n+    }\n+\n+    fn contains_range(&self, range: TextRange) -> bool {\n+        self.text_range().contains_range(range)\n+    }\n+\n+    fn preceedes_range(&self, range: TextRange) -> bool {\n+        self.text_range().end() <= range.start()\n+    }\n+\n+    fn contains_node(&self, node: &SyntaxNode) -> bool {\n+        self.contains_range(node.text_range())\n+    }\n+}\n+\n+impl HasTokenAtOffset for FunctionBody {\n     fn token_at_offset(&self, offset: TextSize) -> TokenAtOffset<SyntaxToken> {\n         match self {\n             FunctionBody::Expr(expr) => expr.syntax().token_at_offset(offset),\n@@ -621,31 +331,278 @@ impl FunctionBody {\n             }\n         }\n     }\n+}\n \n-    fn text_range(&self) -> TextRange {\n-        match self {\n-            FunctionBody::Expr(expr) => expr.syntax().text_range(),\n-            FunctionBody::Span { elements, .. } => TextRange::new(\n-                elements.first().unwrap().text_range().start(),\n-                elements.last().unwrap().text_range().end(),\n-            ),\n-        }\n+fn element_to_node(node: SyntaxElement) -> SyntaxNode {\n+    match node {\n+        syntax::NodeOrToken::Node(n) => n,\n+        syntax::NodeOrToken::Token(t) => t.parent(),\n     }\n+}\n \n-    fn contains_range(&self, range: TextRange) -> bool {\n-        self.text_range().contains_range(range)\n+fn extraction_target(node: &SyntaxNode, selection_range: TextRange) -> Option<FunctionBody> {\n+    if node.text_range() == selection_range {\n+        let body = FunctionBody::from_whole_node(node.clone());\n+        if body.is_some() {\n+            return body;\n+        }\n     }\n \n-    fn preceedes_range(&self, range: TextRange) -> bool {\n-        self.text_range().end() <= range.start()\n+    if node.kind() == BLOCK_EXPR {\n+        let body = FunctionBody::from_range(&node, selection_range);\n+        if body.is_some() {\n+            return body;\n+        }\n+    }\n+    if let Some(parent) = node.parent() {\n+        if parent.kind() == BLOCK_EXPR {\n+            let body = FunctionBody::from_range(&parent, selection_range);\n+            if body.is_some() {\n+                return body;\n+            }\n+        }\n     }\n \n-    fn contains_node(&self, node: &SyntaxNode) -> bool {\n-        self.contains_range(node.text_range())\n+    let body = FunctionBody::from_whole_node(node.clone());\n+    if body.is_some() {\n+        return body;\n+    }\n+\n+    let body = node.ancestors().find_map(FunctionBody::from_whole_node);\n+    if body.is_some() {\n+        return body;\n+    }\n+\n+    None\n+}\n+\n+/// Returns a vector of local variables that are referenced in `body`\n+fn vars_used_in_body(body: &FunctionBody, ctx: &AssistContext) -> Vec<Local> {\n+    body.descendants()\n+        .filter_map(ast::NameRef::cast)\n+        .filter_map(|name_ref| NameRefClass::classify(&ctx.sema, &name_ref))\n+        .map(|name_kind| name_kind.referenced(ctx.db()))\n+        .filter_map(|definition| match definition {\n+            Definition::Local(local) => Some(local),\n+            _ => None,\n+        })\n+        .unique()\n+        .collect()\n+}\n+\n+fn self_param_from_usages(\n+    ctx: &AssistContext,\n+    body: &FunctionBody,\n+    vars_used_in_body: &[Local],\n+) -> Option<(Local, ast::SelfParam)> {\n+    let mut iter = vars_used_in_body\n+        .iter()\n+        .filter(|var| var.is_self(ctx.db()))\n+        .map(|var| (var, var.source(ctx.db())))\n+        .filter(|(_, src)| is_defined_before(ctx, body, src))\n+        .filter_map(|(&node, src)| match src.value {\n+            Either::Right(it) => Some((node, it)),\n+            Either::Left(_) => {\n+                stdx::never!(false, \"Local::is_self returned true, but source is IdentPat\");\n+                None\n+            }\n+        });\n+\n+    let self_param = iter.next();\n+    stdx::always!(\n+        iter.next().is_none(),\n+        \"body references two different self params both defined outside\"\n+    );\n+\n+    self_param\n+}\n+\n+fn extracted_function_params(\n+    ctx: &AssistContext,\n+    body: &FunctionBody,\n+    vars_used_in_body: &[Local],\n+) -> Vec<Param> {\n+    vars_used_in_body\n+        .iter()\n+        .filter(|var| !var.is_self(ctx.db()))\n+        .map(|node| (node, node.source(ctx.db())))\n+        .filter(|(_, src)| is_defined_before(ctx, body, src))\n+        .filter_map(|(&node, src)| {\n+            if src.value.is_left() {\n+                Some(node)\n+            } else {\n+                stdx::never!(false, \"Local::is_self returned false, but source is SelfParam\");\n+                None\n+            }\n+        })\n+        .map(|var| {\n+            let usages = LocalUsages::find(ctx, var);\n+            Param {\n+                var,\n+                has_usages_afterwards: has_usages_after_body(&usages, body),\n+                has_mut_inside_body: has_exclusive_usages(ctx, &usages, body),\n+                is_copy: true,\n+            }\n+        })\n+        .collect()\n+}\n+\n+fn has_usages_after_body(usages: &LocalUsages, body: &FunctionBody) -> bool {\n+    usages.iter().any(|reference| body.preceedes_range(reference.range))\n+}\n+\n+fn has_exclusive_usages(ctx: &AssistContext, usages: &LocalUsages, body: &FunctionBody) -> bool {\n+    usages\n+        .iter()\n+        .filter(|reference| body.contains_range(reference.range))\n+        .any(|reference| reference_is_exclusive(reference, body, ctx))\n+}\n+\n+fn reference_is_exclusive(\n+    reference: &FileReference,\n+    body: &FunctionBody,\n+    ctx: &AssistContext,\n+) -> bool {\n+    if reference.access == Some(ReferenceAccess::Write) {\n+        return true;\n+    }\n+\n+    let path = path_at_offset(body, reference);\n+    if is_mut_ref_expr(path.as_ref()).unwrap_or(false) {\n+        return true;\n+    }\n+\n+    if is_mut_method_call(ctx, path.as_ref()).unwrap_or(false) {\n+        return true;\n+    }\n+\n+    false\n+}\n+\n+struct LocalUsages(ide_db::search::UsageSearchResult);\n+\n+impl LocalUsages {\n+    fn find(ctx: &AssistContext, var: Local) -> Self {\n+        Self(\n+            Definition::Local(var)\n+                .usages(&ctx.sema)\n+                .in_scope(SearchScope::single_file(ctx.frange.file_id))\n+                .all(),\n+        )\n+    }\n+\n+    fn iter(&self) -> impl Iterator<Item = &FileReference> + '_ {\n+        self.0.iter().flat_map(|(_, rs)| rs.iter())\n+    }\n+}\n+\n+trait HasTokenAtOffset {\n+    fn token_at_offset(&self, offset: TextSize) -> TokenAtOffset<SyntaxToken>;\n+}\n+\n+impl HasTokenAtOffset for SyntaxNode {\n+    fn token_at_offset(&self, offset: TextSize) -> TokenAtOffset<SyntaxToken> {\n+        SyntaxNode::token_at_offset(&self, offset)\n+    }\n+}\n+\n+fn path_at_offset(node: &dyn HasTokenAtOffset, reference: &FileReference) -> Option<ast::Expr> {\n+    let token = node.token_at_offset(reference.range.start()).right_biased().or_else(|| {\n+        stdx::never!(false, \"cannot find token at variable usage: {:?}\", reference);\n+        None\n+    })?;\n+    let path = token.ancestors().find_map(ast::Expr::cast).or_else(|| {\n+        stdx::never!(false, \"cannot find path parent of variable usage: {:?}\", token);\n+        None\n+    })?;\n+    stdx::always!(matches!(path, ast::Expr::PathExpr(_)));\n+    Some(path)\n+}\n+\n+fn is_mut_ref_expr(path: Option<&ast::Expr>) -> Option<bool> {\n+    let path = path?;\n+    let ref_expr = path.syntax().parent().and_then(ast::RefExpr::cast)?;\n+    Some(ref_expr.mut_token().is_some())\n+}\n+\n+fn is_mut_method_call(ctx: &AssistContext, path: Option<&ast::Expr>) -> Option<bool> {\n+    let path = path?;\n+    let method_call = path.syntax().parent().and_then(ast::MethodCallExpr::cast)?;\n+\n+    let func = ctx.sema.resolve_method_call(&method_call)?;\n+    let self_param = func.self_param(ctx.db())?;\n+    let access = self_param.access(ctx.db());\n+\n+    Some(matches!(access, hir::Access::Exclusive))\n+}\n+\n+/// Returns a vector of local variables that are defined in `body`\n+fn vars_defined_in_body(body: &FunctionBody, ctx: &AssistContext) -> Vec<Local> {\n+    body.descendants()\n+        .filter_map(ast::IdentPat::cast)\n+        .filter_map(|let_stmt| ctx.sema.to_def(&let_stmt))\n+        .unique()\n+        .collect()\n+}\n+\n+fn vars_defined_in_body_and_outlive(ctx: &AssistContext, body: &FunctionBody) -> Vec<Local> {\n+    let mut vars_defined_in_body = vars_defined_in_body(&body, ctx);\n+    vars_defined_in_body.retain(|var| var_outlives_body(ctx, body, var));\n+    vars_defined_in_body\n+}\n+\n+fn is_defined_before(\n+    ctx: &AssistContext,\n+    body: &FunctionBody,\n+    src: &hir::InFile<Either<ast::IdentPat, ast::SelfParam>>,\n+) -> bool {\n+    src.file_id.original_file(ctx.db()) == ctx.frange.file_id\n+        && !body.contains_node(&either_syntax(&src.value))\n+}\n+\n+fn either_syntax(value: &Either<ast::IdentPat, ast::SelfParam>) -> &SyntaxNode {\n+    match value {\n+        Either::Left(pat) => pat.syntax(),\n+        Either::Right(it) => it.syntax(),\n+    }\n+}\n+\n+fn var_outlives_body(ctx: &AssistContext, body: &FunctionBody, var: &Local) -> bool {\n+    let usages = Definition::Local(*var)\n+        .usages(&ctx.sema)\n+        .in_scope(SearchScope::single_file(ctx.frange.file_id))\n+        .all();\n+    let mut usages = usages.iter().flat_map(|(_, rs)| rs.iter());\n+\n+    usages.any(|reference| body.preceedes_range(reference.range))\n+}\n+\n+fn body_return_ty(ctx: &AssistContext, body: &FunctionBody) -> Option<RetType> {\n+    match body.tail_expr() {\n+        Some(expr) => {\n+            let ty = ctx.sema.type_of_expr(&expr)?;\n+            Some(RetType::Expr(ty))\n+        }\n+        None => Some(RetType::Stmt),\n+    }\n+}\n+#[derive(Debug)]\n+enum Anchor {\n+    Freestanding,\n+    Method,\n+}\n+\n+fn scope_for_fn_insertion(body: &FunctionBody, anchor: Anchor) -> Option<SyntaxNode> {\n+    match body {\n+        FunctionBody::Expr(e) => scope_for_fn_insertion_node(e.syntax(), anchor),\n+        FunctionBody::Span { elements, .. } => {\n+            let node = elements.iter().find_map(|e| e.as_node())?;\n+            scope_for_fn_insertion_node(&node, anchor)\n+        }\n     }\n }\n \n-fn scope_for_fn_insertion(node: &SyntaxNode, anchor: Anchor) -> Option<SyntaxNode> {\n+fn scope_for_fn_insertion_node(node: &SyntaxNode, anchor: Anchor) -> Option<SyntaxNode> {\n     let mut ancestors = node.ancestors().peekable();\n     let mut last_ancestor = None;\n     while let Some(next_ancestor) = ancestors.next() {\n@@ -674,34 +631,207 @@ fn scope_for_fn_insertion(node: &SyntaxNode, anchor: Anchor) -> Option<SyntaxNod\n     last_ancestor\n }\n \n-fn either_syntax(value: &Either<ast::IdentPat, ast::SelfParam>) -> &SyntaxNode {\n-    match value {\n-        Either::Left(pat) => pat.syntax(),\n-        Either::Right(it) => it.syntax(),\n+fn format_replacement(ctx: &AssistContext, fun: &Function) -> String {\n+    let mut buf = String::new();\n+\n+    match fun.vars_defined_in_body_and_outlive.as_slice() {\n+        [] => {}\n+        [var] => format_to!(buf, \"let {} = \", var.name(ctx.db()).unwrap()),\n+        [v0, vs @ ..] => {\n+            buf.push_str(\"let (\");\n+            format_to!(buf, \"{}\", v0.name(ctx.db()).unwrap());\n+            for var in vs {\n+                format_to!(buf, \", {}\", var.name(ctx.db()).unwrap());\n+            }\n+            buf.push_str(\") = \");\n+        }\n+    }\n+\n+    if fun.self_param.is_some() {\n+        format_to!(buf, \"self.\");\n+    }\n+    format_to!(buf, \"{}(\", fun.name);\n+    format_arg_list_to(&mut buf, fun, ctx);\n+    format_to!(buf, \")\");\n+\n+    if fun.ret_ty.is_unit() {\n+        format_to!(buf, \";\");\n     }\n+\n+    buf\n }\n \n-/// Returns a vector of local variables that are referenced in `body`\n-fn vars_used_in_body(body: &FunctionBody, ctx: &AssistContext) -> Vec<Local> {\n-    body.descendants()\n-        .filter_map(ast::NameRef::cast)\n-        .filter_map(|name_ref| NameRefClass::classify(&ctx.sema, &name_ref))\n-        .map(|name_kind| name_kind.referenced(ctx.db()))\n-        .filter_map(|definition| match definition {\n-            Definition::Local(local) => Some(local),\n-            _ => None,\n-        })\n-        .unique()\n-        .collect()\n+fn format_arg_list_to(buf: &mut String, fun: &Function, ctx: &AssistContext) {\n+    let mut it = fun.params.iter();\n+    if let Some(param) = it.next() {\n+        format_arg_to(buf, ctx, param);\n+    }\n+    for param in it {\n+        buf.push_str(\", \");\n+        format_arg_to(buf, ctx, param);\n+    }\n }\n \n-/// Returns a vector of local variables that are defined in `body`\n-fn vars_defined_in_body(body: &FunctionBody, ctx: &AssistContext) -> Vec<Local> {\n-    body.descendants()\n-        .filter_map(ast::IdentPat::cast)\n-        .filter_map(|let_stmt| ctx.sema.to_def(&let_stmt))\n-        .unique()\n-        .collect()\n+fn format_arg_to(buf: &mut String, ctx: &AssistContext, param: &Param) {\n+    format_to!(buf, \"{}{}\", param.value_prefix(), param.var.name(ctx.db()).unwrap());\n+}\n+\n+fn format_function(\n+    ctx: &AssistContext,\n+    module: hir::Module,\n+    fun: &Function,\n+    indent: IndentLevel,\n+) -> String {\n+    let mut fn_def = String::new();\n+    format_to!(fn_def, \"\\n\\n{}fn $0{}(\", indent, fun.name);\n+    format_function_param_list_to(&mut fn_def, ctx, module, fun);\n+    fn_def.push(')');\n+    format_function_ret_to(&mut fn_def, ctx, module, fun);\n+    fn_def.push_str(\" {\");\n+    format_function_body_to(&mut fn_def, ctx, indent, fun);\n+    format_to!(fn_def, \"{}}}\", indent);\n+\n+    fn_def\n+}\n+\n+fn format_function_param_list_to(\n+    fn_def: &mut String,\n+    ctx: &AssistContext,\n+    module: hir::Module,\n+    fun: &Function,\n+) {\n+    let mut it = fun.params.iter();\n+    if let Some(self_param) = &fun.self_param {\n+        format_to!(fn_def, \"{}\", self_param);\n+    } else if let Some(param) = it.next() {\n+        format_param_to(fn_def, ctx, module, param);\n+    }\n+    for param in it {\n+        fn_def.push_str(\", \");\n+        format_param_to(fn_def, ctx, module, param);\n+    }\n+}\n+\n+fn format_param_to(fn_def: &mut String, ctx: &AssistContext, module: hir::Module, param: &Param) {\n+    format_to!(\n+        fn_def,\n+        \"{}{}: {}{}\",\n+        param.mut_pattern(),\n+        param.var.name(ctx.db()).unwrap(),\n+        param.type_prefix(),\n+        format_type(&param.var.ty(ctx.db()), ctx, module)\n+    );\n+}\n+\n+fn format_function_ret_to(\n+    fn_def: &mut String,\n+    ctx: &AssistContext,\n+    module: hir::Module,\n+    fun: &Function,\n+) {\n+    if let Some(ty) = fun.ret_ty.as_fn_ret() {\n+        format_to!(fn_def, \" -> {}\", format_type(ty, ctx, module));\n+    } else {\n+        match fun.vars_defined_in_body_and_outlive.as_slice() {\n+            [] => {}\n+            [var] => {\n+                format_to!(fn_def, \" -> {}\", format_type(&var.ty(ctx.db()), ctx, module));\n+            }\n+            [v0, vs @ ..] => {\n+                format_to!(fn_def, \" -> ({}\", format_type(&v0.ty(ctx.db()), ctx, module));\n+                for var in vs {\n+                    format_to!(fn_def, \", {}\", format_type(&var.ty(ctx.db()), ctx, module));\n+                }\n+                fn_def.push(')');\n+            }\n+        }\n+    }\n+}\n+\n+fn format_function_body_to(\n+    fn_def: &mut String,\n+    ctx: &AssistContext,\n+    indent: IndentLevel,\n+    fun: &Function,\n+) {\n+    match &fun.body {\n+        FunctionBody::Expr(expr) => {\n+            fn_def.push('\\n');\n+            let expr = expr.indent(indent);\n+            let expr = fix_param_usages(ctx, &fun.params, expr.syntax());\n+            format_to!(fn_def, \"{}{}\", indent + 1, expr);\n+            fn_def.push('\\n');\n+        }\n+        FunctionBody::Span { elements, leading_indent } => {\n+            format_to!(fn_def, \"{}\", leading_indent);\n+            for element in elements {\n+                match element {\n+                    syntax::NodeOrToken::Node(node) => {\n+                        format_to!(fn_def, \"{}\", fix_param_usages(ctx, &fun.params, node));\n+                    }\n+                    syntax::NodeOrToken::Token(token) => {\n+                        format_to!(fn_def, \"{}\", token);\n+                    }\n+                }\n+            }\n+            if !fn_def.ends_with('\\n') {\n+                fn_def.push('\\n');\n+            }\n+        }\n+    }\n+\n+    match fun.vars_defined_in_body_and_outlive.as_slice() {\n+        [] => {}\n+        [var] => format_to!(fn_def, \"{}{}\\n\", indent + 1, var.name(ctx.db()).unwrap()),\n+        [v0, vs @ ..] => {\n+            format_to!(fn_def, \"{}({}\", indent + 1, v0.name(ctx.db()).unwrap());\n+            for var in vs {\n+                format_to!(fn_def, \", {}\", var.name(ctx.db()).unwrap());\n+            }\n+            fn_def.push_str(\")\\n\");\n+        }\n+    }\n+}\n+\n+fn format_type(ty: &hir::Type, ctx: &AssistContext, module: hir::Module) -> String {\n+    ty.display_source_code(ctx.db(), module.into()).ok().unwrap_or_else(|| \"()\".to_string())\n+}\n+\n+fn fix_param_usages(ctx: &AssistContext, params: &[Param], syntax: &SyntaxNode) -> SyntaxNode {\n+    let mut rewriter = SyntaxRewriter::default();\n+    for param in params {\n+        if !param.kind().is_ref() {\n+            continue;\n+        }\n+\n+        let usages = LocalUsages::find(ctx, param.var);\n+        let usages = usages\n+            .iter()\n+            .filter(|reference| syntax.text_range().contains_range(reference.range))\n+            .filter_map(|reference| path_at_offset(syntax, reference));\n+        for path in usages {\n+            match path.syntax().ancestors().skip(1).find_map(ast::Expr::cast) {\n+                Some(ast::Expr::MethodCallExpr(_)) => {\n+                    // do nothing\n+                }\n+                Some(ast::Expr::RefExpr(node))\n+                    if param.kind() == ParamKind::MutRef && node.mut_token().is_some() =>\n+                {\n+                    rewriter.replace_ast(&node.clone().into(), &node.expr().unwrap());\n+                }\n+                Some(ast::Expr::RefExpr(node))\n+                    if param.kind() == ParamKind::SharedRef && node.mut_token().is_none() =>\n+                {\n+                    rewriter.replace_ast(&node.clone().into(), &node.expr().unwrap());\n+                }\n+                Some(_) | None => {\n+                    rewriter.replace_ast(&path, &ast::make::expr_prefix(T![*], path.clone()));\n+                }\n+            };\n+        }\n+    }\n+\n+    rewriter.rewrite(syntax)\n }\n \n #[cfg(test)]"}]}