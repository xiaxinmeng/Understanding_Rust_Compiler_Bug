{"sha": "1e32412e28d6668af5c6fe85b4fc921fb1de9a98", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlMzI0MTJlMjhkNjY2OGFmNWM2ZmU4NWI0ZmM5MjFmYjFkZTlhOTg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-12-19T15:27:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-19T15:27:45Z"}, "message": "Merge #2596\n\n2596: Refactor macro tests r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "b82af260fc89c4de8a9de300bc9a61e272a1329f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b82af260fc89c4de8a9de300bc9a61e272a1329f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e32412e28d6668af5c6fe85b4fc921fb1de9a98", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd+5bxCRBK7hj4Ov3rIwAAdHIIAASeHqTkk19pr6tAoV1yPMM1\ndJ3Hqq2S91ARyeJbp240otKktPijbqMf+NX6Ww4WT/CnLFkSELpktAKk/7neRl39\n76zW2EQUVb/CIn1EmPgxiHURwTCwjJ/NllmXEnKSl+yrkr+Ue2/uKG0NqBc2uepG\nQb47Z9+bSY4kUZ5Rj05VnhjOJL5ECZb+SV5VLbEK2mEjzYMSR+tme3VT967gTapf\nZKZciMMsUGQ7SAFPAcAj8+U8moJDfiCPwpK1JJItlCI3Lc4Qljyk4Iay+4xOqPUf\nGb9sGOCMJcpJbQyw0kYC60OapTZXRsht2LUPoVISfnYE3pRiYJUdVoGtsQ2/ceQ=\n=c/nL\n-----END PGP SIGNATURE-----\n", "payload": "tree b82af260fc89c4de8a9de300bc9a61e272a1329f\nparent e17dcc45a679c025e79639bd2d22c3b0f20953f9\nparent 6edc54a1e6a48f6fe3191c549befe91674342d9a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1576769265 +0000\ncommitter GitHub <noreply@github.com> 1576769265 +0000\n\nMerge #2596\n\n2596: Refactor macro tests r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e32412e28d6668af5c6fe85b4fc921fb1de9a98", "html_url": "https://github.com/rust-lang/rust/commit/1e32412e28d6668af5c6fe85b4fc921fb1de9a98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e32412e28d6668af5c6fe85b4fc921fb1de9a98/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e17dcc45a679c025e79639bd2d22c3b0f20953f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e17dcc45a679c025e79639bd2d22c3b0f20953f9", "html_url": "https://github.com/rust-lang/rust/commit/e17dcc45a679c025e79639bd2d22c3b0f20953f9"}, {"sha": "6edc54a1e6a48f6fe3191c549befe91674342d9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6edc54a1e6a48f6fe3191c549befe91674342d9a", "html_url": "https://github.com/rust-lang/rust/commit/6edc54a1e6a48f6fe3191c549befe91674342d9a"}], "stats": {"total": 680, "additions": 283, "deletions": 397}, "files": [{"sha": "ea2cac069e6432c6b985a714b5fbf4eb254c44c5", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1e32412e28d6668af5c6fe85b4fc921fb1de9a98/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e32412e28d6668af5c6fe85b4fc921fb1de9a98/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=1e32412e28d6668af5c6fe85b4fc921fb1de9a98", "patch": "@@ -476,7 +476,7 @@ impl<'a> TreeSink for TtTreeSink<'a> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::tests::{create_rules, expand};\n+    use crate::tests::parse_macro;\n     use ra_parser::TokenSource;\n     use ra_syntax::{\n         algo::{insert_children, InsertPosition},\n@@ -485,7 +485,7 @@ mod tests {\n \n     #[test]\n     fn convert_tt_token_source() {\n-        let rules = create_rules(\n+        let expansion = parse_macro(\n             r#\"\n             macro_rules! literals {\n                 ($i:ident) => {\n@@ -498,8 +498,8 @@ mod tests {\n                 }\n             }\n             \"#,\n-        );\n-        let expansion = expand(&rules, \"literals!(foo);\");\n+        )\n+        .expand_tt(\"literals!(foo);\");\n         let tts = &[expansion.into()];\n         let buffer = tt::buffer::TokenBuffer::new(tts);\n         let mut tt_src = SubtreeTokenSource::new(&buffer);\n@@ -527,7 +527,7 @@ mod tests {\n \n     #[test]\n     fn stmts_token_trees_to_expr_is_err() {\n-        let rules = create_rules(\n+        let expansion = parse_macro(\n             r#\"\n             macro_rules! stmts {\n                 () => {\n@@ -538,8 +538,8 @@ mod tests {\n                 }\n             }\n             \"#,\n-        );\n-        let expansion = expand(&rules, \"stmts!();\");\n+        )\n+        .expand_tt(\"stmts!();\");\n         assert!(token_tree_to_syntax_node(&expansion, FragmentKind::Expr).is_err());\n     }\n "}, {"sha": "e640d115b4513eefc8211432f1f21be4d9d2b1b8", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 275, "deletions": 390, "changes": 665, "blob_url": "https://github.com/rust-lang/rust/blob/1e32412e28d6668af5c6fe85b4fc921fb1de9a98/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e32412e28d6668af5c6fe85b4fc921fb1de9a98/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=1e32412e28d6668af5c6fe85b4fc921fb1de9a98", "patch": "@@ -1,5 +1,7 @@\n+use std::fmt::Write;\n+\n use ra_parser::FragmentKind;\n-use ra_syntax::{ast, AstNode, NodeOrToken, WalkEvent};\n+use ra_syntax::{ast, AstNode, NodeOrToken, SyntaxKind::IDENT, SyntaxNode, WalkEvent, T};\n use test_utils::assert_eq_text;\n \n use super::*;\n@@ -61,13 +63,14 @@ mod rule_parsing {\n \n #[test]\n fn test_token_id_shift() {\n-    let macro_definition = r#\"\n+    let expansion = parse_macro(\n+        r#\"\n macro_rules! foobar {\n     ($e:ident) => { foo bar $e }\n }\n-\"#;\n-    let rules = create_rules(macro_definition);\n-    let expansion = expand(&rules, \"foobar!(baz);\");\n+\"#,\n+    )\n+    .expand_tt(\"foobar!(baz);\");\n \n     fn get_id(t: &tt::TokenTree) -> Option<u32> {\n         if let tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) = t {\n@@ -90,22 +93,23 @@ macro_rules! foobar {\n \n #[test]\n fn test_token_map() {\n-    use ra_parser::SyntaxKind::*;\n-    use ra_syntax::T;\n-\n-    let macro_definition = r#\"\n+    let expanded = parse_macro(\n+        r#\"\n macro_rules! foobar {\n     ($e:ident) => { fn $e() {} }\n }\n-\"#;\n-    let rules = create_rules(macro_definition);\n-    let (expansion, (token_map, content)) = expand_and_map(&rules, \"foobar!(baz);\");\n+\"#,\n+    )\n+    .expand_tt(\"foobar!(baz);\");\n+\n+    let (node, token_map) = token_tree_to_syntax_node(&expanded, FragmentKind::Items).unwrap();\n+    let content = node.syntax_node().to_string();\n \n     let get_text = |id, kind| -> String {\n         content[token_map.range_by_token(id).unwrap().by_kind(kind).unwrap()].to_string()\n     };\n \n-    assert_eq!(expansion.token_trees.len(), 4);\n+    assert_eq!(expanded.token_trees.len(), 4);\n     // {($e:ident) => { fn $e() {} }}\n     // 012345      67 8 9  T12  3\n \n@@ -116,7 +120,7 @@ macro_rules! foobar {\n \n #[test]\n fn test_convert_tt() {\n-    let macro_definition = r#\"\n+    parse_macro(r#\"\n macro_rules! impl_froms {\n     ($e:ident: $($v:ident),*) => {\n         $(\n@@ -128,36 +132,28 @@ macro_rules! impl_froms {\n         )*\n     }\n }\n-\"#;\n-\n-    let macro_invocation = r#\"\n-impl_froms!(TokenTree: Leaf, Subtree);\n-\"#;\n-\n-    let rules = create_rules(macro_definition);\n-    let expansion = expand(&rules, macro_invocation);\n-    assert_eq!(\n-        expansion.to_string(),\n-        \"impl From <Leaf > for TokenTree {fn from (it : Leaf) -> TokenTree {TokenTree ::Leaf (it)}} \\\n-         impl From <Subtree > for TokenTree {fn from (it : Subtree) -> TokenTree {TokenTree ::Subtree (it)}}\"\n-    )\n+\"#)\n+        .assert_expand_tt(\n+            \"impl_froms!(TokenTree: Leaf, Subtree);\",\n+            \"impl From <Leaf > for TokenTree {fn from (it : Leaf) -> TokenTree {TokenTree ::Leaf (it)}} \\\n+             impl From <Subtree > for TokenTree {fn from (it : Subtree) -> TokenTree {TokenTree ::Subtree (it)}}\"\n+        );\n }\n \n #[test]\n fn test_expr_order() {\n-    let rules = create_rules(\n+    let expanded = parse_macro(\n         r#\"\n         macro_rules! foo {\n             ($ i:expr) => {\n                  fn bar() { $ i * 2; }\n             }\n         }\n \"#,\n-    );\n-    let expanded = expand(&rules, \"foo! { 1 + 1}\");\n-    let tree = token_tree_to_syntax_node(&expanded, FragmentKind::Items).unwrap().0.syntax_node();\n+    )\n+    .expand_items(\"foo! { 1 + 1}\");\n \n-    let dump = format!(\"{:#?}\", tree);\n+    let dump = format!(\"{:#?}\", expanded);\n     assert_eq_text!(\n         dump.trim(),\n         r#\"MACRO_ITEMS@[0; 15)\n@@ -189,7 +185,7 @@ fn test_expr_order() {\n \n #[test]\n fn test_fail_match_pattern_by_first_token() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             ($ i:ident) => (\n@@ -203,16 +199,15 @@ fn test_fail_match_pattern_by_first_token() {\n             )\n         }\n \"#,\n-    );\n-\n-    assert_expansion(MacroKind::Items, &rules, \"foo! { foo }\", \"mod foo {}\");\n-    assert_expansion(MacroKind::Items, &rules, \"foo! { = bar }\", \"fn bar () {}\");\n-    assert_expansion(MacroKind::Items, &rules, \"foo! { + Baz }\", \"struct Baz ;\");\n+    )\n+    .assert_expand_items(\"foo! { foo }\", \"mod foo {}\")\n+    .assert_expand_items(\"foo! { = bar }\", \"fn bar () {}\")\n+    .assert_expand_items(\"foo! { + Baz }\", \"struct Baz ;\");\n }\n \n #[test]\n fn test_fail_match_pattern_by_last_token() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             ($ i:ident) => (\n@@ -226,16 +221,15 @@ fn test_fail_match_pattern_by_last_token() {\n             )\n         }\n \"#,\n-    );\n-\n-    assert_expansion(MacroKind::Items, &rules, \"foo! { foo }\", \"mod foo {}\");\n-    assert_expansion(MacroKind::Items, &rules, \"foo! { bar = }\", \"fn bar () {}\");\n-    assert_expansion(MacroKind::Items, &rules, \"foo! { Baz + }\", \"struct Baz ;\");\n+    )\n+    .assert_expand_items(\"foo! { foo }\", \"mod foo {}\")\n+    .assert_expand_items(\"foo! { bar = }\", \"fn bar () {}\")\n+    .assert_expand_items(\"foo! { Baz + }\", \"struct Baz ;\");\n }\n \n #[test]\n fn test_fail_match_pattern_by_word_token() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             ($ i:ident) => (\n@@ -249,16 +243,15 @@ fn test_fail_match_pattern_by_word_token() {\n             )\n         }\n \"#,\n-    );\n-\n-    assert_expansion(MacroKind::Items, &rules, \"foo! { foo }\", \"mod foo {}\");\n-    assert_expansion(MacroKind::Items, &rules, \"foo! { spam bar }\", \"fn bar () {}\");\n-    assert_expansion(MacroKind::Items, &rules, \"foo! { eggs Baz }\", \"struct Baz ;\");\n+    )\n+    .assert_expand_items(\"foo! { foo }\", \"mod foo {}\")\n+    .assert_expand_items(\"foo! { spam bar }\", \"fn bar () {}\")\n+    .assert_expand_items(\"foo! { eggs Baz }\", \"struct Baz ;\");\n }\n \n #[test]\n fn test_match_group_pattern_by_separator_token() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             ($ ($ i:ident),*) => ($ (\n@@ -273,146 +266,126 @@ fn test_match_group_pattern_by_separator_token() {\n             )\n         }\n \"#,\n-    );\n-\n-    assert_expansion(MacroKind::Items, &rules, \"foo! { foo, bar }\", \"mod foo {} mod bar {}\");\n-    assert_expansion(MacroKind::Items, &rules, \"foo! { foo# bar }\", \"fn foo () {} fn bar () {}\");\n-    assert_expansion(MacroKind::Items, &rules, \"foo! { Foo,# Bar }\", \"struct Foo ; struct Bar ;\");\n+    )\n+    .assert_expand_items(\"foo! { foo, bar }\", \"mod foo {} mod bar {}\")\n+    .assert_expand_items(\"foo! { foo# bar }\", \"fn foo () {} fn bar () {}\")\n+    .assert_expand_items(\"foo! { Foo,# Bar }\", \"struct Foo ; struct Bar ;\");\n }\n \n #[test]\n fn test_match_group_pattern_with_multiple_defs() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             ($ ($ i:ident),*) => ( struct Bar { $ (\n                 fn $ i {}\n             )*} );\n         }\n \"#,\n-    );\n-\n-    assert_expansion(\n-        MacroKind::Items,\n-        &rules,\n-        \"foo! { foo, bar }\",\n-        \"struct Bar {fn foo {} fn bar {}}\",\n-    );\n+    )\n+    .assert_expand_items(\"foo! { foo, bar }\", \"struct Bar {fn foo {} fn bar {}}\");\n }\n \n #[test]\n fn test_match_group_pattern_with_multiple_statement() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             ($ ($ i:ident),*) => ( fn baz { $ (\n                 $ i ();\n             )*} );\n         }\n \"#,\n-    );\n-\n-    assert_expansion(MacroKind::Items, &rules, \"foo! { foo, bar }\", \"fn baz {foo () ; bar () ;}\");\n+    )\n+    .assert_expand_items(\"foo! { foo, bar }\", \"fn baz {foo () ; bar () ;}\");\n }\n \n #[test]\n fn test_match_group_pattern_with_multiple_statement_without_semi() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             ($ ($ i:ident),*) => ( fn baz { $ (\n                 $i()\n             );*} );\n         }\n \"#,\n-    );\n-\n-    assert_expansion(MacroKind::Items, &rules, \"foo! { foo, bar }\", \"fn baz {foo () ;bar ()}\");\n+    )\n+    .assert_expand_items(\"foo! { foo, bar }\", \"fn baz {foo () ;bar ()}\");\n }\n \n #[test]\n fn test_match_group_empty_fixed_token() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             ($ ($ i:ident)* #abc) => ( fn baz { $ (\n                 $ i ();\n             )*} );\n         }\n \"#,\n-    );\n-\n-    assert_expansion(MacroKind::Items, &rules, \"foo! {#abc}\", \"fn baz {}\");\n+    )\n+    .assert_expand_items(\"foo! {#abc}\", \"fn baz {}\");\n }\n \n #[test]\n fn test_match_group_in_subtree() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             (fn $name:ident {$($i:ident)*} ) => ( fn $name() { $ (\n                 $ i ();\n             )*} );\n         }\"#,\n-    );\n-\n-    assert_expansion(MacroKind::Items, &rules, \"foo! {fn baz {a b} }\", \"fn baz () {a () ; b () ;}\");\n+    )\n+    .assert_expand_items(\"foo! {fn baz {a b} }\", \"fn baz () {a () ; b () ;}\");\n }\n \n #[test]\n fn test_match_group_with_multichar_sep() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             (fn $name:ident {$($i:literal)*} ) => ( fn $name() -> bool { $($i)&&*} );\n         }\"#,\n-    );\n-\n-    assert_expansion(\n-        MacroKind::Items,\n-        &rules,\n-        \"foo! (fn baz {true true} );\",\n-        \"fn baz () -> bool {true &&true}\",\n-    );\n+    )\n+    .assert_expand_items(\"foo! (fn baz {true true} );\", \"fn baz () -> bool {true &&true}\");\n }\n \n #[test]\n fn test_match_group_zero_match() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             ( $($i:ident)* ) => ();\n         }\"#,\n-    );\n-\n-    assert_expansion(MacroKind::Items, &rules, \"foo! ();\", \"\");\n+    )\n+    .assert_expand_items(\"foo! ();\", \"\");\n }\n \n #[test]\n fn test_match_group_in_group() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             { $( ( $($i:ident)* ) )* } => ( $( ( $($i)* ) )* );\n         }\"#,\n-    );\n-\n-    assert_expansion(MacroKind::Items, &rules, \"foo! ( (a b) );\", \"(a b)\");\n+    )\n+    .assert_expand_items(\"foo! ( (a b) );\", \"(a b)\");\n }\n \n #[test]\n fn test_expand_to_item_list() {\n-    let rules = create_rules(\n+    let tree = parse_macro(\n         \"\n             macro_rules! structs {\n                 ($($i:ident),*) => {\n                     $(struct $i { field: u32 } )*\n                 }\n             }\n             \",\n-    );\n-    let expansion = expand(&rules, \"structs!(Foo, Bar);\");\n-    let tree = token_tree_to_syntax_node(&expansion, FragmentKind::Items).unwrap().0.syntax_node();\n+    )\n+    .expand_items(\"structs!(Foo, Bar);\");\n     assert_eq!(\n         format!(\"{:#?}\", tree).trim(),\n         r#\"\n@@ -469,7 +442,7 @@ fn test_expand_literals_to_token_tree() {\n         unreachable!(\"It is not a literal\");\n     }\n \n-    let rules = create_rules(\n+    let expansion = parse_macro(\n         r#\"\n             macro_rules! literals {\n                 ($i:ident) => {\n@@ -482,8 +455,8 @@ fn test_expand_literals_to_token_tree() {\n                 }\n             }\n             \"#,\n-    );\n-    let expansion = expand(&rules, \"literals!(foo);\");\n+    )\n+    .expand_tt(\"literals!(foo);\");\n     let stm_tokens = &to_subtree(&expansion.token_trees[0]).token_trees;\n \n     // [let] [a] [=] ['c'] [;]\n@@ -498,26 +471,21 @@ fn test_expand_literals_to_token_tree() {\n \n #[test]\n fn test_two_idents() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             ($ i:ident, $ j:ident) => {\n                 fn foo() { let a = $ i; let b = $j; }\n             }\n         }\n \"#,\n-    );\n-    assert_expansion(\n-        MacroKind::Items,\n-        &rules,\n-        \"foo! { foo, bar }\",\n-        \"fn foo () {let a = foo ; let b = bar ;}\",\n-    );\n+    )\n+    .assert_expand_items(\"foo! { foo, bar }\", \"fn foo () {let a = foo ; let b = bar ;}\");\n }\n \n #[test]\n fn test_tt_to_stmts() {\n-    let rules = create_rules(\n+    let stmts = parse_macro(\n         r#\"\n         macro_rules! foo {\n             () => {\n@@ -527,11 +495,8 @@ fn test_tt_to_stmts() {\n             }\n         }\n \"#,\n-    );\n-\n-    let expanded = expand(&rules, \"foo!{}\");\n-    let stmts =\n-        token_tree_to_syntax_node(&expanded, FragmentKind::Statements).unwrap().0.syntax_node();\n+    )\n+    .expand_statements(\"foo!{}\");\n \n     assert_eq!(\n         format!(\"{:#?}\", stmts).trim(),\n@@ -571,97 +536,87 @@ fn test_tt_to_stmts() {\n \n #[test]\n fn test_match_literal() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n     macro_rules! foo {\n         ('(') => {\n             fn foo() {}\n         }\n     }\n \"#,\n-    );\n-    assert_expansion(MacroKind::Items, &rules, \"foo! ['('];\", \"fn foo () {}\");\n+    )\n+    .assert_expand_items(\"foo! ['('];\", \"fn foo () {}\");\n }\n \n // The following tests are port from intellij-rust directly\n // https://github.com/intellij-rust/intellij-rust/blob/c4e9feee4ad46e7953b1948c112533360b6087bb/src/test/kotlin/org/rust/lang/core/macros/RsMacroExpansionTest.kt\n \n #[test]\n fn test_path() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             ($ i:path) => {\n                 fn foo() { let a = $ i; }\n             }\n         }\n \"#,\n-    );\n-    assert_expansion(MacroKind::Items, &rules, \"foo! { foo }\", \"fn foo () {let a = foo ;}\");\n-    assert_expansion(\n-        MacroKind::Items,\n-        &rules,\n+    )\n+    .assert_expand_items(\"foo! { foo }\", \"fn foo () {let a = foo ;}\")\n+    .assert_expand_items(\n         \"foo! { bar::<u8>::baz::<u8> }\",\n         \"fn foo () {let a = bar ::< u8 >:: baz ::< u8 > ;}\",\n     );\n }\n \n #[test]\n fn test_two_paths() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             ($ i:path, $ j:path) => {\n                 fn foo() { let a = $ i; let b = $j; }\n             }\n         }\n \"#,\n-    );\n-    assert_expansion(\n-        MacroKind::Items,\n-        &rules,\n-        \"foo! { foo, bar }\",\n-        \"fn foo () {let a = foo ; let b = bar ;}\",\n-    );\n+    )\n+    .assert_expand_items(\"foo! { foo, bar }\", \"fn foo () {let a = foo ; let b = bar ;}\");\n }\n \n #[test]\n fn test_path_with_path() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             ($ i:path) => {\n                 fn foo() { let a = $ i :: bar; }\n             }\n         }\n \"#,\n-    );\n-    assert_expansion(MacroKind::Items, &rules, \"foo! { foo }\", \"fn foo () {let a = foo :: bar ;}\");\n+    )\n+    .assert_expand_items(\"foo! { foo }\", \"fn foo () {let a = foo :: bar ;}\");\n }\n \n #[test]\n fn test_expr() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             ($ i:expr) => {\n                  fn bar() { $ i; }\n             }\n         }\n \"#,\n-    );\n-\n-    assert_expansion(\n-        MacroKind::Items,\n-        &rules,\n+    )\n+    .assert_expand_items(\n         \"foo! { 2 + 2 * baz(3).quux() }\",\n         \"fn bar () {2 + 2 * baz (3) . quux () ;}\",\n     );\n }\n \n #[test]\n fn test_last_expr() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! vec {\n             ($($item:expr),*) => {\n@@ -675,118 +630,103 @@ fn test_last_expr() {\n             };\n         }\n \"#,\n-    );\n-    assert_expansion(\n-        MacroKind::Items,\n-        &rules,\n+    )\n+    .assert_expand_items(\n         \"vec!(1,2,3);\",\n         \"{let mut v = Vec :: new () ; v . push (1) ; v . push (2) ; v . push (3) ; v}\",\n     );\n }\n \n #[test]\n fn test_ty() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             ($ i:ty) => (\n                 fn bar() -> $ i { unimplemented!() }\n             )\n         }\n \"#,\n-    );\n-    assert_expansion(\n-        MacroKind::Items,\n-        &rules,\n-        \"foo! { Baz<u8> }\",\n-        \"fn bar () -> Baz < u8 > {unimplemented ! ()}\",\n-    );\n+    )\n+    .assert_expand_items(\"foo! { Baz<u8> }\", \"fn bar () -> Baz < u8 > {unimplemented ! ()}\");\n }\n \n #[test]\n fn test_ty_with_complex_type() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             ($ i:ty) => (\n                 fn bar() -> $ i { unimplemented!() }\n             )\n         }\n \"#,\n-    );\n-\n+    )\n     // Reference lifetime struct with generic type\n-    assert_expansion(\n-        MacroKind::Items,\n-        &rules,\n+    .assert_expand_items(\n         \"foo! { &'a Baz<u8> }\",\n         \"fn bar () -> & 'a Baz < u8 > {unimplemented ! ()}\",\n-    );\n-\n+    )\n     // extern \"Rust\" func type\n-    assert_expansion(\n-        MacroKind::Items,\n-        &rules,\n+    .assert_expand_items(\n         r#\"foo! { extern \"Rust\" fn() -> Ret }\"#,\n         r#\"fn bar () -> extern \"Rust\" fn () -> Ret {unimplemented ! ()}\"#,\n     );\n }\n \n #[test]\n fn test_pat_() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             ($ i:pat) => { fn foo() { let $ i; } }\n         }\n \"#,\n-    );\n-    assert_expansion(MacroKind::Items, &rules, \"foo! { (a, b) }\", \"fn foo () {let (a , b) ;}\");\n+    )\n+    .assert_expand_items(\"foo! { (a, b) }\", \"fn foo () {let (a , b) ;}\");\n }\n \n #[test]\n fn test_stmt() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             ($ i:stmt) => (\n                 fn bar() { $ i; }\n             )\n         }\n \"#,\n-    );\n-    assert_expansion(MacroKind::Items, &rules, \"foo! { 2 }\", \"fn bar () {2 ;}\");\n-    assert_expansion(MacroKind::Items, &rules, \"foo! { let a = 0 }\", \"fn bar () {let a = 0 ;}\");\n+    )\n+    .assert_expand_items(\"foo! { 2 }\", \"fn bar () {2 ;}\")\n+    .assert_expand_items(\"foo! { let a = 0 }\", \"fn bar () {let a = 0 ;}\");\n }\n \n #[test]\n fn test_single_item() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             ($ i:item) => (\n                 $ i\n             )\n         }\n \"#,\n-    );\n-    assert_expansion(MacroKind::Items, &rules, \"foo! {mod c {}}\", \"mod c {}\");\n+    )\n+    .assert_expand_items(\"foo! {mod c {}}\", \"mod c {}\");\n }\n \n #[test]\n fn test_all_items() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             ($ ($ i:item)*) => ($ (\n                 $ i\n             )*)\n         }\n \"#,\n-    );\n-    assert_expansion(\n-        MacroKind::Items,\n-        &rules,\n+    ).\n+    assert_expand_items(\n         r#\"\n         foo! {\n             extern crate a;\n@@ -810,19 +750,19 @@ fn test_all_items() {\n \n #[test]\n fn test_block() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             ($ i:block) => { fn foo() $ i }\n         }\n \"#,\n-    );\n-    assert_expansion(MacroKind::Stmts, &rules, \"foo! { { 1; } }\", \"fn foo () {1 ;}\");\n+    )\n+    .assert_expand_statements(\"foo! { { 1; } }\", \"fn foo () {1 ;}\");\n }\n \n #[test]\n fn test_meta() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             ($ i:meta) => (\n@@ -831,18 +771,16 @@ fn test_meta() {\n             )\n         }\n \"#,\n-    );\n-    assert_expansion(\n-        MacroKind::Items,\n-        &rules,\n+    )\n+    .assert_expand_items(\n         r#\"foo! { cfg(target_os = \"windows\") }\"#,\n         r#\"# [cfg (target_os = \"windows\")] fn bar () {}\"#,\n     );\n }\n \n #[test]\n fn test_meta_doc_comments() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n             ($(#[$ i:meta])+) => (\n@@ -851,10 +789,8 @@ fn test_meta_doc_comments() {\n             )\n         }\n \"#,\n-    );\n-    assert_expansion(\n-        MacroKind::Items,\n-        &rules,\n+    ).\n+    assert_expand_items(\n         r#\"foo! {\n             /// Single Line Doc 1\n             /**\n@@ -867,69 +803,68 @@ fn test_meta_doc_comments() {\n \n #[test]\n fn test_tt_block() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n             macro_rules! foo {\n                 ($ i:tt) => { fn foo() $ i }\n             }\n     \"#,\n-    );\n-    assert_expansion(MacroKind::Items, &rules, r#\"foo! { { 1; } }\"#, r#\"fn foo () {1 ;}\"#);\n+    )\n+    .assert_expand_items(r#\"foo! { { 1; } }\"#, r#\"fn foo () {1 ;}\"#);\n }\n \n #[test]\n fn test_tt_group() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n             macro_rules! foo {\n                  ($($ i:tt)*) => { $($ i)* }\n             }\n     \"#,\n-    );\n-    assert_expansion(MacroKind::Items, &rules, r#\"foo! { fn foo() {} }\"#, r#\"fn foo () {}\"#);\n+    )\n+    .assert_expand_items(r#\"foo! { fn foo() {} }\"#, r#\"fn foo () {}\"#);\n }\n #[test]\n fn test_lifetime() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n               ($ lt:lifetime) => { struct Ref<$ lt>{ s: &$ lt str } }\n         }\n \"#,\n-    );\n-    assert_expansion(MacroKind::Items, &rules, r#\"foo!{'a}\"#, r#\"struct Ref <'a > {s : &'a str}\"#);\n+    )\n+    .assert_expand_items(r#\"foo!{'a}\"#, r#\"struct Ref <'a > {s : &'a str}\"#);\n }\n \n #[test]\n fn test_literal() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n               ($ type:ty $ lit:literal) => { const VALUE: $ type = $ lit;};\n         }\n \"#,\n-    );\n-    assert_expansion(MacroKind::Items, &rules, r#\"foo!(u8 0);\"#, r#\"const VALUE : u8 = 0 ;\"#);\n+    )\n+    .assert_expand_items(r#\"foo!(u8 0);\"#, r#\"const VALUE : u8 = 0 ;\"#);\n }\n \n #[test]\n fn test_vis() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! foo {\n               ($ vis:vis $ name:ident) => { $ vis fn $ name() {}};\n         }\n \"#,\n-    );\n-    assert_expansion(MacroKind::Items, &rules, r#\"foo!(pub foo);\"#, r#\"pub fn foo () {}\"#);\n-\n-    // test optional casse\n-    assert_expansion(MacroKind::Items, &rules, r#\"foo!(foo);\"#, r#\"fn foo () {}\"#);\n+    )\n+    .assert_expand_items(r#\"foo!(pub foo);\"#, r#\"pub fn foo () {}\"#)\n+    // test optional cases\n+    .assert_expand_items(r#\"foo!(foo);\"#, r#\"fn foo () {}\"#);\n }\n \n #[test]\n fn test_inner_macro_rules() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n macro_rules! foo {\n     ($a:ident, $b:ident, $c:tt) => {\n@@ -945,10 +880,8 @@ macro_rules! foo {\n     }\n }\n \"#,\n-    );\n-    assert_expansion(\n-        MacroKind::Items,\n-        &rules,\n+    ).\n+    assert_expand_items(\n         r#\"foo!(x,y, 1);\"#,\n         r#\"macro_rules ! bar {($ bi : ident) => {fn $ bi () -> u8 {1}}} bar ! (x) ; fn y () -> u8 {1}\"#,\n     );\n@@ -957,7 +890,7 @@ macro_rules! foo {\n // The following tests are based on real world situations\n #[test]\n fn test_vec() {\n-    let rules = create_rules(\n+    let fixture = parse_macro(\n         r#\"\n          macro_rules! vec {\n             ($($item:expr),*) => {\n@@ -972,16 +905,14 @@ fn test_vec() {\n }\n \"#,\n     );\n-    assert_expansion(MacroKind::Items, &rules, r#\"vec!();\"#, r#\"{let mut v = Vec :: new () ; v}\"#);\n-    assert_expansion(\n-        MacroKind::Items,\n-        &rules,\n-        r#\"vec![1u32,2];\"#,\n-        r#\"{let mut v = Vec :: new () ; v . push (1u32) ; v . push (2) ; v}\"#,\n-    );\n+    fixture\n+        .assert_expand_items(r#\"vec!();\"#, r#\"{let mut v = Vec :: new () ; v}\"#)\n+        .assert_expand_items(\n+            r#\"vec![1u32,2];\"#,\n+            r#\"{let mut v = Vec :: new () ; v . push (1u32) ; v . push (2) ; v}\"#,\n+        );\n \n-    let expansion = expand(&rules, r#\"vec![1u32,2];\"#);\n-    let tree = token_tree_to_syntax_node(&expansion, FragmentKind::Expr).unwrap().0.syntax_node();\n+    let tree = fixture.expand_expr(r#\"vec![1u32,2];\"#);\n \n     assert_eq!(\n         format!(\"{:#?}\", tree).trim(),\n@@ -1055,7 +986,7 @@ fn test_vec() {\n fn test_winapi_struct() {\n     // from https://github.com/retep998/winapi-rs/blob/a7ef2bca086aae76cf6c4ce4c2552988ed9798ad/src/macros.rs#L366\n \n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n macro_rules! STRUCT {\n     ($(#[$attrs:meta])* struct $name:ident {\n@@ -1077,17 +1008,19 @@ macro_rules! STRUCT {\n     );\n }\n \"#,\n-    );\n+    ).\n     // from https://github.com/retep998/winapi-rs/blob/a7ef2bca086aae76cf6c4ce4c2552988ed9798ad/src/shared/d3d9caps.rs\n-    assert_expansion(MacroKind::Items, &rules, r#\"STRUCT!{struct D3DVSHADERCAPS2_0 {Caps: u8,}}\"#,\n-        \"# [repr (C)] # [derive (Copy)] pub struct D3DVSHADERCAPS2_0 {pub Caps : u8 ,} impl Clone for D3DVSHADERCAPS2_0 {# [inline] fn clone (& self) -> D3DVSHADERCAPS2_0 {* self}} # [cfg (feature = \\\"impl-default\\\")] impl Default for D3DVSHADERCAPS2_0 {# [inline] fn default () -> D3DVSHADERCAPS2_0 {unsafe {$crate :: _core :: mem :: zeroed ()}}}\");\n-    assert_expansion(MacroKind::Items, &rules, r#\"STRUCT!{#[cfg_attr(target_arch = \"x86\", repr(packed))] struct D3DCONTENTPROTECTIONCAPS {Caps : u8 ,}}\"#,\n-        \"# [repr (C)] # [derive (Copy)] # [cfg_attr (target_arch = \\\"x86\\\" , repr (packed))] pub struct D3DCONTENTPROTECTIONCAPS {pub Caps : u8 ,} impl Clone for D3DCONTENTPROTECTIONCAPS {# [inline] fn clone (& self) -> D3DCONTENTPROTECTIONCAPS {* self}} # [cfg (feature = \\\"impl-default\\\")] impl Default for D3DCONTENTPROTECTIONCAPS {# [inline] fn default () -> D3DCONTENTPROTECTIONCAPS {unsafe {$crate :: _core :: mem :: zeroed ()}}}\");\n+    assert_expand_items(r#\"STRUCT!{struct D3DVSHADERCAPS2_0 {Caps: u8,}}\"#,\n+        \"# [repr (C)] # [derive (Copy)] pub struct D3DVSHADERCAPS2_0 {pub Caps : u8 ,} impl Clone for D3DVSHADERCAPS2_0 {# [inline] fn clone (& self) -> D3DVSHADERCAPS2_0 {* self}} # [cfg (feature = \\\"impl-default\\\")] impl Default for D3DVSHADERCAPS2_0 {# [inline] fn default () -> D3DVSHADERCAPS2_0 {unsafe {$crate :: _core :: mem :: zeroed ()}}}\"\n+    )\n+    .assert_expand_items(r#\"STRUCT!{#[cfg_attr(target_arch = \"x86\", repr(packed))] struct D3DCONTENTPROTECTIONCAPS {Caps : u8 ,}}\"#,\n+        \"# [repr (C)] # [derive (Copy)] # [cfg_attr (target_arch = \\\"x86\\\" , repr (packed))] pub struct D3DCONTENTPROTECTIONCAPS {pub Caps : u8 ,} impl Clone for D3DCONTENTPROTECTIONCAPS {# [inline] fn clone (& self) -> D3DCONTENTPROTECTIONCAPS {* self}} # [cfg (feature = \\\"impl-default\\\")] impl Default for D3DCONTENTPROTECTIONCAPS {# [inline] fn default () -> D3DCONTENTPROTECTIONCAPS {unsafe {$crate :: _core :: mem :: zeroed ()}}}\"\n+    );\n }\n \n #[test]\n fn test_int_base() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n macro_rules! int_base {\n     ($Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n@@ -1100,17 +1033,15 @@ macro_rules! int_base {\n     }\n }\n \"#,\n-    );\n-\n-    assert_expansion(MacroKind::Items, &rules, r#\" int_base!{Binary for isize as usize -> Binary}\"#,\n+    ).assert_expand_items(r#\" int_base!{Binary for isize as usize -> Binary}\"#,\n         \"# [stable (feature = \\\"rust1\\\" , since = \\\"1.0.0\\\")] impl fmt ::Binary for isize {fn fmt (& self , f : & mut fmt :: Formatter < \\'_ >) -> fmt :: Result {Binary . fmt_int (* self as usize , f)}}\"\n-        );\n+    );\n }\n \n #[test]\n fn test_generate_pattern_iterators() {\n     // from https://github.com/rust-lang/rust/blob/316a391dcb7d66dc25f1f9a4ec9d368ef7615005/src/libcore/str/mod.rs\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n macro_rules! generate_pattern_iterators {\n         { double ended; with $(#[$common_stability_attribute:meta])*,\n@@ -1121,11 +1052,7 @@ macro_rules! generate_pattern_iterators {\n         }\n }\n \"#,\n-    );\n-\n-    assert_expansion(\n-        MacroKind::Items,\n-        &rules,\n+    ).assert_expand_items(\n         r#\"generate_pattern_iterators ! ( double ended ; with # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] , Split , RSplit , & 'a str );\"#,\n         \"fn foo () {}\",\n     );\n@@ -1134,7 +1061,7 @@ macro_rules! generate_pattern_iterators {\n #[test]\n fn test_impl_fn_for_zst() {\n     // from https://github.com/rust-lang/rust/blob/5d20ff4d2718c820632b38c1e49d4de648a9810b/src/libcore/internal_macros.rs\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n macro_rules! impl_fn_for_zst  {\n         {  $( $( #[$attr: meta] )*\n@@ -1175,9 +1102,7 @@ $body: block; )+\n }\n         }\n \"#,\n-    );\n-\n-    assert_expansion(MacroKind::Items, &rules, r#\"\n+    ).assert_expand_items(r#\"\n impl_fn_for_zst !   {\n      # [ derive ( Clone ) ]\n      struct   CharEscapeDebugContinue   impl   Fn   =   | c :   char |   ->   char :: EscapeDebug   {\n@@ -1194,25 +1119,22 @@ impl_fn_for_zst !   {\n      } ;\n  }\n \"#,\n-        \"# [derive (Clone)] struct CharEscapeDebugContinue ; impl Fn < (char ,) > for CharEscapeDebugContinue {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeDebug {{c . escape_debug_ext (false)}}} impl FnMut < (char ,) > for CharEscapeDebugContinue {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeDebug {Fn :: call (&* self , (c ,))}} impl FnOnce < (char ,) > for CharEscapeDebugContinue {type Output = char :: EscapeDebug ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeDebug {Fn :: call (& self , (c ,))}} # [derive (Clone)] struct CharEscapeUnicode ; impl Fn < (char ,) > for CharEscapeUnicode {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeUnicode {{c . escape_unicode ()}}} impl FnMut < (char ,) > for CharEscapeUnicode {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeUnicode {Fn :: call (&* self , (c ,))}} impl FnOnce < (char ,) > for CharEscapeUnicode {type Output = char :: EscapeUnicode ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeUnicode {Fn :: call (& self , (c ,))}} # [derive (Clone)] struct CharEscapeDefault ; impl Fn < (char ,) > for CharEscapeDefault {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeDefault {{c . escape_default ()}}} impl FnMut < (char ,) > for CharEscapeDefault {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeDefault {Fn :: call (&* self , (c ,))}} impl FnOnce < (char ,) > for CharEscapeDefault {type Output = char :: EscapeDefault ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeDefault {Fn :: call (& self , (c ,))}}\");\n+        \"# [derive (Clone)] struct CharEscapeDebugContinue ; impl Fn < (char ,) > for CharEscapeDebugContinue {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeDebug {{c . escape_debug_ext (false)}}} impl FnMut < (char ,) > for CharEscapeDebugContinue {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeDebug {Fn :: call (&* self , (c ,))}} impl FnOnce < (char ,) > for CharEscapeDebugContinue {type Output = char :: EscapeDebug ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeDebug {Fn :: call (& self , (c ,))}} # [derive (Clone)] struct CharEscapeUnicode ; impl Fn < (char ,) > for CharEscapeUnicode {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeUnicode {{c . escape_unicode ()}}} impl FnMut < (char ,) > for CharEscapeUnicode {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeUnicode {Fn :: call (&* self , (c ,))}} impl FnOnce < (char ,) > for CharEscapeUnicode {type Output = char :: EscapeUnicode ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeUnicode {Fn :: call (& self , (c ,))}} # [derive (Clone)] struct CharEscapeDefault ; impl Fn < (char ,) > for CharEscapeDefault {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeDefault {{c . escape_default ()}}} impl FnMut < (char ,) > for CharEscapeDefault {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeDefault {Fn :: call (&* self , (c ,))}} impl FnOnce < (char ,) > for CharEscapeDefault {type Output = char :: EscapeDefault ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeDefault {Fn :: call (& self , (c ,))}}\"\n+    );\n }\n \n #[test]\n fn test_impl_nonzero_fmt() {\n     // from https://github.com/rust-lang/rust/blob/316a391dcb7d66dc25f1f9a4ec9d368ef7615005/src/libcore/num/mod.rs#L12\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! impl_nonzero_fmt {\n             ( #[$stability: meta] ( $( $Trait: ident ),+ ) for $Ty: ident ) => {\n                 fn foo () {}\n             }\n         }\n \"#,\n-    );\n-\n-    assert_expansion(\n-        MacroKind::Items,\n-        &rules,\n+    ).assert_expand_items(\n         r#\"impl_nonzero_fmt! { # [stable(feature= \"nonzero\",since=\"1.28.0\")] (Debug,Display,Binary,Octal,LowerHex,UpperHex) for NonZeroU8}\"#,\n         \"fn foo () {}\",\n     );\n@@ -1221,7 +1143,7 @@ fn test_impl_nonzero_fmt() {\n #[test]\n fn test_cfg_if_items() {\n     // from https://github.com/rust-lang/rust/blob/33fe1131cadba69d317156847be9a402b89f11bb/src/libstd/macros.rs#L986\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! __cfg_if_items {\n             (($($not:meta,)*) ; ) => {};\n@@ -1230,11 +1152,7 @@ fn test_cfg_if_items() {\n             }\n         }\n \"#,\n-    );\n-\n-    assert_expansion(\n-        MacroKind::Items,\n-        &rules,\n+    ).assert_expand_items(\n         r#\"__cfg_if_items ! { ( rustdoc , ) ; ( ( ) ( # [ cfg ( any ( target_os = \"redox\" , unix ) ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as unix ; # [ cfg ( windows ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as windows ; # [ cfg ( any ( target_os = \"linux\" , target_os = \"l4re\" ) ) ] pub mod linux ; ) ) , }\"#,\n         \"__cfg_if_items ! {(rustdoc ,) ;}\",\n     );\n@@ -1243,7 +1161,7 @@ fn test_cfg_if_items() {\n #[test]\n fn test_cfg_if_main() {\n     // from https://github.com/rust-lang/rust/blob/3d211248393686e0f73851fc7548f6605220fbe1/src/libpanic_unwind/macros.rs#L9\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n         macro_rules! cfg_if {\n             ($(\n@@ -1264,9 +1182,7 @@ fn test_cfg_if_main() {\n             };\n         }\n \"#,\n-    );\n-\n-    assert_expansion(MacroKind::Items, &rules, r#\"\n+    ).assert_expand_items(r#\"\n cfg_if !   {\n      if   # [ cfg ( target_env   =   \"msvc\" ) ]   {\n          // no extra unwinder support needed\n@@ -1278,11 +1194,8 @@ cfg_if !   {\n      }\n  }\n \"#,\n-        \"__cfg_if_items ! {() ; ((target_env = \\\"msvc\\\") ()) , ((all (target_arch = \\\"wasm32\\\" , not (target_os = \\\"emscripten\\\"))) ()) , (() (mod libunwind ; pub use libunwind :: * ;)) ,}\");\n-\n-    assert_expansion(\n-        MacroKind::Items,\n-        &rules,\n+        \"__cfg_if_items ! {() ; ((target_env = \\\"msvc\\\") ()) , ((all (target_arch = \\\"wasm32\\\" , not (target_os = \\\"emscripten\\\"))) ()) , (() (mod libunwind ; pub use libunwind :: * ;)) ,}\"\n+    ).assert_expand_items(\n         r#\"\n cfg_if ! { @ __apply cfg ( all ( not ( any ( not ( any ( target_os = \"solaris\" , target_os = \"illumos\" ) ) ) ) ) ) , }\n \"#,\n@@ -1293,7 +1206,7 @@ cfg_if ! { @ __apply cfg ( all ( not ( any ( not ( any ( target_os = \"solaris\" ,\n #[test]\n fn test_proptest_arbitrary() {\n     // from https://github.com/AltSysrq/proptest/blob/d1c4b049337d2f75dd6f49a095115f7c532e5129/proptest/src/arbitrary/macros.rs#L16\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n macro_rules! arbitrary {\n     ([$($bounds : tt)*] $typ: ty, $strat: ty, $params: ty;\n@@ -1308,22 +1221,21 @@ macro_rules! arbitrary {\n     };\n \n }\"#,\n-    );\n-\n-    assert_expansion(MacroKind::Items, &rules, r#\"arbitrary !   ( [ A : Arbitrary ]\n+    ).assert_expand_items(r#\"arbitrary !   ( [ A : Arbitrary ]\n         Vec < A > ,\n         VecStrategy < A :: Strategy > ,\n         RangedParams1 < A :: Parameters > ;\n         args =>   { let product_unpack !   [ range , a ] = args ; vec ( any_with :: < A >   ( a ) , range ) }\n     ) ;\"#,\n-    \"impl <A : Arbitrary > $crate :: arbitrary :: Arbitrary for Vec < A > {type Parameters = RangedParams1 < A :: Parameters > ; type Strategy = VecStrategy < A :: Strategy > ; fn arbitrary_with (args : Self :: Parameters) -> Self :: Strategy {{let product_unpack ! [range , a] = args ; vec (any_with :: < A > (a) , range)}}}\");\n+    \"impl <A : Arbitrary > $crate :: arbitrary :: Arbitrary for Vec < A > {type Parameters = RangedParams1 < A :: Parameters > ; type Strategy = VecStrategy < A :: Strategy > ; fn arbitrary_with (args : Self :: Parameters) -> Self :: Strategy {{let product_unpack ! [range , a] = args ; vec (any_with :: < A > (a) , range)}}}\"\n+    );\n }\n \n #[test]\n fn test_old_ridl() {\n     // This is from winapi 2.8, which do not have a link from github\n     //\n-    let rules = create_rules(\n+    let expanded = parse_macro(\n         r#\"\n #[macro_export]\n macro_rules! RIDL {\n@@ -1339,21 +1251,17 @@ macro_rules! RIDL {\n         }\n     };\n }\"#,\n-    );\n+    ).expand_tt(r#\"\n+    RIDL!{interface ID3D11Asynchronous(ID3D11AsynchronousVtbl): ID3D11DeviceChild(ID3D11DeviceChildVtbl) {\n+        fn GetDataSize(&mut self) -> UINT\n+    }}\"#);\n \n-    let expanded = expand(\n-        &rules,\n-        r#\"\n-RIDL!{interface ID3D11Asynchronous(ID3D11AsynchronousVtbl): ID3D11DeviceChild(ID3D11DeviceChildVtbl) {\n-    fn GetDataSize(&mut self) -> UINT\n-}}\"#,\n-    );\n     assert_eq!(expanded.to_string(), \"impl ID3D11Asynchronous {pub unsafe fn GetDataSize (& mut self) -> UINT {((* self . lpVtbl) .GetDataSize) (self)}}\");\n }\n \n #[test]\n fn test_quick_error() {\n-    let rules = create_rules(\n+    let expanded = parse_macro(\n         r#\"\n macro_rules! quick_error {\n \n@@ -1376,10 +1284,8 @@ macro_rules! quick_error {\n \n }\n \"#,\n-    );\n-\n-    let expanded = expand(\n-        &rules,\n+    )\n+    .expand_tt(\n         r#\"\n quick_error ! (SORT [enum Wrapped # [derive (Debug)]] items [\n         => One : UNIT [] {}\n@@ -1393,7 +1299,7 @@ quick_error ! (SORT [enum Wrapped # [derive (Debug)]] items [\n \n #[test]\n fn test_empty_repeat_vars_in_empty_repeat_vars() {\n-    let rules = create_rules(\n+    parse_macro(\n         r#\"\n macro_rules! delegate_impl {\n     ([$self_type:ident, $self_wrap:ty, $self_map:ident]\n@@ -1440,138 +1346,117 @@ macro_rules! delegate_impl {\n     }\n }\n \"#,\n-    );\n-\n-    assert_expansion(\n-        MacroKind::Items,\n-        &rules,\n+    ).assert_expand_items(\n         r#\"delegate_impl ! {[G , & 'a mut G , deref] pub trait Data : GraphBase {@ section type type NodeWeight ;}}\"#,\n         \"impl <> Data for & \\'a mut G where G : Data {}\",\n     );\n }\n \n #[test]\n fn expr_interpolation() {\n-    let rules = create_rules(\n+    let expanded = parse_macro(\n         r#\"\n         macro_rules! id {\n             ($expr:expr) => {\n                 map($expr)\n             }\n         }\n         \"#,\n-    );\n+    )\n+    .expand_expr(\"id!(x + foo);\");\n \n-    let expanded = expand(&rules, \"id!(x + foo);\");\n-    let expanded =\n-        token_tree_to_syntax_node(&expanded, FragmentKind::Expr).unwrap().0.syntax_node();\n     assert_eq!(expanded.to_string(), \"map(x+foo)\");\n }\n \n-pub(crate) fn create_rules(macro_definition: &str) -> MacroRules {\n-    let source_file = ast::SourceFile::parse(macro_definition).ok().unwrap();\n-    let macro_definition =\n-        source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n-\n-    let (definition_tt, _) = ast_to_token_tree(&macro_definition.token_tree().unwrap()).unwrap();\n-    crate::MacroRules::parse(&definition_tt).unwrap()\n+pub(crate) struct MacroFixture {\n+    rules: MacroRules,\n }\n \n-pub(crate) fn expand(rules: &MacroRules, invocation: &str) -> tt::Subtree {\n-    let source_file = ast::SourceFile::parse(invocation).ok().unwrap();\n-    let macro_invocation =\n-        source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n-\n-    let (invocation_tt, _) = ast_to_token_tree(&macro_invocation.token_tree().unwrap()).unwrap();\n+impl MacroFixture {\n+    pub(crate) fn expand_tt(&self, invocation: &str) -> tt::Subtree {\n+        let source_file = ast::SourceFile::parse(invocation).ok().unwrap();\n+        let macro_invocation =\n+            source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n \n-    rules.expand(&invocation_tt).unwrap()\n-}\n+        let (invocation_tt, _) =\n+            ast_to_token_tree(&macro_invocation.token_tree().unwrap()).unwrap();\n \n-pub(crate) fn expand_and_map(\n-    rules: &MacroRules,\n-    invocation: &str,\n-) -> (tt::Subtree, (TokenMap, String)) {\n-    let source_file = ast::SourceFile::parse(invocation).ok().unwrap();\n-    let macro_invocation =\n-        source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n+        self.rules.expand(&invocation_tt).unwrap()\n+    }\n \n-    let (invocation_tt, _) = ast_to_token_tree(&macro_invocation.token_tree().unwrap()).unwrap();\n-    let expanded = rules.expand(&invocation_tt).unwrap();\n+    fn expand_items(&self, invocation: &str) -> SyntaxNode {\n+        let expanded = self.expand_tt(invocation);\n+        token_tree_to_syntax_node(&expanded, FragmentKind::Items).unwrap().0.syntax_node()\n+    }\n \n-    let (node, expanded_token_tree) =\n-        token_tree_to_syntax_node(&expanded, FragmentKind::Items).unwrap();\n+    fn expand_statements(&self, invocation: &str) -> SyntaxNode {\n+        let expanded = self.expand_tt(invocation);\n+        token_tree_to_syntax_node(&expanded, FragmentKind::Statements).unwrap().0.syntax_node()\n+    }\n \n-    (expanded, (expanded_token_tree, node.syntax_node().to_string()))\n-}\n+    fn expand_expr(&self, invocation: &str) -> SyntaxNode {\n+        let expanded = self.expand_tt(invocation);\n+        token_tree_to_syntax_node(&expanded, FragmentKind::Expr).unwrap().0.syntax_node()\n+    }\n \n-pub(crate) enum MacroKind {\n-    Items,\n-    Stmts,\n-}\n+    fn assert_expand_tt(&self, invocation: &str, expected: &str) {\n+        let expansion = self.expand_tt(invocation);\n+        assert_eq!(expansion.to_string(), expected);\n+    }\n \n-pub(crate) fn assert_expansion(\n-    kind: MacroKind,\n-    rules: &MacroRules,\n-    invocation: &str,\n-    expected: &str,\n-) -> tt::Subtree {\n-    let expanded = expand(rules, invocation);\n-    assert_eq!(expanded.to_string(), expected);\n+    fn assert_expand_items(&self, invocation: &str, expected: &str) -> &MacroFixture {\n+        self.assert_expansion(FragmentKind::Items, invocation, expected);\n+        self\n+    }\n \n-    let expected = expected.replace(\"$crate\", \"C_C__C\");\n+    fn assert_expand_statements(&self, invocation: &str, expected: &str) -> &MacroFixture {\n+        self.assert_expansion(FragmentKind::Statements, invocation, expected);\n+        self\n+    }\n \n-    // wrap the given text to a macro call\n-    let expected = {\n-        let wrapped = format!(\"wrap_macro!( {} )\", expected);\n-        let wrapped = ast::SourceFile::parse(&wrapped);\n-        let wrapped = wrapped.tree().syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n-        let mut wrapped = ast_to_token_tree(&wrapped).unwrap().0;\n-        wrapped.delimiter = None;\n-        wrapped\n-    };\n-    let (expanded_tree, expected_tree) = match kind {\n-        MacroKind::Items => {\n-            let expanded_tree =\n-                token_tree_to_syntax_node(&expanded, FragmentKind::Items).unwrap().0.syntax_node();\n-            let expected_tree =\n-                token_tree_to_syntax_node(&expected, FragmentKind::Items).unwrap().0.syntax_node();\n-\n-            (\n-                debug_dump_ignore_spaces(&expanded_tree).trim().to_string(),\n-                debug_dump_ignore_spaces(&expected_tree).trim().to_string(),\n-            )\n-        }\n+    fn assert_expansion(&self, kind: FragmentKind, invocation: &str, expected: &str) {\n+        let expanded = self.expand_tt(invocation);\n+        assert_eq!(expanded.to_string(), expected);\n+\n+        let expected = expected.replace(\"$crate\", \"C_C__C\");\n+\n+        // wrap the given text to a macro call\n+        let expected = {\n+            let wrapped = format!(\"wrap_macro!( {} )\", expected);\n+            let wrapped = ast::SourceFile::parse(&wrapped);\n+            let wrapped =\n+                wrapped.tree().syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+            let mut wrapped = ast_to_token_tree(&wrapped).unwrap().0;\n+            wrapped.delimiter = None;\n+            wrapped\n+        };\n \n-        MacroKind::Stmts => {\n-            let expanded_tree = token_tree_to_syntax_node(&expanded, FragmentKind::Statements)\n-                .unwrap()\n-                .0\n-                .syntax_node();\n-            let expected_tree = token_tree_to_syntax_node(&expected, FragmentKind::Statements)\n-                .unwrap()\n-                .0\n-                .syntax_node();\n-\n-            (\n-                debug_dump_ignore_spaces(&expanded_tree).trim().to_string(),\n-                debug_dump_ignore_spaces(&expected_tree).trim().to_string(),\n-            )\n-        }\n-    };\n+        let expanded_tree = token_tree_to_syntax_node(&expanded, kind).unwrap().0.syntax_node();\n+        let expanded_tree = debug_dump_ignore_spaces(&expanded_tree).trim().to_string();\n \n-    let expected_tree = expected_tree.replace(\"C_C__C\", \"$crate\");\n-    assert_eq!(\n-        expanded_tree, expected_tree,\n-        \"\\nleft:\\n{}\\nright:\\n{}\",\n-        expanded_tree, expected_tree,\n-    );\n+        let expected_tree = token_tree_to_syntax_node(&expected, kind).unwrap().0.syntax_node();\n+        let expected_tree = debug_dump_ignore_spaces(&expected_tree).trim().to_string();\n \n-    expanded\n+        let expected_tree = expected_tree.replace(\"C_C__C\", \"$crate\");\n+        assert_eq!(\n+            expanded_tree, expected_tree,\n+            \"\\nleft:\\n{}\\nright:\\n{}\",\n+            expanded_tree, expected_tree,\n+        );\n+    }\n }\n \n-pub fn debug_dump_ignore_spaces(node: &ra_syntax::SyntaxNode) -> String {\n-    use std::fmt::Write;\n+pub(crate) fn parse_macro(macro_definition: &str) -> MacroFixture {\n+    let source_file = ast::SourceFile::parse(macro_definition).ok().unwrap();\n+    let macro_definition =\n+        source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n+\n+    let (definition_tt, _) = ast_to_token_tree(&macro_definition.token_tree().unwrap()).unwrap();\n+    let rules = MacroRules::parse(&definition_tt).unwrap();\n+    MacroFixture { rules }\n+}\n \n+fn debug_dump_ignore_spaces(node: &ra_syntax::SyntaxNode) -> String {\n     let mut level = 0;\n     let mut buf = String::new();\n     macro_rules! indent {"}, {"sha": "65134277e128af487e358ca5af9248958dc6c2f5", "filename": "crates/ra_parser/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1e32412e28d6668af5c6fe85b4fc921fb1de9a98/crates%2Fra_parser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e32412e28d6668af5c6fe85b4fc921fb1de9a98/crates%2Fra_parser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Flib.rs?ref=1e32412e28d6668af5c6fe85b4fc921fb1de9a98", "patch": "@@ -83,6 +83,7 @@ pub fn parse(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n     parse_from_tokens(token_source, tree_sink, grammar::root);\n }\n \n+#[derive(Clone, Copy)]\n pub enum FragmentKind {\n     Path,\n     Expr,"}]}