{"sha": "28d6623bccf8f7e9a40a47895df75dd9ef2619da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4ZDY2MjNiY2NmOGY3ZTlhNDBhNDc4OTVkZjc1ZGQ5ZWYyNjE5ZGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-03T20:59:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-03T20:59:08Z"}, "message": "Auto merge of #38148 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 15 pull requests\n\n- Successful merges: #37859, #37919, #38020, #38028, #38029, #38065, #38073, #38077, #38089, #38090, #38096, #38112, #38113, #38130, #38141\n- Failed merges:", "tree": {"sha": "91daee4618a52cda3d0f3a3d7df4d3c8eb8722fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91daee4618a52cda3d0f3a3d7df4d3c8eb8722fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28d6623bccf8f7e9a40a47895df75dd9ef2619da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28d6623bccf8f7e9a40a47895df75dd9ef2619da", "html_url": "https://github.com/rust-lang/rust/commit/28d6623bccf8f7e9a40a47895df75dd9ef2619da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28d6623bccf8f7e9a40a47895df75dd9ef2619da/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cdbd5eb4255974db204819f9aa49c00b15a6d23", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cdbd5eb4255974db204819f9aa49c00b15a6d23", "html_url": "https://github.com/rust-lang/rust/commit/2cdbd5eb4255974db204819f9aa49c00b15a6d23"}, {"sha": "2e038ed3deef5aea93a84d1e5a8fcff5eedf7631", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e038ed3deef5aea93a84d1e5a8fcff5eedf7631", "html_url": "https://github.com/rust-lang/rust/commit/2e038ed3deef5aea93a84d1e5a8fcff5eedf7631"}], "stats": {"total": 831, "additions": 738, "deletions": 93}, "files": [{"sha": "24d716c11958eefec3f942a58037555440bec172", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=28d6623bccf8f7e9a40a47895df75dd9ef2619da", "patch": "@@ -32,7 +32,7 @@ The script accepts commands, flags, and filters to determine what to do:\n   # build the whole compiler\n   ./x.py build\n \n-  # build the stage1 compier\n+  # build the stage1 compiler\n   ./x.py build --stage 1\n \n   # build stage0 libstd"}, {"sha": "ebeb9923197a9aca4a680f15670b47032f56b324", "filename": "src/doc/book/testing.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Fdoc%2Fbook%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Fdoc%2Fbook%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftesting.md?ref=28d6623bccf8f7e9a40a47895df75dd9ef2619da", "patch": "@@ -589,11 +589,11 @@ please see the [Documentation chapter](documentation.html).\n \n # Testing and concurrency\n \n-One thing that is important to note when writing tests are run concurrently\n-using threads. For this reason you should take care that your tests are written\n-in such a way as to not depend on each-other, or on any shared state. \"Shared\n-state\" can also include the environment, such as the current working directory,\n-or environment variables.\n+One thing that is important to note when writing tests is that they may be run\n+concurrently using threads. For this reason you should take care that your tests\n+are written in such a way as to not depend on each-other, or on any shared\n+state. \"Shared state\" can also include the environment, such as the current\n+working directory, or environment variables.\n \n If this is an issue it is possible to control this concurrency, either by\n setting the environment variable `RUST_TEST_THREADS`, or by passing the argument"}, {"sha": "8655bab4b21bf23dc82ad476dc3e781a105e3ce4", "filename": "src/doc/reference.md", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=28d6623bccf8f7e9a40a47895df75dd9ef2619da", "patch": "@@ -740,13 +740,14 @@ There are several kinds of item:\n * [`extern crate` declarations](#extern-crate-declarations)\n * [`use` declarations](#use-declarations)\n * [modules](#modules)\n-* [functions](#functions)\n+* [function definitions](#functions)\n+* [`extern` blocks](#external-blocks)\n * [type definitions](grammar.html#type-definitions)\n-* [structs](#structs)\n-* [enumerations](#enumerations)\n+* [struct definitions](#structs)\n+* [enumeration definitions](#enumerations)\n * [constant items](#constant-items)\n * [static items](#static-items)\n-* [traits](#traits)\n+* [trait definitions](#traits)\n * [implementations](#implementations)\n \n Some items form an implicit scope for the declaration of sub-items. In other"}, {"sha": "919fc98e438c52a0ceb21bf41f38d2fecd48a274", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=28d6623bccf8f7e9a40a47895df75dd9ef2619da", "patch": "@@ -23,23 +23,23 @@ use std::fs::File;\n use std::io::{BufRead, Read};\n use std::path::Path;\n \n-use syntax::parse;\n use syntax::parse::lexer;\n use rustc::dep_graph::DepGraph;\n use rustc::session::{self, config};\n use rustc::middle::cstore::DummyCrateStore;\n \n use std::rc::Rc;\n use syntax::ast;\n-use syntax::ast::Name;\n use syntax::codemap;\n use syntax::parse::token::{self, BinOpToken, DelimToken, Lit, Token};\n use syntax::parse::lexer::TokenAndSpan;\n use syntax_pos::Pos;\n \n+use syntax::symbol::{Symbol, keywords};\n+\n fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n     fn id() -> token::Token {\n-        Token::Ident(ast::Ident::with_empty_ctxt(Name(0)))\n+        Token::Ident(ast::Ident::with_empty_ctxt(keywords::Invalid.name()))\n     }\n \n     let mut res = HashMap::new();\n@@ -65,7 +65,7 @@ fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n             \"SHL\"               => Token::BinOp(BinOpToken::Shl),\n             \"LBRACE\"            => Token::OpenDelim(DelimToken::Brace),\n             \"RARROW\"            => Token::RArrow,\n-            \"LIT_STR\"           => Token::Literal(Lit::Str_(Name(0)), None),\n+            \"LIT_STR\"           => Token::Literal(Lit::Str_(keywords::Invalid.name()), None),\n             \"DOTDOT\"            => Token::DotDot,\n             \"MOD_SEP\"           => Token::ModSep,\n             \"DOTDOTDOT\"         => Token::DotDotDot,\n@@ -75,21 +75,22 @@ fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n             \"ANDAND\"            => Token::AndAnd,\n             \"AT\"                => Token::At,\n             \"LBRACKET\"          => Token::OpenDelim(DelimToken::Bracket),\n-            \"LIT_STR_RAW\"       => Token::Literal(Lit::StrRaw(Name(0), 0), None),\n+            \"LIT_STR_RAW\"       => Token::Literal(Lit::StrRaw(keywords::Invalid.name(), 0), None),\n             \"RPAREN\"            => Token::CloseDelim(DelimToken::Paren),\n             \"SLASH\"             => Token::BinOp(BinOpToken::Slash),\n             \"COMMA\"             => Token::Comma,\n-            \"LIFETIME\"          => Token::Lifetime(ast::Ident::with_empty_ctxt(Name(0))),\n+            \"LIFETIME\"          => Token::Lifetime(\n+                                            ast::Ident::with_empty_ctxt(keywords::Invalid.name())),\n             \"CARET\"             => Token::BinOp(BinOpToken::Caret),\n             \"TILDE\"             => Token::Tilde,\n             \"IDENT\"             => id(),\n             \"PLUS\"              => Token::BinOp(BinOpToken::Plus),\n-            \"LIT_CHAR\"          => Token::Literal(Lit::Char(Name(0)), None),\n-            \"LIT_BYTE\"          => Token::Literal(Lit::Byte(Name(0)), None),\n+            \"LIT_CHAR\"          => Token::Literal(Lit::Char(keywords::Invalid.name()), None),\n+            \"LIT_BYTE\"          => Token::Literal(Lit::Byte(keywords::Invalid.name()), None),\n             \"EQ\"                => Token::Eq,\n             \"RBRACKET\"          => Token::CloseDelim(DelimToken::Bracket),\n             \"COMMENT\"           => Token::Comment,\n-            \"DOC_COMMENT\"       => Token::DocComment(Name(0)),\n+            \"DOC_COMMENT\"       => Token::DocComment(keywords::Invalid.name()),\n             \"DOT\"               => Token::Dot,\n             \"EQEQ\"              => Token::EqEq,\n             \"NE\"                => Token::Ne,\n@@ -99,9 +100,9 @@ fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n             \"BINOP\"             => Token::BinOp(BinOpToken::Plus),\n             \"POUND\"             => Token::Pound,\n             \"OROR\"              => Token::OrOr,\n-            \"LIT_INTEGER\"       => Token::Literal(Lit::Integer(Name(0)), None),\n+            \"LIT_INTEGER\"       => Token::Literal(Lit::Integer(keywords::Invalid.name()), None),\n             \"BINOPEQ\"           => Token::BinOpEq(BinOpToken::Plus),\n-            \"LIT_FLOAT\"         => Token::Literal(Lit::Float(Name(0)), None),\n+            \"LIT_FLOAT\"         => Token::Literal(Lit::Float(keywords::Invalid.name()), None),\n             \"WHITESPACE\"        => Token::Whitespace,\n             \"UNDERSCORE\"        => Token::Underscore,\n             \"MINUS\"             => Token::BinOp(BinOpToken::Minus),\n@@ -111,10 +112,11 @@ fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n             \"OR\"                => Token::BinOp(BinOpToken::Or),\n             \"GT\"                => Token::Gt,\n             \"LE\"                => Token::Le,\n-            \"LIT_BINARY\"        => Token::Literal(Lit::ByteStr(Name(0)), None),\n-            \"LIT_BINARY_RAW\"    => Token::Literal(Lit::ByteStrRaw(Name(0), 0), None),\n+            \"LIT_BINARY\"        => Token::Literal(Lit::ByteStr(keywords::Invalid.name()), None),\n+            \"LIT_BINARY_RAW\"    => Token::Literal(\n+                                            Lit::ByteStrRaw(keywords::Invalid.name(), 0), None),\n             \"QUESTION\"          => Token::Question,\n-            \"SHEBANG\"           => Token::Shebang(Name(0)),\n+            \"SHEBANG\"           => Token::Shebang(keywords::Invalid.name()),\n             _                   => continue,\n         };\n \n@@ -158,7 +160,7 @@ fn fix(mut lit: &str) -> ast::Name {\n     let leading_hashes = count(lit);\n \n     // +1/-1 to adjust for single quotes\n-    parse::token::intern(&lit[leading_hashes + 1..lit.len() - leading_hashes - 1])\n+    Symbol::intern(&lit[leading_hashes + 1..lit.len() - leading_hashes - 1])\n }\n \n /// Assuming a char/byte literal, strip the 'b' prefix and the single quotes.\n@@ -168,7 +170,7 @@ fn fixchar(mut lit: &str) -> ast::Name {\n         lit = &lit[1..];\n     }\n \n-    parse::token::intern(&lit[1..lit.len() - 1])\n+    Symbol::intern(&lit[1..lit.len() - 1])\n }\n \n fn count(lit: &str) -> usize {\n@@ -196,7 +198,7 @@ fn parse_antlr_token(s: &str, tokens: &HashMap<String, token::Token>, surrogate_\n     let not_found = format!(\"didn't find token {:?} in the map\", toknum);\n     let proto_tok = tokens.get(toknum).expect(&not_found[..]);\n \n-    let nm = parse::token::intern(content);\n+    let nm = Symbol::intern(content);\n \n     debug!(\"What we got: content (`{}`), proto: {:?}\", content, proto_tok);\n "}, {"sha": "8871e1fa840ef7cc6cc5b8a5593a785b23dca20b", "filename": "src/libcore/option.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=28d6623bccf8f7e9a40a47895df75dd9ef2619da", "patch": "@@ -659,6 +659,16 @@ impl<T> Option<T> {\n impl<'a, T: Clone> Option<&'a T> {\n     /// Maps an `Option<&T>` to an `Option<T>` by cloning the contents of the\n     /// option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = 12;\n+    /// let opt_x = Some(&x);\n+    /// assert_eq!(opt_x, Some(&12));\n+    /// let cloned = opt_x.cloned();\n+    /// assert_eq!(cloned, Some(12));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn cloned(self) -> Option<T> {\n         self.map(|t| t.clone())"}, {"sha": "79c0ad0d2420957145ddf4140173b90d473ea2b1", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=28d6623bccf8f7e9a40a47895df75dd9ef2619da", "patch": "@@ -886,6 +886,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"enable incremental compilation (experimental)\"),\n     incremental_info: bool = (false, parse_bool, [UNTRACKED],\n         \"print high-level information about incremental reuse (or the lack thereof)\"),\n+    incremental_dump_hash: bool = (false, parse_bool, [UNTRACKED],\n+        \"dump hash information in textual format to stdout\"),\n     dump_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n           \"dump the dependency graph to $RUST_DEP_GRAPH (default: /tmp/dep_graph.gv)\"),\n     query_dep_graph: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "b67caa6750a81b59de426b5923fb98199345a6e7", "filename": "src/librustc_incremental/persist/file_format.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs?ref=28d6623bccf8f7e9a40a47895df75dd9ef2619da", "patch": "@@ -24,6 +24,7 @@ use std::path::Path;\n use std::fs::File;\n use std::env;\n \n+use rustc::session::Session;\n use rustc::session::config::nightly_options;\n \n /// The first few bytes of files generated by incremental compilation\n@@ -59,7 +60,7 @@ pub fn write_file_header<W: io::Write>(stream: &mut W) -> io::Result<()> {\n ///   incompatible version of the compiler.\n /// - Returns `Err(..)` if some kind of IO error occurred while reading the\n ///   file.\n-pub fn read_file(path: &Path) -> io::Result<Option<Vec<u8>>> {\n+pub fn read_file(sess: &Session, path: &Path) -> io::Result<Option<Vec<u8>>> {\n     if !path.exists() {\n         return Ok(None);\n     }\n@@ -72,6 +73,7 @@ pub fn read_file(path: &Path) -> io::Result<Option<Vec<u8>>> {\n         let mut file_magic = [0u8; 4];\n         file.read_exact(&mut file_magic)?;\n         if file_magic != FILE_MAGIC {\n+            report_format_mismatch(sess, path, \"Wrong FILE_MAGIC\");\n             return Ok(None)\n         }\n     }\n@@ -85,6 +87,7 @@ pub fn read_file(path: &Path) -> io::Result<Option<Vec<u8>>> {\n                                     ((header_format_version[1] as u16) << 8);\n \n         if header_format_version != HEADER_FORMAT_VERSION {\n+            report_format_mismatch(sess, path, \"Wrong HEADER_FORMAT_VERSION\");\n             return Ok(None)\n         }\n     }\n@@ -99,6 +102,7 @@ pub fn read_file(path: &Path) -> io::Result<Option<Vec<u8>>> {\n         file.read_exact(&mut buffer[..])?;\n \n         if &buffer[..] != rustc_version().as_bytes() {\n+            report_format_mismatch(sess, path, \"Different compiler version\");\n             return Ok(None);\n         }\n     }\n@@ -109,6 +113,16 @@ pub fn read_file(path: &Path) -> io::Result<Option<Vec<u8>>> {\n     Ok(Some(data))\n }\n \n+fn report_format_mismatch(sess: &Session, file: &Path, message: &str) {\n+    debug!(\"read_file: {}\", message);\n+\n+    if sess.opts.debugging_opts.incremental_info {\n+        println!(\"incremental: ignoring cache artifact `{}`: {}\",\n+                 file.file_name().unwrap().to_string_lossy(),\n+                 message);\n+    }\n+}\n+\n fn rustc_version() -> String {\n     if nightly_options::is_nightly_build() {\n         if let Some(val) = env::var_os(\"RUSTC_FORCE_INCR_COMP_ARTIFACT_HEADER\") {"}, {"sha": "2ad37e98c708a1af3e797d98e4f38812d7533c7f", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=28d6623bccf8f7e9a40a47895df75dd9ef2619da", "patch": "@@ -435,8 +435,8 @@ fn copy_files(target_dir: &Path,\n     }\n \n     if print_stats_on_success {\n-        println!(\"incr. comp. session directory: {} files hard-linked\", files_linked);\n-        println!(\"incr. comp. session directory: {} files copied\", files_copied);\n+        println!(\"incremental: session directory: {} files hard-linked\", files_linked);\n+        println!(\"incremental: session directory: {} files copied\", files_copied);\n     }\n \n     Ok(files_linked > 0 || files_copied == 0)"}, {"sha": "e5203ea02b45a8095ba4c1b14b3810d7660a4535", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=28d6623bccf8f7e9a40a47895df75dd9ef2619da", "patch": "@@ -156,7 +156,7 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n \n             let hashes_file_path = metadata_hash_import_path(&session_dir);\n \n-            match file_format::read_file(&hashes_file_path)\n+            match file_format::read_file(self.tcx.sess, &hashes_file_path)\n             {\n                 Ok(Some(data)) => {\n                     match self.load_from_data(cnum, &data, svh) {"}, {"sha": "8ff04a565e96b6f437b5ec40da954c5b15ac8007", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=28d6623bccf8f7e9a40a47895df75dd9ef2619da", "patch": "@@ -93,7 +93,7 @@ fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn load_data(sess: &Session, path: &Path) -> Option<Vec<u8>> {\n-    match file_format::read_file(path) {\n+    match file_format::read_file(sess, path) {\n         Ok(Some(data)) => return Some(data),\n         Ok(None) => {\n             // The file either didn't exist or was produced by an incompatible\n@@ -132,6 +132,10 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let prev_commandline_args_hash = u64::decode(&mut dep_graph_decoder)?;\n \n     if prev_commandline_args_hash != tcx.sess.opts.dep_tracking_hash() {\n+        if tcx.sess.opts.debugging_opts.incremental_info {\n+            println!(\"incremental: completely ignoring cache because of \\\n+                      differing commandline arguments\");\n+        }\n         // We can't reuse the cache, purge it.\n         debug!(\"decode_dep_graph: differing commandline arg hashes\");\n         for swp in work_products {\n@@ -192,7 +196,8 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 if tcx.sess.opts.debugging_opts.incremental_info {\n                     // It'd be nice to pretty-print these paths better than just\n                     // using the `Debug` impls, but wev.\n-                    println!(\"module {:?} is dirty because {:?} changed or was removed\",\n+                    println!(\"incremental: module {:?} is dirty because {:?} \\\n+                              changed or was removed\",\n                              target_node,\n                              raw_source_node.map_def(|&index| {\n                                  Some(directory.def_path_string(tcx, index))\n@@ -250,11 +255,24 @@ fn dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                    current_hash);\n                 continue;\n             }\n+\n+            if tcx.sess.opts.debugging_opts.incremental_dump_hash {\n+                println!(\"node {:?} is dirty as hash is {:?} was {:?}\",\n+                         dep_node.map_def(|&def_id| Some(tcx.def_path(def_id))).unwrap(),\n+                         current_hash,\n+                         hash.hash);\n+            }\n+\n             debug!(\"initial_dirty_nodes: {:?} is dirty as hash is {:?}, was {:?}\",\n                    dep_node.map_def(|&def_id| Some(tcx.def_path(def_id))).unwrap(),\n                    current_hash,\n                    hash.hash);\n         } else {\n+            if tcx.sess.opts.debugging_opts.incremental_dump_hash {\n+                println!(\"node {:?} is dirty as it was removed\",\n+                         hash.dep_node);\n+            }\n+\n             debug!(\"initial_dirty_nodes: {:?} is dirty as it was removed\",\n                    hash.dep_node);\n         }\n@@ -277,14 +295,19 @@ fn reconcile_work_products<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             debug!(\"reconcile_work_products: dep-node for {:?} is dirty\", swp);\n             delete_dirty_work_product(tcx, swp);\n         } else {\n-            let all_files_exist =\n-                swp.work_product\n-                   .saved_files\n-                   .iter()\n-                   .all(|&(_, ref file_name)| {\n-                       let path = in_incr_comp_dir_sess(tcx.sess, &file_name);\n-                       path.exists()\n-                   });\n+            let mut all_files_exist = true;\n+            for &(_, ref file_name) in swp.work_product.saved_files.iter() {\n+                let path = in_incr_comp_dir_sess(tcx.sess, file_name);\n+                if !path.exists() {\n+                    all_files_exist = false;\n+\n+                    if tcx.sess.opts.debugging_opts.incremental_info {\n+                        println!(\"incremental: could not find file for up-to-date work product: {}\",\n+                                 path.display());\n+                    }\n+                }\n+            }\n+\n             if all_files_exist {\n                 debug!(\"reconcile_work_products: all files for {:?} exist\", swp);\n                 tcx.dep_graph.insert_previous_work_product(&swp.id, swp.work_product);\n@@ -331,7 +354,7 @@ fn load_prev_metadata_hashes(tcx: TyCtxt,\n \n     debug!(\"load_prev_metadata_hashes() - File: {}\", file_path.display());\n \n-    let data = match file_format::read_file(&file_path) {\n+    let data = match file_format::read_file(tcx.sess, &file_path) {\n         Ok(Some(data)) => data,\n         Ok(None) => {\n             debug!(\"load_prev_metadata_hashes() - File produced by incompatible \\"}, {"sha": "1ce4bf7f033417735a3fe09c160ee06a71177a8e", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=28d6623bccf8f7e9a40a47895df75dd9ef2619da", "patch": "@@ -159,6 +159,12 @@ pub fn encode_dep_graph(preds: &Predecessors,\n         }\n     }\n \n+    if tcx.sess.opts.debugging_opts.incremental_dump_hash {\n+        for (dep_node, hash) in &preds.hashes {\n+            println!(\"HIR hash for {:?} is {}\", dep_node, hash);\n+        }\n+    }\n+\n     // Create the serialized dep-graph.\n     let graph = SerializedDepGraph {\n         edges: edges,\n@@ -248,6 +254,15 @@ pub fn encode_metadata_hashes(tcx: TyCtxt,\n         let hash = state.finish();\n \n         debug!(\"save: metadata hash for {:?} is {}\", def_id, hash);\n+\n+        if tcx.sess.opts.debugging_opts.incremental_dump_hash {\n+            println!(\"metadata hash for {:?} is {}\", def_id, hash);\n+            for dep_node in sources {\n+                println!(\"metadata hash for {:?} depends on {:?} with hash {}\",\n+                         def_id, dep_node, preds.hashes[dep_node]);\n+            }\n+        }\n+\n         serialized_hashes.hashes.push(SerializedMetadataHash {\n             def_index: def_id.index,\n             hash: hash,"}, {"sha": "259ef2a780cc251fb6a594dc86afd876531da619", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=28d6623bccf8f7e9a40a47895df75dd9ef2619da", "patch": "@@ -1981,6 +1981,11 @@ fn trans_reuse_previous_work_products(tcx: TyCtxt,\n                     debug!(\"trans_reuse_previous_work_products: reusing {:?}\", work_product);\n                     return Some(work_product);\n                 } else {\n+                    if tcx.sess.opts.debugging_opts.incremental_info {\n+                        println!(\"incremental: CGU `{}` invalidated because of \\\n+                                  changed partitioning hash.\",\n+                                  cgu.name());\n+                    }\n                     debug!(\"trans_reuse_previous_work_products: \\\n                             not reusing {:?} because hash changed to {:?}\",\n                            work_product, hash);"}, {"sha": "b5531b8bb9ec97e627f74645c0f0674e89489bca", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=28d6623bccf8f7e9a40a47895df75dd9ef2619da", "patch": "@@ -884,10 +884,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // those that do.\n         self.ensure_super_predicates(binding.span, trait_ref.def_id())?;\n \n-        let candidates: Vec<ty::PolyTraitRef> =\n+        let candidates =\n             traits::supertraits(tcx, trait_ref.clone())\n-            .filter(|r| self.trait_defines_associated_type_named(r.def_id(), binding.item_name))\n-            .collect();\n+            .filter(|r| self.trait_defines_associated_type_named(r.def_id(), binding.item_name));\n \n         let candidate = self.one_bound_for_assoc_type(candidates,\n                                                       &trait_ref.to_string(),\n@@ -1191,10 +1190,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         // Check that there is exactly one way to find an associated type with the\n         // correct name.\n-        let suitable_bounds: Vec<_> =\n+        let suitable_bounds =\n             traits::transitive_bounds(tcx, &bounds)\n-            .filter(|b| self.trait_defines_associated_type_named(b.def_id(), assoc_name))\n-            .collect();\n+            .filter(|b| self.trait_defines_associated_type_named(b.def_id(), assoc_name));\n \n         self.one_bound_for_assoc_type(suitable_bounds,\n                                       &ty_param_name.as_str(),\n@@ -1205,54 +1203,57 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     // Checks that bounds contains exactly one element and reports appropriate\n     // errors otherwise.\n-    fn one_bound_for_assoc_type(&self,\n-                                bounds: Vec<ty::PolyTraitRef<'tcx>>,\n+    fn one_bound_for_assoc_type<I>(&self,\n+                                mut bounds: I,\n                                 ty_param_name: &str,\n                                 assoc_name: &str,\n                                 span: Span)\n         -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n+        where I: Iterator<Item=ty::PolyTraitRef<'tcx>>\n     {\n-        if bounds.is_empty() {\n-            struct_span_err!(self.tcx().sess, span, E0220,\n-                      \"associated type `{}` not found for `{}`\",\n-                      assoc_name,\n-                      ty_param_name)\n-              .span_label(span, &format!(\"associated type `{}` not found\", assoc_name))\n-              .emit();\n-            return Err(ErrorReported);\n-        }\n-\n-        if bounds.len() > 1 {\n-            let spans = bounds.iter().map(|b| {\n-                self.tcx().associated_items(b.def_id()).find(|item| {\n-                    item.kind == ty::AssociatedKind::Type && item.name == assoc_name\n-                })\n-                .and_then(|item| self.tcx().map.span_if_local(item.def_id))\n-            });\n+        let bound = match bounds.next() {\n+            Some(bound) => bound,\n+            None => {\n+                struct_span_err!(self.tcx().sess, span, E0220,\n+                          \"associated type `{}` not found for `{}`\",\n+                          assoc_name,\n+                          ty_param_name)\n+                  .span_label(span, &format!(\"associated type `{}` not found\", assoc_name))\n+                  .emit();\n+                return Err(ErrorReported);\n+            }\n+        };\n \n+        if let Some(bound2) = bounds.next() {\n+            let bounds = iter::once(bound).chain(iter::once(bound2)).chain(bounds);\n             let mut err = struct_span_err!(\n                 self.tcx().sess, span, E0221,\n                 \"ambiguous associated type `{}` in bounds of `{}`\",\n                 assoc_name,\n                 ty_param_name);\n             err.span_label(span, &format!(\"ambiguous associated type `{}`\", assoc_name));\n \n-            for span_and_bound in spans.zip(&bounds) {\n-                if let Some(span) = span_and_bound.0 {\n+            for bound in bounds {\n+                let bound_span = self.tcx().associated_items(bound.def_id()).find(|item| {\n+                    item.kind == ty::AssociatedKind::Type && item.name == assoc_name\n+                })\n+                .and_then(|item| self.tcx().map.span_if_local(item.def_id));\n+\n+                if let Some(span) = bound_span {\n                     err.span_label(span, &format!(\"ambiguous `{}` from `{}`\",\n                                                   assoc_name,\n-                                                  span_and_bound.1));\n+                                                  bound));\n                 } else {\n                     span_note!(&mut err, span,\n                                \"associated type `{}` could derive from `{}`\",\n                                ty_param_name,\n-                               span_and_bound.1);\n+                               bound);\n                 }\n             }\n             err.emit();\n         }\n \n-        Ok(bounds[0].clone())\n+        return Ok(bound);\n     }\n \n     // Create a type from a path to an associated type.\n@@ -1293,11 +1294,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     return (tcx.types.err, Def::Err);\n                 }\n \n-                let candidates: Vec<ty::PolyTraitRef> =\n+                let candidates =\n                     traits::supertraits(tcx, ty::Binder(trait_ref))\n                     .filter(|r| self.trait_defines_associated_type_named(r.def_id(),\n-                                                                         assoc_name))\n-                    .collect();\n+                                                                         assoc_name));\n \n                 match self.one_bound_for_assoc_type(candidates,\n                                                     \"Self\","}, {"sha": "764ea9445568e7e0864bd092fc35f5753519d533", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=28d6623bccf8f7e9a40a47895df75dd9ef2619da", "patch": "@@ -1101,7 +1101,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     } else {\n                          let mut err = struct_span_err!(tcx.sess, impl_item.span, E0323,\n                                   \"item `{}` is an associated const, \\\n-                                  which doesn't match its trait `{:?}`\",\n+                                  which doesn't match its trait `{}`\",\n                                   ty_impl_item.name,\n                                   impl_trait_ref);\n                          err.span_label(impl_item.span, &format!(\"does not match trait\"));\n@@ -1139,7 +1139,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     } else {\n                         let mut err = struct_span_err!(tcx.sess, impl_item.span, E0324,\n                                   \"item `{}` is an associated method, \\\n-                                  which doesn't match its trait `{:?}`\",\n+                                  which doesn't match its trait `{}`\",\n                                   ty_impl_item.name,\n                                   impl_trait_ref);\n                          err.span_label(impl_item.span, &format!(\"does not match trait\"));\n@@ -1157,7 +1157,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     } else {\n                         let mut err = struct_span_err!(tcx.sess, impl_item.span, E0325,\n                                   \"item `{}` is an associated type, \\\n-                                  which doesn't match its trait `{:?}`\",\n+                                  which doesn't match its trait `{}`\",\n                                   ty_impl_item.name,\n                                   impl_trait_ref);\n                          err.span_label(impl_item.span, &format!(\"does not match trait\"));"}, {"sha": "c1e610f33fb705777a5979bc601832c6833bb819", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=28d6623bccf8f7e9a40a47895df75dd9ef2619da", "patch": "@@ -79,8 +79,18 @@ pub enum Ipv6MulticastScope {\n \n impl IpAddr {\n     /// Returns true for the special 'unspecified' address ([IPv4], [IPv6]).\n+    ///\n     /// [IPv4]: ../../std/net/struct.Ipv4Addr.html#method.is_unspecified\n     /// [IPv6]: ../../std/net/struct.Ipv6Addr.html#method.is_unspecified\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)).is_unspecified(), true);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)).is_unspecified(), true);\n+    /// ```\n     #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n     pub fn is_unspecified(&self) -> bool {\n         match *self {\n@@ -90,8 +100,18 @@ impl IpAddr {\n     }\n \n     /// Returns true if this is a loopback address ([IPv4], [IPv6]).\n+    ///\n     /// [IPv4]: ../../std/net/struct.Ipv4Addr.html#method.is_loopback\n     /// [IPv6]: ../../std/net/struct.Ipv6Addr.html#method.is_loopback\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)).is_loopback(), true);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1)).is_loopback(), true);\n+    /// ```\n     #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n     pub fn is_loopback(&self) -> bool {\n         match *self {\n@@ -101,8 +121,23 @@ impl IpAddr {\n     }\n \n     /// Returns true if the address appears to be globally routable ([IPv4], [IPv6]).\n+    ///\n     /// [IPv4]: ../../std/net/struct.Ipv4Addr.html#method.is_global\n     /// [IPv6]: ../../std/net/struct.Ipv6Addr.html#method.is_global\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// fn main() {\n+    ///     assert_eq!(IpAddr::V4(Ipv4Addr::new(80, 9, 12, 3)).is_global(), true);\n+    ///     assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0x1c9, 0, 0, 0xafc8, 0, 0x1)).is_global(),\n+    ///                true);\n+    /// }\n+    /// ```\n     pub fn is_global(&self) -> bool {\n         match *self {\n             IpAddr::V4(ref a) => a.is_global(),\n@@ -111,8 +146,18 @@ impl IpAddr {\n     }\n \n     /// Returns true if this is a multicast address ([IPv4], [IPv6]).\n+    ///\n     /// [IPv4]: ../../std/net/struct.Ipv4Addr.html#method.is_multicast\n     /// [IPv6]: ../../std/net/struct.Ipv6Addr.html#method.is_multicast\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(224, 254, 0, 0)).is_multicast(), true);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0)).is_multicast(), true);\n+    /// ```\n     #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n     pub fn is_multicast(&self) -> bool {\n         match *self {\n@@ -122,8 +167,23 @@ impl IpAddr {\n     }\n \n     /// Returns true if this address is in a range designated for documentation ([IPv4], [IPv6]).\n+    ///\n     /// [IPv4]: ../../std/net/struct.Ipv4Addr.html#method.is_documentation\n     /// [IPv6]: ../../std/net/struct.Ipv6Addr.html#method.is_documentation\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// fn main() {\n+    ///     assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_documentation(), true);\n+    ///     assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0))\n+    ///                       .is_documentation(), true);\n+    /// }\n+    /// ```\n     pub fn is_documentation(&self) -> bool {\n         match *self {\n             IpAddr::V4(ref a) => a.is_documentation(),\n@@ -132,6 +192,20 @@ impl IpAddr {\n     }\n \n     /// Returns true if this address is a valid IPv4 address, false if it's a valid IPv6 address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ipaddr_checker)]\n+    ///\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// fn main() {\n+    ///     assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_ipv4(), true);\n+    ///     assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_ipv4(),\n+    ///                false);\n+    /// }\n+    /// ```\n     #[unstable(feature = \"ipaddr_checker\", issue = \"36949\")]\n     pub fn is_ipv4(&self) -> bool {\n         match *self {\n@@ -141,6 +215,20 @@ impl IpAddr {\n     }\n \n     /// Returns true if this address is a valid IPv6 address, false if it's a valid IPv4 address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ipaddr_checker)]\n+    ///\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// fn main() {\n+    ///     assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_ipv6(), false);\n+    ///     assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_ipv6(),\n+    ///                true);\n+    /// }\n+    /// ```\n     #[unstable(feature = \"ipaddr_checker\", issue = \"36949\")]\n     pub fn is_ipv6(&self) -> bool {\n         match *self {\n@@ -522,6 +610,14 @@ impl Ipv6Addr {\n     /// Creates a new IPv6 address from eight 16-bit segments.\n     ///\n     /// The result will represent the IP address a:b:c:d:e:f:g:h.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// let addr = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16,\n                h: u16) -> Ipv6Addr {\n@@ -538,6 +634,15 @@ impl Ipv6Addr {\n     }\n \n     /// Returns the eight 16-bit segments that make up this address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).segments(),\n+    ///            [0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn segments(&self) -> [u16; 8] {\n         let arr = &self.inner.s6_addr;\n@@ -558,6 +663,15 @@ impl Ipv6Addr {\n     /// This property is defined in [RFC 4291].\n     ///\n     /// [RFC 4291]: https://tools.ietf.org/html/rfc4291\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unspecified(), false);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).is_unspecified(), true);\n+    /// ```\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_unspecified(&self) -> bool {\n         self.segments() == [0, 0, 0, 0, 0, 0, 0, 0]\n@@ -568,6 +682,15 @@ impl Ipv6Addr {\n     /// This property is defined in [RFC 4291].\n     ///\n     /// [RFC 4291]: https://tools.ietf.org/html/rfc4291\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_loopback(), false);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1).is_loopback(), true);\n+    /// ```\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_loopback(&self) -> bool {\n         self.segments() == [0, 0, 0, 0, 0, 0, 0, 1]\n@@ -580,6 +703,20 @@ impl Ipv6Addr {\n     /// - the loopback address\n     /// - link-local, site-local, and unique local unicast addresses\n     /// - interface-, link-, realm-, admin- and site-local multicast addresses\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// fn main() {\n+    ///     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_global(), true);\n+    ///     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1).is_global(), false);\n+    ///     assert_eq!(Ipv6Addr::new(0, 0, 0x1c9, 0, 0, 0xafc8, 0, 0x1).is_global(), true);\n+    /// }\n+    /// ```\n     pub fn is_global(&self) -> bool {\n         match self.multicast_scope() {\n             Some(Ipv6MulticastScope::Global) => true,\n@@ -593,6 +730,20 @@ impl Ipv6Addr {\n     /// This property is defined in [RFC 4193].\n     ///\n     /// [RFC 4193]: https://tools.ietf.org/html/rfc4193\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// fn main() {\n+    ///     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unique_local(),\n+    ///                false);\n+    ///     assert_eq!(Ipv6Addr::new(0xfc02, 0, 0, 0, 0, 0, 0, 0).is_unique_local(), true);\n+    /// }\n+    /// ```\n     pub fn is_unique_local(&self) -> bool {\n         (self.segments()[0] & 0xfe00) == 0xfc00\n     }\n@@ -602,12 +753,40 @@ impl Ipv6Addr {\n     /// This property is defined in [RFC 4291].\n     ///\n     /// [RFC 4291]: https://tools.ietf.org/html/rfc4291\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// fn main() {\n+    ///     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unicast_link_local(),\n+    ///                false);\n+    ///     assert_eq!(Ipv6Addr::new(0xfe8a, 0, 0, 0, 0, 0, 0, 0).is_unicast_link_local(), true);\n+    /// }\n+    /// ```\n     pub fn is_unicast_link_local(&self) -> bool {\n         (self.segments()[0] & 0xffc0) == 0xfe80\n     }\n \n     /// Returns true if this is a deprecated unicast site-local address\n     /// (fec0::/10).\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// fn main() {\n+    ///     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unicast_site_local(),\n+    ///                false);\n+    ///     assert_eq!(Ipv6Addr::new(0xfec2, 0, 0, 0, 0, 0, 0, 0).is_unicast_site_local(), true);\n+    /// }\n+    /// ```\n     pub fn is_unicast_site_local(&self) -> bool {\n         (self.segments()[0] & 0xffc0) == 0xfec0\n     }\n@@ -618,6 +797,20 @@ impl Ipv6Addr {\n     /// This property is defined in [RFC 3849].\n     ///\n     /// [RFC 3849]: https://tools.ietf.org/html/rfc3849\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// fn main() {\n+    ///     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_documentation(),\n+    ///                false);\n+    ///     assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_documentation(), true);\n+    /// }\n+    /// ```\n     pub fn is_documentation(&self) -> bool {\n         (self.segments()[0] == 0x2001) && (self.segments()[1] == 0xdb8)\n     }\n@@ -632,6 +825,20 @@ impl Ipv6Addr {\n     /// - unique local addresses\n     /// - the unspecified address\n     /// - the address range reserved for documentation\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// fn main() {\n+    ///     assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast_global(), false);\n+    ///     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unicast_global(),\n+    ///                true);\n+    /// }\n+    /// ```\n     pub fn is_unicast_global(&self) -> bool {\n         !self.is_multicast()\n             && !self.is_loopback() && !self.is_unicast_link_local()\n@@ -640,6 +847,20 @@ impl Ipv6Addr {\n     }\n \n     /// Returns the address's multicast scope if the address is multicast.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::{Ipv6Addr, Ipv6MulticastScope};\n+    ///\n+    /// fn main() {\n+    ///     assert_eq!(Ipv6Addr::new(0xff0e, 0, 0, 0, 0, 0, 0, 0).multicast_scope(),\n+    ///                              Some(Ipv6MulticastScope::Global));\n+    ///     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).multicast_scope(), None);\n+    /// }\n+    /// ```\n     pub fn multicast_scope(&self) -> Option<Ipv6MulticastScope> {\n         if self.is_multicast() {\n             match self.segments()[0] & 0x000f {\n@@ -662,6 +883,14 @@ impl Ipv6Addr {\n     /// This property is defined by [RFC 4291].\n     ///\n     /// [RFC 4291]: https://tools.ietf.org/html/rfc4291\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).is_multicast(), true);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_multicast(), false);\n+    /// ```\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_multicast(&self) -> bool {\n         (self.segments()[0] & 0xff00) == 0xff00\n@@ -671,6 +900,16 @@ impl Ipv6Addr {\n     /// neither IPv4-compatible or IPv4-mapped.\n     ///\n     /// ::a.b.c.d and ::ffff:a.b.c.d become a.b.c.d\n+    ///\n+    /// ```\n+    /// use std::net::{Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).to_ipv4(), None);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).to_ipv4(),\n+    ///            Some(Ipv4Addr::new(192, 10, 2, 255)));\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_ipv4(),\n+    ///            Some(Ipv4Addr::new(0, 0, 0, 1)));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_ipv4(&self) -> Option<Ipv4Addr> {\n         match self.segments() {\n@@ -683,6 +922,13 @@ impl Ipv6Addr {\n     }\n \n     /// Returns the sixteen eight-bit integers the IPv6 address consists of.\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).octets(),\n+    ///            [255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n+    /// ```\n     #[stable(feature = \"ipv6_to_octets\", since = \"1.12.0\")]\n     pub fn octets(&self) -> [u8; 16] {\n         self.inner.s6_addr"}, {"sha": "b280f466dd439f3628f1bdb908380f9e4d76c1d0", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 215, "deletions": 11, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=28d6623bccf8f7e9a40a47895df75dd9ef2619da", "patch": "@@ -48,15 +48,36 @@ pub struct UdpSocket(net_imp::UdpSocket);\n impl UdpSocket {\n     /// Creates a UDP socket from the given address.\n     ///\n-    /// The address type can be any implementor of `ToSocketAddr` trait. See\n+    /// The address type can be any implementor of [`ToSocketAddrs`] trait. See\n     /// its documentation for concrete examples.\n+    ///\n+    /// [`ToSocketAddrs`]: ../../std/net/trait.ToSocketAddrs.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<UdpSocket> {\n         super::each_addr(addr, net_imp::UdpSocket::bind).map(UdpSocket)\n     }\n \n     /// Receives data from the socket. On success, returns the number of bytes\n     /// read and the address from whence the data came.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// let mut buf = [0; 10];\n+    /// let (number_of_bytes, src_addr) = socket.recv_from(&mut buf)\n+    ///                                         .expect(\"Didn't receive data\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n         self.0.recv_from(buf)\n@@ -65,11 +86,24 @@ impl UdpSocket {\n     /// Sends data on the socket to the given address. On success, returns the\n     /// number of bytes written.\n     ///\n-    /// Address type can be any implementor of `ToSocketAddrs` trait. See its\n+    /// Address type can be any implementor of [`ToSocketAddrs`] trait. See its\n     /// documentation for concrete examples.\n+    ///\n     /// This will return an error when the IP version of the local socket\n-    /// does not match that returned from `ToSocketAddrs`\n+    /// does not match that returned from [`ToSocketAddrs`].\n+    ///\n     /// See https://github.com/rust-lang/rust/issues/34202 for more details.\n+    ///\n+    /// [`ToSocketAddrs`]: ../../std/net/trait.ToSocketAddrs.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.send_to(&[0; 10], \"127.0.0.1:4242\").expect(\"couldn't send data\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn send_to<A: ToSocketAddrs>(&self, buf: &[u8], addr: A)\n                                      -> io::Result<usize> {\n@@ -81,6 +115,16 @@ impl UdpSocket {\n     }\n \n     /// Returns the socket address that this socket was created from.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4, UdpSocket};\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// assert_eq!(socket.local_addr().unwrap(),\n+    ///            SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 34254)));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n         self.0.socket_addr()\n@@ -91,54 +135,119 @@ impl UdpSocket {\n     /// The returned `UdpSocket` is a reference to the same socket that this\n     /// object references. Both handles will read and write the same port, and\n     /// options set on one socket will be propagated to the other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// let socket_clone = socket.try_clone().expect(\"couldn't clone the socket\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_clone(&self) -> io::Result<UdpSocket> {\n         self.0.duplicate().map(UdpSocket)\n     }\n \n     /// Sets the read timeout to the timeout specified.\n     ///\n-    /// If the value specified is `None`, then `read` calls will block\n-    /// indefinitely. It is an error to pass the zero `Duration` to this\n+    /// If the value specified is [`None`], then [`read()`] calls will block\n+    /// indefinitely. It is an error to pass the zero [`Duration`] to this\n     /// method.\n     ///\n     /// # Note\n     ///\n     /// Platforms may return a different error code whenever a read times out as\n     /// a result of setting this option. For example Unix typically returns an\n-    /// error of the kind `WouldBlock`, but Windows may return `TimedOut`.\n+    /// error of the kind [`WouldBlock`], but Windows may return [`TimedOut`].\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`read()`]: ../../std/io/trait.Read.html#tymethod.read\n+    /// [`Duration`]: ../../std/time/struct.Duration.html\n+    /// [`WouldBlock`]: ../../std/io/enum.ErrorKind.html#variant.WouldBlock\n+    /// [`TimedOut`]: ../../std/io/enum.ErrorKind.html#variant.TimedOut\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_read_timeout(None).expect(\"set_read_timeout call failed\");\n+    /// ```\n     #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n     pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         self.0.set_read_timeout(dur)\n     }\n \n     /// Sets the write timeout to the timeout specified.\n     ///\n-    /// If the value specified is `None`, then `write` calls will block\n-    /// indefinitely. It is an error to pass the zero `Duration` to this\n+    /// If the value specified is [`None`], then [`write()`] calls will block\n+    /// indefinitely. It is an error to pass the zero [`Duration`] to this\n     /// method.\n     ///\n     /// # Note\n     ///\n     /// Platforms may return a different error code whenever a write times out\n     /// as a result of setting this option. For example Unix typically returns\n-    /// an error of the kind `WouldBlock`, but Windows may return `TimedOut`.\n+    /// an error of the kind [`WouldBlock`], but Windows may return [`TimedOut`].\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`write()`]: ../../std/io/trait.Write.html#tymethod.write\n+    /// [`Duration`]: ../../std/time/struct.Duration.html\n+    /// [`WouldBlock`]: ../../std/io/enum.ErrorKind.html#variant.WouldBlock\n+    /// [`TimedOut`]: ../../std/io/enum.ErrorKind.html#variant.TimedOut\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_write_timeout(None).expect(\"set_write_timeout call failed\");\n+    /// ```\n     #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n     pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         self.0.set_write_timeout(dur)\n     }\n \n     /// Returns the read timeout of this socket.\n     ///\n-    /// If the timeout is `None`, then `read` calls will block indefinitely.\n+    /// If the timeout is [`None`], then [`read()`] calls will block indefinitely.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`read()`]: ../../std/io/trait.Read.html#tymethod.read\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_read_timeout(None).expect(\"set_read_timeout call failed\");\n+    /// assert_eq!(socket.read_timeout().unwrap(), None);\n+    /// ```\n     #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n         self.0.read_timeout()\n     }\n \n     /// Returns the write timeout of this socket.\n     ///\n-    /// If the timeout is `None`, then `write` calls will block indefinitely.\n+    /// If the timeout is [`None`], then [`write()`] calls will block indefinitely.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`write()`]: ../../std/io/trait.Write.html#tymethod.write\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_write_timeout(None).expect(\"set_write_timeout call failed\");\n+    /// assert_eq!(socket.write_timeout().unwrap(), None);\n+    /// ```\n     #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n         self.0.write_timeout()\n@@ -148,6 +257,15 @@ impl UdpSocket {\n     ///\n     /// When enabled, this socket is allowed to send packets to a broadcast\n     /// address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_broadcast(false).expect(\"set_broadcast call failed\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn set_broadcast(&self, broadcast: bool) -> io::Result<()> {\n         self.0.set_broadcast(broadcast)\n@@ -159,6 +277,16 @@ impl UdpSocket {\n     /// [`set_broadcast`][link].\n     ///\n     /// [link]: #method.set_broadcast\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_broadcast(false).expect(\"set_broadcast call failed\");\n+    /// assert_eq!(socket.broadcast().unwrap(), false);\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn broadcast(&self) -> io::Result<bool> {\n         self.0.broadcast()\n@@ -168,6 +296,15 @@ impl UdpSocket {\n     ///\n     /// If enabled, multicast packets will be looped back to the local socket.\n     /// Note that this may not have any affect on IPv6 sockets.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_multicast_loop_v4(false).expect(\"set_multicast_loop_v4 call failed\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn set_multicast_loop_v4(&self, multicast_loop_v4: bool) -> io::Result<()> {\n         self.0.set_multicast_loop_v4(multicast_loop_v4)\n@@ -179,6 +316,16 @@ impl UdpSocket {\n     /// [`set_multicast_loop_v4`][link].\n     ///\n     /// [link]: #method.set_multicast_loop_v4\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_multicast_loop_v4(false).expect(\"set_multicast_loop_v4 call failed\");\n+    /// assert_eq!(socket.multicast_loop_v4().unwrap(), false);\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n         self.0.multicast_loop_v4()\n@@ -191,6 +338,15 @@ impl UdpSocket {\n     /// don't leave the local network unless explicitly requested.\n     ///\n     /// Note that this may not have any affect on IPv6 sockets.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_multicast_ttl_v4(42).expect(\"set_multicast_ttl_v4 call failed\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn set_multicast_ttl_v4(&self, multicast_ttl_v4: u32) -> io::Result<()> {\n         self.0.set_multicast_ttl_v4(multicast_ttl_v4)\n@@ -202,6 +358,16 @@ impl UdpSocket {\n     /// [`set_multicast_ttl_v4`][link].\n     ///\n     /// [link]: #method.set_multicast_ttl_v4\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_multicast_ttl_v4(42).expect(\"set_multicast_ttl_v4 call failed\");\n+    /// assert_eq!(socket.multicast_ttl_v4().unwrap(), 42);\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n         self.0.multicast_ttl_v4()\n@@ -211,6 +377,15 @@ impl UdpSocket {\n     ///\n     /// Controls whether this socket sees the multicast packets it sends itself.\n     /// Note that this may not have any affect on IPv4 sockets.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_multicast_loop_v6(false).expect(\"set_multicast_loop_v6 call failed\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn set_multicast_loop_v6(&self, multicast_loop_v6: bool) -> io::Result<()> {\n         self.0.set_multicast_loop_v6(multicast_loop_v6)\n@@ -222,6 +397,16 @@ impl UdpSocket {\n     /// [`set_multicast_loop_v6`][link].\n     ///\n     /// [link]: #method.set_multicast_loop_v6\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_multicast_loop_v6(false).expect(\"set_multicast_loop_v6 call failed\");\n+    /// assert_eq!(socket.multicast_loop_v6().unwrap(), false);\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n         self.0.multicast_loop_v6()\n@@ -231,6 +416,15 @@ impl UdpSocket {\n     ///\n     /// This value sets the time-to-live field that is used in every packet sent\n     /// from this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_ttl(42).expect(\"set_ttl call failed\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n         self.0.set_ttl(ttl)\n@@ -241,6 +435,16 @@ impl UdpSocket {\n     /// For more information about this option, see [`set_ttl`][link].\n     ///\n     /// [link]: #method.set_ttl\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_ttl(42).expect(\"set_ttl call failed\");\n+    /// assert_eq!(socket.ttl().unwrap(), 42);\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn ttl(&self) -> io::Result<u32> {\n         self.0.ttl()"}, {"sha": "d13baea40a9ff8069744f6a278548ac468ddee8d", "filename": "src/libstd/path.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=28d6623bccf8f7e9a40a47895df75dd9ef2619da", "patch": "@@ -457,7 +457,17 @@ pub enum Component<'a> {\n }\n \n impl<'a> Component<'a> {\n-    /// Extracts the underlying `OsStr` slice\n+    /// Extracts the underlying `OsStr` slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"./tmp/foo/bar.txt\");\n+    /// let components: Vec<_> = path.components().map(|comp| comp.as_os_str()).collect();\n+    /// assert_eq!(&components, &[\".\", \"tmp\", \"foo\", \"bar.txt\"]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_os_str(self) -> &'a OsStr {\n         match self {"}, {"sha": "37355ed377b796318ad0958b9a3fdbab4f458bc4", "filename": "src/test/debuginfo/macro-stepping.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Ftest%2Fdebuginfo%2Fmacro-stepping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Ftest%2Fdebuginfo%2Fmacro-stepping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmacro-stepping.rs?ref=28d6623bccf8f7e9a40a47895df75dd9ef2619da", "patch": "@@ -10,6 +10,7 @@\n \n // ignore-windows\n // ignore-android\n+// ignore-aarch64\n // min-lldb-version: 310\n \n // aux-build:macro-stepping.rs"}, {"sha": "adc2b23441ef817355c6af0d2ff05a4cb878c388", "filename": "src/test/incremental/add_private_fn_at_krate_root_cc/auxiliary/point.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Ftest%2Fincremental%2Fadd_private_fn_at_krate_root_cc%2Fauxiliary%2Fpoint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Ftest%2Fincremental%2Fadd_private_fn_at_krate_root_cc%2Fauxiliary%2Fpoint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fadd_private_fn_at_krate_root_cc%2Fauxiliary%2Fpoint.rs?ref=28d6623bccf8f7e9a40a47895df75dd9ef2619da", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Point {\n+    pub x: f32,\n+    pub y: f32,\n+}\n+\n+#[cfg(rpass2)]\n+fn unused_helper() {\n+}\n+\n+pub fn distance_squared(this: &Point) -> f32 {\n+    return this.x * this.x + this.y * this.y;\n+}\n+\n+impl Point {\n+    pub fn distance_from_origin(&self) -> f32 {\n+        distance_squared(self).sqrt()\n+    }\n+}"}, {"sha": "489427ba1c126202be6eafe31f9d379f7a99074a", "filename": "src/test/incremental/add_private_fn_at_krate_root_cc/struct_point.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Ftest%2Fincremental%2Fadd_private_fn_at_krate_root_cc%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Ftest%2Fincremental%2Fadd_private_fn_at_krate_root_cc%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fadd_private_fn_at_krate_root_cc%2Fstruct_point.rs?ref=28d6623bccf8f7e9a40a47895df75dd9ef2619da", "patch": "@@ -0,0 +1,84 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test where we add a private item into the root of an external.\n+// crate. This should not cause anything we use to be invalidated.\n+// Regression test for #36168.\n+\n+// revisions:rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n+// aux-build:point.rs\n+\n+#![feature(rustc_attrs)]\n+#![feature(stmt_expr_attributes)]\n+#![allow(dead_code)]\n+\n+#![rustc_partition_reused(module=\"struct_point-fn_calls_methods_in_same_impl\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_calls_free_fn\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_read_field\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_write_field\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_make_struct\", cfg=\"rpass2\")]\n+\n+extern crate point;\n+\n+/// A fn item that calls (public) methods on `Point` from the same impl\n+mod fn_calls_methods_in_same_impl {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn check() {\n+        let x = Point { x: 2.0, y: 2.0 };\n+        x.distance_from_origin();\n+    }\n+}\n+\n+/// A fn item that calls (public) methods on `Point` from another impl\n+mod fn_calls_free_fn {\n+    use point::{self, Point};\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn check() {\n+        let x = Point { x: 2.0, y: 2.0 };\n+        point::distance_squared(&x);\n+    }\n+}\n+\n+/// A fn item that makes an instance of `Point` but does not invoke methods\n+mod fn_make_struct {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn make_origin() -> Point {\n+        Point { x: 2.0, y: 2.0 }\n+    }\n+}\n+\n+/// A fn item that reads fields from `Point` but does not invoke methods\n+mod fn_read_field {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn get_x(p: Point) -> f32 {\n+        p.x\n+    }\n+}\n+\n+/// A fn item that writes to a field of `Point` but does not invoke methods\n+mod fn_write_field {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn inc_x(p: &mut Point) {\n+        p.x += 1.0;\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "815893e0c82d6a83ffb45d3d1c251a6379a23e84", "filename": "src/test/ui/span/impl-wrong-item-for-trait.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28d6623bccf8f7e9a40a47895df75dd9ef2619da/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr?ref=28d6623bccf8f7e9a40a47895df75dd9ef2619da", "patch": "@@ -1,4 +1,4 @@\n-error[E0323]: item `bar` is an associated const, which doesn't match its trait `<FooConstForMethod as Foo>`\n+error[E0323]: item `bar` is an associated const, which doesn't match its trait `Foo`\n   --> $DIR/impl-wrong-item-for-trait.rs:25:5\n    |\n 16 |     fn bar(&self);\n@@ -24,7 +24,7 @@ error[E0046]: not all trait items implemented, missing: `bar`\n 29 | | }\n    | |_^ ...ending here: missing `bar` in implementation\n \n-error[E0324]: item `MY_CONST` is an associated method, which doesn't match its trait `<FooMethodForConst as Foo>`\n+error[E0324]: item `MY_CONST` is an associated method, which doesn't match its trait `Foo`\n   --> $DIR/impl-wrong-item-for-trait.rs:37:5\n    |\n 17 |     const MY_CONST: u32;\n@@ -50,7 +50,7 @@ error[E0046]: not all trait items implemented, missing: `MY_CONST`\n 40 | | }\n    | |_^ ...ending here: missing `MY_CONST` in implementation\n \n-error[E0325]: item `bar` is an associated type, which doesn't match its trait `<FooTypeForMethod as Foo>`\n+error[E0325]: item `bar` is an associated type, which doesn't match its trait `Foo`\n   --> $DIR/impl-wrong-item-for-trait.rs:47:5\n    |\n 16 |     fn bar(&self);"}]}