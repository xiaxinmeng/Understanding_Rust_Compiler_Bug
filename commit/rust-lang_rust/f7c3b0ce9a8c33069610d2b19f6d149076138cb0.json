{"sha": "f7c3b0ce9a8c33069610d2b19f6d149076138cb0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3YzNiMGNlOWE4YzMzMDY5NjEwZDJiMTlmNmQxNDkwNzYxMzhjYjA=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-05-06T20:36:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-06T20:36:49Z"}, "message": "Rollup merge of #71888 - lcnr:refactor-suggest_traits_to_import, r=estebank\n\nrefactor suggest_traits_to_import", "tree": {"sha": "3a8c6df23113f60ad7a43667f4d90178a07925c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a8c6df23113f60ad7a43667f4d90178a07925c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7c3b0ce9a8c33069610d2b19f6d149076138cb0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJesx/hCRBK7hj4Ov3rIwAAdHIIAD15tSNjYP00O8aDLxKAEe9M\n7rIc0JD8QopQZ4QmFHomemadmiGZh+elh3IwsGhBwalZMC5TCsJnUQgCXhZzG2Id\nRUS91Pgo1u7E2/IMqll/Toqpersr5VF58fGOkYY5y0OEbCSlq8CtCxHU1yR4TDt3\nxN8Q8ANIztrJ71xlYRac3LJqcEZ5IBO/sly+fjEamePyZqCi1JLPB6sdBf6Qw8zj\n7TthRxKjOvdSeILyKDZ9beGb6B8tMNckkAm2LHtyHNaUw9TH7VZApW/bZZl14I4J\ngQfFKFOZjCA30kcOnd0Zifzui5gspeXC1z/OmiAOcUpyYqyjudcQLIxyEmptMZI=\n=ElBg\n-----END PGP SIGNATURE-----\n", "payload": "tree 3a8c6df23113f60ad7a43667f4d90178a07925c7\nparent 7fc579ff5baae024f22d9c196a22e17098832425\nparent ab7360d98f802ce32e9e97ec4aaa180140169f92\nauthor Dylan DPC <dylan.dpc@gmail.com> 1588797409 +0200\ncommitter GitHub <noreply@github.com> 1588797409 +0200\n\nRollup merge of #71888 - lcnr:refactor-suggest_traits_to_import, r=estebank\n\nrefactor suggest_traits_to_import\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7c3b0ce9a8c33069610d2b19f6d149076138cb0", "html_url": "https://github.com/rust-lang/rust/commit/f7c3b0ce9a8c33069610d2b19f6d149076138cb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7c3b0ce9a8c33069610d2b19f6d149076138cb0/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fc579ff5baae024f22d9c196a22e17098832425", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fc579ff5baae024f22d9c196a22e17098832425", "html_url": "https://github.com/rust-lang/rust/commit/7fc579ff5baae024f22d9c196a22e17098832425"}, {"sha": "ab7360d98f802ce32e9e97ec4aaa180140169f92", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab7360d98f802ce32e9e97ec4aaa180140169f92", "html_url": "https://github.com/rust-lang/rust/commit/ab7360d98f802ce32e9e97ec4aaa180140169f92"}], "stats": {"total": 104, "additions": 49, "deletions": 55}, "files": [{"sha": "857cc972559e499c7aa17fd8836ff9bee5d25dd9", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 49, "deletions": 55, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f7c3b0ce9a8c33069610d2b19f6d149076138cb0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7c3b0ce9a8c33069610d2b19f6d149076138cb0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=f7c3b0ce9a8c33069610d2b19f6d149076138cb0", "patch": "@@ -947,65 +947,59 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // this isn't perfect (that is, there are cases when\n                 // implementing a trait would be legal but is rejected\n                 // here).\n-                !unsatisfied_predicates.iter().any(|(p, _)| match p {\n-                        // Hide traits if they are present in predicates as they can be fixed without\n-                        // having to implement them.\n-                        ty::Predicate::Trait(t, _) => t.def_id() != info.def_id,\n-                        ty::Predicate::Projection(p) => p.item_def_id() != info.def_id,\n-                        _ => true,\n-                    }) && (type_is_local || info.def_id.is_local())\n-                        && self\n-                            .associated_item(info.def_id, item_name, Namespace::ValueNS)\n-                            .filter(|item| {\n-                                if let ty::AssocKind::Fn = item.kind {\n-                                    let id = item.def_id.as_local().map(|def_id| {\n-                                        self.tcx.hir().as_local_hir_id(def_id)\n-                                    });\n-                                    if let Some(hir::Node::TraitItem(hir::TraitItem {\n-                                        kind: hir::TraitItemKind::Fn(fn_sig, method),\n-                                        ..\n-                                    })) = id.map(|id| self.tcx.hir().get(id))\n+                unsatisfied_predicates.iter().all(|(p, _)| match p {\n+                    // Hide traits if they are present in predicates as they can be fixed without\n+                    // having to implement them.\n+                    ty::Predicate::Trait(t, _) => t.def_id() == info.def_id,\n+                    ty::Predicate::Projection(p) => p.item_def_id() == info.def_id,\n+                    _ => false,\n+                }) && (type_is_local || info.def_id.is_local())\n+                    && self\n+                        .associated_item(info.def_id, item_name, Namespace::ValueNS)\n+                        .filter(|item| {\n+                            if let ty::AssocKind::Fn = item.kind {\n+                                let id = item\n+                                    .def_id\n+                                    .as_local()\n+                                    .map(|def_id| self.tcx.hir().as_local_hir_id(def_id));\n+                                if let Some(hir::Node::TraitItem(hir::TraitItem {\n+                                    kind: hir::TraitItemKind::Fn(fn_sig, method),\n+                                    ..\n+                                })) = id.map(|id| self.tcx.hir().get(id))\n+                                {\n+                                    let self_first_arg = match method {\n+                                        hir::TraitFn::Required([ident, ..]) => {\n+                                            ident.name == kw::SelfLower\n+                                        }\n+                                        hir::TraitFn::Provided(body_id) => {\n+                                            self.tcx.hir().body(*body_id).params.first().map_or(\n+                                                false,\n+                                                |param| {\n+                                                    matches!(\n+                                                        param.pat.kind,\n+                                                        hir::PatKind::Binding(_, _, ident, _)\n+                                                            if ident.name == kw::SelfLower\n+                                                    )\n+                                                },\n+                                            )\n+                                        }\n+                                        _ => false,\n+                                    };\n+\n+                                    if !fn_sig.decl.implicit_self.has_implicit_self()\n+                                        && self_first_arg\n                                     {\n-                                        let self_first_arg = match method {\n-                                            hir::TraitFn::Required([ident, ..]) => {\n-                                                ident.name == kw::SelfLower\n-                                            }\n-                                            hir::TraitFn::Provided(body_id) => {\n-                                                match &self.tcx.hir().body(*body_id).params[..] {\n-                                                    [hir::Param {\n-                                                        pat:\n-                                                            hir::Pat {\n-                                                                kind:\n-                                                                    hir::PatKind::Binding(\n-                                                                        _,\n-                                                                        _,\n-                                                                        ident,\n-                                                                        ..,\n-                                                                    ),\n-                                                                ..\n-                                                            },\n-                                                        ..\n-                                                    }, ..] => ident.name == kw::SelfLower,\n-                                                    _ => false,\n-                                                }\n-                                            }\n-                                            _ => false,\n-                                        };\n-\n-                                        if !fn_sig.decl.implicit_self.has_implicit_self()\n-                                            && self_first_arg\n-                                        {\n-                                            if let Some(ty) = fn_sig.decl.inputs.get(0) {\n-                                                arbitrary_rcvr.push(ty.span);\n-                                            }\n-                                            return false;\n+                                        if let Some(ty) = fn_sig.decl.inputs.get(0) {\n+                                            arbitrary_rcvr.push(ty.span);\n                                         }\n+                                        return false;\n                                     }\n                                 }\n-                                // We only want to suggest public or local traits (#45781).\n-                                item.vis == ty::Visibility::Public || info.def_id.is_local()\n-                            })\n-                            .is_some()\n+                            }\n+                            // We only want to suggest public or local traits (#45781).\n+                            item.vis == ty::Visibility::Public || info.def_id.is_local()\n+                        })\n+                        .is_some()\n             })\n             .collect::<Vec<_>>();\n         for span in &arbitrary_rcvr {"}]}