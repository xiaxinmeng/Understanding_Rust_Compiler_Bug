{"sha": "82cac1505cb87ccb594aa68b4ad3f27f67720ecf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyY2FjMTUwNWNiODdjY2I1OTRhYTY4YjRhZDNmMjdmNjc3MjBlY2Y=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-15T00:36:07Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-15T00:36:07Z"}, "message": "typeck/expr.rs: extract out check_expr_repeat.", "tree": {"sha": "4a6683998a18b2105179c284d201f7dda9740888", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a6683998a18b2105179c284d201f7dda9740888"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82cac1505cb87ccb594aa68b4ad3f27f67720ecf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82cac1505cb87ccb594aa68b4ad3f27f67720ecf", "html_url": "https://github.com/rust-lang/rust/commit/82cac1505cb87ccb594aa68b4ad3f27f67720ecf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82cac1505cb87ccb594aa68b4ad3f27f67720ecf/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "877d834c653d13fbf0fd205dab6dbe2d0089dd4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/877d834c653d13fbf0fd205dab6dbe2d0089dd4d", "html_url": "https://github.com/rust-lang/rust/commit/877d834c653d13fbf0fd205dab6dbe2d0089dd4d"}], "stats": {"total": 135, "additions": 73, "deletions": 62}, "files": [{"sha": "5b3ad729ea83ff96135539adfcf7f447dc434342", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 73, "deletions": 62, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/82cac1505cb87ccb594aa68b4ad3f27f67720ecf/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cac1505cb87ccb594aa68b4ad3f27f67720ecf/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=82cac1505cb87ccb594aa68b4ad3f27f67720ecf", "patch": "@@ -128,68 +128,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_expr_array(args, expected, expr)\n             }\n             ExprKind::Repeat(ref element, ref count) => {\n-                let count_def_id = tcx.hir().local_def_id_from_hir_id(count.hir_id);\n-                let count = if self.const_param_def_id(count).is_some() {\n-                    Ok(self.to_const(count, self.tcx.type_of(count_def_id)))\n-                } else {\n-                    let param_env = ty::ParamEnv::empty();\n-                    let substs = InternalSubsts::identity_for_item(tcx.global_tcx(), count_def_id);\n-                    let instance = ty::Instance::resolve(\n-                        tcx.global_tcx(),\n-                        param_env,\n-                        count_def_id,\n-                        substs,\n-                    ).unwrap();\n-                    let global_id = GlobalId {\n-                        instance,\n-                        promoted: None\n-                    };\n-\n-                    tcx.const_eval(param_env.and(global_id))\n-                };\n-\n-                let uty = match expected {\n-                    ExpectHasType(uty) => {\n-                        match uty.sty {\n-                            ty::Array(ty, _) | ty::Slice(ty) => Some(ty),\n-                            _ => None\n-                        }\n-                    }\n-                    _ => None\n-                };\n-\n-                let (element_ty, t) = match uty {\n-                    Some(uty) => {\n-                        self.check_expr_coercable_to_type(&element, uty);\n-                        (uty, uty)\n-                    }\n-                    None => {\n-                        let ty = self.next_ty_var(TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::MiscVariable,\n-                            span: element.span,\n-                        });\n-                        let element_ty = self.check_expr_has_type_or_error(&element, ty);\n-                        (element_ty, ty)\n-                    }\n-                };\n-\n-                if let Ok(count) = count {\n-                    let zero_or_one = count.assert_usize(tcx).map_or(false, |count| count <= 1);\n-                    if !zero_or_one {\n-                        // For [foo, ..n] where n > 1, `foo` must have\n-                        // Copy type:\n-                        let lang_item = self.tcx.require_lang_item(lang_items::CopyTraitLangItem);\n-                        self.require_type_meets(t, expr.span, traits::RepeatVec, lang_item);\n-                    }\n-                }\n-\n-                if element_ty.references_error() {\n-                    tcx.types.err\n-                } else if let Ok(count) = count {\n-                    tcx.mk_ty(ty::Array(t, count))\n-                } else {\n-                    tcx.types.err\n-                }\n+                self.check_expr_repeat(element, count, expected, expr)\n             }\n             ExprKind::Tup(ref elts) => {\n                 let flds = expected.only_has_type(self).and_then(|ty| {\n@@ -824,4 +763,76 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n         self.tcx.mk_array(element_ty, args.len() as u64)\n     }\n+\n+    fn check_expr_repeat(\n+        &self,\n+        element: &'tcx hir::Expr,\n+        count: &'tcx hir::AnonConst,\n+        expected: Expectation<'tcx>,\n+        expr: &'tcx hir::Expr,\n+    ) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+        let count_def_id = tcx.hir().local_def_id_from_hir_id(count.hir_id);\n+        let count = if self.const_param_def_id(count).is_some() {\n+            Ok(self.to_const(count, tcx.type_of(count_def_id)))\n+        } else {\n+            let param_env = ty::ParamEnv::empty();\n+            let substs = InternalSubsts::identity_for_item(tcx.global_tcx(), count_def_id);\n+            let instance = ty::Instance::resolve(\n+                tcx.global_tcx(),\n+                param_env,\n+                count_def_id,\n+                substs,\n+            ).unwrap();\n+            let global_id = GlobalId {\n+                instance,\n+                promoted: None\n+            };\n+\n+            tcx.const_eval(param_env.and(global_id))\n+        };\n+\n+        let uty = match expected {\n+            ExpectHasType(uty) => {\n+                match uty.sty {\n+                    ty::Array(ty, _) | ty::Slice(ty) => Some(ty),\n+                    _ => None\n+                }\n+            }\n+            _ => None\n+        };\n+\n+        let (element_ty, t) = match uty {\n+            Some(uty) => {\n+                self.check_expr_coercable_to_type(&element, uty);\n+                (uty, uty)\n+            }\n+            None => {\n+                let ty = self.next_ty_var(TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::MiscVariable,\n+                    span: element.span,\n+                });\n+                let element_ty = self.check_expr_has_type_or_error(&element, ty);\n+                (element_ty, ty)\n+            }\n+        };\n+\n+        if let Ok(count) = count {\n+            let zero_or_one = count.assert_usize(tcx).map_or(false, |count| count <= 1);\n+            if !zero_or_one {\n+                // For [foo, ..n] where n > 1, `foo` must have\n+                // Copy type:\n+                let lang_item = tcx.require_lang_item(lang_items::CopyTraitLangItem);\n+                self.require_type_meets(t, expr.span, traits::RepeatVec, lang_item);\n+            }\n+        }\n+\n+        if element_ty.references_error() {\n+            tcx.types.err\n+        } else if let Ok(count) = count {\n+            tcx.mk_ty(ty::Array(t, count))\n+        } else {\n+            tcx.types.err\n+        }\n+    }\n }"}]}