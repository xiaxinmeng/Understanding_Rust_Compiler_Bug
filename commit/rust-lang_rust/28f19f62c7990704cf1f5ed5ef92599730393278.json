{"sha": "28f19f62c7990704cf1f5ed5ef92599730393278", "node_id": "C_kwDOAAsO6NoAKDI4ZjE5ZjYyYzc5OTA3MDRjZjFmNWVkNWVmOTI1OTk3MzAzOTMyNzg", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-12-21T02:46:55Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-12-23T18:38:54Z"}, "message": "Address review comments", "tree": {"sha": "282f5a2fffa6a43835d35e97a9dc2d1de6ca332d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/282f5a2fffa6a43835d35e97a9dc2d1de6ca332d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28f19f62c7990704cf1f5ed5ef92599730393278", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAmHEwj4ACgkQtAh+UQ6Y\nsWQ+UBAAjCG05Zo3LGnLXwFQDcDySc8FWJJ0Fq9mBHexU3VBEJQxAe/DXB/xo1fG\n3ujaCVrC7UXWY3/M5/P/7WY5FfXbUthWTNHh71QgjaGUHjWghZIsvZcL0t+X5OP8\n9rGFn++yk7ra4OHPRCIz0FOXmNn48w42Xhxmmp7v8Uo/OMHwfdACcsDIAI3NYYJ8\nFCWBE4svzGa+POO5hsa4Kek3pi9kM5adYi1QbbL1jPzuq8YSa/32xtb9I3hTAGUa\nOIIEH1rlrV+Ba1m3JUSVlPAjEWftRhl9NGByD/voMNHfzti/TsngE1Vv+0yUk6rZ\nCufrEbWhUPavOd7IO+II9Beza4YiyjcyU6kVD9s2FGXTZtgkR88nHQCMTXosNHUg\nMF20XgVoz6spNO/w4gYi+rFUbynkiWa/kLmiHWQdF1lFod0LdwoLSOx+Kx4SGnKf\ndGyJVIIisWUmM9K1kmZacyF0eBk89WwMnKXkktCo0+XvzjMZYLox6j5d/XyLP76O\nY4BOEpjeoz0YRQK9VftOJHlzHyMLU7+MQrXXT7irFc/KfvRB5GTVw8XNHaBCLhjo\nc6mTAB7G/AyorgopqteaMej2OAvZOUR5otZLTR3f7uaeLtCR66f6hMjDZQuAu8yK\nfzZiVP55Z1RBz4aisv9pR30Aradu1qs+63dUW+iVJ0np8jNeoU4=\n=LOPw\n-----END PGP SIGNATURE-----", "payload": "tree 282f5a2fffa6a43835d35e97a9dc2d1de6ca332d\nparent ab168e69ac13813962a8c395163bae1360ee27b6\nauthor Aaron Hill <aa1ronham@gmail.com> 1640054815 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1640284734 -0500\n\nAddress review comments\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28f19f62c7990704cf1f5ed5ef92599730393278", "html_url": "https://github.com/rust-lang/rust/commit/28f19f62c7990704cf1f5ed5ef92599730393278", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28f19f62c7990704cf1f5ed5ef92599730393278/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab168e69ac13813962a8c395163bae1360ee27b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab168e69ac13813962a8c395163bae1360ee27b6", "html_url": "https://github.com/rust-lang/rust/commit/ab168e69ac13813962a8c395163bae1360ee27b6"}], "stats": {"total": 73, "additions": 64, "deletions": 9}, "files": [{"sha": "630c76764c7c32fbc224b2840a377862a9c59450", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/28f19f62c7990704cf1f5ed5ef92599730393278/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f19f62c7990704cf1f5ed5ef92599730393278/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=28f19f62c7990704cf1f5ed5ef92599730393278", "patch": "@@ -171,6 +171,57 @@ impl<K: DepKind> DepGraph<K> {\n         K::with_deps(None, op)\n     }\n \n+    /// Used to wrap the deserialization of a query result from disk,\n+    /// This method enforces that no new `DepNodes` are created during\n+    /// query result deserialization.\n+    ///\n+    /// Enforcing this makes the query dep graph simpler - all nodes\n+    /// must be created during the query execution, and should be\n+    /// created from inside the 'body' of a query (the implementation\n+    /// provided by a particular compiler crate).\n+    ///\n+    /// Consider the case of three queries `A`, `B`, and `C`, where\n+    /// `A` invokes `B` and `B` invokes `C`:\n+    ///\n+    /// `A -> B -> C`\n+    ///\n+    /// Suppose that decoding the result of query `B` required invoking\n+    /// a query `D`. If we did not create a fresh `TaskDeps` when\n+    /// decoding `B`, we might would still be using the `TaskDeps` for query `A`\n+    /// (if we needed to re-execute `A`). This would cause us to create\n+    /// a new edge `A -> D`. If this edge did not previously\n+    /// exist in the `DepGraph`, then we could end up with a different\n+    /// `DepGraph` at the end of compilation, even if there were no\n+    /// meaningful changes to the overall program (e.g. a newline was added).\n+    /// In addition, this edge might cause a subsequent compilation run\n+    /// to try to force `D` before marking other necessary nodes green. If\n+    /// `D` did not exist in the new compilation session, then we might\n+    /// get an ICE. Normally, we would have tried (and failed) to mark\n+    /// some other query green (e.g. `item_children`) which was used\n+    /// to obtain `D`, which would prevent us from ever trying to force\n+    /// a non-existent `D`.\n+    ///\n+    /// It might be possible to enforce that all `DepNode`s read during\n+    /// deserialization already exist in the previous `DepGraph`. In\n+    /// the above example, we would invoke `D` during the deserialization\n+    /// of `B`. Since we correctly create a new `TaskDeps` from the decoding\n+    /// of `B`, this would result in an edge `B -> D`. If that edge already\n+    /// existed (with the same `DepPathHash`es), then it should be correct\n+    /// to allow the invocation of the query to proceed during deserialization\n+    /// of a query result. However, this would require additional complexity\n+    /// in the query infrastructure, and is not currently needed by the\n+    /// decoding of any query results. Should the need arise in the future,\n+    /// we should consider extending the query system with this functionality.\n+    pub fn with_query_deserialization<OP, R>(&self, op: OP) -> R\n+    where\n+        OP: FnOnce() -> R,\n+    {\n+        let mut deps = TaskDeps::default();\n+        deps.read_allowed = false;\n+        let deps = Lock::new(deps);\n+        K::with_deps(Some(&deps), op)\n+    }\n+\n     /// Starts a new dep-graph task. Dep-graph tasks are specified\n     /// using a free function (`task`) and **not** a closure -- this\n     /// is intentional because we want to exercise tight control over\n@@ -1121,7 +1172,12 @@ pub struct TaskDeps<K> {\n     reads: EdgesVec,\n     read_set: FxHashSet<DepNodeIndex>,\n     phantom_data: PhantomData<DepNode<K>>,\n-    pub read_allowed: bool,\n+    /// Whether or not we allow `DepGraph::read_index` to run.\n+    /// This is normally true, except inside `with_query_deserialization`,\n+    /// where it set to `false` to enforce that no new `DepNode` edges are\n+    /// created. See the documentation of `with_query_deserialization` for\n+    /// more details.\n+    read_allowed: bool,\n }\n \n impl<K> Default for TaskDeps<K> {"}, {"sha": "192da6735fc51611e8940f94226d91c97f53e915", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/28f19f62c7990704cf1f5ed5ef92599730393278/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f19f62c7990704cf1f5ed5ef92599730393278/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=28f19f62c7990704cf1f5ed5ef92599730393278", "patch": "@@ -2,8 +2,7 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use crate::dep_graph::DepKind;\n-use crate::dep_graph::{DepContext, DepNode, DepNodeIndex, DepNodeParams, TaskDeps};\n+use crate::dep_graph::{DepContext, DepNode, DepNodeIndex, DepNodeParams};\n use crate::query::caches::QueryCache;\n use crate::query::config::{QueryDescription, QueryVtable};\n use crate::query::job::{\n@@ -516,12 +515,12 @@ where\n     if query.cache_on_disk {\n         let prof_timer = tcx.dep_context().profiler().incr_cache_loading();\n \n-        let mut deps = TaskDeps::default();\n-        deps.read_allowed = false;\n-        let deps = Lock::new(deps);\n-        let result = CTX::DepKind::with_deps(Some(&deps), || {\n-            query.try_load_from_disk(tcx, prev_dep_node_index)\n-        });\n+        // The call to `with_query_deserialization` enforces that no new `DepNodes`\n+        // are created during deserialization. See the docs of that method for more\n+        // details.\n+        let result = dep_graph\n+            .with_query_deserialization(|| query.try_load_from_disk(tcx, prev_dep_node_index));\n+\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n         if let Some(result) = result {"}]}