{"sha": "102896897067960341c17dae75958e955c6d7cb2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwMjg5Njg5NzA2Nzk2MDM0MWMxN2RhZTc1OTU4ZTk1NWM2ZDdjYjI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2012-02-20T19:27:30Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2012-02-20T19:27:30Z"}, "message": "Merge pull request #1870 from tychosci/cargo-sysroot\n\ncargo: Fixes for issue #1795", "tree": {"sha": "b8a9ccddef705dfc3b21280e953c86d8fda3a531", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8a9ccddef705dfc3b21280e953c86d8fda3a531"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/102896897067960341c17dae75958e955c6d7cb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/102896897067960341c17dae75958e955c6d7cb2", "html_url": "https://github.com/rust-lang/rust/commit/102896897067960341c17dae75958e955c6d7cb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/102896897067960341c17dae75958e955c6d7cb2/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "657ef8ef6057b09be9b89b1f542ce64d2ec534d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/657ef8ef6057b09be9b89b1f542ce64d2ec534d6", "html_url": "https://github.com/rust-lang/rust/commit/657ef8ef6057b09be9b89b1f542ce64d2ec534d6"}, {"sha": "b06cb0df5a6db06bbc93b0d1c69a7da2770f4a6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b06cb0df5a6db06bbc93b0d1c69a7da2770f4a6b", "html_url": "https://github.com/rust-lang/rust/commit/b06cb0df5a6db06bbc93b0d1c69a7da2770f4a6b"}], "stats": {"total": 97, "additions": 58, "deletions": 39}, "files": [{"sha": "4d67877afd8acd07a20fbc995df38a23dae2fd0f", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 55, "deletions": 36, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/102896897067960341c17dae75958e955c6d7cb2/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/102896897067960341c17dae75958e955c6d7cb2/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=102896897067960341c17dae75958e955c6d7cb2", "patch": "@@ -6,7 +6,7 @@ use std;\n import rustc::syntax::{ast, codemap};\n import rustc::syntax::parse::parser;\n import rustc::util::filesearch::{get_cargo_root, get_cargo_root_nearest,\n-                                 get_cargo_sysroot};\n+                                 get_cargo_sysroot, libdir};\n import rustc::driver::diagnostic;\n \n import std::fs;\n@@ -346,39 +346,35 @@ fn build_cargo_options(argv: [str]) -> options {\n     };\n \n     let test = opt_present(match, \"test\");\n-    let mode = if opt_present(match, \"G\") {\n-        if opt_present(match, \"mode\") { fail \"--mode and -G both provided\"; }\n-        if opt_present(match, \"g\") { fail \"-G and -g both provided\"; }\n-        system_mode\n-    } else if opt_present(match, \"g\") {\n-        if opt_present(match, \"mode\") { fail \"--mode and -g both provided\"; }\n-        if opt_present(match, \"G\") { fail \"-G and -g both provided\"; }\n-        user_mode\n-    } else if opt_present(match, \"mode\") {\n-        alt getopts::opt_str(match, \"mode\") {\n-            \"system\" { system_mode }\n-            \"user\" { user_mode }\n-            \"local\" { local_mode }\n-            _ { fail \"argument to `mode` must be one of `system`\" +\n-                \", `user`, or `normal`\";\n+    let G = opt_present(match, \"G\");\n+    let g = opt_present(match, \"g\");\n+    let m = opt_present(match, \"mode\");\n+    let is_install = vec::len(match.free) > 1u && match.free[1] == \"install\";\n+\n+    if G && g { fail \"-G and -g both provided\"; }\n+    if g && m { fail \"--mode and -g both provided\"; }\n+    if G && m { fail \"--mode and -G both provided\"; }\n+\n+    let mode = if is_install {\n+        if G { system_mode }\n+        else if g { user_mode }\n+        else if m {\n+            alt getopts::opt_str(match, \"mode\") {\n+                \"system\" { system_mode }\n+                \"user\" { user_mode }\n+                \"local\" { local_mode }\n+                _ { fail \"argument to `mode` must be one of `system`\" +\n+                    \", `user`, or `local`\";\n+                }\n             }\n-        }\n-    } else {\n-        local_mode\n-    };\n-\n-    if mode == system_mode {\n-        // FIXME: Per discussion on #1760, we need to think about how\n-        // system mode works. It should install files to the normal\n-        // sysroot paths, but it also needsd an area to place various\n-        // cargo configuration and work files.\n-        fail \"system mode does not exist yet\";\n-    }\n+        } else { local_mode }\n+    } else { system_mode };\n \n     {test: test, mode: mode, free: match.free}\n }\n \n fn configure(opts: options) -> cargo {\n+    let syscargo = result::get(get_cargo_sysroot());\n     let get_cargo_dir = alt opts.mode {\n         system_mode { get_cargo_sysroot }\n         user_mode { get_cargo_root }\n@@ -391,15 +387,15 @@ fn configure(opts: options) -> cargo {\n     };\n \n     let sources = map::new_str_hash::<source>();\n-    try_parse_sources(fs::connect(p, \"sources.json\"), sources);\n-    try_parse_sources(fs::connect(p, \"local-sources.json\"), sources);\n+    try_parse_sources(fs::connect(syscargo, \"sources.json\"), sources);\n+    try_parse_sources(fs::connect(syscargo, \"local-sources.json\"), sources);\n     let c = {\n         pgp: pgp::supported(),\n         root: p,\n         bindir: fs::connect(p, \"bin\"),\n         libdir: fs::connect(p, \"lib\"),\n         workdir: fs::connect(p, \"work\"),\n-        sourcedir: fs::connect(p, \"sources\"),\n+        sourcedir: fs::connect(syscargo, \"sources\"),\n         sources: sources,\n         opts: opts\n     };\n@@ -471,10 +467,31 @@ fn install_one_crate(c: cargo, _path: str, cf: str, _p: pkg) {\n             #debug(\"  bin: %s\", ct);\n             // FIXME: need libstd fs::copy or something\n             run::run_program(\"cp\", [ct, c.bindir]);\n+            if c.opts.mode == system_mode {\n+                install_one_crate_to_sysroot(ct, \"bin\");\n+            }\n         } else {\n             #debug(\"  lib: %s\", ct);\n             run::run_program(\"cp\", [ct, c.libdir]);\n+            if c.opts.mode == system_mode {\n+                install_one_crate_to_sysroot(ct, libdir());\n+            }\n+        }\n+    }\n+}\n+\n+fn install_one_crate_to_sysroot(ct: str, target: str) {\n+    alt os::get_exe_path() {\n+        some(_path) {\n+            let path = [_path, \"..\", target];\n+            check vec::is_not_empty(path);\n+            let target_dir = fs::normalize(fs::connect_many(path));\n+            let p = run::program_output(\"cp\", [ct, target_dir]);\n+            if p.status != 0 {\n+                warn(#fmt[\"Copying %s to %s is failed\", ct, target_dir]);\n+            }\n         }\n+        none { }\n     }\n }\n \n@@ -831,23 +848,25 @@ fn cmd_usage() {\n           \"\n \n     init                                          Set up .cargo\n-    install [--test] [source/]package-name        Install by name\n-    install [--test] uuid:[source/]package-uuid   Install by uuid\n+    install [options] [source/]package-name       Install by name\n+    install [options] uuid:[source/]package-uuid  Install by uuid\n     list [source]                                 List packages\n     search <name | '*'> [tags...]                 Search packages\n     sync                                          Sync all sources\n     usage                                         This\n \n Options:\n \n+  cargo install\n+\n     --mode=[system,user,local]   change mode as (system/user/local)\n     -g                           equivalent to --mode=user\n     -G                           equivalent to --mode=system\n \n NOTE:\n-This command creates/uses local-level .cargo by default.\n-To create/use user-level .cargo, use option -g/--mode=user.\n-To create/use system-level .cargo, use option -G/--mode=system.\n+\\\"cargo install\\\" installs bin/libs to local-level .cargo by default.\n+To install them into user-level .cargo,  use option -g/--mode=user.\n+To install them into bin/lib on sysroot, use option -G/--mode=system.\n \");\n }\n "}, {"sha": "d5919ea3e5a4f5b2183ef52f05fbc8e3f3f2d1ce", "filename": "src/comp/util/filesearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/102896897067960341c17dae75958e955c6d7cb2/src%2Fcomp%2Futil%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/102896897067960341c17dae75958e955c6d7cb2/src%2Fcomp%2Futil%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Ffilesearch.rs?ref=102896897067960341c17dae75958e955c6d7cb2", "patch": "@@ -48,8 +48,6 @@ fn mk_filesearch(maybe_sysroot: option<fs::path>,\n                   result::ok(p) { [p] }\n                   result::err(p) { [] }\n                 }\n-                + [fs::connect(fs::connect(self.sysroot, \".cargo\"),\n-                               libdir())]\n         }\n         fn get_target_lib_path() -> fs::path {\n             make_target_lib_path(self.sysroot, self.target_triple)\n@@ -113,7 +111,9 @@ fn get_sysroot(maybe_sysroot: option<fs::path>) -> fs::path {\n }\n \n fn get_cargo_sysroot() -> result::t<fs::path, str> {\n-    result::ok(fs::connect(get_default_sysroot(),  \".cargo\"))\n+    let path = [get_default_sysroot(), libdir(), \"cargo\"];\n+    check vec::is_not_empty(path);\n+    result::ok(fs::connect_many(path))\n }\n \n fn get_cargo_root() -> result::t<fs::path, str> {"}]}