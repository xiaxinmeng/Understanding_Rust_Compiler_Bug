{"sha": "bd1bd76cd83d0a75917842966c52140a44753ed3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkMWJkNzZjZDgzZDBhNzU5MTc4NDI5NjZjNTIxNDBhNDQ3NTNlZDM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-24T12:45:51Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-24T12:56:52Z"}, "message": "fix linking of place projections\n\nprojections other than dereferences of `&mut` used to do no linking. Fix\nthat.\n\nFixes #46974.", "tree": {"sha": "9abd1790c3c04f102ecb93ca499a4ca3e64258b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9abd1790c3c04f102ecb93ca499a4ca3e64258b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd1bd76cd83d0a75917842966c52140a44753ed3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd1bd76cd83d0a75917842966c52140a44753ed3", "html_url": "https://github.com/rust-lang/rust/commit/bd1bd76cd83d0a75917842966c52140a44753ed3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd1bd76cd83d0a75917842966c52140a44753ed3/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17d4e9be2afba44c05135752b837bbd1b7b5bee6", "url": "https://api.github.com/repos/rust-lang/rust/commits/17d4e9be2afba44c05135752b837bbd1b7b5bee6", "html_url": "https://github.com/rust-lang/rust/commit/17d4e9be2afba44c05135752b837bbd1b7b5bee6"}], "stats": {"total": 145, "additions": 123, "deletions": 22}, "files": [{"sha": "7ca4ebd1cb29660dd60576d21669f5976a06da05", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 75, "deletions": 22, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/bd1bd76cd83d0a75917842966c52140a44753ed3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1bd76cd83d0a75917842966c52140a44753ed3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=bd1bd76cd83d0a75917842966c52140a44753ed3", "patch": "@@ -130,38 +130,91 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n             });\n     }\n \n+    // Add the reborrow constraint at `location` so that `borrowed_place`\n+    // is valid for `borrow_region`.\n     fn add_reborrow_constraint(\n         &mut self,\n         location: Location,\n         borrow_region: ty::Region<'tcx>,\n         borrowed_place: &Place<'tcx>,\n     ) {\n-        if let Projection(ref proj) = *borrowed_place {\n-            let PlaceProjection { ref base, ref elem } = **proj;\n-\n-            if let ProjectionElem::Deref = *elem {\n-                let tcx = self.infcx.tcx;\n-                let base_ty = base.ty(self.mir, tcx).to_ty(tcx);\n-                let base_sty = &base_ty.sty;\n-\n-                if let ty::TyRef(base_region, ty::TypeAndMut { ty: _, mutbl }) = *base_sty {\n-                    match mutbl {\n-                        hir::Mutability::MutImmutable => {}\n-\n-                        hir::Mutability::MutMutable => {\n-                            self.add_reborrow_constraint(location, borrow_region, base);\n+        let mut borrowed_place = borrowed_place;\n+\n+        debug!(\"add_reborrow_constraint({:?}, {:?}, {:?})\",\n+               location, borrow_region, borrowed_place);\n+        while let Projection(box PlaceProjection { base, elem }) = borrowed_place {\n+            debug!(\"add_reborrow_constraint - iteration {:?}\", borrowed_place);\n+\n+            match *elem {\n+                ProjectionElem::Deref => {\n+                    let tcx = self.infcx.tcx;\n+                    let base_ty = base.ty(self.mir, tcx).to_ty(tcx);\n+\n+                    debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n+                    match base_ty.sty {\n+                        ty::TyRef(ref_region, ty::TypeAndMut { ty: _, mutbl }) => {\n+                            let span = self.mir.source_info(location).span;\n+                            self.regioncx.add_outlives(\n+                                span,\n+                                ref_region.to_region_vid(),\n+                                borrow_region.to_region_vid(),\n+                                location.successor_within_block(),\n+                            );\n+\n+                            match mutbl {\n+                                hir::Mutability::MutImmutable => {\n+                                    // Immutable reference. We don't need the base\n+                                    // to be valid for the entire lifetime of\n+                                    // the borrow.\n+                                    break\n+                                }\n+                                hir::Mutability::MutMutable => {\n+                                    // Mutable reference. We *do* need the base\n+                                    // to be valid, because after the base becomes\n+                                    // invalid, someone else can use our mutable deref.\n+\n+                                    // This is in order to make the following function\n+                                    // illegal:\n+                                    // ```\n+                                    // fn unsafe_deref<'a, 'b>(x: &'a &'b mut T) -> &'b mut T {\n+                                    //     &mut *x\n+                                    // }\n+                                    // ```\n+                                    //\n+                                    // As otherwise you could clone `&mut T` using the\n+                                    // following function:\n+                                    // ```\n+                                    // fn bad(x: &mut T) -> (&mut T, &mut T) {\n+                                    //     let my_clone = unsafe_deref(&'a x);\n+                                    //     ENDREGION 'a;\n+                                    //     (my_clone, x)\n+                                    // }\n+                                    // ```\n+                                }\n+                            }\n+                        }\n+                        ty::TyRawPtr(..) => {\n+                            // deref of raw pointer, guaranteed to be valid\n+                            break\n                         }\n+                        ty::TyAdt(def, _) if def.is_box() => {\n+                            // deref of `Box`, need the base to be valid - propagate\n+                        }\n+                        _ => bug!(\"unexpected deref ty {:?} in {:?}\", base_ty, borrowed_place)\n                     }\n-\n-                    let span = self.mir.source_info(location).span;\n-                    self.regioncx.add_outlives(\n-                        span,\n-                        base_region.to_region_vid(),\n-                        borrow_region.to_region_vid(),\n-                        location.successor_within_block(),\n-                    );\n+                }\n+                ProjectionElem::Field(..) |\n+                ProjectionElem::Downcast(..) |\n+                ProjectionElem::Index(..) |\n+                ProjectionElem::ConstantIndex { .. } |\n+                ProjectionElem::Subslice { .. } => {\n+                    // other field access\n                 }\n             }\n+\n+            // The \"propagate\" case. We need to check that our base is valid\n+            // for the borrow's lifetime.\n+            borrowed_place = base;\n         }\n     }\n }"}, {"sha": "57ecddb80ab3db250266a36a38ca64c29266b1a1", "filename": "src/test/ui/nll/guarantor-issue-46974.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bd1bd76cd83d0a75917842966c52140a44753ed3/src%2Ftest%2Fui%2Fnll%2Fguarantor-issue-46974.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1bd76cd83d0a75917842966c52140a44753ed3/src%2Ftest%2Fui%2Fnll%2Fguarantor-issue-46974.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fguarantor-issue-46974.rs?ref=bd1bd76cd83d0a75917842966c52140a44753ed3", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that NLL analysis propagates lifetimes correctly through\n+// field accesses, Box accesses, etc.\n+\n+#![feature(nll)]\n+\n+fn foo(s: &mut (i32,)) -> i32 {\n+    let t = &mut *s; // this borrow should last for the entire function\n+    let x = &t.0;\n+    *s = (2,); //~ ERROR cannot assign to `*s`\n+    *x\n+}\n+\n+fn bar(s: &Box<(i32,)>) -> &'static i32 {\n+    // FIXME(#46983): error message should be better\n+    &s.0 //~ ERROR free region `` does not outlive free region `'static`\n+}\n+\n+fn main() {\n+    foo(&mut (0,));\n+    bar(&Box::new((1,)));\n+}"}, {"sha": "68cc87ef4073418317d90baff9b9216f2e92c903", "filename": "src/test/ui/nll/guarantor-issue-46974.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bd1bd76cd83d0a75917842966c52140a44753ed3/src%2Ftest%2Fui%2Fnll%2Fguarantor-issue-46974.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd1bd76cd83d0a75917842966c52140a44753ed3/src%2Ftest%2Fui%2Fnll%2Fguarantor-issue-46974.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fguarantor-issue-46974.stderr?ref=bd1bd76cd83d0a75917842966c52140a44753ed3", "patch": "@@ -0,0 +1,17 @@\n+error[E0506]: cannot assign to `*s` because it is borrowed\n+  --> $DIR/guarantor-issue-46974.rs:19:5\n+   |\n+17 |     let t = &mut *s; // this borrow should last for the entire function\n+   |             ------- borrow of `*s` occurs here\n+18 |     let x = &t.0;\n+19 |     *s = (2,); //~ ERROR cannot assign to `*s`\n+   |     ^^^^^^^^^ assignment to borrowed `*s` occurs here\n+\n+error: free region `` does not outlive free region `'static`\n+  --> $DIR/guarantor-issue-46974.rs:25:5\n+   |\n+25 |     &s.0 //~ ERROR free region `` does not outlive free region `'static`\n+   |     ^^^^\n+\n+error: aborting due to 2 previous errors\n+"}]}