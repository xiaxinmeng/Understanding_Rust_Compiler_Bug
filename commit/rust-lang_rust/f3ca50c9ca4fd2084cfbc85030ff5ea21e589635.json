{"sha": "f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzY2E1MGM5Y2E0ZmQyMDg0Y2ZiYzg1MDMwZmY1ZWEyMWU1ODk2MzU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-02-14T23:21:53Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-02-25T04:46:27Z"}, "message": "Encode/decode AST into metadata, re-instantiate inlined items", "tree": {"sha": "026a63d77c1657e897e33adc6de3fedb7b36a341", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/026a63d77c1657e897e33adc6de3fedb7b36a341"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "html_url": "https://github.com/rust-lang/rust/commit/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be9914625b0cbf5f305c5af3adbc6bc337ae760e", "url": "https://api.github.com/repos/rust-lang/rust/commits/be9914625b0cbf5f305c5af3adbc6bc337ae760e", "html_url": "https://github.com/rust-lang/rust/commit/be9914625b0cbf5f305c5af3adbc6bc337ae760e"}], "stats": {"total": 11616, "additions": 10674, "deletions": 942}, "files": [{"sha": "33398722605e0d43b3993cc5814fbd23d62377f0", "filename": "src/comp/driver/driver.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fdriver.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -6,7 +6,7 @@ import syntax::parse::{parser};\n import syntax::{ast, codemap};\n import front::attr;\n import middle::{trans, resolve, freevars, kind, ty, typeck, fn_usage,\n-                last_use, lint};\n+                last_use, lint, inline};\n import syntax::print::{pp, pprust};\n import util::{ppaux, filesearch};\n import back::link;\n@@ -157,7 +157,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n          bind middle::check_alt::check_crate(ty_cx, crate));\n     time(time_passes, \"typestate checking\",\n          bind middle::tstate::ck::check_crate(ty_cx, crate));\n-    let mut_map =\n+    let mutbl_map =\n         time(time_passes, \"mutability checking\",\n              bind middle::mutbl::check_crate(ty_cx, crate));\n     let (copy_map, ref_map) =\n@@ -173,12 +173,19 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n     if upto == cu_no_trans { ret {crate: crate, tcx: some(ty_cx)}; }\n     let outputs = option::get(outputs);\n \n+    let maps = {mutbl_map: mutbl_map, copy_map: copy_map,\n+                last_uses: last_uses, impl_map: impl_map,\n+                method_map: method_map, dict_map: dict_map};\n+\n+    let inline_map =\n+        time(time_passes, \"inline\",\n+             bind inline::instantiate_inlines(ty_cx, maps, crate));\n+\n     let (llmod, link_meta) =\n         time(time_passes, \"translation\",\n              bind trans::base::trans_crate(\n-                 sess, crate, ty_cx, outputs.obj_filename, exp_map, ast_map,\n-                 mut_map, copy_map, last_uses, impl_map, method_map,\n-                 dict_map));\n+                 sess, crate, ty_cx, outputs.obj_filename,\n+                 exp_map, maps, inline_map));\n     time(time_passes, \"LLVM passes\",\n          bind link::write::run_passes(sess, llmod, outputs.obj_filename));\n "}, {"sha": "bed7494ebc15ce1ea71b708a6c243ec0f26fd99f", "filename": "src/comp/metadata/astencode.rs", "status": "modified", "additions": 775, "deletions": 542, "changes": 1317, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fastencode.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -1,653 +1,886 @@\n-// Encoding of ASTs and the associated side tables.\n-\n-import middle::base::trans::common::crate_ctxt;\n import syntax::ast;\n-import syntax::codemap::{span, filename};\n+import syntax::fold;\n+import syntax::visit;\n+import syntax::ast_util;\n+import syntax::codemap::span;\n+import std::map::map;\n+import std::smallintmap::map;\n+import std::ebml;\n import std::ebml::writer;\n-import metadata::common::*;\n-\n-enum ast_tag {\n-    at_span,\n-    at_id,\n-\n-    at_span_expninfo_callie_name,\n-    at_span_expninfo_callie_span,\n-\n-    at_blk,\n-    at_blk_stmts,\n-    at_blk_expr,\n-    at_blk_rules,\n-\n-    at_stmt,\n-    at_stmt_node_decl,\n-    at_stmt_node_expr,\n-\n-    at_expr,\n-    at_expr_node_vec,\n-    at_expr_node_rec,\n-    at_expr_node_call,\n-    at_expr_node_tup,\n-    at_expr_node_bind,\n-    at_expr_node_bind_args,\n-    at_expr_node_binary,\n-    at_expr_node_unary,\n-    at_expr_node_lit,\n-    at_expr_node_cast,\n-    at_expr_node_if,\n-    at_expr_node_while,\n-\n-    at_none,\n-    at_some,\n-}\n-\n-type ast_ctxt = {\n-    embl_w: ebml::writer,\n-    ccx: crate_ctxt,\n+import std::serialization;\n+import std::serialization::serializer;\n+import std::serialization::deserializer;\n+import std::serialization::serializer_helpers;\n+import std::serialization::deserializer_helpers;\n+import middle::trans::common::maps;\n+import middle::ty;\n+import middle::typeck;\n+import middle::typeck::method_origin;\n+import middle::typeck::dict_res;\n+import middle::typeck::dict_origin;\n+import middle::ast_map;\n+import driver::session;\n+import driver::session::session;\n+import middle::freevars::freevar_entry;\n+import c = common;\n+import e = encoder;\n+\n+// used in testing:\n+import std::io;\n+import driver::diagnostic;\n+import syntax::codemap;\n+import syntax::parse::parser;\n+import syntax::print::pprust;\n+\n+export encode_inlined_item;\n+export decode_inlined_item;\n+\n+type decode_ctxt = @{\n+    cdata: cstore::crate_metadata,\n+    tcx: ty::ctxt,\n+    maps: maps\n };\n \n-impl ast_output for ast_ctxt {\n-    fn tag(tag: ast_tag, blk: fn()) {\n-        self.embl_w.wr_tag(tag as uint, blk)\n-    }\n+type extended_decode_ctxt = @{\n+    dcx: decode_ctxt,\n+    from_id_range: id_range,\n+    to_id_range: id_range\n+};\n \n-    fn uint(v: uint) {\n-        self.embl_w.wr_uint(v)\n-    }\n+iface tr {\n+    fn tr(xcx: extended_decode_ctxt) -> self;\n+}\n \n-    fn opt<T>(x: option<T>, blk: fn(T)) {\n-        alt x {\n-          none { self.tag(at_none) {||} }\n-          some(v) { self.tag(at_some) {|| blk(v) } }\n-        }\n+// ______________________________________________________________________\n+// Enumerating the IDs which appear in an AST\n+\n+fn encode_inlined_item(ecx: @e::encode_ctxt,\n+                       ebml_w: ebml::writer,\n+                       item: @ast::item) {\n+    let id_range = compute_id_range(item);\n+    ebml_w.wr_tag(c::tag_ast as uint) {||\n+        encode_id_range(ebml_w, id_range);\n+        encode_ast(ebml_w, item);\n+        encode_side_tables_for_item(ecx, ebml_w, item);\n     }\n+}\n \n-    fn str(tag: ast_tag, v: str) {\n-        self.tag(tag) {|| self.embl_w.wr_str(v) };\n+fn decode_inlined_item(cdata: cstore::crate_metadata,\n+                       tcx: ty::ctxt,\n+                       maps: maps,\n+                       path: ast_map::path,\n+                       par_doc: ebml::doc) -> option<@ast::item> {\n+    let dcx = @{cdata: cdata, tcx: tcx, maps: maps};\n+    alt par_doc.opt_child(c::tag_ast) {\n+      none { none }\n+      some(ast_doc) {\n+        let from_id_range = decode_id_range(ast_doc);\n+        let to_id_range = reserve_id_range(dcx.tcx.sess, from_id_range);\n+        let xcx = @{dcx: dcx,\n+                    from_id_range: from_id_range,\n+                    to_id_range: to_id_range};\n+        let raw_item = decode_ast(ast_doc);\n+        let item = renumber_ast(xcx, raw_item);\n+        ast_map::map_decoded_item(dcx.tcx.items, path, item);\n+        decode_side_tables(xcx, ast_doc);\n+        some(item)\n+      }\n     }\n+}\n \n-    fn vec<T>(tag: ast_tag, v: [T], blk: fn(T)) {\n-        self.tag(tag) {||\n-            self.uint(vec::len(v));\n-            vec::iter(v) {|e| blk(e) };\n-        }\n-    }\n+// ______________________________________________________________________\n+// Enumerating the IDs which appear in an AST\n \n-    fn span(sp: span) {\n-        self.tag(at_span) {||\n-            self.uint(sp.lo);\n-            self.uint(sp.hi);\n-            self.opt(sp.expn_info) {|ei|\n-                self.span(ei.call_site);\n-                self.str(at_span_expninfo_callie_name, ei.callie.name);\n-                self.opt(ei.callie.span) {|v| self.span(v) };\n-            }\n-        }\n-    }\n+type id_range = {min: ast::node_id, max: ast::node_id};\n \n-    fn id(id: uint) {\n-        self.tag(at_id) {|| self.uint(id); }\n-    }\n+fn empty(range: id_range) -> bool {\n+    range.min >= range.max\n+}\n \n-    fn blk(blk: ast::blk) {\n-        self.tag(at_blk) {||\n-            self.id(blk.node.id);\n-            self.span(blk.span);\n-            self.vec(at_blk_stmts, blk.node.stmts) {|stmt|\n-                self.stmt(stmt)\n-            }\n-            self.tag(at_blk_expr) {||\n-                self.opt(blk.node.expr) {|e| self.expr(e) }\n-            }\n-            self.tag(at_blk_rules) {||\n-                self.uint(blk.node.rules as uint);\n+fn visit_ids(item: @ast::item, vfn: fn@(ast::node_id)) {\n+    let visitor = visit::mk_simple_visitor(@{\n+        visit_mod: fn@(_m: ast::_mod, _sp: span, id: ast::node_id) {\n+            vfn(id)\n+        },\n+\n+        visit_view_item: fn@(vi: @ast::view_item) {\n+            alt vi.node {\n+              ast::view_item_use(_, _, id) { vfn(id) }\n+              ast::view_item_import(vps) | ast::view_item_export(vps) {\n+                vec::iter(vps) {|vp|\n+                    alt vp.node {\n+                      ast::view_path_simple(_, _, id) { vfn(id) }\n+                      ast::view_path_glob(_, id) { vfn(id) }\n+                      ast::view_path_list(_, _, id) { vfn(id) }\n+                    }\n+                }\n+              }\n             }\n-        }\n-    }\n+        },\n \n-    fn decl(decl: ast::decl) {\n-        self.span(decl.span);\n-        alt decl.node {\n-          ast::decl_local(lcls) {\n-            self.vec(at_decl_local, lcls) {|lcl|\n-                self.local(lcl)\n-            }\n-          }\n+        visit_native_item: fn@(ni: @ast::native_item) {\n+            vfn(ni.id)\n+        },\n \n-          ast::decl_item(item) {\n-            self.tag(at_decl_item) {||\n-                self.item(item);\n-            }\n-          }\n-        }\n-    }\n+        visit_item: fn@(i: @ast::item) {\n+            vfn(i.id)\n+        },\n \n-    fn local(lcl: ast::local) {\n-        self.span(lcl.span);\n-        self.ty(lcl.ty);\n-        self.pat(lcl.pat);\n-        self.opt(lcl.init) {|i| self.initializer(i) };\n-        self.uint(lcl.id);\n-    }\n+        visit_local: fn@(l: @ast::local) {\n+            vfn(l.node.id);\n+        },\n \n-    fn pat(pat: ast::pat) {\n-        self.uint(pat.id);\n-        self.span(pat.span);\n-        alt pat_util::normalize_pat(pat.node) {\n-          pat_wild {\n-            self.tag(at_pat_wild) {||\n-            }\n-          }\n-          pat_ident(path, o_pat) {\n-            self.tag(at_pat_ident) {||\n-                self.path(path);\n-                self.opt(o_pat) {|p|\n-                    self.pat(p)\n-                }\n-            }\n-          }\n-          pat_enum(path, pats) {\n-            self.tag(at_pat_enum) {||\n-                self.path(path);\n-                self.vec(at_pat_enum_pats, pats) {|p| self.pat(p) };\n+        visit_block: fn@(b: ast::blk) {\n+            vfn(b.node.id);\n+        },\n+\n+        visit_stmt: fn@(s: @ast::stmt) {\n+            vfn(ast_util::stmt_id(*s));\n+        },\n+\n+        visit_arm: fn@(_a: ast::arm) { },\n+\n+        visit_pat: fn@(p: @ast::pat) {\n+            vfn(p.id)\n+        },\n+\n+        visit_decl: fn@(_d: @ast::decl) {\n+        },\n+\n+        visit_expr: fn@(e: @ast::expr) {\n+            vfn(e.id);\n+            alt e.node {\n+              ast::expr_unary(_, _) | ast::expr_binary(_, _, _) {\n+                vfn(ast_util::op_expr_callee_id(e));\n+              }\n+              _ { /* fallthrough */ }\n             }\n-          }\n-          pat_rec(field_pats, b) {\n-            self.tag(at_pat_rec) {||\n-                self.vec(at_pat_rec_fields, field_pats) {|p|\n-                    self.field_pat(p)\n-                }\n+        },\n+\n+        visit_ty: fn@(t: @ast::ty) {\n+            alt t.node {\n+              ast::ty_path(_, id) {\n+                vfn(id)\n+              }\n+              _ { /* fall through */ }\n             }\n-          }\n-          pat_tup(pats) {\n-            self.vec(at_pat_tup, pats) {|p| self.pat(p); }\n-          }\n-          pat_box(pat) {\n-            self.tag(at_pat_box) {|| self.pat(pat) }\n-          }\n-          pat_lit(expr) {\n-            self.tag(at_pat_lit) {|| self.expr(expr) }\n-          }\n-          pat_range(l, h) {\n-            self.tag(at_pat_range) {||\n-                self.expr(l);\n-                self.expr(h);\n+        },\n+\n+        visit_ty_params: fn@(ps: [ast::ty_param]) {\n+            vec::iter(ps) {|p| vfn(p.id) }\n+        },\n+\n+        visit_constr: fn@(_p: @ast::path, _sp: span, id: ast::node_id) {\n+            vfn(id);\n+        },\n+\n+        visit_fn: fn@(fk: visit::fn_kind, _d: ast::fn_decl,\n+                      _b: ast::blk, _sp: span, id: ast::node_id) {\n+            vfn(id);\n+\n+            alt fk {\n+              visit::fk_item_fn(_, tps) |\n+              visit::fk_method(_, tps) |\n+              visit::fk_res(_, tps) {\n+                vec::iter(tps) {|tp| vfn(tp.id)}\n+              }\n+              visit::fk_anon(_) |\n+              visit::fk_fn_block {\n+              }\n             }\n-          }\n-        }\n-    }\n+        },\n \n-    fn stmt(stmt: ast::stmt) {\n-        self.tag(at_stmt) {||\n-            self.span(stmt.span);\n-            alt stmt.node {\n-              ast::stmt_decl(d, nid) {\n-                self.id(nid);\n-                self.tag(at_stmt_node_decl) {|| self.decl(d) };\n+        visit_class_item: fn@(_s: span, _p: ast::privacy,\n+                              c: ast::class_member) {\n+            alt c {\n+              ast::instance_var(_, _, _, id) {\n+                vfn(id)\n               }\n-              ast::stmt_expr(e, nid) | ast::stmt_semi(e, nid) {\n-                self.id(nid);\n-                self.tag(at_stmt_node_expr) {|| self.expr(e) };\n+              ast::class_method(_) {\n               }\n             }\n         }\n-    }\n+    });\n+\n+    visitor.visit_item(item, (), visitor);\n+}\n \n-    fn exprs(exprs: [ast::expr]) {\n-        self.vec(at_exprs, exprs) {|e| self.expr(e) };\n+fn compute_id_range(item: @ast::item) -> id_range {\n+    let min = @mutable int::max_value;\n+    let max = @mutable int::min_value;\n+    visit_ids(item) {|id|\n+        *min = int::min(*min, id);\n+        *max = int::max(*max, id + 1);\n     }\n+    ret {min:*min, max:*max};\n+}\n \n-    fn expr(expr: ast:expr) {\n-        self.id(expr.id);\n-        self.span(expr.span);\n-        alt expr.node {\n-          ast::expr_vec(subexprs, mutbl) {\n-            self.tag(at_expr_node_vec) {||\n-                self.exprs(subexprs);\n-                self.mutbl(mutbl);\n-            }\n-          }\n+fn encode_id_range(ebml_w: ebml::writer, id_range: id_range) {\n+    ebml_w.wr_tag(c::tag_id_range as uint) {||\n+        ebml_w.emit_tup(2u) {||\n+            ebml_w.emit_tup_elt(0u) {|| ebml_w.emit_int(id_range.min) }\n+            ebml_w.emit_tup_elt(1u) {|| ebml_w.emit_int(id_range.max) }\n+        }\n+    }\n+}\n \n-          ast::expr_rec(fields, opt_expr) {\n-            self.tag(at_expr_node_rec) {||\n-                self.fields(fields);\n-                self.opt(opt_expr) {|e| self.expr(e) };\n-            }\n-          }\n+fn decode_id_range(par_doc: ebml::doc) -> id_range {\n+    let range_doc = par_doc[c::tag_id_range];\n+    let dsr = serialization::mk_ebml_deserializer(range_doc);\n+    dsr.read_tup(2u) {||\n+        {min: dsr.read_tup_elt(0u) {|| dsr.read_int() },\n+         max: dsr.read_tup_elt(1u) {|| dsr.read_int() }}\n+    }\n+}\n \n-          ast::expr_call(func, args, _) {\n-            self.tag(at_expr_node_call) {||\n-                self.expr(func);\n-                self.exprs(args);\n-            }\n-          }\n+fn reserve_id_range(sess: session::session,\n+                    from_id_range: id_range) -> id_range {\n+    // Handle the case of an empty range:\n+    if empty(from_id_range) { ret from_id_range; }\n+    let cnt = from_id_range.max - from_id_range.min;\n+    let to_id_min = sess.parse_sess.next_id;\n+    let to_id_max = sess.parse_sess.next_id + cnt;\n+    sess.parse_sess.next_id = to_id_max;\n+    ret {min: to_id_min, max: to_id_min};\n+}\n \n-          ast::expr_tup(exprs) {\n-            self.tag(at_expr_node_tup) {||\n-                self.exprs(exprs);\n-            }\n-          }\n+impl translation_routines for extended_decode_ctxt {\n+    fn tr_id(id: ast::node_id) -> ast::node_id {\n+        // from_id_range should be non-empty\n+        assert !empty(self.from_id_range);\n+        (id - self.from_id_range.min + self.to_id_range.min)\n+    }\n+    fn tr_def_id(did: ast::def_id) -> ast::def_id {\n+        decoder::translate_def_id(self.dcx.cdata, did)\n+    }\n+    fn tr_intern_def_id(did: ast::def_id) -> ast::def_id {\n+        assert did.crate == ast::local_crate;\n+        {crate: ast::local_crate, node: self.tr_id(did.node)}\n+    }\n+    fn tr_span(_span: span) -> span {\n+        ast_util::dummy_sp() // TODO...\n+    }\n+}\n \n-          ast::expr_bind(f, args) {\n-            self.tag(at_expr_node_bind) {||\n-                self.expr(f);\n-                self.vec(at_expr_node_bind_args, args) {|opt_e|\n-                    self.opt(opt_e) {|e| self.expr(e)};\n-                }\n-            }\n-          }\n+impl of tr for ast::def_id {\n+    fn tr(xcx: extended_decode_ctxt) -> ast::def_id {\n+        xcx.tr_def_id(self)\n+    }\n+    fn tr_intern(xcx: extended_decode_ctxt) -> ast::def_id {\n+        xcx.tr_intern_def_id(self)\n+    }\n+}\n \n-          ast::expr_binary(binop, l, r) {\n-            self.tag(at_expr_node_binary) {||\n-                self.uint(binop as uint);\n-                self.expr(l);\n-                self.expr(r);\n-            }\n-          }\n+impl of tr for span {\n+    fn tr(xcx: extended_decode_ctxt) -> span {\n+        xcx.tr_span(self)\n+    }\n+}\n \n-          ast::expr_unary(unop, l, r) {\n-            self.tag(at_expr_node_unary) {||\n-                self.uint(unop as uint);\n-                self.expr(l);\n-                self.expr(r);\n-            }\n-          }\n+impl serializer_helpers<S: serialization::serializer> for S {\n+    fn emit_def_id(did: ast::def_id) {\n+        astencode_gen::serialize_syntax_ast_def_id(self, did)\n+    }\n+}\n \n-          ast::expr_lit(lit) {\n-            self.tag(at_expr_node_lit) {|| self.lit(lit) }\n-          }\n+impl deserializer_helpers<D: serialization::deserializer> for D {\n+    fn read_def_id(xcx: extended_decode_ctxt) -> ast::def_id {\n+        let did = astencode_gen::deserialize_syntax_ast_def_id(self);\n+        did.tr(xcx)\n+    }\n+}\n \n-          ast::expr_cast(expr, ty) {\n-            self.tag(at_expr_node_cast) {||\n-                self.expr(expr);\n-                self.ty(ty);\n-            }\n-          }\n+// ______________________________________________________________________\n+// Encoding and decoding the AST itself\n+//\n+// The hard work is done by an autogenerated module astencode_gen.  To\n+// regenerate astencode_gen, run src/etc/gen-astencode.  It will\n+// replace astencode_gen with a dummy file and regenerate its\n+// contents.  If you get compile errors, the dummy file\n+// remains---resolve the errors and then rerun astencode_gen.\n+// Annoying, I know, but hopefully only temporary.\n+//\n+// When decoding, we have to renumber the AST so that the node ids that\n+// appear within are disjoint from the node ids in our existing ASTs.\n+// We also have to adjust the spans: for now we just insert a dummy span,\n+// but eventually we should add entries to the local codemap as required.\n+\n+fn encode_ast(ebml_w: ebml::writer, item: @ast::item) {\n+    ebml_w.wr_tag(c::tag_tree as uint) {||\n+        astencode_gen::serialize_syntax_ast_item(ebml_w, *item);\n+    }\n+}\n \n-          ast::expr_if(cond, blk_then, o_blk_else) {\n-            self.tag(at_expr_node_if) {||\n-                self.expr(cond);\n-                self.blk(blk_then);\n-                self.opt(o_blk_else) {|b| self.blk(b)};\n-            }\n-          }\n+fn decode_ast(par_doc: ebml::doc) -> @ast::item {\n+    let chi_doc = par_doc[c::tag_tree];\n+    let d = serialization::mk_ebml_deserializer(chi_doc);\n+    @astencode_gen::deserialize_syntax_ast_item(d)\n+}\n \n-          ast::expr_while(cond, blk) {\n-            self.tag(at_expr_node_while) {||\n-                self.expr(cond);\n-                self.blk(blk);\n-            }\n-          }\n+fn renumber_ast(xcx: extended_decode_ctxt, item: @ast::item) -> @ast::item {\n+    let fld = fold::make_fold({\n+        new_id: xcx.tr_id(_),\n+        new_span: xcx.tr_span(_)\n+        with *fold::default_ast_fold()\n+    });\n+    fld.fold_item(item)\n+}\n \n-          ast::expr_for(lcl, expr, blk) {\n-            self.tag(at_expr_node_for) {||\n-                self.local(lcl);\n-                self.expr(expr);\n-                self.blk(blk);\n-            }\n-          }\n+// ______________________________________________________________________\n+// Encoding and decoding of ast::def\n \n-          ast::expr_do_while(blk, cond) {\n-            self.tag(at_expr_node_do_while) {||\n-                self.blk(blk);\n-                self.expr(cond);\n-            }\n-          }\n+fn encode_def(ebml_w: ebml::writer, def: ast::def) {\n+    astencode_gen::serialize_syntax_ast_def(ebml_w, def)\n+}\n \n-          ast::expr_alt(cond, arms, _) {\n-            self.tag(at_expr_node_alt) {||\n-                self.blk(blk);\n-                self.expr(cond);\n-            }\n-          }\n+fn decode_def(xcx: extended_decode_ctxt, doc: ebml::doc) -> ast::def {\n+    let dsr = serialization::mk_ebml_deserializer(doc);\n+    let def = astencode_gen::deserialize_syntax_ast_def(dsr);\n+    def.tr(xcx)\n+}\n \n-          ast::expr_block(blk) {\n-            self.tag(at_expr_node_blk) {||\n-                self.blk(blk);\n-            }\n+impl of tr for ast::def {\n+    fn tr(xcx: extended_decode_ctxt) -> ast::def {\n+        alt self {\n+          ast::def_fn(did, p) { ast::def_fn(did.tr(xcx), p) }\n+          ast::def_self(did) { ast::def_self(did.tr(xcx)) }\n+          ast::def_mod(did) { ast::def_mod(did.tr(xcx)) }\n+          ast::def_native_mod(did) { ast::def_native_mod(did.tr(xcx)) }\n+          ast::def_const(did) { ast::def_const(did.tr(xcx)) }\n+          ast::def_arg(did, m) { ast::def_arg(did.tr_intern(xcx), m) }\n+          ast::def_local(did) { ast::def_local(did.tr_intern(xcx)) }\n+          ast::def_variant(e_did, v_did) {\n+            ast::def_variant(e_did.tr(xcx), v_did.tr(xcx))\n+          }\n+          ast::def_ty(did) { ast::def_ty(did.tr(xcx)) }\n+          ast::def_prim_ty(p) { ast::def_prim_ty(p) }\n+          ast::def_ty_param(did, v) { ast::def_ty_param(did.tr(xcx), v) }\n+          ast::def_binding(did) { ast::def_binding(did.tr(xcx)) }\n+          ast::def_use(did) { ast::def_use(did.tr(xcx)) }\n+          ast::def_upvar(did, def, node_id) {\n+            ast::def_upvar(did.tr_intern(xcx),\n+                           @(*def).tr(xcx),\n+                           xcx.tr_id(node_id))\n+          }\n+          ast::def_class(did) {\n+            ast::def_class(did.tr(xcx))\n+          }\n+          ast::def_class_field(did0, did1) {\n+            ast::def_class_field(did0.tr(xcx), did1.tr(xcx))\n+          }\n+          ast::def_class_method(did0, did1) {\n+            ast::def_class_method(did0.tr(xcx), did1.tr(xcx))\n           }\n+        }\n+    }\n+}\n \n-          ast::expr_copy(expr) {\n-            self.tag(at_expr_node_copy) {||\n-                self.expr(expr);\n-            }\n-          }\n+// ______________________________________________________________________\n+// Encoding and decoding of freevar information\n \n-          ast::expr_move(l, r) {\n-            self.tag(at_expr_node_move) {||\n-                self.expr(l);\n-                self.expr(r);\n-            }\n-          }\n+fn encode_freevar_entry(ebml_w: ebml::writer, fv: freevar_entry) {\n+    astencode_gen::serialize_middle_freevars_freevar_entry(ebml_w, fv)\n+}\n \n-          ast::expr_assign(l, r) {\n-            self.tag(at_expr_node_assign) {||\n-                self.expr(l);\n-                self.expr(r);\n-            }\n-          }\n+impl helper for serialization::ebml_deserializer {\n+    fn read_freevar_entry(xcx: extended_decode_ctxt) -> freevar_entry {\n+        let fv =\n+            astencode_gen::deserialize_middle_freevars_freevar_entry(self);\n+        fv.tr(xcx)\n+    }\n+}\n \n-          ast::expr_swap(l, r) {\n-            self.tag(at_expr_node_swap) {||\n-                self.expr(l);\n-                self.expr(r);\n-            }\n-          }\n+impl of tr for freevar_entry {\n+    fn tr(xcx: extended_decode_ctxt) -> freevar_entry {\n+        {def: self.def.tr(xcx), span: self.span.tr(xcx)}\n+    }\n+}\n \n-          ast::expr_assign_of(binop, l, r) {\n-            self.tag(at_expr_node_assign_op) {||\n-                self.uint(binop as uint);\n-                self.expr(l);\n-                self.expr(r);\n-            }\n-          }\n+// ______________________________________________________________________\n+// Encoding and decoding of method_origin\n \n-          ast::expr_field(base, f, tys) {\n-            self.tag(at_expr_node_field) {||\n-                self.expr(base);\n-                self.str(at_ident, f);\n-                self.vec(at_tys) {|v| self.ty(v) }\n-            }\n-          }\n+fn encode_method_origin(ebml_w: ebml::writer, mo: method_origin) {\n+    astencode_gen::serialize_middle_typeck_method_origin(ebml_w, mo)\n+}\n \n-          ast::expr_index(l, r) {\n-            self.tag(at_expr_node_index) {||\n-                self.expr(l);\n-                self.expr(r);\n-            }\n-          }\n+impl helper for serialization::ebml_deserializer {\n+    fn read_method_origin(xcx: extended_decode_ctxt) -> method_origin {\n+        let fv = astencode_gen::deserialize_middle_typeck_method_origin(self);\n+        fv.tr(xcx)\n+    }\n+}\n \n-          ast::expr_path(pth) {\n-            self.tag(at_expr_node_path) {||\n-            }\n+impl of tr for method_origin {\n+    fn tr(xcx: extended_decode_ctxt) -> method_origin {\n+        alt self {\n+          typeck::method_static(did) {\n+            typeck::method_static(did.tr(xcx))\n           }\n-\n-          ast::expr_fail(o_expr) {\n-            self.tag(at_expr_node_fail) {||\n-                self.opt(o_expr) {|e| self.expr(e) }\n-            }\n+          typeck::method_param(did, m, p, b) {\n+            typeck::method_param(did.tr(xcx), m, p, b)\n           }\n-\n-          ast::expr_break {\n-            self.tag(at_expr_node_break) {||}\n+          typeck::method_iface(did, m) {\n+            typeck::method_iface(did.tr(xcx), m)\n           }\n+        }\n+    }\n+}\n \n-          ast::expr_cont {\n-            self.tag(at_expr_node_cont) {||}\n-          }\n+// ______________________________________________________________________\n+// Encoding and decoding dict_res\n+\n+fn encode_dict_res(ecx: @e::encode_ctxt,\n+                   ebml_w: ebml::writer,\n+                   dr: typeck::dict_res) {\n+    // can't autogenerate this code because automatic serialization of\n+    // ty::t doesn't work, and there is no way (atm) to have\n+    // hand-written serialization routines combine with auto-generated\n+    // ones.  perhaps we should fix this.\n+    ebml_w.emit_from_vec(*dr) {|dict_origin|\n+        encode_dict_origin(ecx, ebml_w, dict_origin)\n+    }\n+}\n \n-          ast::expr_ret(o_expr) {\n-            self.tag(at_expr_node_ret) {||\n-                self.opt(o_expr) {|e| self.expr(e) }\n+fn encode_dict_origin(ecx: @e::encode_ctxt,\n+                      ebml_w: ebml::writer,\n+                      dict_origin: typeck::dict_origin) {\n+    ebml_w.emit_enum(\"dict_origin\") {||\n+        alt dict_origin {\n+          typeck::dict_static(def_id, tys, dict_res) {\n+            ebml_w.emit_enum_variant(\"dict_static\", 0u, 3u) {||\n+                ebml_w.emit_enum_variant_arg(0u) {||\n+                    ebml_w.emit_def_id(def_id)\n+                }\n+                ebml_w.emit_enum_variant_arg(1u) {||\n+                    ebml_w.emit_tys(ecx, tys);\n+                }\n+                ebml_w.emit_enum_variant_arg(2u) {||\n+                    encode_dict_res(ecx, ebml_w, dict_res);\n+                }\n             }\n           }\n-\n-          ast::expr_be(expr) {\n-            self.tag(at_expr_node_be) {||\n-                self.expr(expr)\n+          typeck::dict_param(pn, bn) {\n+            ebml_w.emit_enum_variant(\"dict_param\", 1u, 2u) {||\n+                ebml_w.emit_enum_variant_arg(0u) {||\n+                    ebml_w.emit_uint(pn);\n+                }\n+                ebml_w.emit_enum_variant_arg(1u) {||\n+                    ebml_w.emit_uint(bn);\n+                }\n             }\n           }\n-\n-          ast::expr_log(i, e1, e2) {\n-            self.tag(at_expr_node_log) {||\n-                self.uint(i);\n-                self.expr(e1);\n-                self.expr(e2);\n+          typeck::dict_iface(def_id) {\n+            ebml_w.emit_enum_variant(\"dict_iface\", 1u, 3u) {||\n+                ebml_w.emit_enum_variant_arg(0u) {||\n+                    ebml_w.emit_def_id(def_id)\n+                }\n             }\n           }\n+        }\n+    }\n \n-          ast::expr_assert(e) {\n-            self.tag(at_expr_node_assert) {||\n-                self.expr(e);\n-            }\n-          }\n+}\n \n-          ast::expr_check(mode, e) {\n-            self.tag(at_expr_node_check) {||\n-                self.uint(mode as uint);\n-                self.expr(e);\n-            }\n-          }\n+impl helpers for serialization::ebml_deserializer {\n+    fn read_dict_res(xcx: extended_decode_ctxt) -> typeck::dict_res {\n+        @self.read_to_vec {|| self.read_dict_origin(xcx) }\n+    }\n \n-          ast::expr_if_check(cond, b, e) {\n-            self.tag(at_expr_node_if_check) {||\n-                self.expr(cond);\n-                self.blk(b);\n-                self.opt(e) {|e| self.blk(e)};\n+    fn read_dict_origin(xcx: extended_decode_ctxt) -> typeck::dict_origin {\n+        self.read_enum(\"dict_origin\") {||\n+            self.read_enum_variant {|i|\n+                alt check i {\n+                  0u {\n+                    typeck::dict_static(\n+                        self.read_enum_variant_arg(0u) {||\n+                            self.read_def_id(xcx)\n+                        },\n+                        self.read_enum_variant_arg(1u) {||\n+                            self.read_tys(xcx)\n+                        },\n+                        self.read_enum_variant_arg(2u) {||\n+                            self.read_dict_res(xcx)\n+                        }\n+                    )\n+                  }\n+                  1u {\n+                    typeck::dict_param(\n+                        self.read_enum_variant_arg(0u) {||\n+                            self.read_uint()\n+                        },\n+                        self.read_enum_variant_arg(1u) {||\n+                            self.read_uint()\n+                        }\n+                    )\n+                  }\n+                  2u {\n+                    typeck::dict_iface(\n+                        self.read_enum_variant_arg(0u) {||\n+                            self.read_def_id(xcx)\n+                        }\n+                    )\n+                  }\n+                }\n             }\n-          }\n+        }\n+    }\n+}\n \n-          ast::expr_mac(m) {\n-            self.tag(at_expr_node_mac) {||\n-                /* todo */\n-            }\n-          }\n+// ______________________________________________________________________\n+// Encoding and decoding the side tables\n+\n+impl helpers for @e::encode_ctxt {\n+    fn ty_str_ctxt() -> @tyencode::ctxt {\n+        @{ds: e::def_to_str,\n+          tcx: self.ccx.tcx,\n+          abbrevs: tyencode::ac_use_abbrevs(self.type_abbrevs)}\n+    }\n+}\n+\n+impl helpers for ebml::writer {\n+    fn emit_ty(ecx: @e::encode_ctxt, ty: ty::t) {\n+        e::write_type(ecx, self, ty)\n+    }\n+\n+    fn emit_tys(ecx: @e::encode_ctxt, tys: [ty::t]) {\n+        self.emit_from_vec(tys) {|ty|\n+            e::write_type(ecx, self, ty)\n         }\n     }\n \n-    fn lit(l: ast::lit) {\n-        alt l {\n-          lit_str(s) {\n-            self.str(at_lit_str, s);\n-          }\n-          lit_int(i, t) {\n-            self.tag(at_lit_int) {||\n-                self.i64(i);\n-                self.int_ty(t);\n-            }\n-          }\n-          lit_uint(i, t) {\n-            self.tag(at_lit_uint) {||\n-                self.u64(i);\n-                self.uint_ty(t);\n+    fn emit_bounds(ecx: @e::encode_ctxt, bs: ty::param_bounds) {\n+        tyencode::enc_bounds(self.writer, ecx.ty_str_ctxt(), bs)\n+    }\n+\n+    fn emit_tpbt(ecx: @e::encode_ctxt, tpbt: ty::ty_param_bounds_and_ty) {\n+        self.emit_rec {||\n+            self.emit_rec_field(\"bounds\", 0u) {||\n+                self.emit_from_vec(*tpbt.bounds) {|bs|\n+                    self.emit_bounds(ecx, bs)\n+                }\n             }\n-          }\n-          lit_float(s, f) {\n-            self.tag(at_lit_float) {||\n-                self.str(at_value, s);\n-                self.float_ty(f);\n+            self.emit_rec_field(\"ty\", 0u) {||\n+                self.emit_ty(ecx, tpbt.ty);\n             }\n-          }\n-          lit_nil {\n-            self.tag(at_lit_nil) {||}\n-          }\n-          lit_bool(true) {\n-            self.tag(at_lit_true) {||}\n-          }\n-          lit_bool(false) {\n-            self.tag(at_lit_false) {||}\n-          }\n         }\n     }\n+}\n \n-    fn int_ty(t: ast::int_ty) {\n-        self.uint(t as uint);\n+impl writer for ebml::writer {\n+    fn tag(tag_id: c::astencode_tag, f: fn()) {\n+        self.wr_tag(tag_id as uint) {|| f() }\n     }\n \n-    fn uint_ty(t: ast::uint_ty) {\n-        self.uint(t as uint);\n+    fn id(id: ast::node_id) {\n+        self.wr_tagged_u64(c::tag_table_id as uint, id as u64)\n     }\n+}\n \n-    fn float_ty(t: ast::float_ty) {\n-        self.uint(t as uint);\n+fn encode_side_tables_for_item(ecx: @e::encode_ctxt,\n+                               ebml_w: ebml::writer,\n+                               item: @ast::item) {\n+    ebml_w.wr_tag(c::tag_table as uint) {||\n+        visit_ids(item, fn@(id: ast::node_id) {\n+            // Note: this will cause a copy of ebml_w, which is bad as\n+            // it has mutable fields.  But I believe it's harmless since\n+            // we generate balanced EBML.\n+            encode_side_tables_for_id(ecx, ebml_w, id)\n+        });\n     }\n+}\n \n-    fn ty(ty: ast::ty) {\n-        self.tag(at_ty) {||\n-            self.span(ty.span);\n-            alt ty.node {\n-              ty_nil {\n-                self.tag(at_ty_nil) {||}\n-              }\n+fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n+                             ebml_w: ebml::writer,\n+                             id: ast::node_id) {\n \n-              ty_bot {\n-                self.tag(at_ty_bot) {||}\n-              }\n+    let ccx = ecx.ccx;\n+    let tcx = ccx.tcx;\n \n-              ty_box({ty: ty, mutbl: m}) {\n-                self.tag(at_ty_box) {||\n-                    self.ty(ty);\n-                    self.mutbl(m);\n-                }\n-              }\n+    #debug[\"Encoding side tables for id %d\", id];\n \n-              ty_uniq({ty: ty, mutbl: m}) {\n-                self.tag(at_ty_uniq) {||\n-                    self.ty(ty);\n-                    self.mutbl(m);\n-                }\n-              }\n+    option::may(tcx.def_map.find(id)) {|def|\n+        ebml_w.tag(c::tag_table_def) {||\n+            ebml_w.id(id);\n+            ebml_w.tag(c::tag_table_val) {||\n+                astencode_gen::serialize_syntax_ast_def(ebml_w, def)\n+            }\n+        }\n+    }\n+    option::may((*tcx.node_types).find(id as uint)) {|ty|\n+        ebml_w.tag(c::tag_table_node_type) {||\n+            ebml_w.id(id);\n+            ebml_w.tag(c::tag_table_val) {||\n+                e::write_type(ecx, ebml_w, ty)\n+            }\n+        }\n+    }\n \n-              ty_vec({ty: ty, mutbl: m}) {\n-                self.tag(at_ty_vec) {||\n-                    self.ty(ty);\n-                    self.mutbl(m);\n-                }\n-              }\n+    option::may(tcx.node_type_substs.find(id)) {|tys|\n+        ebml_w.tag(c::tag_table_node_type_subst) {||\n+            ebml_w.id(id);\n+            ebml_w.tag(c::tag_table_val) {||\n+                ebml_w.emit_tys(ecx, tys)\n+            }\n+        }\n+    }\n \n-              ty_ptr({ty: ty, mutbl: m}) {\n-                self.tag(at_ty_ptr) {||\n-                    self.ty(ty);\n-                    self.mutbl(m);\n+    option::may(tcx.freevars.find(id)) {|fv|\n+        ebml_w.tag(c::tag_table_freevars) {||\n+            ebml_w.id(id);\n+            ebml_w.tag(c::tag_table_val) {||\n+                ebml_w.emit_from_vec(*fv) {|fv_entry|\n+                    encode_def(ebml_w, fv_entry.def);\n                 }\n-              }\n+            }\n+        }\n+    }\n \n-              ty_rec(fields) {\n-                self.vec(at_ty_rec) {|f|\n-                    self.field(f)\n-                }\n-              }\n+    let lid = {crate: ast::local_crate, node: id};\n+    option::may(tcx.tcache.find(lid)) {|tpbt|\n+        ebml_w.tag(c::tag_table_tcache) {||\n+            ebml_w.id(id);\n+            ebml_w.tag(c::tag_table_val) {||\n+                ebml_w.emit_tpbt(ecx, tpbt);\n+            }\n+        }\n+    }\n \n-              ty_fn(proto, fd) {\n-                self.tag(at_ty_fn) {||\n-                    self.uint(proto as uint);\n-                    self.fn_decl(fd)\n-                }\n-              }\n+    option::may(tcx.ty_param_bounds.find(id)) {|pbs|\n+        ebml_w.tag(c::tag_table_param_bounds) {||\n+            ebml_w.id(id);\n+            ebml_w.tag(c::tag_table_val) {||\n+                ebml_w.emit_bounds(ecx, pbs)\n+            }\n+        }\n+    }\n \n-              ty_tup(tys) {\n-                self.vec(at_ty_tups) {|ty| self.ty(ty)}\n-              }\n+    // I believe it is not necessary to encode this information.  The\n+    // ids will appear in the AST but in the *type* information, which\n+    // is what we actually use in trans, all modes will have been\n+    // resolved.\n+    //\n+    //option::may(tcx.inferred_modes.find(id)) {|m|\n+    //    ebml_w.tag(c::tag_table_inferred_modes) {||\n+    //        ebml_w.id(id);\n+    //        ebml_w.tag(c::tag_table_val) {||\n+    //            tyencode::enc_mode(ebml_w.writer, ty_str_ctxt(), m);\n+    //        }\n+    //    }\n+    //}\n+\n+    option::may(ccx.maps.mutbl_map.find(id)) {|_m|\n+        ebml_w.tag(c::tag_table_mutbl) {||\n+            ebml_w.id(id);\n+        }\n+    }\n \n-              ty_path(p, id) {\n-                self.tag(at_ty_path) {||\n-                    self.path(p);\n-                    self.uint(id);\n-                }\n-              }\n+    option::may(ccx.maps.copy_map.find(id)) {|_m|\n+        ebml_w.tag(c::tag_table_copy) {||\n+            ebml_w.id(id);\n+        }\n+    }\n \n-              ty_constr(t, tcs) {\n-                self.tag(at_ty_constr) {||\n-                    self.ty(t);\n-                    // ... constrs ... who cares ...\n-                }\n-              }\n+    option::may(ccx.maps.last_uses.find(id)) {|_m|\n+        ebml_w.tag(c::tag_table_last_use) {||\n+            ebml_w.id(id);\n+        }\n+    }\n \n-              ty_mac(m) {\n-                self.tag(at_ty_mac) {||\n-                    self.mac(m);\n-                };\n-              }\n+    // impl_map is not used except when emitting metadata,\n+    // don't need to keep it.\n \n-              ty_infer {\n-                self.tag(at_ty_infer) {||\n-                }\n-              }\n+    option::may(ccx.maps.method_map.find(id)) {|mo|\n+        ebml_w.tag(c::tag_table_method_map) {||\n+            ebml_w.id(id);\n+            ebml_w.tag(c::tag_table_val) {||\n+                astencode_gen::\n+                    serialize_middle_typeck_method_origin(ebml_w, mo)\n             }\n         }\n     }\n \n-    fn item(item: @ast::item) {\n-        self.tag(at_item) {||\n-            self.str(at_item_ident, item);\n-            self.vec(at_item_attrs, item.attrs) {|a| self.attr(a)}\n-            self.uint(item.id);\n-            self.span(item.span);\n-\n-            alt item.node {\n-              item_const(t, e) {\n-                self.tag(at_item_const) {||\n-                    self.ty(t);\n-                    self.expr(e);\n-                }\n-              }\n-              item_fn(d, tps, blk) {\n-                self.tag(at_item_fn) {||\n-                    self.fn_decl(d);\n-                    self.ty_params(tps);\n-                }\n-              }\n-              item_mod(m) {\n-                self.tag(at_item_mod) {||\n-                    self.mod_(m)\n-                }\n-              }\n-              item_native_mod(nm) {\n-                self.tag(at_item_native_mod) {||\n-                    self.mod_(nm)\n-                }\n-              }\n-              item_ty(ty, tps) {\n-                self.tag(at_item_ty) {||\n-                    self.ty(ty);\n-                    self.ty_params(tps);\n-                }\n-              }\n-              item_enum(variants, tps) {\n-                self.tag(at_item_enum) {||\n-                    self.ty(ty);\n-                    self.ty_params(tps);\n-                }\n-              }\n-              item_res(fd, tps, blk, node_id, node_id) {\n-                self.tag(at_item_res) {||\n-                    self.fn_decl(fd);\n-                    self.ty_params(tps);\n-                }\n-              }\n-              item_class(tps, citems, fn_decl, blk) {\n-                self.tag(at_item_class) {||\n-                    self.ty_params(tps);\n-                    self.class_items(citems);\n-                    self.fn_decl(fn_decl);\n-                    self.blk(blk);\n-                }\n-              }\n-              item_iface(tps, tms) {\n-                self.tag(at_item_iface) {||\n-                    self.ty_params(tps);\n-                    self.ty_methods(tms);\n-                }\n-              }\n-              item_impl(tps, iface_ty, self_ty, mthds) {\n-                self.tag(at_item_impl) {||\n-                    self.ty_params(tps);\n-                    self.opt(iface_ty) {|t| self.ty(t) };\n-                    self.ty(self_ty);\n-                    self.methods(mthds);\n-                }\n-              }\n+    option::may(ccx.maps.dict_map.find(id)) {|dr|\n+        ebml_w.tag(c::tag_table_dict_map) {||\n+            ebml_w.id(id);\n+            ebml_w.tag(c::tag_table_val) {||\n+                encode_dict_res(ecx, ebml_w, dr);\n             }\n         }\n     }\n+}\n \n-    fn ty_params(tps: [ast::ty_param]) {\n-        self.vec(at_item_tps, tps) {|t| self.ty_param(t) }\n+impl decoder for ebml::doc {\n+    fn as_int() -> int { ebml::doc_as_u64(self) as int }\n+    fn [](tag: c::astencode_tag) -> ebml::doc {\n+        ebml::get_doc(self, tag as uint)\n+    }\n+    fn opt_child(tag: c::astencode_tag) -> option<ebml::doc> {\n+        ebml::maybe_get_doc(self, tag as uint)\n     }\n+}\n \n-    fn ty_param(tp: ast::ty_param) {\n-        self.str(at_ty_param_ident, tp.ident);\n-        self.uint(at_ty_param_id, tp.id);\n-        self.vec(at_param_bounds, *tp.bounds) {|b| self.ty_param_bound(b) };\n+impl decoder for serialization::ebml_deserializer {\n+    fn read_ty(xcx: extended_decode_ctxt) -> ty::t {\n+        tydecode::parse_ty_data(\n+            self.parent.data, xcx.dcx.cdata.cnum, self.pos, xcx.dcx.tcx,\n+            xcx.tr_def_id(_))\n     }\n \n-    fn ty_param_bound(b: ast::ty_param_bound) {\n-        alt b {\n-          bound_copy { self.tag(at_ty_param_bound_copy) {||} }\n-          bound_send { self.tag(at_ty_param_bound_send) {||} }\n-          bound_iface(t) {\n-            self.tag(at_ty_param_bound_iface) {|| self.ty(t) }\n-          }\n+    fn read_tys(xcx: extended_decode_ctxt) -> [ty::t] {\n+        self.read_to_vec {|| self.read_ty(xcx) }\n+    }\n+\n+    fn read_bounds(xcx: extended_decode_ctxt) -> @[ty::param_bound] {\n+        tydecode::parse_bounds_data(\n+            self.parent.data, self.pos, xcx.dcx.cdata.cnum, xcx.dcx.tcx,\n+            xcx.tr_def_id(_))\n+    }\n+\n+    fn read_ty_param_bounds_and_ty(xcx: extended_decode_ctxt)\n+        -> ty::ty_param_bounds_and_ty {\n+        self.read_rec {||\n+            {\n+                bounds: self.read_rec_field(\"bounds\", 0u) {||\n+                    @self.read_to_vec {|| self.read_bounds(xcx) }\n+                },\n+                ty: self.read_rec_field(\"ty\", 1u) {||\n+                    self.read_ty(xcx)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn decode_side_tables(xcx: extended_decode_ctxt,\n+                      ast_doc: ebml::doc) {\n+    let dcx = xcx.dcx;\n+    let tbl_doc = ast_doc[c::tag_table];\n+    ebml::docs(tbl_doc) {|tag, entry_doc|\n+        let id0 = entry_doc[c::tag_table_id].as_int();\n+        let id = xcx.tr_id(id0);\n+\n+        #debug[\"side table document with tag 0x%x found for id %d (orig %d)\",\n+               tag, id, id0];\n+\n+        if tag == (c::tag_table_mutbl as uint) {\n+            dcx.maps.mutbl_map.insert(id, ());\n+        } else if tag == (c::tag_table_copy as uint) {\n+            dcx.maps.copy_map.insert(id, ());\n+        } else if tag == (c::tag_table_last_use as uint) {\n+            dcx.maps.last_uses.insert(id, ());\n+        } else {\n+            let val_doc = entry_doc[c::tag_table_val];\n+            let val_dsr = serialization::mk_ebml_deserializer(val_doc);\n+            if tag == (c::tag_table_def as uint) {\n+                let def = decode_def(xcx, val_doc);\n+                dcx.tcx.def_map.insert(id, def);\n+            } else if tag == (c::tag_table_node_type as uint) {\n+                let ty = val_dsr.read_ty(xcx);\n+                (*dcx.tcx.node_types).insert(id as uint, ty);\n+            } else if tag == (c::tag_table_node_type_subst as uint) {\n+                let tys = val_dsr.read_tys(xcx);\n+                dcx.tcx.node_type_substs.insert(id, tys);\n+            } else if tag == (c::tag_table_freevars as uint) {\n+                let fv_info = @val_dsr.read_to_vec {||\n+                    @val_dsr.read_freevar_entry(xcx)\n+                };\n+                dcx.tcx.freevars.insert(id, fv_info);\n+            } else if tag == (c::tag_table_tcache as uint) {\n+                let tpbt = val_dsr.read_ty_param_bounds_and_ty(xcx);\n+                let lid = {crate: ast::local_crate, node: id};\n+                dcx.tcx.tcache.insert(lid, tpbt);\n+            } else if tag == (c::tag_table_param_bounds as uint) {\n+                let bounds = val_dsr.read_bounds(xcx);\n+                dcx.tcx.ty_param_bounds.insert(id, bounds);\n+            } else if tag == (c::tag_table_method_map as uint) {\n+                dcx.maps.method_map.insert(id,\n+                                           val_dsr.read_method_origin(xcx));\n+            } else if tag == (c::tag_table_dict_map as uint) {\n+                dcx.maps.dict_map.insert(id,\n+                                         val_dsr.read_dict_res(xcx));\n+            } else {\n+                xcx.dcx.tcx.sess.bug(\n+                    #fmt[\"Unknown tag found in side tables: %x\", tag]);\n+            }\n         }\n     }\n }\n \n+// ______________________________________________________________________\n+// Testing\n+\n+#[cfg(test)]\n+fn new_parse_sess() -> parser::parse_sess {\n+    let cm = codemap::new_codemap();\n+    let handler = diagnostic::mk_handler(option::none);\n+    let sess = @{\n+        cm: cm,\n+        mutable next_id: 1,\n+        span_diagnostic: diagnostic::mk_span_handler(handler, cm),\n+        mutable chpos: 0u,\n+        mutable byte_pos: 0u\n+    };\n+    ret sess;\n+}\n+\n+#[cfg(test)]\n+iface fake_ext_ctxt {\n+    fn session() -> fake_session;\n+}\n+\n+#[cfg(test)]\n+type fake_options = {cfg: ast::crate_cfg};\n+\n+#[cfg(test)]\n+type fake_session = {opts: @fake_options,\n+                     parse_sess: parser::parse_sess};\n+\n+#[cfg(test)]\n+impl of fake_ext_ctxt for fake_session {\n+    fn session() -> fake_session {self}\n+}\n+\n+#[cfg(test)]\n+fn mk_ctxt() -> fake_ext_ctxt {\n+    let opts : fake_options = {cfg: []};\n+    {opts: @opts, parse_sess: new_parse_sess()} as fake_ext_ctxt\n+}\n+\n+#[cfg(test)]\n+fn roundtrip(in_item: @ast::item) {\n+    #debug[\"in_item = %s\", pprust::item_to_str(in_item)];\n+    let mbuf = io::mk_mem_buffer();\n+    let ebml_w = ebml::mk_writer(io::mem_buffer_writer(mbuf));\n+    encode_ast(ebml_w, in_item);\n+    let ebml_doc = ebml::new_doc(@io::mem_buffer_buf(mbuf));\n+    let out_item = decode_ast(ebml_doc);\n+    #debug[\"out_item = %s\", pprust::item_to_str(out_item)];\n+    assert in_item == out_item;\n+}\n+\n+#[test]\n+fn test_basic() {\n+    let ext_cx = mk_ctxt();\n+    roundtrip(#ast(item){\n+        fn foo() {}\n+    });\n+}\n+\n+#[test]\n+fn test_smalltalk() {\n+    let ext_cx = mk_ctxt();\n+    roundtrip(#ast(item){\n+        fn foo() -> int { 3 + 4 } // first smalltalk program ever executed.\n+    });\n+}\n+\n+#[test]\n+fn test_more() {\n+    let ext_cx = mk_ctxt();\n+    roundtrip(#ast(item){\n+        fn foo(x: uint, y: uint) -> uint {\n+            let z = x + y;\n+            ret z;\n+        }\n+    });\n+}\n\\ No newline at end of file"}, {"sha": "faa76cc99ed1304a69b1dce8bbb8a8628d54f21b", "filename": "src/comp/metadata/astencode_gen.rs", "status": "added", "additions": 8734, "deletions": 0, "changes": 8734, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmetadata%2Fastencode_gen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmetadata%2Fastencode_gen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fastencode_gen.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635"}, {"sha": "4ccb34055605a0a799ba46af2fcf500949e7ff74", "filename": "src/comp/metadata/common.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcommon.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -76,6 +76,30 @@ const tag_path_len: uint = 0x41u;\n const tag_path_elt_mod: uint = 0x42u;\n const tag_path_elt_name: uint = 0x43u;\n \n+// used to encode crate_ctxt side tables\n+enum astencode_tag { // Reserves 0x50 -- 0x6f\n+    tag_ast = 0x50,\n+\n+    tag_tree = 0x51,\n+\n+    tag_id_range = 0x52,\n+\n+    tag_table = 0x53,\n+    tag_table_id = 0x54,\n+    tag_table_val = 0x55,\n+    tag_table_def = 0x56,\n+    tag_table_node_type = 0x57,\n+    tag_table_node_type_subst = 0x58,\n+    tag_table_freevars = 0x59,\n+    tag_table_tcache,\n+    tag_table_param_bounds,\n+    tag_table_inferred_modes,\n+    tag_table_mutbl,\n+    tag_table_copy,\n+    tag_table_last_use,\n+    tag_table_method_map,\n+    tag_table_dict_map\n+}\n \n // djb's cdb hashes.\n fn hash_node_id(&&node_id: int) -> uint { ret 177573u ^ (node_id as uint); }"}, {"sha": "646ba5ea7514af5aa91d4ee93b935996347bb0d5", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -5,6 +5,7 @@ import syntax::ast_util;\n import middle::{ty, ast_map};\n import option::{some, none};\n import driver::session;\n+import middle::trans::common::maps;\n \n export get_symbol;\n export get_type_param_count;\n@@ -16,6 +17,7 @@ export get_iface_methods;\n export get_type;\n export get_impl_iface;\n export get_item_path;\n+export maybe_get_item_ast;\n \n fn get_symbol(cstore: cstore::cstore, def: ast::def_id) -> str {\n     let cdata = cstore::get_crate_data(cstore, def.crate).data;\n@@ -73,6 +75,16 @@ fn get_item_path(tcx: ty::ctxt, def: ast::def_id) -> ast_map::path {\n     [ast_map::path_mod(cdata.name)] + path\n }\n \n+// Finds the AST for this item in the crate metadata, if any.  If the item was\n+// not marked for inlining, then the AST will not be present and hence none\n+// will be returned.\n+fn maybe_get_item_ast(tcx: ty::ctxt, maps: maps, def: ast::def_id)\n+    -> option<@ast::item> {\n+    let cstore = tcx.sess.cstore;\n+    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    decoder::maybe_get_item_ast(cdata, tcx, maps, def.node)\n+}\n+\n fn get_enum_variants(tcx: ty::ctxt, def: ast::def_id) -> [ty::variant_info] {\n     let cstore = tcx.sess.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);"}, {"sha": "6b741189c486753d14d25c0a133b770fbf31d256", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -11,6 +11,7 @@ import common::*;\n import tydecode::{parse_ty_data, parse_def_id, parse_bounds_data};\n import syntax::print::pprust;\n import cmd=cstore::crate_metadata;\n+import middle::trans::common::maps;\n \n export get_symbol;\n export get_enum_variants;\n@@ -30,6 +31,10 @@ export get_impls_for_mod;\n export get_iface_methods;\n export get_crate_module_paths;\n export get_item_path;\n+export maybe_get_item_ast;\n+\n+// Used internally by astencode:\n+export translate_def_id;\n \n // A function that takes a def_id relative to the crate being searched and\n // returns a def_id relative to the compilation environment, i.e. if we hit a\n@@ -42,14 +47,14 @@ fn lookup_hash(d: ebml::doc, eq_fn: fn@([u8]) -> bool, hash: uint) ->\n     let index = ebml::get_doc(d, tag_index);\n     let table = ebml::get_doc(index, tag_index_table);\n     let hash_pos = table.start + hash % 256u * 4u;\n-    let pos = ebml::be_u64_from_bytes(d.data, hash_pos, 4u) as uint;\n+    let pos = io::u64_from_be_bytes(*d.data, hash_pos, 4u) as uint;\n     let {tag:_, doc:bucket} = ebml::doc_at(d.data, pos);\n     // Awkward logic because we can't ret from foreach yet\n \n     let result: [ebml::doc] = [];\n     let belt = tag_index_buckets_bucket_elt;\n     ebml::tagged_docs(bucket, belt) {|elt|\n-        let pos = ebml::be_u64_from_bytes(elt.data, elt.start, 4u) as uint;\n+        let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4u) as uint;\n         if eq_fn(vec::slice::<u8>(*elt.data, elt.start + 4u, elt.end)) {\n             result += [ebml::doc_at(d.data, pos).doc];\n         }\n@@ -59,7 +64,7 @@ fn lookup_hash(d: ebml::doc, eq_fn: fn@([u8]) -> bool, hash: uint) ->\n \n fn maybe_find_item(item_id: int, items: ebml::doc) -> option<ebml::doc> {\n     fn eq_item(bytes: [u8], item_id: int) -> bool {\n-        ret ebml::be_u64_from_bytes(@bytes, 0u, 4u) as int == item_id;\n+        ret io::u64_from_be_bytes(bytes, 0u, 4u) as int == item_id;\n     }\n     let eqer = bind eq_item(_, item_id);\n     let found = lookup_hash(items, eqer, hash_node_id(item_id));\n@@ -178,17 +183,17 @@ fn item_path(item_doc: ebml::doc) -> ast_map::path {\n     let path_doc = ebml::get_doc(item_doc, tag_path);\n \n     let len_doc = ebml::get_doc(path_doc, tag_path_len);\n-    let len = ebml::doc_as_vuint(len_doc);\n+    let len = ebml::doc_as_u32(len_doc) as uint;\n \n     let result = [];\n     vec::reserve(result, len);\n \n     ebml::docs(path_doc) {|tag, elt_doc|\n         if tag == tag_path_elt_mod {\n-            let str = ebml::doc_str(elt_doc);\n+            let str = ebml::doc_as_str(elt_doc);\n             result += [ast_map::path_mod(str)];\n         } else if tag == tag_path_elt_name {\n-            let str = ebml::doc_str(elt_doc);\n+            let str = ebml::doc_as_str(elt_doc);\n             result += [ast_map::path_name(str)];\n         } else {\n             // ignore tag_path_len element\n@@ -258,6 +263,13 @@ fn get_item_path(cdata: cmd, id: ast::node_id) -> ast_map::path {\n     item_path(lookup_item(id, cdata.data))\n }\n \n+fn maybe_get_item_ast(cdata: cmd, tcx: ty::ctxt, maps: maps,\n+                      id: ast::node_id) -> option<@ast::item> {\n+    let item_doc = lookup_item(id, cdata.data);\n+    let path = vec::init(item_path(item_doc));\n+    astencode::decode_inlined_item(cdata, tcx, maps, path, item_doc)\n+}\n+\n fn get_enum_variants(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     -> [ty::variant_info] {\n     let data = cdata.data;\n@@ -353,7 +365,7 @@ fn family_names_type(fam_ch: char) -> bool {\n \n fn read_path(d: ebml::doc) -> {path: str, pos: uint} {\n     let desc = ebml::doc_data(d);\n-    let pos = ebml::be_u64_from_bytes(@desc, 0u, 4u) as uint;\n+    let pos = io::u64_from_be_bytes(desc, 0u, 4u) as uint;\n     let pathbytes = vec::slice::<u8>(desc, 4u, vec::len::<u8>(desc));\n     let path = str::from_bytes(pathbytes);\n     ret {path: path, pos: pos};"}, {"sha": "348c28784a2f91aee4606e010a1911f1ccd03291", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 138, "deletions": 125, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -2,8 +2,9 @@\n \n import std::{io, ebml, map, list};\n import io::writer_util;\n-import ebml::writer_util;\n+import ebml::writer;\n import syntax::ast::*;\n+import syntax::print::pprust;\n import syntax::ast_util;\n import syntax::ast_util::local_def;\n import common::*;\n@@ -13,25 +14,40 @@ import middle::ty::node_id_to_type;\n import middle::ast_map;\n import front::attr;\n import driver::session::session;\n+import std::serialization::serializer;\n \n export encode_metadata;\n export encoded_ty;\n \n+// used by astencode:\n+export def_to_str;\n+export encode_ctxt;\n+export write_type;\n+export encode_def_id;\n+\n type abbrev_map = map::hashmap<ty::t, tyencode::ty_abbrev>;\n \n type encode_ctxt = {ccx: crate_ctxt, type_abbrevs: abbrev_map};\n \n+fn should_inline(path: ast_map::path, item: @item) -> bool {\n+    if item.ident == \"iter\" { // XXX\n+        #debug[\"should_inline(%s::%s)? attrs=%s result=%b\",\n+               ast_map::path_to_str(path),\n+               item.ident,\n+               str::connect(vec::map(item.attrs, pprust::attr_to_str), \", \"),\n+               attr::attrs_contains_name(item.attrs, \"inline\")];\n+    }\n+\n+    attr::attrs_contains_name(item.attrs, \"inline\")\n+}\n+\n // Path table encoding\n fn encode_name(ebml_w: ebml::writer, name: str) {\n-    ebml_w.wr_tag(tag_paths_data_name) {||\n-        ebml_w.wr_str(name);\n-    }\n+    ebml_w.wr_tagged_str(tag_paths_data_name, name);\n }\n \n fn encode_def_id(ebml_w: ebml::writer, id: def_id) {\n-    ebml_w.wr_tag(tag_def_id) {||\n-        ebml_w.wr_str(def_to_str(id));\n-    }\n+    ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n }\n \n fn encode_named_def_id(ebml_w: ebml::writer, name: str, id: def_id) {\n@@ -85,57 +101,57 @@ fn encode_module_item_paths(ebml_w: ebml::writer, module: _mod, path: [str],\n           }\n           item_mod(_mod) {\n             add_to_index(ebml_w, path, index, it.ident);\n-            ebml::start_tag(ebml_w, tag_paths_data_mod);\n+            ebml_w.start_tag(tag_paths_data_mod);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n             encode_module_item_paths(ebml_w, _mod, path + [it.ident], index);\n-            ebml::end_tag(ebml_w);\n+            ebml_w.end_tag();\n           }\n           item_native_mod(nmod) {\n             add_to_index(ebml_w, path, index, it.ident);\n-            ebml::start_tag(ebml_w, tag_paths_data_mod);\n+            ebml_w.start_tag(tag_paths_data_mod);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n             encode_native_module_item_paths(ebml_w, nmod, path + [it.ident],\n                                             index);\n-            ebml::end_tag(ebml_w);\n+            ebml_w.end_tag();\n           }\n           item_ty(_, tps) {\n             add_to_index(ebml_w, path, index, it.ident);\n-            ebml::start_tag(ebml_w, tag_paths_data_item);\n+            ebml_w.start_tag(tag_paths_data_item);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n-            ebml::end_tag(ebml_w);\n+            ebml_w.end_tag();\n           }\n           item_res(_, tps, _, _, ctor_id) {\n             add_to_index(ebml_w, path, index, it.ident);\n-            ebml::start_tag(ebml_w, tag_paths_data_item);\n+            ebml_w.start_tag(tag_paths_data_item);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(ctor_id));\n-            ebml::end_tag(ebml_w);\n+            ebml_w.end_tag();\n             add_to_index(ebml_w, path, index, it.ident);\n-            ebml::start_tag(ebml_w, tag_paths_data_item);\n+            ebml_w.start_tag(tag_paths_data_item);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n-            ebml::end_tag(ebml_w);\n+            ebml_w.end_tag();\n           }\n           item_class(_,_,_,_,_) {\n               fail \"encode: implement item_class\";\n           }\n           item_enum(variants, tps) {\n             add_to_index(ebml_w, path, index, it.ident);\n-            ebml::start_tag(ebml_w, tag_paths_data_item);\n+            ebml_w.start_tag(tag_paths_data_item);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n-            ebml::end_tag(ebml_w);\n+            ebml_w.end_tag();\n             encode_enum_variant_paths(ebml_w, variants, path, index);\n           }\n           item_iface(_, _) {\n             add_to_index(ebml_w, path, index, it.ident);\n-            ebml::start_tag(ebml_w, tag_paths_data_item);\n+            ebml_w.start_tag(tag_paths_data_item);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n-            ebml::end_tag(ebml_w);\n+            ebml_w.end_tag();\n           }\n           item_impl(_, _, _, _) {}\n         }\n@@ -146,10 +162,10 @@ fn encode_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt, crate: @crate)\n     -> [entry<str>] {\n     let index: [entry<str>] = [];\n     let path: [str] = [];\n-    ebml::start_tag(ebml_w, tag_paths);\n+    ebml_w.start_tag(tag_paths);\n     encode_module_item_paths(ebml_w, crate.node.module, path, index);\n     encode_reexport_paths(ebml_w, ecx, index);\n-    ebml::end_tag(ebml_w);\n+    ebml_w.end_tag();\n     ret index;\n }\n \n@@ -158,20 +174,20 @@ fn encode_reexport_paths(ebml_w: ebml::writer,\n     ecx.ccx.exp_map.items {|path, defs|\n         for def in *defs {\n             index += [{val: path, pos: ebml_w.writer.tell()}];\n-            ebml::start_tag(ebml_w, tag_paths_data_item);\n+            ebml_w.start_tag(tag_paths_data_item);\n             encode_name(ebml_w, path);\n             encode_def_id(ebml_w, ast_util::def_id_of_def(def));\n-            ebml::end_tag(ebml_w);\n+            ebml_w.end_tag();\n         }\n     }\n }\n \n \n // Item info table encoding\n fn encode_family(ebml_w: ebml::writer, c: char) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_family);\n+    ebml_w.start_tag(tag_items_data_item_family);\n     ebml_w.writer.write([c as u8]);\n-    ebml::end_tag(ebml_w);\n+    ebml_w.end_tag();\n }\n \n fn def_to_str(did: def_id) -> str { ret #fmt[\"%d:%d\", did.crate, did.node]; }\n@@ -182,17 +198,17 @@ fn encode_type_param_bounds(ebml_w: ebml::writer, ecx: @encode_ctxt,\n                         tcx: ecx.ccx.tcx,\n                         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     for param in params {\n-        ebml::start_tag(ebml_w, tag_items_data_item_ty_param_bounds);\n+        ebml_w.start_tag(tag_items_data_item_ty_param_bounds);\n         let bs = ecx.ccx.tcx.ty_param_bounds.get(param.id);\n         tyencode::enc_bounds(ebml_w.writer, ty_str_ctxt, bs);\n-        ebml::end_tag(ebml_w);\n+        ebml_w.end_tag();\n     }\n }\n \n fn encode_variant_id(ebml_w: ebml::writer, vid: def_id) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_variant);\n+    ebml_w.start_tag(tag_items_data_item_variant);\n     ebml_w.writer.write(str::bytes(def_to_str(vid)));\n-    ebml::end_tag(ebml_w);\n+    ebml_w.end_tag();\n }\n \n fn write_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n@@ -204,33 +220,33 @@ fn write_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n }\n \n fn encode_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_type);\n+    ebml_w.start_tag(tag_items_data_item_type);\n     write_type(ecx, ebml_w, typ);\n-    ebml::end_tag(ebml_w);\n+    ebml_w.end_tag();\n }\n \n fn encode_symbol(ecx: @encode_ctxt, ebml_w: ebml::writer, id: node_id) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_symbol);\n+    ebml_w.start_tag(tag_items_data_item_symbol);\n     ebml_w.writer.write(str::bytes(ecx.ccx.item_symbols.get(id)));\n-    ebml::end_tag(ebml_w);\n+    ebml_w.end_tag();\n }\n \n fn encode_discriminant(ecx: @encode_ctxt, ebml_w: ebml::writer, id: node_id) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_symbol);\n+    ebml_w.start_tag(tag_items_data_item_symbol);\n     ebml_w.writer.write(str::bytes(ecx.ccx.discrim_symbols.get(id)));\n-    ebml::end_tag(ebml_w);\n+    ebml_w.end_tag();\n }\n \n fn encode_disr_val(_ecx: @encode_ctxt, ebml_w: ebml::writer, disr_val: int) {\n-    ebml::start_tag(ebml_w, tag_disr_val);\n+    ebml_w.start_tag(tag_disr_val);\n     ebml_w.writer.write(str::bytes(int::to_str(disr_val,10u)));\n-    ebml::end_tag(ebml_w);\n+    ebml_w.end_tag();\n }\n \n fn encode_enum_id(ebml_w: ebml::writer, id: def_id) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_enum_id);\n+    ebml_w.start_tag(tag_items_data_item_enum_id);\n     ebml_w.writer.write(str::bytes(def_to_str(id)));\n-    ebml::end_tag(ebml_w);\n+    ebml_w.end_tag();\n }\n \n fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n@@ -242,7 +258,7 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n     let vi = ty::enum_variants(ecx.ccx.tcx, {crate: local_crate, node: id});\n     for variant: variant in variants {\n         index += [{val: variant.node.id, pos: ebml_w.writer.tell()}];\n-        ebml::start_tag(ebml_w, tag_items_data_item);\n+        ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(variant.node.id));\n         encode_family(ebml_w, 'v');\n         encode_name(ebml_w, variant.node.name);\n@@ -259,7 +275,7 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         }\n         encode_type_param_bounds(ebml_w, ecx, ty_params);\n         encode_path(ebml_w, path, ast_map::path_name(variant.node.name));\n-        ebml::end_tag(ebml_w);\n+        ebml_w.end_tag();\n         disr_val += 1;\n         i += 1;\n     }\n@@ -274,41 +290,35 @@ fn encode_path(ebml_w: ebml::writer,\n           ast_map::path_name(name) { (tag_path_elt_name, name) }\n         };\n \n-        ebml_w.wr_tag(tag) {||\n-            ebml_w.wr_str(name)\n-        }\n+        ebml_w.wr_tagged_str(tag, name);\n     }\n \n     ebml_w.wr_tag(tag_path) {||\n-        ebml_w.wr_tag(tag_path_len) {||\n-            ebml_w.wr_vuint(vec::len(path) + 1u);\n-        }\n+        ebml_w.wr_tagged_u32(tag_path_len, (vec::len(path) + 1u) as u32);\n         vec::iter(path) {|pe| encode_path_elt(ebml_w, pe); }\n         encode_path_elt(ebml_w, name);\n     }\n }\n \n fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n                        id: node_id, path: ast_map::path, name: ident) {\n-    ebml::start_tag(ebml_w, tag_items_data_item);\n+    ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(id));\n     encode_family(ebml_w, 'm');\n     encode_name(ebml_w, name);\n-    alt ecx.ccx.impl_map.get(id) {\n+    alt ecx.ccx.maps.impl_map.get(id) {\n       list::cons(impls, @list::nil) {\n         for i in *impls {\n             if ast_util::is_exported(i.ident, md) {\n-                ebml::start_tag(ebml_w, tag_mod_impl);\n-                ebml_w.writer.write(str::bytes(def_to_str(i.did)));\n-                ebml::end_tag(ebml_w);\n+                ebml_w.wr_tagged_str(tag_mod_impl, def_to_str(i.did));\n             }\n         }\n       }\n       _ { ecx.ccx.tcx.sess.bug(\"encode_info_for_mod: \\\n              undocumented invariant\"); }\n     }\n     encode_path(ebml_w, path, ast_map::path_mod(name));\n-    ebml::end_tag(ebml_w);\n+    ebml_w.end_tag();\n }\n \n fn purity_fn_family(p: purity) -> char {\n@@ -325,47 +335,50 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n     let tcx = ecx.ccx.tcx;\n     alt item.node {\n       item_const(_, _) {\n-        ebml::start_tag(ebml_w, tag_items_data_item);\n+        ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'c');\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n-        ebml::end_tag(ebml_w);\n+        ebml_w.end_tag();\n       }\n       item_fn(decl, tps, _) {\n-        ebml::start_tag(ebml_w, tag_items_data_item);\n+        ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, purity_fn_family(decl.purity));\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n-        ebml::end_tag(ebml_w);\n+        if should_inline(path, item) {\n+            astencode::encode_inlined_item(ecx, ebml_w, item);\n+        }\n+        ebml_w.end_tag();\n       }\n       item_mod(m) {\n         encode_info_for_mod(ecx, ebml_w, m, item.id, path, item.ident);\n       }\n       item_native_mod(_) {\n-        ebml::start_tag(ebml_w, tag_items_data_item);\n+        ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'n');\n         encode_name(ebml_w, item.ident);\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n-        ebml::end_tag(ebml_w);\n+        ebml_w.end_tag();\n       }\n       item_ty(_, tps) {\n-        ebml::start_tag(ebml_w, tag_items_data_item);\n+        ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'y');\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n-        ebml::end_tag(ebml_w);\n+        ebml_w.end_tag();\n       }\n       item_enum(variants, tps) {\n-        ebml::start_tag(ebml_w, tag_items_data_item);\n+        ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 't');\n         encode_type_param_bounds(ebml_w, ecx, tps);\n@@ -375,7 +388,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             encode_variant_id(ebml_w, local_def(v.node.id));\n         }\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n-        ebml::end_tag(ebml_w);\n+        ebml_w.end_tag();\n         encode_enum_variant_info(ecx, ebml_w, item.id, variants,\n                                  path, index, tps);\n       }\n@@ -385,91 +398,91 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n       item_res(_, tps, _, _, ctor_id) {\n         let fn_ty = node_id_to_type(tcx, ctor_id);\n \n-        ebml::start_tag(ebml_w, tag_items_data_item);\n+        ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(ctor_id));\n         encode_family(ebml_w, 'y');\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, ty::ty_fn_ret(fn_ty));\n         encode_name(ebml_w, item.ident);\n         encode_symbol(ecx, ebml_w, item.id);\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n-        ebml::end_tag(ebml_w);\n+        ebml_w.end_tag();\n \n         index += [{val: ctor_id, pos: ebml_w.writer.tell()}];\n-        ebml::start_tag(ebml_w, tag_items_data_item);\n+        ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(ctor_id));\n         encode_family(ebml_w, 'f');\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, fn_ty);\n         encode_symbol(ecx, ebml_w, ctor_id);\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n-        ebml::end_tag(ebml_w);\n+        ebml_w.end_tag();\n       }\n       item_impl(tps, ifce, _, methods) {\n-        ebml::start_tag(ebml_w, tag_items_data_item);\n+        ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'i');\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         for m in methods {\n-            ebml::start_tag(ebml_w, tag_item_method);\n+            ebml_w.start_tag(tag_item_method);\n             ebml_w.writer.write(str::bytes(def_to_str(local_def(m.id))));\n-            ebml::end_tag(ebml_w);\n+            ebml_w.end_tag();\n         }\n         alt ifce {\n           some(_) {\n             encode_symbol(ecx, ebml_w, item.id);\n             let i_ty = ty::lookup_item_type(tcx, local_def(item.id)).ty;\n-            ebml::start_tag(ebml_w, tag_impl_iface);\n+            ebml_w.start_tag(tag_impl_iface);\n             write_type(ecx, ebml_w, i_ty);\n-            ebml::end_tag(ebml_w);\n+            ebml_w.end_tag();\n           }\n           _ {}\n         }\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n-        ebml::end_tag(ebml_w);\n+        ebml_w.end_tag();\n \n         let impl_path = path + [ast_map::path_name(item.ident)];\n         for m in methods {\n             index += [{val: m.id, pos: ebml_w.writer.tell()}];\n-            ebml::start_tag(ebml_w, tag_items_data_item);\n+            ebml_w.start_tag(tag_items_data_item);\n             encode_def_id(ebml_w, local_def(m.id));\n             encode_family(ebml_w, purity_fn_family(m.decl.purity));\n             encode_type_param_bounds(ebml_w, ecx, tps + m.tps);\n             encode_type(ecx, ebml_w, node_id_to_type(tcx, m.id));\n             encode_name(ebml_w, m.ident);\n             encode_symbol(ecx, ebml_w, m.id);\n             encode_path(ebml_w, impl_path, ast_map::path_name(m.ident));\n-            ebml::end_tag(ebml_w);\n+            ebml_w.end_tag();\n         }\n       }\n       item_iface(tps, ms) {\n-        ebml::start_tag(ebml_w, tag_items_data_item);\n+        ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'I');\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         let i = 0u;\n         for mty in *ty::iface_methods(tcx, local_def(item.id)) {\n-            ebml::start_tag(ebml_w, tag_item_method);\n+            ebml_w.start_tag(tag_item_method);\n             encode_name(ebml_w, mty.ident);\n             encode_type_param_bounds(ebml_w, ecx, ms[i].tps);\n             encode_type(ecx, ebml_w, ty::mk_fn(tcx, mty.fty));\n             encode_family(ebml_w, purity_fn_family(mty.purity));\n-            ebml::end_tag(ebml_w);\n+            ebml_w.end_tag();\n             i += 1u;\n         }\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n-        ebml::end_tag(ebml_w);\n+        ebml_w.end_tag();\n       }\n     }\n }\n \n fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                                nitem: @native_item, path: ast_map::path) {\n-    ebml::start_tag(ebml_w, tag_items_data_item);\n+    ebml_w.start_tag(tag_items_data_item);\n     alt nitem.node {\n       native_item_fn(fn_decl, tps) {\n         encode_def_id(ebml_w, local_def(nitem.id));\n@@ -480,16 +493,16 @@ fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         encode_path(ebml_w, path, ast_map::path_name(nitem.ident));\n       }\n     }\n-    ebml::end_tag(ebml_w);\n+    ebml_w.end_tag();\n }\n \n fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                          crate_mod: _mod) -> [entry<int>] {\n     let index: [entry<int>] = [];\n-    ebml::start_tag(ebml_w, tag_items_data);\n+    ebml_w.start_tag(tag_items_data);\n     index += [{val: crate_node_id, pos: ebml_w.writer.tell()}];\n     encode_info_for_mod(ecx, ebml_w, crate_mod, crate_node_id, [], \"\");\n-    ecx.ccx.ast_map.items {|key, val|\n+    ecx.ccx.tcx.items.items {|key, val|\n         alt val {\n           middle::ast_map::node_item(i, path) {\n             index += [{val: key, pos: ebml_w.writer.tell()}];\n@@ -502,7 +515,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n           _ { }\n         }\n     };\n-    ebml::end_tag(ebml_w);\n+    ebml_w.end_tag();\n     ret index;\n }\n \n@@ -528,25 +541,25 @@ fn create_index<T: copy>(index: [entry<T>], hash_fn: fn@(T) -> uint) ->\n fn encode_index<T>(ebml_w: ebml::writer, buckets: [@[entry<T>]],\n                    write_fn: fn(io::writer, T)) {\n     let writer = ebml_w.writer;\n-    ebml::start_tag(ebml_w, tag_index);\n+    ebml_w.start_tag(tag_index);\n     let bucket_locs: [uint] = [];\n-    ebml::start_tag(ebml_w, tag_index_buckets);\n+    ebml_w.start_tag(tag_index_buckets);\n     for bucket: @[entry<T>] in buckets {\n         bucket_locs += [ebml_w.writer.tell()];\n-        ebml::start_tag(ebml_w, tag_index_buckets_bucket);\n+        ebml_w.start_tag(tag_index_buckets_bucket);\n         for elt: entry<T> in *bucket {\n-            ebml::start_tag(ebml_w, tag_index_buckets_bucket_elt);\n+            ebml_w.start_tag(tag_index_buckets_bucket_elt);\n             writer.write_be_uint(elt.pos, 4u);\n             write_fn(writer, elt.val);\n-            ebml::end_tag(ebml_w);\n+            ebml_w.end_tag();\n         }\n-        ebml::end_tag(ebml_w);\n+        ebml_w.end_tag();\n     }\n-    ebml::end_tag(ebml_w);\n-    ebml::start_tag(ebml_w, tag_index_table);\n+    ebml_w.end_tag();\n+    ebml_w.start_tag(tag_index_table);\n     for pos: uint in bucket_locs { writer.write_be_uint(pos, 4u); }\n-    ebml::end_tag(ebml_w);\n-    ebml::end_tag(ebml_w);\n+    ebml_w.end_tag();\n+    ebml_w.end_tag();\n }\n \n fn write_str(writer: io::writer, &&s: str) { writer.write_str(s); }\n@@ -558,48 +571,48 @@ fn write_int(writer: io::writer, &&n: int) {\n fn encode_meta_item(ebml_w: ebml::writer, mi: meta_item) {\n     alt mi.node {\n       meta_word(name) {\n-        ebml::start_tag(ebml_w, tag_meta_item_word);\n-        ebml::start_tag(ebml_w, tag_meta_item_name);\n+        ebml_w.start_tag(tag_meta_item_word);\n+        ebml_w.start_tag(tag_meta_item_name);\n         ebml_w.writer.write(str::bytes(name));\n-        ebml::end_tag(ebml_w);\n-        ebml::end_tag(ebml_w);\n+        ebml_w.end_tag();\n+        ebml_w.end_tag();\n       }\n       meta_name_value(name, value) {\n         alt value.node {\n           lit_str(value) {\n-            ebml::start_tag(ebml_w, tag_meta_item_name_value);\n-            ebml::start_tag(ebml_w, tag_meta_item_name);\n+            ebml_w.start_tag(tag_meta_item_name_value);\n+            ebml_w.start_tag(tag_meta_item_name);\n             ebml_w.writer.write(str::bytes(name));\n-            ebml::end_tag(ebml_w);\n-            ebml::start_tag(ebml_w, tag_meta_item_value);\n+            ebml_w.end_tag();\n+            ebml_w.start_tag(tag_meta_item_value);\n             ebml_w.writer.write(str::bytes(value));\n-            ebml::end_tag(ebml_w);\n-            ebml::end_tag(ebml_w);\n+            ebml_w.end_tag();\n+            ebml_w.end_tag();\n           }\n           _ {/* FIXME (#611) */ }\n         }\n       }\n       meta_list(name, items) {\n-        ebml::start_tag(ebml_w, tag_meta_item_list);\n-        ebml::start_tag(ebml_w, tag_meta_item_name);\n+        ebml_w.start_tag(tag_meta_item_list);\n+        ebml_w.start_tag(tag_meta_item_name);\n         ebml_w.writer.write(str::bytes(name));\n-        ebml::end_tag(ebml_w);\n+        ebml_w.end_tag();\n         for inner_item: @meta_item in items {\n             encode_meta_item(ebml_w, *inner_item);\n         }\n-        ebml::end_tag(ebml_w);\n+        ebml_w.end_tag();\n       }\n     }\n }\n \n fn encode_attributes(ebml_w: ebml::writer, attrs: [attribute]) {\n-    ebml::start_tag(ebml_w, tag_attributes);\n+    ebml_w.start_tag(tag_attributes);\n     for attr: attribute in attrs {\n-        ebml::start_tag(ebml_w, tag_attribute);\n+        ebml_w.start_tag(tag_attribute);\n         encode_meta_item(ebml_w, attr.node.value);\n-        ebml::end_tag(ebml_w);\n+        ebml_w.end_tag();\n     }\n-    ebml::end_tag(ebml_w);\n+    ebml_w.end_tag();\n }\n \n // So there's a special crate attribute called 'link' which defines the\n@@ -687,19 +700,19 @@ fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n     // that they are numbered 1 to n.\n     // FIXME: This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n-    ebml::start_tag(ebml_w, tag_crate_deps);\n+    ebml_w.start_tag(tag_crate_deps);\n     for cname: str in get_ordered_names(cstore) {\n-        ebml::start_tag(ebml_w, tag_crate_dep);\n+        ebml_w.start_tag(tag_crate_dep);\n         ebml_w.writer.write(str::bytes(cname));\n-        ebml::end_tag(ebml_w);\n+        ebml_w.end_tag();\n     }\n-    ebml::end_tag(ebml_w);\n+    ebml_w.end_tag();\n }\n \n fn encode_hash(ebml_w: ebml::writer, hash: str) {\n-    ebml::start_tag(ebml_w, tag_crate_hash);\n+    ebml_w.start_tag(tag_crate_hash);\n     ebml_w.writer.write(str::bytes(hash));\n-    ebml::end_tag(ebml_w);\n+    ebml_w.end_tag();\n }\n \n fn encode_metadata(cx: crate_ctxt, crate: @crate) -> [u8] {\n@@ -709,7 +722,7 @@ fn encode_metadata(cx: crate_ctxt, crate: @crate) -> [u8] {\n \n     let buf = io::mk_mem_buffer();\n     let buf_w = io::mem_buffer_writer(buf);\n-    let ebml_w = ebml::create_writer(buf_w);\n+    let ebml_w = ebml::mk_writer(buf_w);\n \n     encode_hash(ebml_w, cx.link_meta.extras_hash);\n \n@@ -719,18 +732,18 @@ fn encode_metadata(cx: crate_ctxt, crate: @crate) -> [u8] {\n     encode_crate_deps(ebml_w, cx.sess.cstore);\n \n     // Encode and index the paths.\n-    ebml::start_tag(ebml_w, tag_paths);\n+    ebml_w.start_tag(tag_paths);\n     let paths_index = encode_item_paths(ebml_w, ecx, crate);\n     let paths_buckets = create_index(paths_index, hash_path);\n     encode_index(ebml_w, paths_buckets, write_str);\n-    ebml::end_tag(ebml_w);\n+    ebml_w.end_tag();\n \n     // Encode and index the items.\n-    ebml::start_tag(ebml_w, tag_items);\n+    ebml_w.start_tag(tag_items);\n     let items_index = encode_info_for_items(ecx, ebml_w, crate.node.module);\n     let items_buckets = create_index(items_index, hash_node_id);\n     encode_index(ebml_w, items_buckets, write_int);\n-    ebml::end_tag(ebml_w);\n+    ebml_w.end_tag();\n \n     // Pad this, since something (LLVM, presumably) is cutting off the\n     // remaining % 4 bytes."}, {"sha": "aa08e313dd72e69b8911cbc433c5323612998fcf", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -14,6 +14,7 @@ export ac_no_abbrevs;\n export ac_use_abbrevs;\n export enc_ty;\n export enc_bounds;\n+export enc_mode;\n \n type ctxt =\n     // Def -> str Callback:\n@@ -211,16 +212,20 @@ fn enc_proto(w: io::writer, proto: proto) {\n     }\n }\n \n+fn enc_mode(w: io::writer, cx: @ctxt, m: mode) {\n+    alt ty::resolved_mode(cx.tcx, m) {\n+      by_mutbl_ref { w.write_char('&'); }\n+      by_move { w.write_char('-'); }\n+      by_copy { w.write_char('+'); }\n+      by_ref { w.write_char('='); }\n+      by_val { w.write_char('#'); }\n+    }\n+}\n+\n fn enc_ty_fn(w: io::writer, cx: @ctxt, ft: ty::fn_ty) {\n     w.write_char('[');\n     for arg: ty::arg in ft.inputs {\n-        alt ty::resolved_mode(cx.tcx, arg.mode) {\n-          by_mutbl_ref { w.write_char('&'); }\n-          by_move { w.write_char('-'); }\n-          by_copy { w.write_char('+'); }\n-          by_ref { w.write_char('='); }\n-          by_val { w.write_char('#'); }\n-        }\n+        enc_mode(w, cx, arg.mode);\n         enc_ty(w, cx, arg.ty);\n     }\n     w.write_char(']');"}, {"sha": "79410158ad553f71e6b853a0e3d5514ef3239696", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -37,22 +37,42 @@ type map = std::map::map<node_id, ast_node>;\n type ctx = {map: map, mutable path: path, mutable local_id: uint};\n type vt = visit::vt<ctx>;\n \n-fn map_crate(c: crate) -> map {\n-    let cx = {map: std::map::new_int_hash(),\n-              mutable path: [],\n-              mutable local_id: 0u};\n-    visit::visit_crate(c, cx, visit::mk_vt(@{\n+fn mk_ast_map_visitor() -> vt {\n+    ret visit::mk_vt(@{\n         visit_item: map_item,\n         visit_native_item: map_native_item,\n         visit_expr: map_expr,\n         visit_fn: map_fn,\n         visit_local: map_local,\n         visit_arm: map_arm\n         with *visit::default_visitor()\n-    }));\n+    });\n+}\n+\n+fn map_crate(c: crate) -> map {\n+    let cx = {map: std::map::new_int_hash(),\n+              mutable path: [],\n+              mutable local_id: 0u};\n+    visit::visit_crate(c, cx, mk_ast_map_visitor());\n     ret cx.map;\n }\n \n+// Used for items loaded from external crate that are being inlined into this\n+// crate:\n+fn map_decoded_item(map: map, path: path, i: @item) {\n+    // I believe it is ok for the local IDs of inlined items from other crates\n+    // to overlap with the local ids from this crate, so just generate the ids\n+    // starting from 0.  (In particular, I think these ids are only used in\n+    // alias analysis, which we will not be running on the inlined items, and\n+    // even if we did I think it only needs an ordering between local\n+    // variables that are simultaneously in scope).\n+    let cx = {map: map,\n+              mutable path: path,\n+              mutable local_id: 0u};\n+    let v = mk_ast_map_visitor();\n+    v.visit_item(i, cx, v);\n+}\n+\n fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n           sp: codemap::span, id: node_id, cx: ctx, v: vt) {\n     for a in decl.inputs {"}, {"sha": "65a4ae627eac52463b3481a4c3b92367eee1cc4d", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -11,6 +11,7 @@ import syntax::codemap::span;\n export annotate_freevars;\n export freevar_map;\n export freevar_info;\n+export freevar_entry;\n export get_freevars;\n export has_freevars;\n "}, {"sha": "e212cfbcc439e26c4e08fcbf2fbd4cc3b9030299", "filename": "src/comp/middle/inline.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmiddle%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmiddle%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Finline.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -0,0 +1,96 @@\n+import std::map::hashmap;\n+import syntax::ast;\n+import syntax::ast_util;\n+import syntax::visit;\n+import middle::typeck::method_map;\n+import middle::trans::common::maps;\n+import metadata::csearch;\n+\n+export inline_map;\n+export instantiate_inlines;\n+\n+type inline_map = hashmap<ast::def_id, @ast::item>;\n+\n+enum ctxt = {\n+    tcx: ty::ctxt,\n+    maps: maps,\n+    inline_map: inline_map,\n+    mutable to_process: [@ast::item]\n+};\n+\n+fn instantiate_inlines(tcx: ty::ctxt,\n+                       maps: maps,\n+                       crate: @ast::crate) -> inline_map {\n+    let vt = visit::mk_vt(@{\n+        visit_expr: fn@(e: @ast::expr, cx: ctxt, vt: visit::vt<ctxt>) {\n+            visit::visit_expr(e, cx, vt);\n+            cx.visit_expr(e);\n+        }\n+        with *visit::default_visitor::<ctxt>()\n+    });\n+    let inline_map = ast_util::new_def_id_hash();\n+    let cx = ctxt({tcx: tcx, maps: maps,\n+                   inline_map: inline_map, mutable to_process: []});\n+    visit::visit_crate(*crate, cx, vt);\n+    while !vec::is_empty(cx.to_process) {\n+        let to_process = [];\n+        to_process <-> cx.to_process;\n+        #debug[\"Recursively looking at inlined items\"];\n+        vec::iter(to_process, {|i| visit::visit_item(i, cx, vt)});\n+    }\n+    ret inline_map;\n+}\n+\n+impl methods for ctxt {\n+    fn visit_expr(e: @ast::expr) {\n+\n+        // Look for fn items or methods that are referenced which\n+        // ought to be inlined.\n+\n+        alt e.node {\n+          ast::expr_path(_) {\n+            alt self.tcx.def_map.get(e.id) {\n+              ast::def_fn(did, _) {\n+                self.maybe_enqueue_fn(did);\n+              }\n+              _ { /* not a fn item, fallthrough */ }\n+            }\n+          }\n+          ast::expr_field(_, _, _) {\n+            alt self.maps.method_map.find(e.id) {\n+              some(origin) {\n+                self.maybe_enqueue_impl_method(origin);\n+              }\n+              _ { /* not an impl method, fallthrough */ }\n+            }\n+          }\n+          _ { /* fallthrough */ }\n+        }\n+    }\n+\n+    fn maybe_enqueue_fn(did: ast::def_id) {\n+        if did.crate == ast::local_crate { ret; }\n+        if self.inline_map.contains_key(did) { ret; }\n+        alt csearch::maybe_get_item_ast(self.tcx, self.maps, did) {\n+          none {\n+            /* no AST attached, do not inline */\n+            #debug[\"No AST attached to def %s\",\n+                   ty::item_path_str(self.tcx, did)];\n+          }\n+          some(item) { /* Found an AST, add to table: */\n+            #debug[\"Inlining def %s\", ty::item_path_str(self.tcx, did)];\n+            self.to_process += [item];\n+            self.inline_map.insert(did, item);\n+          }\n+        }\n+    }\n+\n+    fn maybe_enqueue_impl_method(_origin: typeck::method_origin) {\n+        // alt method_origin {\n+        //   method_static(did) { self.maybe_enqueue_fn(did); }\n+        //   method_param(_, _, _, _) | method_iface(_, _) {\n+        //     /* fallthrough */\n+        //   }\n+        // }\n+    }\n+}"}, {"sha": "9e5333ade64e13e429b1820dc36b1415f1e56213", "filename": "src/comp/middle/trans/alt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -585,7 +585,7 @@ fn make_phi_bindings(bcx: block, map: [exit_node],\n     if success {\n         // Copy references that the alias analysis considered unsafe\n         ids.values {|node_id|\n-            if bcx.ccx().copy_map.contains_key(node_id) {\n+            if bcx.ccx().maps.copy_map.contains_key(node_id) {\n                 let local = alt bcx.fcx.lllocals.find(node_id) {\n                   some(local_mem(x)) { x }\n                   _ { bcx.tcx().sess.bug(\"Someone \\\n@@ -675,7 +675,7 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n     alt pat.node {\n       ast::pat_ident(_,inner) {\n         if pat_is_variant(bcx.tcx().def_map, pat) { ret bcx; }\n-        if make_copy || ccx.copy_map.contains_key(pat.id) {\n+        if make_copy || ccx.maps.copy_map.contains_key(pat.id) {\n             let ty = node_id_type(bcx, pat.id);\n             let llty = type_of::type_of(ccx, ty);\n             let alloc = alloca(bcx, llty);"}, {"sha": "e05f4e12855f204fff8c4d07ec6e33e4d04b5e2e", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 74, "deletions": 27, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -21,6 +21,7 @@ import driver::session;\n import session::session;\n import front::attr;\n import middle::freevars::*;\n+import middle::inline::inline_map;\n import back::{link, abi, upcall};\n import syntax::{ast, ast_util, codemap};\n import ast_util::local_def;\n@@ -59,6 +60,14 @@ enum dest {\n     ignore,\n }\n \n+fn dest_str(ccx: crate_ctxt, d: dest) -> str {\n+    alt d {\n+      by_val(v) { #fmt[\"by_val(%s)\", val_str(ccx.tn, *v)] }\n+      save_in(v) { #fmt[\"save_in(%s)\", val_str(ccx.tn, v)] }\n+      ignore { \"ignore\" }\n+    }\n+}\n+\n fn empty_dest_cell() -> @mutable ValueRef {\n     ret @mutable llvm::LLVMGetUndef(T_nil());\n }\n@@ -1561,7 +1570,7 @@ fn trans_lit(cx: block, lit: ast::lit, dest: dest) -> block {\n fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n                un_expr: @ast::expr, dest: dest) -> block {\n     // Check for user-defined method call\n-    alt bcx.ccx().method_map.find(un_expr.id) {\n+    alt bcx.ccx().maps.method_map.find(un_expr.id) {\n       some(origin) {\n         let callee_id = ast_util::op_expr_callee_id(un_expr);\n         let fty = node_id_type(bcx, callee_id);\n@@ -1741,7 +1750,7 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n     assert (lhs_res.kind == owned);\n \n     // A user-defined operator method\n-    alt bcx.ccx().method_map.find(ex.id) {\n+    alt bcx.ccx().maps.method_map.find(ex.id) {\n       some(origin) {\n         let callee_id = ast_util::op_expr_callee_id(ex);\n         let fty = node_id_type(bcx, callee_id);\n@@ -1852,7 +1861,7 @@ fn trans_lazy_binop(bcx: block, op: lazy_binop_ty, a: @ast::expr,\n fn trans_binary(bcx: block, op: ast::binop, lhs: @ast::expr,\n                 rhs: @ast::expr, dest: dest, ex: @ast::expr) -> block {\n     // User-defined operators\n-    alt bcx.ccx().method_map.find(ex.id) {\n+    alt bcx.ccx().maps.method_map.find(ex.id) {\n       some(origin) {\n         let callee_id = ast_util::op_expr_callee_id(ex);\n         let fty = node_id_type(bcx, callee_id);\n@@ -2110,8 +2119,29 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n                   substs: option<([ty::t], typeck::dict_res)>)\n     -> lval_maybe_callee {\n     let ccx = bcx.ccx();\n+    let tcx = ccx.tcx;\n     let tys = node_id_type_params(bcx, id);\n-    let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n+    let tpt = ty::lookup_item_type(tcx, fn_id);\n+\n+    // Check whether this fn has an inlined copy and, if so, redirect fn_id to\n+    // the local id of the inlined copy.\n+    let fn_id = {\n+        if fn_id.crate == ast::local_crate {\n+            fn_id\n+        } else {\n+            alt ccx.inline_map.find(fn_id) {\n+              none { fn_id }\n+              some(item) {\n+                #debug[\"Found inlined version of %s with id %d\",\n+                       ty::item_path_str(tcx, fn_id),\n+                       item.id];\n+                {crate: ast::local_crate,\n+                 node: item.id}\n+              }\n+            }\n+        }\n+    };\n+\n     // The awkwardness below mostly stems from the fact that we're mixing\n     // monomorphized and non-monomorphized functions at the moment. If\n     // monomorphizing becomes the only approach, this'll be much simpler.\n@@ -2126,7 +2156,7 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n             } else { none }\n           }\n           none {\n-            alt ccx.dict_map.find(id) {\n+            alt ccx.maps.dict_map.find(id) {\n               some(dicts) {\n                 alt impl::resolve_dicts_in_fn_ctxt(bcx.fcx, dicts) {\n                   some(dicts) { monomorphic_fn(ccx, fn_id, tys, some(dicts)) }\n@@ -2146,6 +2176,7 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n           none {}\n         }\n     }\n+\n     let val = if fn_id.crate == ast::local_crate {\n         // Internal reference.\n         assert (ccx.item_ids.contains_key(fn_id.node));\n@@ -2181,7 +2212,7 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n                             static_tis: tis,\n                             tydescs: tydescs,\n                             param_bounds: tpt.bounds,\n-                            origins: ccx.dict_map.find(id)});\n+                            origins: ccx.maps.dict_map.find(id)});\n     }\n     ret {bcx: bcx, val: val, kind: owned, env: null_env, generic: gen};\n }\n@@ -2347,7 +2378,7 @@ fn trans_index(cx: block, ex: @ast::expr, base: @ast::expr,\n \n fn expr_is_lval(bcx: block, e: @ast::expr) -> bool {\n     let ccx = bcx.ccx();\n-    ty::expr_is_lval(ccx.method_map, e)\n+    ty::expr_is_lval(ccx.maps.method_map, e)\n }\n \n fn trans_callee(bcx: block, e: @ast::expr) -> lval_maybe_callee {\n@@ -2356,7 +2387,7 @@ fn trans_callee(bcx: block, e: @ast::expr) -> lval_maybe_callee {\n       ast::expr_field(base, ident, _) {\n         // Lval means this is a record field, so not a method\n         if !expr_is_lval(bcx, e) {\n-            alt bcx.ccx().method_map.find(e.id) {\n+            alt bcx.ccx().maps.method_map.find(e.id) {\n               some(origin) { // An impl method\n                 ret impl::trans_method_callee(bcx, e.id, base, origin);\n               }\n@@ -2553,7 +2584,7 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef,\n             val = do_spill_noroot(bcx, val);\n             copied = true;\n         }\n-        if ccx.copy_map.contains_key(e.id) && lv.kind != temporary {\n+        if ccx.maps.copy_map.contains_key(e.id) && lv.kind != temporary {\n             if !copied {\n                 let alloc = alloc_ty(bcx, e_ty);\n                 bcx = copy_val(alloc.bcx, INIT, alloc.val,\n@@ -2568,7 +2599,7 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef,\n     } else if arg_mode == ast::by_copy || arg_mode == ast::by_move {\n         let {bcx: cx, val: alloc} = alloc_ty(bcx, e_ty);\n         let move_out = arg_mode == ast::by_move ||\n-            ccx.last_uses.contains_key(e.id);\n+            ccx.maps.last_uses.contains_key(e.id);\n         bcx = cx;\n         if lv.kind == temporary { revoke_clean(bcx, val); }\n         if lv.kind == owned || !ty::type_is_immediate(e_ty) {\n@@ -2983,7 +3014,11 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n     let tcx = bcx.tcx();\n     debuginfo::update_source_pos(bcx, e.span);\n \n-    #debug[\"trans_expr(%s,%?)\", expr_to_str(e), dest];\n+    #debug[\"trans_expr(e=%s,e.id=%d,dest=%s,ty=%s)\",\n+           expr_to_str(e),\n+           e.id,\n+           dest_str(bcx.ccx(), dest),\n+           ty_to_str(tcx, expr_ty(bcx, e))];\n \n     if expr_is_lval(bcx, e) {\n         ret lval_to_dps(bcx, e, dest);\n@@ -3056,7 +3091,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n       }\n       ast::expr_index(base, idx) {\n         // If it is here, it's not an lval, so this is a user-defined index op\n-        let origin = bcx.ccx().method_map.get(e.id);\n+        let origin = bcx.ccx().maps.method_map.get(e.id);\n         let callee_id = ast_util::op_expr_callee_id(e);\n         let fty = node_id_type(bcx, callee_id);\n         ret trans_call_inner(bcx, fty, {|bcx|\n@@ -3128,7 +3163,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n         assert kind == owned;\n         ret store_temp_expr(bcx, DROP_EXISTING, addr, src_r,\n                             expr_ty(bcx, src),\n-                            bcx.ccx().last_uses.contains_key(src.id));\n+                            bcx.ccx().maps.last_uses.contains_key(src.id));\n       }\n       ast::expr_move(dst, src) {\n         // FIXME: calculate copy init-ness in typestate.\n@@ -3164,7 +3199,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n fn lval_to_dps(bcx: block, e: @ast::expr, dest: dest) -> block {\n     let lv = trans_lval(bcx, e), ccx = bcx.ccx();\n     let {bcx, val, kind} = lv;\n-    let last_use = kind == owned && ccx.last_uses.contains_key(e.id);\n+    let last_use = kind == owned && ccx.maps.last_uses.contains_key(e.id);\n     let ty = expr_ty(bcx, e);\n     alt dest {\n       by_val(cell) {\n@@ -3717,8 +3752,8 @@ fn alloc_local(cx: block, local: @ast::local) -> block {\n     // Do not allocate space for locals that can be kept immediate.\n     let ccx = cx.ccx();\n     if option::is_some(simple_name) &&\n-       !ccx.mutbl_map.contains_key(local.node.pat.id) &&\n-       !ccx.last_uses.contains_key(local.node.pat.id) &&\n+       !ccx.maps.mutbl_map.contains_key(local.node.pat.id) &&\n+       !ccx.maps.last_uses.contains_key(local.node.pat.id) &&\n        ty::type_is_immediate(t) {\n         alt local.node.init {\n           some({op: ast::init_assign, _}) { ret cx; }\n@@ -4258,6 +4293,12 @@ fn trans_mod(ccx: crate_ctxt, m: ast::_mod) {\n     for item in m.items { trans_item(ccx, *item); }\n }\n \n+fn trans_inlined_items(ccx: crate_ctxt, inline_map: inline_map) {\n+    inline_map.values {|item|\n+        trans_item(ccx, *item)\n+    }\n+}\n+\n fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n     // Bit of a kludge: pick the fn typeref out of the pair.\n     ret struct_elt(llpairty, 0u);\n@@ -4290,6 +4331,9 @@ fn register_fn_fuller(ccx: crate_ctxt, sp: span, path: path, _flav: str,\n     ccx.item_ids.insert(node_id, llfn);\n     ccx.item_symbols.insert(node_id, ps);\n \n+    #debug[\"register_fn_fuller created fn %s for item %d with path %s\",\n+           val_str(ccx.tn, llfn), node_id, ast_map::path_to_str(path)];\n+\n     let is_main = is_main_name(path) && !ccx.sess.building_library;\n     if is_main { create_main_wrapper(ccx, sp, llfn, node_type); }\n }\n@@ -4519,6 +4563,13 @@ fn collect_items(ccx: crate_ctxt, crate: @ast::crate) {\n     }));\n }\n \n+fn collect_inlined_items(ccx: crate_ctxt, inline_map: inline::inline_map) {\n+    let abi = @mutable none::<ast::native_abi>;\n+    inline_map.values {|item|\n+        collect_item(ccx, abi, item);\n+    }\n+}\n+\n // The constant translation pass.\n fn trans_constant(ccx: crate_ctxt, it: @ast::item) {\n     alt it.node {\n@@ -4718,10 +4769,8 @@ fn write_abi_version(ccx: crate_ctxt) {\n }\n \n fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n-               output: str, emap: resolve::exp_map, amap: ast_map::map,\n-               mutbl_map: mutbl::mutbl_map, copy_map: alias::copy_map,\n-               last_uses: last_use::last_uses, impl_map: resolve::impl_map,\n-               method_map: typeck::method_map, dict_map: typeck::dict_map)\n+               output: str, emap: resolve::exp_map, maps: maps,\n+               inline_map: inline::inline_map)\n     -> (ModuleRef, link::link_meta) {\n     let sha = std::sha1::mk_sha1();\n     let link_meta = link::build_link_meta(sess, *crate, output, sha);\n@@ -4769,6 +4818,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n     } else {\n         option::none\n     };\n+\n     let ccx =\n         @{sess: sess,\n           llmod: llmod,\n@@ -4777,7 +4827,6 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           externs: new_str_hash::<ValueRef>(),\n           intrinsics: intrinsics,\n           item_ids: new_int_hash::<ValueRef>(),\n-          ast_map: amap,\n           exp_map: emap,\n           item_symbols: new_int_hash::<str>(),\n           mutable main_fn: none::<ValueRef>,\n@@ -4796,12 +4845,8 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           type_sha1s: ty::new_ty_hash(),\n           type_short_names: ty::new_ty_hash(),\n           tcx: tcx,\n-          mutbl_map: mutbl_map,\n-          copy_map: copy_map,\n-          last_uses: last_uses,\n-          impl_map: impl_map,\n-          method_map: method_map,\n-          dict_map: dict_map,\n+          maps: maps,\n+          inline_map: inline_map,\n           stats:\n               {mutable n_static_tydescs: 0u,\n                mutable n_derived_tydescs: 0u,\n@@ -4823,8 +4868,10 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           dbg_cx: dbg_cx,\n           mutable do_not_commit_warning_issued: false};\n     collect_items(ccx, crate);\n+    collect_inlined_items(ccx, inline_map);\n     trans_constants(ccx, crate);\n     trans_mod(ccx, crate.node.module);\n+    trans_inlined_items(ccx, inline_map);\n     fill_crate_map(ccx, crate_map);\n     emit_tydescs(ccx);\n     gen_shape_tables(ccx);"}, {"sha": "767b2c0b6218f06174a40e8e70f43965dd2a6239", "filename": "src/comp/middle/trans/build.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbuild.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -322,6 +322,9 @@ fn Load(cx: block, PointerVal: ValueRef) -> ValueRef {\n \n fn Store(cx: block, Val: ValueRef, Ptr: ValueRef) {\n     if cx.unreachable { ret; }\n+    #debug[\"Store %s -> %s\",\n+           val_str(cx.ccx().tn, Val),\n+           val_str(cx.ccx().tn, Ptr)];\n     llvm::LLVMBuildStore(B(cx), Val, Ptr);\n }\n "}, {"sha": "d8a66750e90c39ff79c6f215064504d67ecd3993", "filename": "src/comp/middle/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -277,6 +277,7 @@ fn store_environment(\n     let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n     let cboxptr_ty = ty::mk_ptr(tcx, {ty:cbox_ty, mutbl:ast::m_imm});\n     let llbox = cast_if_we_can(bcx, llbox, cboxptr_ty);\n+    #debug[\"tuplify_box_ty = %s\", ty_to_str(tcx, cbox_ty)];\n \n     // If necessary, copy tydescs describing type parameters into the\n     // appropriate slot in the closure.\n@@ -298,8 +299,9 @@ fn store_environment(\n     }\n \n     // Copy expr values into boxed bindings.\n-    // Silly check\n     vec::iteri(bound_values) { |i, bv|\n+        #debug[\"Copy %s into closure\", ev_to_str(ccx, bv)];\n+\n         if (!ccx.sess.opts.no_asm_comments) {\n             add_comment(bcx, #fmt(\"Copy %s into closure\",\n                                   ev_to_str(ccx, bv)));"}, {"sha": "c546ce5341dd0cf9f1c78228d87b9d51a22c0156", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -19,6 +19,7 @@ import lib::llvm::{ModuleRef, ValueRef, TypeRef, BasicBlockRef, BuilderRef};\n import lib::llvm::{True, False, Bool};\n import metadata::csearch;\n import ast_map::path;\n+import middle::inline::inline_map;\n \n type namegen = fn@(str) -> str;\n fn new_namegen() -> namegen {\n@@ -63,6 +64,16 @@ type stats =\n \n resource BuilderRef_res(B: BuilderRef) { llvm::LLVMDisposeBuilder(B); }\n \n+// Misc. auxiliary maps used in the crate_ctxt\n+type maps = {\n+    mutbl_map: middle::mutbl::mutbl_map,\n+    copy_map: middle::alias::copy_map,\n+    last_uses: middle::last_use::last_uses,\n+    impl_map: middle::resolve::impl_map,\n+    method_map: middle::typeck::method_map,\n+    dict_map: middle::typeck::dict_map\n+};\n+\n // Crate context.  Every crate we compile has one of these.\n type crate_ctxt = @{\n      sess: session::session,\n@@ -72,7 +83,6 @@ type crate_ctxt = @{\n      externs: hashmap<str, ValueRef>,\n      intrinsics: hashmap<str, ValueRef>,\n      item_ids: hashmap<ast::node_id, ValueRef>,\n-     ast_map: ast_map::map,\n      exp_map: resolve::exp_map,\n      item_symbols: hashmap<ast::node_id, str>,\n      mutable main_fn: option<ValueRef>,\n@@ -91,12 +101,8 @@ type crate_ctxt = @{\n      type_sha1s: hashmap<ty::t, str>,\n      type_short_names: hashmap<ty::t, str>,\n      tcx: ty::ctxt,\n-     mutbl_map: mutbl::mutbl_map,\n-     copy_map: alias::copy_map,\n-     last_uses: last_use::last_uses,\n-     impl_map: resolve::impl_map,\n-     method_map: typeck::method_map,\n-     dict_map: typeck::dict_map,\n+     maps: maps,\n+     inline_map: inline_map,\n      stats: stats,\n      upcalls: @upcall::upcalls,\n      tydesc_type: TypeRef,"}, {"sha": "47a3d2e571660e55691ac2a5b3b4a34dad5aefd7", "filename": "src/comp/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -780,7 +780,7 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n     let sp = option::get(fcx.span);\n     log(debug, codemap::span_to_str(sp, cx.sess.codemap));\n \n-    let (ident, ret_ty, id) = alt cx.ast_map.get(fcx.id) {\n+    let (ident, ret_ty, id) = alt cx.tcx.items.get(fcx.id) {\n       ast_map::node_item(item, _) {\n         alt item.node {\n           ast::item_fn(decl, _, _) | ast::item_res(decl, _, _, _, _) {"}, {"sha": "00345e8ae021610da3163e300275f0c3afa4a1e6", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -134,7 +134,7 @@ fn trans_vtable_callee(bcx: block, env: callee_env, dict: ValueRef,\n                                 static_tis: tis,\n                                 tydescs: tydescs,\n                                 param_bounds: method.tps,\n-                                origins: ccx.dict_map.find(callee_id)});\n+                                origins: ccx.maps.dict_map.find(callee_id)});\n     }\n     {bcx: bcx, val: mptr, kind: owned,\n      env: env,\n@@ -531,7 +531,7 @@ fn trans_cast(bcx: block, val: @ast::expr, id: ast::node_id, dest: dest)\n     let result = get_dest_addr(dest);\n     Store(bcx, box, PointerCast(bcx, GEPi(bcx, result, [0, 1]),\n                                 T_ptr(val_ty(box))));\n-    let {bcx, val: dict} = get_dict(bcx, ccx.dict_map.get(id)[0]);\n+    let {bcx, val: dict} = get_dict(bcx, ccx.maps.dict_map.get(id)[0]);\n     Store(bcx, dict, PointerCast(bcx, GEPi(bcx, result, [0, 0]),\n                                  T_ptr(val_ty(dict))));\n     bcx"}, {"sha": "a7e218e581bdb940245eb22938a8475764cd9ed4", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -129,6 +129,7 @@ export param_bound, param_bounds, bound_copy, bound_send, bound_iface;\n export param_bounds_to_kind;\n export default_arg_mode_for_ty;\n export item_path;\n+export item_path_str;\n \n // Data types\n \n@@ -2174,6 +2175,10 @@ fn substd_enum_variants(cx: ctxt, id: ast::def_id, tps: [ty::t])\n     }\n }\n \n+fn item_path_str(cx: ctxt, id: ast::def_id) -> str {\n+    ast_map::path_to_str(item_path(cx, id))\n+}\n+\n fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n     if id.crate != ast::local_crate {\n         csearch::get_item_path(cx, id)"}, {"sha": "0343c2c102fba872936b4400dafd85a3ee68aa40", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -444,8 +444,18 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n         // call to resolve any named types.\n         let tpt = {\n             let t0 = ast_ty_to_ty(tcx, mode, t);\n-            {bounds: ty_param_bounds(tcx, mode, tps),\n-             ty: ty::mk_with_id(tcx, t0, def_id)}\n+            let t1 = {\n+                // Do not associate a def id with a named, parameterized type\n+                // like \"foo<X>\".  This is because otherwise ty_to_str will\n+                // print the name as merely \"foo\", as it has no way to\n+                // reconstruct the value of X.\n+                if vec::is_empty(tps) {\n+                    ty::mk_with_id(tcx, t0, def_id)\n+                } else {\n+                    t0\n+                }\n+            };\n+            {bounds: ty_param_bounds(tcx, mode, tps), ty: t1}\n         };\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;"}, {"sha": "8102e4d8cd803df7d816536c0dd2ca9c0affe79f", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -28,6 +28,7 @@ mod middle {\n         mod shape;\n         mod debuginfo;\n     }\n+    mod inline;\n     mod ty;\n     mod ast_map;\n     mod resolve;\n@@ -121,6 +122,8 @@ mod metadata {\n     mod common;\n     mod tyencode;\n     mod tydecode;\n+    mod astencode;\n+    mod astencode_gen;\n     mod encoder;\n     mod decoder;\n     mod creader;"}, {"sha": "d5b33971f8d36db664a4d17531224de822c03123", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -19,6 +19,14 @@ fn path_name_i(idents: [ident]) -> str { str::connect(idents, \"::\") }\n \n fn local_def(id: node_id) -> def_id { ret {crate: local_crate, node: id}; }\n \n+fn stmt_id(s: stmt) -> node_id {\n+    alt s.node {\n+      stmt_decl(_, id) { id }\n+      stmt_expr(_, id) { id }\n+      stmt_semi(_, id) { id }\n+    }\n+}\n+\n fn variant_def_ids(d: def) -> {enm: def_id, var: def_id} {\n     alt d { def_variant(enum_id, var_id) {\n             ret {enm: enum_id, var: var_id}; }"}, {"sha": "00624bdf270afb3fdf7e380c84f93c9a504d2d5c", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 54, "deletions": 25, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -125,9 +125,10 @@ fn fold_attribute_(at: attribute, fmi: fn@(&&@meta_item) -> @meta_item) ->\n }\n //used in noop_fold_native_item and noop_fold_fn_decl\n fn fold_arg_(a: arg, fld: ast_fold) -> arg {\n-    ret {ty: fld.fold_ty(a.ty),\n-         ident: fld.fold_ident(a.ident)\n-         with a};\n+    ret {mode: a.mode,\n+         ty: fld.fold_ty(a.ty),\n+         ident: fld.fold_ident(a.ident),\n+         id: fld.new_id(a.id)};\n }\n //used in noop_fold_expr, and possibly elsewhere in the future\n fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n@@ -156,6 +157,23 @@ fn fold_fn_decl(decl: ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n          constraints: vec::map(decl.constraints, fld.fold_constr)}\n }\n \n+fn fold_ty_param_bound(tpb: ty_param_bound, fld: ast_fold) -> ty_param_bound {\n+    alt tpb {\n+      bound_copy | bound_send { tpb }\n+      bound_iface(ty) { bound_iface(fld.fold_ty(ty)) }\n+    }\n+}\n+\n+fn fold_ty_param(tp: ty_param, fld: ast_fold) -> ty_param {\n+    {ident: tp.ident,\n+     id: fld.new_id(tp.id),\n+     bounds: @vec::map(*tp.bounds, fold_ty_param_bound(_, fld))}\n+}\n+\n+fn fold_ty_params(tps: [ty_param], fld: ast_fold) -> [ty_param] {\n+    vec::map(tps, fold_ty_param(_, fld))\n+}\n+\n fn noop_fold_crate(c: crate_, fld: ast_fold) -> crate_ {\n     let fold_meta_item = bind fold_meta_item_(_, fld);\n     let fold_attribute = bind fold_attribute_(_, fold_meta_item);\n@@ -202,11 +220,12 @@ fn noop_fold_native_item(&&ni: @native_item, fld: ast_fold) -> @native_item {\n                                   cf: fdec.cf,\n                                   constraints:\n                                       vec::map(fdec.constraints,\n-                                               fld.fold_constr)}, typms)\n+                                               fld.fold_constr)},\n+                                 fold_ty_params(typms, fld))\n                 }\n               },\n-          id: ni.id,\n-          span: ni.span};\n+          id: fld.new_id(ni.id),\n+          span: fld.new_span(ni.span)};\n }\n \n fn noop_fold_item(&&i: @item, fld: ast_fold) -> @item {\n@@ -215,9 +234,9 @@ fn noop_fold_item(&&i: @item, fld: ast_fold) -> @item {\n \n     ret @{ident: fld.fold_ident(i.ident),\n           attrs: vec::map(i.attrs, fold_attribute),\n-          id: i.id,\n+          id: fld.new_id(i.id),\n           node: fld.fold_item_underscore(i.node),\n-          span: i.span};\n+          span: fld.new_span(i.span)};\n }\n \n fn noop_fold_class_item(&&ci: @class_item, fld: ast_fold)\n@@ -238,17 +257,20 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n     ret alt i {\n           item_const(t, e) { item_const(fld.fold_ty(t), fld.fold_expr(e)) }\n           item_fn(decl, typms, body) {\n-              let body = fld.fold_block(body);\n-              item_fn(fold_fn_decl(decl, fld), typms, body)\n+              item_fn(fold_fn_decl(decl, fld),\n+                      fold_ty_params(typms, fld),\n+                      fld.fold_block(body))\n           }\n           item_mod(m) { item_mod(fld.fold_mod(m)) }\n           item_native_mod(nm) { item_native_mod(fld.fold_native_mod(nm)) }\n-          item_ty(t, typms) { item_ty(fld.fold_ty(t), typms) }\n+          item_ty(t, typms) { item_ty(fld.fold_ty(t),\n+                                      fold_ty_params(typms, fld)) }\n           item_enum(variants, typms) {\n-            item_enum(vec::map(variants, fld.fold_variant), typms)\n+            item_enum(vec::map(variants, fld.fold_variant),\n+                      fold_ty_params(typms, fld))\n           }\n           item_class(typms, items, id, ctor_decl, ctor_body) {\n-              item_class(typms,\n+              item_class(fold_ty_params(typms, fld),\n                          vec::map(items, fld.fold_class_item),\n                          id,\n                          fold_fn_decl(ctor_decl, fld),\n@@ -260,32 +282,39 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n           }\n           item_iface(tps, methods) { item_iface(tps, methods) }\n           item_res(decl, typms, body, did, cid) {\n-            item_res(fold_fn_decl(decl, fld), typms, fld.fold_block(body),\n-                     did, cid)\n+            item_res(fold_fn_decl(decl, fld),\n+                     fold_ty_params(typms, fld),\n+                     fld.fold_block(body),\n+                     did,\n+                     cid)\n           }\n         };\n }\n \n fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n     ret @{ident: fld.fold_ident(m.ident),\n+          attrs: m.attrs,\n+          tps: fold_ty_params(m.tps, fld),\n           decl: fold_fn_decl(m.decl, fld),\n-          body: fld.fold_block(m.body) with *m};\n+          body: fld.fold_block(m.body),\n+          id: fld.new_id(m.id),\n+          span: fld.new_span(m.span)};\n }\n \n \n fn noop_fold_block(b: blk_, fld: ast_fold) -> blk_ {\n     ret {view_items: vec::map(b.view_items, fld.fold_view_item),\n          stmts: vec::map(b.stmts, fld.fold_stmt),\n          expr: option::map(b.expr, fld.fold_expr),\n-         id: b.id,\n+         id: fld.new_id(b.id),\n          rules: b.rules};\n }\n \n fn noop_fold_stmt(s: stmt_, fld: ast_fold) -> stmt_ {\n     ret alt s {\n-      stmt_decl(d, nid) { stmt_decl(fld.fold_decl(d), nid) }\n-      stmt_expr(e, nid) { stmt_expr(fld.fold_expr(e), nid) }\n-      stmt_semi(e, nid) { stmt_semi(fld.fold_expr(e), nid) }\n+      stmt_decl(d, nid) { stmt_decl(fld.fold_decl(d), fld.new_id(nid)) }\n+      stmt_expr(e, nid) { stmt_expr(fld.fold_expr(e), fld.new_id(nid)) }\n+      stmt_semi(e, nid) { stmt_semi(fld.fold_expr(e), fld.new_id(nid)) }\n     };\n }\n \n@@ -459,7 +488,7 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n }\n \n fn noop_fold_constr(c: constr_, fld: ast_fold) -> constr_ {\n-    {path: fld.fold_path(c.path), args: c.args, id: c.id}\n+    {path: fld.fold_path(c.path), args: c.args, id: fld.new_id(c.id)}\n }\n \n // ...nor do modules\n@@ -475,7 +504,7 @@ fn noop_fold_native_mod(nm: native_mod, fld: ast_fold) -> native_mod {\n \n fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n     fn fold_variant_arg_(va: variant_arg, fld: ast_fold) -> variant_arg {\n-        ret {ty: fld.fold_ty(va.ty), id: va.id};\n+        ret {ty: fld.fold_ty(va.ty), id: fld.new_id(va.id)};\n     }\n     let fold_variant_arg = bind fold_variant_arg_(_, fld);\n     let args = vec::map(v.args, fold_variant_arg);\n@@ -490,7 +519,7 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n     };\n     ret {name: v.name,\n          attrs: attrs,\n-         args: args, id: v.id,\n+         args: args, id: fld.new_id(v.id),\n          disr_expr: de};\n }\n \n@@ -513,7 +542,7 @@ fn noop_fold_local(l: local_, fld: ast_fold) -> local_ {\n                                               expr: fld.fold_expr(init.expr)})\n                }\n              },\n-         id: l.id};\n+         id: fld.new_id(l.id)};\n }\n \n /* temporarily eta-expand because of a compiler bug with using `fn<T>` as a\n@@ -621,7 +650,7 @@ fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n            class_method(i) {\n                class_method(afp.fold_item(i, f))\n            }\n-            }}, span: ci.span}\n+            }}, span: afp.new_span(ci.span)}\n     }\n     fn f_item_underscore(afp: ast_fold_precursor, f: ast_fold, i: item_) ->\n        item_ {"}, {"sha": "0de75d88422e329464cb3662c6d7fb51cb44e4af", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -2280,9 +2280,6 @@ fn fn_expr_lookahead(tok: token::token) -> bool {\n fn parse_item(p: parser, attrs: [ast::attribute]) -> option<@ast::item> {\n     if eat_word(p, \"const\") {\n         ret some(parse_item_const(p, attrs));\n-    } else if eat_word(p, \"inline\") {\n-        expect_word(p, \"fn\");\n-        ret some(parse_item_fn(p, ast::impure_fn, attrs));\n     } else if is_word(p, \"fn\") && !fn_expr_lookahead(p.look_ahead(1u)) {\n         p.bump();\n         ret some(parse_item_fn(p, ast::impure_fn, attrs));"}, {"sha": "5f92b5d5bebc91a0048510f9bb09327609eaa6ac", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -89,6 +89,8 @@ fn stmt_to_str(s: ast::stmt) -> str { be to_str(s, print_stmt); }\n \n fn item_to_str(i: @ast::item) -> str { be to_str(i, print_item); }\n \n+fn attr_to_str(i: ast::attribute) -> str { be to_str(i, print_attribute); }\n+\n fn typarams_to_str(tps: [ast::ty_param]) -> str {\n     be to_str(tps, print_type_params)\n }"}, {"sha": "9e598fafe2f024669e80102d5c8cfc7688d352c5", "filename": "src/etc/gen-astencode", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fetc%2Fgen-astencode", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fetc%2Fgen-astencode", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgen-astencode?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -0,0 +1,57 @@\n+#!/bin/sh\n+\n+M=src/comp/metadata\n+GEN_TYPES=\"syntax::ast::item syntax::ast::def middle::typeck::method_origin \\\n+           middle::freevars::freevar_entry syntax::ast::def_id\"\n+\n+# Find serializer tool:\n+for S in build/*/stage2/bin/serializer; do\n+\n+    # Find rustc:\n+    D=$(dirname \"$S\")\n+    R=\"${D}/rustc\"\n+    if [ ! -x \"$R\" ]; then\n+        echo \"rustc not found or not executable at path '$R'\"\n+        exit 1\n+    fi\n+\n+    echo \"Generating src/comp/metadata/astencode_gen.rs\"\n+\n+    # First, generate dummy fns so that the compiler can type\n+    # everything.\n+    echo \"// TEMPORARY DEFINITIONS: re-run gen-astencode\" \\\n+        > $M/astencode_gen.rs\n+    for T in $GEN_TYPES; do\n+      echo \"fn serialize_${T//::/_}<S>(_s: S, _v: $T) {}\" \\\n+          >> $M/astencode_gen.rs\n+      echo \"fn deserialize_${T//::/_}<S>(_s: S) -> $T { fail; }\" \\\n+          >> $M/astencode_gen.rs\n+    done\n+\n+    # Generate the real code into a temporary file.\n+    if ! \"$S\" src/comp/rustc.rc $GEN_TYPES > tmp.$$.rs\n+    then\n+        echo \"\"\n+        echo \"\"\n+        echo \"****************************************\"\n+        echo \"* Compilation errors encountered       *\"\n+        echo \"*                                      *\"\n+        echo \"* Dummy versions of the AST encoder    *\"\n+        echo \"* have been left in astencode_gen.rs.  *\"\n+        echo \"* Fix the compilation errors and rerun *\"\n+        echo \"* this script to generate the real     *\"\n+        echo \"* versions.                            *\"\n+        echo \"****************************************\"\n+        rm tmp.$$.rs\n+        exit 1\n+    fi\n+\n+    # Copy over into the final destination and clean up.\n+    \"$R\" --pretty normal tmp.$$.rs > $M/astencode_gen.rs\n+    # rm -f tmp.$$.rs\n+    exit 0\n+done\n+\n+# If we made it this far, must not have found any\n+# serializer:\n+echo \"serializer tool not found.\""}, {"sha": "ca57f686dbbdf560b96a4475752505c3bd856ee1", "filename": "src/etc/tidy.py", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fetc%2Ftidy.py", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fetc%2Ftidy.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftidy.py?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -18,8 +18,11 @@ def report_err(s):\n     print(\"%s:%d: %s\" % (fileinput.filename(), fileinput.filelineno(), s))\n     err=1\n \n+file_names = [s for s in sys.argv[1:] if not s.endswith(\"_gen.rs\")]\n+\n try:\n-    for line in fileinput.input(openhook=fileinput.hook_encoded(\"utf-8\")):\n+    for line in fileinput.input(file_names,\n+                                openhook=fileinput.hook_encoded(\"utf-8\")):\n         if (line.find('\\t') != -1 and\n             fileinput.filename().find(\"Makefile\") == -1):\n             report_err(\"tab character\")"}, {"sha": "52cb3adbc5a12f5ead8debbffcfdb9f1cbfc58d3", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -407,7 +407,6 @@ fn pop<T>(&v: [const T]) -> T unsafe {\n     val\n }\n \n-#[inline]\n /*\n Function: push\n "}, {"sha": "9e39042ded150a484d7e58001d35ece6b5055928", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 128, "deletions": 81, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -6,11 +6,31 @@\n import core::option;\n import option::{some, none};\n \n+export doc;\n+\n+export new_doc;\n+export doc_at;\n+export maybe_get_doc;\n+export get_doc;\n+export docs;\n+export tagged_docs;\n+export doc_data;\n+export doc_as_str;\n+export doc_as_u8;\n+export doc_as_u16;\n+export doc_as_u32;\n+export doc_as_u64;\n+export doc_as_i8;\n+export doc_as_i16;\n+export doc_as_i32;\n+export doc_as_i64;\n+export writer;\n+export mk_writer;\n+\n type ebml_tag = {id: uint, size: uint};\n \n type ebml_state = {ebml_tag: ebml_tag, tag_pos: uint, data_pos: uint};\n \n-\n // TODO: When we have module renaming, make \"reader\" and \"writer\" separate\n // modules within this file.\n \n@@ -19,35 +39,29 @@ type doc = {data: @[u8], start: uint, end: uint};\n \n type tagged_doc = {tag: uint, doc: doc};\n \n-fn vu64_at(data: [u8], start: uint) -> {val: u64, next: uint} {\n+fn vuint_at(data: [u8], start: uint) -> {val: uint, next: uint} {\n     let a = data[start];\n     if a & 0x80u8 != 0u8 {\n-        ret {val: (a & 0x7fu8) as u64, next: start + 1u};\n+        ret {val: (a & 0x7fu8) as uint, next: start + 1u};\n     }\n     if a & 0x40u8 != 0u8 {\n-        ret {val: ((a & 0x3fu8) as u64) << 8u64 |\n-                 (data[start + 1u] as u64),\n+        ret {val: ((a & 0x3fu8) as uint) << 8u |\n+                 (data[start + 1u] as uint),\n              next: start + 2u};\n     } else if a & 0x20u8 != 0u8 {\n-        ret {val: ((a & 0x1fu8) as u64) << 16u64 |\n-                 (data[start + 1u] as u64) << 8u64 |\n-                 (data[start + 2u] as u64),\n+        ret {val: ((a & 0x1fu8) as uint) << 16u |\n+                 (data[start + 1u] as uint) << 8u |\n+                 (data[start + 2u] as uint),\n              next: start + 3u};\n     } else if a & 0x10u8 != 0u8 {\n-        ret {val: ((a & 0x0fu8) as u64) << 24u64 |\n-                 (data[start + 1u] as u64) << 16u64 |\n-                 (data[start + 2u] as u64) << 8u64 |\n-                 (data[start + 3u] as u64),\n+        ret {val: ((a & 0x0fu8) as uint) << 24u |\n+                 (data[start + 1u] as uint) << 16u |\n+                 (data[start + 2u] as uint) << 8u |\n+                 (data[start + 3u] as uint),\n              next: start + 4u};\n     } else { #error(\"vint too big\"); fail; }\n }\n \n-fn vuint_at(data: [u8], start: uint) -> {val: uint, next: uint} {\n-    let {val, next} = vu64_at(data, start);\n-    ret {val: val as uint, next: next};\n-}\n-\n-\n fn new_doc(data: @[u8]) -> doc {\n     ret {data: data, start: 0u, end: vec::len::<u8>(*data)};\n }\n@@ -77,7 +91,7 @@ fn get_doc(d: doc, tg: uint) -> doc {\n     alt maybe_get_doc(d, tg) {\n       some(d) { ret d; }\n       none {\n-        #error(\"failed to find block with enum %u\", tg);\n+        #error(\"failed to find block with tag %u\", tg);\n         fail;\n       }\n     }\n@@ -107,111 +121,144 @@ fn tagged_docs(d: doc, tg: uint, it: fn(doc)) {\n \n fn doc_data(d: doc) -> [u8] { ret vec::slice::<u8>(*d.data, d.start, d.end); }\n \n-fn doc_str(d: doc) -> str { ret str::from_bytes(doc_data(d)); }\n-\n-fn be_u64_from_bytes(data: @[u8], start: uint, size: uint) -> u64 {\n-    let sz = size;\n-    assert (sz <= 4u);\n-    let val = 0_u64;\n-    let pos = start;\n-    while sz > 0u {\n-        sz -= 1u;\n-        val += (data[pos] as u64) << ((sz * 8u) as u64);\n-        pos += 1u;\n-    }\n-    ret val;\n-}\n+fn doc_as_str(d: doc) -> str { ret str::from_bytes(doc_data(d)); }\n \n fn doc_as_u8(d: doc) -> u8 {\n     assert d.end == d.start + 1u;\n     ret (*d.data)[d.start];\n }\n \n-fn doc_as_vu64(d: doc) -> u64 {\n-    ret vu64_at(*d.data, d.start).val;\n+fn doc_as_u16(d: doc) -> u16 {\n+    assert d.end == d.start + 2u;\n+    ret io::u64_from_be_bytes(*d.data, d.start, 2u) as u16;\n+}\n+\n+fn doc_as_u32(d: doc) -> u32 {\n+    assert d.end == d.start + 4u;\n+    ret io::u64_from_be_bytes(*d.data, d.start, 4u) as u32;\n }\n \n-fn doc_as_vuint(d: doc) -> uint {\n-    ret vuint_at(*d.data, d.start).val;\n+fn doc_as_u64(d: doc) -> u64 {\n+    assert d.end == d.start + 8u;\n+    ret io::u64_from_be_bytes(*d.data, d.start, 8u);\n }\n \n+fn doc_as_i8(d: doc) -> i8 { doc_as_u8(d) as i8 }\n+fn doc_as_i16(d: doc) -> i16 { doc_as_u16(d) as i16 }\n+fn doc_as_i32(d: doc) -> i32 { doc_as_u32(d) as i32 }\n+fn doc_as_i64(d: doc) -> i64 { doc_as_u64(d) as i64 }\n+\n // ebml writing\n type writer = {writer: io::writer, mutable size_positions: [uint]};\n \n-fn write_sized_vu64(w: io::writer, n: u64, size: uint) {\n+fn write_sized_vuint(w: io::writer, n: uint, size: uint) {\n     let buf: [u8];\n     alt size {\n       1u { buf = [0x80u8 | (n as u8)]; }\n-      2u { buf = [0x40u8 | ((n >> 8_u64) as u8), n as u8]; }\n+      2u { buf = [0x40u8 | ((n >> 8_u) as u8), n as u8]; }\n       3u {\n-        buf = [0x20u8 | ((n >> 16_u64) as u8), (n >> 8_u64) as u8,\n+        buf = [0x20u8 | ((n >> 16_u) as u8), (n >> 8_u) as u8,\n                n as u8];\n       }\n       4u {\n-        buf = [0x10u8 | ((n >> 24_u64) as u8), (n >> 16_u64) as u8,\n-               (n >> 8_u64) as u8, n as u8];\n+        buf = [0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n+               (n >> 8_u) as u8, n as u8];\n       }\n-      _ { #error(\"vint to write too big\"); fail; }\n+      _ { fail #fmt(\"vint to write too big: %?\", n); }\n     }\n     w.write(buf);\n }\n \n-fn write_vu64(w: io::writer, n: u64) {\n-    if n < 0x7f_u64 { write_sized_vu64(w, n, 1u); ret; }\n-    if n < 0x4000_u64 { write_sized_vu64(w, n, 2u); ret; }\n-    if n < 0x200000_u64 { write_sized_vu64(w, n, 3u); ret; }\n-    if n < 0x10000000_u64 { write_sized_vu64(w, n, 4u); ret; }\n-    #error(\"vint to write too big\");\n-    fail;\n+fn write_vuint(w: io::writer, n: uint) {\n+    if n < 0x7f_u { write_sized_vuint(w, n, 1u); ret; }\n+    if n < 0x4000_u { write_sized_vuint(w, n, 2u); ret; }\n+    if n < 0x200000_u { write_sized_vuint(w, n, 3u); ret; }\n+    if n < 0x10000000_u { write_sized_vuint(w, n, 4u); ret; }\n+    fail #fmt(\"vint to write too big: %?\", n);\n }\n \n-fn create_writer(w: io::writer) -> writer {\n+fn mk_writer(w: io::writer) -> writer {\n     let size_positions: [uint] = [];\n     ret {writer: w, mutable size_positions: size_positions};\n }\n \n-\n // TODO: Provide a function to write the standard ebml header.\n-fn start_tag(w: writer, tag_id: uint) {\n-    #debug[\"Start tag %u\", tag_id];\n+impl writer for writer {\n+    fn start_tag(tag_id: uint) {\n+        #debug[\"Start tag %u\", tag_id];\n \n-    // Write the enum ID:\n-    write_vu64(w.writer, tag_id as u64);\n+        // Write the enum ID:\n+        write_vuint(self.writer, tag_id);\n \n-    // Write a placeholder four-byte size.\n-    w.size_positions += [w.writer.tell()];\n-    let zeroes: [u8] = [0u8, 0u8, 0u8, 0u8];\n-    w.writer.write(zeroes);\n-}\n+        // Write a placeholder four-byte size.\n+        self.size_positions += [self.writer.tell()];\n+        let zeroes: [u8] = [0u8, 0u8, 0u8, 0u8];\n+        self.writer.write(zeroes);\n+    }\n \n-fn end_tag(w: writer) {\n-    let last_size_pos = vec::pop::<uint>(w.size_positions);\n-    let cur_pos = w.writer.tell();\n-    w.writer.seek(last_size_pos as int, io::seek_set);\n-    let size = (cur_pos - last_size_pos - 4u);\n-    write_sized_vu64(w.writer, size as u64, 4u);\n-    w.writer.seek(cur_pos as int, io::seek_set);\n+    fn end_tag() {\n+        let last_size_pos = vec::pop::<uint>(self.size_positions);\n+        let cur_pos = self.writer.tell();\n+        self.writer.seek(last_size_pos as int, io::seek_set);\n+        let size = (cur_pos - last_size_pos - 4u);\n+        write_sized_vuint(self.writer, size, 4u);\n+        self.writer.seek(cur_pos as int, io::seek_set);\n \n-    #debug[\"End tag (size = %u)\", size];\n-}\n+        #debug[\"End tag (size = %u)\", size];\n+    }\n \n-impl writer_util for writer {\n     fn wr_tag(tag_id: uint, blk: fn()) {\n-        start_tag(self, tag_id);\n+        self.start_tag(tag_id);\n         blk();\n-        end_tag(self);\n+        self.end_tag();\n     }\n \n-    fn wr_vu64(id: u64) {\n-        #debug[\"Write u64 0x%02x%02x\",\n-               (id >> 32u64) as uint,\n-               (id & 0xFFFFFFFFu64) as uint];\n-        write_vu64(self.writer, id);\n+    fn wr_tagged_bytes(tag_id: uint, b: [u8]) {\n+        write_vuint(self.writer, tag_id);\n+        write_vuint(self.writer, vec::len(b));\n+        self.writer.write(b);\n+    }\n+\n+    fn wr_tagged_u64(tag_id: uint, v: u64) {\n+        self.wr_tagged_bytes(tag_id, io::u64_to_be_bytes(v, 8u));\n+    }\n+\n+    fn wr_tagged_u32(tag_id: uint, v: u32) {\n+        self.wr_tagged_bytes(tag_id, io::u64_to_be_bytes(v as u64, 4u));\n+    }\n+\n+    fn wr_tagged_u16(tag_id: uint, v: u16) {\n+        self.wr_tagged_bytes(tag_id, io::u64_to_be_bytes(v as u64, 2u));\n+    }\n+\n+    fn wr_tagged_u8(tag_id: uint, v: u8) {\n+        self.wr_tagged_bytes(tag_id, [v]);\n     }\n \n-    fn wr_vuint(id: uint) {\n-        #debug[\"Write uint: %u\", id];\n-        write_vu64(self.writer, id as u64);\n+    fn wr_tagged_i64(tag_id: uint, v: i64) {\n+        self.wr_tagged_bytes(tag_id, io::u64_to_be_bytes(v as u64, 8u));\n+    }\n+\n+    fn wr_tagged_i32(tag_id: uint, v: i32) {\n+        self.wr_tagged_bytes(tag_id, io::u64_to_be_bytes(v as u64, 4u));\n+    }\n+\n+    fn wr_tagged_i16(tag_id: uint, v: i16) {\n+        self.wr_tagged_bytes(tag_id, io::u64_to_be_bytes(v as u64, 2u));\n+    }\n+\n+    fn wr_tagged_i8(tag_id: uint, v: i8) {\n+        self.wr_tagged_bytes(tag_id, [v as u8]);\n+    }\n+\n+    fn wr_tagged_str(tag_id: uint, v: str) {\n+        // Lame: can't use str::as_bytes() here because the resulting\n+        // vector is NULL-terminated.  Annoyingly, the underlying\n+        // writer interface doesn't permit us to write a slice of a\n+        // vector.  We need first-class slices, I think.\n+\n+        // str::as_bytes(v) {|b| self.wr_tagged_bytes(tag_id, b); }\n+        self.wr_tagged_bytes(tag_id, str::bytes(v));\n     }\n \n     fn wr_bytes(b: [u8]) {"}, {"sha": "1efd91d54dbd82bafd7a601445eb8a9bfd92f33d", "filename": "src/libstd/io.rs", "status": "modified", "additions": 52, "deletions": 8, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -366,19 +366,41 @@ fn mk_file_writer(path: str, flags: [fileflag])\n     }\n }\n \n-fn uint_to_le_bytes(n: uint, size: uint) -> [u8] {\n+fn u64_to_le_bytes(n: u64, size: uint) -> [u8] {\n     let bytes: [u8] = [], i = size, n = n;\n-    while i > 0u { bytes += [(n & 255u) as u8]; n >>= 8u; i -= 1u; }\n+    while i > 0u {\n+        bytes += [(n & 255_u64) as u8];\n+        n >>= 8_u64;\n+        i -= 1u;\n+    }\n     ret bytes;\n }\n \n-fn uint_to_be_bytes(n: uint, size: uint) -> [u8] {\n+fn u64_to_be_bytes(n: u64, size: uint) -> [u8] {\n+    assert size <= 8u;\n     let bytes: [u8] = [];\n-    let i = (size - 1u) as int;\n-    while i >= 0 { bytes += [(n >> ((i * 8) as uint) & 255u) as u8]; i -= 1; }\n+    let i = size;\n+    while i > 0u {\n+        let shift = ((i - 1u) * 8u) as u64;\n+        bytes += [(n >> shift) as u8];\n+        i -= 1u;\n+    }\n     ret bytes;\n }\n \n+fn u64_from_be_bytes(data: [u8], start: uint, size: uint) -> u64 {\n+    let sz = size;\n+    assert (sz <= 8u);\n+    let val = 0_u64;\n+    let pos = start;\n+    while sz > 0u {\n+        sz -= 1u;\n+        val += (data[pos] as u64) << ((sz * 8u) as u64);\n+        pos += 1u;\n+    }\n+    ret val;\n+}\n+\n impl writer_util for writer {\n     fn write_char(ch: char) {\n         if ch as uint < 128u {\n@@ -393,14 +415,36 @@ impl writer_util for writer {\n     fn write_uint(n: uint) { self.write(str::bytes(uint::to_str(n, 10u))); }\n \n     fn write_le_uint(n: uint, size: uint) {\n-        self.write(uint_to_le_bytes(n, size));\n+        self.write(u64_to_le_bytes(n as u64, size));\n     }\n     fn write_le_int(n: int, size: uint) {\n-        self.write(uint_to_le_bytes(n as uint, size));\n+        self.write(u64_to_le_bytes(n as u64, size));\n     }\n+\n     fn write_be_uint(n: uint, size: uint) {\n-        self.write(uint_to_be_bytes(n, size));\n+        self.write(u64_to_be_bytes(n as u64, size));\n+    }\n+    fn write_be_int(n: int, size: uint) {\n+        self.write(u64_to_be_bytes(n as u64, size));\n     }\n+\n+    fn write_be_u64(n: u64) { self.write(u64_to_be_bytes(n, 8u)); }\n+    fn write_be_u32(n: u32) { self.write(u64_to_be_bytes(n as u64, 4u)); }\n+    fn write_be_u16(n: u16) { self.write(u64_to_be_bytes(n as u64, 2u)); }\n+\n+    fn write_be_i64(n: i64) { self.write(u64_to_be_bytes(n as u64, 8u)); }\n+    fn write_be_i32(n: i32) { self.write(u64_to_be_bytes(n as u64, 4u)); }\n+    fn write_be_i16(n: i16) { self.write(u64_to_be_bytes(n as u64, 2u)); }\n+\n+    fn write_le_u64(n: u64) { self.write(u64_to_le_bytes(n, 8u)); }\n+    fn write_le_u32(n: u32) { self.write(u64_to_le_bytes(n as u64, 4u)); }\n+    fn write_le_u16(n: u16) { self.write(u64_to_le_bytes(n as u64, 2u)); }\n+\n+    fn write_le_i64(n: i64) { self.write(u64_to_le_bytes(n as u64, 8u)); }\n+    fn write_le_i32(n: i32) { self.write(u64_to_le_bytes(n as u64, 4u)); }\n+    fn write_le_i16(n: i16) { self.write(u64_to_le_bytes(n as u64, 2u)); }\n+\n+    fn write_u8(n: u8) { self.write([n]) }\n }\n \n fn file_writer(path: str, flags: [fileflag]) -> result::t<writer, str> {"}, {"sha": "c1c862cd386cadae3735ed2395176a9f87ab1a87", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 129, "deletions": 27, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -5,15 +5,25 @@ Support code for serialization.\n */\n \n import list::list;\n-import ebml::writer_util;\n+import ebml::writer;\n \n iface serializer {\n     // Primitive types:\n     fn emit_nil();\n+    fn emit_uint(v: uint);\n     fn emit_u64(v: u64);\n+    fn emit_u32(v: u32);\n+    fn emit_u16(v: u16);\n+    fn emit_u8(v: u8);\n+    fn emit_int(v: int);\n     fn emit_i64(v: i64);\n+    fn emit_i32(v: i32);\n+    fn emit_i16(v: i16);\n+    fn emit_i8(v: i8);\n     fn emit_bool(v: bool);\n+    fn emit_float(v: float);\n     fn emit_f64(v: f64);\n+    fn emit_f32(v: f32);\n     fn emit_str(v: str);\n \n     // Compound types:\n@@ -33,12 +43,28 @@ iface serializer {\n iface deserializer {\n     // Primitive types:\n     fn read_nil() -> ();\n+\n+    fn read_uint() -> uint;\n     fn read_u64() -> u64;\n+    fn read_u32() -> u32;\n+    fn read_u16() -> u16;\n+    fn read_u8() -> u8;\n+\n+    fn read_int() -> int;\n     fn read_i64() -> i64;\n+    fn read_i32() -> i32;\n+    fn read_i16() -> i16;\n+    fn read_i8() -> i8;\n+\n+\n     fn read_bool() -> bool;\n-    fn read_f64() -> f64;\n+\n     fn read_str() -> str;\n \n+    fn read_f64() -> f64;\n+    fn read_f32() -> f32;\n+    fn read_float() -> float;\n+\n     // Compound types:\n     fn read_enum<T:copy>(name: str, f: fn() -> T) -> T;\n     fn read_enum_variant<T:copy>(f: fn(uint) -> T) -> T;\n@@ -54,47 +80,66 @@ iface deserializer {\n }\n \n enum ebml_serializer_tag {\n-    es_u64, es_i64, es_bool,\n+    es_uint, es_u64, es_u32, es_u16, es_u8,\n+    es_int, es_i64, es_i32, es_i16, es_i8,\n+    es_bool,\n     es_str,\n+    es_f64, es_f32, es_float,\n     es_enum, es_enum_vid, es_enum_body,\n     es_vec, es_vec_len, es_vec_elt\n }\n \n impl of serializer for ebml::writer {\n     fn emit_nil() {}\n \n-    fn emit_num(tag: ebml_serializer_tag, v: u64) {\n-        self.wr_tag(tag as uint) {|| self.wr_vu64(v) }\n+    // used internally to emit things like the vector length and so on\n+    fn _emit_tagged_uint(t: ebml_serializer_tag, v: uint) {\n+        assert v <= 0xFFFF_FFFF_u;\n+        self.wr_tagged_u32(t as uint, v as u32);\n     }\n \n-    fn emit_u64(v: u64) { self.emit_num(es_u64, v) }\n-    fn emit_i64(v: i64) { self.emit_num(es_i64, v as u64) }\n-    fn emit_bool(v: bool) { self.emit_num(es_bool, v as u64) }\n+    fn emit_uint(v: uint) { self.wr_tagged_u64(es_uint as uint, v as u64); }\n+    fn emit_u64(v: u64) { self.wr_tagged_u64(es_u64 as uint, v); }\n+    fn emit_u32(v: u32) { self.wr_tagged_u32(es_u32 as uint, v); }\n+    fn emit_u16(v: u16) { self.wr_tagged_u16(es_u16 as uint, v); }\n+    fn emit_u8(v: u8)   { self.wr_tagged_u8 (es_u8  as uint, v); }\n+\n+    fn emit_int(v: int) { self.wr_tagged_i64(es_int as uint, v as i64); }\n+    fn emit_i64(v: i64) { self.wr_tagged_i64(es_i64 as uint, v); }\n+    fn emit_i32(v: i32) { self.wr_tagged_i32(es_i32 as uint, v); }\n+    fn emit_i16(v: i16) { self.wr_tagged_i16(es_i16 as uint, v); }\n+    fn emit_i8(v: i8)   { self.wr_tagged_i8 (es_i8  as uint, v); }\n+\n+    fn emit_bool(v: bool) { self.wr_tagged_u8(es_bool as uint, v as u8) }\n+\n     fn emit_f64(_v: f64) { fail \"TODO\"; }\n-    fn emit_str(v: str) { self.wr_tag(es_str as uint) {|| self.wr_str(v) } }\n+    fn emit_f32(_v: f32) { fail \"TODO\"; }\n+    fn emit_float(_v: float) { fail \"TODO\"; }\n+\n+    fn emit_str(v: str) { self.wr_tagged_str(es_str as uint, v) }\n \n     fn emit_enum(_name: str, f: fn()) {\n-        self.wr_tag(es_enum as uint) {|| f() }\n+        self.wr_tag(es_enum as uint, f)\n     }\n     fn emit_enum_variant(_v_name: str, v_id: uint, _cnt: uint, f: fn()) {\n-        self.emit_num(es_enum_vid, v_id as u64);\n-        self.wr_tag(es_enum_body as uint) {|| f() }\n+        self._emit_tagged_uint(es_enum_vid, v_id);\n+        self.wr_tag(es_enum_body as uint, f)\n     }\n     fn emit_enum_variant_arg(_idx: uint, f: fn()) { f() }\n \n     fn emit_vec(len: uint, f: fn()) {\n         self.wr_tag(es_vec as uint) {||\n-            self.emit_num(es_vec_len, len as u64);\n+            self._emit_tagged_uint(es_vec_len, len);\n             f()\n         }\n     }\n \n     fn emit_vec_elt(_idx: uint, f: fn()) {\n-        self.wr_tag(es_vec_elt as uint) {|| f() }\n+        self.wr_tag(es_vec_elt as uint, f)\n     }\n \n     fn emit_vec_elt(_idx: uint, f: fn()) {\n-        self.wr_tag(es_vec_elt as uint) {|| f() }\n+        self.wr_tag(es_vec_elt as uint, f)\n     }\n \n     fn emit_box(f: fn()) { f() }\n@@ -145,26 +190,53 @@ impl of deserializer for ebml_deserializer {\n         ret r;\n     }\n \n-    fn next_u64(exp_tag: ebml_serializer_tag) -> u64 {\n-        let r = ebml::doc_as_vu64(self.next_doc(exp_tag));\n-        #debug[\"next_u64 exp_tag=%? result=%?\", exp_tag, r];\n-        ret r;\n+    fn _next_uint(exp_tag: ebml_serializer_tag) -> uint {\n+        let r = ebml::doc_as_u32(self.next_doc(exp_tag));\n+        #debug[\"_next_uint exp_tag=%? result=%?\", exp_tag, r];\n+        ret r as uint;\n     }\n \n     fn read_nil() -> () { () }\n-    fn read_u64() -> u64 { self.next_u64(es_u64) }\n-    fn read_i64() -> i64 { self.next_u64(es_i64) as i64 }\n-    fn read_bool() -> bool { self.next_u64(es_bool) as bool }\n-    fn read_f64() -> f64 { fail \"Float\"; }\n-    fn read_str() -> str { ebml::doc_str(self.next_doc(es_str)) }\n+\n+    fn read_u64() -> u64 { ebml::doc_as_u64(self.next_doc(es_u64)) }\n+    fn read_u32() -> u32 { ebml::doc_as_u32(self.next_doc(es_u32)) }\n+    fn read_u16() -> u16 { ebml::doc_as_u16(self.next_doc(es_u16)) }\n+    fn read_u8 () -> u8  { ebml::doc_as_u8 (self.next_doc(es_u8 )) }\n+    fn read_uint() -> uint {\n+        let v = ebml::doc_as_u64(self.next_doc(es_uint));\n+        if v > (uint::max_value as u64) {\n+            fail #fmt[\"uint %? too large for this architecture\", v];\n+        }\n+        ret v as uint;\n+    }\n+\n+    fn read_i64() -> i64 { ebml::doc_as_u64(self.next_doc(es_i64)) as i64 }\n+    fn read_i32() -> i32 { ebml::doc_as_u32(self.next_doc(es_i32)) as i32 }\n+    fn read_i16() -> i16 { ebml::doc_as_u16(self.next_doc(es_i16)) as i16 }\n+    fn read_i8 () -> i8  { ebml::doc_as_u8 (self.next_doc(es_i8 )) as i8  }\n+    fn read_int() -> int {\n+        let v = ebml::doc_as_u64(self.next_doc(es_int)) as i64;\n+        if v > (int::max_value as i64) || v < (int::min_value as i64) {\n+            fail #fmt[\"int %? out of range for this architecture\", v];\n+        }\n+        ret v as int;\n+    }\n+\n+    fn read_bool() -> bool { ebml::doc_as_u8(self.next_doc(es_bool)) as bool }\n+\n+    fn read_f64() -> f64 { fail \"read_f64()\"; }\n+    fn read_f32() -> f32 { fail \"read_f32()\"; }\n+    fn read_float() -> float { fail \"read_float()\"; }\n+\n+    fn read_str() -> str { ebml::doc_as_str(self.next_doc(es_str)) }\n \n     // Compound types:\n     fn read_enum<T:copy>(_name: str, f: fn() -> T) -> T {\n         self.push_doc(self.next_doc(es_enum), f)\n     }\n \n     fn read_enum_variant<T:copy>(f: fn(uint) -> T) -> T {\n-        let idx = self.next_u64(es_enum_vid) as uint;\n+        let idx = self._next_uint(es_enum_vid);\n         self.push_doc(self.next_doc(es_enum_body)) {||\n             f(idx)\n         }\n@@ -176,7 +248,7 @@ impl of deserializer for ebml_deserializer {\n \n     fn read_vec<T:copy>(f: fn(uint) -> T) -> T {\n         self.push_doc(self.next_doc(es_vec)) {||\n-            let len = self.next_u64(es_vec_len) as uint;\n+            let len = self._next_uint(es_vec_len);\n             f(len)\n         }\n     }\n@@ -210,6 +282,36 @@ impl of deserializer for ebml_deserializer {\n     }\n }\n \n+// ___________________________________________________________________________\n+// Helper routines\n+//\n+// These should eventually be coded as traits.\n+\n+impl serializer_helpers<S: serializer> for S {\n+    fn emit_from_vec<T>(v: [T], f: fn(T)) {\n+        self.emit_vec(vec::len(v)) {||\n+            vec::iteri(v) {|i,e|\n+                self.emit_vec_elt(i) {||\n+                    f(e)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl deserializer_helpers<D: deserializer> for D {\n+    fn read_to_vec<T>(f: fn() -> T) -> [T] {\n+        self.read_vec {|len|\n+            let v = [];\n+            vec::reserve(v, len);\n+            uint::range(0u, len) {|i|\n+                self.read_vec_elt(i) {|| v += [f()] }\n+            }\n+            v\n+        }\n+    }\n+}\n+\n // ___________________________________________________________________________\n // Testing\n \n@@ -257,7 +359,7 @@ fn test_option_int() {\n     fn test_v(v: option<int>) {\n         #debug[\"v == %?\", v];\n         let mbuf = io::mk_mem_buffer();\n-        let ebml_w = ebml::create_writer(io::mem_buffer_writer(mbuf));\n+        let ebml_w = ebml::mk_writer(io::mem_buffer_writer(mbuf));\n         serialize_0(ebml_w, v);\n         let ebml_doc = ebml::new_doc(@io::mem_buffer_buf(mbuf));\n         let deser = mk_ebml_deserializer(ebml_doc);"}, {"sha": "478dbb695132c2d861e9d623f59c4b85458dea89", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -12,7 +12,7 @@ export c_vec, four, tri, util;\n export bitv, deque, fun_treemap, list, map, smallintmap, sort, treemap, ufind;\n export rope;\n export ebml, dbg, getopts, json, rand, sha1, term, time;\n-export test, tempfile;\n+export test, tempfile, serialization;\n // FIXME: generic_os and os_fs shouldn't be exported\n export generic_os, os, os_fs;\n \n@@ -111,5 +111,4 @@ mod os_fs;\n // indent-tabs-mode: nil\n // c-basic-offset: 4\n // buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n // End:"}, {"sha": "90db74c403903727abe4722345220f1b0a15ade3", "filename": "src/serializer/serializer.rs", "status": "modified", "additions": 272, "deletions": 60, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fserializer%2Fserializer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ca50c9ca4fd2084cfbc85030ff5ea21e589635/src%2Fserializer%2Fserializer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fserializer%2Fserializer.rs?ref=f3ca50c9ca4fd2084cfbc85030ff5ea21e589635", "patch": "@@ -56,7 +56,8 @@ type serialize_ctx = {\n     crate: @ast::crate,\n     tcx: ty::ctxt,\n \n-    tyfns: hashmap<ty::t, str>,\n+    serialize_tyfns: hashmap<ty::t, str>,\n+    deserialize_tyfns: hashmap<ty::t, str>,\n     mutable item_fns: [ast_item],\n     mutable constants: [str]\n \n@@ -84,19 +85,10 @@ fn lookup(_mod: ast::_mod, idx: uint, names: [str]) -> @ast::item {\n }\n \n impl serialize_ctx for serialize_ctx {\n-    // fn session() -> parser::parse_sess { self.psess }\n-\n     fn add_item(item: ast_item) {\n         self.item_fns += [item];\n     }\n \n-    fn mk_serialize_named_item_fn(name: str) -> str {\n-        let names = str::split_str(name, \"::\");\n-        let item = lookup(self.crate.node.module, 0u, names);\n-        let def_id = {crate: ast::local_crate, node: item.id};\n-        self.mk_serialize_item_fn(def_id, [])\n-    }\n-\n     fn tp_map(ty_params: [ast::ty_param], tps: [ty::t]) -> tp_map {\n         assert vec::len(tps) == vec::len(ty_params);\n         let tps_map = new_int_hash();\n@@ -123,10 +115,51 @@ impl serialize_ctx for serialize_ctx {\n         };\n     }\n \n-    fn mk_serialize_item_fn(id: ast::def_id,\n-                            tps: [ty::t]) -> str {\n-        let item_ty = self.instantiate(id, tps);\n-        self.mk_serialize_ty_fn(item_ty)\n+    fn memoize(map: hashmap<ty::t, str>, base_name: str,\n+               ty0: ty::t, mk_fn: fn(str)) -> str {\n+        // check for existing function\n+        alt map.find(ty0) {\n+          some(name) { ret name; }\n+          none { /* fallthrough */ }\n+        }\n+\n+        // define the name and insert into the hashtable\n+        // in case of recursive calls:\n+        let id = map.size();\n+        let name = #fmt[\"%s_%u\", base_name, id];\n+        map.insert(ty0, name);\n+        mk_fn(name);\n+        ret name;\n+    }\n+\n+    fn exec_named_item_fn(name: str, f: fn(ty::t) -> str) -> str {\n+        let names = str::split_str(name, \"::\");\n+        let item = lookup(self.crate.node.module, 0u, names);\n+        let def_id = {crate: ast::local_crate, node: item.id};\n+        let item_ty = self.instantiate(def_id, []);\n+        f(item_ty)\n+    }\n+}\n+\n+impl serialize_methods for serialize_ctx {\n+    // fn session() -> parser::parse_sess { self.psess }\n+\n+    fn mk_serialize_named_item_fn(name: str) -> str {\n+        self.exec_named_item_fn(name) {|item_ty|\n+            let fname = self.mk_serialize_ty_fn(item_ty);\n+\n+            let ty_str = ppaux::ty_to_str(self.tcx, item_ty);\n+            check str::is_not_empty(\"::\");\n+            let namep = str::replace(name, \"::\", \"_\");\n+            let item = #fmt[\"fn serialize_%s\\\n+                                 <S:std::serialization::serializer>\\n\\\n+                                 (s: S, v: %s) {\\n\\\n+                                   %s(s, v);\\n\\\n+                                 }\", namep, ty_str, fname];\n+            self.add_item(item);\n+\n+            fname\n+        }\n     }\n \n     fn blk(stmts: [ast_stmt]) -> ast_blk {\n@@ -145,59 +178,75 @@ impl serialize_ctx for serialize_ctx {\n     // Returns an AST fragment that names this function.\n     fn serialize_ty(ty0: ty::t, v: ast_expr) -> ast_expr {\n         let fname = self.mk_serialize_ty_fn(ty0);\n-        #fmt[\"%s(cx, %s)\", fname, v]\n+        let ty0_str = ppaux::ty_to_str(self.tcx, ty0);\n+        #fmt[\"/*%s*/ %s(s, %s)\", ty0_str, fname, v]\n     }\n \n     fn mk_serialize_ty_fn(ty0: ty::t) -> str {\n-        // check for existing function\n-        alt self.tyfns.find(ty0) {\n-          some(name) { ret name; }\n-          none { /* fallthrough */ }\n+        self.memoize(self.serialize_tyfns, \"serialize\", ty0) {|name|\n+            self.mk_serialize_ty_fn0(ty0, name)\n         }\n+    }\n \n-        // define the name and insert into the hashtable\n-        // in case of recursive calls:\n-        let id = self.tyfns.size();\n+    fn mk_serialize_ty_fn0(ty0: ty::t, name: str) {\n         let ty0_str = ppaux::ty_to_str(self.tcx, ty0);\n-        #debug[\"ty0_str = %s / ty0 = %?\", ty0_str, ty0];\n-        let name = #fmt[\"serialize_%u /*%s*/\", id, ty0_str];\n-        self.tyfns.insert(ty0, name);\n         let v = \"v\";\n \n         let body_node = alt ty::get(ty0).struct {\n           ty::ty_nil | ty::ty_bot { \"()\" }\n-          ty::ty_int(_) { #fmt[\"s.emit_i64(%s as i64)\", v] }\n-          ty::ty_uint(_) { #fmt[\"s.emit_u64(%s as u64)\", v] }\n-          ty::ty_float(_) { #fmt[\"s.emit_f64(%s as f64)\", v] }\n-          ty::ty_bool { #fmt[\"s.emit_bool(%s)\", v] }\n-          ty::ty_str { #fmt[\"s.emit_str(%s)\", v] }\n+\n+          ty::ty_int(ast::ty_i)   { #fmt[\"\\ns.emit_int(%s)\\n\", v] }\n+          ty::ty_int(ast::ty_i64) { #fmt[\"\\ns.emit_i64(%s)\\n\", v] }\n+          ty::ty_int(ast::ty_i32) { #fmt[\"\\ns.emit_i32(%s)\\n\", v] }\n+          ty::ty_int(ast::ty_i16) { #fmt[\"\\ns.emit_i16(%s)\\n\", v] }\n+          ty::ty_int(ast::ty_i8)  { #fmt[\"\\ns.emit_i8(%s)\\n\", v]  }\n+\n+          ty::ty_int(ast::ty_char) { #fmt[\"\\ns.emit_i8(%s as i8)\\n\", v] }\n+\n+          ty::ty_uint(ast::ty_u)   { #fmt[\"\\ns.emit_uint(%s)\\n\", v] }\n+          ty::ty_uint(ast::ty_u64) { #fmt[\"\\ns.emit_u64(%s)\\n\", v] }\n+          ty::ty_uint(ast::ty_u32) { #fmt[\"\\ns.emit_u32(%s)\\n\", v] }\n+          ty::ty_uint(ast::ty_u16) { #fmt[\"\\ns.emit_u16(%s)\\n\", v] }\n+          ty::ty_uint(ast::ty_u8)  { #fmt[\"\\ns.emit_u8(%s)\\n\", v]  }\n+\n+          ty::ty_float(ast::ty_f64) { #fmt[\"\\ns.emit_f64(%s)\\n\", v] }\n+          ty::ty_float(ast::ty_f32) { #fmt[\"\\ns.emit_f32(%s)\\n\", v] }\n+          ty::ty_float(ast::ty_f)   { #fmt[\"\\ns.emit_float(%s)\\n\", v] }\n+\n+          ty::ty_bool { #fmt[\"\\ns.emit_bool(%s)\\n\", v] }\n+\n+          ty::ty_str { #fmt[\"\\ns.emit_str(%s)\\n\", v] }\n+\n           ty::ty_enum(def_id, tps) { self.serialize_enum(v, def_id, tps) }\n           ty::ty_box(mt) {\n-            let s = self.serialize_ty(mt.ty, #fmt[\"*%s\", v]);\n-            #fmt[\"s.emit_box({||%s})\", s]\n+            let s = self.serialize_ty(mt.ty, #fmt[\"\\n*%s\\n\", v]);\n+            #fmt[\"\\ns.emit_box({||%s})\\n\", s]\n           }\n           ty::ty_uniq(mt) {\n-            let s = self.serialize_ty(mt.ty, #fmt[\"*%s\", v]);\n-            #fmt[\"s.emit_uniq({||%s})\", s]\n+            let s = self.serialize_ty(mt.ty, #fmt[\"\\n*%s\\n\", v]);\n+            #fmt[\"\\ns.emit_uniq({||%s})\\n\", s]\n           }\n           ty::ty_vec(mt) {\n-            let selem = self.serialize_ty(mt.ty, \"i\");\n-            #fmt[\"s.emit_vec(vec::len(v), {|| \\\n-                  uint::range(0, vec::len(v), {|i| \\\n-                  s.emit_vec_elt(i, {||\\\n-                  %s;\\\n-                  })})})\", selem]\n+            let selem = self.serialize_ty(mt.ty, \"e\");\n+            #fmt[\"\\ns.emit_vec(vec::len(v), {||\\n\\\n+                    vec::iteri(v, {|i, e|\\n\\\n+                      s.emit_vec_elt(i, {||\\n\\\n+                          %s\\n\\\n+                  })})})\\n\", selem]\n           }\n           ty::ty_class(_, _) {\n             fail \"TODO--implement class\";\n           }\n           ty::ty_rec(fields) {\n-            let stmts = vec::map(fields) {|field|\n+            let stmts = vec::init_fn(vec::len(fields)) {|i|\n+                let field = fields[i];\n                 let f_name = field.ident;\n                 let f_ty = field.mt.ty;\n-                self.serialize_ty(f_ty, #fmt[\"%s.%s\", v, f_name])\n+                let efld = self.serialize_ty(f_ty, #fmt[\"\\n%s.%s\\n\", v, f_name]);\n+                #fmt[\"\\ns.emit_rec_field(\\\"%s\\\", %uu, {||%s})\\n\",\n+                     f_name, i, efld]\n             };\n-            #fmt[\"s.emit_rec({||%s})\", self.blk_expr(stmts)]\n+            #fmt[\"\\ns.emit_rec({||%s})\\n\", self.blk_expr(stmts)]\n           }\n           ty::ty_tup(tys) {\n             let (pat, stmts) = self.serialize_arm(\"\", \"emit_tup_elt\", tys);\n@@ -219,12 +268,13 @@ impl serialize_ctx for serialize_ctx {\n           }\n         };\n \n-        let item = #fmt[\"fn %s<S:std::serialization::serializer>\\\n-                            (s: S, v: %s) {\\\n-                             %s;\\\n-                         }\", name, ty0_str, body_node];\n+        let item = #fmt[\"/*%s*/ fn %s\\n\\\n+                         <S:std::serialization::serializer>\\n\\\n+                            (s: S,\\n\\\n+                            v: %s) {\\n\\\n+                             %s;\\n\\\n+                         }\", ty0_str, name, ty0_str, body_node];\n         self.add_item(item);\n-        ret name;\n     }\n \n     fn serialize_enum(v: ast_expr,\n@@ -249,37 +299,197 @@ impl serialize_ctx for serialize_ctx {\n             let v_id = idx;\n             idx += 1u;\n \n-            #fmt[\"%s { \\\n-                    s.emit_enum_variant(\\\"%s\\\", %uu, %uu) {||\\\n-                      %s \\\n-                    } \\\n+            #fmt[\"%s {\\n\\\n+                    s.emit_enum_variant(\\\"%s\\\", %uu, %uu, {||\\n\\\n+                      %s\\n\\\n+                    })\\n\\\n                   }\", v_pat, v_path, v_id, n_args, self.blk(stmts)]\n         };\n \n         let enum_name = ast_map::path_to_str(ty::item_path(self.tcx, id));\n-        #fmt[\"s.emit_enum(\\\"%s\\\") {||\\\n-                alt %s { \\\n-                  %s \\\n-                }\\\n-              }\", enum_name, v, str::connect(arms, \"\\n\")]\n+        #fmt[\"\\ns.emit_enum(\\\"%s\\\", {||\\n\\\n+                alt %s {\\n\\\n+                  %s\\n\\\n+                }\\n\\\n+              })\\n\", enum_name, v, str::connect(arms, \"\\n\")]\n     }\n \n     fn serialize_arm(v_path: str, emit_fn: str, args: [ty::t])\n         -> (ast_pat, [ast_stmt]) {\n         let n_args = vec::len(args);\n         let arg_nms = vec::init_fn(n_args) {|i| #fmt[\"v%u\", i] };\n         let v_pat =\n-            #fmt[\"%s(%s)\", v_path, str::connect(arg_nms, \", \")];\n+            #fmt[\"\\n%s(%s)\\n\", v_path, str::connect(arg_nms, \",\")];\n         let stmts = vec::init_fn(n_args) {|i|\n             let arg_ty = args[i];\n             let serialize_expr =\n                 self.serialize_ty(arg_ty, arg_nms[i]);\n-            #fmt[\"s.%s(%uu, {|| %s })\", emit_fn, i, serialize_expr]\n+            #fmt[\"\\ns.%s(%uu, {||\\n%s\\n})\\n\", emit_fn, i, serialize_expr]\n         };\n         (v_pat, stmts)\n     }\n }\n \n+impl deserialize_methods for serialize_ctx {\n+    fn mk_deserialize_named_item_fn(name: str) -> str {\n+        self.exec_named_item_fn(name) {|item_ty|\n+            let fname = self.mk_deserialize_ty_fn(item_ty);\n+\n+            let ty_str = ppaux::ty_to_str(self.tcx, item_ty);\n+            check str::is_not_empty(\"::\");\n+            let namep = str::replace(name, \"::\", \"_\");\n+            let item = #fmt[\"fn deserialize_%s\\\n+                                 <S:std::serialization::deserializer>\\n\\\n+                                 (s: S) -> %s {\\n\\\n+                                   %s(s)\\\n+                                 }\", namep, ty_str, fname];\n+            self.add_item(item);\n+\n+            fname\n+        }\n+    }\n+\n+    // Generates a function to serialize the given type.\n+    // Returns an AST fragment that names this function.\n+    fn deserialize_ty(ty0: ty::t) -> ast_expr {\n+        let fname = self.mk_deserialize_ty_fn(ty0);\n+        let ty0_str = ppaux::ty_to_str(self.tcx, ty0);\n+        #fmt[\"\\n/*%s*/ %s(s)\\n\", ty0_str, fname]\n+    }\n+\n+    fn mk_deserialize_ty_fn(ty0: ty::t) -> str {\n+        self.memoize(self.deserialize_tyfns, \"deserialize\", ty0) {|name|\n+            self.mk_deserialize_ty_fn0(ty0, name)\n+        }\n+    }\n+\n+    fn mk_deserialize_ty_fn0(ty0: ty::t, name: str) {\n+        let ty0_str = ppaux::ty_to_str(self.tcx, ty0);\n+        let body_node = alt ty::get(ty0).struct {\n+          ty::ty_nil | ty::ty_bot { \"()\" }\n+\n+          ty::ty_int(ast::ty_i)   { #fmt[\"s.read_int()\"] }\n+          ty::ty_int(ast::ty_i64) { #fmt[\"s.read_i64()\"] }\n+          ty::ty_int(ast::ty_i32) { #fmt[\"s.read_i32()\"] }\n+          ty::ty_int(ast::ty_i16) { #fmt[\"s.read_i16()\"] }\n+          ty::ty_int(ast::ty_i8)  { #fmt[\"s.read_i8()\"]  }\n+\n+          ty::ty_int(ast::ty_char) { #fmt[\"s.read_char()\"] }\n+\n+          ty::ty_uint(ast::ty_u)   { #fmt[\"s.read_uint()\"] }\n+          ty::ty_uint(ast::ty_u64) { #fmt[\"s.read_u64()\"] }\n+          ty::ty_uint(ast::ty_u32) { #fmt[\"s.read_u32()\"] }\n+          ty::ty_uint(ast::ty_u16) { #fmt[\"s.read_u16()\"] }\n+          ty::ty_uint(ast::ty_u8)  { #fmt[\"s.read_u8()\"]  }\n+\n+          ty::ty_float(ast::ty_f64) { #fmt[\"s.read_f64()\"] }\n+          ty::ty_float(ast::ty_f32) { #fmt[\"s.read_f32()\"] }\n+          ty::ty_float(ast::ty_f)   { #fmt[\"s.read_float()\"] }\n+\n+          ty::ty_bool { #fmt[\"s.read_bool()\"] }\n+\n+          ty::ty_str { #fmt[\"s.read_str()\"] }\n+\n+          ty::ty_enum(def_id, tps) { self.deserialize_enum(def_id, tps) }\n+          ty::ty_box(mt) {\n+            let s = self.deserialize_ty(mt.ty);\n+            #fmt[\"\\ns.read_box({||@%s})\\n\", s]\n+          }\n+          ty::ty_uniq(mt) {\n+            let s = self.deserialize_ty(mt.ty);\n+            #fmt[\"\\ns.read_uniq({||~%s})\\n\", s]\n+          }\n+          ty::ty_vec(mt) {\n+            let selem = self.deserialize_ty(mt.ty);\n+            #fmt[\"s.read_vec({|len|\\n\\\n+                    vec::init_fn(len, {|i|\\n\\\n+                      s.read_vec_elt(i, {||\\n\\\n+                        %s\\n\\\n+                  })})})\", selem]\n+          }\n+          ty::ty_class(_, _) {\n+            fail \"TODO--implement class\";\n+          }\n+          ty::ty_rec(fields) {\n+            let i = 0u;\n+            let flds = vec::map(fields) {|field|\n+                let f_name = field.ident;\n+                let f_ty = field.mt.ty;\n+                let rfld = self.deserialize_ty(f_ty);\n+                let idx = i;\n+                i += 1u;\n+                #fmt[\"\\n%s: s.read_rec_field(\\\"%s\\\", %uu, {||\\n%s\\n})\\n\",\n+                     f_name, f_name, idx, rfld]\n+            };\n+            #fmt[\"\\ns.read_rec({||{\\n%s\\n}})\\n\", str::connect(flds, \",\")]\n+          }\n+          ty::ty_tup(tys) {\n+            let rexpr = self.deserialize_arm(\"\", \"read_tup_elt\", tys);\n+            #fmt[\"\\ns.read_tup(%uu, {||\\n%s\\n})\\n\", vec::len(tys), rexpr]\n+          }\n+          ty::ty_constr(t, _) {\n+            self.deserialize_ty(t)\n+          }\n+          ty::ty_ptr(_) |\n+          ty::ty_fn(_) |\n+          ty::ty_iface(_, _) |\n+          ty::ty_res(_, _, _) |\n+          ty::ty_var(_) | ty::ty_param(_, _) |\n+          ty::ty_self(_) | ty::ty_type | ty::ty_send_type |\n+          ty::ty_opaque_closure_ptr(_) | ty::ty_opaque_box {\n+            fail #fmt[\"Unhandled type %s\", ty0_str]\n+          }\n+        };\n+\n+        let item = #fmt[\"/*%s*/\\n\\\n+                         fn %s\\n\\\n+                         <S:std::serialization::deserializer>(s: S)\\n\\\n+                         -> %s {\\n\\\n+                             %s\\n\\\n+                         }\", ty0_str, name, ty0_str, body_node];\n+        self.add_item(item);\n+    }\n+\n+    fn deserialize_enum(id: ast::def_id,\n+                        tps: [ty::t]) -> ast_expr {\n+        let variants = ty::substd_enum_variants(self.tcx, id, tps);\n+\n+        let arms = vec::init_fn(vec::len(variants)) {|v_id|\n+            let variant = variants[v_id];\n+            let item_path = ty::item_path(self.tcx, variant.id);\n+            let v_path = ast_map::path_to_str(item_path);\n+            let n_args = vec::len(variant.args);\n+            let rexpr = {\n+                if n_args == 0u {\n+                    #fmt[\"\\n%s\\n\", v_path]\n+                } else {\n+                    self.deserialize_arm(v_path, \"read_enum_variant_arg\",\n+                                         variant.args)\n+                }\n+            };\n+\n+            #fmt[\"\\n%uu { %s }\\n\", v_id, rexpr]\n+        };\n+\n+        let enum_name = ast_map::path_to_str(ty::item_path(self.tcx, id));\n+        #fmt[\"s.read_enum(\\\"%s\\\", {||\\n\\\n+                s.read_enum_variant({|v_id|\\n\\\n+                  alt check v_id {\\n\\\n+                    %s\\n\\\n+                  }\\n\\\n+                })})\", enum_name, str::connect(arms, \"\\n\")]\n+    }\n+\n+    fn deserialize_arm(v_path: str, read_fn: str, args: [ty::t])\n+        -> ast_expr {\n+        let exprs = vec::init_fn(vec::len(args)) {|i|\n+            let rexpr = self.deserialize_ty(args[i]);\n+            #fmt[\"\\ns.%s(%uu, {||%s})\\n\", read_fn, i, rexpr]\n+        };\n+        #fmt[\"\\n%s(%s)\\n\", v_path, str::connect(exprs, \",\")]\n+    }\n+}\n+\n fn main(argv: [str]) {\n     let {crate, tcx, roots} = parse(argv);\n     let sctx: serialize_ctx = {\n@@ -294,13 +504,15 @@ fn main(argv: [str]) {\n         // };\n         {crate: crate,\n          tcx: tcx,\n-         tyfns: ty::new_ty_hash::<str>(),\n+         serialize_tyfns: ty::new_ty_hash::<str>(),\n+         deserialize_tyfns: ty::new_ty_hash::<str>(),\n          mutable item_fns: [],\n          mutable constants: []}\n     };\n \n     vec::iter(roots) {|root|\n         sctx.mk_serialize_named_item_fn(root);\n+        sctx.mk_deserialize_named_item_fn(root);\n     }\n \n     let stdout = io::stdout();"}]}