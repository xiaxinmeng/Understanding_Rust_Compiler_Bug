{"sha": "7869b01b702d1f12acb03ac131b6eb90ad82e9bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4NjliMDFiNzAyZDFmMTJhY2IwM2FjMTMxYjZlYjkwYWQ4MmU5YmI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-28T21:21:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-28T21:21:37Z"}, "message": "Merge #9041\n\n9041: internal: Implement prev sibling determination for `CompletionContext ` r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "e6d76df5212db7589ef8dc6583b32d6c64871a33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6d76df5212db7589ef8dc6583b32d6c64871a33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7869b01b702d1f12acb03ac131b6eb90ad82e9bb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgsV7hCRBK7hj4Ov3rIwAAddgIAIgnK0iByBUpWCtrpygZTiZc\ngwTFONQBKn4sV2cuVXtXDOcKjfM2OXz8+pU3K7Q1x9djcBZSuLWX/Ykri8x4zxie\nNYYkzgzS+ISODL5N3rqCdVY2f20W8VIeO/+mvz+n3xoDWpdp7j++kVUFJYLF8TEM\nBOX6PdTkAAT6vMGr/Q5X0bHznSIIofmn+pNtF4+sFXzSdy+JZd41XYw5PFTqyZJB\nZC4TVrUiUIH7OZBo3tCxPpFn5qTxthkuSSgw5mdbyt1AuZQS5g3Nj9KqRt/Aico+\n4tJ2bJk4Ba2lHlhataQoAJoA3uWkRCqQdIIx1+oRAom+TjpGoDiZNbYrOttlsG8=\n=u0iD\n-----END PGP SIGNATURE-----\n", "payload": "tree e6d76df5212db7589ef8dc6583b32d6c64871a33\nparent d5f7b2e52a41a7d3b841f4d0e2225eb703f6a50a\nparent e42c448077ca2b7675320da3c5294bf4bebaedeb\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1622236897 +0000\ncommitter GitHub <noreply@github.com> 1622236897 +0000\n\nMerge #9041\n\n9041: internal: Implement prev sibling determination for `CompletionContext ` r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7869b01b702d1f12acb03ac131b6eb90ad82e9bb", "html_url": "https://github.com/rust-lang/rust/commit/7869b01b702d1f12acb03ac131b6eb90ad82e9bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7869b01b702d1f12acb03ac131b6eb90ad82e9bb/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5f7b2e52a41a7d3b841f4d0e2225eb703f6a50a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5f7b2e52a41a7d3b841f4d0e2225eb703f6a50a", "html_url": "https://github.com/rust-lang/rust/commit/d5f7b2e52a41a7d3b841f4d0e2225eb703f6a50a"}, {"sha": "e42c448077ca2b7675320da3c5294bf4bebaedeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/e42c448077ca2b7675320da3c5294bf4bebaedeb", "html_url": "https://github.com/rust-lang/rust/commit/e42c448077ca2b7675320da3c5294bf4bebaedeb"}], "stats": {"total": 576, "additions": 328, "deletions": 248}, "files": [{"sha": "69ceba735617b9e0eaf93d6b3bd11e4d1f7150ae", "filename": "crates/base_db/src/fixture.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7869b01b702d1f12acb03ac131b6eb90ad82e9bb/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7869b01b702d1f12acb03ac131b6eb90ad82e9bb/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Ffixture.rs?ref=7869b01b702d1f12acb03ac131b6eb90ad82e9bb", "patch": "@@ -34,19 +34,13 @@ pub trait WithFixture: Default + SourceDatabaseExt + 'static {\n \n     fn with_position(ra_fixture: &str) -> (Self, FilePosition) {\n         let (db, file_id, range_or_offset) = Self::with_range_or_offset(ra_fixture);\n-        let offset = match range_or_offset {\n-            RangeOrOffset::Range(_) => panic!(\"Expected a cursor position, got a range instead\"),\n-            RangeOrOffset::Offset(it) => it,\n-        };\n+        let offset = range_or_offset.expect_offset();\n         (db, FilePosition { file_id, offset })\n     }\n \n     fn with_range(ra_fixture: &str) -> (Self, FileRange) {\n         let (db, file_id, range_or_offset) = Self::with_range_or_offset(ra_fixture);\n-        let range = match range_or_offset {\n-            RangeOrOffset::Range(it) => it,\n-            RangeOrOffset::Offset(_) => panic!(\"Expected a cursor range, got a position instead\"),\n-        };\n+        let range = range_or_offset.expect_range();\n         (db, FileRange { file_id, range })\n     }\n "}, {"sha": "6780af61721a8153abf2fcbe89b69868cd5c50a1", "filename": "crates/ide/src/fixture.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7869b01b702d1f12acb03ac131b6eb90ad82e9bb/crates%2Fide%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7869b01b702d1f12acb03ac131b6eb90ad82e9bb/crates%2Fide%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Ffixture.rs?ref=7869b01b702d1f12acb03ac131b6eb90ad82e9bb", "patch": "@@ -1,7 +1,7 @@\n //! Utilities for creating `Analysis` instances for tests.\n use ide_db::base_db::fixture::ChangeFixture;\n use syntax::{TextRange, TextSize};\n-use test_utils::{extract_annotations, RangeOrOffset};\n+use test_utils::extract_annotations;\n \n use crate::{Analysis, AnalysisHost, FileId, FilePosition, FileRange};\n \n@@ -27,10 +27,7 @@ pub(crate) fn position(ra_fixture: &str) -> (Analysis, FilePosition) {\n     let change_fixture = ChangeFixture::parse(ra_fixture);\n     host.db.apply_change(change_fixture.change);\n     let (file_id, range_or_offset) = change_fixture.file_position.expect(\"expected a marker ($0)\");\n-    let offset = match range_or_offset {\n-        RangeOrOffset::Range(_) => panic!(),\n-        RangeOrOffset::Offset(it) => it,\n-    };\n+    let offset = range_or_offset.expect_offset();\n     (host.analysis(), FilePosition { file_id, offset })\n }\n \n@@ -40,10 +37,7 @@ pub(crate) fn range(ra_fixture: &str) -> (Analysis, FileRange) {\n     let change_fixture = ChangeFixture::parse(ra_fixture);\n     host.db.apply_change(change_fixture.change);\n     let (file_id, range_or_offset) = change_fixture.file_position.expect(\"expected a marker ($0)\");\n-    let range = match range_or_offset {\n-        RangeOrOffset::Range(it) => it,\n-        RangeOrOffset::Offset(_) => panic!(),\n-    };\n+    let range = range_or_offset.expect_range();\n     (host.analysis(), FileRange { file_id, range })\n }\n \n@@ -53,10 +47,7 @@ pub(crate) fn annotations(ra_fixture: &str) -> (Analysis, FilePosition, Vec<(Fil\n     let change_fixture = ChangeFixture::parse(ra_fixture);\n     host.db.apply_change(change_fixture.change);\n     let (file_id, range_or_offset) = change_fixture.file_position.expect(\"expected a marker ($0)\");\n-    let offset = match range_or_offset {\n-        RangeOrOffset::Range(_) => panic!(),\n-        RangeOrOffset::Offset(it) => it,\n-    };\n+    let offset = range_or_offset.expect_offset();\n \n     let annotations = change_fixture\n         .files"}, {"sha": "e71a04b6eca38440b37f8e3b5909fec0509591b4", "filename": "crates/ide_completion/src/completions/keyword.rs", "status": "modified", "additions": 94, "deletions": 98, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/7869b01b702d1f12acb03ac131b6eb90ad82e9bb/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7869b01b702d1f12acb03ac131b6eb90ad82e9bb/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=7869b01b702d1f12acb03ac131b6eb90ad82e9bb", "patch": "@@ -48,91 +48,92 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n         cov_mark::hit!(no_keyword_completion_in_record_lit);\n         return;\n     }\n+    let mut add_keyword = |kw, snippet| add_keyword(ctx, acc, kw, snippet);\n \n     let expects_assoc_item = ctx.expects_assoc_item();\n     let has_block_expr_parent = ctx.has_block_expr_parent();\n     let expects_item = ctx.expects_item();\n+\n     if ctx.has_impl_or_trait_prev_sibling() {\n-        add_keyword(ctx, acc, \"where\", \"where \");\n+        // FIXME this also incorrectly shows up after a complete trait/impl\n+        add_keyword(\"where\", \"where \");\n         return;\n     }\n     if ctx.previous_token_is(T![unsafe]) {\n-        if expects_item || has_block_expr_parent {\n-            add_keyword(ctx, acc, \"fn\", \"fn $1($2) {\\n    $0\\n}\")\n+        if expects_item || expects_assoc_item || has_block_expr_parent {\n+            add_keyword(\"fn\", \"fn $1($2) {\\n    $0\\n}\")\n         }\n \n         if expects_item || has_block_expr_parent {\n-            add_keyword(ctx, acc, \"trait\", \"trait $1 {\\n    $0\\n}\");\n-            add_keyword(ctx, acc, \"impl\", \"impl $1 {\\n    $0\\n}\");\n+            add_keyword(\"trait\", \"trait $1 {\\n    $0\\n}\");\n+            add_keyword(\"impl\", \"impl $1 {\\n    $0\\n}\");\n         }\n \n         return;\n     }\n+\n+    if expects_item || ctx.expects_non_trait_assoc_item() || ctx.expect_record_field() {\n+        add_keyword(\"pub(crate)\", \"pub(crate) \");\n+        add_keyword(\"pub\", \"pub \");\n+    }\n+\n+    if expects_item || expects_assoc_item || has_block_expr_parent || ctx.is_match_arm {\n+        add_keyword(\"unsafe\", \"unsafe \");\n+    }\n+\n     if expects_item || expects_assoc_item || has_block_expr_parent {\n-        add_keyword(ctx, acc, \"fn\", \"fn $1($2) {\\n    $0\\n}\");\n+        add_keyword(\"fn\", \"fn $1($2) {\\n    $0\\n}\");\n+        add_keyword(\"const\", \"const $0\");\n+        add_keyword(\"type\", \"type $0\");\n     }\n+\n     if expects_item || has_block_expr_parent {\n-        add_keyword(ctx, acc, \"use\", \"use \");\n-        add_keyword(ctx, acc, \"impl\", \"impl $1 {\\n    $0\\n}\");\n-        add_keyword(ctx, acc, \"trait\", \"trait $1 {\\n    $0\\n}\");\n+        add_keyword(\"use\", \"use $0\");\n+        add_keyword(\"impl\", \"impl $1 {\\n    $0\\n}\");\n+        add_keyword(\"trait\", \"trait $1 {\\n    $0\\n}\");\n+        add_keyword(\"static\", \"static $0\");\n+        add_keyword(\"extern\", \"extern $0\");\n+        add_keyword(\"mod\", \"mod $0\");\n     }\n \n     if expects_item {\n-        add_keyword(ctx, acc, \"enum\", \"enum $1 {\\n    $0\\n}\");\n-        add_keyword(ctx, acc, \"struct\", \"struct $0\");\n-        add_keyword(ctx, acc, \"union\", \"union $1 {\\n    $0\\n}\");\n+        add_keyword(\"enum\", \"enum $1 {\\n    $0\\n}\");\n+        add_keyword(\"struct\", \"struct $0\");\n+        add_keyword(\"union\", \"union $1 {\\n    $0\\n}\");\n     }\n \n-    if ctx.is_expr {\n-        add_keyword(ctx, acc, \"match\", \"match $1 {\\n    $0\\n}\");\n-        add_keyword(ctx, acc, \"while\", \"while $1 {\\n    $0\\n}\");\n-        add_keyword(ctx, acc, \"while let\", \"while let $1 = $2 {\\n    $0\\n}\");\n-        add_keyword(ctx, acc, \"loop\", \"loop {\\n    $0\\n}\");\n-        add_keyword(ctx, acc, \"if\", \"if $1 {\\n    $0\\n}\");\n-        add_keyword(ctx, acc, \"if let\", \"if let $1 = $2 {\\n    $0\\n}\");\n-        add_keyword(ctx, acc, \"for\", \"for $1 in $2 {\\n    $0\\n}\");\n+    if ctx.expects_expression() {\n+        add_keyword(\"match\", \"match $1 {\\n    $0\\n}\");\n+        add_keyword(\"while\", \"while $1 {\\n    $0\\n}\");\n+        add_keyword(\"while let\", \"while let $1 = $2 {\\n    $0\\n}\");\n+        add_keyword(\"loop\", \"loop {\\n    $0\\n}\");\n+        add_keyword(\"if\", \"if $1 {\\n    $0\\n}\");\n+        add_keyword(\"if let\", \"if let $1 = $2 {\\n    $0\\n}\");\n+        add_keyword(\"for\", \"for $1 in $2 {\\n    $0\\n}\");\n     }\n \n     if ctx.previous_token_is(T![if]) || ctx.previous_token_is(T![while]) || has_block_expr_parent {\n-        add_keyword(ctx, acc, \"let\", \"let \");\n+        add_keyword(\"let\", \"let \");\n     }\n \n-    if ctx.after_if {\n-        add_keyword(ctx, acc, \"else\", \"else {\\n    $0\\n}\");\n-        add_keyword(ctx, acc, \"else if\", \"else if $1 {\\n    $0\\n}\");\n-    }\n-    if expects_item || has_block_expr_parent {\n-        add_keyword(ctx, acc, \"mod\", \"mod $0\");\n+    if ctx.after_if() {\n+        add_keyword(\"else\", \"else {\\n    $0\\n}\");\n+        add_keyword(\"else if\", \"else if $1 {\\n    $0\\n}\");\n     }\n+\n     if ctx.expects_ident_pat_or_ref_expr() {\n-        add_keyword(ctx, acc, \"mut\", \"mut \");\n-    }\n-    if expects_item || expects_assoc_item || has_block_expr_parent {\n-        add_keyword(ctx, acc, \"const\", \"const \");\n-        add_keyword(ctx, acc, \"type\", \"type \");\n-    }\n-    if expects_item || has_block_expr_parent {\n-        add_keyword(ctx, acc, \"static\", \"static \");\n-    };\n-    if expects_item || has_block_expr_parent {\n-        add_keyword(ctx, acc, \"extern\", \"extern \");\n-    }\n-    if expects_item || expects_assoc_item || has_block_expr_parent || ctx.is_match_arm {\n-        add_keyword(ctx, acc, \"unsafe\", \"unsafe \");\n+        add_keyword(\"mut\", \"mut \");\n     }\n+\n     if ctx.in_loop_body {\n         if ctx.can_be_stmt {\n-            add_keyword(ctx, acc, \"continue\", \"continue;\");\n-            add_keyword(ctx, acc, \"break\", \"break;\");\n+            add_keyword(\"continue\", \"continue;\");\n+            add_keyword(\"break\", \"break;\");\n         } else {\n-            add_keyword(ctx, acc, \"continue\", \"continue\");\n-            add_keyword(ctx, acc, \"break\", \"break\");\n+            add_keyword(\"continue\", \"continue\");\n+            add_keyword(\"break\", \"break\");\n         }\n     }\n-    if expects_item || ctx.expects_non_trait_assoc_item() || ctx.expect_record_field() {\n-        add_keyword(ctx, acc, \"pub(crate)\", \"pub(crate) \");\n-        add_keyword(ctx, acc, \"pub\", \"pub \");\n-    }\n \n     if !ctx.is_trivial_path {\n         return;\n@@ -143,8 +144,6 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n     };\n \n     add_keyword(\n-        ctx,\n-        acc,\n         \"return\",\n         match (ctx.can_be_stmt, fn_def.ret_type().is_some()) {\n             (true, true) => \"return $0;\",\n@@ -161,15 +160,12 @@ fn add_keyword(ctx: &CompletionContext, acc: &mut Completions, kw: &str, snippet\n \n     match ctx.config.snippet_cap {\n         Some(cap) => {\n-            let tmp;\n-            let snippet = if snippet.ends_with('}') && ctx.incomplete_let {\n+            if snippet.ends_with('}') && ctx.incomplete_let {\n                 cov_mark::hit!(let_semi);\n-                tmp = format!(\"{};\", snippet);\n-                &tmp\n+                item.insert_snippet(cap, format!(\"{};\", snippet));\n             } else {\n-                snippet\n-            };\n-            item.insert_snippet(cap, snippet);\n+                item.insert_snippet(cap, snippet);\n+            }\n         }\n         None => {\n             item.insert_text(if snippet.contains('$') { kw } else { snippet });\n@@ -232,21 +228,21 @@ mod tests {\n         check(\n             r\"m$0\",\n             expect![[r#\"\n+                kw pub(crate)\n+                kw pub\n+                kw unsafe\n                 kw fn\n+                kw const\n+                kw type\n                 kw use\n                 kw impl\n                 kw trait\n+                kw static\n+                kw extern\n+                kw mod\n                 kw enum\n                 kw struct\n                 kw union\n-                kw mod\n-                kw const\n-                kw type\n-                kw static\n-                kw extern\n-                kw unsafe\n-                kw pub(crate)\n-                kw pub\n             \"#]],\n         );\n     }\n@@ -256,10 +252,16 @@ mod tests {\n         check(\n             r\"fn quux() { $0 }\",\n             expect![[r#\"\n+                kw unsafe\n                 kw fn\n+                kw const\n+                kw type\n                 kw use\n                 kw impl\n                 kw trait\n+                kw static\n+                kw extern\n+                kw mod\n                 kw match\n                 kw while\n                 kw while let\n@@ -268,12 +270,6 @@ mod tests {\n                 kw if let\n                 kw for\n                 kw let\n-                kw mod\n-                kw const\n-                kw type\n-                kw static\n-                kw extern\n-                kw unsafe\n                 kw return\n             \"#]],\n         );\n@@ -284,10 +280,16 @@ mod tests {\n         check(\n             r\"fn quux() { if true { $0 } }\",\n             expect![[r#\"\n+                kw unsafe\n                 kw fn\n+                kw const\n+                kw type\n                 kw use\n                 kw impl\n                 kw trait\n+                kw static\n+                kw extern\n+                kw mod\n                 kw match\n                 kw while\n                 kw while let\n@@ -296,12 +298,6 @@ mod tests {\n                 kw if let\n                 kw for\n                 kw let\n-                kw mod\n-                kw const\n-                kw type\n-                kw static\n-                kw extern\n-                kw unsafe\n                 kw return\n             \"#]],\n         );\n@@ -312,10 +308,16 @@ mod tests {\n         check(\n             r#\"fn quux() { if true { () } $0 }\"#,\n             expect![[r#\"\n+                kw unsafe\n                 kw fn\n+                kw const\n+                kw type\n                 kw use\n                 kw impl\n                 kw trait\n+                kw static\n+                kw extern\n+                kw mod\n                 kw match\n                 kw while\n                 kw while let\n@@ -326,12 +328,6 @@ mod tests {\n                 kw let\n                 kw else\n                 kw else if\n-                kw mod\n-                kw const\n-                kw type\n-                kw static\n-                kw extern\n-                kw unsafe\n                 kw return\n             \"#]],\n         );\n@@ -353,14 +349,14 @@ fn quux() -> i32 {\n }\n \"#,\n             expect![[r#\"\n+                kw unsafe\n                 kw match\n                 kw while\n                 kw while let\n                 kw loop\n                 kw if\n                 kw if let\n                 kw for\n-                kw unsafe\n                 kw return\n             \"#]],\n         );\n@@ -371,10 +367,10 @@ fn quux() -> i32 {\n         check(\n             r\"trait My { $0 }\",\n             expect![[r#\"\n+                kw unsafe\n                 kw fn\n                 kw const\n                 kw type\n-                kw unsafe\n             \"#]],\n         );\n     }\n@@ -384,12 +380,12 @@ fn quux() -> i32 {\n         check(\n             r\"impl My { $0 }\",\n             expect![[r#\"\n+                kw pub(crate)\n+                kw pub\n+                kw unsafe\n                 kw fn\n                 kw const\n                 kw type\n-                kw unsafe\n-                kw pub(crate)\n-                kw pub\n             \"#]],\n         );\n     }\n@@ -399,12 +395,12 @@ fn quux() -> i32 {\n         check(\n             r\"impl My { #[foo] $0 }\",\n             expect![[r#\"\n+                kw pub(crate)\n+                kw pub\n+                kw unsafe\n                 kw fn\n                 kw const\n                 kw type\n-                kw unsafe\n-                kw pub(crate)\n-                kw pub\n             \"#]],\n         );\n     }\n@@ -414,10 +410,16 @@ fn quux() -> i32 {\n         check(\n             r\"fn my() { loop { $0 } }\",\n             expect![[r#\"\n+                kw unsafe\n                 kw fn\n+                kw const\n+                kw type\n                 kw use\n                 kw impl\n                 kw trait\n+                kw static\n+                kw extern\n+                kw mod\n                 kw match\n                 kw while\n                 kw while let\n@@ -426,12 +428,6 @@ fn quux() -> i32 {\n                 kw if let\n                 kw for\n                 kw let\n-                kw mod\n-                kw const\n-                kw type\n-                kw static\n-                kw extern\n-                kw unsafe\n                 kw continue\n                 kw break\n                 kw return"}, {"sha": "8d6440cb23e69187f996b3d988fde88d8aa529c2", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 18, "deletions": 31, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7869b01b702d1f12acb03ac131b6eb90ad82e9bb/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7869b01b702d1f12acb03ac131b6eb90ad82e9bb/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=7869b01b702d1f12acb03ac131b6eb90ad82e9bb", "patch": "@@ -17,8 +17,8 @@ use text_edit::Indel;\n \n use crate::{\n     patterns::{\n-        determine_location, for_is_prev2, has_prev_sibling, inside_impl_trait_block,\n-        is_in_loop_body, is_match_arm, previous_token, ImmediateLocation,\n+        determine_location, determine_prev_sibling, for_is_prev2, inside_impl_trait_block,\n+        is_in_loop_body, is_match_arm, previous_token, ImmediateLocation, ImmediatePrevSibling,\n     },\n     CompletionConfig,\n };\n@@ -29,12 +29,6 @@ pub(crate) enum PatternRefutability {\n     Irrefutable,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub(crate) enum PrevSibling {\n-    Trait,\n-    Impl,\n-}\n-\n /// `CompletionContext` is created early during completion to figure out, where\n /// exactly is the cursor, syntax-wise.\n #[derive(Debug)]\n@@ -76,14 +70,14 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) is_param: bool,\n \n     pub(super) completion_location: Option<ImmediateLocation>,\n+    pub(super) prev_sibling: Option<ImmediatePrevSibling>,\n \n     /// FIXME: `ActiveParameter` is string-based, which is very very wrong\n     pub(super) active_parameter: Option<ActiveParameter>,\n     /// A single-indent path, like `foo`. `::foo` should not be considered a trivial path.\n     pub(super) is_trivial_path: bool,\n     /// If not a trivial path, the prefix (qualifier).\n     pub(super) path_qual: Option<ast::Path>,\n-    pub(super) after_if: bool,\n     /// `true` if we are a statement or a last expr in the block.\n     pub(super) can_be_stmt: bool,\n     /// `true` if we expect an expression at the cursor position.\n@@ -107,7 +101,6 @@ pub(crate) struct CompletionContext<'a> {\n \n     // keyword patterns\n     pub(super) previous_token: Option<SyntaxToken>,\n-    pub(super) prev_sibling: Option<PrevSibling>,\n     pub(super) in_loop_body: bool,\n     pub(super) is_match_arm: bool,\n     pub(super) incomplete_let: bool,\n@@ -173,7 +166,6 @@ impl<'a> CompletionContext<'a> {\n             is_pat_or_const: None,\n             is_trivial_path: false,\n             path_qual: None,\n-            after_if: false,\n             can_be_stmt: false,\n             is_expr: false,\n             is_new_item: false,\n@@ -288,6 +280,10 @@ impl<'a> CompletionContext<'a> {\n         matches!(self.completion_location, Some(ImmediateLocation::ItemList))\n     }\n \n+    pub(crate) fn expects_expression(&self) -> bool {\n+        self.is_expr\n+    }\n+\n     pub(crate) fn has_block_expr_parent(&self) -> bool {\n         matches!(self.completion_location, Some(ImmediateLocation::BlockExpr))\n     }\n@@ -304,7 +300,14 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     pub(crate) fn has_impl_or_trait_prev_sibling(&self) -> bool {\n-        self.prev_sibling.is_some()\n+        matches!(\n+            self.prev_sibling,\n+            Some(ImmediatePrevSibling::ImplDefType) | Some(ImmediatePrevSibling::TraitDefName)\n+        )\n+    }\n+\n+    pub(crate) fn after_if(&self) -> bool {\n+        matches!(self.prev_sibling, Some(ImmediatePrevSibling::IfExpr))\n     }\n \n     pub(crate) fn is_path_disallowed(&self) -> bool {\n@@ -316,15 +319,10 @@ impl<'a> CompletionContext<'a> {\n \n     fn fill_keyword_patterns(&mut self, file_with_fake_ident: &SyntaxNode, offset: TextSize) {\n         let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased().unwrap();\n-        let syntax_element = NodeOrToken::Token(fake_ident_token.clone());\n+        let syntax_element = NodeOrToken::Token(fake_ident_token);\n         self.previous_token = previous_token(syntax_element.clone());\n         self.in_loop_body = is_in_loop_body(syntax_element.clone());\n         self.is_match_arm = is_match_arm(syntax_element.clone());\n-        if has_prev_sibling(syntax_element.clone(), IMPL) {\n-            self.prev_sibling = Some(PrevSibling::Impl)\n-        } else if has_prev_sibling(syntax_element.clone(), TRAIT) {\n-            self.prev_sibling = Some(PrevSibling::Trait)\n-        }\n \n         self.mod_declaration_under_caret =\n             find_node_at_offset::<ast::Module>(&file_with_fake_ident, offset)\n@@ -338,8 +336,6 @@ impl<'a> CompletionContext<'a> {\n         let fn_is_prev = self.previous_token_is(T![fn]);\n         let for_is_prev2 = for_is_prev2(syntax_element.clone());\n         self.no_completion_required = (fn_is_prev && !inside_impl_trait_block) || for_is_prev2;\n-\n-        self.completion_location = determine_location(fake_ident_token);\n     }\n \n     fn fill_impl_def(&mut self) {\n@@ -465,6 +461,8 @@ impl<'a> CompletionContext<'a> {\n             Some(it) => it,\n             None => return,\n         };\n+        self.completion_location = determine_location(&name_like);\n+        self.prev_sibling = determine_prev_sibling(&name_like);\n         match name_like {\n             ast::NameLike::Lifetime(lifetime) => {\n                 self.classify_lifetime(original_file, lifetime, offset);\n@@ -653,17 +651,6 @@ impl<'a> CompletionContext<'a> {\n                 })\n                 .unwrap_or(false);\n             self.is_expr = path.syntax().parent().and_then(ast::PathExpr::cast).is_some();\n-\n-            if let Some(off) = name_ref.syntax().text_range().start().checked_sub(2.into()) {\n-                if let Some(if_expr) =\n-                    self.sema.find_node_at_offset_with_macros::<ast::IfExpr>(original_file, off)\n-                {\n-                    if if_expr.syntax().text_range().end() < name_ref.syntax().text_range().start()\n-                    {\n-                        self.after_if = true;\n-                    }\n-                }\n-            }\n         }\n \n         if let Some(field_expr) = ast::FieldExpr::cast(parent.clone()) {"}, {"sha": "caf0ef39fc2b154d5f5a4a04359c0ba5378e2f1e", "filename": "crates/ide_completion/src/patterns.rs", "status": "modified", "additions": 186, "deletions": 79, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/7869b01b702d1f12acb03ac131b6eb90ad82e9bb/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7869b01b702d1f12acb03ac131b6eb90ad82e9bb/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fpatterns.rs?ref=7869b01b702d1f12acb03ac131b6eb90ad82e9bb", "patch": "@@ -4,12 +4,19 @@ use syntax::{\n     algo::non_trivia_sibling,\n     ast::{self, LoopBodyOwner},\n     match_ast, AstNode, Direction, NodeOrToken, SyntaxElement,\n-    SyntaxKind::{self, *},\n+    SyntaxKind::*,\n     SyntaxNode, SyntaxToken, T,\n };\n \n #[cfg(test)]\n use crate::test_utils::{check_pattern_is_applicable, check_pattern_is_not_applicable};\n+/// Direct parent container of the cursor position\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub(crate) enum ImmediatePrevSibling {\n+    IfExpr,\n+    TraitDefName,\n+    ImplDefType,\n+}\n \n /// Direct parent container of the cursor position\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -24,35 +31,61 @@ pub(crate) enum ImmediateLocation {\n     ItemList,\n }\n \n-pub(crate) fn determine_location(tok: SyntaxToken) -> Option<ImmediateLocation> {\n-    // First walk the element we are completing up to its highest node that has the same text range\n-    // as the element so that we can check in what context it immediately lies. We only do this for\n-    // NameRef -> Path as that's the only thing that makes sense to being \"expanded\" semantically.\n-    // We only wanna do this if the NameRef is the last segment of the path.\n-    let node = match tok.parent().and_then(ast::NameLike::cast)? {\n-        ast::NameLike::NameRef(name_ref) => {\n-            if let Some(segment) = name_ref.syntax().parent().and_then(ast::PathSegment::cast) {\n-                let p = segment.parent_path();\n-                if p.parent_path().is_none() {\n-                    p.syntax()\n-                        .ancestors()\n-                        .take_while(|it| it.text_range() == p.syntax().text_range())\n-                        .last()?\n-                } else {\n-                    return None;\n+pub(crate) fn determine_prev_sibling(name_like: &ast::NameLike) -> Option<ImmediatePrevSibling> {\n+    let node = maximize_name_ref(name_like)?;\n+    let node = match node.parent().and_then(ast::MacroCall::cast) {\n+        // When a path is being typed after the name of a trait/type of an impl it is being\n+        // parsed as a macro, so when the trait/impl has a block following it an we are between the\n+        // name and block the macro will attach the block to itself so maximizing fails to take\n+        // that into account\n+        // FIXME path expr and statement have a similar problem with attrs\n+        Some(call)\n+            if call.excl_token().is_none()\n+                && call.token_tree().map_or(false, |t| t.l_curly_token().is_some())\n+                && call.semicolon_token().is_none() =>\n+        {\n+            call.syntax().clone()\n+        }\n+        _ => node,\n+    };\n+    let prev_sibling = non_trivia_sibling(node.into(), Direction::Prev)?.into_node()?;\n+    let res = match_ast! {\n+        match prev_sibling {\n+            ast::ExprStmt(it) => {\n+                let node = it.expr().filter(|_| it.semicolon_token().is_none())?.syntax().clone();\n+                match_ast! {\n+                    match node {\n+                        ast::IfExpr(_it) => ImmediatePrevSibling::IfExpr,\n+                        _ => return None,\n+                    }\n                 }\n-            } else {\n-                return None;\n-            }\n+            },\n+            ast::Trait(it) => if it.assoc_item_list().is_none() {\n+                    ImmediatePrevSibling::TraitDefName\n+                } else {\n+                    return None\n+            },\n+            ast::Impl(it) => if it.assoc_item_list().is_none()\n+                && (it.for_token().is_none() || it.self_ty().is_some()) {\n+                    ImmediatePrevSibling::ImplDefType\n+                } else {\n+                    return None\n+            },\n+            _ => return None,\n         }\n-        it @ ast::NameLike::Name(_) | it @ ast::NameLike::Lifetime(_) => it.syntax().clone(),\n     };\n+    Some(res)\n+}\n+\n+pub(crate) fn determine_location(name_like: &ast::NameLike) -> Option<ImmediateLocation> {\n+    let node = maximize_name_ref(name_like)?;\n     let parent = match node.parent() {\n         Some(parent) => match ast::MacroCall::cast(parent.clone()) {\n             // When a path is being typed in an (Assoc)ItemList the parser will always emit a macro_call.\n             // This is usually fine as the node expansion code above already accounts for that with\n             // the ancestors call, but there is one exception to this which is that when an attribute\n             // precedes it the code above will not walk the Path to the parent MacroCall as their ranges differ.\n+            // FIXME path expr and statement have a similar problem\n             Some(call)\n                 if call.excl_token().is_none()\n                     && call.token_tree().is_none()\n@@ -90,56 +123,30 @@ pub(crate) fn determine_location(tok: SyntaxToken) -> Option<ImmediateLocation>\n     Some(res)\n }\n \n-#[cfg(test)]\n-fn check_location(code: &str, loc: ImmediateLocation) {\n-    check_pattern_is_applicable(code, |e| {\n-        assert_eq!(determine_location(e.into_token().expect(\"Expected a token\")), Some(loc));\n-        true\n-    });\n-}\n-\n-#[test]\n-fn test_has_trait_parent() {\n-    check_location(r\"trait A { f$0 }\", ImmediateLocation::Trait);\n-}\n-\n-#[test]\n-fn test_has_use_parent() {\n-    check_location(r\"use f$0\", ImmediateLocation::Use);\n-}\n-\n-#[test]\n-fn test_has_impl_parent() {\n-    check_location(r\"impl A { f$0 }\", ImmediateLocation::Impl);\n-}\n-#[test]\n-fn test_has_field_list_parent() {\n-    check_location(r\"struct Foo { f$0 }\", ImmediateLocation::RecordField);\n-    check_location(r\"struct Foo { f$0 pub f: i32}\", ImmediateLocation::RecordField);\n-}\n-\n-#[test]\n-fn test_has_block_expr_parent() {\n-    check_location(r\"fn my_fn() { let a = 2; f$0 }\", ImmediateLocation::BlockExpr);\n-}\n-\n-#[test]\n-fn test_has_ident_pat_parent() {\n-    check_location(r\"fn my_fn(m$0) {}\", ImmediateLocation::IdentPat);\n-    check_location(r\"fn my_fn() { let m$0 }\", ImmediateLocation::IdentPat);\n-    check_location(r\"fn my_fn(&m$0) {}\", ImmediateLocation::IdentPat);\n-    check_location(r\"fn my_fn() { let &m$0 }\", ImmediateLocation::IdentPat);\n-}\n-\n-#[test]\n-fn test_has_ref_expr_parent() {\n-    check_location(r\"fn my_fn() { let x = &m$0 foo; }\", ImmediateLocation::RefExpr);\n-}\n-\n-#[test]\n-fn test_has_item_list_or_source_file_parent() {\n-    check_location(r\"i$0\", ImmediateLocation::ItemList);\n-    check_location(r\"mod foo { f$0 }\", ImmediateLocation::ItemList);\n+fn maximize_name_ref(name_like: &ast::NameLike) -> Option<SyntaxNode> {\n+    // First walk the element we are completing up to its highest node that has the same text range\n+    // as the element so that we can check in what context it immediately lies. We only do this for\n+    // NameRef -> Path as that's the only thing that makes sense to being \"expanded\" semantically.\n+    // We only wanna do this if the NameRef is the last segment of the path.\n+    let node = match name_like {\n+        ast::NameLike::NameRef(name_ref) => {\n+            if let Some(segment) = name_ref.syntax().parent().and_then(ast::PathSegment::cast) {\n+                let p = segment.parent_path();\n+                if p.parent_path().is_none() {\n+                    p.syntax()\n+                        .ancestors()\n+                        .take_while(|it| it.text_range() == p.syntax().text_range())\n+                        .last()?\n+                } else {\n+                    return None;\n+                }\n+            } else {\n+                return None;\n+            }\n+        }\n+        it @ ast::NameLike::Name(_) | it @ ast::NameLike::Lifetime(_) => it.syntax().clone(),\n+    };\n+    Some(node)\n }\n \n pub(crate) fn inside_impl_trait_block(element: SyntaxElement) -> bool {\n@@ -191,14 +198,6 @@ fn test_for_is_prev2() {\n     check_pattern_is_applicable(r\"for i i$0\", for_is_prev2);\n }\n \n-pub(crate) fn has_prev_sibling(element: SyntaxElement, kind: SyntaxKind) -> bool {\n-    previous_sibling_or_ancestor_sibling(element).filter(|it| it.kind() == kind).is_some()\n-}\n-#[test]\n-fn test_has_impl_as_prev_sibling() {\n-    check_pattern_is_applicable(r\"impl A w$0 {}\", |it| has_prev_sibling(it, IMPL));\n-}\n-\n pub(crate) fn is_in_loop_body(element: SyntaxElement) -> bool {\n     element\n         .ancestors()\n@@ -247,3 +246,111 @@ fn previous_sibling_or_ancestor_sibling(element: SyntaxElement) -> Option<Syntax\n         non_trivia_sibling(NodeOrToken::Node(prev_sibling_node), Direction::Prev)\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    fn check_location(code: &str, loc: impl Into<Option<ImmediateLocation>>) {\n+        check_pattern_is_applicable(code, |e| {\n+            let name = &e.parent().and_then(ast::NameLike::cast).expect(\"Expected a namelike\");\n+            assert_eq!(determine_location(name), loc.into());\n+            true\n+        });\n+    }\n+\n+    fn check_prev_sibling(code: &str, sibling: impl Into<Option<ImmediatePrevSibling>>) {\n+        check_pattern_is_applicable(code, |e| {\n+            let name = &e.parent().and_then(ast::NameLike::cast).expect(\"Expected a namelike\");\n+            assert_eq!(determine_prev_sibling(name), sibling.into());\n+            true\n+        });\n+    }\n+\n+    #[test]\n+    fn test_trait_loc() {\n+        check_location(r\"trait A { f$0 }\", ImmediateLocation::Trait);\n+        check_location(r\"trait A { #[attr] f$0 }\", ImmediateLocation::Trait);\n+        check_location(r\"trait A { f$0 fn f() {} }\", ImmediateLocation::Trait);\n+        check_location(r\"trait A { fn f() {} f$0 }\", ImmediateLocation::Trait);\n+        check_location(r\"trait A$0 {}\", None);\n+        check_location(r\"trait A { fn f$0 }\", None);\n+    }\n+\n+    #[test]\n+    fn test_impl_loc() {\n+        check_location(r\"impl A { f$0 }\", ImmediateLocation::Impl);\n+        check_location(r\"impl A { #[attr] f$0 }\", ImmediateLocation::Impl);\n+        check_location(r\"impl A { f$0 fn f() {} }\", ImmediateLocation::Impl);\n+        check_location(r\"impl A { fn f() {} f$0 }\", ImmediateLocation::Impl);\n+        check_location(r\"impl A$0 {}\", None);\n+        check_location(r\"impl A { fn f$0 }\", None);\n+    }\n+\n+    #[test]\n+    fn test_use_loc() {\n+        check_location(r\"use f$0\", ImmediateLocation::Use);\n+        check_location(r\"use f$0;\", ImmediateLocation::Use);\n+        check_location(r\"use f::{f$0}\", None);\n+        check_location(r\"use {f$0}\", None);\n+    }\n+\n+    #[test]\n+    fn test_record_field_loc() {\n+        check_location(r\"struct Foo { f$0 }\", ImmediateLocation::RecordField);\n+        check_location(r\"struct Foo { f$0 pub f: i32}\", ImmediateLocation::RecordField);\n+        check_location(r\"struct Foo { pub f: i32, f$0 }\", ImmediateLocation::RecordField);\n+    }\n+\n+    #[test]\n+    fn test_block_expr_loc() {\n+        check_location(r\"fn my_fn() { let a = 2; f$0 }\", ImmediateLocation::BlockExpr);\n+        check_location(r\"fn my_fn() { f$0 f }\", ImmediateLocation::BlockExpr);\n+    }\n+\n+    #[test]\n+    fn test_ident_pat_loc() {\n+        check_location(r\"fn my_fn(m$0) {}\", ImmediateLocation::IdentPat);\n+        check_location(r\"fn my_fn() { let m$0 }\", ImmediateLocation::IdentPat);\n+        check_location(r\"fn my_fn(&m$0) {}\", ImmediateLocation::IdentPat);\n+        check_location(r\"fn my_fn() { let &m$0 }\", ImmediateLocation::IdentPat);\n+    }\n+\n+    #[test]\n+    fn test_ref_expr_loc() {\n+        check_location(r\"fn my_fn() { let x = &m$0 foo; }\", ImmediateLocation::RefExpr);\n+    }\n+\n+    #[test]\n+    fn test_item_list_loc() {\n+        check_location(r\"i$0\", ImmediateLocation::ItemList);\n+        check_location(r\"#[attr] i$0\", ImmediateLocation::ItemList);\n+        check_location(r\"fn f() {} i$0\", ImmediateLocation::ItemList);\n+        check_location(r\"mod foo { f$0 }\", ImmediateLocation::ItemList);\n+        check_location(r\"mod foo { #[attr] f$0 }\", ImmediateLocation::ItemList);\n+        check_location(r\"mod foo { fn f() {} f$0 }\", ImmediateLocation::ItemList);\n+        check_location(r\"mod foo$0 {}\", None);\n+    }\n+\n+    #[test]\n+    fn test_impl_prev_sibling() {\n+        check_prev_sibling(r\"impl A w$0 \", ImmediatePrevSibling::ImplDefType);\n+        check_prev_sibling(r\"impl A w$0 {}\", ImmediatePrevSibling::ImplDefType);\n+        check_prev_sibling(r\"impl A for A w$0 \", ImmediatePrevSibling::ImplDefType);\n+        check_prev_sibling(r\"impl A for A w$0 {}\", ImmediatePrevSibling::ImplDefType);\n+        check_prev_sibling(r\"impl A for w$0 {}\", None);\n+        check_prev_sibling(r\"impl A for w$0\", None);\n+    }\n+\n+    #[test]\n+    fn test_trait_prev_sibling() {\n+        check_prev_sibling(r\"trait A w$0 \", ImmediatePrevSibling::TraitDefName);\n+        check_prev_sibling(r\"trait A w$0 {}\", ImmediatePrevSibling::TraitDefName);\n+    }\n+\n+    #[test]\n+    fn test_if_expr_prev_sibling() {\n+        check_prev_sibling(r\"fn foo() { if true {} w$0\", ImmediatePrevSibling::IfExpr);\n+        check_prev_sibling(r\"fn foo() { if true {}; w$0\", None);\n+    }\n+}"}, {"sha": "93c7c872ccfdef9eb6d71170a628c57674463a39", "filename": "crates/ide_completion/src/test_utils.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7869b01b702d1f12acb03ac131b6eb90ad82e9bb/crates%2Fide_completion%2Fsrc%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7869b01b702d1f12acb03ac131b6eb90ad82e9bb/crates%2Fide_completion%2Fsrc%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftest_utils.rs?ref=7869b01b702d1f12acb03ac131b6eb90ad82e9bb", "patch": "@@ -12,7 +12,7 @@ use ide_db::{\n use itertools::Itertools;\n use stdx::{format_to, trim_indent};\n use syntax::{AstNode, NodeOrToken, SyntaxElement};\n-use test_utils::{assert_eq_text, RangeOrOffset};\n+use test_utils::assert_eq_text;\n \n use crate::{item::CompletionKind, CompletionConfig, CompletionItem};\n \n@@ -36,10 +36,7 @@ pub(crate) fn position(ra_fixture: &str) -> (RootDatabase, FilePosition) {\n     let mut database = RootDatabase::default();\n     database.apply_change(change_fixture.change);\n     let (file_id, range_or_offset) = change_fixture.file_position.expect(\"expected a marker ($0)\");\n-    let offset = match range_or_offset {\n-        RangeOrOffset::Range(_) => panic!(),\n-        RangeOrOffset::Offset(it) => it,\n-    };\n+    let offset = range_or_offset.expect_offset();\n     (database, FilePosition { file_id, offset })\n }\n \n@@ -52,10 +49,11 @@ pub(crate) fn do_completion_with_config(\n     code: &str,\n     kind: CompletionKind,\n ) -> Vec<CompletionItem> {\n-    let mut kind_completions: Vec<CompletionItem> =\n-        get_all_items(config, code).into_iter().filter(|c| c.completion_kind == kind).collect();\n-    kind_completions.sort_by(|l, r| l.label().cmp(r.label()));\n-    kind_completions\n+    get_all_items(config, code)\n+        .into_iter()\n+        .filter(|c| c.completion_kind == kind)\n+        .sorted_by(|l, r| l.label().cmp(r.label()))\n+        .collect()\n }\n \n pub(crate) fn completion_list(code: &str, kind: CompletionKind) -> String {"}, {"sha": "b585085f381b6ac486c4be5c9882143f034cbd26", "filename": "crates/ide_db/src/call_info/tests.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7869b01b702d1f12acb03ac131b6eb90ad82e9bb/crates%2Fide_db%2Fsrc%2Fcall_info%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7869b01b702d1f12acb03ac131b6eb90ad82e9bb/crates%2Fide_db%2Fsrc%2Fcall_info%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fcall_info%2Ftests.rs?ref=7869b01b702d1f12acb03ac131b6eb90ad82e9bb", "patch": "@@ -1,6 +1,5 @@\n use base_db::{fixture::ChangeFixture, FilePosition};\n use expect_test::{expect, Expect};\n-use test_utils::RangeOrOffset;\n \n use crate::RootDatabase;\n \n@@ -10,10 +9,7 @@ pub(crate) fn position(ra_fixture: &str) -> (RootDatabase, FilePosition) {\n     let mut database = RootDatabase::default();\n     database.apply_change(change_fixture.change);\n     let (file_id, range_or_offset) = change_fixture.file_position.expect(\"expected a marker ($0)\");\n-    let offset = match range_or_offset {\n-        RangeOrOffset::Range(_) => panic!(),\n-        RangeOrOffset::Offset(it) => it,\n-    };\n+    let offset = range_or_offset.expect_offset();\n     (database, FilePosition { file_id, offset })\n }\n "}, {"sha": "de994407c7ca464061eee92c59aa604154ae1b76", "filename": "crates/ide_db/src/traits/tests.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7869b01b702d1f12acb03ac131b6eb90ad82e9bb/crates%2Fide_db%2Fsrc%2Ftraits%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7869b01b702d1f12acb03ac131b6eb90ad82e9bb/crates%2Fide_db%2Fsrc%2Ftraits%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Ftraits%2Ftests.rs?ref=7869b01b702d1f12acb03ac131b6eb90ad82e9bb", "patch": "@@ -2,7 +2,6 @@ use base_db::{fixture::ChangeFixture, FilePosition};\n use expect_test::{expect, Expect};\n use hir::Semantics;\n use syntax::ast::{self, AstNode};\n-use test_utils::RangeOrOffset;\n \n use crate::RootDatabase;\n \n@@ -12,10 +11,7 @@ pub(crate) fn position(ra_fixture: &str) -> (RootDatabase, FilePosition) {\n     let mut database = RootDatabase::default();\n     database.apply_change(change_fixture.change);\n     let (file_id, range_or_offset) = change_fixture.file_position.expect(\"expected a marker ($0)\");\n-    let offset = match range_or_offset {\n-        RangeOrOffset::Range(_) => panic!(),\n-        RangeOrOffset::Offset(it) => it,\n-    };\n+    let offset = range_or_offset.expect_offset();\n     (database, FilePosition { file_id, offset })\n }\n "}, {"sha": "bd017567cae53a320d9aa1f763a09d475f707568", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7869b01b702d1f12acb03ac131b6eb90ad82e9bb/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7869b01b702d1f12acb03ac131b6eb90ad82e9bb/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=7869b01b702d1f12acb03ac131b6eb90ad82e9bb", "patch": "@@ -96,6 +96,21 @@ pub enum RangeOrOffset {\n     Offset(TextSize),\n }\n \n+impl RangeOrOffset {\n+    pub fn expect_offset(self) -> TextSize {\n+        match self {\n+            RangeOrOffset::Offset(it) => it,\n+            RangeOrOffset::Range(_) => panic!(\"expected an offset but got a range instead\"),\n+        }\n+    }\n+    pub fn expect_range(self) -> TextRange {\n+        match self {\n+            RangeOrOffset::Range(it) => it,\n+            RangeOrOffset::Offset(_) => panic!(\"expected a range but got an offset\"),\n+        }\n+    }\n+}\n+\n impl From<RangeOrOffset> for TextRange {\n     fn from(selection: RangeOrOffset) -> Self {\n         match selection {"}]}