{"sha": "82d40cb2ba44a27b7db8ec185b5c532237db4b3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyZDQwY2IyYmE0NGEyN2I3ZGI4ZWMxODViNWM1MzIyMzdkYjRiM2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-24T19:04:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-24T19:04:31Z"}, "message": "Auto merge of #27265 - steveklabnik:rollup, r=steveklabnik\n\n- Successful merges: #27137, #27145, #27177, #27193, #27212, #27220, #27229, #27235, #27238, #27244, #27251\n- Failed merges:", "tree": {"sha": "56707c7138fe42cabe96030d36c74a9b70e28a25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56707c7138fe42cabe96030d36c74a9b70e28a25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82d40cb2ba44a27b7db8ec185b5c532237db4b3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82d40cb2ba44a27b7db8ec185b5c532237db4b3e", "html_url": "https://github.com/rust-lang/rust/commit/82d40cb2ba44a27b7db8ec185b5c532237db4b3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e6b534362de257603f8fc318eba78deb83206e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e6b534362de257603f8fc318eba78deb83206e3", "html_url": "https://github.com/rust-lang/rust/commit/5e6b534362de257603f8fc318eba78deb83206e3"}, {"sha": "427238ce2472ce23ee350bf0dcc9f5c42aa72ece", "url": "https://api.github.com/repos/rust-lang/rust/commits/427238ce2472ce23ee350bf0dcc9f5c42aa72ece", "html_url": "https://github.com/rust-lang/rust/commit/427238ce2472ce23ee350bf0dcc9f5c42aa72ece"}], "stats": {"total": 447, "additions": 409, "deletions": 38}, "files": [{"sha": "26fd2fd8d20d6d071ed534e5130a7365880506f6", "filename": "src/doc/reference.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=82d40cb2ba44a27b7db8ec185b5c532237db4b3e", "patch": "@@ -1636,6 +1636,10 @@ The type of a function declared in an extern block is `extern \"abi\" fn(A1, ...,\n An) -> R`, where `A1...An` are the declared types of its arguments and `R` is\n the declared return type.\n \n+It is valid to add the `link` attribute on an empty extern block. You can use\n+this to satisfy the linking requirements of extern blocks elsewhere in your code\n+(including upstream crates) instead of adding the attribute to each extern block.\n+\n ## Visibility and Privacy\n \n These two terms are often used interchangeably, and what they are attempting to"}, {"sha": "f1e51591aea0eb30a4e77467f4d568cca3144094", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=82d40cb2ba44a27b7db8ec185b5c532237db4b3e", "patch": "@@ -63,7 +63,7 @@\n     * [No stdlib](no-stdlib.md)\n     * [Intrinsics](intrinsics.md)\n     * [Lang items](lang-items.md)\n-    * [Link args](link-args.md)\n+    * [Advanced linking](advanced-linking.md)\n     * [Benchmark Tests](benchmark-tests.md)\n     * [Box Syntax and Patterns](box-syntax-and-patterns.md)\n     * [Slice Patterns](slice-patterns.md)"}, {"sha": "6d37043354282cf6db4dd95b87e320bf5b086b0d", "filename": "src/doc/trpl/advanced-linking.md", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Fdoc%2Ftrpl%2Fadvanced-linking.md", "raw_url": "https://github.com/rust-lang/rust/raw/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Fdoc%2Ftrpl%2Fadvanced-linking.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fadvanced-linking.md?ref=82d40cb2ba44a27b7db8ec185b5c532237db4b3e", "patch": "@@ -0,0 +1,151 @@\n+% Advanced Linking\n+\n+The common cases of linking with Rust have been covered earlier in this book,\n+but supporting the range of linking possibilities made available by other\n+languages is important for Rust to achieve seamless interaction with native\n+libraries.\n+\n+# Link args\n+\n+There is one other way to tell `rustc` how to customize linking, and that is via\n+the `link_args` attribute. This attribute is applied to `extern` blocks and\n+specifies raw flags which need to get passed to the linker when producing an\n+artifact. An example usage would be:\n+\n+``` no_run\n+#![feature(link_args)]\n+\n+#[link_args = \"-foo -bar -baz\"]\n+extern {}\n+# fn main() {}\n+```\n+\n+Note that this feature is currently hidden behind the `feature(link_args)` gate\n+because this is not a sanctioned way of performing linking. Right now `rustc`\n+shells out to the system linker (`gcc` on most systems, `link.exe` on MSVC),\n+so it makes sense to provide extra command line\n+arguments, but this will not always be the case. In the future `rustc` may use\n+LLVM directly to link native libraries, in which case `link_args` will have no\n+meaning. You can achieve the same effect as the `link-args` attribute with the\n+`-C link-args` argument to `rustc`.\n+\n+It is highly recommended to *not* use this attribute, and rather use the more\n+formal `#[link(...)]` attribute on `extern` blocks instead.\n+\n+# Static linking\n+\n+Static linking refers to the process of creating output that contain all\n+required libraries and so don't need libraries installed on every system where\n+you want to use your compiled project. Pure-Rust dependencies are statically\n+linked by default so you can use created binaries and libraries without\n+installing the Rust everywhere. By contrast, native libraries\n+(e.g. `libc` and `libm`) usually dynamically linked, but it is possible to\n+change this and statically link them as well.\n+\n+Linking is a very platform dependent topic \u2014 on some platforms, static linking\n+may not be possible at all! This section assumes some basic familiarity with\n+linking on your platform of choice.\n+\n+## Linux\n+\n+By default, all Rust programs on Linux will link to the system `libc` along with\n+a number of other libraries. Let's look at an example on a 64-bit Linux machine\n+with GCC and `glibc` (by far the most common `libc` on Linux):\n+\n+``` text\n+$ cat example.rs\n+fn main() {}\n+$ rustc example.rs\n+$ ldd example\n+        linux-vdso.so.1 =>  (0x00007ffd565fd000)\n+        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fa81889c000)\n+        libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fa81867e000)\n+        librt.so.1 => /lib/x86_64-linux-gnu/librt.so.1 (0x00007fa818475000)\n+        libgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007fa81825f000)\n+        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fa817e9a000)\n+        /lib64/ld-linux-x86-64.so.2 (0x00007fa818cf9000)\n+        libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007fa817b93000)\n+```\n+\n+Dynamic linking on Linux can be undesirable if you wish to use new library\n+features on old systems or target systems which do not have the required\n+dependencies for your program to run.\n+\n+Static linking is supported via an alternative `libc`, `musl` - this must be\n+enabled at Rust compile-time with some prerequisites available. You can compile\n+your own version of Rust with `musl` enabled and install it into a custom\n+directory with the instructions below:\n+\n+```text\n+$ mkdir musldist\n+$ PREFIX=$(pwd)/musldist\n+$\n+$ # Build musl\n+$ wget http://www.musl-libc.org/releases/musl-1.1.10.tar.gz\n+[...]\n+$ tar xf musl-1.1.10.tar.gz\n+$ cd musl-1.1.10/\n+musl-1.1.10 $ ./configure --disable-shared --prefix=$PREFIX\n+[...]\n+musl-1.1.10 $ make\n+[...]\n+musl-1.1.10 $ make install\n+[...]\n+musl-1.1.10 $ cd ..\n+$ du -h musldist/lib/libc.a\n+2.2M    musldist/lib/libc.a\n+$\n+$ # Build libunwind.a\n+$ wget http://llvm.org/releases/3.6.1/llvm-3.6.1.src.tar.xz\n+$ tar xf llvm-3.6.1.src.tar.xz\n+$ cd llvm-3.6.1.src/projects/\n+llvm-3.6.1.src/projects $ svn co http://llvm.org/svn/llvm-project/libcxxabi/trunk/ libcxxabi\n+llvm-3.6.1.src/projects $ svn co http://llvm.org/svn/llvm-project/libunwind/trunk/ libunwind\n+llvm-3.6.1.src/projects $ sed -i 's#^\\(include_directories\\).*$#\\0\\n\\1(../libcxxabi/include)#' libunwind/CMakeLists.txt\n+llvm-3.6.1.src/projects $ mkdir libunwind/build\n+llvm-3.6.1.src/projects $ cd libunwind/build\n+llvm-3.6.1.src/projects/libunwind/build $ cmake -DLLVM_PATH=../../.. -DLIBUNWIND_ENABLE_SHARED=0 ..\n+llvm-3.6.1.src/projects/libunwind/build $ make\n+llvm-3.6.1.src/projects/libunwind/build $ cp lib/libunwind.a $PREFIX/lib/\n+llvm-3.6.1.src/projects/libunwind/build $ cd cd ../../../../\n+$ du -h musldist/lib/libunwind.a\n+164K    musldist/lib/libunwind.a\n+$\n+$ # Build musl-enabled rust\n+$ git clone https://github.com/rust-lang/rust.git muslrust\n+$ cd muslrust\n+muslrust $ ./configure --target=x86_64-unknown-linux-musl --musl-root=$PREFIX --prefix=$PREFIX\n+muslrust $ make\n+muslrust $ make install\n+muslrust $ cd ..\n+$ du -h musldist/bin/rustc\n+12K     musldist/bin/rustc\n+```\n+\n+You now have a build of a `musl`-enabled Rust! Because we've installed it to a\n+custom prefix we need to make sure our system can the binaries and appropriate\n+libraries when we try and run it:\n+\n+```text\n+$ export PATH=$PREFIX/bin:$PATH\n+$ export LD_LIBRARY_PATH=$PREFIX/lib:$LD_LIBRARY_PATH\n+```\n+\n+Let's try it out!\n+\n+```text\n+$ echo 'fn main() { println!(\"hi!\"); panic!(\"failed\"); }' > example.rs\n+$ rustc --target=x86_64-unknown-linux-musl example.rs\n+$ ldd example\n+        not a dynamic executable\n+$ ./example\n+hi!\n+thread '<main>' panicked at 'failed', example.rs:1\n+```\n+\n+Success! This binary can be copied to almost any Linux machine with the same\n+machine architecture and run without issues.\n+\n+`cargo build` also permits the `--target` option so you should be able to build\n+your crates as normal. However, you may need to recompile your native libraries\n+against `musl` before they can be linked against."}, {"sha": "cdaef6cd9b5109c9e5a825df9ed55279a4aef3e5", "filename": "src/doc/trpl/link-args.md", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Fdoc%2Ftrpl%2Flink-args.md", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Fdoc%2Ftrpl%2Flink-args.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flink-args.md?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -1,25 +0,0 @@\n-% Link args\n-\n-There is one other way to tell rustc how to customize linking, and that is via\n-the `link_args` attribute. This attribute is applied to `extern` blocks and\n-specifies raw flags which need to get passed to the linker when producing an\n-artifact. An example usage would be:\n-\n-``` no_run\n-#![feature(link_args)]\n-\n-#[link_args = \"-foo -bar -baz\"]\n-extern {}\n-# fn main() {}\n-```\n-\n-Note that this feature is currently hidden behind the `feature(link_args)` gate\n-because this is not a sanctioned way of performing linking. Right now rustc\n-shells out to the system linker, so it makes sense to provide extra command line\n-arguments, but this will not always be the case. In the future rustc may use\n-LLVM directly to link native libraries, in which case `link_args` will have no\n-meaning.\n-\n-It is highly recommended to *not* use this attribute, and rather use the more\n-formal `#[link(...)]` attribute on `extern` blocks instead.\n-"}, {"sha": "124ebc7d69ddcb5343a708ad50b26a413cf7783a", "filename": "src/doc/trpl/while-loops.md", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Fdoc%2Ftrpl%2Fwhile-loops.md", "raw_url": "https://github.com/rust-lang/rust/raw/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Fdoc%2Ftrpl%2Fwhile-loops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fwhile-loops.md?ref=82d40cb2ba44a27b7db8ec185b5c532237db4b3e", "patch": "@@ -88,6 +88,24 @@ for x in 0..10 {\n }\n ```\n \n+You may also encounter situations where you have nested loops and need to \n+specify which one your `break` or `continue` statement is for. Like most \n+other languages, by default a `break` or `continue` will apply to innermost \n+loop. In a sitation where you would like to a `break` or `continue` for one \n+of the outer loops, you can use labels to specify which loop the `break` or\n+ `continue` statement applies to. This will only print when both `x` and `y` are\n+ odd:\n+\n+```rust\n+'outer: for x in 0..10 {\n+    'inner: for y in 0..10 {\n+        if x % 2 == 0 { continue 'outer; } // continues the loop over x\n+        if y % 2 == 0 { continue 'inner; } // continues the loop over y\n+        println!(\"x: {}, y: {}\", x, y);\n+    }\n+}\n+```\n+\n Both `continue` and `break` are valid in both `while` loops and [`for` loops][for].\n \n [for]: for-loops.html"}, {"sha": "c1cf2230ac476fc474246a02af4a1a4cb074eb1e", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=82d40cb2ba44a27b7db8ec185b5c532237db4b3e", "patch": "@@ -1057,6 +1057,10 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n /// The `Deref` trait is used to specify the functionality of dereferencing\n /// operations like `*v`.\n ///\n+/// `Deref` also enables ['`Deref` coercions'][coercions].\n+///\n+/// [coercions]: ../../book/deref-coercions.html\n+///\n /// # Examples\n ///\n /// A struct with a single field which is accessible via dereferencing the\n@@ -1111,6 +1115,10 @@ impl<'a, T: ?Sized> Deref for &'a mut T {\n /// The `DerefMut` trait is used to specify the functionality of dereferencing\n /// mutably like `*v = 1;`\n ///\n+/// `DerefMut` also enables ['`Deref` coercions'][coercions].\n+///\n+/// [coercions]: ../../book/deref-coercions.html\n+///\n /// # Examples\n ///\n /// A struct with a single field which is modifiable via dereferencing the"}, {"sha": "a349dab0f72ea990daffca4c82c5608b03ae4f2b", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=82d40cb2ba44a27b7db8ec185b5c532237db4b3e", "patch": "@@ -967,6 +967,9 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n               Some(def::DefVariant(enum_def, variant_def, _)) => {\n                   (lookup_variant_by_id(tcx, enum_def, variant_def), None)\n               }\n+              Some(def::DefStruct(_)) => {\n+                  return Ok(ConstVal::Struct(e.id))\n+              }\n               _ => (None, None)\n           };\n           let const_expr = match const_expr {"}, {"sha": "ddb32f4625b58d0b2af4bedda473ce9271089b45", "filename": "src/librustc_back/target/bitrig_base.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Flibrustc_back%2Ftarget%2Fbitrig_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Flibrustc_back%2Ftarget%2Fbitrig_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fbitrig_base.rs?ref=82d40cb2ba44a27b7db8ec185b5c532237db4b3e", "patch": "@@ -20,9 +20,7 @@ pub fn opts() -> TargetOptions {\n         linker_is_gnu: true,\n         has_rpath: true,\n         position_independent_executables: true,\n-        pre_link_args: vec!(\n-        ),\n-        archive_format: \"bsd\".to_string(),\n+        archive_format: \"gnu\".to_string(),\n \n         .. Default::default()\n     }"}, {"sha": "4f90a287cb999f43ac249b5cb14c0b92a212195a", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=82d40cb2ba44a27b7db8ec185b5c532237db4b3e", "patch": "@@ -12,6 +12,56 @@\n \n register_long_diagnostics! {\n \n+E0373: r##\"\n+This error occurs when an attempt is made to use data captured by a closure,\n+when that data may no longer exist. It's most commonly seen when attempting to\n+return a closure:\n+\n+```\n+fn foo() -> Box<Fn(u32) -> u32> {\n+    let x = 0u32;\n+    Box::new(|y| x + y)\n+}\n+```\n+\n+Notice that `x` is stack-allocated by `foo()`. By default, Rust captures\n+closed-over data by reference. This means that once `foo()` returns, `x` no\n+longer exists. An attempt to access `x` within the closure would thus be unsafe.\n+\n+Another situation where this might be encountered is when spawning threads:\n+\n+```\n+fn foo() {\n+    let x = 0u32;\n+    let y = 1u32;\n+\n+    let thr = std::thread::spawn(|| {\n+        x + y\n+    });\n+}\n+```\n+\n+Since our new thread runs in parallel, the stack frame containing `x` and `y`\n+may well have disappeared by the time we try to use them. Even if we call\n+`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\n+stack frame won't disappear), we will not succeed: the compiler cannot prove\n+that this behaviour is safe, and so won't let us do it.\n+\n+The solution to this problem is usually to switch to using a `move` closure.\n+This approach moves (or copies, where possible) data into the closure, rather\n+than taking references to it. For example:\n+\n+```\n+fn foo() -> Box<Fn(u32) -> u32> {\n+    let x = 0u32;\n+    Box::new(move |y| x + y)\n+}\n+```\n+\n+Now that the closure has its own copy of the data, there's no need to worry\n+about safety.\n+\"##,\n+\n E0381: r##\"\n It is not allowed to use or capture an uninitialized variable. For example:\n \n@@ -28,7 +78,6 @@ used.\n }\n \n register_diagnostics! {\n-    E0373, // closure may outlive current fn, but it borrows {}, which is owned by current fn\n     E0382, // use of partially/collaterally moved value\n     E0383, // partial reinitialization of uninitialized structure\n     E0384, // reassignment of immutable variable"}, {"sha": "9f8a5c90d4e1cb0c02c09a25d827497eb5316133", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=82d40cb2ba44a27b7db8ec185b5c532237db4b3e", "patch": "@@ -426,6 +426,57 @@ use something_which_doesnt_exist;\n Please verify you didn't misspell the import's name.\n \"##,\n \n+E0437: r##\"\n+Trait impls can only implement associated types that are members of the trait in\n+question. This error indicates that you attempted to implement an associated\n+type whose name does not match the name of any associated type in the trait.\n+\n+Here is an example that demonstrates the error:\n+\n+```\n+trait Foo {}\n+\n+impl Foo for i32 {\n+    type Bar = bool;\n+}\n+```\n+\n+The solution to this problem is to remove the extraneous associated type:\n+\n+```\n+trait Foo {}\n+\n+impl Foo for i32 {}\n+```\n+\"##,\n+\n+E0438: r##\"\n+Trait impls can only implement associated constants that are members of the\n+trait in question. This error indicates that you attempted to implement an\n+associated constant whose name does not match the name of any associated\n+constant in the trait.\n+\n+Here is an example that demonstrates the error:\n+\n+```\n+#![feature(associated_consts)]\n+\n+trait Foo {}\n+\n+impl Foo for i32 {\n+    const BAR: bool = true;\n+}\n+```\n+\n+The solution to this problem is to remove the extraneous associated constant:\n+\n+```\n+trait Foo {}\n+\n+impl Foo for i32 {}\n+```\n+\"##\n+\n }\n \n register_diagnostics! {\n@@ -468,6 +519,4 @@ register_diagnostics! {\n     E0432, // unresolved import\n     E0434, // can't capture dynamic environment in a fn item\n     E0435, // attempt to use a non-constant value in a constant\n-    E0437, // type is not a member of trait\n-    E0438, // const is not a member of trait\n }"}, {"sha": "73ee3bbbe5b0132bee84908897f8add77eee573e", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 95, "deletions": 3, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=82d40cb2ba44a27b7db8ec185b5c532237db4b3e", "patch": "@@ -1316,6 +1316,45 @@ fn main() {\n ```\n \"##,\n \n+E0120: r##\"\n+An attempt was made to implement Drop on a trait, which is not allowed: only\n+structs and enums can implement Drop. An example causing this error:\n+\n+```\n+trait MyTrait {}\n+\n+impl Drop for MyTrait {\n+    fn drop(&mut self) {}\n+}\n+```\n+\n+A workaround for this problem is to wrap the trait up in a struct, and implement\n+Drop on that. An example is shown below:\n+\n+```\n+trait MyTrait {}\n+struct MyWrapper<T: MyTrait> { foo: T }\n+\n+impl <T: MyTrait> Drop for MyWrapper<T> {\n+    fn drop(&mut self) {}\n+}\n+\n+```\n+\n+Alternatively, wrapping trait objects requires something like the following:\n+\n+```\n+trait MyTrait {}\n+\n+//or Box<MyTrait>, if you wanted an owned trait object\n+struct MyWrapper<'a> { foo: &'a MyTrait }\n+\n+impl <'a> Drop for MyWrapper<'a> {\n+    fn drop(&mut self) {}\n+}\n+```\n+\"##,\n+\n E0121: r##\"\n In order to be consistent with Rust's lack of global type inference, type\n placeholders are disallowed by design in item signatures.\n@@ -1895,6 +1934,62 @@ type Foo = Trait<Bar=i32>; // ok!\n ```\n \"##,\n \n+E0223: r##\"\n+An attempt was made to retrieve an associated type, but the type was ambiguous.\n+For example:\n+\n+```\n+trait MyTrait {type X; }\n+\n+fn main() {\n+    let foo: MyTrait::X;\n+}\n+```\n+\n+The problem here is that we're attempting to take the type of X from MyTrait.\n+Unfortunately, the type of X is not defined, because it's only made concrete in\n+implementations of the trait. A working version of this code might look like:\n+\n+```\n+trait MyTrait {type X; }\n+struct MyStruct;\n+\n+impl MyTrait for MyStruct {\n+    type X = u32;\n+}\n+\n+fn main() {\n+    let foo: <MyStruct as MyTrait>::X;\n+}\n+```\n+\n+This syntax specifies that we want the X type from MyTrait, as made concrete in\n+MyStruct. The reason that we cannot simply use `MyStruct::X` is that MyStruct\n+might implement two different traits with identically-named associated types.\n+This syntax allows disambiguation between the two.\n+\"##,\n+\n+E0225: r##\"\n+You attempted to use multiple types as bounds for a closure or trait object.\n+Rust does not currently support this. A simple example that causes this error:\n+\n+```\n+fn main() {\n+    let _: Box<std::io::Read+std::io::Write>;\n+}\n+```\n+\n+Builtin traits are an exception to this rule: it's possible to have bounds of\n+one non-builtin type, plus any number of builtin types. For example, the\n+following compiles correctly:\n+\n+```\n+fn main() {\n+    let _: Box<std::io::Read+Copy+Sync>;\n+}\n+```\n+\"##,\n+\n E0232: r##\"\n The attribute must have a value. Erroneous code example:\n \n@@ -2195,7 +2290,6 @@ register_diagnostics! {\n     E0103,\n     E0104,\n     E0118,\n-    E0120,\n     E0122,\n     E0123,\n     E0127,\n@@ -2233,9 +2327,7 @@ register_diagnostics! {\n     E0221, // ambiguous associated type in bounds\n     //E0222, // Error code E0045 (variadic function must have C calling\n              // convention) duplicate\n-    E0223, // ambiguous associated type\n     E0224, // at least one non-builtin train is required for an object type\n-    E0225, // only the builtin traits can be used as closure or object bounds\n     E0226, // only a single explicit lifetime bound is permitted\n     E0227, // ambiguous lifetime bound, explicit lifetime bound required\n     E0228, // explicit lifetime bound required"}, {"sha": "20fcd309a6bef4ee7408e94fe07d9f4aa8b5d7fd", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=82d40cb2ba44a27b7db8ec185b5c532237db4b3e", "patch": "@@ -434,9 +434,9 @@ pub fn panicking() -> bool {\n \n /// Invokes a closure, capturing the cause of panic if one occurs.\n ///\n-/// This function will return `Ok(())` if the closure does not panic, and will\n-/// return `Err(cause)` if the closure panics. The `cause` returned is the\n-/// object with which panic was originally invoked.\n+/// This function will return `Ok` with the closure's result if the closure\n+/// does not panic, and will return `Err(cause)` if the closure panics. The\n+/// `cause` returned is the object with which panic was originally invoked.\n ///\n /// It is currently undefined behavior to unwind from Rust code into foreign\n /// code, so this function is particularly useful when Rust is called from"}, {"sha": "5c3e55e286232b9b41f640de79a169a8819f533b", "filename": "src/snapshots.txt", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=82d40cb2ba44a27b7db8ec185b5c532237db4b3e", "patch": "@@ -1,4 +1,7 @@\n S 2015-07-17 d4432b3\n+  bitrig-x86_64 af77768e0eb0f4c7ec5a8e36047a08053b54b230\n+  freebsd-i386 b049325e5b2efe5f4884f3dafda448c1dac49b4f\n+  freebsd-x86_64 a59e397188dbfe67456a6301df5ca13c7e238ab9\n   linux-i386 93f6216a35d3bed3cedf244c9aff4cd716336bd9\n   linux-x86_64 d8f4967fc71a153c925faecf95a7feadf7e463a4\n   macos-i386 29852c4d4b5a851f16d627856a279cae5bf9bd01"}, {"sha": "2a4b98563ab9f207c524827eedbccc7a6ef72982", "filename": "src/test/compile-fail/issue-27008.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Ftest%2Fcompile-fail%2Fissue-27008.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82d40cb2ba44a27b7db8ec185b5c532237db4b3e/src%2Ftest%2Fcompile-fail%2Fissue-27008.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27008.rs?ref=82d40cb2ba44a27b7db8ec185b5c532237db4b3e", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S;\n+\n+fn main() {\n+    let b = [0; S];\n+    //~^ ERROR mismatched types\n+    //~| expected `usize`\n+    //~| found `S`\n+    //~| expected usize\n+    //~| found struct `S`\n+    //~| ERROR expected positive integer for repeat count, found struct\n+}"}]}