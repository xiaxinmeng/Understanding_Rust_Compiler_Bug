{"sha": "7f822c800d6304466be666937539117d95a58022", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmODIyYzgwMGQ2MzA0NDY2YmU2NjY5Mzc1MzkxMTdkOTVhNTgwMjI=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-01-31T02:21:24Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-02-28T22:15:11Z"}, "message": "Refactor out `parser.expect_delimited_token_tree()`.", "tree": {"sha": "689c7599365ed8302f8b441f7e47987d07787714", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/689c7599365ed8302f8b441f7e47987d07787714"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f822c800d6304466be666937539117d95a58022", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f822c800d6304466be666937539117d95a58022", "html_url": "https://github.com/rust-lang/rust/commit/7f822c800d6304466be666937539117d95a58022", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f822c800d6304466be666937539117d95a58022/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "752413005ed58308160ca57525d6395a00a61116", "url": "https://api.github.com/repos/rust-lang/rust/commits/752413005ed58308160ca57525d6395a00a61116", "html_url": "https://github.com/rust-lang/rust/commit/752413005ed58308160ca57525d6395a00a61116"}], "stats": {"total": 49, "additions": 13, "deletions": 36}, "files": [{"sha": "71274c4fdaa4ead88e9512baac8a1ec75d7b065c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 13, "deletions": 36, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7f822c800d6304466be666937539117d95a58022/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f822c800d6304466be666937539117d95a58022/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7f822c800d6304466be666937539117d95a58022", "patch": "@@ -1170,10 +1170,7 @@ impl<'a> Parser<'a> {\n             self.expect(&token::Not)?;\n \n             // eat a matched-delimiter token tree:\n-            let delim = self.expect_open_delim()?;\n-            let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n-                                            SeqSep::none(),\n-                                            |pp| pp.parse_token_tree())?;\n+            let (delim, tts) = self.expect_delimited_token_tree()?;\n             if delim != token::Brace {\n                 self.expect(&token::Semi)?\n             }\n@@ -1431,10 +1428,7 @@ impl<'a> Parser<'a> {\n             let path = self.parse_path(PathStyle::Type)?;\n             if self.eat(&token::Not) {\n                 // MACRO INVOCATION\n-                let delim = self.expect_open_delim()?;\n-                let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n-                                                SeqSep::none(),\n-                                                |p| p.parse_token_tree())?;\n+                let (_, tts) = self.expect_delimited_token_tree()?;\n                 let hi = self.span.hi;\n                 TyKind::Mac(spanned(lo, hi, Mac_ { path: path, tts: tts }))\n             } else {\n@@ -2028,13 +2022,12 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn expect_open_delim(&mut self) -> PResult<'a, token::DelimToken> {\n-        self.expected_tokens.push(TokenType::Token(token::Gt));\n+    fn expect_delimited_token_tree(&mut self) -> PResult<'a, (token::DelimToken, Vec<TokenTree>)> {\n         match self.token {\n-            token::OpenDelim(delim) => {\n-                self.bump();\n-                Ok(delim)\n-            },\n+            token::OpenDelim(delim) => self.parse_token_tree().map(|tree| match tree {\n+                TokenTree::Delimited(_, delimited) => (delim, delimited.tts.clone()),\n+                _ => unreachable!(),\n+            }),\n             _ => Err(self.fatal(\"expected open delimiter\")),\n         }\n     }\n@@ -2244,10 +2237,7 @@ impl<'a> Parser<'a> {\n                     // `!`, as an operator, is prefix, so we know this isn't that\n                     if self.eat(&token::Not) {\n                         // MACRO INVOCATION expression\n-                        let delim = self.expect_open_delim()?;\n-                        let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n-                                                        SeqSep::none(),\n-                                                        |p| p.parse_token_tree())?;\n+                        let (_, tts) = self.expect_delimited_token_tree()?;\n                         let hi = self.prev_span.hi;\n                         return Ok(self.mk_mac_expr(lo, hi, Mac_ { path: pth, tts: tts }, attrs));\n                     }\n@@ -2580,6 +2570,7 @@ impl<'a> Parser<'a> {\n         match self.token {\n             token::OpenDelim(..) => {\n                 let tt = self.tts.pop().unwrap().0;\n+                self.span = tt.span();\n                 self.bump();\n                 return Ok(tt);\n             },\n@@ -3393,10 +3384,7 @@ impl<'a> Parser<'a> {\n                     token::Not if qself.is_none() => {\n                         // Parse macro invocation\n                         self.bump();\n-                        let delim = self.expect_open_delim()?;\n-                        let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n-                                                        SeqSep::none(),\n-                                                        |p| p.parse_token_tree())?;\n+                        let (_, tts) = self.expect_delimited_token_tree()?;\n                         let mac = spanned(lo, self.prev_span.hi, Mac_ { path: path, tts: tts });\n                         pat = PatKind::Mac(mac);\n                     }\n@@ -3696,12 +3684,7 @@ impl<'a> Parser<'a> {\n                 },\n             };\n \n-            let tts = self.parse_unspanned_seq(\n-                &token::OpenDelim(delim),\n-                &token::CloseDelim(delim),\n-                SeqSep::none(),\n-                |p| p.parse_token_tree()\n-            )?;\n+            let (_, tts) = self.expect_delimited_token_tree()?;\n             let hi = self.prev_span.hi;\n \n             let style = if delim == token::Brace {\n@@ -4609,10 +4592,7 @@ impl<'a> Parser<'a> {\n             self.expect(&token::Not)?;\n \n             // eat a matched-delimiter token tree:\n-            let delim = self.expect_open_delim()?;\n-            let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n-                                            SeqSep::none(),\n-                                            |p| p.parse_token_tree())?;\n+            let (delim, tts) = self.expect_delimited_token_tree()?;\n             if delim != token::Brace {\n                 self.expect(&token::Semi)?\n             }\n@@ -5758,10 +5738,7 @@ impl<'a> Parser<'a> {\n                 keywords::Invalid.ident() // no special identifier\n             };\n             // eat a matched-delimiter token tree:\n-            let delim = self.expect_open_delim()?;\n-            let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n-                                            SeqSep::none(),\n-                                            |p| p.parse_token_tree())?;\n+            let (delim, tts) = self.expect_delimited_token_tree()?;\n             if delim != token::Brace {\n                 if !self.eat(&token::Semi) {\n                     let prev_span = self.prev_span;"}]}