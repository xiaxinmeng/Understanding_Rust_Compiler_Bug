{"sha": "a5e8dfd0247648d8108386f4f98b3af0e48181f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ZThkZmQwMjQ3NjQ4ZDgxMDgzODZmNGY5OGIzYWYwZTQ4MTgxZjc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-03T17:33:12Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-03T19:11:05Z"}, "message": "Add parens for enums", "tree": {"sha": "d745850501442345ffee88fa9fa8f32fa155a088", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d745850501442345ffee88fa9fa8f32fa155a088"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5e8dfd0247648d8108386f4f98b3af0e48181f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5e8dfd0247648d8108386f4f98b3af0e48181f7", "html_url": "https://github.com/rust-lang/rust/commit/a5e8dfd0247648d8108386f4f98b3af0e48181f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5e8dfd0247648d8108386f4f98b3af0e48181f7/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1cf95f691cf919b3933d659e3f394f0e7f292cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1cf95f691cf919b3933d659e3f394f0e7f292cd", "html_url": "https://github.com/rust-lang/rust/commit/b1cf95f691cf919b3933d659e3f394f0e7f292cd"}], "stats": {"total": 221, "additions": 175, "deletions": 46}, "files": [{"sha": "f433faef36a8ba4a663ee9a96efe0864b10c04bb", "filename": "crates/ra_ide/src/completion/complete_dot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5e8dfd0247648d8108386f4f98b3af0e48181f7/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e8dfd0247648d8108386f4f98b3af0e48181f7/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=a5e8dfd0247648d8108386f4f98b3af0e48181f7", "patch": "@@ -61,7 +61,7 @@ fn complete_methods(acc: &mut Completions, ctx: &CompletionContext, receiver: &T\n                 && ctx.scope().module().map_or(true, |m| func.is_visible_from(ctx.db, m))\n                 && seen_methods.insert(func.name(ctx.db))\n             {\n-                acc.add_function(ctx, func);\n+                acc.add_function(ctx, func, None);\n             }\n             None::<()>\n         });"}, {"sha": "3ed2ae2b632be5ed8d3873ae9c417dc4fc9cb15f", "filename": "crates/ra_ide/src/completion/complete_path.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a5e8dfd0247648d8108386f4f98b3af0e48181f7/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e8dfd0247648d8108386f4f98b3af0e48181f7/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=a5e8dfd0247648d8108386f4f98b3af0e48181f7", "patch": "@@ -38,7 +38,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n         hir::ModuleDef::Adt(_) | hir::ModuleDef::TypeAlias(_) => {\n             if let hir::ModuleDef::Adt(Adt::Enum(e)) = def {\n                 for variant in e.variants(ctx.db) {\n-                    acc.add_enum_variant(ctx, variant);\n+                    acc.add_enum_variant(ctx, variant, None);\n                 }\n             }\n             let ty = match def {\n@@ -58,7 +58,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n                     match item {\n                         hir::AssocItem::Function(func) => {\n                             if !func.has_self_param(ctx.db) {\n-                                acc.add_function(ctx, func);\n+                                acc.add_function(ctx, func, None);\n                             }\n                         }\n                         hir::AssocItem::Const(ct) => acc.add_const(ctx, ct),\n@@ -87,7 +87,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n                 match item {\n                     hir::AssocItem::Function(func) => {\n                         if !func.has_self_param(ctx.db) {\n-                            acc.add_function(ctx, func);\n+                            acc.add_function(ctx, func, None);\n                         }\n                     }\n                     hir::AssocItem::Const(ct) => acc.add_const(ctx, ct),\n@@ -355,15 +355,17 @@ mod tests {\n             @r###\"\n         [\n             CompletionItem {\n-                label: \"Bar\",\n+                label: \"Bar(\u2026)\",\n                 source_range: [116; 116),\n                 delete: [116; 116),\n-                insert: \"Bar\",\n+                insert: \"Bar($0)\",\n                 kind: EnumVariant,\n+                lookup: \"Bar\",\n                 detail: \"(i32)\",\n                 documentation: Documentation(\n                     \"Bar Variant with i32\",\n                 ),\n+                trigger_call_info: true,\n             },\n             CompletionItem {\n                 label: \"Foo\",\n@@ -403,15 +405,17 @@ mod tests {\n             @r###\"\n         [\n             CompletionItem {\n-                label: \"Bar\",\n+                label: \"Bar(\u2026)\",\n                 source_range: [180; 180),\n                 delete: [180; 180),\n-                insert: \"Bar\",\n+                insert: \"Bar($0)\",\n                 kind: EnumVariant,\n+                lookup: \"Bar\",\n                 detail: \"(i32, u32)\",\n                 documentation: Documentation(\n                     \"Bar Variant with i32 and u32\",\n                 ),\n+                trigger_call_info: true,\n             },\n             CompletionItem {\n                 label: \"Foo\",\n@@ -425,15 +429,17 @@ mod tests {\n                 ),\n             },\n             CompletionItem {\n-                label: \"S\",\n+                label: \"S(\u2026)\",\n                 source_range: [180; 180),\n                 delete: [180; 180),\n-                insert: \"S\",\n+                insert: \"S($0)\",\n                 kind: EnumVariant,\n+                lookup: \"S\",\n                 detail: \"(S)\",\n                 documentation: Documentation(\n                     \"\",\n                 ),\n+                trigger_call_info: true,\n             },\n         ]\n         \"###"}, {"sha": "1b7d3122f8e718166f5d009793c9ee1aa7a9bdef", "filename": "crates/ra_ide/src/completion/complete_pattern.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5e8dfd0247648d8108386f4f98b3af0e48181f7/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e8dfd0247648d8108386f4f98b3af0e48181f7/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs?ref=a5e8dfd0247648d8108386f4f98b3af0e48181f7", "patch": "@@ -77,6 +77,7 @@ mod tests {\n                 delete: [246; 246),\n                 insert: \"X\",\n                 kind: EnumVariant,\n+                detail: \"()\",\n             },\n             CompletionItem {\n                 label: \"Z\","}, {"sha": "cdfd7bc3243764dda5a17f4c1bad7a533823bb9c", "filename": "crates/ra_ide/src/completion/presentation.rs", "status": "modified", "additions": 158, "deletions": 36, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/a5e8dfd0247648d8108386f4f98b3af0e48181f7/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e8dfd0247648d8108386f4f98b3af0e48181f7/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=a5e8dfd0247648d8108386f4f98b3af0e48181f7", "patch": "@@ -57,14 +57,16 @@ impl Completions {\n         let kind = match resolution {\n             ScopeDef::ModuleDef(Module(..)) => CompletionItemKind::Module,\n             ScopeDef::ModuleDef(Function(func)) => {\n-                return self.add_function_with_name(ctx, Some(local_name), *func);\n+                return self.add_function(ctx, *func, Some(local_name));\n             }\n             ScopeDef::ModuleDef(Adt(hir::Adt::Struct(_))) => CompletionItemKind::Struct,\n             // FIXME: add CompletionItemKind::Union\n             ScopeDef::ModuleDef(Adt(hir::Adt::Union(_))) => CompletionItemKind::Struct,\n             ScopeDef::ModuleDef(Adt(hir::Adt::Enum(_))) => CompletionItemKind::Enum,\n \n-            ScopeDef::ModuleDef(EnumVariant(..)) => CompletionItemKind::EnumVariant,\n+            ScopeDef::ModuleDef(EnumVariant(var)) => {\n+                return self.add_enum_variant(ctx, *var, Some(local_name));\n+            }\n             ScopeDef::ModuleDef(Const(..)) => CompletionItemKind::Const,\n             ScopeDef::ModuleDef(Static(..)) => CompletionItemKind::Static,\n             ScopeDef::ModuleDef(Trait(..)) => CompletionItemKind::Trait,\n@@ -125,10 +127,6 @@ impl Completions {\n         completion_item.kind(kind).set_documentation(docs).add_to(self)\n     }\n \n-    pub(crate) fn add_function(&mut self, ctx: &CompletionContext, func: hir::Function) {\n-        self.add_function_with_name(ctx, None, func)\n-    }\n-\n     fn guess_macro_braces(&self, macro_name: &str, docs: &str) -> &'static str {\n         let mut votes = [0, 0, 0];\n         for (idx, s) in docs.match_indices(&macro_name) {\n@@ -187,15 +185,15 @@ impl Completions {\n         self.add(builder);\n     }\n \n-    fn add_function_with_name(\n+    pub(crate) fn add_function(\n         &mut self,\n         ctx: &CompletionContext,\n-        name: Option<String>,\n         func: hir::Function,\n+        local_name: Option<String>,\n     ) {\n         let has_self_param = func.has_self_param(ctx.db);\n \n-        let name = name.unwrap_or_else(|| func.name(ctx.db).to_string());\n+        let name = local_name.unwrap_or_else(|| func.name(ctx.db).to_string());\n         let ast_node = func.source(ctx.db).value;\n         let function_signature = FunctionSignature::from(&ast_node);\n \n@@ -217,7 +215,7 @@ impl Completions {\n             .cloned()\n             .collect();\n \n-        builder = builder.add_call_parens(ctx, name, params);\n+        builder = builder.add_call_parens(ctx, name, Params::Named(params));\n \n         self.add(builder)\n     }\n@@ -254,14 +252,20 @@ impl Completions {\n             .add_to(self);\n     }\n \n-    pub(crate) fn add_enum_variant(&mut self, ctx: &CompletionContext, variant: hir::EnumVariant) {\n+    pub(crate) fn add_enum_variant(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        variant: hir::EnumVariant,\n+        local_name: Option<String>,\n+    ) {\n         let is_deprecated = is_deprecated(variant, ctx.db);\n-        let name = variant.name(ctx.db);\n+        let name = local_name.unwrap_or_else(|| variant.name(ctx.db).to_string());\n         let detail_types = variant\n             .fields(ctx.db)\n             .into_iter()\n             .map(|field| (field.name(ctx.db), field.signature_ty(ctx.db)));\n-        let detail = match variant.kind(ctx.db) {\n+        let variant_kind = variant.kind(ctx.db);\n+        let detail = match variant_kind {\n             StructKind::Tuple | StructKind::Unit => detail_types\n                 .map(|(_, t)| t.display(ctx.db).to_string())\n                 .sep_by(\", \")\n@@ -273,22 +277,42 @@ impl Completions {\n                 .surround_with(\"{ \", \" }\")\n                 .to_string(),\n         };\n-        CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.to_string())\n-            .kind(CompletionItemKind::EnumVariant)\n-            .set_documentation(variant.docs(ctx.db))\n-            .set_deprecated(is_deprecated)\n-            .detail(detail)\n-            .add_to(self);\n+        let mut res =\n+            CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.clone())\n+                .kind(CompletionItemKind::EnumVariant)\n+                .set_documentation(variant.docs(ctx.db))\n+                .set_deprecated(is_deprecated)\n+                .detail(detail);\n+\n+        if variant_kind == StructKind::Tuple {\n+            let params = Params::Anonymous(variant.fields(ctx.db).len());\n+            res = res.add_call_parens(ctx, name, params)\n+        }\n+\n+        res.add_to(self);\n+    }\n+}\n+\n+enum Params {\n+    Named(Vec<String>),\n+    Anonymous(usize),\n+}\n+\n+impl Params {\n+    fn len(&self) -> usize {\n+        match self {\n+            Params::Named(xs) => xs.len(),\n+            Params::Anonymous(len) => *len,\n+        }\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.len() == 0\n     }\n }\n \n impl Builder {\n-    fn add_call_parens(\n-        mut self,\n-        ctx: &CompletionContext,\n-        name: String,\n-        params: Vec<String>,\n-    ) -> Builder {\n+    fn add_call_parens(mut self, ctx: &CompletionContext, name: String, params: Params) -> Builder {\n         if !ctx.config.add_call_parenthesis {\n             return self;\n         }\n@@ -302,15 +326,16 @@ impl Builder {\n             (format!(\"{}()$0\", name), format!(\"{}()\", name))\n         } else {\n             self = self.trigger_call_info();\n-            let snippet = if ctx.config.add_call_argument_snippets {\n-                let function_params_snippet = params\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(index, param_name)| format!(\"${{{}:{}}}\", index + 1, param_name))\n-                    .sep_by(\", \");\n-                format!(\"{}({})$0\", name, function_params_snippet)\n-            } else {\n-                format!(\"{}($0)\", name)\n+            let snippet = match (ctx.config.add_call_argument_snippets, params) {\n+                (true, Params::Named(params)) => {\n+                    let function_params_snippet = params\n+                        .iter()\n+                        .enumerate()\n+                        .map(|(index, param_name)| format!(\"${{{}:{}}}\", index + 1, param_name))\n+                        .sep_by(\", \");\n+                    format!(\"{}({})$0\", name, function_params_snippet)\n+                }\n+                _ => format!(\"{}($0)\", name),\n             };\n \n             (snippet, format!(\"{}(\u2026)\", name))\n@@ -385,12 +410,14 @@ mod tests {\n         @r###\"\n         [\n             CompletionItem {\n-                label: \"Foo\",\n+                label: \"Foo(\u2026)\",\n                 source_range: [115; 117),\n                 delete: [115; 117),\n-                insert: \"Foo\",\n+                insert: \"Foo($0)\",\n                 kind: EnumVariant,\n+                lookup: \"Foo\",\n                 detail: \"(i32, i32)\",\n+                trigger_call_info: true,\n             },\n         ]\"###\n         );\n@@ -564,6 +591,101 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn inserts_parens_for_tuple_enums() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r\"\n+                enum Option<T> { Some(T), None }\n+                use Option::*;\n+                fn main() -> Option<i32> {\n+                    Som<|>\n+                }\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"None\",\n+                source_range: [144; 147),\n+                delete: [144; 147),\n+                insert: \"None\",\n+                kind: EnumVariant,\n+                detail: \"()\",\n+            },\n+            CompletionItem {\n+                label: \"Option\",\n+                source_range: [144; 147),\n+                delete: [144; 147),\n+                insert: \"Option\",\n+                kind: Enum,\n+            },\n+            CompletionItem {\n+                label: \"Some(\u2026)\",\n+                source_range: [144; 147),\n+                delete: [144; 147),\n+                insert: \"Some($0)\",\n+                kind: EnumVariant,\n+                lookup: \"Some\",\n+                detail: \"(T)\",\n+                trigger_call_info: true,\n+            },\n+            CompletionItem {\n+                label: \"main()\",\n+                source_range: [144; 147),\n+                delete: [144; 147),\n+                insert: \"main()$0\",\n+                kind: Function,\n+                lookup: \"main\",\n+                detail: \"fn main() -> Option<i32>\",\n+            },\n+        ]\n+        \"###\n+        );\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r\"\n+                enum Option<T> { Some(T), None }\n+                use Option::*;\n+                fn main(value: Option<i32>) {\n+                    match value {\n+                        Som<|>\n+                    }\n+                }\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"None\",\n+                source_range: [185; 188),\n+                delete: [185; 188),\n+                insert: \"None\",\n+                kind: EnumVariant,\n+                detail: \"()\",\n+            },\n+            CompletionItem {\n+                label: \"Option\",\n+                source_range: [185; 188),\n+                delete: [185; 188),\n+                insert: \"Option\",\n+                kind: Enum,\n+            },\n+            CompletionItem {\n+                label: \"Some(\u2026)\",\n+                source_range: [185; 188),\n+                delete: [185; 188),\n+                insert: \"Some($0)\",\n+                kind: EnumVariant,\n+                lookup: \"Some\",\n+                detail: \"(T)\",\n+                trigger_call_info: true,\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn arg_snippets_for_method_call() {\n         assert_debug_snapshot!("}]}