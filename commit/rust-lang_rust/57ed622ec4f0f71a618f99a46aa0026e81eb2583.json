{"sha": "57ed622ec4f0f71a618f99a46aa0026e81eb2583", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3ZWQ2MjJlYzRmMGY3MWE2MThmOTlhNDZhYTAwMjZlODFlYjI1ODM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-02T09:12:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-02T09:12:46Z"}, "message": "Merge #5089 #5161 #5184 #5185 #5186\n\n5089: Disable auto-complete on comments r=matklad a=BGluth\n\nResolves #4907 by disabling any auto-completion on comments.\r\n\r\nAs flodiebold [pointed out](https://github.com/rust-analyzer/rust-analyzer/issues/4907#issuecomment-648439979), in the future we may want to support some form of auto-completion within doc comments, but for now it was suggested to just disable auto-completion on them entirely.\r\n\r\nThe implementation involves adding a new field `is_comment` to `CompletionContext` and checking if the immediate token we auto-completed on is a comment. I couldn't see a case where we need to check any of the ancestors, but let me know if this is not sufficient. I also wasn't sure if it was necessary to add a new field to this struct, but I decided it's probably the best option if we want to potentially do auto-completion on doc comments in the future.\r\n\r\nFinally, the three tests I added should I think ideally not filter results by `CompletionKind::Keyword`, but if I want to get unfiltered results, I need access to a non-public function [get_all_completion_items](https://github.com/rust-analyzer/rust-analyzer/blob/9a4d02faf9c47f401b8756c3f7fcab2198f5f9cd/crates/ra_ide/src/completion/test_utils.rs#L32-L39) which I don't know if I should make public just for this.\r\n\r\n\n\n5161: SSR: Add initial support for placeholder constraints r=matklad a=davidlattimore\n\n\n\n5184: Always install required nightly extension if current one is not nightly r=matklad a=Veetaha\n\nThis is weird, but having switched back to stable by uninstalling the extension appears that vscode doesn't destroy the `PersistentState` and thus changing to `nightly` channel doesn't work because the last check for nightly extension was less than 1 hour ago. The simple solution is to skip this check if we know that the current extension version is not nightly.\n\n5185: Force showing extension activation error pop-up notification r=matklad a=Veetaha\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/5091\n\n5186: fix: correct pd/ppd/tfn/tmod completion doc r=matklad a=fannheyward\n\nhttps://github.com/rust-analyzer/rust-analyzer/blob/a33eefa3b26000b3018e6bb873f18dbe15ab4ab7/crates/ra_ide/src/completion/complete_snippet.rs#L23-L24\n\nCo-authored-by: BGluth <gluthb@gmail.com>\nCo-authored-by: David Lattimore <dml@google.com>\nCo-authored-by: Veetaha <veetaha2@gmail.com>\nCo-authored-by: Heyward Fann <fannheyward@gmail.com>", "tree": {"sha": "85d2e22a7e6eeaf34f2d61e4d61721f8771d3af9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85d2e22a7e6eeaf34f2d61e4d61721f8771d3af9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57ed622ec4f0f71a618f99a46aa0026e81eb2583", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe/aUOCRBK7hj4Ov3rIwAAdHIIAABR3gYT/az3lJ1/LbQDxxvu\nlSB7uJPWEC0CgmOj05h89As0d/nOx7FAIirXhQUPbRVQSGzvyo3JCsDHlwrh58m4\nJI6D/uS+PCtC78EMdJjQQWiHDyggeRSr3SbXIKm+LE23m+GwUR3cruTEgvANhD34\n0CrtmfUUlJyh5QrcbVAx8iK04053CcUgxF54V+8yEjLoMriKcNM56rjipGJtWZwg\nrvfDnyhZQ8tcMibhhelLC9xR9YFJmELznVJvqL3jd1/xNL7QMAi3Ph4Cca8MAsS7\nzIKaJ+FKXpD6zSKaGeQ0JRUo1Sdbfbmx5p8sSlyYTOhwAtpygCWtcLSsJou8Bq8=\n=r/I+\n-----END PGP SIGNATURE-----\n", "payload": "tree 85d2e22a7e6eeaf34f2d61e4d61721f8771d3af9\nparent e5f8fb3e91fdc1e372ef31556d88296a054117d9\nparent cc77bdf59ad99d3522663ebdb80be553f2767290\nparent 83588a1c452dff3ca6cd9e84cbe70a3b549fc851\nparent 69b6f6def525d33a60a3a992960d1085403d3b60\nparent 6a6ce616aa8da460a145a8d535357adef9f51678\nparent f1986be8fdcdc01c580b2d6e43574ae980d38e4b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593681166 +0000\ncommitter GitHub <noreply@github.com> 1593681166 +0000\n\nMerge #5089 #5161 #5184 #5185 #5186\n\n5089: Disable auto-complete on comments r=matklad a=BGluth\n\nResolves #4907 by disabling any auto-completion on comments.\r\n\r\nAs flodiebold [pointed out](https://github.com/rust-analyzer/rust-analyzer/issues/4907#issuecomment-648439979), in the future we may want to support some form of auto-completion within doc comments, but for now it was suggested to just disable auto-completion on them entirely.\r\n\r\nThe implementation involves adding a new field `is_comment` to `CompletionContext` and checking if the immediate token we auto-completed on is a comment. I couldn't see a case where we need to check any of the ancestors, but let me know if this is not sufficient. I also wasn't sure if it was necessary to add a new field to this struct, but I decided it's probably the best option if we want to potentially do auto-completion on doc comments in the future.\r\n\r\nFinally, the three tests I added should I think ideally not filter results by `CompletionKind::Keyword`, but if I want to get unfiltered results, I need access to a non-public function [get_all_completion_items](https://github.com/rust-analyzer/rust-analyzer/blob/9a4d02faf9c47f401b8756c3f7fcab2198f5f9cd/crates/ra_ide/src/completion/test_utils.rs#L32-L39) which I don't know if I should make public just for this.\r\n\r\n\n\n5161: SSR: Add initial support for placeholder constraints r=matklad a=davidlattimore\n\n\n\n5184: Always install required nightly extension if current one is not nightly r=matklad a=Veetaha\n\nThis is weird, but having switched back to stable by uninstalling the extension appears that vscode doesn't destroy the `PersistentState` and thus changing to `nightly` channel doesn't work because the last check for nightly extension was less than 1 hour ago. The simple solution is to skip this check if we know that the current extension version is not nightly.\n\n5185: Force showing extension activation error pop-up notification r=matklad a=Veetaha\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/5091\n\n5186: fix: correct pd/ppd/tfn/tmod completion doc r=matklad a=fannheyward\n\nhttps://github.com/rust-analyzer/rust-analyzer/blob/a33eefa3b26000b3018e6bb873f18dbe15ab4ab7/crates/ra_ide/src/completion/complete_snippet.rs#L23-L24\n\nCo-authored-by: BGluth <gluthb@gmail.com>\nCo-authored-by: David Lattimore <dml@google.com>\nCo-authored-by: Veetaha <veetaha2@gmail.com>\nCo-authored-by: Heyward Fann <fannheyward@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57ed622ec4f0f71a618f99a46aa0026e81eb2583", "html_url": "https://github.com/rust-lang/rust/commit/57ed622ec4f0f71a618f99a46aa0026e81eb2583", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57ed622ec4f0f71a618f99a46aa0026e81eb2583/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5f8fb3e91fdc1e372ef31556d88296a054117d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5f8fb3e91fdc1e372ef31556d88296a054117d9", "html_url": "https://github.com/rust-lang/rust/commit/e5f8fb3e91fdc1e372ef31556d88296a054117d9"}, {"sha": "cc77bdf59ad99d3522663ebdb80be553f2767290", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc77bdf59ad99d3522663ebdb80be553f2767290", "html_url": "https://github.com/rust-lang/rust/commit/cc77bdf59ad99d3522663ebdb80be553f2767290"}, {"sha": "83588a1c452dff3ca6cd9e84cbe70a3b549fc851", "url": "https://api.github.com/repos/rust-lang/rust/commits/83588a1c452dff3ca6cd9e84cbe70a3b549fc851", "html_url": "https://github.com/rust-lang/rust/commit/83588a1c452dff3ca6cd9e84cbe70a3b549fc851"}, {"sha": "69b6f6def525d33a60a3a992960d1085403d3b60", "url": "https://api.github.com/repos/rust-lang/rust/commits/69b6f6def525d33a60a3a992960d1085403d3b60", "html_url": "https://github.com/rust-lang/rust/commit/69b6f6def525d33a60a3a992960d1085403d3b60"}, {"sha": "6a6ce616aa8da460a145a8d535357adef9f51678", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a6ce616aa8da460a145a8d535357adef9f51678", "html_url": "https://github.com/rust-lang/rust/commit/6a6ce616aa8da460a145a8d535357adef9f51678"}, {"sha": "f1986be8fdcdc01c580b2d6e43574ae980d38e4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1986be8fdcdc01c580b2d6e43574ae980d38e4b", "html_url": "https://github.com/rust-lang/rust/commit/f1986be8fdcdc01c580b2d6e43574ae980d38e4b"}], "stats": {"total": 268, "additions": 242, "deletions": 26}, "files": [{"sha": "61ae8157a7fafe827e96d227cc0812d9a929f30d", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57ed622ec4f0f71a618f99a46aa0026e81eb2583/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/57ed622ec4f0f71a618f99a46aa0026e81eb2583/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=57ed622ec4f0f71a618f99a46aa0026e81eb2583", "patch": "@@ -1248,6 +1248,7 @@ dependencies = [\n  \"ra_syntax\",\n  \"ra_text_edit\",\n  \"rustc-hash\",\n+ \"test_utils\",\n ]\n \n [[package]]"}, {"sha": "9ebb8ebb7cfe997e02a59ac659f595ca076553d9", "filename": "crates/ra_ide/src/completion.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/57ed622ec4f0f71a618f99a46aa0026e81eb2583/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57ed622ec4f0f71a618f99a46aa0026e81eb2583/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion.rs?ref=57ed622ec4f0f71a618f99a46aa0026e81eb2583", "patch": "@@ -63,19 +63,19 @@ pub use crate::completion::{\n // There also snippet completions:\n //\n // .Expressions\n-// - `pd` -> `println!(\"{:?}\")`\n-// - `ppd` -> `println!(\"{:#?}\")`\n+// - `pd` -> `eprintln!(\" = {:?}\", );\")`\n+// - `ppd` -> `eprintln!(\" = {:#?}\", );`\n //\n // .Items\n-// - `tfn` -> `#[test] fn f(){}`\n+// - `tfn` -> `#[test] fn feature(){}`\n // - `tmod` ->\n // ```rust\n // #[cfg(test)]\n // mod tests {\n //     use super::*;\n //\n //     #[test]\n-//     fn test_fn() {}\n+//     fn test_name() {}\n // }\n // ```\n "}, {"sha": "e599cc3d1662a00e111d1921d3c09db2c2a3c6cf", "filename": "crates/ra_ide/src/completion/complete_keyword.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/57ed622ec4f0f71a618f99a46aa0026e81eb2583/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57ed622ec4f0f71a618f99a46aa0026e81eb2583/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs?ref=57ed622ec4f0f71a618f99a46aa0026e81eb2583", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use ra_syntax::ast;\n+use ra_syntax::{ast, SyntaxKind};\n \n use crate::completion::{\n     CompletionContext, CompletionItem, CompletionItemKind, CompletionKind, Completions,\n@@ -37,6 +37,10 @@ pub(super) fn complete_use_tree_keyword(acc: &mut Completions, ctx: &CompletionC\n }\n \n pub(super) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionContext) {\n+    if ctx.token.kind() == SyntaxKind::COMMENT {\n+        return;\n+    }\n+\n     let has_trait_or_impl_parent = ctx.has_impl_parent || ctx.has_trait_parent;\n     if ctx.trait_as_prev_sibling || ctx.impl_as_prev_sibling {\n         add_keyword(ctx, acc, \"where\", \"where \");"}, {"sha": "b18279746e7a6b02bfdd53fd1239270e58cbb66b", "filename": "crates/ra_ide/src/completion/presentation.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/57ed622ec4f0f71a618f99a46aa0026e81eb2583/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57ed622ec4f0f71a618f99a46aa0026e81eb2583/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=57ed622ec4f0f71a618f99a46aa0026e81eb2583", "patch": "@@ -1516,4 +1516,54 @@ mod tests {\n         \"###\n         );\n     }\n+\n+    #[test]\n+    fn no_keyword_autocompletion_on_line_comments() {\n+        assert_debug_snapshot!(\n+        do_completion(\n+                r\"\n+                    fn test() {\n+                        let x = 2; // A comment<|>\n+                    }\n+                    \",\n+                CompletionKind::Keyword\n+        ),\n+            @r###\"\n+            []\n+            \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn no_keyword_autocompletion_on_multi_line_comments() {\n+        assert_debug_snapshot!(\n+        do_completion(\n+                r\"\n+                    /*\n+                    Some multi-line comment<|>\n+                    */\n+                    \",\n+                CompletionKind::Keyword\n+        ),\n+            @r###\"\n+            []\n+            \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn no_keyword_autocompletion_on_doc_comments() {\n+        assert_debug_snapshot!(\n+        do_completion(\n+                r\"\n+                    /// Some doc comment\n+                    /// let test<|> = 1\n+                    \",\n+                CompletionKind::Keyword\n+        ),\n+            @r###\"\n+            []\n+            \"###\n+        );\n+    }\n }"}, {"sha": "b3e9e5dfe111385693a0ab759318824d20d9d8b2", "filename": "crates/ra_ide/src/ssr.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/57ed622ec4f0f71a618f99a46aa0026e81eb2583/crates%2Fra_ide%2Fsrc%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57ed622ec4f0f71a618f99a46aa0026e81eb2583/crates%2Fra_ide%2Fsrc%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fssr.rs?ref=57ed622ec4f0f71a618f99a46aa0026e81eb2583", "patch": "@@ -10,6 +10,18 @@ use ra_ssr::{MatchFinder, SsrError, SsrRule};\n // The syntax for a structural search replace command is `<search_pattern> ==>> <replace_pattern>`.\n // A `$<name>` placeholder in the search pattern will match any AST node and `$<name>` will reference it in the replacement.\n // Within a macro call, a placeholder will match up until whatever token follows the placeholder.\n+//\n+// Placeholders may be given constraints by writing them as `${<name>:<constraint1>:<constraint2>...}`.\n+//\n+// Supported constraints:\n+//\n+// |===\n+// | Constraint    | Restricts placeholder\n+//\n+// | kind(literal) | Is a literal (e.g. `42` or `\"forty two\"`)\n+// | not(a)        | Negates the constraint `a`\n+// |===\n+//\n // Available via the command `rust-analyzer.ssr`.\n //\n // ```rust"}, {"sha": "fe098aaee30099e3390444bc52fe56865b75441e", "filename": "crates/ra_ssr/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57ed622ec4f0f71a618f99a46aa0026e81eb2583/crates%2Fra_ssr%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/57ed622ec4f0f71a618f99a46aa0026e81eb2583/crates%2Fra_ssr%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2FCargo.toml?ref=57ed622ec4f0f71a618f99a46aa0026e81eb2583", "patch": "@@ -17,3 +17,4 @@ ra_db = { path = \"../ra_db\" }\n ra_ide_db = { path = \"../ra_ide_db\" }\n hir = { path = \"../ra_hir\", package = \"ra_hir\" }\n rustc-hash = \"1.1.0\"\n+test_utils = { path = \"../test_utils\" }"}, {"sha": "ce53d46d2963fd59d288cb56deec1f8a7730c768", "filename": "crates/ra_ssr/src/matching.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/57ed622ec4f0f71a618f99a46aa0026e81eb2583/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57ed622ec4f0f71a618f99a46aa0026e81eb2583/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fmatching.rs?ref=57ed622ec4f0f71a618f99a46aa0026e81eb2583", "patch": "@@ -2,7 +2,7 @@\n //! process of matching, placeholder values are recorded.\n \n use crate::{\n-    parsing::{Placeholder, SsrTemplate},\n+    parsing::{Constraint, NodeKind, Placeholder, SsrTemplate},\n     SsrMatches, SsrPattern, SsrRule,\n };\n use hir::Semantics;\n@@ -11,6 +11,7 @@ use ra_syntax::ast::{AstNode, AstToken};\n use ra_syntax::{ast, SyntaxElement, SyntaxElementChildren, SyntaxKind, SyntaxNode, SyntaxToken};\n use rustc_hash::FxHashMap;\n use std::{cell::Cell, iter::Peekable};\n+use test_utils::mark;\n \n // Creates a match error. If we're currently attempting to match some code that we thought we were\n // going to match, as indicated by the --debug-snippet flag, then populate the reason field.\n@@ -169,6 +170,9 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n         if let Some(placeholder) =\n             match_inputs.get_placeholder(&SyntaxElement::Node(pattern.clone()))\n         {\n+            for constraint in &placeholder.constraints {\n+                self.check_constraint(constraint, code)?;\n+            }\n             if self.match_out.is_none() {\n                 return Ok(());\n             }\n@@ -292,6 +296,24 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n         Ok(())\n     }\n \n+    fn check_constraint(\n+        &self,\n+        constraint: &Constraint,\n+        code: &SyntaxNode,\n+    ) -> Result<(), MatchFailed> {\n+        match constraint {\n+            Constraint::Kind(kind) => {\n+                kind.matches(code)?;\n+            }\n+            Constraint::Not(sub) => {\n+                if self.check_constraint(&*sub, code).is_ok() {\n+                    fail_match!(\"Constraint {:?} failed for '{}'\", constraint, code.text());\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     /// We want to allow the records to match in any order, so we have special matching logic for\n     /// them.\n     fn attempt_match_record_field_list(\n@@ -515,6 +537,21 @@ impl SsrPattern {\n     }\n }\n \n+impl NodeKind {\n+    fn matches(&self, node: &SyntaxNode) -> Result<(), MatchFailed> {\n+        let ok = match self {\n+            Self::Literal => {\n+                mark::hit!(literal_constraint);\n+                ast::Literal::can_cast(node.kind())\n+            }\n+        };\n+        if !ok {\n+            fail_match!(\"Code '{}' isn't of kind {:?}\", node.text(), self);\n+        }\n+        Ok(())\n+    }\n+}\n+\n // If `node` contains nothing but an ident then return it, otherwise return None.\n fn only_ident(element: SyntaxElement) -> Option<SyntaxToken> {\n     match element {"}, {"sha": "5ea1256165a8c538753a641fcd5e2d5055c0ec51", "filename": "crates/ra_ssr/src/parsing.rs", "status": "modified", "additions": 95, "deletions": 13, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/57ed622ec4f0f71a618f99a46aa0026e81eb2583/crates%2Fra_ssr%2Fsrc%2Fparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57ed622ec4f0f71a618f99a46aa0026e81eb2583/crates%2Fra_ssr%2Fsrc%2Fparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fparsing.rs?ref=57ed622ec4f0f71a618f99a46aa0026e81eb2583", "patch": "@@ -6,7 +6,7 @@\n //! e.g. expressions, type references etc.\n \n use crate::{SsrError, SsrPattern, SsrRule};\n-use ra_syntax::{ast, AstNode, SmolStr, SyntaxKind};\n+use ra_syntax::{ast, AstNode, SmolStr, SyntaxKind, T};\n use rustc_hash::{FxHashMap, FxHashSet};\n use std::str::FromStr;\n \n@@ -39,6 +39,18 @@ pub(crate) struct Placeholder {\n     pub(crate) ident: SmolStr,\n     /// A unique name used in place of this placeholder when we parse the pattern as Rust code.\n     stand_in_name: String,\n+    pub(crate) constraints: Vec<Constraint>,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(crate) enum Constraint {\n+    Kind(NodeKind),\n+    Not(Box<Constraint>),\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(crate) enum NodeKind {\n+    Literal,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -149,7 +161,7 @@ fn parse_pattern(pattern_str: &str) -> Result<Vec<PatternElement>, SsrError> {\n     let mut placeholder_names = FxHashSet::default();\n     let mut tokens = tokenize(pattern_str)?.into_iter();\n     while let Some(token) = tokens.next() {\n-        if token.kind == SyntaxKind::DOLLAR {\n+        if token.kind == T![$] {\n             let placeholder = parse_placeholder(&mut tokens)?;\n             if !placeholder_names.insert(placeholder.ident.clone()) {\n                 bail!(\"Name `{}` repeats more than once\", placeholder.ident);\n@@ -177,6 +189,9 @@ fn validate_rule(rule: &SsrRule) -> Result<(), SsrError> {\n             if !defined_placeholders.contains(&placeholder.ident) {\n                 undefined.push(format!(\"${}\", placeholder.ident));\n             }\n+            if !placeholder.constraints.is_empty() {\n+                bail!(\"Replacement placeholders cannot have constraints\");\n+            }\n         }\n     }\n     if !undefined.is_empty() {\n@@ -205,23 +220,90 @@ fn tokenize(source: &str) -> Result<Vec<Token>, SsrError> {\n \n fn parse_placeholder(tokens: &mut std::vec::IntoIter<Token>) -> Result<Placeholder, SsrError> {\n     let mut name = None;\n+    let mut constraints = Vec::new();\n     if let Some(token) = tokens.next() {\n         match token.kind {\n             SyntaxKind::IDENT => {\n                 name = Some(token.text);\n             }\n+            T!['{'] => {\n+                let token =\n+                    tokens.next().ok_or_else(|| SsrError::new(\"Unexpected end of placeholder\"))?;\n+                if token.kind == SyntaxKind::IDENT {\n+                    name = Some(token.text);\n+                }\n+                loop {\n+                    let token = tokens\n+                        .next()\n+                        .ok_or_else(|| SsrError::new(\"Placeholder is missing closing brace '}'\"))?;\n+                    match token.kind {\n+                        T![:] => {\n+                            constraints.push(parse_constraint(tokens)?);\n+                        }\n+                        T!['}'] => break,\n+                        _ => bail!(\"Unexpected token while parsing placeholder: '{}'\", token.text),\n+                    }\n+                }\n+            }\n             _ => {\n-                bail!(\"Placeholders should be $name\");\n+                bail!(\"Placeholders should either be $name or ${name:constraints}\");\n             }\n         }\n     }\n     let name = name.ok_or_else(|| SsrError::new(\"Placeholder ($) with no name\"))?;\n-    Ok(Placeholder::new(name))\n+    Ok(Placeholder::new(name, constraints))\n+}\n+\n+fn parse_constraint(tokens: &mut std::vec::IntoIter<Token>) -> Result<Constraint, SsrError> {\n+    let constraint_type = tokens\n+        .next()\n+        .ok_or_else(|| SsrError::new(\"Found end of placeholder while looking for a constraint\"))?\n+        .text\n+        .to_string();\n+    match constraint_type.as_str() {\n+        \"kind\" => {\n+            expect_token(tokens, \"(\")?;\n+            let t = tokens.next().ok_or_else(|| {\n+                SsrError::new(\"Unexpected end of constraint while looking for kind\")\n+            })?;\n+            if t.kind != SyntaxKind::IDENT {\n+                bail!(\"Expected ident, found {:?} while parsing kind constraint\", t.kind);\n+            }\n+            expect_token(tokens, \")\")?;\n+            Ok(Constraint::Kind(NodeKind::from(&t.text)?))\n+        }\n+        \"not\" => {\n+            expect_token(tokens, \"(\")?;\n+            let sub = parse_constraint(tokens)?;\n+            expect_token(tokens, \")\")?;\n+            Ok(Constraint::Not(Box::new(sub)))\n+        }\n+        x => bail!(\"Unsupported constraint type '{}'\", x),\n+    }\n+}\n+\n+fn expect_token(tokens: &mut std::vec::IntoIter<Token>, expected: &str) -> Result<(), SsrError> {\n+    if let Some(t) = tokens.next() {\n+        if t.text == expected {\n+            return Ok(());\n+        }\n+        bail!(\"Expected {} found {}\", expected, t.text);\n+    }\n+    bail!(\"Expected {} found end of stream\");\n+}\n+\n+impl NodeKind {\n+    fn from(name: &SmolStr) -> Result<NodeKind, SsrError> {\n+        Ok(match name.as_str() {\n+            \"literal\" => NodeKind::Literal,\n+            _ => bail!(\"Unknown node kind '{}'\", name),\n+        })\n+    }\n }\n \n impl Placeholder {\n-    fn new(name: SmolStr) -> Self {\n-        Self { stand_in_name: format!(\"__placeholder_{}\", name), ident: name }\n+    fn new(name: SmolStr, constraints: Vec<Constraint>) -> Self {\n+        Self { stand_in_name: format!(\"__placeholder_{}\", name), constraints, ident: name }\n     }\n }\n \n@@ -241,31 +323,31 @@ mod tests {\n             PatternElement::Token(Token { kind, text: SmolStr::new(text) })\n         }\n         fn placeholder(name: &str) -> PatternElement {\n-            PatternElement::Placeholder(Placeholder::new(SmolStr::new(name)))\n+            PatternElement::Placeholder(Placeholder::new(SmolStr::new(name), Vec::new()))\n         }\n         let result: SsrRule = \"foo($a, $b) ==>> bar($b, $a)\".parse().unwrap();\n         assert_eq!(\n             result.pattern.raw.tokens,\n             vec![\n                 token(SyntaxKind::IDENT, \"foo\"),\n-                token(SyntaxKind::L_PAREN, \"(\"),\n+                token(T!['('], \"(\"),\n                 placeholder(\"a\"),\n-                token(SyntaxKind::COMMA, \",\"),\n+                token(T![,], \",\"),\n                 token(SyntaxKind::WHITESPACE, \" \"),\n                 placeholder(\"b\"),\n-                token(SyntaxKind::R_PAREN, \")\"),\n+                token(T![')'], \")\"),\n             ]\n         );\n         assert_eq!(\n             result.template.tokens,\n             vec![\n                 token(SyntaxKind::IDENT, \"bar\"),\n-                token(SyntaxKind::L_PAREN, \"(\"),\n+                token(T!['('], \"(\"),\n                 placeholder(\"b\"),\n-                token(SyntaxKind::COMMA, \",\"),\n+                token(T![,], \",\"),\n                 token(SyntaxKind::WHITESPACE, \" \"),\n                 placeholder(\"a\"),\n-                token(SyntaxKind::R_PAREN, \")\"),\n+                token(T![')'], \")\"),\n             ]\n         );\n     }"}, {"sha": "9568d44322d6df2afbaa80aee9e5adabd3ba1ce3", "filename": "crates/ra_ssr/src/tests.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/57ed622ec4f0f71a618f99a46aa0026e81eb2583/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57ed622ec4f0f71a618f99a46aa0026e81eb2583/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ftests.rs?ref=57ed622ec4f0f71a618f99a46aa0026e81eb2583", "patch": "@@ -1,5 +1,6 @@\n use crate::{MatchFinder, SsrRule};\n use ra_db::{FileId, SourceDatabaseExt};\n+use test_utils::mark;\n \n fn parse_error_text(query: &str) -> String {\n     format!(\"{}\", query.parse::<SsrRule>().unwrap_err())\n@@ -301,6 +302,22 @@ fn match_pattern() {\n     assert_matches(\"Some($a)\", \"fn f() {if let Some(x) = foo() {}}\", &[\"Some(x)\"]);\n }\n \n+#[test]\n+fn literal_constraint() {\n+    mark::check!(literal_constraint);\n+    let code = r#\"\n+        fn f1() {\n+            let x1 = Some(42);\n+            let x2 = Some(\"foo\");\n+            let x3 = Some(x1);\n+            let x4 = Some(40 + 2);\n+            let x5 = Some(true);\n+        }\n+        \"#;\n+    assert_matches(\"Some(${a:kind(literal)})\", code, &[\"Some(42)\", \"Some(\\\"foo\\\")\", \"Some(true)\"]);\n+    assert_matches(\"Some(${a:not(kind(literal))})\", code, &[\"Some(x1)\", \"Some(40 + 2)\"]);\n+}\n+\n #[test]\n fn match_reordered_struct_instantiation() {\n     assert_matches("}, {"sha": "a1521a93be0a946f16b9a6cd5adffa3618db42df", "filename": "editors/code/src/main.ts", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/57ed622ec4f0f71a618f99a46aa0026e81eb2583/editors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/57ed622ec4f0f71a618f99a46aa0026e81eb2583/editors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fmain.ts?ref=57ed622ec4f0f71a618f99a46aa0026e81eb2583", "patch": "@@ -19,6 +19,16 @@ let ctx: Ctx | undefined;\n const RUST_PROJECT_CONTEXT_NAME = \"inRustProject\";\n \n export async function activate(context: vscode.ExtensionContext) {\n+    // For some reason vscode not always shows pop-up error notifications\n+    // when an extension fails to activate, so we do it explicitly by ourselves.\n+    // FIXME: remove this bit of code once vscode fixes this issue: https://github.com/microsoft/vscode/issues/101242\n+    await tryActivate(context).catch(err => {\n+        void vscode.window.showErrorMessage(`Cannot activate rust-analyzer: ${err.message}`);\n+        throw err;\n+    });\n+}\n+\n+async function tryActivate(context: vscode.ExtensionContext) {\n     // Register a \"dumb\" onEnter command for the case where server fails to\n     // start.\n     //\n@@ -58,9 +68,7 @@ export async function activate(context: vscode.ExtensionContext) {\n \n     const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n     if (workspaceFolder === undefined) {\n-        const err = \"Cannot activate rust-analyzer when no folder is opened\";\n-        void vscode.window.showErrorMessage(err);\n-        throw new Error(err);\n+        throw new Error(\"no folder is opened\");\n     }\n \n     // Note: we try to start the server before we activate type hints so that it\n@@ -152,13 +160,17 @@ async function bootstrapExtension(config: Config, state: PersistentState): Promi\n         return;\n     };\n \n-    const lastCheck = state.lastCheck;\n     const now = Date.now();\n+    if (config.package.releaseTag === NIGHTLY_TAG) {\n+        // Check if we should poll github api for the new nightly version\n+        // if we haven't done it during the past hour\n+        const lastCheck = state.lastCheck;\n \n-    const anHour = 60 * 60 * 1000;\n-    const shouldDownloadNightly = state.releaseId === undefined || (now - (lastCheck ?? 0)) > anHour;\n+        const anHour = 60 * 60 * 1000;\n+        const shouldCheckForNewNightly = state.releaseId === undefined || (now - (lastCheck ?? 0)) > anHour;\n \n-    if (!shouldDownloadNightly) return;\n+        if (!shouldCheckForNewNightly) return;\n+    }\n \n     const release = await fetchRelease(\"nightly\").catch((e) => {\n         log.error(e);"}]}