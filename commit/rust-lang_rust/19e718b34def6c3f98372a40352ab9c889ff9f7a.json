{"sha": "19e718b34def6c3f98372a40352ab9c889ff9f7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ZTcxOGIzNGRlZjZjM2Y5ODM3MmE0MDM1MmFiOWM4ODlmZjlmN2E=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-06T22:10:57Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-08T23:28:21Z"}, "message": "carry self ident forward through re-parsing\n\nformerly, the self identifier was being discarded during parsing, which\nstymies hygiene. The best fix here seems to be to attach a self identifier\nto ExplicitSelf_, a change that rippled through the rest of the compiler,\nbut without any obvious damage.", "tree": {"sha": "7fded5374fe2a5baa57fb3422ba8a4fccb0685ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fded5374fe2a5baa57fb3422ba8a4fccb0685ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19e718b34def6c3f98372a40352ab9c889ff9f7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19e718b34def6c3f98372a40352ab9c889ff9f7a", "html_url": "https://github.com/rust-lang/rust/commit/19e718b34def6c3f98372a40352ab9c889ff9f7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19e718b34def6c3f98372a40352ab9c889ff9f7a/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69c27546ee37ac2d0384748a21c7dad00642a223", "url": "https://api.github.com/repos/rust-lang/rust/commits/69c27546ee37ac2d0384748a21c7dad00642a223", "html_url": "https://github.com/rust-lang/rust/commit/69c27546ee37ac2d0384748a21c7dad00642a223"}], "stats": {"total": 194, "additions": 114, "deletions": 80}, "files": [{"sha": "8a2b95ae463b414f34c8e75774e00ac09562b2bc", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=19e718b34def6c3f98372a40352ab9c889ff9f7a", "patch": "@@ -739,10 +739,11 @@ fn get_explicit_self(item: ebml::Doc) -> ast::ExplicitSelf_ {\n     let explicit_self_kind = string.as_bytes()[0];\n     match explicit_self_kind as char {\n         's' => ast::SelfStatic,\n-        'v' => ast::SelfValue,\n-        '~' => ast::SelfUniq,\n+        'v' => ast::SelfValue(special_idents::self_),\n+        '~' => ast::SelfUniq(special_idents::self_),\n         // FIXME(#4846) expl. region\n-        '&' => ast::SelfRegion(None, get_mutability(string.as_bytes()[1])),\n+        '&' => ast::SelfRegion(None, get_mutability(string.as_bytes()[1]),\n+                               special_idents::self_),\n         _ => fail!(\"unknown self type code: `{}`\", explicit_self_kind as char)\n     }\n }"}, {"sha": "fbf0288418ab8f8e83865255fd3959fe88097f3f", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=19e718b34def6c3f98372a40352ab9c889ff9f7a", "patch": "@@ -628,10 +628,10 @@ fn encode_explicit_self(ebml_w: &mut Encoder, explicit_self: ast::ExplicitSelf_)\n \n     // Encode the base self type.\n     match explicit_self {\n-        SelfStatic => { ebml_w.writer.write(&[ 's' as u8 ]); }\n-        SelfValue  => { ebml_w.writer.write(&[ 'v' as u8 ]); }\n-        SelfUniq   => { ebml_w.writer.write(&[ '~' as u8 ]); }\n-        SelfRegion(_, m) => {\n+        SelfStatic   => { ebml_w.writer.write(&[ 's' as u8 ]); }\n+        SelfValue(_) => { ebml_w.writer.write(&[ 'v' as u8 ]); }\n+        SelfUniq(_)  => { ebml_w.writer.write(&[ '~' as u8 ]); }\n+        SelfRegion(_, m, _) => {\n             // FIXME(#4846) encode custom lifetime\n             ebml_w.writer.write(&['&' as u8]);\n             encode_mutability(ebml_w, m);"}, {"sha": "c79e435707aee724f203f140db71e1d7eac1c3d2", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=19e718b34def6c3f98372a40352ab9c889ff9f7a", "patch": "@@ -502,12 +502,15 @@ fn emit_vtable_methods(bcx: &Block,\n                                                        ExprId(0),\n                                                        substs.clone(),\n                                                        vtables.clone());\n-            if m.explicit_self == ast::SelfValue {\n-                fn_ref = trans_unboxing_shim(bcx,\n-                                             fn_ref,\n-                                             &*m,\n-                                             m_id,\n-                                             substs.clone());\n+            match m.explicit_self {\n+                ast::SelfValue(_) => {\n+                    fn_ref = trans_unboxing_shim(bcx,\n+                                                 fn_ref,\n+                                                 &*m,\n+                                                 m_id,\n+                                                 substs.clone());\n+                },\n+                _ => {}\n             }\n             fn_ref\n         }"}, {"sha": "90331d8f43430c2e3531b870e4724508c6df06d7", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=19e718b34def6c3f98372a40352ab9c889ff9f7a", "patch": "@@ -938,10 +938,10 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n     let self_ty = opt_self_info.and_then(|self_info| {\n         match self_info.explicit_self.node {\n             ast::SelfStatic => None,\n-            ast::SelfValue => {\n+            ast::SelfValue(_) => {\n                 Some(self_info.untransformed_self_ty)\n             }\n-            ast::SelfRegion(ref lifetime, mutability) => {\n+            ast::SelfRegion(ref lifetime, mutability, _) => {\n                 let region =\n                     opt_ast_region_to_region(this, &rb,\n                                              self_info.explicit_self.span,\n@@ -950,7 +950,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n                                  ty::mt {ty: self_info.untransformed_self_ty,\n                                          mutbl: mutability}))\n             }\n-            ast::SelfUniq => {\n+            ast::SelfUniq(_) => {\n                 Some(ty::mk_uniq(this.tcx(), self_info.untransformed_self_ty))\n             }\n         }"}, {"sha": "a184ecac9dea669196a66ce619dc40341f6a9586", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=19e718b34def6c3f98372a40352ab9c889ff9f7a", "patch": "@@ -270,12 +270,12 @@ fn construct_transformed_self_ty_for_object(\n         ast::SelfStatic => {\n             tcx.sess.span_bug(span, \"static method for object type receiver\");\n         }\n-        ast::SelfValue => {\n+        ast::SelfValue(_) => {\n             let tr = ty::mk_trait(tcx, trait_def_id, obj_substs,\n                                   ty::empty_builtin_bounds());\n             ty::mk_uniq(tcx, tr)\n         }\n-        ast::SelfRegion(..) | ast::SelfUniq => {\n+        ast::SelfRegion(..) | ast::SelfUniq(..) => {\n             let transformed_self_ty = *method_ty.fty.sig.inputs.get(0);\n             match ty::get(transformed_self_ty).sty {\n                 ty::ty_rptr(r, mt) => { // must be SelfRegion\n@@ -1227,7 +1227,7 @@ impl<'a> LookupContext<'a> {\n                      through an object\");\n             }\n \n-            ast::SelfValue | ast::SelfRegion(..) | ast::SelfUniq => {}\n+            ast::SelfValue(_) | ast::SelfRegion(..) | ast::SelfUniq(_) => {}\n         }\n \n         // reason (a) above\n@@ -1296,7 +1296,7 @@ impl<'a> LookupContext<'a> {\n                 self.report_statics == ReportStaticMethods\n             }\n \n-            SelfValue => {\n+            SelfValue(_) => {\n                 debug!(\"(is relevant?) explicit self is by-value\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_uniq(typ) => {\n@@ -1319,7 +1319,7 @@ impl<'a> LookupContext<'a> {\n                 }\n             }\n \n-            SelfRegion(_, m) => {\n+            SelfRegion(_, m, _) => {\n                 debug!(\"(is relevant?) explicit self is a region\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_rptr(_, mt) => {\n@@ -1339,7 +1339,7 @@ impl<'a> LookupContext<'a> {\n                 }\n             }\n \n-            SelfUniq => {\n+            SelfUniq(_) => {\n                 debug!(\"(is relevant?) explicit self is a unique pointer\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_uniq(typ) => {"}, {"sha": "b0c9900be909cc2bb8ee0d3b2d38e6737a5826f1", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=19e718b34def6c3f98372a40352ab9c889ff9f7a", "patch": "@@ -947,16 +947,16 @@ impl<'a> Rebuilder<'a> {\n                          -> Option<ast::ExplicitSelf_> {\n         match expl_self_opt {\n             Some(expl_self) => match expl_self {\n-                ast::SelfRegion(lt_opt, muta) => match lt_opt {\n+                ast::SelfRegion(lt_opt, muta, id) => match lt_opt {\n                     Some(lt) => if region_names.contains(&lt.name) {\n-                        return Some(ast::SelfRegion(Some(lifetime), muta));\n+                        return Some(ast::SelfRegion(Some(lifetime), muta, id));\n                     },\n                     None => {\n                         let anon = self.cur_anon.get();\n                         self.inc_and_offset_cur_anon(1);\n                         if anon_nums.contains(&anon) {\n                             self.track_anon(anon);\n-                            return Some(ast::SelfRegion(Some(lifetime), muta));\n+                            return Some(ast::SelfRegion(Some(lifetime), muta, id));\n                         }\n                     }\n                 },"}, {"sha": "af0b6a1cb21d104d496de178bd696f1db0c8920d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=19e718b34def6c3f98372a40352ab9c889ff9f7a", "patch": "@@ -775,9 +775,9 @@ impl Clean<SelfTy> for ast::ExplicitSelf_ {\n     fn clean(&self) -> SelfTy {\n         match *self {\n             ast::SelfStatic => SelfStatic,\n-            ast::SelfValue => SelfValue,\n-            ast::SelfUniq => SelfOwned,\n-            ast::SelfRegion(lt, mt) => SelfBorrowed(lt.clean(), mt.clean()),\n+            ast::SelfValue(_) => SelfValue,\n+            ast::SelfUniq(_) => SelfOwned,\n+            ast::SelfRegion(lt, mt, _) => SelfBorrowed(lt.clean(), mt.clean()),\n         }\n     }\n }"}, {"sha": "5f3adbdb54df498f054fffc5e34b0c1f0fe328ee", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=19e718b34def6c3f98372a40352ab9c889ff9f7a", "patch": "@@ -14,7 +14,7 @@ use codemap::{Span, Spanned, DUMMY_SP};\n use abi::Abi;\n use ast_util;\n use owned_slice::OwnedSlice;\n-use parse::token::{InternedString, special_idents, str_to_ident};\n+use parse::token::{InternedString, str_to_ident};\n use parse::token;\n \n use std::fmt;\n@@ -824,8 +824,8 @@ pub struct Arg {\n }\n \n impl Arg {\n-    pub fn new_self(span: Span, mutability: Mutability) -> Arg {\n-        let path = Spanned{span:span,node:special_idents::self_};\n+    pub fn new_self(span: Span, mutability: Mutability, self_ident: Ident) -> Arg {\n+        let path = Spanned{span:span,node:self_ident};\n         Arg {\n             // HACK(eddyb) fake type for the self argument.\n             ty: P(Ty {\n@@ -874,12 +874,13 @@ pub enum RetStyle {\n     Return, // everything else\n }\n \n+/// Represents the kind of 'self' associated with a method\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum ExplicitSelf_ {\n-    SelfStatic,                                // no self\n-    SelfValue,                                 // `self`\n-    SelfRegion(Option<Lifetime>, Mutability),  // `&'lt self`, `&'lt mut self`\n-    SelfUniq                                   // `~self`\n+    SelfStatic,                                       // no self\n+    SelfValue(Ident),                                 // `self`\n+    SelfRegion(Option<Lifetime>, Mutability, Ident),  // `&'lt self`, `&'lt mut self`\n+    SelfUniq(Ident),                                  // `~self`\n }\n \n pub type ExplicitSelf = Spanned<ExplicitSelf_>;"}, {"sha": "764c88cc954ede2a1e6849706de44b306db9cb65", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=19e718b34def6c3f98372a40352ab9c889ff9f7a", "patch": "@@ -191,6 +191,7 @@ use codemap;\n use codemap::Span;\n use owned_slice::OwnedSlice;\n use parse::token::InternedString;\n+use parse::token::special_idents;\n \n use self::ty::*;\n \n@@ -617,7 +618,8 @@ impl<'a> MethodDef<'a> {\n \n         let self_arg = match explicit_self.node {\n             ast::SelfStatic => None,\n-            _ => Some(ast::Arg::new_self(trait_.span, ast::MutImmutable))\n+            // creating fresh self id\n+            _ => Some(ast::Arg::new_self(trait_.span, ast::MutImmutable, special_idents::self_))\n         };\n         let args = {\n             let args = arg_types.move_iter().map(|(name, ty)| {"}, {"sha": "b53281f99633f8837dbcf04222bf3b79ab44c111", "filename": "src/libsyntax/ext/deriving/generic/ty.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs?ref=19e718b34def6c3f98372a40352ab9c889ff9f7a", "patch": "@@ -19,6 +19,7 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use codemap::{Span,respan};\n use owned_slice::OwnedSlice;\n+use parse::token::special_idents;\n \n use std::gc::Gc;\n \n@@ -244,22 +245,23 @@ impl<'a> LifetimeBounds<'a> {\n     }\n }\n \n-\n pub fn get_explicit_self(cx: &ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n     -> (Gc<Expr>, ast::ExplicitSelf) {\n+    // this constructs a fresh `self` path, which will match the fresh `self` binding\n+    // created below.\n     let self_path = cx.expr_self(span);\n     match *self_ptr {\n         None => {\n-            (self_path, respan(span, ast::SelfValue))\n+            (self_path, respan(span, ast::SelfValue(special_idents::self_)))\n         }\n         Some(ref ptr) => {\n             let self_ty = respan(\n                 span,\n                 match *ptr {\n-                    Send => ast::SelfUniq,\n+                    Send => ast::SelfUniq(special_idents::self_),\n                     Borrowed(ref lt, mutbl) => {\n                         let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(s).name));\n-                        ast::SelfRegion(lt, mutbl)\n+                        ast::SelfRegion(lt, mutbl, special_idents::self_)\n                     }\n                 });\n             let self_expr = cx.expr_deref(span, self_path);"}, {"sha": "9fe431cfb6c757992e53aec94a50cc610b658f70", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=19e718b34def6c3f98372a40352ab9c889ff9f7a", "patch": "@@ -1501,15 +1501,28 @@ mod test {\n             0)\n     }\n \n-    // macro_rules in method position\n-    #[test] fn macro_in_method_posn(){\n+    // macro_rules in method position. Sadly, unimplemented.\n+    #[ignore] #[test] fn macro_in_method_posn(){\n         expand_crate_str(\n             \"macro_rules! my_method (() => fn thirteen(&self) -> int {13})\n             struct A;\n             impl A{ my_method!()}\n             fn f(){A.thirteen;}\".to_string());\n     }\n \n+    // another nested macro\n+    // expands to impl Entries {fn size_hint(&self_1) {self_1;}\n+    #[test] fn item_macro_workaround(){\n+        run_renaming_test(\n+            &(\"macro_rules! item { ($i:item) => {$i}}\n+              struct Entries;\n+              macro_rules! iterator_impl {\n+              () => { item!( impl Entries { fn size_hint(&self) { self;}})}}\n+              iterator_impl! { }\",\n+              vec!(vec!(0)), true),\n+            0)\n+    }\n+\n     // run one of the renaming tests\n     fn run_renaming_test(t: &RenamingTest, test_idx: uint) {\n         let invalid_name = token::special_idents::invalid.name;"}, {"sha": "bcdf920e5dd41779d76bfe020ee324c04a0841b0", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=19e718b34def6c3f98372a40352ab9c889ff9f7a", "patch": "@@ -334,9 +334,9 @@ pub trait Folder {\n \n     fn fold_explicit_self_(&mut self, es: &ExplicitSelf_) -> ExplicitSelf_ {\n         match *es {\n-            SelfStatic | SelfValue | SelfUniq => *es,\n-            SelfRegion(ref lifetime, m) => {\n-                SelfRegion(fold_opt_lifetime(lifetime, self), m)\n+            SelfStatic | SelfValue(_) | SelfUniq(_) => *es,\n+            SelfRegion(ref lifetime, m, id) => {\n+                SelfRegion(fold_opt_lifetime(lifetime, self), m, id)\n             }\n         }\n     }"}, {"sha": "ac4cbf3aa8e55f4dbacdb2fc3d2a0dd38b447b10", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 42, "deletions": 30, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=19e718b34def6c3f98372a40352ab9c889ff9f7a", "patch": "@@ -3748,13 +3748,18 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn expect_self_ident(&mut self) {\n-        if !self.is_self_ident() {\n-            let token_str = self.this_token_to_string();\n-            self.fatal(format!(\"expected `self` but found `{}`\",\n-                               token_str).as_slice())\n+    fn expect_self_ident(&mut self) -> ast::Ident {\n+        match self.token {\n+            token::IDENT(id, false) if id.name == special_idents::self_.name => {\n+                self.bump();\n+                id\n+            },\n+            _ => {\n+                let token_str = self.this_token_to_string();\n+                self.fatal(format!(\"expected `self` but found `{}`\",\n+                                   token_str).as_slice())\n+            }\n         }\n-        self.bump();\n     }\n \n     // parse the argument list and result type of a function\n@@ -3774,24 +3779,21 @@ impl<'a> Parser<'a> {\n \n             if this.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) {\n                 this.bump();\n-                this.expect_self_ident();\n-                SelfRegion(None, MutImmutable)\n+                SelfRegion(None, MutImmutable, this.expect_self_ident())\n             } else if this.look_ahead(1, |t| Parser::token_is_mutability(t)) &&\n                     this.look_ahead(2,\n                                     |t| token::is_keyword(keywords::Self,\n                                                           t)) {\n                 this.bump();\n                 let mutability = this.parse_mutability();\n-                this.expect_self_ident();\n-                SelfRegion(None, mutability)\n+                SelfRegion(None, mutability, this.expect_self_ident())\n             } else if this.look_ahead(1, |t| Parser::token_is_lifetime(t)) &&\n                        this.look_ahead(2,\n                                        |t| token::is_keyword(keywords::Self,\n                                                              t)) {\n                 this.bump();\n                 let lifetime = this.parse_lifetime();\n-                this.expect_self_ident();\n-                SelfRegion(Some(lifetime), MutImmutable)\n+                SelfRegion(Some(lifetime), MutImmutable, this.expect_self_ident())\n             } else if this.look_ahead(1, |t| Parser::token_is_lifetime(t)) &&\n                       this.look_ahead(2, |t| {\n                           Parser::token_is_mutability(t)\n@@ -3801,8 +3803,7 @@ impl<'a> Parser<'a> {\n                 this.bump();\n                 let lifetime = this.parse_lifetime();\n                 let mutability = this.parse_mutability();\n-                this.expect_self_ident();\n-                SelfRegion(Some(lifetime), mutability)\n+                SelfRegion(Some(lifetime), mutability, this.expect_self_ident())\n             } else {\n                 SelfStatic\n             }\n@@ -3822,15 +3823,13 @@ impl<'a> Parser<'a> {\n                 // We need to make sure it isn't a type\n                 if self.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) {\n                     self.bump();\n-                    self.expect_self_ident();\n-                    SelfUniq\n+                    SelfUniq(self.expect_self_ident())\n                 } else {\n                     SelfStatic\n                 }\n             }\n             token::IDENT(..) if self.is_self_ident() => {\n-                self.bump();\n-                SelfValue\n+                SelfValue(self.expect_self_ident())\n             }\n             token::BINOP(token::STAR) => {\n                 // Possibly \"*self\" or \"*mut self\" -- not supported. Try to avoid\n@@ -3844,29 +3843,32 @@ impl<'a> Parser<'a> {\n                     self.span_err(span, \"cannot pass self by unsafe pointer\");\n                     self.bump();\n                 }\n-                SelfValue\n+                // error case, making bogus self ident:\n+                SelfValue(special_idents::self_)\n             }\n             _ if Parser::token_is_mutability(&self.token) &&\n                     self.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) => {\n                 mutbl_self = self.parse_mutability();\n-                self.expect_self_ident();\n-                SelfValue\n+                SelfValue(self.expect_self_ident())\n             }\n             _ if Parser::token_is_mutability(&self.token) &&\n                     self.look_ahead(1, |t| *t == token::TILDE) &&\n                     self.look_ahead(2, |t| token::is_keyword(keywords::Self, t)) => {\n                 mutbl_self = self.parse_mutability();\n                 self.bump();\n-                self.expect_self_ident();\n-                SelfUniq\n+                SelfUniq(self.expect_self_ident())\n             }\n             _ => SelfStatic\n         };\n \n         let explicit_self_sp = mk_sp(lo, self.span.hi);\n \n-        // If we parsed a self type, expect a comma before the argument list.\n-        let fn_inputs = if explicit_self != SelfStatic {\n+        // shared fall-through for the three cases below. borrowing prevents simply\n+        // writing this as a closure\n+        macro_rules! parse_remaining_arguments {\n+            ($self_id:ident) =>\n+            {\n+            // If we parsed a self type, expect a comma before the argument list.\n             match self.token {\n                 token::COMMA => {\n                     self.bump();\n@@ -3876,23 +3878,33 @@ impl<'a> Parser<'a> {\n                         sep,\n                         parse_arg_fn\n                     );\n-                    fn_inputs.unshift(Arg::new_self(explicit_self_sp, mutbl_self));\n+                    fn_inputs.unshift(Arg::new_self(explicit_self_sp, mutbl_self, $self_id));\n                     fn_inputs\n                 }\n                 token::RPAREN => {\n-                    vec!(Arg::new_self(explicit_self_sp, mutbl_self))\n+                    vec!(Arg::new_self(explicit_self_sp, mutbl_self, $self_id))\n                 }\n                 _ => {\n                     let token_str = self.this_token_to_string();\n                     self.fatal(format!(\"expected `,` or `)`, found `{}`\",\n                                        token_str).as_slice())\n                 }\n             }\n-        } else {\n-            let sep = seq_sep_trailing_disallowed(token::COMMA);\n-            self.parse_seq_to_before_end(&token::RPAREN, sep, parse_arg_fn)\n+            }\n+        }\n+\n+        let fn_inputs = match explicit_self {\n+            SelfStatic =>  {\n+                let sep = seq_sep_trailing_disallowed(token::COMMA);\n+                self.parse_seq_to_before_end(&token::RPAREN, sep, parse_arg_fn)\n+            }\n+            SelfValue(id) => parse_remaining_arguments!(id),\n+            SelfRegion(_,_,id) => parse_remaining_arguments!(id),\n+            SelfUniq(id) => parse_remaining_arguments!(id)\n+\n         };\n \n+\n         self.expect(&token::RPAREN);\n \n         let hi = self.span.hi;"}, {"sha": "a5d70a9333ddea942e242e07c8e9e77cf1c51cf8", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=19e718b34def6c3f98372a40352ab9c889ff9f7a", "patch": "@@ -1967,13 +1967,13 @@ impl<'a> State<'a> {\n         try!(self.print_mutability(mutbl));\n         match explicit_self {\n             ast::SelfStatic => { return Ok(false); }\n-            ast::SelfValue => {\n+            ast::SelfValue(_) => {\n                 try!(word(&mut self.s, \"self\"));\n             }\n-            ast::SelfUniq => {\n+            ast::SelfUniq(_) => {\n                 try!(word(&mut self.s, \"~self\"));\n             }\n-            ast::SelfRegion(ref lt, m) => {\n+            ast::SelfRegion(ref lt, m, _) => {\n                 try!(word(&mut self.s, \"&\"));\n                 try!(self.print_opt_lifetime(lt));\n                 try!(self.print_mutability(m));"}, {"sha": "df34ff30db67f1dfd455e0bc943b28a381a280cc", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e718b34def6c3f98372a40352ab9c889ff9f7a/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=19e718b34def6c3f98372a40352ab9c889ff9f7a", "patch": "@@ -202,8 +202,8 @@ pub fn walk_explicit_self<E: Clone, V: Visitor<E>>(visitor: &mut V,\n                                                    explicit_self: &ExplicitSelf,\n                                                    env: E) {\n     match explicit_self.node {\n-        SelfStatic | SelfValue | SelfUniq => {}\n-        SelfRegion(ref lifetime, _) => {\n+        SelfStatic | SelfValue(_) | SelfUniq(_) => {},\n+        SelfRegion(ref lifetime, _, _) => {\n             visitor.visit_opt_lifetime_ref(explicit_self.span, lifetime, env)\n         }\n     }"}]}