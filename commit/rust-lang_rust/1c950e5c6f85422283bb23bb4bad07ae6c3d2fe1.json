{"sha": "1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjOTUwZTVjNmY4NTQyMjI4M2JiMjNiYjRiYWQwN2FlNmMzZDJmZTE=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-03-02T13:59:20Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-03-05T17:36:50Z"}, "message": "Simplify the try intrinsic by using a callback in the catch block", "tree": {"sha": "01318bda757bf28d59cdd218b456b99736c613a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01318bda757bf28d59cdd218b456b99736c613a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1", "html_url": "https://github.com/rust-lang/rust/commit/1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5953c100d1e9eea5ca70f185e905ea0773a34eb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/5953c100d1e9eea5ca70f185e905ea0773a34eb5", "html_url": "https://github.com/rust-lang/rust/commit/5953c100d1e9eea5ca70f185e905ea0773a34eb5"}], "stats": {"total": 276, "additions": 150, "deletions": 126}, "files": [{"sha": "20fb4149b9359090e6b1ce6f97742774b4c68c7a", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1", "patch": "@@ -1390,14 +1390,16 @@ extern \"rust-intrinsic\" {\n     /// cast to a `u64`; if `T` has no discriminant, returns 0.\n     pub fn discriminant_value<T>(v: &T) -> u64;\n \n-    /// Rust's \"try catch\" construct which invokes the function pointer `f` with\n-    /// the data pointer `data`.\n+    /// Rust's \"try catch\" construct which invokes the function pointer `try_fn`\n+    /// with the data pointer `data`.\n     ///\n-    /// The third pointer is a target-specific data pointer which is filled in\n-    /// with the specifics of the exception that occurred. For examples on Unix\n-    /// platforms this is a `*mut *mut T` which is filled in by the compiler and\n-    /// on MSVC it's `*mut [usize; 2]`. For more information see the compiler's\n+    /// The third argument is a function called if a panic occurs. This function\n+    /// takes the data pointer and a pointer to the target-specific exception\n+    /// object that was caught. For more information see the compiler's\n     /// source as well as std's catch implementation.\n+    #[cfg(not(bootstrap))]\n+    pub fn r#try(try_fn: fn(*mut u8), data: *mut u8, catch_fn: fn(*mut u8, *mut u8)) -> i32;\n+    #[cfg(bootstrap)]\n     pub fn r#try(f: fn(*mut u8), data: *mut u8, local_ptr: *mut u8) -> i32;\n \n     /// Emits a `!nontemporal` store according to LLVM (see their docs)."}, {"sha": "f44a875c9d0d5450b022631b138f59470d05fd12", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1", "patch": "@@ -20,11 +20,8 @@\n \n use core::any::Any;\n \n-// We need the definition of TryPayload for __rust_panic_cleanup.\n-include!(\"../libpanic_unwind/payload.rs\");\n-\n #[rustc_std_internal_symbol]\n-pub unsafe extern \"C\" fn __rust_panic_cleanup(_: TryPayload) -> *mut (dyn Any + Send + 'static) {\n+pub unsafe extern \"C\" fn __rust_panic_cleanup(_: *mut u8) -> *mut (dyn Any + Send + 'static) {\n     unreachable!()\n }\n "}, {"sha": "c7144fe16cddabc70c00b4cc3e54d00dac8e6431", "filename": "src/libpanic_unwind/emcc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1/src%2Flibpanic_unwind%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1/src%2Flibpanic_unwind%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Femcc.rs?ref=1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1", "patch": "@@ -52,7 +52,7 @@ struct Exception {\n     // This needs to be an Option because the object's lifetime follows C++\n     // semantics: when catch_unwind moves the Box out of the exception it must\n     // still leave the exception object in a valid state because its destructor\n-    // is still going to be called by __cxa_end_catch..\n+    // is still going to be called by __cxa_end_catch.\n     data: Option<Box<dyn Any + Send>>,\n }\n "}, {"sha": "d6c3366693818583466adac05bed0588e2e6c12a", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1", "patch": "@@ -35,8 +35,6 @@ use alloc::boxed::Box;\n use core::any::Any;\n use core::panic::BoxMeUp;\n \n-// If adding to this list, you should also look at the list of TryPayload types\n-// defined in payload.rs and likely add to there as well.\n cfg_if::cfg_if! {\n     if #[cfg(target_os = \"emscripten\")] {\n         #[path = \"emcc.rs\"]\n@@ -62,8 +60,6 @@ cfg_if::cfg_if! {\n     }\n }\n \n-include!(\"payload.rs\");\n-\n extern \"C\" {\n     /// Handler in libstd called when a panic object is dropped outside of\n     /// `catch_unwind`.\n@@ -73,9 +69,7 @@ extern \"C\" {\n mod dwarf;\n \n #[rustc_std_internal_symbol]\n-pub unsafe extern \"C\" fn __rust_panic_cleanup(\n-    payload: TryPayload,\n-) -> *mut (dyn Any + Send + 'static) {\n+pub unsafe extern \"C\" fn __rust_panic_cleanup(payload: *mut u8) -> *mut (dyn Any + Send + 'static) {\n     Box::into_raw(imp::cleanup(payload))\n }\n "}, {"sha": "1234db7da0f0861e0841b4131ce95a78866d1b54", "filename": "src/libpanic_unwind/payload.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5953c100d1e9eea5ca70f185e905ea0773a34eb5/src%2Flibpanic_unwind%2Fpayload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5953c100d1e9eea5ca70f185e905ea0773a34eb5/src%2Flibpanic_unwind%2Fpayload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fpayload.rs?ref=5953c100d1e9eea5ca70f185e905ea0773a34eb5", "patch": "@@ -1,21 +0,0 @@\n-// Type definition for the payload argument of the try intrinsic.\n-//\n-// This must be kept in sync with the implementations of the try intrinsic.\n-//\n-// This file is included by both panic runtimes and libstd. It is part of the\n-// panic runtime ABI.\n-cfg_if::cfg_if! {\n-    if #[cfg(target_os = \"emscripten\")] {\n-        type TryPayload = *mut u8;\n-    } else if #[cfg(target_arch = \"wasm32\")] {\n-        type TryPayload = *mut u8;\n-    } else if #[cfg(target_os = \"hermit\")] {\n-        type TryPayload = *mut u8;\n-    } else if #[cfg(all(target_env = \"msvc\", target_arch = \"aarch64\"))] {\n-        type TryPayload = *mut u8;\n-    } else if #[cfg(target_env = \"msvc\")] {\n-        type TryPayload = [u64; 2];\n-    } else {\n-        type TryPayload = *mut u8;\n-    }\n-}"}, {"sha": "c1656023b60e60317f23903e6891c61c103ba53c", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1", "patch": "@@ -49,10 +49,17 @@\n \n use alloc::boxed::Box;\n use core::any::Any;\n-use core::mem;\n-use core::raw;\n+use core::mem::{self, ManuallyDrop};\n use libc::{c_int, c_uint, c_void};\n \n+struct Exception {\n+    // This needs to be an Option because we catch the exception by reference\n+    // and its destructor is executed by the C++ runtime. When we take the Box\n+    // out of the exception, we need to leave the exception in a valid state\n+    // for its destructor to run without double-dropping the Box.\n+    data: Option<Box<dyn Any + Send>>,\n+}\n+\n // First up, a whole bunch of type definitions. There's a few platform-specific\n // oddities here, and a lot that's just blatantly copied from LLVM. The purpose\n // of all this is to implement the `panic` function below through a call to\n@@ -186,7 +193,7 @@ static mut CATCHABLE_TYPE: _CatchableType = _CatchableType {\n     properties: 0,\n     pType: ptr!(0),\n     thisDisplacement: _PMD { mdisp: 0, pdisp: -1, vdisp: 0 },\n-    sizeOrOffset: mem::size_of::<[u64; 2]>() as c_int,\n+    sizeOrOffset: mem::size_of::<Exception>() as c_int,\n     copyFunction: ptr!(0),\n };\n \n@@ -229,16 +236,16 @@ static mut TYPE_DESCRIPTOR: _TypeDescriptor = _TypeDescriptor {\n // because Box<dyn Any> isn't clonable.\n macro_rules! define_cleanup {\n     ($abi:tt) => {\n-        unsafe extern $abi fn exception_cleanup(e: *mut [u64; 2]) {\n-            if (*e)[0] != 0 {\n-                cleanup(*e);\n+        unsafe extern $abi fn exception_cleanup(e: *mut Exception) {\n+            if let Some(b) = e.read().data {\n+                drop(b);\n                 super::__rust_drop_panic();\n             }\n         }\n         #[unwind(allowed)]\n-        unsafe extern $abi fn exception_copy(_dest: *mut [u64; 2],\n-                                             _src: *mut [u64; 2])\n-                                             -> *mut [u64; 2] {\n+        unsafe extern $abi fn exception_copy(_dest: *mut Exception,\n+                                             _src: *mut Exception)\n+                                             -> *mut Exception {\n             panic!(\"Rust panics cannot be copied\");\n         }\n     }\n@@ -258,12 +265,11 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     // need to otherwise transfer `data` to the heap. We just pass a stack\n     // pointer to this function.\n     //\n-    // The first argument is the payload being thrown (our two pointers), and\n-    // the second argument is the type information object describing the\n-    // exception (constructed above).\n-    let ptrs = mem::transmute::<_, raw::TraitObject>(data);\n-    let mut ptrs = [ptrs.data as u64, ptrs.vtable as u64];\n-    let throw_ptr = ptrs.as_mut_ptr() as *mut _;\n+    // The ManuallyDrop is needed here since we don't want Exception to be\n+    // dropped when unwinding. Instead it will be dropped by exception_cleanup\n+    // which is invoked by the C++ runtime.\n+    let mut exception = ManuallyDrop::new(Exception { data: Some(data) });\n+    let throw_ptr = &mut exception as *mut _ as *mut _;\n \n     // This... may seems surprising, and justifiably so. On 32-bit MSVC the\n     // pointers between these structure are just that, pointers. On 64-bit MSVC,\n@@ -311,8 +317,9 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     _CxxThrowException(throw_ptr, &mut THROW_INFO as *mut _ as *mut _);\n }\n \n-pub unsafe fn cleanup(payload: [u64; 2]) -> Box<dyn Any + Send> {\n-    mem::transmute(raw::TraitObject { data: payload[0] as *mut _, vtable: payload[1] as *mut _ })\n+pub unsafe fn cleanup(payload: *mut u8) -> Box<dyn Any + Send> {\n+    let exception = &mut *(payload as *mut Exception);\n+    exception.data.take().unwrap()\n }\n \n // This is required by the compiler to exist (e.g., it's a lang item), but"}, {"sha": "d34540638f183e06b36303a2438391d1cb089300", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 46, "deletions": 54, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1", "patch": "@@ -851,21 +851,21 @@ fn memset_intrinsic(\n \n fn try_intrinsic(\n     bx: &mut Builder<'a, 'll, 'tcx>,\n-    func: &'ll Value,\n+    try_func: &'ll Value,\n     data: &'ll Value,\n-    local_ptr: &'ll Value,\n+    catch_func: &'ll Value,\n     dest: &'ll Value,\n ) {\n     if bx.sess().no_landing_pads() {\n-        bx.call(func, &[data], None);\n+        bx.call(try_func, &[data], None);\n         // Return 0 unconditionally from the intrinsic call;\n         // we can never unwind.\n         let ret_align = bx.tcx().data_layout.i32_align.abi;\n         bx.store(bx.const_i32(0), dest, ret_align);\n     } else if wants_msvc_seh(bx.sess()) {\n-        codegen_msvc_try(bx, func, data, local_ptr, dest);\n+        codegen_msvc_try(bx, try_func, data, catch_func, dest);\n     } else {\n-        codegen_gnu_try(bx, func, data, local_ptr, dest);\n+        codegen_gnu_try(bx, try_func, data, catch_func, dest);\n     }\n }\n \n@@ -878,9 +878,9 @@ fn try_intrinsic(\n // as the old ones are still more optimized.\n fn codegen_msvc_try(\n     bx: &mut Builder<'a, 'll, 'tcx>,\n-    func: &'ll Value,\n+    try_func: &'ll Value,\n     data: &'ll Value,\n-    local_ptr: &'ll Value,\n+    catch_func: &'ll Value,\n     dest: &'ll Value,\n ) {\n     let llfn = get_rust_try_fn(bx, &mut |mut bx| {\n@@ -892,15 +892,15 @@ fn codegen_msvc_try(\n         let mut catchpad = bx.build_sibling_block(\"catchpad\");\n         let mut caught = bx.build_sibling_block(\"caught\");\n \n-        let func = llvm::get_param(bx.llfn(), 0);\n+        let try_func = llvm::get_param(bx.llfn(), 0);\n         let data = llvm::get_param(bx.llfn(), 1);\n-        let local_ptr = llvm::get_param(bx.llfn(), 2);\n+        let catch_func = llvm::get_param(bx.llfn(), 2);\n \n         // We're generating an IR snippet that looks like:\n         //\n-        //   declare i32 @rust_try(%func, %data, %ptr) {\n-        //      %slot = alloca [2 x i64]\n-        //      invoke %func(%data) to label %normal unwind label %catchswitch\n+        //   declare i32 @rust_try(%try_func, %data, %catch_func) {\n+        //      %slot = alloca u8*\n+        //      invoke %try_func(%data) to label %normal unwind label %catchswitch\n         //\n         //   normal:\n         //      ret i32 0\n@@ -910,8 +910,8 @@ fn codegen_msvc_try(\n         //\n         //   catchpad:\n         //      %tok = catchpad within %cs [%type_descriptor, 0, %slot]\n-        //      %ptr[0] = %slot[0]\n-        //      %ptr[1] = %slot[1]\n+        //      %ptr = load %slot\n+        //      call %catch_func(%data, %ptr)\n         //      catchret from %tok to label %caught\n         //\n         //   caught:\n@@ -928,26 +928,26 @@ fn codegen_msvc_try(\n         //          ~rust_panic();\n         //\n         //          uint64_t x[2];\n-        //      }\n+        //      };\n         //\n-        //      int bar(void (*foo)(void), uint64_t *ret) {\n+        //      int __rust_try(\n+        //          void (*try_func)(void*),\n+        //          void *data,\n+        //          void (*catch_func)(void*, void*) noexcept\n+        //      ) {\n         //          try {\n-        //              foo();\n+        //              try_func(data);\n         //              return 0;\n         //          } catch(rust_panic& a) {\n-        //              ret[0] = a.x[0];\n-        //              ret[1] = a.x[1];\n-        //              a.x[0] = 0;\n+        //              catch_func(data, &a);\n         //              return 1;\n         //          }\n         //      }\n         //\n         // More information can be found in libstd's seh.rs implementation.\n-        let i64_2 = bx.type_array(bx.type_i64(), 2);\n-        let i64_2_ptr = bx.type_ptr_to(i64_2);\n         let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n-        let slot = bx.alloca(i64_2_ptr, ptr_align);\n-        bx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(), None);\n+        let slot = bx.alloca(bx.type_i8p(), ptr_align);\n+        bx.invoke(try_func, &[data], normal.llbb(), catchswitch.llbb(), None);\n \n         normal.ret(bx.const_i32(0));\n \n@@ -987,17 +987,8 @@ fn codegen_msvc_try(\n         // Source: MicrosoftCXXABI::getAddrOfCXXCatchHandlerType in clang\n         let flags = bx.const_i32(8);\n         let funclet = catchpad.catch_pad(cs, &[tydesc, flags, slot]);\n-        let i64_align = bx.tcx().data_layout.i64_align.abi;\n-        let payload_ptr = catchpad.load(slot, ptr_align);\n-        let payload = catchpad.load(payload_ptr, i64_align);\n-        let local_ptr = catchpad.bitcast(local_ptr, bx.type_ptr_to(i64_2));\n-        catchpad.store(payload, local_ptr, i64_align);\n-\n-        // Clear the first word of the exception so avoid double-dropping it.\n-        // This will be read by the destructor which is implicitly called at the\n-        // end of the catch block by the runtime.\n-        let payload_0_ptr = catchpad.inbounds_gep(payload_ptr, &[bx.const_i32(0), bx.const_i32(0)]);\n-        catchpad.store(bx.const_u64(0), payload_0_ptr, i64_align);\n+        let ptr = catchpad.load(slot, ptr_align);\n+        catchpad.call(catch_func, &[data, ptr], Some(&funclet));\n \n         catchpad.catch_ret(&funclet, caught.llbb());\n \n@@ -1006,7 +997,7 @@ fn codegen_msvc_try(\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llfn, &[func, data, local_ptr], None);\n+    let ret = bx.call(llfn, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n@@ -1024,38 +1015,34 @@ fn codegen_msvc_try(\n // the right personality function.\n fn codegen_gnu_try(\n     bx: &mut Builder<'a, 'll, 'tcx>,\n-    func: &'ll Value,\n+    try_func: &'ll Value,\n     data: &'ll Value,\n-    local_ptr: &'ll Value,\n+    catch_func: &'ll Value,\n     dest: &'ll Value,\n ) {\n     let llfn = get_rust_try_fn(bx, &mut |mut bx| {\n         // Codegens the shims described above:\n         //\n         //   bx:\n-        //      invoke %func(%args...) normal %normal unwind %catch\n+        //      invoke %func(%data) normal %normal unwind %catch\n         //\n         //   normal:\n         //      ret 0\n         //\n         //   catch:\n-        //      (ptr, _) = landingpad\n-        //      store ptr, %local_ptr\n+        //      (%ptr, _) = landingpad\n+        //      call %catch_func(%data, %ptr)\n         //      ret 1\n-        //\n-        // Note that the `local_ptr` data passed into the `try` intrinsic is\n-        // expected to be `*mut *mut u8` for this to actually work, but that's\n-        // managed by the standard library.\n \n         bx.sideeffect();\n \n         let mut then = bx.build_sibling_block(\"then\");\n         let mut catch = bx.build_sibling_block(\"catch\");\n \n-        let func = llvm::get_param(bx.llfn(), 0);\n+        let try_func = llvm::get_param(bx.llfn(), 0);\n         let data = llvm::get_param(bx.llfn(), 1);\n-        let local_ptr = llvm::get_param(bx.llfn(), 2);\n-        bx.invoke(func, &[data], then.llbb(), catch.llbb(), None);\n+        let catch_func = llvm::get_param(bx.llfn(), 2);\n+        bx.invoke(try_func, &[data], then.llbb(), catch.llbb(), None);\n         then.ret(bx.const_i32(0));\n \n         // Type indicator for the exception being thrown.\n@@ -1075,15 +1062,13 @@ fn codegen_gnu_try(\n         };\n         catch.add_clause(vals, tydesc);\n         let ptr = catch.extract_value(vals, 0);\n-        let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n-        let bitcast = catch.bitcast(local_ptr, bx.type_ptr_to(bx.type_i8p()));\n-        catch.store(ptr, bitcast, ptr_align);\n+        catch.call(catch_func, &[data, ptr], None);\n         catch.ret(bx.const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llfn, &[func, data, local_ptr], None);\n+    let ret = bx.call(llfn, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n@@ -1130,15 +1115,22 @@ fn get_rust_try_fn<'ll, 'tcx>(\n     // Define the type up front for the signature of the rust_try function.\n     let tcx = cx.tcx;\n     let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n-    let fn_ty = tcx.mk_fn_ptr(ty::Binder::bind(tcx.mk_fn_sig(\n+    let try_fn_ty = tcx.mk_fn_ptr(ty::Binder::bind(tcx.mk_fn_sig(\n         iter::once(i8p),\n         tcx.mk_unit(),\n         false,\n         hir::Unsafety::Unsafe,\n         Abi::Rust,\n     )));\n+    let catch_fn_ty = tcx.mk_fn_ptr(ty::Binder::bind(tcx.mk_fn_sig(\n+        [i8p, i8p].iter().cloned(),\n+        tcx.mk_unit(),\n+        false,\n+        hir::Unsafety::Unsafe,\n+        Abi::Rust,\n+    )));\n     let output = tcx.types.i32;\n-    let rust_try = gen_fn(cx, \"__rust_try\", vec![fn_ty, i8p, i8p], output, codegen);\n+    let rust_try = gen_fn(cx, \"__rust_try\", vec![try_fn_ty, i8p, catch_fn_ty], output, codegen);\n     cx.rust_try_fn.set(Some(rust_try));\n     rust_try\n }"}, {"sha": "fc2d315b609242ebc5a140bb5a02f78d4073d32e", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1", "patch": "@@ -297,14 +297,25 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n \n             \"try\" => {\n                 let mut_u8 = tcx.mk_mut_ptr(tcx.types.u8);\n-                let fn_ty = ty::Binder::bind(tcx.mk_fn_sig(\n+                let try_fn_ty = ty::Binder::bind(tcx.mk_fn_sig(\n                     iter::once(mut_u8),\n                     tcx.mk_unit(),\n                     false,\n                     hir::Unsafety::Normal,\n                     Abi::Rust,\n                 ));\n-                (0, vec![tcx.mk_fn_ptr(fn_ty), mut_u8, mut_u8], tcx.types.i32)\n+                let catch_fn_ty = ty::Binder::bind(tcx.mk_fn_sig(\n+                    [mut_u8, mut_u8].iter().cloned(),\n+                    tcx.mk_unit(),\n+                    false,\n+                    hir::Unsafety::Normal,\n+                    Abi::Rust,\n+                ));\n+                (\n+                    0,\n+                    vec![tcx.mk_fn_ptr(try_fn_ty), mut_u8, tcx.mk_fn_ptr(catch_fn_ty)],\n+                    tcx.types.i32,\n+                )\n             }\n \n             \"va_start\" | \"va_end\" => match mk_va_list_ty(hir::Mutability::Mut) {"}, {"sha": "0be71b52d9edd559d2efadfeec6553c3b332f54c", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 52, "deletions": 13, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1", "patch": "@@ -12,7 +12,7 @@ use core::panic::{BoxMeUp, Location, PanicInfo};\n use crate::any::Any;\n use crate::fmt;\n use crate::intrinsics;\n-use crate::mem::{self, ManuallyDrop, MaybeUninit};\n+use crate::mem::{self, ManuallyDrop};\n use crate::process;\n use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sys::stdio::panic_output;\n@@ -28,9 +28,6 @@ use crate::io::set_panic;\n #[cfg(test)]\n use realstd::io::set_panic;\n \n-// Include the definition of UnwindPayload from libpanic_unwind.\n-include!(\"../libpanic_unwind/payload.rs\");\n-\n // Binary interface to the panic runtime that the standard library depends on.\n //\n // The standard library is tagged with `#![needs_panic_runtime]` (introduced in\n@@ -43,9 +40,7 @@ include!(\"../libpanic_unwind/payload.rs\");\n // hook up these functions, but it is not this day!\n #[allow(improper_ctypes)]\n extern \"C\" {\n-    /// The payload ptr here is actually the same as the payload ptr for the try\n-    /// intrinsic (i.e., is really `*mut [u64; 2]` or `*mut *mut u8`).\n-    fn __rust_panic_cleanup(payload: TryPayload) -> *mut (dyn Any + Send + 'static);\n+    fn __rust_panic_cleanup(payload: *mut u8) -> *mut (dyn Any + Send + 'static);\n \n     /// `payload` is actually a `*mut &mut dyn BoxMeUp` but that would cause FFI warnings.\n     /// It cannot be `Box<dyn BoxMeUp>` because the other end of this call does not depend\n@@ -246,6 +241,7 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n     union Data<F, R> {\n         f: ManuallyDrop<F>,\n         r: ManuallyDrop<R>,\n+        p: ManuallyDrop<Box<dyn Any + Send>>,\n     }\n \n     // We do some sketchy operations with ownership here for the sake of\n@@ -275,27 +271,57 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n     // method of calling a catch panic whilst juggling ownership.\n     let mut data = Data { f: ManuallyDrop::new(f) };\n \n-    let mut payload: MaybeUninit<TryPayload> = MaybeUninit::uninit();\n-\n     let data_ptr = &mut data as *mut _ as *mut u8;\n-    let payload_ptr = payload.as_mut_ptr() as *mut _;\n-    return if intrinsics::r#try(do_call::<F, R>, data_ptr, payload_ptr) == 0 {\n+    return if do_try(do_call::<F, R>, data_ptr, do_catch::<F, R>) == 0 {\n         Ok(ManuallyDrop::into_inner(data.r))\n     } else {\n-        Err(cleanup(payload.assume_init()))\n+        Err(ManuallyDrop::into_inner(data.p))\n     };\n \n+    // Compatibility wrapper around the try intrinsic for bootstrap\n+    #[inline]\n+    unsafe fn do_try(try_fn: fn(*mut u8), data: *mut u8, catch_fn: fn(*mut u8, *mut u8)) -> i32 {\n+        #[cfg(not(bootstrap))]\n+        {\n+            intrinsics::r#try(try_fn, data, catch_fn)\n+        }\n+        #[cfg(bootstrap)]\n+        {\n+            use crate::mem::MaybeUninit;\n+            #[cfg(target_env = \"msvc\")]\n+            type TryPayload = [u64; 2];\n+            #[cfg(not(target_env = \"msvc\"))]\n+            type TryPayload = *mut u8;\n+\n+            let mut payload: MaybeUninit<TryPayload> = MaybeUninit::uninit();\n+            let payload_ptr = payload.as_mut_ptr() as *mut u8;\n+            let r = intrinsics::r#try(try_fn, data, payload_ptr);\n+            if r != 0 {\n+                #[cfg(target_env = \"msvc\")]\n+                {\n+                    catch_fn(data, payload_ptr)\n+                }\n+                #[cfg(not(target_env = \"msvc\"))]\n+                {\n+                    catch_fn(data, payload.assume_init())\n+                }\n+            }\n+            r\n+        }\n+    }\n+\n     // We consider unwinding to be rare, so mark this function as cold. However,\n     // do not mark it no-inline -- that decision is best to leave to the\n     // optimizer (in most cases this function is not inlined even as a normal,\n     // non-cold function, though, as of the writing of this comment).\n     #[cold]\n-    unsafe fn cleanup(payload: TryPayload) -> Box<dyn Any + Send + 'static> {\n+    unsafe fn cleanup(payload: *mut u8) -> Box<dyn Any + Send + 'static> {\n         let obj = Box::from_raw(__rust_panic_cleanup(payload));\n         update_panic_count(-1);\n         obj\n     }\n \n+    #[inline]\n     fn do_call<F: FnOnce() -> R, R>(data: *mut u8) {\n         unsafe {\n             let data = data as *mut Data<F, R>;\n@@ -304,6 +330,19 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n             data.r = ManuallyDrop::new(f());\n         }\n     }\n+\n+    // We *do* want this part of the catch to be inlined: this allows the\n+    // compiler to properly track accesses to the Data union and optimize it\n+    // away most of the time.\n+    #[inline]\n+    fn do_catch<F: FnOnce() -> R, R>(data: *mut u8, payload: *mut u8) {\n+        unsafe {\n+            let data = data as *mut Data<F, R>;\n+            let data = &mut (*data);\n+            let obj = cleanup(payload);\n+            data.p = ManuallyDrop::new(obj);\n+        }\n+    }\n }\n \n /// Determines whether the current thread is unwinding because of panic."}, {"sha": "166d2bb99426d44ce0940c89c43051ffddeb1d87", "filename": "src/test/codegen/try-panic-abort.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1/src%2Ftest%2Fcodegen%2Ftry-panic-abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1/src%2Ftest%2Fcodegen%2Ftry-panic-abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ftry-panic-abort.rs?ref=1c950e5c6f85422283bb23bb4bad07ae6c3d2fe1", "patch": "@@ -7,11 +7,14 @@ extern \"C\" {\n     #[unwind(allow)]\n     fn bar(data: *mut u8);\n }\n+extern \"Rust\" {\n+    fn catch(data: *mut u8, exception: *mut u8);\n+}\n \n // CHECK-LABEL: @foo\n #[no_mangle]\n pub unsafe fn foo() -> i32 {\n     // CHECK: call void @bar\n     // CHECK: ret i32 0\n-    std::intrinsics::r#try(|x| bar(x), 0 as *mut u8, 0 as *mut u8)\n+    std::intrinsics::r#try(|x| bar(x), 0 as *mut u8, |x, y| catch(x, y))\n }"}]}