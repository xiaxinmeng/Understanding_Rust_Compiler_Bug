{"sha": "25a2d13cdea6011046a9929824deafd332b94436", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1YTJkMTNjZGVhNjAxMTA0NmE5OTI5ODI0ZGVhZmQzMzJiOTQ0MzY=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-12-03T00:36:03Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-12-20T10:37:15Z"}, "message": "Allow multiple suggestions", "tree": {"sha": "f6fbefb1d9e37cbba93725ee8f264e8ce486f469", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6fbefb1d9e37cbba93725ee8f264e8ce486f469"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25a2d13cdea6011046a9929824deafd332b94436", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25a2d13cdea6011046a9929824deafd332b94436", "html_url": "https://github.com/rust-lang/rust/commit/25a2d13cdea6011046a9929824deafd332b94436", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25a2d13cdea6011046a9929824deafd332b94436/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dac8883a94f9a60d115cf9daecc22361dcaed4f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/dac8883a94f9a60d115cf9daecc22361dcaed4f4", "html_url": "https://github.com/rust-lang/rust/commit/dac8883a94f9a60d115cf9daecc22361dcaed4f4"}], "stats": {"total": 159, "additions": 106, "deletions": 53}, "files": [{"sha": "3e7cc0b1e3e9c2150b8235b1576b478f938901ee", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/25a2d13cdea6011046a9929824deafd332b94436/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25a2d13cdea6011046a9929824deafd332b94436/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=25a2d13cdea6011046a9929824deafd332b94436", "patch": "@@ -1367,7 +1367,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                    cause: &ObligationCause<'tcx>,\n                                    expected: Ty<'tcx>,\n                                    actual: Ty<'tcx>,\n-                                   err: TypeError<'tcx>) -> DiagnosticBuilder<'tcx> {\n+                                   err: TypeError<'tcx>)\n+                                   -> DiagnosticBuilder<'tcx> {\n         let trace = TypeTrace::types(cause, true, expected, actual);\n         self.report_and_explain_type_error(trace, &err)\n     }"}, {"sha": "17d1bd777973e42920456acf78c64cbecdd61aa4", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25a2d13cdea6011046a9929824deafd332b94436/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25a2d13cdea6011046a9929824deafd332b94436/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=25a2d13cdea6011046a9929824deafd332b94436", "patch": "@@ -81,7 +81,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn format_method_suggestion(&self, method: &AssociatedItem) -> String {\n         format!(\".{}({})\",\n                 method.name,\n-                if self.has_not_input_arg(method) {\n+                if self.has_no_input_arg(method) {\n                     \"\"\n                 } else {\n                     \"...\"\n@@ -99,7 +99,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn get_best_match(&self, methods: &[AssociatedItem]) -> String {\n         let no_argument_methods: Vec<_> =\n             methods.iter()\n-                   .filter(|ref x| self.has_not_input_arg(&*x))\n+                   .filter(|ref x| self.has_no_input_arg(&*x))\n                    .map(|x| x.clone())\n                    .collect();\n         if no_argument_methods.len() > 0 {\n@@ -110,7 +110,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     // This function checks if the method isn't static and takes other arguments than `self`.\n-    fn has_not_input_arg(&self, method: &AssociatedItem) -> bool {\n+    fn has_no_input_arg(&self, method: &AssociatedItem) -> bool {\n         match method.def() {\n             Def::Method(def_id) => {\n                 match self.tcx.item_type(def_id).sty {"}, {"sha": "b11f6e837d20c6743c9ff5e9213abac4eab2909b", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 101, "deletions": 49, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/25a2d13cdea6011046a9929824deafd332b94436/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25a2d13cdea6011046a9929824deafd332b94436/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=25a2d13cdea6011046a9929824deafd332b94436", "patch": "@@ -37,6 +37,22 @@ pub enum LookingFor<'tcx> {\n     ReturnType(Ty<'tcx>),\n }\n \n+impl<'tcx> LookingFor<'tcx> {\n+    pub fn is_method_name(&self) -> bool {\n+        match *self {\n+            LookingFor::MethodName(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_return_type(&self) -> bool {\n+        match *self {\n+            LookingFor::ReturnType(_) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n struct ProbeContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     span: Span,\n@@ -468,44 +484,81 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         debug!(\"assemble_inherent_impl_probe {:?}\", impl_def_id);\n \n-        let item = match self.impl_or_trait_item(impl_def_id) {\n-            Some(m) => m,\n-            None => {\n+        let items = self.impl_or_trait_item(impl_def_id);\n+        if items.len() < 1 {\n+            return // No method with correct name on this impl\n+        }\n+\n+        if self.looking_for.is_method_name() {\n+            let item = items[0];\n+\n+            if !self.has_applicable_self(&item) {\n+                // No receiver declared. Not a candidate.\n+                return self.record_static_candidate(ImplSource(impl_def_id));\n+            }\n+\n+            if !item.vis.is_accessible_from(self.body_id, &self.tcx.map) {\n+                self.private_candidate = Some(item.def());\n                 return;\n-            } // No method with correct name on this impl\n-        };\n+            }\n \n-        if !self.has_applicable_self(&item) {\n-            // No receiver declared. Not a candidate.\n-            return self.record_static_candidate(ImplSource(impl_def_id));\n-        }\n+            let (impl_ty, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n+            let impl_ty = impl_ty.subst(self.tcx, impl_substs);\n \n-        if !item.vis.is_accessible_from(self.body_id, &self.tcx.map) {\n-            self.private_candidate = Some(item.def());\n-            return;\n-        }\n+            // Determine the receiver type that the method itself expects.\n+            let xform_self_ty = self.xform_self_ty(&item, impl_ty, impl_substs);\n \n-        let (impl_ty, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n-        let impl_ty = impl_ty.subst(self.tcx, impl_substs);\n-\n-        // Determine the receiver type that the method itself expects.\n-        let xform_self_ty = self.xform_self_ty(&item, impl_ty, impl_substs);\n-\n-        // We can't use normalize_associated_types_in as it will pollute the\n-        // fcx's fulfillment context after this probe is over.\n-        let cause = traits::ObligationCause::misc(self.span, self.body_id);\n-        let mut selcx = &mut traits::SelectionContext::new(self.fcx);\n-        let traits::Normalized { value: xform_self_ty, obligations } =\n-            traits::normalize(selcx, cause, &xform_self_ty);\n-        debug!(\"assemble_inherent_impl_probe: xform_self_ty = {:?}\",\n-               xform_self_ty);\n-\n-        self.inherent_candidates.push(Candidate {\n-            xform_self_ty: xform_self_ty,\n-            item: item,\n-            kind: InherentImplCandidate(impl_substs, obligations),\n-            import_id: self.import_id,\n-        });\n+            // We can't use normalize_associated_types_in as it will pollute the\n+            // fcx's fulfillment context after this probe is over.\n+            let cause = traits::ObligationCause::misc(self.span, self.body_id);\n+            let mut selcx = &mut traits::SelectionContext::new(self.fcx);\n+            let traits::Normalized { value: xform_self_ty, obligations } =\n+                traits::normalize(selcx, cause, &xform_self_ty);\n+            debug!(\"assemble_inherent_impl_probe: xform_self_ty = {:?}\",\n+                   xform_self_ty);\n+\n+            self.inherent_candidates.push(Candidate {\n+                xform_self_ty: xform_self_ty,\n+                item: item,\n+                kind: InherentImplCandidate(impl_substs, obligations),\n+                import_id: self.import_id,\n+            });\n+        } else {\n+            for item in items {\n+                if !self.has_applicable_self(&item) {\n+                    // No receiver declared. Not a candidate.\n+                    self.record_static_candidate(ImplSource(impl_def_id));\n+                    continue\n+                }\n+\n+                if !item.vis.is_accessible_from(self.body_id, &self.tcx.map) {\n+                    self.private_candidate = Some(item.def());\n+                    continue\n+                }\n+\n+                let (impl_ty, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n+                let impl_ty = impl_ty.subst(self.tcx, impl_substs);\n+\n+                // Determine the receiver type that the method itself expects.\n+                let xform_self_ty = self.xform_self_ty(&item, impl_ty, impl_substs);\n+\n+                // We can't use normalize_associated_types_in as it will pollute the\n+                // fcx's fulfillment context after this probe is over.\n+                let cause = traits::ObligationCause::misc(self.span, self.body_id);\n+                let mut selcx = &mut traits::SelectionContext::new(self.fcx);\n+                let traits::Normalized { value: xform_self_ty, obligations } =\n+                    traits::normalize(selcx, cause, &xform_self_ty);\n+                debug!(\"assemble_inherent_impl_probe: xform_self_ty = {:?}\",\n+                       xform_self_ty);\n+\n+                self.inherent_candidates.push(Candidate {\n+                    xform_self_ty: xform_self_ty,\n+                    item: item,\n+                    kind: InherentImplCandidate(impl_substs, obligations),\n+                    import_id: self.import_id,\n+                });\n+            }\n+        }\n     }\n \n     fn assemble_inherent_candidates_from_object(&mut self,\n@@ -598,12 +651,11 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         let tcx = self.tcx;\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n-            let item = match self.impl_or_trait_item(bound_trait_ref.def_id()) {\n-                Some(v) => v,\n-                None => {\n-                    continue;\n-                }\n-            };\n+            let items = self.impl_or_trait_item(bound_trait_ref.def_id());\n+            if items.len() < 1 {\n+                continue\n+            }\n+            let item = items[0];\n \n             if !self.has_applicable_self(&item) {\n                 self.record_static_candidate(TraitSource(bound_trait_ref.def_id()));\n@@ -665,12 +717,11 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         debug!(\"assemble_extension_candidates_for_trait(trait_def_id={:?})\",\n                trait_def_id);\n \n-        let item = match self.impl_or_trait_item(trait_def_id) {\n-            Some(i) => i,\n-            None => {\n-                return Ok(());\n-            }\n-        };\n+        let items = self.impl_or_trait_item(trait_def_id);\n+        if items.len() < 1 {\n+            return Ok(());\n+        }\n+        let item = items[0];\n \n         // Check whether `trait_def_id` defines a method with suitable name:\n         if !self.has_applicable_self(&item) {\n@@ -1351,16 +1402,17 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     /// Find the method with the appropriate name (or return type, as the case may be).\n-    fn impl_or_trait_item(&self, def_id: DefId) -> Option<ty::AssociatedItem> {\n+    fn impl_or_trait_item(&self, def_id: DefId) -> Vec<ty::AssociatedItem> {\n         match self.looking_for {\n             LookingFor::MethodName(name) => {\n-                self.fcx.associated_item(def_id, name)\n+                self.fcx.associated_item(def_id, name).map_or(Vec::new(), |x| vec![x])\n             }\n             LookingFor::ReturnType(return_ty) => {\n                 self.tcx\n                     .associated_items(def_id)\n                     .map(|did| self.tcx.associated_item(did.def_id))\n-                    .find(|m| self.matches_return_type(m, return_ty))\n+                    .filter(|m| self.matches_return_type(m, return_ty))\n+                    .collect()\n             }\n         }\n     }"}]}