{"sha": "8b40a188cee5bef97526dfc271afbd2a98008183", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiNDBhMTg4Y2VlNWJlZjk3NTI2ZGZjMjcxYWZiZDJhOTgwMDgxODM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-01T03:46:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-01T03:46:13Z"}, "message": "Auto merge of #60145 - little-dude:ip2, r=alexcrichton\n\nstd::net: Ipv4Addr and Ipv6Addr improvements\n\nPicking this up again from my previous PR: https://github.com/rust-lang/rust/pull/56050\nRelated to: https://github.com/rust-lang/rust/issues/27709\nFixes: https://github.com/rust-lang/rust/issues/57558\n\n- add `add Ipv4Addr::is_reserved()`\n  - [X] implementation\n  - [X] tests\n- add `Ipv6Addr::is_unicast_link_local_strict()` and update `Ipv6Addr::is_unicast_link_local()` documentation\n  - [X] implementation\n  - [X] test\n- add `Ipv4Addr::is_benchmarking()`\n  - [X] implementation\n  - [X] test\n- add `Ipv4Addr::is_ietf_protocol_assignment()`\n  - [X] implementation\n  - [X] test\n- add `Ipv4Addr::is_shared()`\n  - [X] implementation\n  - [x] test\n- fix `Ipv4Addr:is_global()`\n  - [X] implementation\n  - [x] test\n- [X] refactor the tests for IP properties. This makes the tests more verbose, but using macros have two advantages:\n    - it will now be easier to add tests for all the new methods\n    - we get clear error messages when a test is failing. For instance:\n\n```\n---- net::ip::tests::ip_properties stdout ----\nthread '<unnamed>' panicked at 'assertion failed: !ip!(\"fec0::\").is_global()', src/libstd/net/ip.rs:2036:9\n\n```\n\nWhereas previously it was something like\n\n```\nthread '<unnamed>' panicked at 'assertion failed: `(left == right)`\n   left: `true`,\n  right: `false`', libstd/net/ip.rs:1948:13\n```\n\n-----------------------\n\n# Ongoing discussions:\n\n## Should `Ipv4Addr::is_global()` return `true` or `false` for reserved addresses?\n\nReserved addresses are addresses that are matched by `Ipv4Addr::is_reserved()`.\n@the8472 [pointed out](https://github.com/rust-lang/rust/pull/60145#issuecomment-485458319) that [RFC 4291](https://tools.ietf.org/html/rfc4291#section-2.4) says IPv6 reserved addresses should be considered global:\n\n```\nFuture specifications may redefine one or more sub-ranges of the\nGlobal Unicast space for other purposes, but unless and until that\nhappens, implementations must treat all addresses that do not start\nwith any of the above-listed prefixes as Global Unicast addresses.\n```\n\nWe could extrapolate that this should also be the case for IPv4. However, it seems that [IANA considers them non global](https://www.iana.org/assignments/ipv4-address-space/ipv4-address-space.xhtml) (see [my comment](https://github.com/rust-lang/rust/pull/60145#issuecomment-485713270))\n\n### Final decision\n\nThere seems to be a consensus that reserved addresses have a different meaning for IPv4 and IPv6 ([comment1](https://github.com/rust-lang/rust/pull/60145#issuecomment-485963789) [comment2](https://github.com/rust-lang/rust/pull/60145#issuecomment-485944582), so we can consider that RFC4291 does not apply to IPv4, and that reserved IPv4 addresses are _not_ global.\n\n## Should `Ipv6Addr::is_unicast_site_local()` exist?\n\n@pusateri [noted](https://github.com/rust-lang/rust/pull/60145#issuecomment-485507515) that site-local addresses have been deprecated for a while by [RFC 3879](https://tools.ietf.org/html/rfc3879) and new implementations _must not_ support them. However, since this method is stable, removing does not seem possible. This kind of situation is covered by the RFC which stated that existing implementation _may_ continue supporting site-local addresses.\n\n### Final decision\n\nLet's keep this method. It is stable already, and the RFC explicitly states that existing implementation may remain.\n\n---------\n\nNote: I'll be AFK from April 27th to May 11th. Anyone should feel free to pick this up if the PR hasn't been merged by then. Sorry for dragging that for so long already.", "tree": {"sha": "0e95faeb6f27c35303f18569c8d8229871a3afd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e95faeb6f27c35303f18569c8d8229871a3afd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b40a188cee5bef97526dfc271afbd2a98008183", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b40a188cee5bef97526dfc271afbd2a98008183", "html_url": "https://github.com/rust-lang/rust/commit/8b40a188cee5bef97526dfc271afbd2a98008183", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b40a188cee5bef97526dfc271afbd2a98008183/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84f729d0d4dade321210b78f56bedd88025eeff6", "url": "https://api.github.com/repos/rust-lang/rust/commits/84f729d0d4dade321210b78f56bedd88025eeff6", "html_url": "https://github.com/rust-lang/rust/commit/84f729d0d4dade321210b78f56bedd88025eeff6"}, {"sha": "cddb838043fb0201c09bf0a8692001b04b3bec1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cddb838043fb0201c09bf0a8692001b04b3bec1a", "html_url": "https://github.com/rust-lang/rust/commit/cddb838043fb0201c09bf0a8692001b04b3bec1a"}], "stats": {"total": 944, "additions": 781, "deletions": 163}, "files": [{"sha": "6b504056e5f879eb75705e88a0218824eced26ef", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 781, "deletions": 163, "changes": 944, "blob_url": "https://github.com/rust-lang/rust/blob/8b40a188cee5bef97526dfc271afbd2a98008183/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b40a188cee5bef97526dfc271afbd2a98008183/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=8b40a188cee5bef97526dfc271afbd2a98008183", "patch": "@@ -502,12 +502,19 @@ impl Ipv4Addr {\n     ///\n     /// The following return false:\n     ///\n-    /// - private address (10.0.0.0/8, 172.16.0.0/12 and 192.168.0.0/16)\n-    /// - the loopback address (127.0.0.0/8)\n-    /// - the link-local address (169.254.0.0/16)\n-    /// - the broadcast address (255.255.255.255/32)\n-    /// - test addresses used for documentation (192.0.2.0/24, 198.51.100.0/24 and 203.0.113.0/24)\n-    /// - the unspecified address (0.0.0.0)\n+    /// - private addresses (see [`is_private()`](#method.is_private))\n+    /// - the loopback address (see [`is_loopback()`](#method.is_loopback))\n+    /// - the link-local address (see [`is_link_local()`](#method.is_link_local))\n+    /// - the broadcast address (see [`is_broadcast()`](#method.is_broadcast))\n+    /// - addresses used for documentation (see [`is_documentation()`](#method.is_documentation))\n+    /// - the unspecified address (see [`is_unspecified()`](#method.is_unspecified)), and the whole\n+    ///   0.0.0.0/8 block\n+    /// - addresses reserved for future protocols (see\n+    /// [`is_ietf_protocol_assignment()`](#method.is_ietf_protocol_assignment), except\n+    /// `192.0.0.9/32` and `192.0.0.10/32` which are globally routable\n+    /// - addresses reserved for future use (see [`is_reserved()`](#method.is_reserved)\n+    /// - addresses reserved for networking devices benchmarking (see\n+    /// [`is_benchmarking`](#method.is_benchmarking))\n     ///\n     /// [ipv4-sr]: https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml\n     /// [`true`]: ../../std/primitive.bool.html\n@@ -520,16 +527,181 @@ impl Ipv4Addr {\n     /// use std::net::Ipv4Addr;\n     ///\n     /// fn main() {\n+    ///     // private addresses are not global\n     ///     assert_eq!(Ipv4Addr::new(10, 254, 0, 0).is_global(), false);\n     ///     assert_eq!(Ipv4Addr::new(192, 168, 10, 65).is_global(), false);\n     ///     assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_global(), false);\n+    ///\n+    ///     // the 0.0.0.0/8 block is not global\n+    ///     assert_eq!(Ipv4Addr::new(0, 1, 2, 3).is_global(), false);\n+    ///     // in particular, the unspecified address is not global\n     ///     assert_eq!(Ipv4Addr::new(0, 0, 0, 0).is_global(), false);\n+    ///\n+    ///     // the loopback address is not global\n+    ///     assert_eq!(Ipv4Addr::new(127, 0, 0, 1).is_global(), false);\n+    ///\n+    ///     // link local addresses are not global\n+    ///     assert_eq!(Ipv4Addr::new(169, 254, 45, 1).is_global(), false);\n+    ///\n+    ///     // the broadcast address is not global\n+    ///     assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_global(), false);\n+    ///\n+    ///     // the broadcast address is not global\n+    ///     assert_eq!(Ipv4Addr::new(192, 0, 2, 255).is_global(), false);\n+    ///     assert_eq!(Ipv4Addr::new(198, 51, 100, 65).is_global(), false);\n+    ///     assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_global(), false);\n+    ///\n+    ///     // shared addresses are not global\n+    ///     assert_eq!(Ipv4Addr::new(100, 100, 0, 0).is_global(), false);\n+    ///\n+    ///     // addresses reserved for protocol assignment are not global\n+    ///     assert_eq!(Ipv4Addr::new(192, 0, 0, 0).is_global(), false);\n+    ///     assert_eq!(Ipv4Addr::new(192, 0, 0, 255).is_global(), false);\n+    ///\n+    ///     // addresses reserved for future use are not global\n+    ///     assert_eq!(Ipv4Addr::new(250, 10, 20, 30).is_global(), false);\n+    ///\n+    ///     // addresses reserved for network devices benchmarking are not global\n+    ///     assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_global(), false);\n+    ///\n+    ///     // All the other addresses are global\n+    ///     assert_eq!(Ipv4Addr::new(1, 1, 1, 1).is_global(), true);\n     ///     assert_eq!(Ipv4Addr::new(80, 9, 12, 3).is_global(), true);\n     /// }\n     /// ```\n     pub fn is_global(&self) -> bool {\n-        !self.is_private() && !self.is_loopback() && !self.is_link_local() &&\n-        !self.is_broadcast() && !self.is_documentation() && !self.is_unspecified()\n+        // check if this address is 192.0.0.9 or 192.0.0.10. These addresses are the only two\n+        // globally routable addresses in the 192.0.0.0/24 range.\n+        if u32::from(*self) == 0xc0000009 || u32::from(*self) == 0xc000000a {\n+            return true;\n+        }\n+        !self.is_private()\n+            && !self.is_loopback()\n+            && !self.is_link_local()\n+            && !self.is_broadcast()\n+            && !self.is_documentation()\n+            && !self.is_shared()\n+            && !self.is_ietf_protocol_assignment()\n+            && !self.is_reserved()\n+            && !self.is_benchmarking()\n+            // Make sure the address is not in 0.0.0.0/8\n+            && self.octets()[0] != 0\n+    }\n+\n+    /// Returns [`true`] if this address is part of the Shared Address Space defined in\n+    /// [IETF RFC 6598] (`100.64.0.0/10`).\n+    ///\n+    /// [IETF RFC 6598]: https://tools.ietf.org/html/rfc6598\n+    /// [`true`]: ../../std/primitive.bool.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// fn main() {\n+    ///     assert_eq!(Ipv4Addr::new(100, 64, 0, 0).is_shared(), true);\n+    ///     assert_eq!(Ipv4Addr::new(100, 127, 255, 255).is_shared(), true);\n+    ///     assert_eq!(Ipv4Addr::new(100, 128, 0, 0).is_shared(), false);\n+    /// }\n+    /// ```\n+    pub fn is_shared(&self) -> bool {\n+        self.octets()[0] == 100 && (self.octets()[1] & 0b1100_0000 == 0b0100_0000)\n+    }\n+\n+    /// Returns [`true`] if this address is part of `192.0.0.0/24`, which is reserved to\n+    /// IANA for IETF protocol assignments, as documented in [IETF RFC 6890].\n+    ///\n+    /// Note that parts of this block are in use:\n+    ///\n+    /// - `192.0.0.8/32` is the \"IPv4 dummy address\" (see [IETF RFC 7600])\n+    /// - `192.0.0.9/32` is the \"Port Control Protocol Anycast\" (see [IETF RFC 7723])\n+    /// - `192.0.0.10/32` is used for NAT traversal (see [IETF RFC 8155])\n+    ///\n+    /// [IETF RFC 6890]: https://tools.ietf.org/html/rfc6890\n+    /// [IETF RFC 7600]: https://tools.ietf.org/html/rfc7600\n+    /// [IETF RFC 7723]: https://tools.ietf.org/html/rfc7723\n+    /// [IETF RFC 8155]: https://tools.ietf.org/html/rfc8155\n+    /// [`true`]: ../../std/primitive.bool.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// fn main() {\n+    ///     assert_eq!(Ipv4Addr::new(192, 0, 0, 0).is_ietf_protocol_assignment(), true);\n+    ///     assert_eq!(Ipv4Addr::new(192, 0, 0, 8).is_ietf_protocol_assignment(), true);\n+    ///     assert_eq!(Ipv4Addr::new(192, 0, 0, 9).is_ietf_protocol_assignment(), true);\n+    ///     assert_eq!(Ipv4Addr::new(192, 0, 0, 255).is_ietf_protocol_assignment(), true);\n+    ///     assert_eq!(Ipv4Addr::new(192, 0, 1, 0).is_ietf_protocol_assignment(), false);\n+    ///     assert_eq!(Ipv4Addr::new(191, 255, 255, 255).is_ietf_protocol_assignment(), false);\n+    /// }\n+    /// ```\n+    pub fn is_ietf_protocol_assignment(&self) -> bool {\n+        self.octets()[0] == 192 && self.octets()[1] == 0 && self.octets()[2] == 0\n+    }\n+\n+    /// Returns [`true`] if this address part of the `198.18.0.0/15` range, which is reserved for\n+    /// network devices benchmarking. This range is defined in [IETF RFC 2544] as `192.18.0.0`\n+    /// through `198.19.255.255` but [errata 423] corrects it to `198.18.0.0/15`.\n+    ///\n+    /// [IETF RFC 1112]: https://tools.ietf.org/html/rfc1112\n+    /// [errate 423]: https://www.rfc-editor.org/errata/eid423\n+    /// [`true`]: ../../std/primitive.bool.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// fn main() {\n+    ///     assert_eq!(Ipv4Addr::new(198, 17, 255, 255).is_benchmarking(), false);\n+    ///     assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_benchmarking(), true);\n+    ///     assert_eq!(Ipv4Addr::new(198, 19, 255, 255).is_benchmarking(), true);\n+    ///     assert_eq!(Ipv4Addr::new(198, 20, 0, 0).is_benchmarking(), false);\n+    /// }\n+    /// ```\n+    pub fn is_benchmarking(&self) -> bool {\n+        self.octets()[0] == 198 && (self.octets()[1] & 0xfe) == 18\n+    }\n+\n+    /// Returns [`true`] if this address is reserved by IANA for future use. [IETF RFC 1112]\n+    /// defines the block of reserved addresses as `240.0.0.0/4`. This range normally includes the\n+    /// broadcast address `255.255.255.255`, but this implementation explicitely excludes it, since\n+    /// it is obviously not reserved for future use.\n+    ///\n+    /// [IETF RFC 1112]: https://tools.ietf.org/html/rfc1112\n+    /// [`true`]: ../../std/primitive.bool.html\n+    ///\n+    /// # Warning\n+    ///\n+    /// As IANA assigns new addresses, this method will be\n+    /// updated. This may result in non-reserved addresses being\n+    /// treated as reserved in code that relies on an outdated version\n+    /// of this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// fn main() {\n+    ///     assert_eq!(Ipv4Addr::new(240, 0, 0, 0).is_reserved(), true);\n+    ///     assert_eq!(Ipv4Addr::new(255, 255, 255, 254).is_reserved(), true);\n+    ///\n+    ///     assert_eq!(Ipv4Addr::new(239, 255, 255, 255).is_reserved(), false);\n+    ///     // The broadcast address is not considered as reserved for future use by this\n+    ///     // implementation\n+    ///     assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_reserved(), false);\n+    /// }\n+    /// ```\n+    pub fn is_reserved(&self) -> bool {\n+        self.octets()[0] & 240 == 240 && !self.is_broadcast()\n     }\n \n     /// Returns [`true`] if this is a multicast address (224.0.0.0/4).\n@@ -1003,7 +1175,7 @@ impl Ipv6Addr {\n         }\n     }\n \n-    /// Returns [`true`] if this is a unique local address (fc00::/7).\n+    /// Returns [`true`] if this is a unique local address (`fc00::/7`).\n     ///\n     /// This property is defined in [IETF RFC 4193].\n     ///\n@@ -1027,12 +1199,83 @@ impl Ipv6Addr {\n         (self.segments()[0] & 0xfe00) == 0xfc00\n     }\n \n-    /// Returns [`true`] if the address is unicast and link-local (fe80::/10).\n+    /// Returns [`true`] if the address is a unicast link-local address (`fe80::/64`).\n     ///\n-    /// This property is defined in [IETF RFC 4291].\n+    /// A common mis-conception is to think that \"unicast link-local addresses start with\n+    /// `fe80::`\", but the [IETF RFC 4291] actually defines a stricter format for these addresses:\n+    ///\n+    /// ```no_rust\n+    /// |   10     |\n+    /// |  bits    |         54 bits         |          64 bits           |\n+    /// +----------+-------------------------+----------------------------+\n+    /// |1111111010|           0             |       interface ID         |\n+    /// +----------+-------------------------+----------------------------+\n+    /// ```\n+    ///\n+    /// This method validates the format defined in the RFC and won't recognize the following\n+    /// addresses such as `fe80:0:0:1::` or `fe81::` as unicast link-local addresses for example.\n+    /// If you need a less strict validation use [`is_unicast_link_local()`] instead.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// fn main() {\n+    ///     let ip = Ipv6Addr::new(0xfe80, 0, 0, 0, 0, 0, 0, 0);\n+    ///     assert!(ip.is_unicast_link_local_strict());\n+    ///\n+    ///     let ip = Ipv6Addr::new(0xfe80, 0, 0, 0, 0xffff, 0xffff, 0xffff, 0xffff);\n+    ///     assert!(ip.is_unicast_link_local_strict());\n+    ///\n+    ///     let ip = Ipv6Addr::new(0xfe80, 0, 0, 1, 0, 0, 0, 0);\n+    ///     assert!(!ip.is_unicast_link_local_strict());\n+    ///     assert!(ip.is_unicast_link_local());\n+    ///\n+    ///     let ip = Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 0);\n+    ///     assert!(!ip.is_unicast_link_local_strict());\n+    ///     assert!(ip.is_unicast_link_local());\n+    /// }\n+    /// ```\n+    ///\n+    /// # See also\n+    ///\n+    /// - [IETF RFC 4291 section 2.5.6]\n+    /// - [RFC 4291 errata 4406]\n+    /// - [`is_unicast_link_local()`]\n     ///\n     /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n+    /// [IETF RFC 4291 section 2.5.6]: https://tools.ietf.org/html/rfc4291#section-2.5.6\n     /// [`true`]: ../../std/primitive.bool.html\n+    /// [RFC 4291 errata 4406]: https://www.rfc-editor.org/errata/eid4406\n+    /// [`is_unicast_link_local()`]: ../../std/net/struct.Ipv6Addr.html#method.is_unicast_link_local\n+    ///\n+    pub fn is_unicast_link_local_strict(&self) -> bool {\n+        (self.segments()[0] & 0xffff) == 0xfe80\n+            && (self.segments()[1] & 0xffff) == 0\n+            && (self.segments()[2] & 0xffff) == 0\n+            && (self.segments()[3] & 0xffff) == 0\n+    }\n+\n+    /// Returns [`true`] if the address is a unicast link-local address (`fe80::/10`).\n+    ///\n+    /// This method returns [`true`] for addresses in the range reserved by [RFC 4291 section 2.4],\n+    /// i.e. addresses with the following format:\n+    ///\n+    /// ```no_rust\n+    /// |   10     |\n+    /// |  bits    |         54 bits         |          64 bits           |\n+    /// +----------+-------------------------+----------------------------+\n+    /// |1111111010|    arbitratry value     |       interface ID         |\n+    /// +----------+-------------------------+----------------------------+\n+    /// ```\n+    ///\n+    /// As a result, this method consider addresses such as `fe80:0:0:1::` or `fe81::` to be\n+    /// unicast link-local addresses, whereas [`is_unicast_link_local_strict()`] does not. If you\n+    /// need a strict validation fully compliant with the RFC, use\n+    /// [`is_unicast_link_local_strict()`].\n     ///\n     /// # Examples\n     ///\n@@ -1042,19 +1285,49 @@ impl Ipv6Addr {\n     /// use std::net::Ipv6Addr;\n     ///\n     /// fn main() {\n-    ///     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unicast_link_local(),\n-    ///                false);\n-    ///     assert_eq!(Ipv6Addr::new(0xfe8a, 0, 0, 0, 0, 0, 0, 0).is_unicast_link_local(), true);\n+    ///     let ip = Ipv6Addr::new(0xfe80, 0, 0, 0, 0, 0, 0, 0);\n+    ///     assert!(ip.is_unicast_link_local());\n+    ///\n+    ///     let ip = Ipv6Addr::new(0xfe80, 0, 0, 0, 0xffff, 0xffff, 0xffff, 0xffff);\n+    ///     assert!(ip.is_unicast_link_local());\n+    ///\n+    ///     let ip = Ipv6Addr::new(0xfe80, 0, 0, 1, 0, 0, 0, 0);\n+    ///     assert!(ip.is_unicast_link_local());\n+    ///     assert!(!ip.is_unicast_link_local_strict());\n+    ///\n+    ///     let ip = Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 0);\n+    ///     assert!(ip.is_unicast_link_local());\n+    ///     assert!(!ip.is_unicast_link_local_strict());\n     /// }\n     /// ```\n+    ///\n+    /// # See also\n+    ///\n+    /// - [IETF RFC 4291 section 2.4]\n+    /// - [RFC 4291 errata 4406]\n+    ///\n+    /// [IETF RFC 4291 section 2.4]: https://tools.ietf.org/html/rfc4291#section-2.4\n+    /// [`true`]: ../../std/primitive.bool.html\n+    /// [RFC 4291 errata 4406]: https://www.rfc-editor.org/errata/eid4406\n+    /// [`is_unicast_link_local_strict()`]: ../../std/net/struct.Ipv6Addr.html#method.is_unicast_link_local_strict\n+    ///\n     pub fn is_unicast_link_local(&self) -> bool {\n         (self.segments()[0] & 0xffc0) == 0xfe80\n     }\n \n-    /// Returns [`true`] if this is a deprecated unicast site-local address\n-    /// (fec0::/10).\n+    /// Returns [`true`] if this is a deprecated unicast site-local address (fec0::/10). The\n+    /// unicast site-local address format is defined in [RFC 4291 section 2.5.7] as:\n+    ///\n+    /// ```no_rust\n+    /// |   10     |\n+    /// |  bits    |         54 bits         |         64 bits            |\n+    /// +----------+-------------------------+----------------------------+\n+    /// |1111111011|        subnet ID        |       interface ID         |\n+    /// +----------+-------------------------+----------------------------+\n+    /// ```\n     ///\n     /// [`true`]: ../../std/primitive.bool.html\n+    /// [RFC 4291 section 2.5.7]: https://tools.ietf.org/html/rfc4291#section-2.5.7\n     ///\n     /// # Examples\n     ///\n@@ -1069,6 +1342,14 @@ impl Ipv6Addr {\n     ///     assert_eq!(Ipv6Addr::new(0xfec2, 0, 0, 0, 0, 0, 0, 0).is_unicast_site_local(), true);\n     /// }\n     /// ```\n+    ///\n+    /// # Warning\n+    ///\n+    /// As per [RFC 3879], the whole `FEC0::/10` prefix is\n+    /// deprecated. New software must not support site-local\n+    /// addresses.\n+    ///\n+    /// [RFC 3879]: https://tools.ietf.org/html/rfc3879\n     pub fn is_unicast_site_local(&self) -> bool {\n         (self.segments()[0] & 0xffc0) == 0xfec0\n     }\n@@ -1104,12 +1385,20 @@ impl Ipv6Addr {\n     ///\n     /// - the loopback address\n     /// - the link-local addresses\n-    /// - the (deprecated) site-local addresses\n     /// - unique local addresses\n     /// - the unspecified address\n     /// - the address range reserved for documentation\n     ///\n+    /// This method returns [`true`] for site-local addresses as per [RFC 4291 section 2.5.7]\n+    ///\n+    /// ```no_rust\n+    /// The special behavior of [the site-local unicast] prefix defined in [RFC3513] must no longer\n+    /// be supported in new implementations (i.e., new implementations must treat this prefix as\n+    /// Global Unicast).\n+    /// ```\n+    ///\n     /// [`true`]: ../../std/primitive.bool.html\n+    /// [RFC 4291 section 2.5.7]: https://tools.ietf.org/html/rfc4291#section-2.5.7\n     ///\n     /// # Examples\n     ///\n@@ -1126,9 +1415,11 @@ impl Ipv6Addr {\n     /// ```\n     pub fn is_unicast_global(&self) -> bool {\n         !self.is_multicast()\n-            && !self.is_loopback() && !self.is_unicast_link_local()\n-            && !self.is_unicast_site_local() && !self.is_unique_local()\n-            && !self.is_unspecified() && !self.is_documentation()\n+            && !self.is_loopback()\n+            && !self.is_unicast_link_local()\n+            && !self.is_unique_local()\n+            && !self.is_unspecified()\n+            && !self.is_documentation()\n     }\n \n     /// Returns the address's multicast scope if the address is multicast.\n@@ -1510,8 +1801,8 @@ impl From<[u16; 8]> for IpAddr {\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n     use crate::net::*;\n-    use crate::net::Ipv6MulticastScope::*;\n     use crate::net::test::{tsa, sa6, sa4};\n+    use crate::str::FromStr;\n \n     #[test]\n     fn test_from_str_ipv4() {\n@@ -1675,164 +1966,491 @@ mod tests {\n \n     #[test]\n     fn ip_properties() {\n-        fn check4(octets: &[u8; 4], unspec: bool, loopback: bool,\n-                  global: bool, multicast: bool, documentation: bool) {\n-            let ip = IpAddr::V4(Ipv4Addr::new(octets[0], octets[1], octets[2], octets[3]));\n-            assert_eq!(ip.is_unspecified(), unspec);\n-            assert_eq!(ip.is_loopback(), loopback);\n-            assert_eq!(ip.is_global(), global);\n-            assert_eq!(ip.is_multicast(), multicast);\n-            assert_eq!(ip.is_documentation(), documentation);\n+        macro_rules! ip {\n+            ($s:expr) => {\n+                IpAddr::from_str($s).unwrap()\n+            }\n         }\n \n-        fn check6(str_addr: &str, unspec: bool, loopback: bool,\n-                  global: bool, u_doc: bool, mcast: bool) {\n-            let ip = IpAddr::V6(str_addr.parse().unwrap());\n-            assert_eq!(ip.is_unspecified(), unspec);\n-            assert_eq!(ip.is_loopback(), loopback);\n-            assert_eq!(ip.is_global(), global);\n-            assert_eq!(ip.is_documentation(), u_doc);\n-            assert_eq!(ip.is_multicast(), mcast);\n+        macro_rules! check {\n+            ($s:expr) => {\n+                check!($s, 0);\n+            };\n+\n+            ($s:expr, $mask:expr) => {{\n+                let unspec: u8 = 1 << 0;\n+                let loopback: u8 = 1 << 1;\n+                let global: u8 = 1 << 2;\n+                let multicast: u8 = 1 << 3;\n+                let doc: u8 = 1 << 4;\n+\n+                if ($mask & unspec) == unspec {\n+                    assert!(ip!($s).is_unspecified());\n+                } else {\n+                    assert!(!ip!($s).is_unspecified());\n+                }\n+\n+                if ($mask & loopback) == loopback {\n+                    assert!(ip!($s).is_loopback());\n+                } else {\n+                    assert!(!ip!($s).is_loopback());\n+                }\n+\n+                if ($mask & global) == global {\n+                    assert!(ip!($s).is_global());\n+                } else {\n+                    assert!(!ip!($s).is_global());\n+                }\n+\n+                if ($mask & multicast) == multicast {\n+                    assert!(ip!($s).is_multicast());\n+                } else {\n+                    assert!(!ip!($s).is_multicast());\n+                }\n+\n+                if ($mask & doc) == doc {\n+                    assert!(ip!($s).is_documentation());\n+                } else {\n+                    assert!(!ip!($s).is_documentation());\n+                }\n+            }}\n         }\n \n-        //     address                unspec loopbk global multicast doc\n-        check4(&[0, 0, 0, 0],         true,  false, false,  false,   false);\n-        check4(&[0, 0, 0, 1],         false, false, true,   false,   false);\n-        check4(&[0, 1, 0, 0],         false, false, true,   false,   false);\n-        check4(&[10, 9, 8, 7],        false, false, false,  false,   false);\n-        check4(&[127, 1, 2, 3],       false, true,  false,  false,   false);\n-        check4(&[172, 31, 254, 253],  false, false, false,  false,   false);\n-        check4(&[169, 254, 253, 242], false, false, false,  false,   false);\n-        check4(&[192, 0, 2, 183],     false, false, false,  false,   true);\n-        check4(&[192, 1, 2, 183],     false, false, true,   false,   false);\n-        check4(&[192, 168, 254, 253], false, false, false,  false,   false);\n-        check4(&[198, 51, 100, 0],    false, false, false,  false,   true);\n-        check4(&[203, 0, 113, 0],     false, false, false,  false,   true);\n-        check4(&[203, 2, 113, 0],     false, false, true,   false,   false);\n-        check4(&[224, 0, 0, 0],       false, false, true,   true,    false);\n-        check4(&[239, 255, 255, 255], false, false, true,   true,    false);\n-        check4(&[255, 255, 255, 255], false, false, false,  false,   false);\n-\n-        //     address                            unspec loopbk global doc    mcast\n-        check6(\"::\",                              true,  false, false, false, false);\n-        check6(\"::1\",                             false, true,  false, false, false);\n-        check6(\"::0.0.0.2\",                       false, false, true,  false, false);\n-        check6(\"1::\",                             false, false, true,  false, false);\n-        check6(\"fc00::\",                          false, false, false, false, false);\n-        check6(\"fdff:ffff::\",                     false, false, false, false, false);\n-        check6(\"fe80:ffff::\",                     false, false, false, false, false);\n-        check6(\"febf:ffff::\",                     false, false, false, false, false);\n-        check6(\"fec0::\",                          false, false, false, false, false);\n-        check6(\"ff01::\",                          false, false, false, false, true);\n-        check6(\"ff02::\",                          false, false, false, false, true);\n-        check6(\"ff03::\",                          false, false, false, false, true);\n-        check6(\"ff04::\",                          false, false, false, false, true);\n-        check6(\"ff05::\",                          false, false, false, false, true);\n-        check6(\"ff08::\",                          false, false, false, false, true);\n-        check6(\"ff0e::\",                          false, false, true,  false, true);\n-        check6(\"2001:db8:85a3::8a2e:370:7334\",    false, false, false, true,  false);\n-        check6(\"102:304:506:708:90a:b0c:d0e:f10\", false, false, true,  false, false);\n+        let unspec: u8 = 1 << 0;\n+        let loopback: u8 = 1 << 1;\n+        let global: u8 = 1 << 2;\n+        let multicast: u8 = 1 << 3;\n+        let doc: u8 = 1 << 4;\n+\n+        check!(\"0.0.0.0\", unspec);\n+        check!(\"0.0.0.1\");\n+        check!(\"0.1.0.0\");\n+        check!(\"10.9.8.7\");\n+        check!(\"127.1.2.3\", loopback);\n+        check!(\"172.31.254.253\");\n+        check!(\"169.254.253.242\");\n+        check!(\"192.0.2.183\", doc);\n+        check!(\"192.1.2.183\", global);\n+        check!(\"192.168.254.253\");\n+        check!(\"198.51.100.0\", doc);\n+        check!(\"203.0.113.0\", doc);\n+        check!(\"203.2.113.0\", global);\n+        check!(\"224.0.0.0\", global|multicast);\n+        check!(\"239.255.255.255\", global|multicast);\n+        check!(\"255.255.255.255\");\n+        // make sure benchmarking addresses are not global\n+        check!(\"198.18.0.0\");\n+        check!(\"198.18.54.2\");\n+        check!(\"198.19.255.255\");\n+        // make sure addresses reserved for protocol assignment are not global\n+        check!(\"192.0.0.0\");\n+        check!(\"192.0.0.255\");\n+        check!(\"192.0.0.100\");\n+        // make sure reserved addresses are not global\n+        check!(\"240.0.0.0\");\n+        check!(\"251.54.1.76\");\n+        check!(\"254.255.255.255\");\n+        // make sure shared addresses are not global\n+        check!(\"100.64.0.0\");\n+        check!(\"100.127.255.255\");\n+        check!(\"100.100.100.0\");\n+\n+        check!(\"::\", unspec);\n+        check!(\"::1\", loopback);\n+        check!(\"::0.0.0.2\", global);\n+        check!(\"1::\", global);\n+        check!(\"fc00::\");\n+        check!(\"fdff:ffff::\");\n+        check!(\"fe80:ffff::\");\n+        check!(\"febf:ffff::\");\n+        check!(\"fec0::\", global);\n+        check!(\"ff01::\", multicast);\n+        check!(\"ff02::\", multicast);\n+        check!(\"ff03::\", multicast);\n+        check!(\"ff04::\", multicast);\n+        check!(\"ff05::\", multicast);\n+        check!(\"ff08::\", multicast);\n+        check!(\"ff0e::\", global|multicast);\n+        check!(\"2001:db8:85a3::8a2e:370:7334\", doc);\n+        check!(\"102:304:506:708:90a:b0c:d0e:f10\", global);\n     }\n \n     #[test]\n     fn ipv4_properties() {\n-        fn check(octets: &[u8; 4], unspec: bool, loopback: bool,\n-                 private: bool, link_local: bool, global: bool,\n-                 multicast: bool, broadcast: bool, documentation: bool) {\n-            let ip = Ipv4Addr::new(octets[0], octets[1], octets[2], octets[3]);\n-            assert_eq!(octets, &ip.octets());\n-\n-            assert_eq!(ip.is_unspecified(), unspec);\n-            assert_eq!(ip.is_loopback(), loopback);\n-            assert_eq!(ip.is_private(), private);\n-            assert_eq!(ip.is_link_local(), link_local);\n-            assert_eq!(ip.is_global(), global);\n-            assert_eq!(ip.is_multicast(), multicast);\n-            assert_eq!(ip.is_broadcast(), broadcast);\n-            assert_eq!(ip.is_documentation(), documentation);\n+        macro_rules! ip {\n+            ($s:expr) => {\n+                Ipv4Addr::from_str($s).unwrap()\n+            }\n         }\n \n-        //    address                unspec loopbk privt  linloc global multicast brdcast doc\n-        check(&[0, 0, 0, 0],         true,  false, false, false, false,  false,    false,  false);\n-        check(&[0, 0, 0, 1],         false, false, false, false, true,   false,    false,  false);\n-        check(&[0, 1, 0, 0],         false, false, false, false, true,   false,    false,  false);\n-        check(&[10, 9, 8, 7],        false, false, true,  false, false,  false,    false,  false);\n-        check(&[127, 1, 2, 3],       false, true,  false, false, false,  false,    false,  false);\n-        check(&[172, 31, 254, 253],  false, false, true,  false, false,  false,    false,  false);\n-        check(&[169, 254, 253, 242], false, false, false, true,  false,  false,    false,  false);\n-        check(&[192, 0, 2, 183],     false, false, false, false, false,  false,    false,  true);\n-        check(&[192, 1, 2, 183],     false, false, false, false, true,   false,    false,  false);\n-        check(&[192, 168, 254, 253], false, false, true,  false, false,  false,    false,  false);\n-        check(&[198, 51, 100, 0],    false, false, false, false, false,  false,    false,  true);\n-        check(&[203, 0, 113, 0],     false, false, false, false, false,  false,    false,  true);\n-        check(&[203, 2, 113, 0],     false, false, false, false, true,   false,    false,  false);\n-        check(&[224, 0, 0, 0],       false, false, false, false, true,   true,     false,  false);\n-        check(&[239, 255, 255, 255], false, false, false, false, true,   true,     false,  false);\n-        check(&[255, 255, 255, 255], false, false, false, false, false,  false,    true,   false);\n+        macro_rules! check {\n+            ($s:expr) => {\n+                check!($s, 0);\n+            };\n+\n+            ($s:expr, $mask:expr) => {{\n+                let unspec: u16 = 1 << 0;\n+                let loopback: u16 = 1 << 1;\n+                let private: u16 = 1 << 2;\n+                let link_local: u16 = 1 << 3;\n+                let global: u16 = 1 << 4;\n+                let multicast: u16 = 1 << 5;\n+                let broadcast: u16 = 1 << 6;\n+                let documentation: u16 = 1 << 7;\n+                let benchmarking: u16 = 1 << 8;\n+                let ietf_protocol_assignment: u16 = 1 << 9;\n+                let reserved: u16 = 1 << 10;\n+                let shared: u16 = 1 << 11;\n+\n+                if ($mask & unspec) == unspec {\n+                    assert!(ip!($s).is_unspecified());\n+                } else {\n+                    assert!(!ip!($s).is_unspecified());\n+                }\n+\n+                if ($mask & loopback) == loopback {\n+                    assert!(ip!($s).is_loopback());\n+                } else {\n+                    assert!(!ip!($s).is_loopback());\n+                }\n+\n+                if ($mask & private) == private {\n+                    assert!(ip!($s).is_private());\n+                } else {\n+                    assert!(!ip!($s).is_private());\n+                }\n+\n+                if ($mask & link_local) == link_local {\n+                    assert!(ip!($s).is_link_local());\n+                } else {\n+                    assert!(!ip!($s).is_link_local());\n+                }\n+\n+                if ($mask & global) == global {\n+                    assert!(ip!($s).is_global());\n+                } else {\n+                    assert!(!ip!($s).is_global());\n+                }\n+\n+                if ($mask & multicast) == multicast {\n+                    assert!(ip!($s).is_multicast());\n+                } else {\n+                    assert!(!ip!($s).is_multicast());\n+                }\n+\n+                if ($mask & broadcast) == broadcast {\n+                    assert!(ip!($s).is_broadcast());\n+                } else {\n+                    assert!(!ip!($s).is_broadcast());\n+                }\n+\n+                if ($mask & documentation) == documentation {\n+                    assert!(ip!($s).is_documentation());\n+                } else {\n+                    assert!(!ip!($s).is_documentation());\n+                }\n+\n+                if ($mask & benchmarking) == benchmarking {\n+                    assert!(ip!($s).is_benchmarking());\n+                } else {\n+                    assert!(!ip!($s).is_benchmarking());\n+                }\n+\n+                if ($mask & ietf_protocol_assignment) == ietf_protocol_assignment {\n+                    assert!(ip!($s).is_ietf_protocol_assignment());\n+                } else {\n+                    assert!(!ip!($s).is_ietf_protocol_assignment());\n+                }\n+\n+                if ($mask & reserved) == reserved {\n+                    assert!(ip!($s).is_reserved());\n+                } else {\n+                    assert!(!ip!($s).is_reserved());\n+                }\n+\n+                if ($mask & shared) == shared {\n+                    assert!(ip!($s).is_shared());\n+                } else {\n+                    assert!(!ip!($s).is_shared());\n+                }\n+            }}\n+        }\n+\n+        let unspec: u16 = 1 << 0;\n+        let loopback: u16 = 1 << 1;\n+        let private: u16 = 1 << 2;\n+        let link_local: u16 = 1 << 3;\n+        let global: u16 = 1 << 4;\n+        let multicast: u16 = 1 << 5;\n+        let broadcast: u16 = 1 << 6;\n+        let documentation: u16 = 1 << 7;\n+        let benchmarking: u16 = 1 << 8;\n+        let ietf_protocol_assignment: u16 = 1 << 9;\n+        let reserved: u16 = 1 << 10;\n+        let shared: u16 = 1 << 11;\n+\n+        check!(\"0.0.0.0\", unspec);\n+        check!(\"0.0.0.1\");\n+        check!(\"0.1.0.0\");\n+        check!(\"10.9.8.7\", private);\n+        check!(\"127.1.2.3\", loopback);\n+        check!(\"172.31.254.253\", private);\n+        check!(\"169.254.253.242\", link_local);\n+        check!(\"192.0.2.183\", documentation);\n+        check!(\"192.1.2.183\", global);\n+        check!(\"192.168.254.253\", private);\n+        check!(\"198.51.100.0\", documentation);\n+        check!(\"203.0.113.0\", documentation);\n+        check!(\"203.2.113.0\", global);\n+        check!(\"224.0.0.0\", global|multicast);\n+        check!(\"239.255.255.255\", global|multicast);\n+        check!(\"255.255.255.255\", broadcast);\n+        check!(\"198.18.0.0\", benchmarking);\n+        check!(\"198.18.54.2\", benchmarking);\n+        check!(\"198.19.255.255\", benchmarking);\n+        check!(\"192.0.0.0\", ietf_protocol_assignment);\n+        check!(\"192.0.0.255\", ietf_protocol_assignment);\n+        check!(\"192.0.0.100\", ietf_protocol_assignment);\n+        check!(\"240.0.0.0\", reserved);\n+        check!(\"251.54.1.76\", reserved);\n+        check!(\"254.255.255.255\", reserved);\n+        check!(\"100.64.0.0\", shared);\n+        check!(\"100.127.255.255\", shared);\n+        check!(\"100.100.100.0\", shared);\n     }\n \n     #[test]\n     fn ipv6_properties() {\n-        fn check(str_addr: &str, octets: &[u8; 16], unspec: bool, loopback: bool,\n-                 unique_local: bool, global: bool,\n-                 u_link_local: bool, u_site_local: bool, u_global: bool, u_doc: bool,\n-                 m_scope: Option<Ipv6MulticastScope>) {\n-            let ip: Ipv6Addr = str_addr.parse().unwrap();\n-            assert_eq!(str_addr, ip.to_string());\n-            assert_eq!(&ip.octets(), octets);\n-            assert_eq!(Ipv6Addr::from(*octets), ip);\n-\n-            assert_eq!(ip.is_unspecified(), unspec);\n-            assert_eq!(ip.is_loopback(), loopback);\n-            assert_eq!(ip.is_unique_local(), unique_local);\n-            assert_eq!(ip.is_global(), global);\n-            assert_eq!(ip.is_unicast_link_local(), u_link_local);\n-            assert_eq!(ip.is_unicast_site_local(), u_site_local);\n-            assert_eq!(ip.is_unicast_global(), u_global);\n-            assert_eq!(ip.is_documentation(), u_doc);\n-            assert_eq!(ip.multicast_scope(), m_scope);\n-            assert_eq!(ip.is_multicast(), m_scope.is_some());\n+        macro_rules! ip {\n+            ($s:expr) => {\n+                Ipv6Addr::from_str($s).unwrap()\n+            }\n+        }\n+\n+        macro_rules! check {\n+            ($s:expr, &[$($octet:expr),*], $mask:expr) => {\n+                assert_eq!($s, ip!($s).to_string());\n+                let octets = &[$($octet),*];\n+                assert_eq!(&ip!($s).octets(), octets);\n+                assert_eq!(Ipv6Addr::from(*octets), ip!($s));\n+\n+                let unspecified: u16 = 1 << 0;\n+                let loopback: u16 = 1 << 1;\n+                let unique_local: u16 = 1 << 2;\n+                let global: u16 = 1 << 3;\n+                let unicast_link_local: u16 = 1 << 4;\n+                let unicast_link_local_strict: u16 = 1 << 5;\n+                let unicast_site_local: u16 = 1 << 6;\n+                let unicast_global: u16 = 1 << 7;\n+                let documentation: u16 = 1 << 8;\n+                let multicast_interface_local: u16 = 1 << 9;\n+                let multicast_link_local: u16 = 1 << 10;\n+                let multicast_realm_local: u16 = 1 << 11;\n+                let multicast_admin_local: u16 = 1 << 12;\n+                let multicast_site_local: u16 = 1 << 13;\n+                let multicast_organization_local: u16 = 1 << 14;\n+                let multicast_global: u16 = 1 << 15;\n+                let multicast: u16 = multicast_interface_local\n+                    | multicast_admin_local\n+                    | multicast_global\n+                    | multicast_link_local\n+                    | multicast_realm_local\n+                    | multicast_site_local\n+                    | multicast_organization_local;\n+\n+                if ($mask & unspecified) == unspecified {\n+                    assert!(ip!($s).is_unspecified());\n+                } else {\n+                    assert!(!ip!($s).is_unspecified());\n+                }\n+                if ($mask & loopback) == loopback {\n+                    assert!(ip!($s).is_loopback());\n+                } else {\n+                    assert!(!ip!($s).is_loopback());\n+                }\n+                if ($mask & unique_local) == unique_local {\n+                    assert!(ip!($s).is_unique_local());\n+                } else {\n+                    assert!(!ip!($s).is_unique_local());\n+                }\n+                if ($mask & global) == global {\n+                    assert!(ip!($s).is_global());\n+                } else {\n+                    assert!(!ip!($s).is_global());\n+                }\n+                if ($mask & unicast_link_local) == unicast_link_local {\n+                    assert!(ip!($s).is_unicast_link_local());\n+                } else {\n+                    assert!(!ip!($s).is_unicast_link_local());\n+                }\n+                if ($mask & unicast_link_local_strict) == unicast_link_local_strict {\n+                    assert!(ip!($s).is_unicast_link_local_strict());\n+                } else {\n+                    assert!(!ip!($s).is_unicast_link_local_strict());\n+                }\n+                if ($mask & unicast_site_local) == unicast_site_local {\n+                    assert!(ip!($s).is_unicast_site_local());\n+                } else {\n+                    assert!(!ip!($s).is_unicast_site_local());\n+                }\n+                if ($mask & unicast_global) == unicast_global {\n+                    assert!(ip!($s).is_unicast_global());\n+                } else {\n+                    assert!(!ip!($s).is_unicast_global());\n+                }\n+                if ($mask & documentation) == documentation {\n+                    assert!(ip!($s).is_documentation());\n+                } else {\n+                    assert!(!ip!($s).is_documentation());\n+                }\n+                if ($mask & multicast) != 0 {\n+                    assert!(ip!($s).multicast_scope().is_some());\n+                    assert!(ip!($s).is_multicast());\n+                } else {\n+                    assert!(ip!($s).multicast_scope().is_none());\n+                    assert!(!ip!($s).is_multicast());\n+                }\n+                if ($mask & multicast_interface_local) == multicast_interface_local {\n+                    assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                               Ipv6MulticastScope::InterfaceLocal);\n+                }\n+                if ($mask & multicast_link_local) == multicast_link_local {\n+                    assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                               Ipv6MulticastScope::LinkLocal);\n+                }\n+                if ($mask & multicast_realm_local) == multicast_realm_local {\n+                    assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                               Ipv6MulticastScope::RealmLocal);\n+                }\n+                if ($mask & multicast_admin_local) == multicast_admin_local {\n+                    assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                               Ipv6MulticastScope::AdminLocal);\n+                }\n+                if ($mask & multicast_site_local) == multicast_site_local {\n+                    assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                               Ipv6MulticastScope::SiteLocal);\n+                }\n+                if ($mask & multicast_organization_local) == multicast_organization_local {\n+                    assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                               Ipv6MulticastScope::OrganizationLocal);\n+                }\n+                if ($mask & multicast_global) == multicast_global {\n+                    assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                               Ipv6MulticastScope::Global);\n+                }\n+            }\n         }\n \n-        //    unspec loopbk uniqlo global unill  unisl  uniglo doc    mscope\n-        check(\"::\", &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-              true,  false, false, false, false, false, false, false, None);\n-        check(\"::1\", &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n-              false, true,  false, false, false, false, false, false, None);\n-        check(\"::0.0.0.2\", &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],\n-              false, false, false, true,  false, false, true,  false, None);\n-        check(\"1::\", &[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-              false, false, false, true,  false, false, true,  false, None);\n-        check(\"fc00::\", &[0xfc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-              false, false, true,  false, false, false, false, false, None);\n-        check(\"fdff:ffff::\", &[0xfd, 0xff, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-              false, false, true,  false, false, false, false, false, None);\n-        check(\"fe80:ffff::\", &[0xfe, 0x80, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-              false, false, false, false, true,  false, false, false, None);\n-        check(\"febf:ffff::\", &[0xfe, 0xbf, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-              false, false, false, false, true,  false, false, false, None);\n-        check(\"fec0::\", &[0xfe, 0xc0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-              false, false, false, false, false, true,  false, false, None);\n-        check(\"ff01::\", &[0xff, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-              false, false, false, false, false, false, false, false, Some(InterfaceLocal));\n-        check(\"ff02::\", &[0xff, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-              false, false, false, false, false, false, false, false, Some(LinkLocal));\n-        check(\"ff03::\", &[0xff, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-              false, false, false, false, false, false, false, false, Some(RealmLocal));\n-        check(\"ff04::\", &[0xff, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-              false, false, false, false, false, false, false, false, Some(AdminLocal));\n-        check(\"ff05::\", &[0xff, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-              false, false, false, false, false, false, false, false, Some(SiteLocal));\n-        check(\"ff08::\", &[0xff, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-              false, false, false, false, false, false, false, false, Some(OrganizationLocal));\n-        check(\"ff0e::\", &[0xff, 0xe, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-              false, false, false, true,  false, false, false, false, Some(Global));\n-        check(\"2001:db8:85a3::8a2e:370:7334\",\n-              &[0x20, 1, 0xd, 0xb8, 0x85, 0xa3, 0, 0, 0, 0, 0x8a, 0x2e, 3, 0x70, 0x73, 0x34],\n-              false, false, false, false, false, false, false, true, None);\n-        check(\"102:304:506:708:90a:b0c:d0e:f10\",\n-              &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n-              false, false, false, true,  false, false, true,  false, None);\n+        let unspecified: u16 = 1 << 0;\n+        let loopback: u16 = 1 << 1;\n+        let unique_local: u16 = 1 << 2;\n+        let global: u16 = 1 << 3;\n+        let unicast_link_local: u16 = 1 << 4;\n+        let unicast_link_local_strict: u16 = 1 << 5;\n+        let unicast_site_local: u16 = 1 << 6;\n+        let unicast_global: u16 = 1 << 7;\n+        let documentation: u16 = 1 << 8;\n+        let multicast_interface_local: u16 = 1 << 9;\n+        let multicast_link_local: u16 = 1 << 10;\n+        let multicast_realm_local: u16 = 1 << 11;\n+        let multicast_admin_local: u16 = 1 << 12;\n+        let multicast_site_local: u16 = 1 << 13;\n+        let multicast_organization_local: u16 = 1 << 14;\n+        let multicast_global: u16 = 1 << 15;\n+\n+        check!(\"::\",\n+               &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+               unspecified);\n+\n+        check!(\"::1\",\n+               &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n+               loopback);\n+\n+        check!(\"::0.0.0.2\",\n+               &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],\n+               global | unicast_global);\n+\n+        check!(\"1::\",\n+               &[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+               global | unicast_global);\n+\n+        check!(\"fc00::\",\n+               &[0xfc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+               unique_local);\n+\n+        check!(\"fdff:ffff::\",\n+               &[0xfd, 0xff, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+               unique_local);\n+\n+        check!(\"fe80:ffff::\",\n+               &[0xfe, 0x80, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+               unicast_link_local);\n+\n+        check!(\"fe80::\",\n+               &[0xfe, 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+               unicast_link_local|unicast_link_local_strict);\n+\n+        check!(\"febf:ffff::\",\n+               &[0xfe, 0xbf, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+               unicast_link_local);\n+\n+        check!(\"febf::\",\n+               &[0xfe, 0xbf, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+               unicast_link_local);\n+\n+        check!(\"febf:ffff:ffff:ffff:ffff:ffff:ffff:ffff\",\n+               &[0xfe, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+                 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff],\n+               unicast_link_local);\n+\n+        check!(\"fe80::ffff:ffff:ffff:ffff\",\n+               &[0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+                 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff],\n+               unicast_link_local|unicast_link_local_strict);\n+\n+        check!(\"fe80:0:0:1::\",\n+               &[0xfe, 0x80, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n+               unicast_link_local);\n+\n+        check!(\"fec0::\",\n+               &[0xfe, 0xc0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+               unicast_site_local|unicast_global|global);\n+\n+        check!(\"ff01::\",\n+               &[0xff, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+               multicast_interface_local);\n+\n+        check!(\"ff02::\",\n+               &[0xff, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+               multicast_link_local);\n+\n+        check!(\"ff03::\",\n+               &[0xff, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+               multicast_realm_local);\n+\n+        check!(\"ff04::\",\n+               &[0xff, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+               multicast_admin_local);\n+\n+        check!(\"ff05::\",\n+               &[0xff, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+               multicast_site_local);\n+\n+        check!(\"ff08::\",\n+               &[0xff, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+               multicast_organization_local);\n+\n+        check!(\"ff0e::\",\n+               &[0xff, 0xe, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+               multicast_global | global);\n+\n+        check!(\"2001:db8:85a3::8a2e:370:7334\",\n+               &[0x20, 1, 0xd, 0xb8, 0x85, 0xa3, 0, 0, 0, 0, 0x8a, 0x2e, 3, 0x70, 0x73, 0x34],\n+               documentation);\n+\n+        check!(\"102:304:506:708:90a:b0c:d0e:f10\",\n+               &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n+               global| unicast_global);\n     }\n \n     #[test]"}]}