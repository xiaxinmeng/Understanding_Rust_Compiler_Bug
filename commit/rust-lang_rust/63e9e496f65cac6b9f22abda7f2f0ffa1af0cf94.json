{"sha": "63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzZTllNDk2ZjY1Y2FjNmI5ZjIyYWJkYTdmMmYwZmZhMWFmMGNmOTQ=", "commit": {"author": {"name": "Benjamin Herr", "email": "ben@0x539.de", "date": "2013-10-11T13:55:37Z"}, "committer": {"name": "Benjamin Herr", "email": "ben@0x539.de", "date": "2013-10-11T13:55:37Z"}, "message": "extra::tempfile: replace mkdtemp with an RAII wrapper\n\nthis incidentally stops `make check` from leaving directories in `/tmp`", "tree": {"sha": "25ba34476090f29fdd14838e84c94ee0b61f40d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25ba34476090f29fdd14838e84c94ee0b61f40d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94", "html_url": "https://github.com/rust-lang/rust/commit/63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94/comments", "author": {"login": "ben0x539", "id": 24142, "node_id": "MDQ6VXNlcjI0MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/24142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ben0x539", "html_url": "https://github.com/ben0x539", "followers_url": "https://api.github.com/users/ben0x539/followers", "following_url": "https://api.github.com/users/ben0x539/following{/other_user}", "gists_url": "https://api.github.com/users/ben0x539/gists{/gist_id}", "starred_url": "https://api.github.com/users/ben0x539/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ben0x539/subscriptions", "organizations_url": "https://api.github.com/users/ben0x539/orgs", "repos_url": "https://api.github.com/users/ben0x539/repos", "events_url": "https://api.github.com/users/ben0x539/events{/privacy}", "received_events_url": "https://api.github.com/users/ben0x539/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ben0x539", "id": 24142, "node_id": "MDQ6VXNlcjI0MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/24142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ben0x539", "html_url": "https://github.com/ben0x539", "followers_url": "https://api.github.com/users/ben0x539/followers", "following_url": "https://api.github.com/users/ben0x539/following{/other_user}", "gists_url": "https://api.github.com/users/ben0x539/gists{/gist_id}", "starred_url": "https://api.github.com/users/ben0x539/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ben0x539/subscriptions", "organizations_url": "https://api.github.com/users/ben0x539/orgs", "repos_url": "https://api.github.com/users/ben0x539/repos", "events_url": "https://api.github.com/users/ben0x539/events{/privacy}", "received_events_url": "https://api.github.com/users/ben0x539/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bddcc1eadeafd2461f7026d7c1f5c70980c1f06", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bddcc1eadeafd2461f7026d7c1f5c70980c1f06", "html_url": "https://github.com/rust-lang/rust/commit/5bddcc1eadeafd2461f7026d7c1f5c70980c1f06"}], "stats": {"total": 1084, "additions": 616, "deletions": 468}, "files": [{"sha": "60084faad98564062e0a04c285fc0cd2eaca811e", "filename": "src/libextra/tempfile.rs", "status": "modified", "additions": 55, "deletions": 9, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94/src%2Flibextra%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94/src%2Flibextra%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftempfile.rs?ref=63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94", "patch": "@@ -15,17 +15,63 @@ use std::os;\n use std::rand::Rng;\n use std::rand;\n \n-/// Attempts to make a temporary directory inside of `tmpdir` whose name will\n-/// have the suffix `suffix`. If no directory can be created, None is returned.\n-pub fn mkdtemp(tmpdir: &Path, suffix: &str) -> Option<Path> {\n-    let mut r = rand::rng();\n-    for _ in range(0u, 1000) {\n-        let p = tmpdir.push(r.gen_ascii_str(16) + suffix);\n-        if os::make_dir(&p, 0x1c0) { // 700\n-            return Some(p);\n+/// A wrapper for a path to temporary directory implementing automatic\n+/// scope-pased deletion.\n+pub struct TempDir {\n+    priv path: Option<Path>\n+}\n+\n+impl TempDir {\n+    /// Attempts to make a temporary directory inside of `tmpdir` whose name\n+    /// will have the suffix `suffix`. The directory will be automatically\n+    /// deleted once the returned wrapper is destroyed.\n+    ///\n+    /// If no directory can be created, None is returned.\n+    pub fn new_in(tmpdir: &Path, suffix: &str) -> Option<TempDir> {\n+        if !tmpdir.is_absolute() {\n+            let abs_tmpdir = os::make_absolute(tmpdir);\n+            return TempDir::new_in(&abs_tmpdir, suffix);\n+        }\n+\n+        let mut r = rand::rng();\n+        for _ in range(0u, 1000) {\n+            let p = tmpdir.push(r.gen_ascii_str(16) + suffix);\n+            if os::make_dir(&p, 0x1c0) { // 700\n+                return Some(TempDir { path: Some(p) });\n+            }\n+        }\n+        None\n+    }\n+\n+    /// Attempts to make a temporary directory inside of `os::tmpdir()` whose\n+    /// name will have the suffix `suffix`. The directory will be automatically\n+    /// deleted once the returned wrapper is destroyed.\n+    ///\n+    /// If no directory can be created, None is returned.\n+    pub fn new(suffix: &str) -> Option<TempDir> {\n+        TempDir::new_in(&os::tmpdir(), suffix)\n+    }\n+\n+    /// Unwrap the wrapped `std::path::Path` from the `TempDir` wrapper.\n+    /// This discards the wrapper so that the automatic deletion of the\n+    /// temporary directory is prevented.\n+    pub fn unwrap(self) -> Path {\n+        let mut tmpdir = self;\n+        tmpdir.path.take_unwrap()\n+    }\n+\n+    /// Access the wrapped `std::path::Path` to the temporary directory.\n+    pub fn path<'a>(&'a self) -> &'a Path {\n+        self.path.get_ref()\n+    }\n+}\n+\n+impl Drop for TempDir {\n+    fn drop(&mut self) {\n+        for path in self.path.iter() {\n+            os::remove_dir_recursive(path);\n         }\n     }\n-    None\n }\n \n // the tests for this module need to change the path using change_dir,"}, {"sha": "c01c619b0c28553cdb184c1a9d794922ec668bf1", "filename": "src/libextra/test.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94", "patch": "@@ -1148,8 +1148,7 @@ mod tests {\n     use test::{TestOpts, run_test};\n \n     use std::comm::{stream, SharedChan};\n-    use tempfile;\n-    use std::os;\n+    use tempfile::TempDir;\n \n     #[test]\n     pub fn do_not_run_ignored_tests() {\n@@ -1392,9 +1391,8 @@ mod tests {\n \n     pub fn ratchet_test() {\n \n-        let dpth = tempfile::mkdtemp(&os::tmpdir(),\n-                                     \"test-ratchet\").expect(\"missing test for ratchet\");\n-        let pth = dpth.push(\"ratchet.json\");\n+        let dpth = TempDir::new(\"test-ratchet\").expect(\"missing test for ratchet\");\n+        let pth = dpth.path().push(\"ratchet.json\");\n \n         let mut m1 = MetricMap::new();\n         m1.insert_metric(\"runtime\", 1000.0, 2.0);\n@@ -1432,7 +1430,5 @@ mod tests {\n         assert_eq!(m4.len(), 2);\n         assert_eq!(*(m4.find(&~\"runtime\").unwrap()), Metric { value: 1100.0, noise: 2.0 });\n         assert_eq!(*(m4.find(&~\"throughput\").unwrap()), Metric { value: 50.0, noise: 2.0 });\n-\n-        os::remove_dir_recursive(&dpth);\n     }\n }"}, {"sha": "4ffc57d7512b1e6e670eb542844f12017e83ef71", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94", "patch": "@@ -239,9 +239,6 @@ impl PkgSrc {\n     pub fn fetch_git(local: &Path, pkgid: &PkgId) -> Option<Path> {\n         use conditions::git_checkout_failed::cond;\n \n-        // We use a temporary directory because if the git clone fails,\n-        // it creates the target directory anyway and doesn't delete it\n-\n         debug2!(\"Checking whether {} (path = {}) exists locally. Cwd = {}, does it? {:?}\",\n                 pkgid.to_str(), pkgid.path.to_str(),\n                 os::getcwd().to_str(),"}, {"sha": "33b86e7cbc529d8e47b725409eebb432fe2a8745", "filename": "src/librustpkg/source_control.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94", "patch": "@@ -12,7 +12,7 @@\n \n use std::{io, os, run, str};\n use std::run::{ProcessOutput, ProcessOptions, Process};\n-use extra::tempfile;\n+use extra::tempfile::TempDir;\n use version::*;\n use path_util::chmod_read_only;\n \n@@ -22,14 +22,6 @@ use path_util::chmod_read_only;\n /// directory (that the callee may use, for example, to check out remote sources into).\n /// Returns `CheckedOutSources` if the clone succeeded.\n pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult {\n-    use conditions::failed_to_create_temp_dir::cond;\n-\n-    let scratch_dir = tempfile::mkdtemp(&os::tmpdir(), \"rustpkg\");\n-    let clone_target = match scratch_dir {\n-        Some(d) => d.push(\"rustpkg_temp\"),\n-        None    => cond.raise(~\"Failed to create temporary directory for fetching git sources\")\n-    };\n-\n     if os::path_exists(source) {\n         debug2!(\"{} exists locally! Cloning it into {}\",\n                 source.to_str(), target.to_str());\n@@ -77,6 +69,14 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n         }\n         CheckedOutSources\n     } else {\n+        use conditions::failed_to_create_temp_dir::cond;\n+\n+        let scratch_dir = TempDir::new(\"rustpkg\");\n+        let clone_target = match scratch_dir {\n+            Some(d) => d.unwrap().push(\"rustpkg_temp\"),\n+            None    => cond.raise(~\"Failed to create temporary directory for fetching git sources\")\n+        };\n+\n         DirToUse(clone_target)\n     }\n }"}, {"sha": "25e5617f78a9f7fbf8e5ac9c31f42775e8f582ad", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 331, "deletions": 262, "changes": 593, "blob_url": "https://github.com/rust-lang/rust/blob/63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94", "patch": "@@ -14,7 +14,7 @@ use context::{BuildContext, Context, RustcFlags};\n use std::{io, os, run, str, task};\n use extra::arc::Arc;\n use extra::arc::RWArc;\n-use extra::tempfile::mkdtemp;\n+use extra::tempfile::TempDir;\n use extra::workcache;\n use extra::workcache::{Database, Logger};\n use extra::treemap::TreeMap;\n@@ -85,16 +85,16 @@ fn writeFile(file_path: &Path, contents: &str) {\n     out.write_line(contents);\n }\n \n-fn mk_emptier_workspace(tag: &str) -> Path {\n-    let workspace = mkdtemp(&os::tmpdir(), tag).expect(\"couldn't create temp dir\");\n-    let package_dir = workspace.push(\"src\");\n+fn mk_emptier_workspace(tag: &str) -> TempDir {\n+    let workspace = TempDir::new(tag).expect(\"couldn't create temp dir\");\n+    let package_dir = workspace.path().push(\"src\");\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n     workspace\n }\n \n-fn mk_empty_workspace(short_name: &Path, version: &Version, tag: &str) -> Path {\n-    let workspace_dir = mkdtemp(&os::tmpdir(), tag).expect(\"couldn't create temp dir\");\n-    mk_workspace(&workspace_dir, short_name, version);\n+fn mk_empty_workspace(short_name: &Path, version: &Version, tag: &str) -> TempDir {\n+    let workspace_dir = TempDir::new(tag).expect(\"couldn't create temp dir\");\n+    mk_workspace(workspace_dir.path(), short_name, version);\n     workspace_dir\n }\n \n@@ -106,11 +106,12 @@ fn mk_workspace(workspace: &Path, short_name: &Path, version: &Version) -> Path\n     package_dir\n }\n \n-fn mk_temp_workspace(short_name: &Path, version: &Version) -> Path {\n-    let package_dir = mk_empty_workspace(short_name,\n-                          version, \"temp_workspace\").push_many([~\"src\", format!(\"{}-{}\",\n-                                                            short_name.to_str(),\n-                                                            version.to_str())]);\n+fn mk_temp_workspace(short_name: &Path, version: &Version) -> (TempDir, Path) {\n+    let workspace_dir = mk_empty_workspace(short_name, version, \"temp_workspace\");\n+    let package_dir = workspace_dir.path().push_many([~\"src\",\n+                                                      format!(\"{}-{}\",\n+                                                              short_name.to_str(),\n+                                                              version.to_str())]);\n \n     debug2!(\"Created {} and does it exist? {:?}\", package_dir.to_str(),\n           os::path_is_dir(&package_dir));\n@@ -129,7 +130,7 @@ fn mk_temp_workspace(short_name: &Path, version: &Version) -> Path {\n               \"#[test] pub fn f() { (); }\");\n     writeFile(&package_dir.push(\"bench.rs\"),\n               \"#[bench] pub fn f() { (); }\");\n-    package_dir\n+    (workspace_dir, package_dir)\n }\n \n fn run_git(args: &[~str], env: Option<~[(~str, ~str)]>, cwd: &Path, err_msg: &str) {\n@@ -150,10 +151,10 @@ fn run_git(args: &[~str], env: Option<~[(~str, ~str)]>, cwd: &Path, err_msg: &st\n \n /// Should create an empty git repo in p, relative to the tmp dir, and return the new\n /// absolute path\n-fn init_git_repo(p: &Path) -> Path {\n+fn init_git_repo(p: &Path) -> TempDir {\n     assert!(!p.is_absolute());\n-    let tmp = mkdtemp(&os::tmpdir(), \"git_local\").expect(\"couldn't create temp dir\");\n-    let work_dir = tmp.push_rel(p);\n+    let tmp = TempDir::new(\"git_local\").expect(\"couldn't create temp dir\");\n+    let work_dir = tmp.path().push_rel(p);\n     let work_dir_for_opts = work_dir.clone();\n     assert!(os::mkdir_recursive(&work_dir, U_RWX));\n     debug2!(\"Running: git init in {}\", work_dir.to_str());\n@@ -298,10 +299,10 @@ to make sure the command succeeded\n     }\n }\n \n-fn create_local_package(pkgid: &PkgId) -> Path {\n-    let parent_dir = mk_temp_workspace(&pkgid.path, &pkgid.version);\n+fn create_local_package(pkgid: &PkgId) -> TempDir {\n+    let (workspace, parent_dir) = mk_temp_workspace(&pkgid.path, &pkgid.version);\n     debug2!(\"Created empty package dir for {}, returning {}\", pkgid.to_str(), parent_dir.to_str());\n-    parent_dir.pop().pop()\n+    workspace\n }\n \n fn create_local_package_in(pkgid: &PkgId, pkgdir: &Path) -> Path {\n@@ -325,26 +326,26 @@ fn create_local_package_in(pkgid: &PkgId, pkgdir: &Path) -> Path {\n     package_dir\n }\n \n-fn create_local_package_with_test(pkgid: &PkgId) -> Path {\n+fn create_local_package_with_test(pkgid: &PkgId) -> TempDir {\n     debug2!(\"Dry run -- would create package {:?} with test\", pkgid);\n     create_local_package(pkgid) // Already has tests???\n }\n \n-fn create_local_package_with_dep(pkgid: &PkgId, subord_pkgid: &PkgId) -> Path {\n+fn create_local_package_with_dep(pkgid: &PkgId, subord_pkgid: &PkgId) -> TempDir {\n     let package_dir = create_local_package(pkgid);\n-    create_local_package_in(subord_pkgid, &package_dir);\n+    create_local_package_in(subord_pkgid, package_dir.path());\n     // Write a main.rs file into pkgid that references subord_pkgid\n-    writeFile(&package_dir.push_many([~\"src\", pkgid.to_str(), ~\"main.rs\"]),\n+    writeFile(&package_dir.path().push_many([~\"src\", pkgid.to_str(), ~\"main.rs\"]),\n               format!(\"extern mod {};\\nfn main() \\\\{\\\\}\",\n                    subord_pkgid.short_name));\n     // Write a lib.rs file into subord_pkgid that has something in it\n-    writeFile(&package_dir.push_many([~\"src\", subord_pkgid.to_str(), ~\"lib.rs\"]),\n+    writeFile(&package_dir.path().push_many([~\"src\", subord_pkgid.to_str(), ~\"lib.rs\"]),\n               \"pub fn f() {}\");\n     package_dir\n }\n \n fn create_local_package_with_custom_build_hook(pkgid: &PkgId,\n-                                               custom_build_hook: &str) -> Path {\n+                                               custom_build_hook: &str) -> TempDir {\n     debug2!(\"Dry run -- would create package {} with custom build hook {}\",\n            pkgid.to_str(), custom_build_hook);\n     create_local_package(pkgid)\n@@ -545,8 +546,9 @@ fn test_install_valid() {\n     let sysroot = test_sysroot();\n     debug2!(\"sysroot = {}\", sysroot.to_str());\n     let temp_pkg_id = fake_pkg();\n-    let temp_workspace = mk_temp_workspace(&temp_pkg_id.path, &NoVersion).pop().pop();\n-    let ctxt = fake_ctxt(sysroot, &temp_workspace);\n+    let (temp_workspace, _pkg_dir) = mk_temp_workspace(&temp_pkg_id.path, &NoVersion);\n+    let temp_workspace = temp_workspace.path();\n+    let ctxt = fake_ctxt(sysroot, temp_workspace);\n     debug2!(\"temp_workspace = {}\", temp_workspace.to_str());\n     // should have test, bench, lib, and main\n     let src = PkgSrc::new(temp_workspace.clone(),\n@@ -555,28 +557,34 @@ fn test_install_valid() {\n                           temp_pkg_id.clone());\n     ctxt.install(src, &Everything);\n     // Check that all files exist\n-    let exec = target_executable_in_workspace(&temp_pkg_id, &temp_workspace);\n+    let exec = target_executable_in_workspace(&temp_pkg_id, temp_workspace);\n     debug2!(\"exec = {}\", exec.to_str());\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n \n-    let lib = installed_library_in_workspace(&temp_pkg_id.path, &temp_workspace);\n+    let lib = installed_library_in_workspace(&temp_pkg_id.path, temp_workspace);\n     debug2!(\"lib = {:?}\", lib);\n     assert!(lib.as_ref().map_default(false, |l| os::path_exists(l)));\n     assert!(lib.as_ref().map_default(false, |l| is_rwx(l)));\n \n     // And that the test and bench executables aren't installed\n-    assert!(!os::path_exists(&target_test_in_workspace(&temp_pkg_id, &temp_workspace)));\n-    let bench = target_bench_in_workspace(&temp_pkg_id, &temp_workspace);\n+    assert!(!os::path_exists(&target_test_in_workspace(&temp_pkg_id, temp_workspace)));\n+    let bench = target_bench_in_workspace(&temp_pkg_id, temp_workspace);\n     debug2!(\"bench = {}\", bench.to_str());\n     assert!(!os::path_exists(&bench));\n+\n+    // Make sure the db isn't dirty, so that it doesn't try to save()\n+    // asynchronously after the temporary directory that it wants to save\n+    // to has been deleted.\n+    ctxt.workcache_context.db.write(|db| db.db_dirty = false);\n }\n \n #[test]\n fn test_install_invalid() {\n     let sysroot = test_sysroot();\n     let pkgid = fake_pkg();\n-    let temp_workspace = mkdtemp(&os::tmpdir(), \"test\").expect(\"couldn't create temp dir\");\n+    let temp_workspace = TempDir::new(\"test\").expect(\"couldn't create temp dir\");\n+    let temp_workspace = temp_workspace.path().clone();\n     let ctxt = fake_ctxt(sysroot, &temp_workspace);\n \n     // Uses task::try because of #9001\n@@ -597,6 +605,7 @@ fn test_install_invalid() {\n fn test_install_git() {\n     let temp_pkg_id = git_repo_pkg();\n     let repo = init_git_repo(&temp_pkg_id.path);\n+    let repo = repo.path();\n     debug2!(\"repo = {}\", repo.to_str());\n     let repo_subdir = repo.push_many([~\"mockgithub.com\", ~\"catamorphism\", ~\"test-pkg\"]);\n     debug2!(\"repo_subdir = {}\", repo_subdir.to_str());\n@@ -614,7 +623,7 @@ fn test_install_git() {\n     debug2!(\"test_install_git: calling rustpkg install {} in {}\",\n            temp_pkg_id.path.to_str(), repo.to_str());\n     // should have test, bench, lib, and main\n-    command_line_test([~\"install\", temp_pkg_id.path.to_str()], &repo);\n+    command_line_test([~\"install\", temp_pkg_id.path.to_str()], repo);\n     let ws = repo.push(\".rust\");\n     // Check that all files exist\n     debug2!(\"Checking for files in {}\", ws.to_str());\n@@ -686,6 +695,7 @@ fn test_package_ids_must_be_relative_path_like() {\n fn test_package_version() {\n     let local_path = \"mockgithub.com/catamorphism/test_pkg_version\";\n     let repo = init_git_repo(&Path(local_path));\n+    let repo = repo.path();\n     let repo_subdir = repo.push_many([~\"mockgithub.com\", ~\"catamorphism\", ~\"test_pkg_version\"]);\n     debug2!(\"Writing files in: {}\", repo_subdir.to_str());\n     writeFile(&repo_subdir.push(\"main.rs\"),\n@@ -702,7 +712,7 @@ fn test_package_version() {\n     let temp_pkg_id = PkgId::new(\"mockgithub.com/catamorphism/test_pkg_version\");\n     // This should look at the prefix, clone into a workspace, then build.\n     command_line_test([~\"install\", ~\"mockgithub.com/catamorphism/test_pkg_version\"],\n-                      &repo);\n+                      repo);\n     let ws = repo.push(\".rust\");\n     // we can still match on the filename to make sure it contains the 0.4 version\n     assert!(match built_library_in_workspace(&temp_pkg_id,\n@@ -721,6 +731,7 @@ fn test_package_version() {\n fn test_package_request_version() {\n     let local_path = \"mockgithub.com/catamorphism/test_pkg_version\";\n     let repo = init_git_repo(&Path(local_path));\n+    let repo = repo.path();\n     let repo_subdir = repo.push_many([~\"mockgithub.com\", ~\"catamorphism\", ~\"test_pkg_version\"]);\n     debug2!(\"Writing files in: {}\", repo_subdir.to_str());\n     writeFile(&repo_subdir.push(\"main.rs\"),\n@@ -736,7 +747,7 @@ fn test_package_request_version() {\n     writeFile(&repo_subdir.push(\"version-0.4-file.txt\"), \"hello\");\n     add_git_tag(&repo_subdir, ~\"0.4\");\n \n-    command_line_test([~\"install\", format!(\"{}\\\\#0.3\", local_path)], &repo);\n+    command_line_test([~\"install\", format!(\"{}\\\\#0.3\", local_path)], repo);\n \n     assert!(match installed_library_in_workspace(&Path(\"test_pkg_version\"), &repo.push(\".rust\")) {\n         Some(p) => {\n@@ -760,14 +771,15 @@ fn test_package_request_version() {\n #[test]\n #[ignore (reason = \"http-client not ported to rustpkg yet\")]\n fn rustpkg_install_url_2() {\n-    let temp_dir = mkdtemp(&os::tmpdir(), \"rustpkg_install_url_2\").expect(\"rustpkg_install_url_2\");\n+    let temp_dir = TempDir::new(\"rustpkg_install_url_2\").expect(\"rustpkg_install_url_2\");\n     command_line_test([~\"install\", ~\"github.com/mozilla-servo/rust-http-client\"],\n-                     &temp_dir);\n+                     temp_dir.path());\n }\n \n #[test]\n fn rustpkg_library_target() {\n     let foo_repo = init_git_repo(&Path(\"foo\"));\n+    let foo_repo = foo_repo.path();\n     let package_dir = foo_repo.push(\"foo\");\n \n     debug2!(\"Writing files in: {}\", package_dir.to_str());\n@@ -781,21 +793,22 @@ fn rustpkg_library_target() {\n               \"#[bench] pub fn f() { (); }\");\n \n     add_git_tag(&package_dir, ~\"1.0\");\n-    command_line_test([~\"install\", ~\"foo\"], &foo_repo);\n+    command_line_test([~\"install\", ~\"foo\"], foo_repo);\n     assert_lib_exists(&foo_repo.push(\".rust\"), &Path(\"foo\"), ExactRevision(~\"1.0\"));\n }\n \n #[test]\n fn rustpkg_local_pkg() {\n     let dir = create_local_package(&PkgId::new(\"foo\"));\n-    command_line_test([~\"install\", ~\"foo\"], &dir);\n-    assert_executable_exists(&dir, \"foo\");\n+    command_line_test([~\"install\", ~\"foo\"], dir.path());\n+    assert_executable_exists(dir.path(), \"foo\");\n }\n \n #[test]\n #[ignore (reason = \"test makes bogus assumptions about build directory layout: issue #8690\")]\n fn package_script_with_default_build() {\n     let dir = create_local_package(&PkgId::new(\"fancy-lib\"));\n+    let dir = dir.path();\n     debug2!(\"dir = {}\", dir.to_str());\n     let source = test_sysroot().pop().pop().pop().push_many(\n         [~\"src\", ~\"librustpkg\", ~\"testsuite\", ~\"pass\", ~\"src\", ~\"fancy-lib\", ~\"pkg.rs\"]);\n@@ -804,15 +817,15 @@ fn package_script_with_default_build() {\n                       &dir.push_many([~\"src\", ~\"fancy-lib-0.1\", ~\"pkg.rs\"])) {\n         fail2!(\"Couldn't copy file\");\n     }\n-    command_line_test([~\"install\", ~\"fancy-lib\"], &dir);\n-    assert_lib_exists(&dir, &Path(\"fancy-lib\"), NoVersion);\n-    assert!(os::path_exists(&target_build_dir(&dir).push_many([~\"fancy-lib\", ~\"generated.rs\"])));\n+    command_line_test([~\"install\", ~\"fancy-lib\"], dir);\n+    assert_lib_exists(dir, &Path(\"fancy-lib\"), NoVersion);\n+    assert!(os::path_exists(&target_build_dir(dir).push_many([~\"fancy-lib\", ~\"generated.rs\"])));\n }\n \n #[test]\n fn rustpkg_build_no_arg() {\n-    let tmp = mkdtemp(&os::tmpdir(), \"rustpkg_build_no_arg\").expect(\"rustpkg_build_no_arg failed\")\n-              .push(\".rust\");\n+    let tmp = TempDir::new(\"rustpkg_build_no_arg\").expect(\"rustpkg_build_no_arg failed\");\n+    let tmp = tmp.path().push(\".rust\");\n     let package_dir = tmp.push_many([~\"src\", ~\"foo\"]);\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n \n@@ -825,9 +838,8 @@ fn rustpkg_build_no_arg() {\n \n #[test]\n fn rustpkg_install_no_arg() {\n-    let tmp = mkdtemp(&os::tmpdir(),\n-                      \"rustpkg_install_no_arg\").expect(\"rustpkg_install_no_arg failed\")\n-              .push(\".rust\");\n+    let tmp = TempDir::new(\"rustpkg_install_no_arg\").expect(\"rustpkg_install_no_arg failed\");\n+    let tmp = tmp.path().push(\".rust\");\n     let package_dir = tmp.push_many([~\"src\", ~\"foo\"]);\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n     writeFile(&package_dir.push(\"lib.rs\"),\n@@ -839,8 +851,8 @@ fn rustpkg_install_no_arg() {\n \n #[test]\n fn rustpkg_clean_no_arg() {\n-    let tmp = mkdtemp(&os::tmpdir(), \"rustpkg_clean_no_arg\").expect(\"rustpkg_clean_no_arg failed\")\n-              .push(\".rust\");\n+    let tmp = TempDir::new(\"rustpkg_clean_no_arg\").expect(\"rustpkg_clean_no_arg failed\");\n+    let tmp = tmp.path().push(\".rust\");\n     let package_dir = tmp.push_many([~\"src\", ~\"foo\"]);\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n \n@@ -856,8 +868,8 @@ fn rustpkg_clean_no_arg() {\n \n #[test]\n fn rust_path_test() {\n-    let dir_for_path = mkdtemp(&os::tmpdir(), \"more_rust\").expect(\"rust_path_test failed\");\n-    let dir = mk_workspace(&dir_for_path, &Path(\"foo\"), &NoVersion);\n+    let dir_for_path = TempDir::new(\"more_rust\").expect(\"rust_path_test failed\");\n+    let dir = mk_workspace(dir_for_path.path(), &Path(\"foo\"), &NoVersion);\n     debug2!(\"dir = {}\", dir.to_str());\n     writeFile(&dir.push(\"main.rs\"), \"fn main() { let _x = (); }\");\n \n@@ -866,15 +878,15 @@ fn rust_path_test() {\n                                      // use command_line_test_with_env\n     command_line_test_with_env([~\"install\", ~\"foo\"],\n                                &cwd,\n-                               Some(~[(~\"RUST_PATH\", dir_for_path.to_str())]));\n-    assert_executable_exists(&dir_for_path, \"foo\");\n+                               Some(~[(~\"RUST_PATH\", dir_for_path.path().to_str())]));\n+    assert_executable_exists(dir_for_path.path(), \"foo\");\n }\n \n #[test]\n #[ignore] // FIXME(#9184) tests can't change the cwd (other tests are sad then)\n fn rust_path_contents() {\n-    let dir = mkdtemp(&os::tmpdir(), \"rust_path\").expect(\"rust_path_contents failed\");\n-    let abc = &dir.push_many([~\"A\", ~\"B\", ~\"C\"]);\n+    let dir = TempDir::new(\"rust_path\").expect(\"rust_path_contents failed\");\n+    let abc = &dir.path().push_many([~\"A\", ~\"B\", ~\"C\"]);\n     assert!(os::mkdir_recursive(&abc.push(\".rust\"), U_RWX));\n     assert!(os::mkdir_recursive(&abc.pop().push(\".rust\"), U_RWX));\n     assert!(os::mkdir_recursive(&abc.pop().pop().push(\".rust\"), U_RWX));\n@@ -904,26 +916,27 @@ fn rust_path_parse() {\n \n #[test]\n fn test_list() {\n-    let dir = mkdtemp(&os::tmpdir(), \"test_list\").expect(\"test_list failed\");\n+    let dir = TempDir::new(\"test_list\").expect(\"test_list failed\");\n+    let dir = dir.path();\n     let foo = PkgId::new(\"foo\");\n-    create_local_package_in(&foo, &dir);\n+    create_local_package_in(&foo, dir);\n     let bar = PkgId::new(\"bar\");\n-    create_local_package_in(&bar, &dir);\n+    create_local_package_in(&bar, dir);\n     let quux = PkgId::new(\"quux\");\n-    create_local_package_in(&quux, &dir);\n+    create_local_package_in(&quux, dir);\n \n // list doesn't output very much right now...\n-    command_line_test([~\"install\", ~\"foo\"], &dir);\n+    command_line_test([~\"install\", ~\"foo\"], dir);\n     let env_arg = ~[(~\"RUST_PATH\", dir.to_str())];\n     let list_output = command_line_test_output_with_env([~\"list\"], env_arg.clone());\n     assert!(list_output.iter().any(|x| x.starts_with(\"foo\")));\n \n-    command_line_test([~\"install\", ~\"bar\"], &dir);\n+    command_line_test([~\"install\", ~\"bar\"], dir);\n     let list_output = command_line_test_output_with_env([~\"list\"], env_arg.clone());\n     assert!(list_output.iter().any(|x| x.starts_with(\"foo\")));\n     assert!(list_output.iter().any(|x| x.starts_with(\"bar\")));\n \n-    command_line_test([~\"install\", ~\"quux\"], &dir);\n+    command_line_test([~\"install\", ~\"quux\"], dir);\n     let list_output = command_line_test_output_with_env([~\"list\"], env_arg);\n     assert!(list_output.iter().any(|x| x.starts_with(\"foo\")));\n     assert!(list_output.iter().any(|x| x.starts_with(\"bar\")));\n@@ -932,22 +945,23 @@ fn test_list() {\n \n #[test]\n fn install_remove() {\n-    let dir = mkdtemp(&os::tmpdir(), \"install_remove\").expect(\"install_remove\");\n+    let dir = TempDir::new(\"install_remove\").expect(\"install_remove\");\n+    let dir = dir.path();\n     let foo = PkgId::new(\"foo\");\n     let bar = PkgId::new(\"bar\");\n     let quux = PkgId::new(\"quux\");\n-    create_local_package_in(&foo, &dir);\n-    create_local_package_in(&bar, &dir);\n-    create_local_package_in(&quux, &dir);\n+    create_local_package_in(&foo, dir);\n+    create_local_package_in(&bar, dir);\n+    create_local_package_in(&quux, dir);\n     let rust_path_to_use = ~[(~\"RUST_PATH\", dir.to_str())];\n-    command_line_test([~\"install\", ~\"foo\"], &dir);\n-    command_line_test([~\"install\", ~\"bar\"], &dir);\n-    command_line_test([~\"install\", ~\"quux\"], &dir);\n+    command_line_test([~\"install\", ~\"foo\"], dir);\n+    command_line_test([~\"install\", ~\"bar\"], dir);\n+    command_line_test([~\"install\", ~\"quux\"], dir);\n     let list_output = command_line_test_output_with_env([~\"list\"], rust_path_to_use.clone());\n     assert!(list_output.iter().any(|x| x.starts_with(\"foo\")));\n     assert!(list_output.iter().any(|x| x.starts_with(\"bar\")));\n     assert!(list_output.iter().any(|x| x.starts_with(\"quux\")));\n-    command_line_test([~\"uninstall\", ~\"foo\"], &dir);\n+    command_line_test([~\"uninstall\", ~\"foo\"], dir);\n     let list_output = command_line_test_output_with_env([~\"list\"], rust_path_to_use.clone());\n     assert!(!list_output.iter().any(|x| x.starts_with(\"foo\")));\n     assert!(list_output.iter().any(|x| x.starts_with(\"bar\")));\n@@ -959,12 +973,13 @@ fn install_check_duplicates() {\n     // should check that we don't install two packages with the same full name *and* version\n     // (\"Is already installed -- doing nothing\")\n     // check invariant that there are no dups in the pkg database\n-    let dir = mkdtemp(&os::tmpdir(), \"install_remove\").expect(\"install_remove\");\n+    let dir = TempDir::new(\"install_remove\").expect(\"install_remove\");\n+    let dir = dir.path();\n     let foo = PkgId::new(\"foo\");\n-    create_local_package_in(&foo, &dir);\n+    create_local_package_in(&foo, dir);\n \n-    command_line_test([~\"install\", ~\"foo\"], &dir);\n-    command_line_test([~\"install\", ~\"foo\"], &dir);\n+    command_line_test([~\"install\", ~\"foo\"], dir);\n+    command_line_test([~\"install\", ~\"foo\"], dir);\n     let mut contents = ~[];\n     let check_dups = |p: &PkgId| {\n         if contents.contains(p) {\n@@ -982,12 +997,13 @@ fn install_check_duplicates() {\n fn no_rebuilding() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n-    command_line_test([~\"build\", ~\"foo\"], &workspace);\n+    let workspace = workspace.path();\n+    command_line_test([~\"build\", ~\"foo\"], workspace);\n     let date = datestamp(&built_library_in_workspace(&p_id,\n-                                                    &workspace).expect(\"no_rebuilding\"));\n-    command_line_test([~\"build\", ~\"foo\"], &workspace);\n+                                                     workspace).expect(\"no_rebuilding\"));\n+    command_line_test([~\"build\", ~\"foo\"], workspace);\n     let newdate = datestamp(&built_library_in_workspace(&p_id,\n-                                                       &workspace).expect(\"no_rebuilding (2)\"));\n+                                                        workspace).expect(\"no_rebuilding (2)\"));\n     assert_eq!(date, newdate);\n }\n \n@@ -996,16 +1012,17 @@ fn no_rebuilding_dep() {\n     let p_id = PkgId::new(\"foo\");\n     let dep_id = PkgId::new(\"bar\");\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n-    command_line_test([~\"build\", ~\"foo\"], &workspace);\n-    let bar_lib = lib_output_file_name(&workspace, \"bar\");\n+    let workspace = workspace.path();\n+    command_line_test([~\"build\", ~\"foo\"], workspace);\n+    let bar_lib = lib_output_file_name(workspace, \"bar\");\n     let bar_date_1 = datestamp(&bar_lib);\n \n-    frob_source_file(&workspace, &p_id, \"main.rs\");\n+    frob_source_file(workspace, &p_id, \"main.rs\");\n \n     // Now make `bar` read-only so that subsequent rebuilds of it will fail\n     assert!(chmod_read_only(&bar_lib));\n \n-    match command_line_test_partial([~\"build\", ~\"foo\"], &workspace) {\n+    match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n         Success(*) => (), // ok\n         Fail(status) if status == 65 => fail2!(\"no_rebuilding_dep failed: it tried to rebuild bar\"),\n         Fail(_) => fail2!(\"no_rebuilding_dep failed for some other reason\")\n@@ -1021,12 +1038,13 @@ fn do_rebuild_dep_dates_change() {\n     let p_id = PkgId::new(\"foo\");\n     let dep_id = PkgId::new(\"bar\");\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n-    command_line_test([~\"build\", ~\"foo\"], &workspace);\n-    let bar_lib_name = lib_output_file_name(&workspace, \"bar\");\n+    let workspace = workspace.path();\n+    command_line_test([~\"build\", ~\"foo\"], workspace);\n+    let bar_lib_name = lib_output_file_name(workspace, \"bar\");\n     let bar_date = datestamp(&bar_lib_name);\n     debug2!(\"Datestamp on {} is {:?}\", bar_lib_name.to_str(), bar_date);\n-    touch_source_file(&workspace, &dep_id);\n-    command_line_test([~\"build\", ~\"foo\"], &workspace);\n+    touch_source_file(workspace, &dep_id);\n+    command_line_test([~\"build\", ~\"foo\"], workspace);\n     let new_bar_date = datestamp(&bar_lib_name);\n     debug2!(\"Datestamp on {} is {:?}\", bar_lib_name.to_str(), new_bar_date);\n     assert!(new_bar_date > bar_date);\n@@ -1038,20 +1056,21 @@ fn do_rebuild_dep_only_contents_change() {\n     let p_id = PkgId::new(\"foo\");\n     let dep_id = PkgId::new(\"bar\");\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n-    command_line_test([~\"build\", ~\"foo\"], &workspace);\n-    let bar_date = datestamp(&lib_output_file_name(&workspace, \"bar\"));\n-    frob_source_file(&workspace, &dep_id, \"lib.rs\");\n+    let workspace = workspace.path();\n+    command_line_test([~\"build\", ~\"foo\"], workspace);\n+    let bar_date = datestamp(&lib_output_file_name(workspace, \"bar\"));\n+    frob_source_file(workspace, &dep_id, \"lib.rs\");\n     // should adjust the datestamp\n-    command_line_test([~\"build\", ~\"foo\"], &workspace);\n-    let new_bar_date = datestamp(&lib_output_file_name(&workspace, \"bar\"));\n+    command_line_test([~\"build\", ~\"foo\"], workspace);\n+    let new_bar_date = datestamp(&lib_output_file_name(workspace, \"bar\"));\n     assert!(new_bar_date > bar_date);\n }\n \n #[test]\n fn test_versions() {\n     let workspace = create_local_package(&PkgId::new(\"foo#0.1\"));\n-    create_local_package(&PkgId::new(\"foo#0.2\"));\n-    command_line_test([~\"install\", ~\"foo#0.1\"], &workspace);\n+    let _other_workspace = create_local_package(&PkgId::new(\"foo#0.2\"));\n+    command_line_test([~\"install\", ~\"foo#0.1\"], workspace.path());\n     let output = command_line_test_output([~\"list\"]);\n     // make sure output includes versions\n     assert!(!output.iter().any(|x| x == &~\"foo#0.2\"));\n@@ -1062,7 +1081,7 @@ fn test_versions() {\n fn test_build_hooks() {\n     let workspace = create_local_package_with_custom_build_hook(&PkgId::new(\"foo\"),\n                                                                 \"frob\");\n-    command_line_test([~\"do\", ~\"foo\", ~\"frob\"], &workspace);\n+    command_line_test([~\"do\", ~\"foo\", ~\"frob\"], workspace.path());\n }\n \n \n@@ -1071,22 +1090,23 @@ fn test_build_hooks() {\n fn test_info() {\n     let expected_info = ~\"package foo\"; // fill in\n     let workspace = create_local_package(&PkgId::new(\"foo\"));\n-    let output = command_line_test([~\"info\", ~\"foo\"], &workspace);\n+    let output = command_line_test([~\"info\", ~\"foo\"], workspace.path());\n     assert_eq!(str::from_utf8(output.output), expected_info);\n }\n \n #[test]\n fn test_uninstall() {\n     let workspace = create_local_package(&PkgId::new(\"foo\"));\n-    command_line_test([~\"uninstall\", ~\"foo\"], &workspace);\n-    let output = command_line_test([~\"list\"], &workspace);\n+    command_line_test([~\"uninstall\", ~\"foo\"], workspace.path());\n+    let output = command_line_test([~\"list\"], workspace.path());\n     assert!(!str::from_utf8(output.output).contains(\"foo\"));\n }\n \n #[test]\n fn test_non_numeric_tag() {\n     let temp_pkg_id = git_repo_pkg();\n     let repo = init_git_repo(&temp_pkg_id.path);\n+    let repo = repo.path();\n     let repo_subdir = repo.push_many([~\"mockgithub.com\", ~\"catamorphism\", ~\"test-pkg\"]);\n     writeFile(&repo_subdir.push(\"foo\"), \"foo\");\n     writeFile(&repo_subdir.push(\"lib.rs\"),\n@@ -1097,7 +1117,7 @@ fn test_non_numeric_tag() {\n     writeFile(&repo_subdir.push(\"not_on_testbranch_only\"), \"bye bye\");\n     add_all_and_commit(&repo_subdir);\n \n-    command_line_test([~\"install\", format!(\"{}\\\\#testbranch\", temp_pkg_id.path.to_str())], &repo);\n+    command_line_test([~\"install\", format!(\"{}\\\\#testbranch\", temp_pkg_id.path.to_str())], repo);\n     let file1 = repo.push_many([\"mockgithub.com\", \"catamorphism\",\n                                 \"test-pkg\", \"testbranch_only\"]);\n     let file2 = repo.push_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\",\n@@ -1108,9 +1128,11 @@ fn test_non_numeric_tag() {\n \n #[test]\n fn test_extern_mod() {\n-    let dir = mkdtemp(&os::tmpdir(), \"test_extern_mod\").expect(\"test_extern_mod\");\n+    let dir = TempDir::new(\"test_extern_mod\").expect(\"test_extern_mod\");\n+    let dir = dir.path();\n     let main_file = dir.push(\"main.rs\");\n-    let lib_depend_dir = mkdtemp(&os::tmpdir(), \"foo\").expect(\"test_extern_mod\");\n+    let lib_depend_dir = TempDir::new(\"foo\").expect(\"test_extern_mod\");\n+    let lib_depend_dir = lib_depend_dir.path();\n     let aux_dir = lib_depend_dir.push_many([\"src\", \"mockgithub.com\", \"catamorphism\", \"test_pkg\"]);\n     assert!(os::mkdir_recursive(&aux_dir, U_RWX));\n     let aux_pkg_file = aux_dir.push(\"lib.rs\");\n@@ -1122,7 +1144,7 @@ fn test_extern_mod() {\n               \"extern mod test = \\\"mockgithub.com/catamorphism/test_pkg\\\";\\nuse test::bar;\\\n                fn main() { bar::assert_true(); }\\n\");\n \n-    command_line_test([~\"install\", ~\"mockgithub.com/catamorphism/test_pkg\"], &lib_depend_dir);\n+    command_line_test([~\"install\", ~\"mockgithub.com/catamorphism/test_pkg\"], lib_depend_dir);\n \n     let exec_file = dir.push(\"out\");\n     // Be sure to extend the existing environment\n@@ -1135,7 +1157,7 @@ fn test_extern_mod() {\n                                                ~\"-o\", exec_file.to_str()],\n                                      run::ProcessOptions {\n         env: env,\n-        dir: Some(&dir),\n+        dir: Some(dir),\n         in_fd: None,\n         out_fd: None,\n         err_fd: None\n@@ -1151,9 +1173,11 @@ fn test_extern_mod() {\n \n #[test]\n fn test_extern_mod_simpler() {\n-    let dir = mkdtemp(&os::tmpdir(), \"test_extern_mod_simpler\").expect(\"test_extern_mod_simpler\");\n+    let dir = TempDir::new(\"test_extern_mod_simpler\").expect(\"test_extern_mod_simpler\");\n+    let dir = dir.path();\n     let main_file = dir.push(\"main.rs\");\n-    let lib_depend_dir = mkdtemp(&os::tmpdir(), \"foo\").expect(\"test_extern_mod_simpler\");\n+    let lib_depend_dir = TempDir::new(\"foo\").expect(\"test_extern_mod_simpler\");\n+    let lib_depend_dir = lib_depend_dir.path();\n     let aux_dir = lib_depend_dir.push_many([\"src\", \"rust-awesomeness\"]);\n     assert!(os::mkdir_recursive(&aux_dir, U_RWX));\n     let aux_pkg_file = aux_dir.push(\"lib.rs\");\n@@ -1165,7 +1189,7 @@ fn test_extern_mod_simpler() {\n               \"extern mod test = \\\"rust-awesomeness\\\";\\nuse test::bar;\\\n                fn main() { bar::assert_true(); }\\n\");\n \n-    command_line_test([~\"install\", ~\"rust-awesomeness\"], &lib_depend_dir);\n+    command_line_test([~\"install\", ~\"rust-awesomeness\"], lib_depend_dir);\n \n     let exec_file = dir.push(\"out\");\n     // Be sure to extend the existing environment\n@@ -1184,7 +1208,7 @@ fn test_extern_mod_simpler() {\n                                                ~\"-o\", exec_file.to_str()],\n                                      run::ProcessOptions {\n         env: env,\n-        dir: Some(&dir),\n+        dir: Some(dir),\n         in_fd: None,\n         out_fd: None,\n         err_fd: None\n@@ -1202,23 +1226,25 @@ fn test_extern_mod_simpler() {\n fn test_import_rustpkg() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n+    let workspace = workspace.path();\n     writeFile(&workspace.push_many([~\"src\", ~\"foo-0.1\", ~\"pkg.rs\"]),\n               \"extern mod rustpkg; fn main() {}\");\n-    command_line_test([~\"build\", ~\"foo\"], &workspace);\n+    command_line_test([~\"build\", ~\"foo\"], workspace);\n     debug2!(\"workspace = {}\", workspace.to_str());\n-    assert!(os::path_exists(&target_build_dir(&workspace).push(\"foo\").push(format!(\"pkg{}\",\n+    assert!(os::path_exists(&target_build_dir(workspace).push(\"foo\").push(format!(\"pkg{}\",\n         os::EXE_SUFFIX))));\n }\n \n #[test]\n fn test_macro_pkg_script() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n+    let workspace = workspace.path();\n     writeFile(&workspace.push_many([~\"src\", ~\"foo-0.1\", ~\"pkg.rs\"]),\n               \"extern mod rustpkg; fn main() { debug2!(\\\"Hi\\\"); }\");\n-    command_line_test([~\"build\", ~\"foo\"], &workspace);\n+    command_line_test([~\"build\", ~\"foo\"], workspace);\n     debug2!(\"workspace = {}\", workspace.to_str());\n-    assert!(os::path_exists(&target_build_dir(&workspace).push(\"foo\").push(format!(\"pkg{}\",\n+    assert!(os::path_exists(&target_build_dir(workspace).push(\"foo\").push(format!(\"pkg{}\",\n         os::EXE_SUFFIX))));\n }\n \n@@ -1228,15 +1254,16 @@ fn multiple_workspaces() {\n // Copy the exact same package into directory B and install it\n // Set the RUST_PATH to A:B\n // Make a third package that uses foo, make sure we can build/install it\n-    let a_loc = mk_temp_workspace(&Path(\"foo\"), &NoVersion).pop().pop();\n-    let b_loc = mk_temp_workspace(&Path(\"foo\"), &NoVersion).pop().pop();\n+    let (a_loc, _pkg_dir) = mk_temp_workspace(&Path(\"foo\"), &NoVersion);\n+    let (b_loc, _pkg_dir) = mk_temp_workspace(&Path(\"foo\"), &NoVersion);\n+    let (a_loc, b_loc) = (a_loc.path(), b_loc.path());\n     debug2!(\"Trying to install foo in {}\", a_loc.to_str());\n-    command_line_test([~\"install\", ~\"foo\"], &a_loc);\n+    command_line_test([~\"install\", ~\"foo\"], a_loc);\n     debug2!(\"Trying to install foo in {}\", b_loc.to_str());\n-    command_line_test([~\"install\", ~\"foo\"], &b_loc);\n+    command_line_test([~\"install\", ~\"foo\"], b_loc);\n     let env = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\", a_loc.to_str(), b_loc.to_str()))]);\n     let c_loc = create_local_package_with_dep(&PkgId::new(\"bar\"), &PkgId::new(\"foo\"));\n-    command_line_test_with_env([~\"install\", ~\"bar\"], &c_loc, env);\n+    command_line_test_with_env([~\"install\", ~\"bar\"], c_loc.path(), env);\n }\n \n fn rust_path_hack_test(hack_flag: bool) {\n@@ -1250,21 +1277,23 @@ fn rust_path_hack_test(hack_flag: bool) {\n */\n    let p_id = PkgId::new(\"foo\");\n    let workspace = create_local_package(&p_id);\n+   let workspace = workspace.path();\n    let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = dest_workspace.path();\n    let rust_path = Some(~[(~\"RUST_PATH\",\n        format!(\"{}:{}\",\n                dest_workspace.to_str(),\n                workspace.push_many([\"src\", \"foo-0.1\"]).to_str()))]);\n    command_line_test_with_env(~[~\"install\"] + if hack_flag { ~[~\"--rust-path-hack\"] } else { ~[] } +\n-                               ~[~\"foo\"], &dest_workspace, rust_path);\n-   assert_lib_exists(&dest_workspace, &Path(\"foo\"), NoVersion);\n-   assert_executable_exists(&dest_workspace, \"foo\");\n-   assert_built_library_exists(&dest_workspace, \"foo\");\n-   assert_built_executable_exists(&dest_workspace, \"foo\");\n-   assert!(!lib_exists(&workspace, &Path(\"foo\"), NoVersion));\n-   assert!(!executable_exists(&workspace, \"foo\"));\n-   assert!(!built_library_exists(&workspace, \"foo\"));\n-   assert!(!built_executable_exists(&workspace, \"foo\"));\n+                               ~[~\"foo\"], dest_workspace, rust_path);\n+   assert_lib_exists(dest_workspace, &Path(\"foo\"), NoVersion);\n+   assert_executable_exists(dest_workspace, \"foo\");\n+   assert_built_library_exists(dest_workspace, \"foo\");\n+   assert_built_executable_exists(dest_workspace, \"foo\");\n+   assert!(!lib_exists(workspace, &Path(\"foo\"), NoVersion));\n+   assert!(!executable_exists(workspace, \"foo\"));\n+   assert!(!built_library_exists(workspace, \"foo\"));\n+   assert!(!built_executable_exists(workspace, \"foo\"));\n }\n \n #[test]\n@@ -1289,83 +1318,89 @@ fn test_rust_path_can_contain_package_dirs_without_flag() {\n #[test]\n fn rust_path_hack_cwd() {\n    // Same as rust_path_hack_test, but the CWD is the dir to build out of\n-   let cwd = mkdtemp(&os::tmpdir(), \"foo\").expect(\"rust_path_hack_cwd\");\n-   let cwd = cwd.push(\"foo\");\n+   let cwd = TempDir::new(\"foo\").expect(\"rust_path_hack_cwd\");\n+   let cwd = cwd.path().push(\"foo\");\n    assert!(os::mkdir_recursive(&cwd, U_RWX));\n    writeFile(&cwd.push(\"lib.rs\"), \"pub fn f() { }\");\n \n    let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = dest_workspace.path();\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.to_str())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", ~\"foo\"], &cwd, rust_path);\n    debug2!(\"Checking that foo exists in {}\", dest_workspace.to_str());\n-   assert_lib_exists(&dest_workspace, &Path(\"foo\"), NoVersion);\n-   assert_built_library_exists(&dest_workspace, \"foo\");\n+   assert_lib_exists(dest_workspace, &Path(\"foo\"), NoVersion);\n+   assert_built_library_exists(dest_workspace, \"foo\");\n    assert!(!lib_exists(&cwd, &Path(\"foo\"), NoVersion));\n    assert!(!built_library_exists(&cwd, \"foo\"));\n }\n \n #[test]\n fn rust_path_hack_multi_path() {\n    // Same as rust_path_hack_test, but with a more complex package ID\n-   let cwd = mkdtemp(&os::tmpdir(), \"pkg_files\").expect(\"rust_path_hack_cwd\");\n-   let subdir = cwd.push_many([~\"foo\", ~\"bar\", ~\"quux\"]);\n+   let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_cwd\");\n+   let subdir = cwd.path().push_many([~\"foo\", ~\"bar\", ~\"quux\"]);\n    assert!(os::mkdir_recursive(&subdir, U_RWX));\n    writeFile(&subdir.push(\"lib.rs\"), \"pub fn f() { }\");\n    let name = ~\"foo/bar/quux\";\n \n    let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = dest_workspace.path();\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.to_str())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", name.clone()], &subdir, rust_path);\n    debug2!(\"Checking that {} exists in {}\", name, dest_workspace.to_str());\n-   assert_lib_exists(&dest_workspace, &Path(\"quux\"), NoVersion);\n-   assert_built_library_exists(&dest_workspace, name);\n+   assert_lib_exists(dest_workspace, &Path(\"quux\"), NoVersion);\n+   assert_built_library_exists(dest_workspace, name);\n    assert!(!lib_exists(&subdir, &Path(\"quux\"), NoVersion));\n    assert!(!built_library_exists(&subdir, name));\n }\n \n #[test]\n fn rust_path_hack_install_no_arg() {\n    // Same as rust_path_hack_cwd, but making rustpkg infer the pkg id\n-   let cwd = mkdtemp(&os::tmpdir(), \"pkg_files\").expect(\"rust_path_hack_install_no_arg\");\n+   let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_install_no_arg\");\n+   let cwd = cwd.path();\n    let source_dir = cwd.push(\"foo\");\n    assert!(make_dir_rwx(&source_dir));\n    writeFile(&source_dir.push(\"lib.rs\"), \"pub fn f() { }\");\n \n    let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = dest_workspace.path();\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.to_str())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n    debug2!(\"Checking that foo exists in {}\", dest_workspace.to_str());\n-   assert_lib_exists(&dest_workspace, &Path(\"foo\"), NoVersion);\n-   assert_built_library_exists(&dest_workspace, \"foo\");\n+   assert_lib_exists(dest_workspace, &Path(\"foo\"), NoVersion);\n+   assert_built_library_exists(dest_workspace, \"foo\");\n    assert!(!lib_exists(&source_dir, &Path(\"foo\"), NoVersion));\n-   assert!(!built_library_exists(&cwd, \"foo\"));\n+   assert!(!built_library_exists(cwd, \"foo\"));\n }\n \n #[test]\n fn rust_path_hack_build_no_arg() {\n    // Same as rust_path_hack_install_no_arg, but building instead of installing\n-   let cwd = mkdtemp(&os::tmpdir(), \"pkg_files\").expect(\"rust_path_hack_build_no_arg\");\n-   let source_dir = cwd.push(\"foo\");\n+   let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_build_no_arg\");\n+   let source_dir = cwd.path().push(\"foo\");\n    assert!(make_dir_rwx(&source_dir));\n    writeFile(&source_dir.push(\"lib.rs\"), \"pub fn f() { }\");\n \n    let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = dest_workspace.path();\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.to_str())]);\n    command_line_test_with_env([~\"build\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n    debug2!(\"Checking that foo exists in {}\", dest_workspace.to_str());\n-   assert_built_library_exists(&dest_workspace, \"foo\");\n+   assert_built_library_exists(dest_workspace, \"foo\");\n    assert!(!built_library_exists(&source_dir, \"foo\"));\n }\n \n #[test]\n fn rust_path_install_target() {\n-    let dir_for_path = mkdtemp(&os::tmpdir(),\n+    let dir_for_path = TempDir::new(\n         \"source_workspace\").expect(\"rust_path_install_target failed\");\n-    let dir = mk_workspace(&dir_for_path, &Path(\"foo\"), &NoVersion);\n+    let dir = mk_workspace(dir_for_path.path(), &Path(\"foo\"), &NoVersion);\n     debug2!(\"dir = {}\", dir.to_str());\n     writeFile(&dir.push(\"main.rs\"), \"fn main() { let _x = (); }\");\n-    let dir_to_install_to = mkdtemp(&os::tmpdir(),\n+    let dir_to_install_to = TempDir::new(\n         \"dest_workspace\").expect(\"rust_path_install_target failed\");\n+    let dir_to_install_to = dir_to_install_to.path();\n     let dir = dir.pop().pop();\n \n     let rust_path = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\", dir_to_install_to.to_str(),\n@@ -1375,54 +1410,58 @@ fn rust_path_install_target() {\n                                &cwd,\n                                rust_path);\n \n-    assert_executable_exists(&dir_to_install_to, \"foo\");\n+    assert_executable_exists(dir_to_install_to, \"foo\");\n \n }\n \n #[test]\n fn sysroot_flag() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n+    let workspace = workspace.path();\n     // no-op sysroot setting; I'm not sure how else to test this\n     command_line_test([~\"--sysroot\",\n                        test_sysroot().to_str(),\n                        ~\"build\",\n                        ~\"foo\"],\n-                      &workspace);\n-    assert_built_executable_exists(&workspace, \"foo\");\n+                      workspace);\n+    assert_built_executable_exists(workspace, \"foo\");\n }\n \n #[test]\n fn compile_flag_build() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n+    let workspace = workspace.path();\n     command_line_test([test_sysroot().to_str(),\n                        ~\"build\",\n                        ~\"--no-link\",\n                        ~\"foo\"],\n-                      &workspace);\n-    assert!(!built_executable_exists(&workspace, \"foo\"));\n-    assert!(object_file_exists(&workspace, \"foo\"));\n+                      workspace);\n+    assert!(!built_executable_exists(workspace, \"foo\"));\n+    assert!(object_file_exists(workspace, \"foo\"));\n }\n \n #[test]\n fn compile_flag_fail() {\n     // --no-link shouldn't be accepted for install\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n+    let workspace = workspace.path();\n     command_line_test([test_sysroot().to_str(),\n                        ~\"install\",\n                        ~\"--no-link\",\n                        ~\"foo\"],\n-                      &workspace);\n-    assert!(!built_executable_exists(&workspace, \"foo\"));\n-    assert!(!object_file_exists(&workspace, \"foo\"));\n+                      workspace);\n+    assert!(!built_executable_exists(workspace, \"foo\"));\n+    assert!(!object_file_exists(workspace, \"foo\"));\n }\n \n #[test]\n fn notrans_flag_build() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n+    let workspace = workspace.path();\n     let flags_to_test = [~\"--no-trans\", ~\"--parse-only\",\n                          ~\"--pretty\", ~\"-S\"];\n \n@@ -1431,12 +1470,12 @@ fn notrans_flag_build() {\n                            ~\"build\",\n                            flag.clone(),\n                            ~\"foo\"],\n-                          &workspace);\n+                          workspace);\n         // Ideally we'd test that rustpkg actually succeeds, but\n         // since task failure doesn't set the exit code properly,\n         // we can't tell\n-        assert!(!built_executable_exists(&workspace, \"foo\"));\n-        assert!(!object_file_exists(&workspace, \"foo\"));\n+        assert!(!built_executable_exists(workspace, \"foo\"));\n+        assert!(!object_file_exists(workspace, \"foo\"));\n     }\n }\n \n@@ -1445,55 +1484,59 @@ fn notrans_flag_fail() {\n     // --no-trans shouldn't be accepted for install\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n+    let workspace = workspace.path();\n     let flags_to_test = [~\"--no-trans\", ~\"--parse-only\",\n                          ~\"--pretty\", ~\"-S\"];\n     for flag in flags_to_test.iter() {\n         command_line_test([test_sysroot().to_str(),\n                            ~\"install\",\n                            flag.clone(),\n                            ~\"foo\"],\n-                          &workspace);\n+                          workspace);\n         // Ideally we'd test that rustpkg actually fails, but\n         // since task failure doesn't set the exit code properly,\n         // we can't tell\n-        assert!(!built_executable_exists(&workspace, \"foo\"));\n-        assert!(!object_file_exists(&workspace, \"foo\"));\n-        assert!(!lib_exists(&workspace, &Path(\"foo\"), NoVersion));\n+        assert!(!built_executable_exists(workspace, \"foo\"));\n+        assert!(!object_file_exists(workspace, \"foo\"));\n+        assert!(!lib_exists(workspace, &Path(\"foo\"), NoVersion));\n     }\n }\n \n #[test]\n fn dash_S() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n+    let workspace = workspace.path();\n     command_line_test([test_sysroot().to_str(),\n                        ~\"build\",\n                        ~\"-S\",\n                        ~\"foo\"],\n-                      &workspace);\n-    assert!(!built_executable_exists(&workspace, \"foo\"));\n-    assert!(!object_file_exists(&workspace, \"foo\"));\n-    assert!(assembly_file_exists(&workspace, \"foo\"));\n+                      workspace);\n+    assert!(!built_executable_exists(workspace, \"foo\"));\n+    assert!(!object_file_exists(workspace, \"foo\"));\n+    assert!(assembly_file_exists(workspace, \"foo\"));\n }\n \n #[test]\n fn dash_S_fail() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n+    let workspace = workspace.path();\n     command_line_test([test_sysroot().to_str(),\n                        ~\"install\",\n                        ~\"-S\",\n                        ~\"foo\"],\n-                      &workspace);\n-    assert!(!built_executable_exists(&workspace, \"foo\"));\n-    assert!(!object_file_exists(&workspace, \"foo\"));\n-    assert!(!assembly_file_exists(&workspace, \"foo\"));\n+                      workspace);\n+    assert!(!built_executable_exists(workspace, \"foo\"));\n+    assert!(!object_file_exists(workspace, \"foo\"));\n+    assert!(!assembly_file_exists(workspace, \"foo\"));\n }\n \n #[test]\n fn test_cfg_build() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n+    let workspace = workspace.path();\n     // If the cfg flag gets messed up, this won't compile\n     writeFile(&workspace.push_many([\"src\", \"foo-0.1\", \"main.rs\"]),\n                \"#[cfg(quux)] fn main() {}\");\n@@ -1502,20 +1545,21 @@ fn test_cfg_build() {\n                        ~\"--cfg\",\n                        ~\"quux\",\n                        ~\"foo\"],\n-                      &workspace);\n-    assert_built_executable_exists(&workspace, \"foo\");\n+                      workspace);\n+    assert_built_executable_exists(workspace, \"foo\");\n }\n \n #[test]\n fn test_cfg_fail() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n+    let workspace = workspace.path();\n     writeFile(&workspace.push_many([\"src\", \"foo-0.1\", \"main.rs\"]),\n                \"#[cfg(quux)] fn main() {}\");\n     match command_line_test_partial([test_sysroot().to_str(),\n                        ~\"build\",\n                        ~\"foo\"],\n-                      &workspace) {\n+                      workspace) {\n         Success(*) => fail2!(\"test_cfg_fail failed\"),\n         _          => ()\n     }\n@@ -1526,68 +1570,73 @@ fn test_cfg_fail() {\n fn test_emit_llvm_S_build() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n+    let workspace = workspace.path();\n     command_line_test([test_sysroot().to_str(),\n                        ~\"build\",\n                        ~\"-S\", ~\"--emit-llvm\",\n                        ~\"foo\"],\n-                      &workspace);\n-    assert!(!built_executable_exists(&workspace, \"foo\"));\n-    assert!(!object_file_exists(&workspace, \"foo\"));\n-    assert!(llvm_assembly_file_exists(&workspace, \"foo\"));\n-    assert!(!assembly_file_exists(&workspace, \"foo\"));\n+                      workspace);\n+    assert!(!built_executable_exists(workspace, \"foo\"));\n+    assert!(!object_file_exists(workspace, \"foo\"));\n+    assert!(llvm_assembly_file_exists(workspace, \"foo\"));\n+    assert!(!assembly_file_exists(workspace, \"foo\"));\n }\n \n #[test]\n fn test_emit_llvm_S_fail() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n+    let workspace = workspace.path();\n     command_line_test([test_sysroot().to_str(),\n                        ~\"install\",\n                        ~\"-S\", ~\"--emit-llvm\",\n                        ~\"foo\"],\n-                      &workspace);\n-    assert!(!built_executable_exists(&workspace, \"foo\"));\n-    assert!(!object_file_exists(&workspace, \"foo\"));\n-    assert!(!llvm_assembly_file_exists(&workspace, \"foo\"));\n-    assert!(!assembly_file_exists(&workspace, \"foo\"));\n+                      workspace);\n+    assert!(!built_executable_exists(workspace, \"foo\"));\n+    assert!(!object_file_exists(workspace, \"foo\"));\n+    assert!(!llvm_assembly_file_exists(workspace, \"foo\"));\n+    assert!(!assembly_file_exists(workspace, \"foo\"));\n }\n \n #[test]\n fn test_emit_llvm_build() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n+    let workspace = workspace.path();\n     command_line_test([test_sysroot().to_str(),\n                        ~\"build\",\n                        ~\"--emit-llvm\",\n                        ~\"foo\"],\n-                      &workspace);\n-    assert!(!built_executable_exists(&workspace, \"foo\"));\n-    assert!(!object_file_exists(&workspace, \"foo\"));\n-    assert!(llvm_bitcode_file_exists(&workspace, \"foo\"));\n-    assert!(!assembly_file_exists(&workspace, \"foo\"));\n-    assert!(!llvm_assembly_file_exists(&workspace, \"foo\"));\n+                      workspace);\n+    assert!(!built_executable_exists(workspace, \"foo\"));\n+    assert!(!object_file_exists(workspace, \"foo\"));\n+    assert!(llvm_bitcode_file_exists(workspace, \"foo\"));\n+    assert!(!assembly_file_exists(workspace, \"foo\"));\n+    assert!(!llvm_assembly_file_exists(workspace, \"foo\"));\n }\n \n #[test]\n fn test_emit_llvm_fail() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n+    let workspace = workspace.path();\n     command_line_test([test_sysroot().to_str(),\n                        ~\"install\",\n                        ~\"--emit-llvm\",\n                        ~\"foo\"],\n-                      &workspace);\n-    assert!(!built_executable_exists(&workspace, \"foo\"));\n-    assert!(!object_file_exists(&workspace, \"foo\"));\n-    assert!(!llvm_bitcode_file_exists(&workspace, \"foo\"));\n-    assert!(!llvm_assembly_file_exists(&workspace, \"foo\"));\n-    assert!(!assembly_file_exists(&workspace, \"foo\"));\n+                      workspace);\n+    assert!(!built_executable_exists(workspace, \"foo\"));\n+    assert!(!object_file_exists(workspace, \"foo\"));\n+    assert!(!llvm_bitcode_file_exists(workspace, \"foo\"));\n+    assert!(!llvm_assembly_file_exists(workspace, \"foo\"));\n+    assert!(!assembly_file_exists(workspace, \"foo\"));\n }\n \n #[test]\n fn test_linker_build() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n+    let workspace = workspace.path();\n     let matches = getopts([], optgroups());\n     let options = build_session_options(@\"rustpkg\",\n                                         matches.get_ref(),\n@@ -1601,8 +1650,8 @@ fn test_linker_build() {\n                        ~\"--linker\",\n                        get_cc_prog(sess),\n                        ~\"foo\"],\n-                      &workspace);\n-    assert_executable_exists(&workspace, \"foo\");\n+                      workspace);\n+    assert_executable_exists(workspace, \"foo\");\n }\n \n #[test]\n@@ -1628,18 +1677,20 @@ fn test_build_install_flags_fail() {\n fn test_optimized_build() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n+    let workspace = workspace.path();\n     command_line_test([test_sysroot().to_str(),\n                        ~\"build\",\n                        ~\"-O\",\n                        ~\"foo\"],\n-                      &workspace);\n-    assert!(built_executable_exists(&workspace, \"foo\"));\n+                      workspace);\n+    assert!(built_executable_exists(workspace, \"foo\"));\n }\n \n fn pkgid_pointing_to_subdir() {\n     // The actual repo is mockgithub.com/mozilla/some_repo\n     // rustpkg should recognize that and treat the part after some_repo/ as a subdir\n-    let workspace = mkdtemp(&os::tmpdir(), \"parent_repo\").expect(\"Couldn't create temp dir\");\n+    let workspace = TempDir::new(\"parent_repo\").expect(\"Couldn't create temp dir\");\n+    let workspace = workspace.path();\n     assert!(os::mkdir_recursive(&workspace.push_many([~\"src\", ~\"mockgithub.com\",\n                                                      ~\"mozilla\", ~\"some_repo\"]), U_RWX));\n \n@@ -1662,37 +1713,41 @@ fn pkgid_pointing_to_subdir() {\n                use foo::f; use bar::g; \\n\n                fn main() { f(); g(); }\");\n \n-    command_line_test([~\"install\", ~\"testpkg\"], &workspace);\n-    assert_executable_exists(&workspace, \"testpkg\");\n+    command_line_test([~\"install\", ~\"testpkg\"], workspace);\n+    assert_executable_exists(workspace, \"testpkg\");\n }\n \n fn test_recursive_deps() {\n     let a_id = PkgId::new(\"a\");\n     let b_id = PkgId::new(\"b\");\n     let c_id = PkgId::new(\"c\");\n     let b_workspace = create_local_package_with_dep(&b_id, &c_id);\n+    let b_workspace = b_workspace.path();\n     writeFile(&b_workspace.push(\"src\").push(\"c-0.1\").push(\"lib.rs\"),\n                \"pub fn g() {}\");\n     let a_workspace = create_local_package(&a_id);\n+    let a_workspace = a_workspace.path();\n     writeFile(&a_workspace.push(\"src\").push(\"a-0.1\").push(\"main.rs\"),\n                \"extern mod b; use b::f; fn main() { f(); }\");\n     writeFile(&b_workspace.push(\"src\").push(\"b-0.1\").push(\"lib.rs\"),\n                \"extern mod c; use c::g; pub fn f() { g(); }\");\n     let environment = Some(~[(~\"RUST_PATH\", b_workspace.to_str())]);\n     debug2!(\"RUST_PATH={}\", b_workspace.to_str());\n     command_line_test_with_env([~\"install\", ~\"a\"],\n-                               &a_workspace,\n+                               a_workspace,\n                                environment);\n-    assert_lib_exists(&a_workspace, &Path(\"a\"), NoVersion);\n-    assert_lib_exists(&b_workspace, &Path(\"b\"), NoVersion);\n-    assert_lib_exists(&b_workspace, &Path(\"c\"), NoVersion);\n+    assert_lib_exists(a_workspace, &Path(\"a\"), NoVersion);\n+    assert_lib_exists(b_workspace, &Path(\"b\"), NoVersion);\n+    assert_lib_exists(b_workspace, &Path(\"c\"), NoVersion);\n }\n \n #[test]\n fn test_install_to_rust_path() {\n     let p_id = PkgId::new(\"foo\");\n     let second_workspace = create_local_package(&p_id);\n+    let second_workspace = second_workspace.path();\n     let first_workspace = mk_empty_workspace(&Path(\"p\"), &NoVersion, \"dest\");\n+    let first_workspace = first_workspace.path();\n     let rust_path = Some(~[(~\"RUST_PATH\",\n                             format!(\"{}:{}\", first_workspace.to_str(),\n                                  second_workspace.to_str()))]);\n@@ -1701,88 +1756,93 @@ fn test_install_to_rust_path() {\n                        ~\"install\",\n                        ~\"foo\"],\n                       &os::getcwd(), rust_path);\n-    assert!(!built_executable_exists(&first_workspace, \"foo\"));\n-    assert!(built_executable_exists(&second_workspace, \"foo\"));\n-    assert_executable_exists(&first_workspace, \"foo\");\n-    assert!(!executable_exists(&second_workspace, \"foo\"));\n+    assert!(!built_executable_exists(first_workspace, \"foo\"));\n+    assert!(built_executable_exists(second_workspace, \"foo\"));\n+    assert_executable_exists(first_workspace, \"foo\");\n+    assert!(!executable_exists(second_workspace, \"foo\"));\n }\n \n fn test_target_specific_build_dir() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n+    let workspace = workspace.path();\n     command_line_test([test_sysroot().to_str(),\n                        ~\"build\",\n                        ~\"foo\"],\n-                      &workspace);\n-    assert!(os::path_is_dir(&target_build_dir(&workspace)));\n-    assert!(built_executable_exists(&workspace, \"foo\"));\n+                      workspace);\n+    assert!(os::path_is_dir(&target_build_dir(workspace)));\n+    assert!(built_executable_exists(workspace, \"foo\"));\n     assert!(os::list_dir(&workspace.push(\"build\")).len() == 1);\n }\n \n #[test]\n fn test_target_specific_install_dir() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n+    let workspace = workspace.path();\n     command_line_test([test_sysroot().to_str(),\n                        ~\"install\",\n                        ~\"foo\"],\n-                      &workspace);\n+                      workspace);\n     assert!(os::path_is_dir(&workspace.push(\"lib\").push(host_triple())));\n-    assert_lib_exists(&workspace, &Path(\"foo\"), NoVersion);\n+    assert_lib_exists(workspace, &Path(\"foo\"), NoVersion);\n     assert!(os::list_dir(&workspace.push(\"lib\")).len() == 1);\n     assert!(os::path_is_dir(&workspace.push(\"bin\")));\n-    assert_executable_exists(&workspace, \"foo\");\n+    assert_executable_exists(workspace, \"foo\");\n }\n \n #[test]\n #[ignore(reason = \"See #7240\")]\n fn test_dependencies_terminate() {\n     let b_id = PkgId::new(\"b\");\n     let workspace = create_local_package(&b_id);\n+    let workspace = workspace.path();\n     let b_dir = workspace.push_many([~\"src\", ~\"b-0.1\"]);\n     let b_subdir = b_dir.push(\"test\");\n     assert!(os::mkdir_recursive(&b_subdir, U_RWX));\n     writeFile(&b_subdir.push(\"test.rs\"),\n               \"extern mod b; use b::f; #[test] fn g() { f() }\");\n-    command_line_test([~\"install\", ~\"b\"], &workspace);\n+    command_line_test([~\"install\", ~\"b\"], workspace);\n }\n \n #[test]\n fn install_after_build() {\n     let b_id = PkgId::new(\"b\");\n     let workspace = create_local_package(&b_id);\n-    command_line_test([~\"build\", ~\"b\"], &workspace);\n-    command_line_test([~\"install\", ~\"b\"], &workspace);\n-    assert_executable_exists(&workspace, b_id.short_name);\n-    assert_lib_exists(&workspace, &b_id.path, NoVersion);\n+    let workspace = workspace.path();\n+    command_line_test([~\"build\", ~\"b\"], workspace);\n+    command_line_test([~\"install\", ~\"b\"], workspace);\n+    assert_executable_exists(workspace, b_id.short_name);\n+    assert_lib_exists(workspace, &b_id.path, NoVersion);\n }\n \n #[test]\n fn reinstall() {\n     let b = PkgId::new(\"b\");\n     let workspace = create_local_package(&b);\n+    let workspace = workspace.path();\n     // 1. Install, then remove executable file, then install again,\n     // and make sure executable was re-installed\n-    command_line_test([~\"install\", ~\"b\"], &workspace);\n-    assert_executable_exists(&workspace, b.short_name);\n-    assert_lib_exists(&workspace, &b.path, NoVersion);\n-    remove_executable_file(&b, &workspace);\n-    command_line_test([~\"install\", ~\"b\"], &workspace);\n-    assert_executable_exists(&workspace, b.short_name);\n+    command_line_test([~\"install\", ~\"b\"], workspace);\n+    assert_executable_exists(workspace, b.short_name);\n+    assert_lib_exists(workspace, &b.path, NoVersion);\n+    remove_executable_file(&b, workspace);\n+    command_line_test([~\"install\", ~\"b\"], workspace);\n+    assert_executable_exists(workspace, b.short_name);\n     // 2. Build, then remove build executable file, then build again,\n     // and make sure executable was re-built.\n-    command_line_test([~\"build\", ~\"b\"], &workspace);\n-    remove_built_executable_file(&b, &workspace);\n-    command_line_test([~\"build\", ~\"b\"], &workspace);\n-    assert_built_executable_exists(&workspace, b.short_name);\n+    command_line_test([~\"build\", ~\"b\"], workspace);\n+    remove_built_executable_file(&b, workspace);\n+    command_line_test([~\"build\", ~\"b\"], workspace);\n+    assert_built_executable_exists(workspace, b.short_name);\n     // 3. Install, then remove both executable and built executable,\n     // then install again, make sure both were recreated\n-    command_line_test([~\"install\", ~\"b\"], &workspace);\n-    remove_executable_file(&b, &workspace);\n-    remove_built_executable_file(&b, &workspace);\n-    command_line_test([~\"install\", ~\"b\"], &workspace);\n-    assert_executable_exists(&workspace, b.short_name);\n-    assert_built_executable_exists(&workspace, b.short_name);\n+    command_line_test([~\"install\", ~\"b\"], workspace);\n+    remove_executable_file(&b, workspace);\n+    remove_built_executable_file(&b, workspace);\n+    command_line_test([~\"install\", ~\"b\"], workspace);\n+    assert_executable_exists(workspace, b.short_name);\n+    assert_built_executable_exists(workspace, b.short_name);\n }\n \n #[test]\n@@ -1800,7 +1860,9 @@ fn correct_package_name_with_rust_path_hack() {\n     let foo_id = PkgId::new(\"foo\");\n     let bar_id = PkgId::new(\"bar\");\n     let foo_workspace = create_local_package(&foo_id);\n+    let foo_workspace = foo_workspace.path();\n     let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n+    let dest_workspace = dest_workspace.path();\n \n     writeFile(&dest_workspace.push_many([\"src\", \"bar-0.1\", \"main.rs\"]),\n               \"extern mod blat; fn main() { let _x = (); }\");\n@@ -1809,31 +1871,32 @@ fn correct_package_name_with_rust_path_hack() {\n                         foo_workspace.push_many([\"src\", \"foo-0.1\"]).to_str()))]);\n     // bar doesn't exist, but we want to make sure rustpkg doesn't think foo is bar\n     command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", ~\"bar\"],\n-                               &dest_workspace, rust_path);\n-    assert!(!executable_exists(&dest_workspace, \"bar\"));\n-    assert!(!lib_exists(&dest_workspace, &bar_id.path.clone(), bar_id.version.clone()));\n-    assert!(!executable_exists(&dest_workspace, \"foo\"));\n-    assert!(!lib_exists(&dest_workspace, &foo_id.path.clone(), foo_id.version.clone()));\n-    assert!(!executable_exists(&foo_workspace, \"bar\"));\n-    assert!(!lib_exists(&foo_workspace, &bar_id.path.clone(), bar_id.version.clone()));\n-    assert!(!executable_exists(&foo_workspace, \"foo\"));\n-    assert!(!lib_exists(&foo_workspace, &foo_id.path.clone(), foo_id.version.clone()));\n+                               dest_workspace, rust_path);\n+    assert!(!executable_exists(dest_workspace, \"bar\"));\n+    assert!(!lib_exists(dest_workspace, &bar_id.path.clone(), bar_id.version.clone()));\n+    assert!(!executable_exists(dest_workspace, \"foo\"));\n+    assert!(!lib_exists(dest_workspace, &foo_id.path.clone(), foo_id.version.clone()));\n+    assert!(!executable_exists(foo_workspace, \"bar\"));\n+    assert!(!lib_exists(foo_workspace, &bar_id.path.clone(), bar_id.version.clone()));\n+    assert!(!executable_exists(foo_workspace, \"foo\"));\n+    assert!(!lib_exists(foo_workspace, &foo_id.path.clone(), foo_id.version.clone()));\n }\n \n #[test]\n fn test_rustpkg_test_creates_exec() {\n     let foo_id = PkgId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n+    let foo_workspace = foo_workspace.path();\n     writeFile(&foo_workspace.push_many([\"src\", \"foo-0.1\", \"test.rs\"]),\n               \"#[test] fn f() { assert!('a' == 'a'); }\");\n-    command_line_test([~\"test\", ~\"foo\"], &foo_workspace);\n-    assert!(test_executable_exists(&foo_workspace, \"foo\"));\n+    command_line_test([~\"test\", ~\"foo\"], foo_workspace);\n+    assert!(test_executable_exists(foo_workspace, \"foo\"));\n }\n \n #[test]\n fn test_rustpkg_test_output() {\n     let workspace = create_local_package_with_test(&PkgId::new(\"foo\"));\n-    let output = command_line_test([~\"test\", ~\"foo\"], &workspace);\n+    let output = command_line_test([~\"test\", ~\"foo\"], workspace.path());\n     let output_str = str::from_utf8(output.output);\n     // The first two assertions are separate because test output may\n     // contain color codes, which could appear between \"test f\" and \"ok\".\n@@ -1847,15 +1910,16 @@ fn test_rustpkg_test_output() {\n fn test_rebuild_when_needed() {\n     let foo_id = PkgId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n+    let foo_workspace = foo_workspace.path();\n     let test_crate = foo_workspace.push_many([\"src\", \"foo-0.1\", \"test.rs\"]);\n     writeFile(&test_crate, \"#[test] fn f() { assert!('a' == 'a'); }\");\n-    command_line_test([~\"test\", ~\"foo\"], &foo_workspace);\n-    assert!(test_executable_exists(&foo_workspace, \"foo\"));\n+    command_line_test([~\"test\", ~\"foo\"], foo_workspace);\n+    assert!(test_executable_exists(foo_workspace, \"foo\"));\n     let test_executable = built_test_in_workspace(&foo_id,\n-            &foo_workspace).expect(\"test_rebuild_when_needed failed\");\n-    frob_source_file(&foo_workspace, &foo_id, \"test.rs\");\n+            foo_workspace).expect(\"test_rebuild_when_needed failed\");\n+    frob_source_file(foo_workspace, &foo_id, \"test.rs\");\n     chmod_read_only(&test_executable);\n-    match command_line_test_partial([~\"test\", ~\"foo\"], &foo_workspace) {\n+    match command_line_test_partial([~\"test\", ~\"foo\"], foo_workspace) {\n         Success(*) => fail2!(\"test_rebuild_when_needed didn't rebuild\"),\n         Fail(status) if status == 65 => (), // ok\n         Fail(_) => fail2!(\"test_rebuild_when_needed failed for some other reason\")\n@@ -1866,14 +1930,15 @@ fn test_rebuild_when_needed() {\n fn test_no_rebuilding() {\n     let foo_id = PkgId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n+    let foo_workspace = foo_workspace.path();\n     let test_crate = foo_workspace.push_many([\"src\", \"foo-0.1\", \"test.rs\"]);\n     writeFile(&test_crate, \"#[test] fn f() { assert!('a' == 'a'); }\");\n-    command_line_test([~\"test\", ~\"foo\"], &foo_workspace);\n-    assert!(test_executable_exists(&foo_workspace, \"foo\"));\n+    command_line_test([~\"test\", ~\"foo\"], foo_workspace);\n+    assert!(test_executable_exists(foo_workspace, \"foo\"));\n     let test_executable = built_test_in_workspace(&foo_id,\n-                            &foo_workspace).expect(\"test_no_rebuilding failed\");\n+                            foo_workspace).expect(\"test_no_rebuilding failed\");\n     chmod_read_only(&test_executable);\n-    match command_line_test_partial([~\"test\", ~\"foo\"], &foo_workspace) {\n+    match command_line_test_partial([~\"test\", ~\"foo\"], foo_workspace) {\n         Success(*) => (), // ok\n         Fail(status) if status == 65 => fail2!(\"test_no_rebuilding failed: it rebuilt the tests\"),\n         Fail(_) => fail2!(\"test_no_rebuilding failed for some other reason\")\n@@ -1886,6 +1951,7 @@ fn test_installed_read_only() {\n     // Check that afterward, sources are read-only and installed under build/\n     let temp_pkg_id = git_repo_pkg();\n     let repo = init_git_repo(&temp_pkg_id.path);\n+    let repo = repo.path();\n     debug2!(\"repo = {}\", repo.to_str());\n     let repo_subdir = repo.push_many([~\"mockgithub.com\", ~\"catamorphism\", ~\"test-pkg\"]);\n     debug2!(\"repo_subdir = {}\", repo_subdir.to_str());\n@@ -1896,7 +1962,7 @@ fn test_installed_read_only() {\n               \"pub fn f() { let _x = (); }\");\n     add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n \n-    command_line_test([~\"install\", temp_pkg_id.path.to_str()], &repo);\n+    command_line_test([~\"install\", temp_pkg_id.path.to_str()], repo);\n \n     let ws = repo.push(\".rust\");\n     // Check that all files exist\n@@ -1924,6 +1990,7 @@ fn test_installed_read_only() {\n fn test_installed_local_changes() {\n     let temp_pkg_id = git_repo_pkg();\n     let repo = init_git_repo(&temp_pkg_id.path);\n+    let repo = repo.path();\n     debug2!(\"repo = {}\", repo.to_str());\n     let repo_subdir = repo.push_many([~\"mockgithub.com\", ~\"catamorphism\", ~\"test-pkg\"]);\n     debug2!(\"repo_subdir = {}\", repo_subdir.to_str());\n@@ -1935,12 +2002,13 @@ fn test_installed_local_changes() {\n               \"pub fn f() { let _x = (); }\");\n     add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n \n-    command_line_test([~\"install\", temp_pkg_id.path.to_str()], &repo);\n+    command_line_test([~\"install\", temp_pkg_id.path.to_str()], repo);\n \n \n     // We installed the dependency.\n     // Now start a new workspace and clone it into it\n     let hacking_workspace = mk_emptier_workspace(\"hacking_workspace\");\n+    let hacking_workspace = hacking_workspace.path();\n     let target_dir = hacking_workspace.push_many([~\"src\",\n                                                   ~\"mockgithub.com\",\n                                                   ~\"catamorphism\",\n@@ -1960,25 +2028,26 @@ fn test_installed_local_changes() {\n \n     // Finally, make *another* package that uses it\n     let importer_pkg_id = fake_pkg();\n-    let main_subdir = create_local_package_in(&importer_pkg_id, &hacking_workspace);\n+    let main_subdir = create_local_package_in(&importer_pkg_id, hacking_workspace);\n     writeFile(&main_subdir.push(\"main.rs\"),\n               \"extern mod test = \\\"mockgithub.com/catamorphism/test-pkg\\\"; \\\n               use test::g;\n               fn main() { g(); }\");\n     // And make sure we can build it\n \n-    command_line_test([~\"build\", importer_pkg_id.path.to_str()], &hacking_workspace);\n+    command_line_test([~\"build\", importer_pkg_id.path.to_str()], hacking_workspace);\n }\n \n #[test]\n fn test_7402() {\n     let dir = create_local_package(&PkgId::new(\"foo\"));\n-    let dest_workspace = mkdtemp(&os::tmpdir(), \"more_rust\").expect(\"test_7402\");\n+    let dest_workspace = TempDir::new(\"more_rust\").expect(\"test_7402\");\n+    let dest_workspace = dest_workspace.path();\n     let rust_path = Some(~[(~\"RUST_PATH\",\n-                            format!(\"{}:{}\", dest_workspace.to_str(), dir.to_str()))]);\n+                            format!(\"{}:{}\", dest_workspace.to_str(), dir.path().to_str()))]);\n     let cwd = os::getcwd();\n     command_line_test_with_env([~\"install\", ~\"foo\"], &cwd, rust_path);\n-    assert_executable_exists(&dest_workspace, \"foo\");\n+    assert_executable_exists(dest_workspace, \"foo\");\n }\n \n /// Returns true if p exists and is executable"}, {"sha": "17b3cad0c2c3cae1c668c2890ef930d6b5a76211", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94", "patch": "@@ -15,7 +15,7 @@ extern mod std;\n \n use extra::semver;\n use std::{char, os, result, run, str};\n-use extra::tempfile::mkdtemp;\n+use extra::tempfile::TempDir;\n use path_util::rust_path;\n \n #[deriving(Clone)]\n@@ -132,8 +132,9 @@ pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n /// otherwise, `None`\n pub fn try_getting_version(remote_path: &Path) -> Option<Version> {\n     if is_url_like(remote_path) {\n-        let tmp_dir = mkdtemp(&os::tmpdir(),\n-                              \"test\").expect(\"try_getting_version: couldn't create temp dir\");\n+        let tmp_dir = TempDir::new(\"test\");\n+        let tmp_dir = tmp_dir.expect(\"try_getting_version: couldn't create temp dir\");\n+        let tmp_dir = tmp_dir.path();\n         debug2!(\"(to get version) executing \\\\{git clone https://{} {}\\\\}\",\n                remote_path.to_str(),\n                tmp_dir.to_str());"}, {"sha": "08843c28a0436b647be41dfa64023432db8c032e", "filename": "src/test/run-pass/glob-std.rs", "status": "modified", "additions": 147, "deletions": 156, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94/src%2Ftest%2Frun-pass%2Fglob-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94/src%2Ftest%2Frun-pass%2Fglob-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fglob-std.rs?ref=63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94", "patch": "@@ -13,19 +13,11 @@\n extern mod extra;\n \n use extra::glob::glob;\n-use extra::tempfile;\n+use extra::tempfile::TempDir;\n use std::unstable::finally::Finally;\n use std::{io, os, unstable};\n \n pub fn main() {\n-    fn change_then_remove(p: &Path, f: &fn()) {\n-        assert!(os::change_dir(p));\n-\n-        do f.finally {\n-            os::remove_dir_recursive(p);\n-        }\n-    }\n-\n     fn mk_file(path: &str, directory: bool) {\n         if directory {\n             os::make_dir(&Path(path), 0xFFFF);\n@@ -42,162 +34,161 @@ pub fn main() {\n         glob(pattern).collect()\n     }\n \n-    let root = tempfile::mkdtemp(&os::tmpdir(), \"glob-tests\");\n+    let root = TempDir::new(\"glob-tests\");\n     let root = root.expect(\"Should have created a temp directory\");\n+    assert!(os::change_dir(root.path()));\n+\n+    mk_file(\"aaa\", true);\n+    mk_file(\"aaa/apple\", true);\n+    mk_file(\"aaa/orange\", true);\n+    mk_file(\"aaa/tomato\", true);\n+    mk_file(\"aaa/tomato/tomato.txt\", false);\n+    mk_file(\"aaa/tomato/tomoto.txt\", false);\n+    mk_file(\"bbb\", true);\n+    mk_file(\"bbb/specials\", true);\n+    mk_file(\"bbb/specials/!\", false);\n+\n+    // windows does not allow `*` or `?` characters to exist in filenames\n+    if os::consts::FAMILY != os::consts::windows::FAMILY {\n+        mk_file(\"bbb/specials/*\", false);\n+        mk_file(\"bbb/specials/?\", false);\n+    }\n \n-    do change_then_remove(&root) {\n-        mk_file(\"aaa\", true);\n-        mk_file(\"aaa/apple\", true);\n-        mk_file(\"aaa/orange\", true);\n-        mk_file(\"aaa/tomato\", true);\n-        mk_file(\"aaa/tomato/tomato.txt\", false);\n-        mk_file(\"aaa/tomato/tomoto.txt\", false);\n-        mk_file(\"bbb\", true);\n-        mk_file(\"bbb/specials\", true);\n-        mk_file(\"bbb/specials/!\", false);\n-\n-        // windows does not allow `*` or `?` characters to exist in filenames\n-        if os::consts::FAMILY != os::consts::windows::FAMILY {\n-            mk_file(\"bbb/specials/*\", false);\n-            mk_file(\"bbb/specials/?\", false);\n-        }\n+    mk_file(\"bbb/specials/[\", false);\n+    mk_file(\"bbb/specials/]\", false);\n+    mk_file(\"ccc\", true);\n+    mk_file(\"xyz\", true);\n+    mk_file(\"xyz/x\", false);\n+    mk_file(\"xyz/y\", false);\n+    mk_file(\"xyz/z\", false);\n+\n+    assert_eq!(glob_vec(\"\"), ~[]);\n+    assert_eq!(glob_vec(\".\"), ~[]);\n+    assert_eq!(glob_vec(\"..\"), ~[]);\n+\n+    assert_eq!(glob_vec(\"aaa\"), ~[abs_path(\"aaa\")]);\n+    assert_eq!(glob_vec(\"aaa/\"), ~[abs_path(\"aaa\")]);\n+    assert_eq!(glob_vec(\"a\"), ~[]);\n+    assert_eq!(glob_vec(\"aa\"), ~[]);\n+    assert_eq!(glob_vec(\"aaaa\"), ~[]);\n+\n+    assert_eq!(glob_vec(\"aaa/apple\"), ~[abs_path(\"aaa/apple\")]);\n+    assert_eq!(glob_vec(\"aaa/apple/nope\"), ~[]);\n+\n+    // windows should support both / and \\ as directory separators\n+    if os::consts::FAMILY == os::consts::windows::FAMILY {\n+        assert_eq!(glob_vec(\"aaa\\\\apple\"), ~[abs_path(\"aaa/apple\")]);\n+    }\n \n-        mk_file(\"bbb/specials/[\", false);\n-        mk_file(\"bbb/specials/]\", false);\n-        mk_file(\"ccc\", true);\n-        mk_file(\"xyz\", true);\n-        mk_file(\"xyz/x\", false);\n-        mk_file(\"xyz/y\", false);\n-        mk_file(\"xyz/z\", false);\n-\n-        assert_eq!(glob_vec(\"\"), ~[]);\n-        assert_eq!(glob_vec(\".\"), ~[]);\n-        assert_eq!(glob_vec(\"..\"), ~[]);\n-\n-        assert_eq!(glob_vec(\"aaa\"), ~[abs_path(\"aaa\")]);\n-        assert_eq!(glob_vec(\"aaa/\"), ~[abs_path(\"aaa\")]);\n-        assert_eq!(glob_vec(\"a\"), ~[]);\n-        assert_eq!(glob_vec(\"aa\"), ~[]);\n-        assert_eq!(glob_vec(\"aaaa\"), ~[]);\n-\n-        assert_eq!(glob_vec(\"aaa/apple\"), ~[abs_path(\"aaa/apple\")]);\n-        assert_eq!(glob_vec(\"aaa/apple/nope\"), ~[]);\n-\n-        // windows should support both / and \\ as directory separators\n-        if os::consts::FAMILY == os::consts::windows::FAMILY {\n-            assert_eq!(glob_vec(\"aaa\\\\apple\"), ~[abs_path(\"aaa/apple\")]);\n-        }\n+    assert_eq!(glob_vec(\"???/\"), ~[\n+        abs_path(\"aaa\"),\n+        abs_path(\"bbb\"),\n+        abs_path(\"ccc\"),\n+        abs_path(\"xyz\")]);\n+\n+    assert_eq!(glob_vec(\"aaa/tomato/tom?to.txt\"), ~[\n+        abs_path(\"aaa/tomato/tomato.txt\"),\n+        abs_path(\"aaa/tomato/tomoto.txt\")]);\n+\n+    assert_eq!(glob_vec(\"xyz/?\"), ~[\n+        abs_path(\"xyz/x\"),\n+        abs_path(\"xyz/y\"),\n+        abs_path(\"xyz/z\")]);\n+\n+    assert_eq!(glob_vec(\"a*\"), ~[abs_path(\"aaa\")]);\n+    assert_eq!(glob_vec(\"*a*\"), ~[abs_path(\"aaa\")]);\n+    assert_eq!(glob_vec(\"a*a\"), ~[abs_path(\"aaa\")]);\n+    assert_eq!(glob_vec(\"aaa*\"), ~[abs_path(\"aaa\")]);\n+    assert_eq!(glob_vec(\"*aaa\"), ~[abs_path(\"aaa\")]);\n+    assert_eq!(glob_vec(\"*aaa*\"), ~[abs_path(\"aaa\")]);\n+    assert_eq!(glob_vec(\"*a*a*a*\"), ~[abs_path(\"aaa\")]);\n+    assert_eq!(glob_vec(\"aaa*/\"), ~[abs_path(\"aaa\")]);\n+\n+    assert_eq!(glob_vec(\"aaa/*\"), ~[\n+        abs_path(\"aaa/apple\"),\n+        abs_path(\"aaa/orange\"),\n+        abs_path(\"aaa/tomato\")]);\n+\n+    assert_eq!(glob_vec(\"aaa/*a*\"), ~[\n+        abs_path(\"aaa/apple\"),\n+        abs_path(\"aaa/orange\"),\n+        abs_path(\"aaa/tomato\")]);\n+\n+    assert_eq!(glob_vec(\"*/*/*.txt\"), ~[\n+        abs_path(\"aaa/tomato/tomato.txt\"),\n+        abs_path(\"aaa/tomato/tomoto.txt\")]);\n+\n+    assert_eq!(glob_vec(\"*/*/t[aob]m?to[.]t[!y]t\"), ~[\n+        abs_path(\"aaa/tomato/tomato.txt\"),\n+        abs_path(\"aaa/tomato/tomoto.txt\")]);\n+\n+    assert_eq!(glob_vec(\"aa[a]\"), ~[abs_path(\"aaa\")]);\n+    assert_eq!(glob_vec(\"aa[abc]\"), ~[abs_path(\"aaa\")]);\n+    assert_eq!(glob_vec(\"a[bca]a\"), ~[abs_path(\"aaa\")]);\n+    assert_eq!(glob_vec(\"aa[b]\"), ~[]);\n+    assert_eq!(glob_vec(\"aa[xyz]\"), ~[]);\n+    assert_eq!(glob_vec(\"aa[]]\"), ~[]);\n+\n+    assert_eq!(glob_vec(\"aa[!b]\"), ~[abs_path(\"aaa\")]);\n+    assert_eq!(glob_vec(\"aa[!bcd]\"), ~[abs_path(\"aaa\")]);\n+    assert_eq!(glob_vec(\"a[!bcd]a\"), ~[abs_path(\"aaa\")]);\n+    assert_eq!(glob_vec(\"aa[!a]\"), ~[]);\n+    assert_eq!(glob_vec(\"aa[!abc]\"), ~[]);\n+\n+    assert_eq!(glob_vec(\"bbb/specials/[[]\"), ~[abs_path(\"bbb/specials/[\")]);\n+    assert_eq!(glob_vec(\"bbb/specials/!\"), ~[abs_path(\"bbb/specials/!\")]);\n+    assert_eq!(glob_vec(\"bbb/specials/[]]\"), ~[abs_path(\"bbb/specials/]\")]);\n+\n+    if os::consts::FAMILY != os::consts::windows::FAMILY {\n+        assert_eq!(glob_vec(\"bbb/specials/[*]\"), ~[abs_path(\"bbb/specials/*\")]);\n+        assert_eq!(glob_vec(\"bbb/specials/[?]\"), ~[abs_path(\"bbb/specials/?\")]);\n+    }\n \n-        assert_eq!(glob_vec(\"???/\"), ~[\n-            abs_path(\"aaa\"),\n-            abs_path(\"bbb\"),\n-            abs_path(\"ccc\"),\n-            abs_path(\"xyz\")]);\n-\n-        assert_eq!(glob_vec(\"aaa/tomato/tom?to.txt\"), ~[\n-            abs_path(\"aaa/tomato/tomato.txt\"),\n-            abs_path(\"aaa/tomato/tomoto.txt\")]);\n-\n-        assert_eq!(glob_vec(\"xyz/?\"), ~[\n-            abs_path(\"xyz/x\"),\n-            abs_path(\"xyz/y\"),\n-            abs_path(\"xyz/z\")]);\n-\n-        assert_eq!(glob_vec(\"a*\"), ~[abs_path(\"aaa\")]);\n-        assert_eq!(glob_vec(\"*a*\"), ~[abs_path(\"aaa\")]);\n-        assert_eq!(glob_vec(\"a*a\"), ~[abs_path(\"aaa\")]);\n-        assert_eq!(glob_vec(\"aaa*\"), ~[abs_path(\"aaa\")]);\n-        assert_eq!(glob_vec(\"*aaa\"), ~[abs_path(\"aaa\")]);\n-        assert_eq!(glob_vec(\"*aaa*\"), ~[abs_path(\"aaa\")]);\n-        assert_eq!(glob_vec(\"*a*a*a*\"), ~[abs_path(\"aaa\")]);\n-        assert_eq!(glob_vec(\"aaa*/\"), ~[abs_path(\"aaa\")]);\n-\n-        assert_eq!(glob_vec(\"aaa/*\"), ~[\n-            abs_path(\"aaa/apple\"),\n-            abs_path(\"aaa/orange\"),\n-            abs_path(\"aaa/tomato\")]);\n-\n-        assert_eq!(glob_vec(\"aaa/*a*\"), ~[\n-            abs_path(\"aaa/apple\"),\n-            abs_path(\"aaa/orange\"),\n-            abs_path(\"aaa/tomato\")]);\n-\n-        assert_eq!(glob_vec(\"*/*/*.txt\"), ~[\n-            abs_path(\"aaa/tomato/tomato.txt\"),\n-            abs_path(\"aaa/tomato/tomoto.txt\")]);\n-\n-        assert_eq!(glob_vec(\"*/*/t[aob]m?to[.]t[!y]t\"), ~[\n-            abs_path(\"aaa/tomato/tomato.txt\"),\n-            abs_path(\"aaa/tomato/tomoto.txt\")]);\n-\n-        assert_eq!(glob_vec(\"aa[a]\"), ~[abs_path(\"aaa\")]);\n-        assert_eq!(glob_vec(\"aa[abc]\"), ~[abs_path(\"aaa\")]);\n-        assert_eq!(glob_vec(\"a[bca]a\"), ~[abs_path(\"aaa\")]);\n-        assert_eq!(glob_vec(\"aa[b]\"), ~[]);\n-        assert_eq!(glob_vec(\"aa[xyz]\"), ~[]);\n-        assert_eq!(glob_vec(\"aa[]]\"), ~[]);\n-\n-        assert_eq!(glob_vec(\"aa[!b]\"), ~[abs_path(\"aaa\")]);\n-        assert_eq!(glob_vec(\"aa[!bcd]\"), ~[abs_path(\"aaa\")]);\n-        assert_eq!(glob_vec(\"a[!bcd]a\"), ~[abs_path(\"aaa\")]);\n-        assert_eq!(glob_vec(\"aa[!a]\"), ~[]);\n-        assert_eq!(glob_vec(\"aa[!abc]\"), ~[]);\n-\n-        assert_eq!(glob_vec(\"bbb/specials/[[]\"), ~[abs_path(\"bbb/specials/[\")]);\n-        assert_eq!(glob_vec(\"bbb/specials/!\"), ~[abs_path(\"bbb/specials/!\")]);\n-        assert_eq!(glob_vec(\"bbb/specials/[]]\"), ~[abs_path(\"bbb/specials/]\")]);\n-\n-        if os::consts::FAMILY != os::consts::windows::FAMILY {\n-            assert_eq!(glob_vec(\"bbb/specials/[*]\"), ~[abs_path(\"bbb/specials/*\")]);\n-            assert_eq!(glob_vec(\"bbb/specials/[?]\"), ~[abs_path(\"bbb/specials/?\")]);\n-        }\n+    if os::consts::FAMILY == os::consts::windows::FAMILY {\n \n-        if os::consts::FAMILY == os::consts::windows::FAMILY {\n+        assert_eq!(glob_vec(\"bbb/specials/[![]\"), ~[\n+            abs_path(\"bbb/specials/!\"),\n+            abs_path(\"bbb/specials/]\")]);\n \n-            assert_eq!(glob_vec(\"bbb/specials/[![]\"), ~[\n-                abs_path(\"bbb/specials/!\"),\n-                abs_path(\"bbb/specials/]\")]);\n+        assert_eq!(glob_vec(\"bbb/specials/[!]]\"), ~[\n+            abs_path(\"bbb/specials/!\"),\n+            abs_path(\"bbb/specials/[\")]);\n \n-            assert_eq!(glob_vec(\"bbb/specials/[!]]\"), ~[\n-                abs_path(\"bbb/specials/!\"),\n-                abs_path(\"bbb/specials/[\")]);\n+        assert_eq!(glob_vec(\"bbb/specials/[!!]\"), ~[\n+            abs_path(\"bbb/specials/[\"),\n+            abs_path(\"bbb/specials/]\")]);\n \n-            assert_eq!(glob_vec(\"bbb/specials/[!!]\"), ~[\n-                abs_path(\"bbb/specials/[\"),\n-                abs_path(\"bbb/specials/]\")]);\n+    } else {\n \n-        } else {\n+        assert_eq!(glob_vec(\"bbb/specials/[![]\"), ~[\n+            abs_path(\"bbb/specials/!\"),\n+            abs_path(\"bbb/specials/*\"),\n+            abs_path(\"bbb/specials/?\"),\n+            abs_path(\"bbb/specials/]\")]);\n \n-            assert_eq!(glob_vec(\"bbb/specials/[![]\"), ~[\n-                abs_path(\"bbb/specials/!\"),\n-                abs_path(\"bbb/specials/*\"),\n-                abs_path(\"bbb/specials/?\"),\n-                abs_path(\"bbb/specials/]\")]);\n-\n-            assert_eq!(glob_vec(\"bbb/specials/[!]]\"), ~[\n-                abs_path(\"bbb/specials/!\"),\n-                abs_path(\"bbb/specials/*\"),\n-                abs_path(\"bbb/specials/?\"),\n-                abs_path(\"bbb/specials/[\")]);\n-\n-            assert_eq!(glob_vec(\"bbb/specials/[!!]\"), ~[\n-                abs_path(\"bbb/specials/*\"),\n-                abs_path(\"bbb/specials/?\"),\n-                abs_path(\"bbb/specials/[\"),\n-                abs_path(\"bbb/specials/]\")]);\n-\n-            assert_eq!(glob_vec(\"bbb/specials/[!*]\"), ~[\n-                abs_path(\"bbb/specials/!\"),\n-                abs_path(\"bbb/specials/?\"),\n-                abs_path(\"bbb/specials/[\"),\n-                abs_path(\"bbb/specials/]\")]);\n-\n-            assert_eq!(glob_vec(\"bbb/specials/[!?]\"), ~[\n-                abs_path(\"bbb/specials/!\"),\n-                abs_path(\"bbb/specials/*\"),\n-                abs_path(\"bbb/specials/[\"),\n-                abs_path(\"bbb/specials/]\")]);\n+        assert_eq!(glob_vec(\"bbb/specials/[!]]\"), ~[\n+            abs_path(\"bbb/specials/!\"),\n+            abs_path(\"bbb/specials/*\"),\n+            abs_path(\"bbb/specials/?\"),\n+            abs_path(\"bbb/specials/[\")]);\n \n-        }\n-    };\n+        assert_eq!(glob_vec(\"bbb/specials/[!!]\"), ~[\n+            abs_path(\"bbb/specials/*\"),\n+            abs_path(\"bbb/specials/?\"),\n+            abs_path(\"bbb/specials/[\"),\n+            abs_path(\"bbb/specials/]\")]);\n+\n+        assert_eq!(glob_vec(\"bbb/specials/[!*]\"), ~[\n+            abs_path(\"bbb/specials/!\"),\n+            abs_path(\"bbb/specials/?\"),\n+            abs_path(\"bbb/specials/[\"),\n+            abs_path(\"bbb/specials/]\")]);\n+\n+        assert_eq!(glob_vec(\"bbb/specials/[!?]\"), ~[\n+            abs_path(\"bbb/specials/!\"),\n+            abs_path(\"bbb/specials/*\"),\n+            abs_path(\"bbb/specials/[\"),\n+            abs_path(\"bbb/specials/]\")]);\n+\n+    }\n }"}, {"sha": "007ab381a5fc6fcbd65eb81e6c006c5e75ef0d05", "filename": "src/test/run-pass/rename-directory.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94/src%2Ftest%2Frun-pass%2Frename-directory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94/src%2Ftest%2Frun-pass%2Frename-directory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frename-directory.rs?ref=63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n // This test can't be a unit test in std,\n-// because it needs mkdtemp, which is in extra\n+// because it needs TempDir, which is in extra\n \n // xfail-fast\n extern mod extra;\n \n-use extra::tempfile::mkdtemp;\n+use extra::tempfile::TempDir;\n use std::os;\n use std::libc;\n \n@@ -23,7 +23,8 @@ fn rename_directory() {\n     unsafe {\n         static U_RWX: i32 = (libc::S_IRUSR | libc::S_IWUSR | libc::S_IXUSR) as i32;\n \n-        let tmpdir = mkdtemp(&os::tmpdir(), \"rename_directory\").expect(\"rename_directory failed\");\n+        let tmpdir = TempDir::new(\"rename_directory\").expect(\"rename_directory failed\");\n+        let tmpdir = tmpdir.path();\n         let old_path = tmpdir.push_many([\"foo\", \"bar\", \"baz\"]);\n         assert!(os::mkdir_recursive(&old_path, U_RWX));\n         let test_file = &old_path.push(\"temp.txt\");"}, {"sha": "67b84d6c93c23b2dc6030ca141174a92fb4d62d9", "filename": "src/test/run-pass/stat.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94/src%2Ftest%2Frun-pass%2Fstat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94/src%2Ftest%2Frun-pass%2Fstat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstat.rs?ref=63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94", "patch": "@@ -18,8 +18,8 @@ use std::io;\n use std::os;\n \n pub fn main() {\n-    let dir = tempfile::mkdtemp(&Path(\".\"), \"\").unwrap();\n-    let path = dir.push(\"file\");\n+    let dir = tempfile::TempDir::new_in(&Path(\".\"), \"\").unwrap();\n+    let path = dir.path().push(\"file\");\n \n     {\n         match io::file_writer(&path, [io::Create, io::Truncate]) {\n@@ -34,7 +34,4 @@ pub fn main() {\n \n     assert!(path.exists());\n     assert_eq!(path.get_size(), Some(1000));\n-\n-    os::remove_file(&path);\n-    os::remove_dir(&dir);\n }"}, {"sha": "2937a08b7b6cbbf42858bf34e6764a8e2cc2bf85", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 61, "deletions": 11, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=63e9e496f65cac6b9f22abda7f2f0ffa1af0cf94", "patch": "@@ -20,14 +20,62 @@\n \n extern mod extra;\n \n-use extra::tempfile::mkdtemp;\n+use extra::tempfile::TempDir;\n use std::os;\n use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n+use std::task;\n+use std::cell::Cell;\n \n-fn test_mkdtemp() {\n-    let p = mkdtemp(&Path(\".\"), \"foobar\").unwrap();\n-    os::remove_dir(&p);\n-    assert!(p.to_str().ends_with(\"foobar\"));\n+fn test_tempdir() {\n+    let path = {\n+        let p = TempDir::new_in(&Path(\".\"), \"foobar\").unwrap();\n+        let p = p.path();\n+        assert!(p.to_str().ends_with(\"foobar\"));\n+        p.clone()\n+    };\n+    assert!(!os::path_exists(&path));\n+}\n+\n+fn test_rm_tempdir() {\n+    let (rd, wr) = stream();\n+    let f: ~fn() = || {\n+        let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n+        wr.send(tmp.path().clone());\n+        fail2!(\"fail to unwind past `tmp`\");\n+    };\n+    task::try(f);\n+    let path = rd.recv();\n+    assert!(!os::path_exists(&path));\n+\n+    let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n+    let path = tmp.path().clone();\n+    let cell = Cell::new(tmp);\n+    let f: ~fn() = || {\n+        let _tmp = cell.take();\n+        fail2!(\"fail to unwind past `tmp`\");\n+    };\n+    task::try(f);\n+    assert!(!os::path_exists(&path));\n+\n+    let path;\n+    {\n+        let f: ~fn() -> TempDir = || {\n+            TempDir::new(\"test_rm_tempdir\").unwrap()\n+        };\n+        let tmp = task::try(f).expect(\"test_rm_tmdir\");\n+        path = tmp.path().clone();\n+        assert!(os::path_exists(&path));\n+    }\n+    assert!(!os::path_exists(&path));\n+\n+    let path;\n+    {\n+        let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n+        path = tmp.unwrap();\n+    }\n+    assert!(os::path_exists(&path));\n+    os::remove_dir_recursive(&path);\n+    assert!(!os::path_exists(&path));\n }\n \n // Ideally these would be in std::os but then core would need\n@@ -65,12 +113,13 @@ fn recursive_mkdir_rel_2() {\n     assert!(os::path_is_dir(&path2.pop()));\n }\n \n-// Ideally this would be in core, but needs mkdtemp\n+// Ideally this would be in core, but needs TempFile\n pub fn test_rmdir_recursive_ok() {\n     let rwx = (S_IRUSR | S_IWUSR | S_IXUSR) as i32;\n \n-    let tmpdir = mkdtemp(&os::tmpdir(), \"test\").expect(\"test_rmdir_recursive_ok: \\\n-                                        couldn't create temp dir\");\n+    let tmpdir = TempDir::new(\"test\").expect(\"test_rmdir_recursive_ok: \\\n+                                              couldn't create temp dir\");\n+    let tmpdir = tmpdir.path();\n     let root = tmpdir.push(\"foo\");\n \n     debug2!(\"making {}\", root.to_str());\n@@ -85,14 +134,15 @@ pub fn test_rmdir_recursive_ok() {\n }\n \n fn in_tmpdir(f: &fn()) {\n-    let tmpdir = mkdtemp(&os::tmpdir(), \"test\").expect(\"can't make tmpdir\");\n-    assert!(os::change_dir(&tmpdir));\n+    let tmpdir = TempDir::new(\"test\").expect(\"can't make tmpdir\");\n+    assert!(os::change_dir(tmpdir.path()));\n \n     f();\n }\n \n fn main() {\n-    in_tmpdir(test_mkdtemp);\n+    in_tmpdir(test_tempdir);\n+    in_tmpdir(test_rm_tempdir);\n     in_tmpdir(recursive_mkdir_rel);\n     in_tmpdir(recursive_mkdir_dot);\n     in_tmpdir(recursive_mkdir_rel_2);"}]}