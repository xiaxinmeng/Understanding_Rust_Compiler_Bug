{"sha": "e552840e79330f8a1f36fc676b71fa38b3123a50", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1NTI4NDBlNzkzMzBmOGExZjM2ZmM2NzZiNzFmYTM4YjMxMjNhNTA=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-08-28T21:47:52Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-09-05T14:07:17Z"}, "message": "Document test harness generation\n\nAlso ensure that we're consistently using the def-site span when\nappropriate.", "tree": {"sha": "e9c0b11e0dd99bd6042ce6ffaa4e35180b42c766", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9c0b11e0dd99bd6042ce6ffaa4e35180b42c766"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e552840e79330f8a1f36fc676b71fa38b3123a50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e552840e79330f8a1f36fc676b71fa38b3123a50", "html_url": "https://github.com/rust-lang/rust/commit/e552840e79330f8a1f36fc676b71fa38b3123a50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e552840e79330f8a1f36fc676b71fa38b3123a50/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8cf9f5a025bb475804b5a90f54aca310b952526", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8cf9f5a025bb475804b5a90f54aca310b952526", "html_url": "https://github.com/rust-lang/rust/commit/c8cf9f5a025bb475804b5a90f54aca310b952526"}], "stats": {"total": 82, "additions": 55, "deletions": 27}, "files": [{"sha": "b93c11fad382391f3f2c4c5f40cb2854b6342991", "filename": "src/libsyntax_ext/test_harness.rs", "status": "modified", "additions": 55, "deletions": 27, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e552840e79330f8a1f36fc676b71fa38b3123a50/src%2Flibsyntax_ext%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e552840e79330f8a1f36fc676b71fa38b3123a50/src%2Flibsyntax_ext%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_harness.rs?ref=e552840e79330f8a1f36fc676b71fa38b3123a50", "patch": "@@ -25,6 +25,7 @@ struct Test {\n \n struct TestCtxt<'a> {\n     ext_cx: ExtCtxt<'a>,\n+    def_site: Span,\n     test_cases: Vec<Test>,\n     reexport_test_harness_main: Option<Symbol>,\n     test_runner: Option<ast::Path>,\n@@ -125,6 +126,7 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n struct EntryPointCleaner {\n     // Current depth in the ast\n     depth: usize,\n+    def_site: Span,\n }\n \n impl MutVisitor for EntryPointCleaner {\n@@ -141,8 +143,10 @@ impl MutVisitor for EntryPointCleaner {\n             EntryPointType::MainAttr |\n             EntryPointType::Start =>\n                 item.map(|ast::Item {id, ident, attrs, node, vis, span, tokens}| {\n-                    let allow_ident = Ident::with_dummy_span(sym::allow);\n-                    let dc_nested = attr::mk_nested_word_item(Ident::from_str(\"dead_code\"));\n+                    let allow_ident = Ident::new(sym::allow, self.def_site);\n+                    let dc_nested = attr::mk_nested_word_item(\n+                        Ident::from_str_and_span(\"dead_code\", self.def_site),\n+                    );\n                     let allow_dead_code_item = attr::mk_list_item(allow_ident, vec![dc_nested]);\n                     let allow_dead_code = attr::mk_attr_outer(allow_dead_code_item);\n \n@@ -180,15 +184,26 @@ fn generate_test_harness(sess: &ParseSess,\n                          krate: &mut ast::Crate,\n                          features: &Features,\n                          test_runner: Option<ast::Path>) {\n-    // Remove the entry points\n-    let mut cleaner = EntryPointCleaner { depth: 0 };\n-    cleaner.visit_crate(krate);\n-\n     let mut econfig = ExpansionConfig::default(\"test\".to_string());\n     econfig.features = Some(features);\n \n+    let ext_cx = ExtCtxt::new(sess, econfig, resolver);\n+\n+    let expn_id = ext_cx.resolver.expansion_for_ast_pass(\n+        DUMMY_SP,\n+        AstPass::TestHarness,\n+        &[sym::main, sym::test, sym::rustc_attrs],\n+        None,\n+    );\n+    let def_site = DUMMY_SP.with_def_site_ctxt(expn_id);\n+\n+    // Remove the entry points\n+    let mut cleaner = EntryPointCleaner { depth: 0, def_site };\n+    cleaner.visit_crate(krate);\n+\n     let cx = TestCtxt {\n-        ext_cx: ExtCtxt::new(sess, econfig, resolver),\n+        ext_cx,\n+        def_site,\n         test_cases: Vec::new(),\n         reexport_test_harness_main,\n         test_runner\n@@ -202,27 +217,40 @@ fn generate_test_harness(sess: &ParseSess,\n \n /// Creates a function item for use as the main function of a test build.\n /// This function will call the `test_runner` as specified by the crate attribute\n+///\n+/// By default this expands to\n+///\n+/// #[main]\n+/// pub fn main() {\n+///     extern crate test;\n+///     test::test_main_static(&[\n+///         &test_const1,\n+///         &test_const2,\n+///         &test_const3,\n+///     ]);\n+/// }\n+///\n+/// Most of the Ident have the usual def-site hygiene for the AST pass. The\n+/// exception is the `test_const`s. These have a syntax context that has two\n+/// opaque marks: one from the expansion of `test` or `test_case`, and one\n+/// generated  in `TestHarnessGenerator::flat_map_item`. When resolving this\n+/// identifier after failing to find a matching identifier in the root module\n+/// we remove the outer mark, and try resolving at its def-site, which will\n+/// then resolve to `test_const`.\n+///\n+/// The expansion here can be controlled by two attributes:\n+///\n+/// `reexport_test_harness_main` provides a different name for the `main`\n+/// function and `test_runner` provides a path that replaces\n+/// `test::test_main_static`.\n fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n-    // Writing this out by hand:\n-    //        pub fn main() {\n-    //            #![main]\n-    //            test::test_main_static(&[..tests]);\n-    //        }\n-    let expn_id = cx.ext_cx.resolver.expansion_for_ast_pass(\n-        DUMMY_SP,\n-        AstPass::TestHarness,\n-        &[sym::main, sym::test, sym::rustc_attrs],\n-        None,\n-    );\n-    let sp = DUMMY_SP.with_def_site_ctxt(expn_id);\n+    let sp = cx.def_site;\n     let ecx = &cx.ext_cx;\n     let test_id = Ident::new(sym::test, sp);\n \n     // test::test_main_static(...)\n     let mut test_runner = cx.test_runner.clone().unwrap_or(\n-        ecx.path(sp, vec![\n-            test_id, ecx.ident_of(\"test_main_static\")\n-        ]));\n+        ecx.path(sp, vec![test_id, Ident::from_str_and_span(\"test_main_static\", sp)]));\n \n     test_runner.span = sp;\n \n@@ -231,17 +259,17 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n                                        vec![mk_tests_slice(cx, sp)]);\n     let call_test_main = ecx.stmt_expr(call_test_main);\n \n-    // #![main]\n-    let main_meta = ecx.meta_word(sp, sym::main);\n-    let main_attr = ecx.attribute(main_meta);\n-\n     // extern crate test\n     let test_extern_stmt = ecx.stmt_item(sp, ecx.item(sp,\n         test_id,\n         vec![],\n         ast::ItemKind::ExternCrate(None)\n     ));\n \n+    // #[main]\n+    let main_meta = ecx.meta_word(sp, sym::main);\n+    let main_attr = ecx.attribute(main_meta);\n+\n     // pub fn main() { ... }\n     let main_ret_ty = ecx.ty(sp, ast::TyKind::Tup(vec![]));\n \n@@ -279,7 +307,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n }\n \n /// Creates a slice containing every test like so:\n-/// &[test1, test2]\n+/// &[&test1, &test2]\n fn mk_tests_slice(cx: &TestCtxt<'_>, sp: Span) -> P<ast::Expr> {\n     debug!(\"building test vector from {} tests\", cx.test_cases.len());\n     let ref ecx = cx.ext_cx;"}]}