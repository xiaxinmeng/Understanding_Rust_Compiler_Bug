{"sha": "4b42cbd5eb3e947875aa427dbda52121ef186586", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiNDJjYmQ1ZWIzZTk0Nzg3NWFhNDI3ZGJkYTUyMTIxZWYxODY1ODY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-19T22:56:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-19T22:56:38Z"}, "message": "Auto merge of #24527 - nikomatsakis:issue-24085, r=nikomatsakis\n\nExpand the \"givens\" set to cover transitive relations.  The givens array\r\nstores relationships like `'c <= '0` (where `'c` is a free region and\r\n`'0` is an inference variable) that are derived from closure\r\narguments. These are (rather hackily) ignored for purposes of inference,\r\npreventing spurious errors. The current code did not handle transitive\r\ncases like `'c <= '0` and `'0 <= '1`. Fixes #24085.\r\n\r\nr? @pnkfelix \r\ncc @bkoropoff\r\n\r\n*But* I am not sure whether this fix will have a compile-time hit. I'd like to push to try branch observe cycle times.", "tree": {"sha": "5c4382e9cdc2869879b988739afe72446f66914c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c4382e9cdc2869879b988739afe72446f66914c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b42cbd5eb3e947875aa427dbda52121ef186586", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b42cbd5eb3e947875aa427dbda52121ef186586", "html_url": "https://github.com/rust-lang/rust/commit/4b42cbd5eb3e947875aa427dbda52121ef186586", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b42cbd5eb3e947875aa427dbda52121ef186586/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "html_url": "https://github.com/rust-lang/rust/commit/e4efb47b9d23a96ff4684df80360bbed0ec68bc9"}, {"sha": "29c86539b392b98ba84570143c625781ba248a9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/29c86539b392b98ba84570143c625781ba248a9b", "html_url": "https://github.com/rust-lang/rust/commit/29c86539b392b98ba84570143c625781ba248a9b"}], "stats": {"total": 84, "additions": 68, "deletions": 16}, "files": [{"sha": "c33caaa3c03e7cd80e13066588be0e471e3ae621", "filename": "src/librustc/middle/cfg/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b42cbd5eb3e947875aa427dbda52121ef186586/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b42cbd5eb3e947875aa427dbda52121ef186586/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs?ref=4b42cbd5eb3e947875aa427dbda52121ef186586", "patch": "@@ -63,6 +63,7 @@ impl CFG {\n     }\n \n     pub fn node_is_reachable(&self, id: ast::NodeId) -> bool {\n-        self.graph.depth_traverse(self.entry).any(|node| node.id() == id)\n+        self.graph.depth_traverse(self.entry)\n+                  .any(|idx| self.graph.node_data(idx).id() == id)\n     }\n }"}, {"sha": "e397f35685559979b892feb2e2bea061d32f1a19", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4b42cbd5eb3e947875aa427dbda52121ef186586/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b42cbd5eb3e947875aa427dbda52121ef186586/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=4b42cbd5eb3e947875aa427dbda52121ef186586", "patch": "@@ -984,14 +984,18 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         // Dorky hack to cause `dump_constraints` to only get called\n         // if debug mode is enabled:\n-        debug!(\"----() End constraint listing {:?}---\", self.dump_constraints());\n+        debug!(\"----() End constraint listing (subject={}) {:?}---\",\n+               subject, self.dump_constraints(subject));\n         graphviz::maybe_print_constraints_for(self, subject);\n \n+        let graph = self.construct_graph();\n+        self.expand_givens(&graph);\n         self.expansion(free_regions, &mut var_data);\n         self.contraction(free_regions, &mut var_data);\n         let values =\n             self.extract_values_and_collect_conflicts(free_regions,\n-                                                      &var_data[..],\n+                                                      &var_data,\n+                                                      &graph,\n                                                       errors);\n         self.collect_concrete_region_errors(free_regions, &values, errors);\n         values\n@@ -1010,13 +1014,38 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }).collect()\n     }\n \n-    fn dump_constraints(&self) {\n-        debug!(\"----() Start constraint listing ()----\");\n+    fn dump_constraints(&self, subject: ast::NodeId) {\n+        debug!(\"----() Start constraint listing (subject={}) ()----\", subject);\n         for (idx, (constraint, _)) in self.constraints.borrow().iter().enumerate() {\n             debug!(\"Constraint {} => {:?}\", idx, constraint);\n         }\n     }\n \n+    fn expand_givens(&self, graph: &RegionGraph) {\n+        // Givens are a kind of horrible hack to account for\n+        // constraints like 'c <= '0 that are known to hold due to\n+        // closure signatures (see the comment above on the `givens`\n+        // field). They should go away. But until they do, the role\n+        // of this fn is to account for the transitive nature:\n+        //\n+        //     Given 'c <= '0\n+        //     and   '0 <= '1\n+        //     then  'c <= '1\n+\n+        let mut givens = self.givens.borrow_mut();\n+        let seeds: Vec<_> = givens.iter().cloned().collect();\n+        for (fr, vid) in seeds {\n+            let seed_index = NodeIndex(vid.index as usize);\n+            for succ_index in graph.depth_traverse(seed_index) {\n+                let succ_index = succ_index.0 as u32;\n+                if succ_index < self.num_vars() {\n+                    let succ_vid = RegionVid { index: succ_index };\n+                    givens.insert((fr, succ_vid));\n+                }\n+            }\n+        }\n+    }\n+\n     fn expansion(&self, free_regions: &FreeRegionMap, var_data: &mut [VarData]) {\n         self.iterate_until_fixed_point(\"Expansion\", |constraint| {\n             debug!(\"expansion: constraint={:?} origin={:?}\",\n@@ -1258,6 +1287,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         &self,\n         free_regions: &FreeRegionMap,\n         var_data: &[VarData],\n+        graph: &RegionGraph,\n         errors: &mut Vec<RegionResolutionError<'tcx>>)\n         -> Vec<VarValue>\n     {\n@@ -1276,8 +1306,6 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // overlapping locations.\n         let mut dup_vec: Vec<_> = repeat(u32::MAX).take(self.num_vars() as usize).collect();\n \n-        let mut opt_graph = None;\n-\n         for idx in 0..self.num_vars() as usize {\n             match var_data[idx].value {\n                 Value(_) => {\n@@ -1313,11 +1341,6 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                        starts to create problems we'll have to revisit\n                        this portion of the code and think hard about it. =) */\n \n-                    if opt_graph.is_none() {\n-                        opt_graph = Some(self.construct_graph());\n-                    }\n-                    let graph = opt_graph.as_ref().unwrap();\n-\n                     let node_vid = RegionVid { index: idx as u32 };\n                     match var_data[idx].classification {\n                         Expanding => {"}, {"sha": "d73043c043069fc9afd029c8547c485e119ec6ea", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b42cbd5eb3e947875aa427dbda52121ef186586/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b42cbd5eb3e947875aa427dbda52121ef186586/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=4b42cbd5eb3e947875aa427dbda52121ef186586", "patch": "@@ -358,9 +358,9 @@ pub struct DepthFirstTraversal<'g, N:'g, E:'g> {\n }\n \n impl<'g, N:Debug, E:Debug> Iterator for DepthFirstTraversal<'g, N, E> {\n-    type Item = &'g N;\n+    type Item = NodeIndex;\n \n-    fn next(&mut self) -> Option<&'g N> {\n+    fn next(&mut self) -> Option<NodeIndex> {\n         while let Some(idx) = self.stack.pop() {\n             if !self.visited.insert(idx.node_id()) {\n                 continue;\n@@ -372,7 +372,7 @@ impl<'g, N:Debug, E:Debug> Iterator for DepthFirstTraversal<'g, N, E> {\n                 }\n             }\n \n-            return Some(self.graph.node_data(idx));\n+            return Some(idx);\n         }\n \n         return None;"}, {"sha": "8fa47ed2c267c4f0dcf2584c483c48d7ac97b581", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b42cbd5eb3e947875aa427dbda52121ef186586/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b42cbd5eb3e947875aa427dbda52121ef186586/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=4b42cbd5eb3e947875aa427dbda52121ef186586", "patch": "@@ -1142,7 +1142,8 @@ fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>)\n // return slot alloca. This can cause errors related to clean-up due to\n // the clobbering of the existing value in the return slot.\n fn has_nested_returns(tcx: &ty::ctxt, cfg: &cfg::CFG, blk_id: ast::NodeId) -> bool {\n-    for n in cfg.graph.depth_traverse(cfg.entry) {\n+    for index in cfg.graph.depth_traverse(cfg.entry) {\n+        let n = cfg.graph.node_data(index);\n         match tcx.map.find(n.id()) {\n             Some(ast_map::NodeExpr(ex)) => {\n                 if let ast::ExprRet(Some(ref ret_expr)) = ex.node {"}, {"sha": "3617b0d3a577788fde8705b1926c775dd43ac632", "filename": "src/test/run-pass/issue-24085.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4b42cbd5eb3e947875aa427dbda52121ef186586/src%2Ftest%2Frun-pass%2Fissue-24085.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b42cbd5eb3e947875aa427dbda52121ef186586/src%2Ftest%2Frun-pass%2Fissue-24085.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-24085.rs?ref=4b42cbd5eb3e947875aa427dbda52121ef186586", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #24085. Errors were occuring in region\n+// inference due to the requirement that `'a:b'`, which was getting\n+// incorrectly translated in connection with the closure below.\n+\n+#[derive(Copy,Clone)]\n+struct Path<'a:'b, 'b> {\n+    x: &'a i32,\n+    tail: Option<&'b Path<'a, 'b>>\n+}\n+\n+#[allow(dead_code, unconditional_recursion)]\n+fn foo<'a,'b,F>(p: Path<'a, 'b>, mut f: F)\n+                where F: for<'c> FnMut(Path<'a, 'c>) {\n+    foo(p, |x| f(x))\n+}\n+\n+fn main() { }"}]}