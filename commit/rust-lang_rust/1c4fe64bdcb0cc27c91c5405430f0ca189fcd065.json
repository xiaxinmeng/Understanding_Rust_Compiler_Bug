{"sha": "1c4fe64bdcb0cc27c91c5405430f0ca189fcd065", "node_id": "C_kwDOAAsO6NoAKDFjNGZlNjRiZGNiMGNjMjdjOTFjNTQwNTQzMGYwY2ExODlmY2QwNjU", "commit": {"author": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2022-01-27T14:40:38Z"}, "committer": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2022-01-27T14:40:55Z"}, "message": "Continue work on assoc const eq", "tree": {"sha": "0c2acfdd301bd07f28eaa12edb016fbc7dcd27bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c2acfdd301bd07f28eaa12edb016fbc7dcd27bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c4fe64bdcb0cc27c91c5405430f0ca189fcd065", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c4fe64bdcb0cc27c91c5405430f0ca189fcd065", "html_url": "https://github.com/rust-lang/rust/commit/1c4fe64bdcb0cc27c91c5405430f0ca189fcd065", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c4fe64bdcb0cc27c91c5405430f0ca189fcd065/comments", "author": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21b4a9cfdcbb1e76f4b36b5c3cfd64d627285093", "url": "https://api.github.com/repos/rust-lang/rust/commits/21b4a9cfdcbb1e76f4b36b5c3cfd64d627285093", "html_url": "https://github.com/rust-lang/rust/commit/21b4a9cfdcbb1e76f4b36b5c3cfd64d627285093"}], "stats": {"total": 623, "additions": 471, "deletions": 152}, "files": [{"sha": "05a210ef49edff2b8e275a57bf89efc9cf5a5cfa", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1c4fe64bdcb0cc27c91c5405430f0ca189fcd065/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4fe64bdcb0cc27c91c5405430f0ca189fcd065/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=1c4fe64bdcb0cc27c91c5405430f0ca189fcd065", "patch": "@@ -857,6 +857,9 @@ impl<'tcx> Term<'tcx> {\n     pub fn ty(&self) -> Option<Ty<'tcx>> {\n         if let Term::Ty(ty) = self { Some(ty) } else { None }\n     }\n+    pub fn ct(&self) -> Option<&'tcx Const<'tcx>> {\n+        if let Term::Const(c) = self { Some(c) } else { None }\n+    }\n }\n \n /// This kind of predicate has no *direct* correspondent in the"}, {"sha": "8f498f02169f29b114a4282b8a63f25064de6e90", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 367, "deletions": 108, "changes": 475, "blob_url": "https://github.com/rust-lang/rust/blob/1c4fe64bdcb0cc27c91c5405430f0ca189fcd065/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4fe64bdcb0cc27c91c5405430f0ca189fcd065/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=1c4fe64bdcb0cc27c91c5405430f0ca189fcd065", "patch": "@@ -44,7 +44,7 @@ pub(super) struct InProgress;\n \n /// When attempting to resolve `<T as TraitRef>::Name` ...\n #[derive(Debug)]\n-pub enum ProjectionTyError<'tcx> {\n+pub enum ProjectionError<'tcx> {\n     /// ...we found multiple sources of information and couldn't resolve the ambiguity.\n     TooManyCandidates,\n \n@@ -53,7 +53,7 @@ pub enum ProjectionTyError<'tcx> {\n }\n \n #[derive(PartialEq, Eq, Debug)]\n-enum ProjectionTyCandidate<'tcx> {\n+enum ProjectionCandidate<'tcx> {\n     /// From a where-clause in the env or object type\n     ParamEnv(ty::PolyProjectionPredicate<'tcx>),\n \n@@ -67,28 +67,28 @@ enum ProjectionTyCandidate<'tcx> {\n     Select(Selection<'tcx>),\n }\n \n-enum ProjectionTyCandidateSet<'tcx> {\n+enum ProjectionCandidateSet<'tcx> {\n     None,\n-    Single(ProjectionTyCandidate<'tcx>),\n+    Single(ProjectionCandidate<'tcx>),\n     Ambiguous,\n     Error(SelectionError<'tcx>),\n }\n \n-impl<'tcx> ProjectionTyCandidateSet<'tcx> {\n+impl<'tcx> ProjectionCandidateSet<'tcx> {\n     fn mark_ambiguous(&mut self) {\n-        *self = ProjectionTyCandidateSet::Ambiguous;\n+        *self = ProjectionCandidateSet::Ambiguous;\n     }\n \n     fn mark_error(&mut self, err: SelectionError<'tcx>) {\n-        *self = ProjectionTyCandidateSet::Error(err);\n+        *self = ProjectionCandidateSet::Error(err);\n     }\n \n     // Returns true if the push was successful, or false if the candidate\n     // was discarded -- this could be because of ambiguity, or because\n     // a higher-priority candidate is already there.\n-    fn push_candidate(&mut self, candidate: ProjectionTyCandidate<'tcx>) -> bool {\n-        use self::ProjectionTyCandidate::*;\n-        use self::ProjectionTyCandidateSet::*;\n+    fn push_candidate(&mut self, candidate: ProjectionCandidate<'tcx>) -> bool {\n+        use self::ProjectionCandidate::*;\n+        use self::ProjectionCandidateSet::*;\n \n         // This wacky variable is just used to try and\n         // make code readable and avoid confusing paths.\n@@ -196,32 +196,67 @@ fn project_and_unify_type<'cx, 'tcx>(\n     debug!(?obligation, \"project_and_unify_type\");\n \n     let mut obligations = vec![];\n-    let normalized_ty = match opt_normalize_projection_type(\n-        selcx,\n-        obligation.param_env,\n-        obligation.predicate.projection_ty,\n-        obligation.cause.clone(),\n-        obligation.recursion_depth,\n-        &mut obligations,\n-    ) {\n-        Ok(Some(n)) => n,\n-        Ok(None) => return Ok(Ok(None)),\n-        Err(InProgress) => return Ok(Err(InProgress)),\n-    };\n-\n-    debug!(?normalized_ty, ?obligations, \"project_and_unify_type result\");\n \n     let infcx = selcx.infcx();\n-    // FIXME(associated_const_equality): Handle consts here as well as types.\n-    let obligation_pred_ty = obligation.predicate.term.ty().unwrap();\n-    match infcx.at(&obligation.cause, obligation.param_env).eq(normalized_ty, obligation_pred_ty) {\n-        Ok(InferOk { obligations: inferred_obligations, value: () }) => {\n-            obligations.extend(inferred_obligations);\n-            Ok(Ok(Some(obligations)))\n+    match obligation.predicate.term {\n+        ty::Term::Ty(obligation_pred_ty) => {\n+            let normalized_ty = match opt_normalize_projection_type(\n+                selcx,\n+                obligation.param_env,\n+                obligation.predicate.projection_ty,\n+                obligation.cause.clone(),\n+                obligation.recursion_depth,\n+                &mut obligations,\n+            ) {\n+                Ok(Some(n)) => n,\n+                Ok(None) => return Ok(Ok(None)),\n+                Err(InProgress) => return Ok(Err(InProgress)),\n+            };\n+            debug!(?normalized_ty, ?obligations, \"project_and_unify_type result\");\n+            match infcx\n+                .at(&obligation.cause, obligation.param_env)\n+                .eq(normalized_ty, obligation_pred_ty)\n+            {\n+                Ok(InferOk { obligations: inferred_obligations, value: () }) => {\n+                    obligations.extend(inferred_obligations);\n+                    Ok(Ok(Some(obligations)))\n+                }\n+                Err(err) => {\n+                    debug!(\"project_and_unify_type: equating types encountered error {:?}\", err);\n+                    Err(MismatchedProjectionTypes { err })\n+                }\n+            }\n         }\n-        Err(err) => {\n-            debug!(\"project_and_unify_type: equating types encountered error {:?}\", err);\n-            Err(MismatchedProjectionTypes { err })\n+        ty::Term::Const(_obligation_pred_const) => {\n+            let normalized_const = match opt_normalize_projection_const(\n+                selcx,\n+                obligation.param_env,\n+                obligation.predicate.projection_ty,\n+                obligation.cause.clone(),\n+                obligation.recursion_depth,\n+                &mut obligations,\n+            ) {\n+                Ok(Some(n)) => n,\n+                Ok(None) => return Ok(Ok(None)),\n+                Err(InProgress) => return Ok(Err(InProgress)),\n+            };\n+            println!(\"{:?}\", normalized_const);\n+            todo!();\n+            /*\n+            match infcx\n+                .at(&obligation.cause, obligation.param_env)\n+                .eq(normalized_ty, obligation_pred_const)\n+            {\n+                Ok(InferOk { obligations: inferred_obligations, value: () }) => {\n+                    obligations.extend(inferred_obligations);\n+                    Ok(Ok(Some(obligations)))\n+                }\n+                Err(err) => {\n+                    debug!(\"project_and_unify_type: equating consts encountered error {:?}\", err);\n+                    Err(MismatchedProjectionTypes { err })\n+                }\n+            }\n+            */\n         }\n     }\n }\n@@ -813,6 +848,22 @@ pub fn normalize_projection_type<'a, 'b, 'tcx>(\n     })\n }\n \n+fn opt_normalize_projection_const<'a, 'b, 'tcx>(\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    projection_const: ty::ProjectionTy<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: usize,\n+    _obligations: &mut Vec<PredicateObligation<'tcx>>,\n+) -> Result<Option<&'tcx ty::Const<'tcx>>, InProgress> {\n+    let infcx = selcx.infcx();\n+    let projection_const = infcx.resolve_vars_if_possible(projection_const);\n+    let obligation = Obligation::with_depth(cause.clone(), depth, param_env, projection_const);\n+    // TODO continue working on below\n+    let _projected_const = project_const(selcx, &obligation);\n+    //println!(\"{:?}\", projected_const);\n+    todo!();\n+}\n /// The guts of `normalize`: normalize a specific projection like `<T\n /// as Trait>::Item`. The result is always a type (and possibly\n /// additional obligations). Returns `None` in the case of ambiguity,\n@@ -914,8 +965,8 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n     let obligation = Obligation::with_depth(cause.clone(), depth, param_env, projection_ty);\n \n     match project_type(selcx, &obligation) {\n-        Ok(ProjectedTy::Progress(Progress {\n-            ty: projected_ty,\n+        Ok(Projected::Progress(Progress {\n+            term: projected_ty,\n             obligations: mut projected_obligations,\n         })) => {\n             // if projection succeeded, then what we get out of this\n@@ -957,7 +1008,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             obligations.extend(result.obligations);\n             Ok(Some(result.value))\n         }\n-        Ok(ProjectedTy::NoProgress(projected_ty)) => {\n+        Ok(Projected::NoProgress(projected_ty)) => {\n             debug!(?projected_ty, \"opt_normalize_projection_type: no progress\");\n             let result = Normalized { value: projected_ty, obligations: vec![] };\n             if use_cache {\n@@ -966,14 +1017,14 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             // No need to extend `obligations`.\n             Ok(Some(result.value))\n         }\n-        Err(ProjectionTyError::TooManyCandidates) => {\n+        Err(ProjectionError::TooManyCandidates) => {\n             debug!(\"opt_normalize_projection_type: too many candidates\");\n             if use_cache {\n                 infcx.inner.borrow_mut().projection_cache().ambiguous(cache_key);\n             }\n             Ok(None)\n         }\n-        Err(ProjectionTyError::TraitSelectionError(_)) => {\n+        Err(ProjectionError::TraitSelectionError(_)) => {\n             debug!(\"opt_normalize_projection_type: ERROR\");\n             // if we got an error processing the `T as Trait` part,\n             // just return `ty::err` but add the obligation `T :\n@@ -1032,35 +1083,76 @@ fn normalize_to_error<'a, 'tcx>(\n     Normalized { value: new_value, obligations: vec![trait_obligation] }\n }\n \n-enum ProjectedTy<'tcx> {\n-    Progress(Progress<'tcx>),\n-    NoProgress(Ty<'tcx>),\n+enum Projected<'tcx, T> {\n+    Progress(Progress<'tcx, T>),\n+    NoProgress(T),\n }\n \n-struct Progress<'tcx> {\n-    ty: Ty<'tcx>,\n+struct Progress<'tcx, T>\n+where\n+    T: 'tcx,\n+{\n+    term: T,\n     obligations: Vec<PredicateObligation<'tcx>>,\n }\n \n-impl<'tcx> Progress<'tcx> {\n+impl<'tcx> Progress<'tcx, Ty<'tcx>> {\n     fn error(tcx: TyCtxt<'tcx>) -> Self {\n-        Progress { ty: tcx.ty_error(), obligations: vec![] }\n+        Progress { term: tcx.ty_error(), obligations: vec![] }\n     }\n \n     fn with_addl_obligations(mut self, mut obligations: Vec<PredicateObligation<'tcx>>) -> Self {\n-        debug!(\n-            self.obligations.len = ?self.obligations.len(),\n-            obligations.len = obligations.len(),\n-            \"with_addl_obligations\"\n-        );\n-\n-        debug!(?self.obligations, ?obligations, \"with_addl_obligations\");\n-\n         self.obligations.append(&mut obligations);\n         self\n     }\n }\n \n+impl<'tcx> Progress<'tcx, &'tcx ty::Const<'tcx>> {\n+    fn error_const(tcx: TyCtxt<'tcx>) -> Self {\n+        Progress { term: tcx.const_error(tcx.ty_error()), obligations: vec![] }\n+    }\n+}\n+\n+fn project_const<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+) -> Result<Projected<'tcx, &'tcx ty::Const<'tcx>>, ProjectionError<'tcx>> {\n+    if !selcx.tcx().recursion_limit().value_within_limit(obligation.recursion_depth) {\n+        return Err(ProjectionError::TraitSelectionError(SelectionError::Overflow));\n+    }\n+\n+    if obligation.predicate.references_error() {\n+        return Ok(Projected::Progress(Progress::error_const(selcx.tcx())));\n+    }\n+\n+    let mut candidates = ProjectionCandidateSet::None;\n+\n+    assemble_candidates_from_param_env(selcx, obligation, &mut candidates);\n+    assemble_candidates_from_trait_def(selcx, obligation, &mut candidates);\n+    assemble_candidates_from_object_ty(selcx, obligation, &mut candidates);\n+    if let ProjectionCandidateSet::Single(ProjectionCandidate::Object(_)) = candidates {\n+    } else {\n+        assemble_candidates_from_impls(selcx, obligation, &mut candidates);\n+    };\n+    match candidates {\n+        ProjectionCandidateSet::Single(candidate) => {\n+            Ok(Projected::Progress(confirm_candidate_const(selcx, obligation, candidate)))\n+        }\n+        ProjectionCandidateSet::None => todo!(),\n+        /*\n+        Ok(Projected::NoProgress(\n+            selcx\n+                .tcx()\n+                .mk_projection(obligation.predicate.item_def_id, obligation.predicate.substs),\n+        )),\n+        */\n+        // Error occurred while trying to processing impls.\n+        ProjectionCandidateSet::Error(e) => Err(ProjectionError::TraitSelectionError(e)),\n+        // Inherent ambiguity that prevents us from even enumerating the candidates.\n+        ProjectionCandidateSet::Ambiguous => Err(ProjectionError::TooManyCandidates),\n+    }\n+}\n+\n /// Computes the result of a projection type (if we can).\n ///\n /// IMPORTANT:\n@@ -1069,19 +1161,18 @@ impl<'tcx> Progress<'tcx> {\n fn project_type<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-) -> Result<ProjectedTy<'tcx>, ProjectionTyError<'tcx>> {\n+) -> Result<Projected<'tcx, Ty<'tcx>>, ProjectionError<'tcx>> {\n     if !selcx.tcx().recursion_limit().value_within_limit(obligation.recursion_depth) {\n-        debug!(\"project: overflow!\");\n         // This should really be an immediate error, but some existing code\n         // relies on being able to recover from this.\n-        return Err(ProjectionTyError::TraitSelectionError(SelectionError::Overflow));\n+        return Err(ProjectionError::TraitSelectionError(SelectionError::Overflow));\n     }\n \n     if obligation.predicate.references_error() {\n-        return Ok(ProjectedTy::Progress(Progress::error(selcx.tcx())));\n+        return Ok(Projected::Progress(Progress::error(selcx.tcx())));\n     }\n \n-    let mut candidates = ProjectionTyCandidateSet::None;\n+    let mut candidates = ProjectionCandidateSet::None;\n \n     // Make sure that the following procedures are kept in order. ParamEnv\n     // needs to be first because it has highest priority, and Select checks\n@@ -1092,7 +1183,7 @@ fn project_type<'cx, 'tcx>(\n \n     assemble_candidates_from_object_ty(selcx, obligation, &mut candidates);\n \n-    if let ProjectionTyCandidateSet::Single(ProjectionTyCandidate::Object(_)) = candidates {\n+    if let ProjectionCandidateSet::Single(ProjectionCandidate::Object(_)) = candidates {\n         // Avoid normalization cycle from selection (see\n         // `assemble_candidates_from_object_ty`).\n         // FIXME(lazy_normalization): Lazy normalization should save us from\n@@ -1102,19 +1193,19 @@ fn project_type<'cx, 'tcx>(\n     };\n \n     match candidates {\n-        ProjectionTyCandidateSet::Single(candidate) => {\n-            Ok(ProjectedTy::Progress(confirm_candidate(selcx, obligation, candidate)))\n+        ProjectionCandidateSet::Single(candidate) => {\n+            Ok(Projected::Progress(confirm_candidate(selcx, obligation, candidate)))\n         }\n-        ProjectionTyCandidateSet::None => Ok(ProjectedTy::NoProgress(\n+        ProjectionCandidateSet::None => Ok(Projected::NoProgress(\n             selcx\n                 .tcx()\n                 .mk_projection(obligation.predicate.item_def_id, obligation.predicate.substs),\n         )),\n         // Error occurred while trying to processing impls.\n-        ProjectionTyCandidateSet::Error(e) => Err(ProjectionTyError::TraitSelectionError(e)),\n+        ProjectionCandidateSet::Error(e) => Err(ProjectionError::TraitSelectionError(e)),\n         // Inherent ambiguity that prevents us from even enumerating the\n         // candidates.\n-        ProjectionTyCandidateSet::Ambiguous => Err(ProjectionTyError::TooManyCandidates),\n+        ProjectionCandidateSet::Ambiguous => Err(ProjectionError::TooManyCandidates),\n     }\n }\n \n@@ -1124,14 +1215,13 @@ fn project_type<'cx, 'tcx>(\n fn assemble_candidates_from_param_env<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+    candidate_set: &mut ProjectionCandidateSet<'tcx>,\n ) {\n-    debug!(\"assemble_candidates_from_param_env(..)\");\n     assemble_candidates_from_predicates(\n         selcx,\n         obligation,\n         candidate_set,\n-        ProjectionTyCandidate::ParamEnv,\n+        ProjectionCandidate::ParamEnv,\n         obligation.param_env.caller_bounds().iter(),\n         false,\n     );\n@@ -1150,7 +1240,7 @@ fn assemble_candidates_from_param_env<'cx, 'tcx>(\n fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+    candidate_set: &mut ProjectionCandidateSet<'tcx>,\n ) {\n     debug!(\"assemble_candidates_from_trait_def(..)\");\n \n@@ -1173,7 +1263,7 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n         selcx,\n         obligation,\n         candidate_set,\n-        ProjectionTyCandidate::TraitDef,\n+        ProjectionCandidate::TraitDef,\n         bounds.iter(),\n         true,\n     )\n@@ -1191,7 +1281,7 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n fn assemble_candidates_from_object_ty<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+    candidate_set: &mut ProjectionCandidateSet<'tcx>,\n ) {\n     debug!(\"assemble_candidates_from_object_ty(..)\");\n \n@@ -1218,7 +1308,7 @@ fn assemble_candidates_from_object_ty<'cx, 'tcx>(\n         selcx,\n         obligation,\n         candidate_set,\n-        ProjectionTyCandidate::Object,\n+        ProjectionCandidate::Object,\n         env_predicates,\n         false,\n     );\n@@ -1231,14 +1321,13 @@ fn assemble_candidates_from_object_ty<'cx, 'tcx>(\n fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n-    ctor: fn(ty::PolyProjectionPredicate<'tcx>) -> ProjectionTyCandidate<'tcx>,\n+    candidate_set: &mut ProjectionCandidateSet<'tcx>,\n+    ctor: fn(ty::PolyProjectionPredicate<'tcx>) -> ProjectionCandidate<'tcx>,\n     env_predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n     potentially_unnormalized_candidates: bool,\n ) {\n     let infcx = selcx.infcx();\n     for predicate in env_predicates {\n-        debug!(?predicate);\n         let bound_predicate = predicate.kind();\n         if let ty::PredicateKind::Projection(data) = predicate.kind().skip_binder() {\n             let data = bound_predicate.rebind(data);\n@@ -1253,8 +1342,6 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n                     )\n                 });\n \n-            debug!(?data, ?is_match, ?same_def_id);\n-\n             if is_match {\n                 candidate_set.push_candidate(ctor(data));\n \n@@ -1275,7 +1362,7 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n fn assemble_candidates_from_impls<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+    candidate_set: &mut ProjectionCandidateSet<'tcx>,\n ) {\n     // If we are resolving `<T as TraitRef<...>>::Item == Type`,\n     // start out by selecting the predicate `T as TraitRef<...>`:\n@@ -1327,7 +1414,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // NOTE: This should be kept in sync with the similar code in\n                 // `rustc_ty_utils::instance::resolve_associated_item()`.\n                 let node_item =\n-                    assoc_ty_def(selcx, impl_data.impl_def_id, obligation.predicate.item_def_id)\n+                    assoc_def(selcx, impl_data.impl_def_id, obligation.predicate.item_def_id)\n                         .map_err(|ErrorReported| ())?;\n \n                 if node_item.is_final() {\n@@ -1500,7 +1587,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n         };\n \n         if eligible {\n-            if candidate_set.push_candidate(ProjectionTyCandidate::Select(impl_source)) {\n+            if candidate_set.push_candidate(ProjectionCandidate::Select(impl_source)) {\n                 Ok(())\n             } else {\n                 Err(())\n@@ -1514,30 +1601,62 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n fn confirm_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    candidate: ProjectionTyCandidate<'tcx>,\n-) -> Progress<'tcx> {\n+    candidate: ProjectionCandidate<'tcx>,\n+) -> Progress<'tcx, Ty<'tcx>> {\n     debug!(?obligation, ?candidate, \"confirm_candidate\");\n     let mut progress = match candidate {\n-        ProjectionTyCandidate::ParamEnv(poly_projection)\n-        | ProjectionTyCandidate::Object(poly_projection) => {\n+        ProjectionCandidate::ParamEnv(poly_projection)\n+        | ProjectionCandidate::Object(poly_projection) => {\n             confirm_param_env_candidate(selcx, obligation, poly_projection, false)\n         }\n \n-        ProjectionTyCandidate::TraitDef(poly_projection) => {\n+        ProjectionCandidate::TraitDef(poly_projection) => {\n             confirm_param_env_candidate(selcx, obligation, poly_projection, true)\n         }\n \n-        ProjectionTyCandidate::Select(impl_source) => {\n+        ProjectionCandidate::Select(impl_source) => {\n             confirm_select_candidate(selcx, obligation, impl_source)\n         }\n     };\n+\n+    // When checking for cycle during evaluation, we compare predicates with\n+    // \"syntactic\" equality. Since normalization generally introduces a type\n+    // with new region variables, we need to resolve them to existing variables\n+    // when possible for this to work. See `auto-trait-projection-recursion.rs`\n+    // for a case where this matters.\n+    if progress.term.has_infer_regions() {\n+        progress.term = OpportunisticRegionResolver::new(selcx.infcx()).fold_ty(progress.term);\n+    }\n+    progress\n+}\n+\n+fn confirm_candidate_const<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    candidate: ProjectionCandidate<'tcx>,\n+) -> Progress<'tcx, &'tcx ty::Const<'tcx>> {\n+    let mut progress = match candidate {\n+        ProjectionCandidate::ParamEnv(poly_projection)\n+        | ProjectionCandidate::Object(poly_projection) => {\n+            confirm_param_env_candidate_const(selcx, obligation, poly_projection, false)\n+        }\n+\n+        ProjectionCandidate::TraitDef(poly_projection) => {\n+            confirm_param_env_candidate_const(selcx, obligation, poly_projection, true)\n+        }\n+\n+        ProjectionCandidate::Select(impl_source) => {\n+            confirm_select_candidate_const(selcx, obligation, impl_source)\n+        }\n+    };\n+\n     // When checking for cycle during evaluation, we compare predicates with\n     // \"syntactic\" equality. Since normalization generally introduces a type\n     // with new region variables, we need to resolve them to existing variables\n     // when possible for this to work. See `auto-trait-projection-recursion.rs`\n     // for a case where this matters.\n-    if progress.ty.has_infer_regions() {\n-        progress.ty = OpportunisticRegionResolver::new(selcx.infcx()).fold_ty(progress.ty);\n+    if progress.term.has_infer_regions() {\n+        progress.term = OpportunisticRegionResolver::new(selcx.infcx()).fold_const(progress.term);\n     }\n     progress\n }\n@@ -1546,7 +1665,7 @@ fn confirm_select_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     impl_source: Selection<'tcx>,\n-) -> Progress<'tcx> {\n+) -> Progress<'tcx, Ty<'tcx>> {\n     match impl_source {\n         super::ImplSource::UserDefined(data) => confirm_impl_candidate(selcx, obligation, data),\n         super::ImplSource::Generator(data) => confirm_generator_candidate(selcx, obligation, data),\n@@ -1573,11 +1692,42 @@ fn confirm_select_candidate<'cx, 'tcx>(\n     }\n }\n \n+fn confirm_select_candidate_const<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    impl_source: Selection<'tcx>,\n+) -> Progress<'tcx, &'tcx ty::Const<'tcx>> {\n+    match impl_source {\n+        super::ImplSource::UserDefined(data) => {\n+            confirm_impl_candidate_const(selcx, obligation, data)\n+        }\n+        super::ImplSource::Generator(_)\n+        | super::ImplSource::Closure(_)\n+        | super::ImplSource::FnPointer(_)\n+        | super::ImplSource::DiscriminantKind(_)\n+        | super::ImplSource::Pointee(_) => todo!(),\n+        super::ImplSource::Object(_)\n+        | super::ImplSource::AutoImpl(..)\n+        | super::ImplSource::Param(..)\n+        | super::ImplSource::Builtin(..)\n+        | super::ImplSource::TraitUpcasting(_)\n+        | super::ImplSource::TraitAlias(..)\n+        | super::ImplSource::ConstDrop(_) => {\n+            // we don't create Select candidates with this kind of resolution\n+            span_bug!(\n+                obligation.cause.span,\n+                \"Cannot project an associated type from `{:?}`\",\n+                impl_source\n+            )\n+        }\n+    }\n+}\n+\n fn confirm_generator_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     impl_source: ImplSourceGeneratorData<'tcx, PredicateObligation<'tcx>>,\n-) -> Progress<'tcx> {\n+) -> Progress<'tcx, Ty<'tcx>> {\n     let gen_sig = impl_source.substs.as_generator().poly_sig();\n     let Normalized { value: gen_sig, obligations } = normalize_with_depth(\n         selcx,\n@@ -1627,7 +1777,7 @@ fn confirm_discriminant_kind_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     _: ImplSourceDiscriminantKindData,\n-) -> Progress<'tcx> {\n+) -> Progress<'tcx, Ty<'tcx>> {\n     let tcx = selcx.tcx();\n \n     let self_ty = selcx.infcx().shallow_resolve(obligation.predicate.self_ty());\n@@ -1652,7 +1802,7 @@ fn confirm_pointee_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     _: ImplSourcePointeeData,\n-) -> Progress<'tcx> {\n+) -> Progress<'tcx, Ty<'tcx>> {\n     let tcx = selcx.tcx();\n     let self_ty = selcx.infcx().shallow_resolve(obligation.predicate.self_ty());\n \n@@ -1684,7 +1834,7 @@ fn confirm_fn_pointer_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     fn_pointer_impl_source: ImplSourceFnPointerData<'tcx, PredicateObligation<'tcx>>,\n-) -> Progress<'tcx> {\n+) -> Progress<'tcx, Ty<'tcx>> {\n     let fn_type = selcx.infcx().shallow_resolve(fn_pointer_impl_source.fn_ty);\n     let sig = fn_type.fn_sig(selcx.tcx());\n     let Normalized { value: sig, obligations } = normalize_with_depth(\n@@ -1704,7 +1854,7 @@ fn confirm_closure_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     impl_source: ImplSourceClosureData<'tcx, PredicateObligation<'tcx>>,\n-) -> Progress<'tcx> {\n+) -> Progress<'tcx, Ty<'tcx>> {\n     let closure_sig = impl_source.substs.as_closure().sig();\n     let Normalized { value: closure_sig, obligations } = normalize_with_depth(\n         selcx,\n@@ -1726,7 +1876,7 @@ fn confirm_callable_candidate<'cx, 'tcx>(\n     obligation: &ProjectionTyObligation<'tcx>,\n     fn_sig: ty::PolyFnSig<'tcx>,\n     flag: util::TupleArgumentsFlag,\n-) -> Progress<'tcx> {\n+) -> Progress<'tcx, Ty<'tcx>> {\n     let tcx = selcx.tcx();\n \n     debug!(?obligation, ?fn_sig, \"confirm_callable_candidate\");\n@@ -1757,7 +1907,7 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n     obligation: &ProjectionTyObligation<'tcx>,\n     poly_cache_entry: ty::PolyProjectionPredicate<'tcx>,\n     potentially_unnormalized_candidate: bool,\n-) -> Progress<'tcx> {\n+) -> Progress<'tcx, Ty<'tcx>> {\n     let infcx = selcx.infcx();\n     let cause = &obligation.cause;\n     let param_env = obligation.param_env;\n@@ -1804,7 +1954,7 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n             assoc_ty_own_obligations(selcx, obligation, &mut nested_obligations);\n             // FIXME(associated_const_equality): Handle consts here as well? Maybe this progress type should just take\n             // a term instead.\n-            Progress { ty: cache_entry.term.ty().unwrap(), obligations: nested_obligations }\n+            Progress { term: cache_entry.term.ty().unwrap(), obligations: nested_obligations }\n         }\n         Err(e) => {\n             let msg = format!(\n@@ -1813,7 +1963,72 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n             );\n             debug!(\"confirm_param_env_candidate: {}\", msg);\n             let err = infcx.tcx.ty_error_with_message(obligation.cause.span, &msg);\n-            Progress { ty: err, obligations: vec![] }\n+            Progress { term: err, obligations: vec![] }\n+        }\n+    }\n+}\n+\n+fn confirm_param_env_candidate_const<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    poly_cache_entry: ty::PolyProjectionPredicate<'tcx>,\n+    potentially_unnormalized_candidate: bool,\n+) -> Progress<'tcx, &'tcx ty::Const<'tcx>> {\n+    let infcx = selcx.infcx();\n+    let cause = &obligation.cause;\n+    let param_env = obligation.param_env;\n+\n+    let (cache_entry, _) = infcx.replace_bound_vars_with_fresh_vars(\n+        cause.span,\n+        LateBoundRegionConversionTime::HigherRankedType,\n+        poly_cache_entry,\n+    );\n+\n+    let cache_projection = cache_entry.projection_ty;\n+    let mut nested_obligations = Vec::new();\n+    let obligation_projection = obligation.predicate;\n+    let obligation_projection = ensure_sufficient_stack(|| {\n+        normalize_with_depth_to(\n+            selcx,\n+            obligation.param_env,\n+            obligation.cause.clone(),\n+            obligation.recursion_depth + 1,\n+            obligation_projection,\n+            &mut nested_obligations,\n+        )\n+    });\n+    let cache_projection = if potentially_unnormalized_candidate {\n+        ensure_sufficient_stack(|| {\n+            normalize_with_depth_to(\n+                selcx,\n+                obligation.param_env,\n+                obligation.cause.clone(),\n+                obligation.recursion_depth + 1,\n+                cache_projection,\n+                &mut nested_obligations,\n+            )\n+        })\n+    } else {\n+        cache_projection\n+    };\n+\n+    match infcx.at(cause, param_env).eq(cache_projection, obligation_projection) {\n+        Ok(InferOk { value: _, obligations }) => {\n+            nested_obligations.extend(obligations);\n+            assoc_ty_own_obligations(selcx, obligation, &mut nested_obligations);\n+            Progress { term: cache_entry.term.ct().unwrap(), obligations: nested_obligations }\n+        }\n+        Err(e) => {\n+            let msg = format!(\n+                \"Failed to unify obligation `{:?}` with poly_projection `{:?}`: {:?}\",\n+                obligation, poly_cache_entry, e,\n+            );\n+            let err = infcx.tcx.const_error_with_message(\n+                infcx.tcx.ty_error(),\n+                obligation.cause.span,\n+                &msg,\n+            );\n+            Progress { term: err, obligations: vec![] }\n         }\n     }\n }\n@@ -1822,17 +2037,17 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     impl_impl_source: ImplSourceUserDefinedData<'tcx, PredicateObligation<'tcx>>,\n-) -> Progress<'tcx> {\n+) -> Progress<'tcx, Ty<'tcx>> {\n     let tcx = selcx.tcx();\n \n     let ImplSourceUserDefinedData { impl_def_id, substs, mut nested } = impl_impl_source;\n     let assoc_item_id = obligation.predicate.item_def_id;\n     let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n \n     let param_env = obligation.param_env;\n-    let assoc_ty = match assoc_ty_def(selcx, impl_def_id, assoc_item_id) {\n+    let assoc_ty = match assoc_def(selcx, impl_def_id, assoc_item_id) {\n         Ok(assoc_ty) => assoc_ty,\n-        Err(ErrorReported) => return Progress { ty: tcx.ty_error(), obligations: nested },\n+        Err(ErrorReported) => return Progress { term: tcx.ty_error(), obligations: nested },\n     };\n \n     if !assoc_ty.item.defaultness.has_value() {\n@@ -1844,7 +2059,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n             \"confirm_impl_candidate: no associated type {:?} for {:?}\",\n             assoc_ty.item.name, obligation.predicate\n         );\n-        return Progress { ty: tcx.ty_error(), obligations: nested };\n+        return Progress { term: tcx.ty_error(), obligations: nested };\n     }\n     // If we're trying to normalize `<Vec<u32> as X>::A<S>` using\n     //`impl<T> X for Vec<T> { type A<Y> = Box<Y>; }`, then:\n@@ -1861,10 +2076,54 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n             obligation.cause.span,\n             \"impl item and trait item have different parameter counts\",\n         );\n-        Progress { ty: err, obligations: nested }\n+        Progress { term: err, obligations: nested }\n     } else {\n         assoc_ty_own_obligations(selcx, obligation, &mut nested);\n-        Progress { ty: ty.subst(tcx, substs), obligations: nested }\n+        Progress { term: ty.subst(tcx, substs), obligations: nested }\n+    }\n+}\n+\n+fn confirm_impl_candidate_const<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    impl_impl_source: ImplSourceUserDefinedData<'tcx, PredicateObligation<'tcx>>,\n+) -> Progress<'tcx, &'tcx ty::Const<'tcx>> {\n+    let tcx = selcx.tcx();\n+\n+    let ImplSourceUserDefinedData { impl_def_id, substs, nested } = impl_impl_source;\n+    let assoc_item_id = obligation.predicate.item_def_id;\n+    let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n+\n+    let param_env = obligation.param_env;\n+    let assoc_ct = match assoc_def(selcx, impl_def_id, assoc_item_id) {\n+        Ok(assoc_ct) => assoc_ct,\n+        Err(ErrorReported) => {\n+            return Progress { term: tcx.const_error(tcx.ty_error()), obligations: nested };\n+        }\n+    };\n+\n+    if !assoc_ct.item.defaultness.has_value() {\n+        return Progress { term: tcx.const_error(tcx.ty_error()), obligations: nested };\n+    }\n+    let substs = obligation.predicate.substs.rebase_onto(tcx, trait_def_id, substs);\n+    let substs =\n+        translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ct.defining_node);\n+    let _ty = tcx.type_of(assoc_ct.item.def_id);\n+    // TODO need to figure how to get the const of the assoc_ct.item.def_id\n+    // I'm not sure if there's another tcx query for it.\n+    let _ct = ();\n+    if substs.len() != tcx.generics_of(assoc_ct.item.def_id).count() {\n+        let err = tcx.const_error_with_message(\n+            tcx.ty_error(),\n+            obligation.cause.span,\n+            \"impl item and trait item have different parameter counts\",\n+        );\n+        Progress { term: err, obligations: nested }\n+    } else {\n+        // There are no where-clauses on associated consts yet, but if that's\n+        // ever added it would go here.\n+        todo!();\n+        //Progress { term: ct.subst(tcx, substs), obligations: nested }\n     }\n }\n \n@@ -1905,10 +2164,10 @@ fn assoc_ty_own_obligations<'cx, 'tcx>(\n ///\n /// Based on the \"projection mode\", this lookup may in fact only examine the\n /// topmost impl. See the comments for `Reveal` for more details.\n-fn assoc_ty_def(\n+fn assoc_def(\n     selcx: &SelectionContext<'_, '_>,\n     impl_def_id: DefId,\n-    assoc_ty_def_id: DefId,\n+    assoc_def_id: DefId,\n ) -> Result<specialization_graph::LeafDef, ErrorReported> {\n     let tcx = selcx.tcx();\n     let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n@@ -1920,7 +2179,7 @@ fn assoc_ty_def(\n     // for the associated item at the given impl.\n     // If there is no such item in that impl, this function will fail with a\n     // cycle error if the specialization graph is currently being built.\n-    if let Some(&impl_item_id) = tcx.impl_item_implementor_ids(impl_def_id).get(&assoc_ty_def_id) {\n+    if let Some(&impl_item_id) = tcx.impl_item_implementor_ids(impl_def_id).get(&assoc_def_id) {\n         let item = tcx.associated_item(impl_item_id);\n         let impl_node = specialization_graph::Node::Impl(impl_def_id);\n         return Ok(specialization_graph::LeafDef {\n@@ -1931,7 +2190,7 @@ fn assoc_ty_def(\n     }\n \n     let ancestors = trait_def.ancestors(tcx, impl_def_id)?;\n-    if let Some(assoc_item) = ancestors.leaf_def(tcx, assoc_ty_def_id) {\n+    if let Some(assoc_item) = ancestors.leaf_def(tcx, assoc_def_id) {\n         Ok(assoc_item)\n     } else {\n         // This is saying that neither the trait nor\n@@ -1942,7 +2201,7 @@ fn assoc_ty_def(\n         // should have failed in astconv.\n         bug!(\n             \"No associated type `{}` for {}\",\n-            tcx.item_name(assoc_ty_def_id),\n+            tcx.item_name(assoc_def_id),\n             tcx.def_path_str(impl_def_id)\n         )\n     }"}, {"sha": "6124d2906fff07e7104c1328cb7bfe317c2ef810", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1c4fe64bdcb0cc27c91c5405430f0ca189fcd065/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4fe64bdcb0cc27c91c5405430f0ca189fcd065/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=1c4fe64bdcb0cc27c91c5405430f0ca189fcd065", "patch": "@@ -1132,51 +1132,48 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         // We have already adjusted the item name above, so compare with `ident.normalize_to_macros_2_0()` instead\n         // of calling `filter_by_name_and_kind`.\n-        let assoc_ty = tcx\n+        let assoc_item = tcx\n             .associated_items(candidate.def_id())\n             .filter_by_name_unhygienic(assoc_ident.name)\n             .find(|i| {\n                 (i.kind == ty::AssocKind::Type || i.kind == ty::AssocKind::Const)\n                     && i.ident(tcx).normalize_to_macros_2_0() == assoc_ident\n             })\n             .expect(\"missing associated type\");\n-        // FIXME(associated_const_equality): need to handle assoc_consts here as well.\n-        if assoc_ty.kind == ty::AssocKind::Const {\n-            tcx.sess\n-                .struct_span_err(path_span, &format!(\"associated const equality is incomplete\"))\n-                .span_label(path_span, \"cannot yet relate associated const\")\n-                .emit();\n-            return Err(ErrorReported);\n-        }\n \n-        if !assoc_ty.vis.is_accessible_from(def_scope, tcx) {\n+        if !assoc_item.vis.is_accessible_from(def_scope, tcx) {\n+            let kind = match assoc_item.kind {\n+                ty::AssocKind::Type => \"type\",\n+                ty::AssocKind::Const => \"const\",\n+                _ => unreachable!(),\n+            };\n             tcx.sess\n                 .struct_span_err(\n                     binding.span,\n-                    &format!(\"associated type `{}` is private\", binding.item_name),\n+                    &format!(\"associated {kind} `{}` is private\", binding.item_name),\n                 )\n-                .span_label(binding.span, \"private associated type\")\n+                .span_label(binding.span, &format!(\"private associated {kind}\"))\n                 .emit();\n         }\n-        tcx.check_stability(assoc_ty.def_id, Some(hir_ref_id), binding.span, None);\n+        tcx.check_stability(assoc_item.def_id, Some(hir_ref_id), binding.span, None);\n \n         if !speculative {\n             dup_bindings\n-                .entry(assoc_ty.def_id)\n+                .entry(assoc_item.def_id)\n                 .and_modify(|prev_span| {\n                     self.tcx().sess.emit_err(ValueOfAssociatedStructAlreadySpecified {\n                         span: binding.span,\n                         prev_span: *prev_span,\n                         item_name: binding.item_name,\n-                        def_path: tcx.def_path_str(assoc_ty.container.id()),\n+                        def_path: tcx.def_path_str(assoc_item.container.id()),\n                     });\n                 })\n                 .or_insert(binding.span);\n         }\n \n         // Include substitutions for generic parameters of associated types\n         let projection_ty = candidate.map_bound(|trait_ref| {\n-            let ident = Ident::new(assoc_ty.name, binding.item_name.span);\n+            let ident = Ident::new(assoc_item.name, binding.item_name.span);\n             let item_segment = hir::PathSegment {\n                 ident,\n                 hir_id: Some(binding.hir_id),\n@@ -1188,7 +1185,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             let substs_trait_ref_and_assoc_item = self.create_substs_for_associated_item(\n                 tcx,\n                 path_span,\n-                assoc_ty.def_id,\n+                assoc_item.def_id,\n                 &item_segment,\n                 trait_ref.substs,\n             );\n@@ -1199,14 +1196,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             );\n \n             ty::ProjectionTy {\n-                item_def_id: assoc_ty.def_id,\n+                item_def_id: assoc_item.def_id,\n                 substs: substs_trait_ref_and_assoc_item,\n             }\n         });\n \n         if !speculative {\n             // Find any late-bound regions declared in `ty` that are not\n-            // declared in the trait-ref or assoc_ty. These are not well-formed.\n+            // declared in the trait-ref or assoc_item. These are not well-formed.\n             //\n             // Example:\n             //"}, {"sha": "d5430fefc531259102f76e7d9e0a04448f920fa3", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 79, "deletions": 6, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/1c4fe64bdcb0cc27c91c5405430f0ca189fcd065/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4fe64bdcb0cc27c91c5405430f0ca189fcd065/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=1c4fe64bdcb0cc27c91c5405430f0ca189fcd065", "patch": "@@ -1,5 +1,6 @@\n use rustc_errors::{Applicability, ErrorReported, StashKey};\n use rustc_hir as hir;\n+use rustc_hir::def::CtorOf;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit;\n@@ -170,19 +171,47 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n                         .position(|arg| arg.id() == hir_id)\n                         .map(|index| (index, seg))\n                 });\n+            // FIXME(associated_const_equality): recursively search through the bindings instead\n+            // of just top level.\n+\n             let (arg_index, segment) = match filtered {\n                 None => {\n-                    tcx.sess\n-                        .delay_span_bug(tcx.def_span(def_id), \"no arg matching AnonConst in path\");\n-                    return None;\n+                    let binding_filtered = path\n+                        .segments\n+                        .iter()\n+                        .filter_map(|seg| seg.args.map(|args| (args.bindings, seg)))\n+                        .find_map(|(bindings, seg)| {\n+                            bindings\n+                                .iter()\n+                                .filter_map(|binding| {\n+                                    if let hir::TypeBindingKind::Equality { term: Term::Const(c) } =\n+                                        binding.kind\n+                                    {\n+                                        Some(c)\n+                                    } else {\n+                                        None\n+                                    }\n+                                })\n+                                .position(|ct| ct.hir_id == hir_id)\n+                                .map(|idx| (idx, seg))\n+                        });\n+                    match binding_filtered {\n+                        Some(inner) => inner,\n+                        None => {\n+                            tcx.sess.delay_span_bug(\n+                                tcx.def_span(def_id),\n+                                \"no arg matching AnonConst in path\",\n+                            );\n+                            return None;\n+                        }\n+                    }\n                 }\n                 Some(inner) => inner,\n             };\n \n             // Try to use the segment resolution if it is valid, otherwise we\n             // default to the path resolution.\n             let res = segment.res.filter(|&r| r != Res::Err).unwrap_or(path.res);\n-            use def::CtorOf;\n             let generics = match res {\n                 Res::Def(DefKind::Ctor(CtorOf::Variant, _), def_id) => tcx\n                     .generics_of(tcx.parent(def_id).and_then(|def_id| tcx.parent(def_id)).unwrap()),\n@@ -483,15 +512,59 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     .discr_type()\n                     .to_ty(tcx),\n \n+                Node::TraitRef(trait_ref @ &TraitRef {\n+                  path, ..\n+                }) if let Some((binding, seg)) =\n+                  path\n+                      .segments\n+                      .iter()\n+                      .filter_map(|seg| seg.args.map(|args| (args.bindings, seg)))\n+                      .find_map(|(bindings, seg)| {\n+                          bindings\n+                              .iter()\n+                              .filter_map(|binding| {\n+                                  if let hir::TypeBindingKind::Equality { term: Term::Const(c) } =\n+                                      binding.kind\n+                                  {\n+                                          Some((binding, c))\n+                                  } else {\n+                                      None\n+                                  }\n+                              })\n+                              .find_map(|(binding, ct)| if ct.hir_id == hir_id {\n+                                Some((binding, seg))\n+                              } else {\n+                                None\n+                              })\n+                      }) =>\n+                {\n+                  // TODO when does this unwrap fail? I have no idea what case it would.\n+                  let trait_def_id = trait_ref.trait_def_id().unwrap();\n+                  let assoc_items = tcx.associated_items(trait_def_id);\n+                  let assoc_item = assoc_items.find_by_name_and_kind(\n+                    tcx, binding.ident, ty::AssocKind::Const, def_id.to_def_id(),\n+                  );\n+                  if let Some(assoc_item) = assoc_item {\n+                    tcx.type_of(assoc_item.def_id)\n+                  } else {\n+                      // TODO useful error message here.\n+                      tcx.ty_error_with_message(\n+                        DUMMY_SP,\n+                        &format!(\"Could not find associated const on trait\"),\n+                    )\n+                  }\n+                }\n+\n                 Node::GenericParam(&GenericParam {\n                     hir_id: param_hir_id,\n                     kind: GenericParamKind::Const { default: Some(ct), .. },\n                     ..\n                 }) if ct.hir_id == hir_id => tcx.type_of(tcx.hir().local_def_id(param_hir_id)),\n \n-                x => tcx.ty_error_with_message(\n+                x =>\n+                  tcx.ty_error_with_message(\n                     DUMMY_SP,\n-                    &format!(\"unexpected const parent in type_of(): {:?}\", x),\n+                    &format!(\"unexpected const parent in type_of(): {x:?}\"),\n                 ),\n             }\n         }"}, {"sha": "9c7884c80734ca8750a5ae638099657649884968", "filename": "src/test/ui/associated-consts/assoc-const.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1c4fe64bdcb0cc27c91c5405430f0ca189fcd065/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4fe64bdcb0cc27c91c5405430f0ca189fcd065/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const.rs?ref=1c4fe64bdcb0cc27c91c5405430f0ca189fcd065", "patch": "@@ -1,4 +1,6 @@\n+// run-pass\n #![feature(associated_const_equality)]\n+#![allow(unused)]\n \n pub trait Foo {\n   const N: usize;\n@@ -13,9 +15,8 @@ impl Foo for Bar {\n const TEST:usize = 3;\n \n \n-fn foo<F: Foo<N=3>>() {}\n-//~^ ERROR associated const equality is incomplete\n-fn bar<F: Foo<N={TEST}>>() {}\n-//~^ ERROR associated const equality is incomplete\n+fn foo<F: Foo<N=3usize>>() {}\n \n-fn main() {}\n+fn main() {\n+  foo::<Bar>()\n+}"}, {"sha": "ccaa6fa8ee8847156bd2170cba80504468f6ce05", "filename": "src/test/ui/associated-consts/assoc-const.stderr", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/21b4a9cfdcbb1e76f4b36b5c3cfd64d627285093/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21b4a9cfdcbb1e76f4b36b5c3cfd64d627285093/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const.stderr?ref=21b4a9cfdcbb1e76f4b36b5c3cfd64d627285093", "patch": "@@ -1,14 +0,0 @@\n-error: associated const equality is incomplete\n-  --> $DIR/assoc-const.rs:16:15\n-   |\n-LL | fn foo<F: Foo<N=3>>() {}\n-   |               ^^^ cannot yet relate associated const\n-\n-error: associated const equality is incomplete\n-  --> $DIR/assoc-const.rs:18:15\n-   |\n-LL | fn bar<F: Foo<N={TEST}>>() {}\n-   |               ^^^^^^^^ cannot yet relate associated const\n-\n-error: aborting due to 2 previous errors\n-"}]}