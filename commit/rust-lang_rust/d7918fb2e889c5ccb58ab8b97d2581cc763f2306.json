{"sha": "d7918fb2e889c5ccb58ab8b97d2581cc763f2306", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3OTE4ZmIyZTg4OWM1Y2NiNThhYjhiOTdkMjU4MWNjNzYzZjIzMDY=", "commit": {"author": {"name": "Bastian K\u00f6cher", "email": "git@kchr.de", "date": "2017-12-03T21:16:24Z"}, "committer": {"name": "Bastian K\u00f6cher", "email": "git@kchr.de", "date": "2017-12-26T11:26:39Z"}, "message": "Implements RFC 1937: `?` in `main`\n\nThis is the first part of the RFC 1937 that supports new\n`Termination` trait in the rust `main` function.", "tree": {"sha": "a25c4ba1da52089945ce84e9ec8e1b51f45cfd8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a25c4ba1da52089945ce84e9ec8e1b51f45cfd8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7918fb2e889c5ccb58ab8b97d2581cc763f2306", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7918fb2e889c5ccb58ab8b97d2581cc763f2306", "html_url": "https://github.com/rust-lang/rust/commit/d7918fb2e889c5ccb58ab8b97d2581cc763f2306", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/comments", "author": {"login": "bkchr", "id": 5718007, "node_id": "MDQ6VXNlcjU3MTgwMDc=", "avatar_url": "https://avatars.githubusercontent.com/u/5718007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bkchr", "html_url": "https://github.com/bkchr", "followers_url": "https://api.github.com/users/bkchr/followers", "following_url": "https://api.github.com/users/bkchr/following{/other_user}", "gists_url": "https://api.github.com/users/bkchr/gists{/gist_id}", "starred_url": "https://api.github.com/users/bkchr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bkchr/subscriptions", "organizations_url": "https://api.github.com/users/bkchr/orgs", "repos_url": "https://api.github.com/users/bkchr/repos", "events_url": "https://api.github.com/users/bkchr/events{/privacy}", "received_events_url": "https://api.github.com/users/bkchr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bkchr", "id": 5718007, "node_id": "MDQ6VXNlcjU3MTgwMDc=", "avatar_url": "https://avatars.githubusercontent.com/u/5718007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bkchr", "html_url": "https://github.com/bkchr", "followers_url": "https://api.github.com/users/bkchr/followers", "following_url": "https://api.github.com/users/bkchr/following{/other_user}", "gists_url": "https://api.github.com/users/bkchr/gists{/gist_id}", "starred_url": "https://api.github.com/users/bkchr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bkchr/subscriptions", "organizations_url": "https://api.github.com/users/bkchr/orgs", "repos_url": "https://api.github.com/users/bkchr/repos", "events_url": "https://api.github.com/users/bkchr/events{/privacy}", "received_events_url": "https://api.github.com/users/bkchr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cdde6db7138cf2365dd9ceb5b8814e92a922ed4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cdde6db7138cf2365dd9ceb5b8814e92a922ed4", "html_url": "https://github.com/rust-lang/rust/commit/8cdde6db7138cf2365dd9ceb5b8814e92a922ed4"}], "stats": {"total": 356, "additions": 304, "deletions": 52}, "files": [{"sha": "dca676130b9a7bfca693a2d2e788cc680d3dbe66", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=d7918fb2e889c5ccb58ab8b97d2581cc763f2306", "patch": "@@ -338,6 +338,8 @@ language_item_table! {\n     U128ShloFnLangItem,              \"u128_shlo\",               u128_shlo_fn;\n     I128ShroFnLangItem,              \"i128_shro\",               i128_shro_fn;\n     U128ShroFnLangItem,              \"u128_shro\",               u128_shro_fn;\n+\n+    TerminationTraitLangItem,        \"termination\",             termination;\n }\n \n impl<'a, 'tcx, 'gcx> TyCtxt<'a, 'tcx, 'gcx> {"}, {"sha": "056c6989abac850b5cc0b4a2a20d832c63324f98", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 62, "deletions": 22, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=d7918fb2e889c5ccb58ab8b97d2581cc763f2306", "patch": "@@ -194,11 +194,13 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n use rustc::middle::const_val::ConstVal;\n-use rustc::middle::lang_items::{ExchangeMallocFnLangItem};\n+use rustc::middle::lang_items::{ExchangeMallocFnLangItem,StartFnLangItem};\n+use rustc::middle::trans::TransItem;\n use rustc::traits;\n-use rustc::ty::subst::Substs;\n+use rustc::ty::subst::{Substs, Kind};\n use rustc::ty::{self, TypeFoldable, Ty, TyCtxt};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n+use rustc::session::config;\n use rustc::mir::{self, Location};\n use rustc::mir::visit::Visitor as MirVisitor;\n use rustc::mir::mono::MonoItem;\n@@ -212,6 +214,8 @@ use rustc_data_structures::bitvec::BitVector;\n \n use syntax::attr;\n \n+use std::iter;\n+\n #[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n pub enum MonoItemCollectionMode {\n     Eager,\n@@ -329,6 +333,8 @@ fn collect_roots<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             tcx.hir.local_def_id(node_id)\n         });\n \n+        debug!(\"collect_roots: entry_fn = {:?}\", entry_fn);\n+\n         let mut visitor = RootCollector {\n             tcx,\n             mode,\n@@ -951,16 +957,8 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                 // actually used somewhere. Just declaring them is insufficient.\n             }\n             hir::ItemFn(..) => {\n-                let tcx = self.tcx;\n-                let def_id = tcx.hir.local_def_id(item.id);\n-\n-                if self.is_root(def_id) {\n-                    debug!(\"RootCollector: ItemFn({})\",\n-                           def_id_to_string(tcx, def_id));\n-\n-                    let instance = Instance::mono(tcx, def_id);\n-                    self.output.push(MonoItem::Fn(instance));\n-                }\n+                let def_id = self.tcx.hir.local_def_id(item.id);\n+                self.push_if_root(def_id);\n             }\n         }\n     }\n@@ -973,16 +971,8 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n     fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n         match ii.node {\n             hir::ImplItemKind::Method(hir::MethodSig { .. }, _) => {\n-                let tcx = self.tcx;\n-                let def_id = tcx.hir.local_def_id(ii.id);\n-\n-                if self.is_root(def_id) {\n-                    debug!(\"RootCollector: MethodImplItem({})\",\n-                           def_id_to_string(tcx, def_id));\n-\n-                    let instance = Instance::mono(tcx, def_id);\n-                    self.output.push(MonoItem::Fn(instance));\n-                }\n+                let def_id = self.tcx.hir.local_def_id(ii.id);\n+                self.push_if_root(def_id);\n             }\n             _ => { /* Nothing to do here */ }\n         }\n@@ -1003,6 +993,56 @@ impl<'b, 'a, 'v> RootCollector<'b, 'a, 'v> {\n             }\n         }\n     }\n+\n+    /// If `def_id` represents a root, then push it onto the list of\n+    /// outputs. (Note that all roots must be monomorphic.)\n+    fn push_if_root(&mut self, def_id: DefId) {\n+        if self.is_root(def_id) {\n+            debug!(\"RootCollector::push_if_root: found root def_id={:?}\", def_id);\n+\n+            let instance = Instance::mono(self.tcx, def_id);\n+            self.output.push(create_fn_trans_item(instance));\n+\n+            self.push_extra_entry_roots(def_id);\n+        }\n+    }\n+\n+    /// As a special case, when/if we encounter the\n+    /// `main()` function, we also have to generate a\n+    /// monomorphized copy of the start lang item based on\n+    /// the return type of `main`. This is not needed when\n+    /// the user writes their own `start` manually.\n+    fn push_extra_entry_roots(&mut self, def_id: DefId) {\n+        if self.entry_fn != Some(def_id) {\n+            return;\n+        }\n+\n+        if self.tcx.sess.entry_type.get() != Some(config::EntryMain) {\n+            return;\n+        }\n+\n+        let start_def_id = match self.tcx.lang_items().require(StartFnLangItem) {\n+            Ok(s) => s,\n+            Err(err) => self.tcx.sess.fatal(&err),\n+        };\n+        let main_ret_ty = self.tcx.fn_sig(def_id).output();\n+\n+        // Given that `main()` has no arguments,\n+        // then its return type cannot have\n+        // late-bound regions, since late-bound\n+        // regions must appear in the argument\n+        // listing.\n+        let main_ret_ty = self.tcx.no_late_bound_regions(&main_ret_ty).unwrap();\n+\n+        let start_instance = Instance::resolve(\n+            self.tcx,\n+            ty::ParamEnv::empty(traits::Reveal::All),\n+            start_def_id,\n+            self.tcx.mk_substs(iter::once(Kind::from(main_ret_ty)))\n+        ).unwrap();\n+\n+        self.output.push(create_fn_trans_item(start_instance));\n+    }\n }\n \n fn item_has_type_parameters<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {"}, {"sha": "e34698da4dafbe27b551ee43da1e109f891880f6", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=d7918fb2e889c5ccb58ab8b97d2581cc763f2306", "patch": "@@ -106,7 +106,8 @@ use monomorphize::collector::InliningMap;\n use rustc::dep_graph::WorkProductId;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n-use rustc::mir::mono::{Linkage, Visibility};\n+use rustc::middle::lang_items::StartFnLangItem;\n+use rustc::middle::trans::{Linkage, Visibility};\n use rustc::ty::{self, TyCtxt, InstanceDef};\n use rustc::ty::item_path::characteristic_def_id_of_type;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n@@ -312,7 +313,13 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     MonoItem::Fn(ref instance) => {\n                         let visibility = match instance.def {\n                             InstanceDef::Item(def_id) => {\n-                                if def_id.is_local() {\n+                                let start_def_id = tcx.lang_items().require(StartFnLangItem);\n+\n+                                // If we encounter the lang start item, we set the visibility to\n+                                // default.\n+                                if start_def_id == Ok(def_id) {\n+                                    Visibility::Default\n+                                } else if def_id.is_local() {\n                                     if tcx.is_exported_symbol(def_id) {\n                                         Visibility::Default\n                                     } else {"}, {"sha": "b2d516e786883fc784b0b7d4680b005a8bce3f91", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=d7918fb2e889c5ccb58ab8b97d2581cc763f2306", "patch": "@@ -44,6 +44,7 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{self, Align, TyLayout, LayoutOf};\n use rustc::ty::maps::Providers;\n use rustc::dep_graph::{DepNode, DepConstructor};\n+use rustc::ty::subst::Kind;\n use rustc::middle::cstore::{self, LinkMeta, LinkagePreference};\n use rustc::util::common::{time, print_time_passes_entry};\n use rustc::session::config::{self, NoDebugInfo};\n@@ -79,6 +80,7 @@ use std::str;\n use std::sync::Arc;\n use std::time::{Instant, Duration};\n use std::i32;\n+use std::iter;\n use std::sync::mpsc;\n use syntax_pos::Span;\n use syntax_pos::symbol::InternedString;\n@@ -540,17 +542,28 @@ fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n \n     let et = ccx.sess().entry_type.get().unwrap();\n     match et {\n-        config::EntryMain => create_entry_fn(ccx, span, main_llfn, true),\n-        config::EntryStart => create_entry_fn(ccx, span, main_llfn, false),\n+        config::EntryMain => create_entry_fn(ccx, span, main_llfn, main_def_id, true),\n+        config::EntryStart => create_entry_fn(ccx, span, main_llfn, main_def_id, false),\n         config::EntryNone => {}    // Do nothing.\n     }\n \n-    fn create_entry_fn(ccx: &CrateContext,\n+    fn create_entry_fn<'ccx>(ccx: &'ccx CrateContext,\n                        sp: Span,\n                        rust_main: ValueRef,\n+                       rust_main_def_id: DefId,\n                        use_start_lang_item: bool) {\n-        // Signature of native main(), corresponding to C's `int main(int, char **)`\n-        let llfty = Type::func(&[Type::c_int(ccx), Type::i8p(ccx).ptr_to()], &Type::c_int(ccx));\n+        // The libstd lang_start function does not return anything, while user defined lang start\n+        // returns a isize\n+        let start_output_ty = if use_start_lang_item { Type::void(ccx) } else { Type::c_int(ccx) };\n+        let llfty = Type::func(&[Type::c_int(ccx), Type::i8p(ccx).ptr_to()], &start_output_ty);\n+\n+        let main_ret_ty = ccx.tcx().fn_sig(rust_main_def_id).output();\n+        // Given that `main()` has no arguments,\n+        // then its return type cannot have\n+        // late-bound regions, since late-bound\n+        // regions must appear in the argument\n+        // listing.\n+        let main_ret_ty = ccx.tcx().no_late_bound_regions(&main_ret_ty).unwrap();\n \n         if declare::get_defined_value(ccx, \"main\").is_some() {\n             // FIXME: We should be smart and show a better diagnostic here.\n@@ -577,8 +590,8 @@ fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n \n         let (start_fn, args) = if use_start_lang_item {\n             let start_def_id = ccx.tcx().require_lang_item(StartFnLangItem);\n-            let start_instance = Instance::mono(ccx.tcx(), start_def_id);\n-            let start_fn = callee::get_fn(ccx, start_instance);\n+            let start_fn = callee::resolve_and_get_fn(ccx, start_def_id, ccx.tcx().mk_substs(\n+                iter::once(Kind::from(main_ret_ty))));\n             (start_fn, vec![bld.pointercast(rust_main, Type::i8p(ccx).ptr_to()),\n                             arg_argc, arg_argv])\n         } else {\n@@ -588,8 +601,11 @@ fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n \n         let result = bld.call(start_fn, &args, None);\n \n-        // Return rust start function's result from native main()\n-        bld.ret(bld.intcast(result, Type::c_int(ccx), true));\n+        if use_start_lang_item {\n+            bld.ret_void();\n+        } else {\n+            bld.ret(bld.intcast(result, Type::c_int(ccx), true));\n+        }\n     }\n }\n "}, {"sha": "159340d19a7fe09cddbe6f300a75edbae507dc19", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d7918fb2e889c5ccb58ab8b97d2581cc763f2306", "patch": "@@ -93,17 +93,18 @@ use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin};\n use rustc::infer::anon_types::AnonTypeDecl;\n use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::middle::region;\n+use rustc::middle::lang_items::TerminationTraitLangItem;\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, FulfillmentContext, ObligationCause, ObligationCauseCode};\n use rustc::ty::{ParamTy, LvaluePreference, NoPreference, PreferMutLvalue};\n-use rustc::ty::{self, Ty, TyCtxt, Visibility};\n+use rustc::ty::{self, Ty, TyCtxt, Visibility, ToPredicate};\n use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::maps::Providers;\n use rustc::ty::util::{Representability, IntTypeExt};\n use errors::{DiagnosticBuilder, DiagnosticId};\n use require_c_abi_if_variadic;\n-use session::{CompileIncomplete, Session};\n+use session::{CompileIncomplete, config, Session};\n use TypeAndSubsts;\n use lint;\n use util::common::{ErrorReported, indenter};\n@@ -115,6 +116,7 @@ use std::collections::hash_map::Entry;\n use std::cmp;\n use std::fmt::Display;\n use std::mem::replace;\n+use std::iter;\n use std::ops::{self, Deref};\n use syntax::abi::Abi;\n use syntax::ast;\n@@ -1064,6 +1066,24 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     }\n     fcx.demand_suptype(span, ret_ty, actual_return_ty);\n \n+    if let Some((id, _)) = *fcx.tcx.sess.entry_fn.borrow() {\n+        if id == fn_id {\n+            match fcx.sess().entry_type.get() {\n+                Some(config::EntryMain) => {\n+                    let term_id = fcx.tcx.require_lang_item(TerminationTraitLangItem);\n+\n+                    let substs = fcx.tcx.mk_substs(iter::once(Kind::from(ret_ty)));\n+                    let trait_ref = ty::TraitRef::new(term_id, substs);\n+                    let cause = traits::ObligationCause::new(span, fn_id,\n+                                                             ObligationCauseCode::MainFunctionType);\n+                    inherited.register_predicate(\n+                        traits::Obligation::new(cause, param_env, trait_ref.to_predicate()));\n+                },\n+                _ => {},\n+            }\n+        }\n+    }\n+\n     (fcx, gen_ty)\n }\n "}, {"sha": "47022eb152dd07168c5f53a838feb06abd9c4145", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=d7918fb2e889c5ccb58ab8b97d2581cc763f2306", "patch": "@@ -115,7 +115,6 @@ use syntax::ast;\n use syntax::abi::Abi;\n use syntax_pos::Span;\n \n-use std::iter;\n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n mod diagnostics;\n@@ -200,21 +199,6 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 }\n                 _ => ()\n             }\n-            let se_ty = tcx.mk_fn_ptr(ty::Binder(\n-                tcx.mk_fn_sig(\n-                    iter::empty(),\n-                    tcx.mk_nil(),\n-                    false,\n-                    hir::Unsafety::Normal,\n-                    Abi::Rust\n-                )\n-            ));\n-\n-            require_same_types(\n-                tcx,\n-                &ObligationCause::new(main_span, main_id, ObligationCauseCode::MainFunctionType),\n-                se_ty,\n-                tcx.mk_fn_ptr(tcx.fn_sig(main_def_id)));\n         }\n         _ => {\n             span_bug!(main_span,"}, {"sha": "3a7a57fe2b83f761eef84612f13aef9382373a3a", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=d7918fb2e889c5ccb58ab8b97d2581cc763f2306", "patch": "@@ -308,6 +308,7 @@\n #![feature(str_char)]\n #![feature(str_internals)]\n #![feature(str_utf16)]\n+#![feature(termination_trait)]\n #![feature(test, rustc_private)]\n #![feature(thread_local)]\n #![feature(toowned_clone_into)]\n@@ -499,6 +500,11 @@ mod memchr;\n // The runtime entry point and a few unstable public functions used by the\n // compiler\n pub mod rt;\n+// The trait to support returning arbitrary types in the main function\n+mod termination;\n+\n+#[unstable(feature = \"termination_trait\", issue = \"0\")]\n+pub use self::termination::Termination;\n \n // Include a number of private modules that exist solely to provide\n // the rustdoc documentation for primitive types. Using `include!`"}, {"sha": "2b75201ad2b08d6150b5f3a00efb1182a0a97cde", "filename": "src/libstd/rt.rs", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Flibstd%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Flibstd%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt.rs?ref=d7918fb2e889c5ccb58ab8b97d2581cc763f2306", "patch": "@@ -26,7 +26,50 @@\n // Reexport some of our utilities which are expected by other crates.\n pub use panicking::{begin_panic, begin_panic_fmt, update_panic_count};\n \n-#[cfg(not(test))]\n+#[cfg(not(any(test, stage0)))]\n+#[lang = \"start\"]\n+fn lang_start<T: ::termination::Termination + 'static>\n+    (main: fn() -> T, argc: isize, argv: *const *const u8) -> !\n+{\n+    use panic;\n+    use sys;\n+    use sys_common;\n+    use sys_common::thread_info;\n+    use thread::Thread;\n+    use process;\n+    #[cfg(not(feature = \"backtrace\"))]\n+    use mem;\n+\n+    sys::init();\n+\n+    process::exit(unsafe {\n+        let main_guard = sys::thread::guard::init();\n+        sys::stack_overflow::init();\n+\n+        // Next, set up the current Thread with the guard information we just\n+        // created. Note that this isn't necessary in general for new threads,\n+        // but we just do this to name the main thread and to give it correct\n+        // info about the stack bounds.\n+        let thread = Thread::new(Some(\"main\".to_owned()));\n+        thread_info::set(main_guard, thread);\n+\n+        // Store our args if necessary in a squirreled away location\n+        sys::args::init(argc, argv);\n+\n+        // Let's run some code!\n+        #[cfg(feature = \"backtrace\")]\n+        let exit_code = panic::catch_unwind(|| {\n+            ::sys_common::backtrace::__rust_begin_short_backtrace(move || main().report())\n+        });\n+        #[cfg(not(feature = \"backtrace\"))]\n+        let exit_code = panic::catch_unwind(mem::transmute::<_, fn()>(main).report());\n+\n+        sys_common::cleanup();\n+        exit_code.unwrap_or(101)\n+    });\n+}\n+\n+#[cfg(all(not(test), stage0))]\n #[lang = \"start\"]\n fn lang_start(main: fn(), argc: isize, argv: *const *const u8) -> isize {\n     use panic;"}, {"sha": "a08d3dd2d52bc85d5b8f7c55d864ce2ed2221c5e", "filename": "src/libstd/termination.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Flibstd%2Ftermination.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Flibstd%2Ftermination.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftermination.rs?ref=d7918fb2e889c5ccb58ab8b97d2581cc763f2306", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use error::Error;\n+use libc;\n+\n+/// A trait for implementing arbitrary return types in the `main` function.\n+///\n+/// The c-main function only supports to return integers as return type.\n+/// So, every type implementing the `Termination` trait has to be converted\n+/// to an integer.\n+///\n+/// The default implementations are returning `libc::EXIT_SUCCESS` to indicate\n+/// a successful execution. In case of a failure, `libc::EXIT_FAILURE` is returned.\n+#[cfg_attr(not(stage0), lang = \"termination\")]\n+#[unstable(feature = \"termination_trait\", issue = \"0\")]\n+pub trait Termination {\n+    /// Is called to get the representation of the value as status code.\n+    /// This status code is returned to the operating system.\n+    fn report(self) -> i32;\n+}\n+\n+#[unstable(feature = \"termination_trait\", issue = \"0\")]\n+impl Termination for () {\n+    fn report(self) -> i32 { libc::EXIT_SUCCESS }\n+}\n+\n+#[unstable(feature = \"termination_trait\", issue = \"0\")]\n+impl<T: Termination, E: Error> Termination for Result<T, E> {\n+    fn report(self) -> i32 {\n+        match self {\n+            Ok(val) => val.report(),\n+            Err(err) => {\n+                print_error(err);\n+                libc::EXIT_FAILURE\n+            }\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"termination_trait\", issue = \"0\")]\n+fn print_error<E: Error>(err: E) {\n+    eprintln!(\"Error: {}\", err.description());\n+\n+    if let Some(ref err) = err.cause() {\n+        eprintln!(\"Caused by: {}\", err.description());\n+    }\n+}\n+\n+#[unstable(feature = \"termination_trait\", issue = \"0\")]\n+impl Termination for ! {\n+    fn report(self) -> i32 { unreachable!(); }\n+}\n+\n+#[unstable(feature = \"termination_trait\", issue = \"0\")]\n+impl Termination for bool {\n+    fn report(self) -> i32 {\n+        if self { libc::EXIT_SUCCESS } else { libc::EXIT_FAILURE }\n+    }\n+}\n+\n+#[unstable(feature = \"termination_trait\", issue = \"0\")]\n+impl Termination for i32 {\n+    fn report(self) -> i32 {\n+        self\n+    }\n+}"}, {"sha": "178a9b8cf5918b470e08146bf46f6c7b181a200f", "filename": "src/test/compile-fail/termination-trait-not-satisfied.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Ftest%2Fcompile-fail%2Ftermination-trait-not-satisfied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Ftest%2Fcompile-fail%2Ftermination-trait-not-satisfied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftermination-trait-not-satisfied.rs?ref=d7918fb2e889c5ccb58ab8b97d2581cc763f2306", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct ReturnType {}\n+\n+fn main() -> ReturnType { //~ ERROR `ReturnType: std::Termination` is not satisfied\n+    ReturnType {}\n+}"}, {"sha": "5e534da012875f934d609642bc96780d37efb425", "filename": "src/test/run-pass/termination-trait-for-empty.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Ftest%2Frun-pass%2Ftermination-trait-for-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Ftest%2Frun-pass%2Ftermination-trait-for-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftermination-trait-for-empty.rs?ref=d7918fb2e889c5ccb58ab8b97d2581cc763f2306", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(termination_trait)]\n+\n+fn main() {}"}, {"sha": "fa7cb023b447c171431642072eb2160b59185b72", "filename": "src/test/run-pass/termination-trait-for-i32.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Ftest%2Frun-pass%2Ftermination-trait-for-i32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Ftest%2Frun-pass%2Ftermination-trait-for-i32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftermination-trait-for-i32.rs?ref=d7918fb2e889c5ccb58ab8b97d2581cc763f2306", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(termination_trait)]\n+\n+fn main() -> i32 {\n+    0\n+}"}, {"sha": "751db0fb50082a8635f5135399efb87994e73ac9", "filename": "src/test/run-pass/termination-trait-for-result.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Ftest%2Frun-pass%2Ftermination-trait-for-result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7918fb2e889c5ccb58ab8b97d2581cc763f2306/src%2Ftest%2Frun-pass%2Ftermination-trait-for-result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftermination-trait-for-result.rs?ref=d7918fb2e889c5ccb58ab8b97d2581cc763f2306", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(termination_trait)]\n+\n+use std::io::Error;\n+\n+fn main() -> Result<(), Error> {\n+    Ok(())\n+}"}]}