{"sha": "1cde354c35f425026184b8d72f4f5865e96975d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjZGUzNTRjMzVmNDI1MDI2MTg0YjhkNzJmNGY1ODY1ZTk2OTc1ZDQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-29T13:28:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-29T13:28:57Z"}, "message": "Merge #4119\n\n4119: Cache proc-macro dlls r=matklad a=edwin0cheng\n\nThis PR try to fix a deadlock in proc-macro srv by not unloading dlls.\r\n\r\nCurrently we load and unload dlls for each request, however rustc TLS is leaky , such that if we do it a lot of times, all TLS index will be consumed and it will be deadlocked inside panic (it is because panic itself is using TLS too).\r\n\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "11fa53f91ff2bf598f8ba726d130708bf7b3bad2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11fa53f91ff2bf598f8ba726d130708bf7b3bad2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cde354c35f425026184b8d72f4f5865e96975d4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeqYEZCRBK7hj4Ov3rIwAAdHIIAIRweOPMZkL2r4Gr7spuPxKE\n91SKN/FsnfUPHnDr2rtQagiIHVFwvJWV+umDTeucatFf4b2z/IhreGj4A07kg+L6\nZTZL0/lP9qM6weyxlGsSqsj745EQ2TGNPEp6TGgznLDoYALNNK77WpmPGzmjfrye\nzXUb2Tw/OIchWl/PETCB0r+tLLiBdLbxr4ttZgpCgOCBLdfdaWj5e7ledP4Dvr5i\nDllXVA+x4DiEuHdnDbJjbPQD58M9fkSvXP99TdybxkDwfu9TFU/NxkGt0nN3kfCn\nu840nGEiPoXScGev71So7u7cQ6oHIeE02WgaSAmu4+2Ls8ACUNxPX8zX/p7GqJM=\n=jixo\n-----END PGP SIGNATURE-----\n", "payload": "tree 11fa53f91ff2bf598f8ba726d130708bf7b3bad2\nparent 12aae7771dc220a62d1323ac6a30ddf215fe2b92\nparent bfce6573772ebb91a9b1054864c0f53669ceee2f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1588166937 +0000\ncommitter GitHub <noreply@github.com> 1588166937 +0000\n\nMerge #4119\n\n4119: Cache proc-macro dlls r=matklad a=edwin0cheng\n\nThis PR try to fix a deadlock in proc-macro srv by not unloading dlls.\r\n\r\nCurrently we load and unload dlls for each request, however rustc TLS is leaky , such that if we do it a lot of times, all TLS index will be consumed and it will be deadlocked inside panic (it is because panic itself is using TLS too).\r\n\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cde354c35f425026184b8d72f4f5865e96975d4", "html_url": "https://github.com/rust-lang/rust/commit/1cde354c35f425026184b8d72f4f5865e96975d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cde354c35f425026184b8d72f4f5865e96975d4/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12aae7771dc220a62d1323ac6a30ddf215fe2b92", "url": "https://api.github.com/repos/rust-lang/rust/commits/12aae7771dc220a62d1323ac6a30ddf215fe2b92", "html_url": "https://github.com/rust-lang/rust/commit/12aae7771dc220a62d1323ac6a30ddf215fe2b92"}, {"sha": "bfce6573772ebb91a9b1054864c0f53669ceee2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfce6573772ebb91a9b1054864c0f53669ceee2f", "html_url": "https://github.com/rust-lang/rust/commit/bfce6573772ebb91a9b1054864c0f53669ceee2f"}], "stats": {"total": 175, "additions": 110, "deletions": 65}, "files": [{"sha": "1437794c9e23a3030a97bda224f6dc9cadaf8437", "filename": "crates/ra_proc_macro_srv/src/cli.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1cde354c35f425026184b8d72f4f5865e96975d4/crates%2Fra_proc_macro_srv%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cde354c35f425026184b8d72f4f5865e96975d4/crates%2Fra_proc_macro_srv%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fcli.rs?ref=1cde354c35f425026184b8d72f4f5865e96975d4", "patch": "@@ -1,15 +1,17 @@\n //! Driver for proc macro server\n \n-use crate::{expand_task, list_macros};\n+use crate::ProcMacroSrv;\n use ra_proc_macro::msg::{self, Message};\n use std::io;\n \n pub fn run() -> io::Result<()> {\n+    let mut srv = ProcMacroSrv::default();\n+\n     while let Some(req) = read_request()? {\n         let res = match req {\n-            msg::Request::ListMacro(task) => Ok(msg::Response::ListMacro(list_macros(&task))),\n+            msg::Request::ListMacro(task) => srv.list_macros(&task).map(msg::Response::ListMacro),\n             msg::Request::ExpansionMacro(task) => {\n-                expand_task(&task).map(msg::Response::ExpansionMacro)\n+                srv.expand(&task).map(msg::Response::ExpansionMacro)\n             }\n         };\n "}, {"sha": "aa84e951cd5601636490c9ffe2f0638a7c2ade1c", "filename": "crates/ra_proc_macro_srv/src/dylib.rs", "status": "modified", "additions": 69, "deletions": 44, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/1cde354c35f425026184b8d72f4f5865e96975d4/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cde354c35f425026184b8d72f4f5865e96975d4/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs?ref=1cde354c35f425026184b8d72f4f5865e96975d4", "patch": "@@ -2,13 +2,12 @@\n \n use crate::{proc_macro::bridge, rustc_server::TokenStream};\n use std::fs::File;\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n \n use goblin::{mach::Mach, Object};\n use libloading::Library;\n use memmap::Mmap;\n use ra_proc_macro::ProcMacroKind;\n-\n use std::io;\n \n const NEW_REGISTRAR_SYMBOL: &str = \"_rustc_proc_macro_decls_\";\n@@ -109,23 +108,21 @@ impl ProcMacroLibraryLibloading {\n     }\n }\n \n-type ProcMacroLibraryImpl = ProcMacroLibraryLibloading;\n-\n pub struct Expander {\n-    libs: Vec<ProcMacroLibraryImpl>,\n+    inner: ProcMacroLibraryLibloading,\n }\n \n impl Expander {\n-    pub fn new(lib: &Path) -> Result<Expander, String> {\n+    pub fn new(lib: &Path) -> io::Result<Expander> {\n         // Some libraries for dynamic loading require canonicalized path even when it is\n         // already absolute\n-        let lib = lib\n-            .canonicalize()\n-            .unwrap_or_else(|err| panic!(\"Cannot canonicalize {}: {:?}\", lib.display(), err));\n+        let lib = lib.canonicalize()?;\n+\n+        let lib = ensure_file_with_lock_free_access(&lib)?;\n \n-        let library = ProcMacroLibraryImpl::open(&lib).map_err(|e| e.to_string())?;\n+        let library = ProcMacroLibraryLibloading::open(&lib)?;\n \n-        Ok(Expander { libs: vec![library] })\n+        Ok(Expander { inner: library })\n     }\n \n     pub fn expand(\n@@ -141,48 +138,46 @@ impl Expander {\n                 TokenStream::with_subtree(attr.clone())\n             });\n \n-        for lib in &self.libs {\n-            for proc_macro in &lib.exported_macros {\n-                match proc_macro {\n-                    bridge::client::ProcMacro::CustomDerive { trait_name, client, .. }\n-                        if *trait_name == macro_name =>\n-                    {\n-                        let res = client.run(\n-                            &crate::proc_macro::bridge::server::SameThread,\n-                            crate::rustc_server::Rustc::default(),\n-                            parsed_body,\n-                        );\n-                        return res.map(|it| it.subtree);\n-                    }\n-                    bridge::client::ProcMacro::Bang { name, client } if *name == macro_name => {\n-                        let res = client.run(\n-                            &crate::proc_macro::bridge::server::SameThread,\n-                            crate::rustc_server::Rustc::default(),\n-                            parsed_body,\n-                        );\n-                        return res.map(|it| it.subtree);\n-                    }\n-                    bridge::client::ProcMacro::Attr { name, client } if *name == macro_name => {\n-                        let res = client.run(\n-                            &crate::proc_macro::bridge::server::SameThread,\n-                            crate::rustc_server::Rustc::default(),\n-                            parsed_attributes,\n-                            parsed_body,\n-                        );\n-                        return res.map(|it| it.subtree);\n-                    }\n-                    _ => continue,\n+        for proc_macro in &self.inner.exported_macros {\n+            match proc_macro {\n+                bridge::client::ProcMacro::CustomDerive { trait_name, client, .. }\n+                    if *trait_name == macro_name =>\n+                {\n+                    let res = client.run(\n+                        &crate::proc_macro::bridge::server::SameThread,\n+                        crate::rustc_server::Rustc::default(),\n+                        parsed_body,\n+                    );\n+                    return res.map(|it| it.subtree);\n+                }\n+                bridge::client::ProcMacro::Bang { name, client } if *name == macro_name => {\n+                    let res = client.run(\n+                        &crate::proc_macro::bridge::server::SameThread,\n+                        crate::rustc_server::Rustc::default(),\n+                        parsed_body,\n+                    );\n+                    return res.map(|it| it.subtree);\n+                }\n+                bridge::client::ProcMacro::Attr { name, client } if *name == macro_name => {\n+                    let res = client.run(\n+                        &crate::proc_macro::bridge::server::SameThread,\n+                        crate::rustc_server::Rustc::default(),\n+                        parsed_attributes,\n+                        parsed_body,\n+                    );\n+                    return res.map(|it| it.subtree);\n                 }\n+                _ => continue,\n             }\n         }\n \n         Err(bridge::PanicMessage::String(\"Nothing to expand\".to_string()))\n     }\n \n     pub fn list_macros(&self) -> Vec<(String, ProcMacroKind)> {\n-        self.libs\n+        self.inner\n+            .exported_macros\n             .iter()\n-            .flat_map(|it| &it.exported_macros)\n             .map(|proc_macro| match proc_macro {\n                 bridge::client::ProcMacro::CustomDerive { trait_name, .. } => {\n                     (trait_name.to_string(), ProcMacroKind::CustomDerive)\n@@ -197,3 +192,33 @@ impl Expander {\n             .collect()\n     }\n }\n+\n+/// Copy the dylib to temp directory to prevent locking in Windows\n+#[cfg(windows)]\n+fn ensure_file_with_lock_free_access(path: &Path) -> io::Result<PathBuf> {\n+    use std::{ffi::OsString, time::SystemTime};\n+\n+    let mut to = std::env::temp_dir();\n+\n+    let file_name = path.file_name().ok_or_else(|| {\n+        io::Error::new(\n+            io::ErrorKind::InvalidInput,\n+            format!(\"File path is invalid: {}\", path.display()),\n+        )\n+    })?;\n+\n+    // generate a time deps unique number\n+    let t = SystemTime::now().duration_since(std::time::UNIX_EPOCH).expect(\"Time went backwards\");\n+\n+    let mut unique_name = OsString::from(t.as_millis().to_string());\n+    unique_name.push(file_name);\n+\n+    to.push(unique_name);\n+    std::fs::copy(path, &to).unwrap();\n+    Ok(to)\n+}\n+\n+#[cfg(unix)]\n+fn ensure_file_with_lock_free_access(path: &Path) -> io::Result<PathBuf> {\n+    Ok(path.to_path_buf())\n+}"}, {"sha": "922bb84bbfcda92336fcc3f9b35536900547159b", "filename": "crates/ra_proc_macro_srv/src/lib.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1cde354c35f425026184b8d72f4f5865e96975d4/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cde354c35f425026184b8d72f4f5865e96975d4/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs?ref=1cde354c35f425026184b8d72f4f5865e96975d4", "patch": "@@ -21,28 +21,46 @@ mod dylib;\n \n use proc_macro::bridge::client::TokenStream;\n use ra_proc_macro::{ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTask};\n-use std::path::Path;\n+use std::{\n+    collections::{hash_map::Entry, HashMap},\n+    fs,\n+    path::{Path, PathBuf},\n+    time::SystemTime,\n+};\n \n-pub(crate) fn expand_task(task: &ExpansionTask) -> Result<ExpansionResult, String> {\n-    let expander = create_expander(&task.lib);\n+#[derive(Default)]\n+pub(crate) struct ProcMacroSrv {\n+    expanders: HashMap<(PathBuf, SystemTime), dylib::Expander>,\n+}\n \n-    match expander.expand(&task.macro_name, &task.macro_body, task.attributes.as_ref()) {\n-        Ok(expansion) => Ok(ExpansionResult { expansion }),\n-        Err(msg) => {\n-            Err(format!(\"Cannot perform expansion for {}: error {:?}\", &task.macro_name, msg))\n+impl ProcMacroSrv {\n+    pub fn expand(&mut self, task: &ExpansionTask) -> Result<ExpansionResult, String> {\n+        let expander = self.expander(&task.lib)?;\n+        match expander.expand(&task.macro_name, &task.macro_body, task.attributes.as_ref()) {\n+            Ok(expansion) => Ok(ExpansionResult { expansion }),\n+            Err(msg) => {\n+                Err(format!(\"Cannot perform expansion for {}: error {:?}\", &task.macro_name, msg))\n+            }\n         }\n     }\n-}\n \n-pub(crate) fn list_macros(task: &ListMacrosTask) -> ListMacrosResult {\n-    let expander = create_expander(&task.lib);\n+    pub fn list_macros(&mut self, task: &ListMacrosTask) -> Result<ListMacrosResult, String> {\n+        let expander = self.expander(&task.lib)?;\n+        Ok(ListMacrosResult { macros: expander.list_macros() })\n+    }\n \n-    ListMacrosResult { macros: expander.list_macros() }\n-}\n+    fn expander(&mut self, path: &Path) -> Result<&dylib::Expander, String> {\n+        let time = fs::metadata(path).and_then(|it| it.modified()).map_err(|err| {\n+            format!(\"Failed to get file metadata for {}: {:?}\", path.display(), err)\n+        })?;\n \n-fn create_expander(lib: &Path) -> dylib::Expander {\n-    dylib::Expander::new(lib)\n-        .unwrap_or_else(|err| panic!(\"Cannot create expander for {}: {:?}\", lib.display(), err))\n+        Ok(match self.expanders.entry((path.to_path_buf(), time)) {\n+            Entry::Vacant(v) => v.insert(dylib::Expander::new(path).map_err(|err| {\n+                format!(\"Cannot create expander for {}: {:?}\", path.display(), err)\n+            })?),\n+            Entry::Occupied(e) => e.into_mut(),\n+        })\n+    }\n }\n \n pub mod cli;"}, {"sha": "646a427c5653546f4638b319c681509a11cc16eb", "filename": "crates/ra_proc_macro_srv/src/tests/utils.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1cde354c35f425026184b8d72f4f5865e96975d4/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cde354c35f425026184b8d72f4f5865e96975d4/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs?ref=1cde354c35f425026184b8d72f4f5865e96975d4", "patch": "@@ -1,7 +1,7 @@\n //! utils used in proc-macro tests\n \n use crate::dylib;\n-use crate::list_macros;\n+use crate::ProcMacroSrv;\n pub use difference::Changeset as __Changeset;\n use ra_proc_macro::ListMacrosTask;\n use std::str::FromStr;\n@@ -59,7 +59,7 @@ pub fn assert_expand(\n pub fn list(crate_name: &str, version: &str) -> Vec<String> {\n     let path = fixtures::dylib_path(crate_name, version);\n     let task = ListMacrosTask { lib: path };\n-\n-    let res = list_macros(&task);\n+    let mut srv = ProcMacroSrv::default();\n+    let res = srv.list_macros(&task).unwrap();\n     res.macros.into_iter().map(|(name, kind)| format!(\"{} [{:?}]\", name, kind)).collect()\n }"}]}