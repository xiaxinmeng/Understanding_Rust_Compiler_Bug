{"sha": "97f3d21c6459c2d56a029ad2468cc9c49dbbd8df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3ZjNkMjFjNjQ1OWMyZDU2YTAyOWFkMjQ2OGNjOWM0OWRiYmQ4ZGY=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-07-26T11:14:12Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-07-26T11:15:31Z"}, "message": "Issue #51348: lower `match` so an ident gets a distinct temp *for each* candidate pat.\n\nThis required a bit of plumbing to keep track of candidates. But I\ntook advantage of the hack session to try to improve the docs for the\nrelevant structs here.\n\n(I also tried to simplify some of the related code in passing.)", "tree": {"sha": "521baa83d95ea05af9edf3fa179fec8601fcafdf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/521baa83d95ea05af9edf3fa179fec8601fcafdf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97f3d21c6459c2d56a029ad2468cc9c49dbbd8df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97f3d21c6459c2d56a029ad2468cc9c49dbbd8df", "html_url": "https://github.com/rust-lang/rust/commit/97f3d21c6459c2d56a029ad2468cc9c49dbbd8df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97f3d21c6459c2d56a029ad2468cc9c49dbbd8df/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c636ded2c759be0dc8fdb9143e06e420ef03ace3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c636ded2c759be0dc8fdb9143e06e420ef03ace3", "html_url": "https://github.com/rust-lang/rust/commit/c636ded2c759be0dc8fdb9143e06e420ef03ace3"}], "stats": {"total": 129, "additions": 92, "deletions": 37}, "files": [{"sha": "954f9051440cb5eadde8fcf752afae3e793c2190", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/97f3d21c6459c2d56a029ad2468cc9c49dbbd8df/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f3d21c6459c2d56a029ad2468cc9c49dbbd8df/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=97f3d21c6459c2d56a029ad2468cc9c49dbbd8df", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             None,\n                             remainder_span,\n                             lint_level,\n-                            &pattern,\n+                            &[pattern.clone()],\n                             ArmHasGuard(false),\n                             Some((None, initializer_span)),\n                         );\n@@ -138,8 +138,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                 })\n                             }));\n                     } else {\n-                        scope = this.declare_bindings(None, remainder_span, lint_level, &pattern,\n-                                                        ArmHasGuard(false), None);\n+                        scope = this.declare_bindings(\n+                            None, remainder_span, lint_level, &[pattern.clone()],\n+                            ArmHasGuard(false), None);\n \n                         // FIXME(#47184): We currently only insert `UserAssertTy` statements for\n                         // patterns that are bindings, this is as we do not want to deconstruct"}, {"sha": "a38ca7ae5bf64953574c0659126fc4e1ef2fbfd0", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/97f3d21c6459c2d56a029ad2468cc9c49dbbd8df/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f3d21c6459c2d56a029ad2468cc9c49dbbd8df/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=97f3d21c6459c2d56a029ad2468cc9c49dbbd8df", "patch": "@@ -11,7 +11,7 @@\n //! See docs in build/expr/mod.rs\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n-use build::ForGuard::{OutsideGuard, RefWithinGuard, ValWithinGuard};\n+use build::ForGuard::{OutsideGuard, RefWithinGuard};\n use build::expr::category::Category;\n use hair::*;\n use rustc::mir::*;\n@@ -87,14 +87,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block.and(Place::Local(Local::new(1)))\n             }\n             ExprKind::VarRef { id } => {\n-                let place = if this.is_bound_var_in_guard(id) {\n-                    if this.hir.tcx().all_pat_vars_are_implicit_refs_within_guards() {\n-                        let index = this.var_local_id(id, RefWithinGuard);\n-                        Place::Local(index).deref()\n-                    } else {\n-                        let index = this.var_local_id(id, ValWithinGuard);\n-                        Place::Local(index)\n-                    }\n+                let place = if this.is_bound_var_in_guard(id) &&\n+                    this.hir.tcx().all_pat_vars_are_implicit_refs_within_guards()\n+                {\n+                    let index = this.var_local_id(id, RefWithinGuard);\n+                    Place::Local(index).deref()\n                 } else {\n                     let index = this.var_local_id(id, OutsideGuard);\n                     Place::Local(index)"}, {"sha": "962903f165576967ab38545b964e1569954d1dff", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 44, "deletions": 18, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/97f3d21c6459c2d56a029ad2468cc9c49dbbd8df/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f3d21c6459c2d56a029ad2468cc9c49dbbd8df/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=97f3d21c6459c2d56a029ad2468cc9c49dbbd8df", "patch": "@@ -97,7 +97,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let body = self.hir.mirror(arm.body.clone());\n             let scope = self.declare_bindings(None, body.span,\n                                               LintLevel::Inherited,\n-                                              &arm.patterns[0],\n+                                              &arm.patterns[..],\n                                               ArmHasGuard(arm.guard.is_some()),\n                                               Some((Some(&discriminant_place), discriminant_span)));\n             (body, scope.unwrap_or(self.source_scope))\n@@ -118,11 +118,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             arms.iter()\n                 .enumerate()\n                 .flat_map(|(arm_index, arm)| {\n-                    arm.patterns.iter()\n-                                .map(move |pat| (arm_index, pat, arm.guard.clone()))\n+                    arm.patterns.iter().enumerate()\n+                        .map(move |(pat_index, pat)| {\n+                            (arm_index, pat_index, pat, arm.guard.clone())\n+                        })\n                 })\n                 .zip(pre_binding_blocks.iter().zip(pre_binding_blocks.iter().skip(1)))\n-                .map(|((arm_index, pattern, guard),\n+                .map(|((arm_index, pat_index, pattern, guard),\n                        (pre_binding_block, next_candidate_pre_binding_block))| {\n \n                     if let (true, Some(borrow_temp)) = (tcx.emit_read_for_match(),\n@@ -168,6 +170,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         bindings: vec![],\n                         guard,\n                         arm_index,\n+                        pat_index,\n                         pre_binding_block: *pre_binding_block,\n                         next_candidate_pre_binding_block: *next_candidate_pre_binding_block,\n                     }\n@@ -277,6 +280,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             // since we don't call `match_candidates`, next fields is unused\n             arm_index: 0,\n+            pat_index: 0,\n             pre_binding_block: block,\n             next_candidate_pre_binding_block: block\n         };\n@@ -324,14 +328,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             mut visibility_scope: Option<SourceScope>,\n                             scope_span: Span,\n                             lint_level: LintLevel,\n-                            pattern: &Pattern<'tcx>,\n+                            patterns: &[Pattern<'tcx>],\n                             has_guard: ArmHasGuard,\n                             opt_match_place: Option<(Option<&Place<'tcx>>, Span)>)\n                             -> Option<SourceScope> {\n         assert!(!(visibility_scope.is_some() && lint_level.is_explicit()),\n                 \"can't have both a visibility and a lint scope at the same time\");\n         let mut scope = self.source_scope;\n-        self.visit_bindings(pattern, &mut |this, mutability, name, mode, var, span, ty| {\n+        let num_patterns = patterns.len();\n+        self.visit_bindings(&patterns[0], &mut |this, mutability, name, mode, var, span, ty| {\n             if visibility_scope.is_none() {\n                 visibility_scope = Some(this.new_source_scope(scope_span,\n                                                            LintLevel::Inherited,\n@@ -349,8 +354,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 scope,\n             };\n             let visibility_scope = visibility_scope.unwrap();\n-            this.declare_binding(source_info, visibility_scope, mutability, name, mode, var,\n-                                 ty, has_guard, opt_match_place.map(|(x, y)| (x.cloned(), y)));\n+            this.declare_binding(source_info, visibility_scope, mutability, name, mode,\n+                                 num_patterns, var, ty, has_guard,\n+                                 opt_match_place.map(|(x, y)| (x.cloned(), y)));\n         });\n         visibility_scope\n     }\n@@ -453,6 +459,9 @@ pub struct Candidate<'pat, 'tcx:'pat> {\n     // ...and the blocks for add false edges between candidates\n     pre_binding_block: BasicBlock,\n     next_candidate_pre_binding_block: BasicBlock,\n+\n+    // This uniquely identifies this candidate *within* the arm.\n+    pat_index: usize,\n }\n \n #[derive(Clone, Debug)]\n@@ -972,7 +981,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let autoref = self.hir.tcx().all_pat_vars_are_implicit_refs_within_guards();\n         if let Some(guard) = candidate.guard {\n             if autoref {\n-                self.bind_matched_candidate_for_guard(block, &candidate.bindings);\n+                self.bind_matched_candidate_for_guard(\n+                    block, candidate.pat_index, &candidate.bindings);\n                 let guard_frame = GuardFrame {\n                     locals: candidate.bindings.iter()\n                         .map(|b| GuardFrameLocal::new(b.var_id, b.binding_mode))\n@@ -1058,9 +1068,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     // and thus all code/comments assume we are in that context.\n     fn bind_matched_candidate_for_guard(&mut self,\n                                         block: BasicBlock,\n+                                        pat_index: usize,\n                                         bindings: &[Binding<'tcx>]) {\n-        debug!(\"bind_matched_candidate_for_guard(block={:?}, bindings={:?})\",\n-               block, bindings);\n+        debug!(\"bind_matched_candidate_for_guard(block={:?}, pat_index={:?}, bindings={:?})\",\n+               block, pat_index, bindings);\n \n         // Assign each of the bindings. Since we are binding for a\n         // guard expression, this will never trigger moves out of the\n@@ -1099,8 +1110,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // used by the arm body itself. This eases\n                     // observing two-phase borrow restrictions.\n                     let val_for_guard = self.storage_live_binding(\n-                        block, binding.var_id, binding.span, ValWithinGuard);\n-                    self.schedule_drop_for_binding(binding.var_id, binding.span, ValWithinGuard);\n+                        block, binding.var_id, binding.span, ValWithinGuard(pat_index));\n+                    self.schedule_drop_for_binding(\n+                        binding.var_id, binding.span, ValWithinGuard(pat_index));\n \n                     // rust-lang/rust#27282: We reuse the two-phase\n                     // borrow infrastructure so that the mutable\n@@ -1146,16 +1158,26 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     /// Each binding (`ref mut var`/`ref var`/`mut var`/`var`, where\n     /// the bound `var` has type `T` in the arm body) in a pattern\n-    /// maps to *two* locals. The first local is a binding for\n+    /// maps to `2+N` locals. The first local is a binding for\n     /// occurrences of `var` in the guard, which will all have type\n-    /// `&T`. The second local is a binding for occurrences of `var`\n-    /// in the arm body, which will have type `T`.\n+    /// `&T`. The N locals are bindings for the `T` that is referenced\n+    /// by the first local; they are not used outside of the\n+    /// guard. The last local is a binding for occurrences of `var` in\n+    /// the arm body, which will have type `T`.\n+    ///\n+    /// The reason we have N locals rather than just 1 is to\n+    /// accommodate rust-lang/rust#51348: If the arm has N candidate\n+    /// patterns, then in general they can correspond to distinct\n+    /// parts of the matched data, and we want them to be distinct\n+    /// temps in order to simplify checks performed by our internal\n+    /// leveraging of two-phase borrows).\n     fn declare_binding(&mut self,\n                        source_info: SourceInfo,\n                        visibility_scope: SourceScope,\n                        mutability: Mutability,\n                        name: Name,\n                        mode: BindingMode,\n+                       num_patterns: usize,\n                        var_id: NodeId,\n                        var_ty: Ty<'tcx>,\n                        has_guard: ArmHasGuard,\n@@ -1189,7 +1211,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         };\n         let for_arm_body = self.local_decls.push(local.clone());\n         let locals = if has_guard.0 && tcx.all_pat_vars_are_implicit_refs_within_guards() {\n-            let val_for_guard =  self.local_decls.push(local);\n+            let mut vals_for_guard = Vec::with_capacity(num_patterns);\n+            for _ in 0..num_patterns {\n+                let val_for_guard_idx =  self.local_decls.push(local.clone());\n+                vals_for_guard.push(val_for_guard_idx);\n+            }\n             let ref_for_guard = self.local_decls.push(LocalDecl::<'tcx> {\n                 mutability,\n                 ty: tcx.mk_imm_ref(tcx.types.re_empty, var_ty),\n@@ -1200,7 +1226,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 internal: false,\n                 is_user_variable: Some(ClearCrossCrate::Set(BindingForm::RefForGuard)),\n             });\n-            LocalsForNode::Three { val_for_guard, ref_for_guard, for_arm_body }\n+            LocalsForNode::ForGuard { vals_for_guard, ref_for_guard, for_arm_body }\n         } else {\n             LocalsForNode::One(for_arm_body)\n         };"}, {"sha": "52eafad43b3a249d6916e6ba4876025e07b58c0c", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97f3d21c6459c2d56a029ad2468cc9c49dbbd8df/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f3d21c6459c2d56a029ad2468cc9c49dbbd8df/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=97f3d21c6459c2d56a029ad2468cc9c49dbbd8df", "patch": "@@ -631,6 +631,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             bindings: candidate.bindings.clone(),\n             guard: candidate.guard.clone(),\n             arm_index: candidate.arm_index,\n+            pat_index: candidate.pat_index,\n             pre_binding_block: candidate.pre_binding_block,\n             next_candidate_pre_binding_block: candidate.next_candidate_pre_binding_block,\n         }\n@@ -694,6 +695,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             bindings: candidate.bindings.clone(),\n             guard: candidate.guard.clone(),\n             arm_index: candidate.arm_index,\n+            pat_index: candidate.pat_index,\n             pre_binding_block: candidate.pre_binding_block,\n             next_candidate_pre_binding_block: candidate.next_candidate_pre_binding_block,\n         }"}, {"sha": "054bd69c361b92115eb6c60dd32e67ec3cccbcd4", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 36, "deletions": 7, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/97f3d21c6459c2d56a029ad2468cc9c49dbbd8df/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f3d21c6459c2d56a029ad2468cc9c49dbbd8df/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=97f3d21c6459c2d56a029ad2468cc9c49dbbd8df", "patch": "@@ -310,8 +310,31 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n #[derive(Debug)]\n enum LocalsForNode {\n+    /// In the usual case, a node-id for an identifier maps to at most\n+    /// one Local declaration.\n     One(Local),\n-    Three { val_for_guard: Local, ref_for_guard: Local, for_arm_body: Local },\n+\n+    /// The exceptional case is identifiers in a match arm's pattern\n+    /// that are referenced in a guard of that match arm. For these,\n+    /// we can have `2+k` Locals, where `k` is the number of candidate\n+    /// patterns (separated by `|`) in the arm.\n+    ///\n+    /// * `for_arm_body` is the Local used in the arm body (which is\n+    ///   just like the `One` case above),\n+    ///\n+    /// * `ref_for_guard` is the Local used in the arm's guard (which\n+    ///   is a reference to a temp that is an alias of\n+    ///   `for_arm_body`).\n+    ///\n+    /// * `vals_for_guard` is the `k` Locals; at most one of them will\n+    ///   get initialized by the arm's execution, and after it is\n+    ///   initialized, `ref_for_guard` will be assigned a reference to\n+    ///   it.\n+    ///\n+    /// There reason we have `k` Locals rather than just 1 is to\n+    /// accommodate some restrictions imposed by two-phase borrows,\n+    /// which apply when we have a `ref mut` pattern.\n+    ForGuard { vals_for_guard: Vec<Local>, ref_for_guard: Local, for_arm_body: Local },\n }\n \n #[derive(Debug)]\n@@ -350,7 +373,10 @@ struct GuardFrame {\n ///   3. the temp for use outside of guard expressions.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum ForGuard {\n-    ValWithinGuard,\n+    /// The `usize` identifies for which candidate pattern we want the\n+    /// local binding. We keep a temp per-candidate to accommodate\n+    /// two-phase borrows (see `LocalsForNode` documentation).\n+    ValWithinGuard(usize),\n     RefWithinGuard,\n     OutsideGuard,\n }\n@@ -359,12 +385,15 @@ impl LocalsForNode {\n     fn local_id(&self, for_guard: ForGuard) -> Local {\n         match (self, for_guard) {\n             (&LocalsForNode::One(local_id), ForGuard::OutsideGuard) |\n-            (&LocalsForNode::Three { val_for_guard: local_id, .. }, ForGuard::ValWithinGuard) |\n-            (&LocalsForNode::Three { ref_for_guard: local_id, .. }, ForGuard::RefWithinGuard) |\n-            (&LocalsForNode::Three { for_arm_body: local_id, .. }, ForGuard::OutsideGuard) =>\n+            (&LocalsForNode::ForGuard { ref_for_guard: local_id, .. }, ForGuard::RefWithinGuard) |\n+            (&LocalsForNode::ForGuard { for_arm_body: local_id, .. }, ForGuard::OutsideGuard) =>\n                 local_id,\n \n-            (&LocalsForNode::One(_), ForGuard::ValWithinGuard) |\n+            (&LocalsForNode::ForGuard { ref vals_for_guard, .. },\n+             ForGuard::ValWithinGuard(pat_idx)) =>\n+                vals_for_guard[pat_idx],\n+\n+            (&LocalsForNode::One(_), ForGuard::ValWithinGuard(_)) |\n             (&LocalsForNode::One(_), ForGuard::RefWithinGuard) =>\n                 bug!(\"anything with one local should never be within a guard.\"),\n         }\n@@ -740,7 +769,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     }\n                     _ => {\n                         scope = self.declare_bindings(scope, ast_body.span,\n-                                                      LintLevel::Inherited, &pattern,\n+                                                      LintLevel::Inherited, &[pattern.clone()],\n                                                       matches::ArmHasGuard(false),\n                                                       Some((Some(&place), span)));\n                         unpack!(block = self.place_into_pattern(block, pattern, &place, false));"}]}