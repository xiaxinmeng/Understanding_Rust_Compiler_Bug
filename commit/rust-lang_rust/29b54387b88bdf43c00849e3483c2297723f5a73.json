{"sha": "29b54387b88bdf43c00849e3483c2297723f5a73", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5YjU0Mzg3Yjg4YmRmNDNjMDA4NDllMzQ4M2MyMjk3NzIzZjVhNzM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-23T22:54:39Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-24T00:10:19Z"}, "message": "Test fixes and rebase conflicts, round 2", "tree": {"sha": "72d467004da043e823a94690e89e3a2afae8ba2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72d467004da043e823a94690e89e3a2afae8ba2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29b54387b88bdf43c00849e3483c2297723f5a73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29b54387b88bdf43c00849e3483c2297723f5a73", "html_url": "https://github.com/rust-lang/rust/commit/29b54387b88bdf43c00849e3483c2297723f5a73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29b54387b88bdf43c00849e3483c2297723f5a73/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3112716f123bc0f6f69c4df26894241f41c488ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/3112716f123bc0f6f69c4df26894241f41c488ce", "html_url": "https://github.com/rust-lang/rust/commit/3112716f123bc0f6f69c4df26894241f41c488ce"}], "stats": {"total": 328, "additions": 179, "deletions": 149}, "files": [{"sha": "54821e3ce304d5dfc05045c397e56260116bc416", "filename": "src/doc/trpl/documentation.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdocumentation.md?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -361,7 +361,8 @@ Here\u2019s an example of documenting a macro:\n #[macro_export]\n macro_rules! panic_unless {\n     ($condition:expr, $($rest:expr),+) => ({ if ! $condition { panic!($($rest),+); } });\n-} \n+}\n+# fn main() {}\n ```\n \n You\u2019ll note three things: we need to add our own `extern crate` line, so that"}, {"sha": "c9bbc0d74cddc8d745dedf6c2382767e0ceacbd8", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 42, "deletions": 34, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -128,8 +128,8 @@ unsafe impl<T: Sync + Send> Sync for Arc<T> { }\n \n /// A weak pointer to an `Arc`.\n ///\n-/// Weak pointers will not keep the data inside of the `Arc` alive, and can be used to break cycles\n-/// between `Arc` pointers.\n+/// Weak pointers will not keep the data inside of the `Arc` alive, and can be\n+/// used to break cycles between `Arc` pointers.\n #[unsafe_no_drop_flag]\n #[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n@@ -218,8 +218,8 @@ impl<T> Arc<T> {\n     unsafe fn drop_slow(&mut self) {\n         let ptr = *self._ptr;\n \n-        // Destroy the data at this time, even though we may not free the box allocation itself\n-        // (there may still be weak pointers lying around).\n+        // Destroy the data at this time, even though we may not free the box\n+        // allocation itself (there may still be weak pointers lying around).\n         drop(ptr::read(&self.inner().data));\n \n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n@@ -286,8 +286,8 @@ impl<T> Deref for Arc<T> {\n impl<T: Send + Sync + Clone> Arc<T> {\n     /// Make a mutable reference from the given `Arc<T>`.\n     ///\n-    /// This is also referred to as a copy-on-write operation because the inner data is cloned if\n-    /// the reference count is greater than one.\n+    /// This is also referred to as a copy-on-write operation because the inner\n+    /// data is cloned if the reference count is greater than one.\n     ///\n     /// # Examples\n     ///\n@@ -302,16 +302,18 @@ impl<T: Send + Sync + Clone> Arc<T> {\n     #[inline]\n     #[unstable(feature = \"alloc\")]\n     pub fn make_unique(&mut self) -> &mut T {\n-        // Note that we hold a strong reference, which also counts as a weak reference, so we only\n-        // clone if there is an additional reference of either kind.\n+        // Note that we hold a strong reference, which also counts as a weak\n+        // reference, so we only clone if there is an additional reference of\n+        // either kind.\n         if self.inner().strong.load(SeqCst) != 1 ||\n            self.inner().weak.load(SeqCst) != 1 {\n             *self = Arc::new((**self).clone())\n         }\n-        // This unsafety is ok because we're guaranteed that the pointer returned is the *only*\n-        // pointer that will ever be returned to T. Our reference count is guaranteed to be 1 at\n-        // this point, and we required the Arc itself to be `mut`, so we're returning the only\n-        // possible reference to the inner data.\n+        // This unsafety is ok because we're guaranteed that the pointer\n+        // returned is the *only* pointer that will ever be returned to T. Our\n+        // reference count is guaranteed to be 1 at this point, and we required\n+        // the Arc itself to be `mut`, so we're returning the only possible\n+        // reference to the inner data.\n         let inner = unsafe { &mut **self._ptr };\n         &mut inner.data\n     }\n@@ -322,8 +324,9 @@ impl<T: Send + Sync + Clone> Arc<T> {\n impl<T: Sync + Send> Drop for Arc<T> {\n     /// Drops the `Arc<T>`.\n     ///\n-    /// This will decrement the strong reference count. If the strong reference count becomes zero\n-    /// and the only other references are `Weak<T>` ones, `drop`s the inner value.\n+    /// This will decrement the strong reference count. If the strong reference\n+    /// count becomes zero and the only other references are `Weak<T>` ones,\n+    /// `drop`s the inner value.\n     ///\n     /// # Examples\n     ///\n@@ -347,29 +350,32 @@ impl<T: Sync + Send> Drop for Arc<T> {\n     /// ```\n     #[inline]\n     fn drop(&mut self) {\n-        // This structure has #[unsafe_no_drop_flag], so this drop glue may run more than once (but\n-        // it is guaranteed to be zeroed after the first if it's run more than once)\n+        // This structure has #[unsafe_no_drop_flag], so this drop glue may run\n+        // more than once (but it is guaranteed to be zeroed after the first if\n+        // it's run more than once)\n         let ptr = *self._ptr;\n         if ptr.is_null() { return }\n \n-        // Because `fetch_sub` is already atomic, we do not need to synchronize with other threads\n-        // unless we are going to delete the object. This same logic applies to the below\n-        // `fetch_sub` to the `weak` count.\n+        // Because `fetch_sub` is already atomic, we do not need to synchronize\n+        // with other threads unless we are going to delete the object. This\n+        // same logic applies to the below `fetch_sub` to the `weak` count.\n         if self.inner().strong.fetch_sub(1, Release) != 1 { return }\n \n-        // This fence is needed to prevent reordering of use of the data and deletion of the data.\n-        // Because it is marked `Release`, the decreasing of the reference count synchronizes with\n-        // this `Acquire` fence. This means that use of the data happens before decreasing the\n-        // reference count, which happens before this fence, which happens before the deletion of\n-        // the data.\n+        // This fence is needed to prevent reordering of use of the data and\n+        // deletion of the data.  Because it is marked `Release`, the decreasing\n+        // of the reference count synchronizes with this `Acquire` fence. This\n+        // means that use of the data happens before decreasing the reference\n+        // count, which happens before this fence, which happens before the\n+        // deletion of the data.\n         //\n         // As explained in the [Boost documentation][1],\n         //\n-        // > It is important to enforce any possible access to the object in one thread (through an\n-        // > existing reference) to *happen before* deleting the object in a different thread. This\n-        // > is achieved by a \"release\" operation after dropping a reference (any access to the\n-        // > object through this reference must obviously happened before), and an \"acquire\"\n-        // > operation before deleting the object.\n+        // > It is important to enforce any possible access to the object in one\n+        // > thread (through an existing reference) to *happen before* deleting\n+        // > the object in a different thread. This is achieved by a \"release\"\n+        // > operation after dropping a reference (any access to the object\n+        // > through this reference must obviously happened before), and an\n+        // > \"acquire\" operation before deleting the object.\n         //\n         // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n         atomic::fence(Acquire);\n@@ -387,7 +393,8 @@ impl<T: Sync + Send> Weak<T> {\n     ///\n     /// Upgrades the `Weak<T>` reference to an `Arc<T>`, if possible.\n     ///\n-    /// Returns `None` if there were no strong references and the data was destroyed.\n+    /// Returns `None` if there were no strong references and the data was\n+    /// destroyed.\n     ///\n     /// # Examples\n     ///\n@@ -402,8 +409,8 @@ impl<T: Sync + Send> Weak<T> {\n     /// let strong_five: Option<Arc<_>> = weak_five.upgrade();\n     /// ```\n     pub fn upgrade(&self) -> Option<Arc<T>> {\n-        // We use a CAS loop to increment the strong count instead of a fetch_add because once the\n-        // count hits 0 is must never be above 0.\n+        // We use a CAS loop to increment the strong count instead of a\n+        // fetch_add because once the count hits 0 is must never be above 0.\n         let inner = self.inner();\n         loop {\n             let n = inner.strong.load(SeqCst);\n@@ -480,8 +487,9 @@ impl<T: Sync + Send> Drop for Weak<T> {\n         // see comments above for why this check is here\n         if ptr.is_null() { return }\n \n-        // If we find out that we were the last weak pointer, then its time to deallocate the data\n-        // entirely. See the discussion in Arc::drop() about the memory orderings\n+        // If we find out that we were the last weak pointer, then its time to\n+        // deallocate the data entirely. See the discussion in Arc::drop() about\n+        // the memory orderings\n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n             unsafe { deallocate(ptr as *mut u8, size_of::<ArcInner<T>>(),"}, {"sha": "eb3c5c167268bfe143f68dbef5fb449e6443b8b9", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 50, "deletions": 40, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -59,12 +59,12 @@\n //!\n //!     drop(gadget_owner);\n //!\n-//!     // Despite dropping gadget_owner, we're still able to print out the name of\n-//!     // the Owner of the Gadgets. This is because we've only dropped the\n+//!     // Despite dropping gadget_owner, we're still able to print out the name\n+//!     // of the Owner of the Gadgets. This is because we've only dropped the\n //!     // reference count object, not the Owner it wraps. As long as there are\n-//!     // other `Rc<T>` objects pointing at the same Owner, it will remain allocated. Notice\n-//!     // that the `Rc<T>` wrapper around Gadget.owner gets automatically dereferenced\n-//!     // for us.\n+//!     // other `Rc<T>` objects pointing at the same Owner, it will remain\n+//!     // allocated. Notice that the `Rc<T>` wrapper around Gadget.owner gets\n+//!     // automatically dereferenced for us.\n //!     println!(\"Gadget {} owned by {}\", gadget1.id, gadget1.owner.name);\n //!     println!(\"Gadget {} owned by {}\", gadget2.id, gadget2.owner.name);\n //!\n@@ -74,19 +74,22 @@\n //! }\n //! ```\n //!\n-//! If our requirements change, and we also need to be able to traverse from Owner \u2192\u00a0Gadget, we\n-//! will run into problems: an `Rc<T>` pointer from Owner \u2192\u00a0Gadget introduces a cycle between the\n-//! objects. This means that their reference counts can never reach 0, and the objects will remain\n-//! allocated: a memory leak. In order to get around this, we can use `Weak<T>` pointers. These\n-//! pointers don't contribute to the total count.\n+//! If our requirements change, and we also need to be able to traverse from\n+//! Owner \u2192\u00a0Gadget, we will run into problems: an `Rc<T>` pointer from Owner\n+//! \u2192\u00a0Gadget introduces a cycle between the objects. This means that their\n+//! reference counts can never reach 0, and the objects will remain allocated: a\n+//! memory leak. In order to get around this, we can use `Weak<T>` pointers.\n+//! These pointers don't contribute to the total count.\n //!\n-//! Rust actually makes it somewhat difficult to produce this loop in the first place: in order to\n-//! end up with two objects that point at each other, one of them needs to be mutable. This is\n-//! problematic because `Rc<T>` enforces memory safety by only giving out shared references to the\n-//! object it wraps, and these don't allow direct mutation. We need to wrap the part of the object\n-//! we wish to mutate in a `RefCell`, which provides *interior mutability*: a method to achieve\n-//! mutability through a shared reference. `RefCell` enforces Rust's borrowing rules at runtime.\n-//! Read the `Cell` documentation for more details on interior mutability.\n+//! Rust actually makes it somewhat difficult to produce this loop in the first\n+//! place: in order to end up with two objects that point at each other, one of\n+//! them needs to be mutable. This is problematic because `Rc<T>` enforces\n+//! memory safety by only giving out shared references to the object it wraps,\n+//! and these don't allow direct mutation. We need to wrap the part of the\n+//! object we wish to mutate in a `RefCell`, which provides *interior\n+//! mutability*: a method to achieve mutability through a shared reference.\n+//! `RefCell` enforces Rust's borrowing rules at runtime.  Read the `Cell`\n+//! documentation for more details on interior mutability.\n //!\n //! ```rust\n //! # #![feature(alloc)]\n@@ -130,9 +133,10 @@\n //!     for gadget_opt in gadget_owner.gadgets.borrow().iter() {\n //!\n //!         // gadget_opt is a Weak<Gadget>. Since weak pointers can't guarantee\n-//!         // that their object is still allocated, we need to call upgrade() on them\n-//!         // to turn them into a strong reference. This returns an Option, which\n-//!         // contains a reference to our object if it still exists.\n+//!         // that their object is still allocated, we need to call upgrade()\n+//!         // on them to turn them into a strong reference. This returns an\n+//!         // Option, which contains a reference to our object if it still\n+//!         // exists.\n //!         let gadget = gadget_opt.upgrade().unwrap();\n //!         println!(\"Gadget {} owned by {}\", gadget.id, gadget.owner.name);\n //!     }\n@@ -180,8 +184,8 @@ struct RcBox<T> {\n #[unsafe_no_drop_flag]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T> {\n-    // FIXME #12808: strange names to try to avoid interfering with field accesses of the contained\n-    // type via Deref\n+    // FIXME #12808: strange names to try to avoid interfering with field\n+    // accesses of the contained type via Deref\n     _ptr: NonZero<*mut RcBox<T>>,\n }\n \n@@ -203,9 +207,10 @@ impl<T> Rc<T> {\n     pub fn new(value: T) -> Rc<T> {\n         unsafe {\n             Rc {\n-                // there is an implicit weak pointer owned by all the strong pointers, which\n-                // ensures that the weak destructor never frees the allocation while the strong\n-                // destructor is running, even if the weak pointer is stored inside the strong one.\n+                // there is an implicit weak pointer owned by all the strong\n+                // pointers, which ensures that the weak destructor never frees\n+                // the allocation while the strong destructor is running, even\n+                // if the weak pointer is stored inside the strong one.\n                 _ptr: NonZero::new(boxed::into_raw(box RcBox {\n                     value: value,\n                     strong: Cell::new(1),\n@@ -245,7 +250,8 @@ pub fn weak_count<T>(this: &Rc<T>) -> usize { this.weak() - 1 }\n #[unstable(feature = \"alloc\")]\n pub fn strong_count<T>(this: &Rc<T>) -> usize { this.strong() }\n \n-/// Returns true if there are no other `Rc` or `Weak<T>` values that share the same inner value.\n+/// Returns true if there are no other `Rc` or `Weak<T>` values that share the\n+/// same inner value.\n ///\n /// # Examples\n ///\n@@ -330,8 +336,8 @@ pub fn get_mut<'a, T>(rc: &'a mut Rc<T>) -> Option<&'a mut T> {\n impl<T: Clone> Rc<T> {\n     /// Make a mutable reference from the given `Rc<T>`.\n     ///\n-    /// This is also referred to as a copy-on-write operation because the inner data is cloned if\n-    /// the reference count is greater than one.\n+    /// This is also referred to as a copy-on-write operation because the inner\n+    /// data is cloned if the reference count is greater than one.\n     ///\n     /// # Examples\n     ///\n@@ -349,10 +355,11 @@ impl<T: Clone> Rc<T> {\n         if !is_unique(self) {\n             *self = Rc::new((**self).clone())\n         }\n-        // This unsafety is ok because we're guaranteed that the pointer returned is the *only*\n-        // pointer that will ever be returned to T. Our reference count is guaranteed to be 1 at\n-        // this point, and we required the `Rc<T>` itself to be `mut`, so we're returning the only\n-        // possible reference to the inner value.\n+        // This unsafety is ok because we're guaranteed that the pointer\n+        // returned is the *only* pointer that will ever be returned to T. Our\n+        // reference count is guaranteed to be 1 at this point, and we required\n+        // the `Rc<T>` itself to be `mut`, so we're returning the only possible\n+        // reference to the inner value.\n         let inner = unsafe { &mut **self._ptr };\n         &mut inner.value\n     }\n@@ -373,8 +380,9 @@ impl<T> Deref for Rc<T> {\n impl<T> Drop for Rc<T> {\n     /// Drops the `Rc<T>`.\n     ///\n-    /// This will decrement the strong reference count. If the strong reference count becomes zero\n-    /// and the only other references are `Weak<T>` ones, `drop`s the inner value.\n+    /// This will decrement the strong reference count. If the strong reference\n+    /// count becomes zero and the only other references are `Weak<T>` ones,\n+    /// `drop`s the inner value.\n     ///\n     /// # Examples\n     ///\n@@ -404,8 +412,8 @@ impl<T> Drop for Rc<T> {\n                 if self.strong() == 0 {\n                     ptr::read(&**self); // destroy the contained object\n \n-                    // remove the implicit \"strong weak\" pointer now that we've destroyed the\n-                    // contents.\n+                    // remove the implicit \"strong weak\" pointer now that we've\n+                    // destroyed the contents.\n                     self.dec_weak();\n \n                     if self.weak() == 0 {\n@@ -627,7 +635,8 @@ impl<T: fmt::Debug> fmt::Debug for Rc<T> {\n \n /// A weak version of `Rc<T>`.\n ///\n-/// Weak references do not count when determining if the inner value should be dropped.\n+/// Weak references do not count when determining if the inner value should be\n+/// dropped.\n ///\n /// See the [module level documentation](./index.html) for more.\n #[unsafe_no_drop_flag]\n@@ -652,7 +661,8 @@ impl<T> Weak<T> {\n     ///\n     /// Upgrades the `Weak<T>` reference to an `Rc<T>`, if possible.\n     ///\n-    /// Returns `None` if there were no strong references and the data was destroyed.\n+    /// Returns `None` if there were no strong references and the data was\n+    /// destroyed.\n     ///\n     /// # Examples\n     ///\n@@ -710,8 +720,8 @@ impl<T> Drop for Weak<T> {\n             let ptr = *self._ptr;\n             if !ptr.is_null() {\n                 self.dec_weak();\n-                // the weak count starts at 1, and will only go to zero if all the strong pointers\n-                // have disappeared.\n+                // the weak count starts at 1, and will only go to zero if all\n+                // the strong pointers have disappeared.\n                 if self.weak() == 0 {\n                     deallocate(ptr as *mut u8, size_of::<RcBox<T>>(),\n                                min_align_of::<RcBox<T>>())"}, {"sha": "59819d01bc601aeb2f651d4d332474b743c74f7d", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A growable list type with heap-allocated contents, written `Vec<T>` but pronounced 'vector.'\n+//! A growable list type with heap-allocated contents, written `Vec<T>` but\n+//! pronounced 'vector.'\n //!\n //! Vectors have `O(1)` indexing, push (to the end) and pop (from the end).\n //!\n@@ -124,17 +125,19 @@ use borrow::{Cow, IntoCow};\n ///\n /// # Capacity and reallocation\n ///\n-/// The capacity of a vector is the amount of space allocated for any future elements that will be\n-/// added onto the vector. This is not to be confused with the *length* of a vector, which\n-/// specifies the number of actual elements within the vector. If a vector's length exceeds its\n-/// capacity, its capacity will automatically be increased, but its elements will have to be\n+/// The capacity of a vector is the amount of space allocated for any future\n+/// elements that will be added onto the vector. This is not to be confused with\n+/// the *length* of a vector, which specifies the number of actual elements\n+/// within the vector. If a vector's length exceeds its capacity, its capacity\n+/// will automatically be increased, but its elements will have to be\n /// reallocated.\n ///\n-/// For example, a vector with capacity 10 and length 0 would be an empty vector with space for 10\n-/// more elements. Pushing 10 or fewer elements onto the vector will not change its capacity or\n-/// cause reallocation to occur. However, if the vector's length is increased to 11, it will have\n-/// to reallocate, which can be slow. For this reason, it is recommended to use\n-/// `Vec::with_capacity` whenever possible to specify how big the vector is expected to get.\n+/// For example, a vector with capacity 10 and length 0 would be an empty vector\n+/// with space for 10 more elements. Pushing 10 or fewer elements onto the\n+/// vector will not change its capacity or cause reallocation to occur. However,\n+/// if the vector's length is increased to 11, it will have to reallocate, which\n+/// can be slow. For this reason, it is recommended to use `Vec::with_capacity`\n+/// whenever possible to specify how big the vector is expected to get.\n #[unsafe_no_drop_flag]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Vec<T> {\n@@ -1429,7 +1432,7 @@ impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n     #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, _index: ops::RangeFull) -> &[T] {\n-        self.as_slice()\n+        self\n     }\n }\n \n@@ -1733,15 +1736,20 @@ impl<T> AsRef<[T]> for Vec<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Clone> From<&'a [T]> for Vec<T> {\n+    #[cfg(not(test))]\n     fn from(s: &'a [T]) -> Vec<T> {\n         s.to_vec()\n     }\n+    #[cfg(test)]\n+    fn from(s: &'a [T]) -> Vec<T> {\n+        ::slice::to_vec(s)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> From<&'a str> for Vec<u8> {\n     fn from(s: &'a str) -> Vec<u8> {\n-        s.as_bytes().to_vec()\n+        From::from(s.as_bytes())\n     }\n }\n "}, {"sha": "f03a073e274e389712b6f994c74228073dda25b1", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -20,6 +20,7 @@\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unsafe_destructor)]\n+#![feature(into_cow)]\n #![cfg_attr(test, feature(str_char))]\n \n #[macro_use] extern crate log;"}, {"sha": "ccf4a3f48d9a15aa2cc7106b9a878df808c556f2", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -47,13 +47,13 @@\n //! which is cyclic.\n //!\n //! ```rust\n-//! # #![feature(rustc_private, core)]\n+//! # #![feature(rustc_private, core, into_cow)]\n //! use std::borrow::IntoCow;\n //! use std::io::Write;\n //! use graphviz as dot;\n //!\n-//! type Nd = int;\n-//! type Ed = (int,int);\n+//! type Nd = isize;\n+//! type Ed = (isize,isize);\n //! struct Edges(Vec<Ed>);\n //!\n //! pub fn render_to<W: Write>(output: &mut W) {\n@@ -133,7 +133,7 @@\n //! direct reference to the `(source,target)` pair stored in the graph's\n //! internal vector (rather than passing around a copy of the pair\n //! itself). Note that this implies that `fn edges(&'a self)` must\n-//! construct a fresh `Vec<&'a (uint,uint)>` from the `Vec<(uint,uint)>`\n+//! construct a fresh `Vec<&'a (usize,usize)>` from the `Vec<(usize,usize)>`\n //! edges stored in `self`.\n //!\n //! Since both the set of nodes and the set of edges are always\n@@ -149,14 +149,14 @@\n //! entity `&sube`).\n //!\n //! ```rust\n-//! # #![feature(rustc_private, core)]\n+//! # #![feature(rustc_private, core, into_cow)]\n //! use std::borrow::IntoCow;\n //! use std::io::Write;\n //! use graphviz as dot;\n //!\n-//! type Nd = uint;\n-//! type Ed<'a> = &'a (uint, uint);\n-//! struct Graph { nodes: Vec<&'static str>, edges: Vec<(uint,uint)> }\n+//! type Nd = usize;\n+//! type Ed<'a> = &'a (usize, usize);\n+//! struct Graph { nodes: Vec<&'static str>, edges: Vec<(usize,usize)> }\n //!\n //! pub fn render_to<W: Write>(output: &mut W) {\n //!     let nodes = vec!(\"{x,y}\",\"{x}\",\"{y}\",\"{}\");\n@@ -207,14 +207,14 @@\n //! Hasse-diagram for the subsets of the set `{x, y}`.\n //!\n //! ```rust\n-//! # #![feature(rustc_private, core)]\n+//! # #![feature(rustc_private, core, into_cow)]\n //! use std::borrow::IntoCow;\n //! use std::io::Write;\n //! use graphviz as dot;\n //!\n-//! type Nd<'a> = (uint, &'a str);\n+//! type Nd<'a> = (usize, &'a str);\n //! type Ed<'a> = (Nd<'a>, Nd<'a>);\n-//! struct Graph { nodes: Vec<&'static str>, edges: Vec<(uint,uint)> }\n+//! struct Graph { nodes: Vec<&'static str>, edges: Vec<(usize,usize)> }\n //!\n //! pub fn render_to<W: Write>(output: &mut W) {\n //!     let nodes = vec!(\"{x,y}\",\"{x}\",\"{y}\",\"{}\");\n@@ -231,7 +231,7 @@\n //!     }\n //!     fn node_label<'b>(&'b self, n: &Nd<'b>) -> dot::LabelText<'b> {\n //!         let &(i, _) = n;\n-//!         dot::LabelText::LabelStr(self.nodes[i].as_slice().into_cow())\n+//!         dot::LabelText::LabelStr(self.nodes[i].into_cow())\n //!     }\n //!     fn edge_label<'b>(&'b self, _: &Ed<'b>) -> dot::LabelText<'b> {\n //!         dot::LabelText::LabelStr(\"&sube;\".into_cow())\n@@ -240,12 +240,12 @@\n //!\n //! impl<'a> dot::GraphWalk<'a, Nd<'a>, Ed<'a>> for Graph {\n //!     fn nodes(&'a self) -> dot::Nodes<'a,Nd<'a>> {\n-//!         self.nodes.iter().map(|s|s.as_slice()).enumerate().collect()\n+//!         self.nodes.iter().map(|s| &s[..]).enumerate().collect()\n //!     }\n //!     fn edges(&'a self) -> dot::Edges<'a,Ed<'a>> {\n //!         self.edges.iter()\n-//!             .map(|&(i,j)|((i, self.nodes[i].as_slice()),\n-//!                           (j, self.nodes[j].as_slice())))\n+//!             .map(|&(i,j)|((i, &self.nodes[i][..]),\n+//!                           (j, &self.nodes[j][..])))\n //!             .collect()\n //!     }\n //!     fn source(&self, e: &Ed<'a>) -> Nd<'a> { let &(s,_) = e; s }\n@@ -385,7 +385,7 @@ impl<'a> Id<'a> {\n             is_letter_or_underscore(c) || in_range('0', c, '9')\n         }\n         fn in_range(low: char, c: char, high: char) -> bool {\n-            low as uint <= c as uint && c as uint <= high as uint\n+            low as usize <= c as usize && c as usize <= high as usize\n         }\n     }\n \n@@ -602,12 +602,12 @@ mod tests {\n     use std::iter::repeat;\n \n     /// each node is an index in a vector in the graph.\n-    type Node = uint;\n+    type Node = usize;\n     struct Edge {\n-        from: uint, to: uint, label: &'static str\n+        from: usize, to: usize, label: &'static str\n     }\n \n-    fn edge(from: uint, to: uint, label: &'static str) -> Edge {\n+    fn edge(from: usize, to: usize, label: &'static str) -> Edge {\n         Edge { from: from, to: to, label: label }\n     }\n \n@@ -637,7 +637,7 @@ mod tests {\n \n     enum NodeLabels<L> {\n         AllNodesLabelled(Vec<L>),\n-        UnlabelledNodes(uint),\n+        UnlabelledNodes(usize),\n         SomeNodesLabelled(Vec<Option<L>>),\n     }\n "}, {"sha": "63727a573a3cb5ef93037d5642c2b1a2275805fa", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -47,7 +47,6 @@\n #![feature(rand)]\n #![feature(path_ext)]\n #![feature(std_misc)]\n-#![feature(path_relative_from)]\n #![feature(step_by)]\n #![feature(convert)]\n #![cfg_attr(test, feature(test, rand))]"}, {"sha": "ff3f0b78f91b317fae4c0485a0a835c796fdb8cf", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -228,7 +228,7 @@ mod test {\n                 used_crates: Vec::new(),\n                 has_rpath: true,\n                 is_like_osx: true,\n-                out_filename: PathBuf::new(\"bin/rustc\"),\n+                out_filename: PathBuf::from(\"bin/rustc\"),\n                 get_install_prefix_lib_path: &mut || panic!(),\n                 realpath: &mut |p| Ok(p.to_path_buf()),\n             };\n@@ -238,7 +238,7 @@ mod test {\n         } else {\n             let config = &mut RPathConfig {\n                 used_crates: Vec::new(),\n-                out_filename: PathBuf::new(\"bin/rustc\"),\n+                out_filename: PathBuf::from(\"bin/rustc\"),\n                 get_install_prefix_lib_path: &mut || panic!(),\n                 has_rpath: true,\n                 is_like_osx: false,"}, {"sha": "ef65acf8b13f4838d5f848de3e0051f86eb17aa0", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -40,7 +40,6 @@\n #![feature(rustc_private)]\n #![feature(unsafe_destructor)]\n #![feature(staged_api)]\n-#![feature(std_misc)]\n #![feature(str_char)]\n #![cfg_attr(test, feature(test))]\n "}, {"sha": "d6c85e8b173459c5449a60a68dbccc6bdb6d7e99", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -81,7 +81,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n \n     // Default per-arch clobbers\n     // Basically what clang does\n-    let arch_clobbers = match bcx.sess().target.target.arch.as_slice() {\n+    let arch_clobbers = match &bcx.sess().target.target.arch[..] {\n         \"x86\" | \"x86_64\" => vec!(\"~{dirflag}\", \"~{fpsr}\", \"~{flags}\"),\n         _                => Vec::new()\n     };"}, {"sha": "4e7e63a5d7779a6787e1d732aa67e22646ecdbe1", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -80,7 +80,6 @@ This API is completely unstable and subject to change.\n #![feature(collections)]\n #![feature(core)]\n #![feature(int_uint)]\n-#![feature(std_misc)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]"}, {"sha": "fd7532ea4a7652bbb4866c659c05109a408fb1a5", "filename": "src/libstd/env.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -327,12 +327,13 @@ pub struct JoinPathsError {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(convert)]\n /// use std::env;\n /// use std::path::PathBuf;\n ///\n /// if let Some(path) = env::var_os(\"PATH\") {\n ///     let mut paths = env::split_paths(&path).collect::<Vec<_>>();\n-///     paths.push(PathBuf::new(\"/home/xyz/bin\"));\n+///     paths.push(PathBuf::from(\"/home/xyz/bin\"));\n ///     let new_path = env::join_paths(paths.iter()).unwrap();\n ///     env::set_var(\"PATH\", &new_path);\n /// }\n@@ -853,7 +854,7 @@ mod tests {\n     fn split_paths_unix() {\n         fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n             split_paths(unparsed).collect::<Vec<_>>() ==\n-                parsed.iter().map(|s| PathBuf::new(*s)).collect::<Vec<_>>()\n+                parsed.iter().map(|s| PathBuf::from(*s)).collect::<Vec<_>>()\n         }\n \n         assert!(check_parse(\"\", &mut [\"\"]));"}, {"sha": "50f79967f555ef86a707fcd4f96d798f9eb2daa9", "filename": "src/libstd/path.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -35,9 +35,10 @@\n //! To build or modify paths, use `PathBuf`:\n //!\n //! ```rust\n+//! # #![feature(convert)]\n //! use std::path::PathBuf;\n //!\n-//! let mut path = PathBuf::new(\"c:\\\\\");\n+//! let mut path = PathBuf::from(\"c:\\\\\");\n //! path.push(\"windows\");\n //! path.push(\"system32\");\n //! path.set_extension(\"dll\");\n@@ -892,9 +893,10 @@ impl<'a> cmp::Ord for Components<'a> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(convert)]\n /// use std::path::PathBuf;\n ///\n-/// let mut path = PathBuf::new(\"c:\\\\\");\n+/// let mut path = PathBuf::from(\"c:\\\\\");\n /// path.push(\"windows\");\n /// path.push(\"system32\");\n /// path.set_extension(\"dll\");\n@@ -983,15 +985,16 @@ impl PathBuf {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(convert)]\n     /// use std::path::PathBuf;\n     ///\n-    /// let mut buf = PathBuf::new(\"/\");\n+    /// let mut buf = PathBuf::from(\"/\");\n     /// assert!(buf.file_name() == None);\n     /// buf.set_file_name(\"bar\");\n-    /// assert!(buf == PathBuf::new(\"/bar\"));\n+    /// assert!(buf == PathBuf::from(\"/bar\"));\n     /// assert!(buf.file_name().is_some());\n     /// buf.set_file_name(\"baz.txt\");\n-    /// assert!(buf == PathBuf::new(\"/baz.txt\"));\n+    /// assert!(buf == PathBuf::from(\"/baz.txt\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn set_file_name<S: AsRef<OsStr>>(&mut self, file_name: S) {\n@@ -1661,7 +1664,7 @@ mod tests {\n \n         let static_path = Path::new(\"/home/foo\");\n         let static_cow_path: Cow<'static, Path> = static_path.into_cow();\n-        let pathbuf = PathBuf::new(\"/home/foo\");\n+        let pathbuf = PathBuf::from(\"/home/foo\");\n \n         {\n             let path: &Path = &pathbuf;\n@@ -2543,7 +2546,7 @@ mod tests {\n     pub fn test_push() {\n         macro_rules! tp(\n             ($path:expr, $push:expr, $expected:expr) => ( {\n-                let mut actual = PathBuf::new($path);\n+                let mut actual = PathBuf::from($path);\n                 actual.push($push);\n                 assert!(actual.to_str() == Some($expected),\n                         \"pushing {:?} onto {:?}: Expected {:?}, got {:?}\",\n@@ -2631,7 +2634,7 @@ mod tests {\n     pub fn test_pop() {\n         macro_rules! tp(\n             ($path:expr, $expected:expr, $output:expr) => ( {\n-                let mut actual = PathBuf::new($path);\n+                let mut actual = PathBuf::from($path);\n                 let output = actual.pop();\n                 assert!(actual.to_str() == Some($expected) && output == $output,\n                         \"popping from {:?}: Expected {:?}/{:?}, got {:?}/{:?}\",\n@@ -2685,7 +2688,7 @@ mod tests {\n     pub fn test_set_file_name() {\n         macro_rules! tfn(\n                 ($path:expr, $file:expr, $expected:expr) => ( {\n-                let mut p = PathBuf::new($path);\n+                let mut p = PathBuf::from($path);\n                 p.set_file_name($file);\n                 assert!(p.to_str() == Some($expected),\n                         \"setting file name of {:?} to {:?}: Expected {:?}, got {:?}\",\n@@ -2719,7 +2722,7 @@ mod tests {\n     pub fn test_set_extension() {\n         macro_rules! tfe(\n                 ($path:expr, $ext:expr, $expected:expr, $output:expr) => ( {\n-                let mut p = PathBuf::new($path);\n+                let mut p = PathBuf::from($path);\n                 let output = p.set_extension($ext);\n                 assert!(p.to_str() == Some($expected) && output == $output,\n                         \"setting extension of {:?} to {:?}: Expected {:?}/{:?}, got {:?}/{:?}\","}, {"sha": "553412c83712f6dcf4b44c275f62f628ef0109cc", "filename": "src/libstd/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -770,7 +770,7 @@ mod tests {\n         // test changing to the parent of os::getcwd() because we know\n         // the path exists (and os::getcwd() is not expected to be root)\n         let parent_dir = os::getcwd().unwrap().dir_path();\n-        let result = pwd_cmd().current_dir(&parent_dir).output().unwrap();\n+        let result = pwd_cmd().current_dir(parent_dir.as_str().unwrap()).output().unwrap();\n \n         let output = String::from_utf8(result.stdout).unwrap();\n         let child_dir = old_path::Path::new(output.trim());"}, {"sha": "eb61f21aacd5d52ee5a7c66106948e90ac835287", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -13,14 +13,12 @@\n use core::prelude::*;\n \n use cmp;\n-use dynamic_lib::DynamicLibrary;\n use ffi::CString;\n use io;\n use libc::consts::os::posix01::PTHREAD_STACK_MIN;\n use libc;\n use mem;\n use ptr;\n-use sync::{Once, ONCE_INIT};\n use sys::os;\n use thunk::Thunk;\n use time::Duration;\n@@ -322,6 +320,9 @@ pub fn sleep(dur: Duration) {\n // dependency on libc6 (#23628).\n #[cfg(target_os = \"linux\")]\n fn min_stack_size(attr: *const libc::pthread_attr_t) -> libc::size_t {\n+    use dynamic_lib::DynamicLibrary;\n+    use sync::{Once, ONCE_INIT};\n+\n     type F = unsafe extern \"C\" fn(*const libc::pthread_attr_t) -> libc::size_t;\n     static INIT: Once = ONCE_INIT;\n     static mut __pthread_get_minstack: Option<F> = None;"}, {"sha": "998352651117bcbe99b5f9c3f54cc69b2ef3d88f", "filename": "src/libstd/sys/windows/fs2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -372,7 +372,7 @@ pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n                                   sz - 1,\n                                   libc::VOLUME_NAME_DOS)\n     }, |s| OsStringExt::from_wide(s)));\n-    Ok(PathBuf::new(&ret))\n+    Ok(PathBuf::from(&ret))\n }\n \n pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {"}, {"sha": "b1ceac9b9025684429ad28bc8d37c90a3afeb97a", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -304,9 +304,7 @@ fn fill_utf16_buf_new<F1, F2, T>(f1: F1, f2: F2) -> io::Result<T>\n }\n \n fn os2path(s: &[u16]) -> PathBuf {\n-    let os = <OsString as OsStringExt>::from_wide(s);\n-    // FIXME(#22751) should consume `os`\n-    PathBuf::new(&os)\n+    PathBuf::from(OsString::from_wide(s))\n }\n \n pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {"}, {"sha": "83d0637173444c56cb4dbb46a7dfc1f715b712a4", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -363,10 +363,7 @@ pub fn temp_dir() -> PathBuf {\n pub fn home_dir() -> Option<PathBuf> {\n     getenv(\"HOME\".as_os_str()).or_else(|| {\n         getenv(\"USERPROFILE\".as_os_str())\n-    }).map(|os| {\n-        // FIXME(#22751) should consume `os`\n-        PathBuf::new(&os)\n-    }).or_else(|| unsafe {\n+    }).map(PathBuf::from).or_else(|| unsafe {\n         let me = c::GetCurrentProcess();\n         let mut token = ptr::null_mut();\n         if c::OpenProcessToken(me, c::TOKEN_READ, &mut token) == 0 {"}, {"sha": "b384879d7a956751daba630d1061a14a27857117", "filename": "src/libstd/thread/scoped.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibstd%2Fthread%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Flibstd%2Fthread%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fscoped.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -24,7 +24,7 @@\n //! # Examples\n //!\n //! ```\n-//! # #![feature(std_misc)]\n+//! # #![feature(scoped_tls)]\n //! scoped_thread_local!(static FOO: u32);\n //!\n //! // Initially each scoped slot is empty.\n@@ -147,7 +147,7 @@ impl<T> ScopedKey<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n+    /// # #![feature(scoped_tls)]\n     /// scoped_thread_local!(static FOO: u32);\n     ///\n     /// FOO.set(&100, || {\n@@ -200,7 +200,7 @@ impl<T> ScopedKey<T> {\n     /// # Examples\n     ///\n     /// ```no_run\n-    /// # #![feature(std_misc)]\n+    /// # #![feature(scoped_tls)]\n     /// scoped_thread_local!(static FOO: u32);\n     ///\n     /// FOO.with(|slot| {"}, {"sha": "0d42e0be58d0702edccef3084d2cd87cc685aa97", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_private, path)]\n+#![feature(rustc_private, path, convert)]\n \n extern crate rustc;\n extern crate rustc_driver;\n@@ -33,9 +33,9 @@ fn main() {\n         panic!(\"expected rustc path\");\n     }\n \n-    let tmpdir = PathBuf::new(&args[1]);\n+    let tmpdir = PathBuf::from(&args[1]);\n \n-    let mut sysroot = PathBuf::new(&args[3]);\n+    let mut sysroot = PathBuf::from(&args[3]);\n     sysroot.pop();\n     sysroot.pop();\n "}, {"sha": "475df629f6376f5dfcedaf2c217ccc850182c868", "filename": "src/test/run-pass/create-dir-all-bare.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Ftest%2Frun-pass%2Fcreate-dir-all-bare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Ftest%2Frun-pass%2Fcreate-dir-all-bare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcreate-dir-all-bare.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(tempdir)]\n+\n use std::env;\n use std::fs::{self, TempDir};\n "}, {"sha": "d0720ec593fa4a2e97884820a3bf67366356cbb7", "filename": "src/test/run-pass/issue-20797.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Ftest%2Frun-pass%2Fissue-20797.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Ftest%2Frun-pass%2Fissue-20797.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20797.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -12,12 +12,12 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(old_io, old_path)]\n+#![feature(convert)]\n \n use std::default::Default;\n use std::io;\n use std::fs;\n-use std::path::{PathBuf, Path};\n+use std::path::PathBuf;\n \n pub trait PathExtensions {\n     fn is_dir(&self) -> bool { false }\n@@ -98,8 +98,8 @@ impl<S: Strategy> Iterator for Subpaths<S> {\n     }\n }\n \n-fn foo() {\n-    let mut walker: Subpaths<Recursive> = Subpaths::walk(&PathBuf::new(\"/home\")).unwrap();\n+fn _foo() {\n+    let _walker: Subpaths<Recursive> = Subpaths::walk(&PathBuf::from(\"/home\")).unwrap();\n }\n \n fn main() {}"}, {"sha": "d109f7abde44abc2fac4767f46cdbcedbb842f46", "filename": "src/test/run-pass/send_str_hashmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -10,7 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(collections)]\n+#![feature(collections, into_cow)]\n \n extern crate collections;\n "}, {"sha": "07dd54433480c9e5d6ef89720a43bf4035d696d3", "filename": "src/test/run-pass/send_str_treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -10,7 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(collections)]\n+#![feature(collections, into_cow)]\n \n extern crate collections;\n "}, {"sha": "489abf163c0b2d80cc9d9ab9a28527d8c5e03c0a", "filename": "src/test/run-pass/tcp-stress.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-stress.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -13,6 +13,9 @@\n // ignore-openbsd system ulimit (Too many open files)\n // exec-env:RUST_LOG=debug\n \n+#![feature(rustc_private, libc, old_io, io, std_misc)]\n+#![allow(deprecated, unused_must_use)]\n+\n #[macro_use]\n extern crate log;\n extern crate libc;"}, {"sha": "a6ea0f76dc2f9f63b05accb78619da76cd7e677b", "filename": "src/test/run-pass/ufcs-polymorphic-paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Ftest%2Frun-pass%2Fufcs-polymorphic-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b54387b88bdf43c00849e3483c2297723f5a73/src%2Ftest%2Frun-pass%2Fufcs-polymorphic-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fufcs-polymorphic-paths.rs?ref=29b54387b88bdf43c00849e3483c2297723f5a73", "patch": "@@ -10,7 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(collections, rand)]\n+#![feature(collections, rand, into_cow)]\n \n use std::borrow::{Cow, IntoCow};\n use std::collections::BitVec;"}]}