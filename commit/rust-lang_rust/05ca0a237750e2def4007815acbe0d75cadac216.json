{"sha": "05ca0a237750e2def4007815acbe0d75cadac216", "node_id": "C_kwDOAAsO6NoAKDA1Y2EwYTIzNzc1MGUyZGVmNDAwNzgxNWFjYmUwZDc1Y2FkYWMyMTY", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-06-20T18:21:30Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-06-20T18:21:30Z"}, "message": "Refactor a bit", "tree": {"sha": "1fbb8d008eac0574ee38e0ad5ea208268a093f6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fbb8d008eac0574ee38e0ad5ea208268a093f6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05ca0a237750e2def4007815acbe0d75cadac216", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05ca0a237750e2def4007815acbe0d75cadac216", "html_url": "https://github.com/rust-lang/rust/commit/05ca0a237750e2def4007815acbe0d75cadac216", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05ca0a237750e2def4007815acbe0d75cadac216/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98a58114a4f2d83e4ddd4da85493b83b42f6a6b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/98a58114a4f2d83e4ddd4da85493b83b42f6a6b9", "html_url": "https://github.com/rust-lang/rust/commit/98a58114a4f2d83e4ddd4da85493b83b42f6a6b9"}], "stats": {"total": 38, "additions": 15, "deletions": 23}, "files": [{"sha": "6aefb84db8ad20e2b3e3e6bb40dc71c86987e01c", "filename": "crates/project-model/src/workspace.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/05ca0a237750e2def4007815acbe0d75cadac216/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca0a237750e2def4007815acbe0d75cadac216/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=05ca0a237750e2def4007815acbe0d75cadac216", "patch": "@@ -548,8 +548,7 @@ fn cargo_to_crate_graph(\n     let mut has_private = false;\n     // Next, create crates for each package, target pair\n     for pkg in cargo.packages() {\n-        let mut cfg_options = &cfg_options;\n-        let mut replaced_cfg_options;\n+        let mut cfg_options = cfg_options.clone();\n \n         let overrides = match override_cfg {\n             CfgOverrides::Wildcard(cfg_diff) => Some(cfg_diff),\n@@ -558,9 +557,7 @@ fn cargo_to_crate_graph(\n \n         // Add test cfg for local crates\n         if cargo[pkg].is_local {\n-            replaced_cfg_options = cfg_options.clone();\n-            replaced_cfg_options.insert_atom(\"test\".into());\n-            cfg_options = &replaced_cfg_options;\n+            cfg_options.insert_atom(\"test\".into());\n         }\n \n         if let Some(overrides) = overrides {\n@@ -571,9 +568,7 @@ fn cargo_to_crate_graph(\n             // A more ideal solution might be to reanalyze crates based on where the cursor is and\n             // figure out the set of cfgs that would have to apply to make it active.\n \n-            replaced_cfg_options = cfg_options.clone();\n-            replaced_cfg_options.apply_diff(overrides.clone());\n-            cfg_options = &replaced_cfg_options;\n+            cfg_options.apply_diff(overrides.clone());\n         };\n \n         has_private |= cargo[pkg].metadata.rustc_private;\n@@ -593,7 +588,7 @@ fn cargo_to_crate_graph(\n                     &mut crate_graph,\n                     &cargo[pkg],\n                     build_scripts.get_output(pkg),\n-                    cfg_options,\n+                    cfg_options.clone(),\n                     &mut |path| load_proc_macro(&cargo[tgt].name, path),\n                     file_id,\n                     &cargo[tgt].name,\n@@ -758,8 +753,7 @@ fn handle_rustc_crates(\n                 queue.push_back(dep.pkg);\n             }\n \n-            let mut cfg_options = cfg_options;\n-            let mut replaced_cfg_options;\n+            let mut cfg_options = cfg_options.clone();\n \n             let overrides = match override_cfg {\n                 CfgOverrides::Wildcard(cfg_diff) => Some(cfg_diff),\n@@ -776,9 +770,7 @@ fn handle_rustc_crates(\n                 // A more ideal solution might be to reanalyze crates based on where the cursor is and\n                 // figure out the set of cfgs that would have to apply to make it active.\n \n-                replaced_cfg_options = cfg_options.clone();\n-                replaced_cfg_options.apply_diff(overrides.clone());\n-                cfg_options = &replaced_cfg_options;\n+                cfg_options.apply_diff(overrides.clone());\n             };\n \n             for &tgt in rustc_workspace[pkg].targets.iter() {\n@@ -790,7 +782,7 @@ fn handle_rustc_crates(\n                         crate_graph,\n                         &rustc_workspace[pkg],\n                         build_scripts.get_output(pkg),\n-                        cfg_options,\n+                        cfg_options.clone(),\n                         &mut |path| load_proc_macro(&rustc_workspace[tgt].name, path),\n                         file_id,\n                         &rustc_workspace[tgt].name,\n@@ -845,15 +837,21 @@ fn add_target_crate_root(\n     crate_graph: &mut CrateGraph,\n     pkg: &PackageData,\n     build_data: Option<&BuildScriptOutput>,\n-    cfg_options: &CfgOptions,\n+    cfg_options: CfgOptions,\n     load_proc_macro: &mut dyn FnMut(&AbsPath) -> ProcMacroLoadResult,\n     file_id: FileId,\n     cargo_name: &str,\n     is_proc_macro: bool,\n ) -> CrateId {\n     let edition = pkg.edition;\n+    let mut potential_cfg_options = cfg_options.clone();\n+    potential_cfg_options.extend(\n+        pkg.features\n+            .iter()\n+            .map(|feat| CfgFlag::KeyValue { key: \"feature\".into(), value: feat.0.into() }),\n+    );\n     let cfg_options = {\n-        let mut opts = cfg_options.clone();\n+        let mut opts = cfg_options;\n         for feature in pkg.active_features.iter() {\n             opts.insert_key_value(\"feature\".into(), feature.into());\n         }\n@@ -878,12 +876,6 @@ fn add_target_crate_root(\n     };\n \n     let display_name = CrateDisplayName::from_canonical_name(cargo_name.to_string());\n-    let mut potential_cfg_options = cfg_options.clone();\n-    potential_cfg_options.extend(\n-        pkg.features\n-            .iter()\n-            .map(|feat| CfgFlag::KeyValue { key: \"feature\".into(), value: feat.0.into() }),\n-    );\n     crate_graph.add_crate_root(\n         file_id,\n         edition,"}]}