{"sha": "2232321ac7d03ed8c1d191de0653d1c32db877d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyMzIzMjFhYzdkMDNlZDhjMWQxOTFkZTA2NTNkMWMzMmRiODc3ZDY=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-05-27T21:43:05Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-05-29T22:38:15Z"}, "message": "Optimize `TyCtxt::adjust_ident`.\n\nIt's a hot function that returns a 2-tuple, but the hottest call site\n(`hygienic_eq`) discards the second element.\n\nThis commit renames `adjust_ident` as `adjust_ident_and_get_scope`, and\nthen introduces a new `adjust_ident` that only computes the first\nelement. This change also avoids the need to pass in an unused\n`DUMMY_HIR_ID` argument in a couple of places, which is nice.", "tree": {"sha": "17c3e1363ce0e9ab38f3e2ac747c48b56bc81a23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17c3e1363ce0e9ab38f3e2ac747c48b56bc81a23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2232321ac7d03ed8c1d191de0653d1c32db877d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2232321ac7d03ed8c1d191de0653d1c32db877d6", "html_url": "https://github.com/rust-lang/rust/commit/2232321ac7d03ed8c1d191de0653d1c32db877d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2232321ac7d03ed8c1d191de0653d1c32db877d6/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ca6facaaf6dac086acf188b728edce8dd6aa8e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ca6facaaf6dac086acf188b728edce8dd6aa8e3", "html_url": "https://github.com/rust-lang/rust/commit/2ca6facaaf6dac086acf188b728edce8dd6aa8e3"}], "stats": {"total": 43, "additions": 27, "deletions": 16}, "files": [{"sha": "cfe20c5b03fbcc0aa36d77a288623cbec8ac24ce", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2232321ac7d03ed8c1d191de0653d1c32db877d6/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2232321ac7d03ed8c1d191de0653d1c32db877d6/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=2232321ac7d03ed8c1d191de0653d1c32db877d6", "patch": "@@ -3089,20 +3089,28 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // comparison fails frequently, and we want to avoid the expensive\n         // `modern()` calls required for the span comparison whenever possible.\n         use_name.name == def_name.name &&\n-        self.adjust_ident(use_name, def_parent_def_id, hir::DUMMY_HIR_ID).0.span.ctxt() ==\n-            def_name.modern().span.ctxt()\n+        self.adjust_ident(use_name, def_parent_def_id).span.ctxt() == def_name.modern().span.ctxt()\n     }\n \n-    pub fn adjust_ident(self, mut ident: Ident, scope: DefId, block: hir::HirId) -> (Ident, DefId) {\n-        ident = ident.modern();\n-        let target_expansion = match scope.krate {\n+    fn expansion_that_defined(self, scope: DefId) -> Mark {\n+        match scope.krate {\n             LOCAL_CRATE => self.hir().definitions().expansion_that_defined(scope.index),\n             _ => Mark::root(),\n-        };\n-        let scope = match ident.span.adjust(target_expansion) {\n+        }\n+    }\n+\n+    pub fn adjust_ident(self, mut ident: Ident, scope: DefId) -> Ident {\n+        ident = ident.modern();\n+        ident.span.adjust(self.expansion_that_defined(scope));\n+        ident\n+    }\n+\n+    pub fn adjust_ident_and_get_scope(self, mut ident: Ident, scope: DefId, block: hir::HirId)\n+                                      -> (Ident, DefId) {\n+        ident = ident.modern();\n+        let scope = match ident.span.adjust(self.expansion_that_defined(scope)) {\n             Some(actual_expansion) =>\n                 self.hir().definitions().parent_module_of_macro_def(actual_expansion),\n-            None if block == hir::DUMMY_HIR_ID => DefId::local(CRATE_DEF_INDEX), // Dummy DefId\n             None => self.hir().get_module_parent_by_hir_id(block),\n         };\n         (ident, scope)"}, {"sha": "644cf1a3012f26ad400229031d6d9824b2be28c0", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2232321ac7d03ed8c1d191de0653d1c32db877d6/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2232321ac7d03ed8c1d191de0653d1c32db877d6/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=2232321ac7d03ed8c1d191de0653d1c32db877d6", "patch": "@@ -845,7 +845,7 @@ impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n                    field: &'tcx ty::FieldDef) { // definition of the field\n         let ident = Ident::new(kw::Invalid, use_ctxt);\n         let current_hir = self.current_item;\n-        let def_id = self.tcx.adjust_ident(ident, def.did, current_hir).1;\n+        let def_id = self.tcx.adjust_ident_and_get_scope(ident, def.did, current_hir).1;\n         if !def.is_enum() && !field.vis.is_accessible_from(def_id, self.tcx) {\n             struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of {} `{}` is private\",\n                              field.ident, def.variant_descr(), self.tcx.def_path_str(def.did))"}, {"sha": "cd53bdc6ed0a04c9a144e3fcd189ac7d6541dddf", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2232321ac7d03ed8c1d191de0653d1c32db877d6/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2232321ac7d03ed8c1d191de0653d1c32db877d6/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=2232321ac7d03ed8c1d191de0653d1c32db877d6", "patch": "@@ -903,7 +903,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         }?;\n \n         let (assoc_ident, def_scope) =\n-            tcx.adjust_ident(binding.item_name, candidate.def_id(), hir_ref_id);\n+            tcx.adjust_ident_and_get_scope(binding.item_name, candidate.def_id(), hir_ref_id);\n         let assoc_ty = tcx.associated_items(candidate.def_id()).find(|i| {\n             i.kind == ty::AssocKind::Type && i.ident.modern() == assoc_ident\n         }).expect(\"missing associated type\");\n@@ -1433,7 +1433,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         };\n \n         let trait_did = bound.def_id();\n-        let (assoc_ident, def_scope) = tcx.adjust_ident(assoc_ident, trait_did, hir_ref_id);\n+        let (assoc_ident, def_scope) =\n+            tcx.adjust_ident_and_get_scope(assoc_ident, trait_did, hir_ref_id);\n         let item = tcx.associated_items(trait_did).find(|i| {\n             Namespace::from(i.kind) == Namespace::Type &&\n                 i.ident.modern() == assoc_ident"}, {"sha": "f43d2bab352154dd4f32a36f858763465151a55f", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2232321ac7d03ed8c1d191de0653d1c32db877d6/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2232321ac7d03ed8c1d191de0653d1c32db877d6/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=2232321ac7d03ed8c1d191de0653d1c32db877d6", "patch": "@@ -1184,7 +1184,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         let mut inexistent_fields = vec![];\n         // Typecheck each field.\n         for &Spanned { node: ref field, span } in fields {\n-            let ident = tcx.adjust_ident(field.ident, variant.def_id, self.body_id).0;\n+            let ident = tcx.adjust_ident(field.ident, variant.def_id);\n             let field_ty = match used_fields.entry(ident) {\n                 Occupied(occupied) => {\n                     struct_span_err!(tcx.sess, span, E0025,"}, {"sha": "2c20585c5942c22ffc0734831d8333baa41d3b94", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2232321ac7d03ed8c1d191de0653d1c32db877d6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2232321ac7d03ed8c1d191de0653d1c32db877d6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=2232321ac7d03ed8c1d191de0653d1c32db877d6", "patch": "@@ -510,7 +510,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     {\n         let is_accessible = if let Some(name) = self.method_name {\n             let item = candidate.item;\n-            let def_scope = self.tcx.adjust_ident(name, item.container.id(), self.body_id).1;\n+            let def_scope =\n+                self.tcx.adjust_ident_and_get_scope(name, item.container.id(), self.body_id).1;\n             item.vis.is_accessible_from(def_scope, self.tcx)\n         } else {\n             true"}, {"sha": "3596a8680ab1f29db90f104bbe51bf3ba8f1b7a0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2232321ac7d03ed8c1d191de0653d1c32db877d6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2232321ac7d03ed8c1d191de0653d1c32db877d6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2232321ac7d03ed8c1d191de0653d1c32db877d6", "patch": "@@ -3339,7 +3339,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 ty::Adt(base_def, substs) if !base_def.is_enum() => {\n                     debug!(\"struct named {:?}\",  base_t);\n                     let (ident, def_scope) =\n-                        self.tcx.adjust_ident(field, base_def.did, self.body_id);\n+                        self.tcx.adjust_ident_and_get_scope(field, base_def.did, self.body_id);\n                     let fields = &base_def.non_enum_variant().fields;\n                     if let Some(index) = fields.iter().position(|f| f.ident.modern() == ident) {\n                         let field = &fields[index];\n@@ -3510,7 +3510,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn available_field_names(&self, variant: &'tcx ty::VariantDef) -> Vec<ast::Name> {\n         variant.fields.iter().filter(|field| {\n-            let def_scope = self.tcx.adjust_ident(field.ident, variant.def_id, self.body_id).1;\n+            let def_scope =\n+                self.tcx.adjust_ident_and_get_scope(field.ident, variant.def_id, self.body_id).1;\n             field.vis.is_accessible_from(def_scope, self.tcx)\n         })\n         .map(|field| field.ident.name)\n@@ -3628,7 +3629,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Type-check each field.\n         for field in ast_fields {\n-            let ident = tcx.adjust_ident(field.ident, variant.def_id, self.body_id).0;\n+            let ident = tcx.adjust_ident(field.ident, variant.def_id);\n             let field_type = if let Some((i, v_field)) = remaining_fields.remove(&ident) {\n                 seen_fields.insert(ident, field.span);\n                 self.write_field_index(field.hir_id, i);"}]}