{"sha": "2aa3133c530b40ea0448d3c6a5507aeb40aaa558", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhYTMxMzNjNTMwYjQwZWEwNDQ4ZDNjNmE1NTA3YWViNDBhYWE1NTg=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-07-13T14:50:27Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-07-13T15:37:38Z"}, "message": "Add and fix BTreeMap comments", "tree": {"sha": "01f2924b941fd95a74d107191bcfd7382b7e1a2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01f2924b941fd95a74d107191bcfd7382b7e1a2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2aa3133c530b40ea0448d3c6a5507aeb40aaa558", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2aa3133c530b40ea0448d3c6a5507aeb40aaa558", "html_url": "https://github.com/rust-lang/rust/commit/2aa3133c530b40ea0448d3c6a5507aeb40aaa558", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2aa3133c530b40ea0448d3c6a5507aeb40aaa558/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d09331e00b02f81c714b0c41ce3a38380dd36a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d09331e00b02f81c714b0c41ce3a38380dd36a2", "html_url": "https://github.com/rust-lang/rust/commit/9d09331e00b02f81c714b0c41ce3a38380dd36a2"}], "stats": {"total": 43, "additions": 25, "deletions": 18}, "files": [{"sha": "f3781db1cf784ef9b32654f29cf7632d9f6a9135", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aa3133c530b40ea0448d3c6a5507aeb40aaa558/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa3133c530b40ea0448d3c6a5507aeb40aaa558/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=2aa3133c530b40ea0448d3c6a5507aeb40aaa558", "patch": "@@ -1697,6 +1697,8 @@ where\n     pred: F,\n     inner: DrainFilterInner<'a, K, V>,\n }\n+/// Most of the implementation of DrainFilter, independent of the type\n+/// of the predicate, thus also serving for BTreeSet::DrainFilter.\n pub(super) struct DrainFilterInner<'a, K: 'a, V: 'a> {\n     length: &'a mut usize,\n     cur_leaf_edge: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,"}, {"sha": "44f0e25bbd79888e770eaf1c98131a63750bbebf", "filename": "src/liballoc/collections/btree/navigate.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2aa3133c530b40ea0448d3c6a5507aeb40aaa558/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa3133c530b40ea0448d3c6a5507aeb40aaa558/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=2aa3133c530b40ea0448d3c6a5507aeb40aaa558", "patch": "@@ -161,15 +161,16 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n     /// Moves the leaf edge handle to the next leaf edge and returns the key and value\n     /// in between, while deallocating any node left behind.\n-    /// Unsafe for three reasons:\n+    /// Unsafe for two reasons:\n     /// - The caller must ensure that the leaf edge is not the last one in the tree\n     ///   and is not a handle previously resulting from counterpart `next_back_unchecked`.\n-    /// - If the leaf edge is the last edge of a node, that node and possibly ancestors\n+    /// - Further use of the updated leaf edge handle is very dangerous. In particular,\n+    ///   if the leaf edge is the last edge of a node, that node and possibly ancestors\n     ///   will be deallocated, while the reference to those nodes in the surviving ancestor\n-    ///   is left dangling; thus further use of the leaf edge handle is dangerous.\n-    ///   It is, however, safe to call this method again on the updated handle.\n-    ///   if the two preconditions above hold.\n-    /// - Using the updated handle may well invalidate the returned references.\n+    ///   is left dangling.\n+    ///   The only safe way to proceed with the updated handle is to compare it, drop it,\n+    ///   call this method again subject to both preconditions listed in the first point,\n+    ///   or call counterpart `next_back_unchecked` subject to its preconditions.\n     pub unsafe fn next_unchecked(&mut self) -> (K, V) {\n         unsafe {\n             replace(self, |leaf_edge| {\n@@ -183,15 +184,16 @@ impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n \n     /// Moves the leaf edge handle to the previous leaf edge and returns the key\n     /// and value in between, while deallocating any node left behind.\n-    /// Unsafe for three reasons:\n+    /// Unsafe for two reasons:\n     /// - The caller must ensure that the leaf edge is not the first one in the tree\n     ///   and is not a handle previously resulting from counterpart `next_unchecked`.\n-    /// - If the lead edge is the first edge of a node, that node and possibly ancestors\n+    /// - Further use of the updated leaf edge handle is very dangerous. In particular,\n+    ///   if the leaf edge is the first edge of a node, that node and possibly ancestors\n     ///   will be deallocated, while the reference to those nodes in the surviving ancestor\n-    ///   is left dangling; thus further use of the leaf edge handle is dangerous.\n-    ///   It is, however, safe to call this method again on the updated handle.\n-    ///   if the two preconditions above hold.\n-    /// - Using the updated handle may well invalidate the returned references.\n+    ///   is left dangling.\n+    ///   The only safe way to proceed with the updated handle is to compare it, drop it,\n+    ///   call this method again subject to both preconditions listed in the first point,\n+    ///   or call counterpart `next_unchecked` subject to its preconditions.\n     pub unsafe fn next_back_unchecked(&mut self) -> (K, V) {\n         unsafe {\n             replace(self, |leaf_edge| {"}, {"sha": "ce74d4f8ee688ec1e1933642d3f1f2f4fd1a1417", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2aa3133c530b40ea0448d3c6a5507aeb40aaa558/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa3133c530b40ea0448d3c6a5507aeb40aaa558/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=2aa3133c530b40ea0448d3c6a5507aeb40aaa558", "patch": "@@ -94,7 +94,8 @@ struct InternalNode<K, V> {\n     data: LeafNode<K, V>,\n \n     /// The pointers to the children of this node. `len + 1` of these are considered\n-    /// initialized and valid.\n+    /// initialized and valid. Although during the process of `into_iter` or `drop`,\n+    /// some pointers are dangling while others still need to be traversed.\n     edges: [MaybeUninit<BoxedNode<K, V>>; 2 * B],\n }\n \n@@ -408,7 +409,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n \n impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     /// Unsafely asserts to the compiler some static information about whether this\n-    /// node is a `Leaf`.\n+    /// node is a `Leaf` or an `Internal`.\n     unsafe fn cast_unchecked<NewType>(&mut self) -> NodeRef<marker::Mut<'_>, K, V, NewType> {\n         NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n     }\n@@ -515,7 +516,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n-    /// Adds a key/value pair the end of the node.\n+    /// Adds a key/value pair to the end of the node.\n     pub fn push(&mut self, key: K, val: V) {\n         assert!(self.len() < CAPACITY);\n \n@@ -602,8 +603,10 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n-    /// Removes a key/value pair from the end of this node. If this is an internal node,\n-    /// also removes the edge that was to the right of that pair.\n+    /// Removes a key/value pair from the end of this node and returns the pair.\n+    /// If this is an internal node, also removes the edge that was to the right\n+    /// of that pair and returns the orphaned node that this edge owned with its\n+    /// parent erased.\n     pub fn pop(&mut self) -> (K, V, Option<Root<K, V>>) {\n         assert!(self.len() > 0);\n \n@@ -883,7 +886,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n     }\n \n     /// Unsafely asserts to the compiler some static information about whether the underlying\n-    /// node of this handle is a `Leaf`.\n+    /// node of this handle is a `Leaf` or an `Internal`.\n     unsafe fn cast_unchecked<NewType>(\n         &mut self,\n     ) -> Handle<NodeRef<marker::Mut<'_>, K, V, NewType>, marker::Edge> {"}]}