{"sha": "695b3d8279e17689b988e000203ba95ffeb4a91c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NWIzZDgyNzllMTc2ODliOTg4ZTAwMDIwM2JhOTVmZmViNGE5MWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-11T08:58:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-11T08:58:48Z"}, "message": "Auto merge of #34866 - cynicaldevil:panic-counter, r=alexcrichton\n\nRefactored code to access TLS only in case of panic (II)\n\nFixes #34787\nr? @alexcrichton\nDo it **very** carefully this time!", "tree": {"sha": "2ead4208b3bcc7c6f990b8f34ecb83e4a96f9e1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ead4208b3bcc7c6f990b8f34ecb83e4a96f9e1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/695b3d8279e17689b988e000203ba95ffeb4a91c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/695b3d8279e17689b988e000203ba95ffeb4a91c", "html_url": "https://github.com/rust-lang/rust/commit/695b3d8279e17689b988e000203ba95ffeb4a91c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/695b3d8279e17689b988e000203ba95ffeb4a91c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1222f5d52ba0586d67c32a5bc4a3097eb9574aae", "url": "https://api.github.com/repos/rust-lang/rust/commits/1222f5d52ba0586d67c32a5bc4a3097eb9574aae", "html_url": "https://github.com/rust-lang/rust/commit/1222f5d52ba0586d67c32a5bc4a3097eb9574aae"}, {"sha": "ea2216cba88f225c758070fd457e321a58c63951", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea2216cba88f225c758070fd457e321a58c63951", "html_url": "https://github.com/rust-lang/rust/commit/ea2216cba88f225c758070fd457e321a58c63951"}], "stats": {"total": 63, "additions": 40, "deletions": 23}, "files": [{"sha": "c05e0c3ca68dfeea25c7ba5c56a57fd65c00fed1", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/695b3d8279e17689b988e000203ba95ffeb4a91c/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695b3d8279e17689b988e000203ba95ffeb4a91c/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=695b3d8279e17689b988e000203ba95ffeb4a91c", "patch": "@@ -278,6 +278,7 @@\n #![feature(unwind_attributes)]\n #![feature(vec_push_all)]\n #![feature(zero_one)]\n+#![cfg_attr(test, feature(update_panic_count))]\n \n // Issue# 30592: Systematically use alloc_system during stage0 since jemalloc\n // might be unavailable or disabled"}, {"sha": "2f67081e0d71093c29625a4de7c292112cca4dad", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/695b3d8279e17689b988e000203ba95ffeb4a91c/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695b3d8279e17689b988e000203ba95ffeb4a91c/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=695b3d8279e17689b988e000203ba95ffeb4a91c", "patch": "@@ -340,5 +340,5 @@ pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n /// ```\n #[stable(feature = \"resume_unwind\", since = \"1.9.0\")]\n pub fn resume_unwind(payload: Box<Any + Send>) -> ! {\n-    panicking::rust_panic(payload)\n+    panicking::update_count_then_panic(payload)\n }"}, {"sha": "8c1567939fb37caea977653bf5e6e4148ea3662b", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/695b3d8279e17689b988e000203ba95ffeb4a91c/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695b3d8279e17689b988e000203ba95ffeb4a91c/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=695b3d8279e17689b988e000203ba95ffeb4a91c", "patch": "@@ -21,7 +21,6 @@ use prelude::v1::*;\n use io::prelude::*;\n \n use any::Any;\n-use cell::Cell;\n use cell::RefCell;\n use fmt;\n use intrinsics;\n@@ -39,8 +38,6 @@ thread_local! {\n     }\n }\n \n-thread_local! { pub static PANIC_COUNT: Cell<usize> = Cell::new(0) }\n-\n // Binary interface to the panic runtime that the standard library depends on.\n //\n // The standard library is tagged with `#![needs_panic_runtime]` (introduced in\n@@ -187,7 +184,7 @@ fn default_hook(info: &PanicInfo) {\n     // for this panic. Otherwise only print it if logging is enabled.\n     #[cfg(any(not(cargobuild), feature = \"backtrace\"))]\n     let log_backtrace = {\n-        let panics = PANIC_COUNT.with(|c| c.get());\n+        let panics = update_panic_count(0);\n \n         panics >= 2 || backtrace::log_enabled()\n     };\n@@ -238,14 +235,31 @@ fn default_hook(info: &PanicInfo) {\n     }\n }\n \n+\n+#[cfg(not(test))]\n+#[doc(hidden)]\n+#[unstable(feature = \"update_panic_count\", issue = \"0\")]\n+pub fn update_panic_count(amt: isize) -> usize {\n+    use cell::Cell;\n+    thread_local! { static PANIC_COUNT: Cell<usize> = Cell::new(0) }\n+\n+    PANIC_COUNT.with(|c| {\n+        let next = (c.get() as isize + amt) as usize;\n+        c.set(next);\n+        return next\n+    })\n+}\n+\n+#[cfg(test)]\n+pub use realstd::rt::update_panic_count;\n+\n /// Invoke a closure, capturing the cause of an unwinding panic if one occurs.\n pub unsafe fn try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<Any + Send>> {\n     let mut slot = None;\n     let mut f = Some(f);\n-    let ret = PANIC_COUNT.with(|s| {\n-        let prev = s.get();\n-        s.set(0);\n+    let ret;\n \n+    {\n         let mut to_run = || {\n             slot = Some(f.take().unwrap()());\n         };\n@@ -258,18 +272,18 @@ pub unsafe fn try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<Any + Send>> {\n                                          dataptr,\n                                          &mut any_data,\n                                          &mut any_vtable);\n-        s.set(prev);\n-\n         if r == 0 {\n-            Ok(())\n+            ret = Ok(());\n         } else {\n-            Err(mem::transmute(raw::TraitObject {\n+            update_panic_count(-1);\n+            ret = Err(mem::transmute(raw::TraitObject {\n                 data: any_data as *mut _,\n                 vtable: any_vtable as *mut _,\n-            }))\n+            }));\n         }\n-    });\n+    }\n \n+    debug_assert!(update_panic_count(0) == 0);\n     return ret.map(|()| {\n         slot.take().unwrap()\n     });\n@@ -285,7 +299,7 @@ pub unsafe fn try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<Any + Send>> {\n \n /// Determines whether the current thread is unwinding because of panic.\n pub fn panicking() -> bool {\n-    PANIC_COUNT.with(|c| c.get() != 0)\n+    update_panic_count(0) != 0\n }\n \n /// Entry point of panic from the libcore crate.\n@@ -350,18 +364,14 @@ fn rust_panic_with_hook(msg: Box<Any + Send>,\n                         file_line: &(&'static str, u32)) -> ! {\n     let (file, line) = *file_line;\n \n-    let panics = PANIC_COUNT.with(|c| {\n-        let prev = c.get();\n-        c.set(prev + 1);\n-        prev\n-    });\n+    let panics = update_panic_count(1);\n \n     // If this is the third nested call (e.g. panics == 2, this is 0-indexed),\n     // the panic hook probably triggered the last panic, otherwise the\n     // double-panic check would have aborted the process. In this case abort the\n     // process real quickly as we don't want to try calling it again as it'll\n     // probably just panic again.\n-    if panics > 1 {\n+    if panics > 2 {\n         util::dumb_print(format_args!(\"thread panicked while processing \\\n                                        panic. aborting.\\n\"));\n         unsafe { intrinsics::abort() }\n@@ -383,7 +393,7 @@ fn rust_panic_with_hook(msg: Box<Any + Send>,\n         HOOK_LOCK.read_unlock();\n     }\n \n-    if panics > 0 {\n+    if panics > 1 {\n         // If a thread panics while it's already unwinding then we\n         // have limited options. Currently our preference is to\n         // just abort. In the future we may consider resuming\n@@ -396,6 +406,12 @@ fn rust_panic_with_hook(msg: Box<Any + Send>,\n     rust_panic(msg)\n }\n \n+/// Shim around rust_panic. Called by resume_unwind.\n+pub fn update_count_then_panic(msg: Box<Any + Send>) -> ! {\n+    update_panic_count(1);\n+    rust_panic(msg)\n+}\n+\n /// A private no-mangle function on which to slap yer breakpoints.\n #[no_mangle]\n #[allow(private_no_mangle_fns)] // yes we get it, but we like breakpoints"}, {"sha": "a3d9e4db7d19a4b0927b5e30356b813c412438d7", "filename": "src/libstd/rt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/695b3d8279e17689b988e000203ba95ffeb4a91c/src%2Flibstd%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695b3d8279e17689b988e000203ba95ffeb4a91c/src%2Flibstd%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt.rs?ref=695b3d8279e17689b988e000203ba95ffeb4a91c", "patch": "@@ -25,7 +25,7 @@\n \n \n // Reexport some of our utilities which are expected by other crates.\n-pub use panicking::{begin_panic, begin_panic_fmt};\n+pub use panicking::{begin_panic, begin_panic_fmt, update_panic_count};\n \n #[cfg(not(test))]\n #[lang = \"start\"]"}]}