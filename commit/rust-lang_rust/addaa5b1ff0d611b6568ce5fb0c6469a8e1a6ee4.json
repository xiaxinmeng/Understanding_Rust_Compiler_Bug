{"sha": "addaa5b1ff0d611b6568ce5fb0c6469a8e1a6ee4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkZGFhNWIxZmYwZDYxMWI2NTY4Y2U1ZmIwYzY0NjlhOGUxYTZlZTQ=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2015-06-05T15:40:09Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2015-06-06T10:37:10Z"}, "message": "Add complex (but unconditional) Unicode case mapping. Fix #25800\n\nAs a result, the iterator returned by `char::to_uppercase` sometimes\nyields two or three `char`s instead of just one.", "tree": {"sha": "20a8a7b4166eca318f337595e987fb3879ea4ac8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20a8a7b4166eca318f337595e987fb3879ea4ac8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/addaa5b1ff0d611b6568ce5fb0c6469a8e1a6ee4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/addaa5b1ff0d611b6568ce5fb0c6469a8e1a6ee4", "html_url": "https://github.com/rust-lang/rust/commit/addaa5b1ff0d611b6568ce5fb0c6469a8e1a6ee4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/addaa5b1ff0d611b6568ce5fb0c6469a8e1a6ee4/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66af12721a3200f872adf38e0015e22db88cd86e", "url": "https://api.github.com/repos/rust-lang/rust/commits/66af12721a3200f872adf38e0015e22db88cd86e", "html_url": "https://github.com/rust-lang/rust/commit/66af12721a3200f872adf38e0015e22db88cd86e"}], "stats": {"total": 1824, "additions": 1154, "deletions": 670}, "files": [{"sha": "dc11759138bd6d782bd36ca36e2ee78a86009e4a", "filename": "src/etc/unicode.py", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/addaa5b1ff0d611b6568ce5fb0c6469a8e1a6ee4/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/addaa5b1ff0d611b6568ce5fb0c6469a8e1a6ee4/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=addaa5b1ff0d611b6568ce5fb0c6469a8e1a6ee4", "patch": "@@ -104,11 +104,11 @@ def load_unicode_data(f):\n         # generate char to char direct common and simple conversions\n         # uppercase to lowercase\n         if lowcase != \"\" and code_org != lowcase:\n-            to_lower[code] = int(lowcase, 16)\n+            to_lower[code] = (int(lowcase, 16), 0, 0)\n \n         # lowercase to uppercase\n         if upcase != \"\" and code_org != upcase:\n-            to_upper[code] = int(upcase, 16)\n+            to_upper[code] = (int(upcase, 16), 0, 0)\n \n         # store decomposition, if given\n         if decomp != \"\":\n@@ -146,6 +146,31 @@ def load_unicode_data(f):\n \n     return (canon_decomp, compat_decomp, gencats, combines, to_upper, to_lower)\n \n+def load_special_casing(f, to_upper, to_lower):\n+    fetch(f)\n+    for line in fileinput.input(f):\n+        data = line.split('#')[0].split(';')\n+        if len(data) == 5:\n+            code, lower, title, upper, _comment = data\n+        elif len(data) == 6:\n+            code, lower, title, upper, condition, _comment = data\n+            if condition.strip():  # Only keep unconditional mappins\n+                continue\n+        else:\n+            continue\n+        code = code.strip()\n+        lower = lower.strip()\n+        title = title.strip()\n+        upper = upper.strip()\n+        key = int(code, 16)\n+        for (map_, values) in [(to_lower, lower), (to_upper, upper)]:\n+            if values != code:\n+                values = [int(i, 16) for i in values.split()]\n+                for _ in range(len(values), 3):\n+                    values.append(0)\n+                assert len(values) == 3\n+                map_[key] = values\n+\n def group_cats(cats):\n     cats_out = {}\n     for cat in cats:\n@@ -279,7 +304,7 @@ def load_east_asian_width(want_widths, except_cats):\n     return widths\n \n def escape_char(c):\n-    return \"'\\\\u{%x}'\" % c\n+    return \"'\\\\u{%x}'\" % c if c != 0 else \"'\\\\0'\"\n \n def emit_bsearch_range_table(f):\n     f.write(\"\"\"\n@@ -328,21 +353,21 @@ def emit_conversions_module(f, to_upper, to_lower):\n     use core::option::Option::{Some, None};\n     use core::result::Result::{Ok, Err};\n \n-    pub fn to_lower(c: char) -> char {\n+    pub fn to_lower(c: char) -> [char; 3] {\n         match bsearch_case_table(c, to_lowercase_table) {\n-          None        => c,\n+          None        => [c, '\\\\0', '\\\\0'],\n           Some(index) => to_lowercase_table[index].1\n         }\n     }\n \n-    pub fn to_upper(c: char) -> char {\n+    pub fn to_upper(c: char) -> [char; 3] {\n         match bsearch_case_table(c, to_uppercase_table) {\n-            None        => c,\n+            None        => [c, '\\\\0', '\\\\0'],\n             Some(index) => to_uppercase_table[index].1\n         }\n     }\n \n-    fn bsearch_case_table(c: char, table: &'static [(char, char)]) -> Option<usize> {\n+    fn bsearch_case_table(c: char, table: &'static [(char, [char; 3])]) -> Option<usize> {\n         match table.binary_search_by(|&(key, _)| {\n             if c == key { Equal }\n             else if key < c { Less }\n@@ -355,9 +380,17 @@ def emit_conversions_module(f, to_upper, to_lower):\n \n \"\"\")\n     emit_table(f, \"to_lowercase_table\",\n-        sorted(to_lower.iteritems(), key=operator.itemgetter(0)), is_pub=False)\n+        sorted(to_lower.iteritems(), key=operator.itemgetter(0)),\n+        is_pub=False,\n+        t_type = \"&'static [(char, [char; 3])]\",\n+        pfun=lambda x: \"(%s,[%s,%s,%s])\" % (\n+            escape_char(x[0]), escape_char(x[1][0]), escape_char(x[1][1]), escape_char(x[1][2])))\n     emit_table(f, \"to_uppercase_table\",\n-        sorted(to_upper.iteritems(), key=operator.itemgetter(0)), is_pub=False)\n+        sorted(to_upper.iteritems(), key=operator.itemgetter(0)),\n+        is_pub=False,\n+        t_type = \"&'static [(char, [char; 3])]\",\n+        pfun=lambda x: \"(%s,[%s,%s,%s])\" % (\n+            escape_char(x[0]), escape_char(x[1][0]), escape_char(x[1][1]), escape_char(x[1][2])))\n     f.write(\"}\\n\\n\")\n \n def emit_grapheme_module(f, grapheme_table, grapheme_cats):\n@@ -592,6 +625,7 @@ def optimize_width_table(wtable):\n \"\"\" % unicode_version)\n         (canon_decomp, compat_decomp, gencats, combines,\n                 to_upper, to_lower) = load_unicode_data(\"UnicodeData.txt\")\n+        load_special_casing(\"SpecialCasing.txt\", to_upper, to_lower)\n         want_derived = [\"XID_Start\", \"XID_Continue\", \"Alphabetic\", \"Lowercase\", \"Uppercase\"]\n         derived = load_properties(\"DerivedCoreProperties.txt\", want_derived)\n         scripts = load_properties(\"Scripts.txt\", [])"}, {"sha": "d70acbb8a8ec499deff322ace6b78cc769dc7862", "filename": "src/libcollectionstest/char.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/addaa5b1ff0d611b6568ce5fb0c6469a8e1a6ee4/src%2Flibcollectionstest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/addaa5b1ff0d611b6568ce5fb0c6469a8e1a6ee4/src%2Flibcollectionstest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fchar.rs?ref=addaa5b1ff0d611b6568ce5fb0c6469a8e1a6ee4", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use collections::vec::Vec;\n+\n+#[test]\n+fn char_to_lowercase() {\n+    assert_iter_eq('A'.to_lowercase(), &['a']);\n+    assert_iter_eq('\u00c9'.to_lowercase(), &['\u00e9']);\n+    assert_iter_eq('\u01c5'.to_lowercase(), &['\u01c6']);\n+}\n+\n+#[test]\n+fn char_to_uppercase() {\n+    assert_iter_eq('a'.to_uppercase(), &['A']);\n+    assert_iter_eq('\u00e9'.to_uppercase(), &['\u00c9']);\n+    assert_iter_eq('\u01c5'.to_uppercase(), &['\u01c4']);\n+    assert_iter_eq('\u00df'.to_uppercase(), &['S', 'S']);\n+    assert_iter_eq('\ufb01'.to_uppercase(), &['F', 'I']);\n+    assert_iter_eq('\u1f80'.to_uppercase(), &['\u1f08', '\u0399']);\n+}\n+\n+fn assert_iter_eq<I: Iterator<Item=char>>(iter: I, expected: &[char]) {\n+    assert_eq!(iter.collect::<Vec<_>>(), expected);\n+}"}, {"sha": "95794ae211b5cc66d0d14a06189a1462db9cca08", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/addaa5b1ff0d611b6568ce5fb0c6469a8e1a6ee4/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/addaa5b1ff0d611b6568ce5fb0c6469a8e1a6ee4/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=addaa5b1ff0d611b6568ce5fb0c6469a8e1a6ee4", "patch": "@@ -37,6 +37,7 @@ extern crate rustc_unicode;\n mod binary_heap;\n mod bit;\n mod btree;\n+mod char;  // char isn't really a collection, but didn't find a better place for this.\n mod enum_set;\n mod fmt;\n mod linked_list;"}, {"sha": "168d2364806c3fd01fb252d72c68de3fdd813431", "filename": "src/librustc_unicode/char.rs", "status": "modified", "additions": 60, "deletions": 17, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/addaa5b1ff0d611b6568ce5fb0c6469a8e1a6ee4/src%2Flibrustc_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/addaa5b1ff0d611b6568ce5fb0c6469a8e1a6ee4/src%2Flibrustc_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fchar.rs?ref=addaa5b1ff0d611b6568ce5fb0c6469a8e1a6ee4", "patch": "@@ -29,7 +29,7 @@\n #![doc(primitive = \"char\")]\n \n use core::char::CharExt as C;\n-use core::option::Option::{self, Some};\n+use core::option::Option::{self, Some, None};\n use core::iter::Iterator;\n use tables::{derived_property, property, general_category, conversions, charwidth};\n \n@@ -47,24 +47,67 @@ pub use tables::UNICODE_VERSION;\n /// the [`to_lowercase` method](../primitive.char.html#method.to_lowercase) on\n /// characters.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct ToLowercase(Option<char>);\n+pub struct ToLowercase(CaseMappingIter);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for ToLowercase {\n     type Item = char;\n-    fn next(&mut self) -> Option<char> { self.0.take() }\n+    fn next(&mut self) -> Option<char> { self.0.next() }\n }\n \n /// An iterator over the uppercase mapping of a given character, returned from\n /// the [`to_uppercase` method](../primitive.char.html#method.to_uppercase) on\n /// characters.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct ToUppercase(Option<char>);\n+pub struct ToUppercase(CaseMappingIter);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for ToUppercase {\n     type Item = char;\n-    fn next(&mut self) -> Option<char> { self.0.take() }\n+    fn next(&mut self) -> Option<char> { self.0.next() }\n+}\n+\n+\n+enum CaseMappingIter {\n+    Three(char, char, char),\n+    Two(char, char),\n+    One(char),\n+    Zero\n+}\n+\n+impl CaseMappingIter {\n+    fn new(chars: [char; 3]) -> CaseMappingIter {\n+        if chars[2] == '\\0' {\n+            if chars[1] == '\\0' {\n+                CaseMappingIter::One(chars[0])  // Including if chars[0] == '\\0'\n+            } else {\n+                CaseMappingIter::Two(chars[0], chars[1])\n+            }\n+        } else {\n+            CaseMappingIter::Three(chars[0], chars[1], chars[2])\n+        }\n+    }\n+}\n+\n+impl Iterator for CaseMappingIter {\n+    type Item = char;\n+    fn next(&mut self) -> Option<char> {\n+        match *self {\n+            CaseMappingIter::Three(a, b, c) => {\n+                *self = CaseMappingIter::Two(b, c);\n+                Some(a)\n+            }\n+            CaseMappingIter::Two(b, c) => {\n+                *self = CaseMappingIter::One(c);\n+                Some(b)\n+            }\n+            CaseMappingIter::One(c) => {\n+                *self = CaseMappingIter::Zero;\n+                Some(c)\n+            }\n+            CaseMappingIter::Zero => None,\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -397,45 +440,45 @@ impl char {\n \n     /// Converts a character to its lowercase equivalent.\n     ///\n-    /// The case-folding performed is the common or simple mapping. See\n-    /// `to_uppercase()` for references and more information.\n+    /// This performs complex unconditional mappings with no tailoring.\n+    /// See `to_uppercase()` for references and more information.\n     ///\n     /// # Return value\n     ///\n     /// Returns an iterator which yields the characters corresponding to the\n     /// lowercase equivalent of the character. If no conversion is possible then\n-    /// the input character is returned.\n+    /// an iterator with just the input character is returned.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn to_lowercase(self) -> ToLowercase {\n-        ToLowercase(Some(conversions::to_lower(self)))\n+        ToLowercase(CaseMappingIter::new(conversions::to_lower(self)))\n     }\n \n     /// Converts a character to its uppercase equivalent.\n     ///\n-    /// The case-folding performed is the common or simple mapping: it maps\n-    /// one Unicode codepoint to its uppercase equivalent according to the\n-    /// Unicode database [1]. The additional [`SpecialCasing.txt`] is not yet\n-    /// considered here, but the iterator returned will soon support this form\n-    /// of case folding.\n+    /// This performs complex unconditional mappings with no tailoring:\n+    /// it maps one Unicode character to its uppercase equivalent\n+    /// according to the Unicode database [1]\n+    /// and the additional complex mappings [`SpecialCasing.txt`].\n+    /// Conditional mappings (based on context or language) are not considerd here.\n     ///\n     /// A full reference can be found here [2].\n     ///\n     /// # Return value\n     ///\n     /// Returns an iterator which yields the characters corresponding to the\n     /// uppercase equivalent of the character. If no conversion is possible then\n-    /// the input character is returned.\n+    /// an iterator with just the input character is returned.\n     ///\n     /// [1]: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n     ///\n     /// [`SpecialCasing.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n     ///\n-    /// [2]: http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992\n+    /// [2]: http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn to_uppercase(self) -> ToUppercase {\n-        ToUppercase(Some(conversions::to_upper(self)))\n+        ToUppercase(CaseMappingIter::new(conversions::to_upper(self)))\n     }\n \n     /// Returns this character's displayed width in columns, or `None` if it is a"}, {"sha": "7ea8e410e99caa1aa85fa9ea0dccab4e66304fe4", "filename": "src/librustc_unicode/tables.rs", "status": "modified", "additions": 1017, "deletions": 643, "changes": 1660, "blob_url": "https://github.com/rust-lang/rust/blob/addaa5b1ff0d611b6568ce5fb0c6469a8e1a6ee4/src%2Flibrustc_unicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/addaa5b1ff0d611b6568ce5fb0c6469a8e1a6ee4/src%2Flibrustc_unicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Ftables.rs?ref=addaa5b1ff0d611b6568ce5fb0c6469a8e1a6ee4"}]}