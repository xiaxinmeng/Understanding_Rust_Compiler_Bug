{"sha": "8786405047cadcfb5ec3a2d711ca264d74843c13", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3ODY0MDUwNDdjYWRjZmI1ZWMzYTJkNzExY2EyNjRkNzQ4NDNjMTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-23T11:36:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-23T11:36:56Z"}, "message": "auto merge of #12416 : alexcrichton/rust/highlight, r=huonw\n\nThis adds simple syntax highlighting based off libsyntax's lexer to be sure to\r\nstay up to date with rust's grammar. Some of the highlighting is a bit ad-hoc,\r\nbut it definitely seems to get the job done!\r\n\r\nThis currently doesn't highlight rustdoc-rendered function signatures and\r\nstructs that are emitted to each page because the colors already signify what's\r\nclickable and I think we'd have to figure out a different scheme before\r\ncolorizing them. This does, however, colorize all code examples and source code.\r\n\r\nCloses #11393", "tree": {"sha": "41f9c244921aa3a5fe2c2a71cad94bea26b99553", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41f9c244921aa3a5fe2c2a71cad94bea26b99553"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8786405047cadcfb5ec3a2d711ca264d74843c13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8786405047cadcfb5ec3a2d711ca264d74843c13", "html_url": "https://github.com/rust-lang/rust/commit/8786405047cadcfb5ec3a2d711ca264d74843c13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8786405047cadcfb5ec3a2d711ca264d74843c13/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "551da0615764853153db944063ae2e271414a71b", "url": "https://api.github.com/repos/rust-lang/rust/commits/551da0615764853153db944063ae2e271414a71b", "html_url": "https://github.com/rust-lang/rust/commit/551da0615764853153db944063ae2e271414a71b"}, {"sha": "ad9e26dab3ae8f5d739e89167338bc97b99905b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad9e26dab3ae8f5d739e89167338bc97b99905b7", "html_url": "https://github.com/rust-lang/rust/commit/ad9e26dab3ae8f5d739e89167338bc97b99905b7"}], "stats": {"total": 265, "additions": 239, "deletions": 26}, "files": [{"sha": "40b892cd9b48bde2885d4a454876fb0b9fbc60c5", "filename": "src/librustdoc/html/highlight.rs", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/8786405047cadcfb5ec3a2d711ca264d74843c13/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8786405047cadcfb5ec3a2d711ca264d74843c13/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=8786405047cadcfb5ec3a2d711ca264d74843c13", "patch": "@@ -0,0 +1,174 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Basic html highlighting functionality\n+//!\n+//! This module uses libsyntax's lexer to provide token-based highlighting for\n+//! the HTML documentation generated by rustdoc.\n+\n+use std::str;\n+use std::io;\n+\n+use syntax::parse;\n+use syntax::parse::lexer;\n+use syntax::diagnostic;\n+use syntax::codemap::{BytePos, Span};\n+\n+use html::escape::Escape;\n+\n+use t = syntax::parse::token;\n+\n+/// Highlights some source code, returning the HTML output.\n+pub fn highlight(src: &str) -> ~str {\n+    let sess = parse::new_parse_sess();\n+    let handler = diagnostic::mk_handler();\n+    let span_handler = diagnostic::mk_span_handler(handler, sess.cm);\n+    let fm = parse::string_to_filemap(sess, src.to_owned(), ~\"<stdin>\");\n+\n+    let mut out = io::MemWriter::new();\n+    doit(sess,\n+         lexer::new_string_reader(span_handler, fm),\n+         &mut out).unwrap();\n+    str::from_utf8_lossy(out.unwrap()).into_owned()\n+}\n+\n+/// Exhausts the `lexer` writing the output into `out`.\n+///\n+/// The general structure for this method is to iterate over each token,\n+/// possibly giving it an HTML span with a class specifying what flavor of token\n+/// it's used. All source code emission is done as slices from the source map,\n+/// not from the tokens themselves, in order to stay true to the original\n+/// source.\n+fn doit(sess: @parse::ParseSess, lexer: lexer::StringReader,\n+        out: &mut Writer) -> io::IoResult<()> {\n+    use syntax::parse::lexer::Reader;\n+\n+    try!(write!(out, \"<pre class='rust'>\\n\"));\n+    let mut last = BytePos(0);\n+    let mut is_attribute = false;\n+    let mut is_macro = false;\n+    loop {\n+        let next = lexer.next_token();\n+        let test = if next.tok == t::EOF {lexer.pos.get()} else {next.sp.lo};\n+\n+        // The lexer consumes all whitespace and non-doc-comments when iterating\n+        // between tokens. If this token isn't directly adjacent to our last\n+        // token, then we need to emit the whitespace/comment.\n+        //\n+        // If the gap has any '/' characters then we consider the whole thing a\n+        // comment. This will classify some whitespace as a comment, but that\n+        // doesn't matter too much for syntax highlighting purposes.\n+        if test > last {\n+            let snip = sess.cm.span_to_snippet(Span {\n+                lo: last,\n+                hi: test,\n+                expn_info: None,\n+            }).unwrap();\n+            if snip.contains(\"/\") {\n+                try!(write!(out, \"<span class='comment'>{}</span>\",\n+                              Escape(snip)));\n+            } else {\n+                try!(write!(out, \"{}\", Escape(snip)));\n+            }\n+        }\n+        last = next.sp.hi;\n+        if next.tok == t::EOF { break }\n+\n+        let klass = match next.tok {\n+            // If this '&' token is directly adjacent to another token, assume\n+            // that it's the address-of operator instead of the and-operator.\n+            // This allows us to give all pointers their own class (~ and @ are\n+            // below).\n+            t::BINOP(t::AND) if lexer.peek().sp.lo == next.sp.hi => \"kw-2\",\n+            t::AT | t::TILDE => \"kw-2\",\n+\n+            // consider this as part of a macro invocation if there was a\n+            // leading identifier\n+            t::NOT if is_macro => { is_macro = false; \"macro\" }\n+\n+            // operators\n+            t::EQ | t::LT | t::LE | t::EQEQ | t::NE | t::GE | t::GT |\n+                t::ANDAND | t::OROR | t::NOT | t::BINOP(..) | t::RARROW |\n+                t::BINOPEQ(..) | t::FAT_ARROW => \"op\",\n+\n+            // miscellaneous, no highlighting\n+            t::DOT | t::DOTDOT | t::DOTDOTDOT | t::COMMA | t::SEMI |\n+                t::COLON | t::MOD_SEP | t::LARROW | t::DARROW | t::LPAREN |\n+                t::RPAREN | t::LBRACKET | t::LBRACE | t::RBRACE |\n+                t::DOLLAR => \"\",\n+\n+            // This is the start of an attribute. We're going to want to\n+            // continue highlighting it as an attribute until the ending ']' is\n+            // seen, so skip out early. Down below we terminate the attribute\n+            // span when we see the ']'.\n+            t::POUND => {\n+                is_attribute = true;\n+                try!(write!(out, r\"<span class='attribute'>\\#\"));\n+                continue\n+            }\n+            t::RBRACKET => {\n+                if is_attribute {\n+                    is_attribute = false;\n+                    try!(write!(out, \"]</span>\"));\n+                    continue\n+                } else {\n+                    \"\"\n+                }\n+            }\n+\n+            // text literals\n+            t::LIT_CHAR(..) | t::LIT_STR(..) | t::LIT_STR_RAW(..) => \"string\",\n+\n+            // number literals\n+            t::LIT_INT(..) | t::LIT_UINT(..) | t::LIT_INT_UNSUFFIXED(..) |\n+                t::LIT_FLOAT(..) | t::LIT_FLOAT_UNSUFFIXED(..) => \"number\",\n+\n+            // keywords are also included in the identifier set\n+            t::IDENT(ident, _is_mod_sep) => {\n+                match t::get_ident(ident).get() {\n+                    \"ref\" | \"mut\" => \"kw-2\",\n+\n+                    \"self\" => \"self\",\n+                    \"false\" | \"true\" => \"boolval\",\n+\n+                    \"Option\" | \"Result\" => \"prelude-ty\",\n+                    \"Some\" | \"None\" | \"Ok\" | \"Err\" => \"prelude-val\",\n+\n+                    _ if t::is_any_keyword(&next.tok) => \"kw\",\n+                    _ => {\n+                        if lexer.peek().tok == t::NOT {\n+                            is_macro = true;\n+                            \"macro\"\n+                        } else {\n+                            \"ident\"\n+                        }\n+                    }\n+                }\n+            }\n+\n+            t::LIFETIME(..) => \"lifetime\",\n+            t::DOC_COMMENT(..) => \"doccomment\",\n+            t::UNDERSCORE | t::EOF | t::INTERPOLATED(..) => \"\",\n+        };\n+\n+        // as mentioned above, use the original source code instead of\n+        // stringifying this token\n+        let snip = sess.cm.span_to_snippet(next.sp).unwrap();\n+        if klass == \"\" {\n+            try!(write!(out, \"{}\", Escape(snip)));\n+        } else {\n+            try!(write!(out, \"<span class='{}'>{}</span>\", klass,\n+                          Escape(snip)));\n+        }\n+    }\n+\n+    write!(out, \"</pre>\\n\")\n+}\n+"}, {"sha": "2ad5bfb6e44b208a82d9a25d68a1667320a20333", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8786405047cadcfb5ec3a2d711ca264d74843c13/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8786405047cadcfb5ec3a2d711ca264d74843c13/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=8786405047cadcfb5ec3a2d711ca264d74843c13", "patch": "@@ -35,6 +35,8 @@ use std::str;\n use std::intrinsics;\n use std::vec;\n \n+use html::highlight;\n+\n /// A unit struct which has the `fmt::Show` trait implemented. When\n /// formatted, this struct will emit the HTML corresponding to the rendered\n /// version of the contained markdown string.\n@@ -95,6 +97,7 @@ extern {\n     fn sd_markdown_free(md: *sd_markdown);\n \n     fn bufnew(unit: libc::size_t) -> *buf;\n+    fn bufputs(b: *buf, c: *libc::c_char);\n     fn bufrelease(b: *buf);\n \n }\n@@ -127,7 +130,27 @@ pub fn render(w: &mut io::Writer, s: &str) -> fmt::Result {\n                     asize: text.len() as libc::size_t,\n                     unit: 0,\n                 };\n-                (my_opaque.dfltblk)(ob, &buf, lang, opaque);\n+                let rendered = if lang.is_null() {\n+                    false\n+                } else {\n+                    vec::raw::buf_as_slice((*lang).data,\n+                                           (*lang).size as uint, |rlang| {\n+                        let rlang = str::from_utf8(rlang).unwrap();\n+                        if rlang.contains(\"notrust\") {\n+                            (my_opaque.dfltblk)(ob, &buf, lang, opaque);\n+                            true\n+                        } else {\n+                            false\n+                        }\n+                    })\n+                };\n+\n+                if !rendered {\n+                    let output = highlight::highlight(text).to_c_str();\n+                    output.with_ref(|r| {\n+                        bufputs(ob, r)\n+                    })\n+                }\n             })\n         }\n     }\n@@ -181,7 +204,8 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n                 vec::raw::buf_as_slice((*lang).data,\n                                        (*lang).size as uint, |lang| {\n                     let s = str::from_utf8(lang).unwrap();\n-                    (s.contains(\"should_fail\"), s.contains(\"ignore\"))\n+                    (s.contains(\"should_fail\"), s.contains(\"ignore\") ||\n+                                                s.contains(\"notrust\"))\n                 })\n             };\n             if ignore { return }"}, {"sha": "040d2b3b914dc3d58876b0e72f509e9f8cd7e159", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8786405047cadcfb5ec3a2d711ca264d74843c13/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8786405047cadcfb5ec3a2d711ca264d74843c13/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=8786405047cadcfb5ec3a2d711ca264d74843c13", "patch": "@@ -50,10 +50,10 @@ use syntax::parse::token::InternedString;\n use clean;\n use doctree;\n use fold::DocFolder;\n-use html::escape::Escape;\n use html::format::{VisSpace, Method, PuritySpace};\n use html::layout;\n use html::markdown::Markdown;\n+use html::highlight;\n \n /// Major driving force in all rustdoc rendering. This contains information\n /// about where in the tree-like hierarchy rendering is occurring and controls\n@@ -1091,7 +1091,8 @@ fn item_module(w: &mut Writer, cx: &Context,\n \n fn item_function(w: &mut Writer, it: &clean::Item,\n                  f: &clean::Function) -> fmt::Result {\n-    try!(write!(w, \"<pre class='fn'>{vis}{purity}fn {name}{generics}{decl}</pre>\",\n+    try!(write!(w, \"<pre class='rust fn'>{vis}{purity}fn \\\n+                    {name}{generics}{decl}</pre>\",\n            vis = VisSpace(it.visibility),\n            purity = PuritySpace(f.purity),\n            name = it.name.get_ref().as_slice(),\n@@ -1112,7 +1113,7 @@ fn item_trait(w: &mut Writer, it: &clean::Item,\n     }\n \n     // Output the trait definition\n-    try!(write!(w, \"<pre class='trait'>{}trait {}{}{} \",\n+    try!(write!(w, \"<pre class='rust trait'>{}trait {}{}{} \",\n                   VisSpace(it.visibility),\n                   it.name.get_ref().as_slice(),\n                   t.generics,\n@@ -1231,7 +1232,7 @@ fn render_method(w: &mut Writer, meth: &clean::Item) -> fmt::Result {\n \n fn item_struct(w: &mut Writer, it: &clean::Item,\n                s: &clean::Struct) -> fmt::Result {\n-    try!(write!(w, \"<pre class='struct'>\"));\n+    try!(write!(w, \"<pre class='rust struct'>\"));\n     try!(render_struct(w, it, Some(&s.generics), s.struct_type, s.fields,\n                          s.fields_stripped, \"\", true));\n     try!(write!(w, \"</pre>\"));\n@@ -1255,7 +1256,7 @@ fn item_struct(w: &mut Writer, it: &clean::Item,\n }\n \n fn item_enum(w: &mut Writer, it: &clean::Item, e: &clean::Enum) -> fmt::Result {\n-    try!(write!(w, \"<pre class='enum'>{}enum {}{}\",\n+    try!(write!(w, \"<pre class='rust enum'>{}enum {}{}\",\n                   VisSpace(it.visibility),\n                   it.name.get_ref().as_slice(),\n                   e.generics));\n@@ -1532,7 +1533,7 @@ fn render_impl(w: &mut Writer, i: &clean::Impl,\n \n fn item_typedef(w: &mut Writer, it: &clean::Item,\n                 t: &clean::Typedef) -> fmt::Result {\n-    try!(write!(w, \"<pre class='typedef'>type {}{} = {};</pre>\",\n+    try!(write!(w, \"<pre class='rust typedef'>type {}{} = {};</pre>\",\n                   it.name.get_ref().as_slice(),\n                   t.generics,\n                   t.type_));\n@@ -1625,9 +1626,7 @@ impl<'a> fmt::Show for Source<'a> {\n             try!(write!(fmt.buf, \"<span id='{0:u}'>{0:1$u}</span>\\n\", i, cols));\n         }\n         try!(write!(fmt.buf, \"</pre>\"));\n-        try!(write!(fmt.buf, \"<pre class='rust'>\"));\n-        try!(write!(fmt.buf, \"{}\", Escape(s.as_slice())));\n-        try!(write!(fmt.buf, \"</pre>\"));\n+        try!(write!(fmt.buf, \"{}\", highlight::highlight(s.as_slice())));\n         Ok(())\n     }\n }"}, {"sha": "6e5cdbafcd6c98803463e8d2da22c41ca05b6f00", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8786405047cadcfb5ec3a2d711ca264d74843c13/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/8786405047cadcfb5ec3a2d711ca264d74843c13/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=8786405047cadcfb5ec3a2d711ca264d74843c13", "patch": "@@ -303,3 +303,18 @@ a {\n .stability.Locked { border-color: #0084B6; color: #00668c; }\n \n :target { background: #FDFFD3; }\n+\n+pre.rust .kw { color: #cc782f; }\n+pre.rust .kw-2 { color: #3bbb33; }\n+pre.rust .prelude-ty { color: #3bbb33; }\n+pre.rust .number { color: #c13928; }\n+pre.rust .self { color: #c13928; }\n+pre.rust .boolval { color: #c13928; }\n+pre.rust .prelude-val { color: #c13928; }\n+pre.rust .op { color: #cc782f; }\n+pre.rust .comment { color: #533add; }\n+pre.rust .doccomment { color: #d343d0; }\n+pre.rust .macro { color: #d343d0; }\n+pre.rust .string { color: #c13928; }\n+pre.rust .lifetime { color: #d343d0; }\n+pre.rust .attribute { color: #d343d0 !important; }"}, {"sha": "4fb71b6710ea3f219c62f3bf1b4a60f35f98d8fc", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8786405047cadcfb5ec3a2d711ca264d74843c13/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8786405047cadcfb5ec3a2d711ca264d74843c13/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=8786405047cadcfb5ec3a2d711ca264d74843c13", "patch": "@@ -38,6 +38,7 @@ pub mod core;\n pub mod doctree;\n pub mod fold;\n pub mod html {\n+    pub mod highlight;\n     pub mod escape;\n     pub mod format;\n     pub mod layout;"}, {"sha": "f7c1986fca6f2e169c2d783ecaa611fbbc1bb442", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8786405047cadcfb5ec3a2d711ca264d74843c13/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8786405047cadcfb5ec3a2d711ca264d74843c13/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=8786405047cadcfb5ec3a2d711ca264d74843c13", "patch": "@@ -82,7 +82,7 @@ function, but the `format!` macro is a syntax extension which allows it to\n leverage named parameters. Named parameters are listed at the end of the\n argument list and have the syntax:\n \n-```ignore\n+```notrust\n identifier '=' expression\n ```\n \n@@ -107,7 +107,7 @@ and if all references to one argument do not provide a type, then the format `?`\n is used (the type's rust-representation is printed). For example, this is an\n invalid format string:\n \n-```ignore\n+```notrust\n {0:d} {0:s}\n ```\n \n@@ -123,7 +123,7 @@ must have the type `uint`. Although a `uint` can be printed with `{:u}`, it is\n illegal to reference an argument as such. For example, this is another invalid\n format string:\n \n-```ignore\n+```notrust\n {:.*s} {0:u}\n ```\n \n@@ -232,7 +232,7 @@ fn main() {\n There are a number of related macros in the `format!` family. The ones that are\n currently implemented are:\n \n-```rust,ignore\n+```ignore\n format!      // described above\n write!       // first argument is a &mut io::Writer, the destination\n writeln!     // same as write but appends a newline\n@@ -276,7 +276,7 @@ references information on the stack. Under the hood, all of\n the related macros are implemented in terms of this. First\n off, some example usage is:\n \n-```rust,ignore\n+```ignore\n use std::fmt;\n \n # fn lol<T>() -> T { fail!() }\n@@ -334,7 +334,7 @@ This example is the equivalent of `{0:s}` essentially.\n The select method is a switch over a `&str` parameter, and the parameter *must*\n be of the type `&str`. An example of the syntax is:\n \n-```ignore\n+```notrust\n {0, select, male{...} female{...} other{...}}\n ```\n \n@@ -353,7 +353,7 @@ The plural method is a switch statement over a `uint` parameter, and the\n parameter *must* be a `uint`. A plural method in its full glory can be specified\n as:\n \n-```ignore\n+```notrust\n {0, plural, offset=1 =1{...} two{...} many{...} other{...}}\n ```\n \n@@ -381,7 +381,7 @@ should not be too alien. Arguments are formatted with python-like syntax,\n meaning that arguments are surrounded by `{}` instead of the C-like `%`. The\n actual grammar for the formatting syntax is:\n \n-```ignore\n+```notrust\n format_string := <text> [ format <text> ] *\n format := '{' [ argument ] [ ':' format_spec ] [ ',' function_spec ] '}'\n argument := integer | identifier\n@@ -896,10 +896,10 @@ impl<'a> Formatter<'a> {\n     ///\n     /// # Arguments\n     ///\n-    ///     * is_positive - whether the original integer was positive or not.\n-    ///     * prefix - if the '#' character (FlagAlternate) is provided, this\n-    ///       is the prefix to put in front of the number.\n-    ///     * buf - the byte array that the number has been formatted into\n+    /// * is_positive - whether the original integer was positive or not.\n+    /// * prefix - if the '#' character (FlagAlternate) is provided, this\n+    ///   is the prefix to put in front of the number.\n+    /// * buf - the byte array that the number has been formatted into\n     ///\n     /// This function will correctly account for the flags provided as well as\n     /// the minimum width. It will not take precision into account."}, {"sha": "104543d43238b360b61cf4ec2f59d52060715434", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8786405047cadcfb5ec3a2d711ca264d74843c13/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8786405047cadcfb5ec3a2d711ca264d74843c13/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=8786405047cadcfb5ec3a2d711ca264d74843c13", "patch": "@@ -53,7 +53,7 @@ pub trait Zero: Add<Self, Self> {\n     ///\n     /// # Laws\n     ///\n-    /// ~~~ignore\n+    /// ~~~notrust\n     /// a + 0 = a       \u2200 a \u2208 Self\n     /// 0 + a = a       \u2200 a \u2208 Self\n     /// ~~~\n@@ -79,7 +79,7 @@ pub trait One: Mul<Self, Self> {\n     ///\n     /// # Laws\n     ///\n-    /// ~~~ignore\n+    /// ~~~notrust\n     /// a * 1 = a       \u2200 a \u2208 Self\n     /// 1 * a = a       \u2200 a \u2208 Self\n     /// ~~~"}, {"sha": "9c905f37d317c14a2820d6575f448f2b11853f73", "filename": "src/test/run-make/rustdoc-hidden-line/verify.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8786405047cadcfb5ec3a2d711ca264d74843c13/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2Fverify.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8786405047cadcfb5ec3a2d711ca264d74843c13/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2Fverify.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2Fverify.sh?ref=8786405047cadcfb5ec3a2d711ca264d74843c13", "patch": "@@ -3,6 +3,6 @@\n file=\"$1/doc/foo/fn.foo.html\"\n \n grep -v 'invisible' $file &&\n-grep '#\\[deriving(Eq)\\] // Bar' $file\n+grep '#.*\\[.*deriving.*(.*Eq.*).*\\].*//.*Bar' $file\n \n exit $?"}]}