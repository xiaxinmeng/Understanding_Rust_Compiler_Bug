{"sha": "dd6a352e64a2d52efd43feca4b2e80d124210a60", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkNmEzNTJlNjRhMmQ1MmVmZDQzZmVjYTRiMmU4MGQxMjQyMTBhNjA=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-10-05T22:00:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-05T22:00:40Z"}, "message": "Merge #6111\n\n6111: Add assist for converting the base of integer literals. r=SomeoneToIgnore a=vlakreeh\n\nThis PR adds an assist similar to Intellij's [convert number to](https://i.imgur.com/JH6wstP.png). It also does a small refactor to [assists/src/tests.rs](https://github.com/rust-analyzer/rust-analyzer/blob/fc34403018079ea053f26d0a31b7517053c7dd8c/crates/assists/src/tests.rs) to add the ability to specify the resolved assist for a specific action within an assist group.\r\n\r\n## Demo\r\n![Demo of the assist in action](https://i.imgur.com/MBhdPFH.gif)\n\nCo-authored-by: vlakreeh <zeb@zebulon.dev>", "tree": {"sha": "9d8ac48868ba23669f48e665b7c4f8168d7ae9a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d8ac48868ba23669f48e665b7c4f8168d7ae9a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd6a352e64a2d52efd43feca4b2e80d124210a60", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfe5eICRBK7hj4Ov3rIwAAdHIIAKON8+3wCTsw0RSOPsRCpr+k\nGWXIBdVA0mkkFrv8GVeorCpFHb58yP+7BJEF4lixUPZx7bgYGqK5PLN7WT/bf0a3\nQtZfR6mpAtyJ6PsCHXTfb7NrcnWM/WtAbJ23JJw+ktOpCIGKsXKQLf3n8wZSJSXY\njEYFdNHWJLN1XrlR8bt67j2xZSEy7Y8mqJwUeB5VfHjEAVAqEKud+cUreegUaWjW\nCI4L+YARn4VZxj0WBTh46C2lObatAXX0VsGdcA/Nbg+/A7ROo+w+LHF7dF8RuGMm\nwjxp/G/osjuCqmkWbx7FX5Um4jl2EK77QCIUkyGXhxUc8jTxmXoueRYSmq4fzjw=\n=29/w\n-----END PGP SIGNATURE-----\n", "payload": "tree 9d8ac48868ba23669f48e665b7c4f8168d7ae9a7\nparent 3fc7338dcb8af4bc8771ae319ae0dd1612fa9013\nparent b2bfadb52c51b0f73f0b425fb6a486bb644e8ebb\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1601935240 +0000\ncommitter GitHub <noreply@github.com> 1601935240 +0000\n\nMerge #6111\n\n6111: Add assist for converting the base of integer literals. r=SomeoneToIgnore a=vlakreeh\n\nThis PR adds an assist similar to Intellij's [convert number to](https://i.imgur.com/JH6wstP.png). It also does a small refactor to [assists/src/tests.rs](https://github.com/rust-analyzer/rust-analyzer/blob/fc34403018079ea053f26d0a31b7517053c7dd8c/crates/assists/src/tests.rs) to add the ability to specify the resolved assist for a specific action within an assist group.\r\n\r\n## Demo\r\n![Demo of the assist in action](https://i.imgur.com/MBhdPFH.gif)\n\nCo-authored-by: vlakreeh <zeb@zebulon.dev>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd6a352e64a2d52efd43feca4b2e80d124210a60", "html_url": "https://github.com/rust-lang/rust/commit/dd6a352e64a2d52efd43feca4b2e80d124210a60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd6a352e64a2d52efd43feca4b2e80d124210a60/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fc7338dcb8af4bc8771ae319ae0dd1612fa9013", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fc7338dcb8af4bc8771ae319ae0dd1612fa9013", "html_url": "https://github.com/rust-lang/rust/commit/3fc7338dcb8af4bc8771ae319ae0dd1612fa9013"}, {"sha": "b2bfadb52c51b0f73f0b425fb6a486bb644e8ebb", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2bfadb52c51b0f73f0b425fb6a486bb644e8ebb", "html_url": "https://github.com/rust-lang/rust/commit/b2bfadb52c51b0f73f0b425fb6a486bb644e8ebb"}], "stats": {"total": 743, "additions": 738, "deletions": 5}, "files": [{"sha": "ea35e833a94f79d5731110705f2f5250f5ee1024", "filename": "crates/assists/src/handlers/convert_integer_literal.rs", "status": "added", "additions": 701, "deletions": 0, "changes": 701, "blob_url": "https://github.com/rust-lang/rust/blob/dd6a352e64a2d52efd43feca4b2e80d124210a60/crates%2Fassists%2Fsrc%2Fhandlers%2Fconvert_integer_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd6a352e64a2d52efd43feca4b2e80d124210a60/crates%2Fassists%2Fsrc%2Fhandlers%2Fconvert_integer_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fconvert_integer_literal.rs?ref=dd6a352e64a2d52efd43feca4b2e80d124210a60", "patch": "@@ -0,0 +1,701 @@\n+use syntax::{ast, AstNode, SmolStr};\n+\n+use crate::{AssistContext, AssistId, AssistKind, Assists, GroupLabel};\n+\n+// Assist: convert_integer_literal\n+//\n+// Converts the base of integer literals to other bases.\n+//\n+// ```\n+// const _: i32 = 10<|>;\n+// ```\n+// ->\n+// ```\n+// const _: i32 = 0b1010;\n+// ```\n+pub(crate) fn convert_integer_literal(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let literal = ctx.find_node_at_offset::<ast::Literal>()?;\n+    let range = literal.syntax().text_range();\n+    let group_id = GroupLabel(\"Convert integer base\".into());\n+\n+    let suffix = match literal.kind() {\n+        ast::LiteralKind::IntNumber { suffix } => suffix,\n+        _ => return None,\n+    };\n+    let suffix_len = suffix.as_ref().map(|s| s.len()).unwrap_or(0);\n+    let raw_literal_text = literal.syntax().to_string();\n+\n+    // Gets the literal's text without the type suffix and without underscores.\n+    let literal_text = raw_literal_text\n+        .chars()\n+        .take(raw_literal_text.len() - suffix_len)\n+        .filter(|c| *c != '_')\n+        .collect::<SmolStr>();\n+    let literal_base = IntegerLiteralBase::identify(&literal_text)?;\n+\n+    for base in IntegerLiteralBase::bases() {\n+        if *base == literal_base {\n+            continue;\n+        }\n+\n+        let mut converted = literal_base.convert(&literal_text, base);\n+\n+        let label = if let Some(suffix) = &suffix {\n+            format!(\"Convert {} ({}) to {}\", &literal_text, suffix, &converted)\n+        } else {\n+            format!(\"Convert {} to {}\", &literal_text, &converted)\n+        };\n+\n+        // Appends the type suffix back into the new literal if it exists.\n+        if let Some(suffix) = &suffix {\n+            converted.push_str(&suffix);\n+        }\n+\n+        acc.add_group(\n+            &group_id,\n+            AssistId(\"convert_integer_literal\", AssistKind::RefactorInline),\n+            label,\n+            range,\n+            |builder| builder.replace(range, converted),\n+        );\n+    }\n+\n+    Some(())\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+enum IntegerLiteralBase {\n+    Binary,\n+    Octal,\n+    Decimal,\n+    Hexadecimal,\n+}\n+\n+impl IntegerLiteralBase {\n+    fn identify(literal_text: &str) -> Option<Self> {\n+        // We cannot express a literal in anything other than decimal in under 3 characters, so we return here if possible.\n+        if literal_text.len() < 3 && literal_text.chars().all(|c| c.is_digit(10)) {\n+            return Some(Self::Decimal);\n+        }\n+\n+        let base = match &literal_text[..2] {\n+            \"0b\" => Self::Binary,\n+            \"0o\" => Self::Octal,\n+            \"0x\" => Self::Hexadecimal,\n+            _ => Self::Decimal,\n+        };\n+\n+        // Checks that all characters after the base prefix are all valid digits for that base.\n+        if literal_text[base.prefix_len()..].chars().all(|c| c.is_digit(base.base())) {\n+            Some(base)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn convert(&self, literal_text: &str, to: &IntegerLiteralBase) -> String {\n+        let digits = &literal_text[self.prefix_len()..];\n+        let value = u128::from_str_radix(digits, self.base()).unwrap();\n+\n+        match to {\n+            Self::Binary => format!(\"0b{:b}\", value),\n+            Self::Octal => format!(\"0o{:o}\", value),\n+            Self::Decimal => value.to_string(),\n+            Self::Hexadecimal => format!(\"0x{:X}\", value),\n+        }\n+    }\n+\n+    const fn base(&self) -> u32 {\n+        match self {\n+            Self::Binary => 2,\n+            Self::Octal => 8,\n+            Self::Decimal => 10,\n+            Self::Hexadecimal => 16,\n+        }\n+    }\n+\n+    const fn prefix_len(&self) -> usize {\n+        match self {\n+            Self::Decimal => 0,\n+            _ => 2,\n+        }\n+    }\n+\n+    const fn bases() -> &'static [IntegerLiteralBase] {\n+        &[\n+            IntegerLiteralBase::Binary,\n+            IntegerLiteralBase::Octal,\n+            IntegerLiteralBase::Decimal,\n+            IntegerLiteralBase::Hexadecimal,\n+        ]\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    use super::*;\n+    use crate::tests::{check_assist_by_label, check_assist_target};\n+\n+    #[test]\n+    fn binary_target() {\n+        check_assist_target(convert_integer_literal, \"const _: i32 = 0b1010<|>;\", \"0b1010\");\n+    }\n+\n+    #[test]\n+    fn octal_target() {\n+        check_assist_target(convert_integer_literal, \"const _: i32 = 0o12<|>;\", \"0o12\");\n+    }\n+\n+    #[test]\n+    fn decimal_target() {\n+        check_assist_target(convert_integer_literal, \"const _: i32 = 10<|>;\", \"10\");\n+    }\n+\n+    #[test]\n+    fn hexadecimal_target() {\n+        check_assist_target(convert_integer_literal, \"const _: i32 = 0xA<|>;\", \"0xA\");\n+    }\n+\n+    #[test]\n+    fn binary_target_with_underscores() {\n+        check_assist_target(convert_integer_literal, \"const _: i32 = 0b10_10<|>;\", \"0b10_10\");\n+    }\n+\n+    #[test]\n+    fn octal_target_with_underscores() {\n+        check_assist_target(convert_integer_literal, \"const _: i32 = 0o1_2<|>;\", \"0o1_2\");\n+    }\n+\n+    #[test]\n+    fn decimal_target_with_underscores() {\n+        check_assist_target(convert_integer_literal, \"const _: i32 = 1_0<|>;\", \"1_0\");\n+    }\n+\n+    #[test]\n+    fn hexadecimal_target_with_underscores() {\n+        check_assist_target(convert_integer_literal, \"const _: i32 = 0x_A<|>;\", \"0x_A\");\n+    }\n+\n+    #[test]\n+    fn convert_decimal_integer() {\n+        let before = \"const _: i32 = 1000<|>;\";\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0b1111101000;\",\n+            \"Convert 1000 to 0b1111101000\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0o1750;\",\n+            \"Convert 1000 to 0o1750\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0x3E8;\",\n+            \"Convert 1000 to 0x3E8\",\n+        );\n+    }\n+\n+    // Decimal numbers under 3 digits have a special case where they return early because we can't fit a\n+    // other base's prefix, so we have a separate test for that.\n+    #[test]\n+    fn convert_small_decimal_integer() {\n+        let before = \"const _: i32 = 10<|>;\";\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0b1010;\",\n+            \"Convert 10 to 0b1010\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0o12;\",\n+            \"Convert 10 to 0o12\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0xA;\",\n+            \"Convert 10 to 0xA\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_hexadecimal_integer() {\n+        let before = \"const _: i32 = 0xFF<|>;\";\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0b11111111;\",\n+            \"Convert 0xFF to 0b11111111\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0o377;\",\n+            \"Convert 0xFF to 0o377\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 255;\",\n+            \"Convert 0xFF to 255\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_binary_integer() {\n+        let before = \"const _: i32 = 0b11111111<|>;\";\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0o377;\",\n+            \"Convert 0b11111111 to 0o377\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 255;\",\n+            \"Convert 0b11111111 to 255\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0xFF;\",\n+            \"Convert 0b11111111 to 0xFF\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_octal_integer() {\n+        let before = \"const _: i32 = 0o377<|>;\";\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0b11111111;\",\n+            \"Convert 0o377 to 0b11111111\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 255;\",\n+            \"Convert 0o377 to 255\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0xFF;\",\n+            \"Convert 0o377 to 0xFF\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_decimal_integer_with_underscores() {\n+        let before = \"const _: i32 = 1_00_0<|>;\";\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0b1111101000;\",\n+            \"Convert 1000 to 0b1111101000\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0o1750;\",\n+            \"Convert 1000 to 0o1750\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0x3E8;\",\n+            \"Convert 1000 to 0x3E8\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_small_decimal_integer_with_underscores() {\n+        let before = \"const _: i32 = 1_0<|>;\";\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0b1010;\",\n+            \"Convert 10 to 0b1010\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0o12;\",\n+            \"Convert 10 to 0o12\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0xA;\",\n+            \"Convert 10 to 0xA\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_hexadecimal_integer_with_underscores() {\n+        let before = \"const _: i32 = 0x_F_F<|>;\";\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0b11111111;\",\n+            \"Convert 0xFF to 0b11111111\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0o377;\",\n+            \"Convert 0xFF to 0o377\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 255;\",\n+            \"Convert 0xFF to 255\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_binary_integer_with_underscores() {\n+        let before = \"const _: i32 = 0b1111_1111<|>;\";\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0o377;\",\n+            \"Convert 0b11111111 to 0o377\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 255;\",\n+            \"Convert 0b11111111 to 255\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0xFF;\",\n+            \"Convert 0b11111111 to 0xFF\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_octal_integer_with_underscores() {\n+        let before = \"const _: i32 = 0o3_77<|>;\";\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0b11111111;\",\n+            \"Convert 0o377 to 0b11111111\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 255;\",\n+            \"Convert 0o377 to 255\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0xFF;\",\n+            \"Convert 0o377 to 0xFF\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_decimal_integer_with_suffix() {\n+        let before = \"const _: i32 = 1000i32<|>;\";\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0b1111101000i32;\",\n+            \"Convert 1000 (i32) to 0b1111101000\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0o1750i32;\",\n+            \"Convert 1000 (i32) to 0o1750\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0x3E8i32;\",\n+            \"Convert 1000 (i32) to 0x3E8\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_small_decimal_integer_with_suffix() {\n+        let before = \"const _: i32 = 10i32<|>;\";\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0b1010i32;\",\n+            \"Convert 10 (i32) to 0b1010\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0o12i32;\",\n+            \"Convert 10 (i32) to 0o12\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0xAi32;\",\n+            \"Convert 10 (i32) to 0xA\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_hexadecimal_integer_with_suffix() {\n+        let before = \"const _: i32 = 0xFFi32<|>;\";\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0b11111111i32;\",\n+            \"Convert 0xFF (i32) to 0b11111111\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0o377i32;\",\n+            \"Convert 0xFF (i32) to 0o377\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 255i32;\",\n+            \"Convert 0xFF (i32) to 255\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_binary_integer_with_suffix() {\n+        let before = \"const _: i32 = 0b11111111i32<|>;\";\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0o377i32;\",\n+            \"Convert 0b11111111 (i32) to 0o377\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 255i32;\",\n+            \"Convert 0b11111111 (i32) to 255\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0xFFi32;\",\n+            \"Convert 0b11111111 (i32) to 0xFF\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_octal_integer_with_suffix() {\n+        let before = \"const _: i32 = 0o377i32<|>;\";\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0b11111111i32;\",\n+            \"Convert 0o377 (i32) to 0b11111111\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 255i32;\",\n+            \"Convert 0o377 (i32) to 255\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0xFFi32;\",\n+            \"Convert 0o377 (i32) to 0xFF\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_decimal_integer_with_underscores_and_suffix() {\n+        let before = \"const _: i32 = 1_00_0i32<|>;\";\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0b1111101000i32;\",\n+            \"Convert 1000 (i32) to 0b1111101000\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0o1750i32;\",\n+            \"Convert 1000 (i32) to 0o1750\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0x3E8i32;\",\n+            \"Convert 1000 (i32) to 0x3E8\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_small_decimal_integer_with_underscores_and_suffix() {\n+        let before = \"const _: i32 = 1_0i32<|>;\";\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0b1010i32;\",\n+            \"Convert 10 (i32) to 0b1010\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0o12i32;\",\n+            \"Convert 10 (i32) to 0o12\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0xAi32;\",\n+            \"Convert 10 (i32) to 0xA\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_hexadecimal_integer_with_underscores_and_suffix() {\n+        let before = \"const _: i32 = 0x_F_Fi32<|>;\";\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0b11111111i32;\",\n+            \"Convert 0xFF (i32) to 0b11111111\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0o377i32;\",\n+            \"Convert 0xFF (i32) to 0o377\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 255i32;\",\n+            \"Convert 0xFF (i32) to 255\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_binary_integer_with_underscores_and_suffix() {\n+        let before = \"const _: i32 = 0b1111_1111i32<|>;\";\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0o377i32;\",\n+            \"Convert 0b11111111 (i32) to 0o377\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 255i32;\",\n+            \"Convert 0b11111111 (i32) to 255\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0xFFi32;\",\n+            \"Convert 0b11111111 (i32) to 0xFF\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_octal_integer_with_underscores_and_suffix() {\n+        let before = \"const _: i32 = 0o3_77i32<|>;\";\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0b11111111i32;\",\n+            \"Convert 0o377 (i32) to 0b11111111\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 255i32;\",\n+            \"Convert 0o377 (i32) to 255\",\n+        );\n+\n+        check_assist_by_label(\n+            convert_integer_literal,\n+            before,\n+            \"const _: i32 = 0xFFi32;\",\n+            \"Convert 0o377 (i32) to 0xFF\",\n+        );\n+    }\n+}"}, {"sha": "a2bec818c1a4590746d2d46541b21a7ac3d5ab3a", "filename": "crates/assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd6a352e64a2d52efd43feca4b2e80d124210a60/crates%2Fassists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd6a352e64a2d52efd43feca4b2e80d124210a60/crates%2Fassists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Flib.rs?ref=dd6a352e64a2d52efd43feca4b2e80d124210a60", "patch": "@@ -128,6 +128,7 @@ mod handlers {\n     mod auto_import;\n     mod change_return_type_to_result;\n     mod change_visibility;\n+    mod convert_integer_literal;\n     mod early_return;\n     mod expand_glob_import;\n     mod extract_struct_from_enum_variant;\n@@ -172,6 +173,7 @@ mod handlers {\n             auto_import::auto_import,\n             change_return_type_to_result::change_return_type_to_result,\n             change_visibility::change_visibility,\n+            convert_integer_literal::convert_integer_literal,\n             early_return::convert_to_guarded_return,\n             expand_glob_import::expand_glob_import,\n             extract_struct_from_enum_variant::extract_struct_from_enum_variant,"}, {"sha": "2b687decf3ac4a9ca2df3de8ef3cf81aecd0ecea", "filename": "crates/assists/src/tests.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dd6a352e64a2d52efd43feca4b2e80d124210a60/crates%2Fassists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd6a352e64a2d52efd43feca4b2e80d124210a60/crates%2Fassists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Ftests.rs?ref=dd6a352e64a2d52efd43feca4b2e80d124210a60", "patch": "@@ -15,18 +15,30 @@ pub(crate) fn with_single_file(text: &str) -> (RootDatabase, FileId) {\n \n pub(crate) fn check_assist(assist: Handler, ra_fixture_before: &str, ra_fixture_after: &str) {\n     let ra_fixture_after = trim_indent(ra_fixture_after);\n-    check(assist, ra_fixture_before, ExpectedResult::After(&ra_fixture_after));\n+    check(assist, ra_fixture_before, ExpectedResult::After(&ra_fixture_after), None);\n+}\n+\n+// There is no way to choose what assist within a group you want to test against,\n+// so this is here to allow you choose.\n+pub(crate) fn check_assist_by_label(\n+    assist: Handler,\n+    ra_fixture_before: &str,\n+    ra_fixture_after: &str,\n+    label: &str,\n+) {\n+    let ra_fixture_after = trim_indent(ra_fixture_after);\n+    check(assist, ra_fixture_before, ExpectedResult::After(&ra_fixture_after), Some(label));\n }\n \n // FIXME: instead of having a separate function here, maybe use\n // `extract_ranges` and mark the target as `<target> </target>` in the\n // fixture?\n pub(crate) fn check_assist_target(assist: Handler, ra_fixture: &str, target: &str) {\n-    check(assist, ra_fixture, ExpectedResult::Target(target));\n+    check(assist, ra_fixture, ExpectedResult::Target(target), None);\n }\n \n pub(crate) fn check_assist_not_applicable(assist: Handler, ra_fixture: &str) {\n-    check(assist, ra_fixture, ExpectedResult::NotApplicable);\n+    check(assist, ra_fixture, ExpectedResult::NotApplicable, None);\n }\n \n fn check_doc_test(assist_id: &str, before: &str, after: &str) {\n@@ -65,7 +77,7 @@ enum ExpectedResult<'a> {\n     Target(&'a str),\n }\n \n-fn check(handler: Handler, before: &str, expected: ExpectedResult) {\n+fn check(handler: Handler, before: &str, expected: ExpectedResult, assist_label: Option<&str>) {\n     let (db, file_with_caret_id, range_or_offset) = RootDatabase::with_range_or_offset(before);\n     let text_without_caret = db.file_text(file_with_caret_id).to_string();\n \n@@ -77,7 +89,12 @@ fn check(handler: Handler, before: &str, expected: ExpectedResult) {\n     let mut acc = Assists::new_resolved(&ctx);\n     handler(&mut acc, &ctx);\n     let mut res = acc.finish_resolved();\n-    let assist = res.pop();\n+\n+    let assist = match assist_label {\n+        Some(label) => res.into_iter().find(|resolved| resolved.assist.label == label),\n+        None => res.pop(),\n+    };\n+\n     match (assist, expected) {\n         (Some(assist), ExpectedResult::After(after)) => {\n             let mut source_change = assist.source_change;"}, {"sha": "7f6e98a548cb1bca8cb598a957c4c8e7dd9e76e7", "filename": "crates/assists/src/tests/generated.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dd6a352e64a2d52efd43feca4b2e80d124210a60/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd6a352e64a2d52efd43feca4b2e80d124210a60/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs?ref=dd6a352e64a2d52efd43feca4b2e80d124210a60", "patch": "@@ -203,6 +203,19 @@ pub(crate) fn frobnicate() {}\n     )\n }\n \n+#[test]\n+fn doctest_convert_integer_literal() {\n+    check_doc_test(\n+        \"convert_integer_literal\",\n+        r#####\"\n+const _: i32 = 10<|>;\n+\"#####,\n+        r#####\"\n+const _: i32 = 0b1010;\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_convert_to_guarded_return() {\n     check_doc_test("}]}