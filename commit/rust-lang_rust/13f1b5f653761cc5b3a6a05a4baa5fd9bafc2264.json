{"sha": "13f1b5f653761cc5b3a6a05a4baa5fd9bafc2264", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzZjFiNWY2NTM3NjFjYzViM2E2YTA1YTRiYWE1ZmQ5YmFmYzIyNjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-05T10:21:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-05T10:21:46Z"}, "message": "Auto merge of #1393 - RalfJung:arg-count-cleanup, r=RalfJung\n\nMake sure we check argument count everywhere and argument size for non-stub shims", "tree": {"sha": "2aadd626c80242d4706a878428cb05df15d149f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2aadd626c80242d4706a878428cb05df15d149f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13f1b5f653761cc5b3a6a05a4baa5fd9bafc2264", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13f1b5f653761cc5b3a6a05a4baa5fd9bafc2264", "html_url": "https://github.com/rust-lang/rust/commit/13f1b5f653761cc5b3a6a05a4baa5fd9bafc2264", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13f1b5f653761cc5b3a6a05a4baa5fd9bafc2264/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f974f6e1f1ceef6e09e84bb23ae7022bab2df1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f974f6e1f1ceef6e09e84bb23ae7022bab2df1a", "html_url": "https://github.com/rust-lang/rust/commit/2f974f6e1f1ceef6e09e84bb23ae7022bab2df1a"}, {"sha": "40800cfa197100f45419586fbdc622d17ea47b7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/40800cfa197100f45419586fbdc622d17ea47b7f", "html_url": "https://github.com/rust-lang/rust/commit/40800cfa197100f45419586fbdc622d17ea47b7f"}], "stats": {"total": 94, "additions": 59, "deletions": 35}, "files": [{"sha": "951a40293b72d834615b25b5e03f8808b3a4bc9f", "filename": "src/shims/foreign_items/posix.rs", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/13f1b5f653761cc5b3a6a05a4baa5fd9bafc2264/src%2Fshims%2Fforeign_items%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f1b5f653761cc5b3a6a05a4baa5fd9bafc2264/src%2Fshims%2Fforeign_items%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix.rs?ref=13f1b5f653761cc5b3a6a05a4baa5fd9bafc2264", "patch": "@@ -34,7 +34,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"setenv\" => {\n-                let &[name, value, _overwrite] = check_arg_count(args)?;\n+                let &[name, value, overwrite] = check_arg_count(args)?;\n+                this.read_scalar(overwrite)?.to_i32()?;\n                 let result = this.setenv(name, value)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n@@ -51,8 +52,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // File related shims\n             \"open\" | \"open64\" => {\n-                let &[path, flag, _mode] = check_arg_count(args)?;\n-                let result = this.open(path, flag)?;\n+                let &[path, flag, mode] = check_arg_count(args)?;\n+                let result = this.open(path, flag, mode)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"fcntl\" => {\n@@ -379,19 +380,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n             // These shims are enabled only when the caller is in the standard library.\n-            | \"pthread_attr_init\"\n-            | \"pthread_attr_destroy\"\n-            | \"pthread_attr_setstacksize\"\n-            | \"pthread_condattr_init\"\n-            | \"pthread_condattr_setclock\"\n-            | \"pthread_cond_init\"\n-            | \"pthread_condattr_destroy\"\n-            | \"pthread_cond_destroy\" if this.frame().instance.to_string().starts_with(\"std::sys::unix::\")\n-            => {\n-                this.write_null(dest)?;\n-            }\n-            \"pthread_attr_getguardsize\" if this.frame().instance.to_string().starts_with(\"std::sys::unix::\")\n-            => {\n+            \"pthread_attr_getguardsize\"\n+            if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n                 let &[_attr, guard_size] = check_arg_count(args)?;\n                 let guard_size = this.deref_operand(guard_size)?;\n                 let guard_size_layout = this.libc_ty_layout(\"size_t\")?;\n@@ -401,11 +391,33 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n \n+            | \"pthread_attr_init\"\n+            | \"pthread_attr_destroy\"\n+            | \"pthread_condattr_init\"\n+            | \"pthread_condattr_destroy\"\n+            | \"pthread_cond_destroy\"\n+            if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n+                let &[_] = check_arg_count(args)?;\n+                this.write_null(dest)?;\n+            }\n+            | \"pthread_cond_init\"\n+            | \"pthread_attr_setstacksize\"\n+            | \"pthread_condattr_setclock\"\n+            if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n+                let &[_, _] = check_arg_count(args)?;\n+                this.write_null(dest)?;\n+            }\n+\n             | \"signal\"\n-            | \"sigaction\"\n             | \"sigaltstack\"\n-            | \"mprotect\" if this.frame().instance.to_string().starts_with(\"std::sys::unix::\")\n-            => {\n+            if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n+                let &[_, _] = check_arg_count(args)?;\n+                this.write_null(dest)?;\n+            }\n+            | \"sigaction\"\n+            | \"mprotect\"\n+            if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n+                let &[_, _, _] = check_arg_count(args)?;\n                 this.write_null(dest)?;\n             }\n "}, {"sha": "7f3cd03cd2d36fcf841e142f889eac1b0c38fd9a", "filename": "src/shims/foreign_items/windows.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/13f1b5f653761cc5b3a6a05a4baa5fd9bafc2264/src%2Fshims%2Fforeign_items%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f1b5f653761cc5b3a6a05a4baa5fd9bafc2264/src%2Fshims%2Fforeign_items%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fwindows.rs?ref=13f1b5f653761cc5b3a6a05a4baa5fd9bafc2264", "patch": "@@ -63,7 +63,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_machine_isize(which.into(), this), dest)?;\n             }\n             \"WriteFile\" => {\n-                let &[handle, buf, n, written_ptr, _overlapped] = check_arg_count(args)?;\n+                let &[handle, buf, n, written_ptr, overlapped] = check_arg_count(args)?;\n+                this.read_scalar(overlapped)?.to_machine_usize(this)?; // this is a poiner, that we ignore\n                 let handle = this.read_scalar(handle)?.to_machine_isize(this)?;\n                 let buf = this.read_scalar(buf)?.not_undef()?;\n                 let n = this.read_scalar(n)?.to_u32()?;\n@@ -251,22 +252,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // Just fake a HANDLE\n                 this.write_scalar(Scalar::from_machine_isize(1, this), dest)?;\n             }\n-            \"GetModuleHandleW\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\")\n-            => {\n+            \"GetModuleHandleW\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n                 #[allow(non_snake_case)]\n                 let &[_lpModuleName] = check_arg_count(args)?;\n                 // Pretend this does not exist / nothing happened, by returning zero.\n                 this.write_null(dest)?;\n             }\n-            \"GetProcAddress\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\")\n-            => {\n+            \"GetProcAddress\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n                 #[allow(non_snake_case)]\n                 let &[_hModule, _lpProcName] = check_arg_count(args)?;\n                 // Pretend this does not exist / nothing happened, by returning zero.\n                 this.write_null(dest)?;\n             }\n-            \"SetConsoleTextAttribute\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\")\n-            => {\n+            \"SetConsoleTextAttribute\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n                 #[allow(non_snake_case)]\n                 let &[_hConsoleOutput, _wAttribute] = check_arg_count(args)?;\n                 // Pretend these does not exist / nothing happened, by returning zero.\n@@ -281,17 +279,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"InitializeCriticalSection\"\n             | \"EnterCriticalSection\"\n             | \"LeaveCriticalSection\"\n-            | \"DeleteCriticalSection\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\")\n-            => {\n+            | \"DeleteCriticalSection\"\n+            if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n                 #[allow(non_snake_case)]\n                 let &[_lpCriticalSection] = check_arg_count(args)?;\n                 assert_eq!(this.get_total_thread_count()?, 1, \"concurrency on Windows not supported\");\n                 // Nothing to do, not even a return value.\n                 // (Windows locks are reentrant, and we have only 1 thread,\n                 // so not doing any futher checks here is at least not incorrect.)\n             }\n-            \"TryEnterCriticalSection\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\")\n-            => {\n+            \"TryEnterCriticalSection\"\n+            if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n                 #[allow(non_snake_case)]\n                 let &[_lpCriticalSection] = check_arg_count(args)?;\n                 assert_eq!(this.get_total_thread_count()?, 1, \"concurrency on Windows not supported\");"}, {"sha": "58abf748dd5a86179edd5615abde96ef0f630657", "filename": "src/shims/fs.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/13f1b5f653761cc5b3a6a05a4baa5fd9bafc2264/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f1b5f653761cc5b3a6a05a4baa5fd9bafc2264/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=13f1b5f653761cc5b3a6a05a4baa5fd9bafc2264", "patch": "@@ -238,13 +238,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         path_op: OpTy<'tcx, Tag>,\n         flag_op: OpTy<'tcx, Tag>,\n+        mode_op: OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         this.check_no_isolation(\"open\")?;\n \n         let flag = this.read_scalar(flag_op)?.to_i32()?;\n \n+        // Check mode (size depends on platform).\n+        // FIXME: should we do something with the mode?\n+        match this.tcx.sess.target.target.target_os.as_str() {\n+            \"macos\" => {\n+                // FIXME: I think `mode` should be `u16` on macOS, but see\n+                // <https://github.com/rust-lang/rust/issues/71915>.\n+                // For now, just don't check on macos.\n+            }\n+            _ => {\n+                this.read_scalar(mode_op)?.to_u32()?;\n+            }\n+        };\n+\n         let mut options = OpenOptions::new();\n \n         let o_rdonly = this.eval_libc_i32(\"O_RDONLY\")?;\n@@ -331,15 +345,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if args.len() < 2 {\n             throw_ub_format!(\"incorrect number of arguments for fcntl: got {}, expected at least 2\", args.len());\n         }\n+        let fd = this.read_scalar(args[0])?.to_i32()?;\n         let cmd = this.read_scalar(args[1])?.to_i32()?;\n         // We only support getting the flags for a descriptor.\n         if cmd == this.eval_libc_i32(\"F_GETFD\")? {\n             // Currently this is the only flag that `F_GETFD` returns. It is OK to just return the\n             // `FD_CLOEXEC` value without checking if the flag is set for the file because `std`\n             // always sets this flag when opening a file. However we still need to check that the\n             // file itself is open.\n-            let &[fd, _] = check_arg_count(args)?;\n-            let fd = this.read_scalar(fd)?.to_i32()?;\n+            let &[_, _] = check_arg_count(args)?;\n             if this.machine.file_handler.handles.contains_key(&fd) {\n                 Ok(this.eval_libc_i32(\"FD_CLOEXEC\")?)\n             } else {\n@@ -352,8 +366,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // because exec() isn't supported. The F_DUPFD and F_DUPFD_CLOEXEC commands only\n             // differ in whether the FD_CLOEXEC flag is pre-set on the new file descriptor,\n             // thus they can share the same implementation here.\n-            let &[fd, _, start] = check_arg_count(args)?;\n-            let fd = this.read_scalar(fd)?.to_i32()?;\n+            let &[_, _, start] = check_arg_count(args)?;\n             let start = this.read_scalar(start)?.to_i32()?;\n             if fd < MIN_NORMAL_FILE_FD {\n                 throw_unsup_format!(\"duplicating file descriptors for stdin, stdout, or stderr is not supported\")"}, {"sha": "08087b0350d9c02d9be2745dfd2b80eb0753b482", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/13f1b5f653761cc5b3a6a05a4baa5fd9bafc2264/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f1b5f653761cc5b3a6a05a4baa5fd9bafc2264/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=13f1b5f653761cc5b3a6a05a4baa5fd9bafc2264", "patch": "@@ -363,7 +363,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"atomic_singlethreadfence_acqrel\"\n             | \"atomic_singlethreadfence\"\n             => {\n-                // we are inherently singlethreaded and singlecored, this is a nop\n+                let &[] = check_arg_count(args)?;\n+                // FIXME: this will become relevant once we try to detect data races.\n             }\n \n             _ if intrinsic_name.starts_with(\"atomic_xchg\") => {"}]}