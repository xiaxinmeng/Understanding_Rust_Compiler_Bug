{"sha": "31e46ac0a95d58fa95dcd154a0f8a56089e2f5b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxZTQ2YWMwYTk1ZDU4ZmE5NWRjZDE1NGEwZjhhNTYwODllMmY1Yjk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-06T19:55:38Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-11T00:45:19Z"}, "message": "During method resolution, only reborrow if we are not doing an auto-ref.\nThe current behavior leads to adjustments like `&&*` being applied\ninstead of just `&` (when the unmodified receiver is a `&T` or an `&mut\nT`). This causes both safety errors and unexpected behavior. The safety\nerrors result from regionck not being prepared for auto-ref-ref-like\nadjustments; this is worth fixing on its own, but I think the best way\nto do it is to modify regionck to use expr-use-visitor (and fix\nexpr-use-visitor as well, which I don't think properly invokes `borrow`\nfor each level of auto-ref), and for now it's simpler to just not\nproduce the adjustment in question. (I have a separate patch porting\nregionck to use exprusevisitor for a different bug, so that is coming.)", "tree": {"sha": "871e5cdbc82e0ce8e4abb0d3a7671cff67b532bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/871e5cdbc82e0ce8e4abb0d3a7671cff67b532bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31e46ac0a95d58fa95dcd154a0f8a56089e2f5b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31e46ac0a95d58fa95dcd154a0f8a56089e2f5b9", "html_url": "https://github.com/rust-lang/rust/commit/31e46ac0a95d58fa95dcd154a0f8a56089e2f5b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31e46ac0a95d58fa95dcd154a0f8a56089e2f5b9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca98fefd04b2a0ccd784f96538c824c49210a418", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca98fefd04b2a0ccd784f96538c824c49210a418", "html_url": "https://github.com/rust-lang/rust/commit/ca98fefd04b2a0ccd784f96538c824c49210a418"}], "stats": {"total": 114, "additions": 102, "deletions": 12}, "files": [{"sha": "53bda93b28e0216607050d38b188a9b7c3b6c091", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31e46ac0a95d58fa95dcd154a0f8a56089e2f5b9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e46ac0a95d58fa95dcd154a0f8a56089e2f5b9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=31e46ac0a95d58fa95dcd154a0f8a56089e2f5b9", "patch": "@@ -100,6 +100,7 @@ pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n            call_expr.repr(fcx.tcx()),\n            self_expr.repr(fcx.tcx()));\n \n+    let self_ty = fcx.infcx().resolve_type_vars_if_possible(self_ty);\n     let pick = try!(probe::probe(fcx, span, method_name, self_ty, call_expr.id));\n     Ok(confirm::confirm(fcx, span, self_expr, call_expr, self_ty, pick, supplied_method_types))\n }"}, {"sha": "18ab4f79b0b9a81830aa031cf01dae1e11bf7878", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/31e46ac0a95d58fa95dcd154a0f8a56089e2f5b9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e46ac0a95d58fa95dcd154a0f8a56089e2f5b9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=31e46ac0a95d58fa95dcd154a0f8a56089e2f5b9", "patch": "@@ -168,7 +168,7 @@ fn create_steps<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         check::autoderef(\n             fcx, span, self_ty, None, NoPreference,\n             |t, d| {\n-                let adjustment = consider_reborrow(t, d);\n+                let adjustment = AutoDeref(d);\n                 steps.push(CandidateStep { self_ty: t, adjustment: adjustment });\n                 None::<()> // keep iterating until we can't anymore\n             });\n@@ -185,14 +185,6 @@ fn create_steps<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     return steps;\n-\n-    fn consider_reborrow(ty: Ty, d: uint) -> PickAdjustment {\n-        // Insert a `&*` or `&mut *` if this is a reference type:\n-        match ty.sty {\n-            ty::ty_rptr(_, ref mt) => AutoRef(mt.mutbl, box AutoDeref(d+1)),\n-            _ => AutoDeref(d),\n-        }\n-    }\n }\n \n impl<'a,'tcx> ProbeContext<'a,'tcx> {\n@@ -626,7 +618,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             return None;\n         }\n \n-        match self.pick_adjusted_method(step) {\n+        match self.pick_by_value_method(step) {\n             Some(result) => return Some(result),\n             None => {}\n         }\n@@ -644,11 +636,34 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n     }\n \n-    fn pick_adjusted_method(&mut self,\n+    fn pick_by_value_method(&mut self,\n                             step: &CandidateStep<'tcx>)\n                             -> Option<PickResult<'tcx>>\n     {\n-        self.pick_method(step.self_ty).map(|r| self.adjust(r, step.adjustment.clone()))\n+        /*!\n+         * For each type `T` in the step list, this attempts to find a\n+         * method where the (transformed) self type is exactly `T`. We\n+         * do however do one transformation on the adjustment: if we\n+         * are passing a region pointer in, we will potentially\n+         * *reborrow* it to a shorter lifetime. This allows us to\n+         * transparently pass `&mut` pointers, in particular, without\n+         * consuming them for their entire lifetime.\n+         */\n+\n+        let adjustment = match step.adjustment {\n+            AutoDeref(d) => consider_reborrow(step.self_ty, d),\n+            AutoUnsizeLength(..) | AutoRef(..) => step.adjustment.clone(),\n+        };\n+\n+        return self.pick_method(step.self_ty).map(|r| self.adjust(r, adjustment.clone()));\n+\n+        fn consider_reborrow(ty: Ty, d: uint) -> PickAdjustment {\n+            // Insert a `&*` or `&mut *` if this is a reference type:\n+            match ty.sty {\n+                ty::ty_rptr(_, ref mt) => AutoRef(mt.mutbl, box AutoDeref(d+1)),\n+                _ => AutoDeref(d),\n+            }\n+        }\n     }\n \n     fn pick_autorefd_method(&mut self,"}, {"sha": "7529943f0bc5947b40ef75099a898db5cc0b419c", "filename": "src/test/compile-fail/borrowck-return-variable-on-stack-via-clone.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/31e46ac0a95d58fa95dcd154a0f8a56089e2f5b9/src%2Ftest%2Fcompile-fail%2Fborrowck-return-variable-on-stack-via-clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e46ac0a95d58fa95dcd154a0f8a56089e2f5b9/src%2Ftest%2Fcompile-fail%2Fborrowck-return-variable-on-stack-via-clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-return-variable-on-stack-via-clone.rs?ref=31e46ac0a95d58fa95dcd154a0f8a56089e2f5b9", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that when we clone a `&T` pointer we properly relate the\n+// lifetime of the pointer which results to the pointer being cloned.\n+// Bugs in method resolution have sometimes broken this connection.\n+// Issue #19261.\n+\n+fn leak<'a, T>(x: T) -> &'a T {\n+    (&x).clone() //~ ERROR `x` does not live long enough\n+}\n+\n+fn main() { }"}, {"sha": "00319d57f8da64e5cb16cc6c1ce30e559876066e", "filename": "src/test/run-pass/method-mut-self-modifies-mut-slice-lvalue.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/31e46ac0a95d58fa95dcd154a0f8a56089e2f5b9/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e46ac0a95d58fa95dcd154a0f8a56089e2f5b9/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs?ref=31e46ac0a95d58fa95dcd154a0f8a56089e2f5b9", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that an `&mut self` method, when invoked on an lvalue whose\n+// type is `&mut [u8]`, passes in a pointer to the lvalue and not a\n+// temporary. Issue #19147.\n+\n+use std::raw;\n+use std::mem;\n+use std::slice;\n+use std::io::IoResult;\n+\n+trait MyWriter {\n+    fn my_write(&mut self, buf: &[u8]) -> IoResult<()>;\n+}\n+\n+impl<'a> MyWriter for &'a mut [u8] {\n+    fn my_write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        slice::bytes::copy_memory(*self, buf);\n+\n+        let write_len = buf.len();\n+        unsafe {\n+            *self = mem::transmute(raw::Slice {\n+                data: self.as_ptr().offset(write_len as int),\n+                len: self.len() - write_len,\n+            });\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+fn main() {\n+    let mut buf = [0_u8, .. 6];\n+\n+    {\n+        let mut writer = buf.as_mut_slice();\n+        writer.my_write(&[0, 1, 2]).unwrap();\n+        writer.my_write(&[3, 4, 5]).unwrap();\n+    }\n+\n+    // If `my_write` is not modifying `buf` in place, then we will\n+    // wind up with `[3, 4, 5, 0, 0, 0]` because the first call to\n+    // `my_write()` doesn't update the starting point for the write.\n+\n+    assert_eq!(buf, [0, 1, 2, 3, 4, 5]);\n+}"}]}