{"sha": "c8b60a2d9e4cbd782e5076e90d4acd458e4f635d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4YjYwYTJkOWU0Y2JkNzgyZTUwNzZlOTBkNGFjZDQ1OGU0ZjYzNWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-02T21:36:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-02T21:36:41Z"}, "message": "auto merge of #10742 : alexcrichton/rust/frameworks, r=cmr\n\nCommits have the fun details, and scrutiny on the new documentation would be appreciated!", "tree": {"sha": "36009513c5c114037458f9b9157afefc28c4b445", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36009513c5c114037458f9b9157afefc28c4b445"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d", "html_url": "https://github.com/rust-lang/rust/commit/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc4540d23ebec95a09309f042b7992b0926f6fe1", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc4540d23ebec95a09309f042b7992b0926f6fe1", "html_url": "https://github.com/rust-lang/rust/commit/fc4540d23ebec95a09309f042b7992b0926f6fe1"}, {"sha": "d4c40b519b080a08a37d27e015083fd250fdd197", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4c40b519b080a08a37d27e015083fd250fdd197", "html_url": "https://github.com/rust-lang/rust/commit/d4c40b519b080a08a37d27e015083fd250fdd197"}], "stats": {"total": 390, "additions": 353, "deletions": 37}, "files": [{"sha": "92d9cb3ae38fcdea8c143fce8f5ffbc5484b7c6b", "filename": "doc/rust.md", "status": "modified", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=c8b60a2d9e4cbd782e5076e90d4acd458e4f635d", "patch": "@@ -2070,6 +2070,38 @@ The currently implemented features of the compiler are:\n                closure as `once` is unlikely to be supported going forward. So\n                they are hidden behind this feature until they are to be removed.\n \n+* `managed_boxes` - Usage of `@` pointers is gated due to many\n+                    planned changes to this feature. In the past, this has meant\n+                    \"a GC pointer\", but the current implementation uses\n+                    reference counting and will likely change drastically over\n+                    time. Additionally, the `@` syntax will no longer be used to\n+                    create GC boxes.\n+\n+* `asm` - The `asm!` macro provides a means for inline assembly. This is often\n+          useful, but the exact syntax for this feature along with its semantics\n+          are likely to change, so this macro usage must be opted into.\n+\n+* `non_ascii_idents` - The compiler supports the use of non-ascii identifiers,\n+                       but the implementation is a little rough around the\n+                       edges, so this can be seen as an experimental feature for\n+                       now until the specification of identifiers is fully\n+                       fleshed out.\n+\n+* `thread_local` - The usage of the `#[thread_local]` attribute is experimental\n+                   and should be seen as unstable. This attribute is used to\n+                   declare a `static` as being unique per-thread leveraging\n+                   LLVM's implementation which works in concert with the kernel\n+                   loader and dynamic linker. This is not necessarily available\n+                   on all platforms, and usage of it is discouraged (rust\n+                   focuses more on task-local data instead of thread-local\n+                   data).\n+\n+* `link_args` - This attribute is used to specify custom flags to the linker,\n+                but usage is strongly discouraged. The compiler's usage of the\n+                system linker is not guaranteed to continue in the future, and\n+                if the system linker is not used then specifying custom flags\n+                doesn't have much meaning.\n+\n If a feature is promoted to a language feature, then all existing programs will\n start to receive compilation warnings about #[feature] directives which enabled\n the new feature (because the directive is no longer necessary). However, if\n@@ -3611,6 +3643,111 @@ queues, as well as code to copy values between queues and their recipients and\n to serialize values for transmission over operating-system inter-process\n communication facilities.\n \n+### Linkage\n+\n+The Rust compiler supports various methods to link crates together both\n+statically and dynamically. This section will explore the various methods to\n+link Rust crates together, and more information about native libraries can be\n+found in the [ffi tutorial][ffi].\n+\n+In one session of compilation, the compiler can generate multiple artifacts\n+through the usage of command line flags and the `crate_type` attribute.\n+\n+* `--bin`, `#[crate_type = \"bin\"]` - A runnable executable will be produced.\n+  This requires that there is a `main` function in the crate which will be run\n+  when the program begins executing. This will link in all Rust and native\n+  dependencies, producing a distributable binary.\n+\n+* `--lib`, `#[crate_type = \"lib\"]` - A Rust library will be produced. This is\n+  an ambiguous concept as to what exactly is produced because a library can\n+  manifest itself in several forms. The purpose of this generic `lib` option is\n+  to generate the \"compiler recommended\" style of library. The output library\n+  will always be usable by rustc, but the actual type of library may change\n+  from time-to-time. The remaining output types are all different flavors of\n+  libraries, and the `lib` type can be seen as an alias for one of them (but\n+  the actual one is compiler-defined).\n+\n+* `--dylib`, `#[crate_type = \"dylib\"]` - A dynamic Rust library will be\n+  produced. This is different from the `lib` output type in that this forces\n+  dynamic library generation. The resulting dynamic library can be used as a\n+  dependency for other libraries and/or executables.  This output type will\n+  create `*.so` files on linux, `*.dylib` files on osx, and `*.dll` files on\n+  windows.\n+\n+* `--staticlib`, `#[crate_type = \"staticlib\"]` - A static system library will\n+  be produced. This is different from other library outputs in that the Rust\n+  compiler will never attempt to link to `staticlib` outputs. The purpose of\n+  this output type is to create a static library containing all of the local\n+  crate's code along with all upstream dependencies. The static library is\n+  actually a `*.a` archive on linux and osx and a `*.lib` file on windows. This\n+  format is recommended for use in situtations such as linking Rust code into an\n+  existing non-Rust application because it will not have dynamic dependencies on\n+  other Rust code.\n+\n+* `--rlib`, `#[crate_type = \"rlib\"]` - A \"Rust library\" file will be produced.\n+  This is used as an intermediate artifact and can be thought of as a \"static\n+  Rust library\". These `rlib` files, unlike `staticlib` files, are interpreted\n+  by the Rust compiler in future linkage. This essentially means that `rustc`\n+  will look for metadata in `rlib` files like it looks for metadata in dynamic\n+  libraries. This form of output is used to produce statically linked\n+  executables as well as `staticlib` outputs.\n+\n+Note that these outputs are stackable in the sense that if multiple are\n+specified, then the compiler will produce each form of output at once without\n+having to recompile.\n+\n+With all these different kinds of outputs, if crate A depends on crate B, then\n+the compiler could find B in various different forms throughout the system. The\n+only forms looked for by the compiler, however, are the `rlib` format and the\n+dynamic library format. With these two options for a dependent library, the\n+compiler must at some point make a choice between these two formats. With this\n+in mind, the compiler follows these rules when determining what format of\n+dependencies will be used:\n+\n+1. If a dynamic library is being produced, then it is required for all upstream\n+   Rust dependencies to also be dynamic. This is a limitation of the current\n+   implementation of the linkage model.  The reason behind this limitation is to\n+   prevent multiple copies of the same upstream library from showing up, and in\n+   the future it is planned to support a mixture of dynamic and static linking.\n+\n+   When producing a dynamic library, the compiler will generate an error if an\n+   upstream dependency could not be found, and also if an upstream dependency\n+   could only be found in an `rlib` format. Remember that `staticlib` formats\n+   are always ignored by `rustc` for crate-linking purposes.\n+\n+2. If a static library is being produced, all upstream dependecies are\n+   required to be available in `rlib` formats. This requirement stems from the\n+   same reasons that a dynamic library must have all dynamic dependencies.\n+\n+   Note that it is impossible to link in native dynamic dependencies to a static\n+   library, and in this case warnings will be printed about all unlinked native\n+   dynamic dependencies.\n+\n+3. If an `rlib` file is being produced, then there are no restrictions on what\n+   format the upstream dependencies are available in. It is simply required that\n+   all upstream dependencies be available for reading metadata from.\n+\n+   The reason for this is that `rlib` files do not contain any of their upstream\n+   dependencies. It wouldn't be very efficient for all `rlib` files to contain a\n+   copy of `libstd.rlib`!\n+\n+4. If an executable is being produced, then things get a little interesting. As\n+   with the above limitations in dynamic and static libraries, it is required\n+   for all upstream dependencies to be in the same format. The next question is\n+   whether to prefer a dynamic or a static format. The compiler currently favors\n+   static linking over dynamic linking, but this can be inverted with the `-Z\n+   prefer-dynamic` flag to the compiler.\n+\n+   What this means is that first the compiler will attempt to find all upstream\n+   dependencies as `rlib` files, and if successful, it will create a statically\n+   linked executable. If an upstream dependency is missing as an `rlib` file,\n+   then the compiler will force all dependencies to be dynamic and will generate\n+   errors if dynamic versions could not be found.\n+\n+In general, `--bin` or `--lib` should be sufficient for all compilation needs,\n+and the other options are just available if more fine-grained control is desired\n+over the output format of a Rust crate.\n+\n ### Logging system\n \n The runtime contains a system for directing [logging\n@@ -3762,3 +3899,5 @@ Additional specific influences can be seen from the following languages:\n * The typeclass system of Haskell.\n * The lexical identifier rule of Python.\n * The block syntax of Ruby.\n+\n+[ffi]: tutorial-ffi.html"}, {"sha": "f3a72971007ef569152dd2f7d0b544d73ca7785a", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 84, "deletions": 19, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=c8b60a2d9e4cbd782e5076e90d4acd458e4f635d", "patch": "@@ -8,13 +8,13 @@ foreign code. Rust is currently unable to call directly into a C++ library, but\n snappy includes a C interface (documented in\n [`snappy-c.h`](https://code.google.com/p/snappy/source/browse/trunk/snappy-c.h)).\n \n-The following is a minimal example of calling a foreign function which will compile if snappy is\n-installed:\n+The following is a minimal example of calling a foreign function which will\n+compile if snappy is installed:\n \n ~~~~ {.xfail-test}\n use std::libc::size_t;\n \n-#[link_args = \"-lsnappy\"]\n+#[link(name = \"snappy\")]\n extern {\n     fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n }\n@@ -25,26 +25,28 @@ fn main() {\n }\n ~~~~\n \n-The `extern` block is a list of function signatures in a foreign library, in this case with the\n-platform's C ABI. The `#[link_args]` attribute is used to instruct the linker to link against the\n-snappy library so the symbols are resolved.\n+The `extern` block is a list of function signatures in a foreign library, in\n+this case with the platform's C ABI. The `#[link(...)]` attribute is used to\n+instruct the linker to link against the snappy library so the symbols are\n+resolved.\n \n-Foreign functions are assumed to be unsafe so calls to them need to be wrapped with `unsafe {}` as a\n-promise to the compiler that everything contained within truly is safe. C libraries often expose\n-interfaces that aren't thread-safe, and almost any function that takes a pointer argument isn't\n-valid for all possible inputs since the pointer could be dangling, and raw pointers fall outside of\n+Foreign functions are assumed to be unsafe so calls to them need to be wrapped\n+with `unsafe {}` as a promise to the compiler that everything contained within\n+truly is safe. C libraries often expose interfaces that aren't thread-safe, and\n+almost any function that takes a pointer argument isn't valid for all possible\n+inputs since the pointer could be dangling, and raw pointers fall outside of\n Rust's safe memory model.\n \n-When declaring the argument types to a foreign function, the Rust compiler will not check if the\n-declaration is correct, so specifying it correctly is part of keeping the binding correct at\n-runtime.\n+When declaring the argument types to a foreign function, the Rust compiler can\n+not check if the declaration is correct, so specifying it correctly is part of\n+keeping the binding correct at runtime.\n \n The `extern` block can be extended to cover the entire snappy API:\n \n ~~~~ {.xfail-test}\n use std::libc::{c_int, size_t};\n \n-#[link_args = \"-lsnappy\"]\n+#[link(name = \"snappy\")]\n extern {\n     fn snappy_compress(input: *u8,\n                        input_length: size_t,\n@@ -232,9 +234,72 @@ fn main() {\n \n # Linking\n \n-In addition to the `#[link_args]` attribute for explicitly passing arguments to the linker, an\n-`extern mod` block will pass `-lmodname` to the linker by default unless it has a `#[nolink]`\n-attribute applied.\n+The `link` attribute on `extern` blocks provides the basic building block for\n+instructing rustc how it will link to native libraries. There are two accepted\n+forms of the link attribute today:\n+\n+* `#[link(name = \"foo\")]`\n+* `#[link(name = \"foo\", kind = \"bar\")]`\n+\n+In both of these cases, `foo` is the name of the native library that we're\n+linking to, and in the second case `bar` is the type of native library that the\n+compiler is linking to. There are currently three known types of native\n+libraries:\n+\n+* Dynamic - `#[link(name = \"readline\")]\n+* Static - `#[link(name = \"my_build_dependency\", kind = \"static\")]\n+* Frameworks - `#[link(name = \"CoreFoundation\", kind = \"framework\")]\n+\n+Note that frameworks are only available on OSX targets.\n+\n+The different `kind` values are meant to differentiate how the native library\n+participates in linkage. From a linkage perspective, the rust compiler creates\n+two flavors of artifacts: partial (rlib/staticlib) and final (dylib/binary).\n+Native dynamic libraries and frameworks are propagated to the final artifact\n+boundary, while static libraries are not propagated at all.\n+\n+A few examples of how this model can be used are:\n+\n+* A native build dependency. Sometimes some C/C++ glue is needed when writing\n+  some rust code, but distribution of the C/C++ code in a library format is just\n+  a burden. In this case, the code will be archived into `libfoo.a` and then the\n+  rust crate would declare a dependency via `#[link(name = \"foo\", kind =\n+  \"static\")]`.\n+\n+  Regardless of the flavor of output for the crate, the native static library\n+  will be included in the output, meaning that distribution of the native static\n+  library is not necessary.\n+\n+* A normal dynamic dependency. Common system libraries (like `readline`) are\n+  available on a large number of systems, and often a static copy of these\n+  libraries cannot be found. When this dependency is included in a rust crate,\n+  partial targets (like rlibs) will not link to the library, but when the rlib\n+  is included in a final target (like a binary), the native library will be\n+  linked in.\n+\n+On OSX, frameworks behave with the same semantics as a dynamic library.\n+\n+## The `link_args` attribute\n+\n+There is one other way to tell rustc how to customize linking, and that is via\n+the `link_args` attribute. This attribute is applied to `extern` blocks and\n+specifies raw flags which need to get passed to the linker when producing an\n+artifact. An example usage would be:\n+\n+~~~ {.xfail-test}\n+#[link_args = \"-foo -bar -baz\"]\n+extern {}\n+~~~\n+\n+Note that this feature is currently hidden behind the `feature(link_args)` gate\n+because this is not a sanctioned way of performing linking. Right now rustc\n+shells out to the system linker, so it makes sense to provide extra command line\n+arguments, but this will not always be the case. In the future rustc may use\n+LLVM directly to link native libraries in which case `link_args` will have no\n+meaning.\n+\n+It is highly recommended to *not* use this attribute, and rather use the more\n+formal `#[link(...)]` attribute on `extern` blocks instead.\n \n # Unsafe blocks\n \n@@ -260,7 +325,7 @@ blocks with the `static` keyword:\n ~~~{.xfail-test}\n use std::libc;\n \n-#[link_args = \"-lreadline\"]\n+#[link(name = \"readline\")]\n extern {\n     static rl_readline_version: libc::c_int;\n }\n@@ -279,7 +344,7 @@ them.\n use std::libc;\n use std::ptr;\n \n-#[link_args = \"-lreadline\"]\n+#[link(name = \"readline\")]\n extern {\n     static mut rl_prompt: *libc::c_char;\n }"}, {"sha": "6b9f8f763968e09f4a5833b67ed6265ef0d45613", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=c8b60a2d9e4cbd782e5076e90d4acd458e4f635d", "patch": "@@ -1015,7 +1015,7 @@ fn link_rlib(sess: Session, obj_filename: &Path,\n             cstore::NativeStatic => {\n                 a.add_native_library(l.as_slice());\n             }\n-            cstore::NativeUnknown => {}\n+            cstore::NativeFramework | cstore::NativeUnknown => {}\n         }\n     }\n     return a;\n@@ -1044,8 +1044,13 @@ fn link_staticlib(sess: Session, obj_filename: &Path, out_filename: &Path) {\n         };\n         a.add_rlib(&p);\n         let native_libs = csearch::get_native_libraries(sess.cstore, cnum);\n-        for lib in native_libs.iter() {\n-            sess.warn(format!(\"unlinked native library: {}\", *lib));\n+        for &(kind, ref lib) in native_libs.iter() {\n+            let name = match kind {\n+                cstore::NativeStatic => \"static library\",\n+                cstore::NativeUnknown => \"library\",\n+                cstore::NativeFramework => \"framework\",\n+            };\n+            sess.warn(format!(\"unlinked native {}: {}\", name, *lib));\n         }\n     }\n }\n@@ -1204,8 +1209,17 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n                 args.push(cratepath.as_str().unwrap().to_owned());\n \n                 let libs = csearch::get_native_libraries(sess.cstore, cnum);\n-                for lib in libs.iter() {\n-                    args.push(\"-l\" + *lib);\n+                for &(kind, ref lib) in libs.iter() {\n+                    match kind {\n+                        cstore::NativeUnknown => args.push(\"-l\" + *lib),\n+                        cstore::NativeFramework => {\n+                            args.push(~\"-framework\");\n+                            args.push(lib.to_owned());\n+                        }\n+                        cstore::NativeStatic => {\n+                            sess.bug(\"statics shouldn't be propagated\");\n+                        }\n+                    }\n                 }\n             }\n             return;\n@@ -1262,7 +1276,15 @@ fn add_local_native_libraries(args: &mut ~[~str], sess: Session) {\n         args.push(\"-L\" + path.as_str().unwrap().to_owned());\n     }\n \n-    for &(ref l, _) in cstore::get_used_libraries(sess.cstore).iter() {\n-        args.push(~\"-l\" + *l);\n+    for &(ref l, kind) in cstore::get_used_libraries(sess.cstore).iter() {\n+        match kind {\n+            cstore::NativeUnknown | cstore::NativeStatic => {\n+                args.push(\"-l\" + *l);\n+            }\n+            cstore::NativeFramework => {\n+                args.push(~\"-framework\");\n+                args.push(l.to_owned());\n+            }\n+        }\n     }\n }"}, {"sha": "f6eadfcc916e5fdb46f84879cf7663acfb152fd8", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=c8b60a2d9e4cbd782e5076e90d4acd458e4f635d", "patch": "@@ -199,6 +199,8 @@ pub static tag_region_param_def_def_id: uint = 0x102;\n \n pub static tag_native_libraries: uint = 0x103;\n pub static tag_native_libraries_lib: uint = 0x104;\n+pub static tag_native_libraries_name: uint = 0x105;\n+pub static tag_native_libraries_kind: uint = 0x106;\n \n pub struct LinkMeta {\n     name: @str,"}, {"sha": "b425f1449f5e266e3b42f7c788912550749a3b81", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=c8b60a2d9e4cbd782e5076e90d4acd458e4f635d", "patch": "@@ -18,6 +18,7 @@ use metadata::loader;\n use std::hashmap::HashMap;\n use syntax::ast;\n use std::vec;\n+use syntax::abi;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{Span, dummy_sp};\n@@ -191,10 +192,22 @@ fn visit_item(e: &Env, i: @ast::item) {\n                             \"kind\" == k.name()\n                         }).and_then(|a| a.value_str());\n                         let kind = match kind {\n-                            Some(k) if \"static\" == k => cstore::NativeStatic,\n                             Some(k) => {\n-                                e.sess.span_fatal(i.span,\n-                                    format!(\"unknown kind: `{}`\", k));\n+                                if \"static\" == k {\n+                                    cstore::NativeStatic\n+                                } else if e.sess.targ_cfg.os == abi::OsMacos &&\n+                                          \"framework\" == k {\n+                                    cstore::NativeFramework\n+                                } else if \"framework\" == k {\n+                                    e.sess.span_err(m.span,\n+                                        \"native frameworks are only available \\\n+                                         on OSX targets\");\n+                                    cstore::NativeUnknown\n+                                } else {\n+                                    e.sess.span_err(m.span,\n+                                        format!(\"unknown kind: `{}`\", k));\n+                                    cstore::NativeUnknown\n+                                }\n                             }\n                             None => cstore::NativeUnknown\n                         };\n@@ -204,9 +217,10 @@ fn visit_item(e: &Env, i: @ast::item) {\n                         let n = match n {\n                             Some(n) => n,\n                             None => {\n-                                e.sess.span_fatal(i.span,\n+                                e.sess.span_err(m.span,\n                                     \"#[link(...)] specified without \\\n                                      `name = \\\"foo\\\"`\");\n+                                @\"foo\"\n                             }\n                         };\n                         cstore::add_used_library(cstore, n.to_owned(), kind);"}, {"sha": "c1c56e94f27e70de6da0b8a04fbac614d1a80e21", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=c8b60a2d9e4cbd782e5076e90d4acd458e4f635d", "patch": "@@ -263,7 +263,8 @@ pub fn get_item_visibility(cstore: @mut cstore::CStore,\n }\n \n pub fn get_native_libraries(cstore: @mut cstore::CStore,\n-                            crate_num: ast::CrateNum) -> ~[~str] {\n+                            crate_num: ast::CrateNum)\n+                                -> ~[(cstore::NativeLibaryKind, ~str)] {\n     let cdata = cstore::get_crate_data(cstore, crate_num);\n     decoder::get_native_libraries(cdata)\n }"}, {"sha": "c2f6443ed5401b5aaf492453103d82b01d7355c5", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=c8b60a2d9e4cbd782e5076e90d4acd458e4f635d", "patch": "@@ -40,10 +40,11 @@ pub enum LinkagePreference {\n     RequireStatic,\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, FromPrimitive)]\n pub enum NativeLibaryKind {\n-    NativeStatic,\n-    NativeUnknown,\n+    NativeStatic,    // native static library (.a archive)\n+    NativeFramework, // OSX-specific\n+    NativeUnknown,   // default way to specify a dynamic library\n }\n \n // Where a crate came from on the local filesystem. One of these two options"}, {"sha": "b5746cec58d64440ed54f9d2c687b84862291f89", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=c8b60a2d9e4cbd782e5076e90d4acd458e4f635d", "patch": "@@ -1530,11 +1530,16 @@ pub fn get_trait_of_method(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n }\n \n \n-pub fn get_native_libraries(cdata: Cmd) -> ~[~str] {\n+pub fn get_native_libraries(cdata: Cmd) -> ~[(cstore::NativeLibaryKind, ~str)] {\n     let libraries = reader::get_doc(reader::Doc(cdata.data), tag_native_libraries);\n     let mut result = ~[];\n     reader::tagged_docs(libraries, tag_native_libraries_lib, |lib_doc| {\n-        result.push(lib_doc.as_str());\n+        let kind_doc = reader::get_doc(lib_doc, tag_native_libraries_kind);\n+        let name_doc = reader::get_doc(lib_doc, tag_native_libraries_name);\n+        let kind: cstore::NativeLibaryKind =\n+            FromPrimitive::from_u32(reader::doc_as_u32(kind_doc)).unwrap();\n+        let name = name_doc.as_str();\n+        result.push((kind, name));\n         true\n     });\n     return result;"}, {"sha": "2f70527464e304fdc1a65d1b7dde0b689070c4db", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=c8b60a2d9e4cbd782e5076e90d4acd458e4f635d", "patch": "@@ -1640,10 +1640,18 @@ fn encode_native_libraries(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     for &(ref lib, kind) in cstore::get_used_libraries(ecx.cstore).iter() {\n         match kind {\n             cstore::NativeStatic => {} // these libraries are not propagated\n-            cstore::NativeUnknown => {\n+            cstore::NativeFramework | cstore::NativeUnknown => {\n                 ebml_w.start_tag(tag_native_libraries_lib);\n+\n+                ebml_w.start_tag(tag_native_libraries_kind);\n+                ebml_w.writer.write_be_u32(kind as u32);\n+                ebml_w.end_tag();\n+\n+                ebml_w.start_tag(tag_native_libraries_name);\n                 ebml_w.writer.write(lib.as_bytes());\n                 ebml_w.end_tag();\n+\n+                ebml_w.end_tag();\n             }\n         }\n     }"}, {"sha": "0616da266021e86a9397680bd0313d9bb96fc645", "filename": "src/test/compile-fail/bad-extern-link-attrs.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/src%2Ftest%2Fcompile-fail%2Fbad-extern-link-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/src%2Ftest%2Fcompile-fail%2Fbad-extern-link-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-extern-link-attrs.rs?ref=c8b60a2d9e4cbd782e5076e90d4acd458e4f635d", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[link()] //~ ERROR: specified without `name =\n+#[link(name = \"foo\")]\n+#[link(name = \"foo\", kind = \"bar\")] //~ ERROR: unknown kind\n+extern {}\n+\n+fn main() {}"}, {"sha": "615936296564eae9f6fa9288467dfe6b08b6b380", "filename": "src/test/compile-fail/osx-frameworks.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/src%2Ftest%2Fcompile-fail%2Fosx-frameworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/src%2Ftest%2Fcompile-fail%2Fosx-frameworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fosx-frameworks.rs?ref=c8b60a2d9e4cbd782e5076e90d4acd458e4f635d", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-macos this is supposed to succeed on osx\n+\n+#[link(name = \"foo\", kind = \"framework\")]\n+extern {}\n+//~^^ ERROR: native frameworks are only available on OSX\n+\n+fn main() {\n+}"}, {"sha": "cfb7a8e43befa10d9f5c885fcce102770e08be37", "filename": "src/test/run-pass/osx-frameworks.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/src%2Ftest%2Frun-pass%2Fosx-frameworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8b60a2d9e4cbd782e5076e90d4acd458e4f635d/src%2Ftest%2Frun-pass%2Fosx-frameworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fosx-frameworks.rs?ref=c8b60a2d9e4cbd782e5076e90d4acd458e4f635d", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::libc;\n+\n+#[cfg(target_os = \"macos\")]\n+#[link(name = \"CoreFoundation\", kind = \"framework\")]\n+extern {\n+    fn CFRunLoopGetTypeID() -> libc::c_ulong;\n+}\n+\n+#[cfg(target_os = \"macos\")]\n+fn main() {\n+    unsafe { CFRunLoopGetTypeID(); }\n+}\n+\n+#[cfg(not(target_os = \"macos\"))]\n+pub fn main() {}"}]}