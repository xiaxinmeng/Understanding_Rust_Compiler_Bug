{"sha": "310d8996f40fceaa8d294577276cfb1b080c8bc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxMGQ4OTk2ZjQwZmNlYWE4ZDI5NDU3NzI3NmNmYjFiMDgwYzhiYzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-18T07:27:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-18T07:27:49Z"}, "message": "Auto merge of #33654 - petrochenkov:hirident, r=nrc\n\nRemove hir::Ident\n\nNow when name resolution is done on AST, `hir::Ident` is no longer necessary.\nSee https://github.com/rust-lang/rust/pull/30145 for more details.\n\nr? @nrc", "tree": {"sha": "42009bb563e6ab18b8ed13450fee15fd7ee09da5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42009bb563e6ab18b8ed13450fee15fd7ee09da5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/310d8996f40fceaa8d294577276cfb1b080c8bc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/310d8996f40fceaa8d294577276cfb1b080c8bc9", "html_url": "https://github.com/rust-lang/rust/commit/310d8996f40fceaa8d294577276cfb1b080c8bc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/310d8996f40fceaa8d294577276cfb1b080c8bc9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75e23e1b032d87300392a4f3835bde8d5d873823", "url": "https://api.github.com/repos/rust-lang/rust/commits/75e23e1b032d87300392a4f3835bde8d5d873823", "html_url": "https://github.com/rust-lang/rust/commit/75e23e1b032d87300392a4f3835bde8d5d873823"}, {"sha": "02a1eef6e4eb4bcc214e0e00ddc62406c8990e2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/02a1eef6e4eb4bcc214e0e00ddc62406c8990e2d", "html_url": "https://github.com/rust-lang/rust/commit/02a1eef6e4eb4bcc214e0e00ddc62406c8990e2d"}], "stats": {"total": 399, "additions": 160, "deletions": 239}, "files": [{"sha": "76699f13959eacc4f251d5176c8080faa9c34b79", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -285,15 +285,15 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprBreak(label) => {\n-                let loop_scope = self.find_scope(expr, label.map(|l| l.node.name));\n+                let loop_scope = self.find_scope(expr, label.map(|l| l.node));\n                 let b = self.add_ast_node(expr.id, &[pred]);\n                 self.add_exiting_edge(expr, b,\n                                       loop_scope, loop_scope.break_index);\n                 self.add_unreachable_node()\n             }\n \n             hir::ExprAgain(label) => {\n-                let loop_scope = self.find_scope(expr, label.map(|l| l.node.name));\n+                let loop_scope = self.find_scope(expr, label.map(|l| l.node));\n                 let a = self.add_ast_node(expr.id, &[pred]);\n                 self.add_exiting_edge(expr, a,\n                                       loop_scope, loop_scope.continue_index);"}, {"sha": "a91d16f25a2b89a484966ced3a62a6b06f2d550e", "filename": "src/librustc/hir/fold.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -126,10 +126,6 @@ pub trait Folder : Sized {\n         noop_fold_name(n, self)\n     }\n \n-    fn fold_ident(&mut self, i: Ident) -> Ident {\n-        noop_fold_ident(i, self)\n-    }\n-\n     fn fold_usize(&mut self, i: usize) -> usize {\n         noop_fold_usize(i, self)\n     }\n@@ -407,20 +403,16 @@ pub fn noop_fold_name<T: Folder>(n: Name, _: &mut T) -> Name {\n     n\n }\n \n-pub fn noop_fold_ident<T: Folder>(i: Ident, _: &mut T) -> Ident {\n-    i\n-}\n-\n pub fn noop_fold_usize<T: Folder>(i: usize, _: &mut T) -> usize {\n     i\n }\n \n pub fn noop_fold_path<T: Folder>(Path { global, segments, span }: Path, fld: &mut T) -> Path {\n     Path {\n         global: global,\n-        segments: segments.move_map(|PathSegment { identifier, parameters }| {\n+        segments: segments.move_map(|PathSegment { name, parameters }| {\n             PathSegment {\n-                identifier: fld.fold_ident(identifier),\n+                name: fld.fold_name(name),\n                 parameters: fld.fold_path_parameters(parameters),\n             }\n         }),\n@@ -926,7 +918,7 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n                     PatKind::Ident(binding_mode,\n                              Spanned {\n                                  span: folder.new_span(pth1.span),\n-                                 node: folder.fold_ident(pth1.node),\n+                                 node: folder.fold_name(pth1.node),\n                              },\n                              sub.map(|x| folder.fold_pat(x)))\n                 }\n@@ -1014,14 +1006,14 @@ pub fn noop_fold_expr<T: Folder>(Expr { id, node, span, attrs }: Expr, folder: &\n                        folder.fold_block(tr),\n                        fl.map(|x| folder.fold_expr(x)))\n             }\n-            ExprWhile(cond, body, opt_ident) => {\n+            ExprWhile(cond, body, opt_name) => {\n                 ExprWhile(folder.fold_expr(cond),\n                           folder.fold_block(body),\n-                          opt_ident.map(|i| folder.fold_ident(i)))\n+                          opt_name.map(|i| folder.fold_name(i)))\n             }\n-            ExprLoop(body, opt_ident) => {\n+            ExprLoop(body, opt_name) => {\n                 ExprLoop(folder.fold_block(body),\n-                         opt_ident.map(|i| folder.fold_ident(i)))\n+                         opt_name.map(|i| folder.fold_name(i)))\n             }\n             ExprMatch(expr, arms, source) => {\n                 ExprMatch(folder.fold_expr(expr),\n@@ -1061,11 +1053,11 @@ pub fn noop_fold_expr<T: Folder>(Expr { id, node, span, attrs }: Expr, folder: &\n                 });\n                 ExprPath(qself, folder.fold_path(path))\n             }\n-            ExprBreak(opt_ident) => ExprBreak(opt_ident.map(|label| {\n-                respan(folder.new_span(label.span), folder.fold_ident(label.node))\n+            ExprBreak(opt_name) => ExprBreak(opt_name.map(|label| {\n+                respan(folder.new_span(label.span), folder.fold_name(label.node))\n             })),\n-            ExprAgain(opt_ident) => ExprAgain(opt_ident.map(|label| {\n-                respan(folder.new_span(label.span), folder.fold_ident(label.node))\n+            ExprAgain(opt_name) => ExprAgain(opt_name.map(|label| {\n+                respan(folder.new_span(label.span), folder.fold_name(label.node))\n             })),\n             ExprRet(e) => ExprRet(e.map(|x| folder.fold_expr(x))),\n             ExprInlineAsm(asm, outputs, inputs) => {"}, {"sha": "2e9e433b830fcb88b7c497f66e988f13a8ccf8bc", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -97,9 +97,6 @@ pub trait Visitor<'v> : Sized {\n     fn visit_name(&mut self, _span: Span, _name: Name) {\n         // Nothing to do.\n     }\n-    fn visit_ident(&mut self, span: Span, ident: Ident) {\n-        walk_ident(self, span, ident);\n-    }\n     fn visit_mod(&mut self, m: &'v Mod, _s: Span, _n: NodeId) {\n         walk_mod(self, m)\n     }\n@@ -211,16 +208,6 @@ pub fn walk_opt_name<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, opt_name:\n     }\n }\n \n-pub fn walk_opt_ident<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, opt_ident: Option<Ident>) {\n-    for ident in opt_ident {\n-        visitor.visit_ident(span, ident);\n-    }\n-}\n-\n-pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, ident: Ident) {\n-    visitor.visit_name(span, ident.name);\n-}\n-\n /// Walks the contents of a crate. See also `Crate::visit_all_items`.\n pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n     visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID);\n@@ -439,7 +426,7 @@ pub fn walk_path_list_item<'v, V: Visitor<'v>>(visitor: &mut V,\n pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,\n                                              path_span: Span,\n                                              segment: &'v PathSegment) {\n-    visitor.visit_ident(path_span, segment.identifier);\n+    visitor.visit_name(path_span, segment.name);\n     visitor.visit_path_parameters(path_span, &segment.parameters);\n }\n \n@@ -495,7 +482,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n             visitor.visit_pat(subpattern)\n         }\n         PatKind::Ident(_, ref pth1, ref optional_subpattern) => {\n-            visitor.visit_ident(pth1.span, pth1.node);\n+            visitor.visit_name(pth1.span, pth1.node);\n             walk_list!(visitor, visit_pat, optional_subpattern);\n         }\n         PatKind::Lit(ref expression) => visitor.visit_expr(expression),\n@@ -750,14 +737,14 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_block(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprWhile(ref subexpression, ref block, opt_ident) => {\n+        ExprWhile(ref subexpression, ref block, opt_name) => {\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n-            walk_opt_ident(visitor, expression.span, opt_ident)\n+            walk_opt_name(visitor, expression.span, opt_name)\n         }\n-        ExprLoop(ref block, opt_ident) => {\n+        ExprLoop(ref block, opt_name) => {\n             visitor.visit_block(block);\n-            walk_opt_ident(visitor, expression.span, opt_ident)\n+            walk_opt_name(visitor, expression.span, opt_name)\n         }\n         ExprMatch(ref subexpression, ref arms, _) => {\n             visitor.visit_expr(subexpression);\n@@ -796,9 +783,9 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             }\n             visitor.visit_path(path, expression.id)\n         }\n-        ExprBreak(ref opt_sp_ident) | ExprAgain(ref opt_sp_ident) => {\n-            for sp_ident in opt_sp_ident {\n-                visitor.visit_ident(sp_ident.span, sp_ident.node);\n+        ExprBreak(ref opt_sp_name) | ExprAgain(ref opt_sp_name) => {\n+            for sp_name in opt_sp_name {\n+                visitor.visit_name(sp_name.span, sp_name.node);\n             }\n         }\n         ExprRet(ref optional_expression) => {"}, {"sha": "67ea7951de71967ff5234b6e560bbe1ea5f214c7", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 53, "deletions": 36, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -44,7 +44,7 @@ use hir;\n use hir::map::Definitions;\n use hir::map::definitions::DefPathData;\n use hir::def_id::{DefIndex, DefId};\n-use hir::def::Def;\n+use hir::def::{Def, PathResolution};\n \n use std::collections::BTreeMap;\n use std::iter;\n@@ -53,7 +53,7 @@ use syntax::attr::{ThinAttributes, ThinAttributesExt};\n use syntax::ext::mtwt;\n use syntax::ptr::P;\n use syntax::codemap::{respan, Spanned, Span};\n-use syntax::parse::token;\n+use syntax::parse::token::{self, keywords};\n use syntax::std_inject;\n use syntax::visit::{self, Visitor};\n \n@@ -72,6 +72,9 @@ pub trait Resolver {\n     // Resolve a global hir path generated by the lowerer when expanding `for`, `if let`, etc.\n     fn resolve_generated_global_path(&mut self, path: &hir::Path, is_value: bool) -> Def;\n \n+    // Obtain the resolution for a node id\n+    fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution>;\n+\n     // Record the resolution of a path or binding generated by the lowerer when expanding.\n     fn record_resolution(&mut self, id: NodeId, def: Def);\n \n@@ -85,6 +88,9 @@ impl Resolver for DummyResolver {\n     fn resolve_generated_global_path(&mut self, _path: &hir::Path, _is_value: bool) -> Def {\n         Def::Err\n     }\n+    fn get_resolution(&mut self, _id: NodeId) -> Option<PathResolution> {\n+        None\n+    }\n     fn record_resolution(&mut self, _id: NodeId, _def: Def) {}\n     fn definitions(&mut self) -> Option<&mut Definitions> {\n         None\n@@ -150,8 +156,8 @@ impl<'a> LoweringContext<'a> {\n         self.id_assigner.next_node_id()\n     }\n \n-    fn str_to_ident(&self, s: &'static str) -> hir::Ident {\n-        hir::Ident::from_name(token::gensym(s))\n+    fn str_to_ident(&self, s: &'static str) -> Name {\n+        token::gensym(s)\n     }\n \n     fn with_parent_def<T, F>(&mut self, parent_id: NodeId, f: F) -> T\n@@ -169,10 +175,11 @@ impl<'a> LoweringContext<'a> {\n         result\n     }\n \n-    fn lower_ident(&mut self, ident: Ident) -> hir::Ident {\n-        hir::Ident {\n-            name: mtwt::resolve(ident),\n-            unhygienic_name: ident.name,\n+    fn lower_ident(&mut self, ident: Ident) -> Name {\n+        if ident.name != keywords::Invalid.name() {\n+            mtwt::resolve(ident)\n+        } else {\n+            ident.name\n         }\n     }\n \n@@ -318,21 +325,17 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    // Path segments are usually unhygienic, hygienic path segments can occur only in\n-    // identifier-like paths originating from `ExprPath`.\n-    // Make life simpler for rustc_resolve by renaming only such segments.\n-    fn lower_path_full(&mut self, p: &Path, maybe_hygienic: bool) -> hir::Path {\n-        let maybe_hygienic = maybe_hygienic && !p.global && p.segments.len() == 1;\n+    fn lower_path_full(&mut self, p: &Path, rename: bool) -> hir::Path {\n         hir::Path {\n             global: p.global,\n             segments: p.segments\n                        .iter()\n                        .map(|&PathSegment { identifier, ref parameters }| {\n                            hir::PathSegment {\n-                               identifier: if maybe_hygienic {\n+                               name: if rename {\n                                    self.lower_ident(identifier)\n                                } else {\n-                                   hir::Ident::from_name(identifier.name)\n+                                   identifier.name\n                                },\n                                parameters: self.lower_path_parameters(parameters),\n                            }\n@@ -849,9 +852,14 @@ impl<'a> LoweringContext<'a> {\n                 PatKind::Wild => hir::PatKind::Wild,\n                 PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n                     self.with_parent_def(p.id, |this| {\n+                        let name = match this.resolver.get_resolution(p.id).map(|d| d.full_def()) {\n+                            // Only pattern bindings are renamed\n+                            None | Some(Def::Local(..)) => this.lower_ident(pth1.node),\n+                            _ => pth1.node.name,\n+                        };\n                         hir::PatKind::Ident(this.lower_binding_mode(binding_mode),\n-                                      respan(pth1.span, this.lower_ident(pth1.node)),\n-                                      sub.as_ref().map(|x| this.lower_pat(x)))\n+                                            respan(pth1.span, name),\n+                                            sub.as_ref().map(|x| this.lower_pat(x)))\n                     })\n                 }\n                 PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n@@ -1215,7 +1223,16 @@ impl<'a> LoweringContext<'a> {\n                             position: position,\n                         }\n                     });\n-                    hir::ExprPath(hir_qself, self.lower_path_full(path, qself.is_none()))\n+                    let rename = if path.segments.len() == 1 {\n+                        // Only local variables are renamed\n+                        match self.resolver.get_resolution(e.id).map(|d| d.full_def()) {\n+                            Some(Def::Local(..)) | Some(Def::Upvar(..)) => true,\n+                            _ => false,\n+                        }\n+                    } else {\n+                        false\n+                    };\n+                    hir::ExprPath(hir_qself, self.lower_path_full(path, rename))\n                 }\n                 ExprKind::Break(opt_ident) => hir::ExprBreak(opt_ident.map(|sp_ident| {\n                     respan(sp_ident.span, self.lower_ident(sp_ident.node))\n@@ -1692,7 +1709,7 @@ impl<'a> LoweringContext<'a> {\n         self.expr(span, hir::ExprCall(e, args), attrs)\n     }\n \n-    fn expr_ident(&mut self, span: Span, id: hir::Ident, attrs: ThinAttributes, binding: NodeId)\n+    fn expr_ident(&mut self, span: Span, id: Name, attrs: ThinAttributes, binding: NodeId)\n                   -> P<hir::Expr> {\n         let expr_path = hir::ExprPath(None, self.path_ident(span, id));\n         let expr = self.expr(span, expr_path, attrs);\n@@ -1760,7 +1777,7 @@ impl<'a> LoweringContext<'a> {\n     fn stmt_let(&mut self,\n                 sp: Span,\n                 mutbl: bool,\n-                ident: hir::Ident,\n+                ident: Name,\n                 ex: P<hir::Expr>,\n                 attrs: ThinAttributes)\n                 -> (hir::Stmt, NodeId) {\n@@ -1834,24 +1851,24 @@ impl<'a> LoweringContext<'a> {\n         pat\n     }\n \n-    fn pat_ident(&mut self, span: Span, ident: hir::Ident) -> P<hir::Pat> {\n-        self.pat_ident_binding_mode(span, ident, hir::BindByValue(hir::MutImmutable))\n+    fn pat_ident(&mut self, span: Span, name: Name) -> P<hir::Pat> {\n+        self.pat_ident_binding_mode(span, name, hir::BindByValue(hir::MutImmutable))\n     }\n \n-    fn pat_ident_binding_mode(&mut self, span: Span, ident: hir::Ident, bm: hir::BindingMode)\n+    fn pat_ident_binding_mode(&mut self, span: Span, name: Name, bm: hir::BindingMode)\n                               -> P<hir::Pat> {\n         let pat_ident = hir::PatKind::Ident(bm,\n                                             Spanned {\n                                                 span: span,\n-                                                node: ident,\n+                                                node: name,\n                                             },\n                                             None);\n \n         let pat = self.pat(span, pat_ident);\n \n         let parent_def = self.parent_def;\n         let def = self.resolver.definitions().map(|defs| {\n-            let def_path_data = DefPathData::Binding(ident.name);\n+            let def_path_data = DefPathData::Binding(name);\n             let def_index = defs.create_def_with_parent(parent_def, pat.id, def_path_data);\n             Def::Local(DefId::local(def_index), pat.id)\n         }).unwrap_or(Def::Err);\n@@ -1872,36 +1889,36 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn path_ident(&mut self, span: Span, id: hir::Ident) -> hir::Path {\n+    fn path_ident(&mut self, span: Span, id: Name) -> hir::Path {\n         self.path(span, vec![id])\n     }\n \n-    fn path(&mut self, span: Span, strs: Vec<hir::Ident>) -> hir::Path {\n+    fn path(&mut self, span: Span, strs: Vec<Name>) -> hir::Path {\n         self.path_all(span, false, strs, hir::HirVec::new(), hir::HirVec::new(), hir::HirVec::new())\n     }\n \n-    fn path_global(&mut self, span: Span, strs: Vec<hir::Ident>) -> hir::Path {\n+    fn path_global(&mut self, span: Span, strs: Vec<Name>) -> hir::Path {\n         self.path_all(span, true, strs, hir::HirVec::new(), hir::HirVec::new(), hir::HirVec::new())\n     }\n \n     fn path_all(&mut self,\n                 sp: Span,\n                 global: bool,\n-                mut idents: Vec<hir::Ident>,\n+                mut names: Vec<Name>,\n                 lifetimes: hir::HirVec<hir::Lifetime>,\n                 types: hir::HirVec<P<hir::Ty>>,\n                 bindings: hir::HirVec<hir::TypeBinding>)\n                 -> hir::Path {\n-        let last_identifier = idents.pop().unwrap();\n-        let mut segments: Vec<hir::PathSegment> = idents.into_iter().map(|ident| {\n+        let last_identifier = names.pop().unwrap();\n+        let mut segments: Vec<hir::PathSegment> = names.into_iter().map(|name| {\n             hir::PathSegment {\n-                identifier: ident,\n+                name: name,\n                 parameters: hir::PathParameters::none(),\n            }\n         }).collect();\n \n         segments.push(hir::PathSegment {\n-            identifier: last_identifier,\n+            name: last_identifier,\n             parameters: hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n                 lifetimes: lifetimes,\n                 types: types,\n@@ -1915,12 +1932,12 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn std_path(&mut self, components: &[&str]) -> Vec<hir::Ident> {\n+    fn std_path(&mut self, components: &[&str]) -> Vec<Name> {\n         let mut v = Vec::new();\n         if let Some(s) = self.crate_root {\n-            v.push(hir::Ident::from_name(token::intern(s)));\n+            v.push(token::intern(s));\n         }\n-        v.extend(components.iter().map(|s| hir::Ident::from_name(token::intern(s))));\n+        v.extend(components.iter().map(|s| token::intern(s)));\n         return v;\n     }\n "}, {"sha": "e783d84dc1b4ad8f9f040e532449a43276e797aa", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -396,8 +396,8 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n     fn visit_pat(&mut self, pat: &'ast hir::Pat) {\n         let parent_def = self.parent_def;\n \n-        if let hir::PatKind::Ident(_, id, _) = pat.node {\n-            let def = self.create_def(pat.id, DefPathData::Binding(id.node.name));\n+        if let hir::PatKind::Ident(_, name, _) = pat.node {\n+            let def = self.create_def(pat.id, DefPathData::Binding(name.node));\n             self.parent_def = Some(def);\n         }\n "}, {"sha": "c0bbccad5f20f68e18d320b2413ea4ea2cb0ff6d", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -562,9 +562,7 @@ impl<'ast> Map<'ast> {\n             NodeVariant(v) => v.node.name,\n             NodeLifetime(lt) => lt.name,\n             NodeTyParam(tp) => tp.name,\n-            NodeLocal(&Pat { node: PatKind::Ident(_,l,_), .. }) => {\n-                l.node.name\n-            },\n+            NodeLocal(&Pat { node: PatKind::Ident(_,l,_), .. }) => l.node,\n             NodeStructCtor(_) => self.name(self.get_parent(id)),\n             _ => bug!(\"no name for {}\", self.node_to_string(id))\n         }"}, {"sha": "39a6ec9f3af270ed26329079b3a0e9c235ad2211", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 12, "deletions": 79, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -46,8 +46,6 @@ use syntax::ptr::P;\n \n use std::collections::BTreeMap;\n use std::fmt;\n-use std::hash::{Hash, Hasher};\n-use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n /// HIR doesn't commit to a concrete storage type and have its own alias for a vector.\n /// It can be `Vec`, `P<[T]>` or potentially `Box<[T]>`, or some other container with similar\n@@ -76,63 +74,6 @@ pub mod pat_util;\n pub mod print;\n pub mod svh;\n \n-/// Identifier in HIR\n-#[derive(Clone, Copy, Eq)]\n-pub struct Ident {\n-    /// Hygienic name (renamed), should be used by default\n-    pub name: Name,\n-    /// Unhygienic name (original, not renamed), needed in few places in name resolution\n-    pub unhygienic_name: Name,\n-}\n-\n-impl Ident {\n-    /// Creates a HIR identifier with both `name` and `unhygienic_name` initialized with\n-    /// the argument. Hygiene properties of the created identifier depend entirely on this\n-    /// argument. If the argument is a plain interned string `intern(\"iter\")`, then the result\n-    /// is unhygienic and can interfere with other entities named \"iter\". If the argument is\n-    /// a \"fresh\" name created with `gensym(\"iter\")`, then the result is hygienic and can't\n-    /// interfere with other entities having the same string as a name.\n-    pub fn from_name(name: Name) -> Ident {\n-        Ident { name: name, unhygienic_name: name }\n-    }\n-}\n-\n-impl PartialEq for Ident {\n-    fn eq(&self, other: &Ident) -> bool {\n-        self.name == other.name\n-    }\n-}\n-\n-impl Hash for Ident {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.name.hash(state)\n-    }\n-}\n-\n-impl fmt::Debug for Ident {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&self.name, f)\n-    }\n-}\n-\n-impl fmt::Display for Ident {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.name, f)\n-    }\n-}\n-\n-impl Encodable for Ident {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        self.name.encode(s)\n-    }\n-}\n-\n-impl Decodable for Ident {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Ident, D::Error> {\n-        Ok(Ident::from_name(Name::decode(d)?))\n-    }\n-}\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,\n@@ -184,12 +125,12 @@ impl fmt::Display for Path {\n impl Path {\n     /// Convert a span and an identifier to the corresponding\n     /// 1-segment path.\n-    pub fn from_ident(s: Span, ident: Ident) -> Path {\n+    pub fn from_name(s: Span, name: Name) -> Path {\n         Path {\n             span: s,\n             global: false,\n             segments: hir_vec![PathSegment {\n-                identifier: ident,\n+                name: name,\n                 parameters: PathParameters::none()\n             }],\n         }\n@@ -201,15 +142,7 @@ impl Path {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n-    ///\n-    /// Hygiene properties of this identifier are worth noting.\n-    /// Most path segments are not hygienic and they are not renamed during\n-    /// lowering from AST to HIR (see comments to `fn lower_path`). However segments from\n-    /// unqualified paths with one segment originating from `ExprPath` (local-variable-like paths)\n-    /// can be hygienic, so they are renamed. You should not normally care about this peculiarity\n-    /// and just use `identifier.name` unless you modify identifier resolution code\n-    /// (`fn resolve_identifier` and other functions called by it in `rustc_resolve`).\n-    pub identifier: Ident,\n+    pub name: Name,\n \n     /// Type/lifetime parameters attached to this path. They come in\n     /// two flavors: `Path<A,B,C>` and `Path(A,B) -> C`. Note that\n@@ -600,7 +533,7 @@ pub enum PatKind {\n     /// which it is. The resolver determines this, and\n     /// records this pattern's `NodeId` in an auxiliary\n     /// set (of \"PatIdents that refer to unit patterns or constants\").\n-    Ident(BindingMode, Spanned<Ident>, Option<P<Pat>>),\n+    Ident(BindingMode, Spanned<Name>, Option<P<Pat>>),\n \n     /// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.\n     /// The `bool` is `true` in the presence of a `..`.\n@@ -940,11 +873,11 @@ pub enum Expr_ {\n     /// A while loop, with an optional label\n     ///\n     /// `'label: while expr { block }`\n-    ExprWhile(P<Expr>, P<Block>, Option<Ident>),\n+    ExprWhile(P<Expr>, P<Block>, Option<Name>),\n     /// Conditionless loop (can be exited with break, continue, or return)\n     ///\n     /// `'label: loop { block }`\n-    ExprLoop(P<Block>, Option<Ident>),\n+    ExprLoop(P<Block>, Option<Name>),\n     /// A `match` block, with a source that indicates whether or not it is\n     /// the result of a desugaring, and if so, which kind.\n     ExprMatch(P<Expr>, HirVec<Arm>, MatchSource),\n@@ -980,9 +913,9 @@ pub enum Expr_ {\n     /// A referencing operation (`&a` or `&mut a`)\n     ExprAddrOf(Mutability, P<Expr>),\n     /// A `break`, with an optional label to break\n-    ExprBreak(Option<Spanned<Ident>>),\n+    ExprBreak(Option<Spanned<Name>>),\n     /// A `continue`, with an optional label\n-    ExprAgain(Option<Spanned<Ident>>),\n+    ExprAgain(Option<Spanned<Name>>),\n     /// A `return`, with an optional value to be returned\n     ExprRet(Option<P<Expr>>),\n \n@@ -1209,8 +1142,8 @@ pub type ExplicitSelf = Spanned<SelfKind>;\n \n impl Arg {\n     pub fn to_self(&self) -> Option<ExplicitSelf> {\n-        if let PatKind::Ident(BindByValue(mutbl), ident, _) = self.pat.node {\n-            if ident.node.unhygienic_name == keywords::SelfValue.name() {\n+        if let PatKind::Ident(BindByValue(mutbl), name, _) = self.pat.node {\n+            if name.node.unhygienize() == keywords::SelfValue.name() {\n                 return match self.ty.node {\n                     TyInfer => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n                     TyRptr(lt, MutTy{ref ty, mutbl}) if ty.node == TyInfer => {\n@@ -1225,8 +1158,8 @@ impl Arg {\n     }\n \n     pub fn is_self(&self) -> bool {\n-        if let PatKind::Ident(_, ident, _) = self.pat.node {\n-            ident.node.unhygienic_name == keywords::SelfValue.name()\n+        if let PatKind::Ident(_, name, _) = self.pat.node {\n+            name.node.unhygienize() == keywords::SelfValue.name()\n         } else {\n             false\n         }"}, {"sha": "15f2310607ffe9ea6bb681c96adea4a511076a4a", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -113,19 +113,6 @@ pub fn pat_is_binding_or_wild(dm: &DefMap, pat: &hir::Pat) -> bool {\n /// `match foo() { Some(a) => (), None => () }`\n pub fn pat_bindings<I>(dm: &RefCell<DefMap>, pat: &hir::Pat, mut it: I) where\n     I: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<ast::Name>),\n-{\n-    pat.walk(|p| {\n-        match p.node {\n-          PatKind::Ident(binding_mode, ref pth, _) if pat_is_binding(&dm.borrow(), p) => {\n-            it(binding_mode, p.id, p.span, &respan(pth.span, pth.node.name));\n-          }\n-          _ => {}\n-        }\n-        true\n-    });\n-}\n-pub fn pat_bindings_ident<I>(dm: &RefCell<DefMap>, pat: &hir::Pat, mut it: I) where\n-    I: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<hir::Ident>),\n {\n     pat.walk(|p| {\n         match p.node {\n@@ -201,7 +188,7 @@ pub fn pat_contains_bindings_or_wild(dm: &DefMap, pat: &hir::Pat) -> bool {\n pub fn simple_name<'a>(pat: &'a hir::Pat) -> Option<ast::Name> {\n     match pat.node {\n         PatKind::Ident(hir::BindByValue(_), ref path1, None) => {\n-            Some(path1.node.name)\n+            Some(path1.node)\n         }\n         _ => {\n             None\n@@ -210,8 +197,7 @@ pub fn simple_name<'a>(pat: &'a hir::Pat) -> Option<ast::Name> {\n }\n \n pub fn def_to_path<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> hir::Path {\n-    let name = tcx.item_name(id);\n-    hir::Path::from_ident(DUMMY_SP, hir::Ident::from_name(name))\n+    hir::Path::from_name(DUMMY_SP, tcx.item_name(id))\n }\n \n /// Return variants that are necessary to exist for the pattern to match."}, {"sha": "4455c7da3ba3f568c25ce954eae938954dd5ebd2", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -1351,19 +1351,19 @@ impl<'a> State<'a> {\n             hir::ExprIf(ref test, ref blk, ref elseopt) => {\n                 self.print_if(&test, &blk, elseopt.as_ref().map(|e| &**e))?;\n             }\n-            hir::ExprWhile(ref test, ref blk, opt_ident) => {\n-                if let Some(ident) = opt_ident {\n-                    self.print_name(ident.name)?;\n+            hir::ExprWhile(ref test, ref blk, opt_name) => {\n+                if let Some(name) = opt_name {\n+                    self.print_name(name)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"while\")?;\n                 self.print_expr(&test)?;\n                 space(&mut self.s)?;\n                 self.print_block(&blk)?;\n             }\n-            hir::ExprLoop(ref blk, opt_ident) => {\n-                if let Some(ident) = opt_ident {\n-                    self.print_name(ident.name)?;\n+            hir::ExprLoop(ref blk, opt_name) => {\n+                if let Some(name) = opt_name {\n+                    self.print_name(name)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"loop\")?;\n@@ -1455,19 +1455,19 @@ impl<'a> State<'a> {\n             hir::ExprPath(Some(ref qself), ref path) => {\n                 self.print_qpath(path, qself, true)?\n             }\n-            hir::ExprBreak(opt_ident) => {\n+            hir::ExprBreak(opt_name) => {\n                 word(&mut self.s, \"break\")?;\n                 space(&mut self.s)?;\n-                if let Some(ident) = opt_ident {\n-                    self.print_name(ident.node.name)?;\n+                if let Some(name) = opt_name {\n+                    self.print_name(name.node)?;\n                     space(&mut self.s)?;\n                 }\n             }\n-            hir::ExprAgain(opt_ident) => {\n+            hir::ExprAgain(opt_name) => {\n                 word(&mut self.s, \"continue\")?;\n                 space(&mut self.s)?;\n-                if let Some(ident) = opt_ident {\n-                    self.print_name(ident.node.name)?;\n+                if let Some(name) = opt_name {\n+                    self.print_name(name.node)?;\n                     space(&mut self.s)?\n                 }\n             }\n@@ -1615,7 +1615,7 @@ impl<'a> State<'a> {\n                 word(&mut self.s, \"::\")?\n             }\n \n-            self.print_name(segment.identifier.name)?;\n+            self.print_name(segment.name)?;\n \n             self.print_path_parameters(&segment.parameters, colons_before_params)?;\n         }\n@@ -1639,7 +1639,7 @@ impl<'a> State<'a> {\n         word(&mut self.s, \">\")?;\n         word(&mut self.s, \"::\")?;\n         let item_segment = path.segments.last().unwrap();\n-        self.print_name(item_segment.identifier.name)?;\n+        self.print_name(item_segment.name)?;\n         self.print_path_parameters(&item_segment.parameters, colons_before_params)\n     }\n \n@@ -1727,7 +1727,7 @@ impl<'a> State<'a> {\n                         self.word_nbsp(\"mut\")?;\n                     }\n                 }\n-                self.print_name(path1.node.name)?;\n+                self.print_name(path1.node)?;\n                 match *sub {\n                     Some(ref p) => {\n                         word(&mut self.s, \"@\")?;\n@@ -2095,7 +2095,7 @@ impl<'a> State<'a> {\n             hir::ViewPathSimple(name, ref path) => {\n                 self.print_path(path, false, 0)?;\n \n-                if path.segments.last().unwrap().identifier.name != name {\n+                if path.segments.last().unwrap().name != name {\n                     space(&mut self.s)?;\n                     self.word_space(\"as\")?;\n                     self.print_name(name)?;\n@@ -2151,8 +2151,8 @@ impl<'a> State<'a> {\n                 if let Some(eself) = input.to_self() {\n                     self.print_explicit_self(&eself)?;\n                 } else {\n-                    let invalid = if let PatKind::Ident(_, ident, _) = input.pat.node {\n-                        ident.node.name == keywords::Invalid.name()\n+                    let invalid = if let PatKind::Ident(_, name, _) = input.pat.node {\n+                        name.node == keywords::Invalid.name()\n                     } else {\n                         false\n                     };"}, {"sha": "45982793a703bdb6a56c1421b576f4db776dc4f0", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -1514,7 +1514,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n             }\n         };\n         let new_seg = hir::PathSegment {\n-            identifier: last_seg.identifier,\n+            name: last_seg.name,\n             parameters: new_parameters\n         };\n         let mut new_segs = Vec::new();"}, {"sha": "be8caeb436a3499c0edcab852afe08477af7323e", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -1050,7 +1050,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprBreak(opt_label) => {\n               // Find which label this break jumps to\n-              let sc = self.find_loop_scope(opt_label.map(|l| l.node.name), expr.id, expr.span);\n+              let sc = self.find_loop_scope(opt_label.map(|l| l.node), expr.id, expr.span);\n \n               // Now that we know the label we're going to,\n               // look it up in the break loop nodes table\n@@ -1063,7 +1063,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprAgain(opt_label) => {\n               // Find which label this expr continues to\n-              let sc = self.find_loop_scope(opt_label.map(|l| l.node.name), expr.id, expr.span);\n+              let sc = self.find_loop_scope(opt_label.map(|l| l.node), expr.id, expr.span);\n \n               // Now that we know the label we're going to,\n               // look it up in the continue loop nodes table"}, {"sha": "2200d72c883ffa2bb4e259cce7d1b2c90ba0b50b", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -433,7 +433,7 @@ fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v hir::Block) {\n     fn expression_label(ex: &hir::Expr) -> Option<ast::Name> {\n         match ex.node {\n             hir::ExprWhile(_, _, Some(label)) |\n-            hir::ExprLoop(_, Some(label)) => Some(label.unhygienic_name),\n+            hir::ExprLoop(_, Some(label)) => Some(label.unhygienize()),\n             _ => None,\n         }\n     }"}, {"sha": "dfb4ec739247d112a7545e76e7fb6553aeaefbe9", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -2216,7 +2216,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         match self.map.find(id) {\n             Some(ast_map::NodeLocal(pat)) => {\n                 match pat.node {\n-                    PatKind::Ident(_, ref path1, _) => path1.node.name.as_str(),\n+                    PatKind::Ident(_, ref path1, _) => path1.node.as_str(),\n                     _ => {\n                         bug!(\"Variable id {} maps to {:?}, not local\", id, pat);\n                     },"}, {"sha": "83322215e30ca7d28ee97ad0c0c4d82a37f8fa39", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -100,7 +100,7 @@ pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     let pat_span_path_opt = match move_pat.node {\n         PatKind::Ident(_, ref path1, _) => {\n             Some(MoveSpanAndPath{span: move_pat.span,\n-                                 name: path1.node.name})\n+                                 name: path1.node})\n         },\n         _ => None,\n     };"}, {"sha": "2fb5d796589b29ae06615cbec1374c6ed63c9f11", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -240,24 +240,24 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat) {\n     pat.walk(|p| {\n         match p.node {\n-            PatKind::Ident(hir::BindByValue(hir::MutImmutable), ident, None) => {\n+            PatKind::Ident(hir::BindByValue(hir::MutImmutable), name, None) => {\n                 let pat_ty = cx.tcx.pat_ty(p);\n                 if let ty::TyEnum(edef, _) = pat_ty.sty {\n                     let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n                     if let Some(Def::Local(..)) = def {\n                         if edef.variants.iter().any(|variant|\n-                            variant.name == ident.node.unhygienic_name\n+                            variant.name == name.node.unhygienize()\n                                 && variant.kind() == VariantKind::Unit\n                         ) {\n                             let ty_path = cx.tcx.item_path_str(edef.did);\n                             let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n                                 \"pattern binding `{}` is named the same as one \\\n                                  of the variants of the type `{}`\",\n-                                ident.node, ty_path);\n+                                name.node, ty_path);\n                             help!(err,\n                                 \"if you meant to match on a variant, \\\n                                  consider making the path in the pattern qualified: `{}::{}`\",\n-                                ty_path, ident.node);\n+                                ty_path, name.node);\n                             err.emit();\n                         }\n                     }"}, {"sha": "f134f3c3f104445fb8c72006e1bac5ebc1742cd5", "filename": "src/librustc_incremental/calculate_svh.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -244,7 +244,7 @@ mod svh_visitor {\n             ExprType(..)             => SawExprType,\n             ExprIf(..)               => SawExprIf,\n             ExprWhile(..)            => SawExprWhile,\n-            ExprLoop(_, id)          => SawExprLoop(id.map(|id| id.name.as_str())),\n+            ExprLoop(_, id)          => SawExprLoop(id.map(|id| id.as_str())),\n             ExprMatch(..)            => SawExprMatch,\n             ExprClosure(..)          => SawExprClosure,\n             ExprBlock(..)            => SawExprBlock,\n@@ -255,8 +255,8 @@ mod svh_visitor {\n             ExprIndex(..)            => SawExprIndex,\n             ExprPath(ref qself, _)   => SawExprPath(qself.as_ref().map(|q| q.position)),\n             ExprAddrOf(m, _)         => SawExprAddrOf(m),\n-            ExprBreak(id)            => SawExprBreak(id.map(|id| id.node.name.as_str())),\n-            ExprAgain(id)            => SawExprAgain(id.map(|id| id.node.name.as_str())),\n+            ExprBreak(id)            => SawExprBreak(id.map(|id| id.node.as_str())),\n+            ExprAgain(id)            => SawExprAgain(id.map(|id| id.node.as_str())),\n             ExprRet(..)              => SawExprRet,\n             ExprInlineAsm(ref a,_,_) => SawExprInlineAsm(a),\n             ExprStruct(..)           => SawExprStruct,"}, {"sha": "27a6e433c7399c200fbf2d1b1ca7b17c07d94a6a", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -277,7 +277,7 @@ impl LateLintPass for NonSnakeCase {\n         if let &PatKind::Ident(_, ref path1, _) = &p.node {\n             let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n             if let Some(Def::Local(..)) = def {\n-                self.check_snake_case(cx, \"variable\", &path1.node.name.as_str(), Some(p.span));\n+                self.check_snake_case(cx, \"variable\", &path1.node.as_str(), Some(p.span));\n             }\n         }\n     }\n@@ -363,7 +363,7 @@ impl LateLintPass for NonUpperCaseGlobals {\n         match (&p.node, cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def())) {\n             (&PatKind::Ident(_, ref path1, _), Some(Def::Const(..))) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n-                                                      path1.node.name, p.span);\n+                                                      path1.node, p.span);\n             }\n             _ => {}\n         }"}, {"sha": "49b59aea46ee7136005b88ed69cbab2478fb58f5", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -172,7 +172,7 @@ impl LateLintPass for NonShorthandFieldPatterns {\n             });\n             for fieldpat in field_pats {\n                 if let PatKind::Ident(_, ident, None) = fieldpat.node.pat.node {\n-                    if ident.node.unhygienic_name == fieldpat.node.name {\n+                    if ident.node.unhygienize() == fieldpat.node.name {\n                         cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n                                      &format!(\"the `{}:` in this pattern is redundant and can \\\n                                               be removed\", ident.node))"}, {"sha": "662942a5bdc108aa55ec4aad9b418c46cebe2783", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -762,7 +762,7 @@ fn encode_method_argument_names(rbml_w: &mut Encoder,\n     for arg in &decl.inputs {\n         let tag = tag_method_argument_name;\n         if let PatKind::Ident(_, ref path1, _) = arg.pat.node {\n-            let name = path1.node.name.as_str();\n+            let name = path1.node.as_str();\n             rbml_w.wr_tagged_bytes(tag, name.as_bytes());\n         } else {\n             rbml_w.wr_tagged_bytes(tag, &[]);"}, {"sha": "d75cf3b7587ea57e3f7e960711a7bba4e79f8316", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -222,7 +222,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n             };\n             if let Some(hir::map::NodeLocal(pat)) = tcx.map.find(fv.def.var_id()) {\n                 if let hir::PatKind::Ident(_, ref ident, _) = pat.node {\n-                    decl.debug_name = ident.node.name;\n+                    decl.debug_name = ident.node;\n                 }\n             }\n             decl\n@@ -335,7 +335,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             if let Some(pat) = pattern {\n                 if let hir::PatKind::Ident(_, ref ident, _) = pat.node {\n                     if pat_is_binding(&self.hir.tcx().def_map.borrow(), pat) {\n-                        name = ident.node.name;\n+                        name = ident.node;\n                     }\n                 }\n             }"}, {"sha": "0118b97dd7f3e5454b47cf29957a150645d12cac", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -166,7 +166,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n             {\n                 let id = match self.binding_map {\n                     None => pat.id,\n-                    Some(ref map) => map[&ident.node.name],\n+                    Some(ref map) => map[&ident.node],\n                 };\n                 let var_ty = self.cx.tcx.node_id_to_type(pat.id);\n                 let region = match var_ty.sty {\n@@ -197,7 +197,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 PatternKind::Binding {\n                     mutability: mutability,\n                     mode: mode,\n-                    name: ident.node.name,\n+                    name: ident.node,\n                     var: id,\n                     ty: var_ty,\n                     subpattern: self.to_opt_pattern(sub),"}, {"sha": "016dff5f0053940c3128fc61a0c59873e37732b8", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -1102,6 +1102,10 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         }\n     }\n \n+    fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution> {\n+        self.def_map.get(&id).cloned()\n+    }\n+\n     fn record_resolution(&mut self, id: NodeId, def: Def) {\n         self.def_map.insert(id, PathResolution { base_def: def, depth: 0 });\n     }\n@@ -1123,7 +1127,7 @@ impl Named for ast::PathSegment {\n \n impl Named for hir::PathSegment {\n     fn name(&self) -> Name {\n-        self.identifier.name\n+        self.name\n     }\n }\n "}, {"sha": "dbc277f243267e707dd95b86d4f45b96b0d60ccb", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -482,7 +482,7 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         loop {\n             pat = match pat.node {\n                 PatKind::Ident(_, ref path, Some(ref inner)) => {\n-                    bound_ptrs.push((path.node.name, val.val));\n+                    bound_ptrs.push((path.node, val.val));\n                     &inner\n                 },\n                 _ => break\n@@ -520,15 +520,15 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             match this.node {\n                 PatKind::Ident(_, ref path, None) => {\n                     if pat_is_binding(&dm.borrow(), &this) {\n-                        bound_ptrs.push((path.node.name, val.val));\n+                        bound_ptrs.push((path.node, val.val));\n                     }\n                 }\n                 PatKind::Vec(ref before, Some(ref slice), ref after) => {\n                     if let PatKind::Ident(_, ref path, None) = slice.node {\n                         let subslice_val = bind_subslice_pat(\n                             bcx, this.id, val,\n                             before.len(), after.len());\n-                        bound_ptrs.push((path.node.name, subslice_val));\n+                        bound_ptrs.push((path.node, subslice_val));\n                     }\n                 }\n                 _ => {}\n@@ -1802,7 +1802,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // binding will live and place it into the appropriate\n                 // map.\n                 bcx = mk_binding_alloca(\n-                    bcx, pat.id, path1.node.name, cleanup_scope, (),\n+                    bcx, pat.id, path1.node, cleanup_scope, (),\n                     \"_match::bind_irrefutable_pat\",\n                     |(), bcx, Datum { val: llval, ty, kind: _ }| {\n                         match pat_binding_mode {"}, {"sha": "ba592382d1a794d1aa8bba8b96356409dbed7ebd", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -51,9 +51,9 @@ pub fn create_scope_map(cx: &CrateContext,\n     // Push argument identifiers onto the stack so arguments integrate nicely\n     // with variable shadowing.\n     for arg in args {\n-        pat_util::pat_bindings_ident(def_map, &arg.pat, |_, node_id, _, path1| {\n+        pat_util::pat_bindings(def_map, &arg.pat, |_, node_id, _, path1| {\n             scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata,\n-                                               name: Some(path1.node.unhygienic_name) });\n+                                               name: Some(path1.node.unhygienize()) });\n             scope_map.insert(node_id, fn_metadata);\n         })\n     }\n@@ -248,7 +248,7 @@ fn walk_pattern(cx: &CrateContext,\n             // scope stack and maybe introduce an artificial scope\n             if pat_util::pat_is_binding(&def_map.borrow(), &pat) {\n \n-                let name = path1.node.unhygienic_name;\n+                let name = path1.node.unhygienize();\n \n                 // LLVM does not properly generate 'DW_AT_start_scope' fields\n                 // for variable DIEs. For this reason we have to introduce"}, {"sha": "ccb01789aa64c8f4160b5699f1b8b1959b0731a4", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -1946,7 +1946,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         Some(hir_map::NodeLocal(pat)) => {\n             match pat.node {\n                 PatKind::Ident(_, ref path1, _) => {\n-                    path1.node.name\n+                    path1.node\n                 }\n                 _ => {\n                     span_bug!(span,"}, {"sha": "36a593a546b9c045172c9fa94894e99d228c9aa8", "filename": "src/librustc_trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_trans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_trans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fexpr.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -928,13 +928,13 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     match expr.node {\n         hir::ExprBreak(label_opt) => {\n-            controlflow::trans_break(bcx, expr, label_opt.map(|l| l.node.name))\n+            controlflow::trans_break(bcx, expr, label_opt.map(|l| l.node))\n         }\n         hir::ExprType(ref e, _) => {\n             trans_into(bcx, &e, Ignore)\n         }\n         hir::ExprAgain(label_opt) => {\n-            controlflow::trans_cont(bcx, expr, label_opt.map(|l| l.node.name))\n+            controlflow::trans_cont(bcx, expr, label_opt.map(|l| l.node))\n         }\n         hir::ExprRet(ref ex) => {\n             // Check to see if the return expression itself is reachable."}, {"sha": "9944f453f0ad66a4e231dc701f51989903809dcd", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -1283,7 +1283,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                  -> (Ty<'tcx>, Def)\n     {\n         let tcx = self.tcx();\n-        let assoc_name = item_segment.identifier.name;\n+        let assoc_name = item_segment.name;\n \n         debug!(\"associated_path_def_to_ty: {:?}::{}\", ty, assoc_name);\n \n@@ -1394,7 +1394,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             self.report_ambiguous_associated_type(span,\n                                                   \"Type\",\n                                                   &path_str,\n-                                                  &item_segment.identifier.name.as_str());\n+                                                  &item_segment.name.as_str());\n             return tcx.types.err;\n         };\n \n@@ -1409,7 +1409,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         debug!(\"qpath_to_ty: trait_ref={:?}\", trait_ref);\n \n-        self.projected_ty(span, trait_ref, item_segment.identifier.name)\n+        self.projected_ty(span, trait_ref, item_segment.name)\n     }\n \n     /// Convert a type supplied as value for a type argument from AST into our"}, {"sha": "10c8ea84bfd64e3e009eb348d329331c34340fdc", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -200,7 +200,7 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n \n                 // if there are multiple arms, make sure they all agree on\n                 // what the type of the binding `x` ought to be\n-                if let Some(&canon_id) = self.map.get(&path.node.name) {\n+                if let Some(&canon_id) = self.map.get(&path.node) {\n                     if canon_id != pat.id {\n                         let ct = self.local_ty(pat.span, canon_id);\n                         self.demand_eqtype(pat.span, ct, typ);\n@@ -212,7 +212,7 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             PatKind::Ident(_, ref path, _) => {\n-                let path = hir::Path::from_ident(path.span, path.node);\n+                let path = hir::Path::from_name(path.span, path.node);\n                 self.check_pat_enum(pat, &path, Some(&[]), expected, false);\n             }\n             PatKind::TupleStruct(ref path, ref subpats) => {"}, {"sha": "2cd60d20251f3f361d68a89f3a6cecbcb68d3d72", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -216,7 +216,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                         else if let Expr_::ExprPath(_, path) = expr.node.clone() {\n                             if let Some(segment) = path.segments.last() {\n-                                report_function!(expr.span, segment.identifier.name);\n+                                report_function!(expr.span, segment.name);\n                             }\n                         }\n                     }"}, {"sha": "3ea617d310ba3cd475e59e77c5ebbb6651c0dc15", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -3870,7 +3870,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                                  &ty_segments[..base_ty_end],\n                                                                  &ty_segments[base_ty_end..]);\n             let item_segment = path.segments.last().unwrap();\n-            let item_name = item_segment.identifier.name;\n+            let item_name = item_segment.name;\n             let def = match self.resolve_ufcs(span, item_name, ty, node_id) {\n                 Ok(def) => Some(def),\n                 Err(error) => {"}, {"sha": "463702c11b7b75b95dc437cf51d6fdde44f260da", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -1626,7 +1626,7 @@ impl Clean<Type> for hir::Ty {\n                     segments: segments.into(),\n                 };\n                 Type::QPath {\n-                    name: p.segments.last().unwrap().identifier.name.clean(cx),\n+                    name: p.segments.last().unwrap().name.clean(cx),\n                     self_type: box qself.ty.clean(cx),\n                     trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n                 }\n@@ -2064,7 +2064,7 @@ pub struct PathSegment {\n impl Clean<PathSegment> for hir::PathSegment {\n     fn clean(&self, cx: &DocContext) -> PathSegment {\n         PathSegment {\n-            name: self.identifier.name.clean(cx),\n+            name: self.name.clean(cx),\n             params: self.parameters.clean(cx)\n         }\n     }\n@@ -2073,7 +2073,7 @@ impl Clean<PathSegment> for hir::PathSegment {\n fn path_to_string(p: &hir::Path) -> String {\n     let mut s = String::new();\n     let mut first = true;\n-    for i in p.segments.iter().map(|x| x.identifier.name.as_str()) {\n+    for i in p.segments.iter().map(|x| x.name.as_str()) {\n         if !first || p.global {\n             s.push_str(\"::\");\n         } else {"}, {"sha": "d9409d3bbd9213bf3fe842c69a316b6d67d30153", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310d8996f40fceaa8d294577276cfb1b080c8bc9/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=310d8996f40fceaa8d294577276cfb1b080c8bc9", "patch": "@@ -60,6 +60,10 @@ impl Name {\n     pub fn as_str(self) -> token::InternedString {\n         token::InternedString::new_from_name(self)\n     }\n+\n+    pub fn unhygienize(self) -> Name {\n+        token::intern(&self.as_str())\n+    }\n }\n \n impl fmt::Debug for Name {"}]}