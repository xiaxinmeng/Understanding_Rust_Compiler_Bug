{"sha": "3b3063fb2d1804b3dc42184027ef08073de03fd9", "node_id": "C_kwDOAAsO6NoAKDNiMzA2M2ZiMmQxODA0YjNkYzQyMTg0MDI3ZWYwODA3M2RlMDNmZDk", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-11-10T23:19:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-10T23:19:44Z"}, "message": "Merge #10741\n\n10741: internal: Flatten Definition::ModuleDef variant r=Veykril a=Veykril\n\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "e901645ccf8fe44358e58189bb60b982e9b299de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e901645ccf8fe44358e58189bb60b982e9b299de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b3063fb2d1804b3dc42184027ef08073de03fd9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhjFOQCRBK7hj4Ov3rIwAAuiQIADgRRcSScRFsKsZu5BN78Uh+\nap9iKZnQShaiBnDmQFU5QrP/AbdZOBPVC4qvOI0+FCxY26mg6KJCLYBlpAnFVKi3\nM4UBS04Z5btUS3NJO2gkyrCssPG9eh+9eoQdzd6+rxFUTBDSl/kc8lwp82/wVsN8\nBpHuQoBULoYxICmz/1JK/90wWsAJm+dpsByFQ21txGK21hUPGeUoU8n8mcb5RGr/\nQprMddGUUsVsv2T2LI9n5dKZOlMJMkgFxnQoM2f+XBbXq3eJfWbOHDD7y3U8ynkj\nbLv2xJ7PIrJNT/cR6B9+W+fYRnMYcF9LQS863J/b/+XPUCOssN/HB+jD2vpBIrA=\n=g2KY\n-----END PGP SIGNATURE-----\n", "payload": "tree e901645ccf8fe44358e58189bb60b982e9b299de\nparent 1e8d1e84b239dac33228cd95b42dbd77288eb557\nparent 7776aad166760480726ee9d4692d2597dd2fa399\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1636586384 +0000\ncommitter GitHub <noreply@github.com> 1636586384 +0000\n\nMerge #10741\n\n10741: internal: Flatten Definition::ModuleDef variant r=Veykril a=Veykril\n\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b3063fb2d1804b3dc42184027ef08073de03fd9", "html_url": "https://github.com/rust-lang/rust/commit/3b3063fb2d1804b3dc42184027ef08073de03fd9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b3063fb2d1804b3dc42184027ef08073de03fd9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e8d1e84b239dac33228cd95b42dbd77288eb557", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e8d1e84b239dac33228cd95b42dbd77288eb557", "html_url": "https://github.com/rust-lang/rust/commit/1e8d1e84b239dac33228cd95b42dbd77288eb557"}, {"sha": "7776aad166760480726ee9d4692d2597dd2fa399", "url": "https://api.github.com/repos/rust-lang/rust/commits/7776aad166760480726ee9d4692d2597dd2fa399", "html_url": "https://github.com/rust-lang/rust/commit/7776aad166760480726ee9d4692d2597dd2fa399"}], "stats": {"total": 1413, "additions": 710, "deletions": 703}, "files": [{"sha": "e9ace855fc35dee7bebd79aa834dbd836e02d181", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -421,10 +421,7 @@ impl HirDisplay for Static {\n         if data.mutable {\n             write!(f, \"mut \")?;\n         }\n-        match &data.name {\n-            Some(name) => write!(f, \"{}: \", name)?,\n-            None => write!(f, \"_: \")?,\n-        }\n+        write!(f, \"{}: \", &data.name)?;\n         data.type_ref.hir_fmt(f)?;\n         Ok(())\n     }"}, {"sha": "c46324f988c4e233971369c785fc34b68f37b90e", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -316,17 +316,18 @@ impl ModuleDef {\n     }\n \n     pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n-        match self {\n-            ModuleDef::Adt(it) => Some(it.name(db)),\n-            ModuleDef::Trait(it) => Some(it.name(db)),\n-            ModuleDef::Function(it) => Some(it.name(db)),\n-            ModuleDef::Variant(it) => Some(it.name(db)),\n-            ModuleDef::TypeAlias(it) => Some(it.name(db)),\n-            ModuleDef::Module(it) => it.name(db),\n-            ModuleDef::Const(it) => it.name(db),\n+        let name = match self {\n+            ModuleDef::Module(it) => it.name(db)?,\n+            ModuleDef::Const(it) => it.name(db)?,\n+            ModuleDef::Adt(it) => it.name(db),\n+            ModuleDef::Trait(it) => it.name(db),\n+            ModuleDef::Function(it) => it.name(db),\n+            ModuleDef::Variant(it) => it.name(db),\n+            ModuleDef::TypeAlias(it) => it.name(db),\n             ModuleDef::Static(it) => it.name(db),\n-            ModuleDef::BuiltinType(it) => Some(it.name()),\n-        }\n+            ModuleDef::BuiltinType(it) => it.name(),\n+        };\n+        Some(name)\n     }\n \n     pub fn diagnostics(self, db: &dyn HirDatabase) -> Vec<AnyDiagnostic> {\n@@ -1036,7 +1037,7 @@ impl DefWithBody {\n     pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n         match self {\n             DefWithBody::Function(f) => Some(f.name(db)),\n-            DefWithBody::Static(s) => s.name(db),\n+            DefWithBody::Static(s) => Some(s.name(db)),\n             DefWithBody::Const(c) => c.name(db),\n         }\n     }\n@@ -1484,7 +1485,7 @@ impl Static {\n         Module { id: self.id.lookup(db.upcast()).module(db.upcast()) }\n     }\n \n-    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n         db.static_data(self.id).name.clone()\n     }\n "}, {"sha": "f4d0c3af90badd404a4e62aa7b6451f91a04cc42", "filename": "crates/hir_def/src/data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fhir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fhir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdata.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -273,7 +273,7 @@ impl ConstData {\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct StaticData {\n-    pub name: Option<Name>,\n+    pub name: Name,\n     pub type_ref: Interned<TypeRef>,\n     pub visibility: RawVisibility,\n     pub mutable: bool,\n@@ -287,7 +287,7 @@ impl StaticData {\n         let statik = &item_tree[node.id.value];\n \n         Arc::new(StaticData {\n-            name: Some(statik.name.clone()),\n+            name: statik.name.clone(),\n             type_ref: statik.type_ref.clone(),\n             visibility: item_tree[statik.visibility].clone(),\n             mutable: statik.mutable,"}, {"sha": "2583227ff404a73fa0305e370d7b2074cf34b066", "filename": "crates/hir_ty/src/db.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdb.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -162,9 +162,7 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n fn infer_wait(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<InferenceResult> {\n     let _p = profile::span(\"infer:wait\").detail(|| match def {\n         DefWithBodyId::FunctionId(it) => db.function_data(it).name.to_string(),\n-        DefWithBodyId::StaticId(it) => {\n-            db.static_data(it).name.clone().unwrap_or_else(Name::missing).to_string()\n-        }\n+        DefWithBodyId::StaticId(it) => db.static_data(it).name.clone().to_string(),\n         DefWithBodyId::ConstId(it) => {\n             db.const_data(it).name.clone().unwrap_or_else(Name::missing).to_string()\n         }"}, {"sha": "4f4a92447fffee2196d9bc8da1249950b5368974", "filename": "crates/hir_ty/src/diagnostics/decl_check.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -581,10 +581,7 @@ impl<'a> DeclValidator<'a> {\n             return;\n         }\n \n-        let name = match &data.name {\n-            Some(name) => name,\n-            None => return,\n-        };\n+        let name = &data.name;\n \n         let static_name = name.to_string();\n         let replacement = if let Some(new_name) = to_upper_snake_case(&static_name) {"}, {"sha": "23bffd564899dad3caff71f13743c074b0a24c4b", "filename": "crates/ide/src/call_hierarchy.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -47,15 +47,11 @@ pub(crate) fn incoming_calls(\n         .find_nodes_at_offset_with_descend(file, offset)\n         .filter_map(move |node| match node {\n             ast::NameLike::NameRef(name_ref) => match NameRefClass::classify(sema, &name_ref)? {\n-                NameRefClass::Definition(\n-                    def @ Definition::ModuleDef(hir::ModuleDef::Function(_)),\n-                ) => Some(def),\n+                NameRefClass::Definition(def @ Definition::Function(_)) => Some(def),\n                 _ => None,\n             },\n             ast::NameLike::Name(name) => match NameClass::classify(sema, &name)? {\n-                NameClass::Definition(def @ Definition::ModuleDef(hir::ModuleDef::Function(_))) => {\n-                    Some(def)\n-                }\n+                NameClass::Definition(def @ Definition::Function(_)) => Some(def),\n                 _ => None,\n             },\n             ast::NameLike::Lifetime(_) => None,"}, {"sha": "3121cdd4a239b5cc5774a6220cffafbf335f960a", "filename": "crates/ide/src/display/navigation_target.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -196,13 +196,21 @@ impl ToNav for FileSymbol {\n impl TryToNav for Definition {\n     fn try_to_nav(&self, db: &RootDatabase) -> Option<NavigationTarget> {\n         match self {\n+            Definition::Local(it) => Some(it.to_nav(db)),\n+            Definition::Label(it) => Some(it.to_nav(db)),\n+            Definition::Module(it) => Some(it.to_nav(db)),\n             Definition::Macro(it) => it.try_to_nav(db),\n             Definition::Field(it) => it.try_to_nav(db),\n-            Definition::ModuleDef(it) => it.try_to_nav(db),\n             Definition::SelfType(it) => it.try_to_nav(db),\n-            Definition::Local(it) => Some(it.to_nav(db)),\n             Definition::GenericParam(it) => it.try_to_nav(db),\n-            Definition::Label(it) => Some(it.to_nav(db)),\n+            Definition::Function(it) => it.try_to_nav(db),\n+            Definition::Adt(it) => it.try_to_nav(db),\n+            Definition::Variant(it) => it.try_to_nav(db),\n+            Definition::Const(it) => it.try_to_nav(db),\n+            Definition::Static(it) => it.try_to_nav(db),\n+            Definition::Trait(it) => it.try_to_nav(db),\n+            Definition::TypeAlias(it) => it.try_to_nav(db),\n+            Definition::BuiltinType(_) => None,\n         }\n     }\n }"}, {"sha": "075c9172257ea413b733c1b4e3bbe7b87ce74e83", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 113, "deletions": 141, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -8,10 +8,7 @@ use pulldown_cmark_to_cmark::{cmark_with_options, Options as CMarkOptions};\n use stdx::format_to;\n use url::Url;\n \n-use hir::{\n-    db::HirDatabase, Adt, AsAssocItem, AssocItem, AssocItemContainer, Crate, HasAttrs, MacroDef,\n-    ModuleDef,\n-};\n+use hir::{db::HirDatabase, Adt, AsAssocItem, AssocItem, AssocItemContainer, Crate, HasAttrs};\n use ide_db::{\n     defs::{Definition, NameClass, NameRefClass},\n     helpers::pick_best_token,\n@@ -53,10 +50,8 @@ pub(crate) fn rewrite_links(db: &RootDatabase, markdown: &str, definition: Defin\n             if let Some(rewritten) = rewrite_intra_doc_link(db, definition, target, title) {\n                 return rewritten;\n             }\n-            if let Definition::ModuleDef(def) = definition {\n-                if let Some(target) = rewrite_url_link(db, Either::Left(def), target) {\n-                    return (target, title.to_string());\n-                }\n+            if let Some(target) = rewrite_url_link(db, definition, target) {\n+                return (target, title.to_string());\n             }\n \n             (target.to_string(), title.to_string())\n@@ -174,25 +169,27 @@ pub(crate) fn resolve_doc_path_for_def(\n     def: Definition,\n     link: &str,\n     ns: Option<hir::Namespace>,\n-) -> Option<Either<ModuleDef, MacroDef>> {\n-    match def {\n-        Definition::ModuleDef(def) => match def {\n-            hir::ModuleDef::Module(it) => it.resolve_doc_path(db, link, ns),\n-            hir::ModuleDef::Function(it) => it.resolve_doc_path(db, link, ns),\n-            hir::ModuleDef::Adt(it) => it.resolve_doc_path(db, link, ns),\n-            hir::ModuleDef::Variant(it) => it.resolve_doc_path(db, link, ns),\n-            hir::ModuleDef::Const(it) => it.resolve_doc_path(db, link, ns),\n-            hir::ModuleDef::Static(it) => it.resolve_doc_path(db, link, ns),\n-            hir::ModuleDef::Trait(it) => it.resolve_doc_path(db, link, ns),\n-            hir::ModuleDef::TypeAlias(it) => it.resolve_doc_path(db, link, ns),\n-            hir::ModuleDef::BuiltinType(_) => None,\n-        },\n+) -> Option<Definition> {\n+    let def = match def {\n+        Definition::Module(it) => it.resolve_doc_path(db, link, ns),\n+        Definition::Function(it) => it.resolve_doc_path(db, link, ns),\n+        Definition::Adt(it) => it.resolve_doc_path(db, link, ns),\n+        Definition::Variant(it) => it.resolve_doc_path(db, link, ns),\n+        Definition::Const(it) => it.resolve_doc_path(db, link, ns),\n+        Definition::Static(it) => it.resolve_doc_path(db, link, ns),\n+        Definition::Trait(it) => it.resolve_doc_path(db, link, ns),\n+        Definition::TypeAlias(it) => it.resolve_doc_path(db, link, ns),\n         Definition::Macro(it) => it.resolve_doc_path(db, link, ns),\n         Definition::Field(it) => it.resolve_doc_path(db, link, ns),\n-        Definition::SelfType(_)\n+        Definition::BuiltinType(_)\n+        | Definition::SelfType(_)\n         | Definition::Local(_)\n         | Definition::GenericParam(_)\n         | Definition::Label(_) => None,\n+    }?;\n+    match def {\n+        Either::Left(def) => Some(Definition::from(def)),\n+        Either::Right(def) => Some(Definition::Macro(def)),\n     }\n }\n \n@@ -202,17 +199,17 @@ pub(crate) fn doc_attributes(\n ) -> Option<(hir::AttrsWithOwner, Definition)> {\n     match_ast! {\n         match node {\n-            ast::SourceFile(it)  => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Module(def)))),\n-            ast::Module(it)      => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Module(def)))),\n-            ast::Fn(it)          => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Function(def)))),\n-            ast::Struct(it)      => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Struct(def))))),\n-            ast::Union(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Union(def))))),\n-            ast::Enum(it)        => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(def))))),\n-            ast::Variant(it)     => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Variant(def)))),\n-            ast::Trait(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Trait(def)))),\n-            ast::Static(it)      => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Static(def)))),\n-            ast::Const(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Const(def)))),\n-            ast::TypeAlias(it)   => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::TypeAlias(def)))),\n+            ast::SourceFile(it)  => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Module(def))),\n+            ast::Module(it)      => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Module(def))),\n+            ast::Fn(it)          => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Function(def))),\n+            ast::Struct(it)      => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Adt(hir::Adt::Struct(def)))),\n+            ast::Union(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Adt(hir::Adt::Union(def)))),\n+            ast::Enum(it)        => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Adt(hir::Adt::Enum(def)))),\n+            ast::Variant(it)     => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Variant(def))),\n+            ast::Trait(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Trait(def))),\n+            ast::Static(it)      => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Static(def))),\n+            ast::Const(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Const(def))),\n+            ast::TypeAlias(it)   => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::TypeAlias(def))),\n             ast::Impl(it)        => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::SelfType(def))),\n             ast::RecordField(it) => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Field(def))),\n             ast::TupleField(it)  => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Field(def))),\n@@ -274,10 +271,7 @@ impl DocCommentToken {\n             let in_expansion_relative_range = in_expansion_range - descended_prefix_len - token_start;\n             // Apply relative range to the original input comment\n             let absolute_range = in_expansion_relative_range + original_start + prefix_len;\n-            let def = match resolve_doc_path_for_def(sema.db, def, &link, ns)? {\n-                Either::Left(it) => Definition::ModuleDef(it),\n-                Either::Right(it) => Definition::Macro(it),\n-            };\n+            let def = resolve_doc_path_for_def(sema.db, def, &link, ns)?;\n             cb(def, node, absolute_range)\n         })\n     }\n@@ -299,33 +293,8 @@ fn broken_link_clone_cb<'a, 'b>(link: BrokenLink<'a>) -> Option<(CowStr<'b>, Cow\n //\n // This should cease to be a problem if RFC2988 (Stable Rustdoc URLs) is implemented\n // https://github.com/rust-lang/rfcs/pull/2988\n-fn get_doc_link(db: &RootDatabase, definition: Definition) -> Option<String> {\n-    let (target, frag) = match definition {\n-        Definition::ModuleDef(def) => {\n-            if let Some(assoc_item) = def.as_assoc_item(db) {\n-                let def = match assoc_item.container(db) {\n-                    AssocItemContainer::Trait(t) => t.into(),\n-                    AssocItemContainer::Impl(i) => i.self_ty(db).as_adt()?.into(),\n-                };\n-                let frag = get_assoc_item_fragment(db, assoc_item)?;\n-                (Either::Left(def), Some(frag))\n-            } else {\n-                (Either::Left(def), None)\n-            }\n-        }\n-        Definition::Field(field) => {\n-            let def = match field.parent_def(db) {\n-                hir::VariantDef::Struct(it) => it.into(),\n-                hir::VariantDef::Union(it) => it.into(),\n-                hir::VariantDef::Variant(it) => it.into(),\n-            };\n-            (Either::Left(def), Some(format!(\"structfield.{}\", field.name(db))))\n-        }\n-        Definition::Macro(makro) => (Either::Right(makro), None),\n-        // FIXME impls\n-        Definition::SelfType(_) => return None,\n-        Definition::Local(_) | Definition::GenericParam(_) | Definition::Label(_) => return None,\n-    };\n+fn get_doc_link(db: &RootDatabase, def: Definition) -> Option<String> {\n+    let (target, file, frag) = filename_and_frag_for_def(db, def)?;\n \n     let krate = crate_of_def(db, target)?;\n     let mut url = get_doc_base_url(db, &krate)?;\n@@ -334,7 +303,7 @@ fn get_doc_link(db: &RootDatabase, definition: Definition) -> Option<String> {\n         url = url.join(&path).ok()?;\n     }\n \n-    url = url.join(&get_symbol_filename(db, target)?).ok()?;\n+    url = url.join(&file).ok()?;\n     url.set_fragment(frag.as_deref());\n \n     Some(url.into())\n@@ -352,73 +321,51 @@ fn rewrite_intra_doc_link(\n     let krate = crate_of_def(db, resolved)?;\n     let mut url = get_doc_base_url(db, &krate)?;\n \n+    let (_, file, frag) = filename_and_frag_for_def(db, resolved)?;\n     if let Some(path) = mod_path_of_def(db, resolved) {\n         url = url.join(&path).ok()?;\n     }\n \n-    let (resolved, frag) =\n-        if let Some(assoc_item) = resolved.left().and_then(|it| it.as_assoc_item(db)) {\n-            let resolved = match assoc_item.container(db) {\n-                AssocItemContainer::Trait(t) => t.into(),\n-                AssocItemContainer::Impl(i) => i.self_ty(db).as_adt()?.into(),\n-            };\n-            let frag = get_assoc_item_fragment(db, assoc_item)?;\n-            (Either::Left(resolved), Some(frag))\n-        } else {\n-            (resolved, None)\n-        };\n-    url = url.join(&get_symbol_filename(db, resolved)?).ok()?;\n+    url = url.join(&file).ok()?;\n     url.set_fragment(frag.as_deref());\n \n     Some((url.into(), strip_prefixes_suffixes(title).to_string()))\n }\n \n /// Try to resolve path to local documentation via path-based links (i.e. `../gateway/struct.Shard.html`).\n-fn rewrite_url_link(\n-    db: &RootDatabase,\n-    def: Either<ModuleDef, MacroDef>,\n-    target: &str,\n-) -> Option<String> {\n+fn rewrite_url_link(db: &RootDatabase, def: Definition, target: &str) -> Option<String> {\n     if !(target.contains('#') || target.contains(\".html\")) {\n         return None;\n     }\n \n     let krate = crate_of_def(db, def)?;\n     let mut url = get_doc_base_url(db, &krate)?;\n+    let (def, file, frag) = filename_and_frag_for_def(db, def)?;\n \n     if let Some(path) = mod_path_of_def(db, def) {\n         url = url.join(&path).ok()?;\n     }\n \n-    url = url.join(&get_symbol_filename(db, def)?).ok()?;\n+    url = url.join(&file).ok()?;\n+    url.set_fragment(frag.as_deref());\n     url.join(target).ok().map(Into::into)\n }\n \n-fn crate_of_def(db: &RootDatabase, def: Either<ModuleDef, MacroDef>) -> Option<Crate> {\n+fn crate_of_def(db: &RootDatabase, def: Definition) -> Option<Crate> {\n     let krate = match def {\n         // Definition::module gives back the parent module, we don't want that as it fails for root modules\n-        Either::Left(ModuleDef::Module(module)) => module.krate(),\n-        Either::Left(def) => def.module(db)?.krate(),\n-        Either::Right(def) => def.module(db)?.krate(),\n+        Definition::Module(module) => module.krate(),\n+        def => def.module(db)?.krate(),\n     };\n     Some(krate)\n }\n \n-fn mod_path_of_def(db: &RootDatabase, def: Either<ModuleDef, MacroDef>) -> Option<String> {\n-    match def {\n-        Either::Left(def) => def.canonical_module_path(db).map(|it| {\n-            let mut path = String::new();\n-            it.flat_map(|it| it.name(db)).for_each(|name| format_to!(path, \"{}/\", name));\n-            path\n-        }),\n-        Either::Right(def) => {\n-            def.module(db).map(|it| it.path_to_root(db).into_iter().rev()).map(|it| {\n-                let mut path = String::new();\n-                it.flat_map(|it| it.name(db)).for_each(|name| format_to!(path, \"{}/\", name));\n-                path\n-            })\n-        }\n-    }\n+fn mod_path_of_def(db: &RootDatabase, def: Definition) -> Option<String> {\n+    def.canonical_module_path(db).map(|it| {\n+        let mut path = String::new();\n+        it.flat_map(|it| it.name(db)).for_each(|name| format_to!(path, \"{}/\", name));\n+        path\n+    })\n }\n \n /// Rewrites a markdown document, applying 'callback' to each link.\n@@ -496,34 +443,61 @@ fn get_doc_base_url(db: &RootDatabase, krate: &Crate) -> Option<Url> {\n /// https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next\n ///                                    ^^^^^^^^^^^^^^^^^^^\n /// ```\n-fn get_symbol_filename(\n+fn filename_and_frag_for_def(\n     db: &dyn HirDatabase,\n-    definition: Either<ModuleDef, MacroDef>,\n-) -> Option<String> {\n-    let res = match definition {\n-        Either::Left(definition) => match definition {\n-            ModuleDef::Adt(adt) => match adt {\n-                Adt::Struct(s) => format!(\"struct.{}.html\", s.name(db)),\n-                Adt::Enum(e) => format!(\"enum.{}.html\", e.name(db)),\n-                Adt::Union(u) => format!(\"union.{}.html\", u.name(db)),\n-            },\n-            ModuleDef::Module(m) => match m.name(db) {\n-                Some(name) => format!(\"{}/index.html\", name),\n-                None => String::from(\"index.html\"),\n-            },\n-            ModuleDef::Trait(t) => format!(\"trait.{}.html\", t.name(db)),\n-            ModuleDef::TypeAlias(t) => format!(\"type.{}.html\", t.name(db)),\n-            ModuleDef::BuiltinType(t) => format!(\"primitive.{}.html\", t.name()),\n-            ModuleDef::Function(f) => format!(\"fn.{}.html\", f.name(db)),\n-            ModuleDef::Variant(ev) => {\n-                format!(\"enum.{}.html#variant.{}\", ev.parent_enum(db).name(db), ev.name(db))\n-            }\n-            ModuleDef::Const(c) => format!(\"const.{}.html\", c.name(db)?),\n-            ModuleDef::Static(s) => format!(\"static.{}.html\", s.name(db)?),\n+    def: Definition,\n+) -> Option<(Definition, String, Option<String>)> {\n+    if let Some(assoc_item) = def.as_assoc_item(db) {\n+        let def = match assoc_item.container(db) {\n+            AssocItemContainer::Trait(t) => t.into(),\n+            AssocItemContainer::Impl(i) => i.self_ty(db).as_adt()?.into(),\n+        };\n+        let (_, file, _) = filename_and_frag_for_def(db, def)?;\n+        let frag = get_assoc_item_fragment(db, assoc_item)?;\n+        return Some((def, file, Some(frag)));\n+    }\n+\n+    let res = match def {\n+        Definition::Adt(adt) => match adt {\n+            Adt::Struct(s) => format!(\"struct.{}.html\", s.name(db)),\n+            Adt::Enum(e) => format!(\"enum.{}.html\", e.name(db)),\n+            Adt::Union(u) => format!(\"union.{}.html\", u.name(db)),\n+        },\n+        Definition::Module(m) => match m.name(db) {\n+            Some(name) => format!(\"{}/index.html\", name),\n+            None => String::from(\"index.html\"),\n         },\n-        Either::Right(mac) => format!(\"macro.{}.html\", mac.name(db)?),\n+        Definition::Trait(t) => format!(\"trait.{}.html\", t.name(db)),\n+        Definition::TypeAlias(t) => format!(\"type.{}.html\", t.name(db)),\n+        Definition::BuiltinType(t) => format!(\"primitive.{}.html\", t.name()),\n+        Definition::Function(f) => format!(\"fn.{}.html\", f.name(db)),\n+        Definition::Variant(ev) => {\n+            format!(\"enum.{}.html#variant.{}\", ev.parent_enum(db).name(db), ev.name(db))\n+        }\n+        Definition::Const(c) => format!(\"const.{}.html\", c.name(db)?),\n+        Definition::Static(s) => format!(\"static.{}.html\", s.name(db)),\n+        Definition::Macro(mac) => format!(\"macro.{}.html\", mac.name(db)?),\n+        Definition::Field(field) => {\n+            let def = match field.parent_def(db) {\n+                hir::VariantDef::Struct(it) => Definition::Adt(it.into()),\n+                hir::VariantDef::Union(it) => Definition::Adt(it.into()),\n+                hir::VariantDef::Variant(it) => Definition::Variant(it),\n+            };\n+            let (_, file, _) = filename_and_frag_for_def(db, def)?;\n+            return Some((def, file, Some(format!(\"structfield.{}\", field.name(db)))));\n+        }\n+        Definition::SelfType(impl_) => {\n+            let adt = impl_.self_ty(db).as_adt()?.into();\n+            let (_, file, _) = filename_and_frag_for_def(db, adt)?;\n+            // FIXME fragment numbering\n+            return Some((adt, file, Some(String::from(\"impl\"))));\n+        }\n+        Definition::Local(_) => return None,\n+        Definition::GenericParam(_) => return None,\n+        Definition::Label(_) => return None,\n     };\n-    Some(res)\n+\n+    Some((def, res, None))\n }\n \n /// Get the fragment required to link to a specific field, method, associated type, or associated constant.\n@@ -803,8 +777,6 @@ pub struct B$0ar\n \n     #[test]\n     fn rewrite_on_field() {\n-        // FIXME: Should be\n-        //  [Foo](https://docs.rs/test/*/test/struct.Foo.html)\n         check_rewrite(\n             r#\"\n //- /main.rs crate:foo\n@@ -813,7 +785,7 @@ pub struct Foo {\n     fie$0ld: ()\n }\n \"#,\n-            expect![[r#\"[Foo](struct.Foo.html)\"#]],\n+            expect![[r#\"[Foo](https://docs.rs/foo/*/foo/struct.Foo.html)\"#]],\n         );\n     }\n \n@@ -927,17 +899,17 @@ pub struct $0Foo;\n     ) -> Option<Option<(Option<hir::Documentation>, Definition)>> {\n         Some(match_ast! {\n             match node {\n-                ast::SourceFile(it)  => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Module(def)))),\n-                ast::Module(it)      => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Module(def)))),\n-                ast::Fn(it)          => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Function(def)))),\n-                ast::Struct(it)      => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Struct(def))))),\n-                ast::Union(it)       => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Union(def))))),\n-                ast::Enum(it)        => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(def))))),\n-                ast::Variant(it)     => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Variant(def)))),\n-                ast::Trait(it)       => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Trait(def)))),\n-                ast::Static(it)      => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Static(def)))),\n-                ast::Const(it)       => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Const(def)))),\n-                ast::TypeAlias(it)   => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::TypeAlias(def)))),\n+                ast::SourceFile(it)  => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::Module(def))),\n+                ast::Module(it)      => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::Module(def))),\n+                ast::Fn(it)          => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::Function(def))),\n+                ast::Struct(it)      => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::Adt(hir::Adt::Struct(def)))),\n+                ast::Union(it)       => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::Adt(hir::Adt::Union(def)))),\n+                ast::Enum(it)        => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::Adt(hir::Adt::Enum(def)))),\n+                ast::Variant(it)     => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::Variant(def))),\n+                ast::Trait(it)       => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::Trait(def))),\n+                ast::Static(it)      => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::Static(def))),\n+                ast::Const(it)       => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::Const(def))),\n+                ast::TypeAlias(it)   => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::TypeAlias(def))),\n                 ast::Impl(it)        => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::SelfType(def))),\n                 ast::RecordField(it) => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::Field(def))),\n                 ast::TupleField(it)  => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::Field(def))),"}, {"sha": "e62daf03f98ec1bea1f34b3ec116ee0a6da08796", "filename": "crates/ide/src/goto_declaration.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Fgoto_declaration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Fgoto_declaration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_declaration.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -39,7 +39,7 @@ pub(crate) fn goto_declaration(\n                 }\n             };\n             match def? {\n-                Definition::ModuleDef(hir::ModuleDef::Module(module)) => {\n+                Definition::Module(module) => {\n                     Some(NavigationTarget::from_module_to_decl(db, module))\n                 }\n                 _ => None,"}, {"sha": "77f90eee19422f4222699fe411c1c664e421b9eb", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -3,7 +3,7 @@ use std::convert::TryInto;\n use crate::{\n     display::TryToNav, doc_links::token_as_doc_comment, FilePosition, NavigationTarget, RangeInfo,\n };\n-use hir::{AsAssocItem, ModuleDef, Semantics};\n+use hir::{AsAssocItem, Semantics};\n use ide_db::{\n     base_db::{AnchoredPath, FileId, FileLoader},\n     defs::Definition,\n@@ -110,12 +110,7 @@ fn try_find_trait_item_definition(\n     def: &Definition,\n ) -> Option<Vec<NavigationTarget>> {\n     let name = def.name(db)?;\n-    let assoc = match def {\n-        Definition::ModuleDef(ModuleDef::Function(f)) => f.as_assoc_item(db),\n-        Definition::ModuleDef(ModuleDef::Const(c)) => c.as_assoc_item(db),\n-        Definition::ModuleDef(ModuleDef::TypeAlias(ty)) => ty.as_assoc_item(db),\n-        _ => None,\n-    }?;\n+    let assoc = def.as_assoc_item(db)?;\n \n     let imp = match assoc.container(db) {\n         hir::AssocItemContainer::Impl(imp) => imp,"}, {"sha": "c9c7e232f2965eb952f2834c87cedc6684d558b3", "filename": "crates/ide/src/goto_implementation.rs", "status": "modified", "additions": 49, "deletions": 55, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Fgoto_implementation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Fgoto_implementation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_implementation.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -34,63 +34,57 @@ pub(crate) fn goto_implementation(\n             _ => 0,\n         })?;\n     let range = original_token.text_range();\n-    let navs =\n-        sema.descend_into_macros(original_token)\n-            .into_iter()\n-            .filter_map(|token| token.parent().and_then(ast::NameLike::cast))\n-            .filter_map(|node| {\n-                let def = match &node {\n-                    ast::NameLike::Name(name) => {\n-                        NameClass::classify(&sema, name).map(|class| match class {\n-                            NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n-                            NameClass::PatFieldShorthand { local_def, field_ref: _ } => {\n-                                Definition::Local(local_def)\n-                            }\n-                        })\n-                    }\n-                    ast::NameLike::NameRef(name_ref) => NameRefClass::classify(&sema, name_ref)\n-                        .map(|class| match class {\n-                            NameRefClass::Definition(def) => def,\n-                            NameRefClass::FieldShorthand { local_ref, field_ref: _ } => {\n-                                Definition::Local(local_ref)\n-                            }\n-                        }),\n-                    ast::NameLike::Lifetime(_) => None,\n-                }?;\n-\n-                match def {\n-                    Definition::ModuleDef(def) => Some(def),\n-                    _ => None,\n-                }\n-            })\n-            .unique()\n-            .filter_map(|def| {\n-                let navs = match def {\n-                    hir::ModuleDef::Trait(trait_) => impls_for_trait(&sema, trait_),\n-                    hir::ModuleDef::Adt(adt) => impls_for_ty(&sema, adt.ty(sema.db)),\n-                    hir::ModuleDef::TypeAlias(alias) => impls_for_ty(&sema, alias.ty(sema.db)),\n-                    hir::ModuleDef::BuiltinType(builtin) => {\n-                        let module = sema.to_module_def(position.file_id)?;\n-                        impls_for_ty(&sema, builtin.ty(sema.db, module))\n-                    }\n-                    hir::ModuleDef::Function(f) => {\n-                        let assoc = f.as_assoc_item(sema.db)?;\n-                        let name = assoc.name(sema.db)?;\n-                        let trait_ = assoc.containing_trait_or_trait_impl(sema.db)?;\n-                        impls_for_trait_item(&sema, trait_, name)\n+    let navs = sema\n+        .descend_into_macros(original_token)\n+        .into_iter()\n+        .filter_map(|token| token.parent().and_then(ast::NameLike::cast))\n+        .filter_map(|node| match &node {\n+            ast::NameLike::Name(name) => {\n+                NameClass::classify(&sema, name).map(|class| match class {\n+                    NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n+                    NameClass::PatFieldShorthand { local_def, field_ref: _ } => {\n+                        Definition::Local(local_def)\n                     }\n-                    hir::ModuleDef::Const(c) => {\n-                        let assoc = c.as_assoc_item(sema.db)?;\n-                        let name = assoc.name(sema.db)?;\n-                        let trait_ = assoc.containing_trait_or_trait_impl(sema.db)?;\n-                        impls_for_trait_item(&sema, trait_, name)\n+                })\n+            }\n+            ast::NameLike::NameRef(name_ref) => {\n+                NameRefClass::classify(&sema, name_ref).map(|class| match class {\n+                    NameRefClass::Definition(def) => def,\n+                    NameRefClass::FieldShorthand { local_ref, field_ref: _ } => {\n+                        Definition::Local(local_ref)\n                     }\n-                    _ => return None,\n-                };\n-                Some(navs)\n-            })\n-            .flatten()\n-            .collect();\n+                })\n+            }\n+            ast::NameLike::Lifetime(_) => None,\n+        })\n+        .unique()\n+        .filter_map(|def| {\n+            let navs = match def {\n+                Definition::Trait(trait_) => impls_for_trait(&sema, trait_),\n+                Definition::Adt(adt) => impls_for_ty(&sema, adt.ty(sema.db)),\n+                Definition::TypeAlias(alias) => impls_for_ty(&sema, alias.ty(sema.db)),\n+                Definition::BuiltinType(builtin) => {\n+                    let module = sema.to_module_def(position.file_id)?;\n+                    impls_for_ty(&sema, builtin.ty(sema.db, module))\n+                }\n+                Definition::Function(f) => {\n+                    let assoc = f.as_assoc_item(sema.db)?;\n+                    let name = assoc.name(sema.db)?;\n+                    let trait_ = assoc.containing_trait_or_trait_impl(sema.db)?;\n+                    impls_for_trait_item(&sema, trait_, name)\n+                }\n+                Definition::Const(c) => {\n+                    let assoc = c.as_assoc_item(sema.db)?;\n+                    let name = assoc.name(sema.db)?;\n+                    let trait_ = assoc.containing_trait_or_trait_impl(sema.db)?;\n+                    impls_for_trait_item(&sema, trait_, name)\n+                }\n+                _ => return None,\n+            };\n+            Some(navs)\n+        })\n+        .flatten()\n+        .collect();\n \n     Some(RangeInfo { range, info: navs })\n }"}, {"sha": "ce58f72a7750bda9651824d82b7c93e2e93eda39", "filename": "crates/ide/src/goto_type_definition.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -1,4 +1,4 @@\n-use ide_db::{base_db::Upcast, helpers::pick_best_token, RootDatabase};\n+use ide_db::{base_db::Upcast, defs::Definition, helpers::pick_best_token, RootDatabase};\n use syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, T};\n \n use crate::{display::TryToNav, FilePosition, NavigationTarget, RangeInfo};\n@@ -29,7 +29,7 @@ pub(crate) fn goto_type_definition(\n         })?;\n \n     let mut res = Vec::new();\n-    let mut push = |def: hir::ModuleDef| {\n+    let mut push = |def: Definition| {\n         if let Some(nav) = def.try_to_nav(db) {\n             if !res.contains(&nav) {\n                 res.push(nav);"}, {"sha": "5ff6fd10bc8308d9ab0661dd0910f527565d89c6", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -97,7 +97,7 @@ fn highlight_references(\n \n     let declarations = defs.iter().flat_map(|def| {\n         match def {\n-            &Definition::ModuleDef(hir::ModuleDef::Module(module)) => {\n+            &Definition::Module(module) => {\n                 Some(NavigationTarget::from_module_to_decl(sema.db, module))\n             }\n             def => def.try_to_nav(sema.db),"}, {"sha": "f4fb52647e7f81b272f0505ffda63e1b9ca4a229", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 18, "deletions": 27, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -163,9 +163,7 @@ pub(crate) fn hover_for_definition(\n     config: &HoverConfig,\n ) -> Option<HoverResult> {\n     let famous_defs = match &definition {\n-        Definition::ModuleDef(hir::ModuleDef::BuiltinType(_)) => {\n-            Some(FamousDefs(sema, sema.scope(node).krate()))\n-        }\n+        Definition::BuiltinType(_) => Some(FamousDefs(sema, sema.scope(node).krate())),\n         _ => None,\n     };\n     if let Some(markup) = render::definition(sema.db, definition, famous_defs.as_ref(), config) {\n@@ -260,10 +258,8 @@ fn show_implementations_action(db: &RootDatabase, def: Definition) -> Option<Hov\n     }\n \n     let adt = match def {\n-        Definition::ModuleDef(hir::ModuleDef::Trait(it)) => {\n-            return it.try_to_nav(db).map(to_action)\n-        }\n-        Definition::ModuleDef(hir::ModuleDef::Adt(it)) => Some(it),\n+        Definition::Trait(it) => return it.try_to_nav(db).map(to_action),\n+        Definition::Adt(it) => Some(it),\n         Definition::SelfType(it) => it.self_ty(db).as_adt(),\n         _ => None,\n     }?;\n@@ -272,14 +268,12 @@ fn show_implementations_action(db: &RootDatabase, def: Definition) -> Option<Hov\n \n fn show_fn_references_action(db: &RootDatabase, def: Definition) -> Option<HoverAction> {\n     match def {\n-        Definition::ModuleDef(hir::ModuleDef::Function(it)) => {\n-            it.try_to_nav(db).map(|nav_target| {\n-                HoverAction::Reference(FilePosition {\n-                    file_id: nav_target.file_id,\n-                    offset: nav_target.focus_or_full_range().start(),\n-                })\n+        Definition::Function(it) => it.try_to_nav(db).map(|nav_target| {\n+            HoverAction::Reference(FilePosition {\n+                file_id: nav_target.file_id,\n+                offset: nav_target.focus_or_full_range().start(),\n             })\n-        }\n+        }),\n         _ => None,\n     }\n }\n@@ -290,20 +284,17 @@ fn runnable_action(\n     file_id: FileId,\n ) -> Option<HoverAction> {\n     match def {\n-        Definition::ModuleDef(it) => match it {\n-            hir::ModuleDef::Module(it) => runnable_mod(sema, it).map(HoverAction::Runnable),\n-            hir::ModuleDef::Function(func) => {\n-                let src = func.source(sema.db)?;\n-                if src.file_id != file_id.into() {\n-                    cov_mark::hit!(hover_macro_generated_struct_fn_doc_comment);\n-                    cov_mark::hit!(hover_macro_generated_struct_fn_doc_attr);\n-                    return None;\n-                }\n-\n-                runnable_fn(sema, func).map(HoverAction::Runnable)\n+        Definition::Module(it) => runnable_mod(sema, it).map(HoverAction::Runnable),\n+        Definition::Function(func) => {\n+            let src = func.source(sema.db)?;\n+            if src.file_id != file_id.into() {\n+                cov_mark::hit!(hover_macro_generated_struct_fn_doc_comment);\n+                cov_mark::hit!(hover_macro_generated_struct_fn_doc_attr);\n+                return None;\n             }\n-            _ => None,\n-        },\n+\n+            runnable_fn(sema, func).map(HoverAction::Runnable)\n+        }\n         _ => None,\n     }\n }"}, {"sha": "59068028ed9b40ce7bd78a94fe0129006a601fcd", "filename": "crates/ide/src/hover/render.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -242,7 +242,7 @@ pub(super) fn keyword(\n     let docs = doc_owner.attrs(sema.db).docs()?;\n     let markup = process_markup(\n         sema.db,\n-        Definition::ModuleDef(doc_owner.into()),\n+        Definition::Module(doc_owner),\n         &markup(Some(docs.into()), token.text().into(), None)?,\n         config,\n     );\n@@ -311,14 +311,11 @@ fn definition_owner_name(db: &RootDatabase, def: &Definition) -> Option<String>\n     match def {\n         Definition::Field(f) => Some(f.parent_def(db).name(db)),\n         Definition::Local(l) => l.parent(db).name(db),\n-        Definition::ModuleDef(md) => match md {\n-            hir::ModuleDef::Function(f) => match f.as_assoc_item(db)?.container(db) {\n-                hir::AssocItemContainer::Trait(t) => Some(t.name(db)),\n-                hir::AssocItemContainer::Impl(i) => i.self_ty(db).as_adt().map(|adt| adt.name(db)),\n-            },\n-            hir::ModuleDef::Variant(e) => Some(e.parent_enum(db).name(db)),\n-            _ => None,\n+        Definition::Function(f) => match f.as_assoc_item(db)?.container(db) {\n+            hir::AssocItemContainer::Trait(t) => Some(t.name(db)),\n+            hir::AssocItemContainer::Impl(i) => i.self_ty(db).as_adt().map(|adt| adt.name(db)),\n         },\n+        Definition::Variant(e) => Some(e.parent_enum(db).name(db)),\n         _ => None,\n     }\n     .map(|name| name.to_string())\n@@ -351,21 +348,19 @@ pub(super) fn definition(\n             it.attrs(db).docs(),\n         ),\n         Definition::Field(def) => label_and_docs(db, def),\n-        Definition::ModuleDef(it) => match it {\n-            hir::ModuleDef::Module(it) => label_and_docs(db, it),\n-            hir::ModuleDef::Function(it) => label_and_docs(db, it),\n-            hir::ModuleDef::Adt(it) => label_and_docs(db, it),\n-            hir::ModuleDef::Variant(it) => label_and_docs(db, it),\n-            hir::ModuleDef::Const(it) => label_and_docs(db, it),\n-            hir::ModuleDef::Static(it) => label_and_docs(db, it),\n-            hir::ModuleDef::Trait(it) => label_and_docs(db, it),\n-            hir::ModuleDef::TypeAlias(it) => label_and_docs(db, it),\n-            hir::ModuleDef::BuiltinType(it) => {\n-                return famous_defs\n-                    .and_then(|fd| builtin(fd, it))\n-                    .or_else(|| Some(Markup::fenced_block(&it.name())))\n-            }\n-        },\n+        Definition::Module(it) => label_and_docs(db, it),\n+        Definition::Function(it) => label_and_docs(db, it),\n+        Definition::Adt(it) => label_and_docs(db, it),\n+        Definition::Variant(it) => label_and_docs(db, it),\n+        Definition::Const(it) => label_and_docs(db, it),\n+        Definition::Static(it) => label_and_docs(db, it),\n+        Definition::Trait(it) => label_and_docs(db, it),\n+        Definition::TypeAlias(it) => label_and_docs(db, it),\n+        Definition::BuiltinType(it) => {\n+            return famous_defs\n+                .and_then(|fd| builtin(fd, it))\n+                .or_else(|| Some(Markup::fenced_block(&it.name())))\n+        }\n         Definition::Local(it) => return local(db, it),\n         Definition::SelfType(impl_def) => {\n             impl_def.self_ty(db).as_adt().map(|adt| label_and_docs(db, adt))?"}, {"sha": "d1219044fe5c23dc65c457e4be63fb1a15e2e716", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -80,7 +80,7 @@ pub(crate) fn find_all_refs(\n                 let mut usages =\n                     def.usages(sema).set_scope(search_scope.clone()).include_self_refs().all();\n                 let declaration = match def {\n-                    Definition::ModuleDef(hir::ModuleDef::Module(module)) => {\n+                    Definition::Module(module) => {\n                         Some(NavigationTarget::from_module_to_decl(sema.db, module))\n                     }\n                     def => def.try_to_nav(sema.db),\n@@ -168,7 +168,7 @@ fn retain_adt_literal_usages(\n ) {\n     let refs = usages.references.values_mut();\n     match def {\n-        Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(enum_))) => {\n+        Definition::Adt(hir::Adt::Enum(enum_)) => {\n             refs.for_each(|it| {\n                 it.retain(|reference| {\n                     reference\n@@ -179,7 +179,7 @@ fn retain_adt_literal_usages(\n             });\n             usages.references.retain(|_, it| !it.is_empty());\n         }\n-        Definition::ModuleDef(hir::ModuleDef::Adt(_) | hir::ModuleDef::Variant(_)) => {\n+        Definition::Adt(_) | Definition::Variant(_) => {\n             refs.for_each(|it| {\n                 it.retain(|reference| reference.name.as_name_ref().map_or(false, is_lit_name_ref))\n             });"}, {"sha": "f9f9c0832cdf11dceb1b06a5341735d89832a3f5", "filename": "crates/ide/src/rename.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frename.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -113,7 +113,7 @@ pub(crate) fn will_rename_file(\n ) -> Option<SourceChange> {\n     let sema = Semantics::new(db);\n     let module = sema.to_module_def(file_id)?;\n-    let def = Definition::ModuleDef(module.into());\n+    let def = Definition::Module(module);\n     let mut change = def.rename(&sema, new_name_stem).ok()?;\n     change.file_system_edits.clear();\n     Some(change)"}, {"sha": "d63b0c87a904b84ba3e9a0cd14bc3caab8d2b287", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 87, "deletions": 91, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -246,7 +246,7 @@ fn node(\n fn highlight_name_ref_in_attr(sema: &Semantics<RootDatabase>, name_ref: ast::NameRef) -> Highlight {\n     match NameRefClass::classify(sema, &name_ref) {\n         Some(name_class) => match name_class {\n-            NameRefClass::Definition(Definition::ModuleDef(hir::ModuleDef::Module(_)))\n+            NameRefClass::Definition(Definition::Module(_))\n                 if name_ref\n                     .syntax()\n                     .ancestors()\n@@ -302,9 +302,7 @@ fn highlight_name_ref(\n                     {\n                         h |= HlMod::Consuming;\n                     }\n-                    Definition::ModuleDef(hir::ModuleDef::Trait(trait_))\n-                        if trait_.is_unsafe(db) =>\n-                    {\n+                    Definition::Trait(trait_) if trait_.is_unsafe(db) => {\n                         if ast::Impl::for_trait_name_ref(&name_ref)\n                             .map_or(false, |impl_| impl_.unsafe_token().is_some())\n                         {\n@@ -358,7 +356,7 @@ fn highlight_name(\n     match name_kind {\n         Some(NameClass::Definition(def)) => {\n             let mut h = highlight_def(sema, krate, def) | HlMod::Definition;\n-            if let Definition::ModuleDef(hir::ModuleDef::Trait(trait_)) = &def {\n+            if let Definition::Trait(trait_) = &def {\n                 if trait_.is_unsafe(db) {\n                     h |= HlMod::Unsafe;\n                 }\n@@ -398,112 +396,110 @@ fn highlight_def(\n     let mut h = match def {\n         Definition::Macro(_) => Highlight::new(HlTag::Symbol(SymbolKind::Macro)),\n         Definition::Field(_) => Highlight::new(HlTag::Symbol(SymbolKind::Field)),\n-        Definition::ModuleDef(def) => match def {\n-            hir::ModuleDef::Module(module) => {\n-                let mut h = Highlight::new(HlTag::Symbol(SymbolKind::Module));\n-                if module.parent(db).is_none() {\n-                    h |= HlMod::CrateRoot\n-                }\n-                h\n+        Definition::Module(module) => {\n+            let mut h = Highlight::new(HlTag::Symbol(SymbolKind::Module));\n+            if module.parent(db).is_none() {\n+                h |= HlMod::CrateRoot\n             }\n-            hir::ModuleDef::Function(func) => {\n-                let mut h = Highlight::new(HlTag::Symbol(SymbolKind::Function));\n-                if let Some(item) = func.as_assoc_item(db) {\n-                    h |= HlMod::Associated;\n-                    match func.self_param(db) {\n-                        Some(sp) => match sp.access(db) {\n-                            hir::Access::Exclusive => {\n-                                h |= HlMod::Mutable;\n-                                h |= HlMod::Reference;\n-                            }\n-                            hir::Access::Shared => h |= HlMod::Reference,\n-                            hir::Access::Owned => h |= HlMod::Consuming,\n-                        },\n-                        None => h |= HlMod::Static,\n-                    }\n-\n-                    match item.container(db) {\n-                        hir::AssocItemContainer::Impl(i) => {\n-                            if i.trait_(db).is_some() {\n-                                h |= HlMod::Trait;\n-                            }\n+            h\n+        }\n+        Definition::Function(func) => {\n+            let mut h = Highlight::new(HlTag::Symbol(SymbolKind::Function));\n+            if let Some(item) = func.as_assoc_item(db) {\n+                h |= HlMod::Associated;\n+                match func.self_param(db) {\n+                    Some(sp) => match sp.access(db) {\n+                        hir::Access::Exclusive => {\n+                            h |= HlMod::Mutable;\n+                            h |= HlMod::Reference;\n                         }\n-                        hir::AssocItemContainer::Trait(_t) => {\n+                        hir::Access::Shared => h |= HlMod::Reference,\n+                        hir::Access::Owned => h |= HlMod::Consuming,\n+                    },\n+                    None => h |= HlMod::Static,\n+                }\n+\n+                match item.container(db) {\n+                    hir::AssocItemContainer::Impl(i) => {\n+                        if i.trait_(db).is_some() {\n                             h |= HlMod::Trait;\n                         }\n                     }\n+                    hir::AssocItemContainer::Trait(_t) => {\n+                        h |= HlMod::Trait;\n+                    }\n                 }\n-\n-                if func.is_unsafe(db) {\n-                    h |= HlMod::Unsafe;\n-                }\n-                if func.is_async(db) {\n-                    h |= HlMod::Async;\n-                }\n-\n-                h\n             }\n-            hir::ModuleDef::Adt(adt) => {\n-                let h = match adt {\n-                    hir::Adt::Struct(_) => HlTag::Symbol(SymbolKind::Struct),\n-                    hir::Adt::Enum(_) => HlTag::Symbol(SymbolKind::Enum),\n-                    hir::Adt::Union(_) => HlTag::Symbol(SymbolKind::Union),\n-                };\n \n-                Highlight::new(h)\n+            if func.is_unsafe(db) {\n+                h |= HlMod::Unsafe;\n             }\n-            hir::ModuleDef::Variant(_) => Highlight::new(HlTag::Symbol(SymbolKind::Variant)),\n-            hir::ModuleDef::Const(konst) => {\n-                let mut h = Highlight::new(HlTag::Symbol(SymbolKind::Const));\n-\n-                if let Some(item) = konst.as_assoc_item(db) {\n-                    h |= HlMod::Associated;\n-                    match item.container(db) {\n-                        hir::AssocItemContainer::Impl(i) => {\n-                            if i.trait_(db).is_some() {\n-                                h |= HlMod::Trait;\n-                            }\n-                        }\n-                        hir::AssocItemContainer::Trait(_t) => {\n+            if func.is_async(db) {\n+                h |= HlMod::Async;\n+            }\n+\n+            h\n+        }\n+        Definition::Adt(adt) => {\n+            let h = match adt {\n+                hir::Adt::Struct(_) => HlTag::Symbol(SymbolKind::Struct),\n+                hir::Adt::Enum(_) => HlTag::Symbol(SymbolKind::Enum),\n+                hir::Adt::Union(_) => HlTag::Symbol(SymbolKind::Union),\n+            };\n+\n+            Highlight::new(h)\n+        }\n+        Definition::Variant(_) => Highlight::new(HlTag::Symbol(SymbolKind::Variant)),\n+        Definition::Const(konst) => {\n+            let mut h = Highlight::new(HlTag::Symbol(SymbolKind::Const));\n+\n+            if let Some(item) = konst.as_assoc_item(db) {\n+                h |= HlMod::Associated;\n+                match item.container(db) {\n+                    hir::AssocItemContainer::Impl(i) => {\n+                        if i.trait_(db).is_some() {\n                             h |= HlMod::Trait;\n                         }\n                     }\n+                    hir::AssocItemContainer::Trait(_t) => {\n+                        h |= HlMod::Trait;\n+                    }\n                 }\n-\n-                h\n             }\n-            hir::ModuleDef::Trait(_) => Highlight::new(HlTag::Symbol(SymbolKind::Trait)),\n-            hir::ModuleDef::TypeAlias(type_) => {\n-                let mut h = Highlight::new(HlTag::Symbol(SymbolKind::TypeAlias));\n-\n-                if let Some(item) = type_.as_assoc_item(db) {\n-                    h |= HlMod::Associated;\n-                    match item.container(db) {\n-                        hir::AssocItemContainer::Impl(i) => {\n-                            if i.trait_(db).is_some() {\n-                                h |= HlMod::Trait;\n-                            }\n-                        }\n-                        hir::AssocItemContainer::Trait(_t) => {\n+\n+            h\n+        }\n+        Definition::Trait(_) => Highlight::new(HlTag::Symbol(SymbolKind::Trait)),\n+        Definition::TypeAlias(type_) => {\n+            let mut h = Highlight::new(HlTag::Symbol(SymbolKind::TypeAlias));\n+\n+            if let Some(item) = type_.as_assoc_item(db) {\n+                h |= HlMod::Associated;\n+                match item.container(db) {\n+                    hir::AssocItemContainer::Impl(i) => {\n+                        if i.trait_(db).is_some() {\n                             h |= HlMod::Trait;\n                         }\n                     }\n+                    hir::AssocItemContainer::Trait(_t) => {\n+                        h |= HlMod::Trait;\n+                    }\n                 }\n-\n-                h\n             }\n-            hir::ModuleDef::BuiltinType(_) => Highlight::new(HlTag::BuiltinType),\n-            hir::ModuleDef::Static(s) => {\n-                let mut h = Highlight::new(HlTag::Symbol(SymbolKind::Static));\n \n-                if s.is_mut(db) {\n-                    h |= HlMod::Mutable;\n-                    h |= HlMod::Unsafe;\n-                }\n+            h\n+        }\n+        Definition::BuiltinType(_) => Highlight::new(HlTag::BuiltinType),\n+        Definition::Static(s) => {\n+            let mut h = Highlight::new(HlTag::Symbol(SymbolKind::Static));\n \n-                h\n+            if s.is_mut(db) {\n+                h |= HlMod::Mutable;\n+                h |= HlMod::Unsafe;\n             }\n-        },\n+\n+            h\n+        }\n         Definition::SelfType(_) => Highlight::new(HlTag::Symbol(SymbolKind::Impl)),\n         Definition::GenericParam(it) => match it {\n             hir::GenericParam::TypeParam(_) => Highlight::new(HlTag::Symbol(SymbolKind::TypeParam)),\n@@ -540,13 +536,13 @@ fn highlight_def(\n \n     let famous_defs = FamousDefs(sema, krate);\n     let def_crate = def.module(db).map(hir::Module::krate).or_else(|| match def {\n-        Definition::ModuleDef(hir::ModuleDef::Module(module)) => Some(module.krate()),\n+        Definition::Module(module) => Some(module.krate()),\n         _ => None,\n     });\n     let is_from_other_crate = def_crate != krate;\n     let is_from_builtin_crate =\n         def_crate.map_or(false, |def_crate| famous_defs.builtin_crates().any(|it| def_crate == it));\n-    let is_builtin_type = matches!(def, Definition::ModuleDef(hir::ModuleDef::BuiltinType(_)));\n+    let is_builtin_type = matches!(def, Definition::BuiltinType(_));\n     let is_public = def.visibility(db) == Some(hir::Visibility::Public);\n \n     match (is_from_other_crate, is_builtin_type, is_public) {"}, {"sha": "b7a3fb62cb44f76852e0311bf3bb6355be835428", "filename": "crates/ide/src/syntax_highlighting/inject.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -4,7 +4,9 @@ use std::mem;\n \n use either::Either;\n use hir::{InFile, Semantics};\n-use ide_db::{call_info::ActiveParameter, helpers::rust_doc::is_rust_fence, SymbolKind};\n+use ide_db::{\n+    call_info::ActiveParameter, defs::Definition, helpers::rust_doc::is_rust_fence, SymbolKind,\n+};\n use syntax::{\n     ast::{self, AstNode, IsString},\n     AstToken, NodeOrToken, SyntaxNode, SyntaxToken, TextRange, TextSize,\n@@ -237,22 +239,29 @@ fn find_doc_string_in_attr(attr: &hir::Attr, it: &ast::Attr) -> Option<ast::Stri\n     }\n }\n \n-fn module_def_to_hl_tag(def: Either<hir::ModuleDef, hir::MacroDef>) -> HlTag {\n+fn module_def_to_hl_tag(def: Definition) -> HlTag {\n     let symbol = match def {\n-        Either::Left(def) => match def {\n-            hir::ModuleDef::Module(_) => SymbolKind::Module,\n-            hir::ModuleDef::Function(_) => SymbolKind::Function,\n-            hir::ModuleDef::Adt(hir::Adt::Struct(_)) => SymbolKind::Struct,\n-            hir::ModuleDef::Adt(hir::Adt::Enum(_)) => SymbolKind::Enum,\n-            hir::ModuleDef::Adt(hir::Adt::Union(_)) => SymbolKind::Union,\n-            hir::ModuleDef::Variant(_) => SymbolKind::Variant,\n-            hir::ModuleDef::Const(_) => SymbolKind::Const,\n-            hir::ModuleDef::Static(_) => SymbolKind::Static,\n-            hir::ModuleDef::Trait(_) => SymbolKind::Trait,\n-            hir::ModuleDef::TypeAlias(_) => SymbolKind::TypeAlias,\n-            hir::ModuleDef::BuiltinType(_) => return HlTag::BuiltinType,\n+        Definition::Module(_) => SymbolKind::Module,\n+        Definition::Function(_) => SymbolKind::Function,\n+        Definition::Adt(hir::Adt::Struct(_)) => SymbolKind::Struct,\n+        Definition::Adt(hir::Adt::Enum(_)) => SymbolKind::Enum,\n+        Definition::Adt(hir::Adt::Union(_)) => SymbolKind::Union,\n+        Definition::Variant(_) => SymbolKind::Variant,\n+        Definition::Const(_) => SymbolKind::Const,\n+        Definition::Static(_) => SymbolKind::Static,\n+        Definition::Trait(_) => SymbolKind::Trait,\n+        Definition::TypeAlias(_) => SymbolKind::TypeAlias,\n+        Definition::BuiltinType(_) => return HlTag::BuiltinType,\n+        Definition::Macro(_) => SymbolKind::Macro,\n+        Definition::Field(_) => SymbolKind::Field,\n+        Definition::SelfType(_) => SymbolKind::Impl,\n+        Definition::Local(_) => SymbolKind::Local,\n+        Definition::GenericParam(gp) => match gp {\n+            hir::GenericParam::TypeParam(_) => SymbolKind::TypeParam,\n+            hir::GenericParam::LifetimeParam(_) => SymbolKind::LifetimeParam,\n+            hir::GenericParam::ConstParam(_) => SymbolKind::ConstParam,\n         },\n-        Either::Right(_) => SymbolKind::Macro,\n+        Definition::Label(_) => SymbolKind::Label,\n     };\n     HlTag::Symbol(symbol)\n }"}, {"sha": "64f9eb9586a117ef2cce92f353a7779947ec5297", "filename": "crates/ide_assists/src/handlers/add_turbo_fish.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -44,7 +44,7 @@ pub(crate) fn add_turbo_fish(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n         NameRefClass::FieldShorthand { .. } => return None,\n     };\n     let fun = match def {\n-        Definition::ModuleDef(hir::ModuleDef::Function(it)) => it,\n+        Definition::Function(it) => it,\n         _ => return None,\n     };\n     let generics = hir::GenericDef::Function(fun).params(ctx.sema.db);"}, {"sha": "8093ba2560ccd84086f80c0d40faa0110f66e69d", "filename": "crates/ide_assists/src/handlers/convert_tuple_struct_to_named_struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -127,8 +127,8 @@ fn edit_struct_references(\n     names: &[ast::Name],\n ) {\n     let strukt_def = match strukt {\n-        Either::Left(s) => Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Struct(s))),\n-        Either::Right(v) => Definition::ModuleDef(hir::ModuleDef::Variant(v)),\n+        Either::Left(s) => Definition::Adt(hir::Adt::Struct(s)),\n+        Either::Right(v) => Definition::Variant(v),\n     };\n     let usages = strukt_def.usages(&ctx.sema).include_self_refs().all();\n "}, {"sha": "72c17b674c4682947b7d59ce66a59b3c7232711b", "filename": "crates/ide_assists/src/handlers/expand_glob_import.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -1,5 +1,5 @@\n use either::Either;\n-use hir::{AssocItem, HasVisibility, MacroDef, Module, ModuleDef, Name, PathResolution, ScopeDef};\n+use hir::{AssocItem, HasVisibility, Module, ModuleDef, Name, PathResolution, ScopeDef};\n use ide_db::{\n     defs::{Definition, NameRefClass},\n     search::SearchScope,\n@@ -112,36 +112,27 @@ fn find_parent_and_path(\n     }\n }\n \n-#[derive(Debug, PartialEq, Clone)]\n-enum Def {\n-    ModuleDef(ModuleDef),\n-    MacroDef(MacroDef),\n-}\n-\n-impl Def {\n-    fn is_referenced_in(&self, ctx: &AssistContext) -> bool {\n-        let def = match self {\n-            Def::ModuleDef(def) => Definition::ModuleDef(*def),\n-            Def::MacroDef(def) => Definition::Macro(*def),\n-        };\n-\n-        let search_scope = SearchScope::single_file(ctx.file_id());\n-        def.usages(&ctx.sema).in_scope(search_scope).at_least_one()\n-    }\n+fn def_is_referenced_in(def: Definition, ctx: &AssistContext) -> bool {\n+    let search_scope = SearchScope::single_file(ctx.file_id());\n+    def.usages(&ctx.sema).in_scope(search_scope).at_least_one()\n }\n \n #[derive(Debug, Clone)]\n struct Ref {\n     // could be alias\n     visible_name: Name,\n-    def: Def,\n+    def: Definition,\n }\n \n impl Ref {\n     fn from_scope_def(name: Name, scope_def: ScopeDef) -> Option<Self> {\n         match scope_def {\n-            ScopeDef::ModuleDef(def) => Some(Ref { visible_name: name, def: Def::ModuleDef(def) }),\n-            ScopeDef::MacroDef(def) => Some(Ref { visible_name: name, def: Def::MacroDef(def) }),\n+            ScopeDef::ModuleDef(def) => {\n+                Some(Ref { visible_name: name, def: Definition::from(def) })\n+            }\n+            ScopeDef::MacroDef(def) => {\n+                Some(Ref { visible_name: name, def: Definition::Macro(def) })\n+            }\n             _ => None,\n         }\n     }\n@@ -157,10 +148,10 @@ impl Refs {\n                 .clone()\n                 .into_iter()\n                 .filter(|r| {\n-                    if let Def::ModuleDef(ModuleDef::Trait(tr)) = r.def {\n+                    if let Definition::Trait(tr) = r.def {\n                         if tr.items(ctx.db()).into_iter().any(|ai| {\n                             if let AssocItem::Function(f) = ai {\n-                                Def::ModuleDef(ModuleDef::Function(f)).is_referenced_in(ctx)\n+                                def_is_referenced_in(Definition::Function(f), ctx)\n                             } else {\n                                 false\n                             }\n@@ -169,13 +160,13 @@ impl Refs {\n                         }\n                     }\n \n-                    r.def.is_referenced_in(ctx)\n+                    def_is_referenced_in(r.def, ctx)\n                 })\n                 .collect(),\n         )\n     }\n \n-    fn filter_out_by_defs(&self, defs: Vec<Def>) -> Refs {\n+    fn filter_out_by_defs(&self, defs: Vec<Definition>) -> Refs {\n         Refs(self.0.clone().into_iter().filter(|r| !defs.contains(&r.def)).collect())\n     }\n }\n@@ -220,7 +211,7 @@ fn is_mod_visible_from(ctx: &AssistContext, module: Module, from: Module) -> boo\n // use foo::*$0;\n // use baz::Baz;\n // \u2191 ---------------\n-fn find_imported_defs(ctx: &AssistContext, star: SyntaxToken) -> Option<Vec<Def>> {\n+fn find_imported_defs(ctx: &AssistContext, star: SyntaxToken) -> Option<Vec<Definition>> {\n     let parent_use_item_syntax =\n         star.ancestors().find_map(|n| if ast::Use::can_cast(n.kind()) { Some(n) } else { None })?;\n \n@@ -234,8 +225,19 @@ fn find_imported_defs(ctx: &AssistContext, star: SyntaxToken) -> Option<Vec<Def>\n             })\n             .flat_map(|n| n.descendants().filter_map(ast::NameRef::cast))\n             .filter_map(|r| match NameRefClass::classify(&ctx.sema, &r)? {\n-                NameRefClass::Definition(Definition::ModuleDef(def)) => Some(Def::ModuleDef(def)),\n-                NameRefClass::Definition(Definition::Macro(def)) => Some(Def::MacroDef(def)),\n+                NameRefClass::Definition(\n+                    def\n+                    @\n+                    (Definition::Macro(_)\n+                    | Definition::Module(_)\n+                    | Definition::Function(_)\n+                    | Definition::Adt(_)\n+                    | Definition::Variant(_)\n+                    | Definition::Const(_)\n+                    | Definition::Static(_)\n+                    | Definition::Trait(_)\n+                    | Definition::TypeAlias(_)),\n+                ) => Some(def),\n                 _ => None,\n             })\n             .collect(),\n@@ -245,7 +247,7 @@ fn find_imported_defs(ctx: &AssistContext, star: SyntaxToken) -> Option<Vec<Def>\n fn find_names_to_import(\n     ctx: &AssistContext,\n     refs_in_target: Refs,\n-    imported_defs: Vec<Def>,\n+    imported_defs: Vec<Definition>,\n ) -> Vec<Name> {\n     let used_refs = refs_in_target.used_refs(ctx).filter_out_by_defs(imported_defs);\n     used_refs.0.iter().map(|r| r.visible_name.clone()).collect()"}, {"sha": "80fc7946ce337e74bf8cc2d242300dafcc816725", "filename": "crates/ide_assists/src/handlers/extract_module.rs", "status": "modified", "additions": 122, "deletions": 132, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_module.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -1,6 +1,6 @@\n use std::collections::{HashMap, HashSet};\n \n-use hir::{HasSource, ModuleDef, ModuleSource};\n+use hir::{HasSource, ModuleSource};\n use ide_db::{\n     assists::{AssistId, AssistKind},\n     base_db::FileId,\n@@ -184,7 +184,7 @@ impl Module {\n                 match (item.syntax()) {\n                     ast::Adt(it) => {\n                         if let Some( nod ) = ctx.sema.to_def(&it) {\n-                            let node_def = Definition::ModuleDef(nod.into());\n+                            let node_def = Definition::Adt(nod.into());\n                             self.expand_and_group_usages_file_wise(ctx, node_def, &mut refs);\n \n                             //Enum Fields are not allowed to explicitly specify pub, it is implied\n@@ -218,25 +218,25 @@ impl Module {\n                     },\n                     ast::TypeAlias(it) => {\n                         if let Some( nod ) = ctx.sema.to_def(&it) {\n-                            let node_def = Definition::ModuleDef(nod.into());\n+                            let node_def = Definition::TypeAlias(nod.into());\n                             self.expand_and_group_usages_file_wise(ctx, node_def, &mut refs);\n                         }\n                     },\n                     ast::Const(it) => {\n                         if let Some( nod ) = ctx.sema.to_def(&it) {\n-                            let node_def = Definition::ModuleDef(nod.into());\n+                            let node_def = Definition::Const(nod.into());\n                             self.expand_and_group_usages_file_wise(ctx, node_def, &mut refs);\n                         }\n                     },\n                     ast::Static(it) => {\n                         if let Some( nod ) = ctx.sema.to_def(&it) {\n-                            let node_def = Definition::ModuleDef(nod.into());\n+                            let node_def = Definition::Static(nod.into());\n                             self.expand_and_group_usages_file_wise(ctx, node_def, &mut refs);\n                         }\n                     },\n                     ast::Fn(it) => {\n                         if let Some( nod ) = ctx.sema.to_def(&it) {\n-                            let node_def = Definition::ModuleDef(nod.into());\n+                            let node_def = Definition::Function(nod.into());\n                             self.expand_and_group_usages_file_wise(ctx, node_def, &mut refs);\n                         }\n                     },\n@@ -603,161 +603,151 @@ fn does_source_exists_outside_sel_in_same_mod(\n ) -> bool {\n     let mut source_exists_outside_sel_in_same_mod = false;\n     match def {\n-        Definition::ModuleDef(it) => match it {\n-            ModuleDef::Module(x) => {\n-                let source = x.definition_source(ctx.db());\n-                let have_same_parent;\n-                if let Some(ast_module) = &curr_parent_module {\n-                    if let Some(hir_module) = x.parent(ctx.db()) {\n-                        have_same_parent =\n-                            compare_hir_and_ast_module(&ast_module, hir_module, ctx).is_some();\n-                    } else {\n-                        let source_file_id = source.file_id.original_file(ctx.db());\n-                        have_same_parent = source_file_id == curr_file_id;\n-                    }\n+        Definition::Module(x) => {\n+            let source = x.definition_source(ctx.db());\n+            let have_same_parent;\n+            if let Some(ast_module) = &curr_parent_module {\n+                if let Some(hir_module) = x.parent(ctx.db()) {\n+                    have_same_parent =\n+                        compare_hir_and_ast_module(&ast_module, hir_module, ctx).is_some();\n                 } else {\n                     let source_file_id = source.file_id.original_file(ctx.db());\n                     have_same_parent = source_file_id == curr_file_id;\n                 }\n+            } else {\n+                let source_file_id = source.file_id.original_file(ctx.db());\n+                have_same_parent = source_file_id == curr_file_id;\n+            }\n \n-                if have_same_parent {\n-                    match source.value {\n-                        ModuleSource::Module(module_) => {\n-                            source_exists_outside_sel_in_same_mod =\n-                                !selection_range.contains_range(module_.syntax().text_range());\n-                        }\n-                        _ => {}\n+            if have_same_parent {\n+                match source.value {\n+                    ModuleSource::Module(module_) => {\n+                        source_exists_outside_sel_in_same_mod =\n+                            !selection_range.contains_range(module_.syntax().text_range());\n                     }\n+                    _ => {}\n                 }\n             }\n-            ModuleDef::Function(x) => {\n-                if let Some(source) = x.source(ctx.db()) {\n-                    let have_same_parent;\n-                    if let Some(ast_module) = &curr_parent_module {\n-                        have_same_parent =\n-                            compare_hir_and_ast_module(&ast_module, x.module(ctx.db()), ctx)\n-                                .is_some();\n-                    } else {\n-                        let source_file_id = source.file_id.original_file(ctx.db());\n-                        have_same_parent = source_file_id == curr_file_id;\n-                    }\n+        }\n+        Definition::Function(x) => {\n+            if let Some(source) = x.source(ctx.db()) {\n+                let have_same_parent;\n+                if let Some(ast_module) = &curr_parent_module {\n+                    have_same_parent =\n+                        compare_hir_and_ast_module(&ast_module, x.module(ctx.db()), ctx).is_some();\n+                } else {\n+                    let source_file_id = source.file_id.original_file(ctx.db());\n+                    have_same_parent = source_file_id == curr_file_id;\n+                }\n \n-                    if have_same_parent {\n-                        source_exists_outside_sel_in_same_mod =\n-                            !selection_range.contains_range(source.value.syntax().text_range());\n-                    }\n+                if have_same_parent {\n+                    source_exists_outside_sel_in_same_mod =\n+                        !selection_range.contains_range(source.value.syntax().text_range());\n                 }\n             }\n-            ModuleDef::Adt(x) => {\n-                if let Some(source) = x.source(ctx.db()) {\n-                    let have_same_parent;\n-                    if let Some(ast_module) = &curr_parent_module {\n-                        have_same_parent =\n-                            compare_hir_and_ast_module(&ast_module, x.module(ctx.db()), ctx)\n-                                .is_some();\n-                    } else {\n-                        let source_file_id = source.file_id.original_file(ctx.db());\n-                        have_same_parent = source_file_id == curr_file_id;\n-                    }\n+        }\n+        Definition::Adt(x) => {\n+            if let Some(source) = x.source(ctx.db()) {\n+                let have_same_parent;\n+                if let Some(ast_module) = &curr_parent_module {\n+                    have_same_parent =\n+                        compare_hir_and_ast_module(&ast_module, x.module(ctx.db()), ctx).is_some();\n+                } else {\n+                    let source_file_id = source.file_id.original_file(ctx.db());\n+                    have_same_parent = source_file_id == curr_file_id;\n+                }\n \n-                    if have_same_parent {\n-                        source_exists_outside_sel_in_same_mod =\n-                            !selection_range.contains_range(source.value.syntax().text_range());\n-                    }\n+                if have_same_parent {\n+                    source_exists_outside_sel_in_same_mod =\n+                        !selection_range.contains_range(source.value.syntax().text_range());\n                 }\n             }\n-            ModuleDef::Variant(x) => {\n-                if let Some(source) = x.source(ctx.db()) {\n-                    let have_same_parent;\n-                    if let Some(ast_module) = &curr_parent_module {\n-                        have_same_parent =\n-                            compare_hir_and_ast_module(&ast_module, x.module(ctx.db()), ctx)\n-                                .is_some();\n-                    } else {\n-                        let source_file_id = source.file_id.original_file(ctx.db());\n-                        have_same_parent = source_file_id == curr_file_id;\n-                    }\n+        }\n+        Definition::Variant(x) => {\n+            if let Some(source) = x.source(ctx.db()) {\n+                let have_same_parent;\n+                if let Some(ast_module) = &curr_parent_module {\n+                    have_same_parent =\n+                        compare_hir_and_ast_module(&ast_module, x.module(ctx.db()), ctx).is_some();\n+                } else {\n+                    let source_file_id = source.file_id.original_file(ctx.db());\n+                    have_same_parent = source_file_id == curr_file_id;\n+                }\n \n-                    if have_same_parent {\n-                        source_exists_outside_sel_in_same_mod =\n-                            !selection_range.contains_range(source.value.syntax().text_range());\n-                    }\n+                if have_same_parent {\n+                    source_exists_outside_sel_in_same_mod =\n+                        !selection_range.contains_range(source.value.syntax().text_range());\n                 }\n             }\n-            ModuleDef::Const(x) => {\n-                if let Some(source) = x.source(ctx.db()) {\n-                    let have_same_parent;\n-                    if let Some(ast_module) = &curr_parent_module {\n-                        have_same_parent =\n-                            compare_hir_and_ast_module(&ast_module, x.module(ctx.db()), ctx)\n-                                .is_some();\n-                    } else {\n-                        let source_file_id = source.file_id.original_file(ctx.db());\n-                        have_same_parent = source_file_id == curr_file_id;\n-                    }\n+        }\n+        Definition::Const(x) => {\n+            if let Some(source) = x.source(ctx.db()) {\n+                let have_same_parent;\n+                if let Some(ast_module) = &curr_parent_module {\n+                    have_same_parent =\n+                        compare_hir_and_ast_module(&ast_module, x.module(ctx.db()), ctx).is_some();\n+                } else {\n+                    let source_file_id = source.file_id.original_file(ctx.db());\n+                    have_same_parent = source_file_id == curr_file_id;\n+                }\n \n-                    if have_same_parent {\n-                        source_exists_outside_sel_in_same_mod =\n-                            !selection_range.contains_range(source.value.syntax().text_range());\n-                    }\n+                if have_same_parent {\n+                    source_exists_outside_sel_in_same_mod =\n+                        !selection_range.contains_range(source.value.syntax().text_range());\n                 }\n             }\n-            ModuleDef::Static(x) => {\n-                if let Some(source) = x.source(ctx.db()) {\n-                    let have_same_parent;\n-                    if let Some(ast_module) = &curr_parent_module {\n-                        have_same_parent =\n-                            compare_hir_and_ast_module(&ast_module, x.module(ctx.db()), ctx)\n-                                .is_some();\n-                    } else {\n-                        let source_file_id = source.file_id.original_file(ctx.db());\n-                        have_same_parent = source_file_id == curr_file_id;\n-                    }\n+        }\n+        Definition::Static(x) => {\n+            if let Some(source) = x.source(ctx.db()) {\n+                let have_same_parent;\n+                if let Some(ast_module) = &curr_parent_module {\n+                    have_same_parent =\n+                        compare_hir_and_ast_module(&ast_module, x.module(ctx.db()), ctx).is_some();\n+                } else {\n+                    let source_file_id = source.file_id.original_file(ctx.db());\n+                    have_same_parent = source_file_id == curr_file_id;\n+                }\n \n-                    if have_same_parent {\n-                        source_exists_outside_sel_in_same_mod =\n-                            !selection_range.contains_range(source.value.syntax().text_range());\n-                    }\n+                if have_same_parent {\n+                    source_exists_outside_sel_in_same_mod =\n+                        !selection_range.contains_range(source.value.syntax().text_range());\n                 }\n             }\n-            ModuleDef::Trait(x) => {\n-                if let Some(source) = x.source(ctx.db()) {\n-                    let have_same_parent;\n-                    if let Some(ast_module) = &curr_parent_module {\n-                        have_same_parent =\n-                            compare_hir_and_ast_module(&ast_module, x.module(ctx.db()), ctx)\n-                                .is_some();\n-                    } else {\n-                        let source_file_id = source.file_id.original_file(ctx.db());\n-                        have_same_parent = source_file_id == curr_file_id;\n-                    }\n+        }\n+        Definition::Trait(x) => {\n+            if let Some(source) = x.source(ctx.db()) {\n+                let have_same_parent;\n+                if let Some(ast_module) = &curr_parent_module {\n+                    have_same_parent =\n+                        compare_hir_and_ast_module(&ast_module, x.module(ctx.db()), ctx).is_some();\n+                } else {\n+                    let source_file_id = source.file_id.original_file(ctx.db());\n+                    have_same_parent = source_file_id == curr_file_id;\n+                }\n \n-                    if have_same_parent {\n-                        source_exists_outside_sel_in_same_mod =\n-                            !selection_range.contains_range(source.value.syntax().text_range());\n-                    }\n+                if have_same_parent {\n+                    source_exists_outside_sel_in_same_mod =\n+                        !selection_range.contains_range(source.value.syntax().text_range());\n                 }\n             }\n-            ModuleDef::TypeAlias(x) => {\n-                if let Some(source) = x.source(ctx.db()) {\n-                    let have_same_parent;\n-                    if let Some(ast_module) = &curr_parent_module {\n-                        have_same_parent =\n-                            compare_hir_and_ast_module(&ast_module, x.module(ctx.db()), ctx)\n-                                .is_some();\n-                    } else {\n-                        let source_file_id = source.file_id.original_file(ctx.db());\n-                        have_same_parent = source_file_id == curr_file_id;\n-                    }\n+        }\n+        Definition::TypeAlias(x) => {\n+            if let Some(source) = x.source(ctx.db()) {\n+                let have_same_parent;\n+                if let Some(ast_module) = &curr_parent_module {\n+                    have_same_parent =\n+                        compare_hir_and_ast_module(&ast_module, x.module(ctx.db()), ctx).is_some();\n+                } else {\n+                    let source_file_id = source.file_id.original_file(ctx.db());\n+                    have_same_parent = source_file_id == curr_file_id;\n+                }\n \n-                    if have_same_parent {\n-                        source_exists_outside_sel_in_same_mod =\n-                            !selection_range.contains_range(source.value.syntax().text_range());\n-                    }\n+                if have_same_parent {\n+                    source_exists_outside_sel_in_same_mod =\n+                        !selection_range.contains_range(source.value.syntax().text_range());\n                 }\n             }\n-            _ => {}\n-        },\n+        }\n         _ => {}\n     }\n "}, {"sha": "82e0970cc4bf84cb6e8fb508c9fafe61035b5ef6", "filename": "crates/ide_assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -63,8 +63,7 @@ pub(crate) fn extract_struct_from_enum_variant(\n         |builder| {\n             let variant_hir_name = variant_hir.name(ctx.db());\n             let enum_module_def = ModuleDef::from(enum_hir);\n-            let usages =\n-                Definition::ModuleDef(ModuleDef::Variant(variant_hir)).usages(&ctx.sema).all();\n+            let usages = Definition::Variant(variant_hir).usages(&ctx.sema).all();\n \n             let mut visited_modules_set = FxHashSet::default();\n             let current_module = enum_hir.module(ctx.db());"}, {"sha": "0b743307486a36f8d5621f79f98af1e468e7d697", "filename": "crates/ide_assists/src/handlers/fix_visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -181,7 +181,7 @@ fn target_data_for_def(\n             offset_target_and_file_id(db, c)?\n         }\n         hir::ModuleDef::Static(s) => {\n-            target_name = s.name(db);\n+            target_name = Some(s.name(db));\n             offset_target_and_file_id(db, s)?\n         }\n         hir::ModuleDef::Trait(t) => {"}, {"sha": "db3379abf4ccaa94bcfa0754764f9a75b7ecef26", "filename": "crates/ide_assists/src/handlers/generate_function.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -1,6 +1,6 @@\n use rustc_hash::{FxHashMap, FxHashSet};\n \n-use hir::{HasSource, HirDisplay, Module, ModuleDef, Semantics, TypeInfo};\n+use hir::{HasSource, HirDisplay, Module, Semantics, TypeInfo};\n use ide_db::helpers::FamousDefs;\n use ide_db::{\n     base_db::FileId,\n@@ -482,9 +482,8 @@ fn fn_arg_name(sema: &Semantics<RootDatabase>, arg_expr: &ast::Expr) -> String {\n         ast::Expr::CastExpr(cast_expr) => Some(fn_arg_name(sema, &cast_expr.expr()?)),\n         expr => {\n             let name_ref = expr.syntax().descendants().filter_map(ast::NameRef::cast).last()?;\n-            if let Some(NameRefClass::Definition(Definition::ModuleDef(\n-                ModuleDef::Const(_) | ModuleDef::Static(_),\n-            ))) = NameRefClass::classify(sema, &name_ref)\n+            if let Some(NameRefClass::Definition(Definition::Const(_) | Definition::Static(_))) =\n+                NameRefClass::classify(sema, &name_ref)\n             {\n                 return Some(name_ref.to_string().to_lowercase());\n             };"}, {"sha": "cd4f0464116507fe50a79f33d0b99a328a66bde1", "filename": "crates/ide_assists/src/handlers/inline_call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -69,7 +69,7 @@ pub(crate) fn inline_into_callers(acc: &mut Assists, ctx: &AssistContext) -> Opt\n \n     let params = get_fn_params(ctx.sema.db, function, &param_list)?;\n \n-    let usages = Definition::ModuleDef(hir::ModuleDef::Function(function)).usages(&ctx.sema);\n+    let usages = Definition::Function(function).usages(&ctx.sema);\n     if !usages.at_least_one() {\n         return None;\n     }"}, {"sha": "80e2ca918b94b388da1a3b1d15b6a45c2dd68b9b", "filename": "crates/ide_assists/src/handlers/remove_unused_param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -62,7 +62,7 @@ pub(crate) fn remove_unused_param(acc: &mut Assists, ctx: &AssistContext) -> Opt\n     }\n     let fn_def = {\n         let func = ctx.sema.to_def(&func)?;\n-        Definition::ModuleDef(func.into())\n+        Definition::Function(func)\n     };\n \n     let param_def = {"}, {"sha": "5fdbb600814c687ea618a3d823e629f8b50eb11c", "filename": "crates/ide_db/src/defs.rs", "status": "modified", "additions": 131, "deletions": 56, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -7,9 +7,11 @@\n \n use arrayvec::ArrayVec;\n use hir::{\n-    Field, GenericParam, HasVisibility, Impl, Label, Local, MacroDef, Module, ModuleDef, Name,\n-    PathResolution, Semantics, Visibility,\n+    Adt, AsAssocItem, AssocItem, BuiltinType, Const, Field, Function, GenericParam, HasVisibility,\n+    Impl, ItemInNs, Label, Local, MacroDef, Module, ModuleDef, Name, PathResolution, Semantics,\n+    Static, Trait, TypeAlias, Variant, Visibility,\n };\n+use stdx::impl_from;\n use syntax::{\n     ast::{self, AstNode},\n     match_ast, AstToken, SyntaxKind, SyntaxNode, SyntaxToken,\n@@ -22,7 +24,15 @@ use crate::{helpers::try_resolve_derive_input, RootDatabase};\n pub enum Definition {\n     Macro(MacroDef),\n     Field(Field),\n-    ModuleDef(ModuleDef),\n+    Module(Module),\n+    Function(Function),\n+    Adt(Adt),\n+    Variant(Variant),\n+    Const(Const),\n+    Static(Static),\n+    Trait(Trait),\n+    TypeAlias(TypeAlias),\n+    BuiltinType(BuiltinType),\n     SelfType(Impl),\n     Local(Local),\n     GenericParam(GenericParam),\n@@ -98,49 +108,65 @@ impl Definition {\n         res\n     }\n \n+    pub fn canonical_module_path(&self, db: &RootDatabase) -> Option<impl Iterator<Item = Module>> {\n+        self.module(db).map(|it| it.path_to_root(db).into_iter().rev())\n+    }\n+\n     pub fn module(&self, db: &RootDatabase) -> Option<Module> {\n-        match self {\n-            Definition::Macro(it) => it.module(db),\n-            Definition::Field(it) => Some(it.parent_def(db).module(db)),\n-            Definition::ModuleDef(it) => it.module(db),\n-            Definition::SelfType(it) => Some(it.module(db)),\n-            Definition::Local(it) => Some(it.module(db)),\n-            Definition::GenericParam(it) => Some(it.module(db)),\n-            Definition::Label(it) => Some(it.module(db)),\n-        }\n+        let module = match self {\n+            Definition::Macro(it) => it.module(db)?,\n+            Definition::Module(it) => it.parent(db)?,\n+            Definition::Field(it) => it.parent_def(db).module(db),\n+            Definition::Function(it) => it.module(db),\n+            Definition::Adt(it) => it.module(db),\n+            Definition::Const(it) => it.module(db),\n+            Definition::Static(it) => it.module(db),\n+            Definition::Trait(it) => it.module(db),\n+            Definition::TypeAlias(it) => it.module(db),\n+            Definition::Variant(it) => it.module(db),\n+            Definition::SelfType(it) => it.module(db),\n+            Definition::Local(it) => it.module(db),\n+            Definition::GenericParam(it) => it.module(db),\n+            Definition::Label(it) => it.module(db),\n+            Definition::BuiltinType(_) => return None,\n+        };\n+        Some(module)\n     }\n \n     pub fn visibility(&self, db: &RootDatabase) -> Option<Visibility> {\n-        match self {\n-            Definition::Field(sf) => Some(sf.visibility(db)),\n-            Definition::ModuleDef(def) => Some(def.visibility(db)),\n-            Definition::Macro(_)\n-            | Definition::SelfType(_)\n+        let vis = match self {\n+            Definition::Field(sf) => sf.visibility(db),\n+            Definition::Module(it) => it.visibility(db),\n+            Definition::Function(it) => it.visibility(db),\n+            Definition::Adt(it) => it.visibility(db),\n+            Definition::Const(it) => it.visibility(db),\n+            Definition::Static(it) => it.visibility(db),\n+            Definition::Trait(it) => it.visibility(db),\n+            Definition::TypeAlias(it) => it.visibility(db),\n+            Definition::Variant(it) => it.visibility(db),\n+            Definition::BuiltinType(_) => Visibility::Public,\n+            Definition::Macro(_) => return None,\n+            Definition::SelfType(_)\n             | Definition::Local(_)\n             | Definition::GenericParam(_)\n-            | Definition::Label(_) => None,\n-        }\n+            | Definition::Label(_) => return None,\n+        };\n+        Some(vis)\n     }\n \n     pub fn name(&self, db: &RootDatabase) -> Option<Name> {\n         let name = match self {\n             Definition::Macro(it) => it.name(db)?,\n             Definition::Field(it) => it.name(db),\n-            Definition::ModuleDef(def) => match def {\n-                hir::ModuleDef::Module(it) => it.name(db)?,\n-                hir::ModuleDef::Function(it) => it.name(db),\n-                hir::ModuleDef::Adt(def) => match def {\n-                    hir::Adt::Struct(it) => it.name(db),\n-                    hir::Adt::Union(it) => it.name(db),\n-                    hir::Adt::Enum(it) => it.name(db),\n-                },\n-                hir::ModuleDef::Variant(it) => it.name(db),\n-                hir::ModuleDef::Const(it) => it.name(db)?,\n-                hir::ModuleDef::Static(it) => it.name(db)?,\n-                hir::ModuleDef::Trait(it) => it.name(db),\n-                hir::ModuleDef::TypeAlias(it) => it.name(db),\n-                hir::ModuleDef::BuiltinType(it) => it.name(),\n-            },\n+            Definition::Module(it) => it.name(db)?,\n+            Definition::Function(it) => it.name(db),\n+            Definition::Adt(it) => it.name(db),\n+            Definition::Variant(it) => it.name(db),\n+            Definition::Const(it) => it.name(db)?,\n+            Definition::Static(it) => it.name(db),\n+            Definition::Trait(it) => it.name(db),\n+            Definition::TypeAlias(it) => it.name(db),\n+            Definition::BuiltinType(it) => it.name(),\n             Definition::SelfType(_) => return None,\n             Definition::Local(it) => it.name(db)?,\n             Definition::GenericParam(it) => it.name(db),\n@@ -193,7 +219,7 @@ impl NameClass {\n \n         if let Some(bind_pat) = ast::IdentPat::cast(parent.clone()) {\n             if let Some(def) = sema.resolve_bind_pat_to_const(&bind_pat) {\n-                return Some(NameClass::ConstReference(Definition::ModuleDef(def)));\n+                return Some(NameClass::ConstReference(Definition::from(def)));\n             }\n         }\n \n@@ -231,7 +257,7 @@ impl NameClass {\n                         let extern_crate = it.syntax().parent().and_then(ast::ExternCrate::cast)?;\n                         let krate = sema.resolve_extern_crate(&extern_crate)?;\n                         let root_module = krate.root_module(sema.db);\n-                        Some(NameClass::Definition(Definition::ModuleDef(root_module.into())))\n+                        Some(NameClass::Definition(Definition::Module(root_module)))\n                     }\n                 },\n                 ast::IdentPat(it) => {\n@@ -257,43 +283,43 @@ impl NameClass {\n                 },\n                 ast::Module(it) => {\n                     let def = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                    Some(NameClass::Definition(Definition::Module(def)))\n                 },\n                 ast::Struct(it) => {\n                     let def: hir::Struct = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                    Some(NameClass::Definition(Definition::Adt(def.into())))\n                 },\n                 ast::Union(it) => {\n                     let def: hir::Union = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                    Some(NameClass::Definition(Definition::Adt(def.into())))\n                 },\n                 ast::Enum(it) => {\n                     let def: hir::Enum = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                    Some(NameClass::Definition(Definition::Adt(def.into())))\n                 },\n                 ast::Trait(it) => {\n                     let def: hir::Trait = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                    Some(NameClass::Definition(Definition::Trait(def)))\n                 },\n                 ast::Static(it) => {\n                     let def: hir::Static = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                    Some(NameClass::Definition(Definition::Static(def)))\n                 },\n                 ast::Variant(it) => {\n                     let def: hir::Variant = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                    Some(NameClass::Definition(Definition::Variant(def)))\n                 },\n                 ast::Fn(it) => {\n                     let def: hir::Function = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                    Some(NameClass::Definition(Definition::Function(def)))\n                 },\n                 ast::Const(it) => {\n                     let def: hir::Const = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                    Some(NameClass::Definition(Definition::Const(def)))\n                 },\n                 ast::TypeAlias(it) => {\n                     let def: hir::TypeAlias = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                    Some(NameClass::Definition(Definition::TypeAlias(def)))\n                 },\n                 ast::Macro(it) => {\n                     let def = sema.to_def(&it)?;\n@@ -360,7 +386,7 @@ impl NameRefClass {\n \n         if let Some(method_call) = ast::MethodCallExpr::cast(parent.clone()) {\n             if let Some(func) = sema.resolve_method_call(&method_call) {\n-                return Some(NameRefClass::Definition(Definition::ModuleDef(func.into())));\n+                return Some(NameRefClass::Definition(Definition::Function(func)));\n             }\n         }\n \n@@ -406,9 +432,7 @@ impl NameRefClass {\n                         })\n                         .find(|alias| alias.name(sema.db).to_smol_str() == name_ref.text().as_str())\n                     {\n-                        return Some(NameRefClass::Definition(Definition::ModuleDef(\n-                            ModuleDef::TypeAlias(ty),\n-                        )));\n+                        return Some(NameRefClass::Definition(Definition::TypeAlias(ty)));\n                     }\n                 }\n \n@@ -440,9 +464,9 @@ impl NameRefClass {\n                     .map(NameRefClass::Definition),\n                 // in case of the path being a qualifier, don't resolve to anything but a module\n                 Some(true) => match sema.resolve_path(&path)? {\n-                    PathResolution::Def(module @ ModuleDef::Module(_)) => {\n+                    PathResolution::Def(ModuleDef::Module(module)) => {\n                         cov_mark::hit!(name_ref_classify_attr_path_qualifier);\n-                        Some(NameRefClass::Definition(Definition::ModuleDef(module)))\n+                        Some(NameRefClass::Definition(Definition::Module(module)))\n                     }\n                     _ => None,\n                 },\n@@ -455,7 +479,7 @@ impl NameRefClass {\n         let extern_crate = ast::ExternCrate::cast(parent)?;\n         let krate = sema.resolve_extern_crate(&extern_crate)?;\n         let root_module = krate.root_module(sema.db);\n-        Some(NameRefClass::Definition(Definition::ModuleDef(root_module.into())))\n+        Some(NameRefClass::Definition(Definition::Module(root_module)))\n     }\n \n     pub fn classify_lifetime(\n@@ -492,17 +516,34 @@ impl NameRefClass {\n     }\n }\n \n+impl AsAssocItem for Definition {\n+    fn as_assoc_item(self, db: &dyn hir::db::HirDatabase) -> Option<AssocItem> {\n+        match self {\n+            Definition::Function(it) => it.as_assoc_item(db),\n+            Definition::Const(it) => it.as_assoc_item(db),\n+            Definition::TypeAlias(it) => it.as_assoc_item(db),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+impl_from!(\n+    Field, Module, Function, Adt, Variant, Const, Static, Trait, TypeAlias, BuiltinType, Local,\n+    GenericParam, Label\n+    for Definition\n+);\n+\n impl From<PathResolution> for Definition {\n     fn from(path_resolution: PathResolution) -> Self {\n         match path_resolution {\n-            PathResolution::Def(def) => Definition::ModuleDef(def),\n+            PathResolution::Def(def) => def.into(),\n             PathResolution::AssocItem(item) => {\n-                let def = match item {\n+                let def: ModuleDef = match item {\n                     hir::AssocItem::Function(it) => it.into(),\n                     hir::AssocItem::Const(it) => it.into(),\n                     hir::AssocItem::TypeAlias(it) => it.into(),\n                 };\n-                Definition::ModuleDef(def)\n+                def.into()\n             }\n             PathResolution::Local(local) => Definition::Local(local),\n             PathResolution::TypeParam(par) => Definition::GenericParam(par.into()),\n@@ -512,3 +553,37 @@ impl From<PathResolution> for Definition {\n         }\n     }\n }\n+\n+impl From<ModuleDef> for Definition {\n+    fn from(def: ModuleDef) -> Self {\n+        match def {\n+            ModuleDef::Module(it) => Definition::Module(it),\n+            ModuleDef::Function(it) => Definition::Function(it),\n+            ModuleDef::Adt(it) => Definition::Adt(it),\n+            ModuleDef::Variant(it) => Definition::Variant(it),\n+            ModuleDef::Const(it) => Definition::Const(it),\n+            ModuleDef::Static(it) => Definition::Static(it),\n+            ModuleDef::Trait(it) => Definition::Trait(it),\n+            ModuleDef::TypeAlias(it) => Definition::TypeAlias(it),\n+            ModuleDef::BuiltinType(it) => Definition::BuiltinType(it),\n+        }\n+    }\n+}\n+\n+impl From<Definition> for Option<ItemInNs> {\n+    fn from(def: Definition) -> Self {\n+        let item = match def {\n+            Definition::Module(it) => ModuleDef::Module(it),\n+            Definition::Function(it) => ModuleDef::Function(it),\n+            Definition::Adt(it) => ModuleDef::Adt(it),\n+            Definition::Variant(it) => ModuleDef::Variant(it),\n+            Definition::Const(it) => ModuleDef::Const(it),\n+            Definition::Static(it) => ModuleDef::Static(it),\n+            Definition::Trait(it) => ModuleDef::Trait(it),\n+            Definition::TypeAlias(it) => ModuleDef::TypeAlias(it),\n+            Definition::BuiltinType(it) => ModuleDef::BuiltinType(it),\n+            _ => return None,\n+        };\n+        Some(ItemInNs::from(item))\n+    }\n+}"}, {"sha": "a3ea3edc977723ad33a70ca56dcc0d0573c6f4ee", "filename": "crates/ide_db/src/items_locator.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_db%2Fsrc%2Fitems_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_db%2Fsrc%2Fitems_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fitems_locator.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -117,9 +117,8 @@ fn find_items<'a>(\n         .into_iter()\n         .filter_map(move |local_candidate| get_name_definition(sema, &local_candidate))\n         .filter_map(|name_definition_to_import| match name_definition_to_import {\n-            Definition::ModuleDef(module_def) => Some(ItemInNs::from(module_def)),\n             Definition::Macro(macro_def) => Some(ItemInNs::from(macro_def)),\n-            _ => None,\n+            def => <Option<_>>::from(def),\n         });\n \n     external_importables.chain(local_results).filter(move |&item| match assoc_item_search {"}, {"sha": "678153c6e1da27bf5f1a9d206fa58511d510a26b", "filename": "crates/ide_db/src/rename.rs", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_db%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_db%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Frename.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -67,10 +67,8 @@ pub use _bail as bail;\n impl Definition {\n     pub fn rename(&self, sema: &Semantics<RootDatabase>, new_name: &str) -> Result<SourceChange> {\n         match *self {\n-            Definition::ModuleDef(hir::ModuleDef::Module(module)) => {\n-                rename_mod(sema, module, new_name)\n-            }\n-            Definition::ModuleDef(hir::ModuleDef::BuiltinType(_)) => {\n+            Definition::Module(module) => rename_mod(sema, module, new_name),\n+            Definition::BuiltinType(_) => {\n                 bail!(\"Cannot rename builtin type\")\n             }\n             Definition::SelfType(_) => bail!(\"Cannot rename `Self`\"),\n@@ -101,25 +99,23 @@ impl Definition {\n                     FieldSource::Pos(_) => None,\n                 }\n             }\n-            Definition::ModuleDef(module_def) => match module_def {\n-                hir::ModuleDef::Module(module) => {\n-                    let src = module.declaration_source(sema.db)?;\n-                    let name = src.value.name()?;\n-                    src.with_value(name.syntax()).original_file_range_opt(sema.db)\n-                }\n-                hir::ModuleDef::Function(it) => name_range(it, sema),\n-                hir::ModuleDef::Adt(adt) => match adt {\n-                    hir::Adt::Struct(it) => name_range(it, sema),\n-                    hir::Adt::Union(it) => name_range(it, sema),\n-                    hir::Adt::Enum(it) => name_range(it, sema),\n-                },\n-                hir::ModuleDef::Variant(it) => name_range(it, sema),\n-                hir::ModuleDef::Const(it) => name_range(it, sema),\n-                hir::ModuleDef::Static(it) => name_range(it, sema),\n-                hir::ModuleDef::Trait(it) => name_range(it, sema),\n-                hir::ModuleDef::TypeAlias(it) => name_range(it, sema),\n-                hir::ModuleDef::BuiltinType(_) => return None,\n+            Definition::Module(module) => {\n+                let src = module.declaration_source(sema.db)?;\n+                let name = src.value.name()?;\n+                src.with_value(name.syntax()).original_file_range_opt(sema.db)\n+            }\n+            Definition::Function(it) => name_range(it, sema),\n+            Definition::Adt(adt) => match adt {\n+                hir::Adt::Struct(it) => name_range(it, sema),\n+                hir::Adt::Union(it) => name_range(it, sema),\n+                hir::Adt::Enum(it) => name_range(it, sema),\n             },\n+            Definition::Variant(it) => name_range(it, sema),\n+            Definition::Const(it) => name_range(it, sema),\n+            Definition::Static(it) => name_range(it, sema),\n+            Definition::Trait(it) => name_range(it, sema),\n+            Definition::TypeAlias(it) => name_range(it, sema),\n+            Definition::BuiltinType(_) => return None,\n             Definition::SelfType(_) => return None,\n             Definition::Local(local) => {\n                 let src = local.source(sema.db);\n@@ -200,7 +196,7 @@ fn rename_mod(\n             _ => never!(\"Module source node is missing a name\"),\n         }\n     }\n-    let def = Definition::ModuleDef(hir::ModuleDef::Module(module));\n+    let def = Definition::Module(module);\n     let usages = def.usages(sema).all();\n     let ref_edits = usages.iter().map(|(&file_id, references)| {\n         (file_id, source_edit_from_references(references, def, new_name))\n@@ -239,35 +235,40 @@ fn rename_reference(\n         }\n     }\n \n-    def = match def {\n+    let assoc_item = match def {\n         // HACK: resolve trait impl items to the item def of the trait definition\n         // so that we properly resolve all trait item references\n-        Definition::ModuleDef(mod_def) => mod_def\n-            .as_assoc_item(sema.db)\n-            .and_then(|it| it.containing_trait_impl(sema.db))\n-            .and_then(|it| {\n-                it.items(sema.db).into_iter().find_map(|it| match (it, mod_def) {\n-                    (hir::AssocItem::Function(trait_func), hir::ModuleDef::Function(func))\n+        Definition::Function(it) => it.as_assoc_item(sema.db),\n+        Definition::TypeAlias(it) => it.as_assoc_item(sema.db),\n+        Definition::Const(it) => it.as_assoc_item(sema.db),\n+        _ => None,\n+    };\n+    def = match assoc_item {\n+        Some(assoc) => assoc\n+            .containing_trait_impl(sema.db)\n+            .and_then(|trait_| {\n+                trait_.items(sema.db).into_iter().find_map(|it| match (it, assoc) {\n+                    (hir::AssocItem::Function(trait_func), hir::AssocItem::Function(func))\n                         if trait_func.name(sema.db) == func.name(sema.db) =>\n                     {\n-                        Some(Definition::ModuleDef(hir::ModuleDef::Function(trait_func)))\n+                        Some(Definition::Function(trait_func))\n                     }\n-                    (hir::AssocItem::Const(trait_konst), hir::ModuleDef::Const(konst))\n+                    (hir::AssocItem::Const(trait_konst), hir::AssocItem::Const(konst))\n                         if trait_konst.name(sema.db) == konst.name(sema.db) =>\n                     {\n-                        Some(Definition::ModuleDef(hir::ModuleDef::Const(trait_konst)))\n+                        Some(Definition::Const(trait_konst))\n                     }\n                     (\n                         hir::AssocItem::TypeAlias(trait_type_alias),\n-                        hir::ModuleDef::TypeAlias(type_alias),\n+                        hir::AssocItem::TypeAlias(type_alias),\n                     ) if trait_type_alias.name(sema.db) == type_alias.name(sema.db) => {\n-                        Some(Definition::ModuleDef(hir::ModuleDef::TypeAlias(trait_type_alias)))\n+                        Some(Definition::TypeAlias(trait_type_alias))\n                     }\n                     _ => None,\n                 })\n             })\n             .unwrap_or(def),\n-        _ => def,\n+        None => def,\n     };\n     let usages = def.usages(sema).all();\n "}, {"sha": "c23a9ee25721dbbca5889640af6c6a15433a66f5", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 29, "deletions": 36, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3063fb2d1804b3dc42184027ef08073de03fd9/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=3b3063fb2d1804b3dc42184027ef08073de03fd9", "patch": "@@ -8,8 +8,7 @@ use std::{convert::TryInto, mem};\n \n use base_db::{FileId, FileRange, SourceDatabase, SourceDatabaseExt};\n use hir::{\n-    AsAssocItem, DefWithBody, HasAttrs, HasSource, InFile, ModuleDef, ModuleSource, Semantics,\n-    Visibility,\n+    AsAssocItem, DefWithBody, HasAttrs, HasSource, InFile, ModuleSource, Semantics, Visibility,\n };\n use once_cell::unsync::Lazy;\n use rustc_hash::FxHashMap;\n@@ -217,13 +216,13 @@ impl Definition {\n     fn search_scope(&self, db: &RootDatabase) -> SearchScope {\n         let _p = profile::span(\"search_scope\");\n \n-        if let Definition::ModuleDef(hir::ModuleDef::BuiltinType(_)) = self {\n+        if let Definition::BuiltinType(_) = self {\n             return SearchScope::crate_graph(db);\n         }\n \n         // def is crate root\n         // FIXME: We don't do searches for crates currently, as a crate does not actually have a single name\n-        if let &Definition::ModuleDef(hir::ModuleDef::Module(module)) = self {\n+        if let &Definition::Module(module) = self {\n             if module.crate_root(db) == module {\n                 return SearchScope::reverse_dependencies(db, module.krate());\n             }\n@@ -431,7 +430,7 @@ impl<'a> FindUsages<'a> {\n \n         // search for module `self` references in our module's definition source\n         match self.def {\n-            Definition::ModuleDef(hir::ModuleDef::Module(module)) if self.search_self_mod => {\n+            Definition::Module(module) if self.search_self_mod => {\n                 let src = module.definition_source(sema.db);\n                 let file_id = src.file_id.original_file(sema.db);\n                 let (file_id, search_range) = match src.value {\n@@ -491,7 +490,7 @@ impl<'a> FindUsages<'a> {\n         sink: &mut dyn FnMut(FileId, FileReference) -> bool,\n     ) -> bool {\n         match NameRefClass::classify(self.sema, name_ref) {\n-            Some(NameRefClass::Definition(def @ Definition::ModuleDef(_))) if def == self.def => {\n+            Some(NameRefClass::Definition(def @ Definition::Module(_))) if def == self.def => {\n                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n                 let reference = FileReference {\n                     range,\n@@ -604,30 +603,27 @@ impl<'a> FindUsages<'a> {\n                 sink(file_id, reference)\n             }\n             // Resolve trait impl function definitions to the trait definition's version if self.def is the trait definition's\n-            Some(NameClass::Definition(Definition::ModuleDef(mod_def))) => {\n+            Some(NameClass::Definition(def)) if def != self.def => {\n                 /* poor man's try block */\n                 (|| {\n-                    let this = match self.def {\n-                        Definition::ModuleDef(this) if this != mod_def => this,\n-                        _ => return None,\n-                    };\n-                    let this_trait = this\n+                    let this_trait = self\n+                        .def\n                         .as_assoc_item(self.sema.db)?\n                         .containing_trait_or_trait_impl(self.sema.db)?;\n-                    let trait_ = mod_def\n+                    let trait_ = def\n                         .as_assoc_item(self.sema.db)?\n                         .containing_trait_or_trait_impl(self.sema.db)?;\n-                    (trait_ == this_trait\n-                        && self.def.name(self.sema.db) == mod_def.name(self.sema.db))\n-                    .then(|| {\n-                        let FileRange { file_id, range } = self.sema.original_range(name.syntax());\n-                        let reference = FileReference {\n-                            range,\n-                            name: ast::NameLike::Name(name.clone()),\n-                            category: None,\n-                        };\n-                        sink(file_id, reference)\n-                    })\n+                    (trait_ == this_trait && self.def.name(self.sema.db) == def.name(self.sema.db))\n+                        .then(|| {\n+                            let FileRange { file_id, range } =\n+                                self.sema.original_range(name.syntax());\n+                            let reference = FileReference {\n+                                range,\n+                                name: ast::NameLike::Name(name.clone()),\n+                                category: None,\n+                            };\n+                            sink(file_id, reference)\n+                        })\n                 })()\n                 .unwrap_or(false)\n             }\n@@ -638,18 +634,15 @@ impl<'a> FindUsages<'a> {\n \n fn def_to_ty(sema: &Semantics<RootDatabase>, def: &Definition) -> Option<hir::Type> {\n     match def {\n-        Definition::ModuleDef(def) => match def {\n-            ModuleDef::Adt(adt) => Some(adt.ty(sema.db)),\n-            ModuleDef::TypeAlias(it) => Some(it.ty(sema.db)),\n-            ModuleDef::BuiltinType(it) => {\n-                let graph = sema.db.crate_graph();\n-                let krate = graph.iter().next()?;\n-                let root_file = graph[krate].root_file_id;\n-                let module = sema.to_module_def(root_file)?;\n-                Some(it.ty(sema.db, module))\n-            }\n-            _ => None,\n-        },\n+        Definition::Adt(adt) => Some(adt.ty(sema.db)),\n+        Definition::TypeAlias(it) => Some(it.ty(sema.db)),\n+        Definition::BuiltinType(it) => {\n+            let graph = sema.db.crate_graph();\n+            let krate = graph.iter().next()?;\n+            let root_file = graph[krate].root_file_id;\n+            let module = sema.to_module_def(root_file)?;\n+            Some(it.ty(sema.db, module))\n+        }\n         Definition::SelfType(it) => Some(it.self_ty(sema.db)),\n         _ => None,\n     }"}]}