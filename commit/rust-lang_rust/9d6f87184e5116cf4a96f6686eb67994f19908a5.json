{"sha": "9d6f87184e5116cf4a96f6686eb67994f19908a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkNmY4NzE4NGU1MTE2Y2Y0YTk2ZjY2ODZlYjY3OTk0ZjE5OTA4YTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-30T14:47:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-30T14:47:26Z"}, "message": "Auto merge of #67474 - mark-i-m:simplify-borrow_check-4, r=matthewjasper\n\nGet rid of ErrorReportingCtx [5/N]\n\nWe can now use `MirBorrowckCtxt` instead :)\n\n```\n6 files changed, 122 insertions(+), 243 deletions(-)\n```\n\nThis is a followup to (and thus blocked on) #67241.\n\nr? @matthewjasper\n\ncc @eddyb\n\nI while try to do one more to get rid of the weird usage of `RegionInferenceCtx` in `borrow_check::diagnostics::{region_errors, region_naming}`. I think those uses can possibly also be refactored to use `MirBorrowckCtxt`...", "tree": {"sha": "ba1a33ab4e00e6856d9738cfaeaae0e8aded4db1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba1a33ab4e00e6856d9738cfaeaae0e8aded4db1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d6f87184e5116cf4a96f6686eb67994f19908a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d6f87184e5116cf4a96f6686eb67994f19908a5", "html_url": "https://github.com/rust-lang/rust/commit/9d6f87184e5116cf4a96f6686eb67994f19908a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d6f87184e5116cf4a96f6686eb67994f19908a5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fb43801368ae8b5931583f813071120bed55c35", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fb43801368ae8b5931583f813071120bed55c35", "html_url": "https://github.com/rust-lang/rust/commit/0fb43801368ae8b5931583f813071120bed55c35"}, {"sha": "96ce6076c35b5c9c06f13cb571b210e08160641c", "url": "https://api.github.com/repos/rust-lang/rust/commits/96ce6076c35b5c9c06f13cb571b210e08160641c", "html_url": "https://github.com/rust-lang/rust/commit/96ce6076c35b5c9c06f13cb571b210e08160641c"}], "stats": {"total": 358, "additions": 119, "deletions": 239}, "files": [{"sha": "3b7aac5c7f9f2a2cf7c9a6a071b3d4cee13d41ca", "filename": "src/librustc_mir/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9d6f87184e5116cf4a96f6686eb67994f19908a5/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d6f87184e5116cf4a96f6686eb67994f19908a5/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=9d6f87184e5116cf4a96f6686eb67994f19908a5", "patch": "@@ -289,16 +289,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             None => {\n                 if let Some(region) = regioncx.to_error_region_vid(borrow_region_vid) {\n-                    let (category, from_closure, span, region_name) =\n-                        self.nonlexical_regioncx.free_region_constraint_info(\n-                            &self.body,\n-                            &self.local_names,\n-                            &self.upvars,\n-                            self.mir_def_id,\n-                            self.infcx,\n-                            borrow_region_vid,\n-                            region,\n-                        );\n+                    let (category, from_closure, span, region_name) = self\n+                        .nonlexical_regioncx\n+                        .free_region_constraint_info(self, borrow_region_vid, region);\n                     if let Some(region_name) = region_name {\n                         let opt_place_desc = self.describe_place(borrow.borrowed_place.as_ref());\n                         BorrowExplanation::MustBeValidFor {"}, {"sha": "5272054346e170c5cc7630e1dc514c3b922deb43", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d6f87184e5116cf4a96f6686eb67994f19908a5/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d6f87184e5116cf4a96f6686eb67994f19908a5/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=9d6f87184e5116cf4a96f6686eb67994f19908a5", "patch": "@@ -32,7 +32,7 @@ mod region_errors;\n \n crate use mutability_errors::AccessKind;\n crate use outlives_suggestion::OutlivesSuggestionBuilder;\n-crate use region_errors::{ErrorConstraintInfo, ErrorReportingCtx, RegionErrorKind, RegionErrors};\n+crate use region_errors::{ErrorConstraintInfo, RegionErrorKind, RegionErrors};\n crate use region_name::{RegionErrorNamingCtx, RegionName, RegionNameSource};\n \n pub(super) struct IncludingDowncast(pub(super) bool);"}, {"sha": "1425c22e461cfe82fd09b5d731e4e37f56234c09", "filename": "src/librustc_mir/borrow_check/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 25, "deletions": 60, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/9d6f87184e5116cf4a96f6686eb67994f19908a5/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d6f87184e5116cf4a96f6686eb67994f19908a5/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs?ref=9d6f87184e5116cf4a96f6686eb67994f19908a5", "patch": "@@ -4,20 +4,15 @@\n use std::collections::BTreeMap;\n \n use log::debug;\n-use rustc::mir::{Body, Local};\n-use rustc::{hir::def_id::DefId, infer::InferCtxt, ty::RegionVid};\n+use rustc::ty::RegionVid;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{Diagnostic, DiagnosticBuilder};\n-use rustc_index::vec::IndexVec;\n-use syntax_pos::symbol::Symbol;\n+use rustc_errors::DiagnosticBuilder;\n \n use smallvec::SmallVec;\n \n-use crate::borrow_check::region_infer::RegionInferenceContext;\n+use crate::borrow_check::MirBorrowckCtxt;\n \n-use super::{\n-    ErrorConstraintInfo, ErrorReportingCtx, RegionErrorNamingCtx, RegionName, RegionNameSource,\n-};\n+use super::{ErrorConstraintInfo, RegionErrorNamingCtx, RegionName, RegionNameSource};\n \n /// The different things we could suggest.\n enum SuggestedConstraint {\n@@ -35,12 +30,8 @@ enum SuggestedConstraint {\n /// corresponding to a function definition.\n ///\n /// Adds a help note suggesting adding a where clause with the needed constraints.\n-pub struct OutlivesSuggestionBuilder<'a> {\n-    /// The MIR DefId of the fn with the lifetime error.\n-    mir_def_id: DefId,\n-\n-    local_names: &'a IndexVec<Local, Option<Symbol>>,\n-\n+#[derive(Default)]\n+pub struct OutlivesSuggestionBuilder {\n     /// The list of outlives constraints that need to be added. Specifically, we map each free\n     /// region to all other regions that it must outlive. I will use the shorthand `fr:\n     /// outlived_frs`. Not all of these regions will already have names necessarily. Some could be\n@@ -49,16 +40,7 @@ pub struct OutlivesSuggestionBuilder<'a> {\n     constraints_to_add: BTreeMap<RegionVid, Vec<RegionVid>>,\n }\n \n-impl OutlivesSuggestionBuilder<'a> {\n-    /// Create a new builder for the given MIR node representing a fn definition.\n-    crate fn new(mir_def_id: DefId, local_names: &'a IndexVec<Local, Option<Symbol>>) -> Self {\n-        OutlivesSuggestionBuilder {\n-            mir_def_id,\n-            local_names,\n-            constraints_to_add: BTreeMap::default(),\n-        }\n-    }\n-\n+impl OutlivesSuggestionBuilder {\n     /// Returns `true` iff the `RegionNameSource` is a valid source for an outlives\n     /// suggestion.\n     //\n@@ -94,22 +76,19 @@ impl OutlivesSuggestionBuilder<'a> {\n     /// Returns a name for the region if it is suggestable. See `region_name_is_suggestable`.\n     fn region_vid_to_name(\n         &self,\n-        errctx: &ErrorReportingCtx<'_, '_, '_>,\n+        mbcx: &MirBorrowckCtxt<'_, '_>,\n         renctx: &mut RegionErrorNamingCtx,\n         region: RegionVid,\n     ) -> Option<RegionName> {\n-        errctx\n-            .region_infcx\n-            .give_region_a_name(errctx, renctx, region)\n+        mbcx.nonlexical_regioncx\n+            .give_region_a_name(mbcx, renctx, region)\n             .filter(Self::region_name_is_suggestable)\n     }\n \n     /// Compiles a list of all suggestions to be printed in the final big suggestion.\n-    fn compile_all_suggestions<'tcx>(\n+    fn compile_all_suggestions(\n         &self,\n-        body: &Body<'tcx>,\n-        region_infcx: &RegionInferenceContext<'tcx>,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        mbcx: &MirBorrowckCtxt<'_, '_>,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> SmallVec<[SuggestedConstraint; 2]> {\n         let mut suggested = SmallVec::new();\n@@ -118,20 +97,8 @@ impl OutlivesSuggestionBuilder<'a> {\n         // out silly duplicate messages.\n         let mut unified_already = FxHashSet::default();\n \n-        let errctx = ErrorReportingCtx {\n-            region_infcx,\n-            infcx,\n-            body,\n-            mir_def_id: self.mir_def_id,\n-            local_names: self.local_names,\n-\n-            // We should not be suggesting naming upvars, so we pass in a dummy set of upvars that\n-            // should never be used.\n-            upvars: &[],\n-        };\n-\n         for (fr, outlived) in &self.constraints_to_add {\n-            let fr_name = if let Some(fr_name) = self.region_vid_to_name(&errctx, renctx, *fr) {\n+            let fr_name = if let Some(fr_name) = self.region_vid_to_name(mbcx, renctx, *fr) {\n                 fr_name\n             } else {\n                 continue;\n@@ -141,7 +108,7 @@ impl OutlivesSuggestionBuilder<'a> {\n                 .iter()\n                 // if there is a `None`, we will just omit that constraint\n                 .filter_map(|fr| {\n-                    self.region_vid_to_name(&errctx, renctx, *fr).map(|rname| (fr, rname))\n+                    self.region_vid_to_name(mbcx, renctx, *fr).map(|rname| (fr, rname))\n                 })\n                 .collect::<Vec<_>>();\n \n@@ -204,14 +171,14 @@ impl OutlivesSuggestionBuilder<'a> {\n     /// suggestable.\n     crate fn intermediate_suggestion(\n         &mut self,\n-        errctx: &ErrorReportingCtx<'_, '_, '_>,\n+        mbcx: &MirBorrowckCtxt<'_, '_>,\n         errci: &ErrorConstraintInfo,\n         renctx: &mut RegionErrorNamingCtx,\n         diag: &mut DiagnosticBuilder<'_>,\n     ) {\n         // Emit an intermediate note.\n-        let fr_name = self.region_vid_to_name(errctx, renctx, errci.fr);\n-        let outlived_fr_name = self.region_vid_to_name(errctx, renctx, errci.outlived_fr);\n+        let fr_name = self.region_vid_to_name(mbcx, renctx, errci.fr);\n+        let outlived_fr_name = self.region_vid_to_name(mbcx, renctx, errci.outlived_fr);\n \n         if let (Some(fr_name), Some(outlived_fr_name)) = (fr_name, outlived_fr_name) {\n             if let RegionNameSource::Static = outlived_fr_name.source {\n@@ -227,12 +194,9 @@ impl OutlivesSuggestionBuilder<'a> {\n \n     /// If there is a suggestion to emit, add a diagnostic to the buffer. This is the final\n     /// suggestion including all collected constraints.\n-    crate fn add_suggestion<'tcx>(\n+    crate fn add_suggestion(\n         &self,\n-        body: &Body<'tcx>,\n-        region_infcx: &RegionInferenceContext<'tcx>,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        errors_buffer: &mut Vec<Diagnostic>,\n+        mbcx: &mut MirBorrowckCtxt<'_, '_>,\n         renctx: &mut RegionErrorNamingCtx,\n     ) {\n         // No constraints to add? Done.\n@@ -251,7 +215,7 @@ impl OutlivesSuggestionBuilder<'a> {\n         }\n \n         // Get all suggestable constraints.\n-        let suggested = self.compile_all_suggestions(body, region_infcx, infcx, renctx);\n+        let suggested = self.compile_all_suggestions(mbcx, renctx);\n \n         // If there are no suggestable constraints...\n         if suggested.is_empty() {\n@@ -262,7 +226,7 @@ impl OutlivesSuggestionBuilder<'a> {\n         // If there is exactly one suggestable constraints, then just suggest it. Otherwise, emit a\n         // list of diagnostics.\n         let mut diag = if suggested.len() == 1 {\n-            infcx.tcx.sess.diagnostic().struct_help(&match suggested.last().unwrap() {\n+            mbcx.infcx.tcx.sess.diagnostic().struct_help(&match suggested.last().unwrap() {\n                 SuggestedConstraint::Outlives(a, bs) => {\n                     let bs: SmallVec<[String; 2]> = bs.iter().map(|r| format!(\"{}\", r)).collect();\n                     format!(\"add bound `{}: {}`\", a, bs.join(\" + \"))\n@@ -275,7 +239,8 @@ impl OutlivesSuggestionBuilder<'a> {\n             })\n         } else {\n             // Create a new diagnostic.\n-            let mut diag = infcx\n+            let mut diag = mbcx\n+                .infcx\n                 .tcx\n                 .sess\n                 .diagnostic()\n@@ -305,10 +270,10 @@ impl OutlivesSuggestionBuilder<'a> {\n         };\n \n         // We want this message to appear after other messages on the mir def.\n-        let mir_span = infcx.tcx.def_span(self.mir_def_id);\n+        let mir_span = mbcx.infcx.tcx.def_span(mbcx.mir_def_id);\n         diag.sort_span = mir_span.shrink_to_hi();\n \n         // Buffer the diagnostic\n-        diag.buffer(errors_buffer);\n+        diag.buffer(&mut mbcx.errors_buffer);\n     }\n }"}, {"sha": "d560f7c517551a2ad5dd3fa990bea7c373feeb52", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 41, "deletions": 72, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/9d6f87184e5116cf4a96f6686eb67994f19908a5/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d6f87184e5116cf4a96f6686eb67994f19908a5/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=9d6f87184e5116cf4a96f6686eb67994f19908a5", "patch": "@@ -5,22 +5,21 @@ use rustc::infer::{\n     error_reporting::nice_region_error::NiceRegionError, region_constraints::GenericKind,\n     InferCtxt, NLLRegionVariableOrigin,\n };\n-use rustc::mir::{Body, ConstraintCategory, Local, Location};\n+use rustc::mir::{Body, ConstraintCategory, Location};\n use rustc::ty::{self, RegionVid, Ty};\n use rustc_errors::DiagnosticBuilder;\n use rustc_index::vec::IndexVec;\n use std::collections::VecDeque;\n use syntax::errors::Applicability;\n use syntax::symbol::kw;\n-use syntax_pos::symbol::Symbol;\n use syntax_pos::Span;\n \n use crate::util::borrowck_errors;\n \n use crate::borrow_check::{\n     constraints::OutlivesConstraint, nll::ConstraintDescription,\n     region_infer::RegionInferenceContext, type_check::Locations, universal_regions::DefiningTy,\n-    Upvar,\n+    MirBorrowckCtxt,\n };\n \n use super::{OutlivesSuggestionBuilder, RegionErrorNamingCtx, RegionName, RegionNameSource};\n@@ -116,27 +115,6 @@ crate enum RegionErrorKind<'tcx> {\n     },\n }\n \n-/// Various pieces of state used when reporting borrow checker errors.\n-pub struct ErrorReportingCtx<'a, 'b, 'tcx> {\n-    /// The region inference context used for borrow chekcing this MIR body.\n-    pub(super) region_infcx: &'b RegionInferenceContext<'tcx>,\n-\n-    /// The inference context used for type checking.\n-    pub(super) infcx: &'b InferCtxt<'a, 'tcx>,\n-\n-    /// The MIR def we are reporting errors on.\n-    pub(super) mir_def_id: DefId,\n-\n-    /// The MIR body we are reporting errors on (for convenience).\n-    pub(super) body: &'b Body<'tcx>,\n-\n-    /// User variable names for MIR locals (where applicable).\n-    pub(super) local_names: &'b IndexVec<Local, Option<Symbol>>,\n-\n-    /// Any upvars for the MIR body we have kept track of during borrow checking.\n-    pub(super) upvars: &'b [Upvar],\n-}\n-\n /// Information about the various region constraints involved in a borrow checker error.\n #[derive(Clone, Debug)]\n pub struct ErrorConstraintInfo {\n@@ -454,28 +432,24 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Here we would be invoked with `fr = 'a` and `outlived_fr = `'b`.\n     pub(in crate::borrow_check) fn report_error<'a>(\n         &'a self,\n-        body: &Body<'tcx>,\n-        local_names: &IndexVec<Local, Option<Symbol>>,\n-        upvars: &[Upvar],\n-        infcx: &'a InferCtxt<'a, 'tcx>,\n-        mir_def_id: DefId,\n+        mbcx: &MirBorrowckCtxt<'a, 'tcx>,\n         fr: RegionVid,\n         fr_origin: NLLRegionVariableOrigin,\n         outlived_fr: RegionVid,\n-        outlives_suggestion: &mut OutlivesSuggestionBuilder<'_>,\n+        outlives_suggestion: &mut OutlivesSuggestionBuilder,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> DiagnosticBuilder<'a> {\n         debug!(\"report_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n-        let (category, _, span) = self.best_blame_constraint(body, fr, fr_origin, |r| {\n+        let (category, _, span) = self.best_blame_constraint(&mbcx.body, fr, fr_origin, |r| {\n             self.provides_universal_region(r, fr, outlived_fr)\n         });\n \n         debug!(\"report_error: category={:?} {:?}\", category, span);\n         // Check if we can use one of the \"nice region errors\".\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n-            let tables = infcx.tcx.typeck_tables_of(mir_def_id);\n-            let nice = NiceRegionError::new_from_span(infcx, span, o, f, Some(tables));\n+            let tables = mbcx.infcx.tcx.typeck_tables_of(mbcx.mir_def_id);\n+            let nice = NiceRegionError::new_from_span(mbcx.infcx, span, o, f, Some(tables));\n             if let Some(diag) = nice.try_report_from_nll() {\n                 return diag;\n             }\n@@ -491,9 +465,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             fr_is_local, outlived_fr_is_local, category\n         );\n \n-        let errctx =\n-            ErrorReportingCtx { region_infcx: self, infcx, mir_def_id, body, local_names, upvars };\n-\n         let errci = ErrorConstraintInfo {\n             fr,\n             outlived_fr,\n@@ -504,22 +475,22 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         };\n \n         match (category, fr_is_local, outlived_fr_is_local) {\n-            (ConstraintCategory::Return, true, false) if self.is_closure_fn_mut(infcx, fr) => {\n-                self.report_fnmut_error(&errctx, &errci, renctx)\n+            (ConstraintCategory::Return, true, false) if self.is_closure_fn_mut(mbcx.infcx, fr) => {\n+                self.report_fnmut_error(mbcx, &errci, renctx)\n             }\n             (ConstraintCategory::Assignment, true, false)\n             | (ConstraintCategory::CallArgument, true, false) => {\n-                let mut db = self.report_escaping_data_error(&errctx, &errci, renctx);\n+                let mut db = self.report_escaping_data_error(mbcx, &errci, renctx);\n \n-                outlives_suggestion.intermediate_suggestion(&errctx, &errci, renctx, &mut db);\n+                outlives_suggestion.intermediate_suggestion(mbcx, &errci, renctx, &mut db);\n                 outlives_suggestion.collect_constraint(fr, outlived_fr);\n \n                 db\n             }\n             _ => {\n-                let mut db = self.report_general_error(&errctx, &errci, renctx);\n+                let mut db = self.report_general_error(mbcx, &errci, renctx);\n \n-                outlives_suggestion.intermediate_suggestion(&errctx, &errci, renctx, &mut db);\n+                outlives_suggestion.intermediate_suggestion(mbcx, &errci, renctx, &mut db);\n                 outlives_suggestion.collect_constraint(fr, outlived_fr);\n \n                 db\n@@ -569,13 +540,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn report_fnmut_error(\n         &self,\n-        errctx: &ErrorReportingCtx<'_, '_, 'tcx>,\n+        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         errci: &ErrorConstraintInfo,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> DiagnosticBuilder<'_> {\n         let ErrorConstraintInfo { outlived_fr, span, .. } = errci;\n \n-        let mut diag = errctx\n+        let mut diag = mbcx\n             .infcx\n             .tcx\n             .sess\n@@ -593,7 +564,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         diag.span_label(*span, message);\n \n-        match self.give_region_a_name(errctx, renctx, *outlived_fr).unwrap().source {\n+        match self.give_region_a_name(mbcx, renctx, *outlived_fr).unwrap().source {\n             RegionNameSource::NamedEarlyBoundRegion(fr_span)\n             | RegionNameSource::NamedFreeRegion(fr_span)\n             | RegionNameSource::SynthesizedFreeEnvRegion(fr_span, _)\n@@ -630,21 +601,24 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn report_escaping_data_error(\n         &self,\n-        errctx: &ErrorReportingCtx<'_, '_, 'tcx>,\n+        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         errci: &ErrorConstraintInfo,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> DiagnosticBuilder<'_> {\n-        let ErrorReportingCtx { infcx, body, upvars, local_names, .. } = errctx;\n-\n         let ErrorConstraintInfo { span, category, .. } = errci;\n \n-        let fr_name_and_span =\n-            self.get_var_name_and_span_for_region(infcx.tcx, body, local_names, upvars, errci.fr);\n+        let fr_name_and_span = self.get_var_name_and_span_for_region(\n+            mbcx.infcx.tcx,\n+            &mbcx.body,\n+            &mbcx.local_names,\n+            &mbcx.upvars,\n+            errci.fr,\n+        );\n         let outlived_fr_name_and_span = self.get_var_name_and_span_for_region(\n-            infcx.tcx,\n-            body,\n-            local_names,\n-            upvars,\n+            mbcx.infcx.tcx,\n+            &mbcx.body,\n+            &mbcx.local_names,\n+            &mbcx.upvars,\n             errci.outlived_fr,\n         );\n \n@@ -662,14 +636,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             || escapes_from == \"const\"\n         {\n             return self.report_general_error(\n-                errctx,\n+                mbcx,\n                 &ErrorConstraintInfo { fr_is_local: true, outlived_fr_is_local: false, ..*errci },\n                 renctx,\n             );\n         }\n \n         let mut diag =\n-            borrowck_errors::borrowed_data_escapes_closure(infcx.tcx, *span, escapes_from);\n+            borrowck_errors::borrowed_data_escapes_closure(mbcx.infcx.tcx, *span, escapes_from);\n \n         if let Some((Some(outlived_fr_name), outlived_fr_span)) = outlived_fr_name_and_span {\n             diag.span_label(\n@@ -713,11 +687,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn report_general_error(\n         &self,\n-        errctx: &ErrorReportingCtx<'_, '_, 'tcx>,\n+        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         errci: &ErrorConstraintInfo,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> DiagnosticBuilder<'_> {\n-        let ErrorReportingCtx { infcx, mir_def_id, .. } = errctx;\n         let ErrorConstraintInfo {\n             fr,\n             fr_is_local,\n@@ -728,13 +701,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             ..\n         } = errci;\n \n-        let mut diag = infcx.tcx.sess.struct_span_err(*span, \"lifetime may not live long enough\");\n+        let mut diag =\n+            mbcx.infcx.tcx.sess.struct_span_err(*span, \"lifetime may not live long enough\");\n \n-        let mir_def_name = if infcx.tcx.is_closure(*mir_def_id) { \"closure\" } else { \"function\" };\n+        let mir_def_name =\n+            if mbcx.infcx.tcx.is_closure(mbcx.mir_def_id) { \"closure\" } else { \"function\" };\n \n-        let fr_name = self.give_region_a_name(errctx, renctx, *fr).unwrap();\n+        let fr_name = self.give_region_a_name(mbcx, renctx, *fr).unwrap();\n         fr_name.highlight_region_name(&mut diag);\n-        let outlived_fr_name = self.give_region_a_name(errctx, renctx, *outlived_fr).unwrap();\n+        let outlived_fr_name = self.give_region_a_name(mbcx, renctx, *outlived_fr).unwrap();\n         outlived_fr_name.highlight_region_name(&mut diag);\n \n         match (category, outlived_fr_is_local, fr_is_local) {\n@@ -761,7 +736,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n \n-        self.add_static_impl_trait_suggestion(infcx, &mut diag, *fr, fr_name, *outlived_fr);\n+        self.add_static_impl_trait_suggestion(mbcx.infcx, &mut diag, *fr, fr_name, *outlived_fr);\n \n         diag\n     }\n@@ -854,25 +829,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     crate fn free_region_constraint_info(\n         &self,\n-        body: &Body<'tcx>,\n-        local_names: &IndexVec<Local, Option<Symbol>>,\n-        upvars: &[Upvar],\n-        mir_def_id: DefId,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         borrow_region: RegionVid,\n         outlived_region: RegionVid,\n     ) -> (ConstraintCategory, bool, Span, Option<RegionName>) {\n         let (category, from_closure, span) = self.best_blame_constraint(\n-            body,\n+            &mbcx.body,\n             borrow_region,\n             NLLRegionVariableOrigin::FreeRegion,\n             |r| self.provides_universal_region(r, borrow_region, outlived_region),\n         );\n \n         let mut renctx = RegionErrorNamingCtx::new();\n-        let errctx =\n-            ErrorReportingCtx { infcx, body, local_names, upvars, mir_def_id, region_infcx: self };\n-        let outlived_fr_name = self.give_region_a_name(&errctx, &mut renctx, outlived_region);\n+        let outlived_fr_name = self.give_region_a_name(mbcx, &mut renctx, outlived_region);\n \n         (category, from_closure, span, outlived_fr_name)\n     }"}, {"sha": "2c480b8e9dc4fbf7d04b833b66f7b4926b1173ac", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 46, "deletions": 82, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/9d6f87184e5116cf4a96f6686eb67994f19908a5/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d6f87184e5116cf4a96f6686eb67994f19908a5/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=9d6f87184e5116cf4a96f6686eb67994f19908a5", "patch": "@@ -2,21 +2,17 @@ use std::fmt::{self, Display};\n \n use rustc::hir;\n use rustc::hir::def::{DefKind, Res};\n-use rustc::hir::def_id::DefId;\n-use rustc::infer::InferCtxt;\n-use rustc::mir::{Body, Local};\n use rustc::ty::print::RegionHighlightMode;\n use rustc::ty::subst::{GenericArgKind, SubstsRef};\n use rustc::ty::{self, RegionVid, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::DiagnosticBuilder;\n-use rustc_index::vec::IndexVec;\n use syntax::symbol::kw;\n use syntax_pos::{symbol::Symbol, Span, DUMMY_SP};\n \n use crate::borrow_check::{\n-    diagnostics::region_errors::ErrorReportingCtx, nll::ToRegionVid,\n-    region_infer::RegionInferenceContext, universal_regions::DefiningTy, Upvar,\n+    nll::ToRegionVid, region_infer::RegionInferenceContext, universal_regions::DefiningTy,\n+    MirBorrowckCtxt,\n };\n \n /// A name for a particular region used in emitting diagnostics. This name could be a generated\n@@ -193,12 +189,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// and then return the name `'1` for us to use.\n     crate fn give_region_a_name(\n         &self,\n-        errctx: &ErrorReportingCtx<'_, '_, 'tcx>,\n+        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         renctx: &mut RegionErrorNamingCtx,\n         fr: RegionVid,\n     ) -> Option<RegionName> {\n-        let ErrorReportingCtx { infcx, body, mir_def_id, local_names, upvars, .. } = errctx;\n-\n         debug!(\"give_region_a_name(fr={:?}, counter={:?})\", fr, renctx.counter);\n \n         assert!(self.universal_regions.is_universal_region(fr));\n@@ -208,38 +202,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n \n         let value = self\n-            .give_name_from_error_region(infcx.tcx, *mir_def_id, fr, renctx)\n-            .or_else(|| {\n-                self.give_name_if_anonymous_region_appears_in_arguments(\n-                    infcx,\n-                    body,\n-                    local_names,\n-                    *mir_def_id,\n-                    fr,\n-                    renctx,\n-                )\n-            })\n-            .or_else(|| {\n-                self.give_name_if_anonymous_region_appears_in_upvars(infcx.tcx, upvars, fr, renctx)\n-            })\n-            .or_else(|| {\n-                self.give_name_if_anonymous_region_appears_in_output(\n-                    infcx,\n-                    body,\n-                    *mir_def_id,\n-                    fr,\n-                    renctx,\n-                )\n-            })\n-            .or_else(|| {\n-                self.give_name_if_anonymous_region_appears_in_yield_ty(\n-                    infcx,\n-                    body,\n-                    *mir_def_id,\n-                    fr,\n-                    renctx,\n-                )\n-            });\n+            .give_name_from_error_region(mbcx, fr, renctx)\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_arguments(mbcx, fr, renctx))\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_upvars(mbcx, fr, renctx))\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_output(mbcx, fr, renctx))\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_yield_ty(mbcx, fr, renctx));\n \n         if let Some(ref value) = value {\n             renctx.insert(fr, value.clone());\n@@ -255,13 +222,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// named variants.\n     fn give_name_from_error_region(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n-        mir_def_id: DefId,\n+        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         fr: RegionVid,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let error_region = self.to_error_region(fr)?;\n \n+        let tcx = mbcx.infcx.tcx;\n+\n         debug!(\"give_region_a_name: error_region = {:?}\", error_region);\n         match error_region {\n             ty::ReEarlyBound(ebr) => {\n@@ -308,7 +276,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 }\n \n                 ty::BoundRegion::BrEnv => {\n-                    let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).expect(\"non-local mir\");\n+                    let mir_hir_id = mbcx\n+                        .infcx\n+                        .tcx\n+                        .hir()\n+                        .as_local_hir_id(mbcx.mir_def_id)\n+                        .expect(\"non-local mir\");\n                     let def_ty = self.universal_regions.defining_ty;\n \n                     if let DefiningTy::Closure(def_id, substs) = def_ty {\n@@ -373,21 +346,17 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn give_name_if_anonymous_region_appears_in_arguments(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        body: &Body<'tcx>,\n-        local_names: &IndexVec<Local, Option<Symbol>>,\n-        mir_def_id: DefId,\n+        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         fr: RegionVid,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n-        let argument_index = self.get_argument_index_for_region(infcx.tcx, fr)?;\n+        let argument_index = self.get_argument_index_for_region(mbcx.infcx.tcx, fr)?;\n \n         let arg_ty =\n             self.universal_regions.unnormalized_input_tys[implicit_inputs + argument_index];\n         if let Some(region_name) = self.give_name_if_we_can_match_hir_ty_from_argument(\n-            infcx,\n-            mir_def_id,\n+            mbcx,\n             fr,\n             arg_ty,\n             argument_index,\n@@ -396,20 +365,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return Some(region_name);\n         }\n \n-        self.give_name_if_we_cannot_match_hir_ty(infcx, body, local_names, fr, arg_ty, renctx)\n+        self.give_name_if_we_cannot_match_hir_ty(mbcx, fr, arg_ty, renctx)\n     }\n \n     fn give_name_if_we_can_match_hir_ty_from_argument(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        mir_def_id: DefId,\n+        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         argument_index: usize,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n-        let mir_hir_id = infcx.tcx.hir().as_local_hir_id(mir_def_id)?;\n-        let fn_decl = infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n+        let mir_hir_id = mbcx.infcx.tcx.hir().as_local_hir_id(mbcx.mir_def_id)?;\n+        let fn_decl = mbcx.infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n         let argument_hir_ty: &hir::Ty<'_> = fn_decl.inputs.get(argument_index)?;\n         match argument_hir_ty.kind {\n             // This indicates a variable with no type annotation, like\n@@ -420,7 +388,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             hir::TyKind::Infer => None,\n \n             _ => self.give_name_if_we_can_match_hir_ty(\n-                infcx.tcx,\n+                mbcx.infcx.tcx,\n                 needle_fr,\n                 argument_ty,\n                 argument_hir_ty,\n@@ -442,27 +410,28 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn give_name_if_we_cannot_match_hir_ty(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        body: &Body<'tcx>,\n-        local_names: &IndexVec<Local, Option<Symbol>>,\n+        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let counter = renctx.counter;\n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(needle_fr, counter);\n-        let type_name = infcx.extract_type_name(&argument_ty, Some(highlight)).0;\n+        let type_name = mbcx.infcx.extract_type_name(&argument_ty, Some(highlight)).0;\n \n         debug!(\n             \"give_name_if_we_cannot_match_hir_ty: type_name={:?} needle_fr={:?}\",\n             type_name, needle_fr\n         );\n         let assigned_region_name = if type_name.find(&format!(\"'{}\", counter)).is_some() {\n             // Only add a label if we can confirm that a region was labelled.\n-            let argument_index = self.get_argument_index_for_region(infcx.tcx, needle_fr)?;\n-            let (_, span) =\n-                self.get_argument_name_and_span_for_region(body, local_names, argument_index);\n+            let argument_index = self.get_argument_index_for_region(mbcx.infcx.tcx, needle_fr)?;\n+            let (_, span) = self.get_argument_name_and_span_for_region(\n+                &mbcx.body,\n+                &mbcx.local_names,\n+                argument_index,\n+            );\n \n             Some(RegionName {\n                 // This counter value will already have been used, so this function will increment\n@@ -696,14 +665,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn give_name_if_anonymous_region_appears_in_upvars(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n-        upvars: &[Upvar],\n+        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         fr: RegionVid,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n-        let upvar_index = self.get_upvar_index_for_region(tcx, fr)?;\n+        let upvar_index = self.get_upvar_index_for_region(mbcx.infcx.tcx, fr)?;\n         let (upvar_name, upvar_span) =\n-            self.get_upvar_name_and_span_for_region(tcx, upvars, upvar_index);\n+            self.get_upvar_name_and_span_for_region(mbcx.infcx.tcx, &mbcx.upvars, upvar_index);\n         let region_name = renctx.synthesize_region_name();\n \n         Some(RegionName {\n@@ -718,13 +686,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// or be early bound (named, not in argument).\n     fn give_name_if_anonymous_region_appears_in_output(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        body: &Body<'tcx>,\n-        mir_def_id: DefId,\n+        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         fr: RegionVid,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n-        let tcx = infcx.tcx;\n+        let tcx = mbcx.infcx.tcx;\n \n         let return_ty = self.universal_regions.unnormalized_output_ty;\n         debug!(\"give_name_if_anonymous_region_appears_in_output: return_ty = {:?}\", return_ty);\n@@ -734,9 +700,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(fr, renctx.counter);\n-        let type_name = infcx.extract_type_name(&return_ty, Some(highlight)).0;\n+        let type_name = mbcx.infcx.extract_type_name(&return_ty, Some(highlight)).0;\n \n-        let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).expect(\"non-local mir\");\n+        let mir_hir_id = tcx.hir().as_local_hir_id(mbcx.mir_def_id).expect(\"non-local mir\");\n \n         let (return_span, mir_description) = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n@@ -753,7 +719,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 kind: hir::ImplItemKind::Method(method_sig, _),\n                 ..\n             }) => (method_sig.decl.output.span(), \"\"),\n-            _ => (body.span, \"\"),\n+            _ => (mbcx.body.span, \"\"),\n         };\n \n         Some(RegionName {\n@@ -771,9 +737,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     fn give_name_if_anonymous_region_appears_in_yield_ty(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        body: &Body<'tcx>,\n-        mir_def_id: DefId,\n+        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         fr: RegionVid,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n@@ -782,23 +746,23 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let yield_ty = self.universal_regions.yield_ty?;\n         debug!(\"give_name_if_anonymous_region_appears_in_yield_ty: yield_ty = {:?}\", yield_ty,);\n \n-        let tcx = infcx.tcx;\n+        let tcx = mbcx.infcx.tcx;\n \n         if !tcx.any_free_region_meets(&yield_ty, |r| r.to_region_vid() == fr) {\n             return None;\n         }\n \n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(fr, renctx.counter);\n-        let type_name = infcx.extract_type_name(&yield_ty, Some(highlight)).0;\n+        let type_name = mbcx.infcx.extract_type_name(&yield_ty, Some(highlight)).0;\n \n-        let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).expect(\"non-local mir\");\n+        let mir_hir_id = tcx.hir().as_local_hir_id(mbcx.mir_def_id).expect(\"non-local mir\");\n \n         let yield_span = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n                 kind: hir::ExprKind::Closure(_, _, _, span, _), ..\n             }) => (tcx.sess.source_map().end_point(*span)),\n-            _ => body.span,\n+            _ => mbcx.body.span,\n         };\n \n         debug!("}, {"sha": "59e6b0bb14ea34f0f36ecf9dfb4206129f4dea21", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9d6f87184e5116cf4a96f6686eb67994f19908a5/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d6f87184e5116cf4a96f6686eb67994f19908a5/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=9d6f87184e5116cf4a96f6686eb67994f19908a5", "patch": "@@ -1482,8 +1482,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         // FIXME(mark-i-m): Would be great to get rid of the naming context.\n         let mut region_naming = RegionErrorNamingCtx::new();\n-        let mut outlives_suggestion =\n-            OutlivesSuggestionBuilder::new(self.mir_def_id, &self.local_names);\n+        let mut outlives_suggestion = OutlivesSuggestionBuilder::default();\n \n         for nll_error in nll_errors.into_iter() {\n             match nll_error {\n@@ -1561,11 +1560,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 RegionErrorKind::RegionError { fr_origin, longer_fr, shorter_fr, is_reported } => {\n                     if is_reported {\n                         let db = self.nonlexical_regioncx.report_error(\n-                            &self.body,\n-                            &self.local_names,\n-                            &self.upvars,\n-                            self.infcx,\n-                            self.mir_def_id,\n+                            self,\n                             longer_fr,\n                             fr_origin,\n                             shorter_fr,\n@@ -1591,13 +1586,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n \n         // Emit one outlives suggestions for each MIR def we borrowck\n-        outlives_suggestion.add_suggestion(\n-            &self.body,\n-            &self.nonlexical_regioncx,\n-            self.infcx,\n-            &mut self.errors_buffer,\n-            &mut region_naming,\n-        );\n+        outlives_suggestion.add_suggestion(self, &mut region_naming);\n     }\n }\n "}]}