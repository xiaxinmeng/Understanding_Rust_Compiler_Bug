{"sha": "6dc3dae46f600efe75627a7ad386e7462066e34d", "node_id": "C_kwDOAAsO6NoAKDZkYzNkYWU0NmY2MDBlZmU3NTYyN2E3YWQzODZlNzQ2MjA2NmUzNGQ", "commit": {"author": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2021-05-19T13:01:30Z"}, "committer": {"name": "Alan Egerton", "email": "eggyal@gmail.com", "date": "2021-11-26T07:25:16Z"}, "message": "Adapt `TypeFolder` implementors to return a `Result`\n\nCo-authored-by: Alan Egerton <eggyal@gmail.com>", "tree": {"sha": "998df08bd8035cb6a9e2435d15a93fd0a4a0c450", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/998df08bd8035cb6a9e2435d15a93fd0a4a0c450"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6dc3dae46f600efe75627a7ad386e7462066e34d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEm/Nz5g9hEBdpmKVOB8rDzKfgZD8FAmGgi/4ACgkQB8rDzKfg\nZD+6wQ//ZxwzP/RZdUfeRk4EjMD+I5BzUweBvhzV5cNzKldCZox0B7ofcGCSX+kE\n4eo7cqIyGnQzg4Ho7c8kOVW03PqrOfI870mW/rmiRK/GAz1f+QBLxuNsrCuoILZz\nP+CGP/zu4loHqm6OGnyepBI57JY5YrBtjJu7vUHf1d71qH8clo7XzOzlWPovdTpd\n6BKlaTackXted0I3WR6OkVXZSN7OiUZczr+XDRewtMNdayfuSbCt09gWZAf2/yJO\nPsbKPbWYidugUo8ms9weigEx5h3lbOuDPtLi786csSYdNbggz6nTXdkloCvWq9DA\nhP59xUJEnw77ZA9mcrPbcQoFnghKPHndYq1TBAJZCdjsaUhHLFyXS/HFDhwylzcJ\niFaF96vkn2jyJ4KMYp53IxFq6NTtxoxgW3k+TsZ25bE+Mt6PVA40YPfdTdXIsWcG\nTENc+NVdWEcWb1l+S5yapfSLLw+Dw5v2Kb+XtoxvFTXArObtd9/A2vi6k27KgF4q\nTcFfqyrLIjFr3Swpv83xa9k8DFmQKdtcIoo/vcrJht60E3J3qKzu4sn6/SdiGzwm\n69SzIBWBNPkktlT8rojL8HtwYPiDJXcvqOD/B33539r9K4oXevQ4PXHvItlyQdH/\nWvVBGSWITsooOGNNb9VuINcf0zoJqxc7LHhsKPDj/K41WAo/A/s=\n=LZI0\n-----END PGP SIGNATURE-----", "payload": "tree 998df08bd8035cb6a9e2435d15a93fd0a4a0c450\nparent 6e3fa20b00d5b3713848aa162969d7a460bd194a\nauthor LeSeulArtichaut <leseulartichaut@gmail.com> 1621429290 +0200\ncommitter Alan Egerton <eggyal@gmail.com> 1637911516 +0000\n\nAdapt `TypeFolder` implementors to return a `Result`\n\nCo-authored-by: Alan Egerton <eggyal@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6dc3dae46f600efe75627a7ad386e7462066e34d", "html_url": "https://github.com/rust-lang/rust/commit/6dc3dae46f600efe75627a7ad386e7462066e34d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6dc3dae46f600efe75627a7ad386e7462066e34d/comments", "author": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eggyal", "id": 3089613, "node_id": "MDQ6VXNlcjMwODk2MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3089613?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eggyal", "html_url": "https://github.com/eggyal", "followers_url": "https://api.github.com/users/eggyal/followers", "following_url": "https://api.github.com/users/eggyal/following{/other_user}", "gists_url": "https://api.github.com/users/eggyal/gists{/gist_id}", "starred_url": "https://api.github.com/users/eggyal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eggyal/subscriptions", "organizations_url": "https://api.github.com/users/eggyal/orgs", "repos_url": "https://api.github.com/users/eggyal/repos", "events_url": "https://api.github.com/users/eggyal/events{/privacy}", "received_events_url": "https://api.github.com/users/eggyal/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e3fa20b00d5b3713848aa162969d7a460bd194a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e3fa20b00d5b3713848aa162969d7a460bd194a", "html_url": "https://github.com/rust-lang/rust/commit/6e3fa20b00d5b3713848aa162969d7a460bd194a"}], "stats": {"total": 692, "additions": 387, "deletions": 305}, "files": [{"sha": "dd1f0d63aff051ed5d8201896dee51723ce51796", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=6dc3dae46f600efe75627a7ad386e7462066e34d", "patch": "@@ -278,7 +278,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T>(&mut self, t: ty::Binder<'tcx, T>) -> ty::Binder<'tcx, T>\n+    fn fold_binder<T>(&mut self, t: ty::Binder<'tcx, T>) -> Result<ty::Binder<'tcx, T>, Self::Error>\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -288,13 +288,13 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n         t\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         match *r {\n             ty::ReLateBound(index, ..) => {\n                 if index >= self.binder_index {\n                     bug!(\"escaping late-bound region during canonicalization\");\n                 } else {\n-                    r\n+                    Ok(r)\n                 }\n             }\n \n@@ -311,19 +311,19 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                     vid, r\n                 );\n                 let r = self.tcx.reuse_or_mk_region(r, ty::ReVar(resolved_vid));\n-                self.canonicalize_region_mode.canonicalize_free_region(self, r)\n+                Ok(self.canonicalize_region_mode.canonicalize_free_region(self, r))\n             }\n \n             ty::ReStatic\n             | ty::ReEarlyBound(..)\n             | ty::ReFree(_)\n             | ty::ReEmpty(_)\n             | ty::RePlaceholder(..)\n-            | ty::ReErased => self.canonicalize_region_mode.canonicalize_free_region(self, r),\n+            | ty::ReErased => Ok(self.canonicalize_region_mode.canonicalize_free_region(self, r)),\n         }\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         match *t.kind() {\n             ty::Infer(ty::TyVar(vid)) => {\n                 debug!(\"canonical: type var found with vid {:?}\", vid);\n@@ -339,40 +339,40 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                     Err(mut ui) => {\n                         // FIXME: perf problem described in #55921.\n                         ui = ty::UniverseIndex::ROOT;\n-                        self.canonicalize_ty_var(\n+                        Ok(self.canonicalize_ty_var(\n                             CanonicalVarInfo {\n                                 kind: CanonicalVarKind::Ty(CanonicalTyVarKind::General(ui)),\n                             },\n                             t,\n-                        )\n+                        ))\n                     }\n                 }\n             }\n \n-            ty::Infer(ty::IntVar(_)) => self.canonicalize_ty_var(\n+            ty::Infer(ty::IntVar(_)) => Ok(self.canonicalize_ty_var(\n                 CanonicalVarInfo { kind: CanonicalVarKind::Ty(CanonicalTyVarKind::Int) },\n                 t,\n-            ),\n+            )),\n \n-            ty::Infer(ty::FloatVar(_)) => self.canonicalize_ty_var(\n+            ty::Infer(ty::FloatVar(_)) => Ok(self.canonicalize_ty_var(\n                 CanonicalVarInfo { kind: CanonicalVarKind::Ty(CanonicalTyVarKind::Float) },\n                 t,\n-            ),\n+            )),\n \n             ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n                 bug!(\"encountered a fresh type during canonicalization\")\n             }\n \n-            ty::Placeholder(placeholder) => self.canonicalize_ty_var(\n+            ty::Placeholder(placeholder) => Ok(self.canonicalize_ty_var(\n                 CanonicalVarInfo { kind: CanonicalVarKind::PlaceholderTy(placeholder) },\n                 t,\n-            ),\n+            )),\n \n             ty::Bound(debruijn, _) => {\n                 if debruijn >= self.binder_index {\n                     bug!(\"escaping bound type during canonicalization\")\n                 } else {\n-                    t\n+                    Ok(t)\n                 }\n             }\n \n@@ -403,13 +403,16 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                 if t.flags().intersects(self.needs_canonical_flags) {\n                     t.super_fold_with(self)\n                 } else {\n-                    t\n+                    Ok(t)\n                 }\n             }\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         match ct.val {\n             ty::ConstKind::Infer(InferConst::Var(vid)) => {\n                 debug!(\"canonical: const var found with vid {:?}\", vid);\n@@ -424,10 +427,10 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                     Err(mut ui) => {\n                         // FIXME: perf problem described in #55921.\n                         ui = ty::UniverseIndex::ROOT;\n-                        return self.canonicalize_const_var(\n+                        return Ok(self.canonicalize_const_var(\n                             CanonicalVarInfo { kind: CanonicalVarKind::Const(ui) },\n                             ct,\n-                        );\n+                        ));\n                     }\n                 }\n             }\n@@ -438,20 +441,20 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                 if debruijn >= self.binder_index {\n                     bug!(\"escaping bound type during canonicalization\")\n                 } else {\n-                    return ct;\n+                    return Ok(ct);\n                 }\n             }\n             ty::ConstKind::Placeholder(placeholder) => {\n-                return self.canonicalize_const_var(\n+                return Ok(self.canonicalize_const_var(\n                     CanonicalVarInfo { kind: CanonicalVarKind::PlaceholderConst(placeholder) },\n                     ct,\n-                );\n+                ));\n             }\n             _ => {}\n         }\n \n         let flags = FlagComputation::for_const(ct);\n-        if flags.intersects(self.needs_canonical_flags) { ct.super_fold_with(self) } else { ct }\n+        if flags.intersects(self.needs_canonical_flags) { ct.super_fold_with(self) } else { Ok(ct) }\n     }\n }\n "}, {"sha": "fce6403575b79b8db848c5ae74c3c8b1b423ad8f", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=6dc3dae46f600efe75627a7ad386e7462066e34d", "patch": "@@ -119,11 +119,11 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         match *r {\n             ty::ReLateBound(..) => {\n                 // leave bound regions alone\n-                r\n+                Ok(r)\n             }\n \n             ty::ReEarlyBound(..)\n@@ -133,32 +133,32 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             | ty::ReEmpty(_)\n             | ty::ReErased => {\n                 // replace all free regions with 'erased\n-                self.tcx().lifetimes.re_erased\n+                Ok(self.tcx().lifetimes.re_erased)\n             }\n             ty::ReStatic => {\n                 if self.keep_static {\n-                    r\n+                    Ok(r)\n                 } else {\n-                    self.tcx().lifetimes.re_erased\n+                    Ok(self.tcx().lifetimes.re_erased)\n                 }\n             }\n         }\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         if !t.needs_infer() && !t.has_erasable_regions(self.tcx()) {\n-            return t;\n+            return Ok(t);\n         }\n \n         let tcx = self.infcx.tcx;\n \n         match *t.kind() {\n             ty::Infer(ty::TyVar(v)) => {\n                 let opt_ty = self.infcx.inner.borrow_mut().type_variables().probe(v).known();\n-                self.freshen_ty(opt_ty, ty::TyVar(v), ty::FreshTy)\n+                Ok(self.freshen_ty(opt_ty, ty::TyVar(v), ty::FreshTy))\n             }\n \n-            ty::Infer(ty::IntVar(v)) => self.freshen_ty(\n+            ty::Infer(ty::IntVar(v)) => Ok(self.freshen_ty(\n                 self.infcx\n                     .inner\n                     .borrow_mut()\n@@ -167,9 +167,9 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                     .map(|v| v.to_type(tcx)),\n                 ty::IntVar(v),\n                 ty::FreshIntTy,\n-            ),\n+            )),\n \n-            ty::Infer(ty::FloatVar(v)) => self.freshen_ty(\n+            ty::Infer(ty::FloatVar(v)) => Ok(self.freshen_ty(\n                 self.infcx\n                     .inner\n                     .borrow_mut()\n@@ -178,7 +178,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                     .map(|v| v.to_type(tcx)),\n                 ty::FloatVar(v),\n                 ty::FreshFloatTy,\n-            ),\n+            )),\n \n             ty::Infer(ty::FreshTy(ct) | ty::FreshIntTy(ct) | ty::FreshFloatTy(ct)) => {\n                 if ct >= self.ty_freshen_count {\n@@ -189,7 +189,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                         self.ty_freshen_count\n                     );\n                 }\n-                t\n+                Ok(t)\n             }\n \n             ty::Generator(..)\n@@ -221,7 +221,10 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         match ct.val {\n             ty::ConstKind::Infer(ty::InferConst::Var(v)) => {\n                 let opt_ct = self\n@@ -232,12 +235,12 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                     .probe_value(v)\n                     .val\n                     .known();\n-                return self.freshen_const(\n+                return Ok(self.freshen_const(\n                     opt_ct,\n                     ty::InferConst::Var(v),\n                     ty::InferConst::Fresh,\n                     ct.ty,\n-                );\n+                ));\n             }\n             ty::ConstKind::Infer(ty::InferConst::Fresh(i)) => {\n                 if i >= self.const_freshen_count {\n@@ -248,7 +251,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                         self.const_freshen_count,\n                     );\n                 }\n-                return ct;\n+                return Ok(ct);\n             }\n \n             ty::ConstKind::Bound(..) | ty::ConstKind::Placeholder(_) => {"}, {"sha": "c889abf3d3c8863db0530b5e9f383553256bb40a", "filename": "compiler/rustc_infer/src/infer/fudge.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs?ref=6dc3dae46f600efe75627a7ad386e7462066e34d", "patch": "@@ -180,15 +180,15 @@ impl<'a, 'tcx> TypeFolder<'tcx> for InferenceFudger<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         match *ty.kind() {\n             ty::Infer(ty::InferTy::TyVar(vid)) => {\n                 if self.type_vars.0.contains(&vid) {\n                     // This variable was created during the fudging.\n                     // Recreate it with a fresh variable here.\n                     let idx = (vid.as_usize() - self.type_vars.0.start.as_usize()) as usize;\n                     let origin = self.type_vars.1[idx];\n-                    self.infcx.next_ty_var(origin)\n+                    Ok(self.infcx.next_ty_var(origin))\n                 } else {\n                     // This variable was created before the\n                     // \"fudging\". Since we refresh all type\n@@ -198,48 +198,43 @@ impl<'a, 'tcx> TypeFolder<'tcx> for InferenceFudger<'a, 'tcx> {\n                     debug_assert!(\n                         self.infcx.inner.borrow_mut().type_variables().probe(vid).is_unknown()\n                     );\n-                    ty\n+                    Ok(ty)\n                 }\n             }\n             ty::Infer(ty::InferTy::IntVar(vid)) => {\n-                if self.int_vars.contains(&vid) {\n-                    self.infcx.next_int_var()\n-                } else {\n-                    ty\n-                }\n+                Ok(if self.int_vars.contains(&vid) { self.infcx.next_int_var() } else { ty })\n             }\n             ty::Infer(ty::InferTy::FloatVar(vid)) => {\n-                if self.float_vars.contains(&vid) {\n-                    self.infcx.next_float_var()\n-                } else {\n-                    ty\n-                }\n+                Ok(if self.float_vars.contains(&vid) { self.infcx.next_float_var() } else { ty })\n             }\n             _ => ty.super_fold_with(self),\n         }\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         if let ty::ReVar(vid) = *r {\n             if self.region_vars.0.contains(&vid) {\n                 let idx = vid.index() - self.region_vars.0.start.index();\n                 let origin = self.region_vars.1[idx];\n-                return self.infcx.next_region_var(origin);\n+                return Ok(self.infcx.next_region_var(origin));\n             }\n         }\n-        r\n+        Ok(r)\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         if let ty::Const { val: ty::ConstKind::Infer(ty::InferConst::Var(vid)), ty } = ct {\n             if self.const_vars.0.contains(&vid) {\n                 // This variable was created during the fudging.\n                 // Recreate it with a fresh variable here.\n                 let idx = (vid.index - self.const_vars.0.start.index) as usize;\n                 let origin = self.const_vars.1[idx];\n-                self.infcx.next_const_var(ty, origin)\n+                Ok(self.infcx.next_const_var(ty, origin))\n             } else {\n-                ct\n+                Ok(ct)\n             }\n         } else {\n             ct.super_fold_with(self)"}, {"sha": "afac40b0ebd0d12a9300c0a4e316b3f3ecd1d803", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=6dc3dae46f600efe75627a7ad386e7462066e34d", "patch": "@@ -1745,12 +1745,15 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.infcx.shallow_resolve_ty(ty)\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+        Ok(self.infcx.shallow_resolve_ty(ty))\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ty::Const { val: ty::ConstKind::Infer(InferConst::Var(vid)), .. } = ct {\n+    fn fold_const(\n+        &mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+        Ok(if let ty::Const { val: ty::ConstKind::Infer(InferConst::Var(vid)), .. } = ct {\n             self.infcx\n                 .inner\n                 .borrow_mut()\n@@ -1761,7 +1764,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n                 .unwrap_or(ct)\n         } else {\n             ct\n-        }\n+        })\n     }\n }\n "}, {"sha": "d09c585a02598e2fd2dd8c8c0d664c2670d0b3e9", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=6dc3dae46f600efe75627a7ad386e7462066e34d", "patch": "@@ -30,25 +30,28 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticVarResolver<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         if !t.has_infer_types_or_consts() {\n-            t // micro-optimize -- if there is nothing in this type that this fold affects...\n+            Ok(t) // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n             let t = self.infcx.shallow_resolve(t);\n             t.super_fold_with(self)\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx Const<'tcx>) -> &'tcx Const<'tcx> {\n+    fn fold_const(&mut self, ct: &'tcx Const<'tcx>) -> Result<&'tcx Const<'tcx>, Self::Error> {\n         if !ct.has_infer_types_or_consts() {\n-            ct // micro-optimize -- if there is nothing in this const that this fold affects...\n+            Ok(ct) // micro-optimize -- if there is nothing in this const that this fold affects...\n         } else {\n             let ct = self.infcx.shallow_resolve(ct);\n             ct.super_fold_with(self)\n         }\n     }\n \n-    fn fold_mir_const(&mut self, constant: mir::ConstantKind<'tcx>) -> mir::ConstantKind<'tcx> {\n+    fn fold_mir_const(\n+        &mut self,\n+        constant: mir::ConstantKind<'tcx>,\n+    ) -> Result<mir::ConstantKind<'tcx>, Self::Error> {\n         constant.super_fold_with(self)\n     }\n }\n@@ -75,16 +78,16 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticRegionResolver<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         if !t.has_infer_regions() {\n-            t // micro-optimize -- if there is nothing in this type that this fold affects...\n+            Ok(t) // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n             t.super_fold_with(self)\n         }\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        match *r {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+        Ok(match *r {\n             ty::ReVar(rid) => {\n                 let resolved = self\n                     .infcx\n@@ -95,12 +98,15 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticRegionResolver<'a, 'tcx> {\n                 self.tcx().reuse_or_mk_region(r, ty::ReVar(resolved))\n             }\n             _ => r,\n-        }\n+        })\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         if !ct.has_infer_regions() {\n-            ct // micro-optimize -- if there is nothing in this const that this fold affects...\n+            Ok(ct) // micro-optimize -- if there is nothing in this const that this fold affects...\n         } else {\n             ct.super_fold_with(self)\n         }\n@@ -195,23 +201,23 @@ impl<'a, 'tcx> TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         if !t.needs_infer() {\n-            t // micro-optimize -- if there is nothing in this type that this fold affects...\n+            Ok(t) // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n             let t = self.infcx.shallow_resolve(t);\n             match *t.kind() {\n                 ty::Infer(ty::TyVar(vid)) => {\n                     self.err = Some(FixupError::UnresolvedTy(vid));\n-                    self.tcx().ty_error()\n+                    Ok(self.tcx().ty_error())\n                 }\n                 ty::Infer(ty::IntVar(vid)) => {\n                     self.err = Some(FixupError::UnresolvedIntTy(vid));\n-                    self.tcx().ty_error()\n+                    Ok(self.tcx().ty_error())\n                 }\n                 ty::Infer(ty::FloatVar(vid)) => {\n                     self.err = Some(FixupError::UnresolvedFloatTy(vid));\n-                    self.tcx().ty_error()\n+                    Ok(self.tcx().ty_error())\n                 }\n                 ty::Infer(_) => {\n                     bug!(\"Unexpected type in full type resolver: {:?}\", t);\n@@ -221,28 +227,31 @@ impl<'a, 'tcx> TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n         }\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         match *r {\n-            ty::ReVar(rid) => self\n+            ty::ReVar(rid) => Ok(self\n                 .infcx\n                 .lexical_region_resolutions\n                 .borrow()\n                 .as_ref()\n                 .expect(\"region resolution not performed\")\n-                .resolve_var(rid),\n-            _ => r,\n+                .resolve_var(rid)),\n+            _ => Ok(r),\n         }\n     }\n \n-    fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        c: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         if !c.needs_infer() {\n-            c // micro-optimize -- if there is nothing in this const that this fold affects...\n+            Ok(c) // micro-optimize -- if there is nothing in this const that this fold affects...\n         } else {\n             let c = self.infcx.shallow_resolve(c);\n             match c.val {\n                 ty::ConstKind::Infer(InferConst::Var(vid)) => {\n                     self.err = Some(FixupError::UnresolvedConst(vid));\n-                    return self.tcx().const_error(c.ty);\n+                    return Ok(self.tcx().const_error(c.ty));\n                 }\n                 ty::ConstKind::Infer(InferConst::Fresh(_)) => {\n                     bug!(\"Unexpected const in full const resolver: {:?}\", c);"}, {"sha": "559534a7aa4e3e612deb41bd1b64ecb575f2ea6b", "filename": "compiler/rustc_middle/src/ty/erase_regions.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs?ref=6dc3dae46f600efe75627a7ad386e7462066e34d", "patch": "@@ -42,19 +42,19 @@ impl TypeFolder<'tcx> for RegionEraserVisitor<'tcx> {\n         self.tcx\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if ty.needs_infer() { ty.super_fold_with(self) } else { self.tcx.erase_regions_ty(ty) }\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+        if ty.needs_infer() { ty.super_fold_with(self) } else { Ok(self.tcx.erase_regions_ty(ty)) }\n     }\n \n-    fn fold_binder<T>(&mut self, t: ty::Binder<'tcx, T>) -> ty::Binder<'tcx, T>\n+    fn fold_binder<T>(&mut self, t: ty::Binder<'tcx, T>) -> Result<ty::Binder<'tcx, T>, Self::Error>\n     where\n         T: TypeFoldable<'tcx>,\n     {\n         let u = self.tcx.anonymize_late_bound_regions(t);\n         u.super_fold_with(self)\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         // because late-bound regions affect subtyping, we can't\n         // erase the bound/free distinction, but we can replace\n         // all free regions with 'erased.\n@@ -64,12 +64,15 @@ impl TypeFolder<'tcx> for RegionEraserVisitor<'tcx> {\n         // away. In codegen, they will always be erased to 'erased\n         // whenever a substitution occurs.\n         match *r {\n-            ty::ReLateBound(..) => r,\n-            _ => self.tcx.lifetimes.re_erased,\n+            ty::ReLateBound(..) => Ok(r),\n+            _ => Ok(self.tcx.lifetimes.re_erased),\n         }\n     }\n \n-    fn fold_mir_const(&mut self, c: mir::ConstantKind<'tcx>) -> mir::ConstantKind<'tcx> {\n+    fn fold_mir_const(\n+        &mut self,\n+        c: mir::ConstantKind<'tcx>,\n+    ) -> Result<mir::ConstantKind<'tcx>, Self::Error> {\n         c.super_fold_with(self)\n     }\n }"}, {"sha": "639606f6b891ecb5d6bdf7b46dad8c87a8b22d54", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 53, "deletions": 39, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=6dc3dae46f600efe75627a7ad386e7462066e34d", "patch": "@@ -301,19 +301,22 @@ where\n         self.tcx\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        let t = ty.super_fold_with(self);\n-        (self.ty_op)(t)\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+        let t = ty.super_fold_with(self)?;\n+        Ok((self.ty_op)(t))\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        let r = r.super_fold_with(self);\n-        (self.lt_op)(r)\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+        let r = r.super_fold_with(self)?;\n+        Ok((self.lt_op)(r))\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        let ct = ct.super_fold_with(self);\n-        (self.ct_op)(ct)\n+    fn fold_const(\n+        &mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+        let ct = ct.super_fold_with(self)?;\n+        Ok((self.ct_op)(ct))\n     }\n }\n \n@@ -481,24 +484,24 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> ty::Binder<'tcx, T> {\n+    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n         t\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         match *r {\n             ty::ReLateBound(debruijn, _) if debruijn < self.current_index => {\n                 debug!(?self.current_index, \"skipped bound region\");\n                 *self.skipped_regions = true;\n-                r\n+                Ok(r)\n             }\n             _ => {\n                 debug!(?self.current_index, \"folding free region\");\n-                (self.fold_region_fn)(r, self.current_index)\n+                Ok((self.fold_region_fn)(r, self.current_index))\n             }\n         }\n     }\n@@ -539,30 +542,30 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BoundVarReplacer<'a, 'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> ty::Binder<'tcx, T> {\n+    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n         t\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         match *t.kind() {\n             ty::Bound(debruijn, bound_ty) if debruijn == self.current_index => {\n                 if let Some(fld_t) = self.fld_t.as_mut() {\n                     let ty = fld_t(bound_ty);\n-                    return ty::fold::shift_vars(self.tcx, &ty, self.current_index.as_u32());\n+                    return Ok(ty::fold::shift_vars(self.tcx, &ty, self.current_index.as_u32()));\n                 }\n             }\n             _ if t.has_vars_bound_at_or_above(self.current_index) => {\n                 return t.super_fold_with(self);\n             }\n             _ => {}\n         }\n-        t\n+        Ok(t)\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         match *r {\n             ty::ReLateBound(debruijn, br) if debruijn == self.current_index => {\n                 if let Some(fld_r) = self.fld_r.as_mut() {\n@@ -573,33 +576,36 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BoundVarReplacer<'a, 'tcx> {\n                         // debruijn index. Then we adjust it to the\n                         // correct depth.\n                         assert_eq!(debruijn1, ty::INNERMOST);\n-                        self.tcx.mk_region(ty::ReLateBound(debruijn, br))\n+                        Ok(self.tcx.mk_region(ty::ReLateBound(debruijn, br)))\n                     } else {\n-                        region\n+                        Ok(region)\n                     };\n                 }\n             }\n             _ => {}\n         }\n-        r\n+        Ok(r)\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         match *ct {\n             ty::Const { val: ty::ConstKind::Bound(debruijn, bound_const), ty }\n                 if debruijn == self.current_index =>\n             {\n                 if let Some(fld_c) = self.fld_c.as_mut() {\n                     let ct = fld_c(bound_const, ty);\n-                    return ty::fold::shift_vars(self.tcx, &ct, self.current_index.as_u32());\n+                    return Ok(ty::fold::shift_vars(self.tcx, &ct, self.current_index.as_u32()));\n                 }\n             }\n             _ if ct.has_vars_bound_at_or_above(self.current_index) => {\n                 return ct.super_fold_with(self);\n             }\n             _ => {}\n         }\n-        ct\n+        Ok(ct)\n     }\n }\n \n@@ -949,50 +955,55 @@ impl TypeFolder<'tcx> for Shifter<'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> ty::Binder<'tcx, T> {\n+    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n         t\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         match *r {\n             ty::ReLateBound(debruijn, br) => {\n                 if self.amount == 0 || debruijn < self.current_index {\n-                    r\n+                    Ok(r)\n                 } else {\n                     let debruijn = debruijn.shifted_in(self.amount);\n                     let shifted = ty::ReLateBound(debruijn, br);\n-                    self.tcx.mk_region(shifted)\n+                    Ok(self.tcx.mk_region(shifted))\n                 }\n             }\n-            _ => r,\n+            _ => Ok(r),\n         }\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         match *ty.kind() {\n             ty::Bound(debruijn, bound_ty) => {\n                 if self.amount == 0 || debruijn < self.current_index {\n-                    ty\n+                    Ok(ty)\n                 } else {\n                     let debruijn = debruijn.shifted_in(self.amount);\n-                    self.tcx.mk_ty(ty::Bound(debruijn, bound_ty))\n+                    Ok(self.tcx.mk_ty(ty::Bound(debruijn, bound_ty)))\n                 }\n             }\n \n             _ => ty.super_fold_with(self),\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         if let ty::Const { val: ty::ConstKind::Bound(debruijn, bound_ct), ty } = *ct {\n             if self.amount == 0 || debruijn < self.current_index {\n-                ct\n+                Ok(ct)\n             } else {\n                 let debruijn = debruijn.shifted_in(self.amount);\n-                self.tcx.mk_const(ty::Const { val: ty::ConstKind::Bound(debruijn, bound_ct), ty })\n+                Ok(self\n+                    .tcx\n+                    .mk_const(ty::Const { val: ty::ConstKind::Bound(debruijn, bound_ct), ty }))\n             }\n         } else {\n             ct.super_fold_with(self)\n@@ -1295,19 +1306,22 @@ impl<'tcx> TypeFolder<'tcx> for ExposeDefaultConstSubstsFolder<'tcx> {\n         self.tcx\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         if ty.flags().intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS) {\n             ty.super_fold_with(self)\n         } else {\n-            ty\n+            Ok(ty)\n         }\n     }\n \n-    fn fold_predicate(&mut self, pred: ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {\n+    fn fold_predicate(\n+        &mut self,\n+        pred: ty::Predicate<'tcx>,\n+    ) -> Result<ty::Predicate<'tcx>, Self::Error> {\n         if pred.inner.flags.intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS) {\n             pred.super_fold_with(self)\n         } else {\n-            pred\n+            Ok(pred)\n         }\n     }\n }"}, {"sha": "23863bf389e5a1dfaf3ee855719ff9e7899dd0c5", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=6dc3dae46f600efe75627a7ad386e7462066e34d", "patch": "@@ -622,7 +622,7 @@ fn polymorphize<'tcx>(\n             self.tcx\n         }\n \n-        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n             debug!(\"fold_ty: ty={:?}\", ty);\n             match ty.kind {\n                 ty::Closure(def_id, substs) => {\n@@ -631,23 +631,23 @@ fn polymorphize<'tcx>(\n                         ty::InstanceDef::Item(ty::WithOptConstParam::unknown(def_id)),\n                         substs,\n                     );\n-                    if substs == polymorphized_substs {\n+                    Ok(if substs == polymorphized_substs {\n                         ty\n                     } else {\n                         self.tcx.mk_closure(def_id, polymorphized_substs)\n-                    }\n+                    })\n                 }\n                 ty::Generator(def_id, substs, movability) => {\n                     let polymorphized_substs = polymorphize(\n                         self.tcx,\n                         ty::InstanceDef::Item(ty::WithOptConstParam::unknown(def_id)),\n                         substs,\n                     );\n-                    if substs == polymorphized_substs {\n+                    Ok(if substs == polymorphized_substs {\n                         ty\n                     } else {\n                         self.tcx.mk_generator(def_id, polymorphized_substs, movability)\n-                    }\n+                    })\n                 }\n                 _ => ty.super_fold_with(self),\n             }"}, {"sha": "c5d845f97559df96576a4cb2b5d3e71bf3ffdd60", "filename": "compiler/rustc_middle/src/ty/normalize_erasing_regions.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs?ref=6dc3dae46f600efe75627a7ad386e7462066e34d", "patch": "@@ -103,18 +103,24 @@ impl TypeFolder<'tcx> for NormalizeAfterErasingRegionsFolder<'tcx> {\n         self.tcx\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.normalize_generic_arg_after_erasing_regions(ty.into()).expect_ty()\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+        Ok(self.normalize_generic_arg_after_erasing_regions(ty.into()).expect_ty())\n     }\n \n-    fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        self.normalize_generic_arg_after_erasing_regions(c.into()).expect_const()\n+    fn fold_const(\n+        &mut self,\n+        c: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+        Ok(self.normalize_generic_arg_after_erasing_regions(c.into()).expect_const())\n     }\n \n     #[inline]\n-    fn fold_mir_const(&mut self, c: mir::ConstantKind<'tcx>) -> mir::ConstantKind<'tcx> {\n+    fn fold_mir_const(\n+        &mut self,\n+        c: mir::ConstantKind<'tcx>,\n+    ) -> Result<mir::ConstantKind<'tcx>, Self::Error> {\n         // FIXME: This *probably* needs canonicalization too!\n         let arg = self.param_env.and(c);\n-        self.tcx.normalize_mir_const_after_erasing_regions(arg)\n+        Ok(self.tcx.normalize_mir_const_after_erasing_regions(arg))\n     }\n }"}, {"sha": "13c6b4d6b01ba7416361a3d9e5a9fc24322e3aec", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=6dc3dae46f600efe75627a7ad386e7462066e34d", "patch": "@@ -2016,24 +2016,24 @@ impl<'a, 'tcx> ty::TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> ty::Binder<'tcx, T> {\n+    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n         t\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         match *t.kind() {\n             _ if t.has_vars_bound_at_or_above(self.current_index) || t.has_placeholders() => {\n                 return t.super_fold_with(self);\n             }\n             _ => {}\n         }\n-        t\n+        Ok(t)\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         let name = &mut self.name;\n         let region = match *r {\n             ty::ReLateBound(_, br) => self.region_map.entry(br).or_insert_with(|| name(br)),\n@@ -2049,13 +2049,13 @@ impl<'a, 'tcx> ty::TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n                     }\n                 }\n             }\n-            _ => return r,\n+            _ => return Ok(r),\n         };\n         if let ty::ReLateBound(debruijn1, br) = *region {\n             assert_eq!(debruijn1, ty::INNERMOST);\n-            self.tcx.mk_region(ty::ReLateBound(self.current_index, br))\n+            Ok(self.tcx.mk_region(ty::ReLateBound(self.current_index, br)))\n         } else {\n-            region\n+            Ok(region)\n         }\n     }\n }"}, {"sha": "ee6eed0f39b2d33dfe044c3bf3bdcf1b8a866d3c", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=6dc3dae46f600efe75627a7ad386e7462066e34d", "patch": "@@ -1087,12 +1087,12 @@ impl<'tcx> TypeFoldable<'tcx> for InferConst<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Unevaluated<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        ty::Unevaluated {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(ty::Unevaluated {\n             def: self.def,\n             substs_: Some(self.substs(folder.tcx()).fold_with(folder)?),\n             promoted: self.promoted,\n-        }\n+        })\n     }\n \n     fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -1112,12 +1112,12 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Unevaluated<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Unevaluated<'tcx, ()> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        ty::Unevaluated {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(ty::Unevaluated {\n             def: self.def,\n             substs_: Some(self.substs(folder.tcx()).fold_with(folder)?),\n             promoted: self.promoted,\n-        }\n+        })\n     }\n \n     fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {"}, {"sha": "419cf164db3b6600c23a43e2d48f8fb8713917a8", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=6dc3dae46f600efe75627a7ad386e7462066e34d", "patch": "@@ -465,14 +465,14 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> ty::Binder<'tcx, T> {\n+    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n         self.binders_passed += 1;\n-        let t = t.super_fold_with(self);\n+        let t = t.super_fold_with(self)?;\n         self.binders_passed -= 1;\n-        t\n+        Ok(t)\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         // Note: This routine only handles regions that are bound on\n         // type declarations and other outer declarations, not those\n         // bound in *fn types*. Region substitution of the bound\n@@ -482,7 +482,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n             ty::ReEarlyBound(data) => {\n                 let rk = self.substs.get(data.index as usize).map(|k| k.unpack());\n                 match rk {\n-                    Some(GenericArgKind::Lifetime(lt)) => self.shift_region_through_binders(lt),\n+                    Some(GenericArgKind::Lifetime(lt)) => Ok(self.shift_region_through_binders(lt)),\n                     _ => {\n                         let span = self.span.unwrap_or(DUMMY_SP);\n                         let msg = format!(\n@@ -494,31 +494,41 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                     }\n                 }\n             }\n-            _ => r,\n+            _ => Ok(r),\n         }\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         if !t.potentially_needs_subst() {\n-            return t;\n+            return Ok(t);\n         }\n \n         match *t.kind() {\n-            ty::Param(p) => self.ty_for_param(p, t),\n+            ty::Param(p) => Ok(self.ty_for_param(p, t)),\n             _ => t.super_fold_with(self),\n         }\n     }\n \n-    fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        c: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+        if !c.potentially_needs_subst() {\n+            return Ok(c);\n+        }\n+\n         if let ty::ConstKind::Param(p) = c.val {\n-            self.const_for_param(p, c)\n+            Ok(self.const_for_param(p, c))\n         } else {\n             c.super_fold_with(self)\n         }\n     }\n \n     #[inline]\n-    fn fold_mir_const(&mut self, c: mir::ConstantKind<'tcx>) -> mir::ConstantKind<'tcx> {\n+    fn fold_mir_const(\n+        &mut self,\n+        c: mir::ConstantKind<'tcx>,\n+    ) -> Result<mir::ConstantKind<'tcx>, Self::Error> {\n         c.super_fold_with(self)\n     }\n }"}, {"sha": "b90123b4cee827052e17c9a068b2c4a9d6a05de7", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=6dc3dae46f600efe75627a7ad386e7462066e34d", "patch": "@@ -605,13 +605,13 @@ impl<'tcx> TypeFolder<'tcx> for OpaqueTypeExpander<'tcx> {\n         self.tcx\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         if let ty::Opaque(def_id, substs) = t.kind {\n-            self.expand_opaque_ty(def_id, substs).unwrap_or(t)\n+            Ok(self.expand_opaque_ty(def_id, substs).unwrap_or(t))\n         } else if t.has_opaque_types() {\n             t.super_fold_with(self)\n         } else {\n-            t\n+            Ok(t)\n         }\n     }\n }\n@@ -1046,25 +1046,31 @@ pub fn fold_list<'tcx, F, T>(\n     list: &'tcx ty::List<T>,\n     folder: &mut F,\n     intern: impl FnOnce(TyCtxt<'tcx>, &[T]) -> &'tcx ty::List<T>,\n-) -> &'tcx ty::List<T>\n+) -> Result<&'tcx ty::List<T>, F::Error>\n where\n     F: TypeFolder<'tcx>,\n     T: TypeFoldable<'tcx> + PartialEq + Copy,\n {\n     let mut iter = list.iter();\n     // Look for the first element that changed\n-    if let Some((i, new_t)) = iter.by_ref().enumerate().find_map(|(i, t)| {\n-        let new_t = t.fold_with(folder);\n-        if new_t == t { None } else { Some((i, new_t)) }\n+    match iter.by_ref().enumerate().find_map(|(i, t)| match t.fold_with(folder) {\n+        Ok(new_t) if new_t == t => None,\n+        new_t => Some((i, new_t)),\n     }) {\n-        // An element changed, prepare to intern the resulting list\n-        let mut new_list = SmallVec::<[_; 8]>::with_capacity(list.len());\n-        new_list.extend_from_slice(&list[..i]);\n-        new_list.push(new_t);\n-        new_list.extend(iter.map(|t| t.fold_with(folder)));\n-        intern(folder.tcx(), &new_list)\n-    } else {\n-        list\n+        Some((i, Ok(new_t))) => {\n+            // An element changed, prepare to intern the resulting list\n+            let mut new_list = SmallVec::<[_; 8]>::with_capacity(list.len());\n+            new_list.extend_from_slice(&list[..i]);\n+            new_list.push(new_t);\n+            for t in iter {\n+                new_list.push(t.fold_with(folder)?)\n+            }\n+            Ok(intern(folder.tcx(), &new_list))\n+        }\n+        Some((_, Err(err))) => {\n+            return Err(err);\n+        }\n+        None => Ok(list),\n     }\n }\n "}, {"sha": "eb7293ae86e69e7c8fc664e69adc9970f841a250", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=6dc3dae46f600efe75627a7ad386e7462066e34d", "patch": "@@ -140,17 +140,17 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         match r {\n             // Ignore bound regions and `'static` regions that appear in the\n             // type, we only need to remap regions that reference lifetimes\n             // from the function declaraion.\n             // This would ignore `'r` in a type like `for<'r> fn(&'r u32)`.\n-            ty::ReLateBound(..) | ty::ReStatic => return r,\n+            ty::ReLateBound(..) | ty::ReStatic => return Ok(r),\n \n             // If regions have been erased (by writeback), don't try to unerase\n             // them.\n-            ty::ReErased => return r,\n+            ty::ReErased => return Ok(r),\n \n             // The regions that we expect from borrow checking.\n             ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReEmpty(ty::UniverseIndex::ROOT) => {}\n@@ -165,10 +165,10 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n \n         let generics = self.tcx().generics_of(self.opaque_type_def_id);\n         match self.map.get(&r.into()).map(|k| k.unpack()) {\n-            Some(GenericArgKind::Lifetime(r1)) => r1,\n+            Some(GenericArgKind::Lifetime(r1)) => Ok(r1),\n             Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n             None if self.map_missing_regions_to_empty || self.tainted_by_errors => {\n-                self.tcx.lifetimes.re_root_empty\n+                Ok(self.tcx.lifetimes.re_root_empty)\n             }\n             None if generics.parent.is_some() => {\n                 if let Some(hidden_ty) = self.hidden_ty.take() {\n@@ -180,7 +180,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                     )\n                     .emit();\n                 }\n-                self.tcx.lifetimes.re_root_empty\n+                Ok(self.tcx.lifetimes.re_root_empty)\n             }\n             None => {\n                 self.tcx\n@@ -196,12 +196,12 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                     )\n                     .emit();\n \n-                self.tcx().lifetimes.re_static\n+                Ok(self.tcx().lifetimes.re_static)\n             }\n         }\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         match *ty.kind() {\n             ty::Closure(def_id, substs) => {\n                 // I am a horrible monster and I pray for death. When\n@@ -239,7 +239,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                     }\n                 }));\n \n-                self.tcx.mk_closure(def_id, substs)\n+                Ok(self.tcx.mk_closure(def_id, substs))\n             }\n \n             ty::Generator(def_id, substs, movability) => {\n@@ -254,15 +254,15 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                     }\n                 }));\n \n-                self.tcx.mk_generator(def_id, substs, movability)\n+                Ok(self.tcx.mk_generator(def_id, substs, movability))\n             }\n \n             ty::Param(param) => {\n                 // Look it up in the substitution list.\n                 match self.map.get(&ty.into()).map(|k| k.unpack()) {\n                     // Found it in the substitution list; replace with the parameter from the\n                     // opaque type.\n-                    Some(GenericArgKind::Type(t1)) => t1,\n+                    Some(GenericArgKind::Type(t1)) => Ok(t1),\n                     Some(u) => panic!(\"type mapped to unexpected kind: {:?}\", u),\n                     None => {\n                         debug!(?param, ?self.map);\n@@ -278,7 +278,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                             )\n                             .emit();\n \n-                        self.tcx().ty_error()\n+                        Ok(self.tcx().ty_error())\n                     }\n                 }\n             }\n@@ -287,10 +287,13 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         trace!(\"checking const {:?}\", ct);\n         // Find a const parameter\n-        match ct.val {\n+        Ok(match ct.val {\n             ty::ConstKind::Param(..) => {\n                 // Look it up in the substitution list.\n                 match self.map.get(&ct.into()).map(|k| k.unpack()) {\n@@ -317,7 +320,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n             }\n \n             _ => ct,\n-        }\n+        })\n     }\n }\n "}, {"sha": "7af32b2f3b17462867835e27194859303f7aa1f0", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=6dc3dae46f600efe75627a7ad386e7462066e34d", "patch": "@@ -860,11 +860,11 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        (match r {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+        Ok((match r {\n             ty::ReVar(vid) => self.vid_to_region.get(vid).cloned(),\n             _ => None,\n         })\n-        .unwrap_or_else(|| r.super_fold_with(self))\n+        .unwrap_or_else(|| r.super_fold_with(self).into_ok()))\n     }\n }"}, {"sha": "1876b0ce80eedda2ca13cb22639b811993da5702", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=6dc3dae46f600efe75627a7ad386e7462066e34d", "patch": "@@ -1898,15 +1898,15 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.infcx.tcx\n             }\n \n-            fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+            fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n                 if let ty::Param(ty::ParamTy { name, .. }) = *ty.kind() {\n                     let infcx = self.infcx;\n-                    self.var_map.entry(ty).or_insert_with(|| {\n+                    Ok(self.var_map.entry(ty).or_insert_with(|| {\n                         infcx.next_ty_var(TypeVariableOrigin {\n                             kind: TypeVariableOriginKind::TypeParameterDefinition(name, None),\n                             span: DUMMY_SP,\n                         })\n-                    })\n+                    }))\n                 } else {\n                     ty.super_fold_with(self)\n                 }"}, {"sha": "2baa21a43d61d9a47795104a76be3b84413d8c03", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 58, "deletions": 46, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=6dc3dae46f600efe75627a7ad386e7462066e34d", "patch": "@@ -352,16 +352,16 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> ty::Binder<'tcx, T> {\n+    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n         self.universes.push(None);\n         let t = t.super_fold_with(self);\n         self.universes.pop();\n         t\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         if !needs_normalization(&ty, self.param_env.reveal()) {\n-            return ty;\n+            return Ok(ty);\n         }\n \n         // We try to be a little clever here as a performance optimization in\n@@ -387,14 +387,14 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n         // replace bound vars if the current type is a `Projection` and we need\n         // to make sure we don't forget to fold the substs regardless.\n \n-        match *ty.kind() {\n+        Ok(match *ty.kind() {\n             // This is really important. While we *can* handle this, this has\n             // severe performance implications for large opaque types with\n             // late-bound regions. See `issue-88862` benchmark.\n             ty::Opaque(def_id, substs) if !substs.has_escaping_bound_vars() => {\n                 // Only normalize `impl Trait` after type-checking, usually in codegen.\n                 match self.param_env.reveal() {\n-                    Reveal::UserFacing => ty.super_fold_with(self),\n+                    Reveal::UserFacing => ty.super_fold_with(self)?,\n \n                     Reveal::All => {\n                         let recursion_limit = self.tcx().recursion_limit();\n@@ -408,11 +408,11 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                             self.selcx.infcx().report_overflow_error(&obligation, true);\n                         }\n \n-                        let substs = substs.super_fold_with(self);\n+                        let substs = substs.super_fold_with(self)?;\n                         let generic_ty = self.tcx().type_of(def_id);\n                         let concrete_ty = generic_ty.subst(self.tcx(), substs);\n                         self.depth += 1;\n-                        let folded_ty = self.fold_ty(concrete_ty);\n+                        let folded_ty = self.fold_ty(concrete_ty)?;\n                         self.depth -= 1;\n                         folded_ty\n                     }\n@@ -426,7 +426,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 // register an obligation to *later* project, since we know\n                 // there won't be bound vars there.\n \n-                let data = data.super_fold_with(self);\n+                let data = data.super_fold_with(self)?;\n                 let normalized_ty = normalize_projection_type(\n                     self.selcx,\n                     self.param_env,\n@@ -461,7 +461,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 let infcx = self.selcx.infcx();\n                 let (data, mapped_regions, mapped_types, mapped_consts) =\n                     BoundVarReplacer::replace_bound_vars(infcx, &mut self.universes, data);\n-                let data = data.super_fold_with(self);\n+                let data = data.super_fold_with(self)?;\n                 let normalized_ty = opt_normalize_projection_type(\n                     self.selcx,\n                     self.param_env,\n@@ -473,16 +473,18 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 .ok()\n                 .flatten()\n                 .map(|normalized_ty| {\n-                    PlaceholderReplacer::replace_placeholders(\n-                        infcx,\n-                        mapped_regions,\n-                        mapped_types,\n-                        mapped_consts,\n-                        &self.universes,\n-                        normalized_ty,\n-                    )\n+                    Ok({\n+                        PlaceholderReplacer::replace_placeholders(\n+                            infcx,\n+                            mapped_regions,\n+                            mapped_types,\n+                            mapped_consts,\n+                            &self.universes,\n+                            normalized_ty,\n+                        )\n+                    })\n                 })\n-                .unwrap_or_else(|| ty.super_fold_with(self));\n+                .unwrap_or_else(|| ty.super_fold_with(self))?;\n \n                 debug!(\n                     ?self.depth,\n@@ -494,16 +496,19 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 normalized_ty\n             }\n \n-            _ => ty.super_fold_with(self),\n-        }\n+            _ => ty.super_fold_with(self)?,\n+        })\n     }\n \n-    fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        constant: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         if self.selcx.tcx().lazy_normalization() {\n-            constant\n+            Ok(constant)\n         } else {\n-            let constant = constant.super_fold_with(self);\n-            constant.eval(self.selcx.tcx(), self.param_env)\n+            let constant = constant.super_fold_with(self)?;\n+            Ok(constant.eval(self.selcx.tcx(), self.param_env))\n         }\n     }\n }\n@@ -577,14 +582,14 @@ impl TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> ty::Binder<'tcx, T> {\n+    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n         t\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         match *r {\n             ty::ReLateBound(debruijn, _)\n                 if debruijn.as_usize() + 1\n@@ -596,13 +601,13 @@ impl TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n                 let universe = self.universe_for(debruijn);\n                 let p = ty::PlaceholderRegion { universe, name: br.kind };\n                 self.mapped_regions.insert(p, br);\n-                self.infcx.tcx.mk_region(ty::RePlaceholder(p))\n+                Ok(self.infcx.tcx.mk_region(ty::RePlaceholder(p)))\n             }\n-            _ => r,\n+            _ => Ok(r),\n         }\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         match *t.kind() {\n             ty::Bound(debruijn, _)\n                 if debruijn.as_usize() + 1\n@@ -614,14 +619,17 @@ impl TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n                 let universe = self.universe_for(debruijn);\n                 let p = ty::PlaceholderType { universe, name: bound_ty.var };\n                 self.mapped_types.insert(p, bound_ty);\n-                self.infcx.tcx.mk_ty(ty::Placeholder(p))\n+                Ok(self.infcx.tcx.mk_ty(ty::Placeholder(p)))\n             }\n             _ if t.has_vars_bound_at_or_above(self.current_index) => t.super_fold_with(self),\n-            _ => t,\n+            _ => Ok(t),\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         match *ct {\n             ty::Const { val: ty::ConstKind::Bound(debruijn, _), ty: _ }\n                 if debruijn.as_usize() + 1\n@@ -638,10 +646,10 @@ impl TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n                     name: ty::BoundConst { var: bound_const, ty },\n                 };\n                 self.mapped_consts.insert(p, bound_const);\n-                self.infcx.tcx.mk_const(ty::Const { val: ty::ConstKind::Placeholder(p), ty })\n+                Ok(self.infcx.tcx.mk_const(ty::Const { val: ty::ConstKind::Placeholder(p), ty }))\n             }\n             _ if ct.has_vars_bound_at_or_above(self.current_index) => ct.super_fold_with(self),\n-            _ => ct,\n+            _ => Ok(ct),\n         }\n     }\n }\n@@ -685,17 +693,17 @@ impl TypeFolder<'tcx> for PlaceholderReplacer<'_, 'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> ty::Binder<'tcx, T> {\n+    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n         if !t.has_placeholders() && !t.has_infer_regions() {\n-            return t;\n+            return Ok(t);\n         }\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n         t\n     }\n \n-    fn fold_region(&mut self, r0: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r0: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         let r1 = match r0 {\n             ty::ReVar(_) => self\n                 .infcx\n@@ -729,10 +737,10 @@ impl TypeFolder<'tcx> for PlaceholderReplacer<'_, 'tcx> {\n \n         debug!(?r0, ?r1, ?r2, \"fold_region\");\n \n-        r2\n+        Ok(r2)\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         match *ty.kind() {\n             ty::Placeholder(p) => {\n                 let replace_var = self.mapped_types.get(&p);\n@@ -746,18 +754,21 @@ impl TypeFolder<'tcx> for PlaceholderReplacer<'_, 'tcx> {\n                         let db = ty::DebruijnIndex::from_usize(\n                             self.universe_indices.len() - index + self.current_index.as_usize() - 1,\n                         );\n-                        self.tcx().mk_ty(ty::Bound(db, *replace_var))\n+                        Ok(self.tcx().mk_ty(ty::Bound(db, *replace_var)))\n                     }\n-                    None => ty,\n+                    None => Ok(ty),\n                 }\n             }\n \n             _ if ty.has_placeholders() || ty.has_infer_regions() => ty.super_fold_with(self),\n-            _ => ty,\n+            _ => Ok(ty),\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         if let ty::Const { val: ty::ConstKind::Placeholder(p), ty } = *ct {\n             let replace_var = self.mapped_consts.get(&p);\n             match replace_var {\n@@ -770,10 +781,11 @@ impl TypeFolder<'tcx> for PlaceholderReplacer<'_, 'tcx> {\n                     let db = ty::DebruijnIndex::from_usize(\n                         self.universe_indices.len() - index + self.current_index.as_usize() - 1,\n                     );\n-                    self.tcx()\n-                        .mk_const(ty::Const { val: ty::ConstKind::Bound(db, *replace_var), ty })\n+                    Ok(self\n+                        .tcx()\n+                        .mk_const(ty::Const { val: ty::ConstKind::Bound(db, *replace_var), ty }))\n                 }\n-                None => ct,\n+                None => Ok(ct),\n             }\n         } else {\n             ct.super_fold_with(self)"}, {"sha": "f3a90935a9fdf1496720f6366d20976535dfa151", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=6dc3dae46f600efe75627a7ad386e7462066e34d", "patch": "@@ -184,21 +184,21 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> ty::Binder<'tcx, T> {\n+    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n         self.universes.push(None);\n         let t = t.super_fold_with(self);\n         self.universes.pop();\n         t\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         if !needs_normalization(&ty, self.param_env.reveal()) {\n-            return ty;\n+            return Ok(ty);\n         }\n \n         if let Some(ty) = self.cache.get(&ty) {\n-            return ty;\n+            return Ok(ty);\n         }\n \n         // See note in `rustc_trait_selection::traits::project` about why we\n@@ -215,7 +215,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                     Reveal::UserFacing => ty.super_fold_with(self),\n \n                     Reveal::All => {\n-                        let substs = substs.super_fold_with(self);\n+                        let substs = substs.super_fold_with(self)?;\n                         let recursion_limit = self.tcx().recursion_limit();\n                         if !recursion_limit.value_within_limit(self.anon_depth) {\n                             let obligation = Obligation::with_depth(\n@@ -252,7 +252,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                 // we don't need to replace them with placeholders (see branch below).\n \n                 let tcx = self.infcx.tcx;\n-                let data = data.super_fold_with(self);\n+                let data = data.super_fold_with(self)?;\n \n                 let mut orig_values = OriginalQueryValues::default();\n                 // HACK(matthewjasper) `'static` is special-cased in selection,\n@@ -280,7 +280,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                                 debug!(\"QueryNormalizer: result = {:#?}\", result);\n                                 debug!(\"QueryNormalizer: obligations = {:#?}\", obligations);\n                                 self.obligations.extend(obligations);\n-                                result.normalized_ty\n+                                Ok(result.normalized_ty)\n                             }\n \n                             Err(_) => {\n@@ -308,7 +308,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                         &mut self.universes,\n                         data,\n                     );\n-                let data = data.super_fold_with(self);\n+                let data = data.super_fold_with(self)?;\n \n                 let mut orig_values = OriginalQueryValues::default();\n                 // HACK(matthewjasper) `'static` is special-cased in selection,\n@@ -335,14 +335,14 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                                 debug!(\"QueryNormalizer: result = {:#?}\", result);\n                                 debug!(\"QueryNormalizer: obligations = {:#?}\", obligations);\n                                 self.obligations.extend(obligations);\n-                                crate::traits::project::PlaceholderReplacer::replace_placeholders(\n+                                Ok(crate::traits::project::PlaceholderReplacer::replace_placeholders(\n                                     infcx,\n                                     mapped_regions,\n                                     mapped_types,\n                                     mapped_consts,\n                                     &self.universes,\n                                     result.normalized_ty,\n-                                )\n+                                ))\n                             }\n                             Err(_) => {\n                                 self.error = true;\n@@ -358,17 +358,23 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n             }\n \n             _ => ty.super_fold_with(self),\n-        })();\n+        })()?;\n         self.cache.insert(ty, res);\n-        res\n+        Ok(res)\n     }\n \n-    fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        let constant = constant.super_fold_with(self);\n-        constant.eval(self.infcx.tcx, self.param_env)\n+    fn fold_const(\n+        &mut self,\n+        constant: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+        let constant = constant.super_fold_with(self)?;\n+        Ok(constant.eval(self.infcx.tcx, self.param_env))\n     }\n \n-    fn fold_mir_const(&mut self, constant: mir::ConstantKind<'tcx>) -> mir::ConstantKind<'tcx> {\n+    fn fold_mir_const(\n+        &mut self,\n+        constant: mir::ConstantKind<'tcx>,\n+    ) -> Result<mir::ConstantKind<'tcx>, Self::Error> {\n         constant.super_fold_with(self)\n     }\n }"}, {"sha": "033a94658425bf1abe9624197d7d5eb5f83c5b3a", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=6dc3dae46f600efe75627a7ad386e7462066e34d", "patch": "@@ -943,20 +943,23 @@ impl<'a, 'tcx> TypeFolder<'tcx> for NamedBoundVarSubstitutor<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: Binder<'tcx, T>) -> Binder<'tcx, T> {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: Binder<'tcx, T>,\n+    ) -> Result<Binder<'tcx, T>, Self::Error> {\n         self.binder_index.shift_in(1);\n         let result = t.super_fold_with(self);\n         self.binder_index.shift_out(1);\n         result\n     }\n \n-    fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n+    fn fold_region(&mut self, r: Region<'tcx>) -> Result<Region<'tcx>, Self::Error> {\n         match r {\n             ty::ReLateBound(index, br) if *index == self.binder_index => match br.kind {\n                 ty::BrNamed(def_id, _name) => match self.named_parameters.get(&def_id) {\n                     Some(idx) => {\n                         let new_br = ty::BoundRegion { var: br.var, kind: ty::BrAnon(*idx) };\n-                        return self.tcx.mk_region(RegionKind::ReLateBound(*index, new_br));\n+                        return Ok(self.tcx.mk_region(RegionKind::ReLateBound(*index, new_br)));\n                     }\n                     None => panic!(\"Missing `BrNamed`.\"),\n                 },\n@@ -999,40 +1002,43 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: Binder<'tcx, T>) -> Binder<'tcx, T> {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: Binder<'tcx, T>,\n+    ) -> Result<Binder<'tcx, T>, Self::Error> {\n         self.binder_index.shift_in(1);\n         let result = t.super_fold_with(self);\n         self.binder_index.shift_out(1);\n         result\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         match *t.kind() {\n             // FIXME(chalk): currently we convert params to placeholders starting at\n             // index `0`. To support placeholders, we'll actually need to do a\n             // first pass to collect placeholders. Then we can insert params after.\n             ty::Placeholder(_) => unimplemented!(),\n             ty::Param(param) => match self.list.iter().position(|r| r == &param) {\n-                Some(idx) => self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n+                Some(idx) => Ok(self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n                     universe: ty::UniverseIndex::from_usize(0),\n                     name: ty::BoundVar::from_usize(idx),\n-                })),\n+                }))),\n                 None => {\n                     self.list.push(param);\n                     let idx = self.list.len() - 1 + self.next_ty_placeholder;\n                     self.params.insert(idx, param);\n-                    self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n+                    Ok(self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n                         universe: ty::UniverseIndex::from_usize(0),\n                         name: ty::BoundVar::from_usize(idx),\n-                    }))\n+                    })))\n                 }\n             },\n \n             _ => t.super_fold_with(self),\n         }\n     }\n \n-    fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n+    fn fold_region(&mut self, r: Region<'tcx>) -> Result<Region<'tcx>, Self::Error> {\n         match r {\n             // FIXME(chalk) - jackh726 - this currently isn't hit in any tests.\n             // This covers any region variables in a goal, right?\n@@ -1042,14 +1048,14 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n                         var: ty::BoundVar::from_u32(*idx),\n                         kind: ty::BrAnon(*idx),\n                     };\n-                    self.tcx.mk_region(RegionKind::ReLateBound(self.binder_index, br))\n+                    Ok(self.tcx.mk_region(RegionKind::ReLateBound(self.binder_index, br)))\n                 }\n                 None => {\n                     let idx = self.named_regions.len() as u32;\n                     let br =\n                         ty::BoundRegion { var: ty::BoundVar::from_u32(idx), kind: ty::BrAnon(idx) };\n                     self.named_regions.insert(_re.def_id, idx);\n-                    self.tcx.mk_region(RegionKind::ReLateBound(self.binder_index, br))\n+                    Ok(self.tcx.mk_region(RegionKind::ReLateBound(self.binder_index, br)))\n                 }\n             },\n \n@@ -1125,11 +1131,11 @@ impl<'tcx> TypeFolder<'tcx> for RegionsSubstitutor<'tcx> {\n         self.tcx\n     }\n \n-    fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n+    fn fold_region(&mut self, r: Region<'tcx>) -> Result<Region<'tcx>, Self::Error> {\n         match r {\n             ty::ReEmpty(ui) => {\n                 assert_eq!(ui.as_usize(), 0);\n-                self.reempty_placeholder\n+                Ok(self.reempty_placeholder)\n             }\n \n             _ => r.super_fold_with(self),"}, {"sha": "8f852c0b51c9870b9ba1a8f8df4c280e67810daa", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=6dc3dae46f600efe75627a7ad386e7462066e34d", "patch": "@@ -1015,12 +1015,12 @@ impl TypeFolder<'tcx> for TypeParamEraser<'_, 'tcx> {\n         self.0.tcx\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         match ty.kind() {\n-            ty::Param(_) => self.0.next_ty_var(TypeVariableOrigin {\n+            ty::Param(_) => Ok(self.0.next_ty_var(TypeVariableOrigin {\n                 kind: TypeVariableOriginKind::MiscVariable,\n                 span: self.1,\n-            }),\n+            })),\n             _ => ty.super_fold_with(self),\n         }\n     }"}, {"sha": "ecf0332db7b8bcf49994a86d82b7fd609dd75a62", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=6dc3dae46f600efe75627a7ad386e7462066e34d", "patch": "@@ -749,15 +749,15 @@ impl<'tcx> TypeFolder<'tcx> for EraseEarlyRegions<'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         if ty.has_type_flags(ty::TypeFlags::HAS_POTENTIAL_FREE_REGIONS) {\n             ty.super_fold_with(self)\n         } else {\n-            ty\n+            Ok(ty)\n         }\n     }\n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        if let ty::ReLateBound(..) = r { r } else { self.tcx.lifetimes.re_erased }\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+        Ok(if let ty::ReLateBound(..) = r { r } else { self.tcx.lifetimes.re_erased })\n     }\n }\n \n@@ -766,7 +766,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         match self.infcx.fully_resolve(t) {\n             Ok(t) => {\n                 // Do not anonymize late-bound regions\n@@ -779,26 +779,29 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n                 debug!(\"Resolver::fold_ty: input type `{:?}` not fully resolvable\", t);\n                 self.report_type_error(t);\n                 self.replaced_with_error = true;\n-                self.tcx().ty_error()\n+                Ok(self.tcx().ty_error())\n             }\n         }\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         debug_assert!(!r.is_late_bound(), \"Should not be resolving bound region.\");\n-        self.tcx.lifetimes.re_erased\n+        Ok(self.tcx.lifetimes.re_erased)\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        match self.infcx.fully_resolve(ct) {\n+    fn fold_const(\n+        &mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+        Ok(match self.infcx.fully_resolve(ct) {\n             Ok(ct) => self.infcx.tcx.erase_regions(ct),\n             Err(_) => {\n                 debug!(\"Resolver::fold_const: input const `{:?}` not fully resolvable\", ct);\n                 self.report_const_error(ct);\n                 self.replaced_with_error = true;\n                 self.tcx().const_error(ct.ty)\n             }\n-        }\n+        })\n     }\n }\n "}, {"sha": "1dce63416dc96cad2f4374a02f9236e2b027df50", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=6dc3dae46f600efe75627a7ad386e7462066e34d", "patch": "@@ -729,17 +729,17 @@ fn infer_placeholder_type<'a>(\n             self.tcx\n         }\n \n-        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n             if !self.success {\n-                return ty;\n+                return Ok(ty);\n             }\n \n             match ty.kind() {\n-                ty::FnDef(def_id, _) => self.tcx.mk_fn_ptr(self.tcx.fn_sig(*def_id)),\n+                ty::FnDef(def_id, _) => Ok(self.tcx.mk_fn_ptr(self.tcx.fn_sig(*def_id))),\n                 // FIXME: non-capturing closures should also suggest a function pointer\n                 ty::Closure(..) | ty::Generator(..) => {\n                     self.success = false;\n-                    ty\n+                    Ok(ty)\n                 }\n                 _ => ty.super_fold_with(self),\n             }"}, {"sha": "5c229c86ddc1aa25aba102715684f75f27e33ee6", "filename": "compiler/rustc_typeck/src/hir_wf_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc3dae46f600efe75627a7ad386e7462066e34d/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs?ref=6dc3dae46f600efe75627a7ad386e7462066e34d", "patch": "@@ -183,7 +183,7 @@ impl<'tcx> TypeFolder<'tcx> for EraseAllBoundRegions<'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n-    fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n-        if let ty::ReLateBound(..) = r { &ty::ReErased } else { r }\n+    fn fold_region(&mut self, r: Region<'tcx>) -> Result<Region<'tcx>, Self::Error> {\n+        if let ty::ReLateBound(..) = r { Ok(&ty::ReErased) } else { Ok(r) }\n     }\n }"}, {"sha": "3a6f611660ece9706920e0d26c5f7bdef25828f3", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6dc3dae46f600efe75627a7ad386e7462066e34d/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc3dae46f600efe75627a7ad386e7462066e34d/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=6dc3dae46f600efe75627a7ad386e7462066e34d", "patch": "@@ -714,11 +714,11 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        (match *r {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+        Ok((match *r {\n             ty::ReVar(vid) => self.vid_to_region.get(&vid).cloned(),\n             _ => None,\n         })\n-        .unwrap_or_else(|| r.super_fold_with(self))\n+        .unwrap_or_else(|| r.super_fold_with(self).into_ok()))\n     }\n }"}]}