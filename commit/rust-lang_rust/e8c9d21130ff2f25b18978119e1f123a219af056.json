{"sha": "e8c9d21130ff2f25b18978119e1f123a219af056", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4YzlkMjExMzBmZjJmMjViMTg5NzgxMTllMWYxMjNhMjE5YWYwNTY=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-07-15T20:21:51Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-21T16:54:03Z"}, "message": "Guessing game explanation\n\nWe now build the game at the end of the first section.\n\nI wanted to do it as we went along, but it's too hard with these fundamentals\nnot in place. The rest will do the 'as we go' approach, but I think this is\nbetter.", "tree": {"sha": "b7c35a4b0152b0eb393a841fb3d19d2cc0ce9811", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7c35a4b0152b0eb393a841fb3d19d2cc0ce9811"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8c9d21130ff2f25b18978119e1f123a219af056", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8c9d21130ff2f25b18978119e1f123a219af056", "html_url": "https://github.com/rust-lang/rust/commit/e8c9d21130ff2f25b18978119e1f123a219af056", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8c9d21130ff2f25b18978119e1f123a219af056/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fca79e472689bb7f580a947e9268f4cabc2d298d", "url": "https://api.github.com/repos/rust-lang/rust/commits/fca79e472689bb7f580a947e9268f4cabc2d298d", "html_url": "https://github.com/rust-lang/rust/commit/fca79e472689bb7f580a947e9268f4cabc2d298d"}], "stats": {"total": 949, "additions": 879, "deletions": 70}, "files": [{"sha": "e3acb0575d226c07c47fe089742d3cb48da17db7", "filename": "src/doc/guide.md", "status": "modified", "additions": 879, "deletions": 70, "changes": 949, "blob_url": "https://github.com/rust-lang/rust/blob/e8c9d21130ff2f25b18978119e1f123a219af056/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/e8c9d21130ff2f25b18978119e1f123a219af056/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=e8c9d21130ff2f25b18978119e1f123a219af056", "patch": "@@ -18,8 +18,9 @@ something special, and we hope you do too.\n \n To show you how to get going with Rust, we're going to write the traditional\n \"Hello, World!\" program. Next, we'll introduce you to a tool that's useful for\n-writing real-world Rust programs and libraries: \"Cargo.\" Then, we'll show off\n-Rust's features by writing a little program together.\n+writing real-world Rust programs and libraries: \"Cargo.\" After that, we'll talk\n+about the basics of Rust, write a little program to try them out, and then learn\n+more advanced things.\n \n Sound good? Let's go!\n \n@@ -357,70 +358,9 @@ That's it! We've successfully built `hello_world` with Cargo. Even though our\n program is simple, it's using much of the real tooling that you'll use for the\n rest of your Rust career.\n \n-Next, we'll learn more about Rust itself, by starting to write a more complicated\n-program. We hope you want to do more with Rust than just print \"Hello, world!\"\n-\n-## Guessing Game\n-\n-Let's write a bigger program in Rust. We could just go through a laundry list\n-of Rust features, but that's boring. Instead, we'll learn more about how to\n-code in Rust by writing a few example projects.\n-\n-For our first project, we'll implement a classic beginner programming problem:\n-the guessing game. Here's how it works: Our program will generate a random\n-integer between one and a hundred. It will then prompt us to enter a guess.\n-Upon entering our guess, it will tell us if we're too low or too high. Once we\n-guess correctly, it will congratulate us, and print the number of guesses we've\n-taken to the screen. Sound good? It sounds easy, but it'll end up showing off a\n-number of basic features of Rust.\n-\n-### Set up\n-\n-Let's set up a new project. Go to your projects directory, and make a new\n-directory for the project, as well as a `src` directory for our code:\n-\n-```{bash}\n-$ cd ~/projects\n-$ mkdir guessing_game\n-$ cd guessing_game\n-$ mkdir src\n-```\n-\n-Great. Next, let's make a `Cargo.toml` file so Cargo knows how to build our\n-project:\n-\n-```{ignore}\n-[package]\n-\n-name = \"guessing_game\"\n-version = \"0.1.0\"\n-authors = [ \"someone@example.com\" ]\n-\n-[[bin]]\n-\n-name = \"guessing_game\"\n-```\n-\n-Finally, we need our source file. Let's just make it hello world for now, so we\n-can check that our setup works. In `src/guessing_game.rs`:\n-\n-```{rust}\n-fn main() {\n-    println!(\"Hello world!\");\n-}\n-```\n-\n-Let's make sure that worked:\n-\n-```{bash}\n-$ cargo build\n-   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n-$\n-```\n-\n-Excellent! Open up your `src/guessing_game.rs` again. We'll be writing all of\n-our code in this file. The next section of the tutorial will show you how to\n-build multiple-file projects.\n+Now that you've got the tools down, let's actually learn more about the Rust\n+language itself. These are the basics that will serve you well through the rest\n+of your time with Rust.\n \n ## Variable bindings\n \n@@ -1493,6 +1433,8 @@ we haven't seen before. Here's a simple program that reads some input,\n and then prints it back out:\n \n ```{rust,ignore}\n+use std::io;\n+\n fn main() {\n     println!(\"Type something!\");\n \n@@ -1504,7 +1446,7 @@ fn main() {\n \n Let's go over these chunks, one by one:\n \n-```{rust}\n+```{rust,ignore}\n std::io::stdin();\n ```\n \n@@ -1644,11 +1586,878 @@ here.\n That's all you need to get basic input from the standard input! It's not too\n complicated, but there are a number of small parts.\n \n-## Guessing Game: complete\n+## Guessing Game\n+\n+Okay! We've got the basics of Rust down. Let's write a bigger program.\n+\n+For our first project, we'll implement a classic beginner programming problem:\n+the guessing game. Here's how it works: Our program will generate a random\n+integer between one and a hundred. It will then prompt us to enter a guess.\n+Upon entering our guess, it will tell us if we're too low or too high. Once we\n+guess correctly, it will congratulate us, and print the number of guesses we've\n+taken to the screen. Sound good?\n+\n+### Set up\n+\n+Let's set up a new project. Go to your projects directory, and make a new\n+directory for the project, as well as a `src` directory for our code:\n+\n+```{bash}\n+$ cd ~/projects\n+$ mkdir guessing_game\n+$ cd guessing_game\n+$ mkdir src\n+```\n+\n+Great. Next, let's make a `Cargo.toml` file so Cargo knows how to build our\n+project:\n+\n+```{ignore}\n+[package]\n+\n+name = \"guessing_game\"\n+version = \"0.1.0\"\n+authors = [ \"someone@example.com\" ]\n+\n+[[bin]]\n+\n+name = \"guessing_game\"\n+```\n+\n+Finally, we need our source file. Let's just make it hello world for now, so we\n+can check that our setup works. In `src/guessing_game.rs`:\n+\n+```{rust}\n+fn main() {\n+    println!(\"Hello world!\");\n+}\n+```\n+\n+Let's make sure that worked:\n+\n+```{bash}\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n+$\n+```\n+\n+Excellent! Open up your `src/guessing_game.rs` again. We'll be writing all of\n+our code in this file. We'll talk about multiple-file projects later on in the\n+guide.\n+\n+### Processing a Guess\n+\n+Let's get to it! The first thing we need to do for our guessing game is\n+allow our player to input a guess. Put this in your `src/guessing_game.rs`:\n+\n+```{rust,no_run}\n+use std::io;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+\n+    println!(\"You guessed: {}\", input);\n+}\n+```\n+\n+You've seen this code before, when we talked about standard input. We\n+import the `std::io` module with `use`, and then our `main` function contains\n+our program's logic. We print a little message announcing the game, ask the\n+user to input a guess, get their input, and then print it out.\n+\n+Because we talked about this in the section on standard I/O, I won't go into\n+more details here. If you need a refresher, go re-read that section.\n+\n+### Generating a secret number\n+\n+Next, we need to generate a secret number. To do that, we need to use Rust's\n+random number generation, which we haven't talked about yet. Rust includes a\n+bunch of interesting functions in its standard library. If you need a bit of\n+code, it's possible that it's already been written for you! In this case,\n+we do know that Rust has random number generation, but we don't know how to\n+use it.\n+\n+Enter the docs. Rust has a page specifically to document the standard library.\n+You can find that page [here](std/index.html). There's a lot of information on\n+that page, but the best part is the search bar. Right up at the top, there's\n+a box that you can enter in a search term. The search is pretty primitive\n+right now, but is getting better all the time. If you type 'random' in that\n+box, the page will update to [this\n+one](http://doc.rust-lang.org/std/index.html?search=random). The very first\n+result is a link to\n+[std::rand::random](http://doc.rust-lang.org/std/rand/fn.random.html). If we\n+click on that result, we'll be taken to its documentation page.\n+\n+This page shows us a few things: the type signature of the function, some\n+explanatory text, and then an example. Let's modify our code to add in the\n+`random` function:\n+\n+```{rust,ignore}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random() % 100i) + 1i;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+\n+\n+    println!(\"You guessed: {}\", input);\n+}\n+```\n+\n+The first thing we changed was to `use std::rand`, as the docs\n+explained.  We then added in a `let` expression to create a variable binding\n+named `secret_number`, and we printed out its result. Let's try to compile\n+this using `cargo build`:\n+\n+```{notrust,no_run}\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n+src/guessing_game.rs:7:26: 7:34 error: the type of this value must be known in this context\n+src/guessing_game.rs:7     let secret_number = (rand::random() % 100i) + 1i;\n+                                                ^~~~~~~~\n+error: aborting due to previous error\n+```\n+\n+It didn't work! Rust says \"the type of this value must be known in this\n+context.\" What's up with that? Well, as it turns out, `rand::random()` can\n+generate many kinds of random values, not just integers. And in this case, Rust\n+isn't sure what kind of value `random()` should generate. So we have to help\n+it. With number literals, we just add an `i` onto the end to tell Rust they're\n+integers, but that does not work with functions. There's a different syntax,\n+and it looks like this:\n+\n+```{rust,ignore}\n+rand::random::<int>();\n+```\n+\n+This says \"please give me a random `int` value.\" We can change our code to use\n+this hint...\n+\n+```{rust,no_run}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<int>() % 100i) + 1i;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+\n+\n+    println!(\"You guessed: {}\", input);\n+}\n+```\n+\n+... and then recompile:\n+\n+```{notrust,ignore}\n+$ cargo build\n+  Compiling guessing_game v0.1.0 (file:/home/steve/tmp/guessing_game)\n+$\n+```\n+\n+Excellent! Try running our new program a few times:\n+\n+```{notrust,ignore}\n+$ ./target/guessing_game \n+Guess the number!\n+The secret number is: 7\n+Please input your guess.\n+4\n+You guessed: 4\n+$ ./target/guessing_game \n+Guess the number!\n+The secret number is: 83\n+Please input your guess.\n+5\n+You guessed: 5\n+$ ./target/guessing_game \n+Guess the number!\n+The secret number is: -29\n+Please input your guess.\n+42\n+You guessed: 42\n+```\n+\n+Wait. Negative 29? We wanted a number between one and a hundred! We have two\n+options here: we can either ask `random()` to generate an unsigned integer, which\n+can only be positive, or we can use the `abs()` function. Let's go with the\n+unsigned integer approach. If we want a random positive number, we should ask for\n+a random positive number. Our code looks like this now:\n+\n+```{rust,no_run}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+\n+\n+    println!(\"You guessed: {}\", input);\n+}\n+```\n+\n+And trying it out:\n+\n+```{notrust,ignore}\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n+$ ./target/guessing_game \n+Guess the number!\n+The secret number is: 57\n+Please input your guess.\n+3\n+You guessed: 3\n+```\n+\n+Great! Next up: let's compare our guess to the secret guess.\n+\n+### Comparing guesses\n+\n+If you remember, earlier in the tutorial, we made a `cmp` function that compared\n+two numbers. Let's add that in, along with a `match` statement to compare the\n+guess to the secret guess:\n+\n+```{rust,ignore}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+\n+\n+    println!(\"You guessed: {}\", input);\n+\n+    match cmp(input, secret_number) { \n+        Less    => println!(\"Too small!\"),\n+        Greater => println!(\"Too big!\"),\n+        Equal   => { println!(\"You win!\"); },\n+    }\n+}\n+\n+fn cmp(a: int, b: int) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n+}\n+```\n+\n+If we try to compile, we'll get some errors:\n+\n+```{notrust,ignore}\n+$ cargo build\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n+src/guessing_game.rs:20:15: 20:20 error: mismatched types: expected `int` but found `collections::string::String` (expected int but found struct collections::string::String)\n+src/guessing_game.rs:20     match cmp(input, secret_number) {\n+                                      ^~~~~\n+src/guessing_game.rs:20:22: 20:35 error: mismatched types: expected `int` but found `uint` (expected int but found uint)\n+src/guessing_game.rs:20     match cmp(input, secret_number) {\n+                                             ^~~~~~~~~~~~~\n+error: aborting due to 2 previous errors\n+```\n+\n+This often happens when writing Rust programs, and is one of Rust's greatest\n+strengths. You try out some code, see if it compiles, and Rust tells you that\n+you've done something wrong. In this case, our `cmp` function works on integers,\n+but we've given it unsigned integers. In this case, the fix is easy, because\n+we wrote the `cmp` function! Let's change it to take `uint`s:\n+\n+```{rust,ignore}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+\n+\n+    println!(\"You guessed: {}\", input);\n+\n+    match cmp(input, secret_number) {\n+        Less    => println!(\"Too small!\"),\n+        Greater => println!(\"Too big!\"),\n+        Equal   => { println!(\"You win!\"); },\n+    }\n+}\n+\n+fn cmp(a: uint, b: uint) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n+}\n+```\n+\n+And try compiling again:\n+\n+```{notrust,ignore}\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n+src/guessing_game.rs:20:15: 20:20 error: mismatched types: expected `uint` but found `collections::string::String` (expected uint but found struct collections::string::String)\n+src/guessing_game.rs:20     match cmp(input, secret_number) {\n+                                      ^~~~~\n+error: aborting due to previous error\n+```\n+\n+This error is similar to the last one: we expected to get a `uint`, but we got\n+a `String` instead! That's because our `input` variable is coming from the\n+standard input, and you can guess anything. Try it:\n+\n+```{notrust,ignore}\n+$ ./target/guessing_game \n+Guess the number!\n+The secret number is: 73\n+Please input your guess.\n+hello\n+You guessed: hello\n+```\n+\n+Oops! Also, you'll note that we just ran our program even though it didn't compile.\n+This works because the older version we did successfully compile was still lying\n+around. Gotta be careful!\n+\n+Anyway, we have a `String`, but we need a `uint`. What to do? Well, there's\n+a function for that:\n+\n+```{rust,ignore}\n+let input = io::stdin().read_line()\n+                       .ok()\n+                       .expect(\"Failed to read line\");\n+let guess: Option<uint> = from_str(input.as_slice());\n+```\n+\n+The `from_str` function takes in a `&str` value and converts it into something.\n+We tell it what kind of something with a type hint. Remember our type hint with\n+`random()`? It looked like this:\n+\n+```{rust,ignore}\n+rand::random::<uint>();\n+```\n+\n+There's an alternate way of providing a hint too, and that's declaring the type\n+in a `let`:\n+\n+```{rust,ignore}\n+let x: uint = rand::random();\n+```\n+\n+In this case, we say `x` is a `uint` explicitly, so Rust is able to properly\n+tell `random()` what to generate. In a similar fashion, both of these work:\n+\n+```{rust,ignore}\n+let guess = from_str::<Option<uint>>(\"5\");\n+let guess: Option<uint> = from_str(\"5\");\n+```\n+\n+In this case, I happen to prefer the latter, and in the `random()` case, I prefer\n+the former. I think the nested `<>`s make the first option especially ugly and\n+a bit harder to read.\n+\n+Anyway, with us now convering our input to a number, our code looks like this:\n+\n+```{rust,ignore}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+    let input_num: Option<uint> = from_str(input.as_slice());\n+\n+\n+\n+    println!(\"You guessed: {}\", input_num);\n+\n+    match cmp(input_num, secret_number) {\n+        Less    => println!(\"Too small!\"),\n+        Greater => println!(\"Too big!\"),\n+        Equal   => { println!(\"You win!\"); },\n+    }\n+}\n+\n+fn cmp(a: uint, b: uint) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n+}\n+```\n+\n+Let's try it out!\n+\n+```{notrust,ignore}\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:/home/steve/tmp/guessing_game)\n+src/guessing_game.rs:22:15: 22:24 error: mismatched types: expected `uint` but found `core::option::Option<uint>` (expected uint but found enum core::option::Option)\n+src/guessing_game.rs:22     match cmp(input_num, secret_number) {\n+                                      ^~~~~~~~~\n+error: aborting due to previous error\n+```\n+\n+Oh yeah! Our `input_num` has the type `Option<uint>`, rather than `uint`. We\n+need to unwrap the Option. If you remember from before, `match` is a great way\n+to do that. Try this code:\n+\n+```{rust,no_run}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+    let input_num: Option<uint> = from_str(input.as_slice());\n+\n+    let num = match input_num {\n+        Some(num) => num,\n+        None      => {\n+            println!(\"Please input a number!\");\n+            return;\n+        }\n+    };\n+\n+\n+    println!(\"You guessed: {}\", num);\n+\n+    match cmp(num, secret_number) {\n+        Less    => println!(\"Too small!\"),\n+        Greater => println!(\"Too big!\"),\n+        Equal   => { println!(\"You win!\"); },\n+    }\n+}\n+\n+fn cmp(a: uint, b: uint) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n+}\n+```\n+\n+We use a `match` to either give us the `uint` inside of the `Option`, or we\n+print an error message and return. Let's give this a shot:\n+\n+```{notrust,ignore}\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n+$ ./target/guessing_game \n+Guess the number!\n+The secret number is: 17\n+Please input your guess.\n+5\n+Please input a number!\n+$\n+```\n+\n+Uh, what? But we did!\n+\n+... actually, we didn't. See, when you get a line of input from `stdin()`,\n+you get all the input. Including the `\\n` character from you pressing Enter.\n+So, `from_str()` sees the string `\"5\\n\"` and says \"nope, that's not a number,\n+there's non-number stuff in there!\" Luckily for us, `&str`s have an easy\n+method we can use defined on them: `trim()`. One small modification, and our\n+code looks like this:\n+\n+```{rust,no_run}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+    let input_num: Option<uint> = from_str(input.as_slice().trim());\n+\n+    let num = match input_num {\n+        Some(num) => num,\n+        None      => {\n+            println!(\"Please input a number!\");\n+            return;\n+        }\n+    };\n+\n+\n+    println!(\"You guessed: {}\", num);\n+\n+    match cmp(num, secret_number) {\n+        Less    => println!(\"Too small!\"),\n+        Greater => println!(\"Too big!\"),\n+        Equal   => { println!(\"You win!\"); },\n+    }\n+}\n+\n+fn cmp(a: uint, b: uint) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n+}\n+```\n+\n+Let's try it!\n+\n+```{notrust,ignore}\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n+$ ./target/guessing_game \n+Guess the number!\n+The secret number is: 58\n+Please input your guess.\n+  76  \n+You guessed: 76\n+Too big!\n+$\n+```\n+\n+Nice! You can see I even added spaces before my guess, and it still figured\n+out that I guessed 76. Run the program a few times, and verify that guessing\n+the number works, as well as guessing a number too small.\n+\n+The Rust compiler helped us out quite a bit there! This technique is called\n+\"lean on the compiler,\" and it's often useful when working on some code. Let\n+the error messages help guide you towards the correct types.\n+\n+Now we've got most of the game working, but we can only make one guess. Let's\n+change that by adding loops!\n+\n+### Looping\n+\n+As we already discussed, the `loop` key word gives us an infinite loop. So\n+let's add that in:\n+\n+```{rust,no_run}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    loop {\n+\n+        println!(\"Please input your guess.\");\n+\n+        let input = io::stdin().read_line()\n+                               .ok()\n+                               .expect(\"Failed to read line\");\n+        let input_num: Option<uint> = from_str(input.as_slice().trim());\n+\n+        let num = match input_num {\n+            Some(num) => num,\n+            None      => {\n+                println!(\"Please input a number!\");\n+                return;\n+            }\n+        };\n+\n+\n+        println!(\"You guessed: {}\", num);\n+\n+        match cmp(num, secret_number) {\n+            Less    => println!(\"Too small!\"),\n+            Greater => println!(\"Too big!\"),\n+            Equal   => { println!(\"You win!\"); },\n+        }\n+    }\n+}\n+\n+fn cmp(a: uint, b: uint) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n+}\n+```\n+\n+And try it out. But wait, didn't we just add an infinite loop? Yup. Remember\n+that `return`? If we give a non-number answer, we'll `return` and quit. Observe:\n+\n+```{notrust,ignore}\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n+steve@computer:~/tmp/guessing_game$ ./target/guessing_game \n+Guess the number!\n+The secret number is: 59\n+Please input your guess.\n+45\n+You guessed: 45\n+Too small!\n+Please input your guess.\n+60\n+You guessed: 60\n+Too big!\n+Please input your guess.\n+59\n+You guessed: 59\n+You win!\n+Please input your guess.\n+quit\n+Please input a number!\n+$\n+```\n+\n+Ha! `quit` actually quits. As does any other non-number input. Well, this is\n+suboptimal to say the least. First, let's actually quit when you win the game:\n+\n+```{rust,no_run}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    loop {\n+\n+        println!(\"Please input your guess.\");\n+\n+        let input = io::stdin().read_line()\n+                               .ok()\n+                               .expect(\"Failed to read line\");\n+        let input_num: Option<uint> = from_str(input.as_slice().trim());\n+\n+        let num = match input_num {\n+            Some(num) => num,\n+            None      => {\n+                println!(\"Please input a number!\");\n+                return;\n+            }\n+        };\n+\n+\n+        println!(\"You guessed: {}\", num);\n+\n+        match cmp(num, secret_number) {\n+            Less    => println!(\"Too small!\"),\n+            Greater => println!(\"Too big!\"),\n+            Equal   => {\n+                println!(\"You win!\");\n+                return;\n+            },\n+        }\n+    }\n+}\n+\n+fn cmp(a: uint, b: uint) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n+}\n+```\n+\n+By adding the `return` line after the `You win!`, we'll exit the program when\n+we win. We have just one more tweak to make: when someone inputs a non-number,\n+we don't want to quit, we just want to ignore it. Change that `return` to\n+`continue`:\n+\n+\n+```{rust,no_run}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    loop {\n+\n+        println!(\"Please input your guess.\");\n+\n+        let input = io::stdin().read_line()\n+                               .ok()\n+                               .expect(\"Failed to read line\");\n+        let input_num: Option<uint> = from_str(input.as_slice().trim());\n+\n+        let num = match input_num {\n+            Some(num) => num,\n+            None      => {\n+                println!(\"Please input a number!\");\n+                continue;\n+            }\n+        };\n+\n+\n+        println!(\"You guessed: {}\", num);\n+\n+        match cmp(num, secret_number) {\n+            Less    => println!(\"Too small!\"),\n+            Greater => println!(\"Too big!\"),\n+            Equal   => {\n+                println!(\"You win!\");\n+                return;\n+            },\n+        }\n+    }\n+}\n+\n+fn cmp(a: uint, b: uint) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n+}\n+```\n+\n+Now we should be good! Let's try:\n+\n+```{rust,ignore}\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n+$ ./target/guessing_game \n+Guess the number!\n+The secret number is: 61\n+Please input your guess.\n+10\n+You guessed: 10\n+Too small!\n+Please input your guess.\n+99\n+You guessed: 99\n+Too big!\n+Please input your guess.\n+foo\n+Please input a number!\n+Please input your guess.\n+61\n+You guessed: 61\n+You win!\n+```\n+\n+Awesome! With one tiny last tweak, we have finished the guessing game. Can you\n+think of what it is? That's right, we don't want to print out the secret number.\n+It was good for testing, but it kind of ruins the game. Here's our final source:\n+\n+```{rust,no_run}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    loop {\n+\n+        println!(\"Please input your guess.\");\n+\n+        let input = io::stdin().read_line()\n+                               .ok()\n+                               .expect(\"Failed to read line\");\n+        let input_num: Option<uint> = from_str(input.as_slice().trim());\n+\n+        let num = match input_num {\n+            Some(num) => num,\n+            None      => {\n+                println!(\"Please input a number!\");\n+                continue;\n+            }\n+        };\n+\n+\n+        println!(\"You guessed: {}\", num);\n+\n+        match cmp(num, secret_number) {\n+            Less    => println!(\"Too small!\"),\n+            Greater => println!(\"Too big!\"),\n+            Equal   => {\n+                println!(\"You win!\");\n+                return;\n+            },\n+        }\n+    }\n+}\n+\n+fn cmp(a: uint, b: uint) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n+}\n+```\n+\n+### Complete!\n \n At this point, you have successfully built the Guessing Game! Congratulations!\n-For reference, [We've placed the sample code on\n-GitHub](https://github.com/steveklabnik/guessing_game).\n \n You've now learned the basic syntax of Rust. All of this is relatively close to\n various other programming languages you have used in the past. These"}]}