{"sha": "3f0d207b3251e598488588765b942bf6b7a4f9bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmMGQyMDdiMzI1MWU1OTg0ODg1ODg3NjViOTQyYmY2YjdhNGY5YmI=", "commit": {"author": {"name": "Elliott Slaughter", "email": "eslaughter@mozilla.com", "date": "2012-07-16T19:28:15Z"}, "committer": {"name": "Elliott Slaughter", "email": "eslaughter@mozilla.com", "date": "2012-09-07T16:21:21Z"}, "message": "gc: Add stack walker for new garbage collector.\n\nSafe points are exported in a per-module list via the crate map. A C\nruntime call walks the crate map at startup and aggregates the list of\nsafe points for the program.\n\nCurrently the GC doesn't actually deallocate memory on malloc and\nfree. Adding the GC at this stage is primarily of testing value.\n\nThe GC does attempt to clean up exchange heap and stack-allocated\nresource on failure.\n\nA result of this patch is that the user now needs to be careful about\nwhat code they write in destructors, because the GC and/or failure\ncleanup may need to call destructors. Specifically, calls to malloc\nare considered unsafe and may result in infinite loops or segfaults.", "tree": {"sha": "98fad8b4761bb95d63615e7e2217ca559bd4962a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98fad8b4761bb95d63615e7e2217ca559bd4962a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f0d207b3251e598488588765b942bf6b7a4f9bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f0d207b3251e598488588765b942bf6b7a4f9bb", "html_url": "https://github.com/rust-lang/rust/commit/3f0d207b3251e598488588765b942bf6b7a4f9bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f0d207b3251e598488588765b942bf6b7a4f9bb/comments", "author": null, "committer": null, "parents": [{"sha": "fb8786fe522ed96172cf1ae8e205e3f2722e834c", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb8786fe522ed96172cf1ae8e205e3f2722e834c", "html_url": "https://github.com/rust-lang/rust/commit/fb8786fe522ed96172cf1ae8e205e3f2722e834c"}], "stats": {"total": 407, "additions": 375, "deletions": 32}, "files": [{"sha": "ba20684df013957fac7c590b46d2facd1c801164", "filename": "mk/rt.mk", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f0d207b3251e598488588765b942bf6b7a4f9bb/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/3f0d207b3251e598488588765b942bf6b7a4f9bb/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=3f0d207b3251e598488588765b942bf6b7a4f9bb", "patch": "@@ -60,7 +60,9 @@ RUNTIME_CS_$(1) := \\\n               rt/rust_port.cpp \\\n               rt/rust_upcall.cpp \\\n               rt/rust_uv.cpp \\\n+              rt/rust_crate_map.cpp \\\n               rt/rust_log.cpp \\\n+              rt/rust_gc_metadata.cpp \\\n               rt/rust_port_selector.cpp \\\n               rt/rust_util.cpp \\\n               rt/circular_buffer.cpp \\"}, {"sha": "4da21d7f5afbb85400abfa2e46910fd0ca192677", "filename": "src/libcore/core.rc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f0d207b3251e598488588765b942bf6b7a4f9bb/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3f0d207b3251e598488588765b942bf6b7a4f9bb/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=3f0d207b3251e598488588765b942bf6b7a4f9bb", "patch": "@@ -40,7 +40,7 @@ export uint, u8, u16, u32, u64;\n export float, f32, f64;\n export box, char, str, ptr, vec, at_vec, bool;\n export either, option, result, iter;\n-export libc, os, io, run, rand, sys, unsafe, logging;\n+export gc, io, libc, os, run, rand, sys, unsafe, logging;\n export comm, task, future, pipes;\n export extfmt;\n // The test harness links against core, so don't include runtime in tests.\n@@ -216,6 +216,7 @@ mod pipes;\n \n // Runtime and language-primitive support\n \n+mod gc;\n mod io;\n mod libc;\n mod os;"}, {"sha": "eacd0bc62d319a0376b3fc2e02f5ec63318aa173", "filename": "src/libcore/gc.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/3f0d207b3251e598488588765b942bf6b7a4f9bb/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f0d207b3251e598488588765b942bf6b7a4f9bb/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=3f0d207b3251e598488588765b942bf6b7a4f9bb", "patch": "@@ -0,0 +1,155 @@\n+import stackwalk::Word;\n+import libc::size_t;\n+\n+extern mod rustrt {\n+    fn rust_annihilate_box(ptr: *Word);\n+\n+    #[rust_stack]\n+    fn rust_gc_metadata() -> *Word;\n+\n+    #[rust_stack]\n+    fn rust_call_tydesc_glue(root: *Word, tydesc: *Word, field: size_t);\n+}\n+\n+type SafePoint = { sp_meta: *Word, fn_meta: *Word };\n+\n+unsafe fn is_safe_point(pc: *Word) -> Option<SafePoint> {\n+    let module_meta = rustrt::rust_gc_metadata();\n+    let num_safe_points_ptr: *u32 = unsafe::reinterpret_cast(&module_meta);\n+    let num_safe_points = *num_safe_points_ptr as Word;\n+    let safe_points: *Word =\n+        ptr::offset(unsafe::reinterpret_cast(&module_meta), 1);\n+\n+    if ptr::is_null(pc) {\n+        return None;\n+    }\n+\n+    let mut sp = 0 as Word;\n+    while sp < num_safe_points {\n+        let sp_loc = *ptr::offset(safe_points, sp*3) as *Word;\n+        if sp_loc == pc {\n+            return Some(\n+                {sp_meta: *ptr::offset(safe_points, sp*3 + 1) as *Word,\n+                 fn_meta: *ptr::offset(safe_points, sp*3 + 2) as *Word});\n+        }\n+        sp += 1;\n+    }\n+    return None;\n+}\n+\n+type Visitor = fn(root: **Word, tydesc: *Word);\n+\n+unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n+    let fp_bytes: *u8 = unsafe::reinterpret_cast(&fp);\n+    let sp_meta_u32s: *u32 = unsafe::reinterpret_cast(&sp.sp_meta);\n+\n+    let num_stack_roots = *sp_meta_u32s as uint;\n+    let num_reg_roots = *ptr::offset(sp_meta_u32s, 1) as uint;\n+\n+    let stack_roots: *u32 =\n+        unsafe::reinterpret_cast(&ptr::offset(sp_meta_u32s, 2));\n+    let reg_roots: *u8 =\n+        unsafe::reinterpret_cast(&ptr::offset(stack_roots, num_stack_roots));\n+    let addrspaces: *Word =\n+        unsafe::reinterpret_cast(&ptr::offset(reg_roots, num_reg_roots));\n+    let tydescs: ***Word =\n+        unsafe::reinterpret_cast(&ptr::offset(addrspaces, num_stack_roots));\n+\n+    // Stack roots\n+    let mut sri = 0;\n+    while sri < num_stack_roots {\n+        if *ptr::offset(addrspaces, sri) >= 1 {\n+            let root =\n+                ptr::offset(fp_bytes, *ptr::offset(stack_roots, sri) as Word)\n+                as **Word;\n+            let tydescpp = ptr::offset(tydescs, sri);\n+            let tydesc = if ptr::is_not_null(tydescpp) &&\n+                ptr::is_not_null(*tydescpp) {\n+                **tydescpp\n+            } else {\n+                ptr::null()\n+            };\n+            visitor(root, tydesc);\n+        }\n+        sri += 1;\n+    }\n+\n+    // Register roots\n+    let mut rri = 0;\n+    while rri < num_reg_roots {\n+        if *ptr::offset(addrspaces, num_stack_roots + rri) == 1 {\n+            // FIXME(#2997): Need to find callee saved registers on the stack.\n+        }\n+        rri += 1;\n+    }\n+}\n+\n+type Memory = uint;\n+\n+const task_local_heap: Memory = 1;\n+const exchange_heap:   Memory = 2;\n+const stack:           Memory = 4;\n+\n+const need_cleanup:    Memory = exchange_heap | stack;\n+\n+unsafe fn walk_gc_roots(mem: Memory, visitor: Visitor) {\n+    let mut last_ret: *Word = ptr::null();\n+    do stackwalk::walk_stack |frame| {\n+        unsafe {\n+            if ptr::is_not_null(last_ret) {\n+                let sp = is_safe_point(last_ret);\n+                match sp {\n+                  Some(sp_info) => {\n+                    do walk_safe_point(frame.fp, sp_info) |root, tydesc| {\n+                        if ptr::is_null(tydesc) {\n+                            // Root is a generic box.\n+                            let refcount = **root;\n+                            if mem | task_local_heap != 0 && refcount != -1 {\n+                                visitor(root, tydesc);\n+                            } else if mem | exchange_heap != 0 {\n+                                visitor(root, tydesc);\n+                            }\n+                        } else {\n+                            // Root is a non-immediate.\n+                            if mem | stack != 0 {\n+                                visitor(root, tydesc);\n+                            }\n+                        }\n+                    }\n+                  }\n+                  None => ()\n+                }\n+            }\n+            last_ret = *ptr::offset(frame.fp, 1) as *Word;\n+        }\n+        true\n+    }\n+}\n+\n+fn gc() {\n+    unsafe {\n+        let mut i = 0;\n+        do walk_gc_roots(task_local_heap) |_root, _tydesc| {\n+            // FIXME(#2997): Walk roots and mark them.\n+            io::stdout().write([46]); // .\n+            i += 1;\n+        }\n+    }\n+}\n+\n+// This should only be called from fail, as it will drop the roots\n+// which are *live* on the stack, rather than dropping those that are\n+// dead.\n+fn cleanup_stack_for_failure() {\n+    unsafe {\n+        let mut i = 0;\n+        do walk_gc_roots(need_cleanup) |root, tydesc| {\n+            if ptr::is_null(tydesc) {\n+                rustrt::rust_annihilate_box(*root);\n+            } else {\n+                rustrt::rust_call_tydesc_glue(*root, tydesc, 3 as size_t);\n+            }\n+            i += 1;\n+        }\n+    }\n+}"}, {"sha": "0f074bc5c1dc5ad21ff93b3f4a165971912ccd9f", "filename": "src/libcore/rt.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f0d207b3251e598488588765b942bf6b7a4f9bb/src%2Flibcore%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f0d207b3251e598488588765b942bf6b7a4f9bb/src%2Flibcore%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt.rs?ref=3f0d207b3251e598488588765b942bf6b7a4f9bb", "patch": "@@ -8,6 +8,9 @@ use libc::c_void;\n use libc::size_t;\n use libc::uintptr_t;\n \n+import gc::gc;\n+import gc::cleanup_stack_for_failure;\n+\n #[allow(non_camel_case_types)]\n type rust_task = c_void;\n \n@@ -33,6 +36,7 @@ extern mod rustrt {\n // gather_rust_rtcalls.\n #[rt(fail)]\n fn rt_fail(expr: *c_char, file: *c_char, line: size_t) {\n+    cleanup_stack_for_failure();\n     rustrt::rust_upcall_fail(expr, file, line);\n }\n "}, {"sha": "705a96303d4eefda1f35c57bce5051dbd0577261", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f0d207b3251e598488588765b942bf6b7a4f9bb/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3f0d207b3251e598488588765b942bf6b7a4f9bb/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=3f0d207b3251e598488588765b942bf6b7a4f9bb", "patch": "@@ -7,6 +7,7 @@\n #include \"rust_kernel.h\"\n #include \"rust_util.h\"\n #include \"rust_scheduler.h\"\n+#include \"rust_gc_metadata.h\"\n \n // Creates a rust argument vector from the platform argument vector\n struct\n@@ -85,6 +86,8 @@ rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n     // line as well.\n     rust_env *env = load_env();\n \n+    update_gc_metadata(crate_map);\n+\n     update_log_settings(crate_map, env->logspec);\n \n     // Maybe turn on typestate claim checking"}, {"sha": "633361bb932d44aa28c87ad13a2bde510656898e", "filename": "src/rt/rust_crate_map.cpp", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3f0d207b3251e598488588765b942bf6b7a4f9bb/src%2Frt%2Frust_crate_map.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3f0d207b3251e598488588765b942bf6b7a4f9bb/src%2Frt%2Frust_crate_map.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_crate_map.cpp?ref=3f0d207b3251e598488588765b942bf6b7a4f9bb", "patch": "@@ -0,0 +1,33 @@\n+#include \"rust_crate_map.h\"\n+\n+void iter_module_map(const mod_entry* map,\n+                     void (*fn)(const mod_entry* entry, void *cookie),\n+                     void *cookie) {\n+    for (const mod_entry* cur = map; cur->name; cur++) {\n+        fn(cur, cookie);\n+    }\n+}\n+\n+void iter_crate_map(const cratemap* map,\n+                    void (*fn)(const mod_entry* map, void *cookie),\n+                    void *cookie) {\n+    // First iterate this crate\n+    iter_module_map(map->entries, fn, cookie);\n+    // Then recurse on linked crates\n+    // FIXME (#2673) this does double work in diamond-shaped deps. could\n+    //   keep a set of visited addresses, if it turns out to be actually\n+    //   slow\n+    for (size_t i = 0; map->children[i]; i++) {\n+        iter_crate_map(map->children[i], fn, cookie);\n+    }\n+}\n+\n+//\n+// Local Variables:\n+// mode: C++\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:\n+//"}, {"sha": "453feb36e5722cd2f7dd0dc58301d1246e91e5d6", "filename": "src/rt/rust_crate_map.h", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3f0d207b3251e598488588765b942bf6b7a4f9bb/src%2Frt%2Frust_crate_map.h", "raw_url": "https://github.com/rust-lang/rust/raw/3f0d207b3251e598488588765b942bf6b7a4f9bb/src%2Frt%2Frust_crate_map.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_crate_map.h?ref=3f0d207b3251e598488588765b942bf6b7a4f9bb", "patch": "@@ -0,0 +1,34 @@\n+#ifndef RUST_CRATE_MAP_H\n+#define RUST_CRATE_MAP_H\n+\n+#include \"rust_log.h\"\n+\n+struct mod_entry {\n+    const char* name;\n+    uint32_t* state;\n+};\n+\n+struct cratemap {\n+    const mod_entry* entries;\n+    const cratemap* children[1];\n+};\n+\n+void iter_module_map(const mod_entry* map,\n+                     void (*fn)(const mod_entry* entry, void *cookie),\n+                     void *cookie);\n+\n+void iter_crate_map(const cratemap* map,\n+                    void (*fn)(const mod_entry* entry, void *cookie),\n+                    void *cookie);\n+\n+//\n+// Local Variables:\n+// mode: C++\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:\n+//\n+\n+#endif /* RUST_CRATE_MAP_H */"}, {"sha": "a4da879daa0bf4f9ac83f3f36e1deb8ca725850b", "filename": "src/rt/rust_gc_metadata.cpp", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/3f0d207b3251e598488588765b942bf6b7a4f9bb/src%2Frt%2Frust_gc_metadata.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3f0d207b3251e598488588765b942bf6b7a4f9bb/src%2Frt%2Frust_gc_metadata.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_gc_metadata.cpp?ref=3f0d207b3251e598488588765b942bf6b7a4f9bb", "patch": "@@ -0,0 +1,80 @@\n+#include \"rust_gc_metadata.h\"\n+#include \"rust_crate_map.h\"\n+#include \"rust_globals.h\"\n+\n+#include <algorithm>\n+#include <vector>\n+\n+struct safe_point {\n+    size_t safe_point_loc;\n+    size_t safe_point_meta;\n+    size_t function_meta;\n+};\n+\n+struct update_gc_entry_args {\n+    std::vector<safe_point> *safe_points;\n+};\n+\n+static void\n+update_gc_entry(const mod_entry* entry, void *cookie) {\n+    update_gc_entry_args *args = (update_gc_entry_args *)cookie;\n+    if (!strcmp(entry->name, \"_gc_module_metadata\")) {\n+        size_t *next = entry->state;\n+        uint32_t num_safe_points = *(uint32_t *)next;\n+        next++;\n+\n+        for (uint32_t i = 0; i < num_safe_points; i++) {\n+            safe_point sp = { next[0], next[1], next[2] };\n+            next += 3;\n+\n+            args->safe_points->push_back(sp);\n+        }\n+    }\n+}\n+\n+static bool\n+cmp_safe_point(safe_point a, safe_point b) {\n+    return a.safe_point_loc < b.safe_point_loc;\n+}\n+\n+size_t *global_safe_points = 0;\n+\n+void\n+update_gc_metadata(const void* map) {\n+    std::vector<safe_point> safe_points;\n+    update_gc_entry_args args = { &safe_points };\n+\n+    // Extract list of safe points from each module.\n+    iter_crate_map((const cratemap *)map, update_gc_entry, (void *)&args);\n+    std::sort(safe_points.begin(), safe_points.end(), cmp_safe_point);\n+\n+    // Serialize safe point list into format expected by runtime.\n+    global_safe_points =\n+        (size_t *)malloc((safe_points.size()*3 + 1)*sizeof(size_t));\n+    if (!global_safe_points) return;\n+\n+    size_t *next = global_safe_points;\n+    *(uint32_t *)next = safe_points.size();\n+    next++;\n+    for (uint32_t i = 0; i < safe_points.size(); i++) {\n+        next[0] = safe_points[i].safe_point_loc;\n+        next[1] = safe_points[i].safe_point_meta;\n+        next[2] = safe_points[i].function_meta;\n+        next += 3;\n+    }\n+}\n+\n+extern \"C\" CDECL void *\n+rust_gc_metadata() {\n+    return (void *)global_safe_points;\n+}\n+\n+//\n+// Local Variables:\n+// mode: C++\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:\n+//"}, {"sha": "ddeb5b382ff0f98ad8519b3de3ab6ee36e1dafff", "filename": "src/rt/rust_gc_metadata.h", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3f0d207b3251e598488588765b942bf6b7a4f9bb/src%2Frt%2Frust_gc_metadata.h", "raw_url": "https://github.com/rust-lang/rust/raw/3f0d207b3251e598488588765b942bf6b7a4f9bb/src%2Frt%2Frust_gc_metadata.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_gc_metadata.h?ref=3f0d207b3251e598488588765b942bf6b7a4f9bb", "patch": "@@ -0,0 +1,16 @@\n+#ifndef RUST_GC_METADATA_H\n+#define RUST_GC_METADATA_H\n+\n+void update_gc_metadata(const void* map);\n+\n+//\n+// Local Variables:\n+// mode: C++\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:\n+//\n+\n+#endif /* RUST_GC_METADATA_H */"}, {"sha": "666183fcdd39ee53077397247c1d19d45c0f0a76", "filename": "src/rt/rust_log.cpp", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3f0d207b3251e598488588765b942bf6b7a4f9bb/src%2Frt%2Frust_log.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3f0d207b3251e598488588765b942bf6b7a4f9bb/src%2Frt%2Frust_log.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.cpp?ref=3f0d207b3251e598488588765b942bf6b7a4f9bb", "patch": "@@ -4,6 +4,7 @@\n \n \n #include \"rust_log.h\"\n+#include \"rust_crate_map.h\"\n #include \"util/array_list.h\"\n #include \"rust_util.h\"\n #include \"rust_task.h\"\n@@ -160,16 +161,6 @@ rust_log::trace_ln(rust_task *task, uint32_t level, char *message) {\n \n // Reading log directives and setting log level vars\n \n-struct mod_entry {\n-    const char* name;\n-    uint32_t* state;\n-};\n-\n-struct cratemap {\n-    const mod_entry* entries;\n-    const cratemap* children[1];\n-};\n-\n struct log_directive {\n     char* name;\n     size_t level;\n@@ -212,33 +203,36 @@ size_t parse_logging_spec(char* spec, log_directive* dirs) {\n     return dir;\n }\n \n-void update_module_map(const mod_entry* map, log_directive* dirs,\n-                       size_t n_dirs, size_t *n_matches) {\n-    for (const mod_entry* cur = map; cur->name; cur++) {\n-        size_t level = default_log_level, longest_match = 0;\n-        for (size_t d = 0; d < n_dirs; d++) {\n-            if (strstr(cur->name, dirs[d].name) == cur->name &&\n-                strlen(dirs[d].name) > longest_match) {\n-                longest_match = strlen(dirs[d].name);\n-                level = dirs[d].level;\n-            }\n+struct update_entry_args {\n+    log_directive* dirs;\n+    size_t n_dirs;\n+    size_t *n_matches;\n+};\n+\n+static void update_entry(const mod_entry* entry, void *cookie) {\n+    update_entry_args *args = (update_entry_args *)cookie;\n+    size_t level = default_log_level, longest_match = 0;\n+    for (size_t d = 0; d < args->n_dirs; d++) {\n+        if (strstr(entry->name, args->dirs[d].name) == entry->name &&\n+            strlen(args->dirs[d].name) > longest_match) {\n+            longest_match = strlen(args->dirs[d].name);\n+            level = args->dirs[d].level;\n         }\n-        *cur->state = level;\n-        (*n_matches)++;\n     }\n+    *entry->state = level;\n+    (*args->n_matches)++;\n+}\n+\n+void update_module_map(const mod_entry* map, log_directive* dirs,\n+                       size_t n_dirs, size_t *n_matches) {\n+    update_entry_args args = { dirs, n_dirs, n_matches };\n+    iter_module_map(map, update_entry, &args);\n }\n \n void update_crate_map(const cratemap* map, log_directive* dirs,\n                       size_t n_dirs, size_t *n_matches) {\n-    // First update log levels for this crate\n-    update_module_map(map->entries, dirs, n_dirs, n_matches);\n-    // Then recurse on linked crates\n-    // FIXME (#2673) this does double work in diamond-shaped deps. could\n-    //   keep a set of visited addresses, if it turns out to be actually\n-    //   slow\n-    for (size_t i = 0; map->children[i]; i++) {\n-        update_crate_map(map->children[i], dirs, n_dirs, n_matches);\n-    }\n+    update_entry_args args = { dirs, n_dirs, n_matches };\n+    iter_crate_map(map, update_entry, &args);\n }\n \n void print_crate_log_map(const cratemap* map) {"}, {"sha": "315b496e661953f1227a4434a18203f46f3b4df4", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3f0d207b3251e598488588765b942bf6b7a4f9bb/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f0d207b3251e598488588765b942bf6b7a4f9bb/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3f0d207b3251e598488588765b942bf6b7a4f9bb", "patch": "@@ -1595,6 +1595,7 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n         do str::as_c_str(\"generic\") |strategy| {\n             llvm::LLVMSetGC(fcx.llfn, strategy);\n         }\n+        ccx.uses_gc = true;\n     }\n \n     // Create the first basic block in the function and keep a handle on it to\n@@ -2438,6 +2439,20 @@ fn gather_rtcalls(ccx: @crate_ctxt, crate: @ast::crate) {\n     }\n }\n \n+fn decl_gc_metadata(ccx: @crate_ctxt, llmod_id: ~str) {\n+    if !ccx.sess.opts.gc || !ccx.uses_gc {\n+        return;\n+    }\n+\n+    let gc_metadata_name = ~\"_gc_module_metadata_\" + llmod_id;\n+    let gc_metadata = do str::as_c_str(gc_metadata_name) |buf| {\n+        llvm::LLVMAddGlobal(ccx.llmod, T_i32(), buf)\n+    };\n+    llvm::LLVMSetGlobalConstant(gc_metadata, True);\n+    lib::llvm::SetLinkage(gc_metadata, lib::llvm::ExternalLinkage);\n+    ccx.module_data.insert(~\"_gc_module_metadata\", gc_metadata);\n+}\n+\n fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n     let elttype = T_struct(~[ccx.int_type, ccx.int_type]);\n     let maptype = T_array(elttype, ccx.module_data.size() + 1u);\n@@ -2679,6 +2694,7 @@ fn trans_crate(sess: session::session,\n           builder: BuilderRef_res(llvm::LLVMCreateBuilder()),\n           shape_cx: mk_ctxt(llmod),\n           crate_map: crate_map,\n+          mut uses_gc: false,\n           dbg_cx: dbg_cx,\n           class_ctors: int_hash::<ast::def_id>(),\n           mut do_not_commit_warning_issued: false};\n@@ -2696,6 +2712,7 @@ fn trans_crate(sess: session::session,\n         trans_mod(ccx, crate.node.module);\n     }\n \n+    decl_gc_metadata(ccx, llmod_id);\n     fill_crate_map(ccx, crate_map);\n     // NB: Must call force_declare_tydescs before emit_tydescs to break\n     // cyclical dependency with shape code! See shape.rs for details."}, {"sha": "7e612051565f2ab6e93d3ceb330a76ec0a87f72f", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f0d207b3251e598488588765b942bf6b7a4f9bb/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f0d207b3251e598488588765b942bf6b7a4f9bb/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=3f0d207b3251e598488588765b942bf6b7a4f9bb", "patch": "@@ -162,6 +162,10 @@ type crate_ctxt = {\n      builder: BuilderRef_res,\n      shape_cx: shape::ctxt,\n      crate_map: ValueRef,\n+     // Set when at least one function uses GC. Needed so that\n+     // decl_gc_metadata knows whether to link to the module metadata, which\n+     // is not emitted by LLVM's GC pass when no functions use GC.\n+     mut uses_gc: bool,\n      dbg_cx: Option<debuginfo::debug_ctxt>,\n      // Mapping from class constructors to parent class --\n      // used in base::trans_closure"}]}