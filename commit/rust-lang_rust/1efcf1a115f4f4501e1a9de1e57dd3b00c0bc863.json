{"sha": "1efcf1a115f4f4501e1a9de1e57dd3b00c0bc863", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlZmNmMWExMTVmNGY0NTAxZTFhOWRlMWU1N2RkM2IwMGMwYmM4NjM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-05T19:37:55Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-16T10:57:44Z"}, "message": "split the `var_origins` from the `RegionConstraintData`", "tree": {"sha": "15694c559f47cf4d26b742565c30812b6893d8ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15694c559f47cf4d26b742565c30812b6893d8ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1efcf1a115f4f4501e1a9de1e57dd3b00c0bc863", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1efcf1a115f4f4501e1a9de1e57dd3b00c0bc863", "html_url": "https://github.com/rust-lang/rust/commit/1efcf1a115f4f4501e1a9de1e57dd3b00c0bc863", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1efcf1a115f4f4501e1a9de1e57dd3b00c0bc863/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8daa37df694279d0e9241ccba46533926dfd70d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8daa37df694279d0e9241ccba46533926dfd70d", "html_url": "https://github.com/rust-lang/rust/commit/a8daa37df694279d0e9241ccba46533926dfd70d"}], "stats": {"total": 388, "additions": 206, "deletions": 182}, "files": [{"sha": "e097bf27c473a637ead48d203e9d20a7e63fe111", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 161, "deletions": 155, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/1efcf1a115f4f4501e1a9de1e57dd3b00c0bc863/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efcf1a115f4f4501e1a9de1e57dd3b00c0bc863/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=1efcf1a115f4f4501e1a9de1e57dd3b00c0bc863", "patch": "@@ -15,6 +15,7 @@ use infer::RegionVariableOrigin;\n use infer::region_constraints::Constraint;\n use infer::region_constraints::GenericKind;\n use infer::region_constraints::RegionConstraintData;\n+use infer::region_constraints::VarOrigins;\n use infer::region_constraints::VerifyBound;\n use middle::free_region::RegionRelations;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n@@ -29,6 +30,28 @@ use ty::{ReLateBound, ReScope, ReSkolemized, ReVar};\n \n mod graphviz;\n \n+/// This function performs lexical region resolution given a complete\n+/// set of constraints and variable origins. It performs a fixed-point\n+/// iteration to find region values which satisfy all constraints,\n+/// assuming such values can be found. It returns the final values of\n+/// all the variables as well as a set of errors that must be reported.\n+pub fn resolve<'tcx>(\n+    region_rels: &RegionRelations<'_, '_, 'tcx>,\n+    var_origins: VarOrigins,\n+    data: RegionConstraintData<'tcx>\n+) -> (\n+    LexicalRegionResolutions<'tcx>,\n+    Vec<RegionResolutionError<'tcx>>,\n+) {\n+    debug!(\"RegionConstraintData: resolve_regions()\");\n+    let mut errors = vec![];\n+    let mut resolver = LexicalResolver { region_rels, var_origins, data };\n+    let values = resolver.infer_variable_values(&mut errors);\n+    (values, errors)\n+}\n+\n+/// Contains the result of lexical region resolution. Offers methods\n+/// to lookup up the final value of a region variable.\n pub struct LexicalRegionResolutions<'tcx> {\n     values: IndexVec<RegionVid, VarValue<'tcx>>,\n     error_region: ty::Region<'tcx>,\n@@ -74,139 +97,40 @@ struct RegionAndOrigin<'tcx> {\n \n type RegionGraph<'tcx> = graph::Graph<(), Constraint<'tcx>>;\n \n-impl<'tcx> RegionConstraintData<'tcx> {\n-    /// This function performs the actual region resolution.  It must be\n-    /// called after all constraints have been added.  It performs a\n-    /// fixed-point iteration to find region values which satisfy all\n-    /// constraints, assuming such values can be found; if they cannot,\n-    /// errors are reported.\n-    pub fn resolve_regions(\n-        mut self,\n-        region_rels: &RegionRelations<'_, '_, 'tcx>,\n-    ) -> (\n-        LexicalRegionResolutions<'tcx>,\n-        Vec<RegionResolutionError<'tcx>>,\n-    ) {\n-        debug!(\"RegionConstraintData: resolve_regions()\");\n-        let mut errors = vec![];\n-        let values = self.infer_variable_values(region_rels, &mut errors);\n-        (values, errors)\n-    }\n-\n-    fn lub_concrete_regions(\n-        &self,\n-        region_rels: &RegionRelations<'_, '_, 'tcx>,\n-        a: Region<'tcx>,\n-        b: Region<'tcx>,\n-    ) -> Region<'tcx> {\n-        let tcx = region_rels.tcx;\n-        match (a, b) {\n-            (&ReLateBound(..), _) | (_, &ReLateBound(..)) | (&ReErased, _) | (_, &ReErased) => {\n-                bug!(\"cannot relate region: LUB({:?}, {:?})\", a, b);\n-            }\n-\n-            (r @ &ReStatic, _) | (_, r @ &ReStatic) => {\n-                r // nothing lives longer than static\n-            }\n-\n-            (&ReEmpty, r) | (r, &ReEmpty) => {\n-                r // everything lives longer than empty\n-            }\n-\n-            (&ReVar(v_id), _) | (_, &ReVar(v_id)) => {\n-                span_bug!(\n-                    self.var_origins[v_id].span(),\n-                    \"lub_concrete_regions invoked with non-concrete \\\n-                     regions: {:?}, {:?}\",\n-                    a,\n-                    b\n-                );\n-            }\n-\n-            (&ReEarlyBound(_), &ReScope(s_id)) |\n-            (&ReScope(s_id), &ReEarlyBound(_)) |\n-            (&ReFree(_), &ReScope(s_id)) |\n-            (&ReScope(s_id), &ReFree(_)) => {\n-                // A \"free\" region can be interpreted as \"some region\n-                // at least as big as fr.scope\".  So, we can\n-                // reasonably compare free regions and scopes:\n-                let fr_scope = match (a, b) {\n-                    (&ReEarlyBound(ref br), _) | (_, &ReEarlyBound(ref br)) => {\n-                        region_rels.region_scope_tree.early_free_scope(region_rels.tcx, br)\n-                    }\n-                    (&ReFree(ref fr), _) | (_, &ReFree(ref fr)) => {\n-                        region_rels.region_scope_tree.free_scope(region_rels.tcx, fr)\n-                    }\n-                    _ => bug!(),\n-                };\n-                let r_id = region_rels\n-                    .region_scope_tree\n-                    .nearest_common_ancestor(fr_scope, s_id);\n-                if r_id == fr_scope {\n-                    // if the free region's scope `fr.scope` is bigger than\n-                    // the scope region `s_id`, then the LUB is the free\n-                    // region itself:\n-                    match (a, b) {\n-                        (_, &ReScope(_)) => return a,\n-                        (&ReScope(_), _) => return b,\n-                        _ => bug!(),\n-                    }\n-                }\n-\n-                // otherwise, we don't know what the free region is,\n-                // so we must conservatively say the LUB is static:\n-                tcx.types.re_static\n-            }\n-\n-            (&ReScope(a_id), &ReScope(b_id)) => {\n-                // The region corresponding to an outer block is a\n-                // subtype of the region corresponding to an inner\n-                // block.\n-                let lub = region_rels\n-                    .region_scope_tree\n-                    .nearest_common_ancestor(a_id, b_id);\n-                tcx.mk_region(ReScope(lub))\n-            }\n-\n-            (&ReEarlyBound(_), &ReEarlyBound(_)) |\n-            (&ReFree(_), &ReEarlyBound(_)) |\n-            (&ReEarlyBound(_), &ReFree(_)) |\n-            (&ReFree(_), &ReFree(_)) => region_rels.lub_free_regions(a, b),\n-\n-            // For these types, we cannot define any additional\n-            // relationship:\n-            (&ReSkolemized(..), _) | (_, &ReSkolemized(..)) => if a == b {\n-                a\n-            } else {\n-                tcx.types.re_static\n-            },\n-        }\n-    }\n+struct LexicalResolver<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    region_rels: &'cx RegionRelations<'cx, 'gcx, 'tcx>,\n+    var_origins: VarOrigins,\n+    data: RegionConstraintData<'tcx>\n+}\n \n+impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n     fn infer_variable_values(\n         &mut self,\n-        region_rels: &RegionRelations<'_, '_, 'tcx>,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n     ) -> LexicalRegionResolutions<'tcx> {\n-        let mut var_data = self.construct_var_data(region_rels.tcx);\n+        let mut var_data = self.construct_var_data(self.region_rels.tcx);\n \n         // Dorky hack to cause `dump_constraints` to only get called\n         // if debug mode is enabled:\n         debug!(\n             \"----() End constraint listing (context={:?}) {:?}---\",\n-            region_rels.context,\n-            self.dump_constraints(region_rels)\n+            self.region_rels.context,\n+            self.dump_constraints(self.region_rels)\n         );\n-        graphviz::maybe_print_constraints_for(self, region_rels);\n+        graphviz::maybe_print_constraints_for(&self.data, self.region_rels);\n \n         let graph = self.construct_graph();\n         self.expand_givens(&graph);\n-        self.expansion(region_rels, &mut var_data);\n-        self.collect_errors(region_rels, &mut var_data, errors);\n-        self.collect_var_errors(region_rels, &var_data, &graph, errors);\n+        self.expansion(&mut var_data);\n+        self.collect_errors(&mut var_data, errors);\n+        self.collect_var_errors(&var_data, &graph, errors);\n         var_data\n     }\n \n+    fn num_vars(&self) -> usize {\n+        self.var_origins.len()\n+    }\n+\n     /// Initially, the value for all variables is set to `'empty`, the\n     /// empty region. The `expansion` phase will grow this larger.\n     fn construct_var_data(&self, tcx: TyCtxt<'_, '_, 'tcx>) -> LexicalRegionResolutions<'tcx> {\n@@ -223,7 +147,7 @@ impl<'tcx> RegionConstraintData<'tcx> {\n             \"----() Start constraint listing (context={:?}) ()----\",\n             free_regions.context\n         );\n-        for (idx, (constraint, _)) in self.constraints.iter().enumerate() {\n+        for (idx, (constraint, _)) in self.data.constraints.iter().enumerate() {\n             debug!(\"Constraint {} => {:?}\", idx, constraint);\n         }\n     }\n@@ -239,7 +163,7 @@ impl<'tcx> RegionConstraintData<'tcx> {\n         //     and   '0 <= '1\n         //     then  'c <= '1\n \n-        let seeds: Vec<_> = self.givens.iter().cloned().collect();\n+        let seeds: Vec<_> = self.data.givens.iter().cloned().collect();\n         for (r, vid) in seeds {\n \n             // While all things transitively reachable in the graph\n@@ -255,29 +179,28 @@ impl<'tcx> RegionConstraintData<'tcx> {\n                     let succ_vid = RegionVid::new(succ_index);\n \n                     // Add `'c <= '1`.\n-                    self.givens.insert((r, succ_vid));\n+                    self.data.givens.insert((r, succ_vid));\n                 }\n             }\n         }\n     }\n \n     fn expansion(\n         &self,\n-        region_rels: &RegionRelations<'_, '_, 'tcx>,\n         var_values: &mut LexicalRegionResolutions<'tcx>,\n     ) {\n         self.iterate_until_fixed_point(\"Expansion\", |constraint, origin| {\n             debug!(\"expansion: constraint={:?} origin={:?}\", constraint, origin);\n             match *constraint {\n                 Constraint::RegSubVar(a_region, b_vid) => {\n                     let b_data = var_values.value_mut(b_vid);\n-                    self.expand_node(region_rels, a_region, b_vid, b_data)\n+                    self.expand_node(a_region, b_vid, b_data)\n                 }\n                 Constraint::VarSubVar(a_vid, b_vid) => match *var_values.value(a_vid) {\n                     VarValue::ErrorValue => false,\n                     VarValue::Value(a_region) => {\n                         let b_node = var_values.value_mut(b_vid);\n-                        self.expand_node(region_rels, a_region, b_vid, b_node)\n+                        self.expand_node(a_region, b_vid, b_node)\n                     }\n                 },\n                 Constraint::RegSubReg(..) | Constraint::VarSubReg(..) => {\n@@ -291,7 +214,6 @@ impl<'tcx> RegionConstraintData<'tcx> {\n \n     fn expand_node(\n         &self,\n-        region_rels: &RegionRelations<'_, '_, 'tcx>,\n         a_region: Region<'tcx>,\n         b_vid: RegionVid,\n         b_data: &mut VarValue<'tcx>,\n@@ -301,7 +223,7 @@ impl<'tcx> RegionConstraintData<'tcx> {\n         // Check if this relationship is implied by a given.\n         match *a_region {\n             ty::ReEarlyBound(_) | ty::ReFree(_) => {\n-                if self.givens.contains(&(a_region, b_vid)) {\n+                if self.data.givens.contains(&(a_region, b_vid)) {\n                     debug!(\"given\");\n                     return false;\n                 }\n@@ -311,7 +233,7 @@ impl<'tcx> RegionConstraintData<'tcx> {\n \n         match *b_data {\n             VarValue::Value(cur_region) => {\n-                let lub = self.lub_concrete_regions(region_rels, a_region, cur_region);\n+                let lub = self.lub_concrete_regions(a_region, cur_region);\n                 if lub == cur_region {\n                     return false;\n                 }\n@@ -333,16 +255,105 @@ impl<'tcx> RegionConstraintData<'tcx> {\n         }\n     }\n \n+\n+    fn lub_concrete_regions(\n+        &self,\n+        a: Region<'tcx>,\n+        b: Region<'tcx>,\n+    ) -> Region<'tcx> {\n+        let tcx = self.region_rels.tcx;\n+        match (a, b) {\n+            (&ReLateBound(..), _) | (_, &ReLateBound(..)) | (&ReErased, _) | (_, &ReErased) => {\n+                bug!(\"cannot relate region: LUB({:?}, {:?})\", a, b);\n+            }\n+\n+            (r @ &ReStatic, _) | (_, r @ &ReStatic) => {\n+                r // nothing lives longer than static\n+            }\n+\n+            (&ReEmpty, r) | (r, &ReEmpty) => {\n+                r // everything lives longer than empty\n+            }\n+\n+            (&ReVar(v_id), _) | (_, &ReVar(v_id)) => {\n+                span_bug!(\n+                    self.var_origins[v_id].span(),\n+                    \"lub_concrete_regions invoked with non-concrete \\\n+                     regions: {:?}, {:?}\",\n+                    a,\n+                    b\n+                );\n+            }\n+\n+            (&ReEarlyBound(_), &ReScope(s_id)) |\n+            (&ReScope(s_id), &ReEarlyBound(_)) |\n+            (&ReFree(_), &ReScope(s_id)) |\n+            (&ReScope(s_id), &ReFree(_)) => {\n+                // A \"free\" region can be interpreted as \"some region\n+                // at least as big as fr.scope\".  So, we can\n+                // reasonably compare free regions and scopes:\n+                let fr_scope = match (a, b) {\n+                    (&ReEarlyBound(ref br), _) | (_, &ReEarlyBound(ref br)) => {\n+                        self.region_rels.region_scope_tree.early_free_scope(self.region_rels.tcx, br)\n+                    }\n+                    (&ReFree(ref fr), _) | (_, &ReFree(ref fr)) => {\n+                        self.region_rels.region_scope_tree.free_scope(self.region_rels.tcx, fr)\n+                    }\n+                    _ => bug!(),\n+                };\n+                let r_id = self.region_rels\n+                    .region_scope_tree\n+                    .nearest_common_ancestor(fr_scope, s_id);\n+                if r_id == fr_scope {\n+                    // if the free region's scope `fr.scope` is bigger than\n+                    // the scope region `s_id`, then the LUB is the free\n+                    // region itself:\n+                    match (a, b) {\n+                        (_, &ReScope(_)) => return a,\n+                        (&ReScope(_), _) => return b,\n+                        _ => bug!(),\n+                    }\n+                }\n+\n+                // otherwise, we don't know what the free region is,\n+                // so we must conservatively say the LUB is static:\n+                tcx.types.re_static\n+            }\n+\n+            (&ReScope(a_id), &ReScope(b_id)) => {\n+                // The region corresponding to an outer block is a\n+                // subtype of the region corresponding to an inner\n+                // block.\n+                let lub = self.region_rels\n+                    .region_scope_tree\n+                    .nearest_common_ancestor(a_id, b_id);\n+                tcx.mk_region(ReScope(lub))\n+            }\n+\n+            (&ReEarlyBound(_), &ReEarlyBound(_)) |\n+            (&ReFree(_), &ReEarlyBound(_)) |\n+            (&ReEarlyBound(_), &ReFree(_)) |\n+            (&ReFree(_), &ReFree(_)) => self.region_rels.lub_free_regions(a, b),\n+\n+            // For these types, we cannot define any additional\n+            // relationship:\n+            (&ReSkolemized(..), _) | (_, &ReSkolemized(..)) => if a == b {\n+                a\n+            } else {\n+                tcx.types.re_static\n+            },\n+        }\n+    }\n+\n     /// After expansion is complete, go and check upper bounds (i.e.,\n     /// cases where the region cannot grow larger than a fixed point)\n     /// and check that they are satisfied.\n     fn collect_errors(\n         &self,\n-        region_rels: &RegionRelations<'_, '_, 'tcx>,\n         var_data: &mut LexicalRegionResolutions<'tcx>,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n     ) {\n-        for (constraint, origin) in &self.constraints {\n+        for (constraint, origin) in &self.data.constraints {\n             debug!(\n                 \"collect_errors: constraint={:?} origin={:?}\",\n                 constraint,\n@@ -354,7 +365,7 @@ impl<'tcx> RegionConstraintData<'tcx> {\n                 }\n \n                 Constraint::RegSubReg(sub, sup) => {\n-                    if region_rels.is_subregion_of(sub, sup) {\n+                    if self.region_rels.is_subregion_of(sub, sup) {\n                         continue;\n                     }\n \n@@ -385,7 +396,7 @@ impl<'tcx> RegionConstraintData<'tcx> {\n                     // Do not report these errors immediately:\n                     // instead, set the variable value to error and\n                     // collect them later.\n-                    if !region_rels.is_subregion_of(a_region, b_region) {\n+                    if !self.region_rels.is_subregion_of(a_region, b_region) {\n                         debug!(\n                             \"collect_errors: region error at {:?}: \\\n                              cannot verify that {:?}={:?} <= {:?}\",\n@@ -400,7 +411,7 @@ impl<'tcx> RegionConstraintData<'tcx> {\n             }\n         }\n \n-        for verify in &self.verifys {\n+        for verify in &self.data.verifys {\n             debug!(\"collect_errors: verify={:?}\", verify);\n             let sub = var_data.normalize(verify.region);\n \n@@ -410,7 +421,7 @@ impl<'tcx> RegionConstraintData<'tcx> {\n                 continue;\n             }\n \n-            if verify.bound.is_met(region_rels, var_data, sub) {\n+            if self.bound_is_met(&verify.bound, var_data, sub) {\n                 continue;\n             }\n \n@@ -434,7 +445,6 @@ impl<'tcx> RegionConstraintData<'tcx> {\n     /// and create a `RegionResolutionError` for each of them.\n     fn collect_var_errors(\n         &self,\n-        region_rels: &RegionRelations<'_, '_, 'tcx>,\n         var_data: &LexicalRegionResolutions<'tcx>,\n         graph: &RegionGraph<'tcx>,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n@@ -481,7 +491,6 @@ impl<'tcx> RegionConstraintData<'tcx> {\n                        starts to create problems we'll have to revisit\n                        this portion of the code and think hard about it. =) */\n                     self.collect_error_for_expanding_node(\n-                        region_rels,\n                         graph,\n                         &mut dup_vec,\n                         node_vid,\n@@ -509,7 +518,7 @@ impl<'tcx> RegionConstraintData<'tcx> {\n         let dummy_source = graph.add_node(());\n         let dummy_sink = graph.add_node(());\n \n-        for (constraint, _) in &self.constraints {\n+        for (constraint, _) in &self.data.constraints {\n             match *constraint {\n                 Constraint::VarSubVar(a_id, b_id) => {\n                     graph.add_edge(\n@@ -536,7 +545,6 @@ impl<'tcx> RegionConstraintData<'tcx> {\n \n     fn collect_error_for_expanding_node(\n         &self,\n-        region_rels: &RegionRelations<'_, '_, 'tcx>,\n         graph: &RegionGraph<'tcx>,\n         dup_vec: &mut [u32],\n         node_idx: RegionVid,\n@@ -568,7 +576,7 @@ impl<'tcx> RegionConstraintData<'tcx> {\n \n         for lower_bound in &lower_bounds {\n             for upper_bound in &upper_bounds {\n-                if !region_rels.is_subregion_of(lower_bound.region, upper_bound.region) {\n+                if !self.region_rels.is_subregion_of(lower_bound.region, upper_bound.region) {\n                     let origin = self.var_origins[node_idx].clone();\n                     debug!(\n                         \"region inference error at {:?} for {:?}: SubSupConflict sub: {:?} \\\n@@ -624,7 +632,7 @@ impl<'tcx> RegionConstraintData<'tcx> {\n \n         // to start off the process, walk the source node in the\n         // direction specified\n-        process_edges(self, &mut state, graph, orig_node_idx, dir);\n+        process_edges(&self.data, &mut state, graph, orig_node_idx, dir);\n \n         while !state.stack.is_empty() {\n             let node_idx = state.stack.pop().unwrap();\n@@ -642,7 +650,7 @@ impl<'tcx> RegionConstraintData<'tcx> {\n                 node_idx\n             );\n \n-            process_edges(self, &mut state, graph, node_idx, dir);\n+            process_edges(&self.data, &mut state, graph, node_idx, dir);\n         }\n \n         let WalkState {\n@@ -699,7 +707,7 @@ impl<'tcx> RegionConstraintData<'tcx> {\n             changed = false;\n             iteration += 1;\n             debug!(\"---- {} Iteration {}{}\", \"#\", tag, iteration);\n-            for (constraint, origin) in &self.constraints {\n+            for (constraint, origin) in &self.data.constraints {\n                 let edge_changed = body(constraint, origin);\n                 if edge_changed {\n                     debug!(\"Updated due to constraint {:?}\", constraint);\n@@ -709,38 +717,36 @@ impl<'tcx> RegionConstraintData<'tcx> {\n         }\n         debug!(\"---- {} Complete after {} iteration(s)\", tag, iteration);\n     }\n-}\n \n-impl<'tcx> fmt::Debug for RegionAndOrigin<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"RegionAndOrigin({:?},{:?})\", self.region, self.origin)\n-    }\n-}\n-\n-\n-impl<'tcx> VerifyBound<'tcx> {\n-    fn is_met(\n+    fn bound_is_met(\n         &self,\n-        region_rels: &RegionRelations<'_, '_, 'tcx>,\n+        bound: &VerifyBound<'tcx>,\n         var_values: &LexicalRegionResolutions<'tcx>,\n         min: ty::Region<'tcx>,\n     ) -> bool {\n-        match self {\n+        match bound {\n             VerifyBound::AnyRegion(rs) => rs.iter()\n                 .map(|&r| var_values.normalize(r))\n-                .any(|r| region_rels.is_subregion_of(min, r)),\n+                .any(|r| self.region_rels.is_subregion_of(min, r)),\n \n             VerifyBound::AllRegions(rs) => rs.iter()\n                 .map(|&r| var_values.normalize(r))\n-                .all(|r| region_rels.is_subregion_of(min, r)),\n+                .all(|r| self.region_rels.is_subregion_of(min, r)),\n \n-            VerifyBound::AnyBound(bs) => bs.iter().any(|b| b.is_met(region_rels, var_values, min)),\n+            VerifyBound::AnyBound(bs) => bs.iter().any(|b| self.bound_is_met(b, var_values, min)),\n \n-            VerifyBound::AllBounds(bs) => bs.iter().all(|b| b.is_met(region_rels, var_values, min)),\n+            VerifyBound::AllBounds(bs) => bs.iter().all(|b| self.bound_is_met(b, var_values, min)),\n         }\n     }\n }\n \n+impl<'tcx> fmt::Debug for RegionAndOrigin<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"RegionAndOrigin({:?},{:?})\", self.region, self.origin)\n+    }\n+}\n+\n+\n impl<'tcx> LexicalRegionResolutions<'tcx> {\n     fn normalize(&self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {"}, {"sha": "a1ad65a6c4a48ae74eae0198b70dd7cf3aeb8891", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1efcf1a115f4f4501e1a9de1e57dd3b00c0bc863/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efcf1a115f4f4501e1a9de1e57dd3b00c0bc863/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=1efcf1a115f4f4501e1a9de1e57dd3b00c0bc863", "patch": "@@ -1128,15 +1128,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 \"region_obligations not empty: {:#?}\",\n                 self.region_obligations.borrow());\n \n-        let region_rels = RegionRelations::new(self.tcx,\n-                                               region_context,\n-                                               region_map,\n-                                               free_regions);\n-        let region_data = self.region_constraints.borrow_mut()\n-                                                 .take()\n-                                                 .expect(\"regions already resolved\")\n-                                                 .into_data();\n-        let (lexical_region_resolutions, errors) = region_data.resolve_regions(&region_rels);\n+        let region_rels = &RegionRelations::new(self.tcx,\n+                                                region_context,\n+                                                region_map,\n+                                                free_regions);\n+        let (var_origins, data) = self.region_constraints.borrow_mut()\n+                                                         .take()\n+                                                         .expect(\"regions already resolved\")\n+                                                         .into_origins_and_data();\n+        let (lexical_region_resolutions, errors) =\n+            lexical_region_resolve::resolve(region_rels, var_origins, data);\n \n         let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n         assert!(old_value.is_none());"}, {"sha": "36e5e3039572ada804f6c0130b9c8c9405c26839", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1efcf1a115f4f4501e1a9de1e57dd3b00c0bc863/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efcf1a115f4f4501e1a9de1e57dd3b00c0bc863/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=1efcf1a115f4f4501e1a9de1e57dd3b00c0bc863", "patch": "@@ -32,10 +32,26 @@ use std::u32;\n mod taint;\n \n pub struct RegionConstraintCollector<'tcx> {\n+    /// For each `RegionVid`, the corresponding `RegionVariableOrigin`.\n+    pub var_origins: IndexVec<RegionVid, RegionVariableOrigin>,\n+\n     data: RegionConstraintData<'tcx>,\n+\n+    /// For a given pair of regions (R1, R2), maps to a region R3 that\n+    /// is designated as their LUB (edges R1 <= R3 and R2 <= R3\n+    /// exist). This prevents us from making many such regions.\n     lubs: CombineMap<'tcx>,\n+\n+    /// For a given pair of regions (R1, R2), maps to a region R3 that\n+    /// is designated as their GLB (edges R3 <= R1 and R3 <= R2\n+    /// exist). This prevents us from making many such regions.\n     glbs: CombineMap<'tcx>,\n+\n+    /// Number of skolemized variables currently active.\n     skolemization_count: u32,\n+\n+    /// Global counter used during the GLB algorithm to create unique\n+    /// names for fresh bound regions\n     bound_count: u32,\n \n     /// The undo log records actions that might later be undone.\n@@ -49,20 +65,25 @@ pub struct RegionConstraintCollector<'tcx> {\n     /// back.\n     undo_log: Vec<UndoLogEntry<'tcx>>,\n \n+    /// When we add a R1 == R2 constriant, we currently add (a) edges\n+    /// R1 <= R2 and R2 <= R1 and (b) we unify the two regions in this\n+    /// table. You can then call `opportunistic_resolve_var` early\n+    /// which will map R1 and R2 to some common region (i.e., either\n+    /// R1 or R2). This is important when dropck and other such code\n+    /// is iterating to a fixed point, because otherwise we sometimes\n+    /// would wind up with a fresh stream of region variables that\n+    /// have been equated but appear distinct.\n     unification_table: UnificationTable<ty::RegionVid>,\n }\n \n pub type VarOrigins = IndexVec<RegionVid, RegionVariableOrigin>;\n \n /// The full set of region constraints gathered up by the collector.\n-/// Describes a set of region variables ranging from 0..N (where N is\n-/// the length of the `var_origins` vector), and various constraints\n-/// between them.\n+/// Describes constraints between the region variables and other\n+/// regions, as well as other conditions that must be verified, or\n+/// assumptions that can be made.\n #[derive(Default)]\n pub struct RegionConstraintData<'tcx> {\n-    /// For each `RegionVid`, the corresponding `RegionVariableOrigin`.\n-    pub var_origins: IndexVec<RegionVid, RegionVariableOrigin>,\n-\n     /// Constraints of the form `A <= B`, where either `A` or `B` can\n     /// be a region variable (or neither, as it happens).\n     pub constraints: BTreeMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n@@ -252,6 +273,7 @@ impl TaintDirections {\n impl<'tcx> RegionConstraintCollector<'tcx> {\n     pub fn new() -> RegionConstraintCollector<'tcx> {\n         RegionConstraintCollector {\n+            var_origins: VarOrigins::default(),\n             data: RegionConstraintData::default(),\n             lubs: FxHashMap(),\n             glbs: FxHashMap(),\n@@ -263,8 +285,8 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     }\n \n     /// Once all the constraints have been gathered, extract out the final data.\n-    pub fn into_data(self) -> RegionConstraintData<'tcx> {\n-        self.data\n+    pub fn into_origins_and_data(self) -> (VarOrigins, RegionConstraintData<'tcx>) {\n+        (self.var_origins, self.data)\n     }\n \n     fn in_snapshot(&self) -> bool {\n@@ -324,8 +346,8 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n                 // nothing to do here\n             }\n             AddVar(vid) => {\n-                self.data.var_origins.pop().unwrap();\n-                assert_eq!(self.data.var_origins.len(), vid.index as usize);\n+                self.var_origins.pop().unwrap();\n+                assert_eq!(self.var_origins.len(), vid.index as usize);\n             }\n             AddConstraint(ref constraint) => {\n                 self.data.constraints.remove(constraint);\n@@ -347,7 +369,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     }\n \n     pub fn new_region_var(&mut self, origin: RegionVariableOrigin) -> RegionVid {\n-        let vid = self.data.var_origins.push(origin.clone());\n+        let vid = self.var_origins.push(origin.clone());\n \n         let u_vid = self.unification_table\n             .new_key(unify_key::RegionVidKey { min_vid: vid });\n@@ -363,8 +385,9 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         return vid;\n     }\n \n+    /// Returns the origin for the given variable.\n     pub fn var_origin(&self, vid: RegionVid) -> RegionVariableOrigin {\n-        self.data.var_origins[vid].clone()\n+        self.var_origins[vid].clone()\n     }\n \n     /// Creates a new skolemized region. Skolemized regions are fresh\n@@ -862,9 +885,3 @@ impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n         }\n     }\n }\n-\n-impl<'tcx> RegionConstraintData<'tcx> {\n-    pub fn num_vars(&self) -> usize {\n-        self.var_origins.len()\n-    }\n-}"}]}