{"sha": "62e827cfc7b76c0a8a2485fb421f6f41af289048", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyZTgyN2NmYzdiNzZjMGE4YTI0ODVmYjQyMWY2ZjQxYWYyODkwNDg=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-13T18:12:16Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-13T18:12:16Z"}, "message": "rewrite intro", "tree": {"sha": "780e7d84c156c83d5f1d9b043faa7cde423a76b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/780e7d84c156c83d5f1d9b043faa7cde423a76b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62e827cfc7b76c0a8a2485fb421f6f41af289048", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62e827cfc7b76c0a8a2485fb421f6f41af289048", "html_url": "https://github.com/rust-lang/rust/commit/62e827cfc7b76c0a8a2485fb421f6f41af289048", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62e827cfc7b76c0a8a2485fb421f6f41af289048/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acd3c5947a4b85113a0c21d435dec5bd1bd22956", "url": "https://api.github.com/repos/rust-lang/rust/commits/acd3c5947a4b85113a0c21d435dec5bd1bd22956", "html_url": "https://github.com/rust-lang/rust/commit/acd3c5947a4b85113a0c21d435dec5bd1bd22956"}], "stats": {"total": 356, "additions": 202, "deletions": 154}, "files": [{"sha": "874f6f2ac61211038f544a7e06471cb8f8b7333c", "filename": "README.md", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/62e827cfc7b76c0a8a2485fb421f6f41af289048/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/62e827cfc7b76c0a8a2485fb421f6f41af289048/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=62e827cfc7b76c0a8a2485fb421f6f41af289048", "patch": "@@ -1,20 +1,39 @@\n-% The Unsafe Rust Programming Language\n+% The Advanced Rust Programming Language\n \n # NOTE: This is a draft document, and may contain serious errors\n \n-**This document is about advanced functionality and low-level development practices\n-in the Rust Programming Language. Most of the things discussed won't matter\n-to the average Rust programmer. However if you wish to correctly write unsafe\n-code in Rust, this text contains invaluable information.**\n+So you've played around with Rust a bit. You've written a few simple programs and\n+you think you grok the basics. Maybe you've even read through\n+*[The Rust Programming Language][trpl]*. Now you want to get neck-deep in all the\n+nitty-gritty details of the language. You want to know those weird corner-cases.\n+You want to know what the heck `unsafe` really means, and how to properly use it.\n+This is the book for you.\n \n-The Unsafe Rust Programming Language (TURPL) seeks to complement\n-[The Rust Programming Language Book][trpl] (TRPL).\n-Where TRPL introduces the language and teaches the basics, TURPL dives deep into\n-the specification of the language, and all the nasty bits necessary to write\n-Unsafe Rust. TURPL does not assume you have read TRPL, but does assume you know\n-the basics of the language and systems programming. We will not explain the\n-stack or heap. We will not explain the basic syntax.\n+To be clear, this book goes into *serious* detail. We're going to dig into\n+exception-safety and pointer aliasing. We're going to talk about memory\n+models. We're even going to do some type-theory. This is stuff that you\n+absolutely *don't* need to know to write fast and safe Rust programs.\n+You could probably close this book *right now* and still have a productive\n+and happy career in Rust.\n \n+However if you intend to write unsafe code -- or just *really* want to dig into\n+the guts of the language -- this book contains *invaluable* information.\n \n+Unlike *The Rust Programming Language* we *will* be assuming considerable prior\n+knowledge. In particular, you should be comfortable with:\n \n-[trpl]: https://doc.rust-lang.org/book/\n\\ No newline at end of file\n+* Basic Systems Programming:\n+    * Pointers\n+    * [The stack and heap][]\n+    * The memory hierarchy (caches)\n+    * Threads\n+\n+* [Basic Rust][]\n+\n+Due to the nature of advanced Rust programming, we will be spending a lot of time\n+talking about *safety* and *guarantees*. In particular, a significant portion of\n+the book will be dedicated to correctly writing and understanding Unsafe Rust.\n+\n+[trpl]: https://doc.rust-lang.org/book/\n+[The stack and heap]: https://doc.rust-lang.org/book/the-stack-and-the-heap.html\n+[Basic Rust]: https://doc.rust-lang.org/book/syntax-and-semantics.html"}, {"sha": "dc494d2b0c9400c8cb967a46ea3a76aba3b130c9", "filename": "SUMMARY.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62e827cfc7b76c0a8a2485fb421f6f41af289048/SUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/62e827cfc7b76c0a8a2485fb421f6f41af289048/SUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/SUMMARY.md?ref=62e827cfc7b76c0a8a2485fb421f6f41af289048", "patch": "@@ -1,7 +1,7 @@\n # Summary\n \n * [Meet Safe and Unsafe](meet-safe-and-unsafe.md)\n-\t* [What Do Safe and Unsafe Mean](safe-unsafe-meaning.md)\n+\t* [How Safe and Unsafe Interact](safe-unsafe-meaning.md)\n \t* [Working with Unsafe](working-with-unsafe.md)\n * [Data Layout](data.md)\n \t* [repr(Rust)](repr-rust.md)"}, {"sha": "5ff000f2bbce9d486a1d41dd64edb2f4c8c0ace8", "filename": "meet-safe-and-unsafe.md", "status": "modified", "additions": 95, "deletions": 79, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/62e827cfc7b76c0a8a2485fb421f6f41af289048/meet-safe-and-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/62e827cfc7b76c0a8a2485fb421f6f41af289048/meet-safe-and-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/meet-safe-and-unsafe.md?ref=62e827cfc7b76c0a8a2485fb421f6f41af289048", "patch": "@@ -1,82 +1,98 @@\n % Meet Safe and Unsafe\n \n-Safe and Unsafe are Rust's chief engineers.\n-\n-TODO: ADORABLE PICTURES OMG\n-\n-Unsafe handles all the dangerous internal stuff. They build the foundations\n-and handle all the dangerous materials. By all accounts, Unsafe is really a bit\n-unproductive, because the nature of their work means that they have to spend a\n-lot of time checking and double-checking everything. What if there's an earthquake\n-on a leap year? Are we ready for that? Unsafe better be, because if they get\n-*anything* wrong, everything will blow up! What Unsafe brings to the table is\n-*quality*, not quantity. Still, nothing would ever get done if everything was\n-built to Unsafe's standards!\n-\n-That's where Safe comes in. Safe has to handle *everything else*. Since Safe needs\n-to *get work done*, they've grown to be fairly careless and clumsy! Safe doesn't worry\n-about all the crazy eventualities that Unsafe does, because life is too short to deal\n-with leap-year-earthquakes. Of course, this means there's some jobs that Safe just\n-can't handle. Safe is all about quantity over quality.\n-\n-Unsafe loves Safe to bits, but knows that they *can never trust them to do the\n-right thing*. Still, Unsafe acknowledges that not every problem needs quite the\n-attention to detail that they apply. Indeed, Unsafe would *love* if Safe could do\n-*everything* for them. To accomplish this, Unsafe spends most of their time\n-building *safe abstractions*. These abstractions handle all the nitty-gritty\n-details for Safe, and choose good defaults so that the simplest solution (which\n-Safe will inevitably use) is usually the *right* one. Once a safe abstraction is\n-built, Unsafe ideally needs to never work on it again, and Safe can blindly use\n-it in all their work.\n-\n-Unsafe's attention to detail means that all the things that they mark as ok for\n-Safe to use can be combined in arbitrarily ridiculous ways, and all the rules\n-that Unsafe is forced to uphold will never be violated. If they *can* be violated\n-by Safe, that means *Unsafe*'s the one in the wrong. Safe can work carelessly,\n-knowing that if anything blows up, it's not *their* fault. Safe can also call in\n-Unsafe at any time if there's a hard problem they can't quite work out, or if they\n-can't meet the client's quality demands. Of course, Unsafe will beg and plead Safe\n-to try their latest safe abstraction first!\n-\n-In addition to being adorable, Safe and Unsafe are what makes Rust possible.\n-Rust can be thought of as two different languages: Safe Rust, and Unsafe Rust.\n-Any time someone opines the guarantees of Rust, they are almost surely talking about\n-Safe. However Safe is not sufficient to write every program. For that,\n-we need the Unsafe superset.\n-\n-Most fundamentally, writing bindings to other languages\n-(such as the C exposed by your operating system) is never going to be safe. Rust\n-can't control what other languages do to program execution! However Unsafe is\n-also necessary to construct fundamental abstractions where the type system is not\n-sufficient to automatically prove what you're doing is sound.\n-\n-Indeed, the Rust standard library is implemented in Rust, and it makes substantial\n-use of Unsafe for implementing IO, memory allocation, collections,\n-synchronization, and other low-level computational primitives.\n-\n-Upon hearing this, many wonder why they would not simply just use C or C++ in place of\n-Rust (or just use a \"real\" safe language). If we're going to do unsafe things, why not\n-lean on these much more established languages?\n-\n-The most important difference between C++ and Rust is a matter of defaults:\n-Rust is 100% safe by default. Even when you *opt out* of safety in Rust, it is a modular\n-action. In deciding to work with unchecked uninitialized memory, this does not\n-suddenly make dangling or null pointers a problem. When using unchecked indexing on `x`,\n-one does not have to suddenly worry about indexing out of bounds on `y`.\n-C and C++, by contrast, have pervasive unsafety baked into the language. Even the\n-modern best practices like `unique_ptr` have various safety pitfalls.\n-\n-It cannot be emphasized enough that Unsafe should be regarded as an exceptional\n-thing, not a normal one. Unsafe is often the domain of *fundamental libraries*: anything that needs\n-to make FFI bindings or define core abstractions. These fundamental libraries then expose\n-a safe interface for intermediate libraries and applications to build upon. And these\n-safe interfaces make an important promise: if your application segfaults, it's not your\n-fault. *They* have a bug.\n-\n-And really, how is that different from *any* safe language? Python, Ruby, and Java libraries\n-can internally do all sorts of nasty things. The languages themselves are no\n-different. Safe languages *regularly* have bugs that cause critical vulnerabilities.\n-The fact that Rust is written with a healthy spoonful of Unsafe is no different.\n-However it *does* mean that Rust doesn't need to fall back to the pervasive unsafety of\n-C to do the nasty things that need to get done.\n+Programmers in safe \"high-level\" languages face a fundamental dilemma. On one\n+hand, it would be *really* great to just say what you want and not worry about\n+how it's done. On the other hand, that can lead to some *really* poor\n+performance. It may be necessary to drop down to less clear or idiomatic\n+practices to get the performance characteristics you want. Or maybe you just\n+throw up your hands in disgust and decide to shell out to an implementation in\n+a less sugary-wonderful *unsafe* language.\n \n+Worse, when you want to talk directly to the operating system, you *have* to\n+talk to an unsafe language: *C*. C is ever-present and unavoidable. It's the\n+lingua-franca of the programming world.\n+Even other safe languages generally expose C interfaces for the world at large!\n+Regardless of *why* you're doing it, as soon as your program starts talking to\n+C it stops being safe.\n+\n+With that said, Rust is *totally* a safe programming language.\n+\n+Well, Rust *has* a safe programming language. Let's step back a bit.\n+\n+Rust can be thought of as being composed of two\n+programming languages: *Safe* and *Unsafe*. Safe is For Reals Totally Safe.\n+Unsafe, unsurprisingly, is *not* For Reals Totally Safe. In fact, Unsafe lets\n+you do some really crazy unsafe things.\n+\n+Safe is *the* Rust programming language. If all you do is write Safe Rust,\n+you will never have to worry about type-safety or memory-safety. You will never\n+endure a null or dangling pointer, or any of that Undefined Behaviour nonsense.\n+\n+*That's totally awesome*.\n+\n+The standard library also gives you enough utilities out-of-the-box that you'll\n+be able to write awesome high-performance applications and libraries in pure\n+idiomatic Safe Rust.\n+\n+But maybe you want to talk to another language. Maybe you're writing a\n+low-level abstraction not exposed by the standard library. Maybe you're\n+*writing* the standard library (which is written entirely in Rust). Maybe you\n+need to do something the type-system doesn't understand and just *frob some dang\n+bits*. Maybe you need Unsafe Rust.\n+\n+Unsafe Rust is exactly like Safe Rust with *all* the same rules and semantics.\n+However Unsafe Rust lets you do some *extra* things that are Definitely Not Safe.\n+\n+The only things that are different in Unsafe Rust are that you can:\n+\n+* Dereference raw pointers\n+* Call `unsafe` functions (including C functions, intrinsics, and the raw allocator)\n+* Implement `unsafe` traits\n+* Mutate statics\n+\n+That's it. The reason these operations are relegated to Unsafe is that misusing\n+any of these things will cause the ever dreaded Undefined Behaviour. Invoking\n+Undefined Behaviour gives the compiler full rights to do arbitrarily bad things\n+to your program. You definitely *should not* invoke Undefined Behaviour.\n+\n+Unlike C, Undefined Behaviour is pretty limited in scope in Rust. All the core\n+language cares about is preventing the following things:\n+\n+* Dereferencing null or dangling pointers\n+* Reading [uninitialized memory][]\n+* Breaking the [pointer aliasing rules][]\n+* Producing invalid primitive values:\n+    * dangling/null references\n+    * a `bool` that isn't 0 or 1\n+    * an undefined `enum` discriminant\n+    * a `char` outside the ranges [0x0, 0xD7FF] and [0xE000, 0x10FFFF]\n+    * A non-utf8 `str`\n+* Unwinding into another language\n+* Causing a [data race][race]\n+* Double-dropping a value\n+\n+That's it. That's all the Undefined Behaviour baked into Rust. Of course, unsafe\n+functions and traits are free to declare arbitrary other constraints that a\n+program must maintain to avoid Undefined Behaviour. However these are generally\n+just things that will transitively lead to one of the above problems. Some\n+additional constraints may also derive from compiler intrinsics that make special\n+assumptions about how code can be optimized.\n+\n+Rust is otherwise quite permissive with respect to other dubious operations. Rust\n+considers it \"safe\" to:\n+\n+* Deadlock\n+* Have a [race condition][race]\n+* Leak memory\n+* Fail to call destructors\n+* Overflow integers\n+* Abort the program\n+* Delete the production database\n+\n+However any program that actually manages to do such a thing is *probably*\n+incorrect. Rust provides lots of tools to make these things rare, but\n+these problems are considered impractical to categorically prevent.\n+\n+[pointer aliasing rules]: references.html\n+[uninitialized memory]: uninitialized.html\n+[race]: races.html"}, {"sha": "082970d203872cbd31a8678dbd5f7fa1047cc13d", "filename": "safe-unsafe-meaning.md", "status": "modified", "additions": 51, "deletions": 54, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/62e827cfc7b76c0a8a2485fb421f6f41af289048/safe-unsafe-meaning.md", "raw_url": "https://github.com/rust-lang/rust/raw/62e827cfc7b76c0a8a2485fb421f6f41af289048/safe-unsafe-meaning.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/safe-unsafe-meaning.md?ref=62e827cfc7b76c0a8a2485fb421f6f41af289048", "patch": "@@ -1,38 +1,17 @@\n-% What do Safe and Unsafe really mean?\n-\n-Rust cares about preventing the following things:\n-\n-* Dereferencing null or dangling pointers\n-* Reading [uninitialized memory][]\n-* Breaking the [pointer aliasing rules][]\n-* Producing invalid primitive values:\n-    * dangling/null references\n-    * a `bool` that isn't 0 or 1\n-    * an undefined `enum` discriminant\n-    * a `char` larger than char::MAX (TODO: check if stronger restrictions apply)\n-    * A non-utf8 `str`\n-* Unwinding into another language\n-* Causing a [data race][]\n-* Invoking Misc. Undefined Behaviour (in e.g. compiler intrinsics)\n-\n-That's it. That's all the Undefined Behaviour in Rust. Libraries are free to\n-declare arbitrary requirements if they could transitively cause memory safety\n-issues, but it all boils down to the above actions. Rust is otherwise\n-quite permisive with respect to other dubious operations. Rust considers it\n-\"safe\" to:\n-\n-* Deadlock\n-* Have a Race Condition\n-* Leak memory\n-* Fail to call destructors\n-* Overflow integers\n-* Delete the production database\n-\n-However any program that does such a thing is *probably* incorrect. Rust\n-provides lots of tools to make doing these things rare, but these problems are\n-considered impractical to categorically prevent.\n-\n-Rust models the seperation between Safe and Unsafe with the `unsafe` keyword.\n+% How Safe and Unsafe Interact\n+\n+So what's the relationship between Safe and Unsafe? How do they interact?\n+\n+Rust models the seperation between Safe and Unsafe with the `unsafe` keyword, which\n+can be thought as a sort of *foreign function interface* (FFI) between Safe and Unsafe.\n+This is the magic behind why we can say Safe is a safe language: all the scary unsafe\n+bits are relagated *exclusively* to FFI *just like every other safe language*.\n+\n+However because one language is a subset of the other, the two can be cleanly\n+intermixed as long as the boundary between Safe and Unsafe is denoted with the\n+`unsafe` keyword. No need to write headers, initialize runtimes, or any of that\n+other FFI boiler-plate.\n+\n There are several places `unsafe` can appear in Rust today, which can largely be\n grouped into two categories:\n \n@@ -44,7 +23,7 @@ you to write `unsafe` elsewhere:\n       the danger.\n     * On trait declarations, `unsafe` is declaring that *implementing* the trait\n       is an unsafe operation, as it has contracts that other unsafe code is free to\n-      trust blindly.\n+      trust blindly. (More on this below.)\n \n * I am declaring that I have, to the best of my knowledge, adhered to the\n unchecked contracts:\n@@ -55,14 +34,14 @@ unchecked contracts:\n \n There is also `#[unsafe_no_drop_flag]`, which is a special case that exists for\n historical reasons and is in the process of being phased out. See the section on\n-[destructors][] for details.\n+[drop flags][] for details.\n \n Some examples of unsafe functions:\n \n * `slice::get_unchecked` will perform unchecked indexing, allowing memory\n   safety to be freely violated.\n * `ptr::offset` is an intrinsic that invokes Undefined Behaviour if it is\n-  not \"in bounds\" as defined by LLVM (see the lifetimes section for details).\n+  not \"in bounds\" as defined by LLVM.\n * `mem::transmute` reinterprets some value as having the given type,\n   bypassing type safety in arbitrary ways. (see [conversions][] for details)\n * All FFI functions are `unsafe` because they can do arbitrary things.\n@@ -72,14 +51,34 @@ Some examples of unsafe functions:\n As of Rust 1.0 there are exactly two unsafe traits:\n \n * `Send` is a marker trait (it has no actual API) that promises implementors\n-  are safe to send to another thread.\n+  are safe to send (move) to another thread.\n * `Sync` is a marker trait that promises that threads can safely share\n   implementors through a shared reference.\n \n-The need for unsafe traits boils down to the fundamental lack of trust that Unsafe\n-has for Safe. All safe traits are free to declare arbitrary contracts, but because\n-implementing them is a job for Safe, Unsafe can't trust those contracts to actually\n-be upheld.\n+The need for unsafe traits boils down to the fundamental property of safe code:\n+\n+**No matter how completely awful Safe code is, it can't cause Undefined\n+Behaviour.**\n+\n+This means that Unsafe, **the royal vanguard of Undefined Behaviour**, has to be\n+*super paranoid* about generic safe code. Unsafe is free to trust *specific* safe\n+code (or else you would degenerate into infinite spirals of paranoid despair).\n+It is generally regarded as ok to trust the standard library to be correct, as\n+std is effectively an extension of the language (and you *really* just have to trust\n+the language). If `std` fails to uphold the guarantees it declares, then it's\n+basically a language bug.\n+\n+That said, it would be best to minimize *needlessly* relying on properties of\n+concrete safe code. Bugs happen! Of course, I must reinforce that this is only\n+a concern for Unsafe code. Safe code can't blindly trust anyone and everyone\n+as far as basic memory-safety is concerned.\n+\n+On the other hand, safe traits are free to declare arbitrary contracts, but because\n+implementing them is Safe, Unsafe can't trust those contracts to actually\n+be upheld. This is different from the concrete case because *anyone* can\n+randomly implement the interface. There is something fundamentally different\n+about trusting a *particular* piece of code to be correct, and trusting *all the\n+code that will ever be written* to be correct.\n \n For instance Rust has `PartialOrd` and `Ord` traits to try to differentiate\n between types which can \"just\" be compared, and those that actually implement a\n@@ -99,26 +98,26 @@ destructors will be successfully called! Hooray!\n However BTreeMap is implemented using a modest spoonful of Unsafe (most collections\n are). That means that it is not necessarily *trivially true* that a bad Ord\n implementation will make BTreeMap behave safely. Unsafe must be sure not to rely\n-on Ord *where safety is at stake*, because Ord is provided by Safe, and memory\n-safety is not Safe's responsibility to uphold. *It must be impossible for Safe\n-code to violate memory safety*.\n+on Ord *where safety is at stake*. Ord is provided by Safe, and safety is not\n+Safe's responsibility to uphold.\n \n But wouldn't it be grand if there was some way for Unsafe to trust *some* trait\n contracts *somewhere*? This is the problem that unsafe traits tackle: by marking\n *the trait itself* as unsafe *to implement*, Unsafe can trust the implementation\n-to be correct (because Unsafe can trust themself).\n+to be correct.\n \n Rust has traditionally avoided making traits unsafe because it makes Unsafe\n pervasive, which is not desirable. Send and Sync are unsafe is because\n thread safety is a *fundamental property* that Unsafe cannot possibly hope to\n defend against in the same way it would defend against a bad Ord implementation.\n The only way to possibly defend against thread-unsafety would be to *not use\n threading at all*. Making every operation atomic isn't even sufficient, because\n-it's possible for complex invariants between disjoint locations in memory.\n+it's possible for complex invariants to exist between disjoint locations in\n+memory. For instance, the pointer and capacity of a Vec must be in sync.\n \n Even concurrent paradigms that are traditionally regarded as Totally Safe like\n message passing implicitly rely on some notion of thread safety -- are you\n-really message-passing if you send a *pointer*? Send and Sync therefore require\n+really message-passing if you pass a *pointer*? Send and Sync therefore require\n some *fundamental* level of trust that Safe code can't provide, so they must be\n unsafe to implement. To help obviate the pervasive unsafety that this would\n introduce, Send (resp. Sync) is *automatically* derived for all types composed only\n@@ -128,8 +127,6 @@ primitives).\n \n \n \n-[pointer aliasing rules]: lifetimes.html#references\n-[uninitialized memory]: uninitialized.html\n-[data race]: concurrency.html\n-[destructors]: raii.html\n-[conversions]: conversions.html\n\\ No newline at end of file\n+\n+[drop flags]: drop-flags.html\n+[conversions]: conversions.html"}, {"sha": "b1174a74c0bcc141d71262942cccb55be7c02f9a", "filename": "working-with-unsafe.md", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/62e827cfc7b76c0a8a2485fb421f6f41af289048/working-with-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/62e827cfc7b76c0a8a2485fb421f6f41af289048/working-with-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/working-with-unsafe.md?ref=62e827cfc7b76c0a8a2485fb421f6f41af289048", "patch": "@@ -1,11 +1,11 @@\n % Working with Unsafe\n \n-Rust generally only gives us the tools to talk about safety in a scoped and\n-binary manner. Unfortunately reality is significantly more complicated than that.\n+Rust generally only gives us the tools to talk about Unsafe in a scoped and\n+binary manner. Unfortunately, reality is significantly more complicated than that.\n For instance, consider the following toy function:\n \n ```rust\n-fn do_idx(idx: usize, arr: &[u8]) -> Option<u8> {\n+pub fn index(idx: usize, arr: &[u8]) -> Option<u8> {\n     if idx < arr.len() {\n         unsafe {\n             Some(*arr.get_unchecked(idx))\n@@ -22,7 +22,7 @@ function, the scope of the unsafe block is questionable. Consider changing the\n `<` to a `<=`:\n \n ```rust\n-fn do_idx(idx: usize, arr: &[u8]) -> Option<u8> {\n+pub fn index(idx: usize, arr: &[u8]) -> Option<u8> {\n     if idx <= arr.len() {\n         unsafe {\n             Some(*arr.get_unchecked(idx))\n@@ -45,7 +45,7 @@ implementation of `Vec`:\n \n ```rust\n // Note this defintion is insufficient. See the section on lifetimes.\n-struct Vec<T> {\n+pub struct Vec<T> {\n     ptr: *mut T,\n     len: usize,\n     cap: usize,\n@@ -55,7 +55,7 @@ struct Vec<T> {\n // We currently live in a nice imaginary world of only positive fixed-size\n // types.\n impl<T> Vec<T> {\n-    fn push(&mut self, elem: T) {\n+    pub fn push(&mut self, elem: T) {\n         if self.len == self.cap {\n             // not important for this example\n             self.reallocate();\n@@ -80,9 +80,25 @@ adding the following method:\n \n This code is safe, but it is also completely unsound. Changing the capacity\n violates the invariants of Vec (that `cap` reflects the allocated space in the\n-Vec). This is not something the rest of `Vec` can guard against. It *has* to\n+Vec). This is not something the rest of Vec can guard against. It *has* to\n trust the capacity field because there's no way to verify it.\n \n `unsafe` does more than pollute a whole function: it pollutes a whole *module*.\n Generally, the only bullet-proof way to limit the scope of unsafe code is at the\n module boundary with privacy.\n+\n+However this works *perfectly*. The existence of `make_room` is *not* a\n+problem for the soundness of Vec because we didn't mark it as public. Only the\n+module that defines this function can call it. Also, `make_room` directly\n+accesses the private fields of Vec, so it can only be written in the same module\n+as Vec.\n+\n+It is therefore possible for us to write a completely safe abstraction that\n+relies on complex invariants. This is *critical* to the relationship between\n+Safe Rust and Unsafe Rust. We have already seen that Unsafe code must trust\n+*some* Safe code, but can't trust *arbitrary* Safe code. However if Unsafe\n+couldn't prevent client Safe code from messing with its state in arbitrary ways,\n+safety would be a lost cause.\n+\n+Safety lives!\n+"}]}