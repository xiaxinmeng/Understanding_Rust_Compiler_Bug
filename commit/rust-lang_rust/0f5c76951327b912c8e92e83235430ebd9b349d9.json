{"sha": "0f5c76951327b912c8e92e83235430ebd9b349d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmNWM3Njk1MTMyN2I5MTJjOGU5MmU4MzIzNTQzMGViZDliMzQ5ZDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-12T05:52:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-12T05:52:14Z"}, "message": "Auto merge of #75756 - jyn514:diagnostic-suggestions, r=estebank\n\nImprove suggestions for broken intra-doc links\n\n~~Depends on #74489 and should not be merged before that PR.~~ Merged \ud83c\udf89\n~~Depends on #75916 and should not be merged before.~~ Merged\n\nFixes https://github.com/rust-lang/rust/issues/75305.\n\nThis does a lot of different things \ud83d\ude06.\n\n- Add `PerNS::into_iter()` so I didn't have to keep rewriting hacks around it. Also add `PerNS::iter()` for consistency. Let me know if this should be `impl IntoIterator` instead.\n- Make `ResolutionFailure` an enum instead of a unit variant. This was most of the changes: everywhere that said `ErrorKind::ResolutionFailure` now has to say _why_ the link failed to resolve.\n- Store the resolution in case of an anchor failure. Previously this was implemented as variants on `AnchorFailure` which was prone to typos and had inconsistent output compared to the rest of the diagnostics.\n- Turn some `Err`ors into unwrap() or panic()s, because they're rustdoc bugs and not user error. These have comments as to why they're bugs (in particular this would have caught #76073 as a bug a while ago).\n- If an item is not in scope at all, say the first segment in the path that failed to resolve\n- If an item exists but not in the current namespaces, say that and suggests linking to that namespace.\n- If there is a partial resolution for an item (part of the segments resolved, but not all of them), say the partial resolution and why the following segment didn't resolve.\n- Add the `DefId` of associated items to `kind_side_channel` so it can be used for diagnostics (tl;dr of the hack: the rest of rustdoc expects the id of the item, but for diagnostics we need the associated item).\n- No longer suggests escaping the brackets for every link that failed to resolve; this was pretty obnoxious. Now it only suggests `\\[ \\]` if no segment resolved and there is no `::` in the link.\n- Add `Suggestion`, which says _what_ to prefix the link with, not just 'prefix with the item kind'.\n\nPlaces where this is currently buggy:\n\n<details><summary>All outdated</summary>\n\n~~1. When the link has the wrong namespace:~~ Now fixed.\n\n<details>\n\n```rust\n/// [type@S::h]\nimpl S {\n\tpub fn h() {}\n}\n\n/// [type@T::g]\npub trait T {\n\tfn g() {}\n}\n```\n```\nerror: unresolved link to `T::g`\n  --> /home/joshua/rustc/src/test/rustdoc-ui/intra-link-errors.rs:53:6\n   |\n53 | /// [type@T::g]\n   |      ^^^^^^^^^\n   |\n   = note: this link partially resolves to the trait `T`,\n   = note: `T` has no field, variant, or associated item named `g`\n\nerror: unresolved link to `S::h`\n  --> /home/joshua/rustc/src/test/rustdoc-ui/intra-link-errors.rs:48:6\n   |\n48 | /// [type@S::h]\n   |      ^^^^^^^^^\n   |\n   = note: this link partially resolves to the struct `S`,\n   = note: `S` has no field, variant, or associated item named `h`\n```\nInstead it should suggest changing the disambiguator, the way it currently does for macros:\n```\nerror: unresolved link to `S`\n  --> /home/joshua/rustc/src/test/rustdoc-ui/intra-link-errors.rs:38:6\n   |\n38 | /// [S!]\n   |      ^^ help: to link to the unit struct, use its disambiguator: `value@S`\n   |\n   = note: this link resolves to the unit struct `S`, which is not in the macro namespace\n```\n\n</details>\n\n2. ~~Associated items for values. It says that the value isn't in scope; instead it should say that values can't have associated items.~~ Fixed.\n\n<details>\n\n```\nerror: unresolved link to `f::A`\n  --> /home/joshua/rustc/src/test/rustdoc-ui/intra-link-errors.rs:14:6\n   |\n14 | /// [f::A]\n   |      ^^^^\n   |\n   = note: no item named `f` is in scope\n   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n```\nThis is _mostly_ fixed, it now says\n\n```rust\nwarning: unresolved link to `f::A`\n --> /home/joshua/test-rustdoc/f.rs:1:6\n  |\n1 | /// [f::A]\n  |      ^^^^\n  |\n  = note: this link partially resolves to the function `f`\n  = note: `f` is a function, not a module\n```\n\n'function, not a module' seems awfully terse when what I actually mean is '`::` isn't allowed here', though.\n\n</details>\n\nIt looks a lot nicer now, it says\n\n```\nerror: unresolved link to `f::A`\n  --> /home/joshua/rustc/src/test/rustdoc-ui/intra-link-errors.rs:13:6\n   |\n13 | /// [f::A]\n   |      ^^^^\n   |\n   = note: `f` is a function, not a module or type, and cannot have associated items\n```\n\n3. ~~I'm also not very happy with the second note for this error:~~\n\n<details>\n```\nerror: unresolved link to `S::A`\n  --> /home/joshua/rustc/src/test/rustdoc-ui/intra-link-errors.rs:19:6\n   |\n19 | /// [S::A]\n   |      ^^^^\n   |\n   = note: this link partially resolves to the struct `S`,\n   = note: `S` has no field, variant, or associated item named `A`\n```\n\nbut I'm not sure how better to word it.\n\nI ended up going with 'no `A` in `S`' to match `rustc_resolve` but that seems terse as well.\n\n</details>\n\nThis now says\n\n```\nerror: unresolved link to `S::A`\n  --> /home/joshua/rustc/src/test/rustdoc-ui/intra-link-errors.rs:17:6\n   |\n17 | /// [S::A]\n   |      ^^^^\n   |\n   = note: the struct `S` has no field or associated item named `A`\n```\n\nwhich I think looks pretty good :)\n\n4. This is minor, but it would be nice to say that `path` wasn't found instead of the full thing:\n```\nerror: unresolved link to `path::to::nonexistent::module`\n --> /home/joshua/rustc/src/test/rustdoc-ui/intra-link-errors.rs:8:6\n  |\n8 | /// [path::to::nonexistent::module]\n  |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n```\n\nIt will now look at most 3 paths up (so it reports `path::to` as not in scope), but it doesn't work with arbitrarily many paths.\n\n</details>\n\n~~I recommend only reviewing the last few commits - the first 7 are all from #74489.~~ Rebased so that only the relevant commits are shown. Let me know if I should squash the history some more.\n\nr? `@estebank`", "tree": {"sha": "2b93234a580d70cf038fc7b0d3bd247f0feaf0a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b93234a580d70cf038fc7b0d3bd247f0feaf0a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f5c76951327b912c8e92e83235430ebd9b349d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f5c76951327b912c8e92e83235430ebd9b349d9", "html_url": "https://github.com/rust-lang/rust/commit/0f5c76951327b912c8e92e83235430ebd9b349d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f5c76951327b912c8e92e83235430ebd9b349d9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b6838b6e1637b430b0c77294d938effd8e36eb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b6838b6e1637b430b0c77294d938effd8e36eb8", "html_url": "https://github.com/rust-lang/rust/commit/8b6838b6e1637b430b0c77294d938effd8e36eb8"}, {"sha": "5ea3eaf237793c978cad9d48f7850619c7f49d69", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ea3eaf237793c978cad9d48f7850619c7f49d69", "html_url": "https://github.com/rust-lang/rust/commit/5ea3eaf237793c978cad9d48f7850619c7f49d69"}], "stats": {"total": 1159, "additions": 877, "deletions": 282}, "files": [{"sha": "b019e518d0c5457b28c342d416663960dc05a23f", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f5c76951327b912c8e92e83235430ebd9b349d9/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f5c76951327b912c8e92e83235430ebd9b349d9/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=0f5c76951327b912c8e92e83235430ebd9b349d9", "patch": "@@ -6,6 +6,7 @@ use rustc_ast::NodeId;\n use rustc_macros::HashStable_Generic;\n use rustc_span::hygiene::MacroKind;\n \n+use std::array::IntoIter;\n use std::fmt::Debug;\n \n /// Encodes if a `DefKind::Ctor` is the constructor of an enum variant or a struct.\n@@ -291,6 +292,14 @@ impl<T> PerNS<T> {\n     pub fn map<U, F: FnMut(T) -> U>(self, mut f: F) -> PerNS<U> {\n         PerNS { value_ns: f(self.value_ns), type_ns: f(self.type_ns), macro_ns: f(self.macro_ns) }\n     }\n+\n+    pub fn into_iter(self) -> IntoIter<T, 3> {\n+        IntoIter::new([self.value_ns, self.type_ns, self.macro_ns])\n+    }\n+\n+    pub fn iter(&self) -> IntoIter<&T, 3> {\n+        IntoIter::new([&self.value_ns, &self.type_ns, &self.macro_ns])\n+    }\n }\n \n impl<T> ::std::ops::Index<Namespace> for PerNS<T> {"}, {"sha": "9d931b3a9e1e561cff533c98b91c0e6ca220c852", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f5c76951327b912c8e92e83235430ebd9b349d9/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f5c76951327b912c8e92e83235430ebd9b349d9/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=0f5c76951327b912c8e92e83235430ebd9b349d9", "patch": "@@ -2,6 +2,7 @@\n //!\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/hir.html\n \n+#![feature(array_value_iter)]\n #![feature(crate_visibility_modifier)]\n #![feature(const_fn)] // For the unsizing cast on `&[]`\n #![feature(const_panic)]"}, {"sha": "5780610c862102347179867fc2d6afcdaa89f46f", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 600, "deletions": 167, "changes": 767, "blob_url": "https://github.com/rust-lang/rust/blob/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=0f5c76951327b912c8e92e83235430ebd9b349d9", "patch": "@@ -17,8 +17,9 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::Ident;\n use rustc_span::symbol::Symbol;\n use rustc_span::DUMMY_SP;\n-use smallvec::SmallVec;\n+use smallvec::{smallvec, SmallVec};\n \n+use std::borrow::Cow;\n use std::cell::Cell;\n use std::ops::Range;\n \n@@ -46,19 +47,73 @@ pub fn collect_intra_doc_links(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     }\n }\n \n-enum ErrorKind {\n-    ResolutionFailure,\n+enum ErrorKind<'a> {\n+    Resolve(Box<ResolutionFailure<'a>>),\n     AnchorFailure(AnchorFailure),\n }\n \n+impl<'a> From<ResolutionFailure<'a>> for ErrorKind<'a> {\n+    fn from(err: ResolutionFailure<'a>) -> Self {\n+        ErrorKind::Resolve(box err)\n+    }\n+}\n+\n+#[derive(Debug)]\n+enum ResolutionFailure<'a> {\n+    /// This resolved, but with the wrong namespace.\n+    /// `Namespace` is the expected namespace (as opposed to the actual).\n+    WrongNamespace(Res, Namespace),\n+    /// This has a partial resolution, but is not in the TypeNS and so cannot\n+    /// have associated items or fields.\n+    CannotHaveAssociatedItems(Res, Namespace),\n+    /// `name` is the base name of the path (not necessarily the whole link)\n+    NotInScope { module_id: DefId, name: Cow<'a, str> },\n+    /// this is a primitive type without an impls (no associated methods)\n+    /// when will this actually happen?\n+    /// the `Res` is the primitive it resolved to\n+    NoPrimitiveImpl(Res, String),\n+    /// `[u8::not_found]`\n+    /// the `Res` is the primitive it resolved to\n+    NoPrimitiveAssocItem { res: Res, prim_name: &'a str, assoc_item: Symbol },\n+    /// `[S::not_found]`\n+    /// the `String` is the associated item that wasn't found\n+    NoAssocItem(Res, Symbol),\n+    /// should not ever happen\n+    NoParentItem,\n+    /// this could be an enum variant, but the last path fragment wasn't resolved.\n+    /// the `String` is the variant that didn't exist\n+    NotAVariant(Res, Symbol),\n+    /// used to communicate that this should be ignored, but shouldn't be reported to the user\n+    Dummy,\n+}\n+\n+impl ResolutionFailure<'a> {\n+    // A partial or full resolution\n+    fn res(&self) -> Option<Res> {\n+        use ResolutionFailure::*;\n+        match self {\n+            NoPrimitiveAssocItem { res, .. }\n+            | NoAssocItem(res, _)\n+            | NoPrimitiveImpl(res, _)\n+            | NotAVariant(res, _)\n+            | WrongNamespace(res, _)\n+            | CannotHaveAssociatedItems(res, _) => Some(*res),\n+            NotInScope { .. } | NoParentItem | Dummy => None,\n+        }\n+    }\n+\n+    // This resolved fully (not just partially) but is erroneous for some other reason\n+    fn full_res(&self) -> Option<Res> {\n+        match self {\n+            Self::WrongNamespace(res, _) => Some(*res),\n+            _ => None,\n+        }\n+    }\n+}\n+\n enum AnchorFailure {\n     MultipleAnchors,\n-    Primitive,\n-    Variant,\n-    AssocConstant,\n-    AssocType,\n-    Field,\n-    Method,\n+    RustdocAnchorConflict(Res),\n }\n \n struct LinkCollector<'a, 'tcx> {\n@@ -68,7 +123,7 @@ struct LinkCollector<'a, 'tcx> {\n     /// This is used to store the kind of associated items,\n     /// because `clean` and the disambiguator code expect them to be different.\n     /// See the code for associated items on inherent impls for details.\n-    kind_side_channel: Cell<Option<DefKind>>,\n+    kind_side_channel: Cell<Option<(DefKind, DefId)>>,\n }\n \n impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n@@ -78,17 +133,25 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n     fn variant_field(\n         &self,\n-        path_str: &str,\n+        path_str: &'path str,\n         current_item: &Option<String>,\n         module_id: DefId,\n-    ) -> Result<(Res, Option<String>), ErrorKind> {\n+        extra_fragment: &Option<String>,\n+    ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n         let cx = self.cx;\n \n+        debug!(\"looking for enum variant {}\", path_str);\n         let mut split = path_str.rsplitn(3, \"::\");\n-        let variant_field_name =\n-            split.next().map(|f| Symbol::intern(f)).ok_or(ErrorKind::ResolutionFailure)?;\n+        let variant_field_name = split\n+            .next()\n+            .map(|f| Symbol::intern(f))\n+            .expect(\"fold_item should ensure link is non-empty\");\n         let variant_name =\n-            split.next().map(|f| Symbol::intern(f)).ok_or(ErrorKind::ResolutionFailure)?;\n+            // we're not sure this is a variant at all, so use the full string\n+            split.next().map(|f| Symbol::intern(f)).ok_or_else(|| ResolutionFailure::NotInScope {\n+                module_id,\n+                name: path_str.into(),\n+            })?;\n         let path = split\n             .next()\n             .map(|f| {\n@@ -99,14 +162,18 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 }\n                 f.to_owned()\n             })\n-            .ok_or(ErrorKind::ResolutionFailure)?;\n-        let (_, ty_res) = cx\n+            .ok_or_else(|| ResolutionFailure::NotInScope {\n+                module_id,\n+                name: variant_name.to_string().into(),\n+            })?;\n+        let ty_res = cx\n             .enter_resolver(|resolver| {\n                 resolver.resolve_str_path_error(DUMMY_SP, &path, TypeNS, module_id)\n             })\n-            .map_err(|_| ErrorKind::ResolutionFailure)?;\n+            .map(|(_, res)| res)\n+            .unwrap_or(Res::Err);\n         if let Res::Err = ty_res {\n-            return Err(ErrorKind::ResolutionFailure);\n+            return Err(ResolutionFailure::NotInScope { module_id, name: path.into() }.into());\n         }\n         let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n         match ty_res {\n@@ -118,7 +185,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     .flat_map(|imp| cx.tcx.associated_items(*imp).in_definition_order())\n                     .any(|item| item.ident.name == variant_name)\n                 {\n-                    return Err(ErrorKind::ResolutionFailure);\n+                    // This is just to let `fold_item` know that this shouldn't be considered;\n+                    // it's a bug for the error to make it to the user\n+                    return Err(ResolutionFailure::Dummy.into());\n                 }\n                 match cx.tcx.type_of(did).kind() {\n                     ty::Adt(def, _) if def.is_enum() => {\n@@ -131,18 +200,43 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                 )),\n                             ))\n                         } else {\n-                            Err(ErrorKind::ResolutionFailure)\n+                            Err(ResolutionFailure::NotAVariant(ty_res, variant_field_name).into())\n                         }\n                     }\n-                    _ => Err(ErrorKind::ResolutionFailure),\n+                    _ => unreachable!(),\n                 }\n             }\n-            _ => Err(ErrorKind::ResolutionFailure),\n+            // `variant_field` looks at 3 different path segments in a row.\n+            // But `NoAssocItem` assumes there are only 2. Check to see if there's\n+            // an intermediate segment that resolves.\n+            _ => {\n+                let intermediate_path = format!(\"{}::{}\", path, variant_name);\n+                // NOTE: we have to be careful here, because we're already in `resolve`.\n+                // We know this doesn't recurse forever because we use a shorter path each time.\n+                // NOTE: this uses `TypeNS` because nothing else has a valid path segment after\n+                let kind = if let Some(intermediate) = self.check_full_res(\n+                    TypeNS,\n+                    &intermediate_path,\n+                    Some(module_id),\n+                    current_item,\n+                    extra_fragment,\n+                ) {\n+                    ResolutionFailure::NoAssocItem(intermediate, variant_field_name)\n+                } else {\n+                    // Even with the shorter path, it didn't resolve, so say that.\n+                    ResolutionFailure::NoAssocItem(ty_res, variant_name)\n+                };\n+                Err(kind.into())\n+            }\n         }\n     }\n \n     /// Resolves a string as a macro.\n-    fn macro_resolve(&self, path_str: &str, parent_id: Option<DefId>) -> Option<Res> {\n+    fn macro_resolve(\n+        &self,\n+        path_str: &'a str,\n+        parent_id: Option<DefId>,\n+    ) -> Result<Res, ResolutionFailure<'a>> {\n         let cx = self.cx;\n         let path = ast::Path::from_ident(Ident::from_str(path_str));\n         cx.enter_resolver(|resolver| {\n@@ -154,11 +248,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 false,\n             ) {\n                 if let SyntaxExtensionKind::LegacyBang { .. } = ext.kind {\n-                    return Some(res.map_id(|_| panic!(\"unexpected id\")));\n+                    return Some(Ok(res.map_id(|_| panic!(\"unexpected id\"))));\n                 }\n             }\n             if let Some(res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n-                return Some(res.map_id(|_| panic!(\"unexpected id\")));\n+                return Some(Ok(res.map_id(|_| panic!(\"unexpected id\"))));\n             }\n             if let Some(module_id) = parent_id {\n                 debug!(\"resolving {} as a macro in the module {:?}\", path_str, module_id);\n@@ -168,25 +262,47 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     // don't resolve builtins like `#[derive]`\n                     if let Res::Def(..) = res {\n                         let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n-                        return Some(res);\n+                        return Some(Ok(res));\n                     }\n                 }\n             } else {\n                 debug!(\"attempting to resolve item without parent module: {}\", path_str);\n+                return Some(Err(ResolutionFailure::NoParentItem));\n             }\n             None\n         })\n+        // This weird control flow is so we don't borrow the resolver more than once at a time\n+        .unwrap_or_else(|| {\n+            let mut split = path_str.rsplitn(2, \"::\");\n+            if let Some((parent, base)) = split.next().and_then(|x| Some((split.next()?, x))) {\n+                if let Some(res) = self.check_full_res(TypeNS, parent, parent_id, &None, &None) {\n+                    return Err(if matches!(res, Res::PrimTy(_)) {\n+                        ResolutionFailure::NoPrimitiveAssocItem {\n+                            res,\n+                            prim_name: parent,\n+                            assoc_item: Symbol::intern(base),\n+                        }\n+                    } else {\n+                        ResolutionFailure::NoAssocItem(res, Symbol::intern(base))\n+                    });\n+                }\n+            }\n+            Err(ResolutionFailure::NotInScope {\n+                module_id: parent_id.expect(\"already saw `Some` when resolving as a macro\"),\n+                name: path_str.into(),\n+            })\n+        })\n     }\n     /// Resolves a string as a path within a particular namespace. Also returns an optional\n     /// URL fragment in the case of variants and methods.\n-    fn resolve(\n+    fn resolve<'path>(\n         &self,\n-        path_str: &str,\n+        path_str: &'path str,\n         ns: Namespace,\n         current_item: &Option<String>,\n         parent_id: Option<DefId>,\n         extra_fragment: &Option<String>,\n-    ) -> Result<(Res, Option<String>), ErrorKind> {\n+    ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n         let cx = self.cx;\n \n         // In case we're in a module, try to resolve the relative path.\n@@ -196,8 +312,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             });\n             debug!(\"{} resolved to {:?} in namespace {:?}\", path_str, result, ns);\n             let result = match result {\n-                Ok((_, Res::Err)) => Err(ErrorKind::ResolutionFailure),\n-                _ => result.map_err(|_| ErrorKind::ResolutionFailure),\n+                Ok((_, Res::Err)) => Err(()),\n+                x => x,\n             };\n \n             if let Ok((_, res)) = result {\n@@ -213,7 +329,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     // Not a trait item; just return what we found.\n                     Res::PrimTy(..) => {\n                         if extra_fragment.is_some() {\n-                            return Err(ErrorKind::AnchorFailure(AnchorFailure::Primitive));\n+                            return Err(ErrorKind::AnchorFailure(\n+                                AnchorFailure::RustdocAnchorConflict(res),\n+                            ));\n                         }\n                         return Ok((res, Some(path_str.to_owned())));\n                     }\n@@ -226,20 +344,22 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 };\n \n                 if value != (ns == ValueNS) {\n-                    return Err(ErrorKind::ResolutionFailure);\n+                    return Err(ResolutionFailure::WrongNamespace(res, ns).into());\n                 }\n             } else if let Some((path, prim)) = is_primitive(path_str, ns) {\n                 if extra_fragment.is_some() {\n-                    return Err(ErrorKind::AnchorFailure(AnchorFailure::Primitive));\n+                    return Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(\n+                        prim,\n+                    )));\n                 }\n                 return Ok((prim, Some(path.to_owned())));\n             }\n \n             // Try looking for methods and associated items.\n             let mut split = path_str.rsplitn(2, \"::\");\n-            let item_name =\n-                split.next().map(|f| Symbol::intern(f)).ok_or(ErrorKind::ResolutionFailure)?;\n-            let path = split\n+            // this can be an `unwrap()` because we ensure the link is never empty\n+            let item_name = Symbol::intern(split.next().unwrap());\n+            let path_root = split\n                 .next()\n                 .map(|f| {\n                     if f == \"self\" || f == \"Self\" {\n@@ -249,10 +369,17 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     }\n                     f.to_owned()\n                 })\n-                .ok_or(ErrorKind::ResolutionFailure)?;\n-\n-            if let Some((path, prim)) = is_primitive(&path, TypeNS) {\n-                for &impl_ in primitive_impl(cx, &path).ok_or(ErrorKind::ResolutionFailure)? {\n+                // If there's no `::`, it's not an associated item.\n+                // So we can be sure that `rustc_resolve` was accurate when it said it wasn't resolved.\n+                .ok_or_else(|| {\n+                    debug!(\"found no `::`, assumming {} was correctly not in scope\", item_name);\n+                    ResolutionFailure::NotInScope { module_id, name: item_name.to_string().into() }\n+                })?;\n+\n+            if let Some((path, prim)) = is_primitive(&path_root, TypeNS) {\n+                let impls = primitive_impl(cx, &path)\n+                    .ok_or_else(|| ResolutionFailure::NoPrimitiveImpl(prim, path_root.into()))?;\n+                for &impl_ in impls {\n                     let link = cx\n                         .tcx\n                         .associated_items(impl_)\n@@ -272,21 +399,54 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         return Ok(link);\n                     }\n                 }\n-                return Err(ErrorKind::ResolutionFailure);\n+                debug!(\n+                    \"returning primitive error for {}::{} in {} namespace\",\n+                    path,\n+                    item_name,\n+                    ns.descr()\n+                );\n+                return Err(ResolutionFailure::NoPrimitiveAssocItem {\n+                    res: prim,\n+                    prim_name: path,\n+                    assoc_item: item_name,\n+                }\n+                .into());\n             }\n \n-            let (_, ty_res) = cx\n+            let ty_res = cx\n                 .enter_resolver(|resolver| {\n-                    resolver.resolve_str_path_error(DUMMY_SP, &path, TypeNS, module_id)\n+                    // only types can have associated items\n+                    resolver.resolve_str_path_error(DUMMY_SP, &path_root, TypeNS, module_id)\n                 })\n-                .map_err(|_| ErrorKind::ResolutionFailure)?;\n-            if let Res::Err = ty_res {\n-                return if ns == Namespace::ValueNS {\n-                    self.variant_field(path_str, current_item, module_id)\n-                } else {\n-                    Err(ErrorKind::ResolutionFailure)\n-                };\n-            }\n+                .map(|(_, res)| res);\n+            let ty_res = match ty_res {\n+                Err(()) | Ok(Res::Err) => {\n+                    return if ns == Namespace::ValueNS {\n+                        self.variant_field(path_str, current_item, module_id, extra_fragment)\n+                    } else {\n+                        // See if it only broke because of the namespace.\n+                        let kind = cx.enter_resolver(|resolver| {\n+                            // NOTE: this doesn't use `check_full_res` because we explicitly want to ignore `TypeNS` (we already checked it)\n+                            for &ns in &[MacroNS, ValueNS] {\n+                                match resolver\n+                                    .resolve_str_path_error(DUMMY_SP, &path_root, ns, module_id)\n+                                {\n+                                    Ok((_, Res::Err)) | Err(()) => {}\n+                                    Ok((_, res)) => {\n+                                        let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n+                                        return ResolutionFailure::CannotHaveAssociatedItems(\n+                                            res, ns,\n+                                        );\n+                                    }\n+                                }\n+                            }\n+                            ResolutionFailure::NotInScope { module_id, name: path_root.into() }\n+                        });\n+                        Err(kind.into())\n+                    };\n+                }\n+                Ok(res) => res,\n+            };\n             let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n             let res = match ty_res {\n                 Res::Def(\n@@ -295,7 +455,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 ) => {\n                     debug!(\"looking for associated item named {} for item {:?}\", item_name, did);\n                     // Checks if item_name belongs to `impl SomeItem`\n-                    let kind = cx\n+                    let assoc_item = cx\n                         .tcx\n                         .inherent_impls(did)\n                         .iter()\n@@ -307,7 +467,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                 imp,\n                             )\n                         })\n-                        .map(|item| item.kind)\n+                        .map(|item| (item.kind, item.def_id))\n                         // There should only ever be one associated item that matches from any inherent impl\n                         .next()\n                         // Check if item_name belongs to `impl SomeTrait for SomeItem`\n@@ -323,26 +483,25 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                             kind\n                         });\n \n-                    if let Some(kind) = kind {\n+                    if let Some((kind, id)) = assoc_item {\n                         let out = match kind {\n                             ty::AssocKind::Fn => \"method\",\n                             ty::AssocKind::Const => \"associatedconstant\",\n                             ty::AssocKind::Type => \"associatedtype\",\n                         };\n                         Some(if extra_fragment.is_some() {\n-                            Err(ErrorKind::AnchorFailure(if kind == ty::AssocKind::Fn {\n-                                AnchorFailure::Method\n-                            } else {\n-                                AnchorFailure::AssocConstant\n-                            }))\n+                            Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(\n+                                ty_res,\n+                            )))\n                         } else {\n                             // HACK(jynelson): `clean` expects the type, not the associated item.\n                             // but the disambiguator logic expects the associated item.\n                             // Store the kind in a side channel so that only the disambiguator logic looks at it.\n-                            self.kind_side_channel.set(Some(kind.as_def_kind()));\n+                            self.kind_side_channel.set(Some((kind.as_def_kind(), id)));\n                             Ok((ty_res, Some(format!(\"{}.{}\", out, item_name))))\n                         })\n                     } else if ns == Namespace::ValueNS {\n+                        debug!(\"looking for variants or fields named {} for {:?}\", item_name, did);\n                         match cx.tcx.type_of(did).kind() {\n                             ty::Adt(def, _) => {\n                                 let field = if def.is_enum() {\n@@ -355,11 +514,17 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                 };\n                                 field.map(|item| {\n                                     if extra_fragment.is_some() {\n-                                        Err(ErrorKind::AnchorFailure(if def.is_enum() {\n-                                            AnchorFailure::Variant\n-                                        } else {\n-                                            AnchorFailure::Field\n-                                        }))\n+                                        let res = Res::Def(\n+                                            if def.is_enum() {\n+                                                DefKind::Variant\n+                                            } else {\n+                                                DefKind::Field\n+                                            },\n+                                            item.did,\n+                                        );\n+                                        Err(ErrorKind::AnchorFailure(\n+                                            AnchorFailure::RustdocAnchorConflict(res),\n+                                        ))\n                                     } else {\n                                         Ok((\n                                             ty_res,\n@@ -380,7 +545,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         }\n                     } else {\n                         // We already know this isn't in ValueNS, so no need to check variant_field\n-                        return Err(ErrorKind::ResolutionFailure);\n+                        return Err(ResolutionFailure::NoAssocItem(ty_res, item_name).into());\n                     }\n                 }\n                 Res::Def(DefKind::Trait, did) => cx\n@@ -401,13 +566,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         };\n \n                         if extra_fragment.is_some() {\n-                            Err(ErrorKind::AnchorFailure(if item.kind == ty::AssocKind::Const {\n-                                AnchorFailure::AssocConstant\n-                            } else if item.kind == ty::AssocKind::Type {\n-                                AnchorFailure::AssocType\n-                            } else {\n-                                AnchorFailure::Method\n-                            }))\n+                            Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(\n+                                ty_res,\n+                            )))\n                         } else {\n                             let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n                             Ok((res, Some(format!(\"{}.{}\", kind, item_name))))\n@@ -417,14 +578,54 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             };\n             res.unwrap_or_else(|| {\n                 if ns == Namespace::ValueNS {\n-                    self.variant_field(path_str, current_item, module_id)\n+                    self.variant_field(path_str, current_item, module_id, extra_fragment)\n                 } else {\n-                    Err(ErrorKind::ResolutionFailure)\n+                    Err(ResolutionFailure::NoAssocItem(ty_res, item_name).into())\n                 }\n             })\n         } else {\n             debug!(\"attempting to resolve item without parent module: {}\", path_str);\n-            Err(ErrorKind::ResolutionFailure)\n+            Err(ResolutionFailure::NoParentItem.into())\n+        }\n+    }\n+\n+    /// Used for reporting better errors.\n+    ///\n+    /// Returns whether the link resolved 'fully' in another namespace.\n+    /// 'fully' here means that all parts of the link resolved, not just some path segments.\n+    /// This returns the `Res` even if it was erroneous for some reason\n+    /// (such as having invalid URL fragments or being in the wrong namespace).\n+    fn check_full_res(\n+        &self,\n+        ns: Namespace,\n+        path_str: &str,\n+        base_node: Option<DefId>,\n+        current_item: &Option<String>,\n+        extra_fragment: &Option<String>,\n+    ) -> Option<Res> {\n+        let check_full_res_inner = |this: &Self, result: Result<Res, ErrorKind<'_>>| {\n+            let res = match result {\n+                Ok(res) => Some(res),\n+                Err(ErrorKind::Resolve(box kind)) => kind.full_res(),\n+                Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(res))) => {\n+                    Some(res)\n+                }\n+                Err(ErrorKind::AnchorFailure(AnchorFailure::MultipleAnchors)) => None,\n+            };\n+            this.kind_side_channel.take().map(|(kind, id)| Res::Def(kind, id)).or(res)\n+        };\n+        // cannot be used for macro namespace\n+        let check_full_res = |this: &Self, ns| {\n+            let result = this.resolve(path_str, ns, current_item, base_node, extra_fragment);\n+            check_full_res_inner(this, result.map(|(res, _)| res))\n+        };\n+        let check_full_res_macro = |this: &Self| {\n+            let result = this.macro_resolve(path_str, base_node);\n+            check_full_res_inner(this, result.map_err(ErrorKind::from))\n+        };\n+        match ns {\n+            Namespace::MacroNS => check_full_res_macro(self),\n+            Namespace::TypeNS | Namespace::ValueNS => check_full_res(self, ns),\n         }\n     }\n }\n@@ -435,7 +636,7 @@ fn resolve_associated_trait_item(\n     item_name: Symbol,\n     ns: Namespace,\n     cx: &DocContext<'_>,\n-) -> Option<ty::AssocKind> {\n+) -> Option<(ty::AssocKind, DefId)> {\n     let ty = cx.tcx.type_of(did);\n     // First consider automatic impls: `impl From<T> for T`\n     let implicit_impls = crate::clean::get_auto_trait_and_blanket_impls(cx, ty, did);\n@@ -463,7 +664,7 @@ fn resolve_associated_trait_item(\n                             // but provided methods come directly from `tcx`.\n                             // Fortunately, we don't need the whole method, we just need to know\n                             // what kind of associated item it is.\n-                            Some((assoc.def_id, kind))\n+                            Some((kind, assoc.def_id))\n                         });\n                         let assoc = items.next();\n                         debug_assert_eq!(items.count(), 0);\n@@ -485,7 +686,7 @@ fn resolve_associated_trait_item(\n                                 ns,\n                                 trait_,\n                             )\n-                            .map(|assoc| (assoc.def_id, assoc.kind))\n+                            .map(|assoc| (assoc.kind, assoc.def_id))\n                     }\n                 }\n                 _ => panic!(\"get_impls returned something that wasn't an impl\"),\n@@ -502,12 +703,12 @@ fn resolve_associated_trait_item(\n             cx.tcx\n                 .associated_items(trait_)\n                 .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, trait_)\n-                .map(|assoc| (assoc.def_id, assoc.kind))\n+                .map(|assoc| (assoc.kind, assoc.def_id))\n         }));\n     }\n     // FIXME: warn about ambiguity\n     debug!(\"the candidates were {:?}\", candidates);\n-    candidates.pop().map(|(_, kind)| kind)\n+    candidates.pop()\n }\n \n /// Given a type, return all traits in scope in `module` implemented by that type.\n@@ -536,7 +737,7 @@ fn traits_implemented_by(cx: &DocContext<'_>, type_: DefId, module: DefId) -> Fx\n             let trait_ref = cx.tcx.impl_trait_ref(impl_).expect(\"this is not an inherent impl\");\n             // Check if these are the same type.\n             let impl_type = trait_ref.self_ty();\n-            debug!(\n+            trace!(\n                 \"comparing type {} with kind {:?} against type {:?}\",\n                 impl_type,\n                 impl_type.kind(),\n@@ -562,10 +763,10 @@ fn traits_implemented_by(cx: &DocContext<'_>, type_: DefId, module: DefId) -> Fx\n /// Check for resolve collisions between a trait and its derive\n ///\n /// These are common and we should just resolve to the trait in that case\n-fn is_derive_trait_collision<T>(ns: &PerNS<Option<(Res, T)>>) -> bool {\n+fn is_derive_trait_collision<T>(ns: &PerNS<Result<(Res, T), ResolutionFailure<'_>>>) -> bool {\n     if let PerNS {\n-        type_ns: Some((Res::Def(DefKind::Trait, _), _)),\n-        macro_ns: Some((Res::Def(DefKind::Macro(MacroKind::Derive), _), _)),\n+        type_ns: Ok((Res::Def(DefKind::Trait, _), _)),\n+        macro_ns: Ok((Res::Def(DefKind::Macro(MacroKind::Derive), _), _)),\n         ..\n     } = *ns\n     {\n@@ -764,8 +965,32 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         match self.resolve(path_str, ns, &current_item, base_node, &extra_fragment)\n                         {\n                             Ok(res) => res,\n-                            Err(ErrorKind::ResolutionFailure) => {\n-                                resolution_failure(cx, &item, path_str, &dox, link_range);\n+                            Err(ErrorKind::Resolve(box mut kind)) => {\n+                                // We only looked in one namespace. Try to give a better error if possible.\n+                                if kind.full_res().is_none() {\n+                                    let other_ns = if ns == ValueNS { TypeNS } else { ValueNS };\n+                                    for &new_ns in &[other_ns, MacroNS] {\n+                                        if let Some(res) = self.check_full_res(\n+                                            new_ns,\n+                                            path_str,\n+                                            base_node,\n+                                            &current_item,\n+                                            &extra_fragment,\n+                                        ) {\n+                                            kind = ResolutionFailure::WrongNamespace(res, ns);\n+                                            break;\n+                                        }\n+                                    }\n+                                }\n+                                resolution_failure(\n+                                    self,\n+                                    &item,\n+                                    path_str,\n+                                    disambiguator,\n+                                    &dox,\n+                                    link_range,\n+                                    smallvec![kind],\n+                                );\n                                 // This could just be a normal link or a broken link\n                                 // we could potentially check if something is\n                                 // \"intra-doc-link-like\" and warn in that case.\n@@ -792,13 +1017,13 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                             ) {\n                                 Ok(res) => {\n                                     debug!(\"got res in TypeNS: {:?}\", res);\n-                                    Some(res)\n+                                    Ok(res)\n                                 }\n                                 Err(ErrorKind::AnchorFailure(msg)) => {\n                                     anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n                                     continue;\n                                 }\n-                                Err(ErrorKind::ResolutionFailure) => None,\n+                                Err(ErrorKind::Resolve(box kind)) => Err(kind),\n                             },\n                             value_ns: match self.resolve(\n                                 path_str,\n@@ -807,48 +1032,57 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                                 base_node,\n                                 &extra_fragment,\n                             ) {\n-                                Ok(res) => Some(res),\n+                                Ok(res) => Ok(res),\n                                 Err(ErrorKind::AnchorFailure(msg)) => {\n                                     anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n                                     continue;\n                                 }\n-                                Err(ErrorKind::ResolutionFailure) => None,\n+                                Err(ErrorKind::Resolve(box kind)) => Err(kind),\n                             }\n                             .and_then(|(res, fragment)| {\n                                 // Constructors are picked up in the type namespace.\n                                 match res {\n-                                    Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) => None,\n+                                    Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) => {\n+                                        Err(ResolutionFailure::WrongNamespace(res, TypeNS))\n+                                    }\n                                     _ => match (fragment, extra_fragment) {\n                                         (Some(fragment), Some(_)) => {\n                                             // Shouldn't happen but who knows?\n-                                            Some((res, Some(fragment)))\n-                                        }\n-                                        (fragment, None) | (None, fragment) => {\n-                                            Some((res, fragment))\n+                                            Ok((res, Some(fragment)))\n                                         }\n+                                        (fragment, None) | (None, fragment) => Ok((res, fragment)),\n                                     },\n                                 }\n                             }),\n                         };\n \n-                        if candidates.is_empty() {\n-                            resolution_failure(cx, &item, path_str, &dox, link_range);\n+                        let len = candidates.iter().filter(|res| res.is_ok()).count();\n+\n+                        if len == 0 {\n+                            resolution_failure(\n+                                self,\n+                                &item,\n+                                path_str,\n+                                disambiguator,\n+                                &dox,\n+                                link_range,\n+                                candidates.into_iter().filter_map(|res| res.err()).collect(),\n+                            );\n                             // this could just be a normal link\n                             continue;\n                         }\n \n-                        let len = candidates.clone().present_items().count();\n-\n                         if len == 1 {\n-                            candidates.present_items().next().unwrap()\n+                            candidates.into_iter().filter_map(|res| res.ok()).next().unwrap()\n                         } else if len == 2 && is_derive_trait_collision(&candidates) {\n                             candidates.type_ns.unwrap()\n                         } else {\n                             if is_derive_trait_collision(&candidates) {\n-                                candidates.macro_ns = None;\n+                                candidates.macro_ns = Err(ResolutionFailure::Dummy);\n                             }\n+                            // If we're reporting an ambiguity, don't mention the namespaces that failed\n                             let candidates =\n-                                candidates.map(|candidate| candidate.map(|(res, _)| res));\n+                                candidates.map(|candidate| candidate.ok().map(|(res, _)| res));\n                             ambiguity_error(\n                                 cx,\n                                 &item,\n@@ -861,11 +1095,33 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         }\n                     }\n                     Some(MacroNS) => {\n-                        if let Some(res) = self.macro_resolve(path_str, base_node) {\n-                            (res, extra_fragment)\n-                        } else {\n-                            resolution_failure(cx, &item, path_str, &dox, link_range);\n-                            continue;\n+                        match self.macro_resolve(path_str, base_node) {\n+                            Ok(res) => (res, extra_fragment),\n+                            Err(mut kind) => {\n+                                // `macro_resolve` only looks in the macro namespace. Try to give a better error if possible.\n+                                for &ns in &[TypeNS, ValueNS] {\n+                                    if let Some(res) = self.check_full_res(\n+                                        ns,\n+                                        path_str,\n+                                        base_node,\n+                                        &current_item,\n+                                        &extra_fragment,\n+                                    ) {\n+                                        kind = ResolutionFailure::WrongNamespace(res, MacroNS);\n+                                        break;\n+                                    }\n+                                }\n+                                resolution_failure(\n+                                    self,\n+                                    &item,\n+                                    path_str,\n+                                    disambiguator,\n+                                    &dox,\n+                                    link_range,\n+                                    smallvec![kind],\n+                                );\n+                                continue;\n+                            }\n                         }\n                     }\n                 }\n@@ -889,7 +1145,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                                 path_str,\n                                 &dox,\n                                 link_range,\n-                                AnchorFailure::Primitive,\n+                                AnchorFailure::RustdocAnchorConflict(prim),\n                             );\n                             continue;\n                         }\n@@ -907,7 +1163,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             let report_mismatch = |specified: Disambiguator, resolved: Disambiguator| {\n                 // The resolved item did not match the disambiguator; give a better error than 'not found'\n                 let msg = format!(\"incompatible link kind for `{}`\", path_str);\n-                report_diagnostic(cx, &msg, &item, &dox, link_range.clone(), |diag, sp| {\n+                report_diagnostic(cx, &msg, &item, &dox, &link_range, |diag, sp| {\n                     let note = format!(\n                         \"this link resolved to {} {}, which is not {} {}\",\n                         resolved.article(),\n@@ -940,7 +1196,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                 // Disallow e.g. linking to enums with `struct@`\n                 if let Res::Def(kind, _) = res {\n                     debug!(\"saw kind {:?} with disambiguator {:?}\", kind, disambiguator);\n-                    match (self.kind_side_channel.take().unwrap_or(kind), disambiguator) {\n+                    match (self.kind_side_channel.take().map(|(kind, _)| kind).unwrap_or(kind), disambiguator) {\n                         | (DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst, Some(Disambiguator::Kind(DefKind::Const)))\n                         // NOTE: this allows 'method' to mean both normal functions and associated functions\n                         // This can't cause ambiguity because both are in the same namespace.\n@@ -1074,21 +1330,16 @@ impl Disambiguator {\n         }\n     }\n \n-    /// Return (description of the change, suggestion)\n-    fn suggestion_for(self, path_str: &str) -> (&'static str, String) {\n-        const PREFIX: &str = \"prefix with the item kind\";\n-        const FUNCTION: &str = \"add parentheses\";\n-        const MACRO: &str = \"add an exclamation mark\";\n-\n+    fn suggestion(self) -> Suggestion {\n         let kind = match self {\n-            Disambiguator::Primitive => return (PREFIX, format!(\"prim@{}\", path_str)),\n+            Disambiguator::Primitive => return Suggestion::Prefix(\"prim\"),\n             Disambiguator::Kind(kind) => kind,\n             Disambiguator::Namespace(_) => panic!(\"display_for cannot be used on namespaces\"),\n         };\n         if kind == DefKind::Macro(MacroKind::Bang) {\n-            return (MACRO, format!(\"{}!\", path_str));\n+            return Suggestion::Macro;\n         } else if kind == DefKind::Fn || kind == DefKind::AssocFn {\n-            return (FUNCTION, format!(\"{}()\", path_str));\n+            return Suggestion::Function;\n         }\n \n         let prefix = match kind {\n@@ -1113,8 +1364,7 @@ impl Disambiguator {\n             },\n         };\n \n-        // FIXME: if this is an implied shortcut link, it's bad style to suggest `@`\n-        (PREFIX, format!(\"{}@{}\", prefix, path_str))\n+        Suggestion::Prefix(prefix)\n     }\n \n     fn ns(self) -> Namespace {\n@@ -1146,6 +1396,31 @@ impl Disambiguator {\n     }\n }\n \n+enum Suggestion {\n+    Prefix(&'static str),\n+    Function,\n+    Macro,\n+}\n+\n+impl Suggestion {\n+    fn descr(&self) -> Cow<'static, str> {\n+        match self {\n+            Self::Prefix(x) => format!(\"prefix with `{}@`\", x).into(),\n+            Self::Function => \"add parentheses\".into(),\n+            Self::Macro => \"add an exclamation mark\".into(),\n+        }\n+    }\n+\n+    fn as_help(&self, path_str: &str) -> String {\n+        // FIXME: if this is an implied shortcut link, it's bad style to suggest `@`\n+        match self {\n+            Self::Prefix(prefix) => format!(\"{}@{}\", prefix, path_str),\n+            Self::Function => format!(\"{}()\", path_str),\n+            Self::Macro => format!(\"{}!\", path_str),\n+        }\n+    }\n+}\n+\n /// Reports a diagnostic for an intra-doc link.\n ///\n /// If no link range is provided, or the source span of the link cannot be determined, the span of\n@@ -1161,7 +1436,7 @@ fn report_diagnostic(\n     msg: &str,\n     item: &Item,\n     dox: &str,\n-    link_range: Option<Range<usize>>,\n+    link_range: &Option<Range<usize>>,\n     decorate: impl FnOnce(&mut DiagnosticBuilder<'_>, Option<rustc_span::Span>),\n ) {\n     let hir_id = match cx.as_local_hir_id(item.def_id) {\n@@ -1213,24 +1488,197 @@ fn report_diagnostic(\n }\n \n fn resolution_failure(\n-    cx: &DocContext<'_>,\n+    collector: &LinkCollector<'_, '_>,\n     item: &Item,\n     path_str: &str,\n+    disambiguator: Option<Disambiguator>,\n     dox: &str,\n     link_range: Option<Range<usize>>,\n+    kinds: SmallVec<[ResolutionFailure<'_>; 3]>,\n ) {\n     report_diagnostic(\n-        cx,\n+        collector.cx,\n         &format!(\"unresolved link to `{}`\", path_str),\n         item,\n         dox,\n-        link_range,\n+        &link_range,\n         |diag, sp| {\n-            if let Some(sp) = sp {\n-                diag.span_label(sp, \"unresolved link\");\n-            }\n+            let in_scope = kinds.iter().any(|kind| kind.res().is_some());\n+            let item = |res: Res| {\n+                format!(\n+                    \"the {} `{}`\",\n+                    res.descr(),\n+                    collector.cx.tcx.item_name(res.def_id()).to_string()\n+                )\n+            };\n+            let assoc_item_not_allowed = |res: Res| {\n+                let def_id = res.def_id();\n+                let name = collector.cx.tcx.item_name(def_id);\n+                format!(\n+                    \"`{}` is {} {}, not a module or type, and cannot have associated items\",\n+                    name,\n+                    res.article(),\n+                    res.descr()\n+                )\n+            };\n+            // ignore duplicates\n+            let mut variants_seen = SmallVec::<[_; 3]>::new();\n+            for mut failure in kinds {\n+                // Check if _any_ parent of the path gets resolved.\n+                // If so, report it and say the first which failed; if not, say the first path segment didn't resolve.\n+                if let ResolutionFailure::NotInScope { module_id, name } = &mut failure {\n+                    let mut current = name.as_ref();\n+                    loop {\n+                        current = match current.rsplitn(2, \"::\").nth(1) {\n+                            Some(p) => p,\n+                            None => {\n+                                *name = current.to_owned().into();\n+                                break;\n+                            }\n+                        };\n+                        if let Some(res) = collector.check_full_res(\n+                            TypeNS,\n+                            &current,\n+                            Some(*module_id),\n+                            &None,\n+                            &None,\n+                        ) {\n+                            failure = ResolutionFailure::NoAssocItem(res, Symbol::intern(current));\n+                            break;\n+                        }\n+                    }\n+                }\n+                let variant = std::mem::discriminant(&failure);\n+                if variants_seen.contains(&variant) {\n+                    continue;\n+                }\n+                variants_seen.push(variant);\n+                let note = match failure {\n+                    ResolutionFailure::NotInScope { module_id, name, .. } => {\n+                        if in_scope {\n+                            continue;\n+                        }\n+                        // NOTE: uses an explicit `continue` so the `note:` will come before the `help:`\n+                        let module_name = collector.cx.tcx.item_name(module_id);\n+                        let note = format!(\"no item named `{}` in `{}`\", name, module_name);\n+                        if let Some(span) = sp {\n+                            diag.span_label(span, &note);\n+                        } else {\n+                            diag.note(&note);\n+                        }\n+                        // If the link has `::` in the path, assume it's meant to be an intra-doc link\n+                        if !path_str.contains(\"::\") {\n+                            // Otherwise, the `[]` might be unrelated.\n+                            // FIXME(https://github.com/raphlinus/pulldown-cmark/issues/373):\n+                            // don't show this for autolinks (`<>`), `()` style links, or reference links\n+                            diag.help(r#\"to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\"#);\n+                        }\n+                        continue;\n+                    }\n+                    ResolutionFailure::Dummy => continue,\n+                    ResolutionFailure::WrongNamespace(res, expected_ns) => {\n+                        if let Res::Def(kind, _) = res {\n+                            let disambiguator = Disambiguator::Kind(kind);\n+                            suggest_disambiguator(\n+                                disambiguator,\n+                                diag,\n+                                path_str,\n+                                dox,\n+                                sp,\n+                                &link_range,\n+                            )\n+                        }\n \n-            diag.help(r#\"to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\"#);\n+                        format!(\n+                            \"this link resolves to {}, which is not in the {} namespace\",\n+                            item(res),\n+                            expected_ns.descr()\n+                        )\n+                    }\n+                    ResolutionFailure::NoParentItem => {\n+                        diag.level = rustc_errors::Level::Bug;\n+                        \"all intra doc links should have a parent item\".to_owned()\n+                    }\n+                    ResolutionFailure::NoPrimitiveImpl(res, _) => format!(\n+                        \"this link partially resolves to {}, which does not have any associated items\",\n+                        item(res),\n+                    ),\n+                    ResolutionFailure::NoPrimitiveAssocItem { prim_name, assoc_item, .. } => {\n+                        format!(\n+                            \"the builtin type `{}` does not have an associated item named `{}`\",\n+                            prim_name, assoc_item\n+                        )\n+                    }\n+                    ResolutionFailure::NoAssocItem(res, assoc_item) => {\n+                        use DefKind::*;\n+\n+                        let (kind, def_id) = match res {\n+                            Res::Def(kind, def_id) => (kind, def_id),\n+                            x => unreachable!(\n+                                \"primitives are covered above and other `Res` variants aren't possible at module scope: {:?}\",\n+                                x,\n+                            ),\n+                        };\n+                        let name = collector.cx.tcx.item_name(def_id);\n+                        let path_description = if let Some(disambiguator) = disambiguator {\n+                            disambiguator.descr()\n+                        } else {\n+                            match kind {\n+                                Mod | ForeignMod => \"inner item\",\n+                                Struct => \"field or associated item\",\n+                                Enum | Union => \"variant or associated item\",\n+                                Variant\n+                                | Field\n+                                | Closure\n+                                | Generator\n+                                | AssocTy\n+                                | AssocConst\n+                                | AssocFn\n+                                | Fn\n+                                | Macro(_)\n+                                | Const\n+                                | ConstParam\n+                                | ExternCrate\n+                                | Use\n+                                | LifetimeParam\n+                                | Ctor(_, _)\n+                                | AnonConst => {\n+                                    let note = assoc_item_not_allowed(res);\n+                                    if let Some(span) = sp {\n+                                        diag.span_label(span, &note);\n+                                    } else {\n+                                        diag.note(&note);\n+                                    }\n+                                    return;\n+                                }\n+                                Trait | TyAlias | ForeignTy | OpaqueTy | TraitAlias | TyParam\n+                                | Static => \"associated item\",\n+                                Impl | GlobalAsm => unreachable!(\"not a path\"),\n+                            }\n+                        };\n+                        format!(\n+                            \"the {} `{}` has no {} named `{}`\",\n+                            res.descr(),\n+                            name,\n+                            path_description,\n+                            assoc_item\n+                        )\n+                    }\n+                    ResolutionFailure::CannotHaveAssociatedItems(res, _) => {\n+                        assoc_item_not_allowed(res)\n+                    }\n+                    ResolutionFailure::NotAVariant(res, variant) => format!(\n+                        \"this link partially resolves to {}, but there is no variant named {}\",\n+                        item(res),\n+                        variant\n+                    ),\n+                };\n+                if let Some(span) = sp {\n+                    diag.span_label(span, &note);\n+                } else {\n+                    diag.note(&note);\n+                }\n+            }\n         },\n     );\n }\n@@ -1245,31 +1693,14 @@ fn anchor_failure(\n ) {\n     let msg = match failure {\n         AnchorFailure::MultipleAnchors => format!(\"`{}` contains multiple anchors\", path_str),\n-        AnchorFailure::Primitive\n-        | AnchorFailure::Variant\n-        | AnchorFailure::AssocConstant\n-        | AnchorFailure::AssocType\n-        | AnchorFailure::Field\n-        | AnchorFailure::Method => {\n-            let kind = match failure {\n-                AnchorFailure::Primitive => \"primitive type\",\n-                AnchorFailure::Variant => \"enum variant\",\n-                AnchorFailure::AssocConstant => \"associated constant\",\n-                AnchorFailure::AssocType => \"associated type\",\n-                AnchorFailure::Field => \"struct field\",\n-                AnchorFailure::Method => \"method\",\n-                AnchorFailure::MultipleAnchors => unreachable!(\"should be handled already\"),\n-            };\n-\n-            format!(\n-                \"`{}` contains an anchor, but links to {kind}s are already anchored\",\n-                path_str,\n-                kind = kind\n-            )\n-        }\n+        AnchorFailure::RustdocAnchorConflict(res) => format!(\n+            \"`{}` contains an anchor, but links to {kind}s are already anchored\",\n+            path_str,\n+            kind = res.descr(),\n+        ),\n     };\n \n-    report_diagnostic(cx, &msg, item, dox, link_range, |diag, sp| {\n+    report_diagnostic(cx, &msg, item, dox, &link_range, |diag, sp| {\n         if let Some(sp) = sp {\n             diag.span_label(sp, \"contains invalid anchor\");\n         }\n@@ -1308,7 +1739,7 @@ fn ambiguity_error(\n         }\n     }\n \n-    report_diagnostic(cx, &msg, item, dox, link_range.clone(), |diag, sp| {\n+    report_diagnostic(cx, &msg, item, dox, &link_range, |diag, sp| {\n         if let Some(sp) = sp {\n             diag.span_label(sp, \"ambiguous link\");\n         } else {\n@@ -1330,18 +1761,20 @@ fn suggest_disambiguator(\n     sp: Option<rustc_span::Span>,\n     link_range: &Option<Range<usize>>,\n ) {\n-    let (action, mut suggestion) = disambiguator.suggestion_for(path_str);\n-    let help = format!(\"to link to the {}, {}\", disambiguator.descr(), action);\n+    let suggestion = disambiguator.suggestion();\n+    let help = format!(\"to link to the {}, {}\", disambiguator.descr(), suggestion.descr());\n \n     if let Some(sp) = sp {\n         let link_range = link_range.as_ref().expect(\"must have a link range if we have a span\");\n-        if dox.bytes().nth(link_range.start) == Some(b'`') {\n-            suggestion = format!(\"`{}`\", suggestion);\n-        }\n+        let msg = if dox.bytes().nth(link_range.start) == Some(b'`') {\n+            format!(\"`{}`\", suggestion.as_help(path_str))\n+        } else {\n+            suggestion.as_help(path_str)\n+        };\n \n-        diag.span_suggestion(sp, &help, suggestion, Applicability::MaybeIncorrect);\n+        diag.span_suggestion(sp, &help, msg, Applicability::MaybeIncorrect);\n     } else {\n-        diag.help(&format!(\"{}: {}\", help, suggestion));\n+        diag.help(&format!(\"{}: {}\", help, suggestion.as_help(path_str)));\n     }\n }\n \n@@ -1356,7 +1789,7 @@ fn privacy_error(\n     let msg =\n         format!(\"public documentation for `{}` links to private item `{}`\", item_name, path_str);\n \n-    report_diagnostic(cx, &msg, item, dox, link_range, |diag, sp| {\n+    report_diagnostic(cx, &msg, item, dox, &link_range, |diag, sp| {\n         if let Some(sp) = sp {\n             diag.span_label(sp, \"this item is private\");\n         }\n@@ -1375,16 +1808,16 @@ fn handle_variant(\n     cx: &DocContext<'_>,\n     res: Res,\n     extra_fragment: &Option<String>,\n-) -> Result<(Res, Option<String>), ErrorKind> {\n+) -> Result<(Res, Option<String>), ErrorKind<'static>> {\n     use rustc_middle::ty::DefIdTree;\n \n     if extra_fragment.is_some() {\n-        return Err(ErrorKind::AnchorFailure(AnchorFailure::Variant));\n+        return Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(res)));\n     }\n     let parent = if let Some(parent) = cx.tcx.parent(res.def_id()) {\n         parent\n     } else {\n-        return Err(ErrorKind::ResolutionFailure);\n+        return Err(ResolutionFailure::NoParentItem.into());\n     };\n     let parent_def = Res::Def(DefKind::Enum, parent);\n     let variant = cx.tcx.expect_variant_res(res);"}, {"sha": "92d27179e8c3fbce95bd647e251ad1ad6d69558a", "filename": "src/test/rustdoc-ui/assoc-item-not-in-scope.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fassoc-item-not-in-scope.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fassoc-item-not-in-scope.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fassoc-item-not-in-scope.stderr?ref=0f5c76951327b912c8e92e83235430ebd9b349d9", "patch": "@@ -2,14 +2,13 @@ error: unresolved link to `S::fmt`\n   --> $DIR/assoc-item-not-in-scope.rs:4:14\n    |\n LL | /// Link to [`S::fmt`]\n-   |              ^^^^^^^^ unresolved link\n+   |              ^^^^^^^^ the struct `S` has no field or associated item named `fmt`\n    |\n note: the lint level is defined here\n   --> $DIR/assoc-item-not-in-scope.rs:1:9\n    |\n LL | #![deny(broken_intra_doc_links)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n-   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n error: aborting due to previous error\n "}, {"sha": "5020b97b2f20101221466fbc5cf9bdb392401a29", "filename": "src/test/rustdoc-ui/deny-intra-link-resolution-failure.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fdeny-intra-link-resolution-failure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fdeny-intra-link-resolution-failure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdeny-intra-link-resolution-failure.stderr?ref=0f5c76951327b912c8e92e83235430ebd9b349d9", "patch": "@@ -2,7 +2,7 @@ error: unresolved link to `v2`\n   --> $DIR/deny-intra-link-resolution-failure.rs:3:6\n    |\n LL | /// [v2]\n-   |      ^^ unresolved link\n+   |      ^^ no item named `v2` in `deny_intra_link_resolution_failure`\n    |\n note: the lint level is defined here\n   --> $DIR/deny-intra-link-resolution-failure.rs:1:9"}, {"sha": "771fc2204f5f84a60581c5127c2e75e729a20d64", "filename": "src/test/rustdoc-ui/intra-doc-alias-ice.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fintra-doc-alias-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fintra-doc-alias-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc-alias-ice.stderr?ref=0f5c76951327b912c8e92e83235430ebd9b349d9", "patch": "@@ -2,14 +2,13 @@ error: unresolved link to `TypeAlias::hoge`\n   --> $DIR/intra-doc-alias-ice.rs:5:30\n    |\n LL | /// [broken cross-reference](TypeAlias::hoge)\n-   |                              ^^^^^^^^^^^^^^^ unresolved link\n+   |                              ^^^^^^^^^^^^^^^ the type alias `TypeAlias` has no associated item named `hoge`\n    |\n note: the lint level is defined here\n   --> $DIR/intra-doc-alias-ice.rs:1:9\n    |\n LL | #![deny(broken_intra_doc_links)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n-   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n error: aborting due to previous error\n "}, {"sha": "26b629b1313dafb9b7ec28f49419fa2d9d09e163", "filename": "src/test/rustdoc-ui/intra-link-errors.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.rs?ref=0f5c76951327b912c8e92e83235430ebd9b349d9", "patch": "@@ -0,0 +1,88 @@\n+#![deny(broken_intra_doc_links)]\n+//~^ NOTE lint level is defined\n+\n+// FIXME: this should say that it was skipped (maybe an allowed by default lint?)\n+/// [<invalid syntax>]\n+\n+/// [path::to::nonexistent::module]\n+//~^ ERROR unresolved link\n+//~| NOTE no item named `path` in `intra_link_errors`\n+\n+/// [path::to::nonexistent::macro!]\n+//~^ ERROR unresolved link\n+//~| NOTE no item named `path` in `intra_link_errors`\n+\n+/// [type@path::to::nonexistent::type]\n+//~^ ERROR unresolved link\n+//~| NOTE no item named `path` in `intra_link_errors`\n+\n+/// [std::io::not::here]\n+//~^ ERROR unresolved link\n+//~| NOTE the module `io` has no inner item\n+\n+/// [std::io::Error::x]\n+//~^ ERROR unresolved link\n+//~| NOTE the struct `Error` has no field\n+\n+/// [std::io::ErrorKind::x]\n+//~^ ERROR unresolved link\n+//~| NOTE the enum `ErrorKind` has no variant\n+\n+/// [f::A]\n+//~^ ERROR unresolved link\n+//~| NOTE `f` is a function, not a module\n+\n+/// [S::A]\n+//~^ ERROR unresolved link\n+//~| NOTE struct `S` has no field or associated item\n+\n+/// [S::fmt]\n+//~^ ERROR unresolved link\n+//~| NOTE struct `S` has no field or associated item\n+\n+/// [E::D]\n+//~^ ERROR unresolved link\n+//~| NOTE enum `E` has no variant or associated item\n+\n+/// [u8::not_found]\n+//~^ ERROR unresolved link\n+//~| NOTE the builtin type `u8` does not have an associated item named `not_found`\n+\n+/// [S!]\n+//~^ ERROR unresolved link\n+//~| HELP to link to the struct, prefix with `struct@`\n+//~| NOTE this link resolves to the struct `S`\n+pub fn f() {}\n+#[derive(Debug)]\n+pub struct S;\n+\n+pub enum E { A, B, C }\n+\n+/// [type@S::h]\n+//~^ ERROR unresolved link\n+//~| HELP to link to the associated function\n+//~| NOTE not in the type namespace\n+impl S {\n+    pub fn h() {}\n+}\n+\n+/// [type@T::g]\n+//~^ ERROR unresolved link\n+//~| HELP to link to the associated function\n+//~| NOTE not in the type namespace\n+\n+/// [T::h!]\n+//~^ ERROR unresolved link\n+//~| NOTE `T` has no macro named `h`\n+pub trait T {\n+    fn g() {}\n+}\n+\n+/// [m()]\n+//~^ ERROR unresolved link\n+//~| HELP to link to the macro\n+//~| NOTE not in the value namespace\n+#[macro_export]\n+macro_rules! m {\n+    () => {};\n+}"}, {"sha": "fbf3dcbbec29a3b024ef89f9201ad8a3de0b3d9e", "filename": "src/test/rustdoc-ui/intra-link-errors.stderr", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr?ref=0f5c76951327b912c8e92e83235430ebd9b349d9", "patch": "@@ -0,0 +1,116 @@\n+error: unresolved link to `path::to::nonexistent::module`\n+  --> $DIR/intra-link-errors.rs:7:6\n+   |\n+LL | /// [path::to::nonexistent::module]\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no item named `path` in `intra_link_errors`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/intra-link-errors.rs:1:9\n+   |\n+LL | #![deny(broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: unresolved link to `path::to::nonexistent::macro`\n+  --> $DIR/intra-link-errors.rs:11:6\n+   |\n+LL | /// [path::to::nonexistent::macro!]\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no item named `path` in `intra_link_errors`\n+\n+error: unresolved link to `path::to::nonexistent::type`\n+  --> $DIR/intra-link-errors.rs:15:6\n+   |\n+LL | /// [type@path::to::nonexistent::type]\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no item named `path` in `intra_link_errors`\n+\n+error: unresolved link to `std::io::not::here`\n+  --> $DIR/intra-link-errors.rs:19:6\n+   |\n+LL | /// [std::io::not::here]\n+   |      ^^^^^^^^^^^^^^^^^^ the module `io` has no inner item named `not`\n+\n+error: unresolved link to `std::io::Error::x`\n+  --> $DIR/intra-link-errors.rs:23:6\n+   |\n+LL | /// [std::io::Error::x]\n+   |      ^^^^^^^^^^^^^^^^^ the struct `Error` has no field or associated item named `x`\n+\n+error: unresolved link to `std::io::ErrorKind::x`\n+  --> $DIR/intra-link-errors.rs:27:6\n+   |\n+LL | /// [std::io::ErrorKind::x]\n+   |      ^^^^^^^^^^^^^^^^^^^^^ the enum `ErrorKind` has no variant or associated item named `x`\n+\n+error: unresolved link to `f::A`\n+  --> $DIR/intra-link-errors.rs:31:6\n+   |\n+LL | /// [f::A]\n+   |      ^^^^ `f` is a function, not a module or type, and cannot have associated items\n+\n+error: unresolved link to `S::A`\n+  --> $DIR/intra-link-errors.rs:35:6\n+   |\n+LL | /// [S::A]\n+   |      ^^^^ the struct `S` has no field or associated item named `A`\n+\n+error: unresolved link to `S::fmt`\n+  --> $DIR/intra-link-errors.rs:39:6\n+   |\n+LL | /// [S::fmt]\n+   |      ^^^^^^ the struct `S` has no field or associated item named `fmt`\n+\n+error: unresolved link to `E::D`\n+  --> $DIR/intra-link-errors.rs:43:6\n+   |\n+LL | /// [E::D]\n+   |      ^^^^ the enum `E` has no variant or associated item named `D`\n+\n+error: unresolved link to `u8::not_found`\n+  --> $DIR/intra-link-errors.rs:47:6\n+   |\n+LL | /// [u8::not_found]\n+   |      ^^^^^^^^^^^^^ the builtin type `u8` does not have an associated item named `not_found`\n+\n+error: unresolved link to `S`\n+  --> $DIR/intra-link-errors.rs:51:6\n+   |\n+LL | /// [S!]\n+   |      ^^\n+   |      |\n+   |      this link resolves to the struct `S`, which is not in the macro namespace\n+   |      help: to link to the struct, prefix with `struct@`: `struct@S`\n+\n+error: unresolved link to `T::g`\n+  --> $DIR/intra-link-errors.rs:69:6\n+   |\n+LL | /// [type@T::g]\n+   |      ^^^^^^^^^\n+   |      |\n+   |      this link resolves to the associated function `g`, which is not in the type namespace\n+   |      help: to link to the associated function, add parentheses: `T::g()`\n+\n+error: unresolved link to `T::h`\n+  --> $DIR/intra-link-errors.rs:74:6\n+   |\n+LL | /// [T::h!]\n+   |      ^^^^^ the trait `T` has no macro named `h`\n+\n+error: unresolved link to `S::h`\n+  --> $DIR/intra-link-errors.rs:61:6\n+   |\n+LL | /// [type@S::h]\n+   |      ^^^^^^^^^\n+   |      |\n+   |      this link resolves to the associated function `h`, which is not in the type namespace\n+   |      help: to link to the associated function, add parentheses: `S::h()`\n+\n+error: unresolved link to `m`\n+  --> $DIR/intra-link-errors.rs:81:6\n+   |\n+LL | /// [m()]\n+   |      ^^^\n+   |      |\n+   |      this link resolves to the macro `m`, which is not in the value namespace\n+   |      help: to link to the macro, add an exclamation mark: `m!`\n+\n+error: aborting due to 16 previous errors\n+"}, {"sha": "85738ceae8e615b34eeedffa8a0ffb35d9e1b0ac", "filename": "src/test/rustdoc-ui/intra-link-prim-conflict.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fintra-link-prim-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fintra-link-prim-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-prim-conflict.rs?ref=0f5c76951327b912c8e92e83235430ebd9b349d9", "patch": "@@ -18,13 +18,13 @@\n \n /// [struct@char]\n //~^ ERROR incompatible link\n-//~| HELP prefix with the item kind\n+//~| HELP prefix with `mod@`\n //~| NOTE resolved to a module\n pub mod char {}\n \n pub mod inner {\n     //! [struct@char]\n     //~^ ERROR incompatible link\n-    //~| HELP prefix with the item kind\n+    //~| HELP prefix with `prim@`\n     //~| NOTE resolved to a builtin type\n }"}, {"sha": "43587a80021afe8c1937613808f3f92a1a09eef2", "filename": "src/test/rustdoc-ui/intra-link-prim-conflict.stderr", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fintra-link-prim-conflict.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fintra-link-prim-conflict.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-prim-conflict.stderr?ref=0f5c76951327b912c8e92e83235430ebd9b349d9", "patch": "@@ -9,11 +9,11 @@ note: the lint level is defined here\n    |\n LL | #![deny(broken_intra_doc_links)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n-help: to link to the module, prefix with the item kind\n+help: to link to the module, prefix with `mod@`\n    |\n LL | /// [mod@char]\n    |      ^^^^^^^^\n-help: to link to the builtin type, prefix with the item kind\n+help: to link to the builtin type, prefix with `prim@`\n    |\n LL | /// [prim@char]\n    |      ^^^^^^^^^\n@@ -24,11 +24,11 @@ error: `char` is both a module and a builtin type\n LL | /// [type@char]\n    |      ^^^^^^^^^ ambiguous link\n    |\n-help: to link to the module, prefix with the item kind\n+help: to link to the module, prefix with `mod@`\n    |\n LL | /// [mod@char]\n    |      ^^^^^^^^\n-help: to link to the builtin type, prefix with the item kind\n+help: to link to the builtin type, prefix with `prim@`\n    |\n LL | /// [prim@char]\n    |      ^^^^^^^^^\n@@ -37,25 +37,17 @@ error: incompatible link kind for `char`\n   --> $DIR/intra-link-prim-conflict.rs:19:6\n    |\n LL | /// [struct@char]\n-   |      ^^^^^^^^^^^\n+   |      ^^^^^^^^^^^ help: to link to the module, prefix with `mod@`: `mod@char`\n    |\n    = note: this link resolved to a module, which is not a struct\n-help: to link to the module, prefix with the item kind\n-   |\n-LL | /// [mod@char]\n-   |      ^^^^^^^^\n \n error: incompatible link kind for `char`\n   --> $DIR/intra-link-prim-conflict.rs:26:10\n    |\n LL |     //! [struct@char]\n-   |          ^^^^^^^^^^^\n+   |          ^^^^^^^^^^^ help: to link to the builtin type, prefix with `prim@`: `prim@char`\n    |\n    = note: this link resolved to a builtin type, which is not a struct\n-help: to link to the builtin type, prefix with the item kind\n-   |\n-LL |     //! [prim@char]\n-   |          ^^^^^^^^^\n \n error: aborting due to 4 previous errors\n "}, {"sha": "3c13df20588d8ae372ae487817b4730116de8f4a", "filename": "src/test/rustdoc-ui/intra-link-span-ice-55723.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.stderr?ref=0f5c76951327b912c8e92e83235430ebd9b349d9", "patch": "@@ -2,7 +2,7 @@ error: unresolved link to `i`\n   --> $DIR/intra-link-span-ice-55723.rs:9:10\n    |\n LL | /// \uff08arr[i]\uff09\n-   |           ^ unresolved link\n+   |           ^ no item named `i` in `intra_link_span_ice_55723`\n    |\n note: the lint level is defined here\n   --> $DIR/intra-link-span-ice-55723.rs:1:9"}, {"sha": "17891ca05efa18ca43aa7dcf722df85fb13bd5fa", "filename": "src/test/rustdoc-ui/intra-links-ambiguity.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.stderr?ref=0f5c76951327b912c8e92e83235430ebd9b349d9", "patch": "@@ -9,7 +9,7 @@ note: the lint level is defined here\n    |\n LL | #![deny(broken_intra_doc_links)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n-help: to link to the struct, prefix with the item kind\n+help: to link to the struct, prefix with `struct@`\n    |\n LL | /// [`struct@ambiguous`] is ambiguous.\n    |      ^^^^^^^^^^^^^^^^^^\n@@ -24,7 +24,7 @@ error: `ambiguous` is both a struct and a function\n LL | /// [ambiguous] is ambiguous.\n    |      ^^^^^^^^^ ambiguous link\n    |\n-help: to link to the struct, prefix with the item kind\n+help: to link to the struct, prefix with `struct@`\n    |\n LL | /// [struct@ambiguous] is ambiguous.\n    |      ^^^^^^^^^^^^^^^^\n@@ -39,7 +39,7 @@ error: `multi_conflict` is a struct, a function, and a macro\n LL | /// [`multi_conflict`] is a three-way conflict.\n    |      ^^^^^^^^^^^^^^^^ ambiguous link\n    |\n-help: to link to the struct, prefix with the item kind\n+help: to link to the struct, prefix with `struct@`\n    |\n LL | /// [`struct@multi_conflict`] is a three-way conflict.\n    |      ^^^^^^^^^^^^^^^^^^^^^^^\n@@ -58,11 +58,11 @@ error: `type_and_value` is both a module and a constant\n LL | /// Ambiguous [type_and_value].\n    |                ^^^^^^^^^^^^^^ ambiguous link\n    |\n-help: to link to the module, prefix with the item kind\n+help: to link to the module, prefix with `mod@`\n    |\n LL | /// Ambiguous [mod@type_and_value].\n    |                ^^^^^^^^^^^^^^^^^^\n-help: to link to the constant, prefix with the item kind\n+help: to link to the constant, prefix with `const@`\n    |\n LL | /// Ambiguous [const@type_and_value].\n    |                ^^^^^^^^^^^^^^^^^^^^\n@@ -73,7 +73,7 @@ error: `foo::bar` is both an enum and a function\n LL | /// Ambiguous non-implied shortcut link [`foo::bar`].\n    |                                          ^^^^^^^^^^ ambiguous link\n    |\n-help: to link to the enum, prefix with the item kind\n+help: to link to the enum, prefix with `enum@`\n    |\n LL | /// Ambiguous non-implied shortcut link [`enum@foo::bar`].\n    |                                          ^^^^^^^^^^^^^^^"}, {"sha": "1825a4ad1fa6b6c013b8fc652d135dd69b0093d3", "filename": "src/test/rustdoc-ui/intra-links-anchors.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fintra-links-anchors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fintra-links-anchors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-anchors.stderr?ref=0f5c76951327b912c8e92e83235430ebd9b349d9", "patch": "@@ -1,4 +1,4 @@\n-error: `Foo::f#hola` contains an anchor, but links to struct fields are already anchored\n+error: `Foo::f#hola` contains an anchor, but links to fields are already anchored\n   --> $DIR/intra-links-anchors.rs:25:15\n    |\n LL | /// Or maybe [Foo::f#hola].\n@@ -16,13 +16,13 @@ error: `hello#people#!` contains multiple anchors\n LL | /// Another anchor error: [hello#people#!].\n    |                            ^^^^^^^^^^^^^^ contains invalid anchor\n \n-error: `Enum::A#whatever` contains an anchor, but links to enum variants are already anchored\n+error: `Enum::A#whatever` contains an anchor, but links to variants are already anchored\n   --> $DIR/intra-links-anchors.rs:37:28\n    |\n LL | /// Damn enum's variants: [Enum::A#whatever].\n    |                            ^^^^^^^^^^^^^^^^ contains invalid anchor\n \n-error: `u32#hello` contains an anchor, but links to primitive types are already anchored\n+error: `u32#hello` contains an anchor, but links to builtin types are already anchored\n   --> $DIR/intra-links-anchors.rs:43:6\n    |\n LL | /// [u32#hello]"}, {"sha": "b9c8e033b1b21002ceb70070deeb30b5b991a5c7", "filename": "src/test/rustdoc-ui/intra-links-disambiguator-mismatch.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.rs?ref=0f5c76951327b912c8e92e83235430ebd9b349d9", "patch": "@@ -14,27 +14,27 @@ trait T {}\n /// Link to [struct@S]\n //~^ ERROR incompatible link kind for `S`\n //~| NOTE this link resolved\n-//~| HELP prefix with the item kind\n+//~| HELP prefix with `enum@`\n \n /// Link to [mod@S]\n //~^ ERROR incompatible link kind for `S`\n //~| NOTE this link resolved\n-//~| HELP prefix with the item kind\n+//~| HELP prefix with `enum@`\n \n /// Link to [union@S]\n //~^ ERROR incompatible link kind for `S`\n //~| NOTE this link resolved\n-//~| HELP prefix with the item kind\n+//~| HELP prefix with `enum@`\n \n /// Link to [trait@S]\n //~^ ERROR incompatible link kind for `S`\n //~| NOTE this link resolved\n-//~| HELP prefix with the item kind\n+//~| HELP prefix with `enum@`\n \n /// Link to [struct@T]\n //~^ ERROR incompatible link kind for `T`\n //~| NOTE this link resolved\n-//~| HELP prefix with the item kind\n+//~| HELP prefix with `trait@`\n \n /// Link to [derive@m]\n //~^ ERROR incompatible link kind for `m`\n@@ -44,22 +44,22 @@ trait T {}\n /// Link to [const@s]\n //~^ ERROR incompatible link kind for `s`\n //~| NOTE this link resolved\n-//~| HELP prefix with the item kind\n+//~| HELP prefix with `static@`\n \n /// Link to [static@c]\n //~^ ERROR incompatible link kind for `c`\n //~| NOTE this link resolved\n-//~| HELP prefix with the item kind\n+//~| HELP prefix with `const@`\n \n /// Link to [fn@c]\n //~^ ERROR incompatible link kind for `c`\n //~| NOTE this link resolved\n-//~| HELP prefix with the item kind\n+//~| HELP prefix with `const@`\n \n /// Link to [c()]\n //~^ ERROR incompatible link kind for `c`\n //~| NOTE this link resolved\n-//~| HELP prefix with the item kind\n+//~| HELP prefix with `const@`\n \n /// Link to [const@f]\n //~^ ERROR incompatible link kind for `f`"}, {"sha": "2e732baf6e01e246fd0ae317b212eb755caab450", "filename": "src/test/rustdoc-ui/intra-links-disambiguator-mismatch.stderr", "status": "modified", "additions": 9, "deletions": 45, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.stderr?ref=0f5c76951327b912c8e92e83235430ebd9b349d9", "patch": "@@ -2,66 +2,46 @@ error: incompatible link kind for `S`\n   --> $DIR/intra-links-disambiguator-mismatch.rs:14:14\n    |\n LL | /// Link to [struct@S]\n-   |              ^^^^^^^^\n+   |              ^^^^^^^^ help: to link to the enum, prefix with `enum@`: `enum@S`\n    |\n note: the lint level is defined here\n   --> $DIR/intra-links-disambiguator-mismatch.rs:1:9\n    |\n LL | #![deny(broken_intra_doc_links)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n    = note: this link resolved to an enum, which is not a struct\n-help: to link to the enum, prefix with the item kind\n-   |\n-LL | /// Link to [enum@S]\n-   |              ^^^^^^\n \n error: incompatible link kind for `S`\n   --> $DIR/intra-links-disambiguator-mismatch.rs:19:14\n    |\n LL | /// Link to [mod@S]\n-   |              ^^^^^\n+   |              ^^^^^ help: to link to the enum, prefix with `enum@`: `enum@S`\n    |\n    = note: this link resolved to an enum, which is not a module\n-help: to link to the enum, prefix with the item kind\n-   |\n-LL | /// Link to [enum@S]\n-   |              ^^^^^^\n \n error: incompatible link kind for `S`\n   --> $DIR/intra-links-disambiguator-mismatch.rs:24:14\n    |\n LL | /// Link to [union@S]\n-   |              ^^^^^^^\n+   |              ^^^^^^^ help: to link to the enum, prefix with `enum@`: `enum@S`\n    |\n    = note: this link resolved to an enum, which is not a union\n-help: to link to the enum, prefix with the item kind\n-   |\n-LL | /// Link to [enum@S]\n-   |              ^^^^^^\n \n error: incompatible link kind for `S`\n   --> $DIR/intra-links-disambiguator-mismatch.rs:29:14\n    |\n LL | /// Link to [trait@S]\n-   |              ^^^^^^^\n+   |              ^^^^^^^ help: to link to the enum, prefix with `enum@`: `enum@S`\n    |\n    = note: this link resolved to an enum, which is not a trait\n-help: to link to the enum, prefix with the item kind\n-   |\n-LL | /// Link to [enum@S]\n-   |              ^^^^^^\n \n error: incompatible link kind for `T`\n   --> $DIR/intra-links-disambiguator-mismatch.rs:34:14\n    |\n LL | /// Link to [struct@T]\n-   |              ^^^^^^^^\n+   |              ^^^^^^^^ help: to link to the trait, prefix with `trait@`: `trait@T`\n    |\n    = note: this link resolved to a trait, which is not a struct\n-help: to link to the trait, prefix with the item kind\n-   |\n-LL | /// Link to [trait@T]\n-   |              ^^^^^^^\n \n error: incompatible link kind for `m`\n   --> $DIR/intra-links-disambiguator-mismatch.rs:39:14\n@@ -75,49 +55,33 @@ error: incompatible link kind for `s`\n   --> $DIR/intra-links-disambiguator-mismatch.rs:44:14\n    |\n LL | /// Link to [const@s]\n-   |              ^^^^^^^\n+   |              ^^^^^^^ help: to link to the static, prefix with `static@`: `static@s`\n    |\n    = note: this link resolved to a static, which is not a constant\n-help: to link to the static, prefix with the item kind\n-   |\n-LL | /// Link to [static@s]\n-   |              ^^^^^^^^\n \n error: incompatible link kind for `c`\n   --> $DIR/intra-links-disambiguator-mismatch.rs:49:14\n    |\n LL | /// Link to [static@c]\n-   |              ^^^^^^^^\n+   |              ^^^^^^^^ help: to link to the constant, prefix with `const@`: `const@c`\n    |\n    = note: this link resolved to a constant, which is not a static\n-help: to link to the constant, prefix with the item kind\n-   |\n-LL | /// Link to [const@c]\n-   |              ^^^^^^^\n \n error: incompatible link kind for `c`\n   --> $DIR/intra-links-disambiguator-mismatch.rs:54:14\n    |\n LL | /// Link to [fn@c]\n-   |              ^^^^\n+   |              ^^^^ help: to link to the constant, prefix with `const@`: `const@c`\n    |\n    = note: this link resolved to a constant, which is not a function\n-help: to link to the constant, prefix with the item kind\n-   |\n-LL | /// Link to [const@c]\n-   |              ^^^^^^^\n \n error: incompatible link kind for `c`\n   --> $DIR/intra-links-disambiguator-mismatch.rs:59:14\n    |\n LL | /// Link to [c()]\n-   |              ^^^\n+   |              ^^^ help: to link to the constant, prefix with `const@`: `const@c`\n    |\n    = note: this link resolved to a constant, which is not a function\n-help: to link to the constant, prefix with the item kind\n-   |\n-LL | /// Link to [const@c]\n-   |              ^^^^^^^\n \n error: incompatible link kind for `f`\n   --> $DIR/intra-links-disambiguator-mismatch.rs:64:14"}, {"sha": "351f8fafa64d8117b38279e3269dab8f655980b6", "filename": "src/test/rustdoc-ui/intra-links-warning-crlf.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning-crlf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning-crlf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning-crlf.stderr?ref=0f5c76951327b912c8e92e83235430ebd9b349d9", "patch": "@@ -2,7 +2,7 @@ warning: unresolved link to `error`\n   --> $DIR/intra-links-warning-crlf.rs:7:6\n    |\n LL | /// [error]\n-   |      ^^^^^ unresolved link\n+   |      ^^^^^ no item named `error` in `intra_links_warning_crlf`\n    |\n    = note: `#[warn(broken_intra_doc_links)]` on by default\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n@@ -11,23 +11,23 @@ warning: unresolved link to `error1`\n   --> $DIR/intra-links-warning-crlf.rs:12:11\n    |\n LL | /// docs [error1]\n-   |           ^^^^^^ unresolved link\n+   |           ^^^^^^ no item named `error1` in `intra_links_warning_crlf`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error2`\n   --> $DIR/intra-links-warning-crlf.rs:15:11\n    |\n LL | /// docs [error2]\n-   |           ^^^^^^ unresolved link\n+   |           ^^^^^^ no item named `error2` in `intra_links_warning_crlf`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error`\n   --> $DIR/intra-links-warning-crlf.rs:23:20\n    |\n LL |  * It also has an [error].\n-   |                    ^^^^^ unresolved link\n+   |                    ^^^^^ no item named `error` in `intra_links_warning_crlf`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n "}, {"sha": "0832e00d35a005b13093cee326e002d5c13d9725", "filename": "src/test/rustdoc-ui/intra-links-warning.stderr", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr?ref=0f5c76951327b912c8e92e83235430ebd9b349d9", "patch": "@@ -2,72 +2,61 @@ warning: unresolved link to `Foo::baz`\n   --> $DIR/intra-links-warning.rs:3:23\n    |\n LL |        //! Test with [Foo::baz], [Bar::foo], ...\n-   |                       ^^^^^^^^ unresolved link\n+   |                       ^^^^^^^^ the struct `Foo` has no field or associated item named `baz`\n    |\n    = note: `#[warn(broken_intra_doc_links)]` on by default\n-   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `Bar::foo`\n   --> $DIR/intra-links-warning.rs:3:35\n    |\n LL |        //! Test with [Foo::baz], [Bar::foo], ...\n-   |                                   ^^^^^^^^ unresolved link\n-   |\n-   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+   |                                   ^^^^^^^^ no item named `Bar` in `intra_links_warning`\n \n warning: unresolved link to `Uniooon::X`\n   --> $DIR/intra-links-warning.rs:6:13\n    |\n LL |      //! , [Uniooon::X] and [Qux::Z].\n-   |             ^^^^^^^^^^ unresolved link\n-   |\n-   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+   |             ^^^^^^^^^^ no item named `Uniooon` in `intra_links_warning`\n \n warning: unresolved link to `Qux::Z`\n   --> $DIR/intra-links-warning.rs:6:30\n    |\n LL |      //! , [Uniooon::X] and [Qux::Z].\n-   |                              ^^^^^^ unresolved link\n-   |\n-   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+   |                              ^^^^^^ no item named `Qux` in `intra_links_warning`\n \n warning: unresolved link to `Uniooon::X`\n   --> $DIR/intra-links-warning.rs:10:14\n    |\n LL |       //! , [Uniooon::X] and [Qux::Z].\n-   |              ^^^^^^^^^^ unresolved link\n-   |\n-   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+   |              ^^^^^^^^^^ no item named `Uniooon` in `intra_links_warning`\n \n warning: unresolved link to `Qux::Z`\n   --> $DIR/intra-links-warning.rs:10:31\n    |\n LL |       //! , [Uniooon::X] and [Qux::Z].\n-   |                               ^^^^^^ unresolved link\n-   |\n-   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+   |                               ^^^^^^ no item named `Qux` in `intra_links_warning`\n \n warning: unresolved link to `Qux:Y`\n   --> $DIR/intra-links-warning.rs:14:13\n    |\n LL |        /// [Qux:Y]\n-   |             ^^^^^ unresolved link\n+   |             ^^^^^ no item named `Qux:Y` in `intra_links_warning`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error`\n   --> $DIR/intra-links-warning.rs:58:30\n    |\n LL |  * time to introduce a link [error]*/\n-   |                              ^^^^^ unresolved link\n+   |                              ^^^^^ no item named `error` in `intra_links_warning`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error`\n   --> $DIR/intra-links-warning.rs:64:30\n    |\n LL |  * time to introduce a link [error]\n-   |                              ^^^^^ unresolved link\n+   |                              ^^^^^ no item named `error` in `intra_links_warning`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n@@ -81,6 +70,7 @@ LL | #[doc = \"single line [error]\"]\n            \n            single line [error]\n                         ^^^^^\n+   = note: no item named `error` in `intra_links_warning`\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error`\n@@ -93,6 +83,7 @@ LL | #[doc = \"single line with \\\"escaping\\\" [error]\"]\n            \n            single line with \"escaping\" [error]\n                                         ^^^^^\n+   = note: no item named `error` in `intra_links_warning`\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error`\n@@ -107,45 +98,46 @@ LL | | /// [error]\n            \n            [error]\n             ^^^^^\n+   = note: no item named `error` in `intra_links_warning`\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error1`\n   --> $DIR/intra-links-warning.rs:80:11\n    |\n LL | /// docs [error1]\n-   |           ^^^^^^ unresolved link\n+   |           ^^^^^^ no item named `error1` in `intra_links_warning`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error2`\n   --> $DIR/intra-links-warning.rs:82:11\n    |\n LL | /// docs [error2]\n-   |           ^^^^^^ unresolved link\n+   |           ^^^^^^ no item named `error2` in `intra_links_warning`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `BarA`\n   --> $DIR/intra-links-warning.rs:21:10\n    |\n LL | /// bar [BarA] bar\n-   |          ^^^^ unresolved link\n+   |          ^^^^ no item named `BarA` in `intra_links_warning`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `BarB`\n   --> $DIR/intra-links-warning.rs:27:9\n    |\n LL |  * bar [BarB] bar\n-   |         ^^^^ unresolved link\n+   |         ^^^^ no item named `BarB` in `intra_links_warning`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `BarC`\n   --> $DIR/intra-links-warning.rs:34:6\n    |\n LL | bar [BarC] bar\n-   |      ^^^^ unresolved link\n+   |      ^^^^ no item named `BarC` in `intra_links_warning`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n@@ -159,6 +151,7 @@ LL | #[doc = \"Foo\\nbar [BarD] bar\\nbaz\"]\n            \n            bar [BarD] bar\n                 ^^^^\n+   = note: no item named `BarD` in `intra_links_warning`\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `BarF`\n@@ -174,6 +167,7 @@ LL | f!(\"Foo\\nbar [BarF] bar\\nbaz\");\n            \n            bar [BarF] bar\n                 ^^^^\n+   = note: no item named `BarF` in `intra_links_warning`\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n    = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n "}, {"sha": "550b79f6e89286bee7166d439514e661704b90cd", "filename": "src/test/rustdoc-ui/lint-group.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Flint-group.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f5c76951327b912c8e92e83235430ebd9b349d9/src%2Ftest%2Frustdoc-ui%2Flint-group.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Flint-group.stderr?ref=0f5c76951327b912c8e92e83235430ebd9b349d9", "patch": "@@ -32,7 +32,7 @@ error: unresolved link to `error`\n   --> $DIR/lint-group.rs:9:29\n    |\n LL | /// what up, let's make an [error]\n-   |                             ^^^^^ unresolved link\n+   |                             ^^^^^ no item named `error` in `lint_group`\n    |\n note: the lint level is defined here\n   --> $DIR/lint-group.rs:7:9"}]}