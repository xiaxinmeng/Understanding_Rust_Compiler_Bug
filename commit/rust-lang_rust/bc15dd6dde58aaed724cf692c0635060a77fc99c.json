{"sha": "bc15dd6dde58aaed724cf692c0635060a77fc99c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjMTVkZDZkZGU1OGFhZWQ3MjRjZjY5MmMwNjM1MDYwYTc3ZmM5OWM=", "commit": {"author": {"name": "jumbatm", "email": "30644300+jumbatm@users.noreply.github.com", "date": "2020-08-17T16:00:35Z"}, "committer": {"name": "jumbatm", "email": "30644300+jumbatm@users.noreply.github.com", "date": "2020-08-17T16:01:05Z"}, "message": "Wrap recursion in `ensure_sufficient_stack`.", "tree": {"sha": "3753d6923e75fb709e23ac4bcc2bbf88f45debb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3753d6923e75fb709e23ac4bcc2bbf88f45debb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc15dd6dde58aaed724cf692c0635060a77fc99c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc15dd6dde58aaed724cf692c0635060a77fc99c", "html_url": "https://github.com/rust-lang/rust/commit/bc15dd6dde58aaed724cf692c0635060a77fc99c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc15dd6dde58aaed724cf692c0635060a77fc99c/comments", "author": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1321a2dce32893588a0ec4ba586c3a04fb5e47cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/1321a2dce32893588a0ec4ba586c3a04fb5e47cf", "html_url": "https://github.com/rust-lang/rust/commit/1321a2dce32893588a0ec4ba586c3a04fb5e47cf"}], "stats": {"total": 179, "additions": 91, "deletions": 88}, "files": [{"sha": "147eb8f06c81c451f2213829e5577232eba9e626", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 91, "deletions": 88, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/bc15dd6dde58aaed724cf692c0635060a77fc99c/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc15dd6dde58aaed724cf692c0635060a77fc99c/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=bc15dd6dde58aaed724cf692c0635060a77fc99c", "patch": "@@ -29,6 +29,7 @@ use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::visit::{FnCtxt, FnKind};\n use rustc_ast_pretty::pprust::{self, expr_to_string};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n use rustc_feature::{deprecated_attributes, AttributeGate, AttributeTemplate, AttributeType};\n use rustc_feature::{GateIssue, Stability};\n@@ -2188,16 +2189,17 @@ impl ClashingExternDeclarations {\n                     kind.is_primitive() || matches!(kind, RawPtr(..) | Ref(..))\n                 };\n \n-                match (a_kind, b_kind) {\n-                    (Adt(a_def, a_substs), Adt(b_def, b_substs)) => {\n-                        let a = a.subst(cx.tcx, a_substs);\n-                        let b = b.subst(cx.tcx, b_substs);\n-                        debug!(\"Comparing {:?} and {:?}\", a, b);\n+                ensure_sufficient_stack(|| {\n+                    match (a_kind, b_kind) {\n+                        (Adt(a_def, a_substs), Adt(b_def, b_substs)) => {\n+                            let a = a.subst(cx.tcx, a_substs);\n+                            let b = b.subst(cx.tcx, b_substs);\n+                            debug!(\"Comparing {:?} and {:?}\", a, b);\n \n-                        // Grab a flattened representation of all fields.\n-                        let a_fields = a_def.variants.iter().flat_map(|v| v.fields.iter());\n-                        let b_fields = b_def.variants.iter().flat_map(|v| v.fields.iter());\n-                        compare_layouts(a, b)\n+                            // Grab a flattened representation of all fields.\n+                            let a_fields = a_def.variants.iter().flat_map(|v| v.fields.iter());\n+                            let b_fields = b_def.variants.iter().flat_map(|v| v.fields.iter());\n+                            compare_layouts(a, b)\n                             && a_fields.eq_by(\n                                 b_fields,\n                                 |&ty::FieldDef { did: a_did, .. },\n@@ -2211,88 +2213,89 @@ impl ClashingExternDeclarations {\n                                     )\n                                 },\n                             )\n-                    }\n-                    (Array(a_ty, a_const), Array(b_ty, b_const)) => {\n-                        // For arrays, we also check the constness of the type.\n-                        a_const.val == b_const.val\n-                            && structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n-                    }\n-                    (Slice(a_ty), Slice(b_ty)) => {\n-                        structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n-                    }\n-                    (RawPtr(a_tymut), RawPtr(b_tymut)) => {\n-                        a_tymut.mutbl == b_tymut.mutbl\n-                            && structurally_same_type_impl(\n-                                seen_types,\n-                                cx,\n-                                &a_tymut.ty,\n-                                &b_tymut.ty,\n-                                ckind,\n-                            )\n-                    }\n-                    (Ref(_a_region, a_ty, a_mut), Ref(_b_region, b_ty, b_mut)) => {\n-                        // For structural sameness, we don't need the region to be same.\n-                        a_mut == b_mut\n-                            && structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n-                    }\n-                    (FnDef(..), FnDef(..)) => {\n-                        let a_poly_sig = a.fn_sig(tcx);\n-                        let b_poly_sig = b.fn_sig(tcx);\n-\n-                        // As we don't compare regions, skip_binder is fine.\n-                        let a_sig = a_poly_sig.skip_binder();\n-                        let b_sig = b_poly_sig.skip_binder();\n-\n-                        (a_sig.abi, a_sig.unsafety, a_sig.c_variadic)\n-                            == (b_sig.abi, b_sig.unsafety, b_sig.c_variadic)\n-                            && a_sig.inputs().iter().eq_by(b_sig.inputs().iter(), |a, b| {\n-                                structurally_same_type_impl(seen_types, cx, a, b, ckind)\n-                            })\n-                            && structurally_same_type_impl(\n-                                seen_types,\n-                                cx,\n-                                a_sig.output(),\n-                                b_sig.output(),\n-                                ckind,\n-                            )\n-                    }\n-                    (Tuple(a_substs), Tuple(b_substs)) => {\n-                        a_substs.types().eq_by(b_substs.types(), |a_ty, b_ty| {\n+                        }\n+                        (Array(a_ty, a_const), Array(b_ty, b_const)) => {\n+                            // For arrays, we also check the constness of the type.\n+                            a_const.val == b_const.val\n+                                && structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n+                        }\n+                        (Slice(a_ty), Slice(b_ty)) => {\n                             structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n-                        })\n-                    }\n-                    // For these, it's not quite as easy to define structural-sameness quite so easily.\n-                    // For the purposes of this lint, take the conservative approach and mark them as\n-                    // not structurally same.\n-                    (Dynamic(..), Dynamic(..))\n-                    | (Error(..), Error(..))\n-                    | (Closure(..), Closure(..))\n-                    | (Generator(..), Generator(..))\n-                    | (GeneratorWitness(..), GeneratorWitness(..))\n-                    | (Projection(..), Projection(..))\n-                    | (Opaque(..), Opaque(..)) => false,\n-\n-                    // These definitely should have been caught above.\n-                    (Bool, Bool) | (Char, Char) | (Never, Never) | (Str, Str) => unreachable!(),\n-\n-                    // An Adt and a primitive or pointer type. This can be FFI-safe if non-null\n-                    // enum layout optimisation is being applied.\n-                    (Adt(..), other_kind) | (other_kind, Adt(..))\n-                        if is_primitive_or_pointer(other_kind) =>\n-                    {\n-                        let (primitive, adt) =\n-                            if is_primitive_or_pointer(&a.kind) { (a, b) } else { (b, a) };\n-                        if let Some(ty) = crate::types::repr_nullable_ptr(cx, adt, ckind) {\n-                            ty == primitive\n-                        } else {\n-                            compare_layouts(a, b)\n                         }\n+                        (RawPtr(a_tymut), RawPtr(b_tymut)) => {\n+                            a_tymut.mutbl == b_tymut.mutbl\n+                                && structurally_same_type_impl(\n+                                    seen_types,\n+                                    cx,\n+                                    &a_tymut.ty,\n+                                    &b_tymut.ty,\n+                                    ckind,\n+                                )\n+                        }\n+                        (Ref(_a_region, a_ty, a_mut), Ref(_b_region, b_ty, b_mut)) => {\n+                            // For structural sameness, we don't need the region to be same.\n+                            a_mut == b_mut\n+                                && structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n+                        }\n+                        (FnDef(..), FnDef(..)) => {\n+                            let a_poly_sig = a.fn_sig(tcx);\n+                            let b_poly_sig = b.fn_sig(tcx);\n+\n+                            // As we don't compare regions, skip_binder is fine.\n+                            let a_sig = a_poly_sig.skip_binder();\n+                            let b_sig = b_poly_sig.skip_binder();\n+\n+                            (a_sig.abi, a_sig.unsafety, a_sig.c_variadic)\n+                                == (b_sig.abi, b_sig.unsafety, b_sig.c_variadic)\n+                                && a_sig.inputs().iter().eq_by(b_sig.inputs().iter(), |a, b| {\n+                                    structurally_same_type_impl(seen_types, cx, a, b, ckind)\n+                                })\n+                                && structurally_same_type_impl(\n+                                    seen_types,\n+                                    cx,\n+                                    a_sig.output(),\n+                                    b_sig.output(),\n+                                    ckind,\n+                                )\n+                        }\n+                        (Tuple(a_substs), Tuple(b_substs)) => {\n+                            a_substs.types().eq_by(b_substs.types(), |a_ty, b_ty| {\n+                                structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n+                            })\n+                        }\n+                        // For these, it's not quite as easy to define structural-sameness quite so easily.\n+                        // For the purposes of this lint, take the conservative approach and mark them as\n+                        // not structurally same.\n+                        (Dynamic(..), Dynamic(..))\n+                        | (Error(..), Error(..))\n+                        | (Closure(..), Closure(..))\n+                        | (Generator(..), Generator(..))\n+                        | (GeneratorWitness(..), GeneratorWitness(..))\n+                        | (Projection(..), Projection(..))\n+                        | (Opaque(..), Opaque(..)) => false,\n+\n+                        // These definitely should have been caught above.\n+                        (Bool, Bool) | (Char, Char) | (Never, Never) | (Str, Str) => unreachable!(),\n+\n+                        // An Adt and a primitive or pointer type. This can be FFI-safe if non-null\n+                        // enum layout optimisation is being applied.\n+                        (Adt(..), other_kind) | (other_kind, Adt(..))\n+                            if is_primitive_or_pointer(other_kind) =>\n+                        {\n+                            let (primitive, adt) =\n+                                if is_primitive_or_pointer(&a.kind) { (a, b) } else { (b, a) };\n+                            if let Some(ty) = crate::types::repr_nullable_ptr(cx, adt, ckind) {\n+                                ty == primitive\n+                            } else {\n+                                compare_layouts(a, b)\n+                            }\n+                        }\n+                        // Otherwise, just compare the layouts. This may fail to lint for some\n+                        // incompatible types, but at the very least, will stop reads into\n+                        // uninitialised memory.\n+                        _ => compare_layouts(a, b),\n                     }\n-                    // Otherwise, just compare the layouts. This may fail to lint for some\n-                    // incompatible types, but at the very least, will stop reads into\n-                    // uninitialised memory.\n-                    _ => compare_layouts(a, b),\n-                }\n+                })\n             }\n         }\n         let mut seen_types = FxHashSet::default();"}]}