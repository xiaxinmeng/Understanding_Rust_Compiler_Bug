{"sha": "ac708826b0d97e105f91a4cde41bfe14cff032f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjNzA4ODI2YjBkOTdlMTA1ZjkxYTRjZGU0MWJmZTE0Y2ZmMDMyZjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-04T12:20:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-04T12:20:55Z"}, "message": "Auto merge of #55349 - bjorn3:rustc_mir_collect_and_partition_mono_items, r=oli-obk\n\nMove collect_and_partition_mono_items to rustc_mir\n\nMost of the logic of it is inside rustc_mir anyway.\n\nAlso removes the single function crate rustc_metadata_utils. Based on #55225", "tree": {"sha": "8c8cc81d722920ada33dc5e97d1ad7d2bd3d6512", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c8cc81d722920ada33dc5e97d1ad7d2bd3d6512"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac708826b0d97e105f91a4cde41bfe14cff032f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac708826b0d97e105f91a4cde41bfe14cff032f2", "html_url": "https://github.com/rust-lang/rust/commit/ac708826b0d97e105f91a4cde41bfe14cff032f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac708826b0d97e105f91a4cde41bfe14cff032f2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86b88e6a85f4c532c58cdcdabf6050c6170628e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/86b88e6a85f4c532c58cdcdabf6050c6170628e0", "html_url": "https://github.com/rust-lang/rust/commit/86b88e6a85f4c532c58cdcdabf6050c6170628e0"}, {"sha": "9e479c2818eac337657c52791b12955002582dfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e479c2818eac337657c52791b12955002582dfd", "html_url": "https://github.com/rust-lang/rust/commit/9e479c2818eac337657c52791b12955002582dfd"}], "stats": {"total": 583, "additions": 280, "deletions": 303}, "files": [{"sha": "b4317864502cee0fd48979f54fb6f057b47c0bcf", "filename": "src/Cargo.lock", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=ac708826b0d97e105f91a4cde41bfe14cff032f2", "patch": "@@ -2141,11 +2141,13 @@ dependencies = [\n  \"flate2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n+ \"rustc_allocator 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_incremental 0.0.0\",\n- \"rustc_metadata_utils 0.0.0\",\n+ \"rustc_metadata 0.0.0\",\n  \"rustc_mir 0.0.0\",\n  \"rustc_target 0.0.0\",\n+ \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n@@ -2289,23 +2291,13 @@ dependencies = [\n  \"rustc 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n- \"rustc_metadata_utils 0.0.0\",\n  \"rustc_target 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_ext 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n \n-[[package]]\n-name = \"rustc_metadata_utils\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"rustc 0.0.0\",\n- \"syntax 0.0.0\",\n- \"syntax_pos 0.0.0\",\n-]\n-\n [[package]]\n name = \"rustc_mir\"\n version = \"0.0.0\""}, {"sha": "ce4cb1ea3a0423cac94695cb53dba75ab751be8d", "filename": "src/librustc_codegen_llvm/back/archive.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs?ref=ac708826b0d97e105f91a4cde41bfe14cff032f2", "patch": "@@ -52,28 +52,6 @@ enum Addition {\n     },\n }\n \n-pub fn find_library(name: &str, search_paths: &[PathBuf], sess: &Session)\n-                    -> PathBuf {\n-    // On Windows, static libraries sometimes show up as libfoo.a and other\n-    // times show up as foo.lib\n-    let oslibname = format!(\"{}{}{}\",\n-                            sess.target.target.options.staticlib_prefix,\n-                            name,\n-                            sess.target.target.options.staticlib_suffix);\n-    let unixlibname = format!(\"lib{}.a\", name);\n-\n-    for path in search_paths {\n-        debug!(\"looking for {} inside {:?}\", name, path);\n-        let test = path.join(&oslibname);\n-        if test.exists() { return test }\n-        if oslibname != unixlibname {\n-            let test = path.join(&unixlibname);\n-            if test.exists() { return test }\n-        }\n-    }\n-    sess.fatal(&format!(\"could not find native static library `{}`, \\\n-                         perhaps an -L flag is missing?\", name));\n-}\n \n fn is_relevant_child(c: &Child) -> bool {\n     match c.name() {\n@@ -128,7 +106,7 @@ impl<'a> ArchiveBuilder<'a> {\n     /// Adds all of the contents of a native library to this archive. This will\n     /// search in the relevant locations for a library named `name`.\n     pub fn add_native_library(&mut self, name: &str) {\n-        let location = find_library(name, &self.config.lib_search_paths,\n+        let location = ::rustc_codegen_utils::find_library(name, &self.config.lib_search_paths,\n                                     self.config.sess);\n         self.add_archive(&location, |_| false).unwrap_or_else(|e| {\n             self.config.sess.fatal(&format!(\"failed to add native library {}: {}\","}, {"sha": "dd95c3d986299491466baebddfd2d84a1c39e6b9", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=ac708826b0d97e105f91a4cde41bfe14cff032f2", "patch": "@@ -12,8 +12,6 @@ use back::wasm;\n use cc::windows_registry;\n use super::archive::{ArchiveBuilder, ArchiveConfig};\n use super::bytecode::RLIB_BYTECODE_EXTENSION;\n-use super::linker::Linker;\n-use super::command::Command;\n use super::rpath::RPathConfig;\n use super::rpath;\n use metadata::METADATA_FILENAME;\n@@ -31,6 +29,8 @@ use rustc::hir::def_id::CrateNum;\n use tempfile::{Builder as TempFileBuilder, TempDir};\n use rustc_target::spec::{PanicStrategy, RelroLevel, LinkerFlavor};\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_codegen_utils::linker::Linker;\n+use rustc_codegen_utils::command::Command;\n use context::get_reloc_model;\n use llvm;\n \n@@ -701,7 +701,8 @@ fn link_natively(sess: &Session,\n     }\n \n     {\n-        let mut linker = codegen_results.linker_info.to_linker(cmd, &sess, flavor);\n+        let target_cpu = ::llvm_util::target_cpu(sess);\n+        let mut linker = codegen_results.linker_info.to_linker(cmd, &sess, flavor, target_cpu);\n         link_args(&mut *linker, flavor, sess, crate_type, tmpdir,\n                   out_filename, codegen_results);\n         cmd = linker.finalize();"}, {"sha": "8f940e0d22a83db3000da3eea32c9824e3919133", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=ac708826b0d97e105f91a4cde41bfe14cff032f2", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use back::bytecode::{DecodedBytecode, RLIB_BYTECODE_EXTENSION};\n-use back::symbol_export;\n use back::write::{ModuleConfig, with_llvm_pmb, CodegenContext};\n use back::write::{self, DiagnosticHandlers, pre_lto_bitcode_filename};\n use errors::{FatalError, Handler};\n@@ -24,6 +23,7 @@ use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::session::config::{self, Lto};\n use rustc::util::common::time_ext;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_codegen_utils::symbol_export;\n use time_graph::Timeline;\n use {ModuleCodegen, ModuleLlvm, ModuleKind};\n "}, {"sha": "a88ce69604b356fb90d5f85df4edf349e4739827", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=ac708826b0d97e105f91a4cde41bfe14cff032f2", "patch": "@@ -12,9 +12,6 @@ use attributes;\n use back::bytecode::{self, RLIB_BYTECODE_EXTENSION};\n use back::lto::{self, ModuleBuffer, ThinBuffer, SerializedModule};\n use back::link::{self, get_linker, remove};\n-use back::command::Command;\n-use back::linker::LinkerInfo;\n-use back::symbol_export::ExportedSymbols;\n use base;\n use consts;\n use memmap;\n@@ -38,6 +35,9 @@ use rustc::util::common::{time_ext, time_depth, set_time_depth, print_time_passe\n use rustc_fs_util::{path2cstr, link_or_copy};\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_data_structures::svh::Svh;\n+use rustc_codegen_utils::command::Command;\n+use rustc_codegen_utils::linker::LinkerInfo;\n+use rustc_codegen_utils::symbol_export::ExportedSymbols;\n use errors::{self, Handler, Level, DiagnosticBuilder, FatalError, DiagnosticId};\n use errors::emitter::{Emitter};\n use syntax::attr;"}, {"sha": "9736994fc07555ac4d93d30adfc780d19730c3d6", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 4, "deletions": 151, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=ac708826b0d97e105f91a4cde41bfe14cff032f2", "patch": "@@ -54,7 +54,6 @@ use attributes;\n use builder::{Builder, MemFlags};\n use callee;\n use common::{C_bool, C_bytes_in_context, C_i32, C_usize};\n-use rustc_mir::monomorphize::collector::{self, MonoItemCollectionMode};\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n use common::{C_struct_in_context, C_array, val_ty};\n use consts;\n@@ -64,13 +63,13 @@ use declare;\n use meth;\n use mir;\n use monomorphize::Instance;\n-use monomorphize::partitioning::{self, PartitioningStrategy, CodegenUnit, CodegenUnitExt};\n+use monomorphize::partitioning::{CodegenUnit, CodegenUnitExt};\n use rustc_codegen_utils::symbol_names_test;\n use time_graph;\n-use mono_item::{MonoItem, BaseMonoItemExt, MonoItemExt};\n+use mono_item::{MonoItem, MonoItemExt};\n use type_::Type;\n use type_of::LayoutLlvmExt;\n-use rustc::util::nodemap::{FxHashMap, DefIdSet};\n+use rustc::util::nodemap::FxHashMap;\n use CrateInfo;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_data_structures::sync::Lrc;\n@@ -80,7 +79,6 @@ use std::cmp;\n use std::ffi::CString;\n use std::i32;\n use std::ops::{Deref, DerefMut};\n-use std::sync::Arc;\n use std::sync::mpsc;\n use std::time::{Instant, Duration};\n use syntax_pos::Span;\n@@ -1011,128 +1009,6 @@ fn assert_and_save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n          || rustc_incremental::save_dep_graph(tcx));\n }\n \n-fn collect_and_partition_mono_items<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    cnum: CrateNum,\n-) -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>)\n-{\n-    assert_eq!(cnum, LOCAL_CRATE);\n-\n-    let collection_mode = match tcx.sess.opts.debugging_opts.print_mono_items {\n-        Some(ref s) => {\n-            let mode_string = s.to_lowercase();\n-            let mode_string = mode_string.trim();\n-            if mode_string == \"eager\" {\n-                MonoItemCollectionMode::Eager\n-            } else {\n-                if mode_string != \"lazy\" {\n-                    let message = format!(\"Unknown codegen-item collection mode '{}'. \\\n-                                           Falling back to 'lazy' mode.\",\n-                                          mode_string);\n-                    tcx.sess.warn(&message);\n-                }\n-\n-                MonoItemCollectionMode::Lazy\n-            }\n-        }\n-        None => {\n-            if tcx.sess.opts.cg.link_dead_code {\n-                MonoItemCollectionMode::Eager\n-            } else {\n-                MonoItemCollectionMode::Lazy\n-            }\n-        }\n-    };\n-\n-    let (items, inlining_map) =\n-        time(tcx.sess, \"monomorphization collection\", || {\n-            collector::collect_crate_mono_items(tcx, collection_mode)\n-    });\n-\n-    tcx.sess.abort_if_errors();\n-\n-    ::rustc_mir::monomorphize::assert_symbols_are_distinct(tcx, items.iter());\n-\n-    let strategy = if tcx.sess.opts.incremental.is_some() {\n-        PartitioningStrategy::PerModule\n-    } else {\n-        PartitioningStrategy::FixedUnitCount(tcx.sess.codegen_units())\n-    };\n-\n-    let codegen_units = time(tcx.sess, \"codegen unit partitioning\", || {\n-        partitioning::partition(tcx,\n-                                items.iter().cloned(),\n-                                strategy,\n-                                &inlining_map)\n-            .into_iter()\n-            .map(Arc::new)\n-            .collect::<Vec<_>>()\n-    });\n-\n-    let mono_items: DefIdSet = items.iter().filter_map(|mono_item| {\n-        match *mono_item {\n-            MonoItem::Fn(ref instance) => Some(instance.def_id()),\n-            MonoItem::Static(def_id) => Some(def_id),\n-            _ => None,\n-        }\n-    }).collect();\n-\n-    if tcx.sess.opts.debugging_opts.print_mono_items.is_some() {\n-        let mut item_to_cgus: FxHashMap<_, Vec<_>> = Default::default();\n-\n-        for cgu in &codegen_units {\n-            for (&mono_item, &linkage) in cgu.items() {\n-                item_to_cgus.entry(mono_item)\n-                            .or_default()\n-                            .push((cgu.name().clone(), linkage));\n-            }\n-        }\n-\n-        let mut item_keys: Vec<_> = items\n-            .iter()\n-            .map(|i| {\n-                let mut output = i.to_string(tcx);\n-                output.push_str(\" @@\");\n-                let mut empty = Vec::new();\n-                let cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);\n-                cgus.as_mut_slice().sort_by_key(|&(ref name, _)| name.clone());\n-                cgus.dedup();\n-                for &(ref cgu_name, (linkage, _)) in cgus.iter() {\n-                    output.push_str(\" \");\n-                    output.push_str(&cgu_name.as_str());\n-\n-                    let linkage_abbrev = match linkage {\n-                        Linkage::External => \"External\",\n-                        Linkage::AvailableExternally => \"Available\",\n-                        Linkage::LinkOnceAny => \"OnceAny\",\n-                        Linkage::LinkOnceODR => \"OnceODR\",\n-                        Linkage::WeakAny => \"WeakAny\",\n-                        Linkage::WeakODR => \"WeakODR\",\n-                        Linkage::Appending => \"Appending\",\n-                        Linkage::Internal => \"Internal\",\n-                        Linkage::Private => \"Private\",\n-                        Linkage::ExternalWeak => \"ExternalWeak\",\n-                        Linkage::Common => \"Common\",\n-                    };\n-\n-                    output.push_str(\"[\");\n-                    output.push_str(linkage_abbrev);\n-                    output.push_str(\"]\");\n-                }\n-                output\n-            })\n-            .collect();\n-\n-        item_keys.sort();\n-\n-        for item in item_keys {\n-            println!(\"MONO_ITEM {}\", item);\n-        }\n-    }\n-\n-    (Arc::new(mono_items), Arc::new(codegen_units))\n-}\n-\n impl CrateInfo {\n     pub fn new(tcx: TyCtxt) -> CrateInfo {\n         let mut info = CrateInfo {\n@@ -1222,12 +1098,6 @@ impl CrateInfo {\n     }\n }\n \n-fn is_codegened_item(tcx: TyCtxt, id: DefId) -> bool {\n-    let (all_mono_items, _) =\n-        tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n-    all_mono_items.contains(&id)\n-}\n-\n fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   cgu_name: InternedString)\n                                   -> Stats {\n@@ -1318,24 +1188,7 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-pub fn provide(providers: &mut Providers) {\n-    providers.collect_and_partition_mono_items =\n-        collect_and_partition_mono_items;\n-\n-    providers.is_codegened_item = is_codegened_item;\n-\n-    providers.codegen_unit = |tcx, name| {\n-        let (_, all) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n-        all.iter()\n-            .find(|cgu| *cgu.name() == name)\n-            .cloned()\n-            .unwrap_or_else(|| panic!(\"failed to find cgu with name {:?}\", name))\n-    };\n-\n-    provide_extern(providers);\n-}\n-\n-pub fn provide_extern(providers: &mut Providers) {\n+pub fn provide_both(providers: &mut Providers) {\n     providers.dllimport_foreign_items = |tcx, krate| {\n         let module_map = tcx.foreign_modules(krate);\n         let module_map = module_map.iter()"}, {"sha": "5d9bae5412e1a38fbe9db46214311b51355ea81b", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=ac708826b0d97e105f91a4cde41bfe14cff032f2", "patch": "@@ -71,7 +71,6 @@ use back::bytecode::RLIB_BYTECODE_EXTENSION;\n \n pub use llvm_util::target_features;\n use std::any::Any;\n-use std::path::{PathBuf};\n use std::sync::mpsc;\n use rustc_data_structures::sync::Lrc;\n \n@@ -87,20 +86,17 @@ use rustc::util::time_graph;\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n use rustc::util::profiling::ProfileCategory;\n use rustc_mir::monomorphize;\n+use rustc_codegen_utils::{CompiledModule, ModuleKind};\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_data_structures::svh::Svh;\n \n mod diagnostics;\n \n mod back {\n-    pub use rustc_codegen_utils::symbol_names;\n     mod archive;\n     pub mod bytecode;\n-    mod command;\n-    pub mod linker;\n     pub mod link;\n     pub mod lto;\n-    pub mod symbol_export;\n     pub mod write;\n     mod rpath;\n     pub mod wasm;\n@@ -194,15 +190,15 @@ impl CodegenBackend for LlvmCodegenBackend {\n     }\n \n     fn provide(&self, providers: &mut ty::query::Providers) {\n-        back::symbol_names::provide(providers);\n-        back::symbol_export::provide(providers);\n-        base::provide(providers);\n+        rustc_codegen_utils::symbol_export::provide(providers);\n+        rustc_codegen_utils::symbol_names::provide(providers);\n+        base::provide_both(providers);\n         attributes::provide(providers);\n     }\n \n     fn provide_extern(&self, providers: &mut ty::query::Providers) {\n-        back::symbol_export::provide_extern(providers);\n-        base::provide_extern(providers);\n+        rustc_codegen_utils::symbol_export::provide_extern(providers);\n+        base::provide_both(providers);\n         attributes::provide_extern(providers);\n     }\n \n@@ -281,13 +277,6 @@ struct CachedModuleCodegen {\n     source: WorkProduct,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq)]\n-enum ModuleKind {\n-    Regular,\n-    Metadata,\n-    Allocator,\n-}\n-\n impl ModuleCodegen {\n     fn into_compiled_module(self,\n                             emit_obj: bool,\n@@ -321,15 +310,6 @@ impl ModuleCodegen {\n     }\n }\n \n-#[derive(Debug)]\n-struct CompiledModule {\n-    name: String,\n-    kind: ModuleKind,\n-    object: Option<PathBuf>,\n-    bytecode: Option<PathBuf>,\n-    bytecode_compressed: Option<PathBuf>,\n-}\n-\n struct ModuleLlvm {\n     llcx: &'static mut llvm::Context,\n     llmod_raw: *const llvm::Module,\n@@ -377,7 +357,7 @@ struct CodegenResults {\n     crate_hash: Svh,\n     metadata: rustc::middle::cstore::EncodedMetadata,\n     windows_subsystem: Option<String>,\n-    linker_info: back::linker::LinkerInfo,\n+    linker_info: rustc_codegen_utils::linker::LinkerInfo,\n     crate_info: CrateInfo,\n }\n "}, {"sha": "4c57e97841409a0d8a344eb797b823ce87177510", "filename": "src/librustc_codegen_utils/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_codegen_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_codegen_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2FCargo.toml?ref=ac708826b0d97e105f91a4cde41bfe14cff032f2", "patch": "@@ -13,11 +13,13 @@ test = false\n flate2 = \"1.0\"\n log = \"0.4\"\n \n+serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc = { path = \"../librustc\" }\n+rustc_allocator = { path = \"../librustc_allocator\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n-rustc_metadata_utils = { path = \"../librustc_metadata_utils\" }"}, {"sha": "9ebbdd7c3c936eefdde8466292c4cb34f5337458", "filename": "src/librustc_codegen_utils/command.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_codegen_utils%2Fcommand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_codegen_utils%2Fcommand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fcommand.rs?ref=ac708826b0d97e105f91a4cde41bfe14cff032f2", "previous_filename": "src/librustc_codegen_llvm/back/command.rs"}, {"sha": "f0ce1e9b0efab2021377b8f52f57b2e18f724b47", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=ac708826b0d97e105f91a4cde41bfe14cff032f2", "patch": "@@ -30,20 +30,28 @@ extern crate flate2;\n #[macro_use]\n extern crate log;\n \n+extern crate serialize;\n #[macro_use]\n extern crate rustc;\n+extern crate rustc_allocator;\n extern crate rustc_target;\n+extern crate rustc_metadata;\n extern crate rustc_mir;\n extern crate rustc_incremental;\n extern crate syntax;\n extern crate syntax_pos;\n #[macro_use] extern crate rustc_data_structures;\n-extern crate rustc_metadata_utils;\n \n+use std::path::PathBuf;\n+\n+use rustc::session::Session;\n use rustc::ty::TyCtxt;\n \n+pub mod command;\n pub mod link;\n+pub mod linker;\n pub mod codegen_backend;\n+pub mod symbol_export;\n pub mod symbol_names;\n pub mod symbol_names_test;\n \n@@ -61,4 +69,43 @@ pub fn check_for_rustc_errors_attr(tcx: TyCtxt) {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub enum ModuleKind {\n+    Regular,\n+    Metadata,\n+    Allocator,\n+}\n+\n+#[derive(Debug)]\n+pub struct CompiledModule {\n+    pub name: String,\n+    pub kind: ModuleKind,\n+    pub object: Option<PathBuf>,\n+    pub bytecode: Option<PathBuf>,\n+    pub bytecode_compressed: Option<PathBuf>,\n+}\n+\n+pub fn find_library(name: &str, search_paths: &[PathBuf], sess: &Session)\n+                    -> PathBuf {\n+    // On Windows, static libraries sometimes show up as libfoo.a and other\n+    // times show up as foo.lib\n+    let oslibname = format!(\"{}{}{}\",\n+                            sess.target.target.options.staticlib_prefix,\n+                            name,\n+                            sess.target.target.options.staticlib_suffix);\n+    let unixlibname = format!(\"lib{}.a\", name);\n+\n+    for path in search_paths {\n+        debug!(\"looking for {} inside {:?}\", name, path);\n+        let test = path.join(&oslibname);\n+        if test.exists() { return test }\n+        if oslibname != unixlibname {\n+            let test = path.join(&unixlibname);\n+            if test.exists() { return test }\n+        }\n+    }\n+    sess.fatal(&format!(\"could not find native static library `{}`, \\\n+                         perhaps an -L flag is missing?\", name));\n+}\n+\n __build_diagnostic_array! { librustc_codegen_utils, DIAGNOSTICS }"}, {"sha": "b11aa687326f2536b846d10f79270bf009ab8467", "filename": "src/librustc_codegen_utils/link.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_codegen_utils%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_codegen_utils%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flink.rs?ref=ac708826b0d97e105f91a4cde41bfe14cff032f2", "patch": "@@ -13,7 +13,6 @@ use rustc::session::Session;\n use std::path::{Path, PathBuf};\n use syntax::{ast, attr};\n use syntax_pos::Span;\n-use rustc_metadata_utils::validate_crate_name;\n \n pub fn out_filename(sess: &Session,\n                 crate_type: config::CrateType,\n@@ -52,7 +51,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n                        attrs: &[ast::Attribute],\n                        input: &Input) -> String {\n     let validate = |s: String, span: Option<Span>| {\n-        validate_crate_name(sess, &s, span);\n+        ::rustc_metadata::validate_crate_name(sess, &s, span);\n         s\n     };\n "}, {"sha": "c1f41fd509a143fbfa03769c5b315dc163353305", "filename": "src/librustc_codegen_utils/linker.rs", "status": "renamed", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_codegen_utils%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_codegen_utils%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flinker.rs?ref=ac708826b0d97e105f91a4cde41bfe14cff032f2", "patch": "@@ -15,9 +15,7 @@ use std::io::prelude::*;\n use std::io::{self, BufWriter};\n use std::path::{Path, PathBuf};\n \n-use back::archive;\n-use back::command::Command;\n-use back::symbol_export;\n+use command::Command;\n use rustc::hir::def_id::{LOCAL_CRATE, CrateNum};\n use rustc::middle::dependency_format::Linkage;\n use rustc::session::Session;\n@@ -26,7 +24,6 @@ use rustc::session::config::{self, CrateType, OptLevel, DebugInfo,\n use rustc::ty::TyCtxt;\n use rustc_target::spec::{LinkerFlavor, LldFlavor};\n use serialize::{json, Encoder};\n-use llvm_util;\n \n /// For all the linkers we support, and information they might\n /// need out of the shared crate context before we get rid of it.\n@@ -43,10 +40,13 @@ impl LinkerInfo {\n         }\n     }\n \n-    pub fn to_linker<'a>(&'a self,\n-                         cmd: Command,\n-                         sess: &'a Session,\n-                         flavor: LinkerFlavor) -> Box<dyn Linker+'a> {\n+    pub fn to_linker<'a>(\n+        &'a self,\n+        cmd: Command,\n+        sess: &'a Session,\n+        flavor: LinkerFlavor,\n+        target_cpu: &'a str,\n+    ) -> Box<dyn Linker+'a> {\n         match flavor {\n             LinkerFlavor::Lld(LldFlavor::Link) |\n             LinkerFlavor::Msvc => {\n@@ -70,6 +70,7 @@ impl LinkerInfo {\n                     info: self,\n                     hinted_static: false,\n                     is_ld: false,\n+                    target_cpu,\n                 }) as Box<dyn Linker>\n             }\n \n@@ -82,6 +83,7 @@ impl LinkerInfo {\n                     info: self,\n                     hinted_static: false,\n                     is_ld: true,\n+                    target_cpu,\n                 }) as Box<dyn Linker>\n             }\n \n@@ -144,6 +146,7 @@ pub struct GccLinker<'a> {\n     hinted_static: bool, // Keeps track of the current hinting mode.\n     // Link as ld\n     is_ld: bool,\n+    target_cpu: &'a str,\n }\n \n impl<'a> GccLinker<'a> {\n@@ -204,7 +207,8 @@ impl<'a> GccLinker<'a> {\n         };\n \n         self.linker_arg(&format!(\"-plugin-opt={}\", opt_level));\n-        self.linker_arg(&format!(\"-plugin-opt=mcpu={}\", llvm_util::target_cpu(self.sess)));\n+        let target_cpu = self.target_cpu;\n+        self.linker_arg(&format!(\"-plugin-opt=mcpu={}\", target_cpu));\n \n         match self.sess.lto() {\n             config::Lto::Thin |\n@@ -263,7 +267,7 @@ impl<'a> Linker for GccLinker<'a> {\n             // -force_load is the macOS equivalent of --whole-archive, but it\n             // involves passing the full path to the library to link.\n             self.linker_arg(\"-force_load\");\n-            let lib = archive::find_library(lib, search_path, &self.sess);\n+            let lib = ::find_library(lib, search_path, &self.sess);\n             self.linker_arg(&lib);\n         }\n     }\n@@ -898,7 +902,8 @@ impl<'a> Linker for EmLinker<'a> {\n fn exported_symbols(tcx: TyCtxt, crate_type: CrateType) -> Vec<String> {\n     let mut symbols = Vec::new();\n \n-    let export_threshold = symbol_export::crates_export_threshold(&[crate_type]);\n+    let export_threshold =\n+        ::symbol_export::crates_export_threshold(&[crate_type]);\n     for &(symbol, level) in tcx.exported_symbols(LOCAL_CRATE).iter() {\n         if level.is_below_threshold(export_threshold) {\n             symbols.push(symbol.symbol_name(tcx).to_string());", "previous_filename": "src/librustc_codegen_llvm/back/linker.rs"}, {"sha": "2d650f7f18d6f5654b7da9ceb4f353365b0a24be", "filename": "src/librustc_codegen_utils/symbol_export.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_codegen_utils%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_codegen_utils%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_export.rs?ref=ac708826b0d97e105f91a4cde41bfe14cff032f2", "patch": "@@ -11,7 +11,7 @@\n use rustc_data_structures::sync::Lrc;\n use std::sync::Arc;\n \n-use monomorphize::Instance;\n+use rustc::ty::Instance;\n use rustc::hir;\n use rustc::hir::Node;\n use rustc::hir::CodegenFnAttrFlags;", "previous_filename": "src/librustc_codegen_llvm/back/symbol_export.rs"}, {"sha": "338824d5efe4caa862256121941b11a7e38bdbce", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=ac708826b0d97e105f91a4cde41bfe14cff032f2", "patch": "@@ -20,4 +20,3 @@ serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_ext = { path = \"../libsyntax_ext\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n-rustc_metadata_utils = { path = \"../librustc_metadata_utils\" }"}, {"sha": "7733ab2e246d1135fa3fac808b73ce98c0375852", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=ac708826b0d97e105f91a4cde41bfe14cff032f2", "patch": "@@ -30,8 +30,6 @@ use rustc::util::common::record_time;\n use rustc::util::nodemap::FxHashSet;\n use rustc::hir::map::Definitions;\n \n-use rustc_metadata_utils::validate_crate_name;\n-\n use std::ops::Deref;\n use std::path::PathBuf;\n use std::{cmp, fs};\n@@ -1106,7 +1104,7 @@ impl<'a> CrateLoader<'a> {\n                        item.ident, orig_name);\n                 let orig_name = match orig_name {\n                     Some(orig_name) => {\n-                        validate_crate_name(Some(self.sess), &orig_name.as_str(),\n+                        ::validate_crate_name(Some(self.sess), &orig_name.as_str(),\n                                             Some(item.span));\n                         orig_name\n                     }"}, {"sha": "0cc0707a3a51f263bcdf0f5ca347ed71c41f56af", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=ac708826b0d97e105f91a4cde41bfe14cff032f2", "patch": "@@ -38,7 +38,6 @@ extern crate serialize as rustc_serialize; // used by deriving\n extern crate rustc_errors as errors;\n extern crate syntax_ext;\n extern crate proc_macro;\n-extern crate rustc_metadata_utils;\n \n #[macro_use]\n extern crate rustc;\n@@ -64,4 +63,34 @@ pub mod cstore;\n pub mod dynamic_lib;\n pub mod locator;\n \n+pub fn validate_crate_name(\n+    sess: Option<&rustc::session::Session>,\n+    s: &str,\n+    sp: Option<syntax_pos::Span>\n+) {\n+    let mut err_count = 0;\n+    {\n+        let mut say = |s: &str| {\n+            match (sp, sess) {\n+                (_, None) => bug!(\"{}\", s),\n+                (Some(sp), Some(sess)) => sess.span_err(sp, s),\n+                (None, Some(sess)) => sess.err(s),\n+            }\n+            err_count += 1;\n+        };\n+        if s.is_empty() {\n+            say(\"crate name must not be empty\");\n+        }\n+        for c in s.chars() {\n+            if c.is_alphanumeric() { continue }\n+            if c == '_'  { continue }\n+            say(&format!(\"invalid character `{}` in crate name: `{}`\", c, s));\n+        }\n+    }\n+\n+    if err_count > 0 {\n+        sess.unwrap().abort_if_errors();\n+    }\n+}\n+\n __build_diagnostic_array! { librustc_metadata, DIAGNOSTICS }"}, {"sha": "4a5e20376bfb546e23e52091395abd5135cb0409", "filename": "src/librustc_metadata_utils/Cargo.toml", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/86b88e6a85f4c532c58cdcdabf6050c6170628e0/src%2Flibrustc_metadata_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/86b88e6a85f4c532c58cdcdabf6050c6170628e0/src%2Flibrustc_metadata_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata_utils%2FCargo.toml?ref=86b88e6a85f4c532c58cdcdabf6050c6170628e0", "patch": "@@ -1,14 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"rustc_metadata_utils\"\n-version = \"0.0.0\"\n-\n-[lib]\n-name = \"rustc_metadata_utils\"\n-path = \"lib.rs\"\n-crate-type = [\"dylib\"]\n-\n-[dependencies]\n-rustc = { path = \"../librustc\" }\n-syntax = { path = \"../libsyntax\" }\n-syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "a1e5150390ac1bfd3c36dda01427fd9054947b9d", "filename": "src/librustc_metadata_utils/lib.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/86b88e6a85f4c532c58cdcdabf6050c6170628e0/src%2Flibrustc_metadata_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b88e6a85f4c532c58cdcdabf6050c6170628e0/src%2Flibrustc_metadata_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata_utils%2Flib.rs?ref=86b88e6a85f4c532c58cdcdabf6050c6170628e0", "patch": "@@ -1,42 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[macro_use]\n-extern crate rustc;\n-extern crate syntax_pos;\n-\n-use rustc::session::Session;\n-use syntax_pos::Span;\n-\n-pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n-    let mut err_count = 0;\n-    {\n-        let mut say = |s: &str| {\n-            match (sp, sess) {\n-                (_, None) => bug!(\"{}\", s),\n-                (Some(sp), Some(sess)) => sess.span_err(sp, s),\n-                (None, Some(sess)) => sess.err(s),\n-            }\n-            err_count += 1;\n-        };\n-        if s.is_empty() {\n-            say(\"crate name must not be empty\");\n-        }\n-        for c in s.chars() {\n-            if c.is_alphanumeric() { continue }\n-            if c == '_'  { continue }\n-            say(&format!(\"invalid character `{}` in crate name: `{}`\", c, s));\n-        }\n-    }\n-\n-    if err_count > 0 {\n-        sess.unwrap().abort_if_errors();\n-    }\n-}"}, {"sha": "1a35f4da20bf158a1fddab082043edcf30e28cc0", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=ac708826b0d97e105f91a4cde41bfe14cff032f2", "patch": "@@ -93,6 +93,7 @@ pub fn provide(providers: &mut Providers) {\n     borrow_check::provide(providers);\n     shim::provide(providers);\n     transform::provide(providers);\n+    monomorphize::partitioning::provide(providers);\n     providers.const_eval = const_eval::const_eval_provider;\n     providers.const_eval_raw = const_eval::const_eval_raw_provider;\n     providers.check_match = hair::pattern::check_match;"}, {"sha": "2c2bfc995e4d7556a9c7aecea2c9e9eae7979333", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 156, "deletions": 7, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac708826b0d97e105f91a4cde41bfe14cff032f2/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=ac708826b0d97e105f91a4cde41bfe14cff032f2", "patch": "@@ -102,21 +102,27 @@\n //! source-level module, functions from the same module will be available for\n //! inlining, even when they are not marked #[inline].\n \n-use monomorphize::collector::InliningMap;\n+use std::collections::hash_map::Entry;\n+use std::cmp;\n+use std::sync::Arc;\n+\n+use syntax::ast::NodeId;\n+use syntax::symbol::InternedString;\n use rustc::dep_graph::{WorkProductId, WorkProduct, DepNode, DepConstructor};\n use rustc::hir::CodegenFnAttrFlags;\n-use rustc::hir::def_id::{DefId, LOCAL_CRATE, CRATE_DEF_INDEX};\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE, CRATE_DEF_INDEX};\n use rustc::hir::map::DefPathData;\n use rustc::mir::mono::{Linkage, Visibility, CodegenUnitNameBuilder};\n use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::ty::{self, TyCtxt, InstanceDef};\n use rustc::ty::item_path::characteristic_def_id_of_type;\n-use rustc::util::nodemap::{FxHashMap, FxHashSet};\n-use std::collections::hash_map::Entry;\n-use std::cmp;\n-use syntax::ast::NodeId;\n-use syntax::symbol::InternedString;\n+use rustc::ty::query::Providers;\n+use rustc::util::common::time;\n+use rustc::util::nodemap::{DefIdSet, FxHashMap, FxHashSet};\n use rustc::mir::mono::MonoItem;\n+\n+use monomorphize::collector::InliningMap;\n+use monomorphize::collector::{self, MonoItemCollectionMode};\n use monomorphize::item::{MonoItemExt, InstantiationMode};\n \n pub use rustc::mir::mono::CodegenUnit;\n@@ -892,3 +898,146 @@ fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n }\n+\n+fn collect_and_partition_mono_items<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    cnum: CrateNum,\n+) -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>)\n+{\n+    assert_eq!(cnum, LOCAL_CRATE);\n+\n+    let collection_mode = match tcx.sess.opts.debugging_opts.print_mono_items {\n+        Some(ref s) => {\n+            let mode_string = s.to_lowercase();\n+            let mode_string = mode_string.trim();\n+            if mode_string == \"eager\" {\n+                MonoItemCollectionMode::Eager\n+            } else {\n+                if mode_string != \"lazy\" {\n+                    let message = format!(\"Unknown codegen-item collection mode '{}'. \\\n+                                           Falling back to 'lazy' mode.\",\n+                                          mode_string);\n+                    tcx.sess.warn(&message);\n+                }\n+\n+                MonoItemCollectionMode::Lazy\n+            }\n+        }\n+        None => {\n+            if tcx.sess.opts.cg.link_dead_code {\n+                MonoItemCollectionMode::Eager\n+            } else {\n+                MonoItemCollectionMode::Lazy\n+            }\n+        }\n+    };\n+\n+    let (items, inlining_map) =\n+        time(tcx.sess, \"monomorphization collection\", || {\n+            collector::collect_crate_mono_items(tcx, collection_mode)\n+    });\n+\n+    tcx.sess.abort_if_errors();\n+\n+    ::monomorphize::assert_symbols_are_distinct(tcx, items.iter());\n+\n+    let strategy = if tcx.sess.opts.incremental.is_some() {\n+        PartitioningStrategy::PerModule\n+    } else {\n+        PartitioningStrategy::FixedUnitCount(tcx.sess.codegen_units())\n+    };\n+\n+    let codegen_units = time(tcx.sess, \"codegen unit partitioning\", || {\n+        partition(\n+            tcx,\n+            items.iter().cloned(),\n+            strategy,\n+            &inlining_map\n+        )\n+            .into_iter()\n+            .map(Arc::new)\n+            .collect::<Vec<_>>()\n+    });\n+\n+    let mono_items: DefIdSet = items.iter().filter_map(|mono_item| {\n+        match *mono_item {\n+            MonoItem::Fn(ref instance) => Some(instance.def_id()),\n+            MonoItem::Static(def_id) => Some(def_id),\n+            _ => None,\n+        }\n+    }).collect();\n+\n+    if tcx.sess.opts.debugging_opts.print_mono_items.is_some() {\n+        let mut item_to_cgus: FxHashMap<_, Vec<_>> = Default::default();\n+\n+        for cgu in &codegen_units {\n+            for (&mono_item, &linkage) in cgu.items() {\n+                item_to_cgus.entry(mono_item)\n+                            .or_default()\n+                            .push((cgu.name().clone(), linkage));\n+            }\n+        }\n+\n+        let mut item_keys: Vec<_> = items\n+            .iter()\n+            .map(|i| {\n+                let mut output = i.to_string(tcx);\n+                output.push_str(\" @@\");\n+                let mut empty = Vec::new();\n+                let cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);\n+                cgus.as_mut_slice().sort_by_key(|&(ref name, _)| name.clone());\n+                cgus.dedup();\n+                for &(ref cgu_name, (linkage, _)) in cgus.iter() {\n+                    output.push_str(\" \");\n+                    output.push_str(&cgu_name.as_str());\n+\n+                    let linkage_abbrev = match linkage {\n+                        Linkage::External => \"External\",\n+                        Linkage::AvailableExternally => \"Available\",\n+                        Linkage::LinkOnceAny => \"OnceAny\",\n+                        Linkage::LinkOnceODR => \"OnceODR\",\n+                        Linkage::WeakAny => \"WeakAny\",\n+                        Linkage::WeakODR => \"WeakODR\",\n+                        Linkage::Appending => \"Appending\",\n+                        Linkage::Internal => \"Internal\",\n+                        Linkage::Private => \"Private\",\n+                        Linkage::ExternalWeak => \"ExternalWeak\",\n+                        Linkage::Common => \"Common\",\n+                    };\n+\n+                    output.push_str(\"[\");\n+                    output.push_str(linkage_abbrev);\n+                    output.push_str(\"]\");\n+                }\n+                output\n+            })\n+            .collect();\n+\n+        item_keys.sort();\n+\n+        for item in item_keys {\n+            println!(\"MONO_ITEM {}\", item);\n+        }\n+    }\n+\n+    (Arc::new(mono_items), Arc::new(codegen_units))\n+}\n+\n+pub fn provide(providers: &mut Providers) {\n+    providers.collect_and_partition_mono_items =\n+        collect_and_partition_mono_items;\n+\n+    providers.is_codegened_item = |tcx, def_id| {\n+        let (all_mono_items, _) =\n+            tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n+        all_mono_items.contains(&def_id)\n+    };\n+\n+    providers.codegen_unit = |tcx, name| {\n+        let (_, all) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n+        all.iter()\n+            .find(|cgu| *cgu.name() == name)\n+            .cloned()\n+            .unwrap_or_else(|| panic!(\"failed to find cgu with name {:?}\", name))\n+    };\n+}"}]}