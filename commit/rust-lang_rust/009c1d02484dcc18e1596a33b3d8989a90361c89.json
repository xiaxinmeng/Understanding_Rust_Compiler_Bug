{"sha": "009c1d02484dcc18e1596a33b3d8989a90361c89", "node_id": "C_kwDOAAsO6NoAKDAwOWMxZDAyNDg0ZGNjMThlMTU5NmEzM2IzZDg5ODlhOTAzNjFjODk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-26T22:54:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-26T22:54:26Z"}, "message": "Auto merge of #93352 - matthiaskrgr:rollup-5peret4, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #90247 (Improve Duration::try_from_secs_f32/64 accuracy by directly processing exponent and mantissa)\n - #91861 (Replace iterator-based construction of collections by `Into<T>`)\n - #92098 (add OpenBSD platform-support page)\n - #92134 (Add x86_64-pc-windows-msvc linker-plugin-lto instructions)\n - #92256 (Improve selection errors for `~const` trait bounds)\n - #92778 (fs: Use readdir() instead of readdir_r() on Linux and Android)\n - #93338 (Update minifier crate version to 0.0.42)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "43dda6b2560fe7efb4aaca1c11aa8c7481b586d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43dda6b2560fe7efb4aaca1c11aa8c7481b586d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/009c1d02484dcc18e1596a33b3d8989a90361c89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/009c1d02484dcc18e1596a33b3d8989a90361c89", "html_url": "https://github.com/rust-lang/rust/commit/009c1d02484dcc18e1596a33b3d8989a90361c89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/009c1d02484dcc18e1596a33b3d8989a90361c89/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6abb6385b2cb7249f67b9b3ce7522527767dd907", "url": "https://api.github.com/repos/rust-lang/rust/commits/6abb6385b2cb7249f67b9b3ce7522527767dd907", "html_url": "https://github.com/rust-lang/rust/commit/6abb6385b2cb7249f67b9b3ce7522527767dd907"}, {"sha": "4276626299fdf428d6e9834ca925b11919478047", "url": "https://api.github.com/repos/rust-lang/rust/commits/4276626299fdf428d6e9834ca925b11919478047", "html_url": "https://github.com/rust-lang/rust/commit/4276626299fdf428d6e9834ca925b11919478047"}], "stats": {"total": 1233, "additions": 829, "deletions": 404}, "files": [{"sha": "738f33d3fa219849304ec95eeec3fabf53bae3b4", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -2298,9 +2298,9 @@ dependencies = [\n \n [[package]]\n name = \"minifier\"\n-version = \"0.0.41\"\n+version = \"0.0.42\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5594542d20834f2b974f5e5fb8e0cf1c67a2119dcadc29ef5d93a081fb30cc08\"\n+checksum = \"55a1388517eda8a68875243b650c26997e055a33d82571b5a0349129faef7d99\"\n dependencies = [\n  \"macro-utils\",\n ]"}, {"sha": "1123cab807651b29a4024f5b86c31c3bb01697d1", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -402,7 +402,7 @@ impl ObligationCauseCode<'_> {\n \n // `ObligationCauseCode` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(ObligationCauseCode<'_>, 40);\n+static_assert_size!(ObligationCauseCode<'_>, 48);\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum StatementAsExpression {\n@@ -440,11 +440,11 @@ pub struct IfExpressionCause {\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub struct DerivedObligationCause<'tcx> {\n-    /// The trait reference of the parent obligation that led to the\n+    /// The trait predicate of the parent obligation that led to the\n     /// current obligation. Note that only trait obligations lead to\n-    /// derived obligations, so we just store the trait reference here\n+    /// derived obligations, so we just store the trait predicate here\n     /// directly.\n-    pub parent_trait_ref: ty::PolyTraitRef<'tcx>,\n+    pub parent_trait_pred: ty::PolyTraitPredicate<'tcx>,\n \n     /// The parent trait had this cause.\n     pub parent_code: Lrc<ObligationCauseCode<'tcx>>,"}, {"sha": "6174c922e2d063df5e3fbef6c88ed5b504037310", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -766,6 +766,17 @@ impl<'tcx> TraitPredicate<'tcx> {\n             *param_env = param_env.with_constness(self.constness.and(param_env.constness()))\n         }\n     }\n+\n+    /// Remap the constness of this predicate before emitting it for diagnostics.\n+    pub fn remap_constness_diag(&mut self, param_env: ParamEnv<'tcx>) {\n+        // this is different to `remap_constness` that callees want to print this predicate\n+        // in case of selection errors. `T: ~const Drop` bounds cannot end up here when the\n+        // param_env is not const because we it is always satisfied in non-const contexts.\n+        if let hir::Constness::NotConst = param_env.constness() {\n+            self.constness = ty::BoundConstness::NotConst;\n+        }\n+    }\n+\n     pub fn def_id(self) -> DefId {\n         self.trait_ref.def_id\n     }\n@@ -784,6 +795,14 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n     pub fn self_ty(self) -> ty::Binder<'tcx, Ty<'tcx>> {\n         self.map_bound(|trait_ref| trait_ref.self_ty())\n     }\n+\n+    /// Remap the constness of this predicate before emitting it for diagnostics.\n+    pub fn remap_constness_diag(&mut self, param_env: ParamEnv<'tcx>) {\n+        *self = self.map_bound(|mut p| {\n+            p.remap_constness_diag(param_env);\n+            p\n+        });\n+    }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]"}, {"sha": "ddcc8680d835269bd4f34257bccb79f01db361c6", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -2413,6 +2413,29 @@ impl<'tcx> ty::Binder<'tcx, ty::TraitRef<'tcx>> {\n     }\n }\n \n+#[derive(Copy, Clone, TypeFoldable, Lift)]\n+pub struct TraitPredPrintModifiersAndPath<'tcx>(ty::TraitPredicate<'tcx>);\n+\n+impl<'tcx> fmt::Debug for TraitPredPrintModifiersAndPath<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl<'tcx> ty::TraitPredicate<'tcx> {\n+    pub fn print_modifiers_and_trait_path(self) -> TraitPredPrintModifiersAndPath<'tcx> {\n+        TraitPredPrintModifiersAndPath(self)\n+    }\n+}\n+\n+impl<'tcx> ty::PolyTraitPredicate<'tcx> {\n+    pub fn print_modifiers_and_trait_path(\n+        self,\n+    ) -> ty::Binder<'tcx, TraitPredPrintModifiersAndPath<'tcx>> {\n+        self.map_bound(TraitPredPrintModifiersAndPath)\n+    }\n+}\n+\n forward_display_to_print! {\n     Ty<'tcx>,\n     &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n@@ -2427,6 +2450,7 @@ forward_display_to_print! {\n     ty::Binder<'tcx, TraitRefPrintOnlyTraitName<'tcx>>,\n     ty::Binder<'tcx, ty::FnSig<'tcx>>,\n     ty::Binder<'tcx, ty::TraitPredicate<'tcx>>,\n+    ty::Binder<'tcx, TraitPredPrintModifiersAndPath<'tcx>>,\n     ty::Binder<'tcx, ty::SubtypePredicate<'tcx>>,\n     ty::Binder<'tcx, ty::ProjectionPredicate<'tcx>>,\n     ty::Binder<'tcx, ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>,\n@@ -2491,6 +2515,18 @@ define_print_and_forward_display! {\n         p!(print_def_path(self.0.def_id, &[]));\n     }\n \n+    TraitPredPrintModifiersAndPath<'tcx> {\n+        if let ty::BoundConstness::ConstIfConst = self.0.constness {\n+            p!(\"~const \")\n+        }\n+\n+        if let ty::ImplPolarity::Negative = self.0.polarity {\n+            p!(\"!\")\n+        }\n+\n+        p!(print(self.0.trait_ref.print_only_trait_path()));\n+    }\n+\n     ty::ParamTy {\n         p!(write(\"{}\", self.name))\n     }\n@@ -2508,8 +2544,11 @@ define_print_and_forward_display! {\n     }\n \n     ty::TraitPredicate<'tcx> {\n-        p!(print(self.trait_ref.self_ty()), \": \",\n-           print(self.trait_ref.print_only_trait_path()))\n+        p!(print(self.trait_ref.self_ty()), \": \");\n+        if let ty::BoundConstness::ConstIfConst = self.constness {\n+            p!(\"~const \");\n+        }\n+        p!(print(self.trait_ref.print_only_trait_path()))\n     }\n \n     ty::ProjectionPredicate<'tcx> {"}, {"sha": "d99bdd3bdd5be8242b70211d2242edbe49347ca3", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -321,6 +321,7 @@ symbols! {\n         and,\n         and_then,\n         any,\n+        append_const_msg,\n         arbitrary_enum_discriminant,\n         arbitrary_self_types,\n         arith_offset,"}, {"sha": "37cf41a0ec2e28066a402a8bd9fd2897266723e0", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 68, "deletions": 31, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -205,6 +205,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         self.note_obligation_cause_code(\n             &mut err,\n             &obligation.predicate,\n+            obligation.param_env,\n             obligation.cause.code(),\n             &mut vec![],\n             &mut Default::default(),\n@@ -288,7 +289,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 match bound_predicate.skip_binder() {\n                     ty::PredicateKind::Trait(trait_predicate) => {\n                         let trait_predicate = bound_predicate.rebind(trait_predicate);\n-                        let trait_predicate = self.resolve_vars_if_possible(trait_predicate);\n+                        let mut trait_predicate = self.resolve_vars_if_possible(trait_predicate);\n+\n+                        trait_predicate.remap_constness_diag(obligation.param_env);\n+                        let predicate_is_const = ty::BoundConstness::ConstIfConst\n+                            == trait_predicate.skip_binder().constness;\n \n                         if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n                             return;\n@@ -305,13 +310,18 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             })\n                             .unwrap_or_default();\n \n-                        let OnUnimplementedNote { message, label, note, enclosing_scope } =\n-                            self.on_unimplemented_note(trait_ref, &obligation);\n+                        let OnUnimplementedNote {\n+                            message,\n+                            label,\n+                            note,\n+                            enclosing_scope,\n+                            append_const_msg,\n+                        } = self.on_unimplemented_note(trait_ref, &obligation);\n                         let have_alt_message = message.is_some() || label.is_some();\n                         let is_try_conversion = self.is_try_conversion(span, trait_ref.def_id());\n                         let is_unsize =\n                             { Some(trait_ref.def_id()) == self.tcx.lang_items().unsize_trait() };\n-                        let (message, note) = if is_try_conversion {\n+                        let (message, note, append_const_msg) = if is_try_conversion {\n                             (\n                                 Some(format!(\n                                     \"`?` couldn't convert the error to `{}`\",\n@@ -322,21 +332,38 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                         conversion on the error value using the `From` trait\"\n                                         .to_owned(),\n                                 ),\n+                                Some(None),\n                             )\n                         } else {\n-                            (message, note)\n+                            (message, note, append_const_msg)\n                         };\n \n                         let mut err = struct_span_err!(\n                             self.tcx.sess,\n                             span,\n                             E0277,\n                             \"{}\",\n-                            message.unwrap_or_else(|| format!(\n-                                \"the trait bound `{}` is not satisfied{}\",\n-                                trait_ref.without_const().to_predicate(tcx),\n-                                post_message,\n-                            ))\n+                            message\n+                                .and_then(|cannot_do_this| {\n+                                    match (predicate_is_const, append_const_msg) {\n+                                        // do nothing if predicate is not const\n+                                        (false, _) => Some(cannot_do_this),\n+                                        // suggested using default post message\n+                                        (true, Some(None)) => {\n+                                            Some(format!(\"{cannot_do_this} in const contexts\"))\n+                                        }\n+                                        // overriden post message\n+                                        (true, Some(Some(post_message))) => {\n+                                            Some(format!(\"{cannot_do_this}{post_message}\"))\n+                                        }\n+                                        // fallback to generic message\n+                                        (true, None) => None,\n+                                    }\n+                                })\n+                                .unwrap_or_else(|| format!(\n+                                    \"the trait bound `{}` is not satisfied{}\",\n+                                    trait_predicate, post_message,\n+                                ))\n                         );\n \n                         if is_try_conversion {\n@@ -384,15 +411,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             format!(\n                                 \"{}the trait `{}` is not implemented for `{}`\",\n                                 pre_message,\n-                                trait_ref.print_only_trait_path(),\n+                                trait_predicate.print_modifiers_and_trait_path(),\n                                 trait_ref.skip_binder().self_ty(),\n                             )\n                         };\n \n                         if self.suggest_add_reference_to_arg(\n                             &obligation,\n                             &mut err,\n-                            &trait_ref,\n+                            trait_predicate,\n                             have_alt_message,\n                         ) {\n                             self.note_obligation_cause(&mut err, &obligation);\n@@ -435,18 +462,28 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             err.span_label(enclosing_scope_span, s.as_str());\n                         }\n \n-                        self.suggest_dereferences(&obligation, &mut err, trait_ref);\n-                        self.suggest_fn_call(&obligation, &mut err, trait_ref);\n-                        self.suggest_remove_reference(&obligation, &mut err, trait_ref);\n-                        self.suggest_semicolon_removal(&obligation, &mut err, span, trait_ref);\n+                        self.suggest_dereferences(&obligation, &mut err, trait_predicate);\n+                        self.suggest_fn_call(&obligation, &mut err, trait_predicate);\n+                        self.suggest_remove_reference(&obligation, &mut err, trait_predicate);\n+                        self.suggest_semicolon_removal(\n+                            &obligation,\n+                            &mut err,\n+                            span,\n+                            trait_predicate,\n+                        );\n                         self.note_version_mismatch(&mut err, &trait_ref);\n                         self.suggest_remove_await(&obligation, &mut err);\n \n                         if Some(trait_ref.def_id()) == tcx.lang_items().try_trait() {\n-                            self.suggest_await_before_try(&mut err, &obligation, trait_ref, span);\n+                            self.suggest_await_before_try(\n+                                &mut err,\n+                                &obligation,\n+                                trait_predicate,\n+                                span,\n+                            );\n                         }\n \n-                        if self.suggest_impl_trait(&mut err, span, &obligation, trait_ref) {\n+                        if self.suggest_impl_trait(&mut err, span, &obligation, trait_predicate) {\n                             err.emit();\n                             return;\n                         }\n@@ -494,7 +531,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             // which is somewhat confusing.\n                             self.suggest_restricting_param_bound(\n                                 &mut err,\n-                                trait_ref,\n+                                trait_predicate,\n                                 obligation.cause.body_id,\n                             );\n                         } else if !have_alt_message {\n@@ -506,7 +543,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         // Changing mutability doesn't make a difference to whether we have\n                         // an `Unsize` impl (Fixes ICE in #71036)\n                         if !is_unsize {\n-                            self.suggest_change_mut(&obligation, &mut err, trait_ref);\n+                            self.suggest_change_mut(&obligation, &mut err, trait_predicate);\n                         }\n \n                         // If this error is due to `!: Trait` not implemented but `(): Trait` is\n@@ -1121,7 +1158,7 @@ trait InferCtxtPrivExt<'hir, 'tcx> {\n     fn mk_trait_obligation_with_new_self_ty(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n+        trait_ref: ty::PolyTraitPredicate<'tcx>,\n         new_self_ty: Ty<'tcx>,\n     ) -> PredicateObligation<'tcx>;\n \n@@ -1541,7 +1578,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n     ) -> Option<(String, Option<Span>)> {\n         match code {\n             ObligationCauseCode::BuiltinDerivedObligation(data) => {\n-                let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_ref);\n+                let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_pred);\n                 match self.get_parent_trait_ref(&data.parent_code) {\n                     Some(t) => Some(t),\n                     None => {\n@@ -1594,21 +1631,20 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n     fn mk_trait_obligation_with_new_self_ty(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n+        trait_ref: ty::PolyTraitPredicate<'tcx>,\n         new_self_ty: Ty<'tcx>,\n     ) -> PredicateObligation<'tcx> {\n         assert!(!new_self_ty.has_escaping_bound_vars());\n \n-        let trait_ref = trait_ref.map_bound_ref(|tr| ty::TraitRef {\n-            substs: self.tcx.mk_substs_trait(new_self_ty, &tr.substs[1..]),\n+        let trait_pred = trait_ref.map_bound_ref(|tr| ty::TraitPredicate {\n+            trait_ref: ty::TraitRef {\n+                substs: self.tcx.mk_substs_trait(new_self_ty, &tr.trait_ref.substs[1..]),\n+                ..tr.trait_ref\n+            },\n             ..*tr\n         });\n \n-        Obligation::new(\n-            ObligationCause::dummy(),\n-            param_env,\n-            trait_ref.without_const().to_predicate(self.tcx),\n-        )\n+        Obligation::new(ObligationCause::dummy(), param_env, trait_pred.to_predicate(self.tcx))\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n@@ -2009,6 +2045,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n             self.note_obligation_cause_code(\n                 err,\n                 &obligation.predicate,\n+                obligation.param_env,\n                 obligation.cause.code(),\n                 &mut vec![],\n                 &mut Default::default(),\n@@ -2156,7 +2193,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n         cause_code: &ObligationCauseCode<'tcx>,\n     ) -> bool {\n         if let ObligationCauseCode::BuiltinDerivedObligation(ref data) = cause_code {\n-            let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_ref);\n+            let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_pred);\n             let self_ty = parent_trait_ref.skip_binder().self_ty();\n             if obligated_types.iter().any(|ot| ot == &self_ty) {\n                 return true;"}, {"sha": "8c0dbe9b064eab0794a8679259754dd46d4983ec", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 116, "deletions": 110, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -48,15 +48,15 @@ pub trait InferCtxtExt<'tcx> {\n     fn suggest_restricting_param_bound(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n         body_id: hir::HirId,\n     );\n \n     fn suggest_dereferences(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'tcx>,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     );\n \n     fn get_closure_name(\n@@ -70,22 +70,22 @@ pub trait InferCtxtExt<'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     );\n \n     fn suggest_add_reference_to_arg(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: &ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n         has_custom_message: bool,\n     ) -> bool;\n \n     fn suggest_remove_reference(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     );\n \n     fn suggest_remove_await(\n@@ -98,15 +98,15 @@ pub trait InferCtxtExt<'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     );\n \n     fn suggest_semicolon_removal(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     );\n \n     fn return_type_span(&self, obligation: &PredicateObligation<'tcx>) -> Option<Span>;\n@@ -116,7 +116,7 @@ pub trait InferCtxtExt<'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         obligation: &PredicateObligation<'tcx>,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool;\n \n     fn point_at_returns_when_relevant(\n@@ -154,7 +154,7 @@ pub trait InferCtxtExt<'tcx> {\n         interior_extra_info: Option<(Option<Span>, Span, Option<hir::HirId>, Option<Span>)>,\n         inner_generator_body: Option<&hir::Body<'tcx>>,\n         outer_generator: Option<DefId>,\n-        trait_ref: ty::TraitRef<'tcx>,\n+        trait_pred: ty::TraitPredicate<'tcx>,\n         target_ty: Ty<'tcx>,\n         typeck_results: Option<&ty::TypeckResults<'tcx>>,\n         obligation: &PredicateObligation<'tcx>,\n@@ -165,6 +165,7 @@ pub trait InferCtxtExt<'tcx> {\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         predicate: &T,\n+        param_env: ty::ParamEnv<'tcx>,\n         cause_code: &ObligationCauseCode<'tcx>,\n         obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n         seen_requirements: &mut FxHashSet<DefId>,\n@@ -178,7 +179,7 @@ pub trait InferCtxtExt<'tcx> {\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         obligation: &PredicateObligation<'tcx>,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n         span: Span,\n     );\n }\n@@ -204,7 +205,7 @@ fn suggest_restriction<'tcx>(\n     err: &mut DiagnosticBuilder<'_>,\n     fn_sig: Option<&hir::FnSig<'_>>,\n     projection: Option<&ty::ProjectionTy<'_>>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n+    trait_pred: ty::PolyTraitPredicate<'tcx>,\n     super_traits: Option<(&Ident, &hir::GenericBounds<'_>)>,\n ) {\n     // When we are dealing with a trait, `super_traits` will be `Some`:\n@@ -257,9 +258,9 @@ fn suggest_restriction<'tcx>(\n         // The type param `T: Trait` we will suggest to introduce.\n         let type_param = format!(\"{}: {}\", type_param_name, bound_str);\n \n-        // FIXME: modify the `trait_ref` instead of string shenanigans.\n+        // FIXME: modify the `trait_pred` instead of string shenanigans.\n         // Turn `<impl Trait as Foo>::Bar: Qux` into `<T as Foo>::Bar: Qux`.\n-        let pred = trait_ref.without_const().to_predicate(tcx).to_string();\n+        let pred = trait_pred.to_predicate(tcx).to_string();\n         let pred = pred.replace(&impl_trait_str, &type_param_name);\n         let mut sugg = vec![\n             // Find the last of the generic parameters contained within the span of\n@@ -301,19 +302,19 @@ fn suggest_restriction<'tcx>(\n                 .find(|p| !matches!(p.kind, hir::GenericParamKind::Type { synthetic: true, .. })),\n             super_traits,\n         ) {\n-            (_, None) => predicate_constraint(\n-                generics,\n-                trait_ref.without_const().to_predicate(tcx).to_string(),\n+            (_, None) => predicate_constraint(generics, trait_pred.to_predicate(tcx).to_string()),\n+            (None, Some((ident, []))) => (\n+                ident.span.shrink_to_hi(),\n+                format!(\": {}\", trait_pred.print_modifiers_and_trait_path()),\n+            ),\n+            (_, Some((_, [.., bounds]))) => (\n+                bounds.span().shrink_to_hi(),\n+                format!(\" + {}\", trait_pred.print_modifiers_and_trait_path()),\n+            ),\n+            (Some(_), Some((_, []))) => (\n+                generics.span.shrink_to_hi(),\n+                format!(\": {}\", trait_pred.print_modifiers_and_trait_path()),\n             ),\n-            (None, Some((ident, []))) => {\n-                (ident.span.shrink_to_hi(), format!(\": {}\", trait_ref.print_only_trait_path()))\n-            }\n-            (_, Some((_, [.., bounds]))) => {\n-                (bounds.span().shrink_to_hi(), format!(\" + {}\", trait_ref.print_only_trait_path()))\n-            }\n-            (Some(_), Some((_, []))) => {\n-                (generics.span.shrink_to_hi(), format!(\": {}\", trait_ref.print_only_trait_path()))\n-            }\n         };\n \n         err.span_suggestion_verbose(\n@@ -329,10 +330,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_restricting_param_bound(\n         &self,\n         mut err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n         body_id: hir::HirId,\n     ) {\n-        let self_ty = trait_ref.skip_binder().self_ty();\n+        let self_ty = trait_pred.skip_binder().self_ty();\n         let (param_ty, projection) = match self_ty.kind() {\n             ty::Param(_) => (true, None),\n             ty::Projection(projection) => (false, Some(projection)),\n@@ -358,7 +359,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         err,\n                         None,\n                         projection,\n-                        trait_ref,\n+                        trait_pred,\n                         Some((ident, bounds)),\n                     );\n                     return;\n@@ -372,7 +373,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     assert!(param_ty);\n                     // Restricting `Self` for a single method.\n                     suggest_restriction(\n-                        self.tcx, &generics, \"`Self`\", err, None, projection, trait_ref, None,\n+                        self.tcx, &generics, \"`Self`\", err, None, projection, trait_pred, None,\n                     );\n                     return;\n                 }\n@@ -398,7 +399,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         err,\n                         Some(fn_sig),\n                         projection,\n-                        trait_ref,\n+                        trait_pred,\n                         None,\n                     );\n                     return;\n@@ -417,7 +418,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         err,\n                         None,\n                         projection,\n-                        trait_ref,\n+                        trait_pred,\n                         None,\n                     );\n                     return;\n@@ -442,15 +443,16 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 {\n                     // Missing generic type parameter bound.\n                     let param_name = self_ty.to_string();\n-                    let constraint =\n-                        with_no_trimmed_paths(|| trait_ref.print_only_trait_path().to_string());\n+                    let constraint = with_no_trimmed_paths(|| {\n+                        trait_pred.print_modifiers_and_trait_path().to_string()\n+                    });\n                     if suggest_constraining_type_param(\n                         self.tcx,\n                         generics,\n                         &mut err,\n                         &param_name,\n                         &constraint,\n-                        Some(trait_ref.def_id()),\n+                        Some(trait_pred.def_id()),\n                     ) {\n                         return;\n                     }\n@@ -471,7 +473,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 }) if !param_ty => {\n                     // Missing generic type parameter bound.\n                     let param_name = self_ty.to_string();\n-                    let constraint = trait_ref.print_only_trait_path().to_string();\n+                    let constraint = trait_pred.print_modifiers_and_trait_path().to_string();\n                     if suggest_arbitrary_trait_bound(generics, &mut err, &param_name, &constraint) {\n                         return;\n                     }\n@@ -492,7 +494,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'tcx>,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) {\n         // It only make sense when suggesting dereferences for arguments\n         let code = if let ObligationCauseCode::FunctionArgumentObligation { parent_code, .. } =\n@@ -505,13 +507,13 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let param_env = obligation.param_env;\n         let body_id = obligation.cause.body_id;\n         let span = obligation.cause.span;\n-        let real_trait_ref = match &*code {\n+        let real_trait_pred = match &*code {\n             ObligationCauseCode::ImplDerivedObligation(cause)\n             | ObligationCauseCode::DerivedObligation(cause)\n-            | ObligationCauseCode::BuiltinDerivedObligation(cause) => cause.parent_trait_ref,\n-            _ => trait_ref,\n+            | ObligationCauseCode::BuiltinDerivedObligation(cause) => cause.parent_trait_pred,\n+            _ => trait_pred,\n         };\n-        let real_ty = match real_trait_ref.self_ty().no_bound_vars() {\n+        let real_ty = match real_trait_pred.self_ty().no_bound_vars() {\n             Some(ty) => ty,\n             None => return,\n         };\n@@ -522,7 +524,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 // Re-add the `&`\n                 let ty = self.tcx.mk_ref(region, TypeAndMut { ty, mutbl });\n                 let obligation =\n-                    self.mk_trait_obligation_with_new_self_ty(param_env, real_trait_ref, ty);\n+                    self.mk_trait_obligation_with_new_self_ty(param_env, real_trait_pred, ty);\n                 Some(steps).filter(|_| self.predicate_may_hold(&obligation))\n             }) {\n                 if steps > 0 {\n@@ -589,9 +591,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) {\n-        let self_ty = match trait_ref.self_ty().no_bound_vars() {\n+        let self_ty = match trait_pred.self_ty().no_bound_vars() {\n             None => return,\n             Some(ty) => ty,\n         };\n@@ -611,7 +613,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         };\n \n         let new_obligation =\n-            self.mk_trait_obligation_with_new_self_ty(obligation.param_env, trait_ref, output_ty);\n+            self.mk_trait_obligation_with_new_self_ty(obligation.param_env, trait_pred, output_ty);\n \n         match self.evaluate_obligation(&new_obligation) {\n             Ok(\n@@ -682,7 +684,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        poly_trait_ref: &ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        poly_trait_pred: ty::PolyTraitPredicate<'tcx>,\n         has_custom_message: bool,\n     ) -> bool {\n         let span = obligation.cause.span;\n@@ -715,24 +717,18 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let param_env = obligation.param_env;\n \n         // Try to apply the original trait binding obligation by borrowing.\n-        let mut try_borrowing = |old_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        let mut try_borrowing = |old_pred: ty::PolyTraitPredicate<'tcx>,\n                                  blacklist: &[DefId]|\n          -> bool {\n-            if blacklist.contains(&old_ref.def_id()) {\n+            if blacklist.contains(&old_pred.def_id()) {\n                 return false;\n             }\n \n-            let orig_ty = old_ref.self_ty().skip_binder();\n+            let orig_ty = old_pred.self_ty().skip_binder();\n             let mk_result = |new_ty| {\n-                let new_ref = old_ref.rebind(ty::TraitRef::new(\n-                    old_ref.def_id(),\n-                    self.tcx.mk_substs_trait(new_ty, &old_ref.skip_binder().substs[1..]),\n-                ));\n-                self.predicate_must_hold_modulo_regions(&Obligation::new(\n-                    ObligationCause::dummy(),\n-                    param_env,\n-                    new_ref.without_const().to_predicate(self.tcx),\n-                ))\n+                let obligation =\n+                    self.mk_trait_obligation_with_new_self_ty(param_env, old_pred, new_ty);\n+                self.predicate_must_hold_modulo_regions(&obligation)\n             };\n             let imm_result = mk_result(self.tcx.mk_imm_ref(self.tcx.lifetimes.re_static, orig_ty));\n             let mut_result = mk_result(self.tcx.mk_mut_ref(self.tcx.lifetimes.re_static, orig_ty));\n@@ -748,7 +744,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     let msg = format!(\n                         \"the trait bound `{}: {}` is not satisfied\",\n                         orig_ty,\n-                        old_ref.print_only_trait_path(),\n+                        old_pred.print_modifiers_and_trait_path(),\n                     );\n                     if has_custom_message {\n                         err.note(&msg);\n@@ -764,7 +760,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         span,\n                         &format!(\n                             \"expected an implementor of trait `{}`\",\n-                            old_ref.print_only_trait_path(),\n+                            old_pred.print_modifiers_and_trait_path(),\n                         ),\n                     );\n \n@@ -806,11 +802,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         };\n \n         if let ObligationCauseCode::ImplDerivedObligation(obligation) = code {\n-            try_borrowing(obligation.parent_trait_ref, &[])\n+            try_borrowing(obligation.parent_trait_pred, &[])\n         } else if let ObligationCauseCode::BindingObligation(_, _)\n         | ObligationCauseCode::ItemObligation(_) = code\n         {\n-            try_borrowing(*poly_trait_ref, &never_suggest_borrow)\n+            try_borrowing(poly_trait_pred, &never_suggest_borrow)\n         } else {\n             false\n         }\n@@ -822,7 +818,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) {\n         let span = obligation.cause.span;\n \n@@ -834,7 +830,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 return;\n             }\n \n-            let mut suggested_ty = match trait_ref.self_ty().no_bound_vars() {\n+            let mut suggested_ty = match trait_pred.self_ty().no_bound_vars() {\n                 Some(ty) => ty,\n                 None => return,\n             };\n@@ -847,7 +843,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n                 let new_obligation = self.mk_trait_obligation_with_new_self_ty(\n                     obligation.param_env,\n-                    trait_ref,\n+                    trait_pred,\n                     suggested_ty,\n                 );\n \n@@ -941,7 +937,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) {\n         let points_at_arg = matches!(\n             obligation.cause.code(),\n@@ -956,14 +952,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 // Do not suggest removal of borrow from type arguments.\n                 return;\n             }\n-            let trait_ref = self.resolve_vars_if_possible(trait_ref);\n-            if trait_ref.has_infer_types_or_consts() {\n+            let trait_pred = self.resolve_vars_if_possible(trait_pred);\n+            if trait_pred.has_infer_types_or_consts() {\n                 // Do not ICE while trying to find if a reborrow would succeed on a trait with\n                 // unresolved bindings.\n                 return;\n             }\n \n-            if let ty::Ref(region, t_type, mutability) = *trait_ref.skip_binder().self_ty().kind() {\n+            if let ty::Ref(region, t_type, mutability) = *trait_pred.skip_binder().self_ty().kind()\n+            {\n                 if region.is_late_bound() || t_type.has_escaping_bound_vars() {\n                     // Avoid debug assertion in `mk_obligation_for_def_id`.\n                     //\n@@ -980,7 +977,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n                 let new_obligation = self.mk_trait_obligation_with_new_self_ty(\n                     obligation.param_env,\n-                    trait_ref,\n+                    trait_pred,\n                     suggested_ty,\n                 );\n                 let suggested_ty_would_satisfy_obligation = self\n@@ -1002,9 +999,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     } else {\n                         err.note(&format!(\n                             \"`{}` is implemented for `{:?}`, but not for `{:?}`\",\n-                            trait_ref.print_only_trait_path(),\n+                            trait_pred.print_modifiers_and_trait_path(),\n                             suggested_ty,\n-                            trait_ref.skip_binder().self_ty(),\n+                            trait_pred.skip_binder().self_ty(),\n                         ));\n                     }\n                 }\n@@ -1017,7 +1014,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) {\n         let is_empty_tuple =\n             |ty: ty::Binder<'tcx, Ty<'_>>| *ty.skip_binder().kind() == ty::Tuple(ty::List::empty());\n@@ -1033,7 +1030,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             if let hir::ExprKind::Block(blk, _) = &body.value.kind {\n                 if sig.decl.output.span().overlaps(span)\n                     && blk.expr.is_none()\n-                    && is_empty_tuple(trait_ref.self_ty())\n+                    && is_empty_tuple(trait_pred.self_ty())\n                 {\n                     // FIXME(estebank): When encountering a method with a trait\n                     // bound not satisfied in the return type with a body that has\n@@ -1069,7 +1066,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         obligation: &PredicateObligation<'tcx>,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool {\n         match obligation.cause.code().peel_derives() {\n             // Only suggest `impl Trait` if the return type is unsized because it is `dyn Trait`.\n@@ -1088,8 +1085,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             return false;\n         };\n         let body = hir.body(*body_id);\n-        let trait_ref = self.resolve_vars_if_possible(trait_ref);\n-        let ty = trait_ref.skip_binder().self_ty();\n+        let trait_pred = self.resolve_vars_if_possible(trait_pred);\n+        let ty = trait_pred.skip_binder().self_ty();\n         let is_object_safe = match ty.kind() {\n             ty::Dynamic(predicates, _) => {\n                 // If the `dyn Trait` is not object safe, do not suggest `Box<dyn Trait>`.\n@@ -1326,9 +1323,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             trait_ref.rebind(sig).to_string()\n         }\n \n-        let argument_kind = match expected_ref.skip_binder().substs.type_at(0) {\n-            t if t.is_closure() => \"closure\",\n-            t if t.is_generator() => \"generator\",\n+        let argument_kind = match expected_ref.skip_binder().self_ty().kind() {\n+            ty::Closure(..) => \"closure\",\n+            ty::Generator(..) => \"generator\",\n             _ => \"function\",\n         };\n         let mut err = struct_span_err!(\n@@ -1455,7 +1452,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // bound was introduced. At least one generator should be present for this diagnostic to be\n         // modified.\n         let (mut trait_ref, mut target_ty) = match obligation.predicate.kind().skip_binder() {\n-            ty::PredicateKind::Trait(p) => (Some(p.trait_ref), Some(p.self_ty())),\n+            ty::PredicateKind::Trait(p) => (Some(p), Some(p.self_ty())),\n             _ => (None, None),\n         };\n         let mut generator = None;\n@@ -1473,11 +1470,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 ObligationCauseCode::DerivedObligation(derived_obligation)\n                 | ObligationCauseCode::BuiltinDerivedObligation(derived_obligation)\n                 | ObligationCauseCode::ImplDerivedObligation(derived_obligation) => {\n-                    let ty = derived_obligation.parent_trait_ref.skip_binder().self_ty();\n+                    let ty = derived_obligation.parent_trait_pred.skip_binder().self_ty();\n                     debug!(\n                         \"maybe_note_obligation_cause_for_async_await: \\\n                             parent_trait_ref={:?} self_ty.kind={:?}\",\n-                        derived_obligation.parent_trait_ref,\n+                        derived_obligation.parent_trait_pred,\n                         ty.kind()\n                     );\n \n@@ -1495,7 +1492,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             seen_upvar_tys_infer_tuple = true;\n                         }\n                         _ if generator.is_none() => {\n-                            trait_ref = Some(derived_obligation.parent_trait_ref.skip_binder());\n+                            trait_ref = Some(derived_obligation.parent_trait_pred.skip_binder());\n                             target_ty = Some(ty);\n                         }\n                         _ => {}\n@@ -1651,7 +1648,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         interior_extra_info: Option<(Option<Span>, Span, Option<hir::HirId>, Option<Span>)>,\n         inner_generator_body: Option<&hir::Body<'tcx>>,\n         outer_generator: Option<DefId>,\n-        trait_ref: ty::TraitRef<'tcx>,\n+        trait_pred: ty::TraitPredicate<'tcx>,\n         target_ty: Ty<'tcx>,\n         typeck_results: Option<&ty::TypeckResults<'tcx>>,\n         obligation: &PredicateObligation<'tcx>,\n@@ -1671,7 +1668,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // not implemented.\n         let hir = self.tcx.hir();\n         let trait_explanation = if let Some(name @ (sym::Send | sym::Sync)) =\n-            self.tcx.get_diagnostic_name(trait_ref.def_id)\n+            self.tcx.get_diagnostic_name(trait_pred.def_id())\n         {\n             let (trait_name, trait_verb) =\n                 if name == sym::Send { (\"`Send`\", \"sent\") } else { (\"`Sync`\", \"shared\") };\n@@ -1713,7 +1710,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n             format!(\"is not {}\", trait_name)\n         } else {\n-            format!(\"does not implement `{}`\", trait_ref.print_only_trait_path())\n+            format!(\"does not implement `{}`\", trait_pred.print_modifiers_and_trait_path())\n         };\n \n         let mut explain_yield = |interior_span: Span,\n@@ -1894,6 +1891,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         self.note_obligation_cause_code(\n             err,\n             &obligation.predicate,\n+            obligation.param_env,\n             next_code.unwrap(),\n             &mut Vec::new(),\n             &mut Default::default(),\n@@ -1904,6 +1902,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         predicate: &T,\n+        param_env: ty::ParamEnv<'tcx>,\n         cause_code: &ObligationCauseCode<'tcx>,\n         obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n         seen_requirements: &mut FxHashSet<DefId>,\n@@ -2134,7 +2133,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 err.note(\"shared static variables must have a type that implements `Sync`\");\n             }\n             ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n-                let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_ref);\n+                let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_pred);\n                 let ty = parent_trait_ref.skip_binder().self_ty();\n                 if parent_trait_ref.references_error() {\n                     err.cancel();\n@@ -2149,7 +2148,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     if let ObligationCauseCode::BuiltinDerivedObligation(ref data) =\n                         *data.parent_code\n                     {\n-                        let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_ref);\n+                        let parent_trait_ref =\n+                            self.resolve_vars_if_possible(data.parent_trait_pred);\n                         let ty = parent_trait_ref.skip_binder().self_ty();\n                         matches!(ty.kind(), ty::Generator(..))\n                             || matches!(ty.kind(), ty::Closure(..))\n@@ -2172,13 +2172,14 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n                 obligated_types.push(ty);\n \n-                let parent_predicate = parent_trait_ref.without_const().to_predicate(tcx);\n+                let parent_predicate = parent_trait_ref.to_predicate(tcx);\n                 if !self.is_recursive_obligation(obligated_types, &data.parent_code) {\n                     // #74711: avoid a stack overflow\n                     ensure_sufficient_stack(|| {\n                         self.note_obligation_cause_code(\n                             err,\n                             &parent_predicate,\n+                            param_env,\n                             &data.parent_code,\n                             obligated_types,\n                             seen_requirements,\n@@ -2189,6 +2190,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         self.note_obligation_cause_code(\n                             err,\n                             &parent_predicate,\n+                            param_env,\n                             &cause_code.peel_derives(),\n                             obligated_types,\n                             seen_requirements,\n@@ -2197,17 +2199,18 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 }\n             }\n             ObligationCauseCode::ImplDerivedObligation(ref data) => {\n-                let mut parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_ref);\n-                let parent_def_id = parent_trait_ref.def_id();\n+                let mut parent_trait_pred = self.resolve_vars_if_possible(data.parent_trait_pred);\n+                parent_trait_pred.remap_constness_diag(param_env);\n+                let parent_def_id = parent_trait_pred.def_id();\n                 let msg = format!(\n                     \"required because of the requirements on the impl of `{}` for `{}`\",\n-                    parent_trait_ref.print_only_trait_path(),\n-                    parent_trait_ref.skip_binder().self_ty()\n+                    parent_trait_pred.print_modifiers_and_trait_path(),\n+                    parent_trait_pred.skip_binder().self_ty()\n                 );\n                 let mut candidates = vec![];\n                 self.tcx.for_each_relevant_impl(\n                     parent_def_id,\n-                    parent_trait_ref.self_ty().skip_binder(),\n+                    parent_trait_pred.self_ty().skip_binder(),\n                     |impl_def_id| match self.tcx.hir().get_if_local(impl_def_id) {\n                         Some(Node::Item(hir::Item {\n                             kind: hir::ItemKind::Impl(hir::Impl { .. }),\n@@ -2236,21 +2239,21 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     _ => err.note(&msg),\n                 };\n \n-                let mut parent_predicate = parent_trait_ref.without_const().to_predicate(tcx);\n+                let mut parent_predicate = parent_trait_pred.to_predicate(tcx);\n                 let mut data = data;\n                 let mut count = 0;\n                 seen_requirements.insert(parent_def_id);\n                 while let ObligationCauseCode::ImplDerivedObligation(child) = &*data.parent_code {\n                     // Skip redundant recursive obligation notes. See `ui/issue-20413.rs`.\n-                    let child_trait_ref = self.resolve_vars_if_possible(child.parent_trait_ref);\n-                    let child_def_id = child_trait_ref.def_id();\n+                    let child_trait_pred = self.resolve_vars_if_possible(child.parent_trait_pred);\n+                    let child_def_id = child_trait_pred.def_id();\n                     if seen_requirements.insert(child_def_id) {\n                         break;\n                     }\n                     count += 1;\n                     data = child;\n-                    parent_predicate = child_trait_ref.without_const().to_predicate(tcx);\n-                    parent_trait_ref = child_trait_ref;\n+                    parent_predicate = child_trait_pred.to_predicate(tcx);\n+                    parent_trait_pred = child_trait_pred;\n                 }\n                 if count > 0 {\n                     err.note(&format!(\n@@ -2260,29 +2263,31 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     ));\n                     err.note(&format!(\n                         \"required because of the requirements on the impl of `{}` for `{}`\",\n-                        parent_trait_ref.print_only_trait_path(),\n-                        parent_trait_ref.skip_binder().self_ty()\n+                        parent_trait_pred.print_modifiers_and_trait_path(),\n+                        parent_trait_pred.skip_binder().self_ty()\n                     ));\n                 }\n                 // #74711: avoid a stack overflow\n                 ensure_sufficient_stack(|| {\n                     self.note_obligation_cause_code(\n                         err,\n                         &parent_predicate,\n+                        param_env,\n                         &data.parent_code,\n                         obligated_types,\n                         seen_requirements,\n                     )\n                 });\n             }\n             ObligationCauseCode::DerivedObligation(ref data) => {\n-                let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_ref);\n-                let parent_predicate = parent_trait_ref.without_const().to_predicate(tcx);\n+                let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_pred);\n+                let parent_predicate = parent_trait_ref.to_predicate(tcx);\n                 // #74711: avoid a stack overflow\n                 ensure_sufficient_stack(|| {\n                     self.note_obligation_cause_code(\n                         err,\n                         &parent_predicate,\n+                        param_env,\n                         &data.parent_code,\n                         obligated_types,\n                         seen_requirements,\n@@ -2336,6 +2341,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     self.note_obligation_cause_code(\n                         err,\n                         predicate,\n+                        param_env,\n                         &parent_code,\n                         obligated_types,\n                         seen_requirements,\n@@ -2426,15 +2432,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         obligation: &PredicateObligation<'tcx>,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n         span: Span,\n     ) {\n         debug!(\n-            \"suggest_await_before_try: obligation={:?}, span={:?}, trait_ref={:?}, trait_ref_self_ty={:?}\",\n+            \"suggest_await_before_try: obligation={:?}, span={:?}, trait_pred={:?}, trait_pred_self_ty={:?}\",\n             obligation,\n             span,\n-            trait_ref,\n-            trait_ref.self_ty()\n+            trait_pred,\n+            trait_pred.self_ty()\n         );\n         let body_hir_id = obligation.cause.body_id;\n         let item_id = self.tcx.hir().get_parent_node(body_hir_id);\n@@ -2444,7 +2450,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             if let Some(hir::GeneratorKind::Async(_)) = body.generator_kind {\n                 let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n \n-                let self_ty = self.resolve_vars_if_possible(trait_ref.self_ty());\n+                let self_ty = self.resolve_vars_if_possible(trait_pred.self_ty());\n \n                 // Do not check on infer_types to avoid panic in evaluate_obligation.\n                 if self_ty.has_infer_types() {\n@@ -2464,7 +2470,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 let projection_ty = ty::ProjectionTy {\n                     // `T`\n                     substs: self.tcx.mk_substs_trait(\n-                        trait_ref.self_ty().skip_binder(),\n+                        trait_pred.self_ty().skip_binder(),\n                         self.fresh_substs_for_item(span, item_def_id),\n                     ),\n                     // `Future::Output`\n@@ -2489,7 +2495,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 );\n                 let try_obligation = self.mk_trait_obligation_with_new_self_ty(\n                     obligation.param_env,\n-                    trait_ref,\n+                    trait_pred,\n                     normalized_ty,\n                 );\n                 debug!(\"suggest_await_before_try: try_trait_obligation {:?}\", try_obligation);"}, {"sha": "6b20476b95594de9862dc530417b850ea9a0728b", "filename": "compiler/rustc_trait_selection/src/traits/on_unimplemented.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -19,6 +19,7 @@ pub struct OnUnimplementedDirective {\n     pub label: Option<OnUnimplementedFormatString>,\n     pub note: Option<OnUnimplementedFormatString>,\n     pub enclosing_scope: Option<OnUnimplementedFormatString>,\n+    pub append_const_msg: Option<Option<Symbol>>,\n }\n \n #[derive(Default)]\n@@ -27,6 +28,11 @@ pub struct OnUnimplementedNote {\n     pub label: Option<String>,\n     pub note: Option<String>,\n     pub enclosing_scope: Option<String>,\n+    /// Append a message for `~const Trait` errors. `None` means not requested and\n+    /// should fallback to a generic message, `Some(None)` suggests using the default\n+    /// appended message, `Some(Some(s))` suggests use the `s` message instead of the\n+    /// default one..\n+    pub append_const_msg: Option<Option<Symbol>>,\n }\n \n fn parse_error(\n@@ -89,6 +95,7 @@ impl<'tcx> OnUnimplementedDirective {\n         let mut note = None;\n         let mut enclosing_scope = None;\n         let mut subcommands = vec![];\n+        let mut append_const_msg = None;\n \n         let parse_value = |value_str| {\n             OnUnimplementedFormatString::try_parse(tcx, trait_def_id, value_str, span).map(Some)\n@@ -131,6 +138,14 @@ impl<'tcx> OnUnimplementedDirective {\n                     }\n                     continue;\n                 }\n+            } else if item.has_name(sym::append_const_msg) && append_const_msg.is_none() {\n+                if let Some(msg) = item.value_str() {\n+                    append_const_msg = Some(Some(msg));\n+                    continue;\n+                } else if item.is_word() {\n+                    append_const_msg = Some(None);\n+                    continue;\n+                }\n             }\n \n             // nothing found\n@@ -153,6 +168,7 @@ impl<'tcx> OnUnimplementedDirective {\n                 label,\n                 note,\n                 enclosing_scope,\n+                append_const_msg,\n             })\n         }\n     }\n@@ -183,6 +199,7 @@ impl<'tcx> OnUnimplementedDirective {\n                 )?),\n                 note: None,\n                 enclosing_scope: None,\n+                append_const_msg: None,\n             }))\n         } else {\n             return Err(ErrorReported);\n@@ -201,6 +218,7 @@ impl<'tcx> OnUnimplementedDirective {\n         let mut label = None;\n         let mut note = None;\n         let mut enclosing_scope = None;\n+        let mut append_const_msg = None;\n         info!(\"evaluate({:?}, trait_ref={:?}, options={:?})\", self, trait_ref, options);\n \n         for command in self.subcommands.iter().chain(Some(self)).rev() {\n@@ -235,6 +253,8 @@ impl<'tcx> OnUnimplementedDirective {\n             if let Some(ref enclosing_scope_) = command.enclosing_scope {\n                 enclosing_scope = Some(enclosing_scope_.clone());\n             }\n+\n+            append_const_msg = command.append_const_msg.clone();\n         }\n \n         let options: FxHashMap<Symbol, String> =\n@@ -244,6 +264,7 @@ impl<'tcx> OnUnimplementedDirective {\n             message: message.map(|m| m.format(tcx, trait_ref, &options)),\n             note: note.map(|n| n.format(tcx, trait_ref, &options)),\n             enclosing_scope: enclosing_scope.map(|e_s| e_s.format(tcx, trait_ref, &options)),\n+            append_const_msg,\n         }\n     }\n }"}, {"sha": "2e20ea34e10ef15693997fc9182c76e129ddc71e", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -659,7 +659,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n         };\n \n-        let obligation_predicate = obligation.predicate.to_poly_trait_ref();\n+        let obligation_predicate = obligation.predicate;\n         let Normalized { value: obligation_predicate, mut obligations } =\n             ensure_sufficient_stack(|| {\n                 normalize_with_depth(\n@@ -689,7 +689,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligations.extend(self.confirm_poly_trait_refs(\n             obligation.cause.clone(),\n             obligation.param_env,\n-            obligation_predicate,\n+            obligation_predicate.to_poly_trait_ref(),\n             trait_ref,\n         )?);\n "}, {"sha": "ae5369054837597bac04241bee668339fcd48112", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -2413,7 +2413,7 @@ impl<'tcx> TraitObligationExt<'tcx> for TraitObligation<'tcx> {\n         // chain. Ideally, we should have a way to configure this either\n         // by using -Z verbose or just a CLI argument.\n         let derived_cause = DerivedObligationCause {\n-            parent_trait_ref: obligation.predicate.to_poly_trait_ref(),\n+            parent_trait_pred: obligation.predicate,\n             parent_code: obligation.cause.clone_code(),\n         };\n         let derived_code = variant(derived_cause);"}, {"sha": "2c5e7e40cc862912aeb385180f64c17b1c612b3f", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -506,12 +506,21 @@ crate fn to_pretty_impl_header(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Option<St\n     let mut pretty_predicates =\n         Vec::with_capacity(predicates.len() + types_without_default_bounds.len());\n \n-    for (p, _) in predicates {\n+    for (mut p, _) in predicates {\n         if let Some(poly_trait_ref) = p.to_opt_poly_trait_pred() {\n             if Some(poly_trait_ref.def_id()) == sized_trait {\n                 types_without_default_bounds.remove(poly_trait_ref.self_ty().skip_binder());\n                 continue;\n             }\n+\n+            if ty::BoundConstness::ConstIfConst == poly_trait_ref.skip_binder().constness {\n+                let new_trait_pred = poly_trait_ref.map_bound(|mut trait_pred| {\n+                    trait_pred.constness = ty::BoundConstness::NotConst;\n+                    trait_pred\n+                });\n+\n+                p = tcx.mk_predicate(new_trait_pred.map_bound(ty::PredicateKind::Trait))\n+            }\n         }\n         pretty_predicates.push(p.to_string());\n     }"}, {"sha": "493cb199f114485d544538a14e22f1e8dbd7d41e", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -306,10 +306,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n \n         let extend = |obligation: traits::PredicateObligation<'tcx>| {\n             let mut cause = cause.clone();\n-            if let Some(parent_trait_ref) = obligation.predicate.to_opt_poly_trait_pred() {\n+            if let Some(parent_trait_pred) = obligation.predicate.to_opt_poly_trait_pred() {\n                 let derived_cause = traits::DerivedObligationCause {\n-                    // FIXME(fee1-dead): when improving error messages, change this to PolyTraitPredicate\n-                    parent_trait_ref: parent_trait_ref.map_bound(|t| t.trait_ref),\n+                    parent_trait_pred,\n                     parent_code: obligation.cause.clone_code(),\n                 };\n                 *cause.make_mut_code() ="}, {"sha": "4b56cc5321b37d577aa11eea427250d4810a6c7b", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -1021,7 +1021,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 ObligationCauseCode::BuiltinDerivedObligation(code) |\n                 ObligationCauseCode::ImplDerivedObligation(code) |\n                 ObligationCauseCode::DerivedObligation(code) => {\n-                    code.parent_trait_ref.self_ty().skip_binder().into()\n+                    code.parent_trait_pred.self_ty().skip_binder().into()\n                 }\n                 _ if let ty::PredicateKind::Trait(predicate) =\n                     error.obligation.predicate.kind().skip_binder() => {"}, {"sha": "58ea197d3e94041c7b6157a24c1e2d4d6c013cb9", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -823,9 +823,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             _ => None,\n                         })\n                     {\n-                        let parent_trait_ref = data.parent_trait_ref;\n+                        let parent_trait_ref = data.parent_trait_pred;\n                         let parent_def_id = parent_trait_ref.def_id();\n-                        let path = parent_trait_ref.print_only_trait_path();\n+                        let path = parent_trait_ref.print_modifiers_and_trait_path();\n                         let tr_self_ty = parent_trait_ref.skip_binder().self_ty();\n                         let mut candidates = vec![];\n                         self.tcx.for_each_relevant_impl("}, {"sha": "56a47001811990fe286cf3bdc45ae0470271a821", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -433,7 +433,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let mut heap = BinaryHeap::from(vec![1, 3]);\n+    /// let mut heap = BinaryHeap::from([1, 3]);\n     ///\n     /// assert_eq!(heap.pop(), Some(3));\n     /// assert_eq!(heap.pop(), Some(1));\n@@ -506,7 +506,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut heap = BinaryHeap::from(vec![1, 2, 4, 5, 7]);\n+    /// let mut heap = BinaryHeap::from([1, 2, 4, 5, 7]);\n     /// heap.push(6);\n     /// heap.push(3);\n     ///\n@@ -725,11 +725,8 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let v = vec![-10, 1, 2, 3, 3];\n-    /// let mut a = BinaryHeap::from(v);\n-    ///\n-    /// let v = vec![-20, 5, 43];\n-    /// let mut b = BinaryHeap::from(v);\n+    /// let mut a = BinaryHeap::from([-10, 1, 2, 3, 3]);\n+    /// let mut b = BinaryHeap::from([-20, 5, 43]);\n     ///\n     /// a.append(&mut b);\n     ///\n@@ -765,7 +762,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// #![feature(binary_heap_drain_sorted)]\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut heap = BinaryHeap::from(vec![1, 2, 3, 4, 5]);\n+    /// let mut heap = BinaryHeap::from([1, 2, 3, 4, 5]);\n     /// assert_eq!(heap.len(), 5);\n     ///\n     /// drop(heap.drain_sorted()); // removes all elements in heap order\n@@ -790,7 +787,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// #![feature(binary_heap_retain)]\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut heap = BinaryHeap::from(vec![-10, -5, 1, 2, 4, 13]);\n+    /// let mut heap = BinaryHeap::from([-10, -5, 1, 2, 4, 13]);\n     ///\n     /// heap.retain(|x| x % 2 == 0); // only keep even numbers\n     ///\n@@ -826,7 +823,7 @@ impl<T> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let heap = BinaryHeap::from(vec![1, 2, 3, 4]);\n+    /// let heap = BinaryHeap::from([1, 2, 3, 4]);\n     ///\n     /// // Print 1, 2, 3, 4 in arbitrary order\n     /// for x in heap.iter() {\n@@ -848,9 +845,9 @@ impl<T> BinaryHeap<T> {\n     /// ```\n     /// #![feature(binary_heap_into_iter_sorted)]\n     /// use std::collections::BinaryHeap;\n-    /// let heap = BinaryHeap::from(vec![1, 2, 3, 4, 5]);\n+    /// let heap = BinaryHeap::from([1, 2, 3, 4, 5]);\n     ///\n-    /// assert_eq!(heap.into_iter_sorted().take(2).collect::<Vec<_>>(), vec![5, 4]);\n+    /// assert_eq!(heap.into_iter_sorted().take(2).collect::<Vec<_>>(), [5, 4]);\n     /// ```\n     #[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\n     pub fn into_iter_sorted(self) -> IntoIterSorted<T> {\n@@ -1086,7 +1083,7 @@ impl<T> BinaryHeap<T> {\n     /// use std::collections::BinaryHeap;\n     /// use std::io::{self, Write};\n     ///\n-    /// let heap = BinaryHeap::from(vec![1, 2, 3, 4, 5, 6, 7]);\n+    /// let heap = BinaryHeap::from([1, 2, 3, 4, 5, 6, 7]);\n     ///\n     /// io::sink().write(heap.as_slice()).unwrap();\n     /// ```\n@@ -1105,7 +1102,7 @@ impl<T> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let heap = BinaryHeap::from(vec![1, 2, 3, 4, 5, 6, 7]);\n+    /// let heap = BinaryHeap::from([1, 2, 3, 4, 5, 6, 7]);\n     /// let vec = heap.into_vec();\n     ///\n     /// // Will print in some order\n@@ -1127,7 +1124,7 @@ impl<T> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let heap = BinaryHeap::from(vec![1, 3]);\n+    /// let heap = BinaryHeap::from([1, 3]);\n     ///\n     /// assert_eq!(heap.len(), 2);\n     /// ```\n@@ -1171,7 +1168,7 @@ impl<T> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let mut heap = BinaryHeap::from(vec![1, 3]);\n+    /// let mut heap = BinaryHeap::from([1, 3]);\n     ///\n     /// assert!(!heap.is_empty());\n     ///\n@@ -1195,7 +1192,7 @@ impl<T> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let mut heap = BinaryHeap::from(vec![1, 3]);\n+    /// let mut heap = BinaryHeap::from([1, 3]);\n     ///\n     /// assert!(!heap.is_empty());\n     ///\n@@ -1616,7 +1613,7 @@ impl<T> IntoIterator for BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let heap = BinaryHeap::from(vec![1, 2, 3, 4]);\n+    /// let heap = BinaryHeap::from([1, 2, 3, 4]);\n     ///\n     /// // Print 1, 2, 3, 4 in arbitrary order\n     /// for x in heap.into_iter() {"}, {"sha": "cdb961d4cfbc5e697ebf49635231e5959aca84a3", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -1098,10 +1098,8 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     /// use std::collections::BTreeMap;\n     ///\n-    /// let mut map: BTreeMap<&str, i32> = [\"Alice\", \"Bob\", \"Carol\", \"Cheryl\"]\n-    ///     .iter()\n-    ///     .map(|&s| (s, 0))\n-    ///     .collect();\n+    /// let mut map: BTreeMap<&str, i32> =\n+    ///     [(\"Alice\", 0), (\"Bob\", 0), (\"Carol\", 0), (\"Cheryl\", 0)].into();\n     /// for (_, balance) in map.range_mut(\"B\"..\"Cheryl\") {\n     ///     *balance += 100;\n     /// }\n@@ -1135,7 +1133,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// let mut count: BTreeMap<&str, usize> = BTreeMap::new();\n     ///\n     /// // count the number of occurrences of letters in the vec\n-    /// for x in vec![\"a\", \"b\", \"a\", \"c\", \"a\", \"b\"] {\n+    /// for x in [\"a\", \"b\", \"a\", \"c\", \"a\", \"b\"] {\n     ///     *count.entry(x).or_insert(0) += 1;\n     /// }\n     ///\n@@ -1235,8 +1233,8 @@ impl<K, V> BTreeMap<K, V> {\n     /// let mut map: BTreeMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\n     /// let evens: BTreeMap<_, _> = map.drain_filter(|k, _v| k % 2 == 0).collect();\n     /// let odds = map;\n-    /// assert_eq!(evens.keys().copied().collect::<Vec<_>>(), vec![0, 2, 4, 6]);\n-    /// assert_eq!(odds.keys().copied().collect::<Vec<_>>(), vec![1, 3, 5, 7]);\n+    /// assert_eq!(evens.keys().copied().collect::<Vec<_>>(), [0, 2, 4, 6]);\n+    /// assert_eq!(odds.keys().copied().collect::<Vec<_>>(), [1, 3, 5, 7]);\n     /// ```\n     #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n     pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, K, V, F>"}, {"sha": "a8a18d655855eb117585ae9b094b1084f1d9c53e", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -669,7 +669,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf: VecDeque<i32> = [1].into_iter().collect();\n+    /// let mut buf: VecDeque<i32> = [1].into();\n     /// buf.reserve_exact(10);\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n@@ -692,7 +692,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf: VecDeque<i32> = [1].into_iter().collect();\n+    /// let mut buf: VecDeque<i32> = [1].into();\n     /// buf.reserve(10);\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n@@ -1153,7 +1153,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let v: VecDeque<_> = [1, 2, 3].into_iter().collect();\n+    /// let v: VecDeque<_> = [1, 2, 3].into();\n     /// let range = v.range(2..).copied().collect::<VecDeque<_>>();\n     /// assert_eq!(range, [3]);\n     ///\n@@ -1188,17 +1188,17 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let mut v: VecDeque<_> = [1, 2, 3].into_iter().collect();\n+    /// let mut v: VecDeque<_> = [1, 2, 3].into();\n     /// for v in v.range_mut(2..) {\n     ///   *v *= 2;\n     /// }\n-    /// assert_eq!(v, vec![1, 2, 6]);\n+    /// assert_eq!(v, [1, 2, 6]);\n     ///\n     /// // A full range covers all contents\n     /// for v in v.range_mut(..) {\n     ///   *v *= 2;\n     /// }\n-    /// assert_eq!(v, vec![2, 4, 12]);\n+    /// assert_eq!(v, [2, 4, 12]);\n     /// ```\n     #[inline]\n     #[stable(feature = \"deque_range\", since = \"1.51.0\")]\n@@ -1235,7 +1235,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let mut v: VecDeque<_> = [1, 2, 3].into_iter().collect();\n+    /// let mut v: VecDeque<_> = [1, 2, 3].into();\n     /// let drained = v.drain(2..).collect::<VecDeque<_>>();\n     /// assert_eq!(drained, [3]);\n     /// assert_eq!(v, [1, 2]);\n@@ -2025,7 +2025,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf: VecDeque<_> = [1, 2, 3].into_iter().collect();\n+    /// let mut buf: VecDeque<_> = [1, 2, 3].into();\n     /// let buf2 = buf.split_off(1);\n     /// assert_eq!(buf, [1]);\n     /// assert_eq!(buf2, [2, 3]);\n@@ -2091,8 +2091,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf: VecDeque<_> = [1, 2].into_iter().collect();\n-    /// let mut buf2: VecDeque<_> = [3, 4].into_iter().collect();\n+    /// let mut buf: VecDeque<_> = [1, 2].into();\n+    /// let mut buf2: VecDeque<_> = [3, 4].into();\n     /// buf.append(&mut buf2);\n     /// assert_eq!(buf, [1, 2, 3, 4]);\n     /// assert_eq!(buf2, []);\n@@ -2547,7 +2547,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let deque: VecDeque<_> = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();\n+    /// let deque: VecDeque<_> = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();\n     ///\n     /// assert_eq!(deque.binary_search(&13),  Ok(9));\n     /// assert_eq!(deque.binary_search(&4),   Err(7));\n@@ -2562,7 +2562,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let mut deque: VecDeque<_> = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();\n+    /// let mut deque: VecDeque<_> = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();\n     /// let num = 42;\n     /// let idx = deque.binary_search(&num).unwrap_or_else(|x| x);\n     /// deque.insert(idx, num);\n@@ -2605,7 +2605,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let deque: VecDeque<_> = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();\n+    /// let deque: VecDeque<_> = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();\n     ///\n     /// assert_eq!(deque.binary_search_by(|x| x.cmp(&13)),  Ok(9));\n     /// assert_eq!(deque.binary_search_by(|x| x.cmp(&4)),   Err(7));\n@@ -2658,7 +2658,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let deque: VecDeque<_> = vec![(0, 0), (2, 1), (4, 1), (5, 1),\n+    /// let deque: VecDeque<_> = [(0, 0), (2, 1), (4, 1), (5, 1),\n     ///          (3, 1), (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),\n     ///          (1, 21), (2, 34), (4, 55)].into();\n     ///\n@@ -2701,7 +2701,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let deque: VecDeque<_> = vec![1, 2, 3, 3, 5, 6, 7].into();\n+    /// let deque: VecDeque<_> = [1, 2, 3, 3, 5, 6, 7].into();\n     /// let i = deque.partition_point(|&x| x < 5);\n     ///\n     /// assert_eq!(i, 4);"}, {"sha": "1af352d542ac65fcf8dd99780cd9badf773bb217", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -199,9 +199,20 @@ use self::Ordering::*;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(alias = \"==\")]\n #[doc(alias = \"!=\")]\n-#[rustc_on_unimplemented(\n-    message = \"can't compare `{Self}` with `{Rhs}`\",\n-    label = \"no implementation for `{Self} == {Rhs}`\"\n+#[cfg_attr(\n+    bootstrap,\n+    rustc_on_unimplemented(\n+        message = \"can't compare `{Self}` with `{Rhs}`\",\n+        label = \"no implementation for `{Self} == {Rhs}`\"\n+    )\n+)]\n+#[cfg_attr(\n+    not(bootstrap),\n+    rustc_on_unimplemented(\n+        message = \"can't compare `{Self}` with `{Rhs}`\",\n+        label = \"no implementation for `{Self} == {Rhs}`\",\n+        append_const_msg,\n+    )\n )]\n #[rustc_diagnostic_item = \"PartialEq\"]\n pub trait PartialEq<Rhs: ?Sized = Self> {\n@@ -1031,9 +1042,20 @@ impl PartialOrd for Ordering {\n #[doc(alias = \"<\")]\n #[doc(alias = \"<=\")]\n #[doc(alias = \">=\")]\n-#[rustc_on_unimplemented(\n-    message = \"can't compare `{Self}` with `{Rhs}`\",\n-    label = \"no implementation for `{Self} < {Rhs}` and `{Self} > {Rhs}`\"\n+#[cfg_attr(\n+    bootstrap,\n+    rustc_on_unimplemented(\n+        message = \"can't compare `{Self}` with `{Rhs}`\",\n+        label = \"no implementation for `{Self} < {Rhs}` and `{Self} > {Rhs}`\",\n+    )\n+)]\n+#[cfg_attr(\n+    not(bootstrap),\n+    rustc_on_unimplemented(\n+        message = \"can't compare `{Self}` with `{Rhs}`\",\n+        label = \"no implementation for `{Self} < {Rhs}` and `{Self} > {Rhs}`\",\n+        append_const_msg,\n+    )\n )]\n #[rustc_diagnostic_item = \"PartialOrd\"]\n pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {"}, {"sha": "e367be8c167c720d64ecb26125d4d25c963e7980", "filename": "library/core/src/ops/arith.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/library%2Fcore%2Fsrc%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/library%2Fcore%2Fsrc%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Farith.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -65,11 +65,36 @@\n /// ```\n #[lang = \"add\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(\n-    on(all(_Self = \"{integer}\", Rhs = \"{float}\"), message = \"cannot add a float to an integer\",),\n-    on(all(_Self = \"{float}\", Rhs = \"{integer}\"), message = \"cannot add an integer to a float\",),\n-    message = \"cannot add `{Rhs}` to `{Self}`\",\n-    label = \"no implementation for `{Self} + {Rhs}`\"\n+#[cfg_attr(\n+    bootstrap,\n+    rustc_on_unimplemented(\n+        on(\n+            all(_Self = \"{integer}\", Rhs = \"{float}\"),\n+            message = \"cannot add a float to an integer\",\n+        ),\n+        on(\n+            all(_Self = \"{float}\", Rhs = \"{integer}\"),\n+            message = \"cannot add an integer to a float\",\n+        ),\n+        message = \"cannot add `{Rhs}` to `{Self}`\",\n+        label = \"no implementation for `{Self} + {Rhs}`\"\n+    )\n+)]\n+#[cfg_attr(\n+    not(bootstrap),\n+    rustc_on_unimplemented(\n+        on(\n+            all(_Self = \"{integer}\", Rhs = \"{float}\"),\n+            message = \"cannot add a float to an integer\",\n+        ),\n+        on(\n+            all(_Self = \"{float}\", Rhs = \"{integer}\"),\n+            message = \"cannot add an integer to a float\",\n+        ),\n+        message = \"cannot add `{Rhs}` to `{Self}`\",\n+        label = \"no implementation for `{Self} + {Rhs}`\",\n+        append_const_msg,\n+    )\n )]\n #[doc(alias = \"+\")]\n pub trait Add<Rhs = Self> {"}, {"sha": "243c044b5d9d0a55ee918885637f9177d49226e7", "filename": "library/core/src/time.rs", "status": "modified", "additions": 200, "deletions": 101, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -711,14 +711,28 @@ impl Duration {\n     /// as `f64`.\n     ///\n     /// # Panics\n-    /// This constructor will panic if `secs` is not finite, negative or overflows `Duration`.\n+    /// This constructor will panic if `secs` is negative, overflows `Duration` or not finite.\n     ///\n     /// # Examples\n     /// ```\n     /// use std::time::Duration;\n     ///\n-    /// let dur = Duration::from_secs_f64(2.7);\n-    /// assert_eq!(dur, Duration::new(2, 700_000_000));\n+    /// let res = Duration::from_secs_f64(0.0);\n+    /// assert_eq!(res, Duration::new(0, 0));\n+    /// let res = Duration::from_secs_f64(1e-20);\n+    /// assert_eq!(res, Duration::new(0, 0));\n+    /// let res = Duration::from_secs_f64(4.2e-7);\n+    /// assert_eq!(res, Duration::new(0, 420));\n+    /// let res = Duration::from_secs_f64(2.7);\n+    /// assert_eq!(res, Duration::new(2, 700_000_000));\n+    /// let res = Duration::from_secs_f64(3e10);\n+    /// assert_eq!(res, Duration::new(30_000_000_000, 0));\n+    /// // subnormal float\n+    /// let res = Duration::from_secs_f64(f64::from_bits(1));\n+    /// assert_eq!(res, Duration::new(0, 0));\n+    /// // conversion uses truncation, not rounding\n+    /// let res = Duration::from_secs_f64(0.999e-9);\n+    /// assert_eq!(res, Duration::new(0, 0));\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[must_use]\n@@ -731,55 +745,32 @@ impl Duration {\n         }\n     }\n \n-    /// The checked version of [`from_secs_f64`].\n-    ///\n-    /// [`from_secs_f64`]: Duration::from_secs_f64\n-    ///\n-    /// This constructor will return an `Err` if `secs` is not finite, negative or overflows `Duration`.\n-    ///\n-    /// # Examples\n-    /// ```\n-    /// #![feature(duration_checked_float)]\n-    /// use std::time::Duration;\n-    ///\n-    /// let dur = Duration::try_from_secs_f64(2.7);\n-    /// assert_eq!(dur, Ok(Duration::new(2, 700_000_000)));\n-    ///\n-    /// let negative = Duration::try_from_secs_f64(-5.0);\n-    /// assert!(negative.is_err());\n-    /// ```\n-    #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n-    #[inline]\n-    pub const fn try_from_secs_f64(secs: f64) -> Result<Duration, FromSecsError> {\n-        const MAX_NANOS_F64: f64 = ((u64::MAX as u128 + 1) * (NANOS_PER_SEC as u128)) as f64;\n-        let nanos = secs * (NANOS_PER_SEC as f64);\n-        if !nanos.is_finite() {\n-            Err(FromSecsError { kind: FromSecsErrorKind::NonFinite })\n-        } else if nanos >= MAX_NANOS_F64 {\n-            Err(FromSecsError { kind: FromSecsErrorKind::Overflow })\n-        } else if nanos < 0.0 {\n-            Err(FromSecsError { kind: FromSecsErrorKind::Negative })\n-        } else {\n-            let nanos = nanos as u128;\n-            Ok(Duration {\n-                secs: (nanos / (NANOS_PER_SEC as u128)) as u64,\n-                nanos: (nanos % (NANOS_PER_SEC as u128)) as u32,\n-            })\n-        }\n-    }\n-\n     /// Creates a new `Duration` from the specified number of seconds represented\n     /// as `f32`.\n     ///\n     /// # Panics\n-    /// This constructor will panic if `secs` is not finite, negative or overflows `Duration`.\n+    /// This constructor will panic if `secs` is negative, overflows `Duration` or not finite.\n     ///\n     /// # Examples\n     /// ```\n     /// use std::time::Duration;\n     ///\n-    /// let dur = Duration::from_secs_f32(2.7);\n-    /// assert_eq!(dur, Duration::new(2, 700_000_000));\n+    /// let res = Duration::from_secs_f32(0.0);\n+    /// assert_eq!(res, Duration::new(0, 0));\n+    /// let res = Duration::from_secs_f32(1e-20);\n+    /// assert_eq!(res, Duration::new(0, 0));\n+    /// let res = Duration::from_secs_f32(4.2e-7);\n+    /// assert_eq!(res, Duration::new(0, 419));\n+    /// let res = Duration::from_secs_f32(2.7);\n+    /// assert_eq!(res, Duration::new(2, 700_000_047));\n+    /// let res = Duration::from_secs_f32(3e10);\n+    /// assert_eq!(res, Duration::new(30_000_001_024, 0));\n+    /// // subnormal float\n+    /// let res = Duration::from_secs_f32(f32::from_bits(1));\n+    /// assert_eq!(res, Duration::new(0, 0));\n+    /// // conversion uses truncation, not rounding\n+    /// let res = Duration::from_secs_f32(0.999e-9);\n+    /// assert_eq!(res, Duration::new(0, 0));\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[must_use]\n@@ -792,47 +783,10 @@ impl Duration {\n         }\n     }\n \n-    /// The checked version of [`from_secs_f32`].\n-    ///\n-    /// [`from_secs_f32`]: Duration::from_secs_f32\n-    ///\n-    /// This constructor will return an `Err` if `secs` is not finite, negative or overflows `Duration`.\n-    ///\n-    /// # Examples\n-    /// ```\n-    /// #![feature(duration_checked_float)]\n-    /// use std::time::Duration;\n-    ///\n-    /// let dur = Duration::try_from_secs_f32(2.7);\n-    /// assert_eq!(dur, Ok(Duration::new(2, 700_000_000)));\n-    ///\n-    /// let negative = Duration::try_from_secs_f32(-5.0);\n-    /// assert!(negative.is_err());\n-    /// ```\n-    #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n-    #[inline]\n-    pub const fn try_from_secs_f32(secs: f32) -> Result<Duration, FromSecsError> {\n-        const MAX_NANOS_F32: f32 = ((u64::MAX as u128 + 1) * (NANOS_PER_SEC as u128)) as f32;\n-        let nanos = secs * (NANOS_PER_SEC as f32);\n-        if !nanos.is_finite() {\n-            Err(FromSecsError { kind: FromSecsErrorKind::NonFinite })\n-        } else if nanos >= MAX_NANOS_F32 {\n-            Err(FromSecsError { kind: FromSecsErrorKind::Overflow })\n-        } else if nanos < 0.0 {\n-            Err(FromSecsError { kind: FromSecsErrorKind::Negative })\n-        } else {\n-            let nanos = nanos as u128;\n-            Ok(Duration {\n-                secs: (nanos / (NANOS_PER_SEC as u128)) as u64,\n-                nanos: (nanos % (NANOS_PER_SEC as u128)) as u32,\n-            })\n-        }\n-    }\n-\n     /// Multiplies `Duration` by `f64`.\n     ///\n     /// # Panics\n-    /// This method will panic if result is not finite, negative or overflows `Duration`.\n+    /// This method will panic if result is negative, overflows `Duration` or not finite.\n     ///\n     /// # Examples\n     /// ```\n@@ -854,17 +808,15 @@ impl Duration {\n     /// Multiplies `Duration` by `f32`.\n     ///\n     /// # Panics\n-    /// This method will panic if result is not finite, negative or overflows `Duration`.\n+    /// This method will panic if result is negative, overflows `Duration` or not finite.\n     ///\n     /// # Examples\n     /// ```\n     /// use std::time::Duration;\n     ///\n     /// let dur = Duration::new(2, 700_000_000);\n-    /// // note that due to rounding errors result is slightly different\n-    /// // from 8.478 and 847800.0\n     /// assert_eq!(dur.mul_f32(3.14), Duration::new(8, 478_000_640));\n-    /// assert_eq!(dur.mul_f32(3.14e5), Duration::new(847799, 969_120_256));\n+    /// assert_eq!(dur.mul_f32(3.14e5), Duration::new(847800, 0));\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[must_use = \"this returns the result of the operation, \\\n@@ -878,7 +830,7 @@ impl Duration {\n     /// Divide `Duration` by `f64`.\n     ///\n     /// # Panics\n-    /// This method will panic if result is not finite, negative or overflows `Duration`.\n+    /// This method will panic if result is negative, overflows `Duration` or not finite.\n     ///\n     /// # Examples\n     /// ```\n@@ -901,7 +853,7 @@ impl Duration {\n     /// Divide `Duration` by `f32`.\n     ///\n     /// # Panics\n-    /// This method will panic if result is not finite, negative or overflows `Duration`.\n+    /// This method will panic if result is negative, overflows `Duration` or not finite.\n     ///\n     /// # Examples\n     /// ```\n@@ -910,7 +862,7 @@ impl Duration {\n     /// let dur = Duration::new(2, 700_000_000);\n     /// // note that due to rounding errors result is slightly\n     /// // different from 0.859_872_611\n-    /// assert_eq!(dur.div_f32(3.14), Duration::new(0, 859_872_576));\n+    /// assert_eq!(dur.div_f32(3.14), Duration::new(0, 859_872_579));\n     /// // note that truncation is used, not rounding\n     /// assert_eq!(dur.div_f32(3.14e5), Duration::new(0, 8_598));\n     /// ```\n@@ -1267,33 +1219,180 @@ impl fmt::Debug for Duration {\n /// ```\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n-pub struct FromSecsError {\n-    kind: FromSecsErrorKind,\n+pub struct FromFloatSecsError {\n+    kind: FromFloatSecsErrorKind,\n }\n \n-impl FromSecsError {\n+impl FromFloatSecsError {\n     const fn description(&self) -> &'static str {\n         match self.kind {\n-            FromSecsErrorKind::NonFinite => \"non-finite value when converting float to duration\",\n-            FromSecsErrorKind::Overflow => \"overflow when converting float to duration\",\n-            FromSecsErrorKind::Negative => \"negative value when converting float to duration\",\n+            FromFloatSecsErrorKind::Negative => {\n+                \"can not convert float seconds to Duration: value is negative\"\n+            }\n+            FromFloatSecsErrorKind::OverflowOrNan => {\n+                \"can not convert float seconds to Duration: value is either too big or NaN\"\n+            }\n         }\n     }\n }\n \n #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n-impl fmt::Display for FromSecsError {\n+impl fmt::Display for FromFloatSecsError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self.description(), f)\n+        self.description().fmt(f)\n     }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n-enum FromSecsErrorKind {\n-    // Value is not a finite value (either + or - infinity or NaN).\n-    NonFinite,\n-    // Value is too large to store in a `Duration`.\n-    Overflow,\n+enum FromFloatSecsErrorKind {\n     // Value is negative.\n     Negative,\n+    // Value is either too big to be represented as `Duration` or `NaN`.\n+    OverflowOrNan,\n+}\n+\n+macro_rules! try_from_secs {\n+    (\n+        secs = $secs: expr,\n+        mantissa_bits = $mant_bits: literal,\n+        exponent_bits = $exp_bits: literal,\n+        offset = $offset: literal,\n+        bits_ty = $bits_ty:ty,\n+        double_ty = $double_ty:ty,\n+    ) => {{\n+        const MIN_EXP: i16 = 1 - (1i16 << $exp_bits) / 2;\n+        const MANT_MASK: $bits_ty = (1 << $mant_bits) - 1;\n+        const EXP_MASK: $bits_ty = (1 << $exp_bits) - 1;\n+\n+        if $secs.is_sign_negative() {\n+            return Err(FromFloatSecsError { kind: FromFloatSecsErrorKind::Negative });\n+        }\n+\n+        let bits = $secs.to_bits();\n+        let mant = (bits & MANT_MASK) | (MANT_MASK + 1);\n+        let exp = ((bits >> $mant_bits) & EXP_MASK) as i16 + MIN_EXP;\n+\n+        let (secs, nanos) = if exp < -30 {\n+            // the input represents less than 1ns.\n+            (0u64, 0u32)\n+        } else if exp < 0 {\n+            // the input is less than 1 second\n+            let t = <$double_ty>::from(mant) << ($offset + exp);\n+            let nanos = (u128::from(NANOS_PER_SEC) * u128::from(t)) >> ($mant_bits + $offset);\n+            (0, nanos as u32)\n+        } else if exp < $mant_bits {\n+            let secs = mant >> ($mant_bits - exp);\n+            let t = <$double_ty>::from((mant << exp) & MANT_MASK);\n+            let nanos = (<$double_ty>::from(NANOS_PER_SEC) * t) >> $mant_bits;\n+            (u64::from(secs), nanos as u32)\n+        } else if exp < 64 {\n+            // the input has no fractional part\n+            let secs = u64::from(mant) << (exp - $mant_bits);\n+            (secs, 0)\n+        } else {\n+            return Err(FromFloatSecsError { kind: FromFloatSecsErrorKind::OverflowOrNan });\n+        };\n+\n+        Ok(Duration { secs, nanos })\n+    }};\n+}\n+\n+impl Duration {\n+    /// The checked version of [`from_secs_f32`].\n+    ///\n+    /// [`from_secs_f32`]: Duration::from_secs_f32\n+    ///\n+    /// This constructor will return an `Err` if `secs` is negative, overflows `Duration` or not finite.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// #![feature(duration_checked_float)]\n+    ///\n+    /// use std::time::Duration;\n+    ///\n+    /// let res = Duration::try_from_secs_f32(0.0);\n+    /// assert_eq!(res, Ok(Duration::new(0, 0)));\n+    /// let res = Duration::try_from_secs_f32(1e-20);\n+    /// assert_eq!(res, Ok(Duration::new(0, 0)));\n+    /// let res = Duration::try_from_secs_f32(4.2e-7);\n+    /// assert_eq!(res, Ok(Duration::new(0, 419)));\n+    /// let res = Duration::try_from_secs_f32(2.7);\n+    /// assert_eq!(res, Ok(Duration::new(2, 700_000_047)));\n+    /// let res = Duration::try_from_secs_f32(3e10);\n+    /// assert_eq!(res, Ok(Duration::new(30_000_001_024, 0)));\n+    /// // subnormal float:\n+    /// let res = Duration::try_from_secs_f32(f32::from_bits(1));\n+    /// assert_eq!(res, Ok(Duration::new(0, 0)));\n+    /// // conversion uses truncation, not rounding\n+    /// let res = Duration::try_from_secs_f32(0.999e-9);\n+    /// assert_eq!(res, Ok(Duration::new(0, 0)));\n+    ///\n+    /// let res = Duration::try_from_secs_f32(-5.0);\n+    /// assert!(res.is_err());\n+    /// let res = Duration::try_from_secs_f32(f32::NAN);\n+    /// assert!(res.is_err());\n+    /// let res = Duration::try_from_secs_f32(2e19);\n+    /// assert!(res.is_err());\n+    /// ```\n+    #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n+    #[inline]\n+    pub const fn try_from_secs_f32(secs: f32) -> Result<Duration, FromFloatSecsError> {\n+        try_from_secs!(\n+            secs = secs,\n+            mantissa_bits = 23,\n+            exponent_bits = 8,\n+            offset = 41,\n+            bits_ty = u32,\n+            double_ty = u64,\n+        )\n+    }\n+\n+    /// The checked version of [`from_secs_f64`].\n+    ///\n+    /// [`from_secs_f64`]: Duration::from_secs_f64\n+    ///\n+    /// This constructor will return an `Err` if `secs` is negative, overflows `Duration` or not finite.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// #![feature(duration_checked_float)]\n+    ///\n+    /// use std::time::Duration;\n+    ///\n+    /// let res = Duration::try_from_secs_f64(0.0);\n+    /// assert_eq!(res, Ok(Duration::new(0, 0)));\n+    /// let res = Duration::try_from_secs_f64(1e-20);\n+    /// assert_eq!(res, Ok(Duration::new(0, 0)));\n+    /// let res = Duration::try_from_secs_f64(4.2e-7);\n+    /// assert_eq!(res, Ok(Duration::new(0, 420)));\n+    /// let res = Duration::try_from_secs_f64(2.7);\n+    /// assert_eq!(res, Ok(Duration::new(2, 700_000_000)));\n+    /// let res = Duration::try_from_secs_f64(3e10);\n+    /// assert_eq!(res, Ok(Duration::new(30_000_000_000, 0)));\n+    /// // subnormal float\n+    /// let res = Duration::try_from_secs_f64(f64::from_bits(1));\n+    /// assert_eq!(res, Ok(Duration::new(0, 0)));\n+    /// // conversion uses truncation, not rounding\n+    /// let res = Duration::try_from_secs_f32(0.999e-9);\n+    /// assert_eq!(res, Ok(Duration::new(0, 0)));\n+    ///\n+    /// let res = Duration::try_from_secs_f64(-5.0);\n+    /// assert!(res.is_err());\n+    /// let res = Duration::try_from_secs_f64(f64::NAN);\n+    /// assert!(res.is_err());\n+    /// let res = Duration::try_from_secs_f64(2e19);\n+    /// assert!(res.is_err());\n+    /// ```\n+    #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n+    #[inline]\n+    pub const fn try_from_secs_f64(secs: f64) -> Result<Duration, FromFloatSecsError> {\n+        try_from_secs!(\n+            secs = secs,\n+            mantissa_bits = 52,\n+            exponent_bits = 11,\n+            offset = 44,\n+            bits_ty = u64,\n+            double_ty = u128,\n+        )\n+    }\n }"}, {"sha": "1a96b9c928289b3e5be32ed09efe242632290992", "filename": "library/std/src/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/library%2Fstd%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/library%2Fstd%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -602,7 +602,7 @@ impl Error for char::ParseCharError {\n impl Error for alloc::collections::TryReserveError {}\n \n #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n-impl Error for time::FromSecsError {}\n+impl Error for time::FromFloatSecsError {}\n \n // Copied from `any.rs`.\n impl dyn Error + 'static {"}, {"sha": "3bb80b458485c796c14169807f45e5c0f493ef45", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 57, "deletions": 35, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -34,7 +34,20 @@ use libc::c_char;\n use libc::dirfd;\n #[cfg(any(target_os = \"linux\", target_os = \"emscripten\"))]\n use libc::fstatat64;\n+#[cfg(any(\n+    target_os = \"android\",\n+    target_os = \"solaris\",\n+    target_os = \"fuchsia\",\n+    target_os = \"redox\",\n+    target_os = \"illumos\"\n+))]\n+use libc::readdir as readdir64;\n+#[cfg(target_os = \"linux\")]\n+use libc::readdir64;\n+#[cfg(any(target_os = \"emscripten\", target_os = \"l4re\"))]\n+use libc::readdir64_r;\n #[cfg(not(any(\n+    target_os = \"android\",\n     target_os = \"linux\",\n     target_os = \"emscripten\",\n     target_os = \"solaris\",\n@@ -60,9 +73,7 @@ use libc::{\n     lstat as lstat64, off_t as off64_t, open as open64, stat as stat64,\n };\n #[cfg(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"l4re\"))]\n-use libc::{\n-    dirent64, fstat64, ftruncate64, lseek64, lstat64, off64_t, open64, readdir64_r, stat64,\n-};\n+use libc::{dirent64, fstat64, ftruncate64, lseek64, lstat64, off64_t, open64, stat64};\n \n pub use crate::sys_common::fs::try_exists;\n \n@@ -202,6 +213,8 @@ struct InnerReadDir {\n pub struct ReadDir {\n     inner: Arc<InnerReadDir>,\n     #[cfg(not(any(\n+        target_os = \"android\",\n+        target_os = \"linux\",\n         target_os = \"solaris\",\n         target_os = \"illumos\",\n         target_os = \"fuchsia\",\n@@ -218,11 +231,12 @@ unsafe impl Sync for Dir {}\n pub struct DirEntry {\n     entry: dirent64,\n     dir: Arc<InnerReadDir>,\n-    // We need to store an owned copy of the entry name\n-    // on Solaris and Fuchsia because a) it uses a zero-length\n-    // array to store the name, b) its lifetime between readdir\n-    // calls is not guaranteed.\n+    // We need to store an owned copy of the entry name on platforms that use\n+    // readdir() (not readdir_r()), because a) struct dirent may use a flexible\n+    // array to store the name, b) it lives only until the next readdir() call.\n     #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"linux\",\n         target_os = \"solaris\",\n         target_os = \"illumos\",\n         target_os = \"fuchsia\",\n@@ -449,6 +463,8 @@ impl Iterator for ReadDir {\n     type Item = io::Result<DirEntry>;\n \n     #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"linux\",\n         target_os = \"solaris\",\n         target_os = \"fuchsia\",\n         target_os = \"redox\",\n@@ -457,12 +473,13 @@ impl Iterator for ReadDir {\n     fn next(&mut self) -> Option<io::Result<DirEntry>> {\n         unsafe {\n             loop {\n-                // Although readdir_r(3) would be a correct function to use here because\n-                // of the thread safety, on Illumos and Fuchsia the readdir(3C) function\n-                // is safe to use in threaded applications and it is generally preferred\n-                // over the readdir_r(3C) function.\n+                // As of POSIX.1-2017, readdir() is not required to be thread safe; only\n+                // readdir_r() is. However, readdir_r() cannot correctly handle platforms\n+                // with unlimited or variable NAME_MAX.  Many modern platforms guarantee\n+                // thread safety for readdir() as long an individual DIR* is not accessed\n+                // concurrently, which is sufficient for Rust.\n                 super::os::set_errno(0);\n-                let entry_ptr = libc::readdir(self.inner.dirp.0);\n+                let entry_ptr = readdir64(self.inner.dirp.0);\n                 if entry_ptr.is_null() {\n                     // null can mean either the end is reached or an error occurred.\n                     // So we had to clear errno beforehand to check for an error now.\n@@ -486,6 +503,8 @@ impl Iterator for ReadDir {\n     }\n \n     #[cfg(not(any(\n+        target_os = \"android\",\n+        target_os = \"linux\",\n         target_os = \"solaris\",\n         target_os = \"fuchsia\",\n         target_os = \"redox\",\n@@ -531,17 +550,17 @@ impl Drop for Dir {\n \n impl DirEntry {\n     pub fn path(&self) -> PathBuf {\n-        self.dir.root.join(OsStr::from_bytes(self.name_bytes()))\n+        self.dir.root.join(self.file_name_os_str())\n     }\n \n     pub fn file_name(&self) -> OsString {\n-        OsStr::from_bytes(self.name_bytes()).to_os_string()\n+        self.file_name_os_str().to_os_string()\n     }\n \n     #[cfg(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"android\"))]\n     pub fn metadata(&self) -> io::Result<FileAttr> {\n         let fd = cvt(unsafe { dirfd(self.dir.dirp.0) })?;\n-        let name = self.entry.d_name.as_ptr();\n+        let name = self.name_cstr().as_ptr();\n \n         cfg_has_statx! {\n             if let Some(ret) = unsafe { try_statx(\n@@ -639,29 +658,21 @@ impl DirEntry {\n             )\n         }\n     }\n-    #[cfg(any(\n-        target_os = \"android\",\n-        target_os = \"linux\",\n-        target_os = \"emscripten\",\n-        target_os = \"l4re\",\n-        target_os = \"haiku\",\n-        target_os = \"vxworks\",\n-        target_os = \"espidf\"\n-    ))]\n-    fn name_bytes(&self) -> &[u8] {\n-        unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()).to_bytes() }\n-    }\n-    #[cfg(any(\n-        target_os = \"solaris\",\n-        target_os = \"illumos\",\n-        target_os = \"fuchsia\",\n-        target_os = \"redox\"\n-    ))]\n+    #[cfg(not(any(\n+        target_os = \"macos\",\n+        target_os = \"ios\",\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\",\n+        target_os = \"freebsd\",\n+        target_os = \"dragonfly\"\n+    )))]\n     fn name_bytes(&self) -> &[u8] {\n-        self.name.as_bytes()\n+        self.name_cstr().to_bytes()\n     }\n \n     #[cfg(not(any(\n+        target_os = \"android\",\n+        target_os = \"linux\",\n         target_os = \"solaris\",\n         target_os = \"illumos\",\n         target_os = \"fuchsia\",\n@@ -670,7 +681,14 @@ impl DirEntry {\n     fn name_cstr(&self) -> &CStr {\n         unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()) }\n     }\n-    #[cfg(any(target_os = \"solaris\", target_os = \"illumos\", target_os = \"fuchsia\"))]\n+    #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"linux\",\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+        target_os = \"fuchsia\",\n+        target_os = \"redox\"\n+    ))]\n     fn name_cstr(&self) -> &CStr {\n         &self.name\n     }\n@@ -1076,6 +1094,8 @@ pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n             Ok(ReadDir {\n                 inner: Arc::new(inner),\n                 #[cfg(not(any(\n+                    target_os = \"android\",\n+                    target_os = \"linux\",\n                     target_os = \"solaris\",\n                     target_os = \"illumos\",\n                     target_os = \"fuchsia\",\n@@ -1615,6 +1635,8 @@ mod remove_dir_impl {\n             ReadDir {\n                 inner: Arc::new(InnerReadDir { dirp, root: dummy_root }),\n                 #[cfg(not(any(\n+                    target_os = \"android\",\n+                    target_os = \"linux\",\n                     target_os = \"solaris\",\n                     target_os = \"illumos\",\n                     target_os = \"fuchsia\","}, {"sha": "7466c77356c7c40a35a5b1d23359e7ba9f7e799d", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -75,7 +75,7 @@ pub fn errno() -> i32 {\n }\n \n /// Sets the platform-specific value of errno\n-#[cfg(all(not(target_os = \"linux\"), not(target_os = \"dragonfly\"), not(target_os = \"vxworks\")))] // needed for readdir and syscall!\n+#[cfg(all(not(target_os = \"dragonfly\"), not(target_os = \"vxworks\")))] // needed for readdir and syscall!\n #[allow(dead_code)] // but not all target cfgs actually end up using it\n pub fn set_errno(e: i32) {\n     unsafe { *errno_location() = e as c_int }"}, {"sha": "b4f9d8ea28d7b99cff2e2a5f6cc865663e05874a", "filename": "library/std/src/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/library%2Fstd%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/library%2Fstd%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -45,7 +45,7 @@ use crate::sys_common::FromInner;\n pub use core::time::Duration;\n \n #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n-pub use core::time::FromSecsError;\n+pub use core::time::FromFloatSecsError;\n \n /// A measurement of a monotonically nondecreasing clock.\n /// Opaque and useful only with [`Duration`]."}, {"sha": "146408900ab2472a21e9e44ca2124ea7a2c2509a", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -17,6 +17,7 @@\n     - [aarch64-apple-ios-sim](platform-support/aarch64-apple-ios-sim.md)\n     - [armv7-unknown-linux-uclibceabihf](platform-support/armv7-unknown-linux-uclibceabihf.md)\n     - [\\*-kmc-solid_\\*](platform-support/kmc-solid.md)\n+    - [*-unknown-openbsd](platform-support/openbsd.md)\n     - [x86_64-unknown-none](platform-support/x86_64-unknown-none.md)\n     - [wasm64-unknown-unknown](platform-support/wasm64-unknown-unknown.md)\n - [Target Tier Policy](target-tier-policy.md)"}, {"sha": "941c65922d8f09d3d1db1a6b818a1d5420eee222", "filename": "src/doc/rustc/src/linker-plugin-lto.md", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -86,6 +86,48 @@ option:\n rustc -Clinker-plugin-lto=\"/path/to/LLVMgold.so\" -L. -Copt-level=2 ./main.rs\n ```\n \n+### Usage with clang-cl and x86_64-pc-windows-msvc\n+\n+Cross language LTO can be used with the x86_64-pc-windows-msvc target, but this requires using the\n+clang-cl compiler instead of the MSVC cl.exe included with Visual Studio Build Tools, and linking\n+with lld-link. Both clang-cl and lld-link can be downloaded from [LLVM's download page](https://releases.llvm.org/download.html).\n+Note that most crates in the ecosystem are likely to assume you are using cl.exe if using this target\n+and that some things, like for example vcpkg, [don't work very well with clang-cl](https://github.com/microsoft/vcpkg/issues/2087).\n+\n+You will want to make sure your rust major LLVM version matches your installed LLVM tooling version,\n+otherwise it is likely you will get linker errors:\n+\n+```bat\n+rustc -V --verbose\n+clang-cl --version\n+```\n+\n+If you are compiling any proc-macros, you will get this error:\n+\n+```bash\n+error: Linker plugin based LTO is not supported together with `-C prefer-dynamic` when\n+targeting Windows-like targets\n+```\n+\n+This is fixed if you explicitly set the target, for example\n+`cargo build --target x86_64-pc-windows-msvc`\n+Without an explicit --target the flags will be passed to all compiler invocations (including build\n+scripts and proc macros), see [cargo docs on rustflags](https://doc.rust-lang.org/cargo/reference/config.html#buildrustflags)\n+\n+If you have dependencies using the `cc` crate, you will need to set these\n+environment variables:\n+```bat\n+set CC=clang-cl\n+set CXX=clang-cl\n+set CFLAGS=/clang:-flto=thin /clang:-fuse-ld=lld-link\n+set CXXFLAGS=/clang:-flto=thin /clang:-fuse-ld=lld-link\n+REM Needed because msvc's lib.exe crashes on LLVM LTO .obj files\n+set AR=llvm-lib\n+```\n+\n+If you are specifying lld-link as your linker by setting `linker = \"lld-link.exe\"` in your cargo config,\n+you may run into issues with some crates that compile code with separate cargo invocations. You should be\n+able to get around this problem by setting `-Clinker=lld-link` in RUSTFLAGS\n \n ## Toolchain Compatibility\n "}, {"sha": "a31e08f0d12a6f8c225010004fd2b4a77b9c544e", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -208,7 +208,7 @@ target | std | host | notes\n `aarch64-unknown-uefi` | * |  | ARM64 UEFI\n `aarch64-unknown-linux-gnu_ilp32` | \u2713 | \u2713 | ARM64 Linux (ILP32 ABI)\n `aarch64-unknown-netbsd` | \u2713 | \u2713 |\n-`aarch64-unknown-openbsd` | \u2713 | \u2713 | ARM64 OpenBSD\n+[`aarch64-unknown-openbsd`](platform-support/openbsd.md) | \u2713 | \u2713 | ARM64 OpenBSD\n `aarch64-unknown-redox` | ? |  | ARM64 Redox OS\n `aarch64-uwp-windows-msvc` | ? |  |\n `aarch64-wrs-vxworks` | ? |  |\n@@ -237,7 +237,7 @@ target | std | host | notes\n `i686-pc-windows-msvc` | \u2713 |  | 32-bit Windows XP support\n `i686-unknown-haiku` | \u2713 | \u2713 | 32-bit Haiku\n `i686-unknown-netbsd` | \u2713 | \u2713 | NetBSD/i386 with SSE2\n-`i686-unknown-openbsd` | \u2713 | \u2713 | 32-bit OpenBSD\n+[`i686-unknown-openbsd`](platform-support/openbsd.md) | \u2713 | \u2713 | 32-bit OpenBSD\n `i686-unknown-uefi` | * |  | 32-bit UEFI\n `i686-uwp-windows-gnu` | ? |  |\n `i686-uwp-windows-msvc` | ? |  |\n@@ -272,7 +272,7 @@ target | std | host | notes\n `s390x-unknown-linux-musl` |  |  | S390x Linux (kernel 2.6.32, MUSL)\n `sparc-unknown-linux-gnu` | \u2713 |  | 32-bit SPARC Linux\n `sparc64-unknown-netbsd` | \u2713 | \u2713 | NetBSD/sparc64\n-`sparc64-unknown-openbsd` | ? |  |\n+[`sparc64-unknown-openbsd`](platform-support/openbsd.md) | \u2713 | \u2713 | OpenBSD/sparc64\n `thumbv4t-none-eabi` | * |  | ARMv4T T32\n `thumbv7a-pc-windows-msvc` | ? |  |\n `thumbv7a-uwp-windows-msvc` | \u2713 |  |\n@@ -289,7 +289,7 @@ target | std | host | notes\n [`x86_64-unknown-none`](platform-support/x86_64-unknown-none.md) | * |  | Freestanding/bare-metal x86_64, softfloat\n `x86_64-unknown-none-hermitkernel` | ? |  | HermitCore kernel\n `x86_64-unknown-none-linuxkernel` | * |  | Linux kernel modules\n-`x86_64-unknown-openbsd` | \u2713 | \u2713 | 64-bit OpenBSD\n+[`x86_64-unknown-openbsd`](platform-support/openbsd.md) | \u2713 | \u2713 | 64-bit OpenBSD\n `x86_64-unknown-uefi` | * |  | 64-bit UEFI\n `x86_64-uwp-windows-gnu` | \u2713 |  |\n `x86_64-uwp-windows-msvc` | \u2713 |  |"}, {"sha": "b2ac776eada487fe5e2d548d00feb3c5672c2811", "filename": "src/doc/rustc/src/platform-support/openbsd.md", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fopenbsd.md", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fopenbsd.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fopenbsd.md?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -0,0 +1,56 @@\n+# \\*-unknown-openbsd\n+\n+**Tier: 3**\n+\n+[OpenBSD] multi-platform 4.4BSD-based UNIX-like operating system.\n+\n+[OpenBSD]: https://www.openbsd.org/\n+\n+The target names follow this format: `$ARCH-unknown-openbsd`, where `$ARCH` specifies the target processor architecture. The following targets are currently defined:\n+\n+|          Target name           | C++ library | OpenBSD Platform |\n+|--------------------------------|-------------|------------------|\n+| `aarch64-unknown-openbsd`      | libc++      | [64-bit ARM systems](https://www.openbsd.org/arm64.html)  |\n+| `i686-unknown-openbsd`         | libc++      | [Standard PC and clones based on the Intel i386 architecture and compatible processors](https://www.openbsd.org/i386.html) |\n+| `sparc64-unknown-openbsd`      | estdc++     | [Sun UltraSPARC and Fujitsu SPARC64 systems](https://www.openbsd.org/sparc64.html) |\n+| `x86_64-unknown-openbsd`       | libc++      | [AMD64-based systems](https://www.openbsd.org/amd64.html) |\n+\n+Note that all OS versions are *major* even if using X.Y notation (`6.8` and `6.9` are different major versions) and could be binary incompatibles (with breaking changes).\n+\n+\n+## Designated Developers\n+\n+- [@semarie](https://github.com/semarie), `semarie@openbsd.org`\n+- [lang/rust](https://cvsweb.openbsd.org/cgi-bin/cvsweb/ports/lang/rust/Makefile?rev=HEAD&content-type=text/x-cvsweb-markup) maintainer (see MAINTAINER variable)\n+\n+Fallback to ports@openbsd.org, OpenBSD third parties public mailing-list (with openbsd developers readers)\n+\n+\n+## Requirements\n+\n+These targets are natively compiled and could be cross-compiled.\n+C compiler toolchain is required for the purpose of building Rust and functional binaries.\n+\n+## Building\n+\n+The target can be built by enabling it for a `rustc` build.\n+\n+```toml\n+[build]\n+target = [\"$ARCH-unknown-openbsd\"]\n+\n+[target.$ARCH-unknown-openbsd]\n+cc = \"$ARCH-openbsd-cc\"\n+```\n+\n+## Cross-compilation\n+\n+These targets can be cross-compiled, but LLVM might not build out-of-box.\n+\n+## Testing\n+\n+The Rust testsuite could be run natively.\n+\n+## Building Rust programs\n+\n+Rust does not yet ship pre-compiled artifacts for these targets."}, {"sha": "45285c1f442c45d030c4d0578363e03ce869d571", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -11,7 +11,7 @@ arrayvec = { version = \"0.7\", default-features = false }\n askama = { version = \"0.11\", default-features = false, features = [\"config\"] }\n atty = \"0.2\"\n pulldown-cmark = { version = \"0.9\", default-features = false }\n-minifier = \"0.0.41\"\n+minifier = \"0.0.42\"\n rayon = \"1.5.1\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n serde_json = \"1.0\""}, {"sha": "f3c82c5f96816280de4c0de4e239561b3f5c9bdf", "filename": "src/test/ui/consts/const-block-const-bound.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Ftest%2Fui%2Fconsts%2Fconst-block-const-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Ftest%2Fui%2Fconsts%2Fconst-block-const-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-block-const-bound.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -16,8 +16,8 @@ impl !Drop for NonDrop {}\n fn main() {\n     const {\n         f(UnconstDrop);\n-        //~^ ERROR the trait bound `UnconstDrop: Drop` is not satisfied\n+        //~^ ERROR the trait bound `UnconstDrop: ~const Drop` is not satisfied\n         f(NonDrop);\n-        //~^ ERROR the trait bound `NonDrop: Drop` is not satisfied\n+        //~^ ERROR the trait bound `NonDrop: ~const Drop` is not satisfied\n     }\n }"}, {"sha": "b5f5694ba83284d7581f60aa9ce97636ac401e39", "filename": "src/test/ui/consts/const-block-const-bound.stderr", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Ftest%2Fui%2Fconsts%2Fconst-block-const-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Ftest%2Fui%2Fconsts%2Fconst-block-const-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-block-const-bound.stderr?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -1,8 +1,8 @@\n-error[E0277]: the trait bound `UnconstDrop: Drop` is not satisfied\n+error[E0277]: the trait bound `UnconstDrop: ~const Drop` is not satisfied\n   --> $DIR/const-block-const-bound.rs:18:11\n    |\n LL |         f(UnconstDrop);\n-   |         - ^^^^^^^^^^^ the trait `Drop` is not implemented for `UnconstDrop`\n+   |         - ^^^^^^^^^^^ expected an implementor of trait `~const Drop`\n    |         |\n    |         required by a bound introduced by this call\n    |\n@@ -11,16 +11,18 @@ note: required by a bound in `f`\n    |\n LL | const fn f<T: ~const Drop>(x: T) {}\n    |               ^^^^^^^^^^^ required by this bound in `f`\n-help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+help: consider borrowing here\n    |\n-LL | fn main() where UnconstDrop: Drop {\n-   |           +++++++++++++++++++++++\n+LL |         f(&UnconstDrop);\n+   |           +\n+LL |         f(&mut UnconstDrop);\n+   |           ++++\n \n-error[E0277]: the trait bound `NonDrop: Drop` is not satisfied\n+error[E0277]: the trait bound `NonDrop: ~const Drop` is not satisfied\n   --> $DIR/const-block-const-bound.rs:20:11\n    |\n LL |         f(NonDrop);\n-   |         - ^^^^^^^ the trait `Drop` is not implemented for `NonDrop`\n+   |         - ^^^^^^^ expected an implementor of trait `~const Drop`\n    |         |\n    |         required by a bound introduced by this call\n    |\n@@ -29,6 +31,12 @@ note: required by a bound in `f`\n    |\n LL | const fn f<T: ~const Drop>(x: T) {}\n    |               ^^^^^^^^^^^ required by this bound in `f`\n+help: consider borrowing here\n+   |\n+LL |         f(&NonDrop);\n+   |           +\n+LL |         f(&mut NonDrop);\n+   |           ++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7d924e2b7f366880b1243b3e3a3f6d56ab3b83a2", "filename": "src/test/ui/intrinsics/const-eval-select-bad.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -4,9 +4,9 @@ use std::intrinsics::const_eval_select;\n \n const fn not_fn_items() {\n     const_eval_select((), || {}, || {});\n-    //~^ ERROR expected a `FnOnce<()>` closure\n+    //~^ ERROR the trait bound\n     const_eval_select((), 42, 0xDEADBEEF);\n-    //~^ ERROR expected a `FnOnce<()>` closure\n+    //~^ ERROR the trait bound\n     //~| ERROR expected a `FnOnce<()>` closure\n }\n "}, {"sha": "083b00645388eb02d09352b79fe9634919134e14", "filename": "src/test/ui/intrinsics/const-eval-select-bad.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.stderr?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -1,28 +1,28 @@\n-error[E0277]: expected a `FnOnce<()>` closure, found `[closure@$DIR/const-eval-select-bad.rs:6:27: 6:32]`\n+error[E0277]: the trait bound `[closure@$DIR/const-eval-select-bad.rs:6:27: 6:32]: ~const FnOnce<()>` is not satisfied\n   --> $DIR/const-eval-select-bad.rs:6:27\n    |\n LL |     const_eval_select((), || {}, || {});\n    |     -----------------     ^^^^^ expected an `FnOnce<()>` closure, found `[closure@$DIR/const-eval-select-bad.rs:6:27: 6:32]`\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = help: the trait `FnOnce<()>` is not implemented for `[closure@$DIR/const-eval-select-bad.rs:6:27: 6:32]`\n+   = help: the trait `~const FnOnce<()>` is not implemented for `[closure@$DIR/const-eval-select-bad.rs:6:27: 6:32]`\n    = note: wrap the `[closure@$DIR/const-eval-select-bad.rs:6:27: 6:32]` in a closure with no arguments: `|| { /* code */ }`\n note: required by a bound in `const_eval_select`\n   --> $SRC_DIR/core/src/intrinsics.rs:LL:COL\n    |\n LL |     F: ~const FnOnce<ARG, Output = RET>,\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `const_eval_select`\n \n-error[E0277]: expected a `FnOnce<()>` closure, found `{integer}`\n+error[E0277]: the trait bound `{integer}: ~const FnOnce<()>` is not satisfied\n   --> $DIR/const-eval-select-bad.rs:8:27\n    |\n LL |     const_eval_select((), 42, 0xDEADBEEF);\n    |     -----------------     ^^ expected an `FnOnce<()>` closure, found `{integer}`\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = help: the trait `FnOnce<()>` is not implemented for `{integer}`\n+   = help: the trait `~const FnOnce<()>` is not implemented for `{integer}`\n    = note: wrap the `{integer}` in a closure with no arguments: `|| { /* code */ }`\n note: required by a bound in `const_eval_select`\n   --> $SRC_DIR/core/src/intrinsics.rs:LL:COL"}, {"sha": "99eacaa837f91a5bff0ef288af7b8081c0b71143", "filename": "src/test/ui/rfc-2632-const-trait-impl/assoc-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -1,5 +1,5 @@\n-// FIXME(fee1-dead): this should have a better error message\n #![feature(const_trait_impl)]\n+\n struct NonConstAdd(i32);\n \n impl std::ops::Add for NonConstAdd {\n@@ -16,7 +16,7 @@ trait Foo {\n \n impl const Foo for NonConstAdd {\n     type Bar = NonConstAdd;\n-    //~^ ERROR\n+    //~^ ERROR: cannot add `NonConstAdd` to `NonConstAdd` in const contexts\n }\n \n trait Baz {"}, {"sha": "429b9f3364be1d46e52faa50f0eee6a3c5a77fbd", "filename": "src/test/ui/rfc-2632-const-trait-impl/assoc-type.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.stderr?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -1,19 +1,19 @@\n-error[E0277]: cannot add `NonConstAdd` to `NonConstAdd`\n+error[E0277]: cannot add `NonConstAdd` to `NonConstAdd` in const contexts\n   --> $DIR/assoc-type.rs:18:16\n    |\n LL |     type Bar = NonConstAdd;\n    |                ^^^^^^^^^^^ no implementation for `NonConstAdd + NonConstAdd`\n    |\n-   = help: the trait `Add` is not implemented for `NonConstAdd`\n+   = help: the trait `~const Add` is not implemented for `NonConstAdd`\n note: required by a bound in `Foo::Bar`\n   --> $DIR/assoc-type.rs:14:15\n    |\n LL |     type Bar: ~const std::ops::Add;\n    |               ^^^^^^^^^^^^^^^^^^^^ required by this bound in `Foo::Bar`\n help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n    |\n-LL | impl const Foo for NonConstAdd where NonConstAdd: Add {\n-   |                                ++++++++++++++++++++++\n+LL | impl const Foo for NonConstAdd where NonConstAdd: ~const Add {\n+   |                                +++++++++++++++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "13cffaba91a1ddd191235bdd30143778818f63b9", "filename": "src/test/ui/rfc-2632-const-trait-impl/call-generic-method-nonconst.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-nonconst.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-nonconst.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-nonconst.stderr?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -1,12 +1,12 @@\n-error[E0277]: can't compare `S` with `S`\n+error[E0277]: can't compare `S` with `S` in const contexts\n   --> $DIR/call-generic-method-nonconst.rs:19:34\n    |\n LL | pub const EQ: bool = equals_self(&S);\n    |                      ----------- ^^ no implementation for `S == S`\n    |                      |\n    |                      required by a bound introduced by this call\n    |\n-   = help: the trait `PartialEq` is not implemented for `S`\n+   = help: the trait `~const PartialEq` is not implemented for `S`\n note: required by a bound in `equals_self`\n   --> $DIR/call-generic-method-nonconst.rs:12:25\n    |"}, {"sha": "df776908a03655a3de0bdf68b8d69931b9dc77a7", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-drop-fail.precise.stderr", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.precise.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.precise.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.precise.stderr?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -1,26 +1,32 @@\n-error[E0277]: the trait bound `NonTrivialDrop: Drop` is not satisfied\n+error[E0277]: the trait bound `NonTrivialDrop: ~const Drop` is not satisfied\n   --> $DIR/const-drop-fail.rs:44:5\n    |\n LL |         const _: () = check($exp);\n    |                       ----- required by a bound introduced by this call\n ...\n LL |     NonTrivialDrop,\n-   |     ^^^^^^^^^^^^^^ the trait `Drop` is not implemented for `NonTrivialDrop`\n+   |     ^^^^^^^^^^^^^^ expected an implementor of trait `~const Drop`\n    |\n note: required by a bound in `check`\n   --> $DIR/const-drop-fail.rs:35:19\n    |\n LL | const fn check<T: ~const Drop>(_: T) {}\n    |                   ^^^^^^^^^^^ required by this bound in `check`\n+help: consider borrowing here\n+   |\n+LL |     &NonTrivialDrop,\n+   |     +\n+LL |     &mut NonTrivialDrop,\n+   |     ++++\n \n-error[E0277]: the trait bound `NonTrivialDrop: Drop` is not satisfied in `ConstImplWithDropGlue`\n+error[E0277]: the trait bound `NonTrivialDrop: ~const Drop` is not satisfied in `ConstImplWithDropGlue`\n   --> $DIR/const-drop-fail.rs:46:5\n    |\n LL |         const _: () = check($exp);\n    |                       ----- required by a bound introduced by this call\n ...\n LL |     ConstImplWithDropGlue(NonTrivialDrop),\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ within `ConstImplWithDropGlue`, the trait `Drop` is not implemented for `NonTrivialDrop`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ within `ConstImplWithDropGlue`, the trait `~const Drop` is not implemented for `NonTrivialDrop`\n    |\n note: required because it appears within the type `ConstImplWithDropGlue`\n   --> $DIR/const-drop-fail.rs:17:8\n@@ -33,16 +39,16 @@ note: required by a bound in `check`\n LL | const fn check<T: ~const Drop>(_: T) {}\n    |                   ^^^^^^^^^^^ required by this bound in `check`\n \n-error[E0277]: the trait bound `NonTrivialDrop: A` is not satisfied\n+error[E0277]: the trait bound `ConstDropImplWithBounds<NonTrivialDrop>: ~const Drop` is not satisfied\n   --> $DIR/const-drop-fail.rs:48:5\n    |\n LL |         const _: () = check($exp);\n    |                       ----- required by a bound introduced by this call\n ...\n LL |     ConstDropImplWithBounds::<NonTrivialDrop>(PhantomData),\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `A` is not implemented for `NonTrivialDrop`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected an implementor of trait `~const Drop`\n    |\n-note: required because of the requirements on the impl of `Drop` for `ConstDropImplWithBounds<NonTrivialDrop>`\n+note: required because of the requirements on the impl of `~const Drop` for `ConstDropImplWithBounds<NonTrivialDrop>`\n   --> $DIR/const-drop-fail.rs:29:25\n    |\n LL | impl<T: ~const A> const Drop for ConstDropImplWithBounds<T> {\n@@ -52,6 +58,12 @@ note: required by a bound in `check`\n    |\n LL | const fn check<T: ~const Drop>(_: T) {}\n    |                   ^^^^^^^^^^^ required by this bound in `check`\n+help: consider borrowing here\n+   |\n+LL |     &ConstDropImplWithBounds::<NonTrivialDrop>(PhantomData),\n+   |     +\n+LL |     &mut ConstDropImplWithBounds::<NonTrivialDrop>(PhantomData),\n+   |     ++++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "df776908a03655a3de0bdf68b8d69931b9dc77a7", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-drop-fail.stock.stderr", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.stock.stderr?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -1,26 +1,32 @@\n-error[E0277]: the trait bound `NonTrivialDrop: Drop` is not satisfied\n+error[E0277]: the trait bound `NonTrivialDrop: ~const Drop` is not satisfied\n   --> $DIR/const-drop-fail.rs:44:5\n    |\n LL |         const _: () = check($exp);\n    |                       ----- required by a bound introduced by this call\n ...\n LL |     NonTrivialDrop,\n-   |     ^^^^^^^^^^^^^^ the trait `Drop` is not implemented for `NonTrivialDrop`\n+   |     ^^^^^^^^^^^^^^ expected an implementor of trait `~const Drop`\n    |\n note: required by a bound in `check`\n   --> $DIR/const-drop-fail.rs:35:19\n    |\n LL | const fn check<T: ~const Drop>(_: T) {}\n    |                   ^^^^^^^^^^^ required by this bound in `check`\n+help: consider borrowing here\n+   |\n+LL |     &NonTrivialDrop,\n+   |     +\n+LL |     &mut NonTrivialDrop,\n+   |     ++++\n \n-error[E0277]: the trait bound `NonTrivialDrop: Drop` is not satisfied in `ConstImplWithDropGlue`\n+error[E0277]: the trait bound `NonTrivialDrop: ~const Drop` is not satisfied in `ConstImplWithDropGlue`\n   --> $DIR/const-drop-fail.rs:46:5\n    |\n LL |         const _: () = check($exp);\n    |                       ----- required by a bound introduced by this call\n ...\n LL |     ConstImplWithDropGlue(NonTrivialDrop),\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ within `ConstImplWithDropGlue`, the trait `Drop` is not implemented for `NonTrivialDrop`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ within `ConstImplWithDropGlue`, the trait `~const Drop` is not implemented for `NonTrivialDrop`\n    |\n note: required because it appears within the type `ConstImplWithDropGlue`\n   --> $DIR/const-drop-fail.rs:17:8\n@@ -33,16 +39,16 @@ note: required by a bound in `check`\n LL | const fn check<T: ~const Drop>(_: T) {}\n    |                   ^^^^^^^^^^^ required by this bound in `check`\n \n-error[E0277]: the trait bound `NonTrivialDrop: A` is not satisfied\n+error[E0277]: the trait bound `ConstDropImplWithBounds<NonTrivialDrop>: ~const Drop` is not satisfied\n   --> $DIR/const-drop-fail.rs:48:5\n    |\n LL |         const _: () = check($exp);\n    |                       ----- required by a bound introduced by this call\n ...\n LL |     ConstDropImplWithBounds::<NonTrivialDrop>(PhantomData),\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `A` is not implemented for `NonTrivialDrop`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected an implementor of trait `~const Drop`\n    |\n-note: required because of the requirements on the impl of `Drop` for `ConstDropImplWithBounds<NonTrivialDrop>`\n+note: required because of the requirements on the impl of `~const Drop` for `ConstDropImplWithBounds<NonTrivialDrop>`\n   --> $DIR/const-drop-fail.rs:29:25\n    |\n LL | impl<T: ~const A> const Drop for ConstDropImplWithBounds<T> {\n@@ -52,6 +58,12 @@ note: required by a bound in `check`\n    |\n LL | const fn check<T: ~const Drop>(_: T) {}\n    |                   ^^^^^^^^^^^ required by this bound in `check`\n+help: consider borrowing here\n+   |\n+LL |     &ConstDropImplWithBounds::<NonTrivialDrop>(PhantomData),\n+   |     +\n+LL |     &mut ConstDropImplWithBounds::<NonTrivialDrop>(PhantomData),\n+   |     ++++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "76ea17159ac79d57e5c279b98264decb59afaf06", "filename": "src/test/ui/rfc-2632-const-trait-impl/default-method-body-is-const-body-checking.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-body-checking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-body-checking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-body-checking.rs?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -10,7 +10,7 @@ pub trait Foo {\n     #[default_method_body_is_const]\n     fn foo() {\n         foo::<()>();\n-        //~^ ERROR the trait bound `(): Tr` is not satisfied\n+        //~^ ERROR the trait bound `(): ~const Tr` is not satisfied\n     }\n }\n "}, {"sha": "05a74757b94f119dd90efdbbbc51f98c5983c372", "filename": "src/test/ui/rfc-2632-const-trait-impl/default-method-body-is-const-body-checking.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-body-checking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-body-checking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-body-checking.stderr?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -1,8 +1,8 @@\n-error[E0277]: the trait bound `(): Tr` is not satisfied\n+error[E0277]: the trait bound `(): ~const Tr` is not satisfied\n   --> $DIR/default-method-body-is-const-body-checking.rs:12:15\n    |\n LL |         foo::<()>();\n-   |               ^^ the trait `Tr` is not implemented for `()`\n+   |               ^^ the trait `~const Tr` is not implemented for `()`\n    |\n note: required by a bound in `foo`\n   --> $DIR/default-method-body-is-const-body-checking.rs:7:28\n@@ -11,8 +11,8 @@ LL | const fn foo<T>() where T: ~const Tr {}\n    |                            ^^^^^^^^^ required by this bound in `foo`\n help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n    |\n-LL | pub trait Foo where (): Tr {\n-   |               ++++++++++++\n+LL | pub trait Foo where (): ~const Tr {\n+   |               +++++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "903cd924ca55b466d3cf8d7f338fdde95993ef0f", "filename": "src/test/ui/rfc-2632-const-trait-impl/trait-where-clause.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftrait-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/009c1d02484dcc18e1596a33b3d8989a90361c89/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftrait-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftrait-where-clause.stderr?ref=009c1d02484dcc18e1596a33b3d8989a90361c89", "patch": "@@ -1,8 +1,8 @@\n-error[E0277]: the trait bound `T: Bar` is not satisfied\n+error[E0277]: the trait bound `T: ~const Bar` is not satisfied\n   --> $DIR/trait-where-clause.rs:14:5\n    |\n LL |     T::b();\n-   |     ^^^^ the trait `Bar` is not implemented for `T`\n+   |     ^^^^ the trait `~const Bar` is not implemented for `T`\n    |\n note: required by a bound in `Foo::b`\n   --> $DIR/trait-where-clause.rs:8:24\n@@ -11,14 +11,14 @@ LL |     fn b() where Self: ~const Bar;\n    |                        ^^^^^^^^^^ required by this bound in `Foo::b`\n help: consider further restricting this bound\n    |\n-LL | const fn test1<T: ~const Foo + Bar + Bar>() {\n-   |                                    +++++\n+LL | const fn test1<T: ~const Foo + Bar + ~const Bar>() {\n+   |                                    ++++++++++++\n \n-error[E0277]: the trait bound `T: Bar` is not satisfied\n+error[E0277]: the trait bound `T: ~const Bar` is not satisfied\n   --> $DIR/trait-where-clause.rs:16:5\n    |\n LL |     T::c::<T>();\n-   |     ^^^^^^^^^ the trait `Bar` is not implemented for `T`\n+   |     ^^^^^^^^^ the trait `~const Bar` is not implemented for `T`\n    |\n note: required by a bound in `Foo::c`\n   --> $DIR/trait-where-clause.rs:9:13\n@@ -27,8 +27,8 @@ LL |     fn c<T: ~const Bar>();\n    |             ^^^^^^^^^^ required by this bound in `Foo::c`\n help: consider further restricting this bound\n    |\n-LL | const fn test1<T: ~const Foo + Bar + Bar>() {\n-   |                                    +++++\n+LL | const fn test1<T: ~const Foo + Bar + ~const Bar>() {\n+   |                                    ++++++++++++\n \n error[E0277]: the trait bound `T: Bar` is not satisfied\n   --> $DIR/trait-where-clause.rs:28:5"}]}