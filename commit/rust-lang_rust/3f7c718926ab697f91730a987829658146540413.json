{"sha": "3f7c718926ab697f91730a987829658146540413", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmN2M3MTg5MjZhYjY5N2Y5MTczMGE5ODc4Mjk2NTgxNDY1NDA0MTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-20T22:04:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-20T22:04:21Z"}, "message": "Auto merge of #54125 - varkor:less-conservative-uninhabitedness-check, r=nikomatsakis\n\nLess conservative uninhabitedness check\n\nExtends the uninhabitedness check to structs, non-empty enums, tuples and arrays.\n\nPulled out of #47291 and #50262.\n\nFixes https://github.com/rust-lang/rust/issues/54586.\n\nr? @nikomatsakis", "tree": {"sha": "f783cd50ba1f9d98134a0d187deef48ef998818d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f783cd50ba1f9d98134a0d187deef48ef998818d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f7c718926ab697f91730a987829658146540413", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f7c718926ab697f91730a987829658146540413", "html_url": "https://github.com/rust-lang/rust/commit/3f7c718926ab697f91730a987829658146540413", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f7c718926ab697f91730a987829658146540413/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09d6ab90e556bf692ff3f8790d97b3ca4fee94b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/09d6ab90e556bf692ff3f8790d97b3ca4fee94b0", "html_url": "https://github.com/rust-lang/rust/commit/09d6ab90e556bf692ff3f8790d97b3ca4fee94b0"}, {"sha": "0a8b6967935c4da016afb4ee0b74e12e6e40ad63", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a8b6967935c4da016afb4ee0b74e12e6e40ad63", "html_url": "https://github.com/rust-lang/rust/commit/0a8b6967935c4da016afb4ee0b74e12e6e40ad63"}], "stats": {"total": 262, "additions": 157, "deletions": 105}, "files": [{"sha": "4881f10fac25e33b123e378ed6118e96da8ed844", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c718926ab697f91730a987829658146540413/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c718926ab697f91730a987829658146540413/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=3f7c718926ab697f91730a987829658146540413", "patch": "@@ -415,8 +415,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             args: I) -> CFGIndex {\n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n-        // FIXME(canndrew): This is_never should probably be an is_uninhabited.\n-        if self.tables.expr_ty(call_expr).is_never() {\n+        let m = self.tcx.hir().get_module_parent(call_expr.id);\n+        if self.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(call_expr)) {\n             self.add_unreachable_node()\n         } else {\n             ret"}, {"sha": "d1d2fa298a6ca13de98475637deb117528efb00f", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c718926ab697f91730a987829658146540413/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c718926ab697f91730a987829658146540413/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=3f7c718926ab697f91730a987829658146540413", "patch": "@@ -1197,8 +1197,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n \n             hir::ExprKind::Call(ref f, ref args) => {\n-                // FIXME(canndrew): This is_never should really be an is_uninhabited\n-                let succ = if self.tables.expr_ty(expr).is_never() {\n+                let m = self.ir.tcx.hir().get_module_parent(expr.id);\n+                let succ = if self.ir.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(expr)) {\n                     self.s.exit_ln\n                 } else {\n                     succ\n@@ -1208,8 +1208,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n \n             hir::ExprKind::MethodCall(.., ref args) => {\n-                // FIXME(canndrew): This is_never should really be an is_uninhabited\n-                let succ = if self.tables.expr_ty(expr).is_never() {\n+                let m = self.ir.tcx.hir().get_module_parent(expr.id);\n+                let succ = if self.ir.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(expr)) {\n                     self.s.exit_ln\n                 } else {\n                     succ"}, {"sha": "f4506c8e8197661a3377f9400b5909c12a046586", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c718926ab697f91730a987829658146540413/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c718926ab697f91730a987829658146540413/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=3f7c718926ab697f91730a987829658146540413", "patch": "@@ -191,7 +191,14 @@ fn layout_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         ty::tls::enter_context(&icx, |_| {\n             let cx = LayoutCx { tcx, param_env };\n-            cx.layout_raw_uncached(ty)\n+            let layout = cx.layout_raw_uncached(ty);\n+            // Type-level uninhabitedness should always imply ABI uninhabitedness.\n+            if let Ok(layout) = layout {\n+                if ty.conservative_is_privately_uninhabited(tcx) {\n+                    assert!(layout.abi.is_uninhabited());\n+                }\n+            }\n+            layout\n         })\n     })\n }\n@@ -205,12 +212,11 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n \n pub struct LayoutCx<'tcx, C> {\n     pub tcx: C,\n-    pub param_env: ty::ParamEnv<'tcx>\n+    pub param_env: ty::ParamEnv<'tcx>,\n }\n \n impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n-    fn layout_raw_uncached(&self, ty: Ty<'tcx>)\n-                           -> Result<&'tcx LayoutDetails, LayoutError<'tcx>> {\n+    fn layout_raw_uncached(&self, ty: Ty<'tcx>) -> Result<&'tcx LayoutDetails, LayoutError<'tcx>> {\n         let tcx = self.tcx;\n         let param_env = self.param_env;\n         let dl = self.data_layout();\n@@ -551,13 +557,19 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 let size = element.size.checked_mul(count, dl)\n                     .ok_or(LayoutError::SizeOverflow(ty))?;\n \n+                let abi = if count != 0 && ty.conservative_is_privately_uninhabited(tcx) {\n+                    Abi::Uninhabited\n+                } else {\n+                    Abi::Aggregate { sized: true }\n+                };\n+\n                 tcx.intern_layout(LayoutDetails {\n                     variants: Variants::Single { index: VariantIdx::new(0) },\n                     fields: FieldPlacement::Array {\n                         stride: element.size,\n                         count\n                     },\n-                    abi: Abi::Aggregate { sized: true },\n+                    abi,\n                     align: element.align,\n                     size\n                 })"}, {"sha": "2189267cb0b05e130438fb1feaa9ce2e8febe713", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c718926ab697f91730a987829658146540413/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c718926ab697f91730a987829658146540413/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=3f7c718926ab697f91730a987829658146540413", "patch": "@@ -1543,6 +1543,51 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    /// Checks whether a type is definitely uninhabited. This is\n+    /// conservative: for some types that are uninhabited we return `false`,\n+    /// but we only return `true` for types that are definitely uninhabited.\n+    /// `ty.conservative_is_privately_uninhabited` implies that any value of type `ty`\n+    /// will be `Abi::Uninhabited`. (Note that uninhabited types may have nonzero\n+    /// size, to account for partial initialisation. See #49298 for details.)\n+    pub fn conservative_is_privately_uninhabited(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+        // FIXME(varkor): we can make this less conversative by substituting concrete\n+        // type arguments.\n+        match self.sty {\n+            ty::Never => true,\n+            ty::Adt(def, _) if def.is_union() => {\n+                // For now, `union`s are never considered uninhabited.\n+                false\n+            }\n+            ty::Adt(def, _) => {\n+                // Any ADT is uninhabited if either:\n+                // (a) It has no variants (i.e. an empty `enum`);\n+                // (b) Each of its variants (a single one in the case of a `struct`) has at least\n+                //     one uninhabited field.\n+                def.variants.iter().all(|var| {\n+                    var.fields.iter().any(|field| {\n+                        tcx.type_of(field.did).conservative_is_privately_uninhabited(tcx)\n+                    })\n+                })\n+            }\n+            ty::Tuple(tys) => tys.iter().any(|ty| ty.conservative_is_privately_uninhabited(tcx)),\n+            ty::Array(ty, len) => {\n+                match len.assert_usize(tcx) {\n+                    // If the array is definitely non-empty, it's uninhabited if\n+                    // the type of its elements is uninhabited.\n+                    Some(n) if n != 0 => ty.conservative_is_privately_uninhabited(tcx),\n+                    _ => false\n+                }\n+            }\n+            ty::Ref(..) => {\n+                // References to uninitialised memory is valid for any type, including\n+                // uninhabited types, in unsafe code, so we treat all references as\n+                // inhabited.\n+                false\n+            }\n+            _ => false,\n+        }\n+    }\n+\n     pub fn is_primitive(&self) -> bool {\n         match self.sty {\n             Bool | Char | Int(_) | Uint(_) | Float(_) => true,"}, {"sha": "d205e4da798c4adb4b6256efd1c0dc979e9129c9", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c718926ab697f91730a987829658146540413/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c718926ab697f91730a987829658146540413/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=3f7c718926ab697f91730a987829658146540413", "patch": "@@ -1545,8 +1545,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 }\n             }\n             None => {\n-                // FIXME(canndrew): This is_never should probably be an is_uninhabited\n-                if !sig.output().is_never() {\n+                if !sig.output().conservative_is_privately_uninhabited(self.tcx()) {\n                     span_mirbug!(self, term, \"call to converging function {:?} w/o dest\", sig);\n                 }\n             }"}, {"sha": "146bf538306561f1859aa24a579d37e501642b14", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c718926ab697f91730a987829658146540413/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c718926ab697f91730a987829658146540413/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=3f7c718926ab697f91730a987829658146540413", "patch": "@@ -275,8 +275,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 exit_block.unit()\n             }\n             ExprKind::Call { ty, fun, args, from_hir_call } => {\n-                // FIXME(canndrew): This is_never should probably be an is_uninhabited\n-                let diverges = expr.ty.is_never();\n                 let intrinsic = match ty.sty {\n                     ty::FnDef(def_id, _) => {\n                         let f = ty.fn_sig(this.hir.tcx());\n@@ -332,7 +330,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             func: fun,\n                             args,\n                             cleanup: Some(cleanup),\n-                            destination: if diverges {\n+                            // FIXME(varkor): replace this with an uninhabitedness-based check.\n+                            // This requires getting access to the current module to call\n+                            // `tcx.is_ty_uninhabited_from`, which is currently tricky to do.\n+                            destination: if expr.ty.is_never() {\n                                 None\n                             } else {\n                                 Some((destination.clone(), success))\n@@ -421,8 +422,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 });\n \n                 let rvalue = unpack!(block = this.as_local_rvalue(block, expr));\n-                this.cfg\n-                    .push_assign(block, source_info, destination, rvalue);\n+                this.cfg.push_assign(block, source_info, destination, rvalue);\n                 block.unit()\n             }\n         };"}, {"sha": "a251b723d61fcff12f6f57ea702431e36ad4c4f6", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c718926ab697f91730a987829658146540413/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c718926ab697f91730a987829658146540413/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=3f7c718926ab697f91730a987829658146540413", "patch": "@@ -230,7 +230,11 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                 let scrutinee_is_uninhabited = if self.tcx.features().exhaustive_patterns {\n                     self.tcx.is_ty_uninhabited_from(module, pat_ty)\n                 } else {\n-                    self.conservative_is_uninhabited(pat_ty)\n+                    match pat_ty.sty {\n+                        ty::Never => true,\n+                        ty::Adt(def, _) => def.variants.is_empty(),\n+                        _ => false\n+                    }\n                 };\n                 if !scrutinee_is_uninhabited {\n                     // We know the type is inhabited, so this must be wrong\n@@ -258,15 +262,6 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n         })\n     }\n \n-    fn conservative_is_uninhabited(&self, scrutinee_ty: Ty<'tcx>) -> bool {\n-        // \"rustc-1.0-style\" uncontentious uninhabitableness check\n-        match scrutinee_ty.sty {\n-            ty::Never => true,\n-            ty::Adt(def, _) => def.variants.is_empty(),\n-            _ => false\n-        }\n-    }\n-\n     fn check_irrefutable(&self, pat: &'tcx Pat, origin: &str) {\n         let module = self.tcx.hir().get_module_parent(pat.id);\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {"}, {"sha": "347e795c4f71d6b54b5f44b3f2061e6fc87dcc22", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c718926ab697f91730a987829658146540413/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c718926ab697f91730a987829658146540413/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=3f7c718926ab697f91730a987829658146540413", "patch": "@@ -729,6 +729,9 @@ impl TcpListener {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n+        // On WASM, `TcpStream` is uninhabited (as it's unsupported) and so\n+        // the `a` variable here is technically unused.\n+        #[cfg_attr(target_arch = \"wasm32\", allow(unused_variables))]\n         self.0.accept().map(|(a, b)| (TcpStream(a), b))\n     }\n "}, {"sha": "ab42b2eff99f858bffac19b006b2e23c015fa4ee", "filename": "src/test/debuginfo/nil-enum.rs", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/09d6ab90e556bf692ff3f8790d97b3ca4fee94b0/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d6ab90e556bf692ff3f8790d97b3ca4fee94b0/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs?ref=09d6ab90e556bf692ff3f8790d97b3ca4fee94b0", "patch": "@@ -1,55 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// NOTE Instantiating an empty enum is UB. This test may break in the future.\n-\n-// LLDB can't handle zero-sized values\n-// ignore-lldb\n-\n-\n-// Require LLVM with DW_TAG_variant_part and a gdb that can read it.\n-// gdb 8.2.0 crashes on this test case, see\n-// https://sourceware.org/bugzilla/show_bug.cgi?id=23626\n-// This will be fixed in the next release, which will be >= 8.2.1.\n-// min-system-llvm-version: 7.0\n-// min-gdb-version: 8.2.1\n-\n-// compile-flags:-g\n-// gdb-command:run\n-\n-// gdb-command:print first\n-// gdbr-check:$1 = nil_enum::ANilEnum {<No data fields>}\n-\n-// gdb-command:print second\n-// gdbr-check:$2 = nil_enum::AnotherNilEnum {<No data fields>}\n-\n-#![allow(unused_variables)]\n-#![feature(omit_gdb_pretty_printer_section)]\n-#![feature(maybe_uninit)]\n-#![omit_gdb_pretty_printer_section]\n-\n-use std::mem::MaybeUninit;\n-\n-enum ANilEnum {}\n-enum AnotherNilEnum {}\n-\n-// This test relies on gdbg printing the string \"{<No data fields>}\" for empty\n-// structs (which may change some time)\n-// The error from gdbr is expected since nil enums are not supposed to exist.\n-fn main() {\n-    unsafe {\n-        let first: ANilEnum = MaybeUninit::uninitialized().into_inner();\n-        let second: AnotherNilEnum = MaybeUninit::uninitialized().into_inner();\n-\n-        zzz(); // #break\n-    }\n-}\n-\n-fn zzz() {()}"}, {"sha": "904a9c43c1bccc7487b2053c017ae88369f731e1", "filename": "src/test/mir-opt/uninhabited-enum.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c718926ab697f91730a987829658146540413/src%2Ftest%2Fmir-opt%2Funinhabited-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c718926ab697f91730a987829658146540413/src%2Ftest%2Fmir-opt%2Funinhabited-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funinhabited-enum.rs?ref=3f7c718926ab697f91730a987829658146540413", "patch": "@@ -0,0 +1,37 @@\n+#![feature(never_type)]\n+\n+pub enum Void {}\n+\n+#[no_mangle]\n+pub fn process_never(input: *const !) {\n+   let _input = unsafe { &*input };\n+}\n+\n+#[no_mangle]\n+pub fn process_void(input: *const Void) {\n+   let _input = unsafe { &*input };\n+   // In the future, this should end with `unreachable`, but we currently only do\n+   // unreachability analysis for `!`.\n+}\n+\n+fn main() {}\n+\n+// END RUST SOURCE\n+//\n+// START rustc.process_never.SimplifyLocals.after.mir\n+// bb0: {\n+//     StorageLive(_2);\n+//     _2 = &(*_1);\n+//     StorageDead(_2);\n+//     unreachable;\n+// }\n+// END rustc.process_never.SimplifyLocals.after.mir\n+//\n+// START rustc.process_void.SimplifyLocals.after.mir\n+// bb0: {\n+//     StorageLive(_2);\n+//     _2 = &(*_1);\n+//     StorageDead(_2);\n+//     return;\n+// }\n+// END rustc.process_void.SimplifyLocals.after.mir"}, {"sha": "f595bb0da9a27737fde9c6a50011d387bd2da612", "filename": "src/test/run-pass/binding/empty-types-in-patterns.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c718926ab697f91730a987829658146540413/src%2Ftest%2Frun-pass%2Fbinding%2Fempty-types-in-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c718926ab697f91730a987829658146540413/src%2Ftest%2Frun-pass%2Fbinding%2Fempty-types-in-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinding%2Fempty-types-in-patterns.rs?ref=3f7c718926ab697f91730a987829658146540413", "patch": "@@ -14,6 +14,7 @@\n #![feature(slice_patterns)]\n #![allow(unreachable_patterns)]\n #![allow(unreachable_code)]\n+#![allow(unused_variables)]\n \n #[allow(dead_code)]\n fn foo(z: !) {"}, {"sha": "5a5a2adc124e63ec4c4ccb5fee3b658647ea2245", "filename": "src/test/run-pass/issues/issue-41696.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c718926ab697f91730a987829658146540413/src%2Ftest%2Frun-pass%2Fissues%2Fissue-41696.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c718926ab697f91730a987829658146540413/src%2Ftest%2Frun-pass%2Fissues%2Fissue-41696.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-41696.rs?ref=3f7c718926ab697f91730a987829658146540413", "patch": "@@ -11,6 +11,7 @@\n // run-pass\n #![allow(dead_code)]\n #![allow(unused_variables)]\n+#![recursion_limit = \"128\"]\n // this used to cause exponential code-size blowup during LLVM passes.\n \n #![feature(test)]"}, {"sha": "42cba02f579b781cdc6c369cba77a15b6af10c37", "filename": "src/test/ui/consts/const-eval/ub-uninhabit.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c718926ab697f91730a987829658146540413/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c718926ab697f91730a987829658146540413/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs?ref=3f7c718926ab697f91730a987829658146540413", "patch": "@@ -1,13 +1,3 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n #![feature(const_transmute)]\n #![allow(const_err)] // make sure we cannot allow away the errors tested here\n \n@@ -16,14 +6,18 @@ use std::mem;\n #[derive(Copy, Clone)]\n enum Bar {}\n \n-const BAD_BAD_BAD: Bar = unsafe { mem::transmute(()) };\n+union TransmuteUnion<A: Clone + Copy, B: Clone + Copy> {\n+    a: A,\n+    b: B,\n+}\n+\n+const BAD_BAD_BAD: Bar = unsafe { (TransmuteUnion::<(), Bar> { a: () }).b };\n //~^ ERROR it is undefined behavior to use this value\n \n const BAD_BAD_REF: &Bar = unsafe { mem::transmute(1usize) };\n //~^ ERROR it is undefined behavior to use this value\n \n-const BAD_BAD_ARRAY: [Bar; 1] = unsafe { mem::transmute(()) };\n+const BAD_BAD_ARRAY: [Bar; 1] = unsafe { (TransmuteUnion::<(), [Bar; 1]> { a: () }).b };\n //~^ ERROR it is undefined behavior to use this value\n \n-fn main() {\n-}\n+fn main() {}"}, {"sha": "c8842ecc23ca29054bdc396bce1532c761c0a2a1", "filename": "src/test/ui/consts/const-eval/ub-uninhabit.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c718926ab697f91730a987829658146540413/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c718926ab697f91730a987829658146540413/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr?ref=3f7c718926ab697f91730a987829658146540413", "patch": "@@ -1,24 +1,24 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-uninhabit.rs:19:1\n+  --> $DIR/ub-uninhabit.rs:14:1\n    |\n-LL | const BAD_BAD_BAD: Bar = unsafe { mem::transmute(()) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type\n+LL | const BAD_BAD_BAD: Bar = unsafe { (TransmuteUnion::<(), Bar> { a: () }).b };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-uninhabit.rs:22:1\n+  --> $DIR/ub-uninhabit.rs:17:1\n    |\n LL | const BAD_BAD_REF: &Bar = unsafe { mem::transmute(1usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type at .<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-uninhabit.rs:25:1\n+  --> $DIR/ub-uninhabit.rs:20:1\n    |\n-LL | const BAD_BAD_ARRAY: [Bar; 1] = unsafe { mem::transmute(()) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type at [0]\n+LL | const BAD_BAD_ARRAY: [Bar; 1] = unsafe { (TransmuteUnion::<(), [Bar; 1]> { a: () }).b };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "b9d181a76dd9bb5c9b137ab9af64b06fd3882295", "filename": "src/test/ui/consts/validate_never_arrays.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c718926ab697f91730a987829658146540413/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c718926ab697f91730a987829658146540413/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.stderr?ref=3f7c718926ab697f91730a987829658146540413", "patch": "@@ -2,7 +2,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/validate_never_arrays.rs:3:1\n    |\n LL | const FOO: &[!; 1] = unsafe { &*(1_usize as *const [!; 1]) }; //~ ERROR undefined behavior\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type at .<deref>[0]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type at .<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "9fe8a5c832c5a6e1e47cdd78054d3ebe59f20d34", "filename": "src/test/ui/uninhabited/privately-uninhabited-dead-code.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c718926ab697f91730a987829658146540413/src%2Ftest%2Fui%2Funinhabited%2Fprivately-uninhabited-dead-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c718926ab697f91730a987829658146540413/src%2Ftest%2Fui%2Funinhabited%2Fprivately-uninhabited-dead-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Fprivately-uninhabited-dead-code.rs?ref=3f7c718926ab697f91730a987829658146540413", "patch": "@@ -0,0 +1,20 @@\n+// compile-pass\n+\n+#![deny(unused_variables)]\n+\n+mod foo {\n+    enum Bar {}\n+\n+    #[allow(dead_code)]\n+    pub struct Foo {\n+        value: Bar, // \"privately\" uninhabited\n+    }\n+\n+    pub fn give_foo() -> Foo { panic!() }\n+}\n+\n+fn main() {\n+    let a = 42;\n+    foo::give_foo();\n+    println!(\"Hello, {}\", a); // ok: we can't tell that this code is dead\n+}"}]}