{"sha": "8aa13289b5fbfcbdf5afb19d15a41a15d8f8aa22", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhYTEzMjg5YjVmYmZjYmRmNWFmYjE5ZDE1YTQxYTE1ZDhmOGFhMjI=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-15T08:44:23Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-17T19:07:50Z"}, "message": "Make stuff private.", "tree": {"sha": "f96d6e669c8ba3a3ffeedbfe26e5e3a0e217d71b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f96d6e669c8ba3a3ffeedbfe26e5e3a0e217d71b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8aa13289b5fbfcbdf5afb19d15a41a15d8f8aa22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8aa13289b5fbfcbdf5afb19d15a41a15d8f8aa22", "html_url": "https://github.com/rust-lang/rust/commit/8aa13289b5fbfcbdf5afb19d15a41a15d8f8aa22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8aa13289b5fbfcbdf5afb19d15a41a15d8f8aa22/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5557407fbb322dc1265ba3c05cd5474a20c2e1d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5557407fbb322dc1265ba3c05cd5474a20c2e1d3", "html_url": "https://github.com/rust-lang/rust/commit/5557407fbb322dc1265ba3c05cd5474a20c2e1d3"}], "stats": {"total": 43, "additions": 19, "deletions": 24}, "files": [{"sha": "1279ae2059baa2763a3ceaeb30569ce48bb2e415", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8aa13289b5fbfcbdf5afb19d15a41a15d8f8aa22/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aa13289b5fbfcbdf5afb19d15a41a15d8f8aa22/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=8aa13289b5fbfcbdf5afb19d15a41a15d8f8aa22", "patch": "@@ -62,7 +62,7 @@ use std::sync::Arc;\n \n #[macro_use]\n mod plumbing;\n-pub use self::plumbing::CycleError;\n+pub(crate) use self::plumbing::CycleError;\n use self::plumbing::*;\n \n mod stats;"}, {"sha": "0bfcae5fa2e6692a54857b30abf9d4f8eb5710ee", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8aa13289b5fbfcbdf5afb19d15a41a15d8f8aa22/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aa13289b5fbfcbdf5afb19d15a41a15d8f8aa22/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=8aa13289b5fbfcbdf5afb19d15a41a15d8f8aa22", "patch": "@@ -30,11 +30,11 @@ use std::ptr;\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n pub(crate) struct QueryStateShard<'tcx, K, C> {\n-    pub(super) cache: C,\n-    pub(super) active: FxHashMap<K, QueryResult<'tcx>>,\n+    cache: C,\n+    active: FxHashMap<K, QueryResult<'tcx>>,\n \n     /// Used to generate unique ids for active jobs.\n-    pub(super) jobs: u32,\n+    jobs: u32,\n }\n \n impl<'tcx, K, C> QueryStateShard<'tcx, K, C> {\n@@ -50,8 +50,8 @@ impl<'tcx, K, C: Default> Default for QueryStateShard<'tcx, K, C> {\n }\n \n pub(crate) struct QueryState<'tcx, C: QueryCache> {\n-    pub(super) cache: C,\n-    pub(super) shards: Sharded<QueryStateShard<'tcx, C::Key, C::Sharded>>,\n+    cache: C,\n+    shards: Sharded<QueryStateShard<'tcx, C::Key, C::Sharded>>,\n     #[cfg(debug_assertions)]\n     pub(super) cache_hits: AtomicUsize,\n }\n@@ -75,7 +75,7 @@ impl<'tcx, C: QueryCache> QueryState<'tcx, C> {\n }\n \n /// Indicates the state of a query for a given key in a query map.\n-pub(super) enum QueryResult<'tcx> {\n+enum QueryResult<'tcx> {\n     /// An already executing query. The query job can be used to await for its completion.\n     Started(QueryJob<'tcx>),\n \n@@ -85,15 +85,15 @@ pub(super) enum QueryResult<'tcx> {\n }\n \n impl<'tcx, C: QueryCache> QueryState<'tcx, C> {\n-    pub fn iter_results<R>(\n+    pub(super) fn iter_results<R>(\n         &self,\n         f: impl for<'a> FnOnce(\n             Box<dyn Iterator<Item = (&'a C::Key, &'a C::Value, DepNodeIndex)> + 'a>,\n         ) -> R,\n     ) -> R {\n         self.cache.iter(&self.shards, |shard| &mut shard.cache, f)\n     }\n-    pub fn all_inactive(&self) -> bool {\n+    pub(super) fn all_inactive(&self) -> bool {\n         let shards = self.shards.lock_shards();\n         shards.iter().all(|shard| shard.active.is_empty())\n     }\n@@ -142,13 +142,13 @@ impl<'tcx, C: QueryCache> Default for QueryState<'tcx, C> {\n /// Values used when checking a query cache which can be reused on a cache-miss to execute the query.\n pub(crate) struct QueryLookup<'tcx, K, C> {\n     pub(super) key_hash: u64,\n-    pub(super) shard: usize,\n+    shard: usize,\n     pub(super) lock: LockGuard<'tcx, QueryStateShard<'tcx, K, C>>,\n }\n \n /// A type representing the responsibility to execute the job in the `job` field.\n /// This will poison the relevant query if dropped.\n-pub(super) struct JobOwner<'tcx, C>\n+struct JobOwner<'tcx, C>\n where\n     C: QueryCache,\n     C::Key: Eq + Hash + Clone + Debug,\n@@ -174,7 +174,7 @@ where\n     /// This function is inlined because that results in a noticeable speed-up\n     /// for some compile-time benchmarks.\n     #[inline(always)]\n-    pub(super) fn try_start<Q>(\n+    fn try_start<Q>(\n         tcx: TyCtxt<'tcx>,\n         span: Span,\n         key: &C::Key,\n@@ -262,12 +262,7 @@ where\n     /// Completes the query by updating the query cache with the `result`,\n     /// signals the waiter and forgets the JobOwner, so it won't poison the query\n     #[inline(always)]\n-    pub(super) fn complete(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        result: &C::Value,\n-        dep_node_index: DepNodeIndex,\n-    ) {\n+    fn complete(self, tcx: TyCtxt<'tcx>, result: &C::Value, dep_node_index: DepNodeIndex) {\n         // We can move out of `self` here because we `mem::forget` it below\n         let key = unsafe { ptr::read(&self.key) };\n         let state = self.state;\n@@ -327,14 +322,14 @@ where\n }\n \n #[derive(Clone)]\n-pub struct CycleError<'tcx> {\n+pub(crate) struct CycleError<'tcx> {\n     /// The query and related span that uses the cycle.\n     pub(super) usage: Option<(Span, Query<'tcx>)>,\n     pub(super) cycle: Vec<QueryInfo<'tcx>>,\n }\n \n /// The result of `try_start`.\n-pub(super) enum TryGetJob<'tcx, C: QueryCache>\n+enum TryGetJob<'tcx, C: QueryCache>\n where\n     C::Key: Eq + Hash + Clone + Debug,\n     C::Value: Clone,\n@@ -357,7 +352,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// new query job while it executes. It returns the diagnostics\n     /// captured during execution and the actual result.\n     #[inline(always)]\n-    pub(super) fn start_query<F, R>(\n+    fn start_query<F, R>(\n         self,\n         token: QueryJobId,\n         diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n@@ -529,7 +524,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline(always)]\n-    pub(super) fn try_execute_query<Q: QueryDescription<'tcx> + 'tcx>(\n+    fn try_execute_query<Q: QueryDescription<'tcx> + 'tcx>(\n         self,\n         span: Span,\n         key: Q::Key,\n@@ -1136,7 +1131,7 @@ macro_rules! define_queries_struct {\n         }\n \n         impl<$tcx> Queries<$tcx> {\n-            pub fn new(\n+            pub(crate) fn new(\n                 providers: IndexVec<CrateNum, Providers<$tcx>>,\n                 fallback_extern_providers: Providers<$tcx>,\n                 on_disk_cache: OnDiskCache<'tcx>,\n@@ -1149,7 +1144,7 @@ macro_rules! define_queries_struct {\n                 }\n             }\n \n-            pub fn try_collect_active_jobs(\n+            pub(crate) fn try_collect_active_jobs(\n                 &self\n             ) -> Option<FxHashMap<QueryJobId, QueryJobInfo<'tcx>>> {\n                 let mut jobs = FxHashMap::default();"}]}