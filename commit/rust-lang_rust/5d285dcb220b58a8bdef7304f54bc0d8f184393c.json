{"sha": "5d285dcb220b58a8bdef7304f54bc0d8f184393c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkMjg1ZGNiMjIwYjU4YThiZGVmNzMwNGY1NGJjMGQ4ZjE4NDM5M2M=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-02-20T09:49:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-20T09:49:13Z"}, "message": "Rollup merge of #69266 - Zoxc:fix-source-map-race, r=wesleywiser\n\nFix race condition when allocating source files in SourceMap\n\nThis makes allocating address space in the source map an atomic operation. `rustc` does not currently do this in parallel, so this bug can't trigger, but parsing files in parallel could trigger it, and that is something we want to do.\n\nFixes https://github.com/rust-lang/rust/issues/69261.\n\nr? @wesleywiser", "tree": {"sha": "19b3e7c420aa24223fe314bcaea5d4e78b91bb60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19b3e7c420aa24223fe314bcaea5d4e78b91bb60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d285dcb220b58a8bdef7304f54bc0d8f184393c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeTlYZCRBK7hj4Ov3rIwAAdHIIAHxq7SHe6Kau7QBjVN/wnqZ6\nrDiByXZw9PUc/opt2DGY7PXSfkXM7Pju2hUjFDUjf5X2Au2JPvOzc1qARYFxvZCq\nX1sEU9gHHTeXvHaAaSN8bQrZxhp6Z2yVou5kqp+Kx2WSxXGdRRNYA3IbxcOYI22b\nd9F1sYFspZ/Gg0jYYgeyVmy62qfk2eZh4juFkw5va7HXuxKWVL52x24JE/mrLdxZ\njSjMPt3wag83gojaMk24k4sQq2kv63sqXiZ6uQhjFCv+ANsSZoCGZSVj1FkCScLV\na5Pwu+XyU+2Aue3pGLULQarmborI1BGwxeJ8XhAJL4U0jJX/zCCFJujjHxsKGOo=\n=PtaC\n-----END PGP SIGNATURE-----\n", "payload": "tree 19b3e7c420aa24223fe314bcaea5d4e78b91bb60\nparent d96951f5543869567e30ab1c63c0ac44d0d74c30\nparent 437f56edf43182955bb099a0d95970d63492196c\nauthor Dylan DPC <dylan.dpc@gmail.com> 1582192153 +0100\ncommitter GitHub <noreply@github.com> 1582192153 +0100\n\nRollup merge of #69266 - Zoxc:fix-source-map-race, r=wesleywiser\n\nFix race condition when allocating source files in SourceMap\n\nThis makes allocating address space in the source map an atomic operation. `rustc` does not currently do this in parallel, so this bug can't trigger, but parsing files in parallel could trigger it, and that is something we want to do.\n\nFixes https://github.com/rust-lang/rust/issues/69261.\n\nr? @wesleywiser\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d285dcb220b58a8bdef7304f54bc0d8f184393c", "html_url": "https://github.com/rust-lang/rust/commit/5d285dcb220b58a8bdef7304f54bc0d8f184393c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d285dcb220b58a8bdef7304f54bc0d8f184393c/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d96951f5543869567e30ab1c63c0ac44d0d74c30", "url": "https://api.github.com/repos/rust-lang/rust/commits/d96951f5543869567e30ab1c63c0ac44d0d74c30", "html_url": "https://github.com/rust-lang/rust/commit/d96951f5543869567e30ab1c63c0ac44d0d74c30"}, {"sha": "437f56edf43182955bb099a0d95970d63492196c", "url": "https://api.github.com/repos/rust-lang/rust/commits/437f56edf43182955bb099a0d95970d63492196c", "html_url": "https://github.com/rust-lang/rust/commit/437f56edf43182955bb099a0d95970d63492196c"}], "stats": {"total": 66, "additions": 47, "deletions": 19}, "files": [{"sha": "f9f3a9003117ff6113994ee2cb64e8ceac32270d", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5d285dcb220b58a8bdef7304f54bc0d8f184393c/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d285dcb220b58a8bdef7304f54bc0d8f184393c/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=5d285dcb220b58a8bdef7304f54bc0d8f184393c", "patch": "@@ -1075,7 +1075,7 @@ impl SourceFile {\n         unmapped_path: FileName,\n         mut src: String,\n         start_pos: BytePos,\n-    ) -> Result<SourceFile, OffsetOverflowError> {\n+    ) -> Self {\n         let normalized_pos = normalize_src(&mut src, start_pos);\n \n         let src_hash = {\n@@ -1089,14 +1089,12 @@ impl SourceFile {\n             hasher.finish::<u128>()\n         };\n         let end_pos = start_pos.to_usize() + src.len();\n-        if end_pos > u32::max_value() as usize {\n-            return Err(OffsetOverflowError);\n-        }\n+        assert!(end_pos <= u32::max_value() as usize);\n \n         let (lines, multibyte_chars, non_narrow_chars) =\n             analyze_source_file::analyze_source_file(&src[..], start_pos);\n \n-        Ok(SourceFile {\n+        SourceFile {\n             name,\n             name_was_remapped,\n             unmapped_path: Some(unmapped_path),\n@@ -1111,7 +1109,7 @@ impl SourceFile {\n             non_narrow_chars,\n             normalized_pos,\n             name_hash,\n-        })\n+        }\n     }\n \n     /// Returns the `BytePos` of the beginning of the current line."}, {"sha": "31d397f040cb0cd6fc94635cc55a7bf585d68677", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 43, "deletions": 13, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5d285dcb220b58a8bdef7304f54bc0d8f184393c/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d285dcb220b58a8bdef7304f54bc0d8f184393c/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=5d285dcb220b58a8bdef7304f54bc0d8f184393c", "patch": "@@ -12,10 +12,12 @@ pub use crate::*;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::StableHasher;\n-use rustc_data_structures::sync::{Lock, LockGuard, Lrc, MappedLockGuard};\n+use rustc_data_structures::sync::{AtomicU32, Lock, LockGuard, Lrc, MappedLockGuard};\n use std::cmp;\n+use std::convert::TryFrom;\n use std::hash::Hash;\n use std::path::{Path, PathBuf};\n+use std::sync::atomic::Ordering;\n \n use log::debug;\n use std::env;\n@@ -131,6 +133,9 @@ pub(super) struct SourceMapFiles {\n }\n \n pub struct SourceMap {\n+    /// The address space below this value is currently used by the files in the source map.\n+    used_address_space: AtomicU32,\n+\n     files: Lock<SourceMapFiles>,\n     file_loader: Box<dyn FileLoader + Sync + Send>,\n     // This is used to apply the file path remapping as specified via\n@@ -140,14 +145,24 @@ pub struct SourceMap {\n \n impl SourceMap {\n     pub fn new(path_mapping: FilePathMapping) -> SourceMap {\n-        SourceMap { files: Default::default(), file_loader: Box::new(RealFileLoader), path_mapping }\n+        SourceMap {\n+            used_address_space: AtomicU32::new(0),\n+            files: Default::default(),\n+            file_loader: Box::new(RealFileLoader),\n+            path_mapping,\n+        }\n     }\n \n     pub fn with_file_loader(\n         file_loader: Box<dyn FileLoader + Sync + Send>,\n         path_mapping: FilePathMapping,\n     ) -> SourceMap {\n-        SourceMap { files: Default::default(), file_loader, path_mapping }\n+        SourceMap {\n+            used_address_space: AtomicU32::new(0),\n+            files: Default::default(),\n+            file_loader,\n+            path_mapping,\n+        }\n     }\n \n     pub fn path_mapping(&self) -> &FilePathMapping {\n@@ -194,12 +209,25 @@ impl SourceMap {\n         self.files.borrow().stable_id_to_source_file.get(&stable_id).map(|sf| sf.clone())\n     }\n \n-    fn next_start_pos(&self) -> usize {\n-        match self.files.borrow().source_files.last() {\n-            None => 0,\n-            // Add one so there is some space between files. This lets us distinguish\n-            // positions in the `SourceMap`, even in the presence of zero-length files.\n-            Some(last) => last.end_pos.to_usize() + 1,\n+    fn allocate_address_space(&self, size: usize) -> Result<usize, OffsetOverflowError> {\n+        let size = u32::try_from(size).map_err(|_| OffsetOverflowError)?;\n+\n+        loop {\n+            let current = self.used_address_space.load(Ordering::Relaxed);\n+            let next = current\n+                .checked_add(size)\n+                // Add one so there is some space between files. This lets us distinguish\n+                // positions in the `SourceMap`, even in the presence of zero-length files.\n+                .and_then(|next| next.checked_add(1))\n+                .ok_or(OffsetOverflowError)?;\n+\n+            if self\n+                .used_address_space\n+                .compare_exchange(current, next, Ordering::Relaxed, Ordering::Relaxed)\n+                .is_ok()\n+            {\n+                return Ok(usize::try_from(current).unwrap());\n+            }\n         }\n     }\n \n@@ -218,8 +246,6 @@ impl SourceMap {\n         filename: FileName,\n         src: String,\n     ) -> Result<Lrc<SourceFile>, OffsetOverflowError> {\n-        let start_pos = self.next_start_pos();\n-\n         // The path is used to determine the directory for loading submodules and\n         // include files, so it must be before remapping.\n         // Note that filename may not be a valid path, eg it may be `<anon>` etc,\n@@ -241,13 +267,15 @@ impl SourceMap {\n         let lrc_sf = match self.source_file_by_stable_id(file_id) {\n             Some(lrc_sf) => lrc_sf,\n             None => {\n+                let start_pos = self.allocate_address_space(src.len())?;\n+\n                 let source_file = Lrc::new(SourceFile::new(\n                     filename,\n                     was_remapped,\n                     unmapped_path,\n                     src,\n                     Pos::from_usize(start_pos),\n-                )?);\n+                ));\n \n                 let mut files = self.files.borrow_mut();\n \n@@ -277,7 +305,9 @@ impl SourceMap {\n         mut file_local_non_narrow_chars: Vec<NonNarrowChar>,\n         mut file_local_normalized_pos: Vec<NormalizedPos>,\n     ) -> Lrc<SourceFile> {\n-        let start_pos = self.next_start_pos();\n+        let start_pos = self\n+            .allocate_address_space(source_len)\n+            .expect(\"not enough address space for imported source file\");\n \n         let end_pos = Pos::from_usize(start_pos + source_len);\n         let start_pos = Pos::from_usize(start_pos);"}]}