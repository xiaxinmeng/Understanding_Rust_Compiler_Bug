{"sha": "5005be67cc4efb54adf6f68dbaa86d7f2ca14391", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwMDViZTY3Y2M0ZWZiNTRhZGY2ZjY4ZGJhYTg2ZDdmMmNhMTQzOTE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-11-16T22:50:35Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-11-16T22:50:49Z"}, "message": "syntax: rename quote! to quote_tokens!, add quote_{expr,type,item,pat,stmt}!\n\nr=brson, Close #3976.", "tree": {"sha": "91de5ee034f647a86b251f31763c687496b3d6f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91de5ee034f647a86b251f31763c687496b3d6f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5005be67cc4efb54adf6f68dbaa86d7f2ca14391", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5005be67cc4efb54adf6f68dbaa86d7f2ca14391", "html_url": "https://github.com/rust-lang/rust/commit/5005be67cc4efb54adf6f68dbaa86d7f2ca14391", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5005be67cc4efb54adf6f68dbaa86d7f2ca14391/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bf6663cf0864a16c75b95f69a9c2cb37ea485f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bf6663cf0864a16c75b95f69a9c2cb37ea485f6", "html_url": "https://github.com/rust-lang/rust/commit/2bf6663cf0864a16c75b95f69a9c2cb37ea485f6"}], "stats": {"total": 169, "additions": 141, "deletions": 28}, "files": [{"sha": "eb4026c08d90cc86cfa480887e17bc4fdaeedaa9", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5005be67cc4efb54adf6f68dbaa86d7f2ca14391/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5005be67cc4efb54adf6f68dbaa86d7f2ca14391/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=5005be67cc4efb54adf6f68dbaa86d7f2ca14391", "patch": "@@ -96,8 +96,21 @@ fn syntax_expander_table() -> HashMap<~str, syntax_extension> {\n                                 ext::log_syntax::expand_syntax_ext));\n     syntax_expanders.insert(~\"ast\",\n                             builtin(ext::qquote::expand_ast));\n-    syntax_expanders.insert(~\"quote\",\n-                            builtin_expr_tt(ext::quote::expand_quote));\n+\n+    // Quasi-quoting expanders\n+    syntax_expanders.insert(~\"quote_tokens\",\n+                            builtin_expr_tt(ext::quote::expand_quote_tokens));\n+    syntax_expanders.insert(~\"quote_expr\",\n+                            builtin_expr_tt(ext::quote::expand_quote_expr));\n+    syntax_expanders.insert(~\"quote_type\",\n+                            builtin_expr_tt(ext::quote::expand_quote_type));\n+    syntax_expanders.insert(~\"quote_item\",\n+                            builtin_expr_tt(ext::quote::expand_quote_item));\n+    syntax_expanders.insert(~\"quote_pat\",\n+                            builtin_expr_tt(ext::quote::expand_quote_pat));\n+    syntax_expanders.insert(~\"quote_stmt\",\n+                            builtin_expr_tt(ext::quote::expand_quote_stmt));\n+\n     syntax_expanders.insert(~\"line\",\n                             builtin(ext::source_util::expand_line));\n     syntax_expanders.insert(~\"col\","}, {"sha": "db77166bfe316405f0b1d07efca7dea9c7a1789b", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 107, "deletions": 26, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/5005be67cc4efb54adf6f68dbaa86d7f2ca14391/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5005be67cc4efb54adf6f68dbaa86d7f2ca14391/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=5005be67cc4efb54adf6f68dbaa86d7f2ca14391", "patch": "@@ -16,33 +16,54 @@ use token::*;\n *\n */\n \n-pub fn expand_quote(cx: ext_ctxt,\n-                    sp: span,\n-                    tts: ~[ast::token_tree]) -> base::mac_result\n-{\n+pub mod rt {\n+    pub use ast::*;\n+    pub use parse::token::*;\n+    pub use parse::new_parser_from_tt;\n+}\n \n-    // NB: It appears that the main parser loses its mind if we consider\n-    // $foo as a tt_nonterminal during the main parse, so we have to re-parse\n-    // under quote_depth > 0. This is silly and should go away; the _guess_ is\n-    // it has to do with transition away from supporting old-style macros, so\n-    // try removing it when enough of them are gone.\n-    let p = parse::new_parser_from_tt(cx.parse_sess(), cx.cfg(), tts);\n-    p.quote_depth += 1u;\n-    let tq = dvec::DVec();\n-    while p.token != token::EOF {\n-        tq.push(p.parse_token_tree());\n-    }\n-    let tts = tq.get();\n+pub fn expand_quote_tokens(cx: ext_ctxt,\n+                           sp: span,\n+                           tts: ~[ast::token_tree]) -> base::mac_result {\n+    base::mr_expr(expand_tt(cx, sp, tts))\n+}\n \n-    // We want to emit a block expression that does a sequence of 'use's to\n-    // import the AST and token constructors, followed by a tt expression.\n-    let uses = ~[ build::mk_glob_use(cx, sp, ids_ext(cx, ~[~\"syntax\",\n-                                                           ~\"ast\"])),\n-                  build::mk_glob_use(cx, sp, ids_ext(cx, ~[~\"syntax\",\n-                                                           ~\"parse\",\n-                                                           ~\"token\"])) ];\n-    base::mr_expr(build::mk_block(cx, sp, uses, ~[],\n-                                  Some(mk_tt(cx, sp, &ast::tt_delim(tts)))))\n+pub fn expand_quote_expr(cx: ext_ctxt,\n+                         sp: span,\n+                         tts: ~[ast::token_tree]) -> base::mac_result {\n+    base::mr_expr(expand_parse_call(cx, sp, ~\"parse_expr\", ~[], tts))\n+}\n+\n+pub fn expand_quote_item(cx: ext_ctxt,\n+                         sp: span,\n+                         tts: ~[ast::token_tree]) -> base::mac_result {\n+    let e_attrs = build::mk_uniq_vec_e(cx, sp, ~[]);\n+    base::mr_expr(expand_parse_call(cx, sp, ~\"parse_item\",\n+                                    ~[e_attrs], tts))\n+}\n+\n+pub fn expand_quote_pat(cx: ext_ctxt,\n+                        sp: span,\n+                        tts: ~[ast::token_tree]) -> base::mac_result {\n+    let e_refutable = build::mk_lit(cx, sp, ast::lit_bool(true));\n+    base::mr_expr(expand_parse_call(cx, sp, ~\"parse_pat\",\n+                                    ~[e_refutable], tts))\n+}\n+\n+pub fn expand_quote_type(cx: ext_ctxt,\n+                         sp: span,\n+                         tts: ~[ast::token_tree]) -> base::mac_result {\n+    let e_param_colons = build::mk_lit(cx, sp, ast::lit_bool(false));\n+    base::mr_expr(expand_parse_call(cx, sp, ~\"parse_type\",\n+                                    ~[e_param_colons], tts))\n+}\n+\n+pub fn expand_quote_stmt(cx: ext_ctxt,\n+                         sp: span,\n+                         tts: ~[ast::token_tree]) -> base::mac_result {\n+    let e_attrs = build::mk_uniq_vec_e(cx, sp, ~[]);\n+    base::mr_expr(expand_parse_call(cx, sp, ~\"parse_stmt\",\n+                                    ~[e_attrs], tts))\n }\n \n fn ids_ext(cx: ext_ctxt, strs: ~[~str]) -> ~[ast::ident] {\n@@ -304,4 +325,64 @@ fn mk_tt(cx: ext_ctxt, sp: span, tt: &ast::token_tree) -> @ast::expr {\n         ast::tt_nonterminal(sp, ident) =>\n         build::mk_copy(cx, sp, build::mk_path(cx, sp, ~[ident]))\n     }\n-}\n\\ No newline at end of file\n+}\n+\n+\n+fn expand_tt(cx: ext_ctxt,\n+             sp: span,\n+             tts: ~[ast::token_tree]) -> @ast::expr {\n+    // NB: It appears that the main parser loses its mind if we consider\n+    // $foo as a tt_nonterminal during the main parse, so we have to re-parse\n+    // under quote_depth > 0. This is silly and should go away; the _guess_ is\n+    // it has to do with transition away from supporting old-style macros, so\n+    // try removing it when enough of them are gone.\n+    let p = parse::new_parser_from_tt(cx.parse_sess(), cx.cfg(), tts);\n+    p.quote_depth += 1u;\n+    let tq = dvec::DVec();\n+    while p.token != token::EOF {\n+        tq.push(p.parse_token_tree());\n+    }\n+    let tts = tq.get();\n+\n+    // We want to emit a block expression that does a sequence of 'use's to\n+    // import the runtime module, followed by a tt expression.\n+    let uses = ~[ build::mk_glob_use(cx, sp, ids_ext(cx, ~[~\"syntax\",\n+                                                           ~\"ext\",\n+                                                           ~\"quote\",\n+                                                           ~\"rt\"])) ];\n+    build::mk_block(cx, sp, uses, ~[],\n+                    Some(mk_tt(cx, sp, &ast::tt_delim(tts))))\n+}\n+\n+fn expand_parse_call(cx: ext_ctxt,\n+                     sp: span,\n+                     parse_method: ~str,\n+                     arg_exprs: ~[@ast::expr],\n+                     tts: ~[ast::token_tree]) -> @ast::expr {\n+    let tt_expr = expand_tt(cx, sp, tts);\n+\n+    let cfg_call = || build::mk_call_(\n+        cx, sp, build::mk_access(cx, sp, ids_ext(cx, ~[~\"ext_cx\"]),\n+                                 id_ext(cx, ~\"cfg\")), ~[]);\n+\n+    let parse_sess_call = || build::mk_call_(\n+        cx, sp, build::mk_access(cx, sp, ids_ext(cx, ~[~\"ext_cx\"]),\n+                                 id_ext(cx, ~\"parse_sess\")), ~[]);\n+\n+    let new_parser_call =\n+        build::mk_call(cx, sp,\n+                       ids_ext(cx, ~[~\"syntax\",\n+                                     ~\"ext\",\n+                                     ~\"quote\",\n+                                     ~\"rt\",\n+                                     ~\"new_parser_from_tt\"]),\n+                       ~[parse_sess_call(),\n+                         cfg_call(),\n+                         build::mk_uniq_vec_e(cx, sp, ~[tt_expr])]);\n+\n+    build::mk_call_(cx, sp,\n+                    build::mk_access_(cx, sp, new_parser_call,\n+                                      id_ext(cx, parse_method)),\n+                    arg_exprs)\n+}\n+"}, {"sha": "7149c73be80760ec1db46dbed8c8609ee577fe56", "filename": "src/test/run-pass-fulldeps/quote-tokens.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5005be67cc4efb54adf6f68dbaa86d7f2ca14391/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5005be67cc4efb54adf6f68dbaa86d7f2ca14391/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs?ref=5005be67cc4efb54adf6f68dbaa86d7f2ca14391", "patch": "@@ -0,0 +1,19 @@\n+extern mod syntax;\n+\n+use syntax::ext::base::ext_ctxt;\n+\n+fn syntax_extension(ext_cx: @ext_ctxt) {\n+    let e_toks : syntax::ast::token_tree = quote_tokens!(1 + 2);\n+    let p_toks : syntax::ast::token_tree = quote_tokens!((x, 1 .. 4, *));\n+\n+    let _a: @syntax::ast::expr = quote_expr!(1 + 2);\n+    let _b: Option<@syntax::ast::item> = quote_item!( const foo : int = $e_toks; );\n+    let _c: @syntax::ast::pat = quote_pat!( (x, 1 .. 4, *) );\n+    let _d: @syntax::ast::stmt = quote_stmt!( let x = $e_toks; );\n+    let _e: @syntax::ast::expr = quote_expr!( match foo { $p_toks => 10 } );\n+}\n+\n+fn main() {\n+    let _x: syntax::ast::token_tree = quote_tokens!(a::Foo::foo());\n+}\n+"}]}