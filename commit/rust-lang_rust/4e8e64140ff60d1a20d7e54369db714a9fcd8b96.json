{"sha": "4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlOGU2NDE0MGZmNjBkMWEyMGQ3ZTU0MzY5ZGI3MTRhOWZjZDhiOTY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-03-16T16:45:01Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-14T09:55:42Z"}, "message": "eddyb's refactoring of coercions/adjustments", "tree": {"sha": "2b3a26030c79205545f0d66e766a72ecef5f0e70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b3a26030c79205545f0d66e766a72ecef5f0e70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "html_url": "https://github.com/rust-lang/rust/commit/4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4eb5a66a5b33b209a1263830d89d83381a42ccb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4eb5a66a5b33b209a1263830d89d83381a42ccb", "html_url": "https://github.com/rust-lang/rust/commit/a4eb5a66a5b33b209a1263830d89d83381a42ccb"}], "stats": {"total": 2305, "additions": 815, "deletions": 1490}, "files": [{"sha": "2b8540a34b15b0c66c2f7c76cfe0654de0ac03de", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 59, "deletions": 215, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -601,18 +601,18 @@ impl tr for ty::UpvarCapture {\n \n trait read_method_callee_helper<'tcx> {\n     fn read_method_callee<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-        -> (ty::ExprAdjustment, MethodCallee<'tcx>);\n+                                  -> (u32, MethodCallee<'tcx>);\n }\n \n fn encode_method_callee<'a, 'tcx>(ecx: &e::EncodeContext<'a, 'tcx>,\n                                   rbml_w: &mut Encoder,\n-                                  adjustment: ty::ExprAdjustment,\n+                                  autoderef: u32,\n                                   method: &MethodCallee<'tcx>) {\n     use serialize::Encoder;\n \n     rbml_w.emit_struct(\"MethodCallee\", 4, |rbml_w| {\n-        rbml_w.emit_struct_field(\"adjustment\", 0, |rbml_w| {\n-            adjustment.encode(rbml_w)\n+        rbml_w.emit_struct_field(\"autoderef\", 0, |rbml_w| {\n+            autoderef.encode(rbml_w)\n         });\n         rbml_w.emit_struct_field(\"origin\", 1, |rbml_w| {\n             Ok(rbml_w.emit_method_origin(ecx, &method.origin))\n@@ -628,13 +628,13 @@ fn encode_method_callee<'a, 'tcx>(ecx: &e::EncodeContext<'a, 'tcx>,\n \n impl<'a, 'tcx> read_method_callee_helper<'tcx> for reader::Decoder<'a> {\n     fn read_method_callee<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-        -> (ty::ExprAdjustment, MethodCallee<'tcx>) {\n+                                  -> (u32, MethodCallee<'tcx>) {\n \n         self.read_struct(\"MethodCallee\", 4, |this| {\n-            let adjustment = this.read_struct_field(\"adjustment\", 0, |this| {\n+            let autoderef = this.read_struct_field(\"autoderef\", 0, |this| {\n                 Decodable::decode(this)\n             }).unwrap();\n-            Ok((adjustment, MethodCallee {\n+            Ok((autoderef, MethodCallee {\n                 origin: this.read_struct_field(\"origin\", 1, |this| {\n                     Ok(this.read_method_origin(dcx))\n                 }).unwrap(),\n@@ -688,7 +688,7 @@ pub trait vtable_decoder_helpers<'tcx> {\n     fn read_vtable_res_with_key(&mut self,\n                                 tcx: &ty::ctxt<'tcx>,\n                                 cdata: &cstore::crate_metadata)\n-                                -> (ty::ExprAdjustment, ty::vtable_res<'tcx>);\n+                                -> (u32, ty::vtable_res<'tcx>);\n     fn read_vtable_res(&mut self,\n                        tcx: &ty::ctxt<'tcx>, cdata: &cstore::crate_metadata)\n                       -> ty::vtable_res<'tcx>;\n@@ -713,12 +713,12 @@ impl<'tcx, 'a> vtable_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     fn read_vtable_res_with_key(&mut self,\n                                 tcx: &ty::ctxt<'tcx>,\n                                 cdata: &cstore::crate_metadata)\n-                                -> (ty::ExprAdjustment, ty::vtable_res<'tcx>) {\n+                                -> (u32, ty::vtable_res<'tcx>) {\n         self.read_struct(\"VtableWithKey\", 2, |this| {\n-            let adjustment = this.read_struct_field(\"adjustment\", 0, |this| {\n+            let autoderef = this.read_struct_field(\"autoderef\", 0, |this| {\n                 Decodable::decode(this)\n             }).unwrap();\n-            Ok((adjustment, this.read_struct_field(\"vtable_res\", 1, |this| {\n+            Ok((autoderef, this.read_struct_field(\"vtable_res\", 1, |this| {\n                 Ok(this.read_vtable_res(tcx, cdata))\n             }).unwrap()))\n         }).unwrap()\n@@ -845,12 +845,9 @@ trait rbml_writer_helpers<'tcx> {\n     fn emit_builtin_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::BuiltinBounds);\n     fn emit_auto_adjustment<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                                 adj: &ty::AutoAdjustment<'tcx>);\n-    fn emit_autoref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                        autoref: &ty::AutoRef<'tcx>);\n+    fn emit_autoref<'a>(&mut self, autoref: &ty::AutoRef<'tcx>);\n     fn emit_auto_deref_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                                auto_deref_ref: &ty::AutoDerefRef<'tcx>);\n-    fn emit_unsize_kind<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                            uk: &ty::UnsizeKind<'tcx>);\n }\n \n impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n@@ -1012,10 +1009,8 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n \n         self.emit_enum(\"AutoAdjustment\", |this| {\n             match *adj {\n-                ty::AdjustReifyFnPointer(def_id) => {\n-                    this.emit_enum_variant(\"AdjustReifyFnPointer\", 1, 2, |this| {\n-                        this.emit_enum_variant_arg(0, |this| def_id.encode(this))\n-                    })\n+                ty::AdjustReifyFnPointer=> {\n+                    this.emit_enum_variant(\"AdjustReifyFnPointer\", 1, 0, |_| Ok(()))\n                 }\n \n                 ty::AdjustUnsafeFnPointer => {\n@@ -1034,50 +1029,20 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n-    fn emit_autoref<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n-                        autoref: &ty::AutoRef<'tcx>) {\n+    fn emit_autoref<'b>(&mut self, autoref: &ty::AutoRef<'tcx>) {\n         use serialize::Encoder;\n \n         self.emit_enum(\"AutoRef\", |this| {\n             match autoref {\n-                &ty::AutoPtr(r, m, None) => {\n-                    this.emit_enum_variant(\"AutoPtr\", 0, 3, |this| {\n-                        this.emit_enum_variant_arg(0, |this| r.encode(this));\n-                        this.emit_enum_variant_arg(1, |this| m.encode(this));\n-                        this.emit_enum_variant_arg(2,\n-                            |this| this.emit_option(|this| this.emit_option_none()))\n-                    })\n-                }\n-                &ty::AutoPtr(r, m, Some(box ref a)) => {\n-                    this.emit_enum_variant(\"AutoPtr\", 0, 3, |this| {\n+                &ty::AutoPtr(r, m) => {\n+                    this.emit_enum_variant(\"AutoPtr\", 0, 2, |this| {\n                         this.emit_enum_variant_arg(0, |this| r.encode(this));\n-                        this.emit_enum_variant_arg(1, |this| m.encode(this));\n-                        this.emit_enum_variant_arg(2, |this| this.emit_option(\n-                            |this| this.emit_option_some(|this| Ok(this.emit_autoref(ecx, a)))))\n-                    })\n-                }\n-                &ty::AutoUnsize(ref uk) => {\n-                    this.emit_enum_variant(\"AutoUnsize\", 1, 1, |this| {\n-                        this.emit_enum_variant_arg(0, |this| Ok(this.emit_unsize_kind(ecx, uk)))\n+                        this.emit_enum_variant_arg(1, |this| m.encode(this))\n                     })\n                 }\n-                &ty::AutoUnsizeUniq(ref uk) => {\n-                    this.emit_enum_variant(\"AutoUnsizeUniq\", 2, 1, |this| {\n-                        this.emit_enum_variant_arg(0, |this| Ok(this.emit_unsize_kind(ecx, uk)))\n-                    })\n-                }\n-                &ty::AutoUnsafe(m, None) => {\n-                    this.emit_enum_variant(\"AutoUnsafe\", 3, 2, |this| {\n-                        this.emit_enum_variant_arg(0, |this| m.encode(this));\n-                        this.emit_enum_variant_arg(1,\n-                            |this| this.emit_option(|this| this.emit_option_none()))\n-                    })\n-                }\n-                &ty::AutoUnsafe(m, Some(box ref a)) => {\n-                    this.emit_enum_variant(\"AutoUnsafe\", 3, 2, |this| {\n-                        this.emit_enum_variant_arg(0, |this| m.encode(this));\n-                        this.emit_enum_variant_arg(1, |this| this.emit_option(\n-                            |this| this.emit_option_some(|this| Ok(this.emit_autoref(ecx, a)))))\n+                &ty::AutoUnsafe(m) => {\n+                    this.emit_enum_variant(\"AutoUnsafe\", 1, 1, |this| {\n+                        this.emit_enum_variant_arg(0, |this| m.encode(this))\n                     })\n                 }\n             }\n@@ -1090,55 +1055,26 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n \n         self.emit_struct(\"AutoDerefRef\", 2, |this| {\n             this.emit_struct_field(\"autoderefs\", 0, |this| auto_deref_ref.autoderefs.encode(this));\n+\n             this.emit_struct_field(\"autoref\", 1, |this| {\n                 this.emit_option(|this| {\n                     match auto_deref_ref.autoref {\n                         None => this.emit_option_none(),\n-                        Some(ref a) => this.emit_option_some(|this| Ok(this.emit_autoref(ecx, a))),\n+                        Some(ref a) => this.emit_option_some(|this| Ok(this.emit_autoref(a))),\n                     }\n                 })\n-            })\n-        });\n-    }\n-\n-    fn emit_unsize_kind<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n-                            uk: &ty::UnsizeKind<'tcx>) {\n-        use serialize::Encoder;\n+            });\n \n-        self.emit_enum(\"UnsizeKind\", |this| {\n-            match *uk {\n-                ty::UnsizeLength(len) => {\n-                    this.emit_enum_variant(\"UnsizeLength\", 0, 1, |this| {\n-                        this.emit_enum_variant_arg(0, |this| len.encode(this))\n-                    })\n-                }\n-                ty::UnsizeStruct(box ref uk, idx) => {\n-                    this.emit_enum_variant(\"UnsizeStruct\", 1, 2, |this| {\n-                        this.emit_enum_variant_arg(0, |this| Ok(this.emit_unsize_kind(ecx, uk)));\n-                        this.emit_enum_variant_arg(1, |this| idx.encode(this))\n-                    })\n-                }\n-                ty::UnsizeVtable(ty::TyTrait { ref principal,\n-                                               bounds: ref b },\n-                                 self_ty) => {\n-                    this.emit_enum_variant(\"UnsizeVtable\", 2, 4, |this| {\n-                        this.emit_enum_variant_arg(0, |this| {\n-                            try!(this.emit_struct_field(\"principal\", 0, |this| {\n-                                Ok(this.emit_trait_ref(ecx, &*principal.0))\n-                            }));\n-                            this.emit_struct_field(\"bounds\", 1, |this| {\n-                                Ok(this.emit_existential_bounds(ecx, b))\n-                            })\n-                        });\n-                        this.emit_enum_variant_arg(1, |this| Ok(this.emit_ty(ecx, self_ty)))\n-                    })\n-                }\n-                ty::UnsizeUpcast(target_ty) => {\n-                    this.emit_enum_variant(\"UnsizeUpcast\", 3, 1, |this| {\n-                        this.emit_enum_variant_arg(0, |this| Ok(this.emit_ty(ecx, target_ty)))\n-                    })\n-                }\n-            }\n+            this.emit_struct_field(\"unsize\", 2, |this| {\n+                this.emit_option(|this| {\n+                    match auto_deref_ref.unsize {\n+                        None => this.emit_option_none(),\n+                        Some(target) => this.emit_option_some(|this| {\n+                            Ok(this.emit_ty(ecx, target))\n+                        })\n+                    }\n+                })\n+            })\n         });\n     }\n }\n@@ -1258,7 +1194,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     if let Some(method) = tcx.method_map.borrow().get(&method_call) {\n         rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n             rbml_w.id(id);\n-            encode_method_callee(ecx, rbml_w, method_call.adjustment, method)\n+            encode_method_callee(ecx, rbml_w, method_call.autoderef, method)\n         })\n     }\n \n@@ -1271,31 +1207,19 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     if let Some(adjustment) = tcx.adjustments.borrow().get(&id) {\n         match *adjustment {\n-            _ if ty::adjust_is_object(adjustment) => {\n-                let method_call = MethodCall::autoobject(id);\n-                if let Some(method) = tcx.method_map.borrow().get(&method_call) {\n-                    rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n-                        rbml_w.id(id);\n-                        encode_method_callee(ecx, rbml_w, method_call.adjustment, method)\n-                    })\n-                }\n-            }\n             ty::AdjustDerefRef(ref adj) => {\n-                assert!(!ty::adjust_is_object(adjustment));\n                 for autoderef in 0..adj.autoderefs {\n-                    let method_call = MethodCall::autoderef(id, autoderef);\n+                    let method_call = MethodCall::autoderef(id, autoderef as u32);\n                     if let Some(method) = tcx.method_map.borrow().get(&method_call) {\n                         rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n                             rbml_w.id(id);\n                             encode_method_callee(ecx, rbml_w,\n-                                                 method_call.adjustment, method)\n+                                                 method_call.autoderef, method)\n                         })\n                     }\n                 }\n             }\n-            _ => {\n-                assert!(!ty::adjust_is_object(adjustment));\n-            }\n+            _ => {}\n         }\n \n         rbml_w.tag(c::tag_table_adjustments, |rbml_w| {\n@@ -1367,8 +1291,6 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                                    -> ty::AutoDerefRef<'tcx>;\n     fn read_autoref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                             -> ty::AutoRef<'tcx>;\n-    fn read_unsize_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                -> ty::UnsizeKind<'tcx>;\n     fn convert_def_id(&mut self,\n                       dcx: &DecodeContext,\n                       source: DefIdSource,\n@@ -1640,18 +1562,11 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     fn read_auto_adjustment<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                     -> ty::AutoAdjustment<'tcx> {\n         self.read_enum(\"AutoAdjustment\", |this| {\n-            let variants = [\"AutoAddEnv\", \"AutoDerefRef\"];\n+            let variants = [\"AdjustReifyFnPointer\", \"AdjustUnsafeFnPointer\", \"AdjustDerefRef\"];\n             this.read_enum_variant(&variants, |this, i| {\n                 Ok(match i {\n-                    1 => {\n-                        let def_id: ast::DefId =\n-                            this.read_def_id(dcx);\n-\n-                        ty::AdjustReifyFnPointer(def_id)\n-                    }\n-                    2 => {\n-                        ty::AdjustUnsafeFnPointer\n-                    }\n+                    1 => ty::AdjustReifyFnPointer,\n+                    2 => ty::AdjustUnsafeFnPointer,\n                     3 => {\n                         let auto_deref_ref: ty::AutoDerefRef =\n                             this.read_enum_variant_arg(0,\n@@ -1681,111 +1596,40 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                         }\n                     })\n                 }).unwrap(),\n+                unsize: this.read_struct_field(\"unsize\", 2, |this| {\n+                    this.read_option(|this, b| {\n+                        if b {\n+                            Ok(Some(this.read_ty(dcx)))\n+                        } else {\n+                            Ok(None)\n+                        }\n+                    })\n+                }).unwrap(),\n             })\n         }).unwrap()\n     }\n \n-    fn read_autoref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>) -> ty::AutoRef<'tcx> {\n+    fn read_autoref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n+                            -> ty::AutoRef<'tcx> {\n         self.read_enum(\"AutoRef\", |this| {\n-            let variants = [\"AutoPtr\",\n-                            \"AutoUnsize\",\n-                            \"AutoUnsizeUniq\",\n-                            \"AutoUnsafe\"];\n+            let variants = [\"AutoPtr\", \"AutoUnsafe\"];\n             this.read_enum_variant(&variants, |this, i| {\n                 Ok(match i {\n                     0 => {\n                         let r: ty::Region =\n                             this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n                         let m: ast::Mutability =\n                             this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n-                        let a: Option<Box<ty::AutoRef>> =\n-                            this.read_enum_variant_arg(2, |this| this.read_option(|this, b| {\n-                                if b {\n-                                    Ok(Some(box this.read_autoref(dcx)))\n-                                } else {\n-                                    Ok(None)\n-                                }\n-                            })).unwrap();\n-\n-                        ty::AutoPtr(r.tr(dcx), m, a)\n-                    }\n-                    1 => {\n-                        let uk: ty::UnsizeKind =\n-                            this.read_enum_variant_arg(0,\n-                                |this| Ok(this.read_unsize_kind(dcx))).unwrap();\n-\n-                        ty::AutoUnsize(uk)\n-                    }\n-                    2 => {\n-                        let uk: ty::UnsizeKind =\n-                            this.read_enum_variant_arg(0,\n-                                |this| Ok(this.read_unsize_kind(dcx))).unwrap();\n \n-                        ty::AutoUnsizeUniq(uk)\n+                        ty::AutoPtr(dcx.tcx.mk_region(r.tr(dcx)), m)\n                     }\n-                    3 => {\n+                    1 => {\n                         let m: ast::Mutability =\n                             this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n-                        let a: Option<Box<ty::AutoRef>> =\n-                            this.read_enum_variant_arg(1, |this| this.read_option(|this, b| {\n-                                if b {\n-                                    Ok(Some(box this.read_autoref(dcx)))\n-                                } else {\n-                                    Ok(None)\n-                                }\n-                            })).unwrap();\n-\n-                        ty::AutoUnsafe(m, a)\n-                    }\n-                    _ => panic!(\"bad enum variant for ty::AutoRef\")\n-                })\n-            })\n-        }).unwrap()\n-    }\n-\n-    fn read_unsize_kind<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                -> ty::UnsizeKind<'tcx> {\n-        self.read_enum(\"UnsizeKind\", |this| {\n-            let variants = &[\"UnsizeLength\", \"UnsizeStruct\", \"UnsizeVtable\", \"UnsizeUpcast\"];\n-            this.read_enum_variant(variants, |this, i| {\n-                Ok(match i {\n-                    0 => {\n-                        let len: usize =\n-                            this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n-\n-                        ty::UnsizeLength(len)\n-                    }\n-                    1 => {\n-                        let uk: ty::UnsizeKind =\n-                            this.read_enum_variant_arg(0,\n-                                |this| Ok(this.read_unsize_kind(dcx))).unwrap();\n-                        let idx: usize =\n-                            this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n \n-                        ty::UnsizeStruct(box uk, idx)\n-                    }\n-                    2 => {\n-                        let ty_trait = try!(this.read_enum_variant_arg(0, |this| {\n-                            let principal = try!(this.read_struct_field(\"principal\", 0, |this| {\n-                                Ok(this.read_poly_trait_ref(dcx))\n-                            }));\n-                            Ok(ty::TyTrait {\n-                                principal: principal,\n-                                bounds: try!(this.read_struct_field(\"bounds\", 1, |this| {\n-                                    Ok(this.read_existential_bounds(dcx))\n-                                })),\n-                            })\n-                        }));\n-                        let self_ty =\n-                            this.read_enum_variant_arg(1, |this| Ok(this.read_ty(dcx))).unwrap();\n-                        ty::UnsizeVtable(ty_trait, self_ty)\n+                        ty::AutoUnsafe(m)\n                     }\n-                    3 => {\n-                        let target_ty =\n-                            this.read_enum_variant_arg(0, |this| Ok(this.read_ty(dcx))).unwrap();\n-                        ty::UnsizeUpcast(target_ty)\n-                    }\n-                    _ => panic!(\"bad enum variant for ty::UnsizeKind\")\n+                    _ => panic!(\"bad enum variant for ty::AutoRef\")\n                 })\n             })\n         }).unwrap()\n@@ -1922,10 +1766,10 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         dcx.tcx.ty_param_defs.borrow_mut().insert(id, bounds);\n                     }\n                     c::tag_table_method_map => {\n-                        let (adjustment, method) = val_dsr.read_method_callee(dcx);\n+                        let (autoderef, method) = val_dsr.read_method_callee(dcx);\n                         let method_call = MethodCall {\n                             expr_id: id,\n-                            adjustment: adjustment\n+                            autoderef: autoderef\n                         };\n                         dcx.tcx.method_map.borrow_mut().insert(method_call, method);\n                     }"}, {"sha": "c1c551c2be9eb277bc4b46544f35a7986c360077", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 29, "deletions": 59, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -787,23 +787,30 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     // process.\n     fn walk_adjustment(&mut self, expr: &ast::Expr) {\n         let typer = self.typer;\n-        match typer.adjustments().borrow().get(&expr.id) {\n-            None => { }\n-            Some(adjustment) => {\n-                match *adjustment {\n-                    ty::AdjustReifyFnPointer(..) |\n-                    ty::AdjustUnsafeFnPointer(..) => {\n-                        // Creating a closure/fn-pointer consumes the\n-                        // input and stores it into the resulting\n-                        // rvalue.\n-                        debug!(\"walk_adjustment(AutoAddEnv|AdjustReifyFnPointer)\");\n+        if let Some(adjustment) = typer.adjustments().borrow().get(&expr.id) {\n+            match *adjustment {\n+                ty::AdjustReifyFnPointer |\n+                ty::AdjustUnsafeFnPointer => {\n+                    // Creating a closure/fn-pointer or unsizing consumes\n+                    // the input and stores it into the resulting rvalue.\n+                    debug!(\"walk_adjustment(AdjustReifyFnPointer|AdjustUnsafeFnPointer)\");\n+                    let cmt_unadjusted =\n+                        return_if_err!(self.mc.cat_expr_unadjusted(expr));\n+                    self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n+                }\n+                ty::AdjustDerefRef(ref adj) => {\n+                    self.walk_autoderefs(expr, adj.autoderefs);\n+                    if let Some(ref r) = adj.autoref {\n+                        self.walk_autoref(expr, r, adj.autoderefs);\n+                    } else if adj.unsize.is_some() {\n+                        assert!(adj.autoderefs == 0,\n+                                format!(\"Expected no derefs with \\\n+                                         unsize AutoRefs, found: {}\",\n+                                         adj.repr(self.tcx())));\n                         let cmt_unadjusted =\n                             return_if_err!(self.mc.cat_expr_unadjusted(expr));\n                         self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n                     }\n-                    ty::AdjustDerefRef(ref adj) => {\n-                        self.walk_autoderefref(expr, adj);\n-                    }\n                 }\n             }\n         }\n@@ -818,7 +825,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         debug!(\"walk_autoderefs expr={} autoderefs={}\", expr.repr(self.tcx()), autoderefs);\n \n         for i in 0..autoderefs {\n-            let deref_id = ty::MethodCall::autoderef(expr.id, i);\n+            let deref_id = ty::MethodCall::autoderef(expr.id, i as u32);\n             match self.typer.node_method_ty(deref_id) {\n                 None => {}\n                 Some(method_ty) => {\n@@ -903,59 +910,22 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n         };\n \n-        match *autoref {\n-            ty::AutoPtr(r, m, ref baseref) => {\n-                let cmt_base = self.walk_autoref_recursively(expr, cmt_derefd, baseref);\n+        let cmt_base = self.walk_autoref_recursively(expr, cmt_derefd, baseref);\n \n-                debug!(\"walk_autoref: expr.id={} cmt_base={}\",\n-                       expr.id,\n-                       cmt_base.repr(self.tcx()));\n+        debug!(\"walk_autoref: expr.id={} cmt_base={}\",\n+               expr.id,\n+               cmt_base.repr(self.tcx()));\n \n+        match *autoref {\n+            ty::AutoPtr(r, m) => {\n                 self.delegate.borrow(expr.id,\n                                      expr.span,\n-                                     cmt_base,\n-                                     r,\n+                                     cmt_derefd,\n+                                     *r,\n                                      ty::BorrowKind::from_mutbl(m),\n                                      AutoRef);\n             }\n \n-            ty::AutoUnsize(_) => {\n-                // Converting a `[T; N]` to `[T]` or `T` to `Trait`\n-                // isn't really a borrow, move, etc, in and of itself.\n-                // Also, no recursive step here, this is a base case.\n-\n-                // It may seem a bit odd to return the cmt_derefd\n-                // unmodified here, but in fact I think it's the right\n-                // thing to do. Essentially the unsize transformation\n-                // isn't really relevant to the borrowing rules --\n-                // it's best thought of as a kind of side-modifier to\n-                // the autoref, adding additional data that is\n-                // attached to the pointer that is produced, but not\n-                // affecting the data being borrowed in any other\n-                // way. To see what I mean, consider this example:\n-                //\n-                //    fn foo<'a>(&'a self) -> &'a Trait { self }\n-                //\n-                // This is valid because the underlying `self` value\n-                // lives for the lifetime 'a. If we were to treat the\n-                // \"unsizing\" as e.g. producing an rvalue, that would\n-                // only be valid for the temporary scope, which isn't\n-                // enough to justify the return value, which have the\n-                // lifetime 'a.\n-                //\n-                // Another option would be to add a variant for\n-                // categorization (like downcast) that wraps\n-                // cmt_derefd and represents the unsizing operation.\n-                // But I don't think there is any particular use for\n-                // this (yet). -nmatsakis\n-                return cmt_derefd.clone();\n-            }\n-\n-            ty::AutoUnsizeUniq(_) => {\n-                // these are handled via special case above\n-                self.tcx().sess.span_bug(expr.span, \"nexpected AutoUnsizeUniq\");\n-            }\n-\n             ty::AutoUnsafe(m, ref baseref) => {\n                 let cmt_base = self.walk_autoref_recursively(expr, cmt_derefd, baseref);\n "}, {"sha": "003306fe558a1b5d2c9413987f71ab21d1b890f4", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 11, "deletions": 27, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -451,33 +451,23 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n             Some(adjustment) => {\n                 match *adjustment {\n-                    ty::AdjustReifyFnPointer(..) |\n-                    ty::AdjustUnsafeFnPointer(..) => {\n-                        debug!(\"cat_expr(AdjustReifyFnPointer): {}\",\n-                               expr.repr(self.tcx()));\n-                        // Convert a bare fn to a closure by adding NULL env.\n-                        // Result is an rvalue.\n-                        let expr_ty = try!(self.expr_ty_adjusted(expr));\n-                        Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n-                    }\n-\n                     ty::AdjustDerefRef(\n                         ty::AutoDerefRef {\n-                            autoref: Some(_), ..}) => {\n-                        debug!(\"cat_expr(AdjustDerefRef): {}\",\n+                            autoref: None, unsize: None, autoderefs, ..}) => {\n+                        // Equivalent to *expr or something similar.\n+                        self.cat_expr_autoderefd(expr, autoderefs)\n+                    }\n+\n+                    ty::AdjustReifyFnPointer |\n+                    ty::AdjustUnsafeFnPointer |\n+                    ty::AdjustDerefRef(_) => {\n+                        debug!(\"cat_expr({}): {}\",\n+                               adjustment.repr(self.tcx()),\n                                expr.repr(self.tcx()));\n-                        // Equivalent to &*expr or something similar.\n                         // Result is an rvalue.\n                         let expr_ty = try!(self.expr_ty_adjusted(expr));\n                         Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n                     }\n-\n-                    ty::AdjustDerefRef(\n-                        ty::AutoDerefRef {\n-                            autoref: None, autoderefs}) => {\n-                        // Equivalent to *expr or something similar.\n-                        self.cat_expr_autoderefd(expr, autoderefs)\n-                    }\n                 }\n             }\n         }\n@@ -928,15 +918,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                              deref_cnt: usize,\n                              deref_context: DerefKindContext)\n                              -> McResult<cmt<'tcx>> {\n-        let adjustment = match self.typer.adjustments().borrow().get(&node.id()) {\n-            Some(adj) if ty::adjust_is_object(adj) => ty::AutoObject,\n-            _ if deref_cnt != 0 => ty::AutoDeref(deref_cnt),\n-            _ => ty::NoAdjustment\n-        };\n-\n         let method_call = ty::MethodCall {\n             expr_id: node.id(),\n-            adjustment: adjustment\n+            autoderef: deref_cnt as u32\n         };\n         let method_ty = self.typer.node_method_ty(method_call);\n "}, {"sha": "ccb0fa7bfdb40f43324864a87cdbdd3c45db075b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 85, "deletions": 241, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -20,7 +20,6 @@ pub use self::ClosureKind::*;\n pub use self::Variance::*;\n pub use self::AutoAdjustment::*;\n pub use self::Representability::*;\n-pub use self::UnsizeKind::*;\n pub use self::AutoRef::*;\n pub use self::ExprKind::*;\n pub use self::DtorKind::*;\n@@ -33,7 +32,6 @@ pub use self::ImplOrTraitItem::*;\n pub use self::BoundRegion::*;\n pub use self::sty::*;\n pub use self::IntVarValue::*;\n-pub use self::ExprAdjustment::*;\n pub use self::vtable_origin::*;\n pub use self::MethodOrigin::*;\n pub use self::CopyImplementationError::*;\n@@ -283,145 +281,34 @@ pub enum Variance {\n     Bivariant,      // T<A> <: T<B>            -- e.g., unused type parameter\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Copy, Clone, Debug)]\n pub enum AutoAdjustment<'tcx> {\n-    AdjustReifyFnPointer(ast::DefId), // go from a fn-item type to a fn-pointer type\n+    AdjustReifyFnPointer, // go from a fn-item type to a fn-pointer type\n     AdjustUnsafeFnPointer, // go from a safe fn pointer to an unsafe fn pointer\n-    AdjustDerefRef(AutoDerefRef<'tcx>)\n-}\n-\n-#[derive(Clone, PartialEq, Debug)]\n-pub enum UnsizeKind<'tcx> {\n-    // [T, ..n] -> [T], the usize field is n.\n-    UnsizeLength(usize),\n-    // An unsize coercion applied to the tail field of a struct.\n-    // The usize is the index of the type parameter which is unsized.\n-    UnsizeStruct(Box<UnsizeKind<'tcx>>, usize),\n-    UnsizeVtable(TyTrait<'tcx>, /* the self type of the trait */ Ty<'tcx>),\n-    UnsizeUpcast(Ty<'tcx>),\n+    AdjustDerefRef(AutoDerefRef<'tcx>),\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Copy, Clone, Debug)]\n pub struct AutoDerefRef<'tcx> {\n+    /// Apply a number of dereferences, producing an lvalue.\n     pub autoderefs: usize,\n-    pub autoref: Option<AutoRef<'tcx>>\n+\n+    /// Produce a pointer/reference from the value.\n+    pub autoref: Option<AutoRef<'tcx>>,\n+\n+    /// Unsize a pointer/reference value, e.g. &[T; n] to &[T].\n+    /// The stored type is the target pointer type.\n+    pub unsize: Option<Ty<'tcx>>,\n }\n \n-#[derive(Clone, PartialEq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n pub enum AutoRef<'tcx> {\n     /// Convert from T to &T\n-    /// The third field allows us to wrap other AutoRef adjustments.\n-    AutoPtr(Region, ast::Mutability, Option<Box<AutoRef<'tcx>>>),\n-\n-    /// Convert [T, ..n] to [T] (or similar, depending on the kind)\n-    AutoUnsize(UnsizeKind<'tcx>),\n-\n-    /// Convert Box<[T, ..n]> to Box<[T]> or something similar in a Box.\n-    /// With DST and Box a library type, this should be replaced by UnsizeStruct.\n-    AutoUnsizeUniq(UnsizeKind<'tcx>),\n+    AutoPtr(&'tcx Region, ast::Mutability),\n \n     /// Convert from T to *T\n     /// Value to thin pointer\n-    /// The second field allows us to wrap other AutoRef adjustments.\n-    AutoUnsafe(ast::Mutability, Option<Box<AutoRef<'tcx>>>),\n-}\n-\n-// Ugly little helper function. The first bool in the returned tuple is true if\n-// there is an 'unsize to trait object' adjustment at the bottom of the\n-// adjustment. If that is surrounded by an AutoPtr, then we also return the\n-// region of the AutoPtr (in the third argument). The second bool is true if the\n-// adjustment is unique.\n-fn autoref_object_region(autoref: &AutoRef) -> (bool, bool, Option<Region>) {\n-    fn unsize_kind_is_object(k: &UnsizeKind) -> bool {\n-        match k {\n-            &UnsizeVtable(..) => true,\n-            &UnsizeStruct(box ref k, _) => unsize_kind_is_object(k),\n-            _ => false\n-        }\n-    }\n-\n-    match autoref {\n-        &AutoUnsize(ref k) => (unsize_kind_is_object(k), false, None),\n-        &AutoUnsizeUniq(ref k) => (unsize_kind_is_object(k), true, None),\n-        &AutoPtr(adj_r, _, Some(box ref autoref)) => {\n-            let (b, u, r) = autoref_object_region(autoref);\n-            if r.is_some() || u {\n-                (b, u, r)\n-            } else {\n-                (b, u, Some(adj_r))\n-            }\n-        }\n-        &AutoUnsafe(_, Some(box ref autoref)) => autoref_object_region(autoref),\n-        _ => (false, false, None)\n-    }\n-}\n-\n-// If the adjustment introduces a borrowed reference to a trait object, then\n-// returns the region of the borrowed reference.\n-pub fn adjusted_object_region(adj: &AutoAdjustment) -> Option<Region> {\n-    match adj {\n-        &AdjustDerefRef(AutoDerefRef{autoref: Some(ref autoref), ..}) => {\n-            let (b, _, r) = autoref_object_region(autoref);\n-            if b {\n-                r\n-            } else {\n-                None\n-            }\n-        }\n-        _ => None\n-    }\n-}\n-\n-// Returns true if there is a trait cast at the bottom of the adjustment.\n-pub fn adjust_is_object(adj: &AutoAdjustment) -> bool {\n-    match adj {\n-        &AdjustDerefRef(AutoDerefRef{autoref: Some(ref autoref), ..}) => {\n-            let (b, _, _) = autoref_object_region(autoref);\n-            b\n-        }\n-        _ => false\n-    }\n-}\n-\n-// If possible, returns the type expected from the given adjustment. This is not\n-// possible if the adjustment depends on the type of the adjusted expression.\n-pub fn type_of_adjust<'tcx>(cx: &ctxt<'tcx>, adj: &AutoAdjustment<'tcx>) -> Option<Ty<'tcx>> {\n-    fn type_of_autoref<'tcx>(cx: &ctxt<'tcx>, autoref: &AutoRef<'tcx>) -> Option<Ty<'tcx>> {\n-        match autoref {\n-            &AutoUnsize(ref k) => match k {\n-                &UnsizeVtable(TyTrait { ref principal, ref bounds }, _) => {\n-                    Some(mk_trait(cx, principal.clone(), bounds.clone()))\n-                }\n-                _ => None\n-            },\n-            &AutoUnsizeUniq(ref k) => match k {\n-                &UnsizeVtable(TyTrait { ref principal, ref bounds }, _) => {\n-                    Some(mk_uniq(cx, mk_trait(cx, principal.clone(), bounds.clone())))\n-                }\n-                _ => None\n-            },\n-            &AutoPtr(r, m, Some(box ref autoref)) => {\n-                match type_of_autoref(cx, autoref) {\n-                    Some(ty) => Some(mk_rptr(cx, cx.mk_region(r), mt {mutbl: m, ty: ty})),\n-                    None => None\n-                }\n-            }\n-            &AutoUnsafe(m, Some(box ref autoref)) => {\n-                match type_of_autoref(cx, autoref) {\n-                    Some(ty) => Some(mk_ptr(cx, mt {mutbl: m, ty: ty})),\n-                    None => None\n-                }\n-            }\n-            _ => None\n-        }\n-    }\n-\n-    match adj {\n-        &AdjustDerefRef(AutoDerefRef{autoref: Some(ref autoref), ..}) => {\n-            type_of_autoref(cx, autoref)\n-        }\n-        _ => None\n-    }\n+    AutoUnsafe(ast::Mutability),\n }\n \n #[derive(Clone, Copy, RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Debug)]\n@@ -509,35 +396,21 @@ pub struct MethodCallee<'tcx> {\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub struct MethodCall {\n     pub expr_id: ast::NodeId,\n-    pub adjustment: ExprAdjustment\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, Copy)]\n-pub enum ExprAdjustment {\n-    NoAdjustment,\n-    AutoDeref(usize),\n-    AutoObject\n+    pub autoderef: u32\n }\n \n impl MethodCall {\n     pub fn expr(id: ast::NodeId) -> MethodCall {\n         MethodCall {\n             expr_id: id,\n-            adjustment: NoAdjustment\n-        }\n-    }\n-\n-    pub fn autoobject(id: ast::NodeId) -> MethodCall {\n-        MethodCall {\n-            expr_id: id,\n-            adjustment: AutoObject\n+            autoderef: 0\n         }\n     }\n \n     pub fn autoderef(expr_id: ast::NodeId, autoderef: usize) -> MethodCall {\n         MethodCall {\n             expr_id: expr_id,\n-            adjustment: AutoDeref(1 + autoderef)\n+            autoderef: 1 + autoderef\n         }\n     }\n }\n@@ -4581,16 +4454,15 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n     return match adjustment {\n         Some(adjustment) => {\n             match *adjustment {\n-               AdjustReifyFnPointer(_) => {\n+               AdjustReifyFnPointer => {\n                     match unadjusted_ty.sty {\n                         ty::ty_bare_fn(Some(_), b) => {\n                             ty::mk_bare_fn(cx, None, b)\n                         }\n-                        ref b => {\n+                        _ => {\n                             cx.sess.bug(\n                                 &format!(\"AdjustReifyFnPointer adjustment on non-fn-item: \\\n-                                         {:?}\",\n-                                        b));\n+                                          {}\", unadjusted_ty.repr(cx)));\n                         }\n                     }\n                 }\n@@ -4612,7 +4484,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n \n                     if !ty::type_is_error(adjusted_ty) {\n                         for i in 0..adj.autoderefs {\n-                            let method_call = MethodCall::autoderef(expr_id, i);\n+                            let method_call = MethodCall::autoderef(expr_id, i as u32);\n                             match method_type(method_call) {\n                                 Some(method_ty) => {\n                                     // overloaded deref operators have all late-bound\n@@ -4639,7 +4511,11 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                         }\n                     }\n \n-                    adjust_ty_for_autoref(cx, span, adjusted_ty, adj.autoref.as_ref())\n+                    if let Some(target) = adj.unsize {\n+                        target\n+                    } else {\n+                        adjust_ty_for_autoref(cx, adjusted_ty, adj.autoref)\n+                    }\n                 }\n             }\n         }\n@@ -4648,73 +4524,16 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n }\n \n pub fn adjust_ty_for_autoref<'tcx>(cx: &ctxt<'tcx>,\n-                                   span: Span,\n                                    ty: Ty<'tcx>,\n-                                   autoref: Option<&AutoRef<'tcx>>)\n-                                   -> Ty<'tcx>\n-{\n+                                   autoref: Option<AutoRef<'tcx>>)\n+                                   -> Ty<'tcx> {\n     match autoref {\n         None => ty,\n-\n-        Some(&AutoPtr(r, m, ref a)) => {\n-            let adjusted_ty = match a {\n-                &Some(box ref a) => adjust_ty_for_autoref(cx, span, ty, Some(a)),\n-                &None => ty\n-            };\n-            mk_rptr(cx, cx.mk_region(r), mt {\n-                ty: adjusted_ty,\n-                mutbl: m\n-            })\n+        Some(AutoPtr(r, m)) => {\n+            mk_rptr(cx, r, mt { ty: ty, mutbl: m })\n         }\n-\n-        Some(&AutoUnsafe(m, ref a)) => {\n-            let adjusted_ty = match a {\n-                &Some(box ref a) => adjust_ty_for_autoref(cx, span, ty, Some(a)),\n-                &None => ty\n-            };\n-            mk_ptr(cx, mt {ty: adjusted_ty, mutbl: m})\n-        }\n-\n-        Some(&AutoUnsize(ref k)) => unsize_ty(cx, ty, k, span),\n-\n-        Some(&AutoUnsizeUniq(ref k)) => ty::mk_uniq(cx, unsize_ty(cx, ty, k, span)),\n-    }\n-}\n-\n-// Take a sized type and a sizing adjustment and produce an unsized version of\n-// the type.\n-pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n-                       ty: Ty<'tcx>,\n-                       kind: &UnsizeKind<'tcx>,\n-                       span: Span)\n-                       -> Ty<'tcx> {\n-    match kind {\n-        &UnsizeLength(len) => match ty.sty {\n-            ty_vec(ty, Some(n)) => {\n-                assert!(len == n);\n-                mk_vec(cx, ty, None)\n-            }\n-            _ => cx.sess.span_bug(span,\n-                                  &format!(\"UnsizeLength with bad sty: {:?}\",\n-                                          ty_to_string(cx, ty)))\n-        },\n-        &UnsizeStruct(box ref k, tp_index) => match ty.sty {\n-            ty_struct(did, substs) => {\n-                let ty_substs = substs.types.get_slice(subst::TypeSpace);\n-                let new_ty = unsize_ty(cx, ty_substs[tp_index], k, span);\n-                let mut unsized_substs = substs.clone();\n-                unsized_substs.types.get_mut_slice(subst::TypeSpace)[tp_index] = new_ty;\n-                mk_struct(cx, did, cx.mk_substs(unsized_substs))\n-            }\n-            _ => cx.sess.span_bug(span,\n-                                  &format!(\"UnsizeStruct with bad sty: {:?}\",\n-                                          ty_to_string(cx, ty)))\n-        },\n-        &UnsizeVtable(TyTrait { ref principal, ref bounds }, _) => {\n-            mk_trait(cx, principal.clone(), bounds.clone())\n-        }\n-        &UnsizeUpcast(target_ty) => {\n-            target_ty\n+        Some(AutoUnsafe(m)) => {\n+            mk_ptr(cx, mt { ty: ty, mutbl: m })\n         }\n     }\n }\n@@ -5971,6 +5790,47 @@ pub fn tup_fields<'tcx>(v: &[Ty<'tcx>]) -> Vec<field<'tcx>> {\n     }).collect()\n }\n \n+/// Returns the deeply last field of nested structures, or the same type,\n+/// if not a structure at all. Corresponds to the only possible unsized\n+/// field, and its type can be used to determine unsizing strategy.\n+pub fn struct_tail<'tcx>(cx: &ctxt<'tcx>, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n+    while let ty_struct(def_id, substs) = ty.sty {\n+        match struct_fields(cx, def_id, substs).last() {\n+            Some(f) => ty = f.mt.ty,\n+            None => break\n+        }\n+    }\n+    ty\n+}\n+\n+/// Same as applying struct_tail on `source` and `target`, but only\n+/// keeps going as long as the two types are instances of the same\n+/// structure definitions.\n+/// For `(Foo<Foo<T>>, Foo<Trait>)`, the result will be `(Foo<T>, Trait)`,\n+/// whereas struct_tail produces `T`, and `Trait`, respectively.\n+pub fn struct_lockstep_tails<'tcx>(cx: &ctxt<'tcx>,\n+                                   source: Ty<'tcx>,\n+                                   target: Ty<'tcx>)\n+                                   -> (Ty<'tcx>, Ty<'tcx>) {\n+    let (mut a, mut b) = (source, target);\n+    while let (&ty_struct(a_did, a_substs), &ty_struct(b_did, b_substs)) = (&a.sty, &b.sty) {\n+        if a_did != b_did {\n+            continue;\n+        }\n+        if let Some(a_f) = struct_fields(cx, a_did, a_substs).last() {\n+            if let Some(b_f) = struct_fields(cx, b_did, b_substs).last() {\n+                a = a_f.mt.ty;\n+                b = b_f.mt.ty;\n+            } else {\n+                break;\n+            }\n+        } else {\n+            break;\n+        }\n+    }\n+    (a, b)\n+}\n+\n #[derive(Copy, Clone)]\n pub struct ClosureUpvar<'tcx> {\n     pub def: def::Def,\n@@ -6881,16 +6741,16 @@ pub fn with_freevars<T, F>(tcx: &ty::ctxt, fid: ast::NodeId, f: F) -> T where\n impl<'tcx> AutoAdjustment<'tcx> {\n     pub fn is_identity(&self) -> bool {\n         match *self {\n-            AdjustReifyFnPointer(..) => false,\n-            AdjustUnsafeFnPointer(..) => false,\n+            AdjustReifyFnPointer |\n+            AdjustUnsafeFnPointer => false,\n             AdjustDerefRef(ref r) => r.is_identity(),\n         }\n     }\n }\n \n impl<'tcx> AutoDerefRef<'tcx> {\n     pub fn is_identity(&self) -> bool {\n-        self.autoderefs == 0 && self.autoref.is_none()\n+        self.autoderefs == 0 && self.unsize.is_none() && self.autoref.is_none()\n     }\n }\n \n@@ -7051,8 +6911,8 @@ impl DebruijnIndex {\n impl<'tcx> Repr<'tcx> for AutoAdjustment<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         match *self {\n-            AdjustReifyFnPointer(def_id) => {\n-                format!(\"AdjustReifyFnPointer({})\", def_id.repr(tcx))\n+            AdjustReifyFnPointer => {\n+                format!(\"AdjustReifyFnPointer\")\n             }\n             AdjustUnsafeFnPointer => {\n                 format!(\"AdjustUnsafeFnPointer\")\n@@ -7064,37 +6924,21 @@ impl<'tcx> Repr<'tcx> for AutoAdjustment<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for UnsizeKind<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        match *self {\n-            UnsizeLength(n) => format!(\"UnsizeLength({})\", n),\n-            UnsizeStruct(ref k, n) => format!(\"UnsizeStruct({},{})\", k.repr(tcx), n),\n-            UnsizeVtable(ref a, ref b) => format!(\"UnsizeVtable({},{})\", a.repr(tcx), b.repr(tcx)),\n-            UnsizeUpcast(ref a) => format!(\"UnsizeUpcast({})\", a.repr(tcx)),\n-        }\n-    }\n-}\n-\n impl<'tcx> Repr<'tcx> for AutoDerefRef<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"AutoDerefRef({}, {})\", self.autoderefs, self.autoref.repr(tcx))\n+        format!(\"AutoDerefRef({}, unsize={}, {})\",\n+                self.autoderefs, self.unsize.repr(tcx), self.autoref.repr(tcx))\n     }\n }\n \n impl<'tcx> Repr<'tcx> for AutoRef<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         match *self {\n-            AutoPtr(a, b, ref c) => {\n-                format!(\"AutoPtr({},{:?},{})\", a.repr(tcx), b, c.repr(tcx))\n-            }\n-            AutoUnsize(ref a) => {\n-                format!(\"AutoUnsize({})\", a.repr(tcx))\n-            }\n-            AutoUnsizeUniq(ref a) => {\n-                format!(\"AutoUnsizeUniq({})\", a.repr(tcx))\n+            AutoPtr(a, b) => {\n+                format!(\"AutoPtr({},{:?})\", a.repr(tcx), b)\n             }\n-            AutoUnsafe(ref a, ref b) => {\n-                format!(\"AutoUnsafe({:?},{})\", a, b.repr(tcx))\n+            AutoUnsafe(ref a) => {\n+                format!(\"AutoUnsafe({:?})\", a)\n             }\n         }\n     }"}, {"sha": "19a82e3f35492058f23c8ec13f59e66de78229f8", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 4, "deletions": 27, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -477,24 +477,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::InstantiatedPredicates<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::UnsizeKind<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::UnsizeKind<'tcx> {\n-        match *self {\n-            ty::UnsizeLength(len) => ty::UnsizeLength(len),\n-            ty::UnsizeStruct(box ref k, n) => ty::UnsizeStruct(box k.fold_with(folder), n),\n-            ty::UnsizeVtable(ty::TyTrait{ref principal, ref bounds}, self_ty) => {\n-                ty::UnsizeVtable(\n-                    ty::TyTrait {\n-                        principal: principal.fold_with(folder),\n-                        bounds: bounds.fold_with(folder),\n-                    },\n-                    self_ty.fold_with(folder))\n-            }\n-            ty::UnsizeUpcast(t) => ty::UnsizeUpcast(t.fold_with(folder)),\n-        }\n-    }\n-}\n-\n impl<'tcx,O> TypeFoldable<'tcx> for traits::Obligation<'tcx,O>\n     where O : TypeFoldable<'tcx>\n {\n@@ -768,16 +750,11 @@ pub fn super_fold_autoref<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n                                                      -> ty::AutoRef<'tcx>\n {\n     match *autoref {\n-        ty::AutoPtr(r, m, None) => ty::AutoPtr(this.fold_region(r), m, None),\n-        ty::AutoPtr(r, m, Some(ref a)) => {\n-            ty::AutoPtr(this.fold_region(r), m, Some(box super_fold_autoref(this, &**a)))\n-        }\n-        ty::AutoUnsafe(m, None) => ty::AutoUnsafe(m, None),\n-        ty::AutoUnsafe(m, Some(ref a)) => {\n-            ty::AutoUnsafe(m, Some(box super_fold_autoref(this, &**a)))\n+        ty::AutoPtr(r, m) => {\n+            let r = r.fold_with(this);\n+            ty::AutoPtr(this.tcx().mk_region(r), m)\n         }\n-        ty::AutoUnsize(ref k) => ty::AutoUnsize(k.fold_with(this)),\n-        ty::AutoUnsizeUniq(ref k) => ty::AutoUnsizeUniq(k.fold_with(this)),\n+        ty::AutoUnsafe(m) => ty::AutoUnsafe(m)\n     }\n }\n "}, {"sha": "c1d71671eb3f6786ecccb6065e1a0392c0d15e69", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -1405,11 +1405,11 @@ impl LintPass for UnusedAllocation {\n         if let Some(adjustment) = cx.tcx.adjustments.borrow().get(&e.id) {\n             if let ty::AdjustDerefRef(ty::AutoDerefRef { ref autoref, .. }) = *adjustment {\n                 match autoref {\n-                    &Some(ty::AutoPtr(_, ast::MutImmutable, None)) => {\n+                    &Some(ty::AutoPtr(_, ast::MutImmutable)) => {\n                         cx.span_lint(UNUSED_ALLOCATION, e.span,\n                                      \"unnecessary allocation, use & instead\");\n                     }\n-                    &Some(ty::AutoPtr(_, ast::MutMutable, None)) => {\n+                    &Some(ty::AutoPtr(_, ast::MutMutable)) => {\n                         cx.span_lint(UNUSED_ALLOCATION, e.span,\n                                      \"unnecessary allocation, use &mut instead\");\n                     }"}, {"sha": "2ba963a42efbeb2afe9134d2282cc8460cd8694f", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -146,33 +146,6 @@ pub fn type_is_fat_ptr<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     }\n }\n \n-// Return the smallest part of `ty` which is unsized. Fails if `ty` is sized.\n-// 'Smallest' here means component of the static representation of the type; not\n-// the size of an object at runtime.\n-pub fn unsized_part_of_type<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    match ty.sty {\n-        ty::ty_str | ty::ty_trait(..) | ty::ty_vec(..) => ty,\n-        ty::ty_struct(def_id, substs) => {\n-            let unsized_fields: Vec<_> =\n-                ty::struct_fields(cx, def_id, substs)\n-                .iter()\n-                .map(|f| f.mt.ty)\n-                .filter(|ty| !type_is_sized(cx, *ty))\n-                .collect();\n-\n-            // Exactly one of the fields must be unsized.\n-            assert!(unsized_fields.len() == 1);\n-\n-            unsized_part_of_type(cx, unsized_fields[0])\n-        }\n-        _ => {\n-            assert!(type_is_sized(cx, ty),\n-                    \"unsized_part_of_type failed even though ty is unsized\");\n-            panic!(\"called unsized_part_of_type with sized ty\");\n-        }\n-    }\n-}\n-\n // Some things don't need cleanups during unwinding because the\n // task can free them all at once later. Currently only things\n // that only contain scalars and shared boxes can avoid unwind"}, {"sha": "cd56d196242243a83cfc6e6c25a1788f022d2290", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 49, "deletions": 66, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -254,7 +254,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                             &ty::expr_ty_adjusted(cx.tcx(), e));\n     let opt_adj = cx.tcx().adjustments.borrow().get(&e.id).cloned();\n     match opt_adj {\n-        Some(ty::AdjustReifyFnPointer(_def_id)) => {\n+        Some(ty::AdjustReifyFnPointer) => {\n             // FIXME(#19925) once fn item types are\n             // zero-sized, we'll need to do something here\n         }\n@@ -272,73 +272,56 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n             }\n \n-            let second_autoref = match adj.autoref {\n-                None => {\n-                    let (dv, dt) = const_deref(cx, llconst, ty);\n-                    llconst = dv;\n-\n-                    // If we derefed a fat pointer then we will have an\n-                    // open type here. So we need to update the type with\n-                    // the one returned from const_deref.\n-                    ety_adjusted = dt;\n-                    None\n-                }\n-                Some(ty::AutoUnsafe(_, opt_autoref)) |\n-                Some(ty::AutoPtr(_, _, opt_autoref)) => {\n-                    if adj.autoderefs == 0 {\n-                        // Don't copy data to do a deref+ref\n-                        // (i.e., skip the last auto-deref).\n-                        llconst = addr_of(cx, llconst, \"autoref\");\n-                    } else {\n-                        // Seeing as we are deref'ing here and take a reference\n-                        // again to make the pointer part of the far pointer below,\n-                        // we just skip the whole thing. We still need the type\n-                        // though. This works even if we don't need to deref\n-                        // because of byref semantics. Note that this is not just\n-                        // an optimisation, it is necessary for mutable vectors to\n-                        // work properly.\n-                        ty = match ty::deref(ty, true) {\n-                            Some(mt) => mt.ty,\n-                            None => {\n-                                cx.sess().bug(&format!(\"unexpected dereferenceable type {}\",\n-                                                       ty_to_string(cx.tcx(), ty)))\n-                            }\n-                        }\n-                    }\n-                    opt_autoref\n-                }\n-                Some(autoref) => {\n-                    cx.sess().span_bug(e.span,\n-                        &format!(\"unimplemented const first autoref {:?}\", autoref))\n-                }\n-            };\n-            match second_autoref {\n-                None => {}\n-                Some(box ty::AutoUnsafe(_, None)) |\n-                Some(box ty::AutoPtr(_, _, None)) => {\n+            if adj.autoref.is_some() {\n+                if adj.autoderefs == 0 {\n+                    // Don't copy data to do a deref+ref\n+                    // (i.e., skip the last auto-deref).\n                     llconst = addr_of(cx, llconst, \"autoref\");\n+                    ty = ty::mk_imm_rptr(cx.tcx(), cx.tcx().mk_region(ty::ReStatic), ty);\n                 }\n-                Some(box ty::AutoUnsize(ref k)) => {\n-                    let info =\n-                        expr::unsized_info(\n-                            cx, k, e.id, ty, param_substs,\n-                            || const_get_elt(cx, llconst, &[abi::FAT_PTR_EXTRA as u32]));\n-\n-                    let unsized_ty = ty::unsize_ty(cx.tcx(), ty, k, e.span);\n-                    let ptr_ty = type_of::in_memory_type_of(cx, unsized_ty).ptr_to();\n-                    let base = ptrcast(llconst, ptr_ty);\n-\n-                    let prev_const = cx.const_unsized().borrow_mut()\n-                                       .insert(base, llconst);\n-                    assert!(prev_const.is_none() || prev_const == Some(llconst));\n-                    assert_eq!(abi::FAT_PTR_ADDR, 0);\n-                    assert_eq!(abi::FAT_PTR_EXTRA, 1);\n-                    llconst = C_struct(cx, &[base, info], false);\n-                }\n-                Some(autoref) => {\n-                    cx.sess().span_bug(e.span,\n-                        &format!(\"unimplemented const second autoref {:?}\", autoref))\n-                }\n+            } else {\n+                let (dv, dt) = const_deref(cx, llconst, ty);\n+                llconst = dv;\n+\n+                // If we derefed a fat pointer then we will have an\n+                // open type here. So we need to update the type with\n+                // the one returned from const_deref.\n+                ety_adjusted = dt;\n+            }\n+\n+            if let Some(target) = adj.unsize {\n+                let target = monomorphize::apply_param_substs(cx.tcx(),\n+                                                              param_substs,\n+                                                              &target);\n+\n+                let pointee_ty = ty::deref(ty, true)\n+                    .expect(\"consts: unsizing got non-pointer type\").ty;\n+                let (base, old_info) = if !type_is_sized(cx.tcx(), pointee_ty) {\n+                    // Normally, the source is a thin pointer and we are\n+                    // adding extra info to make a fat pointer. The exception\n+                    // is when we are upcasting an existing object fat pointer\n+                    // to use a different vtable. In that case, we want to\n+                    // load out the original data pointer so we can repackage\n+                    // it.\n+                    (const_get_elt(cx, llconst, &[abi::FAT_PTR_ADDR as u32]),\n+                     Some(const_get_elt(cx, llconst, &[abi::FAT_PTR_EXTRA as u32])))\n+                } else {\n+                    (llconst, None)\n+                };\n+\n+                let unsized_ty = ty::deref(target, true)\n+                    .expect(\"consts: unsizing got non-pointer target type\").ty;\n+                let ptr_ty = type_of::in_memory_type_of(cx, unsized_ty).ptr_to();\n+                let base = ptrcast(base, ptr_ty);\n+                let info = expr::unsized_info(cx, pointee_ty, unsized_ty,\n+                                              old_info, param_substs);\n+\n+                let prev_const = cx.const_unsized().borrow_mut()\n+                                   .insert(base, llconst);\n+                assert!(prev_const.is_none() || prev_const == Some(llconst));\n+                assert_eq!(abi::FAT_PTR_ADDR, 0);\n+                assert_eq!(abi::FAT_PTR_EXTRA, 1);\n+                llconst = C_struct(cx, &[base, info], false);\n             }\n         }\n         None => {}"}, {"sha": "5d9d45e02a980d6ed2f524f524a8147a7e66a9a0", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 98, "deletions": 221, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -72,8 +72,7 @@ use trans::monomorphize;\n use trans::tvec;\n use trans::type_of;\n use middle::ty::{struct_fields, tup_fields};\n-use middle::ty::{AdjustDerefRef, AdjustReifyFnPointer, AdjustUnsafeFnPointer, AutoUnsafe};\n-use middle::ty::AutoPtr;\n+use middle::ty::{AdjustDerefRef, AdjustReifyFnPointer, AdjustUnsafeFnPointer};\n use middle::ty::{self, Ty};\n use middle::ty::MethodCall;\n use util::common::indenter;\n@@ -290,72 +289,39 @@ pub fn copy_fat_ptr(bcx: Block, src_ptr: ValueRef, dst_ptr: ValueRef) {\n     Store(bcx, Load(bcx, get_len(bcx, src_ptr)), get_len(bcx, dst_ptr));\n }\n \n-// Retrieve the information we are losing (making dynamic) in an unsizing\n-// adjustment.\n-//\n-// The `unadjusted_val` argument is a bit funny. It is intended\n-// for use in an upcast, where the new vtable for an object will\n-// be drived from the old one. Hence it is a pointer to the fat\n-// pointer.\n-pub fn unsized_info_bcx<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    kind: &ty::UnsizeKind<'tcx>,\n-                                    id: ast::NodeId,\n-                                    unadjusted_ty: Ty<'tcx>,\n-                                    unadjusted_val: ValueRef, // see above (*)\n-                                    param_substs: &'tcx subst::Substs<'tcx>)\n-                                    -> ValueRef {\n-    unsized_info(\n-        bcx.ccx(),\n-        kind,\n-        id,\n-        unadjusted_ty,\n-        param_substs,\n-        || Load(bcx, GEPi(bcx, unadjusted_val, &[0, abi::FAT_PTR_EXTRA])))\n-}\n-\n-// Same as `unsize_info_bcx`, but does not require a bcx -- instead it\n-// takes an extra closure to compute the upcast vtable.\n-pub fn unsized_info<'ccx, 'tcx, MK_UPCAST_VTABLE>(\n-    ccx: &CrateContext<'ccx, 'tcx>,\n-    kind: &ty::UnsizeKind<'tcx>,\n-    id: ast::NodeId,\n-    unadjusted_ty: Ty<'tcx>,\n-    param_substs: &'tcx subst::Substs<'tcx>,\n-    mk_upcast_vtable: MK_UPCAST_VTABLE) // see notes above\n-    -> ValueRef\n-    where MK_UPCAST_VTABLE: FnOnce() -> ValueRef\n-{\n-    debug!(\"unsized_info(kind={:?}, id={}, unadjusted_ty={})\",\n-           kind, id, unadjusted_ty.repr(ccx.tcx()));\n-    match kind {\n-        &ty::UnsizeLength(len) => C_uint(ccx, len),\n-        &ty::UnsizeStruct(box ref k, tp_index) => match unadjusted_ty.sty {\n-            ty::ty_struct(_, ref substs) => {\n-                let ty_substs = substs.types.get_slice(subst::TypeSpace);\n-                unsized_info(ccx, k, id, ty_substs[tp_index], param_substs,\n-                             mk_upcast_vtable)\n-            }\n-            _ => ccx.sess().bug(&format!(\"UnsizeStruct with bad sty: {}\",\n-                                         unadjusted_ty.repr(ccx.tcx())))\n-        },\n-        &ty::UnsizeVtable(ty::TyTrait { ref principal, .. }, _) => {\n+/// Retrieve the information we are losing (making dynamic) in an unsizing\n+/// adjustment.\n+///\n+/// The `old_info` argument is a bit funny. It is intended for use\n+/// in an upcast, where the new vtable for an object will be drived\n+/// from the old one.\n+pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n+                                source: Ty<'tcx>,\n+                                target: Ty<'tcx>,\n+                                old_info: Option<ValueRef>,\n+                                param_substs: &'tcx subst::Substs<'tcx>)\n+                                -> ValueRef {\n+    let (source, target) = ty::struct_lockstep_tails(ccx.tcx(), source, target);\n+    match (&source.sty, &target.sty) {\n+        (&ty::ty_vec(_, Some(len)), &ty::ty_vec(_, None)) => C_uint(ccx, len),\n+        (&ty::ty_trait(_), &ty::ty_trait(_)) => {\n+            // For now, upcasts are limited to changes in marker\n+            // traits, and hence never actually require an actual\n+            // change to the vtable.\n+            old_info.expect(\"unsized_info: missing old info for trait upcast\")\n+        }\n+        (_, &ty::ty_trait(box ty::TyTrait { ref principal, .. })) => {\n             // Note that we preserve binding levels here:\n-            let substs = principal.0.substs.with_self_ty(unadjusted_ty).erase_regions();\n+            let substs = principal.0.substs.with_self_ty(source).erase_regions();\n             let substs = ccx.tcx().mk_substs(substs);\n             let trait_ref = ty::Binder(Rc::new(ty::TraitRef { def_id: principal.def_id(),\n-                                                             substs: substs }));\n-            let trait_ref = monomorphize::apply_param_substs(ccx.tcx(),\n-                                                             param_substs,\n-                                                             &trait_ref);\n+                                                               substs: substs }));\n             consts::ptrcast(meth::get_vtable(ccx, trait_ref, param_substs),\n                             Type::vtable_ptr(ccx))\n         }\n-        &ty::UnsizeUpcast(_) => {\n-            // For now, upcasts are limited to changes in marker\n-            // traits, and hence never actually require an actual\n-            // change to the vtable.\n-            mk_upcast_vtable()\n-        }\n+        _ => ccx.sess().bug(&format!(\"unsized_info: invalid unsizing {} -> {}\",\n+                                     source.repr(ccx.tcx()),\n+                                     target.repr(ccx.tcx())))\n     }\n }\n \n@@ -379,210 +345,120 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n            datum.to_string(bcx.ccx()),\n            adjustment);\n     match adjustment {\n-        AdjustReifyFnPointer(_def_id) => {\n+        AdjustReifyFnPointer => {\n             // FIXME(#19925) once fn item types are\n             // zero-sized, we'll need to do something here\n         }\n         AdjustUnsafeFnPointer => {\n             // purely a type-level thing\n         }\n         AdjustDerefRef(ref adj) => {\n-            let (autoderefs, use_autoref) = match adj.autoref {\n-                // Extracting a value from a box counts as a deref, but if we are\n-                // just converting Box<[T, ..n]> to Box<[T]> we aren't really doing\n-                // a deref (and wouldn't if we could treat Box like a normal struct).\n-                Some(ty::AutoUnsizeUniq(..)) => (adj.autoderefs - 1, true),\n+            let skip_reborrows = if adj.autoderefs == 1 && adj.autoref.is_some() {\n                 // We are a bit paranoid about adjustments and thus might have a re-\n                 // borrow here which merely derefs and then refs again (it might have\n-                // a different region or mutability, but we don't care here. It might\n-                // also be just in case we need to unsize. But if there are no nested\n-                // adjustments then it should be a no-op).\n-                Some(ty::AutoPtr(_, _, None)) |\n-                Some(ty::AutoUnsafe(_, None)) if adj.autoderefs == 1 => {\n-                    match datum.ty.sty {\n-                        // Don't skip a conversion from Box<T> to &T, etc.\n-                        ty::ty_rptr(..) => {\n-                            let method_call = MethodCall::autoderef(expr.id, adj.autoderefs-1);\n-                            let method = bcx.tcx().method_map.borrow().get(&method_call).is_some();\n-                            if method {\n-                                // Don't skip an overloaded deref.\n-                                (adj.autoderefs, true)\n-                            } else {\n-                                (adj.autoderefs - 1, false)\n-                            }\n+                // a different region or mutability, but we don't care here).\n+                match datum.ty.sty {\n+                    // Don't skip a conversion from Box<T> to &T, etc.\n+                    ty::ty_rptr(..) => {\n+                        let method_call = MethodCall::autoderef(expr.id, 0);\n+                        if bcx.tcx().method_map.borrow().contains_key(&method_call) {\n+                            // Don't skip an overloaded deref.\n+                            0\n+                        } else {\n+                            1\n                         }\n-                        _ => (adj.autoderefs, true),\n                     }\n+                    _ => 0\n                 }\n-                _ => (adj.autoderefs, true)\n+            } else {\n+                0\n             };\n \n-            if autoderefs > 0 {\n+            if adj.autoderefs > skip_reborrows {\n                 // Schedule cleanup.\n                 let lval = unpack_datum!(bcx, datum.to_lvalue_datum(bcx, \"auto_deref\", expr.id));\n-                datum = unpack_datum!(\n-                    bcx, deref_multiple(bcx, expr, lval.to_expr_datum(), autoderefs));\n+                datum = unpack_datum!(bcx, deref_multiple(bcx, expr,\n+                                                          lval.to_expr_datum(),\n+                                                          adj.autoderefs - skip_reborrows));\n             }\n \n             // (You might think there is a more elegant way to do this than a\n-            // use_autoref bool, but then you remember that the borrow checker exists).\n-            if let (true, &Some(ref a)) = (use_autoref, &adj.autoref) {\n-                datum = unpack_datum!(bcx, apply_autoref(a,\n-                                                         bcx,\n-                                                         expr,\n-                                                         datum));\n+            // skip_reborrows bool, but then you remember that the borrow checker exists).\n+            if skip_reborrows == 0 && adj.autoref.is_some() {\n+                datum = unpack_datum!(bcx, apply_autoref(bcx, expr, datum));\n+            }\n+\n+            if let Some(target) = adj.unsize {\n+                datum = unpack_datum!(bcx, unsize_pointer(bcx, datum,\n+                                                          bcx.monomorphize(&target)));\n             }\n         }\n     }\n     debug!(\"after adjustments, datum={}\", datum.to_string(bcx.ccx()));\n     return DatumBlock::new(bcx, datum);\n \n-    fn apply_autoref<'blk, 'tcx>(autoref: &ty::AutoRef<'tcx>,\n-                                 bcx: Block<'blk, 'tcx>,\n+    fn apply_autoref<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  expr: &ast::Expr,\n                                  datum: Datum<'tcx, Expr>)\n                                  -> DatumBlock<'blk, 'tcx, Expr> {\n         let mut bcx = bcx;\n-        let mut datum = datum;\n-\n-        let datum = match autoref {\n-            &AutoPtr(_, _, ref a) | &AutoUnsafe(_, ref a) => {\n-                debug!(\"  AutoPtr\");\n-                if let &Some(box ref a) = a {\n-                    datum = unpack_datum!(bcx, apply_autoref(a, bcx, expr, datum));\n-                }\n-                if !type_is_sized(bcx.tcx(), datum.ty) {\n-                    // Arrange cleanup\n-                    let lval = unpack_datum!(bcx,\n-                        datum.to_lvalue_datum(bcx, \"ref_fat_ptr\", expr.id));\n-                    unpack_datum!(bcx, ref_fat_ptr(bcx, lval))\n-                } else {\n-                    unpack_datum!(bcx, auto_ref(bcx, datum, expr))\n-                }\n-            }\n-            &ty::AutoUnsize(ref k) => {\n-                debug!(\"  AutoUnsize\");\n-                unpack_datum!(bcx, unsize_expr(bcx, expr, datum, k))\n-            }\n-            &ty::AutoUnsizeUniq(ty::UnsizeLength(len)) => {\n-                debug!(\"  AutoUnsizeUniq(UnsizeLength)\");\n-                unpack_datum!(bcx, unsize_unique_vec(bcx, expr, datum, len))\n-            }\n-            &ty::AutoUnsizeUniq(ref k) => {\n-                debug!(\"  AutoUnsizeUniq\");\n-                unpack_datum!(bcx, unsize_unique_expr(bcx, expr, datum, k))\n-            }\n-        };\n \n-        DatumBlock::new(bcx, datum)\n+        if !type_is_sized(bcx.tcx(), datum.ty) {\n+            // Arrange cleanup\n+            let lval = unpack_datum!(bcx,\n+                datum.to_lvalue_datum(bcx, \"ref_fat_ptr\", expr.id));\n+            ref_fat_ptr(bcx, lval)\n+        } else {\n+            auto_ref(bcx, datum, expr)\n+        }\n     }\n \n-    fn unsize_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               expr: &ast::Expr,\n-                               datum: Datum<'tcx, Expr>,\n-                               k: &ty::UnsizeKind<'tcx>)\n-                               -> DatumBlock<'blk, 'tcx, Expr> {\n+    fn unsize_pointer<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                  datum: Datum<'tcx, Expr>,\n+                                  target: Ty<'tcx>)\n+                                  -> DatumBlock<'blk, 'tcx, Expr> {\n         let mut bcx = bcx;\n-        let tcx = bcx.tcx();\n-        let datum_ty = datum.ty;\n-        let unsized_ty = ty::unsize_ty(tcx, datum_ty, k, expr.span);\n-        debug!(\"unsized_ty={}\", unsized_ty.repr(bcx.tcx()));\n-\n-        let info = unsized_info_bcx(bcx, k, expr.id, datum_ty, datum.val, bcx.fcx.param_substs);\n-\n-        // Arrange cleanup\n-        let lval = unpack_datum!(bcx, datum.to_lvalue_datum(bcx, \"into_fat_ptr\", expr.id));\n+        let unsized_ty = ty::deref(target, true)\n+            .expect(\"expr::unsize got non-pointer target type\").ty;\n+        debug!(\"unsize_lvalue(unsized_ty={})\", unsized_ty.repr(bcx.tcx()));\n \n-        // Compute the base pointer. This doesn't change the pointer value,\n-        // but merely its type.\n-        let ptr_ty = type_of::in_memory_type_of(bcx.ccx(), unsized_ty).ptr_to();\n-        let base = if !type_is_sized(bcx.tcx(), lval.ty) {\n+        // We do not arrange cleanup ourselves; if we already are an\n+        // L-value, then cleanup will have already been scheduled (and\n+        // the `datum.to_rvalue_datum` call below will emit code to zero\n+        // the drop flag when moving out of the L-value). If we are an\n+        // R-value, then we do not need to schedule cleanup.\n+        let datum = unpack_datum!(bcx, datum.to_rvalue_datum(bcx, \"__unsize_ref\"));\n+\n+        let pointee_ty = ty::deref(datum.ty, true)\n+            .expect(\"expr::unsize got non-pointer datum type\").ty;\n+        let (base, old_info) = if !type_is_sized(bcx.tcx(), pointee_ty) {\n             // Normally, the source is a thin pointer and we are\n             // adding extra info to make a fat pointer. The exception\n             // is when we are upcasting an existing object fat pointer\n             // to use a different vtable. In that case, we want to\n             // load out the original data pointer so we can repackage\n             // it.\n-            Load(bcx, get_dataptr(bcx, lval.val))\n+            (Load(bcx, get_dataptr(bcx, datum.val)),\n+             Some(Load(bcx, get_len(bcx, datum.val))))\n         } else {\n-            lval.val\n+            (datum.val, None)\n         };\n+\n+        let info = unsized_info(bcx.ccx(), pointee_ty, unsized_ty,\n+                                old_info, bcx.fcx.param_substs);\n+\n+        // Compute the base pointer. This doesn't change the pointer value,\n+        // but merely its type.\n+        let ptr_ty = type_of::in_memory_type_of(bcx.ccx(), unsized_ty).ptr_to();\n         let base = PointerCast(bcx, base, ptr_ty);\n \n-        let llty = type_of::type_of(bcx.ccx(), unsized_ty);\n+        let llty = type_of::type_of(bcx.ccx(), target);\n         // HACK(eddyb) get around issues with lifetime intrinsics.\n         let scratch = alloca_no_lifetime(bcx, llty, \"__fat_ptr\");\n         Store(bcx, base, get_dataptr(bcx, scratch));\n         Store(bcx, info, get_len(bcx, scratch));\n \n-        DatumBlock::new(bcx, Datum::new(scratch, unsized_ty, LvalueExpr))\n-    }\n-\n-    fn unsize_unique_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                     expr: &ast::Expr,\n-                                     datum: Datum<'tcx, Expr>,\n-                                     len: usize)\n-                                     -> DatumBlock<'blk, 'tcx, Expr> {\n-        let mut bcx = bcx;\n-        let tcx = bcx.tcx();\n-\n-        let datum_ty = datum.ty;\n-\n-        debug!(\"unsize_unique_vec expr.id={} datum_ty={} len={}\",\n-               expr.id, datum_ty.repr(tcx), len);\n-\n-        // We do not arrange cleanup ourselves; if we already are an\n-        // L-value, then cleanup will have already been scheduled (and\n-        // the `datum.store_to` call below will emit code to zero the\n-        // drop flag when moving out of the L-value). If we are an R-value,\n-        // then we do not need to schedule cleanup.\n-\n-        let ll_len = C_uint(bcx.ccx(), len);\n-        let unit_ty = ty::sequence_element_type(tcx, ty::type_content(datum_ty));\n-        let vec_ty = ty::mk_uniq(tcx, ty::mk_vec(tcx, unit_ty, None));\n-        let scratch = rvalue_scratch_datum(bcx, vec_ty, \"__unsize_unique\");\n-\n-        let base = get_dataptr(bcx, scratch.val);\n-        let base = PointerCast(bcx,\n-                               base,\n-                               type_of::type_of(bcx.ccx(), datum_ty).ptr_to());\n-        bcx = datum.store_to(bcx, base);\n-\n-        Store(bcx, ll_len, get_len(bcx, scratch.val));\n-        DatumBlock::new(bcx, scratch.to_expr_datum())\n-    }\n-\n-    fn unsize_unique_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                      expr: &ast::Expr,\n-                                      datum: Datum<'tcx, Expr>,\n-                                      k: &ty::UnsizeKind<'tcx>)\n-                                      -> DatumBlock<'blk, 'tcx, Expr> {\n-        let mut bcx = bcx;\n-        let tcx = bcx.tcx();\n-\n-        let datum_ty = datum.ty;\n-        let unboxed_ty = match datum_ty.sty {\n-            ty::ty_uniq(t) => t,\n-            _ => bcx.sess().bug(&format!(\"Expected ty_uniq, found {}\",\n-                                        bcx.ty_to_string(datum_ty)))\n-        };\n-        let result_ty = ty::mk_uniq(tcx, ty::unsize_ty(tcx, unboxed_ty, k, expr.span));\n-\n-        // We do not arrange cleanup ourselves; if we already are an\n-        // L-value, then cleanup will have already been scheduled (and\n-        // the `datum.store_to` call below will emit code to zero the\n-        // drop flag when moving out of the L-value). If we are an R-value,\n-        // then we do not need to schedule cleanup.\n-\n-        let scratch = rvalue_scratch_datum(bcx, result_ty, \"__uniq_fat_ptr\");\n-        let llbox_ty = type_of::type_of(bcx.ccx(), datum_ty);\n-        let base = PointerCast(bcx, get_dataptr(bcx, scratch.val), llbox_ty.ptr_to());\n-        bcx = datum.store_to(bcx, base);\n-\n-        let info = unsized_info_bcx(bcx, k, expr.id, unboxed_ty, base, bcx.fcx.param_substs);\n-        Store(bcx, info, get_len(bcx, scratch.val));\n-\n-        DatumBlock::new(bcx, scratch.to_expr_datum())\n+        DatumBlock::new(bcx, Datum::new(scratch, target, RvalueExpr(Rvalue::new(ByRef))))\n     }\n }\n \n@@ -2233,7 +2109,7 @@ fn deref_multiple<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = bcx;\n     let mut datum = datum;\n     for i in 0..times {\n-        let method_call = MethodCall::autoderef(expr.id, i);\n+        let method_call = MethodCall::autoderef(expr.id, i as u32);\n         datum = unpack_datum!(bcx, deref_once(bcx, expr, datum, method_call));\n     }\n     DatumBlock { bcx: bcx, datum: datum }\n@@ -2265,10 +2141,11 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // converts from the `Smaht<T>` pointer that we have into\n             // a `&T` pointer.  We can then proceed down the normal\n             // path (below) to dereference that `&T`.\n-            let datum = match method_call.adjustment {\n+            let datum = if method_call.autoderef == 0 {\n+                datum\n+            } else {\n                 // Always perform an AutoPtr when applying an overloaded auto-deref\n-                ty::AutoDeref(_) => unpack_datum!(bcx, auto_ref(bcx, datum, expr)),\n-                _ => datum\n+                unpack_datum!(bcx, auto_ref(bcx, datum, expr))\n             };\n \n             let ref_ty = // invoked methods have their LB regions instantiated"}, {"sha": "8257dab20facb52a5259271b0a0bf68dc59a5d67", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -359,14 +359,14 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n                   cx.tn().find_type(\"str_slice\").unwrap()\n               } else {\n                   let ptr_ty = in_memory_type_of(cx, ty).ptr_to();\n-                  let unsized_part = unsized_part_of_type(cx.tcx(), ty);\n+                  let unsized_part = ty::struct_tail(cx.tcx(), ty);\n                   let info_ty = match unsized_part.sty {\n                       ty::ty_str | ty::ty_vec(..) => {\n                           Type::uint_from_ty(cx, ast::TyUs)\n                       }\n                       ty::ty_trait(_) => Type::vtable_ptr(cx),\n                       _ => panic!(\"Unexpected type returned from \\\n-                                   unsized_part_of_type: {} for ty={}\",\n+                                   struct_tail: {} for ty={}\",\n                                   unsized_part.repr(cx.tcx()), ty.repr(cx.tcx()))\n                   };\n                   Type::struct_(cx, &[ptr_ty, info_ty], false)"}, {"sha": "ff22127fdc61589a890551ecee8d6d8beddf2f26", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -59,6 +59,7 @@ use middle::ty::{self, RegionEscape, Ty};\n use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope, ExplicitRscope,\n              ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope};\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n+use util::nodemap::FnvHashSet;\n use util::ppaux::{self, Repr, UserString};\n \n use std::iter::repeat;\n@@ -1011,13 +1012,58 @@ fn trait_ref_to_object_type<'tcx>(this: &AstConv<'tcx>,\n                                                      projection_bounds,\n                                                      bounds);\n \n-    let result = ty::mk_trait(this.tcx(), trait_ref, existential_bounds);\n+    let result = make_object_type(this, span, trait_ref, existential_bounds);\n     debug!(\"trait_ref_to_object_type: result={}\",\n            result.repr(this.tcx()));\n \n     result\n }\n \n+fn make_object_type<'tcx>(this: &AstConv<'tcx>,\n+                          span: Span,\n+                          principal: ty::PolyTraitRef<'tcx>,\n+                          bounds: ty::ExistentialBounds<'tcx>)\n+                          -> Ty<'tcx> {\n+    let tcx = this.tcx();\n+    let object = ty::TyTrait {\n+        principal: principal,\n+        bounds: bounds\n+    };\n+    let object_trait_ref =\n+        object.principal_trait_ref_with_self_ty(tcx, tcx.types.err);\n+\n+    // ensure the super predicates and stop if we encountered an error\n+    if this.ensure_super_predicates(span, object.principal_def_id()).is_err() {\n+        return tcx.types.err;\n+    }\n+\n+    let mut associated_types: FnvHashSet<(ast::DefId, ast::Name)> =\n+        traits::supertraits(tcx, object_trait_ref)\n+        .flat_map(|tr| {\n+            let trait_def = ty::lookup_trait_def(tcx, tr.def_id());\n+            trait_def.associated_type_names\n+                .clone()\n+                .into_iter()\n+                .map(move |associated_type_name| (tr.def_id(), associated_type_name))\n+        })\n+        .collect();\n+\n+    for projection_bound in &object.bounds.projection_bounds {\n+        let pair = (projection_bound.0.projection_ty.trait_ref.def_id,\n+                    projection_bound.0.projection_ty.item_name);\n+        associated_types.remove(&pair);\n+    }\n+\n+    for (trait_def_id, name) in associated_types {\n+        span_err!(tcx.sess, span, E0191,\n+            \"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n+                    name.user_string(tcx),\n+                    ty::item_path_str(tcx, trait_def_id));\n+    }\n+\n+    ty::mk_trait(tcx, object.principal, object.bounds)\n+}\n+\n fn report_ambiguous_associated_type(tcx: &ty::ctxt,\n                                     span: Span,\n                                     type_str: &str,\n@@ -1914,7 +1960,7 @@ fn conv_ty_poly_trait_ref<'tcx>(\n                                                         projection_bounds,\n                                                         partitioned_bounds);\n \n-    ty::mk_trait(this.tcx(), main_trait_bound, bounds)\n+    make_object_type(this, span, main_trait_bound, bounds)\n }\n \n pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>("}, {"sha": "b065eb2d2741cff20e1669944c8b04b5d3fa4d08", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -125,14 +125,10 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n            adjusted_ty.repr(fcx.tcx()),\n            autoderefs);\n \n-    let autoderefref = ty::AutoDerefRef { autoderefs: autoderefs, autoref: None };\n-\n     // If the callee is a bare function or a closure, then we're all set.\n     match structurally_resolved_type(fcx, callee_expr.span, adjusted_ty).sty {\n         ty::ty_bare_fn(..) => {\n-            fcx.write_adjustment(callee_expr.id,\n-                                 callee_expr.span,\n-                                 ty::AdjustDerefRef(autoderefref));\n+            fcx.write_autoderef_adjustment(callee_expr.id, autoderefs);\n             return Some(CallStep::Builtin);\n         }\n \n@@ -149,14 +145,14 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     fcx.infcx().replace_late_bound_regions_with_fresh_var(call_expr.span,\n                                                                           infer::FnCall,\n                                                                           &closure_ty.sig).0;\n-                fcx.record_deferred_call_resolution(\n-                    def_id,\n-                    Box::new(CallResolution {call_expr: call_expr,\n-                                         callee_expr: callee_expr,\n-                                         adjusted_ty: adjusted_ty,\n-                                         autoderefref: autoderefref,\n-                                         fn_sig: fn_sig.clone(),\n-                                         closure_def_id: def_id}));\n+                fcx.record_deferred_call_resolution(def_id, Box::new(CallResolution {\n+                    call_expr: call_expr,\n+                    callee_expr: callee_expr,\n+                    adjusted_ty: adjusted_ty,\n+                    autoderefs: autoderefs,\n+                    fn_sig: fn_sig.clone(),\n+                    closure_def_id: def_id\n+                }));\n                 return Some(CallStep::DeferredClosure(fn_sig));\n             }\n         }\n@@ -176,15 +172,15 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         _ => {}\n     }\n \n-    try_overloaded_call_traits(fcx, call_expr, callee_expr, adjusted_ty, autoderefref)\n+    try_overloaded_call_traits(fcx, call_expr, callee_expr, adjusted_ty, autoderefs)\n         .map(|method_callee| CallStep::Overloaded(method_callee))\n }\n \n fn try_overloaded_call_traits<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                        call_expr: &ast::Expr,\n                                        callee_expr: &ast::Expr,\n                                        adjusted_ty: Ty<'tcx>,\n-                                       autoderefref: ty::AutoDerefRef<'tcx>)\n+                                       autoderefs: usize)\n                                        -> Option<ty::MethodCallee<'tcx>>\n {\n     // Try the options that are least restrictive on the caller first.\n@@ -203,7 +199,8 @@ fn try_overloaded_call_traits<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                Some(&*callee_expr),\n                                                method_name,\n                                                trait_def_id,\n-                                               autoderefref.clone(),\n+                                               autoderefs,\n+                                               false,\n                                                adjusted_ty,\n                                                None) {\n             None => continue,\n@@ -335,19 +332,19 @@ struct CallResolution<'tcx> {\n     call_expr: &'tcx ast::Expr,\n     callee_expr: &'tcx ast::Expr,\n     adjusted_ty: Ty<'tcx>,\n-    autoderefref: ty::AutoDerefRef<'tcx>,\n+    autoderefs: usize,\n     fn_sig: ty::FnSig<'tcx>,\n     closure_def_id: ast::DefId,\n }\n \n impl<'tcx> Repr<'tcx> for CallResolution<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"CallResolution(call_expr={}, callee_expr={}, adjusted_ty={}, \\\n-                autoderefref={}, fn_sig={}, closure_def_id={})\",\n+                autoderefs={}, fn_sig={}, closure_def_id={})\",\n                 self.call_expr.repr(tcx),\n                 self.callee_expr.repr(tcx),\n                 self.adjusted_ty.repr(tcx),\n-                self.autoderefref.repr(tcx),\n+                self.autoderefs,\n                 self.fn_sig.repr(tcx),\n                 self.closure_def_id.repr(tcx))\n     }\n@@ -364,7 +361,7 @@ impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n \n         // We may now know enough to figure out fn vs fnmut etc.\n         match try_overloaded_call_traits(fcx, self.call_expr, self.callee_expr,\n-                                         self.adjusted_ty, self.autoderefref.clone()) {\n+                                         self.adjusted_ty, self.autoderefs) {\n             Some(method_callee) => {\n                 // One problem is that when we get here, we are going\n                 // to have a newly instantiated function signature"}, {"sha": "acdeda3d546bdd44c12284de431ff34731879255", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 194, "deletions": 201, "changes": 395, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -61,21 +61,26 @@\n //! we may want to adjust precisely when coercions occur.\n \n use check::{autoderef, FnCtxt, NoPreference, PreferMutLvalue, UnresolvedTypeAction};\n+use check::vtable;\n \n use middle::infer::{self, Coercion};\n use middle::subst;\n-use middle::ty::{AutoPtr, AutoDerefRef, AdjustDerefRef, AutoUnsize, AutoUnsafe};\n+use middle::traits;\n+use middle::ty::{AutoDerefRef, AdjustDerefRef};\n use middle::ty::{self, mt, Ty};\n use middle::ty_relate::RelateResult;\n use util::common::indent;\n use util::ppaux;\n use util::ppaux::Repr;\n \n+use std::cell::Cell;\n use syntax::ast;\n \n struct Coerce<'a, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     origin: infer::TypeOrigin,\n+    trace: TypeTrace<'tcx>,\n+    unsizing_obligation: Cell<Option<Ty<'tcx>>>\n }\n \n type CoerceResult<'tcx> = RelateResult<'tcx, Option<ty::AutoAdjustment<'tcx>>>;\n@@ -144,11 +149,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         self.unpack_actual_value(a, |a| {\n             match a.sty {\n-                ty::ty_bare_fn(Some(a_def_id), a_f) => {\n+                ty::ty_bare_fn(Some(_), a_f) => {\n                     // Function items are coercible to any closure\n                     // type; function pointers are not (that would\n                     // require double indirection).\n-                    self.coerce_from_fn_item(a, a_def_id, a_f, b)\n+                    self.coerce_from_fn_item(a, a_f, b)\n                 }\n                 ty::ty_bare_fn(None, a_f) => {\n                     // We permit coercion of fn pointers to drop the\n@@ -184,18 +189,16 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         match a.sty {\n             ty::ty_rptr(_, mt_a) => {\n-                if !can_coerce_mutbls(mt_a.mutbl, mutbl_b) {\n-                    return Err(ty::terr_mutability);\n-                }\n+                try!(coerce_mutbls(mt_a.mutbl, mutbl_b));\n             }\n             _ => return self.subtype(a, b)\n         }\n \n         let coercion = Coercion(self.origin.span());\n         let r_borrow = self.fcx.infcx().next_region_var(coercion);\n-        let autoref = Some(AutoPtr(r_borrow, mutbl_b, None));\n-\n         let r_borrow = self.tcx().mk_region(r_borrow);\n+        let autoref = Some(ty::AutoPtr(r_borrow, mutbl_b));\n+\n         let lvalue_pref = match mutbl_b {\n             ast::MutMutable => PreferMutLvalue,\n             ast::MutImmutable => NoPreference\n@@ -229,7 +232,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             Some(_) => {\n                 Ok(Some(AdjustDerefRef(AutoDerefRef {\n                     autoderefs: autoderefs,\n-                    autoref: autoref\n+                    autoref: autoref,\n+                    unsize: None\n                 })))\n             }\n             None => {\n@@ -257,183 +261,148 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // we can't unify [T] with U. But to properly support DST, we need to allow\n         // that, at which point we will need extra checks on b here.\n \n-        match (&a.sty, &b.sty) {\n-            (&ty::ty_rptr(_, ty::mt{ty: t_a, mutbl: mutbl_a}), &ty::ty_rptr(_, mt_b)) => {\n-                match self.unsize_ty(t_a, mt_b.ty) {\n-                    Some((ty, kind)) => {\n-                        if !can_coerce_mutbls(mutbl_a, mt_b.mutbl) {\n-                            return Err(ty::terr_mutability);\n-                        }\n-\n-                        let coercion = Coercion(self.origin.span());\n-                        let r_borrow = self.fcx.infcx().next_region_var(coercion);\n-                        let ty = ty::mk_rptr(self.tcx(),\n-                                             self.tcx().mk_region(r_borrow),\n-                                             ty::mt{ty: ty, mutbl: mt_b.mutbl});\n-                        try!(self.subtype(ty, b));\n-                        debug!(\"Success, coerced with AutoDerefRef(1, \\\n-                                AutoPtr(AutoUnsize({:?})))\", kind);\n-                        Ok(Some(AdjustDerefRef(AutoDerefRef {\n-                            autoderefs: 1,\n-                            autoref: Some(ty::AutoPtr(r_borrow, mt_b.mutbl,\n-                                                      Some(box AutoUnsize(kind))))\n-                        })))\n-                    }\n-                    _ => Err(ty::terr_mismatch)\n+        let (reborrow, target) = match (&a.sty, &b.sty) {\n+            (&ty::ty_rptr(_, mt_a), &ty::ty_rptr(_, mt_b)) => {\n+                if let Some(target) = self.unsize_ty(mt_a.ty, mt_b.ty) {\n+                    try!(coerce_mutbls(mt_a.mutbl, mt_b.mutbl));\n+\n+                    let coercion = Coercion(self.trace.clone());\n+                    let r_borrow = self.fcx.infcx().next_region_var(coercion);\n+                    let region = self.tcx().mk_region(r_borrow);\n+                    (Some(ty::AutoPtr(region, mt_b.mutbl)), target)\n+                } else {\n+                    return Err(ty::terr_mismatch);\n                 }\n             }\n-            (&ty::ty_rptr(_, ty::mt{ty: t_a, mutbl: mutbl_a}), &ty::ty_ptr(mt_b)) => {\n-                match self.unsize_ty(t_a, mt_b.ty) {\n-                    Some((ty, kind)) => {\n-                        if !can_coerce_mutbls(mutbl_a, mt_b.mutbl) {\n-                            return Err(ty::terr_mutability);\n-                        }\n-\n-                        let ty = ty::mk_ptr(self.tcx(),\n-                                             ty::mt{ty: ty, mutbl: mt_b.mutbl});\n-                        try!(self.subtype(ty, b));\n-                        debug!(\"Success, coerced with AutoDerefRef(1, \\\n-                                AutoPtr(AutoUnsize({:?})))\", kind);\n-                        Ok(Some(AdjustDerefRef(AutoDerefRef {\n-                            autoderefs: 1,\n-                            autoref: Some(ty::AutoUnsafe(mt_b.mutbl,\n-                                                         Some(box AutoUnsize(kind))))\n-                        })))\n-                    }\n-                    _ => Err(ty::terr_mismatch)\n+            (&ty::ty_rptr(_, mt_a), &ty::ty_ptr(mt_b)) => {\n+                if let Some(target) = self.unsize_ty(mt_a.ty, mt_b.ty) {\n+                    try!(coerce_mutbls(mt_a.mutbl, mt_b.mutbl));\n+                    (Some(ty::AutoUnsafe(mt_b.mutbl)), target)\n+                } else {\n+                    return Err(ty::terr_mismatch);\n                 }\n             }\n             (&ty::ty_uniq(t_a), &ty::ty_uniq(t_b)) => {\n-                match self.unsize_ty(t_a, t_b) {\n-                    Some((ty, kind)) => {\n-                        let ty = ty::mk_uniq(self.tcx(), ty);\n-                        try!(self.subtype(ty, b));\n-                        debug!(\"Success, coerced with AutoDerefRef(1, \\\n-                                AutoUnsizeUniq({:?}))\", kind);\n-                        Ok(Some(AdjustDerefRef(AutoDerefRef {\n-                            autoderefs: 1,\n-                            autoref: Some(ty::AutoUnsizeUniq(kind))\n-                        })))\n-                    }\n-                    _ => Err(ty::terr_mismatch)\n+                if let Some(target) = self.unsize_ty(t_a, t_b) {\n+                    (None, ty::mk_uniq(self.tcx(), target))\n+                } else {\n+                    return Err(ty::terr_mismatch);\n                 }\n             }\n-            _ => Err(ty::terr_mismatch)\n-        }\n+            _ => return Err(ty::terr_mismatch)\n+        };\n+\n+        let target = ty::adjust_ty_for_autoref(self.tcx(), target, reborrow);\n+        try!(self.fcx.infcx().try(|_| self.subtype(target, b)));\n+        let adjustment = AutoDerefRef {\n+            autoderefs: if reborrow.is_some() { 1 } else { 0 },\n+            autoref: reborrow,\n+            unsize: Some(target)\n+        };\n+        debug!(\"Success, coerced with {}\", adjustment.repr(self.tcx()));\n+        Ok(Some(AdjustDerefRef(adjustment)))\n     }\n \n-    // Takes a type and returns an unsized version along with the adjustment\n-    // performed to unsize it.\n-    // E.g., `[T, ..n]` -> `([T], UnsizeLength(n))`\n+    // Takes a type and returns an unsized version.\n+    // E.g., `[T, ..n]` -> `[T]`.\n     fn unsize_ty(&self,\n                  ty_a: Ty<'tcx>,\n                  ty_b: Ty<'tcx>)\n-                 -> Option<(Ty<'tcx>, ty::UnsizeKind<'tcx>)>\n-    {\n+                 -> Option<Ty<'tcx>> {\n         let tcx = self.tcx();\n \n-        self.unpack_actual_value(ty_a, |a| {\n-            self.unpack_actual_value(ty_b, |b| {\n-                debug!(\"unsize_ty(a={}, b={})\", a.repr(self.tcx()), b.repr(self.tcx()));\n-                match (&a.sty, &b.sty) {\n-                    (&ty::ty_vec(t_a, Some(len)), &ty::ty_vec(_, None)) => {\n-                        let ty = ty::mk_vec(tcx, t_a, None);\n-                        Some((ty, ty::UnsizeLength(len)))\n-                    }\n-                    (&ty::ty_trait(ref data_a), &ty::ty_trait(ref data_b)) => {\n-                        // Upcasts permit two things:\n-                        //\n-                        // 1. Dropping builtin bounds, e.g. `Foo+Send` to `Foo`\n-                        // 2. Tightening the region bound, e.g. `Foo+'a` to `Foo+'b` if `'a : 'b`\n-                        //\n-                        // Note that neither of these changes requires any\n-                        // change at runtime.  Eventually this will be\n-                        // generalized.\n-                        //\n-                        // We always upcast when we can because of reason\n-                        // #2 (region bounds).\n-                        if data_a.bounds.builtin_bounds.is_superset(&data_b.bounds.builtin_bounds) {\n-                            // construct a type `a1` which is a version of\n-                            // `a` using the upcast bounds from `b`\n-                            let bounds_a1 = ty::ExistentialBounds {\n-                                // From type b\n-                                region_bound: data_b.bounds.region_bound,\n-                                builtin_bounds: data_b.bounds.builtin_bounds,\n-\n-                                // From type a\n-                                projection_bounds: data_a.bounds.projection_bounds.clone(),\n-                            };\n-                            let ty_a1 = ty::mk_trait(tcx, data_a.principal.clone(), bounds_a1);\n-\n-                            // relate `a1` to `b`\n-                            let result = self.fcx.infcx().commit_if_ok(|_| {\n-                                // it's ok to upcast from Foo+'a to Foo+'b so long as 'a : 'b\n-                                try!(self.outlives(infer::RelateObjectBound(self.origin.span()),\n-                                                   data_a.bounds.region_bound,\n-                                                   data_b.bounds.region_bound));\n-                                self.subtype(ty_a1, ty_b)\n-                            });\n-\n-                            // if that was successful, we have a coercion\n-                            match result {\n-                                Ok(_) => Some((ty_b, ty::UnsizeUpcast(ty_b))),\n-                                Err(_) => None,\n-                            }\n-                        } else {\n-                            None\n+        self.unpack_actual_value(ty_a, |a| self.unpack_actual_value(ty_b, |b| {\n+            debug!(\"unsize_ty(a={}, b={})\", a.repr(self.tcx()), b.repr(self.tcx()));\n+            match (&a.sty, &b.sty) {\n+                (&ty::ty_vec(t_a, Some(_)), &ty::ty_vec(_, None)) => {\n+                    Some(ty::mk_vec(tcx, t_a, None))\n+                }\n+                (&ty::ty_trait(ref data_a), &ty::ty_trait(ref data_b)) => {\n+                    // Upcasts permit two things:\n+                    //\n+                    // 1. Dropping builtin bounds, e.g. `Foo+Send` to `Foo`\n+                    // 2. Tightening the region bound, e.g. `Foo+'a` to `Foo+'b` if `'a : 'b`\n+                    //\n+                    // Note that neither of these changes requires any\n+                    // change at runtime.  Eventually this will be\n+                    // generalized.\n+                    //\n+                    // We always upcast when we can because of reason\n+                    // #2 (region bounds).\n+                    if data_a.bounds.builtin_bounds.is_superset(&data_b.bounds.builtin_bounds) {\n+                        // construct a type `a1` which is a version of\n+                        // `a` using the upcast bounds from `b`\n+                        let bounds_a1 = ty::ExistentialBounds {\n+                            // From type b\n+                            region_bound: data_b.bounds.region_bound,\n+                            builtin_bounds: data_b.bounds.builtin_bounds,\n+\n+                            // From type a\n+                            projection_bounds: data_a.bounds.projection_bounds.clone(),\n+                        };\n+                        let ty_a1 = ty::mk_trait(tcx, data_a.principal.clone(), bounds_a1);\n+\n+                        // relate `a1` to `b`\n+                        let result = self.fcx.infcx().commit_if_ok(|_| {\n+                            // it's ok to upcast from Foo+'a to Foo+'b so long as 'a : 'b\n+                            try!(self.outlives(infer::RelateObjectBound(self.origin.span()),\n+                                               data_a.bounds.region_bound,\n+                                               data_b.bounds.region_bound));\n+                            self.subtype(ty_a1, ty_b)\n+                        });\n+\n+                        // if that was successful, we have a coercion\n+                        match result {\n+                            Ok(_) => Some(ty_b),\n+                            Err(_) => None,\n                         }\n+                    } else {\n+                        None\n                     }\n-                    (_, &ty::ty_trait(ref data)) => {\n-                        Some((ty_b, ty::UnsizeVtable(ty::TyTrait {\n-                                                         principal: data.principal.clone(),\n-                                                         bounds: data.bounds.clone()\n-                                                     },\n-                                                     ty_a)))\n-                    }\n-                    (&ty::ty_struct(did_a, substs_a), &ty::ty_struct(did_b, substs_b))\n-                      if did_a == did_b => {\n-                        debug!(\"unsizing a struct\");\n-                        // Try unsizing each type param in turn to see if we end up with ty_b.\n-                        let ty_substs_a = substs_a.types.get_slice(subst::TypeSpace);\n-                        let ty_substs_b = substs_b.types.get_slice(subst::TypeSpace);\n-                        assert!(ty_substs_a.len() == ty_substs_b.len());\n-\n-                        let mut result = None;\n-                        let tps = ty_substs_a.iter().zip(ty_substs_b.iter()).enumerate();\n-                        for (i, (tp_a, tp_b)) in tps {\n-                            if self.subtype(*tp_a, *tp_b).is_ok() {\n-                                continue;\n-                            }\n-                            match self.unsize_ty(*tp_a, *tp_b) {\n-                                Some((new_tp, k)) => {\n-                                    // Check that the whole types match.\n-                                    let mut new_substs = substs_a.clone();\n-                                    new_substs.types.get_mut_slice(subst::TypeSpace)[i] = new_tp;\n-                                    let ty = ty::mk_struct(tcx, did_a, tcx.mk_substs(new_substs));\n-                                    if self.subtype(ty, ty_b).is_err() {\n-                                        debug!(\"Unsized type parameter '{}', but still \\\n-                                                could not match types {} and {}\",\n-                                               ppaux::ty_to_string(tcx, *tp_a),\n-                                               ppaux::ty_to_string(tcx, ty),\n-                                               ppaux::ty_to_string(tcx, ty_b));\n-                                        // We can only unsize a single type parameter, so\n-                                        // if we unsize one and it doesn't give us the\n-                                        // type we want, then we won't succeed later.\n-                                        break;\n-                                    }\n-\n-                                    result = Some((ty, ty::UnsizeStruct(box k, i)));\n-                                    break;\n-                                }\n-                                None => {}\n+                }\n+                (_, &ty::ty_trait(_)) => {\n+                    assert!(self.unsizing_obligation.get().is_none());\n+                    self.unsizing_obligation.set(Some(a));\n+                    Some(ty_b)\n+                }\n+                (&ty::ty_struct(did_a, substs_a), &ty::ty_struct(did_b, substs_b))\n+                  if did_a == did_b => {\n+                    debug!(\"unsizing a struct\");\n+                    // Try unsizing each type param in turn to see if we end up with ty_b.\n+                    let ty_substs_a = substs_a.types.get_slice(subst::TypeSpace);\n+                    let ty_substs_b = substs_b.types.get_slice(subst::TypeSpace);\n+                    assert!(ty_substs_a.len() == ty_substs_b.len());\n+\n+                    let tps = ty_substs_a.iter().zip(ty_substs_b.iter()).enumerate();\n+                    for (i, (&tp_a, &tp_b)) in tps {\n+                        if self.subtype(*tp_a, *tp_b).is_ok() {\n+                            continue;\n+                        }\n+                        if let Some(new_tp) = self.unsize_ty(tp_a, tp_b) {\n+                            // Check that the whole types match.\n+                            let mut new_substs = substs_a.clone();\n+                            new_substs.types.get_mut_slice(subst::TypeSpace)[i] = new_tp;\n+                            let ty = ty::mk_struct(tcx, did_a, tcx.mk_substs(new_substs));\n+                            if self.subtype(ty, ty_b).is_err() {\n+                                debug!(\"Unsized type parameter '{}', but still \\\n+                                        could not match types {} and {}\",\n+                                        ppaux::ty_to_string(tcx, tp_a),\n+                                        ppaux::ty_to_string(tcx, ty),\n+                                        ppaux::ty_to_string(tcx, ty_b));\n+                                // We can only unsize a single type parameter, so\n+                                // if we unsize one and it doesn't give us the\n+                                // type we want, then we won't succeed later.\n+                                break;\n                             }\n+\n+                            return Some(ty);\n                         }\n-                        result\n                     }\n-                    _ => None\n+                    None\n                 }\n-            })\n-        })\n+                _ => None\n+            }\n+        }))\n     }\n \n     fn coerce_from_fn_pointer(&self,\n@@ -451,29 +420,22 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             debug!(\"coerce_from_fn_pointer(a={}, b={})\",\n                    a.repr(self.tcx()), b.repr(self.tcx()));\n \n-            match b.sty {\n-                ty::ty_bare_fn(None, fn_ty_b) => {\n-                    match (fn_ty_a.unsafety, fn_ty_b.unsafety) {\n-                        (ast::Unsafety::Normal, ast::Unsafety::Unsafe) => {\n-                            let unsafe_a = self.tcx().safe_to_unsafe_fn_ty(fn_ty_a);\n-                            try!(self.subtype(unsafe_a, b));\n-                            Ok(Some(ty::AdjustUnsafeFnPointer))\n-                        }\n-                        _ => {\n-                            self.subtype(a, b)\n-                        }\n+            if let ty::ty_bare_fn(None, fn_ty_b) = b.sty {\n+                match (fn_ty_a.unsafety, fn_ty_b.unsafety) {\n+                    (ast::Unsafety::Normal, ast::Unsafety::Unsafe) => {\n+                        let unsafe_a = self.tcx().safe_to_unsafe_fn_ty(fn_ty_a);\n+                        try!(self.subtype(unsafe_a, b));\n+                        return Ok(Some(ty::AdjustUnsafeFnPointer));\n                     }\n-                }\n-                _ => {\n-                    return self.subtype(a, b)\n+                    _ => {}\n                 }\n             }\n+            self.subtype(a, b)\n         })\n     }\n \n     fn coerce_from_fn_item(&self,\n                            a: Ty<'tcx>,\n-                           fn_def_id_a: ast::DefId,\n                            fn_ty_a: &'tcx ty::BareFnTy<'tcx>,\n                            b: Ty<'tcx>)\n                            -> CoerceResult<'tcx> {\n@@ -490,11 +452,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 ty::ty_bare_fn(None, _) => {\n                     let a_fn_pointer = ty::mk_bare_fn(self.tcx(), None, fn_ty_a);\n                     try!(self.subtype(a_fn_pointer, b));\n-                    Ok(Some(ty::AdjustReifyFnPointer(fn_def_id_a)))\n-                }\n-                _ => {\n-                    return self.subtype(a, b)\n+                    Ok(Some(ty::AdjustReifyFnPointer))\n                 }\n+                _ => self.subtype(a, b)\n             }\n         })\n     }\n@@ -518,16 +478,15 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // Check that the types which they point at are compatible.\n         let a_unsafe = ty::mk_ptr(self.tcx(), ty::mt{ mutbl: mutbl_b, ty: mt_a.ty });\n         try!(self.subtype(a_unsafe, b));\n-        if !can_coerce_mutbls(mt_a.mutbl, mutbl_b) {\n-            return Err(ty::terr_mutability);\n-        }\n+        try!(coerce_mutbls(mt_a.mutbl, mutbl_b));\n \n         // Although references and unsafe ptrs have the same\n         // representation, we still register an AutoDerefRef so that\n         // regionck knows that the region for `a` must be valid here.\n         Ok(Some(AdjustDerefRef(AutoDerefRef {\n             autoderefs: 1,\n-            autoref: Some(ty::AutoUnsafe(mutbl_b, None))\n+            autoref: Some(ty::AutoUnsafe(mutbl_b)),\n+            unsize: None\n         })))\n     }\n }\n@@ -538,27 +497,61 @@ pub fn mk_assignty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                              b: Ty<'tcx>)\n                              -> RelateResult<'tcx, ()> {\n     debug!(\"mk_assignty({} -> {})\", a.repr(fcx.tcx()), b.repr(fcx.tcx()));\n-    let adjustment = try!(indent(|| {\n-        fcx.infcx().commit_if_ok(|_| {\n-            Coerce {\n+    let (adjustment, unsizing_obligation) = try!(indent(|| {\n+        fcx.infcx().commit_if_ok(|| {\n+            let origin = infer::ExprAssignable(expr.span);\n+            let coerce = Coerce {\n                 fcx: fcx,\n                 origin: infer::ExprAssignable(expr.span),\n-            }.coerce(expr, a, b)\n+                trace: infer::TypeTrace::types(origin, false, a, b),\n+                unsizing_obligation: Cell::new(None)\n+            };\n+            Ok((try!(coerce.coerce(expr, a, b)),\n+                coerce.unsizing_obligation.get()))\n         })\n     }));\n+\n+    if let Some(AdjustDerefRef(auto)) = adjustment {\n+        if let (Some(source), Some(target)) = (unsizing_obligation, auto.unsize) {\n+            let target = ty::deref(target, true)\n+                            .expect(\"coercion: unsizing got non-pointer target type\").ty;\n+            let target = ty::struct_tail(fcx.tcx(), target);\n+            if let ty::ty_trait(ref ty_trait) = target.sty {\n+                vtable::check_object_safety(fcx.tcx(), ty_trait, expr.span);\n+\n+                // If the type is `Foo+'a`, ensures that the type\n+                // being cast to `Foo+'a` implements `Foo`:\n+                vtable::register_object_cast_obligations(fcx,\n+                                                         expr.span,\n+                                                         ty_trait,\n+                                                         source);\n+\n+                // If the type is `Foo+'a`, ensures that the type\n+                // being cast to `Foo+'a` outlives `'a`:\n+                let cause = traits::ObligationCause {\n+                    span: expr.span,\n+                    body_id: fcx.body_id,\n+                    code: traits::ObjectCastObligation(source)\n+                };\n+                fcx.register_region_obligation(source, ty_trait.bounds.region_bound, cause);\n+            }\n+        }\n+    }\n+\n     if let Some(adjustment) = adjustment {\n-        fcx.write_adjustment(expr.id, expr.span, adjustment);\n+        debug!(\"Success, coerced with {}\", adjustment.repr(fcx.tcx()));\n+        fcx.write_adjustment(expr.id, adjustment);\n     }\n     Ok(())\n }\n \n-fn can_coerce_mutbls(from_mutbl: ast::Mutability,\n-                     to_mutbl: ast::Mutability)\n-                     -> bool {\n+fn coerce_mutbls<'tcx>(from_mutbl: ast::Mutability,\n+                       to_mutbl: ast::Mutability)\n+                       -> CoerceResult<'tcx> {\n     match (from_mutbl, to_mutbl) {\n-        (ast::MutMutable, ast::MutMutable) => true,\n-        (ast::MutImmutable, ast::MutImmutable) => true,\n-        (ast::MutMutable, ast::MutImmutable) => true,\n-        (ast::MutImmutable, ast::MutMutable) => false,\n+        (ast::MutMutable, ast::MutMutable) |\n+        (ast::MutImmutable, ast::MutImmutable) |\n+        (ast::MutMutable, ast::MutImmutable) => Ok(None),\n+        (ast::MutImmutable, ast::MutMutable) => Err(ty::terr_mutability)\n     }\n }"}, {"sha": "4e62542854fa8076ee4720975c9f302bd45b8e4e", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 60, "deletions": 73, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -24,7 +24,6 @@ use middle::infer::InferCtxt;\n use syntax::ast;\n use syntax::codemap::Span;\n use std::rc::Rc;\n-use std::mem;\n use std::iter::repeat;\n use util::ppaux::Repr;\n \n@@ -84,7 +83,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                -> MethodCallee<'tcx>\n     {\n         // Adjust the self expression the user provided and obtain the adjusted type.\n-        let self_ty = self.adjust_self_ty(unadjusted_self_ty, &pick.adjustment);\n+        let self_ty = self.adjust_self_ty(unadjusted_self_ty, &pick);\n \n         // Make sure nobody calls `drop()` explicitly.\n         self.enforce_illegal_method_limitations(&pick);\n@@ -134,11 +133,20 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n     fn adjust_self_ty(&mut self,\n                       unadjusted_self_ty: Ty<'tcx>,\n-                      adjustment: &probe::PickAdjustment)\n+                      pick: &probe::Pick<'tcx>)\n                       -> Ty<'tcx>\n     {\n-        // Construct the actual adjustment and write it into the table\n-        let auto_deref_ref = self.create_ty_adjustment(adjustment);\n+        let (autoref, unsize) = if let Some(mutbl) = pick.autoref {\n+            let region = self.infcx().next_region_var(infer::Autoref(self.span));\n+            let autoref = ty::AutoPtr(self.tcx().mk_region(region), mutbl);\n+            (Some(autoref), pick.unsize.map(|target| {\n+                ty::adjust_ty_for_autoref(self.tcx(), target, Some(autoref))\n+            }))\n+        } else {\n+            // No unsizing should be performed without autoref.\n+            assert!(pick.unsize.is_none());\n+            (None, None)\n+        };\n \n         // Commit the autoderefs by calling `autoderef again, but this\n         // time writing the results into the various tables.\n@@ -149,47 +157,27 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                                           UnresolvedTypeAction::Error,\n                                                           NoPreference,\n                                                           |_, n| {\n-            if n == auto_deref_ref.autoderefs {\n+            if n == pick.autoderefs {\n                 Some(())\n             } else {\n                 None\n             }\n         });\n-        assert_eq!(n, auto_deref_ref.autoderefs);\n+        assert_eq!(n, pick.autoderefs);\n         assert_eq!(result, Some(()));\n \n-        let final_ty =\n-            ty::adjust_ty_for_autoref(self.tcx(), self.span, autoderefd_ty,\n-                                      auto_deref_ref.autoref.as_ref());\n-\n         // Write out the final adjustment.\n-        self.fcx.write_adjustment(self.self_expr.id, self.span, ty::AdjustDerefRef(auto_deref_ref));\n-\n-        final_ty\n-    }\n+        self.fcx.write_adjustment(self.self_expr.id,\n+                                  ty::AdjustDerefRef(ty::AutoDerefRef {\n+            autoderefs: pick.autoderefs,\n+            autoref: autoref,\n+            unsize: unsize\n+        }));\n \n-    fn create_ty_adjustment(&mut self,\n-                            adjustment: &probe::PickAdjustment)\n-                            -> ty::AutoDerefRef<'tcx>\n-    {\n-        match *adjustment {\n-            probe::AutoDeref(num) => {\n-                ty::AutoDerefRef {\n-                    autoderefs: num,\n-                    autoref: None,\n-                }\n-            }\n-            probe::AutoUnsizeLength(autoderefs, len) => {\n-                ty::AutoDerefRef {\n-                    autoderefs: autoderefs,\n-                    autoref: Some(ty::AutoUnsize(ty::UnsizeLength(len))),\n-                }\n-            }\n-            probe::AutoRef(mutability, ref sub_adjustment) => {\n-                let deref = self.create_ty_adjustment(&**sub_adjustment);\n-                let region = self.infcx().next_region_var(infer::Autoref(self.span));\n-                wrap_autoref(deref, |base| ty::AutoPtr(region, mutability, base))\n-            }\n+        if let Some(target) = unsize {\n+            target\n+        } else {\n+            ty::adjust_ty_for_autoref(self.tcx(), autoderefd_ty, autoref)\n         }\n     }\n \n@@ -499,10 +487,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                             .adjustments\n                                             .borrow()\n                                             .get(&expr.id) {\n-                Some(&ty::AdjustDerefRef(ty::AutoDerefRef {\n-                    autoderefs: autoderef_count,\n-                    autoref: _\n-                })) => autoderef_count,\n+                Some(&ty::AdjustDerefRef(ref adj)) => adj.autoderefs,\n                 Some(_) | None => 0,\n             };\n \n@@ -529,17 +514,6 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             if i != 0 {\n                 match expr.node {\n                     ast::ExprIndex(ref base_expr, ref index_expr) => {\n-                        let mut base_adjustment =\n-                            match self.fcx.inh.adjustments.borrow().get(&base_expr.id) {\n-                                Some(&ty::AdjustDerefRef(ref adr)) => (*adr).clone(),\n-                                None => ty::AutoDerefRef { autoderefs: 0, autoref: None },\n-                                Some(_) => {\n-                                    self.tcx().sess.span_bug(\n-                                        base_expr.span,\n-                                        \"unexpected adjustment type\");\n-                                }\n-                            };\n-\n                         // If this is an overloaded index, the\n                         // adjustment will include an extra layer of\n                         // autoref because the method is an &self/&mut\n@@ -548,21 +522,44 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         // expects. This is annoying and horrible. We\n                         // ought to recode this routine so it doesn't\n                         // (ab)use the normal type checking paths.\n-                        base_adjustment.autoref = match base_adjustment.autoref {\n-                            None => { None }\n-                            Some(ty::AutoPtr(_, _, None)) => { None }\n-                            Some(ty::AutoPtr(_, _, Some(box r))) => { Some(r) }\n+                        let adj = self.fcx.inh.adjustments.borrow().get(&base_expr.id).cloned();\n+                        let (autoderefs, unsize) = match adj {\n+                            Some(ty::AdjustDerefRef(adr)) => match adr.autoref {\n+                                None => {\n+                                    assert!(adr.unsize.is_none());\n+                                    (adr.autoderefs, None)\n+                                }\n+                                Some(ty::AutoPtr(_, _)) => {\n+                                    (adr.autoderefs, adr.unsize.map(|target| {\n+                                        ty::deref(target, false)\n+                                            .expect(\"fixup: AutoPtr is not &T\").ty\n+                                    }))\n+                                }\n+                                Some(_) => {\n+                                    self.tcx().sess.span_bug(\n+                                        base_expr.span,\n+                                        &format!(\"unexpected adjustment autoref {}\",\n+                                                adr.repr(self.tcx())));\n+                                }\n+                            },\n+                            None => (0, None),\n                             Some(_) => {\n                                 self.tcx().sess.span_bug(\n                                     base_expr.span,\n-                                    \"unexpected adjustment autoref\");\n+                                    \"unexpected adjustment type\");\n                             }\n                         };\n \n-                        let adjusted_base_ty =\n-                            self.fcx.adjust_expr_ty(\n-                                &**base_expr,\n-                                Some(&ty::AdjustDerefRef(base_adjustment.clone())));\n+                        let (adjusted_base_ty, unsize) = if let Some(target) = unsize {\n+                            (target, true)\n+                        } else {\n+                            (self.fcx.adjust_expr_ty(base_expr,\n+                                Some(&ty::AdjustDerefRef(ty::AutoDerefRef {\n+                                    autoderefs: autoderefs,\n+                                    autoref: None,\n+                                    unsize: None\n+                                }))), false)\n+                        };\n                         let index_expr_ty = self.fcx.expr_ty(&**index_expr);\n \n                         let result = check::try_index_step(\n@@ -571,7 +568,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                             expr,\n                             &**base_expr,\n                             adjusted_base_ty,\n-                            base_adjustment,\n+                            autoderefs,\n+                            unsize,\n                             PreferMutLvalue,\n                             index_expr_ty);\n \n@@ -658,14 +656,3 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             self.span, infer::FnCall, value).0\n     }\n }\n-\n-fn wrap_autoref<'tcx, F>(mut deref: ty::AutoDerefRef<'tcx>,\n-                         base_fn: F)\n-                         -> ty::AutoDerefRef<'tcx> where\n-    F: FnOnce(Option<Box<ty::AutoRef<'tcx>>>) -> ty::AutoRef<'tcx>,\n-{\n-    let autoref = mem::replace(&mut deref.autoref, None);\n-    let autoref = autoref.map(|r| box r);\n-    deref.autoref = Some(base_fn(autoref));\n-    deref\n-}"}, {"sha": "f1a4dbf7cd52881c7ceb1d88463f0161c51cccbc", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -122,8 +122,7 @@ pub fn lookup_in_trait<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                  -> Option<MethodCallee<'tcx>>\n {\n     lookup_in_trait_adjusted(fcx, span, self_expr, m_name, trait_def_id,\n-                             ty::AutoDerefRef { autoderefs: 0, autoref: None },\n-                             self_ty, opt_input_types)\n+                             0, false, self_ty, opt_input_types)\n }\n \n /// `lookup_in_trait_adjusted` is used for overloaded operators. It does a very narrow slice of\n@@ -140,7 +139,8 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                           self_expr: Option<&ast::Expr>,\n                                           m_name: ast::Name,\n                                           trait_def_id: DefId,\n-                                          autoderefref: ty::AutoDerefRef<'tcx>,\n+                                          autoderefs: usize,\n+                                          unsize: bool,\n                                           self_ty: Ty<'tcx>,\n                                           opt_input_types: Option<Vec<Ty<'tcx>>>)\n                                           -> Option<MethodCallee<'tcx>>\n@@ -241,33 +241,31 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n         Some(self_expr) => {\n             debug!(\"lookup_in_trait_adjusted: inserting adjustment if needed \\\n-                   (self-id={}, base adjustment={:?}, explicit_self={:?})\",\n-                   self_expr.id, autoderefref, method_ty.explicit_self);\n+                   (self-id={}, autoderefs={}, unsize={}, explicit_self={:?})\",\n+                   self_expr.id, autoderefs, unsize,\n+                   method_ty.explicit_self);\n \n             match method_ty.explicit_self {\n                 ty::ByValueExplicitSelfCategory => {\n                     // Trait method is fn(self), no transformation needed.\n-                    if !autoderefref.is_identity() {\n-                        fcx.write_adjustment(\n-                            self_expr.id,\n-                            span,\n-                            ty::AdjustDerefRef(autoderefref));\n-                    }\n+                    assert!(!unsize);\n+                    fcx.write_autoderef_adjustment(self_expr.id, autoderefs);\n                 }\n \n                 ty::ByReferenceExplicitSelfCategory(..) => {\n                     // Trait method is fn(&self) or fn(&mut self), need an\n                     // autoref. Pull the region etc out of the type of first argument.\n                     match transformed_self_ty.sty {\n                         ty::ty_rptr(region, ty::mt { mutbl, ty: _ }) => {\n-                            let ty::AutoDerefRef { autoderefs, autoref } = autoderefref;\n-                            let autoref = autoref.map(|r| box r);\n-                            fcx.write_adjustment(\n-                                self_expr.id,\n-                                span,\n+                            fcx.write_adjustment(self_expr.id,\n                                 ty::AdjustDerefRef(ty::AutoDerefRef {\n                                     autoderefs: autoderefs,\n-                                    autoref: Some(ty::AutoPtr(*region, mutbl, autoref))\n+                                    autoref: Some(ty::AutoPtr(region, mutbl)),\n+                                    unsize: if unsize {\n+                                        Some(transformed_self_ty)\n+                                    } else {\n+                                        None\n+                                    }\n                                 }));\n                         }\n "}, {"sha": "08e2f47c5a67583157ff010c4b7204247cedad51", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 75, "deletions": 92, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -31,7 +31,6 @@ use std::rc::Rc;\n use util::ppaux::Repr;\n \n use self::CandidateKind::*;\n-pub use self::PickAdjustment::*;\n pub use self::PickKind::*;\n \n struct ProbeContext<'a, 'tcx:'a> {\n@@ -49,7 +48,8 @@ struct ProbeContext<'a, 'tcx:'a> {\n \n struct CandidateStep<'tcx> {\n     self_ty: Ty<'tcx>,\n-    adjustment: PickAdjustment,\n+    autoderefs: usize,\n+    unsize: bool\n }\n \n struct Candidate<'tcx> {\n@@ -70,8 +70,24 @@ enum CandidateKind<'tcx> {\n \n pub struct Pick<'tcx> {\n     pub method_ty: Rc<ty::Method<'tcx>>,\n-    pub adjustment: PickAdjustment,\n     pub kind: PickKind<'tcx>,\n+\n+    // Indicates that the source expression should be autoderef'd N times\n+    //\n+    // A = expr | *expr | **expr | ...\n+    pub autoderefs: usize,\n+\n+    // Indicates that an autoref is applied after the optional autoderefs\n+    //\n+    // B = A | &A | &mut A\n+    pub autoref: Option<ast::Mutability>,\n+\n+    // Indicates that the source expression should be \"unsized\" to a\n+    // target type. This should probably eventually go away in favor\n+    // of just coercing method receivers.\n+    //\n+    // C = B | unsize(B)\n+    pub unsize: Option<Ty<'tcx>>,\n }\n \n #[derive(Clone,Debug)]\n@@ -85,30 +101,6 @@ pub enum PickKind<'tcx> {\n \n pub type PickResult<'tcx> = Result<Pick<'tcx>, MethodError>;\n \n-// This is a kind of \"abstracted\" version of ty::AutoAdjustment.  The\n-// difference is that it doesn't embed any regions or other\n-// specifics. The \"confirmation\" step recreates those details as\n-// needed.\n-#[derive(Clone,Debug)]\n-pub enum PickAdjustment {\n-    // Indicates that the source expression should be autoderef'd N times\n-    //\n-    // A = expr | *expr | **expr\n-    AutoDeref(usize),\n-\n-    // Indicates that the source expression should be autoderef'd N\n-    // times and then \"unsized\". This should probably eventually go\n-    // away in favor of just coercing method receivers.\n-    //\n-    // A = unsize(expr | *expr | **expr)\n-    AutoUnsizeLength(/* number of autoderefs */ usize, /* length*/ usize),\n-\n-    // Indicates that an autoref is applied after some number of other adjustments\n-    //\n-    // A = &A | &mut A\n-    AutoRef(ast::Mutability, Box<PickAdjustment>),\n-}\n-\n #[derive(PartialEq, Eq, Copy, Clone)]\n pub enum Mode {\n     // An expression of the form `receiver.method_name(...)`.\n@@ -149,7 +141,8 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     } else {\n         vec![CandidateStep {\n             self_ty: self_ty,\n-            adjustment: AutoDeref(0)\n+            autoderefs: 0,\n+            unsize: false\n         }]\n     };\n \n@@ -200,16 +193,21 @@ fn create_steps<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                        UnresolvedTypeAction::Error,\n                                                        NoPreference,\n                                                        |t, d| {\n-        let adjustment = AutoDeref(d);\n-        steps.push(CandidateStep { self_ty: t, adjustment: adjustment });\n+        steps.push(CandidateStep {\n+            self_ty: t,\n+            autoderefs: d,\n+            unsize: false\n+        });\n         None::<()> // keep iterating until we can't anymore\n     });\n \n     match final_ty.sty {\n-        ty::ty_vec(elem_ty, Some(len)) => {\n+        ty::ty_vec(elem_ty, Some(_)) => {\n+            let slice_ty = ty::mk_vec(fcx.tcx(), elem_ty, None);\n             steps.push(CandidateStep {\n-                self_ty: ty::mk_vec(fcx.tcx(), elem_ty, None),\n-                adjustment: AutoUnsizeLength(dereferences, len),\n+                self_ty: slice_ty,\n+                autoderefs: dereferences,\n+                unsize: true\n             });\n         }\n         ty::ty_err => return None,\n@@ -926,67 +924,50 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n          * consuming them for their entire lifetime.\n          */\n \n-        let adjustment = match step.adjustment {\n-            AutoDeref(d) => consider_reborrow(step.self_ty, d),\n-            AutoUnsizeLength(..) | AutoRef(..) => step.adjustment.clone(),\n-        };\n+        if step.unsize {\n+            return None;\n+        }\n \n-        return self.pick_method(step.self_ty).map(|r| self.adjust(r, adjustment.clone()));\n+        self.pick_method(step.self_ty).map(|r| r.map(|mut pick| {\n+            pick.autoderefs = step.autoderefs;\n \n-        fn consider_reborrow<'tcx>(ty: Ty<'tcx>, d: usize) -> PickAdjustment {\n             // Insert a `&*` or `&mut *` if this is a reference type:\n-            match ty.sty {\n-                ty::ty_rptr(_, ref mt) => AutoRef(mt.mutbl, box AutoDeref(d+1)),\n-                _ => AutoDeref(d),\n+            if let ty::ty_rptr(_, mt) = step.self_ty.sty {\n+                pick.autoderefs += 1;\n+                pick.autoref = Some(mt.mutbl);\n             }\n-        }\n+\n+            pick\n+        }))\n     }\n \n     fn pick_autorefd_method(&mut self,\n                             step: &CandidateStep<'tcx>)\n                             -> Option<PickResult<'tcx>>\n     {\n         let tcx = self.tcx();\n-        self.search_mutabilities(\n-            |m| AutoRef(m, box step.adjustment.clone()),\n-            |m,r| ty::mk_rptr(tcx, tcx.mk_region(r), ty::mt {ty:step.self_ty, mutbl:m}))\n-    }\n \n-    fn search_mutabilities<F, G>(&mut self,\n-                                 mut mk_adjustment: F,\n-                                 mut mk_autoref_ty: G)\n-                                 -> Option<PickResult<'tcx>> where\n-        F: FnMut(ast::Mutability) -> PickAdjustment,\n-        G: FnMut(ast::Mutability, ty::Region) -> Ty<'tcx>,\n-    {\n         // In general, during probing we erase regions. See\n         // `impl_self_ty()` for an explanation.\n-        let region = ty::ReStatic;\n+        let region = tcx.mk_region(ty::ReStatic);\n \n         // Search through mutabilities in order to find one where pick works:\n-        [ast::MutImmutable, ast::MutMutable]\n-            .iter()\n-            .flat_map(|&m| {\n-                let autoref_ty = mk_autoref_ty(m, region);\n-                self.pick_method(autoref_ty)\n-                    .map(|r| self.adjust(r, mk_adjustment(m)))\n-                    .into_iter()\n-            })\n-            .nth(0)\n-    }\n-\n-    fn adjust(&mut self,\n-              result: PickResult<'tcx>,\n-              adjustment: PickAdjustment)\n-              -> PickResult<'tcx>\n-    {\n-        match result {\n-            Err(e) => Err(e),\n-            Ok(mut pick) => {\n-                pick.adjustment = adjustment;\n-                Ok(pick)\n-            }\n-        }\n+        [ast::MutImmutable, ast::MutMutable].iter().filter_map(|&m| {\n+            let autoref_ty = ty::mk_rptr(tcx, region, ty::mt {\n+                ty: step.self_ty,\n+                mutbl: m\n+            });\n+            self.pick_method(autoref_ty).map(|r| r.map(|mut pick| {\n+                pick.autoderefs = step.autoderefs;\n+                pick.autoref = Some(m);\n+                pick.unsize = if step.unsize {\n+                    Some(step.self_ty)\n+                } else {\n+                    None\n+                };\n+                pick\n+            }))\n+        }).nth(0)\n     }\n \n     fn pick_method(&mut self, self_ty: Ty<'tcx>) -> Option<PickResult<'tcx>> {\n@@ -1122,8 +1103,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         let method_ty = probes[0].method_ty.clone();\n         Some(Pick {\n             method_ty: method_ty,\n-            adjustment: AutoDeref(0),\n-            kind: TraitPick(trait_def_id, method_num)\n+            kind: TraitPick(trait_def_id, method_num),\n+            autoderefs: 0,\n+            autoref: None,\n+            unsize: None\n         })\n     }\n \n@@ -1296,7 +1279,6 @@ impl<'tcx> Candidate<'tcx> {\n     fn to_unadjusted_pick(&self) -> Pick<'tcx> {\n         Pick {\n             method_ty: self.method_ty.clone(),\n-            adjustment: AutoDeref(0),\n             kind: match self.kind {\n                 InherentImplCandidate(def_id, _) => {\n                     InherentImplPick(def_id)\n@@ -1323,7 +1305,10 @@ impl<'tcx> Candidate<'tcx> {\n                 ProjectionCandidate(def_id, index) => {\n                     TraitPick(def_id, index)\n                 }\n-            }\n+            },\n+            autoderefs: 0,\n+            autoref: None,\n+            unsize: None\n         }\n     }\n \n@@ -1392,15 +1377,10 @@ impl<'tcx> Repr<'tcx> for CandidateKind<'tcx> {\n \n impl<'tcx> Repr<'tcx> for CandidateStep<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"CandidateStep({},{:?})\",\n+        format!(\"CandidateStep({}, autoderefs={}, unsize={})\",\n                 self.self_ty.repr(tcx),\n-                self.adjustment)\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for PickAdjustment {\n-    fn repr(&self, _tcx: &ty::ctxt) -> String {\n-        format!(\"{:?}\", self)\n+                self.autoderefs,\n+                self.unsize)\n     }\n }\n \n@@ -1412,9 +1392,12 @@ impl<'tcx> Repr<'tcx> for PickKind<'tcx> {\n \n impl<'tcx> Repr<'tcx> for Pick<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"Pick(method_ty={}, adjustment={:?}, kind={:?})\",\n+        format!(\"Pick(method_ty={}, autoderefs={},\n+                 autoref={}, unsize={}, kind={:?})\",\n                 self.method_ty.repr(tcx),\n-                self.adjustment,\n+                self.autoderefs,\n+                self.autoref.repr(tcx),\n+                self.unsize.repr(tcx),\n                 self.kind)\n     }\n }"}, {"sha": "a54adb3533aaf7418a683a7bda67f2710072f3ad", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 39, "deletions": 127, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -1292,35 +1292,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn write_autoderef_adjustment(&self,\n                                       node_id: ast::NodeId,\n-                                      span: Span,\n                                       derefs: usize) {\n-        if derefs == 0 { return; }\n         self.write_adjustment(\n             node_id,\n-            span,\n             ty::AdjustDerefRef(ty::AutoDerefRef {\n                 autoderefs: derefs,\n-                autoref: None })\n+                autoref: None,\n+                unsize: None\n+            })\n         );\n     }\n \n     pub fn write_adjustment(&self,\n                             node_id: ast::NodeId,\n-                            span: Span,\n                             adj: ty::AutoAdjustment<'tcx>) {\n         debug!(\"write_adjustment(node_id={}, adj={})\", node_id, adj.repr(self.tcx()));\n \n         if adj.is_identity() {\n             return;\n         }\n \n-        // Careful: adjustments can imply trait obligations if we are\n-        // casting from a concrete type to an object type. I think\n-        // it'd probably be nicer to move the logic that creates the\n-        // obligation into the code that creates the adjustment, but\n-        // that's a bit awkward, so instead we go digging and pull the\n-        // obligation out here.\n-        self.register_adjustment_obligations(span, &adj);\n         self.inh.adjustments.borrow_mut().insert(node_id, adj);\n     }\n \n@@ -1383,74 +1374,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                        cause)\n     }\n \n-    fn register_adjustment_obligations(&self,\n-                                       span: Span,\n-                                       adj: &ty::AutoAdjustment<'tcx>) {\n-        match *adj {\n-            ty::AdjustReifyFnPointer(..) => { }\n-            ty::AdjustUnsafeFnPointer => { }\n-            ty::AdjustDerefRef(ref d_r) => {\n-                match d_r.autoref {\n-                    Some(ref a_r) => {\n-                        self.register_autoref_obligations(span, a_r);\n-                    }\n-                    None => {}\n-                }\n-            }\n-        }\n-    }\n-\n-    fn register_autoref_obligations(&self,\n-                                    span: Span,\n-                                    autoref: &ty::AutoRef<'tcx>) {\n-        match *autoref {\n-            ty::AutoUnsize(ref unsize) => {\n-                self.register_unsize_obligations(span, unsize);\n-            }\n-            ty::AutoPtr(_, _, None) |\n-            ty::AutoUnsafe(_, None) => {\n-            }\n-            ty::AutoPtr(_, _, Some(ref a_r)) |\n-            ty::AutoUnsafe(_, Some(ref a_r)) => {\n-                self.register_autoref_obligations(span, &**a_r)\n-            }\n-            ty::AutoUnsizeUniq(ref unsize) => {\n-                self.register_unsize_obligations(span, unsize);\n-            }\n-        }\n-    }\n-\n-    fn register_unsize_obligations(&self,\n-                                   span: Span,\n-                                   unsize: &ty::UnsizeKind<'tcx>) {\n-        debug!(\"register_unsize_obligations: unsize={:?}\", unsize);\n-\n-        match *unsize {\n-            ty::UnsizeLength(..) => {}\n-            ty::UnsizeStruct(ref u, _) => {\n-                self.register_unsize_obligations(span, &**u)\n-            }\n-            ty::UnsizeVtable(ref ty_trait, self_ty) => {\n-                vtable::check_object_safety(self.tcx(), ty_trait, span);\n-\n-                // If the type is `Foo+'a`, ensures that the type\n-                // being cast to `Foo+'a` implements `Foo`:\n-                vtable::register_object_cast_obligations(self,\n-                                                         span,\n-                                                         ty_trait,\n-                                                         self_ty);\n-\n-                // If the type is `Foo+'a`, ensures that the type\n-                // being cast to `Foo+'a` outlives `'a`:\n-                let cause = traits::ObligationCause { span: span,\n-                                                      body_id: self.body_id,\n-                                                      code: traits::ObjectCastObligation(self_ty) };\n-                self.register_region_obligation(self_ty, ty_trait.bounds.region_bound, cause);\n-            }\n-            ty::UnsizeUpcast(_) => { }\n-        }\n-    }\n-\n     /// Returns the type of `def_id` with all generics replaced by by fresh type/region variables.\n     /// Also returns the substitution from the type parameters on `def_id` to the fresh variables.\n     /// Registers any trait obligations specified on `def_id` at the same time.\n@@ -1881,7 +1804,8 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let mt = match ty::deref(resolved_t, false) {\n             Some(mt) => Some(mt),\n             None => {\n-                let method_call = opt_expr.map(|expr| MethodCall::autoderef(expr.id, autoderefs));\n+                let method_call =\n+                    opt_expr.map(|expr| MethodCall::autoderef(expr.id, autoderefs as u32));\n \n                 // Super subtle: it might seem as though we should\n                 // pass `opt_expr` to `try_overloaded_deref`, so that\n@@ -1972,13 +1896,13 @@ fn make_overloaded_lvalue_return_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n }\n \n-fn autoderef_for_index<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n-                                       base_expr: &ast::Expr,\n-                                       base_ty: Ty<'tcx>,\n-                                       lvalue_pref: LvaluePreference,\n-                                       mut step: F)\n-                                       -> Option<T> where\n-    F: FnMut(Ty<'tcx>, ty::AutoDerefRef<'tcx>) -> Option<T>,\n+fn lookup_indexing<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                             expr: &ast::Expr,\n+                             base_expr: &'tcx ast::Expr,\n+                             base_ty: Ty<'tcx>,\n+                             idx_ty: Ty<'tcx>,\n+                             lvalue_pref: LvaluePreference)\n+                             -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)>\n {\n     // FIXME(#18741) -- this is almost but not quite the same as the\n     // autoderef that normal method probing does. They could likely be\n@@ -1991,51 +1915,48 @@ fn autoderef_for_index<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                UnresolvedTypeAction::Error,\n                                                lvalue_pref,\n                                                |adj_ty, idx| {\n-            let autoderefref = ty::AutoDerefRef { autoderefs: idx, autoref: None };\n-            step(adj_ty, autoderefref)\n-        });\n+        try_index_step(fcx, MethodCall::expr(expr.id), expr, base_expr,\n+                       adj_ty, idx, false, lvalue_pref, idx_ty)\n+    });\n \n     if final_mt.is_some() {\n         return final_mt;\n     }\n \n     // After we have fully autoderef'd, if the resulting type is [T, ..n], then\n     // do a final unsized coercion to yield [T].\n-    match ty.sty {\n-        ty::ty_vec(element_ty, Some(n)) => {\n-            let adjusted_ty = ty::mk_vec(fcx.tcx(), element_ty, None);\n-            let autoderefref = ty::AutoDerefRef {\n-                autoderefs: autoderefs,\n-                autoref: Some(ty::AutoUnsize(ty::UnsizeLength(n)))\n-            };\n-            step(adjusted_ty, autoderefref)\n-        }\n-        _ => {\n-            None\n-        }\n+    if let ty::ty_vec(element_ty, Some(_)) = ty.sty {\n+        let adjusted_ty = ty::mk_vec(fcx.tcx(), element_ty, None);\n+        try_index_step(fcx, MethodCall::expr(expr.id), expr, base_expr,\n+                       adjusted_ty, autoderefs, true, lvalue_pref, idx_ty)\n+    } else {\n+        None\n     }\n }\n \n /// To type-check `base_expr[index_expr]`, we progressively autoderef (and otherwise adjust)\n /// `base_expr`, looking for a type which either supports builtin indexing or overloaded indexing.\n /// This loop implements one step in that search; the autoderef loop is implemented by\n-/// `autoderef_for_index`.\n+/// `lookup_indexing`.\n fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                             method_call: MethodCall,\n                             expr: &ast::Expr,\n                             base_expr: &'tcx ast::Expr,\n                             adjusted_ty: Ty<'tcx>,\n-                            adjustment: ty::AutoDerefRef<'tcx>,\n+                            autoderefs: usize,\n+                            unsize: bool,\n                             lvalue_pref: LvaluePreference,\n                             index_ty: Ty<'tcx>)\n                             -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)>\n {\n     let tcx = fcx.tcx();\n-    debug!(\"try_index_step(expr={}, base_expr.id={}, adjusted_ty={}, adjustment={:?}, index_ty={})\",\n+    debug!(\"try_index_step(expr={}, base_expr.id={}, adjusted_ty={}, \\\n+                           autoderefs={}, unsize={}, index_ty={})\",\n            expr.repr(tcx),\n            base_expr.repr(tcx),\n            adjusted_ty.repr(tcx),\n-           adjustment,\n+           autoderefs,\n+           unsize,\n            index_ty.repr(tcx));\n \n     let input_ty = fcx.infcx().next_ty_var();\n@@ -2044,7 +1965,9 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     match (ty::index(adjusted_ty), &index_ty.sty) {\n         (Some(ty), &ty::ty_uint(ast::TyUs)) | (Some(ty), &ty::ty_infer(ty::IntVar(_))) => {\n             debug!(\"try_index_step: success, using built-in indexing\");\n-            fcx.write_adjustment(base_expr.id, base_expr.span, ty::AdjustDerefRef(adjustment));\n+            // If we had `[T; N]`, we should've caught it before unsizing to `[T]`.\n+            assert!(!unsize);\n+            fcx.write_autoderef_adjustment(base_expr.id, autoderefs);\n             return Some((tcx.types.usize, ty));\n         }\n         _ => {}\n@@ -2058,7 +1981,8 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                              Some(&*base_expr),\n                                              token::intern(\"index_mut\"),\n                                              trait_did,\n-                                             adjustment.clone(),\n+                                             autoderefs,\n+                                             unsize,\n                                              adjusted_ty,\n                                              Some(vec![input_ty]))\n         }\n@@ -2073,7 +1997,8 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                              Some(&*base_expr),\n                                              token::intern(\"index\"),\n                                              trait_did,\n-                                             adjustment.clone(),\n+                                             autoderefs,\n+                                             unsize,\n                                              adjusted_ty,\n                                              Some(vec![input_ty]))\n         }\n@@ -2662,7 +2587,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         match field_ty {\n             Some(field_ty) => {\n                 fcx.write_ty(expr.id, field_ty);\n-                fcx.write_autoderef_adjustment(base.id, base.span, autoderefs);\n+                fcx.write_autoderef_adjustment(base.id, autoderefs);\n                 return;\n             }\n             None => {}\n@@ -2773,7 +2698,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         match field_ty {\n             Some(field_ty) => {\n                 fcx.write_ty(expr.id, field_ty);\n-                fcx.write_autoderef_adjustment(base.id, base.span, autoderefs);\n+                fcx.write_autoderef_adjustment(base.id, autoderefs);\n                 return;\n             }\n             None => {}\n@@ -3600,26 +3525,13 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                   fcx.write_ty(id, idx_t);\n               } else {\n                   let base_t = structurally_resolved_type(fcx, expr.span, base_t);\n-\n-                  let result =\n-                      autoderef_for_index(fcx, &**base, base_t, lvalue_pref, |adj_ty, adj| {\n-                          try_index_step(fcx,\n-                                         MethodCall::expr(expr.id),\n-                                         expr,\n-                                         &**base,\n-                                         adj_ty,\n-                                         adj,\n-                                         lvalue_pref,\n-                                         idx_t)\n-                      });\n-\n-                  match result {\n+                  match lookup_indexing(fcx, expr, base, base_t, idx_t, lvalue_pref) {\n                       Some((index_ty, element_ty)) => {\n                           let idx_expr_ty = fcx.expr_ty(idx);\n                           demand::eqtype(fcx, expr.span, index_ty, idx_expr_ty);\n                           fcx.write_ty(id, element_ty);\n                       }\n-                      _ => {\n+                      None => {\n                           check_expr_has_type(fcx, &**idx, fcx.tcx().types.err);\n                           fcx.type_error_message(\n                               expr.span,"}, {"sha": "a7c2969fb7f72a3591d80e5fd726c23a26ebc0d9", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -499,10 +499,10 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     if let Some(adjustment) = rcx.fcx.inh.adjustments.borrow().get(&expr.id) {\n         debug!(\"adjustment={:?}\", adjustment);\n         match *adjustment {\n-            ty::AdjustDerefRef(ty::AutoDerefRef {autoderefs, autoref: ref opt_autoref}) => {\n+            ty::AdjustDerefRef(ty::AutoDerefRef {autoderefs, ref autoref, ..}) => {\n                 let expr_ty = rcx.resolve_node_type(expr.id);\n                 constrain_autoderefs(rcx, expr, autoderefs, expr_ty);\n-                if let Some(ref autoref) = *opt_autoref {\n+                if let Some(ref autoref) = *autoref {\n                     link_autoref(rcx, expr, autoderefs, autoref);\n \n                     // Require that the resulting region encompasses\n@@ -872,7 +872,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n \n     let r_deref_expr = ty::ReScope(CodeExtent::from_node_id(deref_expr.id));\n     for i in 0..derefs {\n-        let method_call = MethodCall::autoderef(deref_expr.id, i);\n+        let method_call = MethodCall::autoderef(deref_expr.id, i as u32);\n         debug!(\"constrain_autoderefs: method_call={:?} (of {:?} total)\", method_call, derefs);\n \n         derefd_ty = match rcx.fcx.inh.method_map.borrow().get(&method_call) {\n@@ -904,7 +904,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                     let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n                     debug!(\"constrain_autoderefs: self_cmt={:?}\",\n                            self_cmt.repr(rcx.tcx()));\n-                    link_region(rcx, deref_expr.span, *r,\n+                    link_region(rcx, deref_expr.span, r,\n                                 ty::BorrowKind::from_mutbl(m), self_cmt);\n                 }\n \n@@ -1102,7 +1102,7 @@ fn link_pattern<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                 ast::PatVec(_, Some(ref slice_pat), _) => {\n                     match mc.cat_slice_pattern(sub_cmt, &**slice_pat) {\n                         Ok((slice_cmt, slice_mutbl, slice_r)) => {\n-                            link_region(rcx, sub_pat.span, slice_r,\n+                            link_region(rcx, sub_pat.span, &slice_r,\n                                         ty::BorrowKind::from_mutbl(slice_mutbl),\n                                         slice_cmt);\n                         }\n@@ -1127,16 +1127,15 @@ fn link_autoref(rcx: &Rcx,\n     debug!(\"expr_cmt={}\", expr_cmt.repr(rcx.tcx()));\n \n     match *autoref {\n-        ty::AutoPtr(r, m, _) => {\n-            link_region(rcx, expr.span, r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n+        ty::AutoPtr(r, m) => {\n+            link_region(rcx, expr.span, r,\n+                ty::BorrowKind::from_mutbl(m), expr_cmt);\n         }\n \n-        ty::AutoUnsafe(m, _) => {\n+        ty::AutoUnsafe(m) => {\n             let r = ty::ReScope(CodeExtent::from_node_id(expr.id));\n             link_region(rcx, expr.span, r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n         }\n-\n-        ty::AutoUnsizeUniq(_) | ty::AutoUnsize(_) => {}\n     }\n }\n \n@@ -1151,7 +1150,7 @@ fn link_by_ref(rcx: &Rcx,\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n     let expr_cmt = ignore_err!(mc.cat_expr(expr));\n     let borrow_region = ty::ReScope(callee_scope);\n-    link_region(rcx, expr.span, borrow_region, ty::ImmBorrow, expr_cmt);\n+    link_region(rcx, expr.span, &borrow_region, ty::ImmBorrow, expr_cmt);\n }\n \n /// Like `link_region()`, except that the region is extracted from the type of `id`, which must be\n@@ -1169,7 +1168,7 @@ fn link_region_from_node_type<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n         let tcx = rcx.fcx.ccx.tcx;\n         debug!(\"rptr_ty={}\", ty_to_string(tcx, rptr_ty));\n         let r = ty::ty_region(tcx, span, rptr_ty);\n-        link_region(rcx, span, r, ty::BorrowKind::from_mutbl(mutbl),\n+        link_region(rcx, span, &r, ty::BorrowKind::from_mutbl(mutbl),\n                     cmt_borrowed);\n     }\n }\n@@ -1179,7 +1178,7 @@ fn link_region_from_node_type<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n /// between regions, as explained in `link_reborrowed_region()`.\n fn link_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                          span: Span,\n-                         borrow_region: ty::Region,\n+                         borrow_region: &ty::Region,\n                          borrow_kind: ty::BorrowKind,\n                          borrow_cmt: mc::cmt<'tcx>) {\n     let mut borrow_cmt = borrow_cmt;\n@@ -1273,7 +1272,7 @@ fn link_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n /// recurse and process `ref_cmt` (see case 2 above).\n fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                     span: Span,\n-                                    borrow_region: ty::Region,\n+                                    borrow_region: &ty::Region,\n                                     borrow_kind: ty::BorrowKind,\n                                     ref_cmt: mc::cmt<'tcx>,\n                                     ref_region: ty::Region,\n@@ -1318,7 +1317,7 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     debug!(\"link_reborrowed_region: {} <= {}\",\n            borrow_region.repr(rcx.tcx()),\n            ref_region.repr(rcx.tcx()));\n-    rcx.fcx.mk_subr(cause, borrow_region, ref_region);\n+    rcx.fcx.mk_subr(cause, *borrow_region, ref_region);\n \n     // If we end up needing to recurse and establish a region link\n     // with `ref_cmt`, calculate what borrow kind we will end up"}, {"sha": "f301c89333e3a62da40738f53c09218087fa7739", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -15,7 +15,6 @@ use middle::traits::report_fulfillment_errors;\n use middle::ty::{self, Ty, AsPredicate};\n use syntax::ast;\n use syntax::codemap::Span;\n-use util::nodemap::FnvHashSet;\n use util::ppaux::{Repr, UserString};\n \n \n@@ -133,46 +132,9 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.register_predicate(projection_obligation);\n     }\n \n-    // Finally, check that there IS a projection predicate for every associated type.\n-    check_object_type_binds_all_associated_types(fcx.tcx(),\n-                                                 span,\n-                                                 object_trait);\n-\n     object_trait_ref\n }\n \n-fn check_object_type_binds_all_associated_types<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                                      span: Span,\n-                                                      object_trait: &ty::TyTrait<'tcx>)\n-{\n-    let object_trait_ref =\n-        object_trait.principal_trait_ref_with_self_ty(tcx, tcx.types.err);\n-\n-    let mut associated_types: FnvHashSet<(ast::DefId, ast::Name)> =\n-        traits::supertraits(tcx, object_trait_ref.clone())\n-        .flat_map(|tr| {\n-            let trait_def = ty::lookup_trait_def(tcx, tr.def_id());\n-            trait_def.associated_type_names\n-                .clone()\n-                .into_iter()\n-                .map(move |associated_type_name| (tr.def_id(), associated_type_name))\n-        })\n-        .collect();\n-\n-    for projection_bound in &object_trait.bounds.projection_bounds {\n-        let pair = (projection_bound.0.projection_ty.trait_ref.def_id,\n-                    projection_bound.0.projection_ty.item_name);\n-        associated_types.remove(&pair);\n-    }\n-\n-    for (trait_def_id, name) in associated_types {\n-        span_err!(tcx.sess, span, E0191,\n-            \"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n-                    name.user_string(tcx),\n-                    ty::item_path_str(tcx, trait_def_id));\n-    }\n-}\n-\n pub fn select_all_fcx_obligations_and_apply_defaults(fcx: &FnCtxt) {\n     debug!(\"select_all_fcx_obligations_and_apply_defaults\");\n "}, {"sha": "f778a64f9496943d9c2efbffe7a41c72a1354dc9", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -285,30 +285,23 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             }\n \n             Some(adjustment) => {\n-                let adj_object = ty::adjust_is_object(&adjustment);\n                 let resolved_adjustment = match adjustment {\n-                    ty::AdjustReifyFnPointer(def_id) => {\n-                        ty::AdjustReifyFnPointer(def_id)\n-                    }\n+                    ty::AdjustReifyFnPointer => ty::AdjustReifyFnPointer,\n \n                     ty::AdjustUnsafeFnPointer => {\n                         ty::AdjustUnsafeFnPointer\n                     }\n \n                     ty::AdjustDerefRef(adj) => {\n                         for autoderef in 0..adj.autoderefs {\n-                            let method_call = MethodCall::autoderef(id, autoderef);\n-                            self.visit_method_map_entry(reason, method_call);\n-                        }\n-\n-                        if adj_object {\n-                            let method_call = MethodCall::autoobject(id);\n+                            let method_call = MethodCall::autoderef(id, autoderef as u32);\n                             self.visit_method_map_entry(reason, method_call);\n                         }\n \n                         ty::AdjustDerefRef(ty::AutoDerefRef {\n                             autoderefs: adj.autoderefs,\n                             autoref: self.resolve(&adj.autoref, reason),\n+                            unsize: self.resolve(&adj.unsize, reason),\n                         })\n                     }\n                 };"}, {"sha": "c18d72c445b375e266a0778d4d805d38ed39e466", "filename": "src/test/compile-fail/associated-type-projection-from-multiple-supertraits.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-from-multiple-supertraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-from-multiple-supertraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-from-multiple-supertraits.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -34,6 +34,8 @@ fn dent<C:BoxCar>(c: C, color: C::Color) {\n \n fn dent_object<COLOR>(c: BoxCar<Color=COLOR>) {\n     //~^ ERROR ambiguous associated type\n+    //~| ERROR the associated type `Color` (from the trait `Box`) must be specified\n+    //~| ERROR the associated type `Color` (from the trait `Vehicle`) must be specified\n }\n \n fn paint<C:BoxCar>(c: C, d: C::Color) {"}, {"sha": "01fc4fef03b1ddd5a4112662992e37df184108e4", "filename": "src/test/compile-fail/issue-18819.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Ftest%2Fcompile-fail%2Fissue-18819.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Ftest%2Fcompile-fail%2Fissue-18819.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18819.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -20,7 +20,7 @@ impl Foo for X {\n     type Item = bool;\n }\n \n-fn print_x(_: &Foo, extra: &str) {\n+fn print_x(_: &Foo<Item=bool>, extra: &str) {\n     println!(\"{}\", extra);\n }\n "}, {"sha": "21a50f24d5e5c8295eeeb9a86b03133441ca1484", "filename": "src/test/compile-fail/issue-19482.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Ftest%2Fcompile-fail%2Fissue-19482.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Ftest%2Fcompile-fail%2Fissue-19482.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19482.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // Test that a partially specified trait object with unspecified associated\n-// type does not ICE.\n+// type does not type-check.\n \n // pretty-expanded FIXME #23616\n \n@@ -20,7 +20,6 @@ trait Foo {\n }\n \n fn bar(x: &Foo) {}\n-// FIXME(#19482) -- `Foo` should specify `A`, but this is not\n-// currently enforced except at object creation\n+//~^ ERROR the associated type `A` (from the trait `Foo`) must be specified\n \n pub fn main() {}", "previous_filename": "src/test/run-pass/issue-19121.rs"}, {"sha": "c5e26a26744df659742c97c58d2c5c46bfe3d2fa", "filename": "src/test/compile-fail/retslot-cast.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Ftest%2Fcompile-fail%2Fretslot-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Ftest%2Fcompile-fail%2Fretslot-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fretslot-cast.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -11,7 +11,8 @@\n #![feature(rustc_attrs)]\n #![allow(warnings)]\n \n-pub fn fail(x: Option<& (Iterator+Send)>) -> Option<&Iterator> {\n+pub fn fail(x: Option<&(Iterator<Item=()>+Send)>)\n+            -> Option<&Iterator<Item=()>> {\n     // This call used to trigger an LLVM assertion because the return\n     // slot had type \"Option<&Iterator>\"* instead of\n     // \"Option<&(Iterator+Send)>\"* -- but this now yields a\n@@ -23,7 +24,8 @@ pub fn fail(x: Option<& (Iterator+Send)>) -> Option<&Iterator> {\n     inner(x) //~ ERROR mismatched types\n }\n \n-pub fn inner(x: Option<& (Iterator+Send)>) -> Option<&(Iterator+Send)> {\n+pub fn inner(x: Option<&(Iterator<Item=()>+Send)>)\n+             -> Option<&(Iterator<Item=()>+Send)> {\n     x\n }\n "}, {"sha": "5a821ef1231cc8cedc39ffb7c6fc3d8072008ab3", "filename": "src/test/compile-fail/unboxed-closure-sugar-not-used-on-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-not-used-on-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e64140ff60d1a20d7e54369db714a9fcd8b96/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-not-used-on-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-not-used-on-fn.rs?ref=4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "patch": "@@ -11,7 +11,7 @@\n \n // Test that the `Fn` traits require `()` form without a feature gate.\n \n-fn bar1(x: &Fn<()>) {\n+fn bar1(x: &Fn<(), Output=()>) {\n     //~^ ERROR angle-bracket notation is not stable when used with the `Fn` family\n }\n "}]}