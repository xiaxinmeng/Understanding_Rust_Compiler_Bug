{"sha": "49b902f06e69909bfae468b136852d0a9a927bd2", "node_id": "C_kwDOAAsO6NoAKDQ5YjkwMmYwNmU2OTkwOWJmYWU0NjhiMTM2ODUyZDBhOWE5MjdiZDI", "commit": {"author": {"name": "Pietro Albini", "email": "pietro.albini@ferrous-systems.com", "date": "2023-03-09T11:24:08Z"}, "committer": {"name": "Pietro Albini", "email": "pietro.albini@ferrous-systems.com", "date": "2023-03-09T11:24:32Z"}, "message": "include directories in grouped licensing information", "tree": {"sha": "42d1608933d2db5dd94a4429edb540facd730e49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42d1608933d2db5dd94a4429edb540facd730e49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49b902f06e69909bfae468b136852d0a9a927bd2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEMycKYjxLY0eb13b7zXazX3c0dp4FAmQJwfAACgkQzXazX3c0\ndp5t3Q/+KHAdtYSJsfENn1n5WhW011xWHdLRwg9zgDZpGOJksqXtHKG8R0wDRl6Y\ngQyJd9fd4Ahmo9kxEqzIEJMxUQhPy59WHqUnrL8yNaLgq5pWUVHiqyqKwfPXalkk\n7PLiBeNQBl3YVO9UheyXa5nSjROAv2zq2mlAmf3pAemQFHNnPaj7Q4EeTTK2Bnuy\nXyUr9NQrKd19KyMJBZWgWauR+pZpi/Qsrsbwv/J0c83q1+r8XDDDcOUmYCa1VODI\n0ZKWEuW32HWcR+amuSWmh/UODU8aRPj5Y+ZSIsrTEzvHioaeItO3oCtj9ClR9Rge\nLBnLozd+fvJVFFKSnEZ5YYyte4qiSZcaSgzu9VnmUpnUGA01nXsYI14YETM8iTcU\nZs9GJ0JQdp9tqNsZ0p05tT+tdxMt44soIJjn9NlkR5NbkRX8wSUyehNaWoVN/iAU\n9z0X+xHuSm/ssjPWNlC7DdenovVtA3Z3/NLMPO6Rdeqgm9va5ZJ/iUzLvJANHJ5J\nhr7ijuvfkphIqUWGS4bSstc6HZlBG8sVVxnM8HenaLI3WRXhzOhiKxr9EBljUvwA\nx7Dt1HnSJeBc/hH/i+bS8mz4ocgB/mpXTPZeeqzjtjtxGjyJ5Dc5Jhipv65yl1rh\nCbLtczIuRYYkMXZtbU8gZpN0sz+Doks1ad3B0bnxUtDirHvJCgg=\n=J9Oz\n-----END PGP SIGNATURE-----", "payload": "tree 42d1608933d2db5dd94a4429edb540facd730e49\nparent 6473ff150f75cd5ac32dd8371be99d66acd16a3c\nauthor Pietro Albini <pietro.albini@ferrous-systems.com> 1678361048 +0100\ncommitter Pietro Albini <pietro.albini@ferrous-systems.com> 1678361072 +0100\n\ninclude directories in grouped licensing information\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49b902f06e69909bfae468b136852d0a9a927bd2", "html_url": "https://github.com/rust-lang/rust/commit/49b902f06e69909bfae468b136852d0a9a927bd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49b902f06e69909bfae468b136852d0a9a927bd2/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6473ff150f75cd5ac32dd8371be99d66acd16a3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6473ff150f75cd5ac32dd8371be99d66acd16a3c", "html_url": "https://github.com/rust-lang/rust/commit/6473ff150f75cd5ac32dd8371be99d66acd16a3c"}], "stats": {"total": 102, "additions": 72, "deletions": 30}, "files": [{"sha": "7a2a440636d91345375a5ab72db6d1c8daa618f7", "filename": "src/tools/collect-license-metadata/src/path_tree.rs", "status": "modified", "additions": 69, "deletions": 27, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/49b902f06e69909bfae468b136852d0a9a927bd2/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Fpath_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49b902f06e69909bfae468b136852d0a9a927bd2/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Fpath_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Fpath_tree.rs?ref=49b902f06e69909bfae468b136852d0a9a927bd2", "patch": "@@ -13,7 +13,7 @@ pub(crate) enum Node<L> {\n     Root { childs: Vec<Node<L>> },\n     Directory { name: PathBuf, childs: Vec<Node<L>>, license: Option<L> },\n     File { name: PathBuf, license: L },\n-    FileGroup { names: Vec<PathBuf>, license: L },\n+    Group { files: Vec<PathBuf>, directories: Vec<PathBuf>, license: L },\n     Empty,\n }\n \n@@ -22,7 +22,7 @@ impl Node<LicenseId> {\n         self.merge_directories();\n         self.collapse_in_licensed_directories();\n         self.merge_directory_licenses();\n-        self.merge_file_groups();\n+        self.merge_groups();\n         self.remove_empty();\n     }\n \n@@ -64,8 +64,8 @@ impl Node<LicenseId> {\n                         Node::Root { .. } => {\n                             panic!(\"can't have a root inside another element\");\n                         }\n-                        Node::FileGroup { .. } => {\n-                            panic!(\"FileGroup should not be present at this stage\");\n+                        Node::Group { .. } => {\n+                            panic!(\"Group should not be present at this stage\");\n                         }\n                         Node::Directory { license: Some(_), .. } => {\n                             panic!(\"license should not be set at this stage\");\n@@ -86,8 +86,8 @@ impl Node<LicenseId> {\n             }\n             Node::Empty => {}\n             Node::File { .. } => {}\n-            Node::FileGroup { .. } => {\n-                panic!(\"FileGroup should not be present at this stage\");\n+            Node::Group { .. } => {\n+                panic!(\"Group should not be present at this stage\");\n             }\n             Node::Directory { license: Some(_), .. } => {\n                 panic!(\"license should not be set at this stage\");\n@@ -132,7 +132,7 @@ impl Node<LicenseId> {\n                 }\n             }\n             Node::File { .. } => {}\n-            Node::FileGroup { .. } => {}\n+            Node::Group { .. } => panic!(\"group should not be present at this stage\"),\n             Node::Empty => {}\n         }\n     }\n@@ -165,8 +165,8 @@ impl Node<LicenseId> {\n                             Node::Root { .. } => {\n                                 panic!(\"can't have a root inside another element\");\n                             }\n-                            Node::FileGroup { .. } => {\n-                                panic!(\"FileGroup should not be present at this stage\");\n+                            Node::Group { .. } => {\n+                                panic!(\"Group should not be present at this stage\");\n                             }\n                             Node::Directory { name: child_child_name, .. } => {\n                                 *child_child_name = child_name.join(&child_child_name);\n@@ -185,38 +185,74 @@ impl Node<LicenseId> {\n             }\n             Node::Empty => {}\n             Node::File { .. } => {}\n-            Node::FileGroup { .. } => {}\n+            Node::Group { .. } => panic!(\"Group should not be present at this stage\"),\n         }\n     }\n \n     /// This pass groups multiple files in a directory with the same license into a single\n-    /// \"FileGroup\", so that the license of all those files can be reported as a group.\n+    /// \"Group\", so that the license of all those files can be reported as a group.\n+    ///\n+    /// This also merges directories *without exceptions*.\n     ///\n     /// Crucially this pass runs after collapse_in_licensed_directories, so the most common license\n     /// will already be marked as the directory's license and won't be turned into a group.\n-    fn merge_file_groups(&mut self) {\n+    fn merge_groups(&mut self) {\n+        #[derive(Default)]\n+        struct Grouped {\n+            files: Vec<PathBuf>,\n+            directories: Vec<PathBuf>,\n+        }\n         match self {\n             Node::Root { childs } | Node::Directory { childs, .. } => {\n-                let mut grouped = BTreeMap::new();\n+                let mut grouped: BTreeMap<LicenseId, Grouped> = BTreeMap::new();\n \n                 for child in &mut *childs {\n-                    child.merge_file_groups();\n-                    if let Node::File { name, license } = child {\n-                        grouped.entry(*license).or_insert_with(Vec::new).push(name.clone());\n-                        *child = Node::Empty;\n+                    child.merge_groups();\n+                    match child {\n+                        Node::Directory { name, childs, license: Some(license) } => {\n+                            if childs.is_empty() {\n+                                grouped\n+                                    .entry(*license)\n+                                    .or_insert_with(Grouped::default)\n+                                    .directories\n+                                    .push(name.clone());\n+                                *child = Node::Empty;\n+                            }\n+                        }\n+                        Node::File { name, license } => {\n+                            grouped\n+                                .entry(*license)\n+                                .or_insert_with(Grouped::default)\n+                                .files\n+                                .push(name.clone());\n+                            *child = Node::Empty;\n+                        }\n+                        _ => {}\n                     }\n                 }\n \n-                for (license, mut names) in grouped.into_iter() {\n-                    if names.len() == 1 {\n-                        childs.push(Node::File { license, name: names.pop().unwrap() });\n+                for (license, mut grouped) in grouped.into_iter() {\n+                    if grouped.files.len() + grouped.directories.len() <= 1 {\n+                        if let Some(name) = grouped.files.pop() {\n+                            childs.push(Node::File { license, name });\n+                        } else if let Some(name) = grouped.directories.pop() {\n+                            childs.push(Node::Directory {\n+                                name,\n+                                childs: Vec::new(),\n+                                license: Some(license),\n+                            });\n+                        }\n                     } else {\n-                        childs.push(Node::FileGroup { license, names });\n+                        childs.push(Node::Group {\n+                            license,\n+                            files: grouped.files,\n+                            directories: grouped.directories,\n+                        });\n                     }\n                 }\n             }\n             Node::File { .. } => {}\n-            Node::FileGroup { .. } => panic!(\"FileGroup should not be present at this stage\"),\n+            Node::Group { .. } => panic!(\"FileGroup should not be present at this stage\"),\n             Node::Empty => {}\n         }\n     }\n@@ -231,7 +267,7 @@ impl Node<LicenseId> {\n                 }\n                 childs.retain(|child| !matches!(child, Node::Empty));\n             }\n-            Node::FileGroup { .. } => {}\n+            Node::Group { .. } => {}\n             Node::File { .. } => {}\n             Node::Empty => {}\n         }\n@@ -278,16 +314,22 @@ pub(crate) fn expand_interned_licenses(\n ) -> Node<&License> {\n     match node {\n         Node::Root { childs } => Node::Root {\n-            childs: childs.into_iter().map(|child| expand_interned_licenses(child, interner)).collect(),\n+            childs: childs\n+                .into_iter()\n+                .map(|child| expand_interned_licenses(child, interner))\n+                .collect(),\n         },\n         Node::Directory { name, childs, license } => Node::Directory {\n-            childs: childs.into_iter().map(|child| expand_interned_licenses(child, interner)).collect(),\n+            childs: childs\n+                .into_iter()\n+                .map(|child| expand_interned_licenses(child, interner))\n+                .collect(),\n             license: license.map(|license| interner.resolve(license)),\n             name,\n         },\n         Node::File { name, license } => Node::File { name, license: interner.resolve(license) },\n-        Node::FileGroup { names, license } => {\n-            Node::FileGroup { names, license: interner.resolve(license) }\n+        Node::Group { files, directories, license } => {\n+            Node::Group { files, directories, license: interner.resolve(license) }\n         }\n         Node::Empty => Node::Empty,\n     }"}, {"sha": "4d116c7da653a48046639e416bacbf26584ef759", "filename": "src/tools/generate-copyright/src/main.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49b902f06e69909bfae468b136852d0a9a927bd2/src%2Ftools%2Fgenerate-copyright%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49b902f06e69909bfae468b136852d0a9a927bd2/src%2Ftools%2Fgenerate-copyright%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fgenerate-copyright%2Fsrc%2Fmain.rs?ref=49b902f06e69909bfae468b136852d0a9a927bd2", "patch": "@@ -36,8 +36,8 @@ fn render_recursive(node: &Node, buffer: &mut Vec<u8>, depth: usize) -> Result<(\n                 }\n             }\n         }\n-        Node::FileGroup { names, license } => {\n-            render_license(&prefix, names.iter(), license, buffer)?;\n+        Node::Group { files, directories, license } => {\n+            render_license(&prefix, directories.iter().chain(files.iter()), license, buffer)?;\n         }\n         Node::File { name, license } => {\n             render_license(&prefix, std::iter::once(name), license, buffer)?;\n@@ -76,7 +76,7 @@ pub(crate) enum Node {\n     Root { childs: Vec<Node> },\n     Directory { name: String, childs: Vec<Node>, license: License },\n     File { name: String, license: License },\n-    FileGroup { names: Vec<String>, license: License },\n+    Group { files: Vec<String>, directories: Vec<String>, license: License },\n }\n \n #[derive(serde::Deserialize)]"}]}