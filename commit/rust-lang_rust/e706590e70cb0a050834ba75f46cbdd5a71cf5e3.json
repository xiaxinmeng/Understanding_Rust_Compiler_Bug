{"sha": "e706590e70cb0a050834ba75f46cbdd5a71cf5e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3MDY1OTBlNzBjYjBhMDUwODM0YmE3NWY0NmNiZGQ1YTcxY2Y1ZTM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-07-10T11:40:27Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-07-11T18:37:45Z"}, "message": "Port region inference code to use new graph", "tree": {"sha": "1525079bfc86847998c84f411af8bd6f5a59b35e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1525079bfc86847998c84f411af8bd6f5a59b35e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e706590e70cb0a050834ba75f46cbdd5a71cf5e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e706590e70cb0a050834ba75f46cbdd5a71cf5e3", "html_url": "https://github.com/rust-lang/rust/commit/e706590e70cb0a050834ba75f46cbdd5a71cf5e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e706590e70cb0a050834ba75f46cbdd5a71cf5e3/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7429e7a114c586004a9aa8d4c4b97eda20990107", "url": "https://api.github.com/repos/rust-lang/rust/commits/7429e7a114c586004a9aa8d4c4b97eda20990107", "html_url": "https://github.com/rust-lang/rust/commit/7429e7a114c586004a9aa8d4c4b97eda20990107"}], "stats": {"total": 345, "additions": 165, "deletions": 180}, "files": [{"sha": "c41ce40a9958863d6bc0b5f202fdd4b9b724461c", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 159, "deletions": 180, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/e706590e70cb0a050834ba75f46cbdd5a71cf5e3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e706590e70cb0a050834ba75f46cbdd5a71cf5e3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=e706590e70cb0a050834ba75f46cbdd5a71cf5e3", "patch": "@@ -18,6 +18,8 @@ use middle::ty::{re_scope, ReVar, ReSkolemized, br_fresh};\n use middle::typeck::infer::cres;\n use middle::typeck::infer::{RegionVariableOrigin, SubregionOrigin};\n use middle::typeck::infer;\n+use middle::graph;\n+use middle::graph::{Direction, NodeIndex};\n use util::common::indenter;\n use util::ppaux::{Repr};\n \n@@ -105,7 +107,7 @@ pub struct RegionVarBindings {\n     // This contains the results of inference.  It begins as an empty\n     // cell and only acquires a value after inference is complete.\n     // We use a cell vs a mutable option to circumvent borrowck errors.\n-    values: Cell<~[GraphNodeValue]>,\n+    values: Cell<~[VarValue]>,\n }\n \n pub fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n@@ -168,7 +170,7 @@ impl RegionVarBindings {\n         }\n     }\n \n-    pub fn num_vars(&mut self) -> uint {\n+    pub fn num_vars(&self) -> uint {\n         self.var_origins.len()\n     }\n \n@@ -705,127 +707,101 @@ impl RegionVarBindings {\n \n // ______________________________________________________________________\n \n-#[deriving(Eq)]\n-enum Direction { Incoming = 0, Outgoing = 1 }\n-\n #[deriving(Eq)]\n enum Classification { Expanding, Contracting }\n \n-enum GraphNodeValue { NoValue, Value(Region), ErrorValue }\n+enum VarValue { NoValue, Value(Region), ErrorValue }\n \n-struct GraphNode {\n-    origin: RegionVariableOrigin,\n+struct VarData {\n     classification: Classification,\n-    value: GraphNodeValue,\n-    head_edge: [uint, ..2],\n-}\n-\n-struct GraphEdge {\n-    next_edge: [uint, ..2],\n-    constraint: Constraint,\n-}\n-\n-struct Graph {\n-    nodes: ~[GraphNode],\n-    edges: ~[GraphEdge],\n+    value: VarValue,\n }\n \n struct RegionAndOrigin {\n     region: Region,\n     origin: SubregionOrigin,\n }\n \n+type Graph = graph::Graph<(), Constraint>;\n+type GraphNode = graph::Node<()>;\n+type GraphEdge = graph::Edge<Constraint>;\n+\n impl RegionVarBindings {\n     fn infer_variable_values(&mut self,\n                              errors: &mut OptVec<RegionResolutionError>)\n-                             -> ~[GraphNodeValue] {\n-        let mut graph = self.construct_graph();\n-        self.expansion(&mut graph);\n-        self.contraction(&mut graph);\n+                             -> ~[VarValue] {\n+        let mut var_data = self.construct_var_data();\n+        self.expansion(var_data);\n+        self.contraction(var_data);\n+        let graph = self.construct_graph();\n         self.collect_concrete_region_errors(&graph, errors);\n-        self.extract_values_and_collect_conflicts(&graph, errors)\n+        self.extract_values_and_collect_conflicts(&graph, var_data, errors)\n     }\n \n     fn construct_graph(&mut self) -> Graph {\n         let num_vars = self.num_vars();\n         let num_edges = self.constraints.len();\n \n-        let nodes = vec::from_fn(num_vars, |var_idx| {\n-            GraphNode {\n+        let mut graph = graph::Graph::with_capacity(num_vars + 1,\n+                                                    num_edges);\n+\n+        for uint::range(0, num_vars) |var_idx| {\n+            graph.add_node(());\n+        }\n+        let dummy_idx = graph.add_node(());\n+\n+        for self.constraints.iter().advance |(constraint, _)| {\n+            match *constraint {\n+                ConstrainVarSubVar(a_id, b_id) => {\n+                    graph.add_edge(NodeIndex(a_id.to_uint()),\n+                                   NodeIndex(b_id.to_uint()),\n+                                   *constraint);\n+                }\n+                ConstrainRegSubVar(_, b_id) => {\n+                    graph.add_edge(dummy_idx,\n+                                   NodeIndex(b_id.to_uint()),\n+                                   *constraint);\n+                }\n+                ConstrainVarSubReg(a_id, _) => {\n+                    graph.add_edge(NodeIndex(a_id.to_uint()),\n+                                   dummy_idx,\n+                                   *constraint);\n+                }\n+                ConstrainRegSubReg(*) => {\n+                    // Relations between two concrete regions do not\n+                    // require an edge in the graph.\n+                }\n+            }\n+        }\n+\n+        return graph;\n+    }\n+\n+    fn construct_var_data(&mut self) -> ~[VarData] {\n+        vec::from_fn(self.num_vars(), |var_idx| {\n+            VarData {\n                 // All nodes are initially classified as contracting; during\n                 // the expansion phase, we will shift the classification for\n                 // those nodes that have a concrete region predecessor to\n                 // Expanding.\n                 classification: Contracting,\n-                origin: self.var_origins[var_idx],\n                 value: NoValue,\n-                head_edge: [uint::max_value, uint::max_value]\n-            }\n-        });\n-\n-        // It would be nice to write this using map():\n-        let mut edges = vec::with_capacity(num_edges);\n-        for self.constraints.iter().advance |(constraint, _)| {\n-            edges.push(GraphEdge {\n-                next_edge: [uint::max_value, uint::max_value],\n-                constraint: *constraint,\n-            });\n-        }\n-\n-        let mut graph = Graph {\n-            nodes: nodes,\n-            edges: edges\n-        };\n-\n-        for uint::range(0, num_edges) |edge_idx| {\n-            match graph.edges[edge_idx].constraint {\n-              ConstrainVarSubVar(a_id, b_id) => {\n-                insert_edge(&mut graph, a_id, Outgoing, edge_idx);\n-                insert_edge(&mut graph, b_id, Incoming, edge_idx);\n-              }\n-              ConstrainRegSubVar(_, b_id) => {\n-                insert_edge(&mut graph, b_id, Incoming, edge_idx);\n-              }\n-              ConstrainVarSubReg(a_id, _) => {\n-                insert_edge(&mut graph, a_id, Outgoing, edge_idx);\n-              }\n-              ConstrainRegSubReg(*) => {\n-                  // Relations between two concrete regions do not\n-                  // require an edge in the graph.\n-              }\n             }\n-        }\n-\n-        return (graph);\n-\n-        fn insert_edge(graph: &mut Graph,\n-                       node_id: RegionVid,\n-                       edge_dir: Direction,\n-                       edge_idx: uint) {\n-            //! Insert edge `edge_idx` on the link list of edges in direction\n-            //! `edge_dir` for the node `node_id`\n-            let edge_dir = edge_dir as uint;\n-            assert_eq!(graph.edges[edge_idx].next_edge[edge_dir],\n-                       uint::max_value);\n-            let n = node_id.to_uint();\n-            let prev_head = graph.nodes[n].head_edge[edge_dir];\n-            graph.edges[edge_idx].next_edge[edge_dir] = prev_head;\n-            graph.nodes[n].head_edge[edge_dir] = edge_idx;\n-        }\n+        })\n     }\n \n-    fn expansion(&mut self, graph: &mut Graph) {\n-        do iterate_until_fixed_point(~\"Expansion\", graph) |nodes, edge| {\n-            match edge.constraint {\n+    fn expansion(&mut self, var_data: &mut [VarData]) {\n+        do self.iterate_until_fixed_point(\"Expansion\") |constraint| {\n+            match *constraint {\n               ConstrainRegSubVar(a_region, b_vid) => {\n-                let b_node = &mut nodes[b_vid.to_uint()];\n-                self.expand_node(a_region, b_vid, b_node)\n+                let b_data = &mut var_data[b_vid.to_uint()];\n+                self.expand_node(a_region, b_vid, b_data)\n               }\n               ConstrainVarSubVar(a_vid, b_vid) => {\n-                match nodes[a_vid.to_uint()].value {\n+                match var_data[a_vid.to_uint()].value {\n                   NoValue | ErrorValue => false,\n                   Value(a_region) => {\n-                    let b_node = &mut nodes[b_vid.to_uint()];\n+                    let b_node = &mut var_data[b_vid.to_uint()];\n                     self.expand_node(a_region, b_vid, b_node)\n                   }\n                 }\n@@ -842,20 +818,20 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn expand_node(&mut self,\n+    fn expand_node(&self,\n                    a_region: Region,\n                    b_vid: RegionVid,\n-                   b_node: &mut GraphNode)\n+                   b_data: &mut VarData)\n                    -> bool {\n         debug!(\"expand_node(%?, %? == %?)\",\n-               a_region, b_vid, b_node.value);\n+               a_region, b_vid, b_data.value);\n \n-        b_node.classification = Expanding;\n-        match b_node.value {\n+        b_data.classification = Expanding;\n+        match b_data.value {\n           NoValue => {\n             debug!(\"Setting initial value of %? to %?\", b_vid, a_region);\n \n-            b_node.value = Value(a_region);\n+            b_data.value = Value(a_region);\n             return true;\n           }\n \n@@ -868,7 +844,7 @@ impl RegionVarBindings {\n             debug!(\"Expanding value of %? from %? to %?\",\n                    b_vid, cur_region, lub);\n \n-            b_node.value = Value(lub);\n+            b_data.value = Value(lub);\n             return true;\n           }\n \n@@ -878,26 +854,26 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn contraction(&mut self,\n-                   graph: &mut Graph) {\n-        do iterate_until_fixed_point(~\"Contraction\", graph) |nodes, edge| {\n-            match edge.constraint {\n+    fn contraction(&self,\n+                   var_data: &mut [VarData]) {\n+        do self.iterate_until_fixed_point(\"Contraction\") |constraint| {\n+            match *constraint {\n               ConstrainRegSubVar(*) => {\n                 // This is an expansion constraint.  Ignore.\n                 false\n               }\n               ConstrainVarSubVar(a_vid, b_vid) => {\n-                match nodes[b_vid.to_uint()].value {\n+                match var_data[b_vid.to_uint()].value {\n                   NoValue | ErrorValue => false,\n                   Value(b_region) => {\n-                    let a_node = &mut nodes[a_vid.to_uint()];\n-                    self.contract_node(a_vid, a_node, b_region)\n+                    let a_data = &mut var_data[a_vid.to_uint()];\n+                    self.contract_node(a_vid, a_data, b_region)\n                   }\n                 }\n               }\n               ConstrainVarSubReg(a_vid, b_region) => {\n-                let a_node = &mut nodes[a_vid.to_uint()];\n-                self.contract_node(a_vid, a_node, b_region)\n+                let a_data = &mut var_data[a_vid.to_uint()];\n+                self.contract_node(a_vid, a_data, b_region)\n               }\n               ConstrainRegSubReg(*) => {\n                 // No region variables involved. Ignore.\n@@ -907,18 +883,18 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn contract_node(&mut self,\n+    fn contract_node(&self,\n                      a_vid: RegionVid,\n-                     a_node: &mut GraphNode,\n+                     a_data: &mut VarData,\n                      b_region: Region)\n                      -> bool {\n         debug!(\"contract_node(%? == %?/%?, %?)\",\n-               a_vid, a_node.value, a_node.classification, b_region);\n+               a_vid, a_data.value, a_data.classification, b_region);\n \n-        return match a_node.value {\n+        return match a_data.value {\n             NoValue => {\n-                assert_eq!(a_node.classification, Contracting);\n-                a_node.value = Value(b_region);\n+                assert_eq!(a_data.classification, Contracting);\n+                a_data.value = Value(b_region);\n                 true // changed\n             }\n \n@@ -927,34 +903,34 @@ impl RegionVarBindings {\n             }\n \n             Value(a_region) => {\n-                match a_node.classification {\n+                match a_data.classification {\n                     Expanding => {\n-                        check_node(self, a_vid, a_node, a_region, b_region)\n+                        check_node(self, a_vid, a_data, a_region, b_region)\n                     }\n                     Contracting => {\n-                        adjust_node(self, a_vid, a_node, a_region, b_region)\n+                        adjust_node(self, a_vid, a_data, a_region, b_region)\n                     }\n                 }\n             }\n         };\n \n-        fn check_node(this: &mut RegionVarBindings,\n+        fn check_node(this: &RegionVarBindings,\n                       a_vid: RegionVid,\n-                      a_node: &mut GraphNode,\n+                      a_data: &mut VarData,\n                       a_region: Region,\n                       b_region: Region)\n                    -> bool {\n             if !this.is_subregion_of(a_region, b_region) {\n                 debug!(\"Setting %? to ErrorValue: %? not subregion of %?\",\n                        a_vid, a_region, b_region);\n-                a_node.value = ErrorValue;\n+                a_data.value = ErrorValue;\n             }\n             false\n         }\n \n-        fn adjust_node(this: &mut RegionVarBindings,\n+        fn adjust_node(this: &RegionVarBindings,\n                        a_vid: RegionVid,\n-                       a_node: &mut GraphNode,\n+                       a_data: &mut VarData,\n                        a_region: Region,\n                        b_region: Region)\n                     -> bool {\n@@ -965,31 +941,27 @@ impl RegionVarBindings {\n                     } else {\n                         debug!(\"Contracting value of %? from %? to %?\",\n                                a_vid, a_region, glb);\n-                        a_node.value = Value(glb);\n+                        a_data.value = Value(glb);\n                         true\n                     }\n                 }\n                 Err(_) => {\n                     debug!(\"Setting %? to ErrorValue: no glb of %?, %?\",\n                            a_vid, a_region, b_region);\n-                    a_node.value = ErrorValue;\n+                    a_data.value = ErrorValue;\n                     false\n                 }\n             }\n         }\n     }\n \n     fn collect_concrete_region_errors(\n-        &mut self,\n+        &self,\n         graph: &Graph,\n         errors: &mut OptVec<RegionResolutionError>)\n     {\n-        let num_edges = graph.edges.len();\n-        for uint::range(0, num_edges) |edge_idx| {\n-            let edge = &graph.edges[edge_idx];\n-            let origin = self.constraints.get_copy(&edge.constraint);\n-\n-            let (sub, sup) = match edge.constraint {\n+        for self.constraints.iter().advance |(constraint, _)| {\n+            let (sub, sup) = match *constraint {\n                 ConstrainVarSubVar(*) |\n                 ConstrainRegSubVar(*) |\n                 ConstrainVarSubReg(*) => {\n@@ -1006,15 +978,17 @@ impl RegionVarBindings {\n \n             debug!(\"ConcreteFailure: !(sub <= sup): sub=%?, sup=%?\",\n                    sub, sup);\n+            let origin = self.constraints.get_copy(constraint);\n             errors.push(ConcreteFailure(origin, sub, sup));\n         }\n     }\n \n     fn extract_values_and_collect_conflicts(\n-        &mut self,\n+        &self,\n         graph: &Graph,\n+        var_data: &[VarData],\n         errors: &mut OptVec<RegionResolutionError>)\n-        -> ~[GraphNodeValue]\n+        -> ~[VarValue]\n     {\n         debug!(\"extract_values_and_collect_conflicts()\");\n \n@@ -1029,10 +1003,10 @@ impl RegionVarBindings {\n         // idea is to report errors that derive from independent\n         // regions of the graph, but not those that derive from\n         // overlapping locations.\n-        let mut dup_vec = graph.nodes.map(|_| uint::max_value);\n+        let mut dup_vec = vec::from_elem(self.num_vars(), uint::max_value);\n \n-        graph.nodes.iter().enumerate().transform(|(idx, node)| {\n-            match node.value {\n+        for uint::range(0, self.num_vars()) |idx| {\n+            match var_data[idx].value {\n                 Value(_) => {\n                     /* Inference successful */\n                 }\n@@ -1067,36 +1041,39 @@ impl RegionVarBindings {\n                        this portion of the code and think hard about it. =) */\n \n                     let node_vid = RegionVid { id: idx };\n-                    match node.classification {\n+                    match var_data[idx].classification {\n                         Expanding => {\n                             self.collect_error_for_expanding_node(\n-                                graph, dup_vec, node_vid, errors);\n+                                graph, var_data, dup_vec, node_vid, errors);\n                         }\n                         Contracting => {\n                             self.collect_error_for_contracting_node(\n-                                graph, dup_vec, node_vid, errors);\n+                                graph, var_data, dup_vec, node_vid, errors);\n                         }\n                     }\n                 }\n             }\n+        }\n \n-            node.value\n-        }).collect()\n+        vec::from_fn(self.num_vars(), |idx| var_data[idx].value)\n     }\n \n     fn collect_error_for_expanding_node(\n-        &mut self,\n+        &self,\n         graph: &Graph,\n+        var_data: &[VarData],\n         dup_vec: &mut [uint],\n         node_idx: RegionVid,\n         errors: &mut OptVec<RegionResolutionError>)\n     {\n         // Errors in expanding nodes result from a lower-bound that is\n         // not contained by an upper-bound.\n         let (lower_bounds, lower_dup) =\n-            self.collect_concrete_regions(graph, node_idx, Incoming, dup_vec);\n+            self.collect_concrete_regions(graph, var_data, node_idx,\n+                                          graph::Incoming, dup_vec);\n         let (upper_bounds, upper_dup) =\n-            self.collect_concrete_regions(graph, node_idx, Outgoing, dup_vec);\n+            self.collect_concrete_regions(graph, var_data, node_idx,\n+                                          graph::Outgoing, dup_vec);\n \n         if lower_dup || upper_dup {\n             return;\n@@ -1127,16 +1104,18 @@ impl RegionVarBindings {\n     }\n \n     fn collect_error_for_contracting_node(\n-        &mut self,\n+        &self,\n         graph: &Graph,\n+        var_data: &[VarData],\n         dup_vec: &mut [uint],\n         node_idx: RegionVid,\n         errors: &mut OptVec<RegionResolutionError>)\n     {\n         // Errors in contracting nodes result from two upper-bounds\n         // that have no intersection.\n         let (upper_bounds, dup_found) =\n-            self.collect_concrete_regions(graph, node_idx, Outgoing, dup_vec);\n+            self.collect_concrete_regions(graph, var_data, node_idx,\n+                                          graph::Outgoing, dup_vec);\n \n         if dup_found {\n             return;\n@@ -1168,8 +1147,9 @@ impl RegionVarBindings {\n                  upper_bounds.map(|x| x.region).repr(self.tcx)));\n     }\n \n-    fn collect_concrete_regions(&mut self,\n+    fn collect_concrete_regions(&self,\n                                 graph: &Graph,\n+                                var_data: &[VarData],\n                                 orig_node_idx: RegionVid,\n                                 dir: Direction,\n                                 dup_vec: &mut [uint])\n@@ -1194,7 +1174,7 @@ impl RegionVarBindings {\n \n         while !state.stack.is_empty() {\n             let node_idx = state.stack.pop();\n-            let classification = graph.nodes[node_idx.to_uint()].classification;\n+            let classification = var_data[node_idx.to_uint()].classification;\n \n             // check whether we've visited this node on some previous walk\n             if dup_vec[node_idx.to_uint()] == uint::max_value {\n@@ -1210,8 +1190,8 @@ impl RegionVarBindings {\n             // figure out the direction from which this node takes its\n             // values, and search for concrete regions etc in that direction\n             let dir = match classification {\n-                Expanding => Incoming,\n-                Contracting => Outgoing\n+                Expanding => graph::Incoming,\n+                Contracting => graph::Outgoing,\n             };\n \n             process_edges(self, &mut state, graph, node_idx, dir);\n@@ -1220,15 +1200,16 @@ impl RegionVarBindings {\n         let WalkState {result, dup_found, _} = state;\n         return (result, dup_found);\n \n-        fn process_edges(this: &mut RegionVarBindings,\n+        fn process_edges(this: &RegionVarBindings,\n                          state: &mut WalkState,\n                          graph: &Graph,\n                          source_vid: RegionVid,\n                          dir: Direction) {\n             debug!(\"process_edges(source_vid=%?, dir=%?)\", source_vid, dir);\n \n-            for this.each_edge(graph, source_vid, dir) |edge| {\n-                match edge.constraint {\n+            let source_node_index = NodeIndex(source_vid.to_uint());\n+            for graph.each_adjacent_edge(source_node_index, dir) |_, edge| {\n+                match edge.data {\n                     ConstrainVarSubVar(from_vid, to_vid) => {\n                         let opp_vid =\n                             if from_vid == source_vid {to_vid} else {from_vid};\n@@ -1241,7 +1222,7 @@ impl RegionVarBindings {\n                     ConstrainVarSubReg(_, region) => {\n                         state.result.push(RegionAndOrigin {\n                             region: region,\n-                            origin: this.constraints.get_copy(&edge.constraint)\n+                            origin: this.constraints.get_copy(&edge.data)\n                         });\n                     }\n \n@@ -1251,42 +1232,40 @@ impl RegionVarBindings {\n         }\n     }\n \n-    pub fn each_edge(&self,\n-                     graph: &Graph,\n-                     node_idx: RegionVid,\n-                     dir: Direction,\n-                     op: &fn(edge: &GraphEdge) -> bool)\n-                     -> bool {\n-        let mut edge_idx =\n-            graph.nodes[node_idx.to_uint()].head_edge[dir as uint];\n-        while edge_idx != uint::max_value {\n-            let edge_ptr = &graph.edges[edge_idx];\n-            if !op(edge_ptr) {\n-                return false;\n+    fn iterate_until_fixed_point(&self,\n+                                 tag: &str,\n+                                 body: &fn(constraint: &Constraint) -> bool) {\n+        let mut iteration = 0;\n+        let mut changed = true;\n+        while changed {\n+            changed = false;\n+            iteration += 1;\n+            debug!(\"---- %s Iteration #%u\", tag, iteration);\n+            for self.constraints.iter().advance |(constraint, _)| {\n+                let edge_changed = body(constraint);\n+                if edge_changed {\n+                    debug!(\"Updated due to constraint %s\",\n+                           constraint.repr(self.tcx));\n+                    changed = true;\n+                }\n             }\n-            edge_idx = edge_ptr.next_edge[dir as uint];\n         }\n-        return true;\n+        debug!(\"---- %s Complete after %u iteration(s)\", tag, iteration);\n     }\n+\n }\n \n-fn iterate_until_fixed_point(\n-    tag: ~str,\n-    graph: &mut Graph,\n-    body: &fn(nodes: &mut [GraphNode], edge: &GraphEdge) -> bool)\n-{\n-    let mut iteration = 0;\n-    let mut changed = true;\n-    let num_edges = graph.edges.len();\n-    while changed {\n-        changed = false;\n-        iteration += 1;\n-        debug!(\"---- %s Iteration #%u\", tag, iteration);\n-        for uint::range(0, num_edges) |edge_idx| {\n-            changed |= body(graph.nodes, &graph.edges[edge_idx]);\n-            debug!(\" >> Change after edge #%?: %?\",\n-                   edge_idx, graph.edges[edge_idx]);\n+impl Repr for Constraint {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        match *self {\n+            ConstrainVarSubVar(a, b) => fmt!(\"ConstrainVarSubVar(%s, %s)\",\n+                                             a.repr(tcx), b.repr(tcx)),\n+            ConstrainRegSubVar(a, b) => fmt!(\"ConstrainRegSubVar(%s, %s)\",\n+                                             a.repr(tcx), b.repr(tcx)),\n+            ConstrainVarSubReg(a, b) => fmt!(\"ConstrainVarSubReg(%s, %s)\",\n+                                             a.repr(tcx), b.repr(tcx)),\n+            ConstrainRegSubReg(a, b) => fmt!(\"ConstrainRegSubReg(%s, %s)\",\n+                                             a.repr(tcx), b.repr(tcx)),\n         }\n     }\n-    debug!(\"---- %s Complete after %u iteration(s)\", tag, iteration);\n }"}, {"sha": "ae91713be0430b71ff80dabcaa2b601b76429c99", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e706590e70cb0a050834ba75f46cbdd5a71cf5e3/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e706590e70cb0a050834ba75f46cbdd5a71cf5e3/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=e706590e70cb0a050834ba75f46cbdd5a71cf5e3", "patch": "@@ -751,6 +751,12 @@ impl Repr for typeck::method_param {\n     }\n }\n \n+impl Repr for ty::RegionVid {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        fmt!(\"%?\", *self)\n+    }\n+}\n+\n impl Repr for ty::TraitStore {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         match self {"}]}