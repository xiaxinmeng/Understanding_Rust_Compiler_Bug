{"sha": "8612838dd04ae9343088955136626b1c1b579999", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2MTI4MzhkZDA0YWU5MzQzMDg4OTU1MTM2NjI2YjFjMWI1Nzk5OTk=", "commit": {"author": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-07-12T14:41:26Z"}, "committer": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-07-14T11:57:46Z"}, "message": "Add back in old school mode", "tree": {"sha": "2c8f0ac3b05b2ce5a9037cbd35990bbcade090ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c8f0ac3b05b2ce5a9037cbd35990bbcade090ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8612838dd04ae9343088955136626b1c1b579999", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8612838dd04ae9343088955136626b1c1b579999", "html_url": "https://github.com/rust-lang/rust/commit/8612838dd04ae9343088955136626b1c1b579999", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8612838dd04ae9343088955136626b1c1b579999/comments", "author": null, "committer": null, "parents": [{"sha": "71ec2867e3c4cc448cb64890daffd1d5ffbe353b", "url": "https://api.github.com/repos/rust-lang/rust/commits/71ec2867e3c4cc448cb64890daffd1d5ffbe353b", "html_url": "https://github.com/rust-lang/rust/commit/71ec2867e3c4cc448cb64890daffd1d5ffbe353b"}], "stats": {"total": 291, "additions": 265, "deletions": 26}, "files": [{"sha": "037d64ba128fbc02571dfbb58310b48289601821", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 265, "deletions": 26, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/8612838dd04ae9343088955136626b1c1b579999/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8612838dd04ae9343088955136626b1c1b579999/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=8612838dd04ae9343088955136626b1c1b579999", "patch": "@@ -34,31 +34,14 @@ pub trait Emitter {\n \n impl Emitter for EmitterWriter {\n     fn emit(&mut self, db: &DiagnosticBuilder) {\n-        if check_old_skool() {\n-            self.emit_message(&FullSpan(db.span.clone()),\n-                            &db.message,\n-                            db.code.as_ref().map(|s| &**s),\n-                            db.level,\n-                            true,\n-                            true);\n-            let db_span = FullSpan(db.span.clone());\n-\n-            for child in &db.children {\n-                let render_span = child.render_span\n-                                    .clone()\n-                                    .unwrap_or_else(\n-                                        || FullSpan(child.span.clone()));\n-                let (render_span, show_snippet) = match render_span.span().primary_span() {\n-                    None => (db_span.clone(), false),\n-                    _ => (render_span, true)\n-                };\n-                self.emit_message(&render_span,\n-                                    &child.message,\n-                                    None,\n-                                    child.level,\n-                                    false,\n-                                    show_snippet);\n-            }\n+        let old_school = match self.format_mode {\n+            FormatMode::NewErrorFormat => false,\n+            FormatMode::OriginalErrorFormat => true,\n+            FormatMode::EnvironmentSelected => check_old_skool()\n+        };\n+\n+        if old_school {\n+            self.emit_messages_old_school(db);\n         } else {\n             self.emit_messages_default(db);\n         }\n@@ -718,6 +701,239 @@ impl EmitterWriter {\n         }\n         write!(&mut self.dst, \"\\n\");\n     }\n+    fn emit_message_old_school(&mut self,\n+                               msp: &MultiSpan,\n+                               msg: &str,\n+                               code: &Option<String>,\n+                               level: &Level,\n+                               show_snippet: bool)\n+                               -> io::Result<()> {\n+        let mut buffer = StyledBuffer::new();\n+\n+        let loc = match msp.primary_span() {\n+            Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => \"\".to_string(),\n+            Some(ps) => if let Some(ref cm) = self.cm {\n+                cm.span_to_string(ps)\n+            } else {\n+                \"\".to_string()\n+            },\n+            None => {\n+                \"\".to_string()\n+            }\n+        };\n+        if loc != \"\" {\n+            buffer.append(0, &loc, Style::NoStyle);\n+            buffer.append(0, \" \", Style::NoStyle);\n+        }\n+        buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n+        buffer.append(0, \": \", Style::HeaderMsg);\n+        buffer.append(0, msg, Style::HeaderMsg);\n+        buffer.append(0, \" \", Style::NoStyle);\n+        match code {\n+            &Some(ref code) => {\n+                buffer.append(0, \"[\", Style::ErrorCode);\n+                buffer.append(0, &code, Style::ErrorCode);\n+                buffer.append(0, \"]\", Style::ErrorCode);\n+            }\n+            _ => {}\n+        }\n+\n+        if !show_snippet {\n+            emit_to_destination(&buffer.render(), level, &mut self.dst);\n+            return Ok(());\n+        }\n+\n+        // Watch out for various nasty special spans; don't try to\n+        // print any filename or anything for those.\n+        match msp.primary_span() {\n+            Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => {\n+                emit_to_destination(&buffer.render(), level, &mut self.dst);\n+                return Ok(());\n+            }\n+            _ => { }\n+        }\n+\n+        let mut annotated_files = self.preprocess_annotations(msp);\n+\n+        if let (Some(ref cm), Some(ann_file), Some(ref primary_span)) =\n+            (self.cm.as_ref(), annotated_files.first(), msp.primary_span().as_ref()) {\n+\n+            // Next, print the source line and its squiggle\n+            // for old school mode, we will render them to the buffer, then insert the file loc\n+            // (or space the same amount) in front of the line and the squiggle\n+            let source_string = ann_file.file.get_line(ann_file.lines[0].line_index - 1)\n+                .unwrap_or(\"\");\n+\n+            let line_offset = buffer.num_lines();\n+\n+            let lo = cm.lookup_char_pos(primary_span.lo);\n+            //Before each secondary line in old skool-mode, print the label\n+            //as an old-style note\n+            let file_pos = format!(\"{}:{} \", lo.file.name.clone(), lo.line);\n+            let file_pos_len = file_pos.len();\n+\n+            // First create the source line we will highlight.\n+            buffer.puts(line_offset, 0, &file_pos, Style::FileNameStyle);\n+            buffer.puts(line_offset, file_pos_len, &source_string, Style::Quotation);\n+            // Sort the annotations by (start, end col)\n+            let mut annotations = ann_file.lines[0].annotations.clone();\n+\n+            // Next, create the highlight line.\n+            for annotation in &annotations {\n+                for p in annotation.start_col..annotation.end_col {\n+                    if p == annotation.start_col {\n+                        buffer.putc(line_offset + 1,\n+                                    file_pos_len + p,\n+                                    '^',\n+                                    if annotation.is_primary {\n+                                        Style::UnderlinePrimary\n+                                    } else {\n+                                        Style::OldSchoolNote\n+                                    });\n+                    } else {\n+                        buffer.putc(line_offset + 1,\n+                                    file_pos_len + p,\n+                                    '~',\n+                                    if annotation.is_primary {\n+                                        Style::UnderlinePrimary\n+                                    } else {\n+                                        Style::OldSchoolNote\n+                                    });\n+                    }\n+                }\n+            }\n+        }\n+        if let Some(ref primary_span) = msp.primary_span().as_ref() {\n+            self.render_macro_backtrace_old_school(primary_span, &mut buffer)?;\n+        }\n+\n+        match code {\n+            &Some(ref code) if self.registry.as_ref()\n+                                           .and_then(|registry| registry.find_description(code))\n+                                           .is_some() => {\n+                let msg = \"run `rustc --explain \".to_string() + &code.to_string() +\n+                    \"` to see a detailed explanation\";\n+\n+                let line_offset = buffer.num_lines();\n+                buffer.append(line_offset, &loc, Style::NoStyle);\n+                buffer.append(line_offset, \" \", Style::NoStyle);\n+                buffer.append(line_offset, &Level::Help.to_string(), Style::Level(Level::Help));\n+                buffer.append(line_offset, \": \", Style::HeaderMsg);\n+                buffer.append(line_offset, &msg, Style::HeaderMsg);\n+            }\n+            _ => ()\n+        }\n+\n+        // final step: take our styled buffer, render it, then output it\n+        emit_to_destination(&buffer.render(), level, &mut self.dst);\n+        Ok(())\n+    }\n+    fn emit_suggestion_old_school(&mut self,\n+                                  suggestion: &CodeSuggestion,\n+                                  level: &Level,\n+                                  msg: &str)\n+                                  -> io::Result<()> {\n+        use std::borrow::Borrow;\n+\n+        let primary_span = suggestion.msp.primary_span().unwrap();\n+        if let Some(ref cm) = self.cm {\n+            let mut buffer = StyledBuffer::new();\n+\n+            let loc = cm.span_to_string(primary_span);\n+\n+            if loc != \"\" {\n+                buffer.append(0, &loc, Style::NoStyle);\n+                buffer.append(0, \" \", Style::NoStyle);\n+            }\n+\n+            buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n+            buffer.append(0, \": \", Style::HeaderMsg);\n+            buffer.append(0, msg, Style::HeaderMsg);\n+\n+            let lines = cm.span_to_lines(primary_span).unwrap();\n+\n+            assert!(!lines.lines.is_empty());\n+\n+            let complete = suggestion.splice_lines(cm.borrow());\n+            let line_count = cmp::min(lines.lines.len(), MAX_HIGHLIGHT_LINES);\n+            let display_lines = &lines.lines[..line_count];\n+\n+            let fm = &*lines.file;\n+            // Calculate the widest number to format evenly\n+            let max_digits = line_num_max_digits(display_lines.last().unwrap());\n+\n+            // print the suggestion without any line numbers, but leave\n+            // space for them. This helps with lining up with previous\n+            // snippets from the actual error being reported.\n+            let mut lines = complete.lines();\n+            let mut row_num = 1;\n+            for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n+                buffer.append(row_num, &fm.name, Style::FileNameStyle);\n+                for i in 0..max_digits+2 {\n+                    buffer.append(row_num, &\" \", Style::NoStyle);\n+                }\n+                buffer.append(row_num, line, Style::NoStyle);\n+                row_num += 1;\n+            }\n+\n+            // if we elided some lines, add an ellipsis\n+            if let Some(_) = lines.next() {\n+                buffer.append(row_num, \"...\", Style::NoStyle);\n+            }\n+            emit_to_destination(&buffer.render(), level, &mut self.dst);\n+        }\n+        Ok(())\n+    }\n+\n+    fn emit_messages_old_school(&mut self, db: &DiagnosticBuilder) {\n+        match self.emit_message_old_school(&db.span,\n+                                           &db.message,\n+                                           &db.code,\n+                                           &db.level,\n+                                           true) {\n+            Ok(()) => {\n+                for child in &db.children {\n+                    let (span, show_snippet) = if child.span.primary_spans().is_empty() {\n+                        (db.span.clone(), false)\n+                    } else {\n+                        (child.span.clone(), true)\n+                    };\n+\n+                    match child.render_span {\n+                        Some(FullSpan(ref msp)) => {\n+                            match self.emit_message_old_school(&span,\n+                                                               &child.message,\n+                                                               &None,\n+                                                               &child.level,\n+                                                               show_snippet) {\n+                                Err(e) => panic!(\"failed to emit error: {}\", e),\n+                                _ => ()\n+                            }\n+                        },\n+                        Some(Suggestion(ref cs)) => {\n+                            match self.emit_suggestion_old_school(cs,\n+                                                                  &child.level,\n+                                                                  &child.message) {\n+                                Err(e) => panic!(\"failed to emit error: {}\", e),\n+                                _ => ()\n+                            }\n+                        },\n+                        None => {\n+                            match self.emit_message_old_school(&span,\n+                                                               &child.message,\n+                                                               &None,\n+                                                               &child.level,\n+                                                               show_snippet) {\n+                                Err(e) => panic!(\"failed to emit error: {}\", e),\n+                                _ => ()\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            Err(e) => panic!(\"failed to emit error: {}\", e)\n+        }\n+    }\n \n     fn emit_message_(&mut self,\n                      rsp: &RenderSpan,\n@@ -948,6 +1164,29 @@ impl EmitterWriter {\n         Ok(())\n     }\n \n+    fn render_macro_backtrace_old_school(&mut self,\n+                                         sp: &Span,\n+                                         buffer: &mut StyledBuffer) -> io::Result<()> {\n+        if let Some(ref cm) = self.cm {\n+            for trace in cm.macro_backtrace(sp.clone()) {\n+                let line_offset = buffer.num_lines();\n+\n+                let mut diag_string =\n+                    format!(\"in this expansion of {}\", trace.macro_decl_name);\n+                if let Some(def_site_span) = trace.def_site_span {\n+                    diag_string.push_str(\n+                        &format!(\" (defined in {})\",\n+                            cm.span_to_filename(def_site_span)));\n+                }\n+                let snippet = cm.span_to_string(trace.call_site);\n+                buffer.append(line_offset, &format!(\"{} \", snippet), Style::NoStyle);\n+                buffer.append(line_offset, \"Note\", Style::Level(Level::Note));\n+                buffer.append(line_offset, \": \", Style::NoStyle);\n+                buffer.append(line_offset, &diag_string, Style::OldSchoolNoteText);\n+            }\n+        }\n+        Ok(())\n+    }\n     fn print_macro_backtrace(&mut self,\n                              sp: Span)\n                              -> io::Result<()> {\n@@ -1087,7 +1326,7 @@ impl Destination {\n             }\n             Style::ErrorCode => {\n                 try!(self.start_attr(term::Attr::Bold));\n-                //try!(self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_MAGENTA)));\n+                try!(self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_MAGENTA)));\n             }\n             Style::Quotation => {}\n             Style::OldSchoolNote => {"}]}