{"sha": "c001b0940c1597f422f41c308a55cc6e22f48e46", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwMDFiMDk0MGMxNTk3ZjQyMmY0MWMzMDhhNTVjYzZlMjJmNDhlNDY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-01T18:57:21Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-01T18:57:21Z"}, "message": "rustc_const_eval: build Pattern instead of hir::Pat for pretty-printing.", "tree": {"sha": "8318a2e3b7af43f843e982218071eda7a3f49938", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8318a2e3b7af43f843e982218071eda7a3f49938"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c001b0940c1597f422f41c308a55cc6e22f48e46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c001b0940c1597f422f41c308a55cc6e22f48e46", "html_url": "https://github.com/rust-lang/rust/commit/c001b0940c1597f422f41c308a55cc6e22f48e46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c001b0940c1597f422f41c308a55cc6e22f48e46/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e227433dc39ab13aa2368814169c049b8f876825", "url": "https://api.github.com/repos/rust-lang/rust/commits/e227433dc39ab13aa2368814169c049b8f876825", "html_url": "https://github.com/rust-lang/rust/commit/e227433dc39ab13aa2368814169c049b8f876825"}], "stats": {"total": 336, "additions": 231, "deletions": 105}, "files": [{"sha": "6d04975f533da853e30acff48273b106e13bfc9a", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 62, "deletions": 83, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/c001b0940c1597f422f41c308a55cc6e22f48e46/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c001b0940c1597f422f41c308a55cc6e22f48e46/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=c001b0940c1597f422f41c308a55cc6e22f48e46", "patch": "@@ -23,18 +23,12 @@ use rustc_data_structures::indexed_vec::Idx;\n use pattern::{FieldPattern, Pattern, PatternKind};\n use pattern::{PatternFoldable, PatternFolder};\n \n-use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n-use rustc::hir;\n-use rustc::hir::def::CtorKind;\n-use rustc::hir::{Pat, PatKind};\n+use rustc::mir::Field;\n use rustc::util::common::ErrorReported;\n \n-use syntax::ast::{self, DUMMY_NODE_ID};\n-use syntax::codemap::Spanned;\n-use syntax::ptr::P;\n use syntax_pos::{Span, DUMMY_SP};\n \n use arena::TypedArena;\n@@ -74,12 +68,6 @@ impl<'tcx> PatternFolder<'tcx> for LiteralExpander {\n     }\n }\n \n-pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n-    id: DUMMY_NODE_ID,\n-    node: PatKind::Wild,\n-    span: DUMMY_SP\n-};\n-\n impl<'tcx> Pattern<'tcx> {\n     fn is_wildcard(&self) -> bool {\n         match *self.kind {\n@@ -224,25 +212,34 @@ pub enum Constructor {\n }\n \n impl<'tcx> Constructor {\n-    fn variant_for_adt(&self, adt: &'tcx ty::AdtDef) -> &'tcx ty::VariantDef {\n+    fn variant_index_for_adt(&self, adt: &'tcx ty::AdtDef) -> usize {\n         match self {\n-            &Variant(vid) => adt.variant_with_id(vid),\n+            &Variant(vid) => adt.variant_index_with_id(vid),\n             &Single => {\n                 assert_eq!(adt.variants.len(), 1);\n-                &adt.variants[0]\n+                0\n             }\n             _ => bug!(\"bad constructor {:?} for adt {:?}\", self, adt)\n         }\n     }\n }\n \n-#[derive(Clone, PartialEq)]\n-pub enum Usefulness {\n+#[derive(Clone)]\n+pub enum Usefulness<'tcx> {\n     Useful,\n-    UsefulWithWitness(Vec<Witness>),\n+    UsefulWithWitness(Vec<Witness<'tcx>>),\n     NotUseful\n }\n \n+impl<'tcx> Usefulness<'tcx> {\n+    fn is_useful(&self) -> bool {\n+        match *self {\n+            NotUseful => false,\n+            _ => true\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone)]\n pub enum WitnessPreference {\n     ConstructWitness,\n@@ -255,39 +252,25 @@ struct PatternContext<'tcx> {\n     max_slice_length: usize,\n }\n \n-\n-fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n-    let node = match value {\n-        &ConstVal::Bool(b) => ast::LitKind::Bool(b),\n-        _ => bug!()\n-    };\n-    P(hir::Expr {\n-        id: DUMMY_NODE_ID,\n-        node: hir::ExprLit(P(Spanned { node: node, span: DUMMY_SP })),\n-        span: DUMMY_SP,\n-        attrs: ast::ThinVec::new(),\n-    })\n-}\n-\n /// A stack of patterns in reverse order of construction\n-#[derive(Clone, PartialEq, Eq)]\n-pub struct Witness(Vec<P<Pat>>);\n+#[derive(Clone)]\n+pub struct Witness<'tcx>(Vec<Pattern<'tcx>>);\n \n-impl Witness {\n-    pub fn single_pattern(&self) -> &Pat {\n+impl<'tcx> Witness<'tcx> {\n+    pub fn single_pattern(&self) -> &Pattern<'tcx> {\n         assert_eq!(self.0.len(), 1);\n         &self.0[0]\n     }\n \n-    fn push_wild_constructor<'a, 'tcx>(\n+    fn push_wild_constructor<'a>(\n         mut self,\n         cx: &MatchCheckCtxt<'a, 'tcx>,\n         ctor: &Constructor,\n         ty: Ty<'tcx>)\n         -> Self\n     {\n         let arity = constructor_arity(cx, ctor, ty);\n-        self.0.extend(repeat(DUMMY_WILD_PAT).take(arity).map(|p| P(p.clone())));\n+        self.0.extend(repeat(cx.wild_pattern).take(arity).cloned());\n         self.apply_constructor(cx, ctor, ty)\n     }\n \n@@ -305,7 +288,7 @@ impl Witness {\n     ///\n     /// left_ty: struct X { a: (bool, &'static str), b: usize}\n     /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n-    fn apply_constructor<'a, 'tcx>(\n+    fn apply_constructor<'a>(\n         mut self,\n         cx: &MatchCheckCtxt<'a,'tcx>,\n         ctor: &Constructor,\n@@ -318,60 +301,56 @@ impl Witness {\n             let mut pats = self.0.drain(len-arity..).rev();\n \n             match ty.sty {\n-                ty::TyTuple(..) => PatKind::Tuple(pats.collect(), None),\n-\n-                ty::TyAdt(adt, _) => {\n-                    let v = ctor.variant_for_adt(adt);\n-                    let qpath = hir::QPath::Resolved(None, P(hir::Path {\n-                        span: DUMMY_SP,\n-                        def: Def::Err,\n-                        segments: vec![hir::PathSegment::from_name(v.name)].into(),\n-                    }));\n-                    match v.ctor_kind {\n-                        CtorKind::Fictive => {\n-                            let field_pats: hir::HirVec<_> = v.fields.iter()\n-                                .zip(pats)\n-                                .filter(|&(_, ref pat)| pat.node != PatKind::Wild)\n-                                .map(|(field, pat)| Spanned {\n-                                    span: DUMMY_SP,\n-                                    node: hir::FieldPat {\n-                                        name: field.name,\n-                                        pat: pat,\n-                                        is_shorthand: false,\n-                                    }\n-                                }).collect();\n-                            let has_more_fields = field_pats.len() < arity;\n-                            PatKind::Struct(qpath, field_pats, has_more_fields)\n+                ty::TyAdt(..) |\n+                ty::TyTuple(..) => {\n+                    let pats = pats.enumerate().map(|(i, p)| {\n+                        FieldPattern {\n+                            field: Field::new(i),\n+                            pattern: p\n                         }\n-                        CtorKind::Fn => {\n-                            PatKind::TupleStruct(qpath, pats.collect(), None)\n+                    }).collect();\n+\n+                    if let ty::TyAdt(adt, _) = ty.sty {\n+                        if adt.variants.len() > 1 {\n+                            PatternKind::Variant {\n+                                adt_def: adt,\n+                                variant_index: ctor.variant_index_for_adt(adt),\n+                                subpatterns: pats\n+                            }\n+                        } else {\n+                            PatternKind::Leaf { subpatterns: pats }\n                         }\n-                        CtorKind::Const => PatKind::Path(qpath)\n+                    } else {\n+                        PatternKind::Leaf { subpatterns: pats }\n                     }\n                 }\n \n-                ty::TyRef(_, ty::TypeAndMut { mutbl, .. }) => {\n-                    PatKind::Ref(pats.nth(0).unwrap(), mutbl)\n+                ty::TyRef(..) => {\n+                    PatternKind::Deref { subpattern: pats.nth(0).unwrap() }\n                 }\n \n                 ty::TySlice(_) | ty::TyArray(..) => {\n-                    PatKind::Slice(pats.collect(), None, hir::HirVec::new())\n+                    PatternKind::Slice {\n+                        prefix: pats.collect(),\n+                        slice: None,\n+                        suffix: vec![]\n+                    }\n                 }\n \n                 _ => {\n                     match *ctor {\n-                        ConstantValue(ref v) => PatKind::Lit(const_val_to_expr(v)),\n-                        _ => PatKind::Wild,\n+                        ConstantValue(ref v) => PatternKind::Constant { value: v.clone() },\n+                        _ => PatternKind::Wild,\n                     }\n                 }\n             }\n         };\n \n-        self.0.push(P(hir::Pat {\n-            id: DUMMY_NODE_ID,\n-            node: pat,\n-            span: DUMMY_SP\n-        }));\n+        self.0.push(Pattern {\n+            ty: ty,\n+            span: DUMMY_SP,\n+            kind: Box::new(pat),\n+        });\n \n         self\n     }\n@@ -528,13 +507,13 @@ pub fn is_useful<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                            matrix: &Matrix<'a, 'tcx>,\n                            v: &[&'a Pattern<'tcx>],\n                            witness: WitnessPreference)\n-                           -> Usefulness {\n+                           -> Usefulness<'tcx> {\n     let &Matrix(ref rows) = matrix;\n     debug!(\"is_useful({:?}, {:?})\", matrix, v);\n     if rows.is_empty() {\n         return match witness {\n             ConstructWitness => UsefulWithWitness(vec![Witness(\n-                repeat(DUMMY_WILD_PAT).take(v.len()).map(|p| P(p.clone())).collect()\n+                repeat(cx.wild_pattern).take(v.len()).cloned().collect()\n             )]),\n             LeaveOutWitness => Useful\n         };\n@@ -559,15 +538,15 @@ pub fn is_useful<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         debug!(\"is_useful - expanding constructors: {:?}\", constructors);\n         constructors.into_iter().map(|c|\n             is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n-        ).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n+        ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n     } else {\n         debug!(\"is_useful - expanding wildcard\");\n         let constructors = missing_constructors(cx, matrix, pcx);\n         debug!(\"is_useful - missing_constructors = {:?}\", constructors);\n         if constructors.is_empty() {\n             all_constructors(cx, pcx).into_iter().map(|c| {\n                 is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n-            }).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n+            }).find(|result| result.is_useful()).unwrap_or(NotUseful)\n         } else {\n             let matrix = rows.iter().filter_map(|r| {\n                 if r[0].is_wildcard() {\n@@ -597,7 +576,7 @@ fn is_useful_specialized<'a, 'tcx>(\n     v: &[&'a Pattern<'tcx>],\n     ctor: Constructor,\n     lty: Ty<'tcx>,\n-    witness: WitnessPreference) -> Usefulness\n+    witness: WitnessPreference) -> Usefulness<'tcx>\n {\n     let arity = constructor_arity(cx, &ctor, lty);\n     let matrix = Matrix(m.iter().flat_map(|r| {\n@@ -672,7 +651,7 @@ fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize\n         },\n         ty::TyRef(..) => 1,\n         ty::TyAdt(adt, _) => {\n-            ctor.variant_for_adt(adt).fields.len()\n+            adt.variants[ctor.variant_index_for_adt(adt)].fields.len()\n         }\n         _ => 0\n     }"}, {"sha": "1bb0667409acb7a409f88fc602f197af4558c9d6", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c001b0940c1597f422f41c308a55cc6e22f48e46/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c001b0940c1597f422f41c308a55cc6e22f48e46/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=c001b0940c1597f422f41c308a55cc6e22f48e46", "patch": "@@ -9,11 +9,10 @@\n // except according to those terms.\n \n use _match::{MatchCheckCtxt, Matrix, expand_pattern, is_useful};\n-use _match::{DUMMY_WILD_PAT};\n use _match::Usefulness::*;\n use _match::WitnessPreference::*;\n \n-use pattern::{Pattern, PatternContext, PatternError};\n+use pattern::{Pattern, PatternContext, PatternError, PatternKind};\n \n use eval::report_const_eval_err;\n \n@@ -230,9 +229,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                 Useful => bug!()\n             };\n \n-            let pattern_string = hir::print::to_string(&self.tcx.map, |s| {\n-                s.print_pat(witness[0].single_pattern())\n-            });\n+            let pattern_string = witness[0].single_pattern().to_string();\n             let mut diag = struct_span_err!(\n                 self.tcx.sess, pat.span, E0005,\n                 \"refutable pattern in {}: `{}` not covered\",\n@@ -369,23 +366,21 @@ fn check_exhaustive<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     match is_useful(cx, matrix, &[cx.wild_pattern], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             let witnesses = if pats.is_empty() {\n-                vec![DUMMY_WILD_PAT]\n+                vec![cx.wild_pattern]\n             } else {\n                 pats.iter().map(|w| w.single_pattern()).collect()\n             };\n             match source {\n                 hir::MatchSource::ForLoopDesugar => {\n                     // `witnesses[0]` has the form `Some(<head>)`, peel off the `Some`\n-                    let witness = match witnesses[0].node {\n-                        PatKind::TupleStruct(_, ref pats, _) => match &pats[..] {\n-                            &[ref pat] => &**pat,\n+                    let witness = match *witnesses[0].kind {\n+                        PatternKind::Variant { ref subpatterns, .. } => match &subpatterns[..] {\n+                            &[ref pat] => &pat.pattern,\n                             _ => bug!(),\n                         },\n                         _ => bug!(),\n                     };\n-                    let pattern_string = hir::print::to_string(&cx.tcx.map, |s| {\n-                        s.print_pat(witness)\n-                    });\n+                    let pattern_string = witness.to_string();\n                     struct_span_err!(cx.tcx.sess, sp, E0297,\n                         \"refutable pattern in `for` loop binding: \\\n                                 `{}` not covered\",\n@@ -394,24 +389,23 @@ fn check_exhaustive<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                         .emit();\n                 },\n                 _ => {\n-                    let pattern_strings: Vec<_> = witnesses.iter().map(|w| {\n-                        hir::print::to_string(&cx.tcx.map, |s| s.print_pat(w))\n-                    }).collect();\n                     const LIMIT: usize = 3;\n-                    let joined_patterns = match pattern_strings.len() {\n+                    let joined_patterns = match witnesses.len() {\n                         0 => bug!(),\n-                        1 => format!(\"`{}`\", pattern_strings[0]),\n+                        1 => format!(\"`{}`\", witnesses[0]),\n                         2...LIMIT => {\n-                            let (tail, head) = pattern_strings.split_last().unwrap();\n-                            format!(\"`{}`\", head.join(\"`, `\") + \"` and `\" + tail)\n+                            let (tail, head) = witnesses.split_last().unwrap();\n+                            let head: Vec<_> = head.iter().map(|w| w.to_string()).collect();\n+                            format!(\"`{}` and `{}`\", head.join(\"`, `\"), tail)\n                         },\n                         _ => {\n-                            let (head, tail) = pattern_strings.split_at(LIMIT);\n+                            let (head, tail) = witnesses.split_at(LIMIT);\n+                            let head: Vec<_> = head.iter().map(|w| w.to_string()).collect();\n                             format!(\"`{}` and {} more\", head.join(\"`, `\"), tail.len())\n                         }\n                     };\n \n-                    let label_text = match pattern_strings.len(){\n+                    let label_text = match witnesses.len() {\n                         1 => format!(\"pattern {} not covered\", joined_patterns),\n                         _ => format!(\"patterns {} not covered\", joined_patterns)\n                     };"}, {"sha": "03baebd7901c503abc96717b96fa69032803925b", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 154, "deletions": 1, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/c001b0940c1597f422f41c308a55cc6e22f48e46/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c001b0940c1597f422f41c308a55cc6e22f48e46/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=c001b0940c1597f422f41c308a55cc6e22f48e46", "patch": "@@ -14,12 +14,13 @@ use rustc::middle::const_val::ConstVal;\n use rustc::mir::{Field, BorrowKind, Mutability};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n use rustc::hir::{self, PatKind};\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n \n use rustc_data_structures::indexed_vec::Idx;\n \n+use std::fmt;\n use syntax::ast;\n use syntax::ptr::P;\n use syntax_pos::Span;\n@@ -105,6 +106,158 @@ pub enum PatternKind<'tcx> {\n     },\n }\n \n+fn print_const_val(value: &ConstVal, f: &mut fmt::Formatter) -> fmt::Result {\n+    match *value {\n+        ConstVal::Float(ref x) => write!(f, \"{}\", x),\n+        ConstVal::Integral(ref i) => write!(f, \"{}\", i),\n+        ConstVal::Str(ref s) => write!(f, \"{:?}\", &s[..]),\n+        ConstVal::ByteStr(ref b) => write!(f, \"{:?}\", &b[..]),\n+        ConstVal::Bool(b) => write!(f, \"{:?}\", b),\n+        ConstVal::Char(c) => write!(f, \"{:?}\", c),\n+        ConstVal::Struct(_) |\n+        ConstVal::Tuple(_) |\n+        ConstVal::Function(_) |\n+        ConstVal::Array(..) |\n+        ConstVal::Repeat(..) |\n+        ConstVal::Dummy => bug!(\"{:?} not printable in a pattern\", value)\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for Pattern<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self.kind {\n+            PatternKind::Wild => write!(f, \"_\"),\n+            PatternKind::Binding { mutability, name, mode, ref subpattern, .. } => {\n+                let is_mut = match mode {\n+                    BindingMode::ByValue => mutability == Mutability::Mut,\n+                    BindingMode::ByRef(_, bk) => {\n+                        write!(f, \"ref \")?;\n+                        bk == BorrowKind::Mut\n+                    }\n+                };\n+                if is_mut {\n+                    write!(f, \"mut \")?;\n+                }\n+                write!(f, \"{}\", name)?;\n+                if let Some(ref subpattern) = *subpattern {\n+                    write!(f, \" @ {}\", subpattern)?;\n+                }\n+                Ok(())\n+            }\n+            PatternKind::Variant { ref subpatterns, .. } |\n+            PatternKind::Leaf { ref subpatterns } => {\n+                let variant = match *self.kind {\n+                    PatternKind::Variant { adt_def, variant_index, .. } => {\n+                        Some(&adt_def.variants[variant_index])\n+                    }\n+                    _ => if let ty::TyAdt(adt, _) = self.ty.sty {\n+                        Some(adt.struct_variant())\n+                    } else {\n+                        None\n+                    }\n+                };\n+\n+                let mut first = true;\n+                let mut start_or_continue = || if first { first = false; \"\" } else { \", \" };\n+\n+                if let Some(variant) = variant {\n+                    write!(f, \"{}\", variant.name)?;\n+\n+                    // Only for TyAdt we can have `S {...}`,\n+                    // which we handle separately here.\n+                    if variant.ctor_kind == CtorKind::Fictive {\n+                        write!(f, \" {{ \")?;\n+\n+                        let mut printed = 0;\n+                        for p in subpatterns {\n+                            if let PatternKind::Wild = *p.pattern.kind {\n+                                continue;\n+                            }\n+                            let name = variant.fields[p.field.index()].name;\n+                            write!(f, \"{}{}: {}\", start_or_continue(), name, p.pattern)?;\n+                            printed += 1;\n+                        }\n+\n+                        if printed < variant.fields.len() {\n+                            write!(f, \"{}..\", start_or_continue())?;\n+                        }\n+\n+                        return write!(f, \" }}\");\n+                    }\n+                }\n+\n+                let num_fields = variant.map_or(subpatterns.len(), |v| v.fields.len());\n+                if num_fields != 0 || variant.is_none() {\n+                    write!(f, \"(\")?;\n+                    for i in 0..num_fields {\n+                        write!(f, \"{}\", start_or_continue())?;\n+\n+                        // Common case: the field is where we expect it.\n+                        if let Some(p) = subpatterns.get(i) {\n+                            if p.field.index() == i {\n+                                write!(f, \"{}\", p.pattern)?;\n+                                continue;\n+                            }\n+                        }\n+\n+                        // Otherwise, we have to go looking for it.\n+                        if let Some(p) = subpatterns.iter().find(|p| p.field.index() == i) {\n+                            write!(f, \"{}\", p.pattern)?;\n+                        } else {\n+                            write!(f, \"_\")?;\n+                        }\n+                    }\n+                    write!(f, \")\")?;\n+                }\n+\n+                Ok(())\n+            }\n+            PatternKind::Deref { ref subpattern } => {\n+                match self.ty.sty {\n+                    ty::TyBox(_) => write!(f, \"box \")?,\n+                    ty::TyRef(_, mt) => {\n+                        write!(f, \"&\")?;\n+                        if mt.mutbl == hir::MutMutable {\n+                            write!(f, \"mut \")?;\n+                        }\n+                    }\n+                    _ => bug!(\"{} is a bad Deref pattern type\", self.ty)\n+                }\n+                write!(f, \"{}\", subpattern)\n+            }\n+            PatternKind::Constant { ref value } => {\n+                print_const_val(value, f)\n+            }\n+            PatternKind::Range { ref lo, ref hi } => {\n+                print_const_val(lo, f)?;\n+                write!(f, \"...\")?;\n+                print_const_val(hi, f)\n+            }\n+            PatternKind::Slice { ref prefix, ref slice, ref suffix } |\n+            PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n+                let mut first = true;\n+                let mut start_or_continue = || if first { first = false; \"\" } else { \", \" };\n+                write!(f, \"[\")?;\n+                for p in prefix {\n+                    write!(f, \"{}{}\", start_or_continue(), p)?;\n+                }\n+                if let Some(ref slice) = *slice {\n+                    write!(f, \"{}\", start_or_continue())?;\n+                    match *slice.kind {\n+                        PatternKind::Wild => {}\n+                        _ => write!(f, \"{}\", slice)?\n+                    }\n+                    write!(f, \"..\")?;\n+                }\n+                for p in suffix {\n+                    write!(f, \"{}{}\", start_or_continue(), p)?;\n+                }\n+                write!(f, \"]\")\n+            }\n+        }\n+    }\n+}\n+\n pub struct PatternContext<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     pub errors: Vec<PatternError>,"}]}