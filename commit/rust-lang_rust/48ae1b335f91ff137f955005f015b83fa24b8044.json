{"sha": "48ae1b335f91ff137f955005f015b83fa24b8044", "node_id": "C_kwDOAAsO6NoAKDQ4YWUxYjMzNWY5MWZmMTM3Zjk1NTAwNWYwMTViODNmYTI0YjgwNDQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-26T01:21:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-26T01:21:12Z"}, "message": "Auto merge of #105096 - LegionMammal978:copied-allocators, r=Amanieu\n\nClarify that copied allocators must behave the same\n\nCurrently, the safety documentation for `Allocator` says that a cloned or moved allocator must behave the same as the original. However, it does not specify that a copied allocator must behave the same, and it's possible to construct an allocator that permits being moved or cloned, but sometimes produces a new allocator when copied.\n\n<details>\n<summary>Contrived example which results in a Miri error</summary>\n\n```rust\n#![feature(allocator_api, once_cell, strict_provenance)]\nuse std::{\n    alloc::{AllocError, Allocator, Global, Layout},\n    collections::HashMap,\n    hint,\n    marker::PhantomPinned,\n    num::NonZeroUsize,\n    pin::Pin,\n    ptr::{addr_of, NonNull},\n    sync::{LazyLock, Mutex},\n};\n\nmod source_allocator {\n    use super::*;\n\n    // `SourceAllocator` has 3 states:\n    // - invalid value: is_cloned == false, source != self.addr()\n    // - source value:  is_cloned == false, source == self.addr()\n    // - cloned value:  is_cloned == true\n    pub struct SourceAllocator {\n        is_cloned: bool,\n        source: usize,\n        _pin: PhantomPinned,\n    }\n\n    impl SourceAllocator {\n        // Returns a pinned source value (pointing to itself).\n        pub fn new_source() -> Pin<Box<Self>> {\n            let mut b = Box::new(Self {\n                is_cloned: false,\n                source: 0,\n                _pin: PhantomPinned,\n            });\n            b.source = b.addr();\n            Box::into_pin(b)\n        }\n\n        fn addr(&self) -> usize {\n            addr_of!(*self).addr()\n        }\n\n        // Invalid values point to source 0.\n        // Source values point to themselves.\n        // Cloned values point to their corresponding source.\n        fn source(&self) -> usize {\n            if self.is_cloned || self.addr() == self.source {\n                self.source\n            } else {\n                0\n            }\n        }\n    }\n\n    // Copying an invalid value produces an invalid value.\n    // Copying a source value produces an invalid value.\n    // Copying a cloned value produces a cloned value with the same source.\n    impl Copy for SourceAllocator {}\n\n    // Cloning an invalid value produces an invalid value.\n    // Cloning a source value produces a cloned value with that source.\n    // Cloning a cloned value produces a cloned value with the same source.\n    impl Clone for SourceAllocator {\n        fn clone(&self) -> Self {\n            if self.is_cloned || self.addr() != self.source {\n                *self\n            } else {\n                Self {\n                    is_cloned: true,\n                    source: self.source,\n                    _pin: PhantomPinned,\n                }\n            }\n        }\n    }\n\n    static SOURCE_MAP: LazyLock<Mutex<HashMap<NonZeroUsize, usize>>> =\n        LazyLock::new(Default::default);\n\n    // SAFETY: Wraps `Global`'s methods with additional tracking.\n    // All invalid values share blocks with each other.\n    // Each source value shares blocks with all cloned values pointing to it.\n    // Cloning an allocator always produces a compatible allocator:\n    // - Cloning an invalid value produces another invalid value.\n    // - Cloning a source value produces a cloned value pointing to it.\n    // - Cloning a cloned value produces another cloned value with the same source.\n    // Moving an allocator always produces a compatible allocator:\n    // - Invalid values remain invalid when moved.\n    // - Source values cannot be moved, since they are always pinned to the heap.\n    // - Cloned values keep the same source when moved.\n    unsafe impl Allocator for SourceAllocator {\n        fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n            let mut map = SOURCE_MAP.lock().unwrap();\n            let block = Global.allocate(layout)?;\n            let block_addr = block.cast::<u8>().addr();\n            map.insert(block_addr, self.source());\n            Ok(block)\n        }\n\n        unsafe fn deallocate(&self, block: NonNull<u8>, layout: Layout) {\n            let mut map = SOURCE_MAP.lock().unwrap();\n            let block_addr = block.addr();\n            // SAFETY: `block` came from an allocator that shares blocks with this allocator.\n            if map.remove(&block_addr) != Some(self.source()) {\n                hint::unreachable_unchecked()\n            }\n            Global.deallocate(block, layout)\n        }\n    }\n}\nuse source_allocator::SourceAllocator;\n\n// SAFETY: `alloc1` and `alloc2` must share blocks.\nunsafe fn test_same(alloc1: &SourceAllocator, alloc2: &SourceAllocator) {\n    let ptr = alloc1.allocate(Layout::new::<i32>()).unwrap();\n    alloc2.deallocate(ptr.cast(), Layout::new::<i32>());\n}\n\nfn main() {\n    let orig = &*SourceAllocator::new_source();\n    let orig_cloned1 = &orig.clone();\n    let orig_cloned2 = &orig.clone();\n    let copied = &{ *orig };\n    let copied_cloned1 = &copied.clone();\n    let copied_cloned2 = &copied.clone();\n    unsafe {\n        test_same(orig, orig_cloned1);\n        test_same(orig_cloned1, orig_cloned2);\n        test_same(copied, copied_cloned1);\n        test_same(copied_cloned1, copied_cloned2);\n        test_same(orig, copied); // error\n    }\n}\n```\n</details>\n\nThis could result in issues in the future for algorithms that specialize on `Copy` types. Right now, nothing in the standard library that depends on `Allocator + Clone` is susceptible to this issue, but I still think it would make sense to specify that copying an allocator is always as valid as cloning it.", "tree": {"sha": "8981d44a6005194298d5bcd395207b52ad597446", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8981d44a6005194298d5bcd395207b52ad597446"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48ae1b335f91ff137f955005f015b83fa24b8044", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48ae1b335f91ff137f955005f015b83fa24b8044", "html_url": "https://github.com/rust-lang/rust/commit/48ae1b335f91ff137f955005f015b83fa24b8044", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48ae1b335f91ff137f955005f015b83fa24b8044/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c61c7a978fe9f7b77a1d667c77d2202dadd1c10", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c61c7a978fe9f7b77a1d667c77d2202dadd1c10", "html_url": "https://github.com/rust-lang/rust/commit/0c61c7a978fe9f7b77a1d667c77d2202dadd1c10"}, {"sha": "57e12f970cd97c65a7d1ce97989a778ffa102584", "url": "https://api.github.com/repos/rust-lang/rust/commits/57e12f970cd97c65a7d1ce97989a778ffa102584", "html_url": "https://github.com/rust-lang/rust/commit/57e12f970cd97c65a7d1ce97989a778ffa102584"}], "stats": {"total": 6, "additions": 3, "deletions": 3}, "files": [{"sha": "ff390322d552de3d6a9fb637dc42355f7c743e13", "filename": "library/core/src/alloc/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/48ae1b335f91ff137f955005f015b83fa24b8044/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ae1b335f91ff137f955005f015b83fa24b8044/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs?ref=48ae1b335f91ff137f955005f015b83fa24b8044", "patch": "@@ -95,10 +95,10 @@ impl fmt::Display for AllocError {\n /// # Safety\n ///\n /// * Memory blocks returned from an allocator must point to valid memory and retain their validity\n-///   until the instance and all of its clones are dropped,\n+///   until the instance and all of its copies and clones are dropped,\n ///\n-/// * cloning or moving the allocator must not invalidate memory blocks returned from this\n-///   allocator. A cloned allocator must behave like the same allocator, and\n+/// * copying, cloning, or moving the allocator must not invalidate memory blocks returned from this\n+///   allocator. A copied or cloned allocator must behave like the same allocator, and\n ///\n /// * any pointer to a memory block which is [*currently allocated*] may be passed to any other\n ///   method of the allocator."}]}