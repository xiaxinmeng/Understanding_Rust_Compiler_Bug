{"sha": "a3d7a5e94507e3d6618790187bd85250ced82c4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzZDdhNWU5NDUwN2UzZDY2MTg3OTAxODdiZDg1MjUwY2VkODJjNGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-29T20:56:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-29T20:56:25Z"}, "message": "Auto merge of #78528 - jonas-schievink:rollup-e70g9zk, r=jonas-schievink\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #75078 (Improve documentation for slice strip_* functions)\n - #76138 (Explain fully qualified syntax for `Rc` and `Arc`)\n - #78244 (Dogfood {exclusive,half-open} ranges in compiler (nfc))\n - #78422 (Do not ICE on invalid input)\n - #78423 (rustc_span: improve bounds checks in byte_pos_to_line_and_col)\n - #78431 (Prefer new associated numeric consts in float error messages)\n - #78462 (Use unwrapDIPtr because the Scope may be null.)\n - #78493 (Update cargo)\n - #78499 (Prevent String::retain from creating non-utf8 strings when abusing panic)\n - #78505 (Update Clippy - temporary_cstring_as_ptr deprecation)\n - #78527 (Fix some more typos)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "822ba7acb43ce58660c3c75fe4e6a6fa9ada56bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/822ba7acb43ce58660c3c75fe4e6a6fa9ada56bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3d7a5e94507e3d6618790187bd85250ced82c4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3d7a5e94507e3d6618790187bd85250ced82c4f", "html_url": "https://github.com/rust-lang/rust/commit/a3d7a5e94507e3d6618790187bd85250ced82c4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3d7a5e94507e3d6618790187bd85250ced82c4f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bdae9edd0cc099daa6038bca469dc09b6fc078a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bdae9edd0cc099daa6038bca469dc09b6fc078a", "html_url": "https://github.com/rust-lang/rust/commit/6bdae9edd0cc099daa6038bca469dc09b6fc078a"}, {"sha": "e656e609ba8794997d466f764d83374de61b8eea", "url": "https://api.github.com/repos/rust-lang/rust/commits/e656e609ba8794997d466f764d83374de61b8eea", "html_url": "https://github.com/rust-lang/rust/commit/e656e609ba8794997d466f764d83374de61b8eea"}], "stats": {"total": 3817, "additions": 3070, "deletions": 747}, "files": [{"sha": "269811053a08459e81f2074d4a1aa845a501bb27", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -148,7 +148,7 @@ struct LoweringContext<'a, 'hir: 'a> {\n     is_collecting_in_band_lifetimes: bool,\n \n     /// Currently in-scope lifetimes defined in impl headers, fn headers, or HRTB.\n-    /// When `is_collectin_in_band_lifetimes` is true, each lifetime is checked\n+    /// When `is_collecting_in_band_lifetimes` is true, each lifetime is checked\n     /// against this list to see if it is already in-scope, or if a definition\n     /// needs to be created for it.\n     ///\n@@ -257,7 +257,7 @@ enum ImplTraitPosition {\n     /// Disallowed in `let` / `const` / `static` bindings.\n     Binding,\n \n-    /// All other posiitons.\n+    /// All other positions.\n     Other,\n }\n \n@@ -363,7 +363,7 @@ enum ParenthesizedGenericArgs {\n ///   elided bounds follow special rules. Note that this only covers\n ///   cases where *nothing* is written; the `'_` in `Box<dyn Foo +\n ///   '_>` is a case of \"modern\" elision.\n-/// - **Deprecated** -- this coverse cases like `Ref<T>`, where the lifetime\n+/// - **Deprecated** -- this covers cases like `Ref<T>`, where the lifetime\n ///   parameter to ref is completely elided. `Ref<'_, T>` would be the modern,\n ///   non-deprecated equivalent.\n ///"}, {"sha": "d6585bcc4259b141a01c2b231152b54c56b0d935", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -516,7 +516,7 @@ impl<'a> AstValidator<'a> {\n         self.session.source_map().guess_head_span(self.extern_mod.unwrap().span)\n     }\n \n-    /// An `fn` in `extern { ... }` cannot have qualfiers, e.g. `async fn`.\n+    /// An `fn` in `extern { ... }` cannot have qualifiers, e.g. `async fn`.\n     fn check_foreign_fn_headerless(&self, ident: Ident, span: Span, header: FnHeader) {\n         if header.has_qualifiers() {\n             self.err_handler()"}, {"sha": "cd1e12ca450163d0e424f121f3a99436af352987", "filename": "compiler/rustc_data_structures/src/tagged_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -24,7 +24,7 @@ mod drop;\n pub use copy::CopyTaggedPtr;\n pub use drop::TaggedPtr;\n \n-/// This describes the pointer type encaspulated by TaggedPtr.\n+/// This describes the pointer type encapsulated by TaggedPtr.\n ///\n /// # Safety\n ///"}, {"sha": "2e1512b3929ca3bbad7c0c0a10002175e4ac85e2", "filename": "compiler/rustc_data_structures/src/transitive_relation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -18,7 +18,7 @@ pub struct TransitiveRelation<T: Eq + Hash> {\n     edges: Vec<Edge>,\n \n     // This is a cached transitive closure derived from the edges.\n-    // Currently, we build it lazilly and just throw out any existing\n+    // Currently, we build it lazily and just throw out any existing\n     // copy whenever a new edge is added. (The Lock is to permit\n     // the lazy computation.) This is kind of silly, except for the\n     // fact its size is tied to `self.elements.len()`, so I wanted to\n@@ -255,7 +255,7 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n             // argument is that, after step 2, we know that no element\n             // can reach its successors (in the vector, not the graph).\n             // After step 3, we know that no element can reach any of\n-            // its predecesssors (because of step 2) nor successors\n+            // its predecessors (because of step 2) nor successors\n             // (because we just called `pare_down`)\n             //\n             // This same algorithm is used in `parents` below."}, {"sha": "08e9bdf308798894f641eeacdcc555ea6646c856", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -513,7 +513,7 @@ impl Emitter for SilentEmitter {\n /// Maximum number of lines we will print for a multiline suggestion; arbitrary.\n ///\n /// This should be replaced with a more involved mechanism to output multiline suggestions that\n-/// more closely mimmics the regular diagnostic output, where irrelevant code lines are elided.\n+/// more closely mimics the regular diagnostic output, where irrelevant code lines are elided.\n pub const MAX_SUGGESTION_HIGHLIGHT_LINES: usize = 6;\n /// Maximum number of suggestions to be shown\n ///\n@@ -887,7 +887,7 @@ impl EmitterWriter {\n                                                      // or the next are vertical line placeholders.\n                         || (annotation.takes_space() // If either this or the next annotation is\n                             && next.has_label())     // multiline start/end, move it to a new line\n-                        || (annotation.has_label()   // so as not to overlap the orizontal lines.\n+                        || (annotation.has_label()   // so as not to overlap the horizontal lines.\n                             && next.takes_space())\n                         || (annotation.takes_space() && next.takes_space())\n                         || (overlaps(next, annotation, l)"}, {"sha": "2ecdff1a18d4133e6a6990765df6fbc32009c9ea", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -35,6 +35,8 @@\n #![feature(never_type)]\n #![feature(nll)]\n #![feature(or_patterns)]\n+#![feature(half_open_range_patterns)]\n+#![feature(exclusive_range_pattern)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "bd0250305671ed923bb5edd8b68e71f8e5deed0e", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -439,7 +439,7 @@ fn lint_literal<'tcx>(\n                 cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, |lint| {\n                     lint.build(&format!(\"literal out of range for `{}`\", t.name_str()))\n                         .note(&format!(\n-                            \"the literal `{}` does not fit into the type `{}` and will be converted to `std::{}::INFINITY`\",\n+                            \"the literal `{}` does not fit into the type `{}` and will be converted to `{}::INFINITY`\",\n                             cx.sess()\n                                 .source_map()\n                                 .span_to_snippet(lit.span)"}, {"sha": "17f0d5632e657e0dfa71b346a74c6a645b974897", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -250,13 +250,13 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                     has_emitted\n                 }\n                 ty::Array(ty, len) => match len.try_eval_usize(cx.tcx, cx.param_env) {\n+                    // If the array is empty we don't lint, to avoid false positives\n+                    Some(0) | None => false,\n                     // If the array is definitely non-empty, we can do `#[must_use]` checking.\n-                    Some(n) if n != 0 => {\n+                    Some(n) => {\n                         let descr_pre = &format!(\"{}array{} of \", descr_pre, plural_suffix,);\n                         check_must_use_ty(cx, ty, expr, span, descr_pre, descr_post, n as usize + 1)\n                     }\n-                    // Otherwise, we don't lint, to avoid false positives.\n-                    _ => false,\n                 },\n                 ty::Closure(..) => {\n                     cx.struct_span_lint(UNUSED_MUST_USE, span, |lint| {"}, {"sha": "869aaa569ca407f4fc53c4a4ed29c2c9d0788330", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -766,7 +766,7 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateTypedef(\n     LLVMMetadataRef File, unsigned LineNo, LLVMMetadataRef Scope) {\n   return wrap(Builder->createTypedef(\n     unwrap<DIType>(Type), StringRef(Name, NameLen), unwrap<DIFile>(File),\n-    LineNo, unwrap<DIScope>(Scope)));\n+    LineNo, unwrapDIPtr<DIScope>(Scope)));\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreatePointerType("}, {"sha": "5ccadb7e660f681c055c9700396fe25a8cdcc4d8", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -47,6 +47,8 @@\n #![feature(associated_type_bounds)]\n #![feature(rustc_attrs)]\n #![feature(int_error_matching)]\n+#![feature(half_open_range_patterns)]\n+#![feature(exclusive_range_pattern)]\n #![recursion_limit = \"512\"]\n \n #[macro_use]"}, {"sha": "2f7707b9498ad45541075e61788351088cd3ee00", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -201,13 +201,13 @@ impl<'tcx> TyS<'tcx> {\n             ),\n \n             Array(ty, len) => match len.try_eval_usize(tcx, param_env) {\n+                Some(0) | None => DefIdForest::empty(),\n                 // If the array is definitely non-empty, it's uninhabited if\n                 // the type of its elements is uninhabited.\n-                Some(n) if n != 0 => ty.uninhabited_from(tcx, param_env),\n-                _ => DefIdForest::empty(),\n+                Some(1..) => ty.uninhabited_from(tcx, param_env),\n             },\n \n-            // References to uninitialised memory is valid for any type, including\n+            // References to uninitialised memory are valid for any type, including\n             // uninhabited types, in unsafe code, so we treat all references as\n             // inhabited.\n             // The precise semantics of inhabitedness with respect to references is currently"}, {"sha": "431fa30ed0fa1d9f8884c19ce1dbab01a90f07b6", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1834,10 +1834,10 @@ impl<'tcx> TyS<'tcx> {\n             }\n             ty::Array(ty, len) => {\n                 match len.try_eval_usize(tcx, ParamEnv::empty()) {\n+                    Some(0) | None => false,\n                     // If the array is definitely non-empty, it's uninhabited if\n                     // the type of its elements is uninhabited.\n-                    Some(n) if n != 0 => ty.conservative_is_privately_uninhabited(tcx),\n-                    _ => false,\n+                    Some(1..) => ty.conservative_is_privately_uninhabited(tcx),\n                 }\n             }\n             ty::Ref(..) => {"}, {"sha": "55ee4e52082e51e3b10c57e4fc7dd2db3126b391", "filename": "compiler/rustc_session/src/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -153,14 +153,14 @@ fn find_libdir(sysroot: &Path) -> Cow<'static, str> {\n     const SECONDARY_LIB_DIR: &str = \"lib\";\n \n     match option_env!(\"CFG_LIBDIR_RELATIVE\") {\n-        Some(libdir) if libdir != \"lib\" => libdir.into(),\n-        _ => {\n+        None | Some(\"lib\") => {\n             if sysroot.join(PRIMARY_LIB_DIR).join(RUST_LIB_DIR).exists() {\n                 PRIMARY_LIB_DIR.into()\n             } else {\n                 SECONDARY_LIB_DIR.into()\n             }\n         }\n+        Some(libdir) => libdir.into(),\n     }\n }\n "}, {"sha": "15dd00fb483e786c0c896e1fa8fa4fca80beeb2e", "filename": "compiler/rustc_span/src/caching_source_map_view.rs", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_span%2Fsrc%2Fcaching_source_map_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_span%2Fsrc%2Fcaching_source_map_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fcaching_source_map_view.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1,13 +1,25 @@\n use crate::source_map::SourceMap;\n use crate::{BytePos, SourceFile};\n use rustc_data_structures::sync::Lrc;\n+use std::ops::Range;\n \n #[derive(Clone)]\n struct CacheEntry {\n     time_stamp: usize,\n     line_number: usize,\n-    line_start: BytePos,\n-    line_end: BytePos,\n+    // The line's byte position range in the `SourceMap`. This range will fail to contain a valid\n+    // position in certain edge cases. Spans often start/end one past something, and when that\n+    // something is the last character of a file (this can happen when a file doesn't end in a\n+    // newline, for example), we'd still like for the position to be considered within the last\n+    // line. However, it isn't according to the exclusive upper bound of this range. We cannot\n+    // change the upper bound to be inclusive, because for most lines, the upper bound is the same\n+    // as the lower bound of the next line, so there would be an ambiguity.\n+    //\n+    // Since the containment aspect of this range is only used to see whether or not the cache\n+    // entry contains a position, the only ramification of the above is that we will get cache\n+    // misses for these rare positions. A line lookup for the position via `SourceMap::lookup_line`\n+    // after a cache miss will produce the last line number, as desired.\n+    line: Range<BytePos>,\n     file: Lrc<SourceFile>,\n     file_index: usize,\n }\n@@ -26,8 +38,7 @@ impl<'sm> CachingSourceMapView<'sm> {\n         let entry = CacheEntry {\n             time_stamp: 0,\n             line_number: 0,\n-            line_start: BytePos(0),\n-            line_end: BytePos(0),\n+            line: BytePos(0)..BytePos(0),\n             file: first_file,\n             file_index: 0,\n         };\n@@ -47,13 +58,13 @@ impl<'sm> CachingSourceMapView<'sm> {\n \n         // Check if the position is in one of the cached lines\n         for cache_entry in self.line_cache.iter_mut() {\n-            if pos >= cache_entry.line_start && pos < cache_entry.line_end {\n+            if cache_entry.line.contains(&pos) {\n                 cache_entry.time_stamp = self.time_stamp;\n \n                 return Some((\n                     cache_entry.file.clone(),\n                     cache_entry.line_number,\n-                    pos - cache_entry.line_start,\n+                    pos - cache_entry.line.start,\n                 ));\n             }\n         }\n@@ -69,13 +80,13 @@ impl<'sm> CachingSourceMapView<'sm> {\n         let cache_entry = &mut self.line_cache[oldest];\n \n         // If the entry doesn't point to the correct file, fix it up\n-        if pos < cache_entry.file.start_pos || pos >= cache_entry.file.end_pos {\n+        if !file_contains(&cache_entry.file, pos) {\n             let file_valid;\n             if self.source_map.files().len() > 0 {\n                 let file_index = self.source_map.lookup_source_file_idx(pos);\n                 let file = self.source_map.files()[file_index].clone();\n \n-                if pos >= file.start_pos && pos < file.end_pos {\n+                if file_contains(&file, pos) {\n                     cache_entry.file = file;\n                     cache_entry.file_index = file_index;\n                     file_valid = true;\n@@ -95,10 +106,19 @@ impl<'sm> CachingSourceMapView<'sm> {\n         let line_bounds = cache_entry.file.line_bounds(line_index);\n \n         cache_entry.line_number = line_index + 1;\n-        cache_entry.line_start = line_bounds.0;\n-        cache_entry.line_end = line_bounds.1;\n+        cache_entry.line = line_bounds;\n         cache_entry.time_stamp = self.time_stamp;\n \n-        Some((cache_entry.file.clone(), cache_entry.line_number, pos - cache_entry.line_start))\n+        Some((cache_entry.file.clone(), cache_entry.line_number, pos - cache_entry.line.start))\n     }\n }\n+\n+#[inline]\n+fn file_contains(file: &SourceFile, pos: BytePos) -> bool {\n+    // `SourceMap::lookup_source_file_idx` and `SourceFile::contains` both consider the position\n+    // one past the end of a file to belong to it. Normally, that's what we want. But for the\n+    // purposes of converting a byte position to a line and column number, we can't come up with a\n+    // line and column number if the file is empty, because an empty file doesn't contain any\n+    // lines. So for our purposes, we don't consider empty files to contain any byte position.\n+    file.contains(pos) && !file.is_empty()\n+}"}, {"sha": "0e3027273abbc4421357c766a12bdbc65a148f81", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -52,7 +52,7 @@ use std::cell::RefCell;\n use std::cmp::{self, Ordering};\n use std::fmt;\n use std::hash::Hash;\n-use std::ops::{Add, Sub};\n+use std::ops::{Add, Range, Sub};\n use std::path::{Path, PathBuf};\n use std::str::FromStr;\n \n@@ -1426,24 +1426,33 @@ impl SourceFile {\n         if line_index >= 0 { Some(line_index as usize) } else { None }\n     }\n \n-    pub fn line_bounds(&self, line_index: usize) -> (BytePos, BytePos) {\n-        if self.start_pos == self.end_pos {\n-            return (self.start_pos, self.end_pos);\n+    pub fn line_bounds(&self, line_index: usize) -> Range<BytePos> {\n+        if self.is_empty() {\n+            return self.start_pos..self.end_pos;\n         }\n \n         assert!(line_index < self.lines.len());\n         if line_index == (self.lines.len() - 1) {\n-            (self.lines[line_index], self.end_pos)\n+            self.lines[line_index]..self.end_pos\n         } else {\n-            (self.lines[line_index], self.lines[line_index + 1])\n+            self.lines[line_index]..self.lines[line_index + 1]\n         }\n     }\n \n+    /// Returns whether or not the file contains the given `SourceMap` byte\n+    /// position. The position one past the end of the file is considered to be\n+    /// contained by the file. This implies that files for which `is_empty`\n+    /// returns true still contain one byte position according to this function.\n     #[inline]\n     pub fn contains(&self, byte_pos: BytePos) -> bool {\n         byte_pos >= self.start_pos && byte_pos <= self.end_pos\n     }\n \n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.start_pos == self.end_pos\n+    }\n+\n     /// Calculates the original byte position relative to the start of the file\n     /// based on the given byte position.\n     pub fn original_relative_byte_pos(&self, pos: BytePos) -> BytePos {"}, {"sha": "c52fd0b57868508052c6a9bb86b18ab43e92cdf7", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -461,10 +461,17 @@ fn virtual_call_violation_for_method<'tcx>(\n \n             let param_env = tcx.param_env(method.def_id);\n \n-            let abi_of_ty = |ty: Ty<'tcx>| -> &Abi {\n+            let abi_of_ty = |ty: Ty<'tcx>| -> Option<&Abi> {\n                 match tcx.layout_of(param_env.and(ty)) {\n-                    Ok(layout) => &layout.abi,\n-                    Err(err) => bug!(\"error: {}\\n while computing layout for type {:?}\", err, ty),\n+                    Ok(layout) => Some(&layout.abi),\n+                    Err(err) => {\n+                        // #78372\n+                        tcx.sess.delay_span_bug(\n+                            tcx.def_span(method.def_id),\n+                            &format!(\"error: {}\\n while computing layout for type {:?}\", err, ty),\n+                        );\n+                        None\n+                    }\n                 }\n             };\n \n@@ -473,7 +480,7 @@ fn virtual_call_violation_for_method<'tcx>(\n                 receiver_for_self_ty(tcx, receiver_ty, tcx.mk_unit(), method.def_id);\n \n             match abi_of_ty(unit_receiver_ty) {\n-                &Abi::Scalar(..) => (),\n+                Some(Abi::Scalar(..)) => (),\n                 abi => {\n                     tcx.sess.delay_span_bug(\n                         tcx.def_span(method.def_id),\n@@ -493,13 +500,12 @@ fn virtual_call_violation_for_method<'tcx>(\n                 receiver_for_self_ty(tcx, receiver_ty, trait_object_ty, method.def_id);\n \n             match abi_of_ty(trait_object_receiver) {\n-                &Abi::ScalarPair(..) => (),\n+                Some(Abi::ScalarPair(..)) => (),\n                 abi => {\n                     tcx.sess.delay_span_bug(\n                         tcx.def_span(method.def_id),\n                         &format!(\n-                            \"receiver when `Self = {}` should have a ScalarPair ABI; \\\n-                                 found {:?}\",\n+                            \"receiver when `Self = {}` should have a ScalarPair ABI; found {:?}\",\n                             trait_object_ty, abi\n                         ),\n                     );"}, {"sha": "6dcd0c6056c3039f9189c41685865ec6a97ea5a2", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -11,7 +11,7 @@\n //! is no exception: you cannot generally obtain a mutable reference to\n //! something inside an [`Rc`]. If you need mutability, put a [`Cell`]\n //! or [`RefCell`] inside the [`Rc`]; see [an example of mutability\n-//! inside an Rc][mutability].\n+//! inside an `Rc`][mutability].\n //!\n //! [`Rc`] uses non-atomic reference counting. This means that overhead is very\n //! low, but an [`Rc`] cannot be sent between threads, and consequently [`Rc`]\n@@ -35,15 +35,29 @@\n //! `Rc<T>` automatically dereferences to `T` (via the [`Deref`] trait),\n //! so you can call `T`'s methods on a value of type [`Rc<T>`][`Rc`]. To avoid name\n //! clashes with `T`'s methods, the methods of [`Rc<T>`][`Rc`] itself are associated\n-//! functions, called using function-like syntax:\n+//! functions, called using [fully qualified syntax]:\n //!\n //! ```\n //! use std::rc::Rc;\n-//! let my_rc = Rc::new(());\n //!\n+//! let my_rc = Rc::new(());\n //! Rc::downgrade(&my_rc);\n //! ```\n //!\n+//! `Rc<T>`'s implementations of traits like `Clone` may also be called using\n+//! fully qualified syntax. Some people prefer to use fully qualified syntax,\n+//! while others prefer using method-call syntax.\n+//!\n+//! ```\n+//! use std::rc::Rc;\n+//!\n+//! let rc = Rc::new(());\n+//! // Method-call syntax\n+//! let rc2 = rc.clone();\n+//! // Fully qualified syntax\n+//! let rc3 = Rc::clone(&rc);\n+//! ```\n+//!\n //! [`Weak<T>`][`Weak`] does not auto-dereference to `T`, because the inner value may have\n //! already been dropped.\n //!\n@@ -54,6 +68,7 @@\n //!\n //! ```\n //! use std::rc::Rc;\n+//!\n //! let foo = Rc::new(vec![1.0, 2.0, 3.0]);\n //! // The two syntaxes below are equivalent.\n //! let a = foo.clone();\n@@ -218,7 +233,7 @@\n //! [`Cell`]: core::cell::Cell\n //! [`RefCell`]: core::cell::RefCell\n //! [send]: core::marker::Send\n-//! [arc]: ../../std/sync/struct.Arc.html\n+//! [arc]: crate::sync::Arc\n //! [`Deref`]: core::ops::Deref\n //! [downgrade]: Rc::downgrade\n //! [upgrade]: Weak::upgrade\n@@ -272,10 +287,9 @@ struct RcBox<T: ?Sized> {\n ///\n /// The inherent methods of `Rc` are all associated functions, which means\n /// that you have to call them as e.g., [`Rc::get_mut(&mut value)`][get_mut] instead of\n-/// `value.get_mut()`. This avoids conflicts with methods of the inner\n-/// type `T`.\n+/// `value.get_mut()`. This avoids conflicts with methods of the inner type `T`.\n ///\n-/// [get_mut]: #method.get_mut\n+/// [get_mut]: Rc::get_mut\n #[cfg_attr(not(test), rustc_diagnostic_item = \"Rc\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T: ?Sized> {"}, {"sha": "ce216e5336eb8082c36eddc5c98187773028be2d", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1235,6 +1235,10 @@ impl String {\n         let mut del_bytes = 0;\n         let mut idx = 0;\n \n+        unsafe {\n+            self.vec.set_len(0);\n+        }\n+\n         while idx < len {\n             let ch = unsafe { self.get_unchecked(idx..len).chars().next().unwrap() };\n             let ch_len = ch.len_utf8();\n@@ -1255,10 +1259,8 @@ impl String {\n             idx += ch_len;\n         }\n \n-        if del_bytes > 0 {\n-            unsafe {\n-                self.vec.set_len(len - del_bytes);\n-            }\n+        unsafe {\n+            self.vec.set_len(len - del_bytes);\n         }\n     }\n "}, {"sha": "5ab930a5208843bfdb68035ea1b9bbb24ea4306a", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -129,15 +129,29 @@ macro_rules! acquire {\n /// `Arc<T>` automatically dereferences to `T` (via the [`Deref`][deref] trait),\n /// so you can call `T`'s methods on a value of type `Arc<T>`. To avoid name\n /// clashes with `T`'s methods, the methods of `Arc<T>` itself are associated\n-/// functions, called using function-like syntax:\n+/// functions, called using [fully qualified syntax]:\n ///\n /// ```\n /// use std::sync::Arc;\n-/// let my_arc = Arc::new(());\n ///\n+/// let my_arc = Arc::new(());\n /// Arc::downgrade(&my_arc);\n /// ```\n ///\n+/// `Arc<T>`'s implementations of traits like `Clone` may also be called using\n+/// fully qualified syntax. Some people prefer to use fully qualified syntax,\n+/// while others prefer using method-call syntax.\n+///\n+/// ```\n+/// use std::sync::Arc;\n+///\n+/// let arc = Arc::new(());\n+/// // Method-call syntax\n+/// let arc2 = arc.clone();\n+/// // Fully qualified syntax\n+/// let arc3 = Arc::clone(&arc);\n+/// ```\n+///\n /// [`Weak<T>`][Weak] does not auto-dereference to `T`, because the inner value may have\n /// already been dropped.\n ///\n@@ -154,6 +168,7 @@ macro_rules! acquire {\n /// [`RefCell<T>`]: core::cell::RefCell\n /// [`std::sync`]: ../../std/sync/index.html\n /// [`Arc::clone(&from)`]: Arc::clone\n+/// [fully qualified syntax]: https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name\n ///\n /// # Examples\n ///"}, {"sha": "b28694186b65ee611d3b486f8e6152ce5c7c3d1a", "filename": "library/alloc/tests/string.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/library%2Falloc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/library%2Falloc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstring.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1,6 +1,7 @@\n use std::borrow::Cow;\n use std::collections::TryReserveError::*;\n use std::ops::Bound::*;\n+use std::panic;\n \n pub trait IntoCow<'a, B: ?Sized>\n where\n@@ -378,6 +379,20 @@ fn test_retain() {\n \n     s.retain(|_| false);\n     assert_eq!(s, \"\");\n+\n+    let mut s = String::from(\"0\u00e80\");\n+    let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n+        let mut count = 0;\n+        s.retain(|_| {\n+            count += 1;\n+            match count {\n+                1 => false,\n+                2 => true,\n+                _ => panic!(),\n+            }\n+        });\n+    }));\n+    assert!(std::str::from_utf8(s.as_bytes()).is_ok());\n }\n \n #[test]"}, {"sha": "79ae1d5829a24464a580d76d2e53306fef5ff481", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1768,8 +1768,10 @@ impl<T> [T] {\n \n     /// Returns a subslice with the prefix removed.\n     ///\n-    /// This method returns [`None`] if slice does not start with `prefix`.\n-    /// Also it returns the original slice if `prefix` is an empty slice.\n+    /// If the slice starts with `prefix`, returns the subslice after the prefix, wrapped in `Some`.\n+    /// If `prefix` is empty, simply returns the original slice.\n+    ///\n+    /// If the slice does not start with `prefix`, returns `None`.\n     ///\n     /// # Examples\n     ///\n@@ -1799,8 +1801,10 @@ impl<T> [T] {\n \n     /// Returns a subslice with the suffix removed.\n     ///\n-    /// This method returns [`None`] if slice does not end with `suffix`.\n-    /// Also it returns the original slice if `suffix` is an empty slice\n+    /// If the slice ends with `suffix`, returns the subslice before the suffix, wrapped in `Some`.\n+    /// If `suffix` is empty, simply returns the original slice.\n+    ///\n+    /// If the slice does not end with `suffix`, returns `None`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "b36d9f5c38841beb64b317a1e1a7b6e4ef59798e", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1965,11 +1965,10 @@ impl str {\n \n     /// Returns a string slice with the prefix removed.\n     ///\n-    /// If the string starts with the pattern `prefix`, `Some` is returned with the substring where\n-    /// the prefix is removed. Unlike `trim_start_matches`, this method removes the prefix exactly\n-    /// once.\n+    /// If the string starts with the pattern `prefix`, returns substring after the prefix, wrapped\n+    /// in `Some`.  Unlike `trim_start_matches`, this method removes the prefix exactly once.\n     ///\n-    /// If the string does not start with `prefix`, `None` is returned.\n+    /// If the string does not start with `prefix`, returns `None`.\n     ///\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n@@ -1993,11 +1992,10 @@ impl str {\n \n     /// Returns a string slice with the suffix removed.\n     ///\n-    /// If the string ends with the pattern `suffix`, `Some` is returned with the substring where\n-    /// the suffix is removed. Unlike `trim_end_matches`, this method removes the suffix exactly\n-    /// once.\n+    /// If the string ends with the pattern `suffix`, returns the substring before the suffix,\n+    /// wrapped in `Some`.  Unlike `trim_end_matches`, this method removes the suffix exactly once.\n     ///\n-    /// If the string does not end with `suffix`, `None` is returned.\n+    /// If the string does not end with `suffix`, returns `None`.\n     ///\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches."}, {"sha": "77a8c92c81c7eb0b4fb036f6a57ea566bad80daa", "filename": "src/test/ui/issues/issue-78372.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftest%2Fui%2Fissues%2Fissue-78372.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftest%2Fui%2Fissues%2Fissue-78372.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-78372.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -0,0 +1,14 @@\n+use std::ops::DispatchFromDyn; //~ ERROR use of unstable library feature 'dispatch_from_dyn'\n+struct Smaht<T, MISC>(PhantomData); //~ ERROR cannot find type `PhantomData` in this scope\n+impl<T> DispatchFromDyn<Smaht<U, MISC>> for T {} //~ ERROR cannot find type `U` in this scope\n+//~^ ERROR cannot find type `MISC` in this scope\n+//~| ERROR use of unstable library feature 'dispatch_from_dyn'\n+//~| ERROR the trait `DispatchFromDyn` may only be implemented for a coercion between structures\n+//~| ERROR type parameter `T` must be covered by another type when it appears before the first\n+trait Foo: X<u32> {}\n+trait X<T> {\n+    fn foo(self: Smaht<Self, T>);\n+}\n+trait Marker {}\n+impl Marker for dyn Foo {}\n+fn main() {}"}, {"sha": "9267e838ceae917f839578f08d9396950f904381", "filename": "src/test/ui/issues/issue-78372.stderr", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftest%2Fui%2Fissues%2Fissue-78372.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftest%2Fui%2Fissues%2Fissue-78372.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-78372.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -0,0 +1,62 @@\n+error[E0412]: cannot find type `PhantomData` in this scope\n+  --> $DIR/issue-78372.rs:2:23\n+   |\n+LL | struct Smaht<T, MISC>(PhantomData);\n+   |                       ^^^^^^^^^^^ not found in this scope\n+   |\n+help: consider importing this struct\n+   |\n+LL | use std::marker::PhantomData;\n+   |\n+\n+error[E0412]: cannot find type `U` in this scope\n+  --> $DIR/issue-78372.rs:3:31\n+   |\n+LL | impl<T> DispatchFromDyn<Smaht<U, MISC>> for T {}\n+   |      -                        ^ help: a type parameter with a similar name exists: `T`\n+   |      |\n+   |      similarly named type parameter `T` defined here\n+\n+error[E0412]: cannot find type `MISC` in this scope\n+  --> $DIR/issue-78372.rs:3:34\n+   |\n+LL | impl<T> DispatchFromDyn<Smaht<U, MISC>> for T {}\n+   |       -                          ^^^^ not found in this scope\n+   |       |\n+   |       help: you might be missing a type parameter: `, MISC`\n+\n+error[E0658]: use of unstable library feature 'dispatch_from_dyn'\n+  --> $DIR/issue-78372.rs:1:5\n+   |\n+LL | use std::ops::DispatchFromDyn;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add `#![feature(dispatch_from_dyn)]` to the crate attributes to enable\n+\n+error[E0658]: use of unstable library feature 'dispatch_from_dyn'\n+  --> $DIR/issue-78372.rs:3:9\n+   |\n+LL | impl<T> DispatchFromDyn<Smaht<U, MISC>> for T {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add `#![feature(dispatch_from_dyn)]` to the crate attributes to enable\n+\n+error[E0378]: the trait `DispatchFromDyn` may only be implemented for a coercion between structures\n+  --> $DIR/issue-78372.rs:3:1\n+   |\n+LL | impl<T> DispatchFromDyn<Smaht<U, MISC>> for T {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0210]: type parameter `T` must be covered by another type when it appears before the first local type (`Smaht<[type error], [type error]>`)\n+  --> $DIR/issue-78372.rs:3:6\n+   |\n+LL | impl<T> DispatchFromDyn<Smaht<U, MISC>> for T {}\n+   |      ^ type parameter `T` must be covered by another type when it appears before the first local type (`Smaht<[type error], [type error]>`)\n+   |\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local, and no uncovered type parameters appear before that first local type\n+   = note: in this case, 'before' refers to the following order: `impl<..> ForeignTrait<T1, ..., Tn> for T0`, where `T0` is the first and `Tn` is the last\n+\n+error: aborting due to 7 previous errors\n+\n+Some errors have detailed explanations: E0210, E0378, E0412, E0658.\n+For more information about an error, try `rustc --explain E0210`."}, {"sha": "0f16229a291783b8926c56959ea76e07df5021ad", "filename": "src/test/ui/lint/lint-type-overflow2.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftest%2Fui%2Flint%2Flint-type-overflow2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftest%2Fui%2Flint%2Flint-type-overflow2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-type-overflow2.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -17,31 +17,31 @@ error: literal out of range for `f32`\n LL |     let x = -3.40282357e+38_f32;\n    |              ^^^^^^^^^^^^^^^^^^\n    |\n-   = note: the literal `3.40282357e+38_f32` does not fit into the type `f32` and will be converted to `std::f32::INFINITY`\n+   = note: the literal `3.40282357e+38_f32` does not fit into the type `f32` and will be converted to `f32::INFINITY`\n \n error: literal out of range for `f32`\n   --> $DIR/lint-type-overflow2.rs:10:14\n    |\n LL |     let x =  3.40282357e+38_f32;\n    |              ^^^^^^^^^^^^^^^^^^\n    |\n-   = note: the literal `3.40282357e+38_f32` does not fit into the type `f32` and will be converted to `std::f32::INFINITY`\n+   = note: the literal `3.40282357e+38_f32` does not fit into the type `f32` and will be converted to `f32::INFINITY`\n \n error: literal out of range for `f64`\n   --> $DIR/lint-type-overflow2.rs:11:14\n    |\n LL |     let x = -1.7976931348623159e+308_f64;\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: the literal `1.7976931348623159e+308_f64` does not fit into the type `f64` and will be converted to `std::f64::INFINITY`\n+   = note: the literal `1.7976931348623159e+308_f64` does not fit into the type `f64` and will be converted to `f64::INFINITY`\n \n error: literal out of range for `f64`\n   --> $DIR/lint-type-overflow2.rs:12:14\n    |\n LL |     let x =  1.7976931348623159e+308_f64;\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: the literal `1.7976931348623159e+308_f64` does not fit into the type `f64` and will be converted to `std::f64::INFINITY`\n+   = note: the literal `1.7976931348623159e+308_f64` does not fit into the type `f64` and will be converted to `f64::INFINITY`\n \n error: aborting due to 5 previous errors\n "}, {"sha": "becb4c282b8f37469efb8f5beda45a5501f9d367", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1 +1 @@\n-Subproject commit dd83ae55c871d94f060524656abab62ec40b4c40\n+Subproject commit becb4c282b8f37469efb8f5beda45a5501f9d367"}, {"sha": "321e00df153b6a2fcdfae8b222edb9d09026a340", "filename": "src/tools/clippy/.github/driver.sh", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2F.github%2Fdriver.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2F.github%2Fdriver.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fdriver.sh?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -7,9 +7,9 @@ sysroot=$(./target/debug/clippy-driver --print sysroot)\n test \"$sysroot\" = \"$(rustc --print sysroot)\"\n \n if [[ ${OS} == \"Windows\" ]]; then\n-  desired_sysroot=C:/tmp\n+\tdesired_sysroot=C:/tmp\n else\n-  desired_sysroot=/tmp\n+\tdesired_sysroot=/tmp\n fi\n sysroot=$(./target/debug/clippy-driver --sysroot $desired_sysroot --print sysroot)\n test \"$sysroot\" = $desired_sysroot\n@@ -22,20 +22,18 @@ unset CARGO_MANIFEST_DIR\n \n # Run a lint and make sure it produces the expected output. It's also expected to exit with code 1\n # FIXME: How to match the clippy invocation in compile-test.rs?\n-./target/debug/clippy-driver -Dwarnings -Aunused -Zui-testing --emit metadata --crate-type bin tests/ui/cast.rs 2> cast.stderr && exit 1\n-sed -e \"s,tests/ui,\\$DIR,\" -e \"/= help/d\" cast.stderr > normalized.stderr\n-diff normalized.stderr tests/ui/cast.stderr\n-\n+./target/debug/clippy-driver -Dwarnings -Aunused -Zui-testing --emit metadata --crate-type bin tests/ui/double_neg.rs 2>double_neg.stderr && exit 1\n+sed -e \"s,tests/ui,\\$DIR,\" -e \"/= help/d\" double_neg.stderr >normalized.stderr\n+diff normalized.stderr tests/ui/double_neg.stderr\n \n # make sure \"clippy-driver --rustc --arg\" and \"rustc --arg\" behave the same\n-SYSROOT=`rustc --print sysroot`\n+SYSROOT=$(rustc --print sysroot)\n diff <(LD_LIBRARY_PATH=${SYSROOT}/lib ./target/debug/clippy-driver --rustc --version --verbose) <(rustc --version --verbose)\n \n-\n-echo \"fn main() {}\" > target/driver_test.rs\n+echo \"fn main() {}\" >target/driver_test.rs\n # we can't run 2 rustcs on the same file at the same time\n-CLIPPY=`LD_LIBRARY_PATH=${SYSROOT}/lib ./target/debug/clippy-driver ./target/driver_test.rs --rustc`\n-RUSTC=`rustc ./target/driver_test.rs`\n+CLIPPY=$(LD_LIBRARY_PATH=${SYSROOT}/lib ./target/debug/clippy-driver ./target/driver_test.rs --rustc)\n+RUSTC=$(rustc ./target/driver_test.rs)\n diff <($CLIPPY) <($RUSTC)\n \n # TODO: CLIPPY_CONF_DIR / CARGO_MANIFEST_DIR"}, {"sha": "25f3b5da198afbd8971819c2a2e1837c1c8b7edf", "filename": "src/tools/clippy/CHANGELOG.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1632,6 +1632,7 @@ Released 2018-09-13\n [`assign_ops`]: https://rust-lang.github.io/rust-clippy/master/index.html#assign_ops\n [`async_yields_async`]: https://rust-lang.github.io/rust-clippy/master/index.html#async_yields_async\n [`await_holding_lock`]: https://rust-lang.github.io/rust-clippy/master/index.html#await_holding_lock\n+[`await_holding_refcell_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#await_holding_refcell_ref\n [`bad_bit_mask`]: https://rust-lang.github.io/rust-clippy/master/index.html#bad_bit_mask\n [`bind_instead_of_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#bind_instead_of_map\n [`blacklisted_name`]: https://rust-lang.github.io/rust-clippy/master/index.html#blacklisted_name\n@@ -1779,6 +1780,7 @@ Released 2018-09-13\n [`large_digit_groups`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_digit_groups\n [`large_enum_variant`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_enum_variant\n [`large_stack_arrays`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_stack_arrays\n+[`large_types_passed_by_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_types_passed_by_value\n [`len_without_is_empty`]: https://rust-lang.github.io/rust-clippy/master/index.html#len_without_is_empty\n [`len_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#len_zero\n [`let_and_return`]: https://rust-lang.github.io/rust-clippy/master/index.html#let_and_return\n@@ -1793,6 +1795,7 @@ Released 2018-09-13\n [`manual_async_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_async_fn\n [`manual_memcpy`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_memcpy\n [`manual_non_exhaustive`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_non_exhaustive\n+[`manual_range_contains`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains\n [`manual_saturating_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_saturating_arithmetic\n [`manual_strip`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_strip\n [`manual_swap`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_swap\n@@ -1841,6 +1844,7 @@ Released 2018-09-13\n [`must_use_unit`]: https://rust-lang.github.io/rust-clippy/master/index.html#must_use_unit\n [`mut_from_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#mut_from_ref\n [`mut_mut`]: https://rust-lang.github.io/rust-clippy/master/index.html#mut_mut\n+[`mut_mutex_lock`]: https://rust-lang.github.io/rust-clippy/master/index.html#mut_mutex_lock\n [`mut_range_bound`]: https://rust-lang.github.io/rust-clippy/master/index.html#mut_range_bound\n [`mutable_key_type`]: https://rust-lang.github.io/rust-clippy/master/index.html#mutable_key_type\n [`mutex_atomic`]: https://rust-lang.github.io/rust-clippy/master/index.html#mutex_atomic\n@@ -1936,6 +1940,7 @@ Released 2018-09-13\n [`single_char_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_char_pattern\n [`single_char_push_str`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_char_push_str\n [`single_component_path_imports`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_component_path_imports\n+[`single_element_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_element_loop\n [`single_match`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_match\n [`single_match_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_match_else\n [`skip_while_next`]: https://rust-lang.github.io/rust-clippy/master/index.html#skip_while_next\n@@ -1979,6 +1984,7 @@ Released 2018-09-13\n [`try_err`]: https://rust-lang.github.io/rust-clippy/master/index.html#try_err\n [`type_complexity`]: https://rust-lang.github.io/rust-clippy/master/index.html#type_complexity\n [`type_repetition_in_bounds`]: https://rust-lang.github.io/rust-clippy/master/index.html#type_repetition_in_bounds\n+[`undropped_manually_drops`]: https://rust-lang.github.io/rust-clippy/master/index.html#undropped_manually_drops\n [`unicode_not_nfc`]: https://rust-lang.github.io/rust-clippy/master/index.html#unicode_not_nfc\n [`unimplemented`]: https://rust-lang.github.io/rust-clippy/master/index.html#unimplemented\n [`uninit_assumed_init`]: https://rust-lang.github.io/rust-clippy/master/index.html#uninit_assumed_init\n@@ -2011,6 +2017,7 @@ Released 2018-09-13\n [`unused_label`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_label\n [`unused_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_self\n [`unused_unit`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_unit\n+[`unusual_byte_groupings`]: https://rust-lang.github.io/rust-clippy/master/index.html#unusual_byte_groupings\n [`unwrap_in_result`]: https://rust-lang.github.io/rust-clippy/master/index.html#unwrap_in_result\n [`unwrap_used`]: https://rust-lang.github.io/rust-clippy/master/index.html#unwrap_used\n [`use_debug`]: https://rust-lang.github.io/rust-clippy/master/index.html#use_debug"}, {"sha": "fcebb54c6c217840d3b5a2b7faa8f1249dc72a29", "filename": "src/tools/clippy/clippy_lints/src/await_holding_invalid.rs", "status": "renamed", "additions": 56, "deletions": 3, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -45,13 +45,52 @@ declare_clippy_lint! {\n     /// }\n     /// ```\n     pub AWAIT_HOLDING_LOCK,\n-    pedantic,\n+    correctness,\n     \"Inside an async function, holding a MutexGuard while calling await\"\n }\n \n-declare_lint_pass!(AwaitHoldingLock => [AWAIT_HOLDING_LOCK]);\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to await while holding a\n+    /// `RefCell` `Ref` or `RefMut`.\n+    ///\n+    /// **Why is this bad?** `RefCell` refs only check for exclusive mutable access\n+    /// at runtime. Holding onto a `RefCell` ref across an `await` suspension point\n+    /// risks panics from a mutable ref shared while other refs are outstanding.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust,ignore\n+    /// use std::cell::RefCell;\n+    ///\n+    /// async fn foo(x: &RefCell<u32>) {\n+    ///   let b = x.borrow_mut()();\n+    ///   *ref += 1;\n+    ///   bar.await;\n+    /// }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// use std::cell::RefCell;\n+    ///\n+    /// async fn foo(x: &RefCell<u32>) {\n+    ///   {\n+    ///     let b = x.borrow_mut();\n+    ///     *ref += 1;\n+    ///   }\n+    ///   bar.await;\n+    /// }\n+    /// ```\n+    pub AWAIT_HOLDING_REFCELL_REF,\n+    correctness,\n+    \"Inside an async function, holding a RefCell ref while calling await\"\n+}\n \n-impl LateLintPass<'_> for AwaitHoldingLock {\n+declare_lint_pass!(AwaitHolding => [AWAIT_HOLDING_LOCK, AWAIT_HOLDING_REFCELL_REF]);\n+\n+impl LateLintPass<'_> for AwaitHolding {\n     fn check_body(&mut self, cx: &LateContext<'_>, body: &'_ Body<'_>) {\n         use AsyncGeneratorKind::{Block, Closure, Fn};\n         if let Some(GeneratorKind::Async(Block | Closure | Fn)) = body.generator_kind {\n@@ -78,6 +117,16 @@ fn check_interior_types(cx: &LateContext<'_>, ty_causes: &[GeneratorInteriorType\n                     \"these are all the await points this lock is held through\",\n                 );\n             }\n+            if is_refcell_ref(cx, adt.did) {\n+                span_lint_and_note(\n+                        cx,\n+                        AWAIT_HOLDING_REFCELL_REF,\n+                        ty_cause.span,\n+                        \"this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\",\n+                        ty_cause.scope_span.or(Some(span)),\n+                        \"these are all the await points this ref is held through\",\n+                    );\n+            }\n         }\n     }\n }\n@@ -90,3 +139,7 @@ fn is_mutex_guard(cx: &LateContext<'_>, def_id: DefId) -> bool {\n         || match_def_path(cx, def_id, &paths::PARKING_LOT_RWLOCK_READ_GUARD)\n         || match_def_path(cx, def_id, &paths::PARKING_LOT_RWLOCK_WRITE_GUARD)\n }\n+\n+fn is_refcell_ref(cx: &LateContext<'_>, def_id: DefId) -> bool {\n+    match_def_path(cx, def_id, &paths::REFCELL_REF) || match_def_path(cx, def_id, &paths::REFCELL_REFMUT)\n+}", "previous_filename": "src/tools/clippy/clippy_lints/src/await_holding_lock.rs"}, {"sha": "736730d4084f43e7467b60a541cc3d00e2bd2244", "filename": "src/tools/clippy/clippy_lints/src/blocks_in_if_conditions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -28,7 +28,6 @@ declare_clippy_lint! {\n     ///\n     /// ```rust\n     /// # fn somefunc() -> bool { true };\n-    ///\n     /// // Bad\n     /// if { let x = somefunc(); x } { /* ... */ }\n     ///"}, {"sha": "46ce92ea6d782273d7f894a2c9e634913fbd1888", "filename": "src/tools/clippy/clippy_lints/src/copies.rs", "status": "modified", "additions": 4, "deletions": 211, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1,13 +1,8 @@\n-use crate::utils::{eq_expr_value, in_macro, SpanlessEq, SpanlessHash};\n-use crate::utils::{get_parent_expr, higher, if_sequence, snippet, span_lint_and_note, span_lint_and_then};\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::{Arm, Block, Expr, ExprKind, MatchSource, Pat, PatKind};\n+use crate::utils::{eq_expr_value, in_macro, search_same, SpanlessEq, SpanlessHash};\n+use crate::utils::{get_parent_expr, higher, if_sequence, span_lint_and_note};\n+use rustc_hir::{Block, Expr};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{Ty, TyS};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::Symbol;\n-use std::collections::hash_map::Entry;\n-use std::hash::BuildHasherDefault;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for consecutive `if`s with the same condition.\n@@ -108,48 +103,7 @@ declare_clippy_lint! {\n     \"`if` with the same `then` and `else` blocks\"\n }\n \n-declare_clippy_lint! {\n-    /// **What it does:** Checks for `match` with identical arm bodies.\n-    ///\n-    /// **Why is this bad?** This is probably a copy & paste error. If arm bodies\n-    /// are the same on purpose, you can factor them\n-    /// [using `|`](https://doc.rust-lang.org/book/patterns.html#multiple-patterns).\n-    ///\n-    /// **Known problems:** False positive possible with order dependent `match`\n-    /// (see issue\n-    /// [#860](https://github.com/rust-lang/rust-clippy/issues/860)).\n-    ///\n-    /// **Example:**\n-    /// ```rust,ignore\n-    /// match foo {\n-    ///     Bar => bar(),\n-    ///     Quz => quz(),\n-    ///     Baz => bar(), // <= oops\n-    /// }\n-    /// ```\n-    ///\n-    /// This should probably be\n-    /// ```rust,ignore\n-    /// match foo {\n-    ///     Bar => bar(),\n-    ///     Quz => quz(),\n-    ///     Baz => baz(), // <= fixed\n-    /// }\n-    /// ```\n-    ///\n-    /// or if the original code was not a typo:\n-    /// ```rust,ignore\n-    /// match foo {\n-    ///     Bar | Baz => bar(), // <= shows the intent better\n-    ///     Quz => quz(),\n-    /// }\n-    /// ```\n-    pub MATCH_SAME_ARMS,\n-    pedantic,\n-    \"`match` with identical arm bodies\"\n-}\n-\n-declare_lint_pass!(CopyAndPaste => [IFS_SAME_COND, SAME_FUNCTIONS_IN_IF_CONDITION, IF_SAME_THEN_ELSE, MATCH_SAME_ARMS]);\n+declare_lint_pass!(CopyAndPaste => [IFS_SAME_COND, SAME_FUNCTIONS_IN_IF_CONDITION, IF_SAME_THEN_ELSE]);\n \n impl<'tcx> LateLintPass<'tcx> for CopyAndPaste {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n@@ -167,7 +121,6 @@ impl<'tcx> LateLintPass<'tcx> for CopyAndPaste {\n             lint_same_then_else(cx, &blocks);\n             lint_same_cond(cx, &conds);\n             lint_same_fns_in_if_cond(cx, &conds);\n-            lint_match_arms(cx, expr);\n         }\n     }\n }\n@@ -243,122 +196,6 @@ fn lint_same_fns_in_if_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>]) {\n     }\n }\n \n-/// Implementation of `MATCH_SAME_ARMS`.\n-fn lint_match_arms<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n-    fn same_bindings<'tcx>(lhs: &FxHashMap<Symbol, Ty<'tcx>>, rhs: &FxHashMap<Symbol, Ty<'tcx>>) -> bool {\n-        lhs.len() == rhs.len()\n-            && lhs\n-                .iter()\n-                .all(|(name, l_ty)| rhs.get(name).map_or(false, |r_ty| TyS::same_type(l_ty, r_ty)))\n-    }\n-\n-    if let ExprKind::Match(_, ref arms, MatchSource::Normal) = expr.kind {\n-        let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n-            let mut h = SpanlessHash::new(cx);\n-            h.hash_expr(&arm.body);\n-            h.finish()\n-        };\n-\n-        let eq = |&(lindex, lhs): &(usize, &Arm<'_>), &(rindex, rhs): &(usize, &Arm<'_>)| -> bool {\n-            let min_index = usize::min(lindex, rindex);\n-            let max_index = usize::max(lindex, rindex);\n-\n-            // Arms with a guard are ignored, those can\u2019t always be merged together\n-            // This is also the case for arms in-between each there is an arm with a guard\n-            (min_index..=max_index).all(|index| arms[index].guard.is_none()) &&\n-                SpanlessEq::new(cx).eq_expr(&lhs.body, &rhs.body) &&\n-                // all patterns should have the same bindings\n-                same_bindings(&bindings(cx, &lhs.pat), &bindings(cx, &rhs.pat))\n-        };\n-\n-        let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n-        for (&(_, i), &(_, j)) in search_same(&indexed_arms, hash, eq) {\n-            span_lint_and_then(\n-                cx,\n-                MATCH_SAME_ARMS,\n-                j.body.span,\n-                \"this `match` has identical arm bodies\",\n-                |diag| {\n-                    diag.span_note(i.body.span, \"same as this\");\n-\n-                    // Note: this does not use `span_suggestion` on purpose:\n-                    // there is no clean way\n-                    // to remove the other arm. Building a span and suggest to replace it to \"\"\n-                    // makes an even more confusing error message. Also in order not to make up a\n-                    // span for the whole pattern, the suggestion is only shown when there is only\n-                    // one pattern. The user should know about `|` if they are already using it\u2026\n-\n-                    let lhs = snippet(cx, i.pat.span, \"<pat1>\");\n-                    let rhs = snippet(cx, j.pat.span, \"<pat2>\");\n-\n-                    if let PatKind::Wild = j.pat.kind {\n-                        // if the last arm is _, then i could be integrated into _\n-                        // note that i.pat cannot be _, because that would mean that we're\n-                        // hiding all the subsequent arms, and rust won't compile\n-                        diag.span_note(\n-                            i.body.span,\n-                            &format!(\n-                                \"`{}` has the same arm body as the `_` wildcard, consider removing it\",\n-                                lhs\n-                            ),\n-                        );\n-                    } else {\n-                        diag.span_help(i.pat.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs));\n-                    }\n-                },\n-            );\n-        }\n-    }\n-}\n-\n-/// Returns the list of bindings in a pattern.\n-fn bindings<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>) -> FxHashMap<Symbol, Ty<'tcx>> {\n-    fn bindings_impl<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>, map: &mut FxHashMap<Symbol, Ty<'tcx>>) {\n-        match pat.kind {\n-            PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => bindings_impl(cx, pat, map),\n-            PatKind::TupleStruct(_, pats, _) => {\n-                for pat in pats {\n-                    bindings_impl(cx, pat, map);\n-                }\n-            },\n-            PatKind::Binding(.., ident, ref as_pat) => {\n-                if let Entry::Vacant(v) = map.entry(ident.name) {\n-                    v.insert(cx.typeck_results().pat_ty(pat));\n-                }\n-                if let Some(ref as_pat) = *as_pat {\n-                    bindings_impl(cx, as_pat, map);\n-                }\n-            },\n-            PatKind::Or(fields) | PatKind::Tuple(fields, _) => {\n-                for pat in fields {\n-                    bindings_impl(cx, pat, map);\n-                }\n-            },\n-            PatKind::Struct(_, fields, _) => {\n-                for pat in fields {\n-                    bindings_impl(cx, &pat.pat, map);\n-                }\n-            },\n-            PatKind::Slice(lhs, ref mid, rhs) => {\n-                for pat in lhs {\n-                    bindings_impl(cx, pat, map);\n-                }\n-                if let Some(ref mid) = *mid {\n-                    bindings_impl(cx, mid, map);\n-                }\n-                for pat in rhs {\n-                    bindings_impl(cx, pat, map);\n-                }\n-            },\n-            PatKind::Lit(..) | PatKind::Range(..) | PatKind::Wild | PatKind::Path(..) => (),\n-        }\n-    }\n-\n-    let mut result = FxHashMap::default();\n-    bindings_impl(cx, pat, &mut result);\n-    result\n-}\n-\n fn search_same_sequenced<T, Eq>(exprs: &[T], eq: Eq) -> Option<(&T, &T)>\n where\n     Eq: Fn(&T, &T) -> bool,\n@@ -370,47 +207,3 @@ where\n     }\n     None\n }\n-\n-fn search_common_cases<'a, T, Eq>(exprs: &'a [T], eq: &Eq) -> Option<(&'a T, &'a T)>\n-where\n-    Eq: Fn(&T, &T) -> bool,\n-{\n-    if exprs.len() == 2 && eq(&exprs[0], &exprs[1]) {\n-        Some((&exprs[0], &exprs[1]))\n-    } else {\n-        None\n-    }\n-}\n-\n-fn search_same<T, Hash, Eq>(exprs: &[T], hash: Hash, eq: Eq) -> Vec<(&T, &T)>\n-where\n-    Hash: Fn(&T) -> u64,\n-    Eq: Fn(&T, &T) -> bool,\n-{\n-    if let Some(expr) = search_common_cases(&exprs, &eq) {\n-        return vec![expr];\n-    }\n-\n-    let mut match_expr_list: Vec<(&T, &T)> = Vec::new();\n-\n-    let mut map: FxHashMap<_, Vec<&_>> =\n-        FxHashMap::with_capacity_and_hasher(exprs.len(), BuildHasherDefault::default());\n-\n-    for expr in exprs {\n-        match map.entry(hash(expr)) {\n-            Entry::Occupied(mut o) => {\n-                for o in o.get() {\n-                    if eq(o, expr) {\n-                        match_expr_list.push((o, expr));\n-                    }\n-                }\n-                o.get_mut().push(expr);\n-            },\n-            Entry::Vacant(v) => {\n-                v.insert(vec![expr]);\n-            },\n-        }\n-    }\n-\n-    match_expr_list\n-}"}, {"sha": "461c6e31d3eb40b2ad099246f598caf7f69714b9", "filename": "src/tools/clippy/clippy_lints/src/deprecated_lints.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeprecated_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeprecated_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeprecated_lints.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -172,3 +172,12 @@ declare_deprecated_lint! {\n     pub DROP_BOUNDS,\n     \"this lint has been uplifted to rustc and is now called `drop_bounds`\"\n }\n+\n+declare_deprecated_lint! {\n+    /// **What it does:** Nothing. This lint has been deprecated.\n+    ///\n+    /// **Deprecation reason:** This lint has been uplifted to rustc and is now called\n+    /// `temporary_cstring_as_ptr`.\n+    pub TEMPORARY_CSTRING_AS_PTR,\n+    \"this lint has been uplifted to rustc and is now called `temporary_cstring_as_ptr`\"\n+}"}, {"sha": "c75efc6e99f899c73ed3c3d56c43ef00f47ef127", "filename": "src/tools/clippy/clippy_lints/src/derive.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1,6 +1,6 @@\n use crate::utils::paths;\n use crate::utils::{\n-    get_trait_def_id, is_allowed, is_automatically_derived, is_copy, match_path, span_lint_and_help,\n+    get_trait_def_id, is_allowed, is_automatically_derived, is_copy, match_def_path, match_path, span_lint_and_help,\n     span_lint_and_note, span_lint_and_then,\n };\n use if_chain::if_chain;\n@@ -193,10 +193,9 @@ fn check_hash_peq<'tcx>(\n     hash_is_automatically_derived: bool,\n ) {\n     if_chain! {\n-        if match_path(&trait_ref.path, &paths::HASH);\n         if let Some(peq_trait_def_id) = cx.tcx.lang_items().eq_trait();\n-        if let Some(def_id) = &trait_ref.trait_def_id();\n-        if !def_id.is_local();\n+        if let Some(def_id) = trait_ref.trait_def_id();\n+        if match_def_path(cx, def_id, &paths::HASH);\n         then {\n             // Look for the PartialEq implementations for `ty`\n             cx.tcx.for_each_relevant_impl(peq_trait_def_id, ty, |impl_id| {\n@@ -352,7 +351,8 @@ fn check_unsafe_derive_deserialize<'tcx>(\n     }\n \n     if_chain! {\n-        if match_path(&trait_ref.path, &paths::SERDE_DESERIALIZE);\n+        if let Some(trait_def_id) = trait_ref.trait_def_id();\n+        if match_def_path(cx, trait_def_id, &paths::SERDE_DESERIALIZE);\n         if let ty::Adt(def, _) = ty.kind();\n         if let Some(local_def_id) = def.did.as_local();\n         let adt_hir_id = cx.tcx.hir().local_def_id_to_hir_id(local_def_id);"}, {"sha": "1bf3b810fb50ee7f9ecdabdead0562c813fa3fa4", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -29,7 +29,6 @@ declare_clippy_lint! {\n     /// **Example:**\n     /// ```rust\n     /// # fn foo(bar: usize) {}\n-    ///\n     /// // Bad\n     /// let x = Box::new(1);\n     /// foo(*x);"}, {"sha": "c1c08597ee67004700cc2aef27b2e0c8e4ba39f7", "filename": "src/tools/clippy/clippy_lints/src/float_equality_without_abs.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1,7 +1,8 @@\n-use crate::utils::{match_qpath, paths, span_lint_and_then, sugg};\n+use crate::utils::{match_def_path, paths, span_lint_and_then, sugg};\n use if_chain::if_chain;\n use rustc_ast::util::parser::AssocOp;\n use rustc_errors::Applicability;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n@@ -76,7 +77,8 @@ impl<'tcx> LateLintPass<'tcx> for FloatEqualityWithoutAbs {\n \n             // right hand side matches either f32::EPSILON or f64::EPSILON\n             if let ExprKind::Path(ref epsilon_path) = rhs.kind;\n-            if match_qpath(epsilon_path, &paths::F32_EPSILON) || match_qpath(epsilon_path, &paths::F64_EPSILON);\n+            if let Res::Def(DefKind::AssocConst, def_id) = cx.qpath_res(epsilon_path, rhs.hir_id);\n+            if match_def_path(cx, def_id, &paths::F32_EPSILON) || match_def_path(cx, def_id, &paths::F64_EPSILON);\n \n             // values of the substractions on the left hand side are of the type float\n             let t_val_l = cx.typeck_results().expr_ty(val_l);"}, {"sha": "9c0efef95de8a4ac93a1aa3dbe9956b6397bae66", "filename": "src/tools/clippy/clippy_lints/src/functions.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -579,9 +579,8 @@ fn is_mutable_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, tys: &mut FxHashSet<\n     if let hir::PatKind::Wild = pat.kind {\n         return false; // ignore `_` patterns\n     }\n-    let def_id = pat.hir_id.owner.to_def_id();\n-    if cx.tcx.has_typeck_results(def_id) {\n-        is_mutable_ty(cx, &cx.tcx.typeck(def_id.expect_local()).pat_ty(pat), pat.span, tys)\n+    if cx.tcx.has_typeck_results(pat.hir_id.owner.to_def_id()) {\n+        is_mutable_ty(cx, &cx.tcx.typeck(pat.hir_id.owner).pat_ty(pat), pat.span, tys)\n     } else {\n         false\n     }\n@@ -694,11 +693,10 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n             Call(_, args) | MethodCall(_, _, args, _) => {\n                 let mut tys = FxHashSet::default();\n                 for arg in args {\n-                    let def_id = arg.hir_id.owner.to_def_id();\n-                    if self.cx.tcx.has_typeck_results(def_id)\n+                    if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n                         && is_mutable_ty(\n                             self.cx,\n-                            self.cx.tcx.typeck(def_id.expect_local()).expr_ty(arg),\n+                            self.cx.tcx.typeck(arg.hir_id.owner).expr_ty(arg),\n                             arg.span,\n                             &mut tys,\n                         )"}, {"sha": "2d37496984609b213df72b51794fcb1ca0be4cba", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 44, "deletions": 11, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -160,7 +160,7 @@ mod assign_ops;\n mod async_yields_async;\n mod atomic_ordering;\n mod attrs;\n-mod await_holding_lock;\n+mod await_holding_invalid;\n mod bit_mask;\n mod blacklisted_name;\n mod blocks_in_if_conditions;\n@@ -255,6 +255,7 @@ mod modulo_arithmetic;\n mod multiple_crate_versions;\n mod mut_key;\n mod mut_mut;\n+mod mut_mutex_lock;\n mod mut_reference;\n mod mutable_debug_assertion;\n mod mutex_atomic;\n@@ -278,6 +279,7 @@ mod overflow_check_conditional;\n mod panic_in_result_fn;\n mod panic_unimplemented;\n mod partialeq_ne_impl;\n+mod pass_by_ref_or_value;\n mod path_buf_push_overwrite;\n mod pattern_type_mismatch;\n mod precedence;\n@@ -311,9 +313,9 @@ mod to_string_in_display;\n mod trait_bounds;\n mod transmute;\n mod transmuting_null;\n-mod trivially_copy_pass_by_ref;\n mod try_err;\n mod types;\n+mod undropped_manually_drops;\n mod unicode;\n mod unit_return_expecting_ord;\n mod unnamed_address;\n@@ -486,6 +488,10 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         \"clippy::drop_bounds\",\n         \"this lint has been uplifted to rustc and is now called `drop_bounds`\",\n     );\n+    store.register_removed(\n+        \"clippy::temporary_cstring_as_ptr\",\n+        \"this lint has been uplifted to rustc and is now called `temporary_cstring_as_ptr`\",\n+    );\n     // end deprecated lints, do not remove this comment, it\u2019s used in `update_lints`\n \n     // begin register lints, do not remove this comment, it\u2019s used in `update_lints`\n@@ -509,7 +515,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &attrs::MISMATCHED_TARGET_OS,\n         &attrs::UNKNOWN_CLIPPY_LINTS,\n         &attrs::USELESS_ATTRIBUTE,\n-        &await_holding_lock::AWAIT_HOLDING_LOCK,\n+        &await_holding_invalid::AWAIT_HOLDING_LOCK,\n+        &await_holding_invalid::AWAIT_HOLDING_REFCELL_REF,\n         &bit_mask::BAD_BIT_MASK,\n         &bit_mask::INEFFECTIVE_BIT_MASK,\n         &bit_mask::VERBOSE_BIT_MASK,\n@@ -525,7 +532,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &comparison_chain::COMPARISON_CHAIN,\n         &copies::IFS_SAME_COND,\n         &copies::IF_SAME_THEN_ELSE,\n-        &copies::MATCH_SAME_ARMS,\n         &copies::SAME_FUNCTIONS_IN_IF_CONDITION,\n         &copy_iterator::COPY_ITERATOR,\n         &create_dir::CREATE_DIR,\n@@ -620,6 +626,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &literal_representation::LARGE_DIGIT_GROUPS,\n         &literal_representation::MISTYPED_LITERAL_SUFFIXES,\n         &literal_representation::UNREADABLE_LITERAL,\n+        &literal_representation::UNUSUAL_BYTE_GROUPINGS,\n         &loops::EMPTY_LOOP,\n         &loops::EXPLICIT_COUNTER_LOOP,\n         &loops::EXPLICIT_INTO_ITER_LOOP,\n@@ -633,6 +640,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &loops::NEEDLESS_RANGE_LOOP,\n         &loops::NEVER_LOOP,\n         &loops::SAME_ITEM_PUSH,\n+        &loops::SINGLE_ELEMENT_LOOP,\n         &loops::WHILE_IMMUTABLE_CONDITION,\n         &loops::WHILE_LET_LOOP,\n         &loops::WHILE_LET_ON_ITERATOR,\n@@ -654,6 +662,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &matches::MATCH_LIKE_MATCHES_MACRO,\n         &matches::MATCH_OVERLAPPING_ARM,\n         &matches::MATCH_REF_PATS,\n+        &matches::MATCH_SAME_ARMS,\n         &matches::MATCH_SINGLE_BINDING,\n         &matches::MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n         &matches::MATCH_WILD_ERR_ARM,\n@@ -742,6 +751,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &multiple_crate_versions::MULTIPLE_CRATE_VERSIONS,\n         &mut_key::MUTABLE_KEY_TYPE,\n         &mut_mut::MUT_MUT,\n+        &mut_mutex_lock::MUT_MUTEX_LOCK,\n         &mut_reference::UNNECESSARY_MUT_PASSED,\n         &mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL,\n         &mutex_atomic::MUTEX_ATOMIC,\n@@ -775,6 +785,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &panic_unimplemented::UNIMPLEMENTED,\n         &panic_unimplemented::UNREACHABLE,\n         &partialeq_ne_impl::PARTIALEQ_NE_IMPL,\n+        &pass_by_ref_or_value::LARGE_TYPES_PASSED_BY_VALUE,\n+        &pass_by_ref_or_value::TRIVIALLY_COPY_PASS_BY_REF,\n         &path_buf_push_overwrite::PATH_BUF_PUSH_OVERWRITE,\n         &pattern_type_mismatch::PATTERN_TYPE_MISMATCH,\n         &precedence::PRECEDENCE,\n@@ -784,6 +796,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &ptr_eq::PTR_EQ,\n         &ptr_offset_with_cast::PTR_OFFSET_WITH_CAST,\n         &question_mark::QUESTION_MARK,\n+        &ranges::MANUAL_RANGE_CONTAINS,\n         &ranges::RANGE_MINUS_ONE,\n         &ranges::RANGE_PLUS_ONE,\n         &ranges::RANGE_ZIP_WITH_LEN,\n@@ -834,7 +847,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &transmute::USELESS_TRANSMUTE,\n         &transmute::WRONG_TRANSMUTE,\n         &transmuting_null::TRANSMUTING_NULL,\n-        &trivially_copy_pass_by_ref::TRIVIALLY_COPY_PASS_BY_REF,\n         &try_err::TRY_ERR,\n         &types::ABSURD_EXTREME_COMPARISONS,\n         &types::BORROWED_BOX,\n@@ -861,6 +873,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &types::UNIT_CMP,\n         &types::UNNECESSARY_CAST,\n         &types::VEC_BOX,\n+        &undropped_manually_drops::UNDROPPED_MANUALLY_DROPS,\n         &unicode::INVISIBLE_CHARACTERS,\n         &unicode::NON_ASCII_LITERAL,\n         &unicode::UNICODE_NOT_NFC,\n@@ -882,6 +895,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &utils::internal_lints::COLLAPSIBLE_SPAN_LINT_CALLS,\n         &utils::internal_lints::COMPILER_LINT_FUNCTIONS,\n         &utils::internal_lints::DEFAULT_LINT,\n+        &utils::internal_lints::INVALID_PATHS,\n         &utils::internal_lints::LINT_WITHOUT_LINT_PASS,\n         &utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n         &utils::internal_lints::OUTER_EXPN_EXPN_DATA,\n@@ -904,11 +918,12 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     ]);\n     // end register lints, do not remove this comment, it\u2019s used in `update_lints`\n \n-    store.register_late_pass(|| box await_holding_lock::AwaitHoldingLock);\n+    store.register_late_pass(|| box await_holding_invalid::AwaitHolding);\n     store.register_late_pass(|| box serde_api::SerdeAPI);\n     store.register_late_pass(|| box utils::internal_lints::CompilerLintFunctions::new());\n     store.register_late_pass(|| box utils::internal_lints::LintWithoutLintPass::default());\n     store.register_late_pass(|| box utils::internal_lints::OuterExpnDataPass);\n+    store.register_late_pass(|| box utils::internal_lints::InvalidPaths);\n     store.register_late_pass(|| box utils::inspector::DeepCodeInspector);\n     store.register_late_pass(|| box utils::author::Author);\n     let vec_box_size_threshold = conf.vec_box_size_threshold;\n@@ -1008,11 +1023,12 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || box large_enum_variant::LargeEnumVariant::new(enum_variant_size_threshold));\n     store.register_late_pass(|| box explicit_write::ExplicitWrite);\n     store.register_late_pass(|| box needless_pass_by_value::NeedlessPassByValue);\n-    let trivially_copy_pass_by_ref = trivially_copy_pass_by_ref::TriviallyCopyPassByRef::new(\n+    let pass_by_ref_or_value = pass_by_ref_or_value::PassByRefOrValue::new(\n         conf.trivial_copy_size_limit,\n+        conf.pass_by_value_size_limit,\n         &sess.target,\n     );\n-    store.register_late_pass(move || box trivially_copy_pass_by_ref);\n+    store.register_late_pass(move || box pass_by_ref_or_value);\n     store.register_late_pass(|| box try_err::TryErr);\n     store.register_late_pass(|| box use_self::UseSelf);\n     store.register_late_pass(|| box bytecount::ByteCount);\n@@ -1108,6 +1124,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box future_not_send::FutureNotSend);\n     store.register_late_pass(|| box utils::internal_lints::CollapsibleCalls);\n     store.register_late_pass(|| box if_let_mutex::IfLetMutex);\n+    store.register_late_pass(|| box mut_mutex_lock::MutMutexLock);\n     store.register_late_pass(|| box match_on_vec_items::MatchOnVecItems);\n     store.register_early_pass(|| box manual_non_exhaustive::ManualNonExhaustive);\n     store.register_late_pass(|| box manual_async_fn::ManualAsyncFn);\n@@ -1136,6 +1153,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || box disallowed_method::DisallowedMethod::new(&disallowed_methods));\n     store.register_early_pass(|| box asm_syntax::InlineAsmX86AttSyntax);\n     store.register_early_pass(|| box asm_syntax::InlineAsmX86IntelSyntax);\n+    store.register_late_pass(|| box undropped_manually_drops::UndroppedManuallyDrops);\n \n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n@@ -1187,10 +1205,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n \n     store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n         LintId::of(&attrs::INLINE_ALWAYS),\n-        LintId::of(&await_holding_lock::AWAIT_HOLDING_LOCK),\n         LintId::of(&bit_mask::VERBOSE_BIT_MASK),\n         LintId::of(&checked_conversions::CHECKED_CONVERSIONS),\n-        LintId::of(&copies::MATCH_SAME_ARMS),\n         LintId::of(&copies::SAME_FUNCTIONS_IN_IF_CONDITION),\n         LintId::of(&copy_iterator::COPY_ITERATOR),\n         LintId::of(&default_trait_access::DEFAULT_TRAIT_ACCESS),\n@@ -1220,6 +1236,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&map_err_ignore::MAP_ERR_IGNORE),\n         LintId::of(&match_on_vec_items::MATCH_ON_VEC_ITEMS),\n         LintId::of(&matches::MATCH_BOOL),\n+        LintId::of(&matches::MATCH_SAME_ARMS),\n         LintId::of(&matches::MATCH_WILDCARD_FOR_SINGLE_VARIANTS),\n         LintId::of(&matches::MATCH_WILD_ERR_ARM),\n         LintId::of(&matches::SINGLE_MATCH_ELSE),\n@@ -1236,13 +1253,14 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&needless_pass_by_value::NEEDLESS_PASS_BY_VALUE),\n         LintId::of(&non_expressive_names::SIMILAR_NAMES),\n         LintId::of(&option_if_let_else::OPTION_IF_LET_ELSE),\n+        LintId::of(&pass_by_ref_or_value::LARGE_TYPES_PASSED_BY_VALUE),\n+        LintId::of(&pass_by_ref_or_value::TRIVIALLY_COPY_PASS_BY_REF),\n         LintId::of(&ranges::RANGE_MINUS_ONE),\n         LintId::of(&ranges::RANGE_PLUS_ONE),\n         LintId::of(&shadow::SHADOW_UNRELATED),\n         LintId::of(&strings::STRING_ADD_ASSIGN),\n         LintId::of(&trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS),\n         LintId::of(&trait_bounds::TYPE_REPETITION_IN_BOUNDS),\n-        LintId::of(&trivially_copy_pass_by_ref::TRIVIALLY_COPY_PASS_BY_REF),\n         LintId::of(&types::CAST_LOSSLESS),\n         LintId::of(&types::CAST_POSSIBLE_TRUNCATION),\n         LintId::of(&types::CAST_POSSIBLE_WRAP),\n@@ -1267,6 +1285,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&utils::internal_lints::COLLAPSIBLE_SPAN_LINT_CALLS),\n         LintId::of(&utils::internal_lints::COMPILER_LINT_FUNCTIONS),\n         LintId::of(&utils::internal_lints::DEFAULT_LINT),\n+        LintId::of(&utils::internal_lints::INVALID_PATHS),\n         LintId::of(&utils::internal_lints::LINT_WITHOUT_LINT_PASS),\n         LintId::of(&utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM),\n         LintId::of(&utils::internal_lints::OUTER_EXPN_EXPN_DATA),\n@@ -1286,6 +1305,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&attrs::MISMATCHED_TARGET_OS),\n         LintId::of(&attrs::UNKNOWN_CLIPPY_LINTS),\n         LintId::of(&attrs::USELESS_ATTRIBUTE),\n+        LintId::of(&await_holding_invalid::AWAIT_HOLDING_LOCK),\n+        LintId::of(&await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n         LintId::of(&bit_mask::BAD_BIT_MASK),\n         LintId::of(&bit_mask::INEFFECTIVE_BIT_MASK),\n         LintId::of(&blacklisted_name::BLACKLISTED_NAME),\n@@ -1351,6 +1372,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&lifetimes::NEEDLESS_LIFETIMES),\n         LintId::of(&literal_representation::INCONSISTENT_DIGIT_GROUPING),\n         LintId::of(&literal_representation::MISTYPED_LITERAL_SUFFIXES),\n+        LintId::of(&literal_representation::UNUSUAL_BYTE_GROUPINGS),\n         LintId::of(&loops::EMPTY_LOOP),\n         LintId::of(&loops::EXPLICIT_COUNTER_LOOP),\n         LintId::of(&loops::FOR_KV_MAP),\n@@ -1362,6 +1384,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::NEEDLESS_RANGE_LOOP),\n         LintId::of(&loops::NEVER_LOOP),\n         LintId::of(&loops::SAME_ITEM_PUSH),\n+        LintId::of(&loops::SINGLE_ELEMENT_LOOP),\n         LintId::of(&loops::WHILE_IMMUTABLE_CONDITION),\n         LintId::of(&loops::WHILE_LET_LOOP),\n         LintId::of(&loops::WHILE_LET_ON_ITERATOR),\n@@ -1439,6 +1462,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&misc_early::UNNEEDED_WILDCARD_PATTERN),\n         LintId::of(&misc_early::ZERO_PREFIXED_LITERAL),\n         LintId::of(&mut_key::MUTABLE_KEY_TYPE),\n+        LintId::of(&mut_mutex_lock::MUT_MUTEX_LOCK),\n         LintId::of(&mut_reference::UNNECESSARY_MUT_PASSED),\n         LintId::of(&mutex_atomic::MUTEX_ATOMIC),\n         LintId::of(&needless_arbitrary_self_type::NEEDLESS_ARBITRARY_SELF_TYPE),\n@@ -1467,6 +1491,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&ptr_eq::PTR_EQ),\n         LintId::of(&ptr_offset_with_cast::PTR_OFFSET_WITH_CAST),\n         LintId::of(&question_mark::QUESTION_MARK),\n+        LintId::of(&ranges::MANUAL_RANGE_CONTAINS),\n         LintId::of(&ranges::RANGE_ZIP_WITH_LEN),\n         LintId::of(&ranges::REVERSED_EMPTY_RANGES),\n         LintId::of(&redundant_clone::REDUNDANT_CLONE),\n@@ -1519,6 +1544,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&types::UNIT_CMP),\n         LintId::of(&types::UNNECESSARY_CAST),\n         LintId::of(&types::VEC_BOX),\n+        LintId::of(&undropped_manually_drops::UNDROPPED_MANUALLY_DROPS),\n         LintId::of(&unicode::INVISIBLE_CHARACTERS),\n         LintId::of(&unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD),\n         LintId::of(&unnamed_address::FN_ADDRESS_COMPARISONS),\n@@ -1568,6 +1594,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&len_zero::LEN_WITHOUT_IS_EMPTY),\n         LintId::of(&len_zero::LEN_ZERO),\n         LintId::of(&literal_representation::INCONSISTENT_DIGIT_GROUPING),\n+        LintId::of(&literal_representation::UNUSUAL_BYTE_GROUPINGS),\n         LintId::of(&loops::EMPTY_LOOP),\n         LintId::of(&loops::FOR_KV_MAP),\n         LintId::of(&loops::NEEDLESS_RANGE_LOOP),\n@@ -1610,6 +1637,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&misc_early::DUPLICATE_UNDERSCORE_ARGUMENT),\n         LintId::of(&misc_early::MIXED_CASE_HEX_LITERALS),\n         LintId::of(&misc_early::REDUNDANT_PATTERN),\n+        LintId::of(&mut_mutex_lock::MUT_MUTEX_LOCK),\n         LintId::of(&mut_reference::UNNECESSARY_MUT_PASSED),\n         LintId::of(&neg_multiply::NEG_MULTIPLY),\n         LintId::of(&new_without_default::NEW_WITHOUT_DEFAULT),\n@@ -1622,6 +1650,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&ptr::PTR_ARG),\n         LintId::of(&ptr_eq::PTR_EQ),\n         LintId::of(&question_mark::QUESTION_MARK),\n+        LintId::of(&ranges::MANUAL_RANGE_CONTAINS),\n         LintId::of(&redundant_field_names::REDUNDANT_FIELD_NAMES),\n         LintId::of(&redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES),\n         LintId::of(&regex::TRIVIAL_REGEX),\n@@ -1662,6 +1691,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&lifetimes::NEEDLESS_LIFETIMES),\n         LintId::of(&loops::EXPLICIT_COUNTER_LOOP),\n         LintId::of(&loops::MUT_RANGE_BOUND),\n+        LintId::of(&loops::SINGLE_ELEMENT_LOOP),\n         LintId::of(&loops::WHILE_LET_LOOP),\n         LintId::of(&manual_strip::MANUAL_STRIP),\n         LintId::of(&manual_unwrap_or::MANUAL_UNWRAP_OR),\n@@ -1731,6 +1761,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&attrs::DEPRECATED_SEMVER),\n         LintId::of(&attrs::MISMATCHED_TARGET_OS),\n         LintId::of(&attrs::USELESS_ATTRIBUTE),\n+        LintId::of(&await_holding_invalid::AWAIT_HOLDING_LOCK),\n+        LintId::of(&await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n         LintId::of(&bit_mask::BAD_BIT_MASK),\n         LintId::of(&bit_mask::INEFFECTIVE_BIT_MASK),\n         LintId::of(&booleans::LOGIC_BUG),\n@@ -1787,6 +1819,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&types::ABSURD_EXTREME_COMPARISONS),\n         LintId::of(&types::CAST_REF_TO_MUT),\n         LintId::of(&types::UNIT_CMP),\n+        LintId::of(&undropped_manually_drops::UNDROPPED_MANUALLY_DROPS),\n         LintId::of(&unicode::INVISIBLE_CHARACTERS),\n         LintId::of(&unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD),\n         LintId::of(&unnamed_address::FN_ADDRESS_COMPARISONS),"}, {"sha": "c8a5a9c9431352ab2d2f4f7cf09c07fa55677550", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -414,7 +414,7 @@ fn has_where_lifetimes<'tcx>(cx: &LateContext<'tcx>, where_clause: &'tcx WhereCl\n                 let mut visitor = RefVisitor::new(cx);\n                 // walk the type F, it may not contain LT refs\n                 walk_ty(&mut visitor, &pred.bounded_ty);\n-                if !visitor.lts.is_empty() {\n+                if !visitor.all_lts().is_empty() {\n                     return true;\n                 }\n                 // if the bounds define new lifetimes, they are fine to occur\n@@ -424,7 +424,9 @@ fn has_where_lifetimes<'tcx>(cx: &LateContext<'tcx>, where_clause: &'tcx WhereCl\n                     walk_param_bound(&mut visitor, bound);\n                 }\n                 // and check that all lifetimes are allowed\n-                return visitor.all_lts().iter().any(|it| !allowed_lts.contains(it));\n+                if visitor.all_lts().iter().any(|it| !allowed_lts.contains(it)) {\n+                    return true;\n+                }\n             },\n             WherePredicate::EqPredicate(ref pred) => {\n                 let mut visitor = RefVisitor::new(cx);"}, {"sha": "e8a741683dac12d7192a8e02562b3484e1599750", "filename": "src/tools/clippy/clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -82,6 +82,25 @@ declare_clippy_lint! {\n     \"integer literals with digits grouped inconsistently\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Warns if hexadecimal or binary literals are not grouped\n+    /// by nibble or byte.\n+    ///\n+    /// **Why is this bad?** Negatively impacts readability.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let x: u32 = 0xFFF_FFF;\n+    /// let y: u8 = 0b01_011_101;\n+    /// ```\n+    pub UNUSUAL_BYTE_GROUPINGS,\n+    style,\n+    \"binary or hex literals that aren't grouped by four\"\n+}\n+\n declare_clippy_lint! {\n     /// **What it does:** Warns if the digits of an integral or floating-point\n     /// constant are grouped into groups that\n@@ -125,6 +144,7 @@ enum WarningType {\n     LargeDigitGroups,\n     DecimalRepresentation,\n     MistypedLiteralSuffix,\n+    UnusualByteGroupings,\n }\n \n impl WarningType {\n@@ -175,6 +195,15 @@ impl WarningType {\n                 suggested_format,\n                 Applicability::MachineApplicable,\n             ),\n+            Self::UnusualByteGroupings => span_lint_and_sugg(\n+                cx,\n+                UNUSUAL_BYTE_GROUPINGS,\n+                span,\n+                \"digits of hex or binary literal not grouped by four\",\n+                \"consider\",\n+                suggested_format,\n+                Applicability::MachineApplicable,\n+            ),\n         };\n     }\n }\n@@ -184,6 +213,7 @@ declare_lint_pass!(LiteralDigitGrouping => [\n     INCONSISTENT_DIGIT_GROUPING,\n     LARGE_DIGIT_GROUPS,\n     MISTYPED_LITERAL_SUFFIXES,\n+    UNUSUAL_BYTE_GROUPINGS,\n ]);\n \n impl EarlyLintPass for LiteralDigitGrouping {\n@@ -217,9 +247,9 @@ impl LiteralDigitGrouping {\n \n                 let result = (|| {\n \n-                    let integral_group_size = Self::get_group_size(num_lit.integer.split('_'))?;\n+                    let integral_group_size = Self::get_group_size(num_lit.integer.split('_'), num_lit.radix)?;\n                     if let Some(fraction) = num_lit.fraction {\n-                        let fractional_group_size = Self::get_group_size(fraction.rsplit('_'))?;\n+                        let fractional_group_size = Self::get_group_size(fraction.rsplit('_'), num_lit.radix)?;\n \n                         let consistent = Self::parts_consistent(integral_group_size,\n                                                                 fractional_group_size,\n@@ -229,6 +259,7 @@ impl LiteralDigitGrouping {\n                             return Err(WarningType::InconsistentDigitGrouping);\n                         };\n                     }\n+\n                     Ok(())\n                 })();\n \n@@ -237,6 +268,7 @@ impl LiteralDigitGrouping {\n                     let should_warn = match warning_type {\n                         | WarningType::UnreadableLiteral\n                         | WarningType::InconsistentDigitGrouping\n+                        | WarningType::UnusualByteGroupings\n                         | WarningType::LargeDigitGroups => {\n                             !in_macro(lit.span)\n                         }\n@@ -331,11 +363,15 @@ impl LiteralDigitGrouping {\n \n     /// Returns the size of the digit groups (or None if ungrouped) if successful,\n     /// otherwise returns a `WarningType` for linting.\n-    fn get_group_size<'a>(groups: impl Iterator<Item = &'a str>) -> Result<Option<usize>, WarningType> {\n+    fn get_group_size<'a>(groups: impl Iterator<Item = &'a str>, radix: Radix) -> Result<Option<usize>, WarningType> {\n         let mut groups = groups.map(str::len);\n \n         let first = groups.next().expect(\"At least one group\");\n \n+        if (radix == Radix::Binary || radix == Radix::Hexadecimal) && groups.any(|i| i != 4 && i != 2) {\n+            return Err(WarningType::UnusualByteGroupings);\n+        }\n+\n         if let Some(second) = groups.next() {\n             if !groups.all(|x| x == second) || first > second {\n                 Err(WarningType::InconsistentDigitGrouping)"}, {"sha": "c3f75f283f498494b27fd76d1c71c56fdd5a4cd3", "filename": "src/tools/clippy/clippy_lints/src/loops.rs", "status": "modified", "additions": 100, "deletions": 12, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -4,9 +4,10 @@ use crate::utils::sugg::Sugg;\n use crate::utils::usage::{is_unused, mutated_variables};\n use crate::utils::{\n     contains_name, get_enclosing_block, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait,\n-    is_integer_const, is_no_std_crate, is_refutable, is_type_diagnostic_item, last_path_segment, match_trait_method,\n-    match_type, match_var, multispan_sugg, qpath_res, snippet, snippet_with_applicability, snippet_with_macro_callsite,\n-    span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, sugg, SpanlessEq,\n+    indent_of, is_integer_const, is_no_std_crate, is_refutable, is_type_diagnostic_item, last_path_segment,\n+    match_trait_method, match_type, match_var, multispan_sugg, qpath_res, single_segment_path, snippet,\n+    snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg,\n+    span_lint_and_then, sugg, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast::ast;\n@@ -293,9 +294,24 @@ declare_clippy_lint! {\n declare_clippy_lint! {\n     /// **What it does:** Checks for empty `loop` expressions.\n     ///\n-    /// **Why is this bad?** Those busy loops burn CPU cycles without doing\n-    /// anything. Think of the environment and either block on something or at least\n-    /// make the thread sleep for some microseconds.\n+    /// **Why is this bad?** These busy loops burn CPU cycles without doing\n+    /// anything. It is _almost always_ a better idea to `panic!` than to have\n+    /// a busy loop.\n+    ///\n+    /// If panicking isn't possible, think of the environment and either:\n+    ///   - block on something\n+    ///   - sleep the thread for some microseconds\n+    ///   - yield or pause the thread\n+    ///\n+    /// For `std` targets, this can be done with\n+    /// [`std::thread::sleep`](https://doc.rust-lang.org/std/thread/fn.sleep.html)\n+    /// or [`std::thread::yield_now`](https://doc.rust-lang.org/std/thread/fn.yield_now.html).\n+    ///\n+    /// For `no_std` targets, doing this is more complicated, especially because\n+    /// `#[panic_handler]`s can't panic. To stop/pause the thread, you will\n+    /// probably need to invoke some target-specific intrinsic. Examples include:\n+    ///   - [`x86_64::instructions::hlt`](https://docs.rs/x86_64/0.12.2/x86_64/instructions/fn.hlt.html)\n+    ///   - [`cortex_m::asm::wfi`](https://docs.rs/cortex-m/0.6.3/cortex_m/asm/fn.wfi.html)\n     ///\n     /// **Known problems:** None.\n     ///\n@@ -452,6 +468,31 @@ declare_clippy_lint! {\n     \"the same item is pushed inside of a for loop\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks whether a for loop has a single element.\n+    ///\n+    /// **Why is this bad?** There is no reason to have a loop of a\n+    /// single element.\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let item1 = 2;\n+    /// for item in &[item1] {\n+    ///     println!(\"{}\", item);\n+    /// }\n+    /// ```\n+    /// could be written as\n+    /// ```rust\n+    /// let item1 = 2;\n+    /// let item = &item1;\n+    /// println!(\"{}\", item);\n+    /// ```\n+    pub SINGLE_ELEMENT_LOOP,\n+    complexity,\n+    \"there is no reason to have a single element loop\"\n+}\n+\n declare_lint_pass!(Loops => [\n     MANUAL_MEMCPY,\n     NEEDLESS_RANGE_LOOP,\n@@ -469,6 +510,7 @@ declare_lint_pass!(Loops => [\n     MUT_RANGE_BOUND,\n     WHILE_IMMUTABLE_CONDITION,\n     SAME_ITEM_PUSH,\n+    SINGLE_ELEMENT_LOOP,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Loops {\n@@ -502,13 +544,15 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n         // (even if the \"match\" or \"if let\" is used for declaration)\n         if let ExprKind::Loop(ref block, _, LoopSource::Loop) = expr.kind {\n             // also check for empty `loop {}` statements\n+            // TODO(issue #6161): Enable for no_std crates (outside of #[panic_handler])\n             if block.stmts.is_empty() && block.expr.is_none() && !is_no_std_crate(cx.tcx.hir().krate()) {\n-                span_lint(\n+                span_lint_and_help(\n                     cx,\n                     EMPTY_LOOP,\n                     expr.span,\n-                    \"empty `loop {}` detected. You may want to either use `panic!()` or add \\\n-                     `std::thread::sleep(..);` to the loop body.\",\n+                    \"empty `loop {}` wastes CPU cycles\",\n+                    None,\n+                    \"You should either use `panic!()` or add `std::thread::sleep(..);` to the loop body.\",\n                 );\n             }\n \n@@ -777,6 +821,7 @@ fn check_for_loop<'tcx>(\n     check_for_loop_arg(cx, pat, arg, expr);\n     check_for_loop_over_map_kv(cx, pat, arg, body, expr);\n     check_for_mut_range_bound(cx, arg, body);\n+    check_for_single_element_loop(cx, pat, arg, body, expr);\n     detect_same_item_push(cx, pat, arg, body, expr);\n }\n \n@@ -1866,6 +1911,43 @@ fn check_for_loop_over_map_kv<'tcx>(\n     }\n }\n \n+fn check_for_single_element_loop<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n+) {\n+    if_chain! {\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref arg_expr) = arg.kind;\n+        if let PatKind::Binding(.., target, _) = pat.kind;\n+        if let ExprKind::Array(ref arg_expr_list) = arg_expr.kind;\n+        if let [arg_expression] = arg_expr_list;\n+        if let ExprKind::Path(ref list_item) = arg_expression.kind;\n+        if let Some(list_item_name) = single_segment_path(list_item).map(|ps| ps.ident.name);\n+        if let ExprKind::Block(ref block, _) = body.kind;\n+        if !block.stmts.is_empty();\n+\n+        then {\n+            let for_span = get_span_of_entire_for_loop(expr);\n+            let mut block_str = snippet(cx, block.span, \"..\").into_owned();\n+            block_str.remove(0);\n+            block_str.pop();\n+\n+\n+            span_lint_and_sugg(\n+                cx,\n+                SINGLE_ELEMENT_LOOP,\n+                for_span,\n+                \"for loop over a single element\",\n+                \"try\",\n+                format!(\"{{\\n{}let {} = &{};{}}}\", \" \".repeat(indent_of(cx, block.stmts[0].span).unwrap_or(0)), target.name, list_item_name, block_str),\n+                Applicability::MachineApplicable\n+            )\n+        }\n+    }\n+}\n+\n struct MutatePairDelegate<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     hir_id_low: Option<HirId>,\n@@ -1969,12 +2051,11 @@ fn check_for_mutation<'tcx>(\n         span_low: None,\n         span_high: None,\n     };\n-    let def_id = body.hir_id.owner.to_def_id();\n     cx.tcx.infer_ctxt().enter(|infcx| {\n         ExprUseVisitor::new(\n             &mut delegate,\n             &infcx,\n-            def_id.expect_local(),\n+            body.hir_id.owner,\n             cx.param_env,\n             cx.typeck_results(),\n         )\n@@ -2920,7 +3001,14 @@ impl IterFunction {\n             IterFunctionKind::IntoIter => String::new(),\n             IterFunctionKind::Len => String::from(\".count()\"),\n             IterFunctionKind::IsEmpty => String::from(\".next().is_none()\"),\n-            IterFunctionKind::Contains(span) => format!(\".any(|x| x == {})\", snippet(cx, *span, \"..\")),\n+            IterFunctionKind::Contains(span) => {\n+                let s = snippet(cx, *span, \"..\");\n+                if let Some(stripped) = s.strip_prefix('&') {\n+                    format!(\".any(|x| x == {})\", stripped)\n+                } else {\n+                    format!(\".any(|x| x == *{})\", s)\n+                }\n+            },\n         }\n     }\n     fn get_suggestion_text(&self) -> &'static str {"}, {"sha": "22aa37e41fec0e4124b7b3ba316c4bfc91e777f9", "filename": "src/tools/clippy/clippy_lints/src/manual_unwrap_or.rs", "status": "modified", "additions": 52, "deletions": 28, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_unwrap_or.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1,16 +1,17 @@\n use crate::consts::constant_simple;\n use crate::utils;\n+use crate::utils::sugg;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{def, Arm, Expr, ExprKind, PatKind, QPath};\n+use rustc_hir::{def, Arm, Expr, ExprKind, Pat, PatKind, QPath};\n use rustc_lint::LintContext;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n     /// **What it does:**\n-    /// Finds patterns that reimplement `Option::unwrap_or`.\n+    /// Finds patterns that reimplement `Option::unwrap_or` or `Result::unwrap_or`.\n     ///\n     /// **Why is this bad?**\n     /// Concise code helps focusing on behavior instead of boilerplate.\n@@ -33,7 +34,7 @@ declare_clippy_lint! {\n     /// ```\n     pub MANUAL_UNWRAP_OR,\n     complexity,\n-    \"finds patterns that can be encoded more concisely with `Option::unwrap_or`\"\n+    \"finds patterns that can be encoded more concisely with `Option::unwrap_or` or `Result::unwrap_or`\"\n }\n \n declare_lint_pass!(ManualUnwrapOr => [MANUAL_UNWRAP_OR]);\n@@ -43,32 +44,50 @@ impl LateLintPass<'_> for ManualUnwrapOr {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n-        lint_option_unwrap_or_case(cx, expr);\n+        lint_manual_unwrap_or(cx, expr);\n     }\n }\n \n-fn lint_option_unwrap_or_case<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-    fn applicable_none_arm<'a>(arms: &'a [Arm<'a>]) -> Option<&'a Arm<'a>> {\n+#[derive(Copy, Clone)]\n+enum Case {\n+    Option,\n+    Result,\n+}\n+\n+impl Case {\n+    fn unwrap_fn_path(&self) -> &str {\n+        match self {\n+            Case::Option => \"Option::unwrap_or\",\n+            Case::Result => \"Result::unwrap_or\",\n+        }\n+    }\n+}\n+\n+fn lint_manual_unwrap_or<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n+    fn applicable_or_arm<'a>(arms: &'a [Arm<'a>]) -> Option<&'a Arm<'a>> {\n         if_chain! {\n             if arms.len() == 2;\n             if arms.iter().all(|arm| arm.guard.is_none());\n-            if let Some((idx, none_arm)) = arms.iter().enumerate().find(|(_, arm)|\n-                if let PatKind::Path(ref qpath) = arm.pat.kind {\n-                    utils::match_qpath(qpath, &utils::paths::OPTION_NONE)\n-                } else {\n-                    false\n+            if let Some((idx, or_arm)) = arms.iter().enumerate().find(|(_, arm)|\n+                match arm.pat.kind {\n+                    PatKind::Path(ref some_qpath) =>\n+                        utils::match_qpath(some_qpath, &utils::paths::OPTION_NONE),\n+                    PatKind::TupleStruct(ref err_qpath, &[Pat { kind: PatKind::Wild, .. }], _) =>\n+                        utils::match_qpath(err_qpath, &utils::paths::RESULT_ERR),\n+                    _ => false,\n                 }\n             );\n-            let some_arm = &arms[1 - idx];\n-            if let PatKind::TupleStruct(ref some_qpath, &[some_binding], _) = some_arm.pat.kind;\n-            if utils::match_qpath(some_qpath, &utils::paths::OPTION_SOME);\n-            if let PatKind::Binding(_, binding_hir_id, ..) = some_binding.kind;\n-            if let ExprKind::Path(QPath::Resolved(_, body_path)) = some_arm.body.kind;\n+            let unwrap_arm = &arms[1 - idx];\n+            if let PatKind::TupleStruct(ref unwrap_qpath, &[unwrap_pat], _) = unwrap_arm.pat.kind;\n+            if utils::match_qpath(unwrap_qpath, &utils::paths::OPTION_SOME)\n+                || utils::match_qpath(unwrap_qpath, &utils::paths::RESULT_OK);\n+            if let PatKind::Binding(_, binding_hir_id, ..) = unwrap_pat.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, body_path)) = unwrap_arm.body.kind;\n             if let def::Res::Local(body_path_hir_id) = body_path.res;\n             if body_path_hir_id == binding_hir_id;\n-            if !utils::usage::contains_return_break_continue_macro(none_arm.body);\n+            if !utils::usage::contains_return_break_continue_macro(or_arm.body);\n             then {\n-                Some(none_arm)\n+                Some(or_arm)\n             } else {\n                 None\n             }\n@@ -78,24 +97,29 @@ fn lint_option_unwrap_or_case<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tc\n     if_chain! {\n         if let ExprKind::Match(scrutinee, match_arms, _) = expr.kind;\n         let ty = cx.typeck_results().expr_ty(scrutinee);\n-        if utils::is_type_diagnostic_item(cx, ty, sym!(option_type));\n-        if let Some(none_arm) = applicable_none_arm(match_arms);\n-        if let Some(scrutinee_snippet) = utils::snippet_opt(cx, scrutinee.span);\n-        if let Some(none_body_snippet) = utils::snippet_opt(cx, none_arm.body.span);\n+        if let Some(case) = if utils::is_type_diagnostic_item(cx, ty, sym!(option_type)) {\n+            Some(Case::Option)\n+        } else if utils::is_type_diagnostic_item(cx, ty, sym!(result_type)) {\n+            Some(Case::Result)\n+        } else {\n+            None\n+        };\n+        if let Some(or_arm) = applicable_or_arm(match_arms);\n+        if let Some(or_body_snippet) = utils::snippet_opt(cx, or_arm.body.span);\n         if let Some(indent) = utils::indent_of(cx, expr.span);\n-        if constant_simple(cx, cx.typeck_results(), none_arm.body).is_some();\n+        if constant_simple(cx, cx.typeck_results(), or_arm.body).is_some();\n         then {\n-            let reindented_none_body =\n-                utils::reindent_multiline(none_body_snippet.into(), true, Some(indent));\n+            let reindented_or_body =\n+                utils::reindent_multiline(or_body_snippet.into(), true, Some(indent));\n             utils::span_lint_and_sugg(\n                 cx,\n                 MANUAL_UNWRAP_OR, expr.span,\n-                \"this pattern reimplements `Option::unwrap_or`\",\n+                &format!(\"this pattern reimplements `{}`\", case.unwrap_fn_path()),\n                 \"replace with\",\n                 format!(\n                     \"{}.unwrap_or({})\",\n-                    scrutinee_snippet,\n-                    reindented_none_body,\n+                    sugg::Sugg::hir(cx, scrutinee, \"..\").maybe_par(),\n+                    reindented_or_body,\n                 ),\n                 Applicability::MachineApplicable,\n             );"}, {"sha": "4bdfca1a2921d8e16c8f0571a0f965714fdfe508", "filename": "src/tools/clippy/clippy_lints/src/matches.rs", "status": "modified", "additions": 199, "deletions": 20, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1,5 +1,4 @@\n use crate::consts::{constant, miri_to_const, Constant};\n-use crate::utils::paths;\n use crate::utils::sugg::Sugg;\n use crate::utils::usage::is_unused;\n use crate::utils::{\n@@ -8,8 +7,10 @@ use crate::utils::{\n     snippet_block, snippet_with_applicability, span_lint_and_help, span_lint_and_note, span_lint_and_sugg,\n     span_lint_and_then,\n };\n+use crate::utils::{paths, search_same, SpanlessEq, SpanlessHash};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n use rustc_hir::def::CtorKind;\n use rustc_hir::{\n@@ -18,10 +19,12 @@ use rustc_hir::{\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, Ty, TyS};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n+use rustc_span::Symbol;\n use std::cmp::Ordering;\n+use std::collections::hash_map::Entry;\n use std::collections::Bound;\n \n declare_clippy_lint! {\n@@ -36,7 +39,6 @@ declare_clippy_lint! {\n     /// ```rust\n     /// # fn bar(stool: &str) {}\n     /// # let x = Some(\"abc\");\n-    ///\n     /// // Bad\n     /// match x {\n     ///     Some(ref foo) => bar(foo),\n@@ -239,7 +241,6 @@ declare_clippy_lint! {\n     /// ```rust\n     /// # enum Foo { A(usize), B(usize) }\n     /// # let x = Foo::B(1);\n-    ///\n     /// // Bad\n     /// match x {\n     ///     Foo::A(_) => {},\n@@ -477,6 +478,47 @@ declare_clippy_lint! {\n     \"a match that could be written with the matches! macro\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `match` with identical arm bodies.\n+    ///\n+    /// **Why is this bad?** This is probably a copy & paste error. If arm bodies\n+    /// are the same on purpose, you can factor them\n+    /// [using `|`](https://doc.rust-lang.org/book/patterns.html#multiple-patterns).\n+    ///\n+    /// **Known problems:** False positive possible with order dependent `match`\n+    /// (see issue\n+    /// [#860](https://github.com/rust-lang/rust-clippy/issues/860)).\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// match foo {\n+    ///     Bar => bar(),\n+    ///     Quz => quz(),\n+    ///     Baz => bar(), // <= oops\n+    /// }\n+    /// ```\n+    ///\n+    /// This should probably be\n+    /// ```rust,ignore\n+    /// match foo {\n+    ///     Bar => bar(),\n+    ///     Quz => quz(),\n+    ///     Baz => baz(), // <= fixed\n+    /// }\n+    /// ```\n+    ///\n+    /// or if the original code was not a typo:\n+    /// ```rust,ignore\n+    /// match foo {\n+    ///     Bar | Baz => bar(), // <= shows the intent better\n+    ///     Quz => quz(),\n+    /// }\n+    /// ```\n+    pub MATCH_SAME_ARMS,\n+    pedantic,\n+    \"`match` with identical arm bodies\"\n+}\n+\n #[derive(Default)]\n pub struct Matches {\n     infallible_destructuring_match_linted: bool,\n@@ -497,7 +539,8 @@ impl_lint_pass!(Matches => [\n     INFALLIBLE_DESTRUCTURING_MATCH,\n     REST_PAT_IN_FULLY_BOUND_STRUCTS,\n     REDUNDANT_PATTERN_MATCHING,\n-    MATCH_LIKE_MATCHES_MACRO\n+    MATCH_LIKE_MATCHES_MACRO,\n+    MATCH_SAME_ARMS,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Matches {\n@@ -507,7 +550,9 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n         }\n \n         redundant_pattern_match::check(cx, expr);\n-        check_match_like_matches(cx, expr);\n+        if !check_match_like_matches(cx, expr) {\n+            lint_match_arms(cx, expr);\n+        }\n \n         if let ExprKind::Match(ref ex, ref arms, MatchSource::Normal) = expr.kind {\n             check_single_match(cx, ex, arms, expr);\n@@ -1065,32 +1110,47 @@ fn check_wild_in_or_pats(cx: &LateContext<'_>, arms: &[Arm<'_>]) {\n }\n \n /// Lint a `match` or `if let .. { .. } else { .. }` expr that could be replaced by `matches!`\n-fn check_match_like_matches<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+fn check_match_like_matches<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n     if let ExprKind::Match(ex, arms, ref match_source) = &expr.kind {\n         match match_source {\n             MatchSource::Normal => find_matches_sugg(cx, ex, arms, expr, false),\n             MatchSource::IfLetDesugar { .. } => find_matches_sugg(cx, ex, arms, expr, true),\n-            _ => return,\n+            _ => false,\n         }\n+    } else {\n+        false\n     }\n }\n \n /// Lint a `match` or desugared `if let` for replacement by `matches!`\n-fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>, desugared: bool) {\n+fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>, desugared: bool) -> bool {\n     if_chain! {\n-        if arms.len() == 2;\n+        if arms.len() >= 2;\n         if cx.typeck_results().expr_ty(expr).is_bool();\n-        if is_wild(&arms[1].pat);\n-        if let Some(first) = find_bool_lit(&arms[0].body.kind, desugared);\n-        if let Some(second) = find_bool_lit(&arms[1].body.kind, desugared);\n-        if first != second;\n+        if let Some((b1_arm, b0_arms)) = arms.split_last();\n+        if let Some(b0) = find_bool_lit(&b0_arms[0].body.kind, desugared);\n+        if let Some(b1) = find_bool_lit(&b1_arm.body.kind, desugared);\n+        if is_wild(&b1_arm.pat);\n+        if b0 != b1;\n+        let if_guard = &b0_arms[0].guard;\n+        if if_guard.is_none() || b0_arms.len() == 1;\n+        if b0_arms[1..].iter()\n+            .all(|arm| {\n+                find_bool_lit(&arm.body.kind, desugared).map_or(false, |b| b == b0) &&\n+                arm.guard.is_none()\n+            });\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n-\n-            let pat_and_guard = if let Some(Guard::If(g)) = arms[0].guard {\n-                format!(\"{} if {}\", snippet_with_applicability(cx, arms[0].pat.span, \"..\", &mut applicability), snippet_with_applicability(cx, g.span, \"..\", &mut applicability))\n+            let pat = {\n+                use itertools::Itertools as _;\n+                b0_arms.iter()\n+                    .map(|arm| snippet_with_applicability(cx, arm.pat.span, \"..\", &mut applicability))\n+                    .join(\" | \")\n+            };\n+            let pat_and_guard = if let Some(Guard::If(g)) = if_guard {\n+                format!(\"{} if {}\", pat, snippet_with_applicability(cx, g.span, \"..\", &mut applicability))\n             } else {\n-                format!(\"{}\", snippet_with_applicability(cx, arms[0].pat.span, \"..\", &mut applicability))\n+                pat\n             };\n             span_lint_and_sugg(\n                 cx,\n@@ -1100,12 +1160,15 @@ fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr\n                 \"try this\",\n                 format!(\n                     \"{}matches!({}, {})\",\n-                    if first { \"\" } else { \"!\" },\n+                    if b0 { \"\" } else { \"!\" },\n                     snippet_with_applicability(cx, ex.span, \"..\", &mut applicability),\n                     pat_and_guard,\n                 ),\n                 applicability,\n-            )\n+            );\n+            true\n+        } else {\n+            false\n         }\n     }\n }\n@@ -1659,3 +1722,119 @@ fn test_overlapping() {\n         ],)\n     );\n }\n+\n+/// Implementation of `MATCH_SAME_ARMS`.\n+fn lint_match_arms<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n+    fn same_bindings<'tcx>(lhs: &FxHashMap<Symbol, Ty<'tcx>>, rhs: &FxHashMap<Symbol, Ty<'tcx>>) -> bool {\n+        lhs.len() == rhs.len()\n+            && lhs\n+                .iter()\n+                .all(|(name, l_ty)| rhs.get(name).map_or(false, |r_ty| TyS::same_type(l_ty, r_ty)))\n+    }\n+\n+    if let ExprKind::Match(_, ref arms, MatchSource::Normal) = expr.kind {\n+        let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n+            let mut h = SpanlessHash::new(cx);\n+            h.hash_expr(&arm.body);\n+            h.finish()\n+        };\n+\n+        let eq = |&(lindex, lhs): &(usize, &Arm<'_>), &(rindex, rhs): &(usize, &Arm<'_>)| -> bool {\n+            let min_index = usize::min(lindex, rindex);\n+            let max_index = usize::max(lindex, rindex);\n+\n+            // Arms with a guard are ignored, those can\u2019t always be merged together\n+            // This is also the case for arms in-between each there is an arm with a guard\n+            (min_index..=max_index).all(|index| arms[index].guard.is_none()) &&\n+                SpanlessEq::new(cx).eq_expr(&lhs.body, &rhs.body) &&\n+                // all patterns should have the same bindings\n+                same_bindings(&bindings(cx, &lhs.pat), &bindings(cx, &rhs.pat))\n+        };\n+\n+        let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n+        for (&(_, i), &(_, j)) in search_same(&indexed_arms, hash, eq) {\n+            span_lint_and_then(\n+                cx,\n+                MATCH_SAME_ARMS,\n+                j.body.span,\n+                \"this `match` has identical arm bodies\",\n+                |diag| {\n+                    diag.span_note(i.body.span, \"same as this\");\n+\n+                    // Note: this does not use `span_suggestion` on purpose:\n+                    // there is no clean way\n+                    // to remove the other arm. Building a span and suggest to replace it to \"\"\n+                    // makes an even more confusing error message. Also in order not to make up a\n+                    // span for the whole pattern, the suggestion is only shown when there is only\n+                    // one pattern. The user should know about `|` if they are already using it\u2026\n+\n+                    let lhs = snippet(cx, i.pat.span, \"<pat1>\");\n+                    let rhs = snippet(cx, j.pat.span, \"<pat2>\");\n+\n+                    if let PatKind::Wild = j.pat.kind {\n+                        // if the last arm is _, then i could be integrated into _\n+                        // note that i.pat cannot be _, because that would mean that we're\n+                        // hiding all the subsequent arms, and rust won't compile\n+                        diag.span_note(\n+                            i.body.span,\n+                            &format!(\n+                                \"`{}` has the same arm body as the `_` wildcard, consider removing it\",\n+                                lhs\n+                            ),\n+                        );\n+                    } else {\n+                        diag.span_help(i.pat.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs));\n+                    }\n+                },\n+            );\n+        }\n+    }\n+}\n+\n+/// Returns the list of bindings in a pattern.\n+fn bindings<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>) -> FxHashMap<Symbol, Ty<'tcx>> {\n+    fn bindings_impl<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>, map: &mut FxHashMap<Symbol, Ty<'tcx>>) {\n+        match pat.kind {\n+            PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => bindings_impl(cx, pat, map),\n+            PatKind::TupleStruct(_, pats, _) => {\n+                for pat in pats {\n+                    bindings_impl(cx, pat, map);\n+                }\n+            },\n+            PatKind::Binding(.., ident, ref as_pat) => {\n+                if let Entry::Vacant(v) = map.entry(ident.name) {\n+                    v.insert(cx.typeck_results().pat_ty(pat));\n+                }\n+                if let Some(ref as_pat) = *as_pat {\n+                    bindings_impl(cx, as_pat, map);\n+                }\n+            },\n+            PatKind::Or(fields) | PatKind::Tuple(fields, _) => {\n+                for pat in fields {\n+                    bindings_impl(cx, pat, map);\n+                }\n+            },\n+            PatKind::Struct(_, fields, _) => {\n+                for pat in fields {\n+                    bindings_impl(cx, &pat.pat, map);\n+                }\n+            },\n+            PatKind::Slice(lhs, ref mid, rhs) => {\n+                for pat in lhs {\n+                    bindings_impl(cx, pat, map);\n+                }\n+                if let Some(ref mid) = *mid {\n+                    bindings_impl(cx, mid, map);\n+                }\n+                for pat in rhs {\n+                    bindings_impl(cx, pat, map);\n+                }\n+            },\n+            PatKind::Lit(..) | PatKind::Range(..) | PatKind::Wild | PatKind::Path(..) => (),\n+        }\n+    }\n+\n+    let mut result = FxHashMap::default();\n+    bindings_impl(cx, pat, &mut result);\n+    result\n+}"}, {"sha": "5bc45c87874b46576a6cd07b4a68ef989c91cf8c", "filename": "src/tools/clippy/clippy_lints/src/misc_early.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -231,7 +231,6 @@ declare_clippy_lint! {\n     /// ```rust\n     /// # struct TupleStruct(u32, u32, u32);\n     /// # let t = TupleStruct(1, 2, 3);\n-    ///\n     /// // Bad\n     /// match t {\n     ///     TupleStruct(0, .., _) => (),"}, {"sha": "df1cecb328cb151698aff17b375176e714e3619c", "filename": "src/tools/clippy/clippy_lints/src/mut_mutex_lock.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mutex_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mutex_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mutex_lock.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -0,0 +1,68 @@\n+use crate::utils::{is_type_diagnostic_item, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, Mutability};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `&mut Mutex::lock` calls\n+    ///\n+    /// **Why is this bad?** `Mutex::lock` is less efficient than\n+    /// calling `Mutex::get_mut`. In addition you also have a statically\n+    /// guarantee that the mutex isn't locked, instead of just a runtime\n+    /// guarantee.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// use std::sync::{Arc, Mutex};\n+    ///\n+    /// let mut value_rc = Arc::new(Mutex::new(42_u8));\n+    /// let value_mutex = Arc::get_mut(&mut value_rc).unwrap();\n+    ///\n+    /// let mut value = value_mutex.lock().unwrap();\n+    /// *value += 1;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::sync::{Arc, Mutex};\n+    ///\n+    /// let mut value_rc = Arc::new(Mutex::new(42_u8));\n+    /// let value_mutex = Arc::get_mut(&mut value_rc).unwrap();\n+    ///\n+    /// let value = value_mutex.get_mut().unwrap();\n+    /// *value += 1;\n+    /// ```\n+    pub MUT_MUTEX_LOCK,\n+    style,\n+    \"`&mut Mutex::lock` does unnecessary locking\"\n+}\n+\n+declare_lint_pass!(MutMutexLock => [MUT_MUTEX_LOCK]);\n+\n+impl<'tcx> LateLintPass<'tcx> for MutMutexLock {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, ex: &'tcx Expr<'tcx>) {\n+        if_chain! {\n+            if let ExprKind::MethodCall(path, method_span, args, _) = &ex.kind;\n+            if path.ident.name == sym!(lock);\n+            let ty = cx.typeck_results().expr_ty(&args[0]);\n+            if let ty::Ref(_, inner_ty, Mutability::Mut) = ty.kind();\n+            if is_type_diagnostic_item(cx, inner_ty, sym!(mutex_type));\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    MUT_MUTEX_LOCK,\n+                    *method_span,\n+                    \"calling `&mut Mutex::lock` unnecessarily locks an exclusive (mutable) reference\",\n+                    \"change this to\",\n+                    \"get_mut\".to_owned(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "a799a644e970e1d3bce83435db28f6576bba5115", "filename": "src/tools/clippy/clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -3,7 +3,9 @@\n //! This lint is **warn** by default\n \n use crate::utils::sugg::Sugg;\n-use crate::utils::{higher, parent_node_is_if_expr, snippet_with_applicability, span_lint, span_lint_and_sugg};\n+use crate::utils::{\n+    higher, is_expn_of, parent_node_is_if_expr, snippet_with_applicability, span_lint, span_lint_and_sugg,\n+};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n@@ -233,6 +235,9 @@ fn check_comparison<'a, 'tcx>(\n             cx.typeck_results().expr_ty(left_side),\n             cx.typeck_results().expr_ty(right_side),\n         );\n+        if is_expn_of(left_side.span, \"cfg\").is_some() || is_expn_of(right_side.span, \"cfg\").is_some() {\n+            return;\n+        }\n         if l_ty.is_bool() && r_ty.is_bool() {\n             let mut applicability = Applicability::MachineApplicable;\n \n@@ -295,7 +300,14 @@ fn suggest_bool_comparison<'a, 'tcx>(\n     message: &str,\n     conv_hint: impl FnOnce(Sugg<'a>) -> Sugg<'a>,\n ) {\n-    let hint = Sugg::hir_with_applicability(cx, expr, \"..\", &mut applicability);\n+    let hint = if expr.span.from_expansion() {\n+        if applicability != Applicability::Unspecified {\n+            applicability = Applicability::MaybeIncorrect;\n+        }\n+        Sugg::hir_with_macro_callsite(cx, expr, \"..\")\n+    } else {\n+        Sugg::hir_with_applicability(cx, expr, \"..\", &mut applicability)\n+    };\n     span_lint_and_sugg(\n         cx,\n         BOOL_COMPARISON,"}, {"sha": "28816c3076ddf5f38f3639e19cf563d01adc59e5", "filename": "src/tools/clippy/clippy_lints/src/pass_by_ref_or_value.rs", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -0,0 +1,256 @@\n+use std::cmp;\n+\n+use crate::utils::{is_copy, is_self_ty, snippet, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_ast::attr;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::FnKind;\n+use rustc_hir::{BindingAnnotation, Body, FnDecl, HirId, ItemKind, MutTy, Mutability, Node, PatKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::Span;\n+use rustc_target::abi::LayoutOf;\n+use rustc_target::spec::abi::Abi;\n+use rustc_target::spec::Target;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for functions taking arguments by reference, where\n+    /// the argument type is `Copy` and small enough to be more efficient to always\n+    /// pass by value.\n+    ///\n+    /// **Why is this bad?** In many calling conventions instances of structs will\n+    /// be passed through registers if they fit into two or less general purpose\n+    /// registers.\n+    ///\n+    /// **Known problems:** This lint is target register size dependent, it is\n+    /// limited to 32-bit to try and reduce portability problems between 32 and\n+    /// 64-bit, but if you are compiling for 8 or 16-bit targets then the limit\n+    /// will be different.\n+    ///\n+    /// The configuration option `trivial_copy_size_limit` can be set to override\n+    /// this limit for a project.\n+    ///\n+    /// This lint attempts to allow passing arguments by reference if a reference\n+    /// to that argument is returned. This is implemented by comparing the lifetime\n+    /// of the argument and return value for equality. However, this can cause\n+    /// false positives in cases involving multiple lifetimes that are bounded by\n+    /// each other.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// // Bad\n+    /// fn foo(v: &u32) {}\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// // Better\n+    /// fn foo(v: u32) {}\n+    /// ```\n+    pub TRIVIALLY_COPY_PASS_BY_REF,\n+    pedantic,\n+    \"functions taking small copyable arguments by reference\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for functions taking arguments by value, where\n+    /// the argument type is `Copy` and large enough to be worth considering\n+    /// passing by reference. Does not trigger if the function is being exported,\n+    /// because that might induce API breakage, if the parameter is declared as mutable,\n+    /// or if the argument is a `self`.\n+    ///\n+    /// **Why is this bad?** Arguments passed by value might result in an unnecessary\n+    /// shallow copy, taking up more space in the stack and requiring a call to\n+    /// `memcpy`, which which can be expensive.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// #[derive(Clone, Copy)]\n+    /// struct TooLarge([u8; 2048]);\n+    ///\n+    /// // Bad\n+    /// fn foo(v: TooLarge) {}\n+    /// ```\n+    /// ```rust\n+    /// #[derive(Clone, Copy)]\n+    /// struct TooLarge([u8; 2048]);\n+    ///\n+    /// // Good\n+    /// fn foo(v: &TooLarge) {}\n+    /// ```\n+    pub LARGE_TYPES_PASSED_BY_VALUE,\n+    pedantic,\n+    \"functions taking large arguments by value\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct PassByRefOrValue {\n+    ref_min_size: u64,\n+    value_max_size: u64,\n+}\n+\n+impl<'tcx> PassByRefOrValue {\n+    pub fn new(ref_min_size: Option<u64>, value_max_size: u64, target: &Target) -> Self {\n+        let ref_min_size = ref_min_size.unwrap_or_else(|| {\n+            let bit_width = u64::from(target.pointer_width);\n+            // Cap the calculated bit width at 32-bits to reduce\n+            // portability problems between 32 and 64-bit targets\n+            let bit_width = cmp::min(bit_width, 32);\n+            #[allow(clippy::integer_division)]\n+            let byte_width = bit_width / 8;\n+            // Use a limit of 2 times the register byte width\n+            byte_width * 2\n+        });\n+\n+        Self {\n+            ref_min_size,\n+            value_max_size,\n+        }\n+    }\n+\n+    fn check_poly_fn(&mut self, cx: &LateContext<'tcx>, hir_id: HirId, decl: &FnDecl<'_>, span: Option<Span>) {\n+        let fn_def_id = cx.tcx.hir().local_def_id(hir_id);\n+\n+        let fn_sig = cx.tcx.fn_sig(fn_def_id);\n+        let fn_sig = cx.tcx.erase_late_bound_regions(&fn_sig);\n+\n+        let fn_body = cx.enclosing_body.map(|id| cx.tcx.hir().body(id));\n+\n+        for (index, (input, &ty)) in decl.inputs.iter().zip(fn_sig.inputs()).enumerate() {\n+            // All spans generated from a proc-macro invocation are the same...\n+            match span {\n+                Some(s) if s == input.span => return,\n+                _ => (),\n+            }\n+\n+            match ty.kind() {\n+                ty::Ref(input_lt, ty, Mutability::Not) => {\n+                    // Use lifetimes to determine if we're returning a reference to the\n+                    // argument. In that case we can't switch to pass-by-value as the\n+                    // argument will not live long enough.\n+                    let output_lts = match *fn_sig.output().kind() {\n+                        ty::Ref(output_lt, _, _) => vec![output_lt],\n+                        ty::Adt(_, substs) => substs.regions().collect(),\n+                        _ => vec![],\n+                    };\n+\n+                    if_chain! {\n+                        if !output_lts.contains(&input_lt);\n+                        if is_copy(cx, ty);\n+                        if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());\n+                        if size <= self.ref_min_size;\n+                        if let hir::TyKind::Rptr(_, MutTy { ty: ref decl_ty, .. }) = input.kind;\n+                        then {\n+                            let value_type = if is_self_ty(decl_ty) {\n+                                \"self\".into()\n+                            } else {\n+                                snippet(cx, decl_ty.span, \"_\").into()\n+                            };\n+                            span_lint_and_sugg(\n+                                cx,\n+                                TRIVIALLY_COPY_PASS_BY_REF,\n+                                input.span,\n+                                &format!(\"this argument ({} byte) is passed by reference, but would be more efficient if passed by value (limit: {} byte)\", size, self.ref_min_size),\n+                                \"consider passing by value instead\",\n+                                value_type,\n+                                Applicability::Unspecified,\n+                            );\n+                        }\n+                    }\n+                },\n+\n+                ty::Adt(_, _) | ty::Array(_, _) | ty::Tuple(_) => {\n+                    // if function has a body and parameter is annotated with mut, ignore\n+                    if let Some(param) = fn_body.and_then(|body| body.params.get(index)) {\n+                        match param.pat.kind {\n+                            PatKind::Binding(BindingAnnotation::Unannotated, _, _, _) => {},\n+                            _ => continue,\n+                        }\n+                    }\n+\n+                    if_chain! {\n+                        if !cx.access_levels.is_exported(hir_id);\n+                        if is_copy(cx, ty);\n+                        if !is_self_ty(input);\n+                        if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());\n+                        if size > self.value_max_size;\n+                        then {\n+                            span_lint_and_sugg(\n+                                cx,\n+                                LARGE_TYPES_PASSED_BY_VALUE,\n+                                input.span,\n+                                &format!(\"this argument ({} byte) is passed by value, but might be more efficient if passed by reference (limit: {} byte)\", size, self.value_max_size),\n+                                \"consider passing by reference instead\",\n+                                format!(\"&{}\", snippet(cx, input.span, \"_\")),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                    }\n+                },\n+\n+                _ => {},\n+            }\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(PassByRefOrValue => [TRIVIALLY_COPY_PASS_BY_REF, LARGE_TYPES_PASSED_BY_VALUE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for PassByRefOrValue {\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n+        if item.span.from_expansion() {\n+            return;\n+        }\n+\n+        if let hir::TraitItemKind::Fn(method_sig, _) = &item.kind {\n+            self.check_poly_fn(cx, item.hir_id, &*method_sig.decl, None);\n+        }\n+    }\n+\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'tcx>,\n+        kind: FnKind<'tcx>,\n+        decl: &'tcx FnDecl<'_>,\n+        _body: &'tcx Body<'_>,\n+        span: Span,\n+        hir_id: HirId,\n+    ) {\n+        if span.from_expansion() {\n+            return;\n+        }\n+\n+        match kind {\n+            FnKind::ItemFn(.., header, _, attrs) => {\n+                if header.abi != Abi::Rust {\n+                    return;\n+                }\n+                for a in attrs {\n+                    if let Some(meta_items) = a.meta_item_list() {\n+                        if a.has_name(sym!(proc_macro_derive))\n+                            || (a.has_name(sym!(inline)) && attr::list_contains_name(&meta_items, sym!(always)))\n+                        {\n+                            return;\n+                        }\n+                    }\n+                }\n+            },\n+            FnKind::Method(..) => (),\n+            FnKind::Closure(..) => return,\n+        }\n+\n+        // Exclude non-inherent impls\n+        if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n+            if matches!(item.kind, ItemKind::Impl{ of_trait: Some(_), .. } |\n+            ItemKind::Trait(..))\n+            {\n+                return;\n+            }\n+        }\n+\n+        self.check_poly_fn(cx, hir_id, decl, Some(span));\n+    }\n+}"}, {"sha": "de54711d8511b6998238d5787b95e8acbb1f042a", "filename": "src/tools/clippy/clippy_lints/src/ranges.rs", "status": "modified", "additions": 185, "deletions": 31, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -2,15 +2,19 @@ use crate::consts::{constant, Constant};\n use if_chain::if_chain;\n use rustc_ast::ast::RangeLimits;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind, QPath};\n+use rustc_hir::{BinOpKind, Expr, ExprKind, PathSegment, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Spanned;\n+use rustc_span::source_map::{Span, Spanned};\n+use rustc_span::symbol::Ident;\n use std::cmp::Ordering;\n \n use crate::utils::sugg::Sugg;\n-use crate::utils::{get_parent_expr, is_integer_const, snippet, snippet_opt, span_lint, span_lint_and_then};\n+use crate::utils::{\n+    get_parent_expr, is_integer_const, single_segment_path, snippet, snippet_opt, snippet_with_applicability,\n+    span_lint, span_lint_and_sugg, span_lint_and_then,\n+};\n use crate::utils::{higher, SpanlessEq};\n \n declare_clippy_lint! {\n@@ -128,43 +132,51 @@ declare_clippy_lint! {\n     \"reversing the limits of range expressions, resulting in empty ranges\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for expressions like `x >= 3 && x < 8` that could\n+    /// be more readably expressed as `(3..8).contains(x)`.\n+    ///\n+    /// **Why is this bad?** `contains` expresses the intent better and has less\n+    /// failure modes (such as fencepost errors or using `||` instead of `&&`).\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// // given\n+    /// let x = 6;\n+    ///\n+    /// assert!(x >= 3 && x < 8);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    ///# let x = 6;\n+    /// assert!((3..8).contains(&x));\n+    /// ```\n+    pub MANUAL_RANGE_CONTAINS,\n+    style,\n+    \"manually reimplementing {`Range`, `RangeInclusive`}`::contains`\"\n+}\n+\n declare_lint_pass!(Ranges => [\n     RANGE_ZIP_WITH_LEN,\n     RANGE_PLUS_ONE,\n     RANGE_MINUS_ONE,\n     REVERSED_EMPTY_RANGES,\n+    MANUAL_RANGE_CONTAINS,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Ranges {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind {\n-            let name = path.ident.as_str();\n-            if name == \"zip\" && args.len() == 2 {\n-                let iter = &args[0].kind;\n-                let zip_arg = &args[1];\n-                if_chain! {\n-                    // `.iter()` call\n-                    if let ExprKind::MethodCall(ref iter_path, _, ref iter_args , _) = *iter;\n-                    if iter_path.ident.name == sym!(iter);\n-                    // range expression in `.zip()` call: `0..x.len()`\n-                    if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(zip_arg);\n-                    if is_integer_const(cx, start, 0);\n-                    // `.len()` call\n-                    if let ExprKind::MethodCall(ref len_path, _, ref len_args, _) = end.kind;\n-                    if len_path.ident.name == sym!(len) && len_args.len() == 1;\n-                    // `.iter()` and `.len()` called on same `Path`\n-                    if let ExprKind::Path(QPath::Resolved(_, ref iter_path)) = iter_args[0].kind;\n-                    if let ExprKind::Path(QPath::Resolved(_, ref len_path)) = len_args[0].kind;\n-                    if SpanlessEq::new(cx).eq_path_segments(&iter_path.segments, &len_path.segments);\n-                     then {\n-                         span_lint(cx,\n-                                   RANGE_ZIP_WITH_LEN,\n-                                   expr.span,\n-                                   &format!(\"it is more idiomatic to use `{}.iter().enumerate()`\",\n-                                            snippet(cx, iter_args[0].span, \"_\")));\n-                    }\n-                }\n-            }\n+        match expr.kind {\n+            ExprKind::MethodCall(ref path, _, ref args, _) => {\n+                check_range_zip_with_len(cx, path, args, expr.span);\n+            },\n+            ExprKind::Binary(ref op, ref l, ref r) => {\n+                check_possible_range_contains(cx, op.node, l, r, expr.span);\n+            },\n+            _ => {},\n         }\n \n         check_exclusive_range_plus_one(cx, expr);\n@@ -173,6 +185,148 @@ impl<'tcx> LateLintPass<'tcx> for Ranges {\n     }\n }\n \n+fn check_possible_range_contains(cx: &LateContext<'_>, op: BinOpKind, l: &Expr<'_>, r: &Expr<'_>, span: Span) {\n+    let combine_and = match op {\n+        BinOpKind::And | BinOpKind::BitAnd => true,\n+        BinOpKind::Or | BinOpKind::BitOr => false,\n+        _ => return,\n+    };\n+    // value, name, order (higher/lower), inclusiveness\n+    if let (Some((lval, lname, name_span, lval_span, lord, linc)), Some((rval, rname, _, rval_span, rord, rinc))) =\n+        (check_range_bounds(cx, l), check_range_bounds(cx, r))\n+    {\n+        // we only lint comparisons on the same name and with different\n+        // direction\n+        if lname != rname || lord == rord {\n+            return;\n+        }\n+        let ord = Constant::partial_cmp(cx.tcx, cx.typeck_results().expr_ty(l), &lval, &rval);\n+        if combine_and && ord == Some(rord) {\n+            // order lower bound and upper bound\n+            let (l_span, u_span, l_inc, u_inc) = if rord == Ordering::Less {\n+                (lval_span, rval_span, linc, rinc)\n+            } else {\n+                (rval_span, lval_span, rinc, linc)\n+            };\n+            // we only lint inclusive lower bounds\n+            if !l_inc {\n+                return;\n+            }\n+            let (range_type, range_op) = if u_inc {\n+                (\"RangeInclusive\", \"..=\")\n+            } else {\n+                (\"Range\", \"..\")\n+            };\n+            let mut applicability = Applicability::MachineApplicable;\n+            let name = snippet_with_applicability(cx, name_span, \"_\", &mut applicability);\n+            let lo = snippet_with_applicability(cx, l_span, \"_\", &mut applicability);\n+            let hi = snippet_with_applicability(cx, u_span, \"_\", &mut applicability);\n+            span_lint_and_sugg(\n+                cx,\n+                MANUAL_RANGE_CONTAINS,\n+                span,\n+                &format!(\"manual `{}::contains` implementation\", range_type),\n+                \"use\",\n+                format!(\"({}{}{}).contains(&{})\", lo, range_op, hi, name),\n+                applicability,\n+            );\n+        } else if !combine_and && ord == Some(lord) {\n+            // `!_.contains(_)`\n+            // order lower bound and upper bound\n+            let (l_span, u_span, l_inc, u_inc) = if lord == Ordering::Less {\n+                (lval_span, rval_span, linc, rinc)\n+            } else {\n+                (rval_span, lval_span, rinc, linc)\n+            };\n+            if l_inc {\n+                return;\n+            }\n+            let (range_type, range_op) = if u_inc {\n+                (\"Range\", \"..\")\n+            } else {\n+                (\"RangeInclusive\", \"..=\")\n+            };\n+            let mut applicability = Applicability::MachineApplicable;\n+            let name = snippet_with_applicability(cx, name_span, \"_\", &mut applicability);\n+            let lo = snippet_with_applicability(cx, l_span, \"_\", &mut applicability);\n+            let hi = snippet_with_applicability(cx, u_span, \"_\", &mut applicability);\n+            span_lint_and_sugg(\n+                cx,\n+                MANUAL_RANGE_CONTAINS,\n+                span,\n+                &format!(\"manual `!{}::contains` implementation\", range_type),\n+                \"use\",\n+                format!(\"!({}{}{}).contains(&{})\", lo, range_op, hi, name),\n+                applicability,\n+            );\n+        }\n+    }\n+}\n+\n+fn check_range_bounds(cx: &LateContext<'_>, ex: &Expr<'_>) -> Option<(Constant, Ident, Span, Span, Ordering, bool)> {\n+    if let ExprKind::Binary(ref op, ref l, ref r) = ex.kind {\n+        let (inclusive, ordering) = match op.node {\n+            BinOpKind::Gt => (false, Ordering::Greater),\n+            BinOpKind::Ge => (true, Ordering::Greater),\n+            BinOpKind::Lt => (false, Ordering::Less),\n+            BinOpKind::Le => (true, Ordering::Less),\n+            _ => return None,\n+        };\n+        if let Some(id) = match_ident(l) {\n+            if let Some((c, _)) = constant(cx, cx.typeck_results(), r) {\n+                return Some((c, id, l.span, r.span, ordering, inclusive));\n+            }\n+        } else if let Some(id) = match_ident(r) {\n+            if let Some((c, _)) = constant(cx, cx.typeck_results(), l) {\n+                return Some((c, id, r.span, l.span, ordering.reverse(), inclusive));\n+            }\n+        }\n+    }\n+    None\n+}\n+\n+fn match_ident(e: &Expr<'_>) -> Option<Ident> {\n+    if let ExprKind::Path(ref qpath) = e.kind {\n+        if let Some(seg) = single_segment_path(qpath) {\n+            if seg.args.is_none() {\n+                return Some(seg.ident);\n+            }\n+        }\n+    }\n+    None\n+}\n+\n+fn check_range_zip_with_len(cx: &LateContext<'_>, path: &PathSegment<'_>, args: &[Expr<'_>], span: Span) {\n+    let name = path.ident.as_str();\n+    if name == \"zip\" && args.len() == 2 {\n+        let iter = &args[0].kind;\n+        let zip_arg = &args[1];\n+        if_chain! {\n+            // `.iter()` call\n+            if let ExprKind::MethodCall(ref iter_path, _, ref iter_args, _) = *iter;\n+            if iter_path.ident.name == sym!(iter);\n+            // range expression in `.zip()` call: `0..x.len()`\n+            if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(zip_arg);\n+            if is_integer_const(cx, start, 0);\n+            // `.len()` call\n+            if let ExprKind::MethodCall(ref len_path, _, ref len_args, _) = end.kind;\n+            if len_path.ident.name == sym!(len) && len_args.len() == 1;\n+            // `.iter()` and `.len()` called on same `Path`\n+            if let ExprKind::Path(QPath::Resolved(_, ref iter_path)) = iter_args[0].kind;\n+            if let ExprKind::Path(QPath::Resolved(_, ref len_path)) = len_args[0].kind;\n+            if SpanlessEq::new(cx).eq_path_segments(&iter_path.segments, &len_path.segments);\n+            then {\n+                span_lint(cx,\n+                    RANGE_ZIP_WITH_LEN,\n+                    span,\n+                    &format!(\"it is more idiomatic to use `{}.iter().enumerate()`\",\n+                        snippet(cx, iter_args[0].span, \"_\"))\n+                );\n+            }\n+        }\n+    }\n+}\n+\n // exclusive range plus one: `x..(y+1)`\n fn check_exclusive_range_plus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {"}, {"sha": "e90ea0fc200a9ab2177f98a9324eece30132094a", "filename": "src/tools/clippy/clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "removed", "additions": 0, "deletions": 183, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/6bdae9edd0cc099daa6038bca469dc09b6fc078a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bdae9edd0cc099daa6038bca469dc09b6fc078a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=6bdae9edd0cc099daa6038bca469dc09b6fc078a", "patch": "@@ -1,183 +0,0 @@\n-use std::cmp;\n-\n-use crate::utils::{is_copy, is_self_ty, snippet, span_lint_and_sugg};\n-use if_chain::if_chain;\n-use rustc_ast::attr;\n-use rustc_errors::Applicability;\n-use rustc_hir as hir;\n-use rustc_hir::intravisit::FnKind;\n-use rustc_hir::{Body, FnDecl, HirId, ItemKind, MutTy, Mutability, Node};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::Span;\n-use rustc_target::abi::LayoutOf;\n-use rustc_target::spec::abi::Abi;\n-use rustc_target::spec::Target;\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for functions taking arguments by reference, where\n-    /// the argument type is `Copy` and small enough to be more efficient to always\n-    /// pass by value.\n-    ///\n-    /// **Why is this bad?** In many calling conventions instances of structs will\n-    /// be passed through registers if they fit into two or less general purpose\n-    /// registers.\n-    ///\n-    /// **Known problems:** This lint is target register size dependent, it is\n-    /// limited to 32-bit to try and reduce portability problems between 32 and\n-    /// 64-bit, but if you are compiling for 8 or 16-bit targets then the limit\n-    /// will be different.\n-    ///\n-    /// The configuration option `trivial_copy_size_limit` can be set to override\n-    /// this limit for a project.\n-    ///\n-    /// This lint attempts to allow passing arguments by reference if a reference\n-    /// to that argument is returned. This is implemented by comparing the lifetime\n-    /// of the argument and return value for equality. However, this can cause\n-    /// false positives in cases involving multiple lifetimes that are bounded by\n-    /// each other.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// ```rust\n-    /// // Bad\n-    /// fn foo(v: &u32) {}\n-    /// ```\n-    ///\n-    /// ```rust\n-    /// // Better\n-    /// fn foo(v: u32) {}\n-    /// ```\n-    pub TRIVIALLY_COPY_PASS_BY_REF,\n-    pedantic,\n-    \"functions taking small copyable arguments by reference\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct TriviallyCopyPassByRef {\n-    limit: u64,\n-}\n-\n-impl<'tcx> TriviallyCopyPassByRef {\n-    pub fn new(limit: Option<u64>, target: &Target) -> Self {\n-        let limit = limit.unwrap_or_else(|| {\n-            let bit_width = u64::from(target.pointer_width);\n-            // Cap the calculated bit width at 32-bits to reduce\n-            // portability problems between 32 and 64-bit targets\n-            let bit_width = cmp::min(bit_width, 32);\n-            #[allow(clippy::integer_division)]\n-            let byte_width = bit_width / 8;\n-            // Use a limit of 2 times the register byte width\n-            byte_width * 2\n-        });\n-        Self { limit }\n-    }\n-\n-    fn check_poly_fn(&mut self, cx: &LateContext<'tcx>, hir_id: HirId, decl: &FnDecl<'_>, span: Option<Span>) {\n-        let fn_def_id = cx.tcx.hir().local_def_id(hir_id);\n-\n-        let fn_sig = cx.tcx.fn_sig(fn_def_id);\n-        let fn_sig = cx.tcx.erase_late_bound_regions(&fn_sig);\n-\n-        // Use lifetimes to determine if we're returning a reference to the\n-        // argument. In that case we can't switch to pass-by-value as the\n-        // argument will not live long enough.\n-        let output_lts = match *fn_sig.output().kind() {\n-            ty::Ref(output_lt, _, _) => vec![output_lt],\n-            ty::Adt(_, substs) => substs.regions().collect(),\n-            _ => vec![],\n-        };\n-\n-        for (input, &ty) in decl.inputs.iter().zip(fn_sig.inputs()) {\n-            // All spans generated from a proc-macro invocation are the same...\n-            match span {\n-                Some(s) if s == input.span => return,\n-                _ => (),\n-            }\n-\n-            if_chain! {\n-                if let ty::Ref(input_lt, ty, Mutability::Not) = ty.kind();\n-                if !output_lts.contains(&input_lt);\n-                if is_copy(cx, ty);\n-                if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());\n-                if size <= self.limit;\n-                if let hir::TyKind::Rptr(_, MutTy { ty: ref decl_ty, .. }) = input.kind;\n-                then {\n-                    let value_type = if is_self_ty(decl_ty) {\n-                        \"self\".into()\n-                    } else {\n-                        snippet(cx, decl_ty.span, \"_\").into()\n-                    };\n-                    span_lint_and_sugg(\n-                        cx,\n-                        TRIVIALLY_COPY_PASS_BY_REF,\n-                        input.span,\n-                        &format!(\"this argument ({} byte) is passed by reference, but would be more efficient if passed by value (limit: {} byte)\", size, self.limit),\n-                        \"consider passing by value instead\",\n-                        value_type,\n-                        Applicability::Unspecified,\n-                    );\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl_lint_pass!(TriviallyCopyPassByRef => [TRIVIALLY_COPY_PASS_BY_REF]);\n-\n-impl<'tcx> LateLintPass<'tcx> for TriviallyCopyPassByRef {\n-    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n-        if item.span.from_expansion() {\n-            return;\n-        }\n-\n-        if let hir::TraitItemKind::Fn(method_sig, _) = &item.kind {\n-            self.check_poly_fn(cx, item.hir_id, &*method_sig.decl, None);\n-        }\n-    }\n-\n-    fn check_fn(\n-        &mut self,\n-        cx: &LateContext<'tcx>,\n-        kind: FnKind<'tcx>,\n-        decl: &'tcx FnDecl<'_>,\n-        _body: &'tcx Body<'_>,\n-        span: Span,\n-        hir_id: HirId,\n-    ) {\n-        if span.from_expansion() {\n-            return;\n-        }\n-\n-        match kind {\n-            FnKind::ItemFn(.., header, _, attrs) => {\n-                if header.abi != Abi::Rust {\n-                    return;\n-                }\n-                for a in attrs {\n-                    if let Some(meta_items) = a.meta_item_list() {\n-                        if a.has_name(sym!(proc_macro_derive))\n-                            || (a.has_name(sym!(inline)) && attr::list_contains_name(&meta_items, sym!(always)))\n-                        {\n-                            return;\n-                        }\n-                    }\n-                }\n-            },\n-            FnKind::Method(..) => (),\n-            FnKind::Closure(..) => return,\n-        }\n-\n-        // Exclude non-inherent impls\n-        if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n-            if matches!(item.kind, ItemKind::Impl{ of_trait: Some(_), .. } |\n-                ItemKind::Trait(..))\n-            {\n-                return;\n-            }\n-        }\n-\n-        self.check_poly_fn(cx, hir_id, decl, Some(span));\n-    }\n-}"}, {"sha": "6a33aaaaab204f660f1cda1aae0f158599561ec5", "filename": "src/tools/clippy/clippy_lints/src/types.rs", "status": "modified", "additions": 54, "deletions": 12, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -11,7 +11,7 @@ use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{\n     BinOpKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericParamKind, HirId, ImplItem,\n-    ImplItemKind, Item, ItemKind, Lifetime, Local, MatchSource, MutTy, Mutability, Node, QPath, Stmt, StmtKind,\n+    ImplItemKind, Item, ItemKind, Lifetime, Lit, Local, MatchSource, MutTy, Mutability, Node, QPath, Stmt, StmtKind,\n     TraitFn, TraitItem, TraitItemKind, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -1224,7 +1224,8 @@ declare_clippy_lint! {\n }\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for casts to the same type.\n+    /// **What it does:** Checks for casts to the same type, casts of int literals to integer types\n+    /// and casts of float literals to float types.\n     ///\n     /// **Why is this bad?** It's just unnecessary.\n     ///\n@@ -1233,6 +1234,14 @@ declare_clippy_lint! {\n     /// **Example:**\n     /// ```rust\n     /// let _ = 2i32 as i32;\n+    /// let _ = 0.5 as f32;\n+    /// ```\n+    ///\n+    /// Better:\n+    ///\n+    /// ```rust\n+    /// let _ = 2_i32;\n+    /// let _ = 0.5_f32;\n     /// ```\n     pub UNNECESSARY_CAST,\n     complexity,\n@@ -1598,7 +1607,9 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n         if let ExprKind::Cast(ref ex, _) = expr.kind {\n             let (cast_from, cast_to) = (cx.typeck_results().expr_ty(ex), cx.typeck_results().expr_ty(expr));\n             lint_fn_to_numeric_cast(cx, expr, ex, cast_from, cast_to);\n-            if let ExprKind::Lit(ref lit) = ex.kind {\n+            if let Some(lit) = get_numeric_literal(ex) {\n+                let literal_str = snippet_opt(cx, ex.span).unwrap_or_default();\n+\n                 if_chain! {\n                     if let LitKind::Int(n, _) = lit.node;\n                     if let Some(src) = snippet_opt(cx, lit.span);\n@@ -1608,19 +1619,19 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n                     let to_nbits = fp_ty_mantissa_nbits(cast_to);\n                     if from_nbits != 0 && to_nbits != 0 && from_nbits <= to_nbits && num_lit.is_decimal();\n                     then {\n-                        span_lint_and_sugg(\n-                            cx,\n-                            UNNECESSARY_CAST,\n-                            expr.span,\n-                            &format!(\"casting integer literal to `{}` is unnecessary\", cast_to),\n-                            \"try\",\n-                            format!(\"{}_{}\", n, cast_to),\n-                            Applicability::MachineApplicable,\n-                        );\n+                        let literal_str = if is_unary_neg(ex) { format!(\"-{}\", num_lit.integer) } else { num_lit.integer.into() };\n+                        show_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n                         return;\n                     }\n                 }\n+\n                 match lit.node {\n+                    LitKind::Int(_, LitIntType::Unsuffixed) if cast_to.is_integral() => {\n+                        show_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n+                    },\n+                    LitKind::Float(_, LitFloatType::Unsuffixed) if cast_to.is_floating_point() => {\n+                        show_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n+                    },\n                     LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::Float(_, LitFloatType::Unsuffixed) => {},\n                     _ => {\n                         if cast_from.kind() == cast_to.kind() && !in_external_macro(cx.sess(), expr.span) {\n@@ -1646,6 +1657,37 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n     }\n }\n \n+fn is_unary_neg(expr: &Expr<'_>) -> bool {\n+    matches!(expr.kind, ExprKind::Unary(UnOp::UnNeg, _))\n+}\n+\n+fn get_numeric_literal<'e>(expr: &'e Expr<'e>) -> Option<&'e Lit> {\n+    match expr.kind {\n+        ExprKind::Lit(ref lit) => Some(lit),\n+        ExprKind::Unary(UnOp::UnNeg, e) => {\n+            if let ExprKind::Lit(ref lit) = e.kind {\n+                Some(lit)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    }\n+}\n+\n+fn show_unnecessary_cast(cx: &LateContext<'_>, expr: &Expr<'_>, literal_str: &str, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+    let literal_kind_name = if cast_from.is_integral() { \"integer\" } else { \"float\" };\n+    span_lint_and_sugg(\n+        cx,\n+        UNNECESSARY_CAST,\n+        expr.span,\n+        &format!(\"casting {} literal to `{}` is unnecessary\", literal_kind_name, cast_to),\n+        \"try\",\n+        format!(\"{}_{}\", literal_str, cast_to),\n+        Applicability::MachineApplicable,\n+    );\n+}\n+\n fn lint_numeric_casts<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &Expr<'tcx>,"}, {"sha": "5443f1601fcbb083c8fcef94219a56a26d67cc5c", "filename": "src/tools/clippy/clippy_lints/src/undropped_manually_drops.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundropped_manually_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundropped_manually_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundropped_manually_drops.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -0,0 +1,50 @@\n+use crate::utils::{is_type_lang_item, match_function_call, paths, span_lint_and_help};\n+use rustc_hir::{lang_items, Expr};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Prevents the safe `std::mem::drop` function from being called on `std::mem::ManuallyDrop`.\n+    ///\n+    /// **Why is this bad?** The safe `drop` function does not drop the inner value of a `ManuallyDrop`.\n+    ///\n+    /// **Known problems:** Does not catch cases if the user binds `std::mem::drop`\n+    /// to a different name and calls it that way.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// struct S;\n+    /// drop(std::mem::ManuallyDrop::new(S));\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// struct S;\n+    /// unsafe {\n+    ///     std::mem::ManuallyDrop::drop(&mut std::mem::ManuallyDrop::new(S));\n+    /// }\n+    /// ```\n+    pub UNDROPPED_MANUALLY_DROPS,\n+    correctness,\n+    \"use of safe `std::mem::drop` function to drop a std::mem::ManuallyDrop, which will not drop the inner value\"\n+}\n+\n+declare_lint_pass!(UndroppedManuallyDrops => [UNDROPPED_MANUALLY_DROPS]);\n+\n+impl LateLintPass<'tcx> for UndroppedManuallyDrops {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if let Some(ref args) = match_function_call(cx, expr, &paths::DROP) {\n+            let ty = cx.typeck_results().expr_ty(&args[0]);\n+            if is_type_lang_item(cx, ty, lang_items::LangItem::ManuallyDrop) {\n+                span_lint_and_help(\n+                    cx,\n+                    UNDROPPED_MANUALLY_DROPS,\n+                    expr.span,\n+                    \"the inner value of this ManuallyDrop will not be dropped\",\n+                    None,\n+                    \"to drop a `ManuallyDrop<T>`, use std::mem::ManuallyDrop::drop\",\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "0ac8fff69f05742f241109b52959341813bb2922", "filename": "src/tools/clippy/clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -150,6 +150,8 @@ define_Conf! {\n     (literal_representation_threshold, \"literal_representation_threshold\": u64, 16384),\n     /// Lint: TRIVIALLY_COPY_PASS_BY_REF. The maximum size (in bytes) to consider a `Copy` type for passing by value instead of by reference.\n     (trivial_copy_size_limit, \"trivial_copy_size_limit\": Option<u64>, None),\n+    /// Lint: LARGE_TYPE_PASS_BY_MOVE. The minimum size (in bytes) to consider a type for passing by reference instead of by value.\n+    (pass_by_value_size_limit, \"pass_by_value_size_limit\": u64, 256),\n     /// Lint: TOO_MANY_LINES. The maximum number of lines a function or method can have\n     (too_many_lines_threshold, \"too_many_lines_threshold\": u64, 100),\n     /// Lint: LARGE_STACK_ARRAYS, LARGE_CONST_ARRAYS. The maximum allowed size for arrays on the stack"}, {"sha": "e4ad105c3513e3f5c3539c4a5e23eb689544a465", "filename": "src/tools/clippy/clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -261,14 +261,8 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     pub fn eq_path_segment(&mut self, left: &PathSegment<'_>, right: &PathSegment<'_>) -> bool {\n         // The == of idents doesn't work with different contexts,\n         // we have to be explicit about hygiene\n-        if left.ident.as_str() != right.ident.as_str() {\n-            return false;\n-        }\n-        match (&left.args, &right.args) {\n-            (&None, &None) => true,\n-            (&Some(ref l), &Some(ref r)) => self.eq_path_parameters(l, r),\n-            _ => false,\n-        }\n+        left.ident.as_str() == right.ident.as_str()\n+            && both(&left.args, &right.args, |l, r| self.eq_path_parameters(l, r))\n     }\n \n     pub fn eq_ty(&mut self, left: &Ty<'_>, right: &Ty<'_>) -> bool {"}, {"sha": "6ca72d895c8dab74c2af2b4a89b1151c2e0dc1ae", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1,3 +1,4 @@\n+use crate::consts::{constant_simple, Constant};\n use crate::utils::{\n     is_expn_of, match_def_path, match_qpath, match_type, method_calls, path_to_res, paths, qpath_res, run_lints,\n     snippet, span_lint, span_lint_and_help, span_lint_and_sugg, SpanlessEq,\n@@ -14,9 +15,11 @@ use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n use rustc_hir::{Crate, Expr, ExprKind, HirId, Item, MutTy, Mutability, Node, Path, StmtKind, Ty, TyKind};\n use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n+use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::symbol::{Symbol, SymbolStr};\n+use rustc_typeck::hir_ty_to_ty;\n \n use std::borrow::{Borrow, Cow};\n \n@@ -229,6 +232,21 @@ declare_clippy_lint! {\n     \"using `utils::match_type()` instead of `utils::is_type_diagnostic_item()`\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Checks the paths module for invalid paths.\n+    ///\n+    /// **Why is this bad?**\n+    /// It indicates a bug in the code.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:** None.\n+    pub INVALID_PATHS,\n+    internal,\n+    \"invalid path\"\n+}\n+\n declare_lint_pass!(ClippyLintsInternal => [CLIPPY_LINTS_INTERNAL]);\n \n impl EarlyLintPass for ClippyLintsInternal {\n@@ -761,3 +779,64 @@ fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Ve\n \n     None\n }\n+\n+// This is not a complete resolver for paths. It works on all the paths currently used in the paths\n+// module.  That's all it does and all it needs to do.\n+pub fn check_path(cx: &LateContext<'_>, path: &[&str]) -> bool {\n+    if path_to_res(cx, path).is_some() {\n+        return true;\n+    }\n+\n+    // Some implementations can't be found by `path_to_res`, particularly inherent\n+    // implementations of native types. Check lang items.\n+    let path_syms: Vec<_> = path.iter().map(|p| Symbol::intern(p)).collect();\n+    let lang_items = cx.tcx.lang_items();\n+    for lang_item in lang_items.items() {\n+        if let Some(def_id) = lang_item {\n+            let lang_item_path = cx.get_def_path(*def_id);\n+            if path_syms.starts_with(&lang_item_path) {\n+                if let [item] = &path_syms[lang_item_path.len()..] {\n+                    for child in cx.tcx.item_children(*def_id) {\n+                        if child.ident.name == *item {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    false\n+}\n+\n+declare_lint_pass!(InvalidPaths => [INVALID_PATHS]);\n+\n+impl<'tcx> LateLintPass<'tcx> for InvalidPaths {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+        let local_def_id = &cx.tcx.parent_module(item.hir_id);\n+        let mod_name = &cx.tcx.item_name(local_def_id.to_def_id());\n+        if_chain! {\n+            if mod_name.as_str() == \"paths\";\n+            if let hir::ItemKind::Const(ty, body_id) = item.kind;\n+            let ty = hir_ty_to_ty(cx.tcx, ty);\n+            if let ty::Array(el_ty, _) = &ty.kind();\n+            if let ty::Ref(_, el_ty, _) = &el_ty.kind();\n+            if el_ty.is_str();\n+            let body = cx.tcx.hir().body(body_id);\n+            let typeck_results = cx.tcx.typeck_body(body_id);\n+            if let Some(Constant::Vec(path)) = constant_simple(cx, typeck_results, &body.value);\n+            let path: Vec<&str> = path.iter().map(|x| {\n+                    if let Constant::Str(s) = x {\n+                        s.as_str()\n+                    } else {\n+                        // We checked the type of the constant above\n+                        unreachable!()\n+                    }\n+                }).collect();\n+            if !check_path(cx, &path[..]);\n+            then {\n+                span_lint(cx, CLIPPY_LINTS_INTERNAL, item.span, \"invalid path\");\n+            }\n+        }\n+    }\n+}"}, {"sha": "0a8a4a5f9aedbebc8a058ee3535c922afe520109", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 64, "deletions": 1, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -27,11 +27,14 @@ pub use self::diagnostics::*;\n pub use self::hir_utils::{both, eq_expr_value, over, SpanlessEq, SpanlessHash};\n \n use std::borrow::Cow;\n+use std::collections::hash_map::Entry;\n+use std::hash::BuildHasherDefault;\n use std::mem;\n \n use if_chain::if_chain;\n use rustc_ast::ast::{self, Attribute, LitKind};\n use rustc_attr as attr;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -268,6 +271,7 @@ pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Option<def::Res> {\n             krate: *krate,\n             index: CRATE_DEF_INDEX,\n         };\n+        let mut current_item = None;\n         let mut items = cx.tcx.item_children(krate);\n         let mut path_it = path.iter().skip(1).peekable();\n \n@@ -277,17 +281,41 @@ pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Option<def::Res> {\n                 None => return None,\n             };\n \n+            // `get_def_path` seems to generate these empty segments for extern blocks.\n+            // We can just ignore them.\n+            if segment.is_empty() {\n+                continue;\n+            }\n+\n             let result = SmallVec::<[_; 8]>::new();\n             for item in mem::replace(&mut items, cx.tcx.arena.alloc_slice(&result)).iter() {\n                 if item.ident.name.as_str() == *segment {\n                     if path_it.peek().is_none() {\n                         return Some(item.res);\n                     }\n \n+                    current_item = Some(item);\n                     items = cx.tcx.item_children(item.res.def_id());\n                     break;\n                 }\n             }\n+\n+            // The segment isn't a child_item.\n+            // Try to find it under an inherent impl.\n+            if_chain! {\n+                if path_it.peek().is_none();\n+                if let Some(current_item) = current_item;\n+                let item_def_id = current_item.res.def_id();\n+                if cx.tcx.def_kind(item_def_id) == DefKind::Struct;\n+                then {\n+                    // Bad `find_map` suggestion. See #4193.\n+                    #[allow(clippy::find_map)]\n+                    return cx.tcx.inherent_impls(item_def_id).iter()\n+                        .flat_map(|&impl_def_id| cx.tcx.item_children(impl_def_id))\n+                        .find(|item| item.ident.name.as_str() == *segment)\n+                        .map(|item| item.res);\n+                }\n+            }\n         }\n     } else {\n         None\n@@ -299,7 +327,7 @@ pub fn qpath_res(cx: &LateContext<'_>, qpath: &hir::QPath<'_>, id: hir::HirId) -\n         hir::QPath::Resolved(_, path) => path.res,\n         hir::QPath::TypeRelative(..) | hir::QPath::LangItem(..) => {\n             if cx.tcx.has_typeck_results(id.owner.to_def_id()) {\n-                cx.tcx.typeck(id.owner.to_def_id().expect_local()).qpath_res(qpath, id)\n+                cx.tcx.typeck(id.owner).qpath_res(qpath, id)\n             } else {\n                 Res::Err\n             }\n@@ -1440,6 +1468,41 @@ pub fn is_slice_of_primitives(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<S\n     None\n }\n \n+/// returns list of all pairs (a, b) from `exprs` such that `eq(a, b)`\n+/// `hash` must be comformed with `eq`\n+pub fn search_same<T, Hash, Eq>(exprs: &[T], hash: Hash, eq: Eq) -> Vec<(&T, &T)>\n+where\n+    Hash: Fn(&T) -> u64,\n+    Eq: Fn(&T, &T) -> bool,\n+{\n+    if exprs.len() == 2 && eq(&exprs[0], &exprs[1]) {\n+        return vec![(&exprs[0], &exprs[1])];\n+    }\n+\n+    let mut match_expr_list: Vec<(&T, &T)> = Vec::new();\n+\n+    let mut map: FxHashMap<_, Vec<&_>> =\n+        FxHashMap::with_capacity_and_hasher(exprs.len(), BuildHasherDefault::default());\n+\n+    for expr in exprs {\n+        match map.entry(hash(expr)) {\n+            Entry::Occupied(mut o) => {\n+                for o in o.get() {\n+                    if eq(o, expr) {\n+                        match_expr_list.push((o, expr));\n+                    }\n+                }\n+                o.get_mut().push(expr);\n+            },\n+            Entry::Vacant(v) => {\n+                v.insert(vec![expr]);\n+            },\n+        }\n+    }\n+\n+    match_expr_list\n+}\n+\n #[macro_export]\n macro_rules! unwrap_cargo_metadata {\n     ($cx: ident, $lint: ident, $deps: expr) => {{"}, {"sha": "d02603d7702c7f3c6a8f7f48d30b29a027ff7e00", "filename": "src/tools/clippy/clippy_lints/src/utils/numeric_literal.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fnumeric_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fnumeric_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fnumeric_literal.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1,6 +1,6 @@\n use rustc_ast::ast::{Lit, LitFloatType, LitIntType, LitKind};\n \n-#[derive(Debug, PartialEq)]\n+#[derive(Debug, PartialEq, Copy, Clone)]\n pub enum Radix {\n     Binary,\n     Octal,\n@@ -11,8 +11,8 @@ pub enum Radix {\n impl Radix {\n     /// Returns a reasonable digit group size for this radix.\n     #[must_use]\n-    fn suggest_grouping(&self) -> usize {\n-        match *self {\n+    fn suggest_grouping(self) -> usize {\n+        match self {\n             Self::Binary | Self::Hexadecimal => 4,\n             Self::Octal | Self::Decimal => 3,\n         }"}, {"sha": "cd72fdd61fd3ab0c285c9f385c85385ccf80aaee", "filename": "src/tools/clippy/clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -31,10 +31,10 @@ pub const DISPLAY_TRAIT: [&str; 3] = [\"core\", \"fmt\", \"Display\"];\n pub const DOUBLE_ENDED_ITERATOR: [&str; 4] = [\"core\", \"iter\", \"traits\", \"DoubleEndedIterator\"];\n pub const DROP: [&str; 3] = [\"core\", \"mem\", \"drop\"];\n pub const DURATION: [&str; 3] = [\"core\", \"time\", \"Duration\"];\n-pub const EARLY_CONTEXT: [&str; 4] = [\"rustc\", \"lint\", \"context\", \"EarlyContext\"];\n+pub const EARLY_CONTEXT: [&str; 2] = [\"rustc_lint\", \"EarlyContext\"];\n pub const EXIT: [&str; 3] = [\"std\", \"process\", \"exit\"];\n-pub const F32_EPSILON: [&str; 2] = [\"f32\", \"EPSILON\"];\n-pub const F64_EPSILON: [&str; 2] = [\"f64\", \"EPSILON\"];\n+pub const F32_EPSILON: [&str; 4] = [\"core\", \"f32\", \"<impl f32>\", \"EPSILON\"];\n+pub const F64_EPSILON: [&str; 4] = [\"core\", \"f64\", \"<impl f64>\", \"EPSILON\"];\n pub const FILE: [&str; 3] = [\"std\", \"fs\", \"File\"];\n pub const FILE_TYPE: [&str; 3] = [\"std\", \"fs\", \"FileType\"];\n pub const FMT_ARGUMENTS_NEW_V1: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1\"];\n@@ -46,7 +46,7 @@ pub const FN_ONCE: [&str; 3] = [\"core\", \"ops\", \"FnOnce\"];\n pub const FROM_FROM: [&str; 4] = [\"core\", \"convert\", \"From\", \"from\"];\n pub const FROM_TRAIT: [&str; 3] = [\"core\", \"convert\", \"From\"];\n pub const FUTURE_FROM_GENERATOR: [&str; 3] = [\"core\", \"future\", \"from_generator\"];\n-pub const HASH: [&str; 2] = [\"hash\", \"Hash\"];\n+pub const HASH: [&str; 3] = [\"core\", \"hash\", \"Hash\"];\n pub const HASHMAP: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n pub const HASHMAP_ENTRY: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n pub const HASHSET: [&str; 5] = [\"std\", \"collections\", \"hash\", \"set\", \"HashSet\"];\n@@ -57,7 +57,7 @@ pub const INTO_ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"collect\", \"Into\n pub const IO_READ: [&str; 3] = [\"std\", \"io\", \"Read\"];\n pub const IO_WRITE: [&str; 3] = [\"std\", \"io\", \"Write\"];\n pub const ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\"];\n-pub const LATE_CONTEXT: [&str; 4] = [\"rustc\", \"lint\", \"context\", \"LateContext\"];\n+pub const LATE_CONTEXT: [&str; 2] = [\"rustc_lint\", \"LateContext\"];\n pub const LINKED_LIST: [&str; 4] = [\"alloc\", \"collections\", \"linked_list\", \"LinkedList\"];\n pub const LINT: [&str; 3] = [\"rustc_session\", \"lint\", \"Lint\"];\n pub const MEM_DISCRIMINANT: [&str; 3] = [\"core\", \"mem\", \"discriminant\"];\n@@ -85,13 +85,15 @@ pub const PATH_BUF_AS_PATH: [&str; 4] = [\"std\", \"path\", \"PathBuf\", \"as_path\"];\n pub const PATH_TO_PATH_BUF: [&str; 4] = [\"std\", \"path\", \"Path\", \"to_path_buf\"];\n pub const POLL: [&str; 4] = [\"core\", \"task\", \"poll\", \"Poll\"];\n pub const PTR_EQ: [&str; 3] = [\"core\", \"ptr\", \"eq\"];\n-pub const PTR_NULL: [&str; 2] = [\"ptr\", \"null\"];\n-pub const PTR_NULL_MUT: [&str; 2] = [\"ptr\", \"null_mut\"];\n+pub const PTR_NULL: [&str; 3] = [\"core\", \"ptr\", \"null\"];\n+pub const PTR_NULL_MUT: [&str; 3] = [\"core\", \"ptr\", \"null_mut\"];\n pub const PUSH_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"push_str\"];\n pub const RANGE_ARGUMENT_TRAIT: [&str; 3] = [\"core\", \"ops\", \"RangeBounds\"];\n pub const RC: [&str; 3] = [\"alloc\", \"rc\", \"Rc\"];\n pub const RC_PTR_EQ: [&str; 4] = [\"alloc\", \"rc\", \"Rc\", \"ptr_eq\"];\n pub const RECEIVER: [&str; 4] = [\"std\", \"sync\", \"mpsc\", \"Receiver\"];\n+pub const REFCELL_REF: [&str; 3] = [\"core\", \"cell\", \"Ref\"];\n+pub const REFCELL_REFMUT: [&str; 3] = [\"core\", \"cell\", \"RefMut\"];\n pub const REGEX_BUILDER_NEW: [&str; 5] = [\"regex\", \"re_builder\", \"unicode\", \"RegexBuilder\", \"new\"];\n pub const REGEX_BYTES_BUILDER_NEW: [&str; 5] = [\"regex\", \"re_builder\", \"bytes\", \"RegexBuilder\", \"new\"];\n pub const REGEX_BYTES_NEW: [&str; 4] = [\"regex\", \"re_bytes\", \"Regex\", \"new\"];\n@@ -104,7 +106,7 @@ pub const RESULT_ERR: [&str; 4] = [\"core\", \"result\", \"Result\", \"Err\"];\n pub const RESULT_OK: [&str; 4] = [\"core\", \"result\", \"Result\", \"Ok\"];\n pub const RWLOCK_READ_GUARD: [&str; 4] = [\"std\", \"sync\", \"rwlock\", \"RwLockReadGuard\"];\n pub const RWLOCK_WRITE_GUARD: [&str; 4] = [\"std\", \"sync\", \"rwlock\", \"RwLockWriteGuard\"];\n-pub const SERDE_DESERIALIZE: [&str; 2] = [\"_serde\", \"Deserialize\"];\n+pub const SERDE_DESERIALIZE: [&str; 3] = [\"serde\", \"de\", \"Deserialize\"];\n pub const SERDE_DE_VISITOR: [&str; 3] = [\"serde\", \"de\", \"Visitor\"];\n pub const SLICE_INTO_VEC: [&str; 4] = [\"alloc\", \"slice\", \"<impl [T]>\", \"into_vec\"];\n pub const SLICE_ITER: [&str; 4] = [\"core\", \"slice\", \"iter\", \"Iter\"];"}, {"sha": "8b327b2d4675e54c0b9970c4afe204b32063a879", "filename": "src/tools/clippy/clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -19,12 +19,11 @@ pub fn mutated_variables<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) ->\n         used_mutably: FxHashSet::default(),\n         skip: false,\n     };\n-    let def_id = expr.hir_id.owner.to_def_id();\n     cx.tcx.infer_ctxt().enter(|infcx| {\n         ExprUseVisitor::new(\n             &mut delegate,\n             &infcx,\n-            def_id.expect_local(),\n+            expr.hir_id.owner,\n             cx.param_env,\n             cx.typeck_results(),\n         )"}, {"sha": "c2e63ecb581ecde0afb8282304d06283dc1f0f35", "filename": "src/tools/clippy/src/lintlist/mod.rs", "status": "modified", "additions": 54, "deletions": 5, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -62,10 +62,17 @@ vec![\n     },\n     Lint {\n         name: \"await_holding_lock\",\n-        group: \"pedantic\",\n+        group: \"correctness\",\n         desc: \"Inside an async function, holding a MutexGuard while calling await\",\n         deprecation: None,\n-        module: \"await_holding_lock\",\n+        module: \"await_holding_invalid\",\n+    },\n+    Lint {\n+        name: \"await_holding_refcell_ref\",\n+        group: \"correctness\",\n+        desc: \"Inside an async function, holding a RefCell ref while calling await\",\n+        deprecation: None,\n+        module: \"await_holding_invalid\",\n     },\n     Lint {\n         name: \"bad_bit_mask\",\n@@ -1061,6 +1068,13 @@ vec![\n         deprecation: None,\n         module: \"large_stack_arrays\",\n     },\n+    Lint {\n+        name: \"large_types_passed_by_value\",\n+        group: \"pedantic\",\n+        desc: \"functions taking large arguments by value\",\n+        deprecation: None,\n+        module: \"pass_by_ref_or_value\",\n+    },\n     Lint {\n         name: \"len_without_is_empty\",\n         group: \"style\",\n@@ -1159,6 +1173,13 @@ vec![\n         deprecation: None,\n         module: \"manual_non_exhaustive\",\n     },\n+    Lint {\n+        name: \"manual_range_contains\",\n+        group: \"style\",\n+        desc: \"manually reimplementing {`Range`, `RangeInclusive`}`::contains`\",\n+        deprecation: None,\n+        module: \"ranges\",\n+    },\n     Lint {\n         name: \"manual_saturating_arithmetic\",\n         group: \"style\",\n@@ -1183,7 +1204,7 @@ vec![\n     Lint {\n         name: \"manual_unwrap_or\",\n         group: \"complexity\",\n-        desc: \"finds patterns that can be encoded more concisely with `Option::unwrap_or`\",\n+        desc: \"finds patterns that can be encoded more concisely with `Option::unwrap_or` or `Result::unwrap_or`\",\n         deprecation: None,\n         module: \"manual_unwrap_or\",\n     },\n@@ -1283,7 +1304,7 @@ vec![\n         group: \"pedantic\",\n         desc: \"`match` with identical arm bodies\",\n         deprecation: None,\n-        module: \"copies\",\n+        module: \"matches\",\n     },\n     Lint {\n         name: \"match_single_binding\",\n@@ -1488,6 +1509,13 @@ vec![\n         deprecation: None,\n         module: \"mut_mut\",\n     },\n+    Lint {\n+        name: \"mut_mutex_lock\",\n+        group: \"style\",\n+        desc: \"`&mut Mutex::lock` does unnecessary locking\",\n+        deprecation: None,\n+        module: \"mut_mutex_lock\",\n+    },\n     Lint {\n         name: \"mut_range_bound\",\n         group: \"complexity\",\n@@ -2125,6 +2153,13 @@ vec![\n         deprecation: None,\n         module: \"single_component_path_imports\",\n     },\n+    Lint {\n+        name: \"single_element_loop\",\n+        group: \"complexity\",\n+        desc: \"there is no reason to have a single element loop\",\n+        deprecation: None,\n+        module: \"loops\",\n+    },\n     Lint {\n         name: \"single_match\",\n         group: \"style\",\n@@ -2382,7 +2417,7 @@ vec![\n         group: \"pedantic\",\n         desc: \"functions taking small copyable arguments by reference\",\n         deprecation: None,\n-        module: \"trivially_copy_pass_by_ref\",\n+        module: \"pass_by_ref_or_value\",\n     },\n     Lint {\n         name: \"try_err\",\n@@ -2405,6 +2440,13 @@ vec![\n         deprecation: None,\n         module: \"trait_bounds\",\n     },\n+    Lint {\n+        name: \"undropped_manually_drops\",\n+        group: \"correctness\",\n+        desc: \"use of safe `std::mem::drop` function to drop a std::mem::ManuallyDrop, which will not drop the inner value\",\n+        deprecation: None,\n+        module: \"undropped_manually_drops\",\n+    },\n     Lint {\n         name: \"unicode_not_nfc\",\n         group: \"pedantic\",\n@@ -2594,6 +2636,13 @@ vec![\n         deprecation: None,\n         module: \"unused_unit\",\n     },\n+    Lint {\n+        name: \"unusual_byte_groupings\",\n+        group: \"style\",\n+        desc: \"binary or hex literals that aren\\'t grouped by four\",\n+        deprecation: None,\n+        module: \"literal_representation\",\n+    },\n     Lint {\n         name: \"unwrap_in_result\",\n         group: \"restriction\","}, {"sha": "a58e7e918e2f85a6301c5f2d062f1fbce0bc892b", "filename": "src/tools/clippy/tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1,4 +1,4 @@\n-error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-trait-bounds`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `disallowed-methods`, `third-party` at line 5 column 1\n+error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `pass-by-value-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-trait-bounds`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `disallowed-methods`, `third-party` at line 5 column 1\n \n error: aborting due to previous error\n "}, {"sha": "88841597bb60bf5bc8a8bff346fdfc9391a40cfe", "filename": "src/tools/clippy/tests/ui/await_holding_refcell_ref.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fawait_holding_refcell_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fawait_holding_refcell_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fawait_holding_refcell_ref.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -0,0 +1,86 @@\n+// edition:2018\n+#![warn(clippy::await_holding_refcell_ref)]\n+\n+use std::cell::RefCell;\n+\n+async fn bad(x: &RefCell<u32>) -> u32 {\n+    let b = x.borrow();\n+    baz().await\n+}\n+\n+async fn bad_mut(x: &RefCell<u32>) -> u32 {\n+    let b = x.borrow_mut();\n+    baz().await\n+}\n+\n+async fn good(x: &RefCell<u32>) -> u32 {\n+    {\n+        let b = x.borrow_mut();\n+        let y = *b + 1;\n+    }\n+    baz().await;\n+    let b = x.borrow_mut();\n+    47\n+}\n+\n+async fn baz() -> u32 {\n+    42\n+}\n+\n+async fn also_bad(x: &RefCell<u32>) -> u32 {\n+    let first = baz().await;\n+\n+    let b = x.borrow_mut();\n+\n+    let second = baz().await;\n+\n+    let third = baz().await;\n+\n+    first + second + third\n+}\n+\n+async fn less_bad(x: &RefCell<u32>) -> u32 {\n+    let first = baz().await;\n+\n+    let b = x.borrow_mut();\n+\n+    let second = baz().await;\n+\n+    drop(b);\n+\n+    let third = baz().await;\n+\n+    first + second + third\n+}\n+\n+async fn not_good(x: &RefCell<u32>) -> u32 {\n+    let first = baz().await;\n+\n+    let second = {\n+        let b = x.borrow_mut();\n+        baz().await\n+    };\n+\n+    let third = baz().await;\n+\n+    first + second + third\n+}\n+\n+#[allow(clippy::manual_async_fn)]\n+fn block_bad(x: &RefCell<u32>) -> impl std::future::Future<Output = u32> + '_ {\n+    async move {\n+        let b = x.borrow_mut();\n+        baz().await\n+    }\n+}\n+\n+fn main() {\n+    let rc = RefCell::new(100);\n+    good(&rc);\n+    bad(&rc);\n+    bad_mut(&rc);\n+    also_bad(&rc);\n+    less_bad(&rc);\n+    not_good(&rc);\n+    block_bad(&rc);\n+}"}, {"sha": "b504f0454913634969cb11a6ced5b3fc5e9fb2f9", "filename": "src/tools/clippy/tests/ui/await_holding_refcell_ref.stderr", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fawait_holding_refcell_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fawait_holding_refcell_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fawait_holding_refcell_ref.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -0,0 +1,95 @@\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:7:9\n+   |\n+LL |     let b = x.borrow();\n+   |         ^\n+   |\n+   = note: `-D clippy::await-holding-refcell-ref` implied by `-D warnings`\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:7:5\n+   |\n+LL | /     let b = x.borrow();\n+LL | |     baz().await\n+LL | | }\n+   | |_^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:12:9\n+   |\n+LL |     let b = x.borrow_mut();\n+   |         ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:12:5\n+   |\n+LL | /     let b = x.borrow_mut();\n+LL | |     baz().await\n+LL | | }\n+   | |_^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:33:9\n+   |\n+LL |     let b = x.borrow_mut();\n+   |         ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:33:5\n+   |\n+LL | /     let b = x.borrow_mut();\n+LL | |\n+LL | |     let second = baz().await;\n+LL | |\n+...  |\n+LL | |     first + second + third\n+LL | | }\n+   | |_^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:45:9\n+   |\n+LL |     let b = x.borrow_mut();\n+   |         ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:45:5\n+   |\n+LL | /     let b = x.borrow_mut();\n+LL | |\n+LL | |     let second = baz().await;\n+LL | |\n+...  |\n+LL | |     first + second + third\n+LL | | }\n+   | |_^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:60:13\n+   |\n+LL |         let b = x.borrow_mut();\n+   |             ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:60:9\n+   |\n+LL | /         let b = x.borrow_mut();\n+LL | |         baz().await\n+LL | |     };\n+   | |_____^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:72:13\n+   |\n+LL |         let b = x.borrow_mut();\n+   |             ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:72:9\n+   |\n+LL | /         let b = x.borrow_mut();\n+LL | |         baz().await\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "5a012ff4d27ab184ff758cf1f1492246a51e47c1", "filename": "src/tools/clippy/tests/ui/bool_comparison.fixed", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbool_comparison.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbool_comparison.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbool_comparison.fixed?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n \n-#[warn(clippy::bool_comparison)]\n+#![warn(clippy::bool_comparison)]\n+\n fn main() {\n     let x = true;\n     if x {\n@@ -127,3 +128,40 @@ fn issue4983() {\n     if b == a {};\n     if !b == !a {};\n }\n+\n+macro_rules! m {\n+    ($func:ident) => {\n+        $func()\n+    };\n+}\n+\n+fn func() -> bool {\n+    true\n+}\n+\n+#[allow(dead_code)]\n+fn issue3973() {\n+    // ok, don't lint on `cfg` invocation\n+    if false == cfg!(feature = \"debugging\") {}\n+    if cfg!(feature = \"debugging\") == false {}\n+    if true == cfg!(feature = \"debugging\") {}\n+    if cfg!(feature = \"debugging\") == true {}\n+\n+    // lint, could be simplified\n+    if !m!(func) {}\n+    if !m!(func) {}\n+    if m!(func) {}\n+    if m!(func) {}\n+\n+    // no lint with a variable\n+    let is_debug = false;\n+    if is_debug == cfg!(feature = \"debugging\") {}\n+    if cfg!(feature = \"debugging\") == is_debug {}\n+    if is_debug == m!(func) {}\n+    if m!(func) == is_debug {}\n+    let is_debug = true;\n+    if is_debug == cfg!(feature = \"debugging\") {}\n+    if cfg!(feature = \"debugging\") == is_debug {}\n+    if is_debug == m!(func) {}\n+    if m!(func) == is_debug {}\n+}"}, {"sha": "c534bc25c20f1105ea497f9405d24a5334c3f7b9", "filename": "src/tools/clippy/tests/ui/bool_comparison.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbool_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbool_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbool_comparison.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n \n-#[warn(clippy::bool_comparison)]\n+#![warn(clippy::bool_comparison)]\n+\n fn main() {\n     let x = true;\n     if x == true {\n@@ -127,3 +128,40 @@ fn issue4983() {\n     if b == a {};\n     if !b == !a {};\n }\n+\n+macro_rules! m {\n+    ($func:ident) => {\n+        $func()\n+    };\n+}\n+\n+fn func() -> bool {\n+    true\n+}\n+\n+#[allow(dead_code)]\n+fn issue3973() {\n+    // ok, don't lint on `cfg` invocation\n+    if false == cfg!(feature = \"debugging\") {}\n+    if cfg!(feature = \"debugging\") == false {}\n+    if true == cfg!(feature = \"debugging\") {}\n+    if cfg!(feature = \"debugging\") == true {}\n+\n+    // lint, could be simplified\n+    if false == m!(func) {}\n+    if m!(func) == false {}\n+    if true == m!(func) {}\n+    if m!(func) == true {}\n+\n+    // no lint with a variable\n+    let is_debug = false;\n+    if is_debug == cfg!(feature = \"debugging\") {}\n+    if cfg!(feature = \"debugging\") == is_debug {}\n+    if is_debug == m!(func) {}\n+    if m!(func) == is_debug {}\n+    let is_debug = true;\n+    if is_debug == cfg!(feature = \"debugging\") {}\n+    if cfg!(feature = \"debugging\") == is_debug {}\n+    if is_debug == m!(func) {}\n+    if m!(func) == is_debug {}\n+}"}, {"sha": "31522d4a525199e23c9ec51da602c2b2ee2495ac", "filename": "src/tools/clippy/tests/ui/bool_comparison.stderr", "status": "modified", "additions": 43, "deletions": 19, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbool_comparison.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbool_comparison.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbool_comparison.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1,112 +1,136 @@\n error: equality checks against true are unnecessary\n-  --> $DIR/bool_comparison.rs:6:8\n+  --> $DIR/bool_comparison.rs:7:8\n    |\n LL |     if x == true {\n    |        ^^^^^^^^^ help: try simplifying it as shown: `x`\n    |\n    = note: `-D clippy::bool-comparison` implied by `-D warnings`\n \n error: equality checks against false can be replaced by a negation\n-  --> $DIR/bool_comparison.rs:11:8\n+  --> $DIR/bool_comparison.rs:12:8\n    |\n LL |     if x == false {\n    |        ^^^^^^^^^^ help: try simplifying it as shown: `!x`\n \n error: equality checks against true are unnecessary\n-  --> $DIR/bool_comparison.rs:16:8\n+  --> $DIR/bool_comparison.rs:17:8\n    |\n LL |     if true == x {\n    |        ^^^^^^^^^ help: try simplifying it as shown: `x`\n \n error: equality checks against false can be replaced by a negation\n-  --> $DIR/bool_comparison.rs:21:8\n+  --> $DIR/bool_comparison.rs:22:8\n    |\n LL |     if false == x {\n    |        ^^^^^^^^^^ help: try simplifying it as shown: `!x`\n \n error: inequality checks against true can be replaced by a negation\n-  --> $DIR/bool_comparison.rs:26:8\n+  --> $DIR/bool_comparison.rs:27:8\n    |\n LL |     if x != true {\n    |        ^^^^^^^^^ help: try simplifying it as shown: `!x`\n \n error: inequality checks against false are unnecessary\n-  --> $DIR/bool_comparison.rs:31:8\n+  --> $DIR/bool_comparison.rs:32:8\n    |\n LL |     if x != false {\n    |        ^^^^^^^^^^ help: try simplifying it as shown: `x`\n \n error: inequality checks against true can be replaced by a negation\n-  --> $DIR/bool_comparison.rs:36:8\n+  --> $DIR/bool_comparison.rs:37:8\n    |\n LL |     if true != x {\n    |        ^^^^^^^^^ help: try simplifying it as shown: `!x`\n \n error: inequality checks against false are unnecessary\n-  --> $DIR/bool_comparison.rs:41:8\n+  --> $DIR/bool_comparison.rs:42:8\n    |\n LL |     if false != x {\n    |        ^^^^^^^^^^ help: try simplifying it as shown: `x`\n \n error: less than comparison against true can be replaced by a negation\n-  --> $DIR/bool_comparison.rs:46:8\n+  --> $DIR/bool_comparison.rs:47:8\n    |\n LL |     if x < true {\n    |        ^^^^^^^^ help: try simplifying it as shown: `!x`\n \n error: greater than checks against false are unnecessary\n-  --> $DIR/bool_comparison.rs:51:8\n+  --> $DIR/bool_comparison.rs:52:8\n    |\n LL |     if false < x {\n    |        ^^^^^^^^^ help: try simplifying it as shown: `x`\n \n error: greater than checks against false are unnecessary\n-  --> $DIR/bool_comparison.rs:56:8\n+  --> $DIR/bool_comparison.rs:57:8\n    |\n LL |     if x > false {\n    |        ^^^^^^^^^ help: try simplifying it as shown: `x`\n \n error: less than comparison against true can be replaced by a negation\n-  --> $DIR/bool_comparison.rs:61:8\n+  --> $DIR/bool_comparison.rs:62:8\n    |\n LL |     if true > x {\n    |        ^^^^^^^^ help: try simplifying it as shown: `!x`\n \n error: order comparisons between booleans can be simplified\n-  --> $DIR/bool_comparison.rs:67:8\n+  --> $DIR/bool_comparison.rs:68:8\n    |\n LL |     if x < y {\n    |        ^^^^^ help: try simplifying it as shown: `!x & y`\n \n error: order comparisons between booleans can be simplified\n-  --> $DIR/bool_comparison.rs:72:8\n+  --> $DIR/bool_comparison.rs:73:8\n    |\n LL |     if x > y {\n    |        ^^^^^ help: try simplifying it as shown: `x & !y`\n \n error: this comparison might be written more concisely\n-  --> $DIR/bool_comparison.rs:120:8\n+  --> $DIR/bool_comparison.rs:121:8\n    |\n LL |     if a == !b {};\n    |        ^^^^^^^ help: try simplifying it as shown: `a != b`\n \n error: this comparison might be written more concisely\n-  --> $DIR/bool_comparison.rs:121:8\n+  --> $DIR/bool_comparison.rs:122:8\n    |\n LL |     if !a == b {};\n    |        ^^^^^^^ help: try simplifying it as shown: `a != b`\n \n error: this comparison might be written more concisely\n-  --> $DIR/bool_comparison.rs:125:8\n+  --> $DIR/bool_comparison.rs:126:8\n    |\n LL |     if b == !a {};\n    |        ^^^^^^^ help: try simplifying it as shown: `b != a`\n \n error: this comparison might be written more concisely\n-  --> $DIR/bool_comparison.rs:126:8\n+  --> $DIR/bool_comparison.rs:127:8\n    |\n LL |     if !b == a {};\n    |        ^^^^^^^ help: try simplifying it as shown: `b != a`\n \n-error: aborting due to 18 previous errors\n+error: equality checks against false can be replaced by a negation\n+  --> $DIR/bool_comparison.rs:151:8\n+   |\n+LL |     if false == m!(func) {}\n+   |        ^^^^^^^^^^^^^^^^^ help: try simplifying it as shown: `!m!(func)`\n+\n+error: equality checks against false can be replaced by a negation\n+  --> $DIR/bool_comparison.rs:152:8\n+   |\n+LL |     if m!(func) == false {}\n+   |        ^^^^^^^^^^^^^^^^^ help: try simplifying it as shown: `!m!(func)`\n+\n+error: equality checks against true are unnecessary\n+  --> $DIR/bool_comparison.rs:153:8\n+   |\n+LL |     if true == m!(func) {}\n+   |        ^^^^^^^^^^^^^^^^ help: try simplifying it as shown: `m!(func)`\n+\n+error: equality checks against true are unnecessary\n+  --> $DIR/bool_comparison.rs:154:8\n+   |\n+LL |     if m!(func) == true {}\n+   |        ^^^^^^^^^^^^^^^^ help: try simplifying it as shown: `m!(func)`\n+\n+error: aborting due to 22 previous errors\n "}, {"sha": "140676a5ffcfc82ad79dadf0f18d9c7d79390ae7", "filename": "src/tools/clippy/tests/ui/cast_size_32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_size_32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_size_32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_size_32bit.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -124,7 +124,7 @@ error: casting integer literal to `f64` is unnecessary\n   --> $DIR/cast_size_32bit.rs:34:5\n    |\n LL |     3_999_999_999usize as f64;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `3999999999_f64`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `3_999_999_999_f64`\n    |\n    = note: `-D clippy::unnecessary-cast` implied by `-D warnings`\n "}, {"sha": "bb03ce4035533a4b19a8bb0cb99e8cfb1b43fe47", "filename": "src/tools/clippy/tests/ui/crashes/ice-360.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-360.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-360.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-360.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -12,13 +12,14 @@ LL | |     }\n    |\n    = note: `-D clippy::while-let-loop` implied by `-D warnings`\n \n-error: empty `loop {}` detected. You may want to either use `panic!()` or add `std::thread::sleep(..);` to the loop body.\n+error: empty `loop {}` wastes CPU cycles\n   --> $DIR/ice-360.rs:10:9\n    |\n LL |         loop {}\n    |         ^^^^^^^\n    |\n    = note: `-D clippy::empty-loop` implied by `-D warnings`\n+   = help: You should either use `panic!()` or add `std::thread::sleep(..);` to the loop body.\n \n error: aborting due to 2 previous errors\n "}, {"sha": "56755596c97fc646faee8d75531021c79660b22d", "filename": "src/tools/clippy/tests/ui/deprecated.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeprecated.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -9,5 +9,6 @@\n #[warn(clippy::unused_label)]\n #[warn(clippy::regex_macro)]\n #[warn(clippy::drop_bounds)]\n+#[warn(clippy::temporary_cstring_as_ptr)]\n \n fn main() {}"}, {"sha": "37b726fc00f1c414e76421db7b6bb12f8918262d", "filename": "src/tools/clippy/tests/ui/deprecated.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeprecated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeprecated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeprecated.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -66,11 +66,17 @@ error: lint `clippy::drop_bounds` has been removed: `this lint has been uplifted\n LL | #[warn(clippy::drop_bounds)]\n    |        ^^^^^^^^^^^^^^^^^^^\n \n+error: lint `clippy::temporary_cstring_as_ptr` has been removed: `this lint has been uplifted to rustc and is now called `temporary_cstring_as_ptr``\n+  --> $DIR/deprecated.rs:12:8\n+   |\n+LL | #[warn(clippy::temporary_cstring_as_ptr)]\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: lint `clippy::str_to_string` has been removed: `using `str::to_string` is common even today and specialization will likely happen soon`\n   --> $DIR/deprecated.rs:1:8\n    |\n LL | #[warn(clippy::str_to_string)]\n    |        ^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 13 previous errors\n "}, {"sha": "fd3979f259a145c6ea6a917fb2876a7119d7f3f8", "filename": "src/tools/clippy/tests/ui/empty_loop.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fempty_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fempty_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fempty_loop.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1,22 +1,27 @@\n-error: empty `loop {}` detected. You may want to either use `panic!()` or add `std::thread::sleep(..);` to the loop body.\n+error: empty `loop {}` wastes CPU cycles\n   --> $DIR/empty_loop.rs:9:5\n    |\n LL |     loop {}\n    |     ^^^^^^^\n    |\n    = note: `-D clippy::empty-loop` implied by `-D warnings`\n+   = help: You should either use `panic!()` or add `std::thread::sleep(..);` to the loop body.\n \n-error: empty `loop {}` detected. You may want to either use `panic!()` or add `std::thread::sleep(..);` to the loop body.\n+error: empty `loop {}` wastes CPU cycles\n   --> $DIR/empty_loop.rs:11:9\n    |\n LL |         loop {}\n    |         ^^^^^^^\n+   |\n+   = help: You should either use `panic!()` or add `std::thread::sleep(..);` to the loop body.\n \n-error: empty `loop {}` detected. You may want to either use `panic!()` or add `std::thread::sleep(..);` to the loop body.\n+error: empty `loop {}` wastes CPU cycles\n   --> $DIR/empty_loop.rs:15:9\n    |\n LL |         'inner: loop {}\n    |         ^^^^^^^^^^^^^^^\n+   |\n+   = help: You should either use `panic!()` or add `std::thread::sleep(..);` to the loop body.\n \n error: aborting due to 3 previous errors\n "}, {"sha": "879d1d5d916e439bf219fef4e343ab0320c13d51", "filename": "src/tools/clippy/tests/ui/empty_loop_no_std.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fempty_loop_no_std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fempty_loop_no_std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fempty_loop_no_std.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "previous_filename": "src/tools/clippy/tests/ui/issue-3746.rs"}, {"sha": "4e09d19ea214572f70adbeba6142268609c7a2f7", "filename": "src/tools/clippy/tests/ui/eq_op.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feq_op.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -6,6 +6,7 @@\n #[allow(clippy::no_effect, unused_variables, clippy::unnecessary_operation, clippy::short_circuit_statement)]\n #[allow(clippy::nonminimal_bool)]\n #[allow(unused)]\n+#[allow(clippy::unnecessary_cast)]\n fn main() {\n     // simple values and comparisons\n     1 == 1;"}, {"sha": "ad81b35a766493c9e81e61bca13a8540ef1e6f91", "filename": "src/tools/clippy/tests/ui/eq_op.stderr", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feq_op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feq_op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feq_op.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1,163 +1,163 @@\n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:11:5\n+  --> $DIR/eq_op.rs:12:5\n    |\n LL |     1 == 1;\n    |     ^^^^^^\n    |\n    = note: `-D clippy::eq-op` implied by `-D warnings`\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:12:5\n+  --> $DIR/eq_op.rs:13:5\n    |\n LL |     \"no\" == \"no\";\n    |     ^^^^^^^^^^^^\n \n error: equal expressions as operands to `!=`\n-  --> $DIR/eq_op.rs:14:5\n+  --> $DIR/eq_op.rs:15:5\n    |\n LL |     false != false;\n    |     ^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `<`\n-  --> $DIR/eq_op.rs:15:5\n+  --> $DIR/eq_op.rs:16:5\n    |\n LL |     1.5 < 1.5;\n    |     ^^^^^^^^^\n \n error: equal expressions as operands to `>=`\n-  --> $DIR/eq_op.rs:16:5\n+  --> $DIR/eq_op.rs:17:5\n    |\n LL |     1u64 >= 1u64;\n    |     ^^^^^^^^^^^^\n \n error: equal expressions as operands to `&`\n-  --> $DIR/eq_op.rs:19:5\n+  --> $DIR/eq_op.rs:20:5\n    |\n LL |     (1 as u64) & (1 as u64);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `^`\n-  --> $DIR/eq_op.rs:20:5\n+  --> $DIR/eq_op.rs:21:5\n    |\n LL |     1 ^ ((((((1))))));\n    |     ^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `<`\n-  --> $DIR/eq_op.rs:23:5\n+  --> $DIR/eq_op.rs:24:5\n    |\n LL |     (-(2) < -(2));\n    |     ^^^^^^^^^^^^^\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:24:5\n+  --> $DIR/eq_op.rs:25:5\n    |\n LL |     ((1 + 1) & (1 + 1) == (1 + 1) & (1 + 1));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `&`\n-  --> $DIR/eq_op.rs:24:6\n+  --> $DIR/eq_op.rs:25:6\n    |\n LL |     ((1 + 1) & (1 + 1) == (1 + 1) & (1 + 1));\n    |      ^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `&`\n-  --> $DIR/eq_op.rs:24:27\n+  --> $DIR/eq_op.rs:25:27\n    |\n LL |     ((1 + 1) & (1 + 1) == (1 + 1) & (1 + 1));\n    |                           ^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:25:5\n+  --> $DIR/eq_op.rs:26:5\n    |\n LL |     (1 * 2) + (3 * 4) == 1 * 2 + 3 * 4;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `!=`\n-  --> $DIR/eq_op.rs:28:5\n+  --> $DIR/eq_op.rs:29:5\n    |\n LL |     ([1] != [1]);\n    |     ^^^^^^^^^^^^\n \n error: equal expressions as operands to `!=`\n-  --> $DIR/eq_op.rs:29:5\n+  --> $DIR/eq_op.rs:30:5\n    |\n LL |     ((1, 2) != (1, 2));\n    |     ^^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:33:5\n+  --> $DIR/eq_op.rs:34:5\n    |\n LL |     1 + 1 == 2;\n    |     ^^^^^^^^^^\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:34:5\n+  --> $DIR/eq_op.rs:35:5\n    |\n LL |     1 - 1 == 0;\n    |     ^^^^^^^^^^\n \n error: equal expressions as operands to `-`\n-  --> $DIR/eq_op.rs:34:5\n+  --> $DIR/eq_op.rs:35:5\n    |\n LL |     1 - 1 == 0;\n    |     ^^^^^\n \n error: equal expressions as operands to `-`\n-  --> $DIR/eq_op.rs:36:5\n+  --> $DIR/eq_op.rs:37:5\n    |\n LL |     1 - 1;\n    |     ^^^^^\n \n error: equal expressions as operands to `/`\n-  --> $DIR/eq_op.rs:37:5\n+  --> $DIR/eq_op.rs:38:5\n    |\n LL |     1 / 1;\n    |     ^^^^^\n \n error: equal expressions as operands to `&&`\n-  --> $DIR/eq_op.rs:38:5\n+  --> $DIR/eq_op.rs:39:5\n    |\n LL |     true && true;\n    |     ^^^^^^^^^^^^\n \n error: equal expressions as operands to `||`\n-  --> $DIR/eq_op.rs:40:5\n+  --> $DIR/eq_op.rs:41:5\n    |\n LL |     true || true;\n    |     ^^^^^^^^^^^^\n \n error: equal expressions as operands to `&&`\n-  --> $DIR/eq_op.rs:46:5\n+  --> $DIR/eq_op.rs:47:5\n    |\n LL |     a == b && b == a;\n    |     ^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `&&`\n-  --> $DIR/eq_op.rs:47:5\n+  --> $DIR/eq_op.rs:48:5\n    |\n LL |     a != b && b != a;\n    |     ^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `&&`\n-  --> $DIR/eq_op.rs:48:5\n+  --> $DIR/eq_op.rs:49:5\n    |\n LL |     a < b && b > a;\n    |     ^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `&&`\n-  --> $DIR/eq_op.rs:49:5\n+  --> $DIR/eq_op.rs:50:5\n    |\n LL |     a <= b && b >= a;\n    |     ^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:52:5\n+  --> $DIR/eq_op.rs:53:5\n    |\n LL |     a == a;\n    |     ^^^^^^\n \n error: equal expressions as operands to `/`\n-  --> $DIR/eq_op.rs:62:20\n+  --> $DIR/eq_op.rs:63:20\n    |\n LL |     const D: u32 = A / A;\n    |                    ^^^^^"}, {"sha": "8d54f75b5d19f297d7f4e56be4f5659dc81b1a31", "filename": "src/tools/clippy/tests/ui/if_same_then_else2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_same_then_else2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_same_then_else2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_same_then_else2.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -3,7 +3,8 @@\n     clippy::blacklisted_name,\n     clippy::collapsible_if,\n     clippy::ifs_same_cond,\n-    clippy::needless_return\n+    clippy::needless_return,\n+    clippy::single_element_loop\n )]\n \n fn if_same_then_else2() -> Result<&'static str, ()> {"}, {"sha": "da2be6c8aa5acb4078b1787fca8aac2234dbcbe0", "filename": "src/tools/clippy/tests/ui/if_same_then_else2.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_same_then_else2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_same_then_else2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_same_then_else2.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1,5 +1,5 @@\n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:19:12\n+  --> $DIR/if_same_then_else2.rs:20:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -13,7 +13,7 @@ LL | |     }\n    |\n    = note: `-D clippy::if-same-then-else` implied by `-D warnings`\n note: same as this\n-  --> $DIR/if_same_then_else2.rs:10:13\n+  --> $DIR/if_same_then_else2.rs:11:13\n    |\n LL |       if true {\n    |  _____________^\n@@ -26,7 +26,7 @@ LL | |     } else {\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:33:12\n+  --> $DIR/if_same_then_else2.rs:34:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -36,7 +36,7 @@ LL | |     }\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else2.rs:31:13\n+  --> $DIR/if_same_then_else2.rs:32:13\n    |\n LL |       if true {\n    |  _____________^\n@@ -45,7 +45,7 @@ LL | |     } else {\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:40:12\n+  --> $DIR/if_same_then_else2.rs:41:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -55,7 +55,7 @@ LL | |     }\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else2.rs:38:13\n+  --> $DIR/if_same_then_else2.rs:39:13\n    |\n LL |       if true {\n    |  _____________^\n@@ -64,7 +64,7 @@ LL | |     } else {\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:90:12\n+  --> $DIR/if_same_then_else2.rs:91:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -74,7 +74,7 @@ LL | |     };\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else2.rs:88:21\n+  --> $DIR/if_same_then_else2.rs:89:21\n    |\n LL |       let _ = if true {\n    |  _____________________^\n@@ -83,7 +83,7 @@ LL | |     } else {\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:97:12\n+  --> $DIR/if_same_then_else2.rs:98:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -93,7 +93,7 @@ LL | |     }\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else2.rs:95:13\n+  --> $DIR/if_same_then_else2.rs:96:13\n    |\n LL |       if true {\n    |  _____________^\n@@ -102,7 +102,7 @@ LL | |     } else {\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:122:12\n+  --> $DIR/if_same_then_else2.rs:123:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -112,7 +112,7 @@ LL | |     }\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else2.rs:119:20\n+  --> $DIR/if_same_then_else2.rs:120:20\n    |\n LL |       } else if true {\n    |  ____________________^"}, {"sha": "01e28ae5e9d3581c0995e1b88abb0fd738494052", "filename": "src/tools/clippy/tests/ui/invalid_paths.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finvalid_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finvalid_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finvalid_paths.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -0,0 +1,23 @@\n+#![warn(clippy::internal)]\n+\n+mod paths {\n+    // Good path\n+    pub const ANY_TRAIT: [&str; 3] = [\"std\", \"any\", \"Any\"];\n+\n+    // Path to method on inherent impl of a primitive type\n+    pub const F32_EPSILON: [&str; 4] = [\"core\", \"f32\", \"<impl f32>\", \"EPSILON\"];\n+\n+    // Path to method on inherent impl\n+    pub const ARC_PTR_EQ: [&str; 4] = [\"alloc\", \"sync\", \"Arc\", \"ptr_eq\"];\n+\n+    // Path with empty segment\n+    pub const TRANSMUTE: [&str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n+\n+    // Path with bad crate\n+    pub const BAD_CRATE_PATH: [&str; 2] = [\"bad\", \"path\"];\n+\n+    // Path with bad module\n+    pub const BAD_MOD_PATH: [&str; 2] = [\"std\", \"xxx\"];\n+}\n+\n+fn main() {}"}, {"sha": "bd69d661b714fe8bd29e553588d2736e3eb22fc3", "filename": "src/tools/clippy/tests/ui/invalid_paths.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finvalid_paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finvalid_paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finvalid_paths.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -0,0 +1,16 @@\n+error: invalid path\n+  --> $DIR/invalid_paths.rs:17:5\n+   |\n+LL |     pub const BAD_CRATE_PATH: [&str; 2] = [\"bad\", \"path\"];\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::clippy-lints-internal` implied by `-D warnings`\n+\n+error: invalid path\n+  --> $DIR/invalid_paths.rs:20:5\n+   |\n+LL |     pub const BAD_MOD_PATH: [&str; 2] = [\"std\", \"xxx\"];\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "3430c137ec2207435c2dcb5a7d636ac6a348dfa3", "filename": "src/tools/clippy/tests/ui/large_digit_groups.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flarge_digit_groups.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flarge_digit_groups.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flarge_digit_groups.fixed?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -11,7 +11,7 @@ fn main() {\n     let _good = (\n         0b1011_i64,\n         0o1_234_u32,\n-        0x1_234_567,\n+        0x0123_4567,\n         1_2345_6789,\n         1234_f32,\n         1_234.12_f32,"}, {"sha": "13d108b56e02e72558003d8c838410a07219e11a", "filename": "src/tools/clippy/tests/ui/large_digit_groups.stderr", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flarge_digit_groups.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flarge_digit_groups.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flarge_digit_groups.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1,24 +1,30 @@\n-error: digit groups should be smaller\n+error: digits of hex or binary literal not grouped by four\n+  --> $DIR/large_digit_groups.rs:14:9\n+   |\n+LL |         0x1_234_567,\n+   |         ^^^^^^^^^^^ help: consider: `0x0123_4567`\n+   |\n+   = note: `-D clippy::unusual-byte-groupings` implied by `-D warnings`\n+\n+error: digits of hex or binary literal not grouped by four\n   --> $DIR/large_digit_groups.rs:22:9\n    |\n LL |         0b1_10110_i64,\n    |         ^^^^^^^^^^^^^ help: consider: `0b11_0110_i64`\n-   |\n-   = note: `-D clippy::large-digit-groups` implied by `-D warnings`\n \n-error: digits grouped inconsistently by underscores\n+error: digits of hex or binary literal not grouped by four\n   --> $DIR/large_digit_groups.rs:23:9\n    |\n LL |         0xd_e_adbee_f_usize,\n    |         ^^^^^^^^^^^^^^^^^^^ help: consider: `0xdead_beef_usize`\n-   |\n-   = note: `-D clippy::inconsistent-digit-grouping` implied by `-D warnings`\n \n error: digit groups should be smaller\n   --> $DIR/large_digit_groups.rs:24:9\n    |\n LL |         1_23456_f32,\n    |         ^^^^^^^^^^^ help: consider: `123_456_f32`\n+   |\n+   = note: `-D clippy::large-digit-groups` implied by `-D warnings`\n \n error: digit groups should be smaller\n   --> $DIR/large_digit_groups.rs:25:9\n@@ -38,5 +44,5 @@ error: digit groups should be smaller\n LL |         1_23456.12345_6_f64,\n    |         ^^^^^^^^^^^^^^^^^^^ help: consider: `123_456.123_456_f64`\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 7 previous errors\n "}, {"sha": "e4a2e9df4d7ba71d6ad41d0f9faa75d3f7ced853", "filename": "src/tools/clippy/tests/ui/large_types_passed_by_value.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flarge_types_passed_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flarge_types_passed_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flarge_types_passed_by_value.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -0,0 +1,66 @@\n+// normalize-stderr-test \"\\(\\d+ byte\\)\" -> \"(N byte)\"\n+// normalize-stderr-test \"\\(limit: \\d+ byte\\)\" -> \"(limit: N byte)\"\n+\n+#![warn(clippy::large_types_passed_by_value)]\n+\n+pub struct Large([u8; 2048]);\n+\n+#[derive(Clone, Copy)]\n+pub struct LargeAndCopy([u8; 2048]);\n+\n+pub struct Small([u8; 4]);\n+\n+#[derive(Clone, Copy)]\n+pub struct SmallAndCopy([u8; 4]);\n+\n+fn small(a: Small, b: SmallAndCopy) {}\n+fn not_copy(a: Large) {}\n+fn by_ref(a: &Large, b: &LargeAndCopy) {}\n+fn mutable(mut a: LargeAndCopy) {}\n+fn bad(a: LargeAndCopy) {}\n+pub fn bad_but_pub(a: LargeAndCopy) {}\n+\n+impl LargeAndCopy {\n+    fn self_is_ok(self) {}\n+    fn other_is_not_ok(self, other: LargeAndCopy) {}\n+    fn unless_other_can_change(self, mut other: LargeAndCopy) {}\n+    pub fn or_were_in_public(self, other: LargeAndCopy) {}\n+}\n+\n+trait LargeTypeDevourer {\n+    fn devoure_array(&self, array: [u8; 6666]);\n+    fn devoure_tuple(&self, tup: (LargeAndCopy, LargeAndCopy));\n+    fn devoure_array_and_tuple_wow(&self, array: [u8; 6666], tup: (LargeAndCopy, LargeAndCopy));\n+}\n+\n+pub trait PubLargeTypeDevourer {\n+    fn devoure_array_in_public(&self, array: [u8; 6666]);\n+}\n+\n+struct S {}\n+impl LargeTypeDevourer for S {\n+    fn devoure_array(&self, array: [u8; 6666]) {\n+        todo!();\n+    }\n+    fn devoure_tuple(&self, tup: (LargeAndCopy, LargeAndCopy)) {\n+        todo!();\n+    }\n+    fn devoure_array_and_tuple_wow(&self, array: [u8; 6666], tup: (LargeAndCopy, LargeAndCopy)) {\n+        todo!();\n+    }\n+}\n+\n+#[inline(always)]\n+fn foo_always(x: LargeAndCopy) {\n+    todo!();\n+}\n+#[inline(never)]\n+fn foo_never(x: LargeAndCopy) {\n+    todo!();\n+}\n+#[inline]\n+fn foo(x: LargeAndCopy) {\n+    todo!();\n+}\n+\n+fn main() {}"}, {"sha": "5f42dcfb9b5218e43238f9d3bf26777e8aa630a0", "filename": "src/tools/clippy/tests/ui/large_types_passed_by_value.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flarge_types_passed_by_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flarge_types_passed_by_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flarge_types_passed_by_value.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -0,0 +1,52 @@\n+error: this argument (N byte) is passed by value, but might be more efficient if passed by reference (limit: N byte)\n+  --> $DIR/large_types_passed_by_value.rs:20:11\n+   |\n+LL | fn bad(a: LargeAndCopy) {}\n+   |           ^^^^^^^^^^^^ help: consider passing by reference instead: `&LargeAndCopy`\n+   |\n+   = note: `-D clippy::large-types-passed-by-value` implied by `-D warnings`\n+\n+error: this argument (N byte) is passed by value, but might be more efficient if passed by reference (limit: N byte)\n+  --> $DIR/large_types_passed_by_value.rs:25:37\n+   |\n+LL |     fn other_is_not_ok(self, other: LargeAndCopy) {}\n+   |                                     ^^^^^^^^^^^^ help: consider passing by reference instead: `&LargeAndCopy`\n+\n+error: this argument (N byte) is passed by value, but might be more efficient if passed by reference (limit: N byte)\n+  --> $DIR/large_types_passed_by_value.rs:31:36\n+   |\n+LL |     fn devoure_array(&self, array: [u8; 6666]);\n+   |                                    ^^^^^^^^^^ help: consider passing by reference instead: `&[u8; 6666]`\n+\n+error: this argument (N byte) is passed by value, but might be more efficient if passed by reference (limit: N byte)\n+  --> $DIR/large_types_passed_by_value.rs:32:34\n+   |\n+LL |     fn devoure_tuple(&self, tup: (LargeAndCopy, LargeAndCopy));\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider passing by reference instead: `&(LargeAndCopy, LargeAndCopy)`\n+\n+error: this argument (N byte) is passed by value, but might be more efficient if passed by reference (limit: N byte)\n+  --> $DIR/large_types_passed_by_value.rs:33:50\n+   |\n+LL |     fn devoure_array_and_tuple_wow(&self, array: [u8; 6666], tup: (LargeAndCopy, LargeAndCopy));\n+   |                                                  ^^^^^^^^^^ help: consider passing by reference instead: `&[u8; 6666]`\n+\n+error: this argument (N byte) is passed by value, but might be more efficient if passed by reference (limit: N byte)\n+  --> $DIR/large_types_passed_by_value.rs:33:67\n+   |\n+LL |     fn devoure_array_and_tuple_wow(&self, array: [u8; 6666], tup: (LargeAndCopy, LargeAndCopy));\n+   |                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider passing by reference instead: `&(LargeAndCopy, LargeAndCopy)`\n+\n+error: this argument (N byte) is passed by value, but might be more efficient if passed by reference (limit: N byte)\n+  --> $DIR/large_types_passed_by_value.rs:58:17\n+   |\n+LL | fn foo_never(x: LargeAndCopy) {\n+   |                 ^^^^^^^^^^^^ help: consider passing by reference instead: `&LargeAndCopy`\n+\n+error: this argument (N byte) is passed by value, but might be more efficient if passed by reference (limit: N byte)\n+  --> $DIR/large_types_passed_by_value.rs:62:11\n+   |\n+LL | fn foo(x: LargeAndCopy) {\n+   |           ^^^^^^^^^^^^ help: consider passing by reference instead: `&LargeAndCopy`\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "a72a74b9131d8bb21fb3b2431fd344c2d069706c", "filename": "src/tools/clippy/tests/ui/literals.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fliterals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fliterals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fliterals.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -33,4 +33,9 @@ fn main() {\n     let fail19 = 12_3456_21;\n     let fail22 = 3__4___23;\n     let fail23 = 3__16___23;\n+\n+    let fail24 = 0xAB_ABC_AB;\n+    let fail25 = 0b01_100_101;\n+    let ok26 = 0x6_A0_BF;\n+    let ok27 = 0b1_0010_0101;\n }"}, {"sha": "64ceeb316d8e5a109871389304449d97f424bda1", "filename": "src/tools/clippy/tests/ui/literals.stderr", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fliterals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fliterals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fliterals.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -69,5 +69,19 @@ error: digits grouped inconsistently by underscores\n LL |     let fail23 = 3__16___23;\n    |                  ^^^^^^^^^^ help: consider: `31_623`\n \n-error: aborting due to 8 previous errors\n+error: digits of hex or binary literal not grouped by four\n+  --> $DIR/literals.rs:37:18\n+   |\n+LL |     let fail24 = 0xAB_ABC_AB;\n+   |                  ^^^^^^^^^^^ help: consider: `0x0ABA_BCAB`\n+   |\n+   = note: `-D clippy::unusual-byte-groupings` implied by `-D warnings`\n+\n+error: digits of hex or binary literal not grouped by four\n+  --> $DIR/literals.rs:38:18\n+   |\n+LL |     let fail25 = 0b01_100_101;\n+   |                  ^^^^^^^^^^^^ help: consider: `0b0110_0101`\n+\n+error: aborting due to 10 previous errors\n "}, {"sha": "5aa5a43cb92cf672da6888096fed8bd4ceb9db3b", "filename": "src/tools/clippy/tests/ui/manual_unwrap_or.fixed", "status": "modified", "additions": 72, "deletions": 1, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_unwrap_or.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_unwrap_or.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_unwrap_or.fixed?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1,7 +1,8 @@\n // run-rustfix\n #![allow(dead_code)]\n+#![allow(unused_variables)]\n \n-fn unwrap_or() {\n+fn option_unwrap_or() {\n     // int case\n     Some(1).unwrap_or(42);\n \n@@ -65,4 +66,74 @@ fn unwrap_or() {\n     };\n }\n \n+fn result_unwrap_or() {\n+    // int case\n+    Ok::<i32, &str>(1).unwrap_or(42);\n+\n+    // int case, scrutinee is a binding\n+    let a = Ok::<i32, &str>(1);\n+    a.unwrap_or(42);\n+\n+    // int case, suggestion must surround Result expr with parenthesis\n+    (Ok(1) as Result<i32, &str>).unwrap_or(42);\n+\n+    // method call case, suggestion must not surround Result expr `s.method()` with parenthesis\n+    struct S {}\n+    impl S {\n+        fn method(self) -> Option<i32> {\n+            Some(42)\n+        }\n+    }\n+    let s = S {};\n+    s.method().unwrap_or(42);\n+\n+    // int case reversed\n+    Ok::<i32, &str>(1).unwrap_or(42);\n+\n+    // richer none expr\n+    Ok::<i32, &str>(1).unwrap_or(1 + 42);\n+\n+    // multiline case\n+    #[rustfmt::skip]\n+    Ok::<i32, &str>(1).unwrap_or({\n+        42 + 42\n+            + 42 + 42 + 42\n+            + 42 + 42 + 42\n+    });\n+\n+    // string case\n+    Ok::<&str, &str>(\"Bob\").unwrap_or(\"Alice\");\n+\n+    // don't lint\n+    match Ok::<i32, &str>(1) {\n+        Ok(i) => i + 2,\n+        Err(_) => 42,\n+    };\n+    match Ok::<i32, &str>(1) {\n+        Ok(i) => i,\n+        Err(_) => return,\n+    };\n+    for j in 0..4 {\n+        match Ok::<i32, &str>(j) {\n+            Ok(i) => i,\n+            Err(_) => continue,\n+        };\n+        match Ok::<i32, &str>(j) {\n+            Ok(i) => i,\n+            Err(_) => break,\n+        };\n+    }\n+\n+    // don't lint, Err value is used\n+    match Ok::<&str, &str>(\"Alice\") {\n+        Ok(s) => s,\n+        Err(s) => s,\n+    };\n+    // could lint, but unused_variables takes care of it\n+    match Ok::<&str, &str>(\"Alice\") {\n+        Ok(s) => s,\n+        Err(s) => \"Bob\",\n+    };\n+}\n+\n fn main() {}"}, {"sha": "df534031f54c32c83991357f07cb3826f021323c", "filename": "src/tools/clippy/tests/ui/manual_unwrap_or.rs", "status": "modified", "additions": 96, "deletions": 1, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_unwrap_or.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1,7 +1,8 @@\n // run-rustfix\n #![allow(dead_code)]\n+#![allow(unused_variables)]\n \n-fn unwrap_or() {\n+fn option_unwrap_or() {\n     // int case\n     match Some(1) {\n         Some(i) => i,\n@@ -80,4 +81,98 @@ fn unwrap_or() {\n     };\n }\n \n+fn result_unwrap_or() {\n+    // int case\n+    match Ok::<i32, &str>(1) {\n+        Ok(i) => i,\n+        Err(_) => 42,\n+    };\n+\n+    // int case, scrutinee is a binding\n+    let a = Ok::<i32, &str>(1);\n+    match a {\n+        Ok(i) => i,\n+        Err(_) => 42,\n+    };\n+\n+    // int case, suggestion must surround Result expr with parenthesis\n+    match Ok(1) as Result<i32, &str> {\n+        Ok(i) => i,\n+        Err(_) => 42,\n+    };\n+\n+    // method call case, suggestion must not surround Result expr `s.method()` with parenthesis\n+    struct S {}\n+    impl S {\n+        fn method(self) -> Option<i32> {\n+            Some(42)\n+        }\n+    }\n+    let s = S {};\n+    match s.method() {\n+        Some(i) => i,\n+        None => 42,\n+    };\n+\n+    // int case reversed\n+    match Ok::<i32, &str>(1) {\n+        Err(_) => 42,\n+        Ok(i) => i,\n+    };\n+\n+    // richer none expr\n+    match Ok::<i32, &str>(1) {\n+        Ok(i) => i,\n+        Err(_) => 1 + 42,\n+    };\n+\n+    // multiline case\n+    #[rustfmt::skip]\n+    match Ok::<i32, &str>(1) {\n+        Ok(i) => i,\n+        Err(_) => {\n+            42 + 42\n+                + 42 + 42 + 42\n+                + 42 + 42 + 42\n+        }\n+    };\n+\n+    // string case\n+    match Ok::<&str, &str>(\"Bob\") {\n+        Ok(i) => i,\n+        Err(_) => \"Alice\",\n+    };\n+\n+    // don't lint\n+    match Ok::<i32, &str>(1) {\n+        Ok(i) => i + 2,\n+        Err(_) => 42,\n+    };\n+    match Ok::<i32, &str>(1) {\n+        Ok(i) => i,\n+        Err(_) => return,\n+    };\n+    for j in 0..4 {\n+        match Ok::<i32, &str>(j) {\n+            Ok(i) => i,\n+            Err(_) => continue,\n+        };\n+        match Ok::<i32, &str>(j) {\n+            Ok(i) => i,\n+            Err(_) => break,\n+        };\n+    }\n+\n+    // don't lint, Err value is used\n+    match Ok::<&str, &str>(\"Alice\") {\n+        Ok(s) => s,\n+        Err(s) => s,\n+    };\n+    // could lint, but unused_variables takes care of it\n+    match Ok::<&str, &str>(\"Alice\") {\n+        Ok(s) => s,\n+        Err(s) => \"Bob\",\n+    };\n+}\n+\n fn main() {}"}, {"sha": "fc174c4c2705dc3c6d7ea4b6df6b889b7b881c8c", "filename": "src/tools/clippy/tests/ui/manual_unwrap_or.stderr", "status": "modified", "additions": 90, "deletions": 6, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_unwrap_or.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_unwrap_or.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_unwrap_or.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1,5 +1,5 @@\n error: this pattern reimplements `Option::unwrap_or`\n-  --> $DIR/manual_unwrap_or.rs:6:5\n+  --> $DIR/manual_unwrap_or.rs:7:5\n    |\n LL | /     match Some(1) {\n LL | |         Some(i) => i,\n@@ -10,7 +10,7 @@ LL | |     };\n    = note: `-D clippy::manual-unwrap-or` implied by `-D warnings`\n \n error: this pattern reimplements `Option::unwrap_or`\n-  --> $DIR/manual_unwrap_or.rs:12:5\n+  --> $DIR/manual_unwrap_or.rs:13:5\n    |\n LL | /     match Some(1) {\n LL | |         None => 42,\n@@ -19,7 +19,7 @@ LL | |     };\n    | |_____^ help: replace with: `Some(1).unwrap_or(42)`\n \n error: this pattern reimplements `Option::unwrap_or`\n-  --> $DIR/manual_unwrap_or.rs:18:5\n+  --> $DIR/manual_unwrap_or.rs:19:5\n    |\n LL | /     match Some(1) {\n LL | |         Some(i) => i,\n@@ -28,7 +28,7 @@ LL | |     };\n    | |_____^ help: replace with: `Some(1).unwrap_or(1 + 42)`\n \n error: this pattern reimplements `Option::unwrap_or`\n-  --> $DIR/manual_unwrap_or.rs:25:5\n+  --> $DIR/manual_unwrap_or.rs:26:5\n    |\n LL | /     match Some(1) {\n LL | |         Some(i) => i,\n@@ -49,13 +49,97 @@ LL |     });\n    |\n \n error: this pattern reimplements `Option::unwrap_or`\n-  --> $DIR/manual_unwrap_or.rs:35:5\n+  --> $DIR/manual_unwrap_or.rs:36:5\n    |\n LL | /     match Some(\"Bob\") {\n LL | |         Some(i) => i,\n LL | |         None => \"Alice\",\n LL | |     };\n    | |_____^ help: replace with: `Some(\"Bob\").unwrap_or(\"Alice\")`\n \n-error: aborting due to 5 previous errors\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:86:5\n+   |\n+LL | /     match Ok::<i32, &str>(1) {\n+LL | |         Ok(i) => i,\n+LL | |         Err(_) => 42,\n+LL | |     };\n+   | |_____^ help: replace with: `Ok::<i32, &str>(1).unwrap_or(42)`\n+\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:93:5\n+   |\n+LL | /     match a {\n+LL | |         Ok(i) => i,\n+LL | |         Err(_) => 42,\n+LL | |     };\n+   | |_____^ help: replace with: `a.unwrap_or(42)`\n+\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:99:5\n+   |\n+LL | /     match Ok(1) as Result<i32, &str> {\n+LL | |         Ok(i) => i,\n+LL | |         Err(_) => 42,\n+LL | |     };\n+   | |_____^ help: replace with: `(Ok(1) as Result<i32, &str>).unwrap_or(42)`\n+\n+error: this pattern reimplements `Option::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:112:5\n+   |\n+LL | /     match s.method() {\n+LL | |         Some(i) => i,\n+LL | |         None => 42,\n+LL | |     };\n+   | |_____^ help: replace with: `s.method().unwrap_or(42)`\n+\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:118:5\n+   |\n+LL | /     match Ok::<i32, &str>(1) {\n+LL | |         Err(_) => 42,\n+LL | |         Ok(i) => i,\n+LL | |     };\n+   | |_____^ help: replace with: `Ok::<i32, &str>(1).unwrap_or(42)`\n+\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:124:5\n+   |\n+LL | /     match Ok::<i32, &str>(1) {\n+LL | |         Ok(i) => i,\n+LL | |         Err(_) => 1 + 42,\n+LL | |     };\n+   | |_____^ help: replace with: `Ok::<i32, &str>(1).unwrap_or(1 + 42)`\n+\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:131:5\n+   |\n+LL | /     match Ok::<i32, &str>(1) {\n+LL | |         Ok(i) => i,\n+LL | |         Err(_) => {\n+LL | |             42 + 42\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+help: replace with\n+   |\n+LL |     Ok::<i32, &str>(1).unwrap_or({\n+LL |         42 + 42\n+LL |             + 42 + 42 + 42\n+LL |             + 42 + 42 + 42\n+LL |     });\n+   |\n+\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:141:5\n+   |\n+LL | /     match Ok::<&str, &str>(\"Bob\") {\n+LL | |         Ok(i) => i,\n+LL | |         Err(_) => \"Alice\",\n+LL | |     };\n+   | |_____^ help: replace with: `Ok::<&str, &str>(\"Bob\").unwrap_or(\"Alice\")`\n+\n+error: aborting due to 13 previous errors\n "}, {"sha": "7f4ebf566733a6e8df6d300f10a7d919671c982a", "filename": "src/tools/clippy/tests/ui/match_expr_like_matches_macro.fixed", "status": "modified", "additions": 67, "deletions": 1, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.fixed?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::match_like_matches_macro)]\n-#![allow(unreachable_patterns)]\n+#![allow(unreachable_patterns, dead_code)]\n \n fn main() {\n     let x = Some(5);\n@@ -33,4 +33,70 @@ fn main() {\n         _ => true,\n         None => false,\n     };\n+\n+    enum E {\n+        A(u32),\n+        B(i32),\n+        C,\n+        D,\n+    };\n+    let x = E::A(2);\n+    {\n+        // lint\n+        let _ans = matches!(x, E::A(_) | E::B(_));\n+    }\n+    {\n+        // lint\n+        let _ans = !matches!(x, E::B(_) | E::C);\n+    }\n+    {\n+        // no lint\n+        let _ans = match x {\n+            E::A(_) => false,\n+            E::B(_) => false,\n+            E::C => true,\n+            _ => true,\n+        };\n+    }\n+    {\n+        // no lint\n+        let _ans = match x {\n+            E::A(_) => true,\n+            E::B(_) => false,\n+            E::C => false,\n+            _ => true,\n+        };\n+    }\n+    {\n+        // no lint\n+        let _ans = match x {\n+            E::A(a) if a < 10 => false,\n+            E::B(a) if a < 10 => false,\n+            _ => true,\n+        };\n+    }\n+    {\n+        // no lint\n+        let _ans = match x {\n+            E::A(_) => false,\n+            E::B(a) if a < 10 => false,\n+            _ => true,\n+        };\n+    }\n+    {\n+        // no lint\n+        let _ans = match x {\n+            E::A(a) => a == 10,\n+            E::B(_) => false,\n+            _ => true,\n+        };\n+    }\n+    {\n+        // no lint\n+        let _ans = match x {\n+            E::A(_) => false,\n+            E::B(_) => true,\n+            _ => false,\n+        };\n+    }\n }"}, {"sha": "aee56dd4a5ef474e478dc2a72acdb950368796d2", "filename": "src/tools/clippy/tests/ui/match_expr_like_matches_macro.rs", "status": "modified", "additions": 75, "deletions": 1, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::match_like_matches_macro)]\n-#![allow(unreachable_patterns)]\n+#![allow(unreachable_patterns, dead_code)]\n \n fn main() {\n     let x = Some(5);\n@@ -45,4 +45,78 @@ fn main() {\n         _ => true,\n         None => false,\n     };\n+\n+    enum E {\n+        A(u32),\n+        B(i32),\n+        C,\n+        D,\n+    };\n+    let x = E::A(2);\n+    {\n+        // lint\n+        let _ans = match x {\n+            E::A(_) => true,\n+            E::B(_) => true,\n+            _ => false,\n+        };\n+    }\n+    {\n+        // lint\n+        let _ans = match x {\n+            E::B(_) => false,\n+            E::C => false,\n+            _ => true,\n+        };\n+    }\n+    {\n+        // no lint\n+        let _ans = match x {\n+            E::A(_) => false,\n+            E::B(_) => false,\n+            E::C => true,\n+            _ => true,\n+        };\n+    }\n+    {\n+        // no lint\n+        let _ans = match x {\n+            E::A(_) => true,\n+            E::B(_) => false,\n+            E::C => false,\n+            _ => true,\n+        };\n+    }\n+    {\n+        // no lint\n+        let _ans = match x {\n+            E::A(a) if a < 10 => false,\n+            E::B(a) if a < 10 => false,\n+            _ => true,\n+        };\n+    }\n+    {\n+        // no lint\n+        let _ans = match x {\n+            E::A(_) => false,\n+            E::B(a) if a < 10 => false,\n+            _ => true,\n+        };\n+    }\n+    {\n+        // no lint\n+        let _ans = match x {\n+            E::A(a) => a == 10,\n+            E::B(_) => false,\n+            _ => true,\n+        };\n+    }\n+    {\n+        // no lint\n+        let _ans = match x {\n+            E::A(_) => false,\n+            E::B(_) => true,\n+            _ => false,\n+        };\n+    }\n }"}, {"sha": "c52e41c788944e5757c3f26c2f97d500f3dbf92a", "filename": "src/tools/clippy/tests/ui/match_expr_like_matches_macro.stderr", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -48,5 +48,27 @@ error: if let .. else expression looks like `matches!` macro\n LL |     let _zzz = if let Some(5) = x { true } else { false };\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `matches!(x, Some(5))`\n \n-error: aborting due to 5 previous errors\n+error: match expression looks like `matches!` macro\n+  --> $DIR/match_expr_like_matches_macro.rs:58:20\n+   |\n+LL |           let _ans = match x {\n+   |  ____________________^\n+LL | |             E::A(_) => true,\n+LL | |             E::B(_) => true,\n+LL | |             _ => false,\n+LL | |         };\n+   | |_________^ help: try this: `matches!(x, E::A(_) | E::B(_))`\n+\n+error: match expression looks like `matches!` macro\n+  --> $DIR/match_expr_like_matches_macro.rs:66:20\n+   |\n+LL |           let _ans = match x {\n+   |  ____________________^\n+LL | |             E::B(_) => false,\n+LL | |             E::C => false,\n+LL | |             _ => true,\n+LL | |         };\n+   | |_________^ help: try this: `!matches!(x, E::B(_) | E::C)`\n+\n+error: aborting due to 7 previous errors\n "}, {"sha": "06d91497242e1f493abf50fad80407e87df18e36", "filename": "src/tools/clippy/tests/ui/match_same_arms2.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_same_arms2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_same_arms2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_same_arms2.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -119,6 +119,22 @@ fn match_same_arms() {\n             unreachable!();\n         },\n     }\n+\n+    match_expr_like_matches_macro_priority();\n+}\n+\n+fn match_expr_like_matches_macro_priority() {\n+    enum E {\n+        A,\n+        B,\n+        C,\n+    }\n+    let x = E::A;\n+    let _ans = match x {\n+        E::A => false,\n+        E::B => false,\n+        _ => true,\n+    };\n }\n \n fn main() {}"}, {"sha": "fccaf805616b48bc99aae55bcb53d817859b42fe", "filename": "src/tools/clippy/tests/ui/match_same_arms2.stderr", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_same_arms2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_same_arms2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_same_arms2.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -141,5 +141,18 @@ LL |         Ok(3) => println!(\"ok\"),\n    |         ^^^^^\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 7 previous errors\n+error: match expression looks like `matches!` macro\n+  --> $DIR/match_same_arms2.rs:133:16\n+   |\n+LL |       let _ans = match x {\n+   |  ________________^\n+LL | |         E::A => false,\n+LL | |         E::B => false,\n+LL | |         _ => true,\n+LL | |     };\n+   | |_____^ help: try this: `!matches!(x, E::A | E::B)`\n+   |\n+   = note: `-D clippy::match-like-matches-macro` implied by `-D warnings`\n+\n+error: aborting due to 8 previous errors\n "}, {"sha": "36bc52e3374e1a9747ddfdcad7da7306963bb092", "filename": "src/tools/clippy/tests/ui/mut_mutex_lock.fixed", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmut_mutex_lock.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmut_mutex_lock.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmut_mutex_lock.fixed?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -0,0 +1,21 @@\n+// run-rustfix\n+#![allow(dead_code, unused_mut)]\n+#![warn(clippy::mut_mutex_lock)]\n+\n+use std::sync::{Arc, Mutex};\n+\n+fn mut_mutex_lock() {\n+    let mut value_rc = Arc::new(Mutex::new(42_u8));\n+    let value_mutex = Arc::get_mut(&mut value_rc).unwrap();\n+\n+    let mut value = value_mutex.get_mut().unwrap();\n+    *value += 1;\n+}\n+\n+fn no_owned_mutex_lock() {\n+    let mut value_rc = Arc::new(Mutex::new(42_u8));\n+    let mut value = value_rc.lock().unwrap();\n+    *value += 1;\n+}\n+\n+fn main() {}"}, {"sha": "ea60df5ae1bbc92cda19453e4756aefea50833b3", "filename": "src/tools/clippy/tests/ui/mut_mutex_lock.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmut_mutex_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmut_mutex_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmut_mutex_lock.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -0,0 +1,21 @@\n+// run-rustfix\n+#![allow(dead_code, unused_mut)]\n+#![warn(clippy::mut_mutex_lock)]\n+\n+use std::sync::{Arc, Mutex};\n+\n+fn mut_mutex_lock() {\n+    let mut value_rc = Arc::new(Mutex::new(42_u8));\n+    let value_mutex = Arc::get_mut(&mut value_rc).unwrap();\n+\n+    let mut value = value_mutex.lock().unwrap();\n+    *value += 1;\n+}\n+\n+fn no_owned_mutex_lock() {\n+    let mut value_rc = Arc::new(Mutex::new(42_u8));\n+    let mut value = value_rc.lock().unwrap();\n+    *value += 1;\n+}\n+\n+fn main() {}"}, {"sha": "21c1b3486cacf5f2a23a90c16e02e268b8ff0f6b", "filename": "src/tools/clippy/tests/ui/mut_mutex_lock.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmut_mutex_lock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmut_mutex_lock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmut_mutex_lock.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -0,0 +1,10 @@\n+error: calling `&mut Mutex::lock` unnecessarily locks an exclusive (mutable) reference\n+  --> $DIR/mut_mutex_lock.rs:11:33\n+   |\n+LL |     let mut value = value_mutex.lock().unwrap();\n+   |                                 ^^^^ help: change this to: `get_mut`\n+   |\n+   = note: `-D clippy::mut-mutex-lock` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "4f6e53577273cf1b05cc33ca9aaed6a3260abf62", "filename": "src/tools/clippy/tests/ui/needless_collect_indirect.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect_indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect_indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect_indirect.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -16,4 +16,10 @@ fn main() {\n         .into_iter()\n         .map(|x| (*x, *x + 1))\n         .collect::<HashMap<_, _>>();\n+\n+    // #6202\n+    let a = \"a\".to_string();\n+    let sample = vec![a.clone(), \"b\".to_string(), \"c\".to_string()];\n+    let non_copy_contains = sample.into_iter().collect::<Vec<_>>();\n+    non_copy_contains.contains(&a);\n }"}, {"sha": "fb807da5f8abee5b3339dcfffe92eb6e16532264", "filename": "src/tools/clippy/tests/ui/needless_collect_indirect.stderr", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect_indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect_indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect_indirect.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -48,8 +48,21 @@ LL | |     indirect_contains.contains(&&5);\n help: Check if the original Iterator contains an element instead of collecting then checking\n    |\n LL |     \n-LL |     sample.iter().any(|x| x == &&5);\n+LL |     sample.iter().any(|x| x == &5);\n    |\n \n-error: aborting due to 4 previous errors\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:23:5\n+   |\n+LL | /     let non_copy_contains = sample.into_iter().collect::<Vec<_>>();\n+LL | |     non_copy_contains.contains(&a);\n+   | |____^\n+   |\n+help: Check if the original Iterator contains an element instead of collecting then checking\n+   |\n+LL |     \n+LL |     sample.into_iter().any(|x| x == a);\n+   |\n+\n+error: aborting due to 5 previous errors\n "}, {"sha": "6001ef37eb781cbb497397e1cbbdb74fd0d7bcb6", "filename": "src/tools/clippy/tests/ui/needless_lifetimes.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_lifetimes.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -357,4 +357,15 @@ mod nested_elision_sites {\n     }\n }\n \n+mod issue6159 {\n+    use std::ops::Deref;\n+    pub fn apply_deref<'a, T, F, R>(x: &'a T, f: F) -> R\n+    where\n+        T: Deref,\n+        F: FnOnce(&'a T::Target) -> R,\n+    {\n+        f(x.deref())\n+    }\n+}\n+\n fn main() {}"}, {"sha": "632a6592a28b84b6831c29dd4e65bb90143d0dbb", "filename": "src/tools/clippy/tests/ui/range_contains.fixed", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_contains.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_contains.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_contains.fixed?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -0,0 +1,41 @@\n+// run-rustfix\n+\n+#[warn(clippy::manual_range_contains)]\n+#[allow(unused)]\n+#[allow(clippy::no_effect)]\n+#[allow(clippy::short_circuit_statement)]\n+#[allow(clippy::unnecessary_operation)]\n+fn main() {\n+    let x = 9_u32;\n+\n+    // order shouldn't matter\n+    (8..12).contains(&x);\n+    (21..42).contains(&x);\n+    (1..100).contains(&x);\n+\n+    // also with inclusive ranges\n+    (9..=99).contains(&x);\n+    (1..=33).contains(&x);\n+    (1..=999).contains(&x);\n+\n+    // and the outside\n+    !(8..12).contains(&x);\n+    !(21..42).contains(&x);\n+    !(1..100).contains(&x);\n+\n+    // also with the outside of inclusive ranges\n+    !(9..=99).contains(&x);\n+    !(1..=33).contains(&x);\n+    !(1..=999).contains(&x);\n+\n+    // not a range.contains\n+    x > 8 && x < 12; // lower bound not inclusive\n+    x < 8 && x <= 12; // same direction\n+    x >= 12 && 12 >= x; // same bounds\n+    x < 8 && x > 12; // wrong direction\n+\n+    x <= 8 || x >= 12;\n+    x >= 8 || x >= 12;\n+    x < 12 || 12 < x;\n+    x >= 8 || x <= 12;\n+}"}, {"sha": "6af0d034ef617b25576507cf407b79a59879ba70", "filename": "src/tools/clippy/tests/ui/range_contains.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_contains.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -0,0 +1,41 @@\n+// run-rustfix\n+\n+#[warn(clippy::manual_range_contains)]\n+#[allow(unused)]\n+#[allow(clippy::no_effect)]\n+#[allow(clippy::short_circuit_statement)]\n+#[allow(clippy::unnecessary_operation)]\n+fn main() {\n+    let x = 9_u32;\n+\n+    // order shouldn't matter\n+    x >= 8 && x < 12;\n+    x < 42 && x >= 21;\n+    100 > x && 1 <= x;\n+\n+    // also with inclusive ranges\n+    x >= 9 && x <= 99;\n+    x <= 33 && x >= 1;\n+    999 >= x && 1 <= x;\n+\n+    // and the outside\n+    x < 8 || x >= 12;\n+    x >= 42 || x < 21;\n+    100 <= x || 1 > x;\n+\n+    // also with the outside of inclusive ranges\n+    x < 9 || x > 99;\n+    x > 33 || x < 1;\n+    999 < x || 1 > x;\n+\n+    // not a range.contains\n+    x > 8 && x < 12; // lower bound not inclusive\n+    x < 8 && x <= 12; // same direction\n+    x >= 12 && 12 >= x; // same bounds\n+    x < 8 && x > 12; // wrong direction\n+\n+    x <= 8 || x >= 12;\n+    x >= 8 || x >= 12;\n+    x < 12 || 12 < x;\n+    x >= 8 || x <= 12;\n+}"}, {"sha": "69b009eafc30ab589f603f5d9c166072e560d173", "filename": "src/tools/clippy/tests/ui/range_contains.stderr", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_contains.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_contains.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_contains.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -0,0 +1,76 @@\n+error: manual `Range::contains` implementation\n+  --> $DIR/range_contains.rs:12:5\n+   |\n+LL |     x >= 8 && x < 12;\n+   |     ^^^^^^^^^^^^^^^^ help: use: `(8..12).contains(&x)`\n+   |\n+   = note: `-D clippy::manual-range-contains` implied by `-D warnings`\n+\n+error: manual `Range::contains` implementation\n+  --> $DIR/range_contains.rs:13:5\n+   |\n+LL |     x < 42 && x >= 21;\n+   |     ^^^^^^^^^^^^^^^^^ help: use: `(21..42).contains(&x)`\n+\n+error: manual `Range::contains` implementation\n+  --> $DIR/range_contains.rs:14:5\n+   |\n+LL |     100 > x && 1 <= x;\n+   |     ^^^^^^^^^^^^^^^^^ help: use: `(1..100).contains(&x)`\n+\n+error: manual `RangeInclusive::contains` implementation\n+  --> $DIR/range_contains.rs:17:5\n+   |\n+LL |     x >= 9 && x <= 99;\n+   |     ^^^^^^^^^^^^^^^^^ help: use: `(9..=99).contains(&x)`\n+\n+error: manual `RangeInclusive::contains` implementation\n+  --> $DIR/range_contains.rs:18:5\n+   |\n+LL |     x <= 33 && x >= 1;\n+   |     ^^^^^^^^^^^^^^^^^ help: use: `(1..=33).contains(&x)`\n+\n+error: manual `RangeInclusive::contains` implementation\n+  --> $DIR/range_contains.rs:19:5\n+   |\n+LL |     999 >= x && 1 <= x;\n+   |     ^^^^^^^^^^^^^^^^^^ help: use: `(1..=999).contains(&x)`\n+\n+error: manual `!Range::contains` implementation\n+  --> $DIR/range_contains.rs:22:5\n+   |\n+LL |     x < 8 || x >= 12;\n+   |     ^^^^^^^^^^^^^^^^ help: use: `!(8..12).contains(&x)`\n+\n+error: manual `!Range::contains` implementation\n+  --> $DIR/range_contains.rs:23:5\n+   |\n+LL |     x >= 42 || x < 21;\n+   |     ^^^^^^^^^^^^^^^^^ help: use: `!(21..42).contains(&x)`\n+\n+error: manual `!Range::contains` implementation\n+  --> $DIR/range_contains.rs:24:5\n+   |\n+LL |     100 <= x || 1 > x;\n+   |     ^^^^^^^^^^^^^^^^^ help: use: `!(1..100).contains(&x)`\n+\n+error: manual `!RangeInclusive::contains` implementation\n+  --> $DIR/range_contains.rs:27:5\n+   |\n+LL |     x < 9 || x > 99;\n+   |     ^^^^^^^^^^^^^^^ help: use: `!(9..=99).contains(&x)`\n+\n+error: manual `!RangeInclusive::contains` implementation\n+  --> $DIR/range_contains.rs:28:5\n+   |\n+LL |     x > 33 || x < 1;\n+   |     ^^^^^^^^^^^^^^^ help: use: `!(1..=33).contains(&x)`\n+\n+error: manual `!RangeInclusive::contains` implementation\n+  --> $DIR/range_contains.rs:29:5\n+   |\n+LL |     999 < x || 1 > x;\n+   |     ^^^^^^^^^^^^^^^^ help: use: `!(1..=999).contains(&x)`\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "8ca068293a611455cd246bd1d5a16b73456027c7", "filename": "src/tools/clippy/tests/ui/single_element_loop.fixed", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_element_loop.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_element_loop.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_element_loop.fixed?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -0,0 +1,11 @@\n+// run-rustfix\n+// Tests from for_loop.rs that don't have suggestions\n+\n+#[warn(clippy::single_element_loop)]\n+fn main() {\n+    let item1 = 2;\n+    {\n+        let item = &item1;\n+        println!(\"{}\", item);\n+    }\n+}"}, {"sha": "57e9336a31fcf6c3d775273f7c7a78bedee5c0cf", "filename": "src/tools/clippy/tests/ui/single_element_loop.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_element_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_element_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_element_loop.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -0,0 +1,10 @@\n+// run-rustfix\n+// Tests from for_loop.rs that don't have suggestions\n+\n+#[warn(clippy::single_element_loop)]\n+fn main() {\n+    let item1 = 2;\n+    for item in &[item1] {\n+        println!(\"{}\", item);\n+    }\n+}"}, {"sha": "90be1dc328371f6bc611cc236bd14b31f600d6e1", "filename": "src/tools/clippy/tests/ui/single_element_loop.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_element_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_element_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_element_loop.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -0,0 +1,19 @@\n+error: for loop over a single element\n+  --> $DIR/single_element_loop.rs:7:5\n+   |\n+LL | /     for item in &[item1] {\n+LL | |         println!(\"{}\", item);\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::single-element-loop` implied by `-D warnings`\n+help: try\n+   |\n+LL |     {\n+LL |         let item = &item1;\n+LL |         println!(\"{}\", item);\n+LL |     }\n+   |\n+\n+error: aborting due to previous error\n+"}, {"sha": "f4cfc92e1cd0259eddc426dce698b54ee4c7b61d", "filename": "src/tools/clippy/tests/ui/undropped_manually_drops.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fundropped_manually_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fundropped_manually_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fundropped_manually_drops.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -0,0 +1,26 @@\n+#![warn(clippy::undropped_manually_drops)]\n+\n+struct S;\n+\n+fn main() {\n+    let f = std::mem::drop;\n+    let g = std::mem::ManuallyDrop::drop;\n+    let mut manual1 = std::mem::ManuallyDrop::new(S);\n+    let mut manual2 = std::mem::ManuallyDrop::new(S);\n+    let mut manual3 = std::mem::ManuallyDrop::new(S);\n+    let mut manual4 = std::mem::ManuallyDrop::new(S);\n+\n+    // These lines will not drop `S` and should be linted\n+    drop(std::mem::ManuallyDrop::new(S));\n+    drop(manual1);\n+\n+    // FIXME: this line is not linted, though it should be\n+    f(manual2);\n+\n+    // These lines will drop `S` and should be okay.\n+    unsafe {\n+        std::mem::ManuallyDrop::drop(&mut std::mem::ManuallyDrop::new(S));\n+        std::mem::ManuallyDrop::drop(&mut manual3);\n+        g(&mut manual4);\n+    }\n+}"}, {"sha": "2ac0fe98697efce7dfe01155e2637e51fe4e53fb", "filename": "src/tools/clippy/tests/ui/undropped_manually_drops.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fundropped_manually_drops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fundropped_manually_drops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fundropped_manually_drops.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -0,0 +1,19 @@\n+error: the inner value of this ManuallyDrop will not be dropped\n+  --> $DIR/undropped_manually_drops.rs:14:5\n+   |\n+LL |     drop(std::mem::ManuallyDrop::new(S));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::undropped-manually-drops` implied by `-D warnings`\n+   = help: to drop a `ManuallyDrop<T>`, use std::mem::ManuallyDrop::drop\n+\n+error: the inner value of this ManuallyDrop will not be dropped\n+  --> $DIR/undropped_manually_drops.rs:15:5\n+   |\n+LL |     drop(manual1);\n+   |     ^^^^^^^^^^^^^\n+   |\n+   = help: to drop a `ManuallyDrop<T>`, use std::mem::ManuallyDrop::drop\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "350da4965d11d9323433b7cf33631f1fd7e3e0a7", "filename": "src/tools/clippy/tests/ui/unnecessary_cast_fixable.fixed", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast_fixable.fixed?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -8,16 +8,31 @@ fn main() {\n     100_f32;\n     100_f64;\n     100_f64;\n+    let _ = -100_f32;\n+    let _ = -100_f64;\n+    let _ = -100_f64;\n     // Should not trigger\n     #[rustfmt::skip]\n     let v = vec!(1);\n     &v as &[i32];\n-    1.0 as f64;\n-    1 as u64;\n     0x10 as f32;\n     0o10 as f32;\n     0b10 as f32;\n     0x11 as f64;\n     0o11 as f64;\n     0b11 as f64;\n+\n+    1_u32;\n+    0x10_i32;\n+    0b10_usize;\n+    0o73_u16;\n+    1_000_000_000_u32;\n+\n+    1.0_f64;\n+    0.5_f32;\n+\n+    1.0 as u16;\n+\n+    let _ = -1_i32;\n+    let _ = -1.0_f32;\n }"}, {"sha": "ad2fb2e628921477fad7cf24c73e87a00b681898", "filename": "src/tools/clippy/tests/ui/unnecessary_cast_fixable.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast_fixable.rs?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -8,16 +8,31 @@ fn main() {\n     100 as f32;\n     100 as f64;\n     100_i32 as f64;\n+    let _ = -100 as f32;\n+    let _ = -100 as f64;\n+    let _ = -100_i32 as f64;\n     // Should not trigger\n     #[rustfmt::skip]\n     let v = vec!(1);\n     &v as &[i32];\n-    1.0 as f64;\n-    1 as u64;\n     0x10 as f32;\n     0o10 as f32;\n     0b10 as f32;\n     0x11 as f64;\n     0o11 as f64;\n     0b11 as f64;\n+\n+    1 as u32;\n+    0x10 as i32;\n+    0b10 as usize;\n+    0o73 as u16;\n+    1_000_000_000 as u32;\n+\n+    1.0 as f64;\n+    0.5 as f32;\n+\n+    1.0 as u16;\n+\n+    let _ = -1 as i32;\n+    let _ = -1.0 as f32;\n }"}, {"sha": "5a210fc89097bcdc7f5c93260b08ae89709849ed", "filename": "src/tools/clippy/tests/ui/unnecessary_cast_fixable.stderr", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast_fixable.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -18,5 +18,77 @@ error: casting integer literal to `f64` is unnecessary\n LL |     100_i32 as f64;\n    |     ^^^^^^^^^^^^^^ help: try: `100_f64`\n \n-error: aborting due to 3 previous errors\n+error: casting integer literal to `f32` is unnecessary\n+  --> $DIR/unnecessary_cast_fixable.rs:11:13\n+   |\n+LL |     let _ = -100 as f32;\n+   |             ^^^^^^^^^^^ help: try: `-100_f32`\n+\n+error: casting integer literal to `f64` is unnecessary\n+  --> $DIR/unnecessary_cast_fixable.rs:12:13\n+   |\n+LL |     let _ = -100 as f64;\n+   |             ^^^^^^^^^^^ help: try: `-100_f64`\n+\n+error: casting integer literal to `f64` is unnecessary\n+  --> $DIR/unnecessary_cast_fixable.rs:13:13\n+   |\n+LL |     let _ = -100_i32 as f64;\n+   |             ^^^^^^^^^^^^^^^ help: try: `-100_f64`\n+\n+error: casting integer literal to `u32` is unnecessary\n+  --> $DIR/unnecessary_cast_fixable.rs:25:5\n+   |\n+LL |     1 as u32;\n+   |     ^^^^^^^^ help: try: `1_u32`\n+\n+error: casting integer literal to `i32` is unnecessary\n+  --> $DIR/unnecessary_cast_fixable.rs:26:5\n+   |\n+LL |     0x10 as i32;\n+   |     ^^^^^^^^^^^ help: try: `0x10_i32`\n+\n+error: casting integer literal to `usize` is unnecessary\n+  --> $DIR/unnecessary_cast_fixable.rs:27:5\n+   |\n+LL |     0b10 as usize;\n+   |     ^^^^^^^^^^^^^ help: try: `0b10_usize`\n+\n+error: casting integer literal to `u16` is unnecessary\n+  --> $DIR/unnecessary_cast_fixable.rs:28:5\n+   |\n+LL |     0o73 as u16;\n+   |     ^^^^^^^^^^^ help: try: `0o73_u16`\n+\n+error: casting integer literal to `u32` is unnecessary\n+  --> $DIR/unnecessary_cast_fixable.rs:29:5\n+   |\n+LL |     1_000_000_000 as u32;\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: try: `1_000_000_000_u32`\n+\n+error: casting float literal to `f64` is unnecessary\n+  --> $DIR/unnecessary_cast_fixable.rs:31:5\n+   |\n+LL |     1.0 as f64;\n+   |     ^^^^^^^^^^ help: try: `1.0_f64`\n+\n+error: casting float literal to `f32` is unnecessary\n+  --> $DIR/unnecessary_cast_fixable.rs:32:5\n+   |\n+LL |     0.5 as f32;\n+   |     ^^^^^^^^^^ help: try: `0.5_f32`\n+\n+error: casting integer literal to `i32` is unnecessary\n+  --> $DIR/unnecessary_cast_fixable.rs:36:13\n+   |\n+LL |     let _ = -1 as i32;\n+   |             ^^^^^^^^^ help: try: `-1_i32`\n+\n+error: casting float literal to `f32` is unnecessary\n+  --> $DIR/unnecessary_cast_fixable.rs:37:13\n+   |\n+LL |     let _ = -1.0 as f32;\n+   |             ^^^^^^^^^^^ help: try: `-1.0_f32`\n+\n+error: aborting due to 15 previous errors\n "}, {"sha": "4043d53299f6b0ca219892ade384801523d5ed3a", "filename": "src/tools/clippy/tests/ui/unreadable_literal.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funreadable_literal.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funreadable_literal.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funreadable_literal.fixed?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -14,7 +14,7 @@ fn main() {\n     let _good = (\n         0b1011_i64,\n         0o1_234_u32,\n-        0x1_234_567,\n+        0x0123_4567,\n         65536,\n         1_2345_6789,\n         1234_f32,"}, {"sha": "8645cabeabbbc92dfe8a7a0a16e57f4d82bb990c", "filename": "src/tools/clippy/tests/ui/unreadable_literal.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funreadable_literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funreadable_literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funreadable_literal.stderr?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1,3 +1,11 @@\n+error: digits of hex or binary literal not grouped by four\n+  --> $DIR/unreadable_literal.rs:17:9\n+   |\n+LL |         0x1_234_567,\n+   |         ^^^^^^^^^^^ help: consider: `0x0123_4567`\n+   |\n+   = note: `-D clippy::unusual-byte-groupings` implied by `-D warnings`\n+\n error: long literal lacking separators\n   --> $DIR/unreadable_literal.rs:25:17\n    |\n@@ -54,5 +62,5 @@ error: long literal lacking separators\n LL |     let _fail12: i128 = 0xabcabcabcabcabcabc;\n    |                         ^^^^^^^^^^^^^^^^^^^^ help: consider: `0x00ab_cabc_abca_bcab_cabc`\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 10 previous errors\n "}, {"sha": "b7b20b40e68a5fa3e3f001224bc1c79d50bae933", "filename": "src/tools/clippy/triagebot.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftriagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a3d7a5e94507e3d6618790187bd85250ced82c4f/src%2Ftools%2Fclippy%2Ftriagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftriagebot.toml?ref=a3d7a5e94507e3d6618790187bd85250ced82c4f", "patch": "@@ -1,7 +1,7 @@\n [relabel]\n allow-unauthenticated = [\n-    \"C-*\", \"A-*\", \"E-*\", \"L-*\", \"M-*\", \"O-*\", \"S-*\",\n-    \"good first issue\", \"needs test\"\n+    \"A-*\", \"C-*\", \"E-*\", \"L-*\", \"M-*\", \"O-*\", \"P-*\", \"S-*\", \"T-*\",\n+    \"good first issue\"\n ]\n \n [assign]"}]}