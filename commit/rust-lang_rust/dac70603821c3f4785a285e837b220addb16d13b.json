{"sha": "dac70603821c3f4785a285e837b220addb16d13b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhYzcwNjAzODIxYzNmNDc4NWEyODVlODM3YjIyMGFkZGIxNmQxM2I=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-11-07T18:21:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-07T18:21:11Z"}, "message": "Merge #6476\n\n6476: Add missing AssocItems in add_custom_impl assist r=matklad a=Veykril\n\n```rust\r\nuse std::fmt;\r\n\r\n#[derive(Debu<|>g)]\r\nstruct Foo {\r\n    bar: String,\r\n}\r\n```\r\n->\r\n```rust\r\nuse std::fmt;\r\n\r\nstruct Foo {\r\n    bar: String,\r\n}\r\n\r\nimpl fmt::Debug for Foo {\r\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\r\n        ${0:todo!()}\r\n    }\r\n}\r\n```\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "a0adc6df6a84b57bcba97fd1835a2da8020f5258", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0adc6df6a84b57bcba97fd1835a2da8020f5258"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dac70603821c3f4785a285e837b220addb16d13b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfpuWXCRBK7hj4Ov3rIwAAdHIIAF5dEP/CQ/lYdXcMVtlakKdC\n+g4GJ8tpl4Kupeyuk7wb7SqFex0AFwn8iuhGeTenZAAB6LhRcyeZUjGnKO32avPR\nIGkf+caVqvM1wfxNxh4u1+/cDXKHeVrq4Z6sqv/sjtb2FfcxdvgrYGOL7PDUegvR\n7l26aG7SrExM0zZF4I/DJEy/+KvDjMHNj23xWJhxEDeFm5yQoHc/5o9L7Y9YtMLq\nusmy4liLau0cBASyUBhdXFiSpI7ky/eEMkNyRAWjqvkHc9yjRPvZPsNKe7ZF22f9\nMhxEm6hIyvaA615yyn7etJ6JLy6MbFxKE/wrWhxDJq7NegzcA6n6RQYJm9YVlYE=\n=8kxj\n-----END PGP SIGNATURE-----\n", "payload": "tree a0adc6df6a84b57bcba97fd1835a2da8020f5258\nparent f3fe6561c00a07a7d6131db42983cbc3eb658957\nparent 19443c1fa30e5a360c84f82d0b7aac733ea2e240\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1604773271 +0000\ncommitter GitHub <noreply@github.com> 1604773271 +0000\n\nMerge #6476\n\n6476: Add missing AssocItems in add_custom_impl assist r=matklad a=Veykril\n\n```rust\r\nuse std::fmt;\r\n\r\n#[derive(Debu<|>g)]\r\nstruct Foo {\r\n    bar: String,\r\n}\r\n```\r\n->\r\n```rust\r\nuse std::fmt;\r\n\r\nstruct Foo {\r\n    bar: String,\r\n}\r\n\r\nimpl fmt::Debug for Foo {\r\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\r\n        ${0:todo!()}\r\n    }\r\n}\r\n```\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dac70603821c3f4785a285e837b220addb16d13b", "html_url": "https://github.com/rust-lang/rust/commit/dac70603821c3f4785a285e837b220addb16d13b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dac70603821c3f4785a285e837b220addb16d13b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3fe6561c00a07a7d6131db42983cbc3eb658957", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3fe6561c00a07a7d6131db42983cbc3eb658957", "html_url": "https://github.com/rust-lang/rust/commit/f3fe6561c00a07a7d6131db42983cbc3eb658957"}, {"sha": "19443c1fa30e5a360c84f82d0b7aac733ea2e240", "url": "https://api.github.com/repos/rust-lang/rust/commits/19443c1fa30e5a360c84f82d0b7aac733ea2e240", "html_url": "https://github.com/rust-lang/rust/commit/19443c1fa30e5a360c84f82d0b7aac733ea2e240"}], "stats": {"total": 350, "additions": 240, "deletions": 110}, "files": [{"sha": "c13493fd87ccd28d475d0b13e1667a2fe47f62ba", "filename": "crates/assists/src/handlers/add_custom_impl.rs", "status": "modified", "additions": 131, "deletions": 30, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/dac70603821c3f4785a285e837b220addb16d13b/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dac70603821c3f4785a285e837b220addb16d13b/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs?ref=dac70603821c3f4785a285e837b220addb16d13b", "patch": "@@ -4,13 +4,15 @@ use syntax::{\n     ast::{self, make, AstNode},\n     Direction, SmolStr,\n     SyntaxKind::{IDENT, WHITESPACE},\n-    TextRange, TextSize,\n+    TextSize,\n };\n \n use crate::{\n-    assist_config::SnippetCap,\n     assist_context::{AssistBuilder, AssistContext, Assists},\n-    utils::mod_path_to_ast,\n+    utils::{\n+        add_trait_assoc_items_to_impl, filter_assoc_items, mod_path_to_ast, render_snippet, Cursor,\n+        DefaultMethods,\n+    },\n     AssistId, AssistKind,\n };\n \n@@ -47,11 +49,10 @@ pub(crate) fn add_custom_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<\n         ctx.token_at_offset().find(|t| t.kind() == IDENT && *t.text() != attr_name)?;\n     let trait_path = make::path_unqualified(make::path_segment(make::name_ref(trait_token.text())));\n \n-    let annotated = attr.syntax().siblings(Direction::Next).find_map(ast::Name::cast)?;\n-    let annotated_name = annotated.syntax().text().to_string();\n-    let insert_pos = annotated.syntax().parent()?.text_range().end();\n+    let annotated_name = attr.syntax().siblings(Direction::Next).find_map(ast::Name::cast)?;\n+    let insert_pos = annotated_name.syntax().parent()?.text_range().end();\n \n-    let current_module = ctx.sema.scope(annotated.syntax()).module()?;\n+    let current_module = ctx.sema.scope(annotated_name.syntax()).module()?;\n     let current_crate = current_module.krate();\n \n     let found_traits = imports_locator::find_imports(&ctx.sema, current_crate, trait_token.text())\n@@ -69,21 +70,22 @@ pub(crate) fn add_custom_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<\n         });\n \n     let mut no_traits_found = true;\n-    for (trait_path, _trait) in found_traits.inspect(|_| no_traits_found = false) {\n-        add_assist(acc, ctx.config.snippet_cap, &attr, &trait_path, &annotated_name, insert_pos)?;\n+    for (trait_path, trait_) in found_traits.inspect(|_| no_traits_found = false) {\n+        add_assist(acc, ctx, &attr, &trait_path, Some(trait_), &annotated_name, insert_pos)?;\n     }\n     if no_traits_found {\n-        add_assist(acc, ctx.config.snippet_cap, &attr, &trait_path, &annotated_name, insert_pos)?;\n+        add_assist(acc, ctx, &attr, &trait_path, None, &annotated_name, insert_pos)?;\n     }\n     Some(())\n }\n \n fn add_assist(\n     acc: &mut Assists,\n-    snippet_cap: Option<SnippetCap>,\n+    ctx: &AssistContext,\n     attr: &ast::Attr,\n     trait_path: &ast::Path,\n-    annotated_name: &str,\n+    trait_: Option<hir::Trait>,\n+    annotated_name: &ast::Name,\n     insert_pos: TextSize,\n ) -> Option<()> {\n     let target = attr.syntax().text_range();\n@@ -92,25 +94,62 @@ fn add_assist(\n     let trait_name = trait_path.segment().and_then(|seg| seg.name_ref())?;\n \n     acc.add(AssistId(\"add_custom_impl\", AssistKind::Refactor), label, target, |builder| {\n+        let impl_def_with_items =\n+            impl_def_from_trait(&ctx.sema, annotated_name, trait_, trait_path);\n         update_attribute(builder, &input, &trait_name, &attr);\n-        match snippet_cap {\n-            Some(cap) => {\n+        match (ctx.config.snippet_cap, impl_def_with_items) {\n+            (None, _) => builder.insert(\n+                insert_pos,\n+                format!(\"\\n\\nimpl {} for {} {{\\n\\n}}\", trait_path, annotated_name),\n+            ),\n+            (Some(cap), None) => builder.insert_snippet(\n+                cap,\n+                insert_pos,\n+                format!(\"\\n\\nimpl {} for {} {{\\n    $0\\n}}\", trait_path, annotated_name),\n+            ),\n+            (Some(cap), Some((impl_def, first_assoc_item))) => {\n+                let mut cursor = Cursor::Before(first_assoc_item.syntax());\n+                let placeholder;\n+                if let ast::AssocItem::Fn(ref func) = first_assoc_item {\n+                    if let Some(m) = func.syntax().descendants().find_map(ast::MacroCall::cast) {\n+                        if m.syntax().text() == \"todo!()\" {\n+                            placeholder = m;\n+                            cursor = Cursor::Replace(placeholder.syntax());\n+                        }\n+                    }\n+                }\n+\n                 builder.insert_snippet(\n                     cap,\n                     insert_pos,\n-                    format!(\"\\n\\nimpl {} for {} {{\\n    $0\\n}}\", trait_path, annotated_name),\n-                );\n-            }\n-            None => {\n-                builder.insert(\n-                    insert_pos,\n-                    format!(\"\\n\\nimpl {} for {} {{\\n\\n}}\", trait_path, annotated_name),\n-                );\n+                    format!(\"\\n\\n{}\", render_snippet(cap, impl_def.syntax(), cursor)),\n+                )\n             }\n-        }\n+        };\n     })\n }\n \n+fn impl_def_from_trait(\n+    sema: &hir::Semantics<ide_db::RootDatabase>,\n+    annotated_name: &ast::Name,\n+    trait_: Option<hir::Trait>,\n+    trait_path: &ast::Path,\n+) -> Option<(ast::Impl, ast::AssocItem)> {\n+    let trait_ = trait_?;\n+    let target_scope = sema.scope(annotated_name.syntax());\n+    let trait_items = filter_assoc_items(sema.db, &trait_.items(sema.db), DefaultMethods::No);\n+    if trait_items.is_empty() {\n+        return None;\n+    }\n+    let impl_def = make::impl_trait(\n+        trait_path.clone(),\n+        make::path_unqualified(make::path_segment(make::name_ref(annotated_name.text()))),\n+    );\n+    let (impl_def, first_assoc_item) =\n+        add_trait_assoc_items_to_impl(sema, trait_items, trait_, impl_def, target_scope);\n+    Some((impl_def, first_assoc_item))\n+}\n+\n fn update_attribute(\n     builder: &mut AssistBuilder,\n     input: &ast::TokenTree,\n@@ -133,13 +172,14 @@ fn update_attribute(\n         let attr_range = attr.syntax().text_range();\n         builder.delete(attr_range);\n \n-        let line_break_range = attr\n+        if let Some(line_break_range) = attr\n             .syntax()\n             .next_sibling_or_token()\n             .filter(|t| t.kind() == WHITESPACE)\n             .map(|t| t.text_range())\n-            .unwrap_or_else(|| TextRange::new(TextSize::from(0), TextSize::from(0)));\n-        builder.delete(line_break_range);\n+        {\n+            builder.delete(line_break_range);\n+        }\n     }\n }\n \n@@ -150,12 +190,17 @@ mod tests {\n     use super::*;\n \n     #[test]\n-    fn add_custom_impl_qualified() {\n+    fn add_custom_impl_debug() {\n         check_assist(\n             add_custom_impl,\n             \"\n mod fmt {\n-    pub trait Debug {}\n+    pub struct Error;\n+    pub type Result = Result<(), Error>;\n+    pub struct Formatter<'a>;\n+    pub trait Debug {\n+        fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n+    }\n }\n \n #[derive(Debu<|>g)]\n@@ -165,15 +210,71 @@ struct Foo {\n \",\n             \"\n mod fmt {\n-    pub trait Debug {}\n+    pub struct Error;\n+    pub type Result = Result<(), Error>;\n+    pub struct Formatter<'a>;\n+    pub trait Debug {\n+        fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n+    }\n }\n \n struct Foo {\n     bar: String,\n }\n \n impl fmt::Debug for Foo {\n-    $0\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        ${0:todo!()}\n+    }\n+}\n+\",\n+        )\n+    }\n+    #[test]\n+    fn add_custom_impl_all() {\n+        check_assist(\n+            add_custom_impl,\n+            \"\n+mod foo {\n+    pub trait Bar {\n+        type Qux;\n+        const Baz: usize = 42;\n+        const Fez: usize;\n+        fn foo();\n+        fn bar() {}\n+    }\n+}\n+\n+#[derive(<|>Bar)]\n+struct Foo {\n+    bar: String,\n+}\n+\",\n+            \"\n+mod foo {\n+    pub trait Bar {\n+        type Qux;\n+        const Baz: usize = 42;\n+        const Fez: usize;\n+        fn foo();\n+        fn bar() {}\n+    }\n+}\n+\n+struct Foo {\n+    bar: String,\n+}\n+\n+impl foo::Bar for Foo {\n+    $0type Qux;\n+\n+    const Baz: usize = 42;\n+\n+    const Fez: usize;\n+\n+    fn foo() {\n+        todo!()\n+    }\n }\n \",\n         )"}, {"sha": "bbb71e261f3111d9b208b5b2472f2b5b16130615", "filename": "crates/assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 15, "deletions": 77, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/dac70603821c3f4785a285e837b220addb16d13b/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dac70603821c3f4785a285e837b220addb16d13b/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=dac70603821c3f4785a285e837b220addb16d13b", "patch": "@@ -1,27 +1,14 @@\n-use hir::HasSource;\n-use ide_db::traits::{get_missing_assoc_items, resolve_target_trait};\n-use syntax::{\n-    ast::{\n-        self,\n-        edit::{self, AstNodeEdit, IndentLevel},\n-        make, AstNode, NameOwner,\n-    },\n-    SmolStr,\n-};\n+use ide_db::traits::resolve_target_trait;\n+use syntax::ast::{self, AstNode};\n \n use crate::{\n     assist_context::{AssistContext, Assists},\n-    ast_transform::{self, AstTransform, QualifyPaths, SubstituteTypeParams},\n-    utils::{render_snippet, Cursor},\n+    utils::add_trait_assoc_items_to_impl,\n+    utils::DefaultMethods,\n+    utils::{filter_assoc_items, render_snippet, Cursor},\n     AssistId, AssistKind,\n };\n \n-#[derive(PartialEq)]\n-enum AddMissingImplMembersMode {\n-    DefaultMethodsOnly,\n-    NoDefaultMethods,\n-}\n-\n // Assist: add_impl_missing_members\n //\n // Adds scaffold for required impl members.\n@@ -55,7 +42,7 @@ pub(crate) fn add_missing_impl_members(acc: &mut Assists, ctx: &AssistContext) -\n     add_missing_impl_members_inner(\n         acc,\n         ctx,\n-        AddMissingImplMembersMode::NoDefaultMethods,\n+        DefaultMethods::No,\n         \"add_impl_missing_members\",\n         \"Implement missing members\",\n     )\n@@ -97,7 +84,7 @@ pub(crate) fn add_missing_default_members(acc: &mut Assists, ctx: &AssistContext\n     add_missing_impl_members_inner(\n         acc,\n         ctx,\n-        AddMissingImplMembersMode::DefaultMethodsOnly,\n+        DefaultMethods::Only,\n         \"add_impl_default_members\",\n         \"Implement default members\",\n     )\n@@ -106,70 +93,29 @@ pub(crate) fn add_missing_default_members(acc: &mut Assists, ctx: &AssistContext\n fn add_missing_impl_members_inner(\n     acc: &mut Assists,\n     ctx: &AssistContext,\n-    mode: AddMissingImplMembersMode,\n+    mode: DefaultMethods,\n     assist_id: &'static str,\n     label: &'static str,\n ) -> Option<()> {\n     let _p = profile::span(\"add_missing_impl_members_inner\");\n     let impl_def = ctx.find_node_at_offset::<ast::Impl>()?;\n     let trait_ = resolve_target_trait(&ctx.sema, &impl_def)?;\n \n-    let def_name = |item: &ast::AssocItem| -> Option<SmolStr> {\n-        match item {\n-            ast::AssocItem::Fn(def) => def.name(),\n-            ast::AssocItem::TypeAlias(def) => def.name(),\n-            ast::AssocItem::Const(def) => def.name(),\n-            ast::AssocItem::MacroCall(_) => None,\n-        }\n-        .map(|it| it.text().clone())\n-    };\n-\n-    let missing_items = get_missing_assoc_items(&ctx.sema, &impl_def)\n-        .iter()\n-        .map(|i| match i {\n-            hir::AssocItem::Function(i) => ast::AssocItem::Fn(i.source(ctx.db()).value),\n-            hir::AssocItem::TypeAlias(i) => ast::AssocItem::TypeAlias(i.source(ctx.db()).value),\n-            hir::AssocItem::Const(i) => ast::AssocItem::Const(i.source(ctx.db()).value),\n-        })\n-        .filter(|t| def_name(&t).is_some())\n-        .filter(|t| match t {\n-            ast::AssocItem::Fn(def) => match mode {\n-                AddMissingImplMembersMode::DefaultMethodsOnly => def.body().is_some(),\n-                AddMissingImplMembersMode::NoDefaultMethods => def.body().is_none(),\n-            },\n-            _ => mode == AddMissingImplMembersMode::NoDefaultMethods,\n-        })\n-        .collect::<Vec<_>>();\n+    let missing_items = filter_assoc_items(\n+        ctx.db(),\n+        &ide_db::traits::get_missing_assoc_items(&ctx.sema, &impl_def),\n+        mode,\n+    );\n \n     if missing_items.is_empty() {\n         return None;\n     }\n \n     let target = impl_def.syntax().text_range();\n     acc.add(AssistId(assist_id, AssistKind::QuickFix), label, target, |builder| {\n-        let impl_item_list = impl_def.assoc_item_list().unwrap_or_else(make::assoc_item_list);\n-\n-        let n_existing_items = impl_item_list.assoc_items().count();\n-        let source_scope = ctx.sema.scope_for_def(trait_);\n         let target_scope = ctx.sema.scope(impl_def.syntax());\n-        let ast_transform = QualifyPaths::new(&target_scope, &source_scope)\n-            .or(SubstituteTypeParams::for_trait_impl(&source_scope, trait_, impl_def.clone()));\n-\n-        let items = missing_items\n-            .into_iter()\n-            .map(|it| ast_transform::apply(&*ast_transform, it))\n-            .map(|it| match it {\n-                ast::AssocItem::Fn(def) => ast::AssocItem::Fn(add_body(def)),\n-                ast::AssocItem::TypeAlias(def) => ast::AssocItem::TypeAlias(def.remove_bounds()),\n-                _ => it,\n-            })\n-            .map(|it| edit::remove_attrs_and_docs(&it));\n-\n-        let new_impl_item_list = impl_item_list.append_items(items);\n-        let new_impl_def = impl_def.with_assoc_item_list(new_impl_item_list);\n-        let first_new_item =\n-            new_impl_def.assoc_item_list().unwrap().assoc_items().nth(n_existing_items).unwrap();\n-\n+        let (new_impl_def, first_new_item) =\n+            add_trait_assoc_items_to_impl(&ctx.sema, missing_items, trait_, impl_def, target_scope);\n         match ctx.config.snippet_cap {\n             None => builder.replace(target, new_impl_def.to_string()),\n             Some(cap) => {\n@@ -193,14 +139,6 @@ fn add_missing_impl_members_inner(\n     })\n }\n \n-fn add_body(fn_def: ast::Fn) -> ast::Fn {\n-    if fn_def.body().is_some() {\n-        return fn_def;\n-    }\n-    let body = make::block_expr(None, Some(make::expr_todo())).indent(IndentLevel(1));\n-    fn_def.with_body(body)\n-}\n-\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};"}, {"sha": "7071fe96b16cbb64569762bedfba3551ee63950d", "filename": "crates/assists/src/utils.rs", "status": "modified", "additions": 89, "deletions": 3, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/dac70603821c3f4785a285e837b220addb16d13b/crates%2Fassists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dac70603821c3f4785a285e837b220addb16d13b/crates%2Fassists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils.rs?ref=dac70603821c3f4785a285e837b220addb16d13b", "patch": "@@ -4,17 +4,22 @@ pub(crate) mod import_assets;\n \n use std::ops;\n \n-use hir::{Crate, Enum, Module, ScopeDef, Semantics, Trait};\n+use hir::{Crate, Enum, HasSource, Module, ScopeDef, Semantics, Trait};\n use ide_db::RootDatabase;\n use itertools::Itertools;\n use syntax::{\n-    ast::{self, make, ArgListOwner},\n+    ast::edit::AstNodeEdit,\n+    ast::NameOwner,\n+    ast::{self, edit, make, ArgListOwner},\n     AstNode, Direction,\n     SyntaxKind::*,\n     SyntaxNode, TextSize, T,\n };\n \n-use crate::assist_config::SnippetCap;\n+use crate::{\n+    assist_config::SnippetCap,\n+    ast_transform::{self, AstTransform, QualifyPaths, SubstituteTypeParams},\n+};\n \n pub use insert_use::MergeBehaviour;\n pub(crate) use insert_use::{insert_use, ImportScope};\n@@ -77,6 +82,87 @@ pub fn extract_trivial_expression(block: &ast::BlockExpr) -> Option<ast::Expr> {\n     None\n }\n \n+#[derive(Copy, Clone, PartialEq)]\n+pub enum DefaultMethods {\n+    Only,\n+    No,\n+}\n+\n+pub fn filter_assoc_items(\n+    db: &RootDatabase,\n+    items: &[hir::AssocItem],\n+    default_methods: DefaultMethods,\n+) -> Vec<ast::AssocItem> {\n+    fn has_def_name(item: &ast::AssocItem) -> bool {\n+        match item {\n+            ast::AssocItem::Fn(def) => def.name(),\n+            ast::AssocItem::TypeAlias(def) => def.name(),\n+            ast::AssocItem::Const(def) => def.name(),\n+            ast::AssocItem::MacroCall(_) => None,\n+        }\n+        .is_some()\n+    };\n+\n+    items\n+        .iter()\n+        .map(|i| match i {\n+            hir::AssocItem::Function(i) => ast::AssocItem::Fn(i.source(db).value),\n+            hir::AssocItem::TypeAlias(i) => ast::AssocItem::TypeAlias(i.source(db).value),\n+            hir::AssocItem::Const(i) => ast::AssocItem::Const(i.source(db).value),\n+        })\n+        .filter(has_def_name)\n+        .filter(|it| match it {\n+            ast::AssocItem::Fn(def) => matches!(\n+                (default_methods, def.body()),\n+                (DefaultMethods::Only, Some(_)) | (DefaultMethods::No, None)\n+            ),\n+            _ => default_methods == DefaultMethods::No,\n+        })\n+        .collect::<Vec<_>>()\n+}\n+\n+pub fn add_trait_assoc_items_to_impl(\n+    sema: &hir::Semantics<ide_db::RootDatabase>,\n+    items: Vec<ast::AssocItem>,\n+    trait_: hir::Trait,\n+    impl_def: ast::Impl,\n+    target_scope: hir::SemanticsScope,\n+) -> (ast::Impl, ast::AssocItem) {\n+    let impl_item_list = impl_def.assoc_item_list().unwrap_or_else(make::assoc_item_list);\n+\n+    let n_existing_items = impl_item_list.assoc_items().count();\n+    let source_scope = sema.scope_for_def(trait_);\n+    let ast_transform = QualifyPaths::new(&target_scope, &source_scope)\n+        .or(SubstituteTypeParams::for_trait_impl(&source_scope, trait_, impl_def.clone()));\n+\n+    let items = items\n+        .into_iter()\n+        .map(|it| ast_transform::apply(&*ast_transform, it))\n+        .map(|it| match it {\n+            ast::AssocItem::Fn(def) => ast::AssocItem::Fn(add_body(def)),\n+            ast::AssocItem::TypeAlias(def) => ast::AssocItem::TypeAlias(def.remove_bounds()),\n+            _ => it,\n+        })\n+        .map(|it| edit::remove_attrs_and_docs(&it));\n+\n+    let new_impl_item_list = impl_item_list.append_items(items);\n+    let new_impl_def = impl_def.with_assoc_item_list(new_impl_item_list);\n+    let first_new_item =\n+        new_impl_def.assoc_item_list().unwrap().assoc_items().nth(n_existing_items).unwrap();\n+    return (new_impl_def, first_new_item);\n+\n+    fn add_body(fn_def: ast::Fn) -> ast::Fn {\n+        match fn_def.body() {\n+            Some(_) => fn_def,\n+            None => {\n+                let body =\n+                    make::block_expr(None, Some(make::expr_todo())).indent(edit::IndentLevel(1));\n+                fn_def.with_body(body)\n+            }\n+        }\n+    }\n+}\n+\n #[derive(Clone, Copy, Debug)]\n pub(crate) enum Cursor<'a> {\n     Replace(&'a SyntaxNode),"}, {"sha": "876659a2b76a7796fc14bae095dc947f48e1a498", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dac70603821c3f4785a285e837b220addb16d13b/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dac70603821c3f4785a285e837b220addb16d13b/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=dac70603821c3f4785a285e837b220addb16d13b", "patch": "@@ -25,6 +25,10 @@ pub fn assoc_item_list() -> ast::AssocItemList {\n     ast_from_text(\"impl C for D {};\")\n }\n \n+pub fn impl_trait(trait_: ast::Path, ty: ast::Path) -> ast::Impl {\n+    ast_from_text(&format!(\"impl {} for {} {{}}\", trait_, ty))\n+}\n+\n pub fn path_segment(name_ref: ast::NameRef) -> ast::PathSegment {\n     ast_from_text(&format!(\"use {};\", name_ref))\n }"}, {"sha": "4c7db8405ec1e2ebb2dc2368cd7e8797cd8df466", "filename": "xtask/tests/tidy.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dac70603821c3f4785a285e837b220addb16d13b/xtask%2Ftests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dac70603821c3f4785a285e837b220addb16d13b/xtask%2Ftests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy.rs?ref=dac70603821c3f4785a285e837b220addb16d13b", "patch": "@@ -215,6 +215,7 @@ fn check_todo(path: &Path, text: &str) {\n         \"tests/cli.rs\",\n         // Some of our assists generate `todo!()`.\n         \"tests/generated.rs\",\n+        \"handlers/add_custom_impl.rs\",\n         \"handlers/add_missing_impl_members.rs\",\n         \"handlers/add_turbo_fish.rs\",\n         \"handlers/generate_function.rs\","}]}