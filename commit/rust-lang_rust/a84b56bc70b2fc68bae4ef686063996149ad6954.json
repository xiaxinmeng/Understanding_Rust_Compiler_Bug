{"sha": "a84b56bc70b2fc68bae4ef686063996149ad6954", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4NGI1NmJjNzBiMmZjNjhiYWU0ZWY2ODYwNjM5OTYxNDlhZDY5NTQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-23T13:45:47Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-23T13:45:47Z"}, "message": "Remove more needless context threading in trans", "tree": {"sha": "95f3eba37b94ea5bae3fd39bd0e785cff52b5ee5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95f3eba37b94ea5bae3fd39bd0e785cff52b5ee5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a84b56bc70b2fc68bae4ef686063996149ad6954", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a84b56bc70b2fc68bae4ef686063996149ad6954", "html_url": "https://github.com/rust-lang/rust/commit/a84b56bc70b2fc68bae4ef686063996149ad6954", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a84b56bc70b2fc68bae4ef686063996149ad6954/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5cfbbbc9ed32951cf568ac1ca98863a31fb68e35", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cfbbbc9ed32951cf568ac1ca98863a31fb68e35", "html_url": "https://github.com/rust-lang/rust/commit/5cfbbbc9ed32951cf568ac1ca98863a31fb68e35"}], "stats": {"total": 302, "additions": 125, "deletions": 177}, "files": [{"sha": "a3d5dba565a1579758661869432429de54edd0c1", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a84b56bc70b2fc68bae4ef686063996149ad6954/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a84b56bc70b2fc68bae4ef686063996149ad6954/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=a84b56bc70b2fc68bae4ef686063996149ad6954", "patch": "@@ -262,7 +262,6 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n    {vals: [ValueRef], bcx: block} {\n     let _icx = bcx.insn_ctxt(\"alt::extract_variant_args\");\n     let ccx = bcx.fcx.ccx;\n-    let mut bcx = bcx;\n     let enum_ty_substs = alt check ty::get(node_id_type(bcx, pat_id)).struct {\n       ty::ty_enum(id, tps) { assert id == vdefs.enm; tps }\n     };\n@@ -280,10 +279,8 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n     let vdefs_tg = vdefs.enm;\n     let vdefs_var = vdefs.var;\n     while i < size {\n-        let r = GEP_enum(bcx, blobptr, vdefs_tg, vdefs_var,\n-                         enum_ty_substs, i);\n-        bcx = r.bcx;\n-        args += [r.val];\n+        args += [GEP_enum(bcx, blobptr, vdefs_tg, vdefs_var,\n+                          enum_ty_substs, i)];\n         i += 1u;\n     }\n     ret {vals: args, bcx: bcx};\n@@ -597,10 +594,9 @@ fn make_phi_bindings(bcx: block, map: [exit_node],\n                         make_phi_bindings\"); }\n                 };\n                 let e_ty = node_id_type(bcx, node_id);\n-                let {bcx: abcx, val: alloc} = alloc_ty(bcx, e_ty);\n-                bcx = copy_val(abcx, INIT, alloc,\n-                                      load_if_immediate(abcx, local, e_ty),\n-                                      e_ty);\n+                let alloc = alloc_ty(bcx, e_ty);\n+                bcx = copy_val(bcx, INIT, alloc,\n+                               load_if_immediate(bcx, local, e_ty), e_ty);\n                 add_clean(bcx, alloc, e_ty);\n                 bcx.fcx.lllocals.insert(node_id, local_mem(alloc));\n             }\n@@ -659,7 +655,7 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: [ast::arm],\n     };\n     let mut exit_map = [];\n     let t = node_id_type(bcx, expr.id);\n-    let {bcx, val: spilled} = spill_if_immediate(bcx, val, t);\n+    let spilled = spill_if_immediate(bcx, val, t);\n     compile_submatch(bcx, match, [spilled], mk_fail, exit_map);\n \n     let mut arm_cxs = [], arm_dests = [], i = 0u;"}, {"sha": "1b6ad460e9ad9ad0b7239f519cd7ca5129e9df80", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 94, "deletions": 140, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/a84b56bc70b2fc68bae4ef686063996149ad6954/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a84b56bc70b2fc68bae4ef686063996149ad6954/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a84b56bc70b2fc68bae4ef686063996149ad6954", "patch": "@@ -284,7 +284,7 @@ fn bump_ptr(bcx: block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n // is meaningless, as it will be cast away.\n fn GEP_enum(bcx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n             variant_id: ast::def_id, ty_substs: [ty::t],\n-            ix: uint) -> result {\n+            ix: uint) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"GEP_enum\");\n     let ccx = bcx.ccx();\n     let variant = ty::enum_variant_with_id(ccx.tcx, enum_id, variant_id);\n@@ -295,16 +295,16 @@ fn GEP_enum(bcx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n     });\n     let typed_blobptr = PointerCast(bcx, llblobptr,\n                                     T_ptr(T_struct(arg_lltys)));\n-    rslt(bcx, GEPi(bcx, typed_blobptr, [0, ix as int]))\n+    GEPi(bcx, typed_blobptr, [0, ix as int])\n }\n \n // trans_shared_malloc: expects a type indicating which pointer type we want\n // and a size indicating how much space we want malloc'd.\n-fn trans_shared_malloc(cx: block, llptr_ty: TypeRef, llsize: ValueRef)\n-   -> result {\n+fn shared_malloc(cx: block, llptr_ty: TypeRef, llsize: ValueRef)\n+   -> ValueRef {\n     let _icx = cx.insn_ctxt(\"opaque_shared_malloc\");\n     let rval = Call(cx, cx.ccx().upcalls.shared_malloc, [llsize]);\n-    ret rslt(cx, PointerCast(cx, rval, llptr_ty));\n+    PointerCast(cx, rval, llptr_ty)\n }\n \n // Returns a pointer to the body for the box. The box may be an opaque\n@@ -325,15 +325,14 @@ fn opaque_box_body(bcx: block,\n // trans_malloc_boxed_raw: expects an unboxed type and returns a pointer to\n // enough space for a box of that type.  This includes a rust_opaque_box\n // header.\n-fn trans_malloc_boxed_raw(bcx: block, t: ty::t,\n-                          &static_ti: option<@tydesc_info>) -> result {\n+fn malloc_boxed_raw(bcx: block, t: ty::t,\n+                    &static_ti: option<@tydesc_info>) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"trans_malloc_boxed_raw\");\n-    let mut bcx = bcx;\n     let ccx = bcx.ccx();\n \n     // Grab the TypeRef type of box_ptr, because that's what trans_raw_malloc\n     // wants.\n-    let box_ptr = ty::mk_imm_box(bcx.tcx(), t);\n+    let box_ptr = ty::mk_imm_box(ccx.tcx, t);\n     let llty = type_of(ccx, box_ptr);\n \n     // Get the tydesc for the body:\n@@ -342,18 +341,17 @@ fn trans_malloc_boxed_raw(bcx: block, t: ty::t,\n \n     // Allocate space:\n     let rval = Call(bcx, ccx.upcalls.malloc, [lltydesc]);\n-    ret rslt(bcx, PointerCast(bcx, rval, llty));\n+    ret PointerCast(bcx, rval, llty);\n }\n \n // trans_malloc_boxed: usefully wraps trans_malloc_box_raw; allocates a box,\n // initializes the reference count to 1, and pulls out the body and rc\n-fn trans_malloc_boxed(bcx: block, t: ty::t) ->\n-   {bcx: block, box: ValueRef, body: ValueRef} {\n+fn malloc_boxed(bcx: block, t: ty::t) -> {box: ValueRef, body: ValueRef} {\n     let _icx = bcx.insn_ctxt(\"trans_malloc_boxed\");\n     let mut ti = none;\n-    let {bcx, val:box} = trans_malloc_boxed_raw(bcx, t, ti);\n+    let box = malloc_boxed_raw(bcx, t, ti);\n     let body = GEPi(bcx, box, [0, abi::box_field_body]);\n-    ret {bcx: bcx, box: box, body: body};\n+    ret {box: box, body: body};\n }\n \n // Type descriptor and type glue stuff\n@@ -571,30 +569,30 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n     };\n }\n \n-fn make_take_glue(cx: block, v: ValueRef, t: ty::t) {\n-    let _icx = cx.insn_ctxt(\"make_take_glue\");\n-    let mut bcx = cx;\n+fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n+    let _icx = bcx.insn_ctxt(\"make_take_glue\");\n     // NB: v is a *pointer* to type t here, not a direct value.\n-    bcx = alt ty::get(t).struct {\n+    let bcx = alt ty::get(t).struct {\n       ty::ty_box(_) | ty::ty_opaque_box {\n-        incr_refcnt_of_boxed(bcx, Load(bcx, v))\n+        incr_refcnt_of_boxed(bcx, Load(bcx, v)); bcx\n       }\n       ty::ty_uniq(_) {\n-        let r = uniq::duplicate(bcx, Load(bcx, v), t);\n-        Store(r.bcx, r.val, v);\n-        r.bcx\n+        let {bcx, val} = uniq::duplicate(bcx, Load(bcx, v), t);\n+        Store(bcx, val, v);\n+        bcx\n       }\n       ty::ty_vec(_) | ty::ty_str {\n-        let r = tvec::duplicate(bcx, Load(bcx, v), t);\n-        Store(r.bcx, r.val, v);\n-        r.bcx\n+        let {bcx, val} = tvec::duplicate(bcx, Load(bcx, v), t);\n+        Store(bcx, val, v);\n+        bcx\n       }\n       ty::ty_fn(_) {\n         closure::make_fn_glue(bcx, v, t, take_ty)\n       }\n       ty::ty_iface(_, _) {\n         let box = Load(bcx, GEPi(bcx, v, [0, 1]));\n-        incr_refcnt_of_boxed(bcx, box)\n+        incr_refcnt_of_boxed(bcx, box);\n+        bcx\n       }\n       ty::ty_opaque_closure_ptr(ck) {\n         closure::make_opaque_cbox_take_glue(bcx, ck, v)\n@@ -608,15 +606,14 @@ fn make_take_glue(cx: block, v: ValueRef, t: ty::t) {\n     build_return(bcx);\n }\n \n-fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) -> block {\n+fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n     let _icx = cx.insn_ctxt(\"incr_refcnt_of_boxed\");\n     let ccx = cx.ccx();\n     maybe_validate_box(cx, box_ptr);\n     let rc_ptr = GEPi(cx, box_ptr, [0, abi::box_field_refcnt]);\n     let rc = Load(cx, rc_ptr);\n     let rc = Add(cx, rc, C_int(ccx, 1));\n     Store(cx, rc, rc_ptr);\n-    ret cx;\n }\n \n fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n@@ -881,9 +878,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n             let mut j = 0u;\n             let v_id = variant.id;\n             for a: ty::arg in args {\n-                let rslt = GEP_enum(cx, a_tup, tid, v_id, tps, j);\n-                let llfldp_a = rslt.val;\n-                cx = rslt.bcx;\n+                let llfldp_a = GEP_enum(cx, a_tup, tid, v_id, tps, j);\n                 let ty_subst = ty::substitute_type_params(ccx.tcx, tps, a.ty);\n                 cx = f(cx, llfldp_a, ty_subst);\n                 j += 1u;\n@@ -1080,19 +1075,14 @@ fn call_tydesc_glue(cx: block, v: ValueRef, t: ty::t, field: int) ->\n     ret cx;\n }\n \n-fn call_cmp_glue(cx: block, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n-                 llop: ValueRef) -> result {\n+fn call_cmp_glue(bcx: block, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n+                 llop: ValueRef) -> ValueRef {\n     // We can't use call_tydesc_glue_full() and friends here because compare\n     // glue has a special signature.\n-    let _icx = cx.insn_ctxt(\"call_cmp_glue\");\n-    let bcx = cx;\n+    let _icx = bcx.insn_ctxt(\"call_cmp_glue\");\n \n-    let r = spill_if_immediate(bcx, lhs, t);\n-    let lllhs = r.val;\n-    let bcx = r.bcx;\n-    let r = spill_if_immediate(bcx, rhs, t);\n-    let llrhs = r.val;\n-    let bcx = r.bcx;\n+    let lllhs = spill_if_immediate(bcx, lhs, t);\n+    let llrhs = spill_if_immediate(bcx, rhs, t);\n \n     let llrawlhsptr = BitCast(bcx, lllhs, T_ptr(T_i8()));\n     let llrawrhsptr = BitCast(bcx, llrhs, T_ptr(T_i8()));\n@@ -1105,7 +1095,7 @@ fn call_cmp_glue(cx: block, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n     let llcmpresultptr = alloca(bcx, T_i1());\n     Call(bcx, llfn, [llcmpresultptr, lltydesc, lltydescs,\n                      llrawlhsptr, llrawrhsptr, llop]);\n-    ret rslt(bcx, Load(bcx, llcmpresultptr));\n+    ret Load(bcx, llcmpresultptr);\n }\n \n fn take_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n@@ -1139,7 +1129,8 @@ fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> result {\n     let _icx = bcx.insn_ctxt(\"take_ty_immediate\");\n     alt ty::get(t).struct {\n       ty::ty_box(_) | ty::ty_opaque_box {\n-        rslt(incr_refcnt_of_boxed(bcx, v), v)\n+        incr_refcnt_of_boxed(bcx, v);\n+        rslt(bcx, v)\n       }\n       ty::ty_uniq(_) {\n         uniq::duplicate(bcx, v, t)\n@@ -1158,7 +1149,7 @@ fn free_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n }\n \n fn call_memmove(cx: block, dst: ValueRef, src: ValueRef,\n-                n_bytes: ValueRef) -> result {\n+                n_bytes: ValueRef) {\n     // FIXME: Provide LLVM with better alignment information when the\n     // alignment is statically known (it must be nothing more than a constant\n     // int, or LLVM complains -- not even a constant element of a tydesc\n@@ -1175,21 +1166,18 @@ fn call_memmove(cx: block, dst: ValueRef, src: ValueRef,\n     let size = IntCast(cx, n_bytes, ccx.int_type);\n     let align = C_i32(1i32);\n     let volatile = C_bool(false);\n-    let ret_val = Call(cx, memmove, [dst_ptr, src_ptr, size,\n-                                     align, volatile]);\n-    ret rslt(cx, ret_val);\n+    Call(cx, memmove, [dst_ptr, src_ptr, size, align, volatile]);\n }\n \n-fn memmove_ty(bcx: block, dst: ValueRef, src: ValueRef, t: ty::t) ->\n-    block {\n+fn memmove_ty(bcx: block, dst: ValueRef, src: ValueRef, t: ty::t) {\n     let _icx = bcx.insn_ctxt(\"memmove_ty\");\n     let ccx = bcx.ccx();\n     if ty::type_is_structural(t) {\n         let llsz = llsize_of(ccx, type_of(ccx, t));\n-        ret call_memmove(bcx, dst, src, llsz).bcx;\n+        call_memmove(bcx, dst, src, llsz);\n+    } else {\n+        Store(bcx, Load(bcx, src), dst);\n     }\n-    Store(bcx, Load(bcx, src), dst);\n-    ret bcx;\n }\n \n enum copy_action { INIT, DROP_EXISTING, }\n@@ -1238,7 +1226,7 @@ fn copy_val_no_check(bcx: block, action: copy_action, dst: ValueRef,\n     }\n     if type_is_structural_or_param(t) {\n         if action == DROP_EXISTING { bcx = drop_ty(bcx, dst, t); }\n-        bcx = memmove_ty(bcx, dst, src, t);\n+        memmove_ty(bcx, dst, src, t);\n         ret take_ty(bcx, dst, t);\n     }\n     ccx.sess.bug(\"unexpected type in trans::copy_val_no_check: \" +\n@@ -1273,7 +1261,7 @@ fn move_val(cx: block, action: copy_action, dst: ValueRef,\n         ret cx;\n     } else if type_is_structural_or_param(t) {\n         if action == DROP_EXISTING { cx = drop_ty(cx, dst, t); }\n-        cx = memmove_ty(cx, dst, src_val, t);\n+        memmove_ty(cx, dst, src_val, t);\n         if src.kind == owned { ret zero_alloca(cx, src_val, t); }\n         // If we're here, it must be a temporary.\n         revoke_clean(cx, src_val);\n@@ -1354,15 +1342,15 @@ fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n         ret store_in_dest(bcx, neg, dest);\n       }\n       ast::box(_) {\n-        let mut {bcx, box, body} = trans_malloc_boxed(bcx, e_ty);\n+        let mut {box, body} = malloc_boxed(bcx, e_ty);\n         add_clean_free(bcx, box, false);\n         // Cast the body type to the type of the value. This is needed to\n         // make enums work, since enums have a different LLVM type depending\n         // on whether they're boxed or not\n         let ccx = bcx.ccx();\n         let llety = T_ptr(type_of(ccx, e_ty));\n         body = PointerCast(bcx, body, llety);\n-        bcx = trans_expr_save_in(bcx, e, body);\n+        let bcx = trans_expr_save_in(bcx, e, body);\n         revoke_clean(bcx, box);\n         ret store_in_dest(bcx, box, dest);\n       }\n@@ -1383,8 +1371,7 @@ fn trans_addr_of(cx: block, e: @ast::expr, dest: dest) -> block {\n     let ety = expr_ty(cx, e);\n     let is_immediate = ty::type_is_immediate(ety);\n     if (kind == temporary && is_immediate) || kind == owned_imm {\n-        let {bcx: bcx2, val: val2} = do_spill(cx, val, ety);\n-        bcx = bcx2; val = val2;\n+        val = do_spill(cx, val, ety);\n     }\n     ret store_in_dest(bcx, val, dest);\n }\n@@ -1407,16 +1394,13 @@ fn trans_compare(cx: block, op: ast::binop, lhs: ValueRef,\n         }\n     };\n \n-    let rs = call_cmp_glue(cx, lhs, rhs, rhs_t, llop);\n+    let cmpval = call_cmp_glue(cx, lhs, rhs, rhs_t, llop);\n \n     // Invert the result if necessary.\n     alt op {\n-      ast::eq | ast::lt | ast::le { ret rslt(rs.bcx, rs.val); }\n-      ast::ne | ast::ge | ast::gt {\n-        ret rslt(rs.bcx, Not(rs.bcx, rs.val));\n-      }\n-      _ { cx.tcx().sess.bug(\"trans_compare got\\\n-              non-comparison-op\"); }\n+      ast::eq | ast::lt | ast::le { rslt(cx, cmpval) }\n+      ast::ne | ast::ge | ast::gt { rslt(cx, Not(cx, cmpval)) }\n+      _ { cx.tcx().sess.bug(\"trans_compare got non-comparison-op\"); }\n     }\n }\n \n@@ -2254,16 +2238,14 @@ fn trans_var(cx: block, def: ast::def, id: ast::node_id, path: @ast::path)\n         } else {\n             // Nullary variant.\n             let enum_ty = node_id_type(cx, id);\n-            let alloc_result = alloc_ty(cx, enum_ty);\n-            let llenumblob = alloc_result.val;\n+            let llenumblob = alloc_ty(cx, enum_ty);\n             let llenumty = type_of_enum(ccx, tid, enum_ty);\n-            let bcx = alloc_result.bcx;\n-            let llenumptr = PointerCast(bcx, llenumblob, T_ptr(llenumty));\n-            let lldiscrimptr = GEPi(bcx, llenumptr, [0, 0]);\n-            let lldiscrim_gv = lookup_discriminant(bcx.fcx.ccx, vid);\n-            let lldiscrim = Load(bcx, lldiscrim_gv);\n-            Store(bcx, lldiscrim, lldiscrimptr);\n-            ret lval_no_env(bcx, llenumptr, temporary);\n+            let llenumptr = PointerCast(cx, llenumblob, T_ptr(llenumty));\n+            let lldiscrimptr = GEPi(cx, llenumptr, [0, 0]);\n+            let lldiscrim_gv = lookup_discriminant(ccx, vid);\n+            let lldiscrim = Load(cx, lldiscrim_gv);\n+            Store(cx, lldiscrim, lldiscrimptr);\n+            ret lval_no_env(cx, llenumptr, temporary);\n         }\n       }\n       ast::def_const(did) {\n@@ -2425,10 +2407,10 @@ fn lval_maybe_callee_to_lval(c: lval_maybe_callee, ty: ty::t) -> lval_result {\n         let n_args = ty::ty_fn_args(ty).len();\n         let args = vec::from_elem(n_args, none);\n         let space = alloc_ty(c.bcx, ty);\n-        let bcx = closure::trans_bind_1(space.bcx, ty, c, args, ty,\n-                                              save_in(space.val));\n-        add_clean_temp(bcx, space.val, ty);\n-        {bcx: bcx, val: space.val, kind: temporary}\n+        let bcx = closure::trans_bind_1(c.bcx, ty, c, args, ty,\n+                                        save_in(space));\n+        add_clean_temp(bcx, space, ty);\n+        {bcx: bcx, val: space, kind: temporary}\n     } else {\n         alt check c.env {\n           is_closure { {bcx: c.bcx, val: c.val, kind: c.kind} }\n@@ -2571,23 +2553,22 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n         if ccx.maps.copy_map.contains_key(e.id) && lv.kind != temporary {\n             if !copied {\n                 let alloc = alloc_ty(bcx, e_ty);\n-                bcx = copy_val(alloc.bcx, INIT, alloc.val,\n-                               load_if_immediate(alloc.bcx, val, e_ty), e_ty);\n-                val = alloc.val;\n+                bcx = copy_val(bcx, INIT, alloc,\n+                               load_if_immediate(bcx, val, e_ty), e_ty);\n+                val = alloc;\n             } else { bcx = take_ty(bcx, val, e_ty); }\n             add_clean(bcx, val, e_ty);\n         }\n         if arg_mode == ast::by_val && (lv.kind == owned || !imm) {\n             val = Load(bcx, val);\n         }\n     } else if arg_mode == ast::by_copy || arg_mode == ast::by_move {\n-        let {bcx: cx, val: alloc} = alloc_ty(bcx, e_ty);\n+        let alloc = alloc_ty(bcx, e_ty);\n         let move_out = arg_mode == ast::by_move ||\n             ccx.maps.last_uses.contains_key(e.id);\n-        bcx = cx;\n         if lv.kind == temporary { revoke_clean(bcx, val); }\n         if lv.kind == owned || !ty::type_is_immediate(e_ty) {\n-            bcx = memmove_ty(bcx, alloc, val, e_ty);\n+            memmove_ty(bcx, alloc, val, e_ty);\n             if move_out && ty::type_needs_drop(ccx.tcx, e_ty) {\n                 bcx = zero_alloca(bcx, val, e_ty);\n             }\n@@ -2602,9 +2583,7 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n         add_clean_temp_mem(bcx, val, e_ty);\n         temp_cleanups += [val];\n     } else if ty::type_is_immediate(e_ty) && lv.kind != owned {\n-        let r = do_spill(bcx, val, e_ty);\n-        val = r.val;\n-        bcx = r.bcx;\n+        val = do_spill(bcx, val, e_ty);\n     }\n \n     if !is_bot && arg.ty != e_ty || ty::type_has_params(arg.ty) {\n@@ -2641,18 +2620,10 @@ fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n       ignore {\n         if ty::type_is_nil(retty) && !always_valid_retptr {\n             llvm::LLVMGetUndef(T_ptr(T_nil()))\n-        } else {\n-            let {bcx: cx, val} = alloc_ty(bcx, retty);\n-            bcx = cx;\n-            val\n-        }\n+        } else { alloc_ty(bcx, retty) }\n       }\n       save_in(dst) { dst }\n-      by_val(_) {\n-          let {bcx: cx, val} = alloc_ty(bcx, retty);\n-          bcx = cx;\n-          val\n-      }\n+      by_val(_) { alloc_ty(bcx, retty) }\n     };\n \n     llargs += [llretslot];\n@@ -2966,7 +2937,7 @@ fn trans_temp_lval(bcx: block, e: @ast::expr) -> lval_result {\n             add_clean_temp(bcx, *cell, ty);\n             ret {bcx: bcx, val: *cell, kind: temporary};\n         } else {\n-            let {bcx, val: scratch} = alloc_ty(bcx, ty);\n+            let scratch = alloc_ty(bcx, ty);\n             let bcx = trans_expr_save_in(bcx, e, scratch);\n             add_clean_temp(bcx, scratch, ty);\n             ret {bcx: bcx, val: scratch, kind: temporary};\n@@ -3068,7 +3039,8 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n         let callee = trans_callee(bcx, e), ty = expr_ty(bcx, e);\n         let lv = lval_maybe_callee_to_lval(callee, ty);\n         revoke_clean(lv.bcx, lv.val);\n-        ret memmove_ty(lv.bcx, get_dest_addr(dest), lv.val, ty);\n+        memmove_ty(lv.bcx, get_dest_addr(dest), lv.val, ty);\n+        ret lv.bcx;\n       }\n       ast::expr_index(base, idx) {\n         // If it is here, it's not an lval, so this is a user-defined index op\n@@ -3165,9 +3137,9 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n         assert lhs_res.kind == owned;\n         let rhs_res = trans_lval(lhs_res.bcx, src);\n         let t = expr_ty(bcx, src);\n-        let {bcx: bcx, val: tmp_alloc} = alloc_ty(rhs_res.bcx, t);\n+        let tmp_alloc = alloc_ty(rhs_res.bcx, t);\n         // Swap through a temporary.\n-        let bcx = move_val(bcx, INIT, tmp_alloc, lhs_res, t);\n+        let bcx = move_val(rhs_res.bcx, INIT, tmp_alloc, lhs_res, t);\n         let bcx = move_val(bcx, INIT, lhs_res.val, rhs_res, t);\n         ret move_val(bcx, INIT, rhs_res.val, lval_owned(bcx, tmp_alloc), t);\n       }\n@@ -3183,7 +3155,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n         // Allocate space for the ptr that will be returned from\n         // `pool.alloc()`:\n         let ptr_ty = expr_ty(bcx, e);\n-        let {bcx, val: ptr_ptr_val} = alloc_ty(bcx, ptr_ty);\n+        let ptr_ptr_val = alloc_ty(bcx, ptr_ty);\n \n         #debug[\"ptr_ty = %s\", ty_to_str(tcx, ptr_ty)];\n         #debug[\"ptr_ptr_val = %s\", val_str(ccx.tn, ptr_ptr_val)];\n@@ -3250,21 +3222,13 @@ fn lval_to_dps(bcx: block, e: @ast::expr, dest: dest) -> block {\n     ret bcx;\n }\n \n-fn do_spill(cx: block, v: ValueRef, t: ty::t) -> result {\n-    // We have a value but we have to spill it, and root it, to pass by alias.\n-    let mut bcx = cx;\n-\n+fn do_spill(bcx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     if ty::type_is_bot(t) {\n-        ret rslt(bcx, C_null(T_ptr(T_i8())));\n+        ret C_null(T_ptr(T_i8()));\n     }\n-\n-    let r = alloc_ty(bcx, t);\n-    bcx = r.bcx;\n-    let llptr = r.val;\n-\n+    let llptr = alloc_ty(bcx, t);\n     Store(bcx, v, llptr);\n-\n-    ret rslt(bcx, llptr);\n+    ret llptr;\n }\n \n // Since this function does *not* root, it is the caller's responsibility to\n@@ -3275,10 +3239,10 @@ fn do_spill_noroot(cx: block, v: ValueRef) -> ValueRef {\n     ret llptr;\n }\n \n-fn spill_if_immediate(cx: block, v: ValueRef, t: ty::t) -> result {\n+fn spill_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"spill_if_immediate\");\n     if ty::type_is_immediate(t) { ret do_spill(cx, v, t); }\n-    ret rslt(cx, v);\n+    ret v;\n }\n \n fn load_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n@@ -3325,7 +3289,7 @@ fn trans_log(lvl: @ast::expr, bcx: block, e: @ast::expr) -> block {\n             let e_ty = expr_ty(bcx, e);\n             let tydesc = get_tydesc_simple(ccx, e_ty);\n             // Call the polymorphic log function.\n-            let {bcx, val} = spill_if_immediate(bcx, val, e_ty);\n+            let val = spill_if_immediate(bcx, val, e_ty);\n             let val = PointerCast(bcx, val, T_ptr(T_i8()));\n             Call(bcx, ccx.upcalls.log_type, [tydesc, val, level]);\n             bcx\n@@ -3744,21 +3708,13 @@ fn block_locals(b: ast::blk, it: fn(@ast::local)) {\n     }\n }\n \n-fn alloc_ty(cx: block, t: ty::t) -> result {\n-    let _icx = cx.insn_ctxt(\"alloc_ty\");\n-    let bcx = cx, ccx = cx.ccx();\n+fn alloc_ty(bcx: block, t: ty::t) -> ValueRef {\n+    let _icx = bcx.insn_ctxt(\"alloc_ty\");\n+    let ccx = bcx.ccx();\n     let llty = type_of(ccx, t);\n     assert !ty::type_has_params(t);\n     let val = alloca(bcx, llty);\n-\n-    // NB: since we've pushed all size calculations in this\n-    // function up to the alloca block, we actually return the\n-    // block passed into us unmodified; it doesn't really\n-    // have to be passed-and-returned here, but it fits\n-    // past caller conventions and may well make sense again,\n-    // so we leave it as-is.\n-\n-    ret rslt(cx, val);\n+    ret val;\n }\n \n fn alloc_local(cx: block, local: @ast::local) -> block {\n@@ -3779,7 +3735,7 @@ fn alloc_local(cx: block, local: @ast::local) -> block {\n           _ {}\n         }\n     }\n-    let {bcx, val} = alloc_ty(cx, t);\n+    let val = alloc_ty(cx, t);\n     if cx.sess().opts.debuginfo {\n         option::may(simple_name) {|name|\n             str::as_c_str(name, {|buf|\n@@ -3788,7 +3744,7 @@ fn alloc_local(cx: block, local: @ast::local) -> block {\n         }\n     }\n     cx.fcx.lllocals.insert(local.node.id, local_mem(val));\n-    ret bcx;\n+    ret cx;\n }\n \n fn trans_block(bcx: block, b: ast::blk, dest: dest)\n@@ -3917,8 +3873,7 @@ fn copy_args_to_allocas(fcx: fn_ctxt, bcx: block, args: [ast::arg],\n           ast::by_move | ast::by_copy { add_clean(bcx, argval, arg.ty); }\n           ast::by_val {\n             if !ty::type_is_immediate(arg.ty) {\n-                let {bcx: cx, val: alloc} = alloc_ty(bcx, arg.ty);\n-                bcx = cx;\n+                let alloc = alloc_ty(bcx, arg.ty);\n                 Store(bcx, argval, alloc);\n                 fcx.llargs.insert(id, local_mem(alloc));\n             } else {\n@@ -4049,7 +4004,7 @@ fn trans_res_ctor(ccx: @crate_ctxt, path: path, dtor: ast::fn_decl,\n     let llretptr = fcx.llretptr;\n \n     let dst = GEPi(bcx, llretptr, [0, 1]);\n-    bcx = memmove_ty(bcx, dst, arg, arg_t);\n+    memmove_ty(bcx, dst, arg, arg_t);\n     let flag = GEPi(bcx, llretptr, [0, 0]);\n     let one = C_u8(1u);\n     Store(bcx, one, flag);\n@@ -4078,9 +4033,9 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n       some(substs) { substs.tys }\n       none { [] }\n     };\n-    let mut bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n+    let bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, variant.node.id));\n-    bcx = copy_args_to_allocas(fcx, bcx, fn_args, arg_tys);\n+    let bcx = copy_args_to_allocas(fcx, bcx, fn_args, arg_tys);\n \n     // Cast the enum to a type we can GEP into.\n     let llblobptr = if is_degen {\n@@ -4096,17 +4051,16 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n     let t_id = local_def(enum_id);\n     let v_id = local_def(variant.node.id);\n     for va: ast::variant_arg in variant.node.args {\n-        let rslt = GEP_enum(bcx, llblobptr, t_id, v_id, ty_param_substs, i);\n-        bcx = rslt.bcx;\n-        let lldestptr = rslt.val;\n+        let lldestptr = GEP_enum(bcx, llblobptr, t_id, v_id,\n+                                 ty_param_substs, i);\n         // If this argument to this function is a enum, it'll have come in to\n         // this function as an opaque blob due to the way that type_of()\n         // works. So we have to cast to the destination's view of the type.\n         let llarg = alt check fcx.llargs.find(va.id) {\n           some(local_mem(x)) { x }\n         };\n         let arg_ty = arg_tys[i].ty;\n-        bcx = memmove_ty(bcx, lldestptr, llarg, arg_ty);\n+        memmove_ty(bcx, lldestptr, llarg, arg_ty);\n         i += 1u;\n     }\n     build_return(bcx);"}, {"sha": "127b04996e5316cc60285dc8b50ea057b8d81dc3", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a84b56bc70b2fc68bae4ef686063996149ad6954/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a84b56bc70b2fc68bae4ef686063996149ad6954/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=a84b56bc70b2fc68bae4ef686063996149ad6954", "patch": "@@ -174,19 +174,19 @@ fn allocate_cbox(bcx: block,\n     let mut temp_cleanups = [];\n     let (bcx, box) = alt ck {\n       ty::ck_box {\n-        let {bcx, val: box} = trans_malloc_boxed_raw(bcx, cdata_ty, ti);\n+        let box = malloc_boxed_raw(bcx, cdata_ty, ti);\n         (bcx, box)\n       }\n       ty::ck_uniq {\n         let uniq_cbox_ty = mk_tuplified_uniq_cbox_ty(tcx, cdata_ty);\n-        let {bcx, val: box} = uniq::alloc_uniq(bcx, uniq_cbox_ty);\n+        let box = uniq::alloc_uniq(bcx, uniq_cbox_ty);\n         nuke_ref_count(bcx, box);\n         let bcx = store_tydesc(bcx, cdata_ty, box, ti);\n         (bcx, box)\n       }\n       ty::ck_block {\n         let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n-        let {bcx, val: box} = base::alloc_ty(bcx, cbox_ty);\n+        let box = base::alloc_ty(bcx, cbox_ty);\n         nuke_ref_count(bcx, box);\n         (bcx, box)\n       }\n@@ -432,7 +432,8 @@ fn trans_bind_1(cx: block, outgoing_fty: ty::t,\n        (f_res.env == null_env || f_res.env == is_closure) {\n         // Trivial 'binding': just return the closure\n         let lv = lval_maybe_callee_to_lval(f_res, pair_ty);\n-        ret memmove_ty(lv.bcx, get_dest_addr(dest), lv.val, pair_ty);\n+        memmove_ty(lv.bcx, get_dest_addr(dest), lv.val, pair_ty);\n+        ret lv.bcx;\n     }\n \n     // Arrange for the bound function to live in the first binding spot\n@@ -510,7 +511,7 @@ fn make_opaque_cbox_take_glue(\n     let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_take_glue\");\n     alt ck {\n       ty::ck_block { ret bcx; }\n-      ty::ck_box { ret incr_refcnt_of_boxed(bcx, Load(bcx, cboxptr)); }\n+      ty::ck_box { incr_refcnt_of_boxed(bcx, Load(bcx, cboxptr)); ret bcx; }\n       ty::ck_uniq { /* hard case: */ }\n     }\n \n@@ -533,7 +534,7 @@ fn make_opaque_cbox_take_glue(\n         let malloc = ccx.upcalls.shared_malloc;\n         let cbox_out = Call(bcx, malloc, [sz]);\n         let cbox_out = PointerCast(bcx, cbox_out, llopaquecboxty);\n-        let {bcx, val: _} = call_memmove(bcx, cbox_out, cbox_in, sz);\n+        call_memmove(bcx, cbox_out, cbox_in, sz);\n         Store(bcx, cbox_out, cboxptr);\n \n         // Take the (deeply cloned) type descriptor\n@@ -733,8 +734,8 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n                 val = Load(bcx, val);\n               }\n               ast::by_copy {\n-                let {bcx: cx, val: alloc} = alloc_ty(bcx, out_arg.ty);\n-                bcx = memmove_ty(cx, alloc, val, out_arg.ty);\n+                let alloc = alloc_ty(bcx, out_arg.ty);\n+                memmove_ty(bcx, alloc, val, out_arg.ty);\n                 bcx = take_ty(bcx, alloc, out_arg.ty);\n                 val = alloc;\n               }"}, {"sha": "45b96dc5076b306ebb12e3b07dbd499d6603ca81", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a84b56bc70b2fc68bae4ef686063996149ad6954/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a84b56bc70b2fc68bae4ef686063996149ad6954/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=a84b56bc70b2fc68bae4ef686063996149ad6954", "patch": "@@ -267,9 +267,9 @@ fn trans_cast(bcx: block, val: @ast::expr, id: ast::node_id, dest: dest)\n     if dest == ignore { ret trans_expr(bcx, val, ignore); }\n     let ccx = bcx.ccx();\n     let v_ty = expr_ty(bcx, val);\n-    let mut {bcx, box, body} = trans_malloc_boxed(bcx, v_ty);\n+    let {box, body} = malloc_boxed(bcx, v_ty);\n     add_clean_free(bcx, box, false);\n-    bcx = trans_expr_save_in(bcx, val, body);\n+    let bcx = trans_expr_save_in(bcx, val, body);\n     revoke_clean(bcx, box);\n     let result = get_dest_addr(dest);\n     Store(bcx, box, PointerCast(bcx, GEPi(bcx, result, [0, 1]),"}, {"sha": "b579edbec71db70d35ed65afd038f3b1b9aebec9", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a84b56bc70b2fc68bae4ef686063996149ad6954/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a84b56bc70b2fc68bae4ef686063996149ad6954/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=a84b56bc70b2fc68bae4ef686063996149ad6954", "patch": "@@ -2,7 +2,7 @@ import syntax::ast;\n import driver::session::session;\n import lib::llvm::{ValueRef, TypeRef};\n import back::abi;\n-import base::{call_memmove, trans_shared_malloc,\n+import base::{call_memmove, shared_malloc,\n                INIT, copy_val, load_if_immediate, get_tydesc,\n                sub_block, do_spill_noroot,\n                dest, bcx_icx};\n@@ -39,8 +39,7 @@ fn alloc_raw(bcx: block, fill: ValueRef, alloc: ValueRef) -> result {\n     let ccx = bcx.ccx();\n     let llvecty = ccx.opaque_vec_type;\n     let vecsize = Add(bcx, alloc, llsize_of(ccx, llvecty));\n-    let {bcx: bcx, val: vecptr} =\n-        trans_shared_malloc(bcx, T_ptr(llvecty), vecsize);\n+    let vecptr = shared_malloc(bcx, T_ptr(llvecty), vecsize);\n     Store(bcx, fill, GEPi(bcx, vecptr, [0, abi::vec_elt_fill]));\n     Store(bcx, alloc, GEPi(bcx, vecptr, [0, abi::vec_elt_alloc]));\n     ret {bcx: bcx, val: vecptr};\n@@ -77,14 +76,13 @@ fn duplicate(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> result {\n     let ccx = bcx.ccx();\n     let fill = get_fill(bcx, vptr);\n     let size = Add(bcx, fill, llsize_of(ccx, ccx.opaque_vec_type));\n-    let {bcx: bcx, val: newptr} =\n-        trans_shared_malloc(bcx, val_ty(vptr), size);\n-    let mut bcx = call_memmove(bcx, newptr, vptr, size).bcx;\n+    let newptr = shared_malloc(bcx, val_ty(vptr), size);\n+    call_memmove(bcx, newptr, vptr, size);\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n     Store(bcx, fill, GEPi(bcx, newptr, [0, abi::vec_elt_alloc]));\n-    if ty::type_needs_drop(bcx.tcx(), unit_ty) {\n-        bcx = iter_vec(bcx, newptr, vec_ty, base::take_ty);\n-    }\n+    let bcx = if ty::type_needs_drop(bcx.tcx(), unit_ty) {\n+        iter_vec(bcx, newptr, vec_ty, base::take_ty)\n+    } else { bcx };\n     ret rslt(bcx, newptr);\n }\n fn make_free_glue(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n@@ -139,8 +137,8 @@ fn trans_str(bcx: block, s: str, dest: dest) -> block {\n \n     let ccx = bcx.ccx();\n     let llcstr = C_cstr(ccx, s);\n-    let bcx = call_memmove(bcx, get_dataptr(bcx, sptr, T_i8()), llcstr,\n-                           C_uint(ccx, veclen)).bcx;\n+    call_memmove(bcx, get_dataptr(bcx, sptr, T_i8()), llcstr,\n+                 C_uint(ccx, veclen));\n     ret base::store_in_dest(bcx, sptr, dest);\n }\n \n@@ -211,7 +209,7 @@ fn trans_append_literal(bcx: block, vptrptr: ValueRef, vec_ty: ty::t,\n         set_fill(bcx, vptr, new_fill);\n         let targetptr = pointer_add(bcx, get_dataptr(bcx, vptr, elt_llty),\n                                     old_fill);\n-        bcx = call_memmove(bcx, targetptr, scratch, elt_sz).bcx;\n+        call_memmove(bcx, targetptr, scratch, elt_sz);\n     }\n     bcx\n }"}, {"sha": "bac8033e6eab4732239df8b060b70670eb6d6bed", "filename": "src/rustc/middle/trans/uniq.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a84b56bc70b2fc68bae4ef686063996149ad6954/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a84b56bc70b2fc68bae4ef686063996149ad6954/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=a84b56bc70b2fc68bae4ef686063996149ad6954", "patch": "@@ -11,21 +11,20 @@ fn trans_uniq(bcx: block, contents: @ast::expr,\n               node_id: ast::node_id, dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(\"uniq::trans_uniq\");\n     let uniq_ty = node_id_type(bcx, node_id);\n-    let {bcx, val: llptr} = alloc_uniq(bcx, uniq_ty);\n+    let llptr = alloc_uniq(bcx, uniq_ty);\n     add_clean_free(bcx, llptr, true);\n     let bcx = trans_expr_save_in(bcx, contents, llptr);\n     revoke_clean(bcx, llptr);\n     ret store_in_dest(bcx, llptr, dest);\n }\n \n-fn alloc_uniq(cx: block, uniq_ty: ty::t) -> result {\n-    let bcx = cx;\n+fn alloc_uniq(bcx: block, uniq_ty: ty::t) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"uniq::alloc_uniq\");\n     let contents_ty = content_ty(uniq_ty);\n     let llty = type_of::type_of(bcx.ccx(), contents_ty);\n     let llsz = llsize_of(bcx.ccx(), llty);\n     let llptrty = T_ptr(llty);\n-    trans_shared_malloc(bcx, llptrty, llsz)\n+    shared_malloc(bcx, llptrty, llsz)\n }\n \n fn make_free_glue(bcx: block, vptr: ValueRef, t: ty::t)\n@@ -52,7 +51,7 @@ fn autoderef(v: ValueRef, t: ty::t) -> {v: ValueRef, t: ty::t} {\n fn duplicate(bcx: block, v: ValueRef, t: ty::t) -> result {\n     let _icx = bcx.insn_ctxt(\"uniq::duplicate\");\n     let content_ty = content_ty(t);\n-    let {bcx, val: llptr} = alloc_uniq(bcx, t);\n+    let llptr = alloc_uniq(bcx, t);\n \n     let src = load_if_immediate(bcx, v, content_ty);\n     let dst = llptr;"}]}