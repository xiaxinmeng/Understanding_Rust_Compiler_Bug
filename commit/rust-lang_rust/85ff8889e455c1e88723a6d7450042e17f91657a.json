{"sha": "85ff8889e455c1e88723a6d7450042e17f91657a", "node_id": "C_kwDOAAsO6NoAKDg1ZmY4ODg5ZTQ1NWMxZTg4NzIzYTZkNzQ1MDA0MmUxN2Y5MTY1N2E", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2022-12-26T20:00:22Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2022-12-26T20:31:53Z"}, "message": "Tweak wording", "tree": {"sha": "4921629ec93bf32b8755badce75cb10a7b54c259", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4921629ec93bf32b8755badce75cb10a7b54c259"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85ff8889e455c1e88723a6d7450042e17f91657a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85ff8889e455c1e88723a6d7450042e17f91657a", "html_url": "https://github.com/rust-lang/rust/commit/85ff8889e455c1e88723a6d7450042e17f91657a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85ff8889e455c1e88723a6d7450042e17f91657a/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34b9594f6d7cecb748a7a88c27fc23137898f417", "url": "https://api.github.com/repos/rust-lang/rust/commits/34b9594f6d7cecb748a7a88c27fc23137898f417", "html_url": "https://github.com/rust-lang/rust/commit/34b9594f6d7cecb748a7a88c27fc23137898f417"}], "stats": {"total": 128, "additions": 98, "deletions": 30}, "files": [{"sha": "ea34cd94f8aeb574e1c56f81c422aa2ad08d8da1", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 84, "deletions": 17, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/85ff8889e455c1e88723a6d7450042e17f91657a/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ff8889e455c1e88723a6d7450042e17f91657a/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=85ff8889e455c1e88723a6d7450042e17f91657a", "patch": "@@ -335,29 +335,43 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n         let hir::ExprKind::Unary(hir::UnOp::Deref, deref) = lhs.kind else { return; };\n         let hir::ExprKind::MethodCall(path, base, args, _) = deref.kind else { return; };\n-        let self_ty = self.typeck_results.borrow().expr_ty_adjusted_opt(base).unwrap();\n-        let pick = self\n+        let Some(self_ty) = self.typeck_results.borrow().expr_ty_adjusted_opt(base) else { return; };\n+\n+        let Ok(pick) = self\n             .probe_for_name(\n                 probe::Mode::MethodCall,\n                 path.ident,\n                 probe::IsSuggestion(true),\n                 self_ty,\n                 deref.hir_id,\n                 probe::ProbeScope::TraitsInScope,\n-            )\n-            .unwrap();\n-        let methods = self.probe_for_name_many(\n+            ) else {\n+                return;\n+            };\n+        let in_scope_methods = self.probe_for_name_many(\n+            probe::Mode::MethodCall,\n+            path.ident,\n+            probe::IsSuggestion(true),\n+            self_ty,\n+            deref.hir_id,\n+            probe::ProbeScope::TraitsInScope,\n+        );\n+        let other_methods_in_scope: Vec<_> =\n+            in_scope_methods.iter().filter(|c| c.item.def_id != pick.item.def_id).collect();\n+\n+        let all_methods = self.probe_for_name_many(\n             probe::Mode::MethodCall,\n             path.ident,\n             probe::IsSuggestion(true),\n             self_ty,\n             deref.hir_id,\n             probe::ProbeScope::AllTraits,\n         );\n-        let suggestions: Vec<_> = methods\n+        let suggestions: Vec<_> = all_methods\n             .into_iter()\n-            .filter(|m| m.def_id != pick.item.def_id)\n-            .map(|m| {\n+            .filter(|c| c.item.def_id != pick.item.def_id)\n+            .map(|c| {\n+                let m = c.item;\n                 let substs = ty::InternalSubsts::for_item(self.tcx, m.def_id, |param, _| {\n                     self.var_for_def(deref.span, param)\n                 });\n@@ -389,21 +403,74 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut path_span: MultiSpan = path.ident.span.into();\n         path_span.push_span_label(\n             path.ident.span,\n-            format!(\n+            with_no_trimmed_paths!(format!(\n                 \"refers to `{}`\",\n-                with_no_trimmed_paths!(self.tcx.def_path_str(pick.item.def_id)),\n-            ),\n+                self.tcx.def_path_str(pick.item.def_id),\n+            )),\n         );\n+        let container_id = pick.item.container_id(self.tcx);\n+        let container = with_no_trimmed_paths!(self.tcx.def_path_str(container_id));\n+        for def_id in pick.import_ids {\n+            let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n+            path_span.push_span_label(\n+                self.tcx.hir().span(hir_id),\n+                format!(\"`{container}` imported here\"),\n+            );\n+        }\n+        let tail = with_no_trimmed_paths!(match &other_methods_in_scope[..] {\n+            [] => return,\n+            [candidate] => format!(\n+                \"the method of the same name on {} `{}`\",\n+                match candidate.kind {\n+                    probe::CandidateKind::InherentImplCandidate(..) => \"the inherent impl for\",\n+                    _ => \"trait\",\n+                },\n+                self.tcx.def_path_str(candidate.item.container_id(self.tcx))\n+            ),\n+            [.., last] if other_methods_in_scope.len() < 5 => {\n+                format!(\n+                    \"the methods of the same name on {} and `{}`\",\n+                    other_methods_in_scope[..other_methods_in_scope.len() - 1]\n+                        .iter()\n+                        .map(|c| format!(\n+                            \"`{}`\",\n+                            self.tcx.def_path_str(c.item.container_id(self.tcx))\n+                        ))\n+                        .collect::<Vec<String>>()\n+                        .join(\", \"),\n+                    self.tcx.def_path_str(last.item.container_id(self.tcx))\n+                )\n+            }\n+            _ => format!(\n+                \"the methods of the same name on {} other traits\",\n+                other_methods_in_scope.len()\n+            ),\n+        });\n         err.span_note(\n             path_span,\n             &format!(\n-            \"there are multiple methods with the same name, `{}` refers to `{}` in the method call\",\n-            path.ident,\n-            with_no_trimmed_paths!(self.tcx.def_path_str(pick.item.def_id)),\n-        ));\n+                \"the `{}` call is resolved to the method in `{container}`, shadowing {tail}\",\n+                path.ident,\n+            ),\n+        );\n+        if suggestions.len() > other_methods_in_scope.len() {\n+            err.note(&format!(\n+                \"additionally, there are {} other available methods that aren't in scope\",\n+                suggestions.len() - other_methods_in_scope.len()\n+            ));\n+        }\n         err.multipart_suggestions(\n-            \"you might have meant to invoke a different method, you can use the fully-qualified path\",\n-        suggestions,\n+            &format!(\n+                \"you might have meant to call {}; you can use the fully-qualified path to call {} \\\n+                 explicitly\",\n+                if suggestions.len() == 1 {\n+                    \"the other method\"\n+                } else {\n+                    \"one of the other methods\"\n+                },\n+                if suggestions.len() == 1 { \"it\" } else { \"one of them\" },\n+            ),\n+            suggestions,\n             Applicability::MaybeIncorrect,\n         );\n     }"}, {"sha": "6b3fa664d9c5a9d0badbe66b9445dd9d737dfac9", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/85ff8889e455c1e88723a6d7450042e17f91657a/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ff8889e455c1e88723a6d7450042e17f91657a/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=85ff8889e455c1e88723a6d7450042e17f91657a", "patch": "@@ -97,7 +97,7 @@ impl<'a, 'tcx> Deref for ProbeContext<'a, 'tcx> {\n }\n \n #[derive(Debug, Clone)]\n-struct Candidate<'tcx> {\n+pub(crate) struct Candidate<'tcx> {\n     // Candidates are (I'm not quite sure, but they are mostly) basically\n     // some metadata on top of a `ty::AssocItem` (without substs).\n     //\n@@ -131,13 +131,13 @@ struct Candidate<'tcx> {\n     // if `T: Sized`.\n     xform_self_ty: Ty<'tcx>,\n     xform_ret_ty: Option<Ty<'tcx>>,\n-    item: ty::AssocItem,\n-    kind: CandidateKind<'tcx>,\n-    import_ids: SmallVec<[LocalDefId; 1]>,\n+    pub(crate) item: ty::AssocItem,\n+    pub(crate) kind: CandidateKind<'tcx>,\n+    pub(crate) import_ids: SmallVec<[LocalDefId; 1]>,\n }\n \n #[derive(Debug, Clone)]\n-enum CandidateKind<'tcx> {\n+pub(crate) enum CandidateKind<'tcx> {\n     InherentImplCandidate(\n         SubstsRef<'tcx>,\n         // Normalize obligations\n@@ -323,15 +323,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n-    pub fn probe_for_name_many(\n+    pub(crate) fn probe_for_name_many(\n         &self,\n         mode: Mode,\n         item_name: Ident,\n         is_suggestion: IsSuggestion,\n         self_ty: Ty<'tcx>,\n         scope_expr_id: hir::HirId,\n         scope: ProbeScope,\n-    ) -> Vec<ty::AssocItem> {\n+    ) -> Vec<Candidate<'tcx>> {\n         self.probe_op(\n             item_name.span,\n             mode,\n@@ -344,10 +344,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             |probe_cx| {\n                 Ok(probe_cx\n                     .inherent_candidates\n-                    .iter()\n-                    .chain(&probe_cx.extension_candidates)\n-                    // .filter(|candidate| candidate_filter(&candidate.item))\n-                    .map(|candidate| candidate.item)\n+                    .into_iter()\n+                    .chain(probe_cx.extension_candidates)\n                     .collect())\n             },\n         )"}, {"sha": "91d0d1200d4362bd3ddae84fd9c8d2b2a3d657b5", "filename": "src/test/ui/suggestions/shadowed-lplace-method.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/85ff8889e455c1e88723a6d7450042e17f91657a/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/85ff8889e455c1e88723a6d7450042e17f91657a/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.stderr?ref=85ff8889e455c1e88723a6d7450042e17f91657a", "patch": "@@ -8,12 +8,15 @@ LL |     *rc.borrow_mut() = false;\n    |\n    = note: expected struct `Rc<RefCell<bool>>`\n                 found type `bool`\n-note: there are multiple methods with the same name, `borrow_mut` refers to `std::borrow::BorrowMut::borrow_mut` in the method call\n+note: the `borrow_mut` call is resolved to the method in `std::borrow::BorrowMut`, shadowing the method of the same name on the inherent impl for `std::cell::RefCell<T>`\n   --> $DIR/shadowed-lplace-method.rs:9:9\n    |\n+LL | use std::borrow::BorrowMut;\n+   |     ---------------------- `std::borrow::BorrowMut` imported here\n+...\n LL |     *rc.borrow_mut() = false;\n    |         ^^^^^^^^^^ refers to `std::borrow::BorrowMut::borrow_mut`\n-help: you might have meant to invoke a different method, you can use the fully-qualified path\n+help: you might have meant to call the other method; you can use the fully-qualified path to call it explicitly\n    |\n LL |     *std::cell::RefCell::<_>::borrow_mut(&rc) = false;\n    |      +++++++++++++++++++++++++++++++++++++  ~"}]}