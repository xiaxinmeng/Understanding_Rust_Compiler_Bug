{"sha": "104963c539e538a89fff21c133692fc21dac3e64", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwNDk2M2M1MzllNTM4YTg5ZmZmMjFjMTMzNjkyZmMyMWRhYzNlNjQ=", "commit": {"author": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-07-22T05:50:04Z"}, "committer": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-08-13T13:37:09Z"}, "message": "Switch on TyEmpty\n\nParse -> ! as FnConverging(!)\nAdd AdjustEmptyToAny coercion to all ! expressions\nSome fixes", "tree": {"sha": "47f0eb74a863f329732f74914c7951fecd0d1260", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47f0eb74a863f329732f74914c7951fecd0d1260"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/104963c539e538a89fff21c133692fc21dac3e64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/104963c539e538a89fff21c133692fc21dac3e64", "html_url": "https://github.com/rust-lang/rust/commit/104963c539e538a89fff21c133692fc21dac3e64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/104963c539e538a89fff21c133692fc21dac3e64/comments", "author": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f9f8567eb4effe1052b7458c7451f62d1dcc0b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f9f8567eb4effe1052b7458c7451f62d1dcc0b1", "html_url": "https://github.com/rust-lang/rust/commit/9f9f8567eb4effe1052b7458c7451f62d1dcc0b1"}], "stats": {"total": 142, "additions": 88, "deletions": 54}, "files": [{"sha": "89964043819d93b8e4927efcb42b2f8440b9ca3e", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/104963c539e538a89fff21c133692fc21dac3e64/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/104963c539e538a89fff21c133692fc21dac3e64/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=104963c539e538a89fff21c133692fc21dac3e64", "patch": "@@ -379,7 +379,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n-        if fn_ty.fn_ret().diverges() {\n+        if fn_ty.fn_ret().diverges(self.tcx) {\n             self.add_unreachable_node()\n         } else {\n             ret"}, {"sha": "3a293c304ee4d4518d0f789b774b06ba150b9fa1", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/104963c539e538a89fff21c133692fc21dac3e64/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/104963c539e538a89fff21c133692fc21dac3e64/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=104963c539e538a89fff21c133692fc21dac3e64", "patch": "@@ -1112,7 +1112,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprCall(ref f, ref args) => {\n             let diverges = !self.ir.tcx.is_method_call(expr.id) &&\n-                self.ir.tcx.expr_ty_adjusted(&f).fn_ret().diverges();\n+                self.ir.tcx.expr_ty_adjusted(&f).fn_ret().diverges(self.ir.tcx);\n             let succ = if diverges {\n                 self.s.exit_ln\n             } else {\n@@ -1125,7 +1125,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           hir::ExprMethodCall(_, _, ref args) => {\n             let method_call = ty::MethodCall::expr(expr.id);\n             let method_ty = self.ir.tcx.tables.borrow().method_map[&method_call].ty;\n-            let succ = if method_ty.fn_ret().diverges() {\n+            let succ = if method_ty.fn_ret().diverges(self.ir.tcx) {\n                 self.s.exit_ln\n             } else {\n                 succ"}, {"sha": "6cc7eef1c6fadd6aa955d7a71b602b136485631c", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/104963c539e538a89fff21c133692fc21dac3e64/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/104963c539e538a89fff21c133692fc21dac3e64/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=104963c539e538a89fff21c133692fc21dac3e64", "patch": "@@ -484,8 +484,11 @@ pub enum FnOutput<'tcx> {\n }\n \n impl<'tcx> FnOutput<'tcx> {\n-    pub fn diverges(&self) -> bool {\n-        *self == FnDiverging\n+    pub fn diverges(&self, tcx: TyCtxt) -> bool {\n+        match *self {\n+            FnConverging(ref ty) => ty.is_empty(tcx),\n+            FnDiverging => true,\n+        }\n     }\n \n     pub fn unwrap(self) -> Ty<'tcx> {\n@@ -513,8 +516,8 @@ impl<'tcx> FnOutput<'tcx> {\n pub type PolyFnOutput<'tcx> = Binder<FnOutput<'tcx>>;\n \n impl<'tcx> PolyFnOutput<'tcx> {\n-    pub fn diverges(&self) -> bool {\n-        self.0.diverges()\n+    pub fn diverges(&self, tcx: TyCtxt) -> bool {\n+        self.0.diverges(tcx)\n     }\n }\n \n@@ -936,11 +939,15 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn is_empty(&self, _cx: TyCtxt) -> bool {\n+    pub fn is_empty(&self, cx: TyCtxt) -> bool {\n         // FIXME(#24885): be smarter here\n         match self.sty {\n             TyEnum(def, _) | TyStruct(def, _) => def.is_empty(),\n-            _ => false\n+            TyEmpty => true,\n+            TyTuple(ref tys) => tys.iter().any(|ty| ty.is_empty(cx)),\n+            // FIXME (canndrew): this line breaks core::fmt\n+            //TyRef(_, ref tm) => tm.ty.is_empty(cx),\n+            _ => false,\n         }\n     }\n "}, {"sha": "692f0d3e5ac2bd97900726054a58af6e23f076be", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/104963c539e538a89fff21c133692fc21dac3e64/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/104963c539e538a89fff21c133692fc21dac3e64/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=104963c539e538a89fff21c133692fc21dac3e64", "patch": "@@ -210,7 +210,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Call { ty, fun, args } => {\n                 let diverges = match ty.sty {\n                     ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f) => {\n-                        f.sig.0.output.diverges()\n+                        f.sig.0.output.diverges(this.hir.tcx())\n                     }\n                     _ => false\n                 };"}, {"sha": "53329a85036fdefe1a10276dcc353158e2650858", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/104963c539e538a89fff21c133692fc21dac3e64/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/104963c539e538a89fff21c133692fc21dac3e64/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=104963c539e538a89fff21c133692fc21dac3e64", "patch": "@@ -504,9 +504,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 }\n             }\n             (&None, ty::FnDiverging) => {}\n-            (&None, ty::FnConverging(..)) => {\n-                span_mirbug!(self, term, \"call to converging function {:?} w/o dest\", sig);\n-             }\n+            (&None, ty::FnConverging(ref ty)) => {\n+                if !ty.is_empty(tcx) {\n+                    span_mirbug!(self, term, \"call to converging function {:?} w/o dest\", sig);\n+                }\n+            }\n         }\n     }\n "}, {"sha": "4c58ce6b78c033304b5301c2c6498baaf43694d1", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/104963c539e538a89fff21c133692fc21dac3e64/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/104963c539e538a89fff21c133692fc21dac3e64/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=104963c539e538a89fff21c133692fc21dac3e64", "patch": "@@ -171,6 +171,7 @@ impl<'tcx> TypeMap<'tcx> {\n         unique_type_id.push('{');\n \n         match type_.sty {\n+            ty::TyEmpty    |\n             ty::TyBool     |\n             ty::TyChar     |\n             ty::TyStr      |\n@@ -704,6 +705,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let sty = &t.sty;\n     let MetadataCreationResult { metadata, already_stored_in_typemap } = match *sty {\n+        ty::TyEmpty    |\n         ty::TyBool     |\n         ty::TyChar     |\n         ty::TyInt(_)   |\n@@ -931,6 +933,7 @@ fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     debug!(\"basic_type_metadata: {:?}\", t);\n \n     let (name, encoding) = match t.sty {\n+        ty::TyEmpty => (\"!\", DW_ATE_unsigned),\n         ty::TyTuple(ref elements) if elements.is_empty() =>\n             (\"()\", DW_ATE_unsigned),\n         ty::TyBool => (\"bool\", DW_ATE_boolean),"}, {"sha": "6b9917afdfbb77e08fa8b5088962a37aa3a06d1e", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/104963c539e538a89fff21c133692fc21dac3e64/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/104963c539e538a89fff21c133692fc21dac3e64/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=104963c539e538a89fff21c133692fc21dac3e64", "patch": "@@ -473,7 +473,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n         }\n \n-        self.write_ty(expr.id, result_ty);\n+        self.write_ty_expr(expr.id, result_ty);\n     }\n }\n \n@@ -550,7 +550,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let scheme = tcx.lookup_item_type(def.def_id());\n         let predicates = tcx.lookup_predicates(def.def_id());\n         let pat_ty = self.instantiate_value_path(segments, scheme, &predicates,\n-                                                 opt_ty, def, pat.span, pat.id);\n+                                                 opt_ty, def, pat.span, pat.id, false);\n         self.demand_suptype(pat.span, expected, pat_ty);\n     }\n \n@@ -618,7 +618,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n         let predicates = tcx.lookup_predicates(def.def_id());\n         let pat_ty = self.instantiate_value_path(segments, scheme, &predicates,\n-                                                 opt_ty, def, pat.span, pat.id);\n+                                                 opt_ty, def, pat.span, pat.id, false);\n         self.demand_eqtype(pat.span, expected, pat_ty);\n \n         // Type check subpatterns."}, {"sha": "4788911662d308823e307307a59b1a1a6e120721", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/104963c539e538a89fff21c133692fc21dac3e64/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/104963c539e538a89fff21c133692fc21dac3e64/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=104963c539e538a89fff21c133692fc21dac3e64", "patch": "@@ -106,7 +106,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n         };\n         (n_tps, inputs, ty::FnConverging(output))\n     } else if &name[..] == \"abort\" || &name[..] == \"unreachable\" {\n-        (0, Vec::new(), ty::FnDiverging)\n+        (0, Vec::new(), ty::FnConverging(tcx.mk_empty()))\n     } else {\n         let (n_tps, inputs, output) = match &name[..] {\n             \"breakpoint\" => (0, Vec::new(), tcx.mk_nil()),"}, {"sha": "89a4bc4cac6e30649a2b972934adb2ac1a7a1114", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 55, "deletions": 29, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/104963c539e538a89fff21c133692fc21dac3e64/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/104963c539e538a89fff21c133692fc21dac3e64/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=104963c539e538a89fff21c133692fc21dac3e64", "patch": "@@ -93,7 +93,7 @@ use rustc::traits::{self, Reveal};\n use rustc::ty::{GenericPredicates, TypeScheme};\n use rustc::ty::{ParamTy, ParameterEnvironment};\n use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n-use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, Visibility};\n+use rustc::ty::{self, ToPolyTraitRef, Ty, TypeVariants, TyCtxt, Visibility};\n use rustc::ty::{MethodCall, MethodCallee};\n use rustc::ty::adjustment;\n use rustc::ty::fold::{BottomUpFolder, TypeFoldable};\n@@ -1561,6 +1561,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.tables.borrow_mut().node_types.insert(node_id, ty);\n     }\n \n+    #[inline]\n+    pub fn write_ty_expr(&self, node_id: ast::NodeId, ty: Ty<'tcx>) {\n+        self.write_ty(node_id, ty);\n+        if let TypeVariants::TyEmpty = ty.sty {\n+            self.write_adjustment(node_id, adjustment::AdjustEmptyToAny(self.next_diverging_ty_var()));\n+        }\n+    }\n+\n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts<'tcx>) {\n         if !substs.substs.is_noop() {\n             debug!(\"write_substs({}, {:?}) in fcx {}\",\n@@ -1731,6 +1739,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn write_nil(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, self.tcx.mk_nil());\n     }\n+\n+    pub fn write_empty(&self, node_id: ast::NodeId) {\n+        self.write_ty_expr(node_id, self.tcx.mk_empty());\n+    }\n+\n     pub fn write_error(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, self.tcx.types.err);\n     }\n@@ -1788,6 +1801,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn expr_ty(&self, ex: &hir::Expr) -> Ty<'tcx> {\n+        if let Some(&adjustment::AdjustEmptyToAny(ref t))\n+                = self.tables.borrow().adjustments.get(&ex.id) {\n+            return t;\n+        }\n         match self.tables.borrow().node_types.get(&ex.id) {\n             Some(&t) => t,\n             None => {\n@@ -1966,9 +1983,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         for ty in &self.unsolved_variables() {\n             let resolved = self.resolve_type_vars_if_possible(ty);\n             if self.type_var_diverges(resolved) {\n-                debug!(\"default_type_parameters: defaulting `{:?}` to `()` because it diverges\",\n+                debug!(\"default_type_parameters: defaulting `{:?}` to `!` because it diverges\",\n                        resolved);\n-                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.mk_nil());\n+                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.mk_empty());\n             } else {\n                 match self.type_is_unconstrained_numeric(resolved) {\n                     UnconstrainedInt => {\n@@ -2042,7 +2059,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             for ty in &unsolved_variables {\n                 let resolved = self.resolve_type_vars_if_possible(ty);\n                 if self.type_var_diverges(resolved) {\n-                    self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.mk_nil());\n+                    self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.mk_empty());\n                 } else {\n                     match self.type_is_unconstrained_numeric(resolved) {\n                         UnconstrainedInt | UnconstrainedFloat => {\n@@ -2100,7 +2117,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let _ = self.commit_if_ok(|_: &infer::CombinedSnapshot| {\n                 for ty in &unbound_tyvars {\n                     if self.type_var_diverges(ty) {\n-                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.mk_nil());\n+                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.mk_empty());\n                     } else {\n                         match self.type_is_unconstrained_numeric(ty) {\n                             UnconstrainedInt => {\n@@ -2196,7 +2213,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // reporting for more then one conflict.\n         for ty in &unbound_tyvars {\n             if self.type_var_diverges(ty) {\n-                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.mk_nil());\n+                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.mk_empty());\n             } else {\n                 match self.type_is_unconstrained_numeric(ty) {\n                     UnconstrainedInt => {\n@@ -2601,7 +2618,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 if let Some(&arg_ty) = self.tables.borrow().node_types.get(&arg.id) {\n-                    any_diverges = any_diverges || self.type_var_diverges(arg_ty);\n+                    any_diverges = any_diverges ||\n+                                   self.type_var_diverges(arg_ty) ||\n+                                   arg_ty.is_empty(self.tcx);\n                 }\n             }\n             if any_diverges && !warned {\n@@ -2670,7 +2689,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn write_call(&self,\n                   call_expr: &hir::Expr,\n                   output: ty::FnOutput<'tcx>) {\n-        self.write_ty(call_expr.id, match output {\n+        self.write_ty_expr(call_expr.id, match output {\n             ty::FnConverging(output_ty) => output_ty,\n             ty::FnDiverging => self.next_diverging_ty_var()\n         });\n@@ -2910,7 +2929,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // the type of the block, because old trans still uses it.\n                 let adj = self.tables.borrow().adjustments.get(&then.id).cloned();\n                 if res.is_ok() && adj.is_some() {\n-                    self.write_ty(then_blk.id, self.adjust_expr_ty(then, adj.as_ref()));\n+                    self.write_ty_expr(then_blk.id, self.adjust_expr_ty(then, adj.as_ref()));\n                 }\n \n                 res\n@@ -2951,7 +2970,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        self.write_ty(id, if_ty);\n+        self.write_ty_expr(id, if_ty);\n     }\n \n     // Check field access expressions\n@@ -2972,7 +2991,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let field_ty = self.field_ty(expr.span, field, substs);\n                     if field.vis.is_accessible_from(self.body_id, &self.tcx().map) {\n                         autoderef.finalize(lvalue_pref, Some(base));\n-                        self.write_ty(expr.id, field_ty);\n+                        self.write_ty_expr(expr.id, field_ty);\n                         self.write_autoderef_adjustment(base.id, autoderefs);\n                         return;\n                     }\n@@ -2984,7 +3003,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some((did, field_ty)) = private_candidate {\n             let struct_path = self.tcx().item_path_str(did);\n-            self.write_ty(expr.id, field_ty);\n+            self.write_ty_expr(expr.id, field_ty);\n             let msg = format!(\"field `{}` of struct `{}` is private\", field.node, struct_path);\n             let mut err = self.tcx().sess.struct_span_err(expr.span, &msg);\n             // Also check if an accessible method exists, which is often what is meant.\n@@ -3079,7 +3098,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             if let Some(field_ty) = field {\n                 autoderef.finalize(lvalue_pref, Some(base));\n-                self.write_ty(expr.id, field_ty);\n+                self.write_ty_expr(expr.id, field_ty);\n                 self.write_autoderef_adjustment(base.id, autoderefs);\n                 return;\n             }\n@@ -3090,7 +3109,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let struct_path = self.tcx().item_path_str(did);\n             let msg = format!(\"field `{}` of struct `{}` is private\", idx.node, struct_path);\n             self.tcx().sess.span_err(expr.span, &msg);\n-            self.write_ty(expr.id, field_ty);\n+            self.write_ty_expr(expr.id, field_ty);\n             return;\n         }\n \n@@ -3343,7 +3362,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n           hir::ExprLit(ref lit) => {\n             let typ = self.check_lit(&lit, expected);\n-            self.write_ty(id, typ);\n+            self.write_ty_expr(id, typ);\n           }\n           hir::ExprBinary(op, ref lhs, ref rhs) => {\n             self.check_binop(expr, op, lhs, rhs);\n@@ -3409,7 +3428,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            self.write_ty(id, oprnd_t);\n+            self.write_ty_expr(id, oprnd_t);\n           }\n           hir::ExprAddrOf(mutbl, ref oprnd) => {\n             let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n@@ -3460,7 +3479,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   let (scheme, predicates) = self.type_scheme_and_predicates_for_def(expr.span,\n                                                                                      def);\n                   self.instantiate_value_path(segments, scheme, &predicates,\n-                                              opt_ty, def, expr.span, id);\n+                                              opt_ty, def, expr.span, id, true);\n               } else {\n                   self.set_tainted_by_errors();\n                   self.write_error(id);\n@@ -3481,8 +3500,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               }\n               self.write_nil(id);\n           }\n-          hir::ExprBreak(_) => { self.write_ty(id, self.next_diverging_ty_var()); }\n-          hir::ExprAgain(_) => { self.write_ty(id, self.next_diverging_ty_var()); }\n+          hir::ExprBreak(_) => { self.write_empty(id); }\n+          hir::ExprAgain(_) => { self.write_empty(id); }\n           hir::ExprRet(ref expr_opt) => {\n             match self.ret_ty {\n                 ty::FnConverging(result_type) => {\n@@ -3513,7 +3532,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         .emit();\n                 }\n             }\n-            self.write_ty(id, self.next_diverging_ty_var());\n+            self.write_empty(id);\n           }\n           hir::ExprAssign(ref lhs, ref rhs) => {\n             self.check_expr_with_lvalue_pref(&lhs, PreferMutLvalue);\n@@ -3555,7 +3574,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprLoop(ref body, _) => {\n             self.check_block_no_value(&body);\n             if !may_break(tcx, expr.id, &body) {\n-                self.write_ty(id, self.next_diverging_ty_var());\n+                self.write_empty(id);\n             } else {\n                 self.write_nil(id);\n             }\n@@ -3568,7 +3587,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           }\n           hir::ExprBlock(ref b) => {\n             self.check_block_with_expected(&b, expected);\n-            self.write_ty(id, self.node_ty(b.id));\n+            self.write_ty_expr(id, self.node_ty(b.id));\n           }\n           hir::ExprCall(ref callee, ref args) => {\n               self.check_call(expr, &callee, &args[..], expected);\n@@ -3604,7 +3623,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             } else {\n                 // Write a type for the whole expression, assuming everything is going\n                 // to work out Ok.\n-                self.write_ty(id, t_cast);\n+                self.write_ty_expr(id, t_cast);\n \n                 // Defer other checks until we're done type checking.\n                 let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n@@ -3621,7 +3640,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprType(ref e, ref t) => {\n             let typ = self.to_ty(&t);\n             self.check_expr_eq_type(&e, typ);\n-            self.write_ty(id, typ);\n+            self.write_ty_expr(id, typ);\n           }\n           hir::ExprVec(ref args) => {\n             let uty = expected.to_option(self).and_then(|uty| {\n@@ -3755,7 +3774,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       Some((index_ty, element_ty)) => {\n                           let idx_expr_ty = self.expr_ty(idx);\n                           self.demand_eqtype(expr.span, index_ty, idx_expr_ty);\n-                          self.write_ty(id, element_ty);\n+                          self.write_ty_expr(id, element_ty);\n                       }\n                       None => {\n                           self.check_expr_has_type(&idx, self.tcx.types.err);\n@@ -4011,7 +4030,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               \"unreachable statement\".to_string());\n                 warned = true;\n             }\n-            any_diverges = any_diverges || self.type_var_diverges(s_ty);\n+            any_diverges = any_diverges ||\n+                           self.type_var_diverges(s_ty) ||\n+                           s_ty.is_empty(self.tcx);\n             any_err = any_err || s_ty.references_error();\n         }\n         match blk.expr {\n@@ -4047,7 +4068,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 } else if any_diverges {\n                     self.write_ty(blk.id, self.next_diverging_ty_var());\n                 } else {\n-                    self.write_ty(blk.id, ety);\n+                    self.write_ty_expr(blk.id, ety);\n                 }\n             }\n         };\n@@ -4096,7 +4117,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   opt_self_ty: Option<Ty<'tcx>>,\n                                   def: Def,\n                                   span: Span,\n-                                  node_id: ast::NodeId)\n+                                  node_id: ast::NodeId,\n+                                  node_is_expr: bool) {\n                                   -> Ty<'tcx> {\n         debug!(\"instantiate_value_path(path={:?}, def={:?}, node_id={}, type_scheme={:?})\",\n                segments,\n@@ -4360,7 +4382,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"instantiate_value_path: type of {:?} is {:?}\",\n                node_id,\n                ty_substituted);\n-        self.write_ty(node_id, ty_substituted);\n+        if node_is_expr {\n+            self.write_ty_expr(node_id, ty_substituted);\n+        } else {\n+            self.write_ty(node_id, ty_substituted);\n+        }\n         self.write_substs(node_id, ty::ItemSubsts {\n             substs: substs\n         });"}, {"sha": "17da3cd34904ec3059169e90f0c9b58e9439f12f", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/104963c539e538a89fff21c133692fc21dac3e64/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/104963c539e538a89fff21c133692fc21dac3e64/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=104963c539e538a89fff21c133692fc21dac3e64", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.enforce_builtin_binop_types(lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n             self.write_nil(expr.id);\n         } else {\n-            self.write_ty(expr.id, return_ty);\n+            self.write_ty_expr(expr.id, return_ty);\n         }\n \n         let tcx = self.tcx;\n@@ -69,7 +69,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // && and || are a simple case.\n                 self.demand_suptype(lhs_expr.span, tcx.mk_bool(), lhs_ty);\n                 self.check_expr_coercable_to_type(rhs_expr, tcx.mk_bool());\n-                self.write_ty(expr.id, tcx.mk_bool());\n+                self.write_ty_expr(expr.id, tcx.mk_bool());\n             }\n             _ => {\n                 // Otherwise, we always treat operators as if they are\n@@ -101,7 +101,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     self.demand_suptype(expr.span, builtin_return_ty, return_ty);\n                 }\n \n-                self.write_ty(expr.id, return_ty);\n+                self.write_ty_expr(expr.id, return_ty);\n             }\n         }\n     }"}, {"sha": "4f54f52932261cfa6c70914d5a262bd354c3e445", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/104963c539e538a89fff21c133692fc21dac3e64/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/104963c539e538a89fff21c133692fc21dac3e64/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=104963c539e538a89fff21c133692fc21dac3e64", "patch": "@@ -1332,11 +1332,7 @@ impl<'a> Parser<'a> {\n     /// Parse optional return type [ -> TY ] in function decl\n     pub fn parse_ret_ty(&mut self) -> PResult<'a, FunctionRetTy> {\n         if self.eat(&token::RArrow) {\n-            if self.eat(&token::Not) {\n-                Ok(FunctionRetTy::None(self.last_span))\n-            } else {\n-                Ok(FunctionRetTy::Ty(self.parse_ty()?))\n-            }\n+            Ok(FunctionRetTy::Ty(self.parse_ty()?))\n         } else {\n             let pos = self.span.lo;\n             Ok(FunctionRetTy::Default(mk_sp(pos, pos)))"}]}