{"sha": "7c4f94be4859ee6b6bc8fd50fa75328b3d30c9aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNGY5NGJlNDg1OWVlNmI2YmM4ZmQ1MGZhNzUzMjhiM2QzMGM5YWE=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-19T22:58:04Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-27T00:46:32Z"}, "message": "Use pat_constructor to simplify specialize_one_pattern", "tree": {"sha": "96e87c839a8f74953ab10185e98b220703357f2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96e87c839a8f74953ab10185e98b220703357f2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c4f94be4859ee6b6bc8fd50fa75328b3d30c9aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c4f94be4859ee6b6bc8fd50fa75328b3d30c9aa", "html_url": "https://github.com/rust-lang/rust/commit/7c4f94be4859ee6b6bc8fd50fa75328b3d30c9aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c4f94be4859ee6b6bc8fd50fa75328b3d30c9aa/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "feb1e13960ab435ba14a37e237a3c5aaee8b9558", "url": "https://api.github.com/repos/rust-lang/rust/commits/feb1e13960ab435ba14a37e237a3c5aaee8b9558", "html_url": "https://github.com/rust-lang/rust/commit/feb1e13960ab435ba14a37e237a3c5aaee8b9558"}], "stats": {"total": 176, "additions": 71, "deletions": 105}, "files": [{"sha": "3c9b8d5da1d2419fef07368707d6ace97cf0bb63", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 71, "deletions": 105, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/7c4f94be4859ee6b6bc8fd50fa75328b3d30c9aa/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4f94be4859ee6b6bc8fd50fa75328b3d30c9aa/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=7c4f94be4859ee6b6bc8fd50fa75328b3d30c9aa", "patch": "@@ -2529,17 +2529,69 @@ fn specialize_one_pattern<'p, 'tcx>(\n     pat: &'p Pat<'tcx>,\n     constructor: &Constructor<'tcx>,\n     ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n-    is_its_own_ctor: bool, // Whether `ctor` is known to be derived from `pat`\n+    is_its_own_ctor: bool, // Whether `constructor` is known to be derived from `pat`\n ) -> Option<Fields<'p, 'tcx>> {\n-    if let NonExhaustive = constructor {\n-        // Only a wildcard pattern can match the special extra constructor.\n-        if !pat.is_wildcard() {\n-            return None;\n-        }\n-        return Some(Fields::empty());\n+    if pat.is_wildcard() {\n+        return Some(ctor_wild_subpatterns.clone());\n     }\n \n-    if let Opaque = constructor {\n+    let ty = pat.ty;\n+    // `unwrap` is safe because `pat` is not a wildcard.\n+    let pat_ctor = pat_constructor(cx.tcx, cx.param_env, pat).unwrap();\n+\n+    let result = match (constructor, &pat_ctor, pat.kind.as_ref()) {\n+        (Single, Single, PatKind::Leaf { subpatterns }) => {\n+            Some(ctor_wild_subpatterns.replace_with_fieldpats(subpatterns))\n+        }\n+        (Single, Single, PatKind::Deref { subpattern }) => {\n+            Some(Fields::from_single_pattern(subpattern))\n+        }\n+        (Variant(_), Variant(_), _) if constructor != &pat_ctor => None,\n+        (Variant(_), Variant(_), PatKind::Variant { subpatterns, .. }) => {\n+            Some(ctor_wild_subpatterns.replace_with_fieldpats(subpatterns))\n+        }\n+\n+        (IntRange(ctor_range), IntRange(pat_range), _) => {\n+            ctor_range.intersection(cx.tcx, &pat_range)?;\n+            // Constructor splitting should ensure that all intersections we encounter\n+            // are actually inclusions.\n+            assert!(ctor_range.is_subrange(&pat_range));\n+            Some(Fields::empty())\n+        }\n+        (FloatRange(ctor_from, ctor_to, ctor_end), FloatRange(pat_from, pat_to, pat_end), _) => {\n+            let to = compare_const_vals(cx.tcx, ctor_to, pat_to, cx.param_env, ty)?;\n+            let from = compare_const_vals(cx.tcx, ctor_from, pat_from, cx.param_env, ty)?;\n+            let intersects = (from == Ordering::Greater || from == Ordering::Equal)\n+                && (to == Ordering::Less || (pat_end == ctor_end && to == Ordering::Equal));\n+            if intersects { Some(Fields::empty()) } else { None }\n+        }\n+        (Str(ctor_val), Str(pat_val), _) => {\n+            // FIXME: there's probably a more direct way of comparing for equality\n+            let comparison = compare_const_vals(cx.tcx, ctor_val, pat_val, cx.param_env, ty)?;\n+            if comparison == Ordering::Equal { Some(Fields::empty()) } else { None }\n+        }\n+\n+        (Slice(ctor_slice), Slice(pat_slice), _)\n+            if !pat_slice.pattern_kind().covers_length(ctor_slice.arity()) =>\n+        {\n+            None\n+        }\n+        (\n+            Slice(ctor_slice),\n+            Slice(_),\n+            PatKind::Array { prefix, suffix, .. } | PatKind::Slice { prefix, suffix, .. },\n+        ) => {\n+            // Number of subpatterns for the constructor\n+            let ctor_arity = ctor_slice.arity();\n+\n+            // Replace the prefix and the suffix with the given patterns, leaving wildcards in\n+            // the middle if there was a subslice pattern `..`.\n+            let prefix = prefix.iter().enumerate();\n+            let suffix =\n+                suffix.iter().enumerate().map(|(i, p)| (ctor_arity as usize - suffix.len() + i, p));\n+            Some(ctor_wild_subpatterns.replace_fields_indexed(prefix.chain(suffix)))\n+        }\n+\n         // Only a wildcard pattern can match an opaque constant, unless we're specializing the\n         // value against its own constructor. That happens when we call\n         // `v.specialize_constructor(ctor)` with `ctor` obtained from `pat_constructor(v.head())`.\n@@ -2559,109 +2611,23 @@ fn specialize_one_pattern<'p, 'tcx>(\n         //     (FOO, false) => {}\n         // }\n         // ```\n-        if is_its_own_ctor || pat.is_wildcard() {\n-            return Some(Fields::empty());\n-        } else {\n-            return None;\n-        }\n-    }\n-\n-    let result = match *pat.kind {\n-        PatKind::AscribeUserType { .. } => bug!(), // Handled by `expand_pattern`\n-\n-        PatKind::Binding { .. } | PatKind::Wild => Some(ctor_wild_subpatterns.clone()),\n-\n-        PatKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n-            let variant = &adt_def.variants[variant_index];\n-            if constructor != &Variant(variant.def_id) {\n-                return None;\n-            }\n-            Some(ctor_wild_subpatterns.replace_with_fieldpats(subpatterns))\n-        }\n-\n-        PatKind::Leaf { ref subpatterns } => {\n-            Some(ctor_wild_subpatterns.replace_with_fieldpats(subpatterns))\n-        }\n-\n-        PatKind::Deref { ref subpattern } => Some(Fields::from_single_pattern(subpattern)),\n-\n-        PatKind::Constant { .. } | PatKind::Range { .. } => {\n-            match constructor {\n-                IntRange(ctor) => {\n-                    let pat = IntRange::from_pat(cx.tcx, cx.param_env, pat)?;\n-                    ctor.intersection(cx.tcx, &pat)?;\n-                    // Constructor splitting should ensure that all intersections we encounter\n-                    // are actually inclusions.\n-                    assert!(ctor.is_subrange(&pat));\n-                }\n-                FloatRange(ctor_from, ctor_to, ctor_end) => {\n-                    let (pat_from, pat_to, pat_end, ty) = match *pat.kind {\n-                        PatKind::Constant { value } => (value, value, RangeEnd::Included, value.ty),\n-                        PatKind::Range(PatRange { lo, hi, end }) => (lo, hi, end, lo.ty),\n-                        _ => unreachable!(), // This is ensured by the branch we're in\n-                    };\n-                    let to = compare_const_vals(cx.tcx, ctor_to, pat_to, cx.param_env, ty)?;\n-                    let from = compare_const_vals(cx.tcx, ctor_from, pat_from, cx.param_env, ty)?;\n-                    let intersects = (from == Ordering::Greater || from == Ordering::Equal)\n-                        && (to == Ordering::Less\n-                            || (pat_end == *ctor_end && to == Ordering::Equal));\n-                    if !intersects {\n-                        return None;\n-                    }\n-                }\n-                Str(ctor_value) => {\n-                    let pat_value = match *pat.kind {\n-                        PatKind::Constant { value } => value,\n-                        _ => span_bug!(\n-                            pat.span,\n-                            \"unexpected range pattern {:?} for constant value ctor\",\n-                            pat\n-                        ),\n-                    };\n-\n-                    // FIXME: there's probably a more direct way of comparing for equality\n-                    if compare_const_vals(cx.tcx, ctor_value, pat_value, cx.param_env, pat.ty)?\n-                        != Ordering::Equal\n-                    {\n-                        return None;\n-                    }\n-                }\n-                _ => {\n-                    // If we reach here, we must be trying to inspect an opaque constant. Thus we skip\n-                    // the row.\n-                    return None;\n-                }\n-            }\n-            Some(Fields::empty())\n-        }\n-\n-        PatKind::Array { ref prefix, ref slice, ref suffix }\n-        | PatKind::Slice { ref prefix, ref slice, ref suffix } => match *constructor {\n-            Slice(_) => {\n-                // Number of subpatterns for this pattern\n-                let pat_len = prefix.len() + suffix.len();\n-                // Number of subpatterns for this constructor\n-                let arity = ctor_wild_subpatterns.len();\n-\n-                if (slice.is_none() && arity != pat_len) || pat_len > arity {\n-                    return None;\n-                }\n-\n-                // Replace the prefix and the suffix with the given patterns, leaving wildcards in\n-                // the middle if there was a subslice pattern `..`.\n-                let prefix = prefix.iter().enumerate();\n-                let suffix = suffix.iter().enumerate().map(|(i, p)| (arity - suffix.len() + i, p));\n-                Some(ctor_wild_subpatterns.replace_fields_indexed(prefix.chain(suffix)))\n-            }\n-            _ => span_bug!(pat.span, \"unexpected ctor {:?} for slice pat\", constructor),\n-        },\n+        (Opaque, Opaque, _) if is_its_own_ctor => Some(Fields::empty()),\n+        // We are trying to inspect an opaque constant. Thus we skip the row.\n+        (Opaque, _, _) | (_, Opaque, _) => None,\n+        // Only a wildcard pattern can match the special extra constructor.\n+        (NonExhaustive, _, _) => None,\n \n-        PatKind::Or { .. } => bug!(\"Or-pattern should have been expanded earlier on.\"),\n+        _ => bug!(\"trying to specialize pattern {:?} with constructor {:?}\", pat, constructor),\n     };\n+\n     debug!(\n         \"specialize({:#?}, {:#?}, {:#?}) = {:#?}\",\n         pat, constructor, ctor_wild_subpatterns, result\n     );\n \n+    if let Some(fields) = &result {\n+        debug_assert_eq!(fields.len(), ctor_wild_subpatterns.len());\n+    }\n+\n     result\n }"}]}