{"sha": "a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4OTY0NDBjYTFiOTNjYzVkYzZlZGQ4MjdlYTJhZTg5NjAyYmZhOWU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-03-15T19:24:24Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-04-30T10:59:32Z"}, "message": "new borrow checker (mass squash)", "tree": {"sha": "c6945d51bf84faeb9be6ac32247c8ffa2cd39226", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6945d51bf84faeb9be6ac32247c8ffa2cd39226"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "html_url": "https://github.com/rust-lang/rust/commit/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5a7e8b35322869b1cf51bd1b35a86e9e721da54", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5a7e8b35322869b1cf51bd1b35a86e9e721da54", "html_url": "https://github.com/rust-lang/rust/commit/b5a7e8b35322869b1cf51bd1b35a86e9e721da54"}], "stats": {"total": 10726, "additions": 6449, "deletions": 4277}, "files": [{"sha": "1dfe1b22dc4fb4bc94dc98706ec60b55c68e335b", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -126,22 +126,29 @@ struct AnnihilateStats {\n     n_bytes_freed: uint\n }\n \n-unsafe fn each_live_alloc(f: &fn(box: *mut BoxRepr, uniq: bool) -> bool) {\n+unsafe fn each_live_alloc(read_next_before: bool,\n+                          f: &fn(box: *mut BoxRepr, uniq: bool) -> bool) {\n+    //! Walks the internal list of allocations\n+\n     use managed;\n \n     let task: *Task = transmute(rustrt::rust_get_task());\n     let box = (*task).boxed_region.live_allocs;\n     let mut box: *mut BoxRepr = transmute(copy box);\n     while box != mut_null() {\n-        let next = transmute(copy (*box).header.next);\n+        let next_before = transmute(copy (*box).header.next);\n         let uniq =\n             (*box).header.ref_count == managed::raw::RC_MANAGED_UNIQUE;\n \n         if ! f(box, uniq) {\n             break\n         }\n \n-        box = next\n+        if read_next_before {\n+            box = next_before;\n+        } else {\n+            box = transmute(copy (*box).header.next);\n+        }\n     }\n }\n \n@@ -159,7 +166,7 @@ fn debug_mem() -> bool {\n #[cfg(notest)]\n #[lang=\"annihilate\"]\n pub unsafe fn annihilate() {\n-    use unstable::lang::local_free;\n+    use unstable::lang::{local_free, debug_ptr};\n     use io::WriterUtil;\n     use io;\n     use libc;\n@@ -173,27 +180,46 @@ pub unsafe fn annihilate() {\n     };\n \n     // Pass 1: Make all boxes immortal.\n-    for each_live_alloc |box, uniq| {\n+    //\n+    // In this pass, nothing gets freed, so it does not matter whether\n+    // we read the next field before or after the callback.\n+    for each_live_alloc(true) |box, uniq| {\n         stats.n_total_boxes += 1;\n         if uniq {\n+            debug_ptr(\"Managed-uniq: \", &*box);\n             stats.n_unique_boxes += 1;\n         } else {\n+            debug_ptr(\"Immortalizing: \", &*box);\n             (*box).header.ref_count = managed::raw::RC_IMMORTAL;\n         }\n     }\n \n     // Pass 2: Drop all boxes.\n-    for each_live_alloc |box, uniq| {\n+    //\n+    // In this pass, unique-managed boxes may get freed, but not\n+    // managed boxes, so we must read the `next` field *after* the\n+    // callback, as the original value may have been freed.\n+    for each_live_alloc(false) |box, uniq| {\n         if !uniq {\n+            debug_ptr(\"Invoking tydesc/glue on: \", &*box);\n             let tydesc: *TypeDesc = transmute(copy (*box).header.type_desc);\n             let drop_glue: DropGlue = transmute(((*tydesc).drop_glue, 0));\n+            debug_ptr(\"Box data: \", &(*box).data);\n+            debug_ptr(\"Type descriptor: \", tydesc);\n             drop_glue(to_unsafe_ptr(&tydesc), transmute(&(*box).data));\n+            debug_ptr(\"Dropped \", &*box);\n         }\n     }\n \n     // Pass 3: Free all boxes.\n-    for each_live_alloc |box, uniq| {\n+    //\n+    // In this pass, managed boxes may get freed (but not\n+    // unique-managed boxes, though I think that none of those are\n+    // left), so we must read the `next` field before, since it will\n+    // not be valid after.\n+    for each_live_alloc(true) |box, uniq| {\n         if !uniq {\n+            debug_ptr(\"About to free: \", &*box);\n             stats.n_bytes_freed +=\n                 (*((*box).header.type_desc)).size\n                 + sys::size_of::<BoxRepr>();"}, {"sha": "217ea1a9982c14e4c914a2f0014972c958da8c73", "filename": "src/libcore/io.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -1022,7 +1022,7 @@ pub enum WriterType { Screen, File }\n pub trait Writer {\n \n     /// Write all of the given bytes.\n-    fn write(&self, v: &const [u8]);\n+    fn write(&self, v: &[u8]);\n \n     /// Move the current position within the stream. The second parameter\n     /// determines the position that the first parameter is relative to.\n@@ -1039,23 +1039,23 @@ pub trait Writer {\n }\n \n impl Writer for @Writer {\n-    fn write(&self, v: &const [u8]) { self.write(v) }\n+    fn write(&self, v: &[u8]) { self.write(v) }\n     fn seek(&self, a: int, b: SeekStyle) { self.seek(a, b) }\n     fn tell(&self) -> uint { self.tell() }\n     fn flush(&self) -> int { self.flush() }\n     fn get_type(&self) -> WriterType { self.get_type() }\n }\n \n impl<W:Writer,C> Writer for Wrapper<W, C> {\n-    fn write(&self, bs: &const [u8]) { self.base.write(bs); }\n+    fn write(&self, bs: &[u8]) { self.base.write(bs); }\n     fn seek(&self, off: int, style: SeekStyle) { self.base.seek(off, style); }\n     fn tell(&self) -> uint { self.base.tell() }\n     fn flush(&self) -> int { self.base.flush() }\n     fn get_type(&self) -> WriterType { File }\n }\n \n impl Writer for *libc::FILE {\n-    fn write(&self, v: &const [u8]) {\n+    fn write(&self, v: &[u8]) {\n         unsafe {\n             do vec::as_const_buf(v) |vbuf, len| {\n                 let nout = libc::fwrite(vbuf as *c_void,\n@@ -1105,7 +1105,7 @@ pub fn FILE_writer(f: *libc::FILE, cleanup: bool) -> @Writer {\n }\n \n impl Writer for fd_t {\n-    fn write(&self, v: &const [u8]) {\n+    fn write(&self, v: &[u8]) {\n         unsafe {\n             let mut count = 0u;\n             do vec::as_const_buf(v) |vbuf, len| {\n@@ -1262,7 +1262,7 @@ pub fn u64_to_be_bytes<T>(n: u64, size: uint,\n     }\n }\n \n-pub fn u64_from_be_bytes(data: &const [u8],\n+pub fn u64_from_be_bytes(data: &[u8],\n                          start: uint,\n                          size: uint)\n                       -> u64 {\n@@ -1497,7 +1497,7 @@ pub struct BytesWriter {\n }\n \n impl Writer for BytesWriter {\n-    fn write(&self, v: &const [u8]) {\n+    fn write(&self, v: &[u8]) {\n         let v_len = v.len();\n         let bytes_len = vec::uniq_len(&const self.bytes);\n "}, {"sha": "a2132676c1a03abc217cf9c6be733976a7018b59", "filename": "src/libcore/rt/sched/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Fmod.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -304,7 +304,7 @@ pub impl Scheduler {\n         unsafe {\n             let last_task = transmute::<Option<&Task>, Option<&mut Task>>(last_task);\n             let last_task_context = match last_task {\n-                Some(ref t) => Some(&mut t.saved_context), None => None\n+                Some(t) => Some(&mut t.saved_context), None => None\n             };\n             let next_task_context = match self.current_task {\n                 Some(ref mut t) => Some(&mut t.saved_context), None => None"}, {"sha": "f4430ca669fb12225c7e5016cfe757c0fc969dd7", "filename": "src/libcore/str.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -2356,9 +2356,6 @@ pub trait StrSlice<'self> {\n     fn any(&self, it: &fn(char) -> bool) -> bool;\n     fn contains<'a>(&self, needle: &'a str) -> bool;\n     fn contains_char(&self, needle: char) -> bool;\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn char_iter(&self) -> StrCharIterator<'self>;\n     fn each(&self, it: &fn(u8) -> bool);\n     fn eachi(&self, it: &fn(uint, u8) -> bool);\n@@ -2420,9 +2417,6 @@ impl<'self> StrSlice<'self> for &'self str {\n         contains_char(*self, needle)\n     }\n \n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     #[inline]\n     fn char_iter(&self) -> StrCharIterator<'self> {\n         StrCharIterator {\n@@ -2615,17 +2609,11 @@ impl Clone for ~str {\n     }\n }\n \n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n pub struct StrCharIterator<'self> {\n     priv index: uint,\n     priv string: &'self str,\n }\n \n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n impl<'self> Iterator<char> for StrCharIterator<'self> {\n     #[inline]\n     fn next(&mut self) -> Option<char> {"}, {"sha": "63dcf0f44dc3ba95ba15c782c1209a8195268fb7", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -19,7 +19,7 @@ use io::Writer;\n use option::{None, Option, Some};\n use str;\n \n-pub type Cb<'self> = &'self fn(buf: &const [u8]) -> bool;\n+pub type Cb<'self> = &'self fn(buf: &[u8]) -> bool;\n \n /**\n  * A trait to implement in order to make a type hashable;"}, {"sha": "cf71b01aeaeebd3f71a7762d4b3ce2a2077619a8", "filename": "src/libcore/unstable/lang.rs", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibcore%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibcore%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Flang.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -11,7 +11,7 @@\n //! Runtime calls emitted by the compiler.\n \n use cast::transmute;\n-use libc::{c_char, c_uchar, c_void, size_t, uintptr_t, c_int};\n+use libc::{c_char, c_uchar, c_void, size_t, uintptr_t, c_int, STDERR_FILENO};\n use managed::raw::BoxRepr;\n use str;\n use sys;\n@@ -74,7 +74,44 @@ pub fn fail_borrowed() {\n #[lang=\"exchange_malloc\"]\n #[inline(always)]\n pub unsafe fn exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n-    transmute(exchange_alloc::malloc(transmute(td), transmute(size)))\n+    let result = transmute(exchange_alloc::malloc(transmute(td), transmute(size)));\n+    debug_ptr(\"exchange_malloc: \", result);\n+    return result;\n+}\n+\n+/// Because this code is so perf. sensitive, use a static constant so that\n+/// debug printouts are compiled out most of the time.\n+static ENABLE_DEBUG_PTR: bool = false;\n+\n+#[inline]\n+pub fn debug_ptr<T>(tag: &'static str, p: *T) {\n+    //! A useful debugging function that prints a pointer + tag + newline\n+    //! without allocating memory.\n+\n+    if ENABLE_DEBUG_PTR && ::rt::env::get().debug_mem {\n+        debug_ptr_slow(tag, p);\n+    }\n+\n+    fn debug_ptr_slow<T>(tag: &'static str, p: *T) {\n+        use io;\n+        let dbg = STDERR_FILENO as io::fd_t;\n+        let letters = ['0', '1', '2', '3', '4', '5', '6', '7', '8',\n+                       '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n+        dbg.write_str(tag);\n+\n+        static uint_nibbles: uint = ::uint::bytes << 1;\n+        let mut buffer = [0_u8, ..uint_nibbles+1];\n+        let mut i = p as uint;\n+        let mut c = uint_nibbles;\n+        while c > 0 {\n+            c -= 1;\n+            buffer[c] = letters[i & 0xF] as u8;\n+            i >>= 4;\n+        }\n+        dbg.write(buffer.slice(0, uint_nibbles));\n+\n+        dbg.write_str(\"\\n\");\n+    }\n }\n \n // NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n@@ -83,13 +120,16 @@ pub unsafe fn exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n #[lang=\"exchange_free\"]\n #[inline(always)]\n pub unsafe fn exchange_free(ptr: *c_char) {\n+    debug_ptr(\"exchange_free: \", ptr);\n     exchange_alloc::free(transmute(ptr))\n }\n \n #[lang=\"malloc\"]\n #[inline(always)]\n pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n-    return rustrt::rust_upcall_malloc_noswitch(td, size);\n+    let result = rustrt::rust_upcall_malloc_noswitch(td, size);\n+    debug_ptr(\"local_malloc: \", result);\n+    return result;\n }\n \n // NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n@@ -98,6 +138,7 @@ pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n #[lang=\"free\"]\n #[inline(always)]\n pub unsafe fn local_free(ptr: *c_char) {\n+    debug_ptr(\"local_free: \", ptr);\n     rustrt::rust_upcall_free_noswitch(ptr);\n }\n "}, {"sha": "2f9488d1bc7a736a06f2192da887800e58cdff5a", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -19,9 +19,6 @@ use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use clone::Clone;\n use old_iter::BaseIter;\n use old_iter;\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n use iterator::Iterator;\n use kinds::Copy;\n use libc;\n@@ -1824,7 +1821,7 @@ pub trait CopyableVector<T> {\n }\n \n /// Extension methods for vectors\n-impl<'self,T:Copy> CopyableVector<T> for &'self const [T] {\n+impl<'self,T:Copy> CopyableVector<T> for &'self [T] {\n     /// Returns a copy of `v`.\n     #[inline]\n     fn to_owned(&self) -> ~[T] {\n@@ -2710,18 +2707,12 @@ impl<A:Clone> Clone for ~[A] {\n }\n \n // could be implemented with &[T] with .slice(), but this avoids bounds checks\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n pub struct VecIterator<'self, T> {\n     priv ptr: *T,\n     priv end: *T,\n     priv lifetime: &'self T // FIXME: #5922\n }\n \n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n impl<'self, T> Iterator<&'self T> for VecIterator<'self, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'self T> {"}, {"sha": "e899b1abc26486f99866011de0ac828b55341f2c", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -263,38 +263,35 @@ pub fn compile_rest(sess: Session,\n              middle::check_loop::check_crate(ty_cx, crate));\n \n         let middle::moves::MoveMaps {moves_map, variable_moves_map,\n-                                     capture_map} =\n+                                     moved_variables_set, capture_map} =\n             time(time_passes, ~\"compute moves\", ||\n                  middle::moves::compute_moves(ty_cx, method_map, crate));\n \n         time(time_passes, ~\"match checking\", ||\n              middle::check_match::check_crate(ty_cx, method_map,\n                                               moves_map, crate));\n \n-        let last_use_map =\n-            time(time_passes, ~\"liveness checking\", ||\n-                 middle::liveness::check_crate(ty_cx, method_map,\n-                                               variable_moves_map,\n-                                               capture_map, crate));\n+        time(time_passes, ~\"liveness checking\", ||\n+             middle::liveness::check_crate(ty_cx, method_map,\n+                                           variable_moves_map,\n+                                           capture_map, crate));\n \n-        let (root_map, mutbl_map, write_guard_map) =\n+        let (root_map, write_guard_map) =\n             time(time_passes, ~\"borrow checking\", ||\n                  middle::borrowck::check_crate(ty_cx, method_map,\n-                                               moves_map, capture_map,\n-                                               crate));\n+                                               moves_map, moved_variables_set,\n+                                               capture_map, crate));\n \n         time(time_passes, ~\"kind checking\", ||\n-             kind::check_crate(ty_cx, method_map, last_use_map, crate));\n+             kind::check_crate(ty_cx, method_map, crate));\n \n         time(time_passes, ~\"lint checking\", ||\n              lint::check_crate(ty_cx, crate));\n \n         if upto == cu_no_trans { return (crate, Some(ty_cx)); }\n \n         let maps = astencode::Maps {\n-            mutbl_map: mutbl_map,\n             root_map: root_map,\n-            last_use_map: last_use_map,\n             method_map: method_map,\n             vtable_map: vtable_map,\n             write_guard_map: write_guard_map,"}, {"sha": "fff97d2436af39d05b69829d87e61ccd87a376c6", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -173,15 +173,19 @@ pub type Session = @Session_;\n \n pub impl Session_ {\n     fn span_fatal(@self, sp: span, msg: ~str) -> ! {\n+        debug!(\"span_fatal invoked: %s\", msg);\n         self.span_diagnostic.span_fatal(sp, msg)\n     }\n     fn fatal(@self, msg: ~str) -> ! {\n+        debug!(\"fatal invoked: %s\", msg);\n         self.span_diagnostic.handler().fatal(msg)\n     }\n     fn span_err(@self, sp: span, msg: ~str) {\n+        debug!(\"span_err invoked: %s\", msg);\n         self.span_diagnostic.span_err(sp, msg)\n     }\n     fn err(@self, msg: ~str) {\n+        debug!(\"err invoked: %s\", msg);\n         self.span_diagnostic.handler().err(msg)\n     }\n     fn has_errors(@self) -> bool {\n@@ -191,15 +195,19 @@ pub impl Session_ {\n         self.span_diagnostic.handler().abort_if_errors()\n     }\n     fn span_warn(@self, sp: span, msg: ~str) {\n+        debug!(\"span_warn invoked: %s\", msg);\n         self.span_diagnostic.span_warn(sp, msg)\n     }\n     fn warn(@self, msg: ~str) {\n+        debug!(\"warn invoked: %s\", msg);\n         self.span_diagnostic.handler().warn(msg)\n     }\n     fn span_note(@self, sp: span, msg: ~str) {\n+        debug!(\"span_note invoked: %s\", msg);\n         self.span_diagnostic.span_note(sp, msg)\n     }\n     fn note(@self, msg: ~str) {\n+        debug!(\"note invoked: %s\", msg);\n         self.span_diagnostic.handler().note(msg)\n     }\n     fn span_bug(@self, sp: span, msg: ~str) -> ! {"}, {"sha": "22bce62336cabde52034fa966ad4ee2102d281b0", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -69,7 +69,8 @@ fn generate_test_harness(sess: session::Session,\n         testfns: ~[]\n     };\n \n-    cx.ext_cx.bt_push(ExpandedFrom(CallInfo {\n+    let ext_cx = cx.ext_cx;\n+    ext_cx.bt_push(ExpandedFrom(CallInfo {\n         call_site: dummy_sp(),\n         callee: NameAndSpan {\n             name: ~\"test\",\n@@ -84,7 +85,7 @@ fn generate_test_harness(sess: session::Session,\n \n     let fold = fold::make_fold(precursor);\n     let res = @fold.fold_crate(&*crate);\n-    cx.ext_cx.bt_pop();\n+    ext_cx.bt_pop();\n     return res;\n }\n "}, {"sha": "1a94b57279cc4d8ecf956d7352d2ad876b32dcdb", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -244,8 +244,8 @@ fn doc_transformed_self_ty(doc: ebml::Doc,\n     }\n }\n \n-pub fn item_type(_: ast::def_id, item: ebml::Doc, tcx: ty::ctxt, cdata: cmd)\n-                 -> ty::t {\n+pub fn item_type(_item_id: ast::def_id, item: ebml::Doc,\n+                 tcx: ty::ctxt, cdata: cmd) -> ty::t {\n     doc_type(item, tcx, cdata)\n }\n "}, {"sha": "963afa08bfe338d543d595d72f44fa31658966a6", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -245,6 +245,9 @@ fn parse_region(st: @mut PState) -> ty::Region {\n       't' => {\n         ty::re_static\n       }\n+      'e' => {\n+        ty::re_static\n+      }\n       _ => fail!(~\"parse_region: bad input\")\n     }\n }"}, {"sha": "fdba3ac4f00abf24b38994bb2cdf016f62db8b87", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -71,30 +71,29 @@ pub fn enc_ty(w: @io::Writer, cx: @ctxt, t: ty::t) {\n         w.write_str(result_str);\n       }\n       ac_use_abbrevs(abbrevs) => {\n-        match abbrevs.find(&t) {\n-          Some(a) => { w.write_str(*a.s); return; }\n-          None => {\n-            let pos = w.tell();\n-            enc_sty(w, cx, /*bad*/copy ty::get(t).sty);\n-            let end = w.tell();\n-            let len = end - pos;\n-            fn estimate_sz(u: uint) -> uint {\n-                let mut n = u;\n-                let mut len = 0u;\n-                while n != 0u { len += 1u; n = n >> 4u; }\n-                return len;\n-            }\n-            let abbrev_len = 3u + estimate_sz(pos) + estimate_sz(len);\n-            if abbrev_len < len {\n-                // I.e. it's actually an abbreviation.\n-                let s = ~\"#\" + uint::to_str_radix(pos, 16u) + ~\":\" +\n-                    uint::to_str_radix(len, 16u) + ~\"#\";\n-                let a = ty_abbrev { pos: pos, len: len, s: @s };\n-                abbrevs.insert(t, a);\n-            }\n-            return;\n+          match abbrevs.find(&t) {\n+              Some(a) => { w.write_str(*a.s); return; }\n+              None => {}\n           }\n-        }\n+          let pos = w.tell();\n+          enc_sty(w, cx, /*bad*/copy ty::get(t).sty);\n+          let end = w.tell();\n+          let len = end - pos;\n+          fn estimate_sz(u: uint) -> uint {\n+              let mut n = u;\n+              let mut len = 0u;\n+              while n != 0u { len += 1u; n = n >> 4u; }\n+              return len;\n+          }\n+          let abbrev_len = 3u + estimate_sz(pos) + estimate_sz(len);\n+          if abbrev_len < len {\n+              // I.e. it's actually an abbreviation.\n+              let s = ~\"#\" + uint::to_str_radix(pos, 16u) + ~\":\" +\n+                  uint::to_str_radix(len, 16u) + ~\"#\";\n+              let a = ty_abbrev { pos: pos, len: len, s: @s };\n+              abbrevs.insert(t, a);\n+          }\n+          return;\n       }\n     }\n }\n@@ -152,6 +151,9 @@ fn enc_region(w: @io::Writer, cx: @ctxt, r: ty::Region) {\n       ty::re_static => {\n         w.write_char('t');\n       }\n+      ty::re_empty => {\n+        w.write_char('e');\n+      }\n       ty::re_infer(_) => {\n         // these should not crop up after typeck\n         cx.diag.handler().bug(~\"Cannot encode region variables\");"}, {"sha": "7a3bdce875da2531fa885e5a9e0042ef489c5aa2", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 38, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -44,9 +44,7 @@ use writer = std::ebml::writer;\n \n // Auxiliary maps of things to be encoded\n pub struct Maps {\n-    mutbl_map: middle::borrowck::mutbl_map,\n     root_map: middle::borrowck::root_map,\n-    last_use_map: middle::liveness::last_use_map,\n     method_map: middle::typeck::method_map,\n     vtable_map: middle::typeck::vtable_map,\n     write_guard_map: middle::borrowck::write_guard_map,\n@@ -151,7 +149,7 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n fn reserve_id_range(sess: Session,\n                     from_id_range: ast_util::id_range) -> ast_util::id_range {\n     // Handle the case of an empty range:\n-    if ast_util::empty(from_id_range) { return from_id_range; }\n+    if from_id_range.empty() { return from_id_range; }\n     let cnt = from_id_range.max - from_id_range.min;\n     let to_id_min = sess.parse_sess.next_id;\n     let to_id_max = sess.parse_sess.next_id + cnt;\n@@ -162,7 +160,6 @@ fn reserve_id_range(sess: Session,\n pub impl ExtendedDecodeContext {\n     fn tr_id(&self, id: ast::node_id) -> ast::node_id {\n         /*!\n-         *\n          * Translates an internal id, meaning a node id that is known\n          * to refer to some part of the item currently being inlined,\n          * such as a local variable or argument.  All naked node-ids\n@@ -173,12 +170,11 @@ pub impl ExtendedDecodeContext {\n          */\n \n         // from_id_range should be non-empty\n-        assert!(!ast_util::empty(self.from_id_range));\n+        assert!(!self.from_id_range.empty());\n         (id - self.from_id_range.min + self.to_id_range.min)\n     }\n     fn tr_def_id(&self, did: ast::def_id) -> ast::def_id {\n         /*!\n-         *\n          * Translates an EXTERNAL def-id, converting the crate number\n          * from the one used in the encoded data to the current crate\n          * numbers..  By external, I mean that it be translated to a\n@@ -203,7 +199,6 @@ pub impl ExtendedDecodeContext {\n     }\n     fn tr_intern_def_id(&self, did: ast::def_id) -> ast::def_id {\n         /*!\n-         *\n          * Translates an INTERNAL def-id, meaning a def-id that is\n          * known to refer to some part of the item currently being\n          * inlined.  In that case, we want to convert the def-id to\n@@ -461,11 +456,7 @@ impl tr for ty::AutoAdjustment {\n \n impl tr for ty::AutoRef {\n     fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::AutoRef {\n-        ty::AutoRef {\n-            kind: self.kind,\n-            region: self.region.tr(xcx),\n-            mutbl: self.mutbl,\n-        }\n+        self.map_region(|r| r.tr(xcx))\n     }\n }\n \n@@ -474,7 +465,7 @@ impl tr for ty::Region {\n         match *self {\n             ty::re_bound(br) => ty::re_bound(br.tr(xcx)),\n             ty::re_scope(id) => ty::re_scope(xcx.tr_id(id)),\n-            ty::re_static | ty::re_infer(*) => *self,\n+            ty::re_empty | ty::re_static | ty::re_infer(*) => *self,\n             ty::re_free(ref fr) => {\n                 ty::re_free(ty::FreeRegion {scope_id: xcx.tr_id(fr.scope_id),\n                                             bound_region: fr.bound_region.tr(xcx)})\n@@ -914,23 +905,6 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n         }\n     }\n \n-    if maps.mutbl_map.contains(&id) {\n-        do ebml_w.tag(c::tag_table_mutbl) {\n-            ebml_w.id(id);\n-        }\n-    }\n-\n-    for maps.last_use_map.find(&id).each |&m| {\n-        do ebml_w.tag(c::tag_table_last_use) {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {\n-                do ebml_w.emit_from_vec(/*bad*/ copy **m) |id| {\n-                    id.encode(ebml_w);\n-                }\n-            }\n-        }\n-    }\n-\n     for maps.method_map.find(&id).each |&mme| {\n         do ebml_w.tag(c::tag_table_method_map) {\n             ebml_w.id(id);\n@@ -1108,9 +1082,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                 found for id %d (orig %d)\",\n                tag, id, id0);\n \n-        if tag == (c::tag_table_mutbl as uint) {\n-            dcx.maps.mutbl_map.insert(id);\n-        } else if tag == (c::tag_table_moves_map as uint) {\n+        if tag == (c::tag_table_moves_map as uint) {\n             dcx.maps.moves_map.insert(id);\n         } else {\n             let val_doc = entry_doc.get(c::tag_table_val as uint);\n@@ -1138,11 +1110,6 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n             } else if tag == (c::tag_table_param_defs as uint) {\n                 let bounds = val_dsr.read_type_param_def(xcx);\n                 dcx.tcx.ty_param_defs.insert(id, bounds);\n-            } else if tag == (c::tag_table_last_use as uint) {\n-                let ids = val_dsr.read_to_vec(|| {\n-                    xcx.tr_id(val_dsr.read_int())\n-                });\n-                dcx.maps.last_use_map.insert(id, @mut ids);\n             } else if tag == (c::tag_table_method_map as uint) {\n                 dcx.maps.method_map.insert(\n                     id,"}, {"sha": "56eb57009ca0882e2c5abe85dabbcfd643442481", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 506, "deletions": 557, "changes": 1063, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -18,504 +18,502 @@\n // 4. moves do not affect things loaned out in any way\n \n use middle::moves;\n-use middle::typeck::check::PurityState;\n-use middle::borrowck::{Loan, bckerr, BorrowckCtxt, inherent_mutability};\n-use middle::borrowck::{ReqMaps, root_map_key, save_and_restore_managed};\n-use middle::borrowck::{MoveError, MoveOk, MoveFromIllegalCmt};\n-use middle::borrowck::{MoveWhileBorrowed};\n-use middle::mem_categorization::{cat_arg, cat_comp, cat_deref};\n-use middle::mem_categorization::{cat_local, cat_rvalue, cat_self};\n-use middle::mem_categorization::{cat_special, cmt, gc_ptr, loan_path, lp_arg};\n-use middle::mem_categorization::{lp_comp, lp_deref, lp_local};\n+use middle::borrowck::*;\n+use mc = middle::mem_categorization;\n use middle::ty;\n-use util::ppaux::ty_to_str;\n-\n+use util::ppaux::Repr;\n use core::hashmap::HashSet;\n-use core::util::with;\n-use syntax::ast::m_mutbl;\n+use syntax::ast::{m_mutbl, m_imm, m_const};\n use syntax::ast;\n use syntax::ast_util;\n-use syntax::codemap::span;\n-use syntax::print::pprust;\n use syntax::visit;\n+use syntax::codemap::span;\n \n-struct CheckLoanCtxt {\n+struct CheckLoanCtxt<'self> {\n     bccx: @BorrowckCtxt,\n-    req_maps: ReqMaps,\n-\n-    reported: HashSet<ast::node_id>,\n-\n-    declared_purity: @mut PurityState,\n-    fn_args: @mut @~[ast::node_id]\n-}\n-\n-// if we are enforcing purity, why are we doing so?\n-#[deriving(Eq)]\n-enum purity_cause {\n-    // enforcing purity because fn was declared pure:\n-    pc_pure_fn,\n-\n-    // enforce purity because we need to guarantee the\n-    // validity of some alias; `bckerr` describes the\n-    // reason we needed to enforce purity.\n-    pc_cmt(bckerr)\n-}\n-\n-// if we're not pure, why?\n-#[deriving(Eq)]\n-enum impurity_cause {\n-    // some surrounding block was marked as 'unsafe'\n-    pc_unsafe,\n-\n-    // nothing was unsafe, and nothing was pure\n-    pc_default,\n+    dfcx: &'self LoanDataFlow,\n+    all_loans: &'self [Loan],\n+    reported: @mut HashSet<ast::node_id>,\n }\n \n pub fn check_loans(bccx: @BorrowckCtxt,\n-                   req_maps: ReqMaps,\n-                   crate: @ast::crate) {\n+                   dfcx: &LoanDataFlow,\n+                   all_loans: &[Loan],\n+                   body: &ast::blk) {\n+    debug!(\"check_loans(body id=%?)\", body.node.id);\n+\n     let clcx = @mut CheckLoanCtxt {\n         bccx: bccx,\n-        req_maps: req_maps,\n-        reported: HashSet::new(),\n-        declared_purity: @mut PurityState::function(ast::impure_fn, 0),\n-        fn_args: @mut @~[]\n+        dfcx: dfcx,\n+        all_loans: all_loans,\n+        reported: @mut HashSet::new(),\n     };\n+\n     let vt = visit::mk_vt(@visit::Visitor {visit_expr: check_loans_in_expr,\n                                            visit_local: check_loans_in_local,\n                                            visit_block: check_loans_in_block,\n+                                           visit_pat: check_loans_in_pat,\n                                            visit_fn: check_loans_in_fn,\n                                            .. *visit::default_visitor()});\n-    visit::visit_crate(crate, clcx, vt);\n+    (vt.visit_block)(body, clcx, vt);\n }\n \n-#[deriving(Eq)]\n-enum assignment_type {\n-    at_straight_up,\n-    at_swap\n+enum MoveError {\n+    MoveOk,\n+    MoveFromIllegalCmt(mc::cmt),\n+    MoveWhileBorrowed(/*loan*/@LoanPath, /*loan*/span)\n }\n \n-pub impl assignment_type {\n-    fn checked_by_liveness(&self) -> bool {\n-        // the liveness pass guarantees that immutable local variables\n-        // are only assigned once; but it doesn't consider &mut\n-        match *self {\n-          at_straight_up => true,\n-          at_swap => true\n-        }\n-    }\n-    fn ing_form(&self, desc: ~str) -> ~str {\n-        match *self {\n-          at_straight_up => ~\"assigning to \" + desc,\n-          at_swap => ~\"swapping to and from \" + desc\n-        }\n-    }\n-}\n-\n-pub impl CheckLoanCtxt {\n+pub impl<'self> CheckLoanCtxt<'self> {\n     fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n-    fn purity(&mut self, scope_id: ast::node_id)\n-                -> Either<purity_cause, impurity_cause>\n+    fn each_issued_loan(&self,\n+                        scope_id: ast::node_id,\n+                        op: &fn(&Loan) -> bool)\n     {\n-        let default_purity = match self.declared_purity.purity {\n-          // an unsafe declaration overrides all\n-          ast::unsafe_fn => return Right(pc_unsafe),\n-\n-          // otherwise, remember what was declared as the\n-          // default, but we must scan for requirements\n-          // imposed by the borrow check\n-          ast::pure_fn => Left(pc_pure_fn),\n-          ast::extern_fn | ast::impure_fn => Right(pc_default)\n-        };\n-\n-        // scan to see if this scope or any enclosing scope requires\n-        // purity.  if so, that overrides the declaration.\n-\n-        let mut scope_id = scope_id;\n-        loop {\n-            match self.req_maps.pure_map.find(&scope_id) {\n-              None => (),\n-              Some(e) => return Left(pc_cmt(*e))\n-            }\n-\n-            match self.tcx().region_maps.opt_encl_scope(scope_id) {\n-              None => return default_purity,\n-              Some(next_scope_id) => scope_id = next_scope_id\n+        //! Iterates over each loan that that has been issued\n+        //! on entrance to `scope_id`, regardless of whether it is\n+        //! actually *in scope* at that point.  Sometimes loans\n+        //! are issued for future scopes and thus they may have been\n+        //! *issued* but not yet be in effect.\n+\n+        for self.dfcx.each_bit_on_entry(scope_id) |loan_index| {\n+            let loan = &self.all_loans[loan_index];\n+            if !op(loan) {\n+                return;\n             }\n         }\n     }\n \n-    fn walk_loans(&self,\n-                  mut scope_id: ast::node_id,\n-                  f: &fn(v: &Loan) -> bool) {\n-\n-        loop {\n-            for self.req_maps.req_loan_map.find(&scope_id).each |loans| {\n-                for loans.each |loan| {\n-                    if !f(loan) { return; }\n-                }\n-            }\n-\n-            match self.tcx().region_maps.opt_encl_scope(scope_id) {\n-              None => return,\n-              Some(next_scope_id) => scope_id = next_scope_id,\n-            }\n-        }\n-    }\n-\n-    fn walk_loans_of(&mut self,\n-                     scope_id: ast::node_id,\n-                     lp: @loan_path,\n-                     f: &fn(v: &Loan) -> bool) {\n-        for self.walk_loans(scope_id) |loan| {\n-            if loan.lp == lp {\n-                if !f(loan) { return; }\n-            }\n-        }\n-    }\n+    fn each_in_scope_loan(&self,\n+                          scope_id: ast::node_id,\n+                          op: &fn(&Loan) -> bool)\n+    {\n+        //! Like `each_issued_loan()`, but only considers loans that are\n+        //! currently in scope.\n \n-    // when we are in a pure context, we check each call to ensure\n-    // that the function which is invoked is itself pure.\n-    //\n-    // note: we take opt_expr and expr_id separately because for\n-    // overloaded operators the callee has an id but no expr.\n-    // annoying.\n-    fn check_pure_callee_or_arg(&mut self,\n-                                pc: Either<purity_cause, impurity_cause>,\n-                                opt_expr: Option<@ast::expr>,\n-                                callee_id: ast::node_id,\n-                                callee_span: span) {\n-        let tcx = self.tcx();\n-\n-        debug!(\"check_pure_callee_or_arg(pc=%?, expr=%?, \\\n-                callee_id=%d, ty=%s)\",\n-               pc,\n-               opt_expr.map(|e| pprust::expr_to_str(*e, tcx.sess.intr()) ),\n-               callee_id,\n-               ty_to_str(self.tcx(), ty::node_id_to_type(tcx, callee_id)));\n-\n-        // Purity rules: an expr B is a legal callee or argument to a\n-        // call within a pure function A if at least one of the\n-        // following holds:\n-        //\n-        // (a) A was declared pure and B is one of its arguments;\n-        // (b) B is a stack closure;\n-        // (c) B is a pure fn;\n-        // (d) B is not a fn.\n-\n-        match opt_expr {\n-          Some(expr) => {\n-            match expr.node {\n-              ast::expr_path(_) if pc == Left(pc_pure_fn) => {\n-                let def = *self.tcx().def_map.get(&expr.id);\n-                let did = ast_util::def_id_of_def(def);\n-                let is_fn_arg =\n-                    did.crate == ast::local_crate &&\n-                    (*self.fn_args).contains(&(did.node));\n-                if is_fn_arg { return; } // case (a) above\n-              }\n-              ast::expr_fn_block(*) | ast::expr_loop_body(*) |\n-              ast::expr_do_body(*) => {\n-                if self.is_stack_closure(expr.id) {\n-                    // case (b) above\n+        let region_maps = self.tcx().region_maps;\n+        for self.each_issued_loan(scope_id) |loan| {\n+            if region_maps.is_subscope_of(scope_id, loan.kill_scope) {\n+                if !op(loan) {\n                     return;\n                 }\n-              }\n-              _ => ()\n             }\n-          }\n-          None => ()\n         }\n+    }\n \n-        let callee_ty = ty::node_id_to_type(tcx, callee_id);\n-        match ty::get(callee_ty).sty {\n-            ty::ty_bare_fn(ty::BareFnTy {purity: purity, _}) |\n-            ty::ty_closure(ty::ClosureTy {purity: purity, _}) => {\n-                match purity {\n-                    ast::pure_fn => return, // case (c) above\n-                    ast::impure_fn | ast::unsafe_fn | ast::extern_fn => {\n-                        self.report_purity_error(\n-                            pc, callee_span,\n-                            fmt!(\"access to %s function\",\n-                                 purity.to_str()));\n+    fn each_in_scope_restriction(&self,\n+                                 scope_id: ast::node_id,\n+                                 loan_path: @LoanPath,\n+                                 op: &fn(&Loan, &Restriction) -> bool)\n+    {\n+        //! Iterates through all the in-scope restrictions for the\n+        //! given `loan_path`\n+\n+        for self.each_in_scope_loan(scope_id) |loan| {\n+            for loan.restrictions.each |restr| {\n+                if restr.loan_path == loan_path {\n+                    if !op(loan, restr) {\n+                        return;\n                     }\n                 }\n             }\n-            _ => return, // case (d) above\n         }\n     }\n \n-    // True if the expression with the given `id` is a stack closure.\n-    // The expression must be an expr_fn_block(*)\n-    fn is_stack_closure(&mut self, id: ast::node_id) -> bool {\n-        let fn_ty = ty::node_id_to_type(self.tcx(), id);\n-        match ty::get(fn_ty).sty {\n-            ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil,\n-                                          _}) => true,\n-            _ => false\n-        }\n-    }\n+    fn loans_generated_by(&self, scope_id: ast::node_id) -> ~[uint] {\n+        //! Returns a vector of the loans that are generated as\n+        //! we encounter `scope_id`.\n \n-    fn is_allowed_pure_arg(&mut self, expr: @ast::expr) -> bool {\n-        return match expr.node {\n-          ast::expr_path(_) => {\n-            let def = *self.tcx().def_map.get(&expr.id);\n-            let did = ast_util::def_id_of_def(def);\n-            did.crate == ast::local_crate &&\n-                (*self.fn_args).contains(&(did.node))\n-          }\n-          ast::expr_fn_block(*) => self.is_stack_closure(expr.id),\n-          _ => false,\n-        };\n+        let mut result = ~[];\n+        for self.dfcx.each_gen_bit(scope_id) |loan_index| {\n+            result.push(loan_index);\n+        }\n+        return result;\n     }\n \n     fn check_for_conflicting_loans(&mut self, scope_id: ast::node_id) {\n-        debug!(\"check_for_conflicting_loans(scope_id=%?)\", scope_id);\n+        //! Checks to see whether any of the loans that are issued\n+        //! by `scope_id` conflict with loans that have already been\n+        //! issued when we enter `scope_id` (for example, we do not\n+        //! permit two `&mut` borrows of the same variable).\n \n-        let new_loans = match self.req_maps.req_loan_map.find(&scope_id) {\n-            None => return,\n-            Some(&loans) => loans\n-        };\n-        let new_loans: &mut ~[Loan] = new_loans;\n-\n-        debug!(\"new_loans has length %?\", new_loans.len());\n+        debug!(\"check_for_conflicting_loans(scope_id=%?)\", scope_id);\n \n-        let par_scope_id = self.tcx().region_maps.encl_scope(scope_id);\n-        for self.walk_loans(par_scope_id) |old_loan| {\n-            debug!(\"old_loan=%?\", self.bccx.loan_to_repr(old_loan));\n+        let new_loan_indices = self.loans_generated_by(scope_id);\n+        debug!(\"new_loan_indices = %?\", new_loan_indices);\n \n-            for new_loans.each |new_loan| {\n-                self.report_error_if_loans_conflict(old_loan, new_loan);\n+        for self.each_issued_loan(scope_id) |issued_loan| {\n+            for new_loan_indices.each |&new_loan_index| {\n+                let new_loan = &self.all_loans[new_loan_index];\n+                self.report_error_if_loans_conflict(issued_loan, new_loan);\n             }\n         }\n \n-        let len = new_loans.len();\n-        for uint::range(0, len) |i| {\n-            let loan_i = new_loans[i];\n-            for uint::range(i+1, len) |j| {\n-                let loan_j = new_loans[j];\n-                self.report_error_if_loans_conflict(&loan_i, &loan_j);\n+        for uint::range(0, new_loan_indices.len()) |i| {\n+            let old_loan = &self.all_loans[new_loan_indices[i]];\n+            for uint::range(i+1, new_loan_indices.len()) |j| {\n+                let new_loan = &self.all_loans[new_loan_indices[j]];\n+                self.report_error_if_loans_conflict(old_loan, new_loan);\n             }\n         }\n     }\n \n     fn report_error_if_loans_conflict(&self,\n                                       old_loan: &Loan,\n                                       new_loan: &Loan) {\n-        if old_loan.lp != new_loan.lp {\n-            return;\n-        }\n+        //! Checks whether `old_loan` and `new_loan` can safely be issued\n+        //! simultaneously.\n+\n+        debug!(\"report_error_if_loans_conflict(old_loan=%s, new_loan=%s)\",\n+               old_loan.repr(self.tcx()),\n+               new_loan.repr(self.tcx()));\n+\n+        // Should only be called for loans that are in scope at the same time.\n+        let region_maps = self.tcx().region_maps;\n+        assert!(region_maps.scopes_intersect(old_loan.kill_scope,\n+                                             new_loan.kill_scope));\n+\n+        self.report_error_if_loan_conflicts_with_restriction(\n+            old_loan, new_loan, old_loan, new_loan) &&\n+        self.report_error_if_loan_conflicts_with_restriction(\n+            new_loan, old_loan, old_loan, new_loan);\n+    }\n \n-        match (old_loan.kind, new_loan.kind) {\n-            (PartialFreeze, PartialTake) | (PartialTake, PartialFreeze) |\n-            (TotalFreeze, PartialFreeze) | (PartialFreeze, TotalFreeze) |\n-            (Immobile, _) | (_, Immobile) |\n-            (PartialFreeze, PartialFreeze) |\n-            (PartialTake, PartialTake) |\n-            (TotalFreeze, TotalFreeze) => {\n-                /* ok */\n-            }\n+    fn report_error_if_loan_conflicts_with_restriction(&self,\n+                                                       loan1: &Loan,\n+                                                       loan2: &Loan,\n+                                                       old_loan: &Loan,\n+                                                       new_loan: &Loan) -> bool {\n+        //! Checks whether the restrictions introduced by `loan1` would\n+        //! prohibit `loan2`. Returns false if an error is reported.\n+\n+        debug!(\"report_error_if_loan_conflicts_with_restriction(\\\n+                loan1=%s, loan2=%s)\",\n+               loan1.repr(self.tcx()),\n+               loan2.repr(self.tcx()));\n+\n+        // Restrictions that would cause the new loan to be immutable:\n+        let illegal_if = match loan2.mutbl {\n+            m_mutbl => RESTR_ALIAS | RESTR_FREEZE | RESTR_MUTATE,\n+            m_imm =>   RESTR_ALIAS | RESTR_FREEZE,\n+            m_const => RESTR_ALIAS,\n+        };\n+        debug!(\"illegal_if=%?\", illegal_if);\n+\n+        for loan1.restrictions.each |restr| {\n+            if !restr.set.intersects(illegal_if) { loop; }\n+            if restr.loan_path != loan2.loan_path { loop; }\n \n-            (PartialTake, TotalFreeze) | (TotalFreeze, PartialTake) |\n-            (TotalTake, TotalFreeze) | (TotalFreeze, TotalTake) |\n-            (TotalTake, PartialFreeze) | (PartialFreeze, TotalTake) |\n-            (TotalTake, PartialTake) | (PartialTake, TotalTake) |\n-            (TotalTake, TotalTake) => {\n-                self.bccx.span_err(\n-                    new_loan.cmt.span,\n-                    fmt!(\"loan of %s as %s \\\n-                          conflicts with prior loan\",\n-                         self.bccx.cmt_to_str(new_loan.cmt),\n-                         self.bccx.loan_kind_to_str(new_loan.kind)));\n-                self.bccx.span_note(\n-                    old_loan.cmt.span,\n-                    fmt!(\"prior loan as %s granted here\",\n-                         self.bccx.loan_kind_to_str(old_loan.kind)));\n+            match (new_loan.mutbl, old_loan.mutbl) {\n+                (m_mutbl, m_mutbl) => {\n+                    self.bccx.span_err(\n+                        new_loan.span,\n+                        fmt!(\"cannot borrow `%s` as mutable \\\n+                              more than once at at a time\",\n+                             self.bccx.loan_path_to_str(new_loan.loan_path)));\n+                    self.bccx.span_note(\n+                        old_loan.span,\n+                        fmt!(\"second borrow of `%s` as mutable occurs here\",\n+                             self.bccx.loan_path_to_str(new_loan.loan_path)));\n+                    return false;\n+                }\n+\n+                _ => {\n+                    self.bccx.span_err(\n+                        new_loan.span,\n+                        fmt!(\"cannot borrow `%s` as %s because \\\n+                              it is also borrowed as %s\"\n+                             self.bccx.loan_path_to_str(new_loan.loan_path),\n+                             self.bccx.mut_to_str(new_loan.mutbl),\n+                             self.bccx.mut_to_str(old_loan.mutbl)));\n+                    self.bccx.span_note(\n+                        old_loan.span,\n+                        fmt!(\"second borrow of `%s` occurs here\",\n+                             self.bccx.loan_path_to_str(new_loan.loan_path)));\n+                    return false;\n+                }\n             }\n         }\n+\n+        true\n     }\n \n-    fn is_local_variable(&self, cmt: cmt) -> bool {\n+    fn is_local_variable(&self, cmt: mc::cmt) -> bool {\n         match cmt.cat {\n-          cat_local(_) => true,\n+          mc::cat_local(_) => true,\n           _ => false\n         }\n     }\n \n-    fn check_assignment(&mut self, at: assignment_type, ex: @ast::expr) {\n+    fn check_assignment(&self, expr: @ast::expr) {\n         // We don't use cat_expr() here because we don't want to treat\n         // auto-ref'd parameters in overloaded operators as rvalues.\n-        let cmt = match self.bccx.tcx.adjustments.find(&ex.id) {\n-            None => self.bccx.cat_expr_unadjusted(ex),\n-            Some(&adj) => self.bccx.cat_expr_autoderefd(ex, adj)\n+        let cmt = match self.bccx.tcx.adjustments.find(&expr.id) {\n+            None => self.bccx.cat_expr_unadjusted(expr),\n+            Some(&adj) => self.bccx.cat_expr_autoderefd(expr, adj)\n         };\n \n-        debug!(\"check_assignment(cmt=%s)\",\n-               self.bccx.cmt_to_repr(cmt));\n-\n-        if self.is_local_variable(cmt) && at.checked_by_liveness() {\n-            // liveness guarantees that immutable local variables\n-            // are only assigned once\n-        } else {\n-            match cmt.mutbl {\n-                McDeclared | McInherited => {\n-                    // Ok, but if this loan is a mutable loan, then mark the\n-                    // loan path (if it exists) as being used. This is similar\n-                    // to the check performed in loan.rs in issue_loan(). This\n-                    // type of use of mutable is different from issuing a loan,\n-                    // however.\n-                    for cmt.lp.each |lp| {\n-                        for lp.node_id().each |&id| {\n-                            self.tcx().used_mut_nodes.insert(id);\n-                        }\n-                    }\n-                }\n-                McReadOnly | McImmutable => {\n+        debug!(\"check_assignment(cmt=%s)\", cmt.repr(self.tcx()));\n+\n+        // check that the value being assigned is declared as mutable\n+        // and report an error otherwise.\n+        match cmt.mutbl {\n+            mc::McDeclared => {\n+                // OK\n+            }\n+            mc::McInherited => {\n+                // OK, but we may have to add an entry to `used_mut_nodes`\n+                mark_writes_through_upvars_as_used_mut(self, cmt);\n+            }\n+            mc::McReadOnly | mc::McImmutable => {\n+                // Subtle: liveness guarantees that immutable local\n+                // variables are only assigned once, so no need to\n+                // report an error for an assignment to a local\n+                // variable (note also that it is not legal to borrow\n+                // for a local variable before it has been assigned\n+                // for the first time).\n+                if !self.is_local_variable(cmt) {\n                     self.bccx.span_err(\n-                        ex.span,\n-                        at.ing_form(self.bccx.cmt_to_str(cmt)));\n-                    return;\n+                        expr.span,\n+                        fmt!(\"cannot assign to %s %s\"\n+                             cmt.mutbl.to_user_str(),\n+                             self.bccx.cmt_to_str(cmt)));\n                 }\n+                return;\n             }\n         }\n \n-        // if this is a pure function, only loan-able state can be\n-        // assigned, because it is uniquely tied to this function and\n-        // is not visible from the outside\n-        let purity = self.purity(ex.id);\n-        match purity {\n-          Right(_) => (),\n-          Left(pc_cmt(_)) => {\n-            // Subtle: Issue #3162.  If we are enforcing purity\n-            // because there is a reference to aliasable, mutable data\n-            // that we require to be immutable, we can't allow writes\n-            // even to data owned by the current stack frame.  This is\n-            // because that aliasable data might have been located on\n-            // the current stack frame, we don't know.\n-            self.report_purity_error(\n-                purity,\n-                ex.span,\n-                at.ing_form(self.bccx.cmt_to_str(cmt)));\n-          }\n-          Left(pc_pure_fn) => {\n-            if cmt.lp.is_none() {\n-                self.report_purity_error(\n-                    purity, ex.span,\n-                    at.ing_form(self.bccx.cmt_to_str(cmt)));\n-            }\n-          }\n+        if check_for_aliasable_mutable_writes(self, expr, cmt) {\n+            check_for_assignment_to_restricted_or_frozen_location(\n+                self, expr, cmt);\n         }\n \n-        // check for a conflicting loan as well, except in the case of\n-        // taking a mutable ref.  that will create a loan of its own\n-        // which will be checked for compat separately in\n-        // check_for_conflicting_loans()\n-        for cmt.lp.each |lp| {\n-            self.check_for_loan_conflicting_with_assignment(\n-                at, ex, cmt, *lp);\n-        }\n+        fn mark_writes_through_upvars_as_used_mut(self: &CheckLoanCtxt,\n+                                                  cmt: mc::cmt) {\n+            //! If the mutability of the `cmt` being written is inherited\n+            //! from a local variable in another closure, liveness may\n+            //! not have been able to detect that this variable's mutability\n+            //! is important, so we must add the variable to the\n+            //! `used_mut_nodes` table here. This is because liveness\n+            //! does not consider closures.\n+\n+            let mut passed_upvar = false;\n+            let mut cmt = cmt;\n+            loop {\n+                debug!(\"mark_writes_through_upvars_as_used_mut(cmt=%s)\",\n+                       cmt.repr(self.tcx()));\n+                match cmt.cat {\n+                    mc::cat_local(id) |\n+                    mc::cat_arg(id, _) |\n+                    mc::cat_self(id) => {\n+                        if passed_upvar {\n+                            self.tcx().used_mut_nodes.insert(id);\n+                        }\n+                        return;\n+                    }\n \n-        self.bccx.add_to_mutbl_map(cmt);\n+                    mc::cat_stack_upvar(b) => {\n+                        cmt = b;\n+                        passed_upvar = true;\n+                    }\n \n-        // Check for and insert write guards as necessary.\n-        self.add_write_guards_if_necessary(cmt);\n-    }\n+                    mc::cat_rvalue |\n+                    mc::cat_static_item |\n+                    mc::cat_implicit_self |\n+                    mc::cat_copied_upvar(*) |\n+                    mc::cat_deref(_, _, mc::unsafe_ptr(*)) |\n+                    mc::cat_deref(_, _, mc::gc_ptr(*)) |\n+                    mc::cat_deref(_, _, mc::region_ptr(*)) => {\n+                        assert_eq!(cmt.mutbl, mc::McDeclared);\n+                        return;\n+                    }\n \n-    fn add_write_guards_if_necessary(&mut self, cmt: cmt) {\n-        match cmt.cat {\n-            cat_deref(base, deref_count, ptr_kind) => {\n-                self.add_write_guards_if_necessary(base);\n-\n-                match ptr_kind {\n-                    gc_ptr(ast::m_mutbl) => {\n-                        let key = root_map_key {\n-                            id: base.id,\n-                            derefs: deref_count\n-                        };\n-                        self.bccx.write_guard_map.insert(key);\n+                    mc::cat_discr(b, _) |\n+                    mc::cat_deref(b, _, mc::uniq_ptr(*)) => {\n+                        assert_eq!(cmt.mutbl, mc::McInherited);\n+                        cmt = b;\n+                    }\n+\n+                    mc::cat_interior(b, _) => {\n+                        if cmt.mutbl == mc::McInherited {\n+                            cmt = b;\n+                        } else {\n+                            return; // field declared as mutable or some such\n+                        }\n                     }\n-                    _ => {}\n                 }\n             }\n-            cat_comp(base, _) => {\n-                self.add_write_guards_if_necessary(base);\n-            }\n-            _ => {}\n         }\n-    }\n \n-    fn check_for_loan_conflicting_with_assignment(&mut self,\n-                                                  at: assignment_type,\n-                                                  ex: @ast::expr,\n-                                                  cmt: cmt,\n-                                                  lp: @loan_path) {\n-        for self.walk_loans_of(ex.id, lp) |loan| {\n-            match loan.kind {\n-                Immobile => { /* ok */ }\n-                TotalFreeze | PartialFreeze |\n-                TotalTake | PartialTake => {\n-                    self.bccx.span_err(\n-                        ex.span,\n-                        fmt!(\"%s prohibited due to outstanding loan\",\n-                             at.ing_form(self.bccx.cmt_to_str(cmt))));\n-                    self.bccx.span_note(\n-                        loan.cmt.span,\n-                        fmt!(\"loan of %s granted here\",\n-                             self.bccx.cmt_to_str(loan.cmt)));\n-                    return;\n+        fn check_for_aliasable_mutable_writes(self: &CheckLoanCtxt,\n+                                              expr: @ast::expr,\n+                                              cmt: mc::cmt) -> bool {\n+            //! Safety checks related to writes to aliasable, mutable locations\n+\n+            let guarantor = cmt.guarantor();\n+            match guarantor.cat {\n+                mc::cat_deref(b, _, mc::region_ptr(m_mutbl, _)) => {\n+                    // Statically prohibit writes to `&mut` when aliasable\n+\n+                    match b.freely_aliasable() {\n+                        None => {}\n+                        Some(cause) => {\n+                            self.bccx.report_aliasability_violation(\n+                                expr.span,\n+                                MutabilityViolation,\n+                                cause);\n+                        }\n+                    }\n                 }\n+\n+                mc::cat_deref(base, deref_count, mc::gc_ptr(ast::m_mutbl)) => {\n+                    // Dynamically check writes to `@mut`\n+\n+                    let key = root_map_key {\n+                        id: base.id,\n+                        derefs: deref_count\n+                    };\n+                    self.bccx.write_guard_map.insert(key);\n+                }\n+\n+                _ => {}\n             }\n-        }\n \n-        // Subtle: if the mutability of the component being assigned\n-        // is inherited from the thing that the component is embedded\n-        // within, then we have to check whether that thing has been\n-        // loaned out as immutable!  An example:\n-        //    let mut x = {f: Some(3)};\n-        //    let y = &x; // x loaned out as immutable\n-        //    x.f = none; // changes type of y.f, which appears to be imm\n-        match *lp {\n-          lp_comp(lp_base, ck) if inherent_mutability(ck) != m_mutbl => {\n-            self.check_for_loan_conflicting_with_assignment(\n-                at, ex, cmt, lp_base);\n-          }\n-          lp_comp(*) | lp_self | lp_local(*) | lp_arg(*) | lp_deref(*) => ()\n+            return true; // no errors reported\n         }\n-    }\n \n-    fn report_purity_error(&mut self, pc: Either<purity_cause, impurity_cause>,\n-                           sp: span, msg: ~str) {\n-        match pc {\n-          Right(pc_default) => { fail!(~\"pc_default should be filtered sooner\") }\n-          Right(pc_unsafe) => {\n-            // this error was prevented by being marked as unsafe, so flag the\n-            // definition as having contributed to the validity of the program\n-            let def = self.declared_purity.def;\n-            debug!(\"flagging %? as a used unsafe source\", def);\n-            self.tcx().used_unsafe.insert(def);\n-          }\n-          Left(pc_pure_fn) => {\n-            self.tcx().sess.span_err(\n-                sp,\n-                fmt!(\"%s prohibited in pure context\", msg));\n-          }\n-          Left(pc_cmt(ref e)) => {\n-            if self.reported.insert((*e).cmt.id) {\n-                self.tcx().sess.span_err(\n-                    (*e).cmt.span,\n-                    fmt!(\"illegal borrow unless pure: %s\",\n-                         self.bccx.bckerr_to_str((*e))));\n-                self.bccx.note_and_explain_bckerr((*e));\n-                self.tcx().sess.span_note(\n-                    sp,\n-                    fmt!(\"impure due to %s\", msg));\n+        fn check_for_assignment_to_restricted_or_frozen_location(\n+            self: &CheckLoanCtxt,\n+            expr: @ast::expr,\n+            cmt: mc::cmt) -> bool\n+        {\n+            //! Check for assignments that violate the terms of an\n+            //! outstanding loan.\n+\n+            let loan_path = match opt_loan_path(cmt) {\n+                Some(lp) => lp,\n+                None => { return true; /* no loan path, can't be any loans */ }\n+            };\n+\n+            // Start by searching for an assignment to a *restricted*\n+            // location. Here is one example of the kind of error caught\n+            // by this check:\n+            //\n+            //    let mut v = ~[1, 2, 3];\n+            //    let p = &v;\n+            //    v = ~[4];\n+            //\n+            // In this case, creating `p` triggers a RESTR_MUTATE\n+            // restriction on the path `v`.\n+            //\n+            // Here is a second, more subtle example:\n+            //\n+            //    let mut v = ~[1, 2, 3];\n+            //    let p = &const v[0];\n+            //    v[0] = 4;                   // OK\n+            //    v[1] = 5;                   // OK\n+            //    v = ~[4, 5, 3];             // Error\n+            //\n+            // In this case, `p` is pointing to `v[0]`, and it is a\n+            // `const` pointer in any case. So the first two\n+            // assignments are legal (and would be permitted by this\n+            // check). However, the final assignment (which is\n+            // logically equivalent) is forbidden, because it would\n+            // cause the existing `v` array to be freed, thus\n+            // invalidating `p`. In the code, this error results\n+            // because `gather_loans::restrictions` adds a\n+            // `RESTR_MUTATE` restriction whenever the contents of an\n+            // owned pointer are borrowed, and hence while `v[*]` is not\n+            // restricted from being written, `v` is.\n+            for self.each_in_scope_restriction(expr.id, loan_path)\n+                |loan, restr|\n+            {\n+                if restr.set.intersects(RESTR_MUTATE) {\n+                    self.report_illegal_mutation(expr, loan_path, loan);\n+                    return false;\n+                }\n+            }\n+\n+            // The previous code handled assignments to paths that\n+            // have been restricted. This covers paths that have been\n+            // directly lent out and their base paths, but does not\n+            // cover random extensions of those paths. For example,\n+            // the following program is not declared illegal by the\n+            // previous check:\n+            //\n+            //    let mut v = ~[1, 2, 3];\n+            //    let p = &v;\n+            //    v[0] = 4; // declared error by loop below, not code above\n+            //\n+            // The reason that this passes the previous check whereas\n+            // an assignment like `v = ~[4]` fails is because the assignment\n+            // here is to `v[*]`, and the existing restrictions were issued\n+            // for `v`, not `v[*]`.\n+            //\n+            // So in this loop, we walk back up the loan path so long\n+            // as the mutability of the path is dependent on a super\n+            // path, and check that the super path was not lent out as\n+            // mutable or immutable (a const loan is ok).\n+            //\n+            // Note that we are *not* checking for any and all\n+            // restrictions.  We are only interested in the pointers\n+            // that the user created, whereas we add restrictions for\n+            // all kinds of paths that are not directly aliased. If we checked\n+            // for all restrictions, and not just loans, then the following\n+            // valid program would be considered illegal:\n+            //\n+            //    let mut v = ~[1, 2, 3];\n+            //    let p = &const v[0];\n+            //    v[1] = 5; // ok\n+            //\n+            // Here the restriction that `v` not be mutated would be misapplied\n+            // to block the subpath `v[1]`.\n+            let full_loan_path = loan_path;\n+            let mut loan_path = loan_path;\n+            loop {\n+                match *loan_path {\n+                    // Peel back one layer if `loan_path` has\n+                    // inherited mutability\n+                    LpExtend(lp_base, mc::McInherited, _) => {\n+                        loan_path = lp_base;\n+                    }\n+\n+                    // Otherwise stop iterating\n+                    LpExtend(_, mc::McDeclared, _) |\n+                    LpExtend(_, mc::McImmutable, _) |\n+                    LpExtend(_, mc::McReadOnly, _) |\n+                    LpVar(_) => {\n+                        return true;\n+                    }\n+                }\n+\n+                // Check for a non-const loan of `loan_path`\n+                for self.each_in_scope_loan(expr.id) |loan| {\n+                    if loan.loan_path == loan_path && loan.mutbl != m_const {\n+                        self.report_illegal_mutation(expr, full_loan_path, loan);\n+                        return false;\n+                    }\n+                }\n             }\n-          }\n         }\n     }\n \n-    fn check_move_out_from_expr(@mut self, ex: @ast::expr) {\n+    fn report_illegal_mutation(&self,\n+                               expr: @ast::expr,\n+                               loan_path: &LoanPath,\n+                               loan: &Loan) {\n+        self.bccx.span_err(\n+            expr.span,\n+            fmt!(\"cannot assign to `%s` because it is borrowed\",\n+                 self.bccx.loan_path_to_str(loan_path)));\n+        self.bccx.span_note(\n+            loan.span,\n+            fmt!(\"borrow of `%s` occurs here\",\n+                 self.bccx.loan_path_to_str(loan_path)));\n+    }\n+\n+    fn check_move_out_from_expr(&self, ex: @ast::expr) {\n         match ex.node {\n             ast::expr_paren(*) => {\n                 /* In the case of an expr_paren(), the expression inside\n@@ -529,158 +527,104 @@ pub impl CheckLoanCtxt {\n                     MoveFromIllegalCmt(_) => {\n                         self.bccx.span_err(\n                             cmt.span,\n-                            fmt!(\"moving out of %s\",\n+                            fmt!(\"cannot move out of %s\",\n                                  self.bccx.cmt_to_str(cmt)));\n                     }\n-                    MoveWhileBorrowed(_, loan_cmt) => {\n+                    MoveWhileBorrowed(loan_path, loan_span) => {\n                         self.bccx.span_err(\n                             cmt.span,\n-                            fmt!(\"moving out of %s prohibited \\\n-                                  due to outstanding loan\",\n-                                 self.bccx.cmt_to_str(cmt)));\n+                            fmt!(\"cannot move out of `%s` \\\n+                                  because it is borrowed\",\n+                                 self.bccx.loan_path_to_str(loan_path)));\n                         self.bccx.span_note(\n-                            loan_cmt.span,\n-                            fmt!(\"loan of %s granted here\",\n-                                 self.bccx.cmt_to_str(loan_cmt)));\n+                            loan_span,\n+                            fmt!(\"borrow of `%s` occurs here\",\n+                                 self.bccx.loan_path_to_str(loan_path)));\n                     }\n                 }\n             }\n         }\n     }\n \n-    fn analyze_move_out_from_cmt(&mut self, cmt: cmt) -> MoveError {\n-        debug!(\"check_move_out_from_cmt(cmt=%s)\",\n-               self.bccx.cmt_to_repr(cmt));\n+    fn analyze_move_out_from_cmt(&self, cmt: mc::cmt) -> MoveError {\n+        debug!(\"check_move_out_from_cmt(cmt=%s)\", cmt.repr(self.tcx()));\n \n         match cmt.cat {\n-          // Rvalues, locals, and arguments can be moved:\n-          cat_rvalue | cat_local(_) | cat_arg(_) | cat_self(_) => {}\n-\n-          // We allow moving out of static items because the old code\n-          // did.  This seems consistent with permitting moves out of\n-          // rvalues, I guess.\n-          cat_special(sk_static_item) => {}\n-\n-          cat_deref(_, _, unsafe_ptr) => {}\n-\n-          // Nothing else.\n-          _ => {\n-              return MoveFromIllegalCmt(cmt);\n-          }\n+            // Rvalues, locals, and arguments can be moved:\n+            mc::cat_rvalue | mc::cat_local(_) |\n+            mc::cat_arg(_, ast::by_copy) | mc::cat_self(_) => {}\n+\n+            // It seems strange to allow a move out of a static item,\n+            // but what happens in practice is that you have a\n+            // reference to a constant with a type that should be\n+            // moved, like `None::<~int>`.  The type of this constant\n+            // is technically `Option<~int>`, which moves, but we know\n+            // that the content of static items will never actually\n+            // contain allocated pointers, so we can just memcpy it.\n+            mc::cat_static_item => {}\n+\n+            mc::cat_deref(_, _, mc::unsafe_ptr(*)) => {}\n+\n+            // Nothing else.\n+            _ => {\n+                return MoveFromIllegalCmt(cmt);\n+            }\n         }\n \n-        self.bccx.add_to_mutbl_map(cmt);\n+        // NOTE inadequare if/when we permit `move a.b`\n \n         // check for a conflicting loan:\n-        for cmt.lp.each |lp| {\n-            for self.walk_loans_of(cmt.id, *lp) |loan| {\n-                return MoveWhileBorrowed(cmt, loan.cmt);\n+        for opt_loan_path(cmt).each |&lp| {\n+            for self.each_in_scope_restriction(cmt.id, lp) |loan, _| {\n+                // Any restriction prevents moves.\n+                return MoveWhileBorrowed(loan.loan_path, loan.span);\n             }\n         }\n \n         return MoveOk;\n     }\n \n     fn check_call(&mut self,\n-                  expr: @ast::expr,\n-                  callee: Option<@ast::expr>,\n-                  callee_id: ast::node_id,\n-                  callee_span: span,\n-                  args: &[@ast::expr]) {\n-        let pc = self.purity(expr.id);\n-        match pc {\n-            // no purity, no need to check for anything\n-            Right(pc_default) => return,\n-\n-            // some form of purity, definitely need to check\n-            Left(_) => (),\n-\n-            // Unsafe trumped. To see if the unsafe is necessary, see what the\n-            // purity would have been without a trump, and if it's some form\n-            // of purity then we need to go ahead with the check\n-            Right(pc_unsafe) => {\n-                match do with(&mut self.declared_purity.purity,\n-                              ast::impure_fn) { self.purity(expr.id) } {\n-                    Right(pc_unsafe) => fail!(~\"unsafe can't trump twice\"),\n-                    Right(pc_default) => return,\n-                    Left(_) => ()\n-                }\n-            }\n-\n-        }\n-        self.check_pure_callee_or_arg(\n-            pc, callee, callee_id, callee_span);\n-        for args.each |arg| {\n-            self.check_pure_callee_or_arg(\n-                pc, Some(*arg), arg.id, arg.span);\n-        }\n+                  _expr: @ast::expr,\n+                  _callee: Option<@ast::expr>,\n+                  _callee_id: ast::node_id,\n+                  _callee_span: span,\n+                  _args: &[@ast::expr])\n+    {\n+        // NB: This call to check for conflicting loans is not truly\n+        // necessary, because the callee_id never issues new loans.\n+        // However, I added it for consistency and lest the system\n+        // should change in the future.\n+        //\n+        // FIXME(#5074) nested method calls\n+        // self.check_for_conflicting_loans(callee_id);\n     }\n }\n \n-fn check_loans_in_fn(fk: &visit::fn_kind,\n-                     decl: &ast::fn_decl,\n-                     body: &ast::blk,\n-                     sp: span,\n-                     id: ast::node_id,\n-                     self: @mut CheckLoanCtxt,\n-                     visitor: visit::vt<@mut CheckLoanCtxt>) {\n-    let is_stack_closure = self.is_stack_closure(id);\n-    let fty = ty::node_id_to_type(self.tcx(), id);\n-\n-    let declared_purity, src;\n+fn check_loans_in_fn<'a>(fk: &visit::fn_kind,\n+                         decl: &ast::fn_decl,\n+                         body: &ast::blk,\n+                         sp: span,\n+                         id: ast::node_id,\n+                         self: @mut CheckLoanCtxt<'a>,\n+                         visitor: visit::vt<@mut CheckLoanCtxt<'a>>) {\n     match *fk {\n-        visit::fk_item_fn(*) | visit::fk_method(*) |\n+        visit::fk_item_fn(*) |\n+        visit::fk_method(*) |\n         visit::fk_dtor(*) => {\n-            declared_purity = ty::ty_fn_purity(fty);\n-            src = id;\n+            // Don't process nested items.\n+            return;\n         }\n \n-        visit::fk_anon(*) | visit::fk_fn_block(*) => {\n+        visit::fk_anon(*) |\n+        visit::fk_fn_block(*) => {\n+            let fty = ty::node_id_to_type(self.tcx(), id);\n             let fty_sigil = ty::ty_closure_sigil(fty);\n             check_moves_from_captured_variables(self, id, fty_sigil);\n-            let pair = ty::determine_inherited_purity(\n-                (self.declared_purity.purity, self.declared_purity.def),\n-                (ty::ty_fn_purity(fty), id),\n-                fty_sigil);\n-            declared_purity = pair.first();\n-            src = pair.second();\n         }\n     }\n \n-    debug!(\"purity on entry=%?\", copy self.declared_purity);\n-    do save_and_restore_managed(self.declared_purity) {\n-        do save_and_restore_managed(self.fn_args) {\n-            self.declared_purity = @mut PurityState::function(declared_purity, src);\n-\n-            match *fk {\n-                visit::fk_anon(*) |\n-                visit::fk_fn_block(*) if is_stack_closure => {\n-                    // inherits the fn_args from enclosing ctxt\n-                }\n-                visit::fk_anon(*) | visit::fk_fn_block(*) |\n-                visit::fk_method(*) | visit::fk_item_fn(*) |\n-                visit::fk_dtor(*) => {\n-                    let mut fn_args = ~[];\n-                    for decl.inputs.each |input| {\n-                        // For the purposes of purity, only consider function-\n-                        // typed bindings in trivial patterns to be function\n-                        // arguments. For example, do not allow `f` and `g` in\n-                        // (f, g): (&fn(), &fn()) to be called.\n-                        match input.pat.node {\n-                            ast::pat_ident(_, _, None) => {\n-                                fn_args.push(input.pat.id);\n-                            }\n-                            _ => {} // Ignore this argument.\n-                        }\n-                    }\n-                    *self.fn_args = @fn_args;\n-                }\n-            }\n-\n-            visit::visit_fn(fk, decl, body, sp, id, self, visitor);\n-        }\n-    }\n-    debug!(\"purity on exit=%?\", copy self.declared_purity);\n+    visit::visit_fn(fk, decl, body, sp, id, self, visitor);\n \n     fn check_moves_from_captured_variables(self: @mut CheckLoanCtxt,\n                                            id: ast::node_id,\n@@ -706,16 +650,16 @@ fn check_loans_in_fn(fk: &visit::fn_kind,\n                                 fmt!(\"illegal by-move capture of %s\",\n                                      self.bccx.cmt_to_str(move_cmt)));\n                         }\n-                        MoveWhileBorrowed(move_cmt, loan_cmt) => {\n+                        MoveWhileBorrowed(loan_path, loan_span) => {\n                             self.bccx.span_err(\n                                 cap_var.span,\n-                                fmt!(\"by-move capture of %s prohibited \\\n-                                      due to outstanding loan\",\n-                                     self.bccx.cmt_to_str(move_cmt)));\n+                                fmt!(\"cannot move `%s` into closure \\\n+                                      because it is borrowed\",\n+                                     self.bccx.loan_path_to_str(loan_path)));\n                             self.bccx.span_note(\n-                                loan_cmt.span,\n-                                fmt!(\"loan of %s granted here\",\n-                                     self.bccx.cmt_to_str(loan_cmt)));\n+                                loan_span,\n+                                fmt!(\"borrow of `%s` occurs here\",\n+                                     self.bccx.loan_path_to_str(loan_path)));\n                         }\n                     }\n                 }\n@@ -726,17 +670,19 @@ fn check_loans_in_fn(fk: &visit::fn_kind,\n     }\n }\n \n-fn check_loans_in_local(local: @ast::local,\n-                        self: @mut CheckLoanCtxt,\n-                        vt: visit::vt<@mut CheckLoanCtxt>) {\n+fn check_loans_in_local<'a>(local: @ast::local,\n+                            self: @mut CheckLoanCtxt<'a>,\n+                            vt: visit::vt<@mut CheckLoanCtxt<'a>>) {\n     visit::visit_local(local, self, vt);\n }\n \n-fn check_loans_in_expr(expr: @ast::expr,\n-                       self: @mut CheckLoanCtxt,\n-                       vt: visit::vt<@mut CheckLoanCtxt>) {\n-    debug!(\"check_loans_in_expr(expr=%?/%s)\",\n-           expr.id, pprust::expr_to_str(expr, self.tcx().sess.intr()));\n+fn check_loans_in_expr<'a>(expr: @ast::expr,\n+                           self: @mut CheckLoanCtxt<'a>,\n+                           vt: visit::vt<@mut CheckLoanCtxt<'a>>) {\n+    debug!(\"check_loans_in_expr(expr=%s)\",\n+           expr.repr(self.tcx()));\n+\n+    visit::visit_expr(expr, self, vt);\n \n     self.check_for_conflicting_loans(expr.id);\n \n@@ -746,12 +692,12 @@ fn check_loans_in_expr(expr: @ast::expr,\n \n     match expr.node {\n       ast::expr_swap(l, r) => {\n-        self.check_assignment(at_swap, l);\n-        self.check_assignment(at_swap, r);\n+        self.check_assignment(l);\n+        self.check_assignment(r);\n       }\n       ast::expr_assign(dest, _) |\n       ast::expr_assign_op(_, dest, _) => {\n-        self.check_assignment(at_straight_up, dest);\n+        self.check_assignment(dest);\n       }\n       ast::expr_call(f, ref args, _) => {\n         self.check_call(expr, Some(f), f.id, f.span, *args);\n@@ -776,32 +722,35 @@ fn check_loans_in_expr(expr: @ast::expr,\n                         expr.span,\n                         ~[]);\n       }\n-      ast::expr_match(*) => {\n-          // Note: moves out of pattern bindings are not checked by\n-          // the borrow checker, at least not directly.  What happens\n-          // is that if there are any moved bindings, the discriminant\n-          // will be considered a move, and this will be checked as\n-          // normal.  Then, in `middle::check_match`, we will check\n-          // that no move occurs in a binding that is underneath an\n-          // `@` or `&`.  Together these give the same guarantees as\n-          // `check_move_out_from_expr()` without requiring us to\n-          // rewalk the patterns and rebuild the pattern\n-          // categorizations.\n-      }\n       _ => { }\n     }\n-\n-    visit::visit_expr(expr, self, vt);\n }\n \n-fn check_loans_in_block(blk: &ast::blk,\n-                        self: @mut CheckLoanCtxt,\n-                        vt: visit::vt<@mut CheckLoanCtxt>) {\n-    do save_and_restore_managed(self.declared_purity) {\n-        self.check_for_conflicting_loans(blk.node.id);\n+fn check_loans_in_pat<'a>(pat: @ast::pat,\n+                          self: @mut CheckLoanCtxt<'a>,\n+                          vt: visit::vt<@mut CheckLoanCtxt<'a>>)\n+{\n+    self.check_for_conflicting_loans(pat.id);\n+\n+    // Note: moves out of pattern bindings are not checked by\n+    // the borrow checker, at least not directly.  What happens\n+    // is that if there are any moved bindings, the discriminant\n+    // will be considered a move, and this will be checked as\n+    // normal.  Then, in `middle::check_match`, we will check\n+    // that no move occurs in a binding that is underneath an\n+    // `@` or `&`.  Together these give the same guarantees as\n+    // `check_move_out_from_expr()` without requiring us to\n+    // rewalk the patterns and rebuild the pattern\n+    // categorizations.\n+\n+    visit::visit_pat(pat, self, vt);\n+}\n \n-        *self.declared_purity = self.declared_purity.recurse(blk);\n-        visit::visit_block(blk, self, vt);\n-    }\n+fn check_loans_in_block<'a>(blk: &ast::blk,\n+                            self: @mut CheckLoanCtxt<'a>,\n+                            vt: visit::vt<@mut CheckLoanCtxt<'a>>)\n+{\n+    visit::visit_block(blk, self, vt);\n+    self.check_for_conflicting_loans(blk.node.id);\n }\n "}, {"sha": "1e09fbe71843c1be8ea45ac2ac257daa09ff1cd8", "filename": "src/librustc/middle/borrowck/doc.rs", "status": "added", "additions": 750, "deletions": 0, "changes": 750, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -0,0 +1,750 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+# The Borrow Checker\n+\n+This pass has the job of enforcing memory safety. This is a subtle\n+topic. The only way I know how to explain it is terms of a formal\n+model, so that's what I'll do.\n+\n+# Formal model\n+\n+Let's consider a simple subset of Rust in which you can only borrow\n+from lvalues like so:\n+\n+    LV = x | LV.f | *LV\n+\n+Here `x` represents some variable, `LV.f` is a field reference,\n+and `*LV` is a pointer dereference. There is no auto-deref or other\n+niceties. This means that if you have a type like:\n+\n+    struct S { f: uint }\n+\n+and a variable `a: ~S`, then the rust expression `a.f` would correspond\n+to an `LV` of `(*a).f`.\n+\n+Here is the formal grammar for the types we'll consider:\n+\n+    TY = () | S<'LT...> | ~TY | & 'LT MQ TY | @ MQ TY\n+    MQ = mut | imm | const\n+\n+Most of these types should be pretty self explanatory. Here `S` is a\n+struct name and we assume structs are declared like so:\n+\n+    SD = struct S<'LT...> { (f: TY)... }\n+\n+# An intuitive explanation\n+\n+## Issuing loans\n+\n+Now, imagine we had a program like this:\n+\n+    struct Foo { f: uint, g: uint }\n+    ...\n+    'a: {\n+      let mut x: ~Foo = ...;\n+      let y = &mut (*x).f;\n+      x = ...;\n+    }\n+\n+This is of course dangerous because mutating `x` will free the old\n+value and hence invalidate `y`. The borrow checker aims to prevent\n+this sort of thing.\n+\n+### Loans\n+\n+The way the borrow checker works is that it analyzes each borrow\n+expression (in our simple model, that's stuff like `&LV`, though in\n+real life there are a few other cases to consider). For each borrow\n+expression, it computes a vector of loans:\n+\n+    LOAN = (LV, LT, PT, LK)\n+    PT = Partial | Total\n+    LK = MQ | RESERVE\n+\n+Each `LOAN` tuple indicates some sort of restriction on what can be\n+done to the lvalue `LV`; `LV` will always be a path owned by the\n+current stack frame. These restrictions are called \"loans\" because\n+they are always the result of a borrow expression.\n+\n+Every loan has a lifetime `LT` during which those restrictions are in\n+effect.  The indicator `PT` distinguishes between *total* loans, in\n+which the LV itself was borrowed, and *partial* loans, which means\n+that some content ownwed by LV was borrowed.\n+\n+The final element in the loan tuple is the *loan kind* `LK`.  There\n+are four kinds: mutable, immutable, const, and reserve:\n+\n+- A \"mutable\" loan means that LV may be written to through an alias, and\n+  thus LV cannot be written to directly or immutably aliased (remember\n+  that we preserve the invariant that any given value can only be\n+  written to through one path at a time; hence if there is a mutable\n+  alias to LV, then LV cannot be written directly until this alias is\n+  out of scope).\n+\n+- An \"immutable\" loan means that LV must remain immutable.  Hence it\n+  cannot be written, but other immutable aliases are permitted.\n+\n+- A \"const\" loan means that an alias to LV exists.  LV may still be\n+  written or frozen.\n+\n+- A \"reserve\" loan is the strongest case.  It prevents both mutation\n+  and aliasing of any kind, including `&const` loans.  Reserve loans\n+  are a side-effect of borrowing an `&mut` loan.\n+\n+In addition to affecting mutability, a loan of any kind implies that\n+LV cannot be moved.\n+\n+### Example\n+\n+To give you a better feeling for what a loan is, let's look at three\n+loans that would be issued as a result of the borrow `&(*x).f` in the\n+example above:\n+\n+    ((*x).f, Total, mut, 'a)\n+    (*x, Partial, mut, 'a)\n+    (x, Partial, mut, 'a)\n+\n+The first loan states that the expression `(*x).f` has been loaned\n+totally as mutable for the lifetime `'a`. This first loan would\n+prevent an assignment `(*x).f = ...` from occurring during the\n+lifetime `'a`.\n+\n+Now let's look at the second loan. You may have expected that each\n+borrow would result in only one loan. But this is not the case.\n+Instead, there will be loans for every path where mutation might\n+affect the validity of the borrowed pointer that is created (in some\n+cases, there can even be multiple loans per path, see the section on\n+\"Borrowing in Calls\" below for the gory details). The reason for this\n+is to prevent actions that would indirectly affect the borrowed path.\n+In this case, we wish to ensure that `(*x).f` is not mutated except\n+through the mutable alias `y`.  Therefore, we must not only prevent an\n+assignment to `(*x).f` but also an assignment like `*x = Foo {...}`,\n+as this would also mutate the field `f`.  To do so, we issue a\n+*partial* mutable loan for `*x` (the loan is partial because `*x`\n+itself was not borrowed).  This partial loan will cause any attempt to\n+assign to `*x` to be flagged as an error.\n+\n+Because both partial and total loans prevent assignments, you may\n+wonder why we bother to distinguish between them.  The reason for this\n+distinction has to do with preventing double borrows. In particular,\n+it is legal to borrow both `&mut x.f` and `&mut x.g` simultaneously,\n+but it is not legal to borrow `&mut x.f` twice. In the borrow checker,\n+the first case would result in two *partial* mutable loans of `x`\n+(along with one total mutable loan of `x.f` and one of `x.g) whereas\n+the second would result in two *total* mutable loans of `x.f` (along\n+with two partial mutable loans of `x`).  Multiple *total mutable* loan\n+for the same path are not permitted, but multiple *partial* loans (of\n+any mutability) are permitted.\n+\n+Finally, we come to the third loan. This loan is a partial mutable\n+loan of `x`.  This loan prevents us from reassigning `x`, which would\n+be bad for two reasons.  First, it would change the value of `(*x).f`\n+but, even worse, it would cause the pointer `y` to become a dangling\n+pointer.  Bad all around.\n+\n+## Checking for illegal assignments, moves, and reborrows\n+\n+Once we have computed the loans introduced by each borrow, the borrow\n+checker will determine the full set of loans in scope at each\n+expression and use that to decide whether that expression is legal.\n+Remember that the scope of loan is defined by its lifetime LT.  We\n+sometimes say that a loan which is in-scope at a particular point is\n+an \"outstanding loan\".\n+\n+The kinds of expressions which in-scope loans can render illegal are\n+*assignments*, *moves*, and *borrows*.\n+\n+An assignments to an lvalue LV is illegal if there is in-scope mutable\n+or immutable loan for LV.  Assignment with an outstanding mutable loan\n+is illegal because then the `&mut` pointer is supposed to be the only\n+way to mutate the value.  Assignment with an outstanding immutable\n+loan is illegal because the value is supposed to be immutable at that\n+point.\n+\n+A move from an lvalue LV is illegal if there is any sort of\n+outstanding loan.\n+\n+A borrow expression may be illegal if any of the loans which it\n+produces conflict with other outstanding loans.  Two loans are\n+considered compatible if one of the following conditions holds:\n+\n+- At least one loan is a const loan.\n+- Both loans are partial loans.\n+- Both loans are immutable.\n+\n+Any other combination of loans is illegal.\n+\n+# The set of loans that results from a borrow expression\n+\n+Here we'll define four functions---MUTATE, FREEZE, ALIAS, and\n+TAKE---which are all used to compute the set of LOANs that result\n+from a borrow expression.  The first three functions each have\n+a similar type signature:\n+\n+    MUTATE(LV, LT, PT) -> LOANS\n+    FREEZE(LV, LT, PT) -> LOANS\n+    ALIAS(LV, LT, PT) -> LOANS\n+\n+MUTATE, FREEZE, and ALIAS are used when computing the loans result\n+from mutable, immutable, and const loans respectively.  For example,\n+the loans resulting from an expression like `&mut (*x).f` would be\n+computed by `MUTATE((*x).f, LT, Total)`, where `LT` is the lifetime of\n+the resulting pointer.  Similarly the loans for `&(*x).f` and `&const\n+(*x).f` would be computed by `FREEZE((*x).f, LT, Total)` and\n+`ALIAS((*x).f, LT, Total)` respectively. (Actually this is a slight\n+simplification; see the section below on Borrows in Calls for the full\n+gory details)\n+\n+The names MUTATE, FREEZE, and ALIAS are intended to suggest the\n+semantics of `&mut`, `&`, and `&const` borrows respectively.  `&mut`,\n+for example, creates a mutable alias of LV.  `&` causes the borrowed\n+value to be frozen (immutable).  `&const` does neither but does\n+introduce an alias to be the borrowed value.\n+\n+Each of these three functions is only defined for some inputs.  That\n+is, it may occur that some particular borrow is not legal.  For\n+example, it is illegal to make an `&mut` loan of immutable data.  In\n+that case, the MUTATE() function is simply not defined (in the code,\n+it returns a Result<> condition to indicate when a loan would be\n+illegal).\n+\n+The final function, RESERVE, is used as part of borrowing an `&mut`\n+pointer.  Due to the fact that it is used for one very particular\n+purpose, it has a rather simpler signature than the others:\n+\n+    RESERVE(LV, LT) -> LOANS\n+\n+It is explained when we come to that case.\n+\n+## The function MUTATE()\n+\n+Here we use [inference rules][ir] to define the MUTATE() function.\n+We will go case by case for the various kinds of lvalues that\n+can be borrowed.\n+\n+[ir]: http://en.wikipedia.org/wiki/Rule_of_inference\n+\n+### Mutating local variables\n+\n+The rule for mutating local variables is as follows:\n+\n+    Mutate-Variable:\n+      LT <= Scope(x)\n+      Mut(x) = Mut\n+      --------------------------------------------------\n+      MUTATE(x, LT, PT) = (x, LT, PT, mut)\n+\n+Here `Scope(x)` is the lifetime of the block in which `x` was declared\n+and `Mut(x)` indicates the mutability with which `x` was declared.\n+This rule simply states that you can only create a mutable alias\n+to a variable if it is mutable, and that alias cannot outlive the\n+stack frame in which the variable is declared.\n+\n+### Mutating fields and owned pointers\n+\n+As it turns out, the rules for mutating fields and mutating owned\n+pointers turn out to be quite similar.  The reason is that the\n+expressions `LV.f` and `*LV` are both owned by their base expression\n+`LV`.  So basically the result of mutating `LV.f` or `*LV` is computed\n+by adding a loan for `LV.f` or `*LV` and then the loans for a partial\n+take of `LV`:\n+\n+    Mutate-Field:\n+      MUTATE(LV, LT, Partial) = LOANS\n+      ------------------------------------------------------------\n+      MUTATE(LV.f, LT, PT) = LOANS, (LV.F, LT, PT, mut)\n+\n+    Mutate-Owned-Ptr:\n+      Type(LV) = ~Ty\n+      MUTATE(LV, LT, Partial) = LOANS\n+      ------------------------------------------------------------\n+      MUTATE(*LV, LT, PT) = LOANS, (*LV, LT, PT, mut)\n+\n+Note that while our micro-language only has fields, the slight\n+variations on the `Mutate-Field` rule are used for any interior content\n+that appears in the full Rust language, such as the contents of a\n+tuple, fields in a struct, or elements of a fixed-length vector.\n+\n+### Mutating dereferenced borrowed pointers\n+\n+The rule for borrowed pointers is by far the most complicated:\n+\n+    Mutate-Mut-Borrowed-Ptr:\n+      Type(LV) = &LT_P mut Ty             // (1)\n+      LT <= LT_P                          // (2)\n+      RESERVE(LV, LT) = LOANS             // (3)\n+      ------------------------------------------------------------\n+      MUTATE(*LV, LT, PT) = LOANS, (*LV, LT, PT, Mut)\n+\n+Condition (1) states that only a mutable borrowed pointer can be\n+taken.  Condition (2) states that the lifetime of the alias must be\n+less than the lifetime of the borrowed pointer being taken.\n+\n+Conditions (3) and (4) are where things get interesting.  The intended\n+semantics of the borrow is that the new `&mut` pointer is the only one\n+which has the right to modify the data; the original `&mut` pointer\n+must not be used for mutation.  Because borrowed pointers do not own\n+their content nor inherit mutability, we must be particularly cautious\n+of aliases, which could permit the original borrowed pointer to be\n+reached from another path and thus circumvent our loans.\n+\n+Here is one example of what could go wrong if we ignore clause (4):\n+\n+    let x: &mut T;\n+    ...\n+    let y = &mut *x;   // Only *y should be able to mutate...\n+    let z = &const x;\n+    **z = ...;         // ...but here **z is still able to mutate!\n+\n+Another possible error could occur with moves:\n+\n+    let x: &mut T;\n+    ...\n+    let y = &mut *x;   // Issues loan: (*x, LT, Total, Mut)\n+    let z = x;         // moves from x\n+    *z = ...;          // Mutates *y indirectly! Bad.\n+\n+In both of these cases, the problem is that when creating the alias\n+`y` we would only issue a loan preventing assignment through `*x`.\n+But this loan can be easily circumvented by moving from `x` or\n+aliasing it.  Note that, in the first example, the alias of `x` was\n+created using `&const`, which is a particularly weak form of alias.\n+\n+The danger of aliases can also occur when the `&mut` pointer itself\n+is already located in an alias location, as here:\n+\n+    let x: @mut &mut T; // or &mut &mut T, &&mut T,\n+    ...                 // &const &mut T, @&mut T, etc\n+    let y = &mut **x;   // Only *y should be able to mutate...\n+    let z = x;\n+    **z = ...;          // ...but here **z is still able to mutate!\n+\n+When we cover the rules for RESERVE, we will see that it would\n+disallow this case, because MUTATE can only be applied to canonical\n+lvalues which are owned by the current stack frame.\n+\n+It might be the case that if `&const` and `@const` pointers were\n+removed, we could do away with RESERVE and simply use MUTATE instead.\n+But we have to be careful about the final example in particular, since\n+dynamic freezing would not be sufficient to prevent this example.\n+Perhaps a combination of MUTATE with a predicate OWNED(LV).\n+\n+One final detail: unlike every other case, when we calculate the loans\n+using RESERVE we do not use the original lifetime `LT` but rather\n+`GLB(Scope(LV), LT)`.  What this says is:\n+\n+### Mutating dereferenced managed pointers\n+\n+Because the correctness of managed pointer loans is checked dynamically,\n+the rule is quite simple:\n+\n+    Mutate-Mut-Managed-Ptr:\n+      Type(LV) = @mut Ty\n+      Add ROOT-FREEZE annotation for *LV with lifetime LT\n+      ------------------------------------------------------------\n+      MUTATE(*LV, LT, Total) = []\n+\n+No loans are issued.  Instead, we add a side annotation that causes\n+`*LV` to be rooted and frozen on entry to LV.  You could rephrase\n+these rules as having multiple returns values, or rephrase this as a\n+kind of loan, but whatever.\n+\n+One interesting point is that *partial takes* of `@mut` are forbidden.\n+This is not for any soundness reason but just because it is clearer\n+for users when `@mut` values are either lent completely or not at all.\n+\n+## The function FREEZE\n+\n+The rules for FREEZE are pretty similar to MUTATE.  The first four\n+cases I'll just present without discussion, as the reasoning is\n+quite analogous to the MUTATE case:\n+\n+    Freeze-Variable:\n+      LT <= Scope(x)\n+      --------------------------------------------------\n+      FREEZE(x, LT, PT) = (x, LT, PT, imm)\n+\n+    Freeze-Field:\n+      FREEZE(LV, LT, Partial) = LOANS\n+      ------------------------------------------------------------\n+      FREEZE(LV.f, LT, PT) = LOANS, (LV.F, LT, PT, imm)\n+\n+    Freeze-Owned-Ptr:\n+      Type(LV) = ~Ty\n+      FREEZE(LV, LT, Partial) = LOANS\n+      ------------------------------------------------------------\n+      FREEZE(*LV, LT, PT) = LOANS, (*LV, LT, PT, imm)\n+\n+    Freeze-Mut-Borrowed-Ptr:\n+      Type(LV) = &LT_P mut Ty\n+      LT <= LT_P\n+      RESERVE(LV, LT) = LOANS\n+      ------------------------------------------------------------\n+      FREEZE(*LV, LT, PT) = LOANS, (*LV, LT, PT, Imm)\n+\n+    Freeze-Mut-Managed-Ptr:\n+      Type(LV) = @mut Ty\n+      Add ROOT-FREEZE annotation for *LV with lifetime LT\n+      ------------------------------------------------------------\n+      Freeze(*LV, LT, Total) = []\n+\n+The rule to \"freeze\" an immutable borrowed pointer is quite\n+simple, since the content is already immutable:\n+\n+    Freeze-Imm-Borrowed-Ptr:\n+      Type(LV) = &LT_P Ty                 // (1)\n+      LT <= LT_P                          // (2)\n+      ------------------------------------------------------------\n+      FREEZE(*LV, LT, PT) = LOANS, (*LV, LT, PT, Mut)\n+\n+The final two rules pertain to borrows of `@Ty`.  There is a bit of\n+subtlety here.  The main problem is that we must guarantee that the\n+managed box remains live for the entire borrow.  We can either do this\n+dynamically, by rooting it, or (better) statically, and hence there\n+are two rules:\n+\n+    Freeze-Imm-Managed-Ptr-1:\n+      Type(LV) = @Ty\n+      Add ROOT annotation for *LV\n+      ------------------------------------------------------------\n+      FREEZE(*LV, LT, PT) = []\n+\n+    Freeze-Imm-Managed-Ptr-2:\n+      Type(LV) = @Ty\n+      LT <= Scope(LV)\n+      Mut(LV) = imm\n+      LV is not moved\n+      ------------------------------------------------------------\n+      FREEZE(*LV, LT, PT) = []\n+\n+The intention of the second rule is to avoid an extra root if LV\n+serves as a root.  In that case, LV must (1) outlive the borrow; (2)\n+be immutable; and (3) not be moved.\n+\n+## The ALIAS function\n+\n+The function ALIAS is used for `&const` loans but also to handle one\n+corner case concerning function arguments (covered in the section\n+\"Borrows in Calls\" below).  It computes the loans that result from\n+observing that there is a pointer to `LV` and thus that pointer must\n+remain valid.\n+\n+The first two rules are simple:\n+\n+    Alias-Variable:\n+      LT <= Scope(x)\n+      --------------------------------------------------\n+      ALIAS(x, LT, PT) = (x, LT, PT, Const)\n+\n+    Alias-Field:\n+      ALIAS(LV, LT, Partial) = LOANS\n+      ------------------------------------------------------------\n+      ALIAS(LV.f, LT, PT) = LOANS, (LV.F, LT, PT, Const)\n+\n+### Aliasing owned pointers\n+\n+The rule for owned pointers is somewhat interesting:\n+\n+    Alias-Owned-Ptr:\n+      Type(LV) = ~Ty\n+      FREEZE(LV, LT, Partial) = LOANS\n+      ------------------------------------------------------------\n+      ALIAS(*LV, LT, PT) = LOANS, (*LV, LT, PT, Const)\n+\n+Here we *freeze* the base `LV`.  The reason is that if an owned\n+pointer is mutated it frees its content, which means that the alias to\n+`*LV` would become a dangling pointer.\n+\n+### Aliasing borrowed pointers\n+\n+The rule for borrowed pointers is quite simple, because borrowed\n+pointers do not own their content and thus do not play a role in\n+keeping it live:\n+\n+    Alias-Borrowed-Ptr:\n+      Type(LV) = &LT_P MQ Ty\n+      LT <= LT_P\n+      ------------------------------------------------------------\n+      ALIAS(*LV, LT, PT) = []\n+\n+Basically, the existence of a borrowed pointer to some memory with\n+lifetime LT_P is proof that the memory can safely be aliased for any\n+lifetime LT <= LT_P.\n+\n+### Aliasing managed pointers\n+\n+The rules for aliasing managed pointers are similar to those\n+used with FREEZE, except that they apply to all manager pointers\n+regardles of mutability:\n+\n+    Alias-Managed-Ptr-1:\n+      Type(LV) = @MQ Ty\n+      Add ROOT annotation for *LV\n+      ------------------------------------------------------------\n+      ALIAS(*LV, LT, PT) = []\n+\n+    Alias-Managed-Ptr-2:\n+      Type(LV) = @MQ Ty\n+      LT <= Scope(LV)\n+      Mut(LV) = imm\n+      LV is not moved\n+      ------------------------------------------------------------\n+      ALIAS(*LV, LT, PT) = []\n+\n+## The RESERVE function\n+\n+The final function, RESERVE, is used for loans of `&mut` pointers.  As\n+discussed in the section on the function MUTATE, we must be quite\n+careful when \"re-borrowing\" an `&mut` pointer to ensure that the original\n+`&mut` pointer can no longer be used to mutate.\n+\n+There are a couple of dangers to be aware of:\n+\n+- `&mut` pointers do not inherit mutability.  Therefore, if you have\n+  an lvalue LV with type `&mut T` and you freeze `LV`, you do *not*\n+  freeze `*LV`.  This is quite different from an `LV` with type `~T`.\n+\n+- Also, because they do not inherit mutability, if the `&mut` pointer\n+  lives in an aliased location, then *any alias* can be used to write!\n+\n+As a consequence of these two rules, RESERVE can only be successfully\n+invoked on an lvalue LV that is *owned by the current stack frame*.\n+This ensures that there are no aliases that are not visible from the\n+outside.  Moreover, Reserve loans are incompatible with all other\n+loans, even Const loans.  This prevents any aliases from being created\n+within the current function.\n+\n+### Reserving local variables\n+\n+The rule for reserving a variable is generally straightforward but\n+with one interesting twist:\n+\n+    Reserve-Variable:\n+      --------------------------------------------------\n+      RESERVE(x, LT) = (x, LT, Total, Reserve)\n+\n+The twist here is that the incoming lifetime is not required to\n+be a subset of the incoming variable, unlike every other case.  To\n+see the reason for this, imagine the following function:\n+\n+    struct Foo { count: uint }\n+    fn count_field(x: &'a mut Foo) -> &'a mut count {\n+        &mut (*x).count\n+    }\n+\n+This function consumes one `&mut` pointer and returns another with the\n+same lifetime pointing at a particular field.  The borrow for the\n+`&mut` expression will result in a call to `RESERVE(x, 'a)`, which is\n+intended to guarantee that `*x` is not later aliased or used to\n+mutate.  But the lifetime of `x` is limited to the current function,\n+which is a sublifetime of the parameter `'a`, so the rules used for\n+MUTATE, FREEZE, and ALIAS (which require that the lifetime of the loan\n+not exceed the lifetime of the variable) would result in an error.\n+\n+Nonetheless this function is perfectly legitimate.  After all, the\n+caller has moved in an `&mut` pointer with lifetime `'a`, and thus has\n+given up their right to mutate the value for the remainder of `'a`.\n+So it is fine for us to return a pointer with the same lifetime.\n+\n+The reason that RESERVE differs from the other functions is that\n+RESERVE is not responsible for guaranteeing that the pointed-to data\n+will outlive the borrowed pointer being created.  After all, `&mut`\n+values do not own the data they point at.\n+\n+### Reserving owned content\n+\n+The rules for fields and owned pointers are very straightforward:\n+\n+    Reserve-Field:\n+      RESERVE(LV, LT) = LOANS\n+      ------------------------------------------------------------\n+      RESERVE(LV.f, LT) = LOANS, (LV.F, LT, Total, Reserve)\n+\n+    Reserve-Owned-Ptr:\n+      Type(LV) = ~Ty\n+      RESERVE(LV, LT) = LOANS\n+      ------------------------------------------------------------\n+      RESERVE(*LV, LT) = LOANS, (*LV, LT, Total, Reserve)\n+\n+### Reserving `&mut` borrowed pointers\n+\n+Unlike other borrowed pointers, `&mut` pointers are unaliasable,\n+so we can reserve them like everything else:\n+\n+    Reserve-Mut-Borrowed-Ptr:\n+      Type(LV) = &LT_P mut Ty\n+      RESERVE(LV, LT) = LOANS\n+      ------------------------------------------------------------\n+      RESERVE(*LV, LT) = LOANS, (*LV, LT, Total, Reserve)\n+\n+## Borrows in calls\n+\n+Earlier we said that the MUTATE, FREEZE, and ALIAS functions were used\n+to compute the loans resulting from a borrow expression.  But this is\n+not strictly correct, there is a slight complication that occurs with\n+calls by which additional loans may be necessary.  We will explain\n+that here and give the full details.\n+\n+Imagine a call expression `'a: E1(E2, E3)`, where `Ei` are some\n+expressions. If we break this down to something a bit lower-level, it\n+is kind of short for:\n+\n+    'a: {\n+        'a_arg1: let temp1: ... = E1;\n+        'a_arg2: let temp2: ... = E2;\n+        'a_arg3: let temp3: ... = E3;\n+        'a_call: temp1(temp2, temp3)\n+    }\n+\n+Here the lifetime labels indicate the various lifetimes. As you can\n+see there are in fact four relevant lifetimes (only one of which was\n+named by the user): `'a` corresponds to the expression `E1(E2, E3)` as\n+a whole. `'a_arg1`, `'a_arg2`, and `'a_arg3` correspond to the\n+evaluations of `E1`, `E2`, and `E3` respectively. Finally, `'a_call`\n+corresponds to the *actual call*, which is the point where the values\n+of the parameters will be used.\n+\n+Now, let's look at a (contrived, but representative) example to see\n+why all this matters:\n+\n+    struct Foo { f: uint, g: uint }\n+    ...\n+    fn add(p: &mut uint, v: uint) {\n+        *p += v;\n+    }\n+    ...\n+    fn inc(p: &mut uint) -> uint {\n+        *p += 1; *p\n+    }\n+    fn weird() {\n+        let mut x: ~Foo = ~Foo { ... };\n+        'a: add(&mut (*x).f,\n+                'b: inc(&mut (*x).f)) // (*)\n+    }\n+\n+The important part is the line marked `(*)` which contains a call to\n+`add()`. The first argument is a mutable borrow of the field `f`.\n+The second argument *always borrows* the field `f`. Now, if these two\n+borrows overlapped in time, this would be illegal, because there would\n+be two `&mut` pointers pointing at `f`. And, in a way, they *do*\n+overlap in time, since the first argument will be evaluated first,\n+meaning that the pointer will exist when the second argument executes.\n+But in another important way they do not overlap in time. Let's\n+expand out that final call to `add()` as we did before:\n+\n+    'a: {\n+        'a_arg1: let a_temp1: ... = add;\n+        'a_arg2: let a_temp2: &'a_call mut uint = &'a_call mut (*x).f;\n+        'a_arg3_: let a_temp3: uint = {\n+            let b_temp1: ... = inc;\n+            let b_temp2: &'b_call = &'b_call mut (*x).f;\n+            'b_call: b_temp1(b_temp2)\n+        };\n+        'a_call: a_temp1(a_temp2, a_temp3)\n+    }\n+\n+When it's written this way, we can see that although there are two\n+borrows, the first has lifetime `'a_call` and the second has lifetime\n+`'b_call` and in fact these lifetimes do not overlap. So everything\n+is fine.\n+\n+But this does not mean that there isn't reason for caution!  Imagine a\n+devious program like *this* one:\n+\n+    struct Foo { f: uint, g: uint }\n+    ...\n+    fn add(p: &mut uint, v: uint) {\n+        *p += v;\n+    }\n+    ...\n+    fn consume(x: ~Foo) -> uint {\n+        x.f + x.g\n+    }\n+    fn weird() {\n+        let mut x: ~Foo = ~Foo { ... };\n+        'a: add(&mut (*x).f, consume(x)) // (*)\n+    }\n+\n+In this case, there is only one borrow, but the second argument is\n+`consume(x)` instead of a second borrow. Because `consume()` is\n+declared to take a `~Foo`, it will in fact free the pointer `x` when\n+it has finished executing. If it is not obvious why this is\n+troublesome, consider this expanded version of that call:\n+\n+    'a: {\n+        'a_arg1: let a_temp1: ... = add;\n+        'a_arg2: let a_temp2: &'a_call mut uint = &'a_call mut (*x).f;\n+        'a_arg3_: let a_temp3: uint = {\n+            let b_temp1: ... = consume;\n+            let b_temp2: ~Foo = x;\n+            'b_call: b_temp1(x)\n+        };\n+        'a_call: a_temp1(a_temp2, a_temp3)\n+    }\n+\n+In this example, we will have borrowed the first argument before `x`\n+is freed and then free `x` during evaluation of the second\n+argument. This causes `a_temp2` to be invalidated.\n+\n+Of course the loans computed from the borrow expression are supposed\n+to prevent this situation.  But if we just considered the loans from\n+`MUTATE((*x).f, 'a_call, Total)`, the resulting loans would be:\n+\n+    ((*x).f, 'a_call, Total,   Mut)\n+    (*x,     'a_call, Partial, Mut)\n+    (x,      'a_call, Partial, Mut)\n+\n+Because these loans are only in scope for `'a_call`, they do nothing\n+to prevent the move that occurs evaluating the second argument.\n+\n+The way that we solve this is to say that if you have a borrow\n+expression `&'LT_P mut LV` which itself occurs in the lifetime\n+`'LT_B`, then the resulting loans are:\n+\n+    MUTATE(LV, LT_P, Total) + ALIAS(LV, LUB(LT_P, LT_B), Total)\n+\n+The call to MUTATE is what we've seen so far.  The second part\n+expresses the idea that the expression LV will be evaluated starting\n+at LT_B until the end of LT_P.  Now, in the normal case, LT_P >= LT_B,\n+and so the second set of loans that result from a ALIAS are basically\n+a no-op.  However, in the case of an argument where the evaluation of\n+the borrow occurs before the interval where the resulting pointer will\n+be used, this ALIAS is important.\n+\n+In the case of our example, it would produce a set of loans like:\n+\n+    ((*x).f, 'a, Total, Const)\n+    (*x, 'a, Total, Const)\n+    (x, 'a, Total, Imm)\n+\n+The scope of these loans is `'a = LUB('a_arg2, 'a_call)`, and so they\n+encompass all subsequent arguments.  The first set of loans are Const\n+loans, which basically just prevent moves.  However, when we cross\n+over the dereference of the owned pointer `x`, the rule for ALIAS\n+specifies that `x` must be frozen, and hence the final loan is an Imm\n+loan.  In any case the troublesome second argument would be flagged\n+as an error.\n+\n+# Maps that are created\n+\n+Borrowck results in two maps.\n+\n+- `root_map`: identifies those expressions or patterns whose result\n+  needs to be rooted. Conceptually the root_map maps from an\n+  expression or pattern node to a `node_id` identifying the scope for\n+  which the expression must be rooted (this `node_id` should identify\n+  a block or call). The actual key to the map is not an expression id,\n+  however, but a `root_map_key`, which combines an expression id with a\n+  deref count and is used to cope with auto-deref.\n+\n+*/"}, {"sha": "e40d0e63eb38eab0bd03d5fb44af06f48ae698ec", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "removed", "additions": 0, "deletions": 643, "changes": 643, "blob_url": "https://github.com/rust-lang/rust/blob/b5a7e8b35322869b1cf51bd1b35a86e9e721da54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a7e8b35322869b1cf51bd1b35a86e9e721da54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=b5a7e8b35322869b1cf51bd1b35a86e9e721da54", "patch": "@@ -1,643 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ----------------------------------------------------------------------\n-// Gathering loans\n-//\n-// The borrow check proceeds in two phases. In phase one, we gather the full\n-// set of loans that are required at any point.  These are sorted according to\n-// their associated scopes.  In phase two, checking loans, we will then make\n-// sure that all of these loans are honored.\n-\n-use middle::borrowck::preserve::{PreserveCondition, PcOk, PcIfPure};\n-use middle::borrowck::{Loan, bckerr, bckres, BorrowckCtxt, err_mutbl};\n-use middle::borrowck::{LoanKind, TotalFreeze, PartialFreeze,\n-                       TotalTake, PartialTake, Immobile};\n-use middle::borrowck::ReqMaps;\n-use middle::borrowck::loan;\n-use middle::mem_categorization::{cmt, mem_categorization_ctxt};\n-use middle::pat_util;\n-use middle::ty::{ty_region};\n-use middle::ty;\n-use util::common::indenter;\n-use util::ppaux::{Repr, region_to_str};\n-\n-use core::hashmap::{HashSet, HashMap};\n-use syntax::ast::{m_const, m_imm, m_mutbl};\n-use syntax::ast;\n-use syntax::codemap::span;\n-use syntax::print::pprust;\n-use syntax::visit;\n-\n-/// Context used while gathering loans:\n-///\n-/// - `bccx`: the the borrow check context\n-/// - `req_maps`: the maps computed by `gather_loans()`, see def'n of the\n-///   struct `ReqMaps` for more info\n-/// - `item_ub`: the id of the block for the enclosing fn/method item\n-/// - `root_ub`: the id of the outermost block for which we can root\n-///   an `@T`.  This is the id of the innermost enclosing\n-///   loop or function body.\n-///\n-/// The role of `root_ub` is to prevent us from having to accumulate\n-/// vectors of rooted items at runtime.  Consider this case:\n-///\n-///     fn foo(...) -> int {\n-///         let mut ptr: &int;\n-///         while some_cond {\n-///             let x: @int = ...;\n-///             ptr = &*x;\n-///         }\n-///         *ptr\n-///     }\n-///\n-/// If we are not careful here, we would infer the scope of the borrow `&*x`\n-/// to be the body of the function `foo()` as a whole.  We would then\n-/// have root each `@int` that is produced, which is an unbounded number.\n-/// No good.  Instead what will happen is that `root_ub` will be set to the\n-/// body of the while loop and we will refuse to root the pointer `&*x`\n-/// because it would have to be rooted for a region greater than `root_ub`.\n-struct GatherLoanCtxt {\n-    bccx: @BorrowckCtxt,\n-    req_maps: ReqMaps,\n-    item_ub: ast::node_id,\n-    root_ub: ast::node_id,\n-    ignore_adjustments: HashSet<ast::node_id>\n-}\n-\n-pub fn gather_loans(bccx: @BorrowckCtxt, crate: @ast::crate) -> ReqMaps {\n-    let glcx = @mut GatherLoanCtxt {\n-        bccx: bccx,\n-        req_maps: ReqMaps { req_loan_map: HashMap::new(),\n-                            pure_map: HashMap::new() },\n-        item_ub: 0,\n-        root_ub: 0,\n-        ignore_adjustments: HashSet::new()\n-    };\n-    let v = visit::mk_vt(@visit::Visitor {visit_expr: req_loans_in_expr,\n-                                          visit_fn: req_loans_in_fn,\n-                                          visit_stmt: add_stmt_to_map,\n-                                          .. *visit::default_visitor()});\n-    visit::visit_crate(crate, glcx, v);\n-    let @GatherLoanCtxt{req_maps, _} = glcx;\n-    return req_maps;\n-}\n-\n-fn req_loans_in_fn(fk: &visit::fn_kind,\n-                   decl: &ast::fn_decl,\n-                   body: &ast::blk,\n-                   sp: span,\n-                   id: ast::node_id,\n-                   self: @mut GatherLoanCtxt,\n-                   v: visit::vt<@mut GatherLoanCtxt>) {\n-    // see explanation attached to the `root_ub` field:\n-    let old_item_id = self.item_ub;\n-    let old_root_ub = self.root_ub;\n-    self.root_ub = body.node.id;\n-\n-    match *fk {\n-        visit::fk_anon(*) | visit::fk_fn_block(*) => {}\n-        visit::fk_item_fn(*) | visit::fk_method(*) |\n-        visit::fk_dtor(*) => {\n-            self.item_ub = body.node.id;\n-        }\n-    }\n-\n-    visit::visit_fn(fk, decl, body, sp, id, self, v);\n-    self.root_ub = old_root_ub;\n-    self.item_ub = old_item_id;\n-}\n-\n-fn req_loans_in_expr(ex: @ast::expr,\n-                     self: @mut GatherLoanCtxt,\n-                     vt: visit::vt<@mut GatherLoanCtxt>) {\n-    let bccx = self.bccx;\n-    let tcx = bccx.tcx;\n-    let old_root_ub = self.root_ub;\n-\n-    debug!(\"req_loans_in_expr(expr=%?/%s)\",\n-           ex.id, pprust::expr_to_str(ex, tcx.sess.intr()));\n-\n-    // If this expression is borrowed, have to ensure it remains valid:\n-    {\n-        let mut this = &mut *self;\n-        if !this.ignore_adjustments.contains(&ex.id) {\n-            for tcx.adjustments.find(&ex.id).each |&adjustments| {\n-                this.guarantee_adjustments(ex, *adjustments);\n-            }\n-        }\n-    }\n-\n-    // Special checks for various kinds of expressions:\n-    match ex.node {\n-      ast::expr_addr_of(mutbl, base) => {\n-        let base_cmt = self.bccx.cat_expr(base);\n-\n-        // make sure that the thing we are pointing out stays valid\n-        // for the lifetime `scope_r` of the resulting ptr:\n-        let scope_r = ty_region(tcx, ex.span, tcx.ty(ex));\n-        self.guarantee_valid(base_cmt, mutbl, scope_r);\n-        visit::visit_expr(ex, self, vt);\n-      }\n-\n-      ast::expr_match(ex_v, ref arms) => {\n-        let cmt = self.bccx.cat_expr(ex_v);\n-        for (*arms).each |arm| {\n-            for arm.pats.each |pat| {\n-                self.gather_pat(cmt, *pat, arm.body.node.id, ex.id);\n-            }\n-        }\n-        visit::visit_expr(ex, self, vt);\n-      }\n-\n-      ast::expr_index(rcvr, _) |\n-      ast::expr_binary(_, rcvr, _) |\n-      ast::expr_unary(_, rcvr) |\n-      ast::expr_assign_op(_, rcvr, _)\n-      if self.bccx.method_map.contains_key(&ex.id) => {\n-        // Receivers in method calls are always passed by ref.\n-        //\n-        // Here, in an overloaded operator, the call is this expression,\n-        // and hence the scope of the borrow is this call.\n-        //\n-        // FIX? / NOT REALLY---technically we should check the other\n-        // argument and consider the argument mode.  But how annoying.\n-        // And this problem when goes away when argument modes are\n-        // phased out.  So I elect to leave this undone.\n-        let scope_r = ty::re_scope(ex.id);\n-        let rcvr_cmt = self.bccx.cat_expr(rcvr);\n-        self.guarantee_valid(rcvr_cmt, m_imm, scope_r);\n-\n-        // FIXME (#3387): Total hack: Ignore adjustments for the left-hand\n-        // side. Their regions will be inferred to be too large.\n-        self.ignore_adjustments.insert(rcvr.id);\n-\n-        visit::visit_expr(ex, self, vt);\n-      }\n-\n-      // FIXME--#3387\n-      // ast::expr_binary(_, lhs, rhs) => {\n-      //     // Universal comparison operators like ==, >=, etc\n-      //     // take their arguments by reference.\n-      //     let lhs_ty = ty::expr_ty(self.tcx(), lhs);\n-      //     if !ty::type_is_scalar(lhs_ty) {\n-      //         let scope_r = ty::re_scope(ex.id);\n-      //         let lhs_cmt = self.bccx.cat_expr(lhs);\n-      //         self.guarantee_valid(lhs_cmt, m_imm, scope_r);\n-      //         let rhs_cmt = self.bccx.cat_expr(rhs);\n-      //         self.guarantee_valid(rhs_cmt, m_imm, scope_r);\n-      //     }\n-      //     visit::visit_expr(ex, self, vt);\n-      // }\n-\n-      ast::expr_field(rcvr, _, _)\n-      if self.bccx.method_map.contains_key(&ex.id) => {\n-        // Receivers in method calls are always passed by ref.\n-        //\n-        // Here, the field a.b is in fact a closure.  Eventually, this\n-        // should be an &fn, but for now it's an @fn.  In any case,\n-        // the enclosing scope is either the call where it is a rcvr\n-        // (if used like `a.b(...)`), the call where it's an argument\n-        // (if used like `x(a.b)`), or the block (if used like `let x\n-        // = a.b`).\n-        let scope_r = self.tcx().region_maps.encl_region(ex.id);\n-        let rcvr_cmt = self.bccx.cat_expr(rcvr);\n-        self.guarantee_valid(rcvr_cmt, m_imm, scope_r);\n-        visit::visit_expr(ex, self, vt);\n-      }\n-\n-      // see explanation attached to the `root_ub` field:\n-      ast::expr_while(cond, ref body) => {\n-        // during the condition, can only root for the condition\n-        self.root_ub = cond.id;\n-        (vt.visit_expr)(cond, self, vt);\n-\n-        // during body, can only root for the body\n-        self.root_ub = body.node.id;\n-        (vt.visit_block)(body, self, vt);\n-      }\n-\n-      // see explanation attached to the `root_ub` field:\n-      ast::expr_loop(ref body, _) => {\n-        self.root_ub = body.node.id;\n-        visit::visit_expr(ex, self, vt);\n-      }\n-\n-      _ => {\n-        visit::visit_expr(ex, self, vt);\n-      }\n-    }\n-\n-    // Check any contained expressions:\n-\n-    self.root_ub = old_root_ub;\n-}\n-\n-pub impl GatherLoanCtxt {\n-    fn tcx(&mut self) -> ty::ctxt { self.bccx.tcx }\n-\n-    fn guarantee_adjustments(&mut self,\n-                             expr: @ast::expr,\n-                             adjustment: &ty::AutoAdjustment) {\n-        debug!(\"guarantee_adjustments(expr=%s, adjustment=%?)\",\n-               expr.repr(self.tcx()), adjustment);\n-        let _i = indenter();\n-\n-        match *adjustment {\n-            ty::AutoAddEnv(*) => {\n-                debug!(\"autoaddenv -- no autoref\");\n-                return;\n-            }\n-\n-            ty::AutoDerefRef(\n-                ty::AutoDerefRef {\n-                    autoref: None, _ }) => {\n-                debug!(\"no autoref\");\n-                return;\n-            }\n-\n-            ty::AutoDerefRef(\n-                ty::AutoDerefRef {\n-                    autoref: Some(ref autoref),\n-                    autoderefs: autoderefs}) => {\n-                let mcx = &mem_categorization_ctxt {\n-                    tcx: self.tcx(),\n-                    method_map: self.bccx.method_map};\n-                let cmt = mcx.cat_expr_autoderefd(expr, autoderefs);\n-                debug!(\"after autoderef, cmt=%s\", self.bccx.cmt_to_repr(cmt));\n-\n-                match autoref.kind {\n-                    ty::AutoPtr => {\n-                        self.guarantee_valid(cmt,\n-                                             autoref.mutbl,\n-                                             autoref.region)\n-                    }\n-                    ty::AutoBorrowVec | ty::AutoBorrowVecRef => {\n-                        let cmt_index = mcx.cat_index(expr, cmt);\n-                        self.guarantee_valid(cmt_index,\n-                                             autoref.mutbl,\n-                                             autoref.region)\n-                    }\n-                    ty::AutoBorrowFn => {\n-                        let cmt_deref = mcx.cat_deref_fn(expr, cmt, 0);\n-                        self.guarantee_valid(cmt_deref,\n-                                             autoref.mutbl,\n-                                             autoref.region)\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    // guarantees that addr_of(cmt) will be valid for the duration of\n-    // `static_scope_r`, or reports an error.  This may entail taking\n-    // out loans, which will be added to the `req_loan_map`.  This can\n-    // also entail \"rooting\" GC'd pointers, which means ensuring\n-    // dynamically that they are not freed.\n-    fn guarantee_valid(&mut self,\n-                       cmt: cmt,\n-                       req_mutbl: ast::mutability,\n-                       scope_r: ty::Region)\n-    {\n-\n-        let loan_kind = match req_mutbl {\n-            m_mutbl => TotalTake,\n-            m_imm => TotalFreeze,\n-            m_const => Immobile\n-        };\n-\n-        self.bccx.stats.guaranteed_paths += 1;\n-\n-        debug!(\"guarantee_valid(cmt=%s, req_mutbl=%?, \\\n-                loan_kind=%?, scope_r=%s)\",\n-               self.bccx.cmt_to_repr(cmt),\n-               req_mutbl,\n-               loan_kind,\n-               region_to_str(self.tcx(), scope_r));\n-        let _i = indenter();\n-\n-        match cmt.lp {\n-          // If this expression is a loanable path, we MUST take out a\n-          // loan.  This is somewhat non-obvious.  You might think,\n-          // for example, that if we have an immutable local variable\n-          // `x` whose value is being borrowed, we could rely on `x`\n-          // not to change.  This is not so, however, because even\n-          // immutable locals can be moved.  So we take out a loan on\n-          // `x`, guaranteeing that it remains immutable for the\n-          // duration of the reference: if there is an attempt to move\n-          // it within that scope, the loan will be detected and an\n-          // error will be reported.\n-          Some(_) => {\n-              match loan::loan(self.bccx, cmt, scope_r, loan_kind) {\n-                  Err(ref e) => { self.bccx.report((*e)); }\n-                  Ok(loans) => {\n-                      self.add_loans(cmt, loan_kind, scope_r, loans);\n-                  }\n-              }\n-          }\n-\n-          // The path is not loanable: in that case, we must try and\n-          // preserve it dynamically (or see that it is preserved by\n-          // virtue of being rooted in some immutable path).  We must\n-          // also check that the mutability of the desired pointer\n-          // matches with the actual mutability (but if an immutable\n-          // pointer is desired, that is ok as long as we are pure)\n-          None => {\n-            let result: bckres<PreserveCondition> = {\n-                do self.check_mutbl(loan_kind, cmt).chain |pc1| {\n-                    do self.bccx.preserve(cmt, scope_r,\n-                                          self.item_ub,\n-                                          self.root_ub).chain |pc2| {\n-                        Ok(pc1.combine(pc2))\n-                    }\n-                }\n-            };\n-\n-            match result {\n-                Ok(PcOk) => {\n-                    debug!(\"result of preserve: PcOk\");\n-\n-                    // we were able guarantee the validity of the ptr,\n-                    // perhaps by rooting or because it is immutably\n-                    // rooted.  good.\n-                    self.bccx.stats.stable_paths += 1;\n-                }\n-                Ok(PcIfPure(ref e)) => {\n-                    debug!(\"result of preserve: %?\", PcIfPure((*e)));\n-\n-                    // we are only able to guarantee the validity if\n-                    // the scope is pure\n-                    match scope_r {\n-                        ty::re_scope(pure_id) => {\n-                            // if the scope is some block/expr in the\n-                            // fn, then just require that this scope\n-                            // be pure\n-                            self.req_maps.pure_map.insert(pure_id, *e);\n-                            self.bccx.stats.req_pure_paths += 1;\n-\n-                            debug!(\"requiring purity for scope %?\",\n-                                   scope_r);\n-\n-                            if self.tcx().sess.borrowck_note_pure() {\n-                                self.bccx.span_note(\n-                                    cmt.span,\n-                                    fmt!(\"purity required\"));\n-                            }\n-                        }\n-                        _ => {\n-                            // otherwise, we can't enforce purity for\n-                            // that scope, so give up and report an\n-                            // error\n-                            self.bccx.report((*e));\n-                        }\n-                    }\n-                }\n-                Err(ref e) => {\n-                    // we cannot guarantee the validity of this pointer\n-                    debug!(\"result of preserve: error\");\n-                    self.bccx.report((*e));\n-                }\n-            }\n-          }\n-        }\n-    }\n-\n-    // Check that the pat `cmt` is compatible with the required\n-    // mutability, presuming that it can be preserved to stay alive\n-    // long enough.\n-    //\n-    // For example, if you have an expression like `&x.f` where `x`\n-    // has type `@mut{f:int}`, this check might fail because `&x.f`\n-    // reqires an immutable pointer, but `f` lives in (aliased)\n-    // mutable memory.\n-    fn check_mutbl(&mut self,\n-                   loan_kind: LoanKind,\n-                   cmt: cmt)\n-                -> bckres<PreserveCondition> {\n-        debug!(\"check_mutbl(loan_kind=%?, cmt.mutbl=%?)\",\n-               loan_kind, cmt.mutbl);\n-\n-        match loan_kind {\n-            Immobile => Ok(PcOk),\n-\n-            TotalTake | PartialTake => {\n-                if cmt.mutbl.is_mutable() {\n-                    Ok(PcOk)\n-                } else {\n-                    Err(bckerr { cmt: cmt, code: err_mutbl(loan_kind) })\n-                }\n-            }\n-\n-            TotalFreeze | PartialFreeze => {\n-                if cmt.mutbl.is_immutable() {\n-                    Ok(PcOk)\n-                } else if cmt.cat.is_mutable_box() {\n-                    Ok(PcOk)\n-                } else {\n-                    // Eventually:\n-                    let e = bckerr {cmt: cmt,\n-                                    code: err_mutbl(loan_kind)};\n-                    Ok(PcIfPure(e))\n-                }\n-            }\n-        }\n-    }\n-\n-    fn add_loans(&mut self,\n-                 cmt: cmt,\n-                 loan_kind: LoanKind,\n-                 scope_r: ty::Region,\n-                 loans: ~[Loan]) {\n-        if loans.len() == 0 {\n-            return;\n-        }\n-\n-        // Normally we wouldn't allow `re_free` here. However, in this case\n-        // it should be sound. Below is nmatsakis' reasoning:\n-        //\n-        // Perhaps [this permits] a function kind of like this one here, which\n-        // consumes one mut pointer and returns a narrower one:\n-        //\n-        //     struct Foo { f: int }\n-        //     fn foo(p: &'v mut Foo) -> &'v mut int { &mut p.f }\n-        //\n-        // I think this should work fine but there is more subtlety to it than\n-        // I at first imagined. Unfortunately it's a very important use case,\n-        // I think, so it really ought to work. The changes you [pcwalton]\n-        // made to permit re_free() do permit this case, I think, but I'm not\n-        // sure what else they permit. I have to think that over a bit.\n-        //\n-        // Ordinarily, a loan with scope re_free wouldn't make sense, because\n-        // you couldn't enforce it. But in this case, your function signature\n-        // informs the caller that you demand exclusive access to p and its\n-        // contents for the lifetime v. Since borrowed pointers are\n-        // non-copyable, they must have (a) made a borrow which will enforce\n-        // those conditions and then (b) given you the resulting pointer.\n-        // Therefore, they should be respecting the loan. So it actually seems\n-        // that it's ok in this case to have a loan with re_free, so long as\n-        // the scope of the loan is no greater than the region pointer on\n-        // which it is based. Neat but not something I had previously\n-        // considered all the way through. (Note that we already rely on\n-        // similar reasoning to permit you to return borrowed pointers into\n-        // immutable structures, this is just the converse I suppose)\n-\n-        let scope_id = match scope_r {\n-            ty::re_scope(scope_id) |\n-            ty::re_free(ty::FreeRegion {scope_id, _}) => {\n-                scope_id\n-            }\n-            _ => {\n-                self.bccx.tcx.sess.span_bug(\n-                    cmt.span,\n-                    fmt!(\"loans required but scope is scope_region is %s \\\n-                          (%?)\",\n-                         region_to_str(self.tcx(), scope_r),\n-                         scope_r));\n-            }\n-        };\n-\n-        self.add_loans_to_scope_id(scope_id, loans);\n-\n-        if loan_kind.is_freeze() && !cmt.mutbl.is_immutable() {\n-            self.bccx.stats.loaned_paths_imm += 1;\n-\n-            if self.tcx().sess.borrowck_note_loan() {\n-                self.bccx.span_note(\n-                    cmt.span,\n-                    fmt!(\"immutable loan required\"));\n-            }\n-        } else {\n-            self.bccx.stats.loaned_paths_same += 1;\n-        }\n-    }\n-\n-    fn add_loans_to_scope_id(&mut self,\n-                             scope_id: ast::node_id,\n-                             loans: ~[Loan]) {\n-        debug!(\"adding %u loans to scope_id %?: %s\",\n-               loans.len(), scope_id,\n-               str::connect(loans.map(|l| self.bccx.loan_to_repr(l)), \", \"));\n-        match self.req_maps.req_loan_map.find(&scope_id) {\n-            Some(req_loans) => {\n-                req_loans.push_all(loans);\n-                return;\n-            }\n-            None => {}\n-        }\n-        self.req_maps.req_loan_map.insert(scope_id, @mut loans);\n-    }\n-\n-    fn gather_pat(@mut self,\n-                  discr_cmt: cmt,\n-                  root_pat: @ast::pat,\n-                  arm_id: ast::node_id,\n-                  match_id: ast::node_id) {\n-        do self.bccx.cat_pattern(discr_cmt, root_pat) |cmt, pat| {\n-            match pat.node {\n-              ast::pat_ident(bm, _, _) if self.pat_is_binding(pat) => {\n-                match bm {\n-                  ast::bind_by_ref(mutbl) => {\n-                    // ref x or ref x @ p --- creates a ptr which must\n-                    // remain valid for the scope of the match\n-\n-                    // find the region of the resulting pointer (note that\n-                    // the type of such a pattern will *always* be a\n-                    // region pointer)\n-                    let scope_r = ty_region(self.tcx(), pat.span,\n-                                            self.tcx().ty(pat));\n-\n-                    // if the scope of the region ptr turns out to be\n-                    // specific to this arm, wrap the categorization with\n-                    // a cat_discr() node.  There is a detailed discussion\n-                    // of the function of this node in method preserve():\n-                    let arm_scope = ty::re_scope(arm_id);\n-                    if self.bccx.is_subregion_of(scope_r, arm_scope) {\n-                        let cmt_discr = self.bccx.cat_discr(cmt, match_id);\n-                        self.guarantee_valid(cmt_discr, mutbl, scope_r);\n-                    } else {\n-                        self.guarantee_valid(cmt, mutbl, scope_r);\n-                    }\n-                  }\n-                  ast::bind_by_copy | ast::bind_infer => {\n-                    // Nothing to do here; neither copies nor moves induce\n-                    // borrows.\n-                  }\n-                }\n-              }\n-\n-              ast::pat_vec(_, Some(slice_pat), _) => {\n-                  // The `slice_pat` here creates a slice into the\n-                  // original vector.  This is effectively a borrow of\n-                  // the elements of the vector being matched.\n-\n-                  let slice_ty = self.tcx().ty(slice_pat);\n-                  let (slice_mutbl, slice_r) =\n-                      self.vec_slice_info(slice_pat, slice_ty);\n-                  let mcx = self.bccx.mc_ctxt();\n-                  let cmt_index = mcx.cat_index(slice_pat, cmt);\n-                  self.guarantee_valid(cmt_index, slice_mutbl, slice_r);\n-              }\n-\n-              _ => {}\n-            }\n-        }\n-    }\n-\n-    fn vec_slice_info(@mut self,\n-                      pat: @ast::pat,\n-                      slice_ty: ty::t) -> (ast::mutability, ty::Region) {\n-        /*!\n-         *\n-         * In a pattern like [a, b, ..c], normally `c` has slice type,\n-         * but if you have [a, b, ..ref c], then the type of `ref c`\n-         * will be `&&[]`, so to extract the slice details we have\n-         * to recurse through rptrs.\n-         */\n-\n-        match ty::get(slice_ty).sty {\n-            ty::ty_evec(slice_mt, ty::vstore_slice(slice_r)) => {\n-                (slice_mt.mutbl, slice_r)\n-            }\n-\n-            ty::ty_rptr(_, ref mt) => {\n-                self.vec_slice_info(pat, mt.ty)\n-            }\n-\n-            _ => {\n-                self.tcx().sess.span_bug(\n-                    pat.span,\n-                    fmt!(\"Type of slice pattern is not a slice\"));\n-            }\n-        }\n-    }\n-\n-    fn pat_is_variant_or_struct(@mut self, pat: @ast::pat) -> bool {\n-        pat_util::pat_is_variant_or_struct(self.bccx.tcx.def_map, pat)\n-    }\n-\n-    fn pat_is_binding(@mut self, pat: @ast::pat) -> bool {\n-        pat_util::pat_is_binding(self.bccx.tcx.def_map, pat)\n-    }\n-}\n-\n-// Setting up info that preserve needs.\n-// This is just the most convenient place to do it.\n-fn add_stmt_to_map(stmt: @ast::stmt,\n-                   self: @mut GatherLoanCtxt,\n-                   vt: visit::vt<@mut GatherLoanCtxt>) {\n-    match stmt.node {\n-        ast::stmt_expr(_, id) | ast::stmt_semi(_, id) => {\n-            self.bccx.stmt_map.insert(id);\n-        }\n-        _ => ()\n-    }\n-    visit::visit_stmt(stmt, self, vt);\n-}\n-"}, {"sha": "21d7e7041d9593778530ff19ce91d8301617605a", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "added", "additions": 322, "deletions": 0, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -0,0 +1,322 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module implements the check that the lifetime of a borrow\n+//! does not exceed the lifetime of the value being borrowed.\n+\n+use core::prelude::*;\n+use middle::borrowck::*;\n+use mc = middle::mem_categorization;\n+use middle::ty;\n+use syntax::ast::{m_const, m_imm, m_mutbl};\n+use syntax::ast;\n+use syntax::codemap::span;\n+\n+pub fn guarantee_lifetime(bccx: @BorrowckCtxt,\n+                          item_scope_id: ast::node_id,\n+                          root_scope_id: ast::node_id,\n+                          span: span,\n+                          cmt: mc::cmt,\n+                          loan_region: ty::Region,\n+                          loan_mutbl: ast::mutability) {\n+    debug!(\"guarantee_lifetime(cmt=%s, loan_region=%s)\",\n+           cmt.repr(bccx.tcx), loan_region.repr(bccx.tcx));\n+    let ctxt = GuaranteeLifetimeContext {bccx: bccx,\n+                                         item_scope_id: item_scope_id,\n+                                         span: span,\n+                                         loan_region: loan_region,\n+                                         loan_mutbl: loan_mutbl,\n+                                         cmt_original: cmt,\n+                                         root_scope_id: root_scope_id};\n+    ctxt.check(cmt, None);\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Private\n+\n+struct GuaranteeLifetimeContext {\n+    bccx: @BorrowckCtxt,\n+\n+    // the node id of the function body for the enclosing item\n+    item_scope_id: ast::node_id,\n+\n+    // the node id of the innermost loop / function body; this is the\n+    // longest scope for which we can root managed boxes\n+    root_scope_id: ast::node_id,\n+\n+    span: span,\n+    loan_region: ty::Region,\n+    loan_mutbl: ast::mutability,\n+    cmt_original: mc::cmt\n+}\n+\n+impl GuaranteeLifetimeContext {\n+    fn tcx(&self) -> ty::ctxt {\n+        self.bccx.tcx\n+    }\n+\n+    fn check(&self, cmt: mc::cmt, discr_scope: Option<ast::node_id>) {\n+        //! Main routine. Walks down `cmt` until we find the \"guarantor\".\n+\n+        match cmt.cat {\n+            mc::cat_rvalue |\n+            mc::cat_implicit_self |\n+            mc::cat_copied_upvar(*) |\n+            mc::cat_local(*) |\n+            mc::cat_arg(*) |\n+            mc::cat_self(*) |\n+            mc::cat_deref(_, _, mc::region_ptr(*)) |\n+            mc::cat_deref(_, _, mc::unsafe_ptr) => {\n+                let scope = self.scope(cmt);\n+                self.check_scope(scope)\n+            }\n+\n+            mc::cat_stack_upvar(cmt) => {\n+                self.check(cmt, discr_scope)\n+            }\n+\n+            mc::cat_static_item => {\n+            }\n+\n+            mc::cat_deref(base, derefs, mc::gc_ptr(ptr_mutbl)) => {\n+                let base_scope = self.scope(base);\n+\n+                // See rule Freeze-Imm-Managed-Ptr-2 in doc.rs\n+                let omit_root = (\n+                    self.bccx.is_subregion_of(self.loan_region, base_scope) &&\n+                    base.mutbl.is_immutable() &&\n+                    !self.is_moved(base)\n+                );\n+\n+                if !omit_root {\n+                    self.check_root(base, derefs, ptr_mutbl, discr_scope);\n+                } else {\n+                    debug!(\"omitting root, base=%s, base_scope=%?\",\n+                           base.repr(self.tcx()), base_scope);\n+                }\n+            }\n+\n+            mc::cat_deref(base, _, mc::uniq_ptr(*)) |\n+            mc::cat_interior(base, _) => {\n+                self.check(base, discr_scope)\n+            }\n+\n+            mc::cat_discr(base, new_discr_scope) => {\n+                // Subtle: in a match, we must ensure that each binding\n+                // variable remains valid for the duration of the arm in\n+                // which it appears, presuming that this arm is taken.\n+                // But it is inconvenient in trans to root something just\n+                // for one arm.  Therefore, we insert a cat_discr(),\n+                // basically a special kind of category that says \"if this\n+                // value must be dynamically rooted, root it for the scope\n+                // `match_id`.\n+                //\n+                // As an example, consider this scenario:\n+                //\n+                //    let mut x = @Some(3);\n+                //    match *x { Some(y) {...} None {...} }\n+                //\n+                // Technically, the value `x` need only be rooted\n+                // in the `some` arm.  However, we evaluate `x` in trans\n+                // before we know what arm will be taken, so we just\n+                // always root it for the duration of the match.\n+                //\n+                // As a second example, consider *this* scenario:\n+                //\n+                //    let x = @mut @Some(3);\n+                //    match x { @@Some(y) {...} @@None {...} }\n+                //\n+                // Here again, `x` need only be rooted in the `some` arm.\n+                // In this case, the value which needs to be rooted is\n+                // found only when checking which pattern matches: but\n+                // this check is done before entering the arm.  Therefore,\n+                // even in this case we just choose to keep the value\n+                // rooted for the entire match.  This means the value will be\n+                // rooted even if the none arm is taken.  Oh well.\n+                //\n+                // At first, I tried to optimize the second case to only\n+                // root in one arm, but the result was suboptimal: first,\n+                // it interfered with the construction of phi nodes in the\n+                // arm, as we were adding code to root values before the\n+                // phi nodes were added.  This could have been addressed\n+                // with a second basic block.  However, the naive approach\n+                // also yielded suboptimal results for patterns like:\n+                //\n+                //    let x = @mut @...;\n+                //    match x { @@some_variant(y) | @@some_other_variant(y) =>\n+                //\n+                // The reason is that we would root the value once for\n+                // each pattern and not once per arm.  This is also easily\n+                // fixed, but it's yet more code for what is really quite\n+                // the corner case.\n+                //\n+                // Nonetheless, if you decide to optimize this case in the\n+                // future, you need only adjust where the cat_discr()\n+                // node appears to draw the line between what will be rooted\n+                // in the *arm* vs the *match*.\n+                self.check(base, Some(new_discr_scope))\n+            }\n+        }\n+    }\n+\n+    fn check_root(&self,\n+                  cmt_base: mc::cmt,\n+                  derefs: uint,\n+                  ptr_mutbl: ast::mutability,\n+                  discr_scope: Option<ast::node_id>) {\n+        debug!(\"check_root(cmt_base=%s, derefs=%? ptr_mutbl=%?, \\\n+                discr_scope=%?)\",\n+               cmt_base.repr(self.tcx()),\n+               derefs,\n+               ptr_mutbl,\n+               discr_scope);\n+\n+        // Make sure that the loan does not exceed the maximum time\n+        // that we can root the value, dynamically.\n+        let root_region = ty::re_scope(self.root_scope_id);\n+        if !self.bccx.is_subregion_of(self.loan_region, root_region) {\n+            self.report_error(\n+                err_out_of_root_scope(root_region, self.loan_region));\n+            return;\n+        }\n+\n+        // Extract the scope id that indicates how long the rooting is required\n+        let root_scope = match self.loan_region {\n+            ty::re_scope(id) => id,\n+            _ => {\n+                // the check above should fail for anything is not re_scope\n+                self.bccx.tcx.sess.span_bug(\n+                    cmt_base.span,\n+                    fmt!(\"Cannot issue root for scope region: %?\",\n+                         self.loan_region));\n+            }\n+        };\n+\n+        // If inside of a match arm, expand the rooting to the entire\n+        // match. See the detailed discussion in `check()` above.\n+        let mut root_scope = match discr_scope {\n+            None => root_scope,\n+            Some(id) => {\n+                if self.bccx.is_subscope_of(root_scope, id) {\n+                    id\n+                } else {\n+                    root_scope\n+                }\n+            }\n+        };\n+\n+        // FIXME(#3511) grow to the nearest cleanup scope---this can\n+        // cause observable errors if freezing!\n+        if !self.bccx.tcx.region_maps.is_cleanup_scope(root_scope) {\n+            debug!(\"%? is not a cleanup scope, adjusting\", root_scope);\n+            root_scope = self.bccx.tcx.region_maps.cleanup_scope(root_scope);\n+        }\n+\n+        // If we are borrowing the inside of an `@mut` box,\n+        // we need to dynamically mark it to prevent incompatible\n+        // borrows from happening later.\n+        let opt_dyna = match ptr_mutbl {\n+            m_imm | m_const => None,\n+            m_mutbl => {\n+                match self.loan_mutbl {\n+                    m_mutbl => Some(DynaMut),\n+                    m_imm | m_const => Some(DynaImm)\n+                }\n+            }\n+        };\n+\n+        // Add a record of what is required\n+        let rm_key = root_map_key {id: cmt_base.id, derefs: derefs};\n+        let root_info = RootInfo {scope: root_scope, freeze: opt_dyna};\n+        self.bccx.root_map.insert(rm_key, root_info);\n+\n+        debug!(\"root_key: %? root_info: %?\", rm_key, root_info);\n+    }\n+\n+    fn check_scope(&self, max_scope: ty::Region) {\n+        //! Reports an error if `loan_region` is larger than `valid_scope`\n+\n+        if !self.bccx.is_subregion_of(self.loan_region, max_scope) {\n+            self.report_error(err_out_of_scope(max_scope, self.loan_region));\n+        }\n+    }\n+\n+    fn is_moved(&self, cmt: mc::cmt) -> bool {\n+        //! True if `cmt` is something that is potentially moved\n+        //! out of the current stack frame.\n+\n+        match cmt.guarantor().cat {\n+            mc::cat_local(id) |\n+            mc::cat_self(id) |\n+            mc::cat_arg(id, _) => {\n+                self.bccx.moved_variables_set.contains(&id)\n+            }\n+            mc::cat_rvalue |\n+            mc::cat_static_item |\n+            mc::cat_implicit_self |\n+            mc::cat_copied_upvar(*) |\n+            mc::cat_deref(*) => {\n+                false\n+            }\n+            r @ mc::cat_interior(*) |\n+            r @ mc::cat_stack_upvar(*) |\n+            r @ mc::cat_discr(*) => {\n+                self.tcx().sess.span_bug(\n+                    cmt.span,\n+                    fmt!(\"illegal guarantor category: %?\", r));\n+            }\n+        }\n+    }\n+\n+    fn scope(&self, cmt: mc::cmt) -> ty::Region {\n+        //! Returns the maximal region scope for the which the\n+        //! lvalue `cmt` is guaranteed to be valid without any\n+        //! rooting etc, and presuming `cmt` is not mutated.\n+\n+        match cmt.cat {\n+            mc::cat_rvalue => {\n+                ty::re_scope(self.bccx.tcx.region_maps.cleanup_scope(cmt.id))\n+            }\n+            mc::cat_implicit_self |\n+            mc::cat_copied_upvar(_) => {\n+                ty::re_scope(self.item_scope_id)\n+            }\n+            mc::cat_static_item => {\n+                ty::re_static\n+            }\n+            mc::cat_local(local_id) |\n+            mc::cat_arg(local_id, _) |\n+            mc::cat_self(local_id) => {\n+                self.bccx.tcx.region_maps.encl_region(local_id)\n+            }\n+            mc::cat_deref(_, _, mc::unsafe_ptr(*)) => {\n+                ty::re_static\n+            }\n+            mc::cat_deref(_, _, mc::region_ptr(_, r)) => {\n+                r\n+            }\n+            mc::cat_deref(cmt, _, mc::uniq_ptr(*)) |\n+            mc::cat_deref(cmt, _, mc::gc_ptr(*)) |\n+            mc::cat_interior(cmt, _) |\n+            mc::cat_stack_upvar(cmt) |\n+            mc::cat_discr(cmt, _) => {\n+                self.scope(cmt)\n+            }\n+        }\n+    }\n+\n+    fn report_error(&self, code: bckerr_code) {\n+        self.bccx.report(BckError {\n+            cmt: self.cmt_original,\n+            span: self.span,\n+            code: code\n+        });\n+    }\n+}"}, {"sha": "82638ceb4d4f1bbe9c90f351e557fbd8ece3a313", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "added", "additions": 710, "deletions": 0, "changes": 710, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -0,0 +1,710 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ----------------------------------------------------------------------\n+// Gathering loans\n+//\n+// The borrow check proceeds in two phases. In phase one, we gather the full\n+// set of loans that are required at any point.  These are sorted according to\n+// their associated scopes.  In phase two, checking loans, we will then make\n+// sure that all of these loans are honored.\n+\n+use core::prelude::*;\n+\n+use middle::borrowck::*;\n+use mc = middle::mem_categorization;\n+use middle::pat_util;\n+use middle::ty::{ty_region};\n+use middle::ty;\n+use util::common::indenter;\n+use util::ppaux::{Repr};\n+\n+use core::hashmap::HashSet;\n+use core::vec;\n+use syntax::ast::{m_const, m_imm, m_mutbl};\n+use syntax::ast;\n+use syntax::ast_util::id_range;\n+use syntax::codemap::span;\n+use syntax::print::pprust;\n+use syntax::visit;\n+\n+mod lifetime;\n+mod restrictions;\n+\n+/// Context used while gathering loans:\n+///\n+/// - `bccx`: the the borrow check context\n+/// - `item_ub`: the id of the block for the enclosing fn/method item\n+/// - `root_ub`: the id of the outermost block for which we can root\n+///   an `@T`.  This is the id of the innermost enclosing\n+///   loop or function body.\n+///\n+/// The role of `root_ub` is to prevent us from having to accumulate\n+/// vectors of rooted items at runtime.  Consider this case:\n+///\n+///     fn foo(...) -> int {\n+///         let mut ptr: &int;\n+///         while some_cond {\n+///             let x: @int = ...;\n+///             ptr = &*x;\n+///         }\n+///         *ptr\n+///     }\n+///\n+/// If we are not careful here, we would infer the scope of the borrow `&*x`\n+/// to be the body of the function `foo()` as a whole.  We would then\n+/// have root each `@int` that is produced, which is an unbounded number.\n+/// No good.  Instead what will happen is that `root_ub` will be set to the\n+/// body of the while loop and we will refuse to root the pointer `&*x`\n+/// because it would have to be rooted for a region greater than `root_ub`.\n+struct GatherLoanCtxt {\n+    bccx: @BorrowckCtxt,\n+    id_range: id_range,\n+    all_loans: @mut ~[Loan],\n+    item_ub: ast::node_id,\n+    repeating_ids: ~[ast::node_id],\n+    ignore_adjustments: HashSet<ast::node_id>\n+}\n+\n+pub fn gather_loans(bccx: @BorrowckCtxt,\n+                    body: &ast::blk) -> (id_range, @mut ~[Loan]) {\n+    let glcx = @mut GatherLoanCtxt {\n+        bccx: bccx,\n+        id_range: id_range::max(),\n+        all_loans: @mut ~[],\n+        item_ub: body.node.id,\n+        repeating_ids: ~[body.node.id],\n+        ignore_adjustments: HashSet::new()\n+    };\n+    let v = visit::mk_vt(@visit::Visitor {visit_expr: gather_loans_in_expr,\n+                                          visit_block: gather_loans_in_block,\n+                                          visit_fn: gather_loans_in_fn,\n+                                          visit_stmt: add_stmt_to_map,\n+                                          visit_pat: add_pat_to_id_range,\n+                                          .. *visit::default_visitor()});\n+    (v.visit_block)(body, glcx, v);\n+    return (glcx.id_range, glcx.all_loans);\n+}\n+\n+fn add_pat_to_id_range(p: @ast::pat,\n+                       self: @mut GatherLoanCtxt,\n+                       v: visit::vt<@mut GatherLoanCtxt>) {\n+    // NB: This visitor function just adds the pat ids into the id\n+    // range. We gather loans that occur in patterns using the\n+    // `gather_pat()` method below. Eventually these two should be\n+    // brought together.\n+    self.id_range.add(p.id);\n+    visit::visit_pat(p, self, v);\n+}\n+\n+fn gather_loans_in_fn(fk: &visit::fn_kind,\n+                      decl: &ast::fn_decl,\n+                      body: &ast::blk,\n+                      sp: span,\n+                      id: ast::node_id,\n+                      self: @mut GatherLoanCtxt,\n+                      v: visit::vt<@mut GatherLoanCtxt>) {\n+    match fk {\n+        // Do not visit items here, the outer loop in borrowck/mod\n+        // will visit them for us in turn.\n+        &visit::fk_item_fn(*) | &visit::fk_method(*) |\n+        &visit::fk_dtor(*) => {\n+            return;\n+        }\n+\n+        // Visit closures as part of the containing item.\n+        &visit::fk_anon(*) | &visit::fk_fn_block(*) => {\n+            self.push_repeating_id(body.node.id);\n+            visit::visit_fn(fk, decl, body, sp, id, self, v);\n+            self.pop_repeating_id(body.node.id);\n+        }\n+    }\n+}\n+\n+fn gather_loans_in_block(blk: &ast::blk,\n+                         self: @mut GatherLoanCtxt,\n+                         vt: visit::vt<@mut GatherLoanCtxt>) {\n+    self.id_range.add(blk.node.id);\n+    visit::visit_block(blk, self, vt);\n+}\n+\n+fn gather_loans_in_expr(ex: @ast::expr,\n+                        self: @mut GatherLoanCtxt,\n+                        vt: visit::vt<@mut GatherLoanCtxt>) {\n+    let bccx = self.bccx;\n+    let tcx = bccx.tcx;\n+\n+    debug!(\"gather_loans_in_expr(expr=%?/%s)\",\n+           ex.id, pprust::expr_to_str(ex, tcx.sess.intr()));\n+\n+    self.id_range.add(ex.id);\n+    self.id_range.add(ex.callee_id);\n+\n+    // If this expression is borrowed, have to ensure it remains valid:\n+    {\n+        let mut this = &mut *self; // FIXME(#5074)\n+        if !this.ignore_adjustments.contains(&ex.id) {\n+            for tcx.adjustments.find(&ex.id).each |&adjustments| {\n+                this.guarantee_adjustments(ex, *adjustments);\n+            }\n+        }\n+    }\n+\n+    // Special checks for various kinds of expressions:\n+    match ex.node {\n+      ast::expr_addr_of(mutbl, base) => {\n+        let base_cmt = self.bccx.cat_expr(base);\n+\n+        // make sure that the thing we are pointing out stays valid\n+        // for the lifetime `scope_r` of the resulting ptr:\n+        let scope_r = ty_region(tcx, ex.span, ty::expr_ty(tcx, ex));\n+        self.guarantee_valid(ex.id, ex.span, base_cmt, mutbl, scope_r);\n+        visit::visit_expr(ex, self, vt);\n+      }\n+\n+      ast::expr_call(f, ref args, _) => {\n+        let arg_tys = ty::ty_fn_args(ty::expr_ty(self.tcx(), f));\n+        self.guarantee_arguments(ex, *args, arg_tys);\n+        visit::visit_expr(ex, self, vt);\n+      }\n+\n+      ast::expr_method_call(_, _, _, ref args, _) => {\n+        let arg_tys = ty::ty_fn_args(ty::node_id_to_type(self.tcx(),\n+                                                         ex.callee_id));\n+        self.guarantee_arguments(ex, *args, arg_tys);\n+\n+        visit::visit_expr(ex, self, vt);\n+      }\n+\n+      ast::expr_match(ex_v, ref arms) => {\n+        let cmt = self.bccx.cat_expr(ex_v);\n+        for arms.each |arm| {\n+            for arm.pats.each |pat| {\n+                self.gather_pat(cmt, *pat, arm.body.node.id, ex.id);\n+            }\n+        }\n+        visit::visit_expr(ex, self, vt);\n+      }\n+\n+      ast::expr_index(rcvr, _) |\n+      ast::expr_binary(_, rcvr, _) |\n+      ast::expr_unary(_, rcvr) |\n+      ast::expr_assign_op(_, rcvr, _)\n+      if self.bccx.method_map.contains_key(&ex.id) => {\n+        // Receivers in method calls are always passed by ref.\n+        //\n+        // Here, in an overloaded operator, the call is this expression,\n+        // and hence the scope of the borrow is this call.\n+        //\n+        // FIX? / NOT REALLY---technically we should check the other\n+        // argument and consider the argument mode.  But how annoying.\n+        // And this problem when goes away when argument modes are\n+        // phased out.  So I elect to leave this undone.\n+        let scope_r = ty::re_scope(ex.id);\n+        let rcvr_cmt = self.bccx.cat_expr(rcvr);\n+        self.guarantee_valid(rcvr.id, rcvr.span, rcvr_cmt, m_imm, scope_r);\n+\n+        // FIXME (#3387): Total hack: Ignore adjustments for the left-hand\n+        // side. Their regions will be inferred to be too large.\n+        self.ignore_adjustments.insert(rcvr.id);\n+\n+        visit::visit_expr(ex, self, vt);\n+      }\n+\n+      // FIXME--#3387\n+      // ast::expr_binary(_, lhs, rhs) => {\n+      //     // Universal comparison operators like ==, >=, etc\n+      //     // take their arguments by reference.\n+      //     let lhs_ty = ty::expr_ty(self.tcx(), lhs);\n+      //     if !ty::type_is_scalar(lhs_ty) {\n+      //         let scope_r = ty::re_scope(ex.id);\n+      //         let lhs_cmt = self.bccx.cat_expr(lhs);\n+      //         self.guarantee_valid(lhs_cmt, m_imm, scope_r);\n+      //         let rhs_cmt = self.bccx.cat_expr(rhs);\n+      //         self.guarantee_valid(rhs_cmt, m_imm, scope_r);\n+      //     }\n+      //     visit::visit_expr(ex, self, vt);\n+      // }\n+\n+      // see explanation attached to the `root_ub` field:\n+      ast::expr_while(cond, ref body) => {\n+          // during the condition, can only root for the condition\n+          self.push_repeating_id(cond.id);\n+          (vt.visit_expr)(cond, self, vt);\n+          self.pop_repeating_id(cond.id);\n+\n+          // during body, can only root for the body\n+          self.push_repeating_id(body.node.id);\n+          (vt.visit_block)(body, self, vt);\n+          self.pop_repeating_id(body.node.id);\n+      }\n+\n+      // see explanation attached to the `root_ub` field:\n+      ast::expr_loop(ref body, _) => {\n+          self.push_repeating_id(body.node.id);\n+          visit::visit_expr(ex, self, vt);\n+          self.pop_repeating_id(body.node.id);\n+      }\n+\n+      _ => {\n+        visit::visit_expr(ex, self, vt);\n+      }\n+    }\n+}\n+\n+pub impl GatherLoanCtxt {\n+    fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n+\n+    fn push_repeating_id(&mut self, id: ast::node_id) {\n+        self.repeating_ids.push(id);\n+    }\n+\n+    fn pop_repeating_id(&mut self, id: ast::node_id) {\n+        let popped = self.repeating_ids.pop();\n+        assert!(id == popped);\n+    }\n+\n+    fn guarantee_arguments(&mut self,\n+                           call_expr: @ast::expr,\n+                           args: &[@ast::expr],\n+                           arg_tys: &[ty::arg]) {\n+        for vec::each2(args, arg_tys) |arg, arg_ty| {\n+            match ty::resolved_mode(self.tcx(), arg_ty.mode) {\n+                ast::by_ref => {\n+                    self.guarantee_by_ref_argument(call_expr, *arg);\n+                }\n+                ast::by_copy => {}\n+            }\n+        }\n+    }\n+\n+    fn guarantee_by_ref_argument(&mut self,\n+                                 call_expr: @ast::expr,\n+                                 arg_expr: @ast::expr) {\n+        // FIXME(#5074) nested method calls\n+        let scope_r = ty::re_scope(call_expr.id);\n+        let arg_cmt = self.bccx.cat_expr(arg_expr);\n+        self.guarantee_valid(arg_expr.id, arg_expr.span,\n+                             arg_cmt, m_imm, scope_r);\n+    }\n+\n+    fn guarantee_adjustments(&mut self,\n+                             expr: @ast::expr,\n+                             adjustment: &ty::AutoAdjustment) {\n+        debug!(\"guarantee_adjustments(expr=%s, adjustment=%?)\",\n+               expr.repr(self.tcx()), adjustment);\n+        let _i = indenter();\n+\n+        match *adjustment {\n+            ty::AutoAddEnv(*) => {\n+                debug!(\"autoaddenv -- no autoref\");\n+                return;\n+            }\n+\n+            ty::AutoDerefRef(\n+                ty::AutoDerefRef {\n+                    autoref: None, _ }) => {\n+                debug!(\"no autoref\");\n+                return;\n+            }\n+\n+            ty::AutoDerefRef(\n+                ty::AutoDerefRef {\n+                    autoref: Some(ref autoref),\n+                    autoderefs: autoderefs}) => {\n+                let mcx = &mc::mem_categorization_ctxt {\n+                    tcx: self.tcx(),\n+                    method_map: self.bccx.method_map};\n+                let mut cmt = mcx.cat_expr_autoderefd(expr, autoderefs);\n+                debug!(\"after autoderef, cmt=%s\", cmt.repr(self.tcx()));\n+\n+                match *autoref {\n+                    ty::AutoPtr(r, m) => {\n+                        self.guarantee_valid(expr.id,\n+                                             expr.span,\n+                                             cmt,\n+                                             m,\n+                                             r)\n+                    }\n+                    ty::AutoBorrowVec(r, m) | ty::AutoBorrowVecRef(r, m) => {\n+                        let cmt_index = mcx.cat_index(expr, cmt);\n+                        self.guarantee_valid(expr.id,\n+                                             expr.span,\n+                                             cmt_index,\n+                                             m,\n+                                             r)\n+                    }\n+                    ty::AutoBorrowFn(r) => {\n+                        let cmt_deref = mcx.cat_deref_fn(expr, cmt, 0);\n+                        self.guarantee_valid(expr.id,\n+                                             expr.span,\n+                                             cmt_deref,\n+                                             m_imm,\n+                                             r)\n+                    }\n+                    ty::AutoUnsafe(_) => {}\n+                }\n+            }\n+        }\n+    }\n+\n+    // Guarantees that addr_of(cmt) will be valid for the duration of\n+    // `static_scope_r`, or reports an error.  This may entail taking\n+    // out loans, which will be added to the `req_loan_map`.  This can\n+    // also entail \"rooting\" GC'd pointers, which means ensuring\n+    // dynamically that they are not freed.\n+    fn guarantee_valid(&mut self,\n+                       borrow_id: ast::node_id,\n+                       borrow_span: span,\n+                       cmt: mc::cmt,\n+                       req_mutbl: ast::mutability,\n+                       loan_region: ty::Region)\n+    {\n+        debug!(\"guarantee_valid(borrow_id=%?, cmt=%s, \\\n+                req_mutbl=%?, loan_region=%?)\",\n+               borrow_id,\n+               cmt.repr(self.tcx()),\n+               req_mutbl,\n+               loan_region);\n+\n+        // a loan for the empty region can never be dereferenced, so\n+        // it is always safe\n+        if loan_region == ty::re_empty {\n+            return;\n+        }\n+\n+        let root_ub = { *self.repeating_ids.last() }; // FIXME(#5074)\n+\n+        // Check that the lifetime of the borrow does not exceed\n+        // the lifetime of the data being borrowed.\n+        lifetime::guarantee_lifetime(self.bccx, self.item_ub, root_ub,\n+                                     borrow_span, cmt, loan_region, req_mutbl);\n+\n+        // Check that we don't allow mutable borrows of non-mutable data.\n+        check_mutability(self.bccx, borrow_span, cmt, req_mutbl);\n+\n+        // Compute the restrictions that are required to enforce the\n+        // loan is safe.\n+        let restr = restrictions::compute_restrictions(\n+            self.bccx, borrow_span,\n+            cmt, self.restriction_set(req_mutbl));\n+\n+        // Create the loan record (if needed).\n+        let loan = match restr {\n+            restrictions::Safe => {\n+                // No restrictions---no loan record necessary\n+                return;\n+            }\n+\n+            restrictions::SafeIf(loan_path, restrictions) => {\n+                let loan_scope = match loan_region {\n+                    ty::re_scope(id) => id,\n+                    ty::re_free(ref fr) => fr.scope_id,\n+\n+                    ty::re_static => {\n+                        // If we get here, an error must have been\n+                        // reported in\n+                        // `lifetime::guarantee_lifetime()`, because\n+                        // the only legal ways to have a borrow with a\n+                        // static lifetime should not require\n+                        // restrictions. To avoid reporting derived\n+                        // errors, we just return here without adding\n+                        // any loans.\n+                        return;\n+                    }\n+\n+                    ty::re_empty |\n+                    ty::re_bound(*) |\n+                    ty::re_infer(*) => {\n+                        self.tcx().sess.span_bug(\n+                            cmt.span,\n+                            fmt!(\"Invalid borrow lifetime: %?\", loan_region));\n+                    }\n+                };\n+                debug!(\"loan_scope = %?\", loan_scope);\n+\n+                let gen_scope = self.compute_gen_scope(borrow_id, loan_scope);\n+                debug!(\"gen_scope = %?\", gen_scope);\n+\n+                let kill_scope = self.compute_kill_scope(loan_scope, loan_path);\n+                debug!(\"kill_scope = %?\", kill_scope);\n+\n+                if req_mutbl == m_mutbl {\n+                    self.mark_loan_path_as_mutated(loan_path);\n+                }\n+\n+                let all_loans = &mut *self.all_loans; // FIXME(#5074)\n+                Loan {\n+                    index: all_loans.len(),\n+                    loan_path: loan_path,\n+                    cmt: cmt,\n+                    mutbl: req_mutbl,\n+                    gen_scope: gen_scope,\n+                    kill_scope: kill_scope,\n+                    span: borrow_span,\n+                    restrictions: restrictions\n+                }\n+            }\n+        };\n+\n+        debug!(\"guarantee_valid(borrow_id=%?), loan=%s\",\n+               borrow_id, loan.repr(self.tcx()));\n+\n+        // let loan_path = loan.loan_path;\n+        // let loan_gen_scope = loan.gen_scope;\n+        // let loan_kill_scope = loan.kill_scope;\n+        self.all_loans.push(loan);\n+\n+        // if loan_gen_scope != borrow_id {\n+            // NOTE handle case where gen_scope is not borrow_id\n+            //\n+            // Typically, the scope of the loan includes the point at\n+            // which the loan is originated. This\n+            // This is a subtle case. See the test case\n+            // <compile-fail/borrowck-bad-nested-calls-free.rs>\n+            // to see what we are guarding against.\n+\n+            //let restr = restrictions::compute_restrictions(\n+            //    self.bccx, borrow_span, cmt, RESTR_EMPTY);\n+            //let loan = {\n+            //    let all_loans = &mut *self.all_loans; // FIXME(#5074)\n+            //    Loan {\n+            //        index: all_loans.len(),\n+            //        loan_path: loan_path,\n+            //        cmt: cmt,\n+            //        mutbl: m_const,\n+            //        gen_scope: borrow_id,\n+            //        kill_scope: kill_scope,\n+            //        span: borrow_span,\n+            //        restrictions: restrictions\n+            //    }\n+        // }\n+\n+        fn check_mutability(bccx: @BorrowckCtxt,\n+                            borrow_span: span,\n+                            cmt: mc::cmt,\n+                            req_mutbl: ast::mutability) {\n+            match req_mutbl {\n+                m_const => {\n+                    // Data of any mutability can be lent as const.\n+                }\n+\n+                m_imm => {\n+                    match cmt.mutbl {\n+                        mc::McImmutable | mc::McDeclared | mc::McInherited => {\n+                            // both imm and mut data can be lent as imm;\n+                            // for mutable data, this is a freeze\n+                        }\n+                        mc::McReadOnly => {\n+                            bccx.report(BckError {span: borrow_span,\n+                                                  cmt: cmt,\n+                                                  code: err_mutbl(req_mutbl)});\n+                        }\n+                    }\n+                }\n+\n+                m_mutbl => {\n+                    // Only mutable data can be lent as mutable.\n+                    if !cmt.mutbl.is_mutable() {\n+                        bccx.report(BckError {span: borrow_span,\n+                                              cmt: cmt,\n+                                              code: err_mutbl(req_mutbl)});\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn restriction_set(&self, req_mutbl: ast::mutability) -> RestrictionSet {\n+        match req_mutbl {\n+            m_const => RESTR_EMPTY,\n+            m_imm   => RESTR_EMPTY | RESTR_MUTATE,\n+            m_mutbl => RESTR_EMPTY | RESTR_MUTATE | RESTR_FREEZE\n+        }\n+    }\n+\n+    fn mark_loan_path_as_mutated(&self, loan_path: @LoanPath) {\n+        //! For mutable loans of content whose mutability derives\n+        //! from a local variable, mark the mutability decl as necessary.\n+\n+        match *loan_path {\n+            LpVar(local_id) => {\n+                self.tcx().used_mut_nodes.insert(local_id);\n+            }\n+            LpExtend(base, mc::McInherited, _) => {\n+                self.mark_loan_path_as_mutated(base);\n+            }\n+            LpExtend(_, mc::McDeclared, _) |\n+            LpExtend(_, mc::McImmutable, _) |\n+            LpExtend(_, mc::McReadOnly, _) => {\n+            }\n+        }\n+    }\n+\n+    fn compute_gen_scope(&self,\n+                         borrow_id: ast::node_id,\n+                         loan_scope: ast::node_id) -> ast::node_id {\n+        //! Determine when to introduce the loan. Typically the loan\n+        //! is introduced at the point of the borrow, but in some cases,\n+        //! notably method arguments, the loan may be introduced only\n+        //! later, once it comes into scope.\n+\n+        let rm = self.bccx.tcx.region_maps;\n+        if rm.is_subscope_of(borrow_id, loan_scope) {\n+            borrow_id\n+        } else {\n+            loan_scope\n+        }\n+    }\n+\n+    fn compute_kill_scope(&self,\n+                          loan_scope: ast::node_id,\n+                          lp: @LoanPath) -> ast::node_id {\n+        //! Determine when the loan restrictions go out of scope.\n+        //! This is either when the lifetime expires or when the\n+        //! local variable which roots the loan-path goes out of scope,\n+        //! whichever happens faster.\n+        //!\n+        //! It may seem surprising that we might have a loan region\n+        //! larger than the variable which roots the loan-path; this can\n+        //! come about when variables of `&mut` type are re-borrowed,\n+        //! as in this example:\n+        //!\n+        //!     fn counter<'a>(v: &'a mut Foo) -> &'a mut uint {\n+        //!         &mut v.counter\n+        //!     }\n+        //!\n+        //! In this case, the borrowed pointer (`'a`) outlives the\n+        //! variable `v` that hosts it. Note that this doesn't come up\n+        //! with immutable `&` pointers, because borrows of such pointers\n+        //! do not require restrictions and hence do not cause a loan.\n+\n+        let rm = self.bccx.tcx.region_maps;\n+        let lexical_scope = rm.encl_scope(lp.node_id());\n+        if rm.is_subscope_of(lexical_scope, loan_scope) {\n+            lexical_scope\n+        } else {\n+            assert!(rm.is_subscope_of(loan_scope, lexical_scope));\n+            loan_scope\n+        }\n+    }\n+\n+    fn gather_pat(&mut self,\n+                  discr_cmt: mc::cmt,\n+                  root_pat: @ast::pat,\n+                  arm_body_id: ast::node_id,\n+                  match_id: ast::node_id) {\n+        do self.bccx.cat_pattern(discr_cmt, root_pat) |cmt, pat| {\n+            match pat.node {\n+              ast::pat_ident(bm, _, _) if self.pat_is_binding(pat) => {\n+                match bm {\n+                  ast::bind_by_ref(mutbl) => {\n+                    // ref x or ref x @ p --- creates a ptr which must\n+                    // remain valid for the scope of the match\n+\n+                    // find the region of the resulting pointer (note that\n+                    // the type of such a pattern will *always* be a\n+                    // region pointer)\n+                    let scope_r =\n+                        ty_region(self.tcx(), pat.span,\n+                                  ty::node_id_to_type(self.tcx(), pat.id));\n+\n+                    // if the scope of the region ptr turns out to be\n+                    // specific to this arm, wrap the categorization\n+                    // with a cat_discr() node.  There is a detailed\n+                    // discussion of the function of this node in\n+                    // `lifetime.rs`:\n+                    let arm_scope = ty::re_scope(arm_body_id);\n+                    if self.bccx.is_subregion_of(scope_r, arm_scope) {\n+                        let cmt_discr = self.bccx.cat_discr(cmt, match_id);\n+                        self.guarantee_valid(pat.id, pat.span,\n+                                             cmt_discr, mutbl, scope_r);\n+                    } else {\n+                        self.guarantee_valid(pat.id, pat.span,\n+                                             cmt, mutbl, scope_r);\n+                    }\n+                  }\n+                  ast::bind_by_copy | ast::bind_infer => {\n+                    // Nothing to do here; neither copies nor moves induce\n+                    // borrows.\n+                  }\n+                }\n+              }\n+\n+              ast::pat_vec(_, Some(slice_pat), _) => {\n+                  // The `slice_pat` here creates a slice into the\n+                  // original vector.  This is effectively a borrow of\n+                  // the elements of the vector being matched.\n+\n+                  let slice_ty = ty::node_id_to_type(self.tcx(),\n+                                                     slice_pat.id);\n+                  let (slice_mutbl, slice_r) =\n+                      self.vec_slice_info(slice_pat, slice_ty);\n+                  let mcx = self.bccx.mc_ctxt();\n+                  let cmt_index = mcx.cat_index(slice_pat, cmt);\n+                  self.guarantee_valid(pat.id, pat.span,\n+                                       cmt_index, slice_mutbl, slice_r);\n+              }\n+\n+              _ => {}\n+            }\n+        }\n+    }\n+\n+    fn vec_slice_info(&self,\n+                      pat: @ast::pat,\n+                      slice_ty: ty::t) -> (ast::mutability, ty::Region) {\n+        /*!\n+         *\n+         * In a pattern like [a, b, ..c], normally `c` has slice type,\n+         * but if you have [a, b, ..ref c], then the type of `ref c`\n+         * will be `&&[]`, so to extract the slice details we have\n+         * to recurse through rptrs.\n+         */\n+\n+        match ty::get(slice_ty).sty {\n+            ty::ty_evec(slice_mt, ty::vstore_slice(slice_r)) => {\n+                (slice_mt.mutbl, slice_r)\n+            }\n+\n+            ty::ty_rptr(_, ref mt) => {\n+                self.vec_slice_info(pat, mt.ty)\n+            }\n+\n+            _ => {\n+                self.tcx().sess.span_bug(\n+                    pat.span,\n+                    fmt!(\"Type of slice pattern is not a slice\"));\n+            }\n+        }\n+    }\n+\n+    fn pat_is_variant_or_struct(&self, pat: @ast::pat) -> bool {\n+        pat_util::pat_is_variant_or_struct(self.bccx.tcx.def_map, pat)\n+    }\n+\n+    fn pat_is_binding(&self, pat: @ast::pat) -> bool {\n+        pat_util::pat_is_binding(self.bccx.tcx.def_map, pat)\n+    }\n+}\n+\n+// Setting up info that preserve needs.\n+// This is just the most convenient place to do it.\n+fn add_stmt_to_map(stmt: @ast::stmt,\n+                   self: @mut GatherLoanCtxt,\n+                   vt: visit::vt<@mut GatherLoanCtxt>) {\n+    match stmt.node {\n+        ast::stmt_expr(_, id) | ast::stmt_semi(_, id) => {\n+            self.bccx.stmt_map.insert(id);\n+        }\n+        _ => ()\n+    }\n+    visit::visit_stmt(stmt, self, vt);\n+}"}, {"sha": "950dbc58ec3644a2d08331b1d95657f0db086ca1", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -0,0 +1,251 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Computes the restrictions that result from a borrow.\n+\n+use core::prelude::*;\n+use middle::borrowck::*;\n+use mc = middle::mem_categorization;\n+use middle::ty;\n+use syntax::ast::{m_const, m_imm, m_mutbl};\n+use syntax::ast;\n+use syntax::codemap::span;\n+\n+pub enum RestrictionResult {\n+    Safe,\n+    SafeIf(@LoanPath, ~[Restriction])\n+}\n+\n+pub fn compute_restrictions(bccx: @BorrowckCtxt,\n+                            span: span,\n+                            cmt: mc::cmt,\n+                            restr: RestrictionSet) -> RestrictionResult {\n+    let ctxt = RestrictionsContext {\n+        bccx: bccx,\n+        span: span,\n+        cmt_original: cmt\n+    };\n+\n+    ctxt.compute(cmt, restr)\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Private\n+\n+struct RestrictionsContext {\n+    bccx: @BorrowckCtxt,\n+    span: span,\n+    cmt_original: mc::cmt\n+}\n+\n+impl RestrictionsContext {\n+    fn tcx(&self) -> ty::ctxt {\n+        self.bccx.tcx\n+    }\n+\n+    fn compute(&self,\n+               cmt: mc::cmt,\n+               restrictions: RestrictionSet) -> RestrictionResult {\n+\n+        // Check for those cases where we cannot control the aliasing\n+        // and make sure that we are not being asked to.\n+        match cmt.freely_aliasable() {\n+            None => {}\n+            Some(cause) => {\n+                self.check_aliasing_permitted(cause, restrictions);\n+            }\n+        }\n+\n+        match cmt.cat {\n+            mc::cat_rvalue => {\n+                // Effectively, rvalues are stored into a\n+                // non-aliasable temporary on the stack. Since they\n+                // are inherently non-aliasable, they can only be\n+                // accessed later through the borrow itself and hence\n+                // must inherently comply with its terms.\n+                Safe\n+            }\n+\n+            mc::cat_local(local_id) |\n+            mc::cat_arg(local_id, ast::by_copy) |\n+            mc::cat_self(local_id) => {\n+                let lp = @LpVar(local_id);\n+                SafeIf(lp, ~[Restriction {loan_path: lp,\n+                                          set: restrictions}])\n+            }\n+\n+            mc::cat_interior(cmt_base, i @ mc::interior_variant(_)) => {\n+                // When we borrow the interior of an enum, we have to\n+                // ensure the enum itself is not mutated, because that\n+                // could cause the type of the memory to change.\n+                let result = self.compute(cmt_base, restrictions | RESTR_MUTATE);\n+                self.extend(result, cmt.mutbl, LpInterior(i), restrictions)\n+            }\n+\n+            mc::cat_interior(cmt_base, i @ mc::interior_tuple) |\n+            mc::cat_interior(cmt_base, i @ mc::interior_anon_field) |\n+            mc::cat_interior(cmt_base, i @ mc::interior_field(*)) |\n+            mc::cat_interior(cmt_base, i @ mc::interior_index(*)) => {\n+                // For all of these cases, overwriting the base would\n+                // not change the type of the memory, so no additional\n+                // restrictions are needed.\n+                //\n+                // FIXME(#5397) --- Mut fields are not treated soundly\n+                //                  (hopefully they will just get phased out)\n+                let result = self.compute(cmt_base, restrictions);\n+                self.extend(result, cmt.mutbl, LpInterior(i), restrictions)\n+            }\n+\n+            mc::cat_deref(cmt_base, _, mc::uniq_ptr(*)) => {\n+                // When we borrow the interior of an owned pointer, we\n+                // cannot permit the base to be mutated, because that\n+                // would cause the unique pointer to be freed.\n+                let result = self.compute(cmt_base, restrictions | RESTR_MUTATE);\n+                self.extend(result, cmt.mutbl, LpDeref, restrictions)\n+            }\n+\n+            mc::cat_copied_upvar(*) | // FIXME(#2152) allow mutation of upvars\n+            mc::cat_static_item(*) |\n+            mc::cat_implicit_self(*) |\n+            mc::cat_arg(_, ast::by_ref) |\n+            mc::cat_deref(_, _, mc::region_ptr(m_imm, _)) |\n+            mc::cat_deref(_, _, mc::gc_ptr(m_imm)) => {\n+                Safe\n+            }\n+\n+            mc::cat_deref(_, _, mc::region_ptr(m_const, _)) |\n+            mc::cat_deref(_, _, mc::gc_ptr(m_const)) => {\n+                self.check_no_mutability_control(cmt, restrictions);\n+                Safe\n+            }\n+\n+            mc::cat_deref(cmt_base, _, mc::gc_ptr(m_mutbl)) => {\n+                // Technically, no restrictions are *necessary* here.\n+                // The validity of the borrow is guaranteed\n+                // dynamically.  However, nonetheless we add a\n+                // restriction to make a \"best effort\" to report\n+                // static errors. For example, if there is code like\n+                //\n+                //    let v = @mut ~[1, 2, 3];\n+                //    for v.each |e| {\n+                //        v.push(e + 1);\n+                //    }\n+                //\n+                // Then the code below would add restrictions on `*v`,\n+                // which means that an error would be reported\n+                // here. This of course is not perfect. For example,\n+                // a function like the following would not report an error\n+                // at compile-time but would fail dynamically:\n+                //\n+                //    let v = @mut ~[1, 2, 3];\n+                //    let w = v;\n+                //    for v.each |e| {\n+                //        w.push(e + 1);\n+                //    }\n+                //\n+                // In addition, we only add a restriction for those cases\n+                // where we can construct a sensible loan path, so an\n+                // example like the following will fail dynamically:\n+                //\n+                //    impl V {\n+                //      fn get_list(&self) -> @mut ~[int];\n+                //    }\n+                //    ...\n+                //    let v: &V = ...;\n+                //    for v.get_list().each |e| {\n+                //        v.get_list().push(e + 1);\n+                //    }\n+                match opt_loan_path(cmt_base) {\n+                    None => Safe,\n+                    Some(lp_base) => {\n+                        let lp = @LpExtend(lp_base, cmt.mutbl, LpDeref);\n+                        SafeIf(lp, ~[Restriction {loan_path: lp,\n+                                                  set: restrictions}])\n+                    }\n+                }\n+            }\n+\n+            mc::cat_deref(cmt_base, _, mc::region_ptr(m_mutbl, _)) => {\n+                // Because an `&mut` pointer does not inherit its\n+                // mutability, we can only prevent mutation or prevent\n+                // freezing if it is not aliased. Therefore, in such\n+                // cases we restrict aliasing on `cmt_base`.\n+                if restrictions.intersects(RESTR_MUTATE | RESTR_FREEZE) {\n+                    let result = self.compute(cmt_base, restrictions | RESTR_ALIAS);\n+                    self.extend(result, cmt.mutbl, LpDeref, restrictions)\n+                } else {\n+                    let result = self.compute(cmt_base, restrictions);\n+                    self.extend(result, cmt.mutbl, LpDeref, restrictions)\n+                }\n+            }\n+\n+            mc::cat_deref(_, _, mc::unsafe_ptr) => {\n+                // We are very trusting when working with unsafe pointers.\n+                Safe\n+            }\n+\n+            mc::cat_stack_upvar(cmt_base) |\n+            mc::cat_discr(cmt_base, _) => {\n+                self.compute(cmt_base, restrictions)\n+            }\n+        }\n+    }\n+\n+    fn extend(&self,\n+              result: RestrictionResult,\n+              mc: mc::MutabilityCategory,\n+              elem: LoanPathElem,\n+              restrictions: RestrictionSet) -> RestrictionResult {\n+        match result {\n+            Safe => Safe,\n+            SafeIf(base_lp, base_vec) => {\n+                let lp = @LpExtend(base_lp, mc, elem);\n+                SafeIf(lp, vec::append_one(base_vec,\n+                                           Restriction {loan_path: lp,\n+                                                        set: restrictions}))\n+            }\n+        }\n+    }\n+\n+    fn check_aliasing_permitted(&self,\n+                                cause: mc::AliasableReason,\n+                                restrictions: RestrictionSet) {\n+        //! This method is invoked when the current `cmt` is something\n+        //! where aliasing cannot be controlled. It reports an error if\n+        //! the restrictions required that it not be aliased; currently\n+        //! this only occurs when re-borrowing an `&mut` pointer.\n+        //!\n+        //! NB: To be 100% consistent, we should report an error if\n+        //! RESTR_FREEZE is found, because we cannot prevent freezing,\n+        //! nor would we want to. However, we do not report such an\n+        //! error, because this restriction only occurs when the user\n+        //! is creating an `&mut` pointer to immutable or read-only\n+        //! data, and there is already another piece of code that\n+        //! checks for this condition.\n+\n+        if restrictions.intersects(RESTR_ALIAS) {\n+            self.bccx.report_aliasability_violation(\n+                self.span,\n+                BorrowViolation,\n+                cause);\n+        }\n+    }\n+\n+    fn check_no_mutability_control(&self,\n+                                   cmt: mc::cmt,\n+                                   restrictions: RestrictionSet) {\n+        if restrictions.intersects(RESTR_MUTATE | RESTR_FREEZE) {\n+            self.bccx.report(BckError {span: self.span,\n+                                       cmt: cmt,\n+                                       code: err_freeze_aliasable_const});\n+        }\n+    }\n+}\n+"}, {"sha": "21de29b8f60ad4e6025e50a2c288b131bea55d54", "filename": "src/librustc/middle/borrowck/loan.rs", "status": "removed", "additions": 0, "deletions": 312, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/b5a7e8b35322869b1cf51bd1b35a86e9e721da54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a7e8b35322869b1cf51bd1b35a86e9e721da54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=b5a7e8b35322869b1cf51bd1b35a86e9e721da54", "patch": "@@ -1,312 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-The `Loan` module deals with borrows of *uniquely mutable* data.  We\n-say that data is uniquely mutable if the current activation (stack\n-frame) controls the only mutable reference to the data.  The most\n-common way that this can occur is if the current activation owns the\n-data being borrowed, but it can also occur with `&mut` pointers.  The\n-primary characteristic of uniquely mutable data is that, at any given\n-time, there is at most one path that can be used to mutate it, and\n-that path is only accessible from the top stack frame.\n-\n-Given that some data found at a path P is being borrowed to a borrowed\n-pointer with mutability M and lifetime L, the job of the code in this\n-module is to compute the set of *loans* that are necessary to ensure\n-that (1) the data found at P outlives L and that (2) if M is mutable\n-then the path P will not be modified directly or indirectly except\n-through that pointer.  A *loan* is the combination of a path P_L, a\n-mutability M_L, and a lifetime L_L where:\n-\n-- The path P_L indicates what data has been lent.\n-- The mutability M_L indicates the access rights on the data:\n-  - const: the data cannot be moved\n-  - immutable/mutable: the data cannot be moved or mutated\n-- The lifetime L_L indicates the *scope* of the loan.\n-\n-FIXME #4730 --- much more needed, don't have time to write this all up now\n-\n-*/\n-\n-// ----------------------------------------------------------------------\n-// Loan(Ex, M, S) = Ls holds if ToAddr(Ex) will remain valid for the entirety\n-// of the scope S, presuming that the returned set of loans `Ls` are honored.\n-\n-use middle::borrowck::{Loan, bckerr, bckres, BorrowckCtxt, err_mutbl};\n-use middle::borrowck::{LoanKind, TotalFreeze, PartialFreeze,\n-                       TotalTake, PartialTake, Immobile};\n-use middle::borrowck::{err_out_of_scope};\n-use middle::mem_categorization::{cat_arg, cat_binding, cat_discr, cat_comp};\n-use middle::mem_categorization::{cat_deref, cat_discr, cat_local, cat_self};\n-use middle::mem_categorization::{cat_special, cat_stack_upvar, cmt};\n-use middle::mem_categorization::{comp_field, comp_index, comp_variant};\n-use middle::mem_categorization::{gc_ptr, region_ptr};\n-use middle::ty;\n-use util::common::indenter;\n-\n-use syntax::ast::m_imm;\n-use syntax::ast;\n-\n-pub fn loan(bccx: @BorrowckCtxt,\n-            cmt: cmt,\n-            scope_region: ty::Region,\n-            loan_kind: LoanKind) -> bckres<~[Loan]>\n-{\n-    let mut lc = LoanContext {\n-        bccx: bccx,\n-        scope_region: scope_region,\n-        loans: ~[]\n-    };\n-    match lc.loan(cmt, loan_kind, true) {\n-        Err(ref e) => return Err((*e)),\n-        Ok(()) => {}\n-    }\n-    // FIXME #4945: Workaround for borrow check bug.\n-    Ok(copy lc.loans)\n-}\n-\n-struct LoanContext {\n-    bccx: @BorrowckCtxt,\n-\n-    // the region scope for which we must preserve the memory\n-    scope_region: ty::Region,\n-\n-    // accumulated list of loans that will be required\n-    loans: ~[Loan]\n-}\n-\n-pub impl LoanContext {\n-    fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n-\n-    fn loan(&mut self,\n-            cmt: cmt,\n-            loan_kind: LoanKind,\n-            owns_lent_data: bool) -> bckres<()>\n-    {\n-        /*!\n-         *\n-         * The main routine.\n-         *\n-         * # Parameters\n-         *\n-         * - `cmt`: the categorization of the data being borrowed\n-         * - `req_mutbl`: the mutability of the borrowed pointer\n-         *                that was created\n-         * - `owns_lent_data`: indicates whether `cmt` owns the\n-         *                     data that is being lent.  See\n-         *                     discussion in `issue_loan()`.\n-         */\n-\n-        debug!(\"loan(%s, %?)\",\n-               self.bccx.cmt_to_repr(cmt),\n-               loan_kind);\n-        let _i = indenter();\n-\n-        // see stable() above; should only be called when `cmt` is lendable\n-        if cmt.lp.is_none() {\n-            self.bccx.tcx.sess.span_bug(\n-                cmt.span,\n-                ~\"loan() called with non-lendable value\");\n-        }\n-\n-        match cmt.cat {\n-          cat_binding(_) | cat_rvalue | cat_special(_) => {\n-            // should never be loanable\n-            self.bccx.tcx.sess.span_bug(\n-                cmt.span,\n-                ~\"rvalue with a non-none lp\");\n-          }\n-          cat_local(local_id) | cat_arg(local_id) | cat_self(local_id) => {\n-              // FIXME(#4903)\n-            let local_region = self.bccx.tcx.region_maps.encl_region(local_id);\n-            self.issue_loan(cmt, local_region, loan_kind,\n-                            owns_lent_data)\n-          }\n-          cat_stack_upvar(cmt) => {\n-            self.loan(cmt, loan_kind, owns_lent_data)\n-          }\n-          cat_discr(base, _) => {\n-            self.loan(base, loan_kind, owns_lent_data)\n-          }\n-          cat_comp(cmt_base, comp_field(_, m)) |\n-          cat_comp(cmt_base, comp_index(_, m)) => {\n-            // For most components, the type of the embedded data is\n-            // stable.  Therefore, the base structure need only be\n-            // const---unless the component must be immutable.  In\n-            // that case, it must also be embedded in an immutable\n-            // location, or else the whole structure could be\n-            // overwritten and the component along with it.\n-            self.loan_stable_comp(cmt, cmt_base, loan_kind, m,\n-                                  owns_lent_data)\n-          }\n-          cat_comp(cmt_base, comp_tuple) |\n-          cat_comp(cmt_base, comp_anon_field) => {\n-            // As above.\n-            self.loan_stable_comp(cmt, cmt_base, loan_kind, m_imm,\n-                                  owns_lent_data)\n-          }\n-          cat_comp(cmt_base, comp_variant(enum_did)) => {\n-            // For enums, the memory is unstable if there are multiple\n-            // variants, because if the enum value is overwritten then\n-            // the memory changes type.\n-            if ty::enum_is_univariant(self.bccx.tcx, enum_did) {\n-                self.loan_stable_comp(cmt, cmt_base, loan_kind, m_imm,\n-                                      owns_lent_data)\n-            } else {\n-                self.loan_unstable_deref(cmt, cmt_base, loan_kind,\n-                                         owns_lent_data)\n-            }\n-          }\n-          cat_deref(cmt_base, _, uniq_ptr) => {\n-            // For unique pointers, the memory being pointed out is\n-            // unstable because if the unique pointer is overwritten\n-            // then the memory is freed.\n-            self.loan_unstable_deref(cmt, cmt_base, loan_kind,\n-                                     owns_lent_data)\n-          }\n-          cat_deref(cmt_base, _, region_ptr(ast::m_mutbl, region)) => {\n-            // Mutable data can be loaned out as immutable or const. We must\n-            // loan out the base as well as the main memory. For example,\n-            // if someone borrows `*b`, we want to borrow `b` as immutable\n-            // as well.\n-            do self.loan(cmt_base, TotalFreeze, false).chain |_| {\n-                self.issue_loan(cmt, region, loan_kind, owns_lent_data)\n-            }\n-          }\n-          cat_deref(_, _, unsafe_ptr) |\n-          cat_deref(_, _, gc_ptr(_)) |\n-          cat_deref(_, _, region_ptr(_, _)) => {\n-            // Aliased data is simply not lendable.\n-            self.bccx.tcx.sess.span_bug(\n-                cmt.span,\n-                ~\"aliased ptr with a non-none lp\");\n-          }\n-        }\n-    }\n-\n-    // A \"stable component\" is one where assigning the base of the\n-    // component cannot cause the component itself to change types.\n-    // Example: record fields.\n-    fn loan_stable_comp(&mut self,\n-                        cmt: cmt,\n-                        cmt_base: cmt,\n-                        loan_kind: LoanKind,\n-                        comp_mutbl: ast::mutability,\n-                        owns_lent_data: bool) -> bckres<()>\n-    {\n-        let base_kind = match (comp_mutbl, loan_kind) {\n-            // Declared as \"immutable\" means: inherited mutability and\n-            // hence mutable iff parent is mutable.  So propagate\n-            // mutability on up.\n-            (m_imm, TotalFreeze) | (m_imm, PartialFreeze) => PartialFreeze,\n-            (m_imm, TotalTake) | (m_imm, PartialTake) => PartialTake,\n-\n-            // Declared as \"mutable\" means: always mutable no matter\n-            // what the mutability of the base is.  So that means we\n-            // can weaken the condition on the base to PartialFreeze.\n-            // This implies that the user could freeze the base, but\n-            // that is ok since the even with an &T base, the mut\n-            // field will still be considered mutable.\n-            (_, TotalTake) | (_, PartialTake) |\n-            (_, TotalFreeze) | (_, PartialFreeze) => {\n-                PartialFreeze\n-            }\n-\n-            // If we just need to guarantee the value won't be moved,\n-            // it doesn't matter what mutability the component was\n-            // declared with.\n-            (_, Immobile) => Immobile,\n-        };\n-\n-        do self.loan(cmt_base, base_kind, owns_lent_data).chain |_ok| {\n-            // can use static for the scope because the base\n-            // determines the lifetime, ultimately\n-            self.issue_loan(cmt, ty::re_static, loan_kind,\n-                            owns_lent_data)\n-        }\n-    }\n-\n-    // An \"unstable deref\" means a deref of a ptr/comp where, if the\n-    // base of the deref is assigned to, pointers into the result of the\n-    // deref would be invalidated. Examples: interior of variants, uniques.\n-    fn loan_unstable_deref(&mut self,\n-                           cmt: cmt,\n-                           cmt_base: cmt,\n-                           loan_kind: LoanKind,\n-                           owns_lent_data: bool) -> bckres<()> {\n-        // Variant components: the base must be immutable, because\n-        // if it is overwritten, the types of the embedded data\n-        // could change.\n-        do self.loan(cmt_base, PartialFreeze, owns_lent_data).chain |_| {\n-            // can use static, as in loan_stable_comp()\n-            self.issue_loan(cmt, ty::re_static, loan_kind,\n-                            owns_lent_data)\n-        }\n-    }\n-\n-    fn issue_loan(&mut self,\n-                  cmt: cmt,\n-                  scope_ub: ty::Region,\n-                  loan_kind: LoanKind,\n-                  owns_lent_data: bool) -> bckres<()> {\n-        // Subtle: the `scope_ub` is the maximal lifetime of `cmt`.\n-        // Therefore, if `cmt` owns the data being lent, then the\n-        // scope of the loan must be less than `scope_ub`, or else the\n-        // data would be freed while the loan is active.\n-        //\n-        // However, if `cmt` does *not* own the data being lent, then\n-        // it is ok if `cmt` goes out of scope during the loan.  This\n-        // can occur when you have an `&mut` parameter that is being\n-        // reborrowed.\n-\n-        if !owns_lent_data ||\n-            self.bccx.is_subregion_of(self.scope_region, scope_ub)\n-        {\n-            if cmt.mutbl.is_mutable() {\n-                // If this loan is a mutable loan, then mark the loan path (if\n-                // it exists) as being used. This is similar to the check\n-                // performed in check_loans.rs in check_assignment(), but this\n-                // is for a different purpose of having the 'mut' qualifier.\n-                for cmt.lp.each |lp| {\n-                    for lp.node_id().each |&id| {\n-                        self.tcx().used_mut_nodes.insert(id);\n-                    }\n-                }\n-            } else if loan_kind.is_take() {\n-                // We do not allow non-mutable data to be \"taken\"\n-                // under any circumstances.\n-                return Err(bckerr {\n-                    cmt:cmt,\n-                    code:err_mutbl(loan_kind)\n-                });\n-            }\n-\n-            self.loans.push(Loan {\n-                // Note: cmt.lp must be Some(_) because otherwise this\n-                // loan process does not apply at all.\n-                lp: cmt.lp.get(),\n-                cmt: cmt,\n-                kind: loan_kind\n-            });\n-\n-            return Ok(());\n-        } else {\n-            // The loan being requested lives longer than the data\n-            // being loaned out!\n-            return Err(bckerr {\n-                cmt:cmt,\n-                code:err_out_of_scope(scope_ub, self.scope_region)\n-            });\n-        }\n-    }\n-}\n-"}, {"sha": "c108b020378ebc4d818d77a7156578dac8f1a46e", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 458, "deletions": 403, "changes": 861, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -8,254 +8,64 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n-# Borrow check\n-\n-This pass is in job of enforcing *memory safety* and *purity*.  As\n-memory safety is by far the more complex topic, I'll focus on that in\n-this description, but purity will be covered later on. In the context\n-of Rust, memory safety means three basic things:\n-\n-- no writes to immutable memory;\n-- all pointers point to non-freed memory;\n-- all pointers point to memory of the same type as the pointer.\n-\n-The last point might seem confusing: after all, for the most part,\n-this condition is guaranteed by the type check.  However, there are\n-two cases where the type check effectively delegates to borrow check.\n-\n-The first case has to do with enums.  If there is a pointer to the\n-interior of an enum, and the enum is in a mutable location (such as a\n-local variable or field declared to be mutable), it is possible that\n-the user will overwrite the enum with a new value of a different\n-variant, and thus effectively change the type of the memory that the\n-pointer is pointing at.\n+/*! See doc.rs for a thorough explanation of the borrow checker */\n \n-The second case has to do with mutability.  Basically, the type\n-checker has only a limited understanding of mutability.  It will allow\n-(for example) the user to get an immutable pointer with the address of\n-a mutable local variable.  It will also allow a `@mut T` or `~mut T`\n-pointer to be borrowed as a `&r.T` pointer.  These seeming oversights\n-are in fact intentional; they allow the user to temporarily treat a\n-mutable value as immutable.  It is up to the borrow check to guarantee\n-that the value in question is not in fact mutated during the lifetime\n-`r` of the reference.\n+use core;\n+use core::prelude::*;\n \n-# Definition of unstable memory\n-\n-The primary danger to safety arises due to *unstable memory*.\n-Unstable memory is memory whose validity or type may change as a\n-result of an assignment, move, or a variable going out of scope.\n-There are two cases in Rust where memory is unstable: the contents of\n-unique boxes and enums.\n-\n-Unique boxes are unstable because when the variable containing the\n-unique box is re-assigned, moves, or goes out of scope, the unique box\n-is freed or---in the case of a move---potentially given to another\n-task.  In either case, if there is an extant and usable pointer into\n-the box, then safety guarantees would be compromised.\n-\n-Enum values are unstable because they are reassigned the types of\n-their contents may change if they are assigned with a different\n-variant than they had previously.\n-\n-# Safety criteria that must be enforced\n-\n-Whenever a piece of memory is borrowed for lifetime L, there are two\n-things which the borrow checker must guarantee.  First, it must\n-guarantee that the memory address will remain allocated (and owned by\n-the current task) for the entirety of the lifetime L.  Second, it must\n-guarantee that the type of the data will not change for the entirety\n-of the lifetime L.  In exchange, the region-based type system will\n-guarantee that the pointer is not used outside the lifetime L.  These\n-guarantees are to some extent independent but are also inter-related.\n-\n-In some cases, the type of a pointer cannot be invalidated but the\n-lifetime can.  For example, imagine a pointer to the interior of\n-a shared box like:\n-\n-    let mut x = @mut {f: 5, g: 6};\n-    let y = &mut x.f;\n-\n-Here, a pointer was created to the interior of a shared box which\n-contains a record.  Even if `*x` were to be mutated like so:\n-\n-    *x = {f: 6, g: 7};\n-\n-This would cause `*y` to change from 5 to 6, but the pointer pointer\n-`y` remains valid.  It still points at an integer even if that integer\n-has been overwritten.\n-\n-However, if we were to reassign `x` itself, like so:\n-\n-    x = @{f: 6, g: 7};\n-\n-This could potentially invalidate `y`, because if `x` were the final\n-reference to the shared box, then that memory would be released and\n-now `y` points at freed memory.  (We will see that to prevent this\n-scenario we will *root* shared boxes that reside in mutable memory\n-whose contents are borrowed; rooting means that we create a temporary\n-to ensure that the box is not collected).\n-\n-In other cases, like an enum on the stack, the memory cannot be freed\n-but its type can change:\n-\n-    let mut x = Some(5);\n-    match x {\n-      Some(ref y) => { ... }\n-      None => { ... }\n-    }\n-\n-Here as before, the pointer `y` would be invalidated if we were to\n-reassign `x` to `none`.  (We will see that this case is prevented\n-because borrowck tracks data which resides on the stack and prevents\n-variables from reassigned if there may be pointers to their interior)\n-\n-Finally, in some cases, both dangers can arise.  For example, something\n-like the following:\n-\n-    let mut x = ~Some(5);\n-    match x {\n-      ~Some(ref y) => { ... }\n-      ~None => { ... }\n-    }\n-\n-In this case, if `x` to be reassigned or `*x` were to be mutated, then\n-the pointer `y` would be invalided.  (This case is also prevented by\n-borrowck tracking data which is owned by the current stack frame)\n-\n-# Summary of the safety check\n-\n-In order to enforce mutability, the borrow check has a few tricks up\n-its sleeve:\n-\n-- When data is owned by the current stack frame, we can identify every\n-  possible assignment to a local variable and simply prevent\n-  potentially dangerous assignments directly.\n-\n-- If data is owned by a shared box, we can root the box to increase\n-  its lifetime.\n-\n-- If data is found within a borrowed pointer, we can assume that the\n-  data will remain live for the entirety of the borrowed pointer.\n-\n-- We can rely on the fact that pure actions (such as calling pure\n-  functions) do not mutate data which is not owned by the current\n-  stack frame.\n-\n-# Possible future directions\n-\n-There are numerous ways that the `borrowck` could be strengthened, but\n-these are the two most likely:\n-\n-- flow-sensitivity: we do not currently consider flow at all but only\n-  block-scoping.  This means that innocent code like the following is\n-  rejected:\n-\n-      let mut x: int;\n-      ...\n-      x = 5;\n-      let y: &int = &x; // immutable ptr created\n-      ...\n-\n-  The reason is that the scope of the pointer `y` is the entire\n-  enclosing block, and the assignment `x = 5` occurs within that\n-  block.  The analysis is not smart enough to see that `x = 5` always\n-  happens before the immutable pointer is created.  This is relatively\n-  easy to fix and will surely be fixed at some point.\n-\n-- finer-grained purity checks: currently, our fallback for\n-  guaranteeing random references into mutable, aliasable memory is to\n-  require *total purity*.  This is rather strong.  We could use local\n-  type-based alias analysis to distinguish writes that could not\n-  possibly invalid the references which must be guaranteed.  This\n-  would only work within the function boundaries; function calls would\n-  still require total purity.  This seems less likely to be\n-  implemented in the short term as it would make the code\n-  significantly more complex; there is currently no code to analyze\n-  the types and determine the possible impacts of a write.\n-\n-# How the code works\n-\n-The borrow check code is divided into several major modules, each of\n-which is documented in its own file.\n-\n-The `gather_loans` and `check_loans` are the two major passes of the\n-analysis.  The `gather_loans` pass runs over the IR once to determine\n-what memory must remain valid and for how long.  Its name is a bit of\n-a misnomer; it does in fact gather up the set of loans which are\n-granted, but it also determines when @T pointers must be rooted and\n-for which scopes purity must be required.\n-\n-The `check_loans` pass walks the IR and examines the loans and purity\n-requirements computed in `gather_loans`.  It checks to ensure that (a)\n-the conditions of all loans are honored; (b) no contradictory loans\n-were granted (for example, loaning out the same memory as mutable and\n-immutable simultaneously); and (c) any purity requirements are\n-honored.\n-\n-The remaining modules are helper modules used by `gather_loans` and\n-`check_loans`:\n-\n-- `categorization` has the job of analyzing an expression to determine\n-  what kind of memory is used in evaluating it (for example, where\n-  dereferences occur and what kind of pointer is dereferenced; whether\n-  the memory is mutable; etc)\n-- `loan` determines when data uniquely tied to the stack frame can be\n-  loaned out.\n-- `preserve` determines what actions (if any) must be taken to preserve\n-  aliasable data.  This is the code which decides when to root\n-  an @T pointer or to require purity.\n-\n-# Maps that are created\n-\n-Borrowck results in two maps.\n-\n-- `root_map`: identifies those expressions or patterns whose result\n-  needs to be rooted.  Conceptually the root_map maps from an\n-  expression or pattern node to a `node_id` identifying the scope for\n-  which the expression must be rooted (this `node_id` should identify\n-  a block or call).  The actual key to the map is not an expression id,\n-  however, but a `root_map_key`, which combines an expression id with a\n-  deref count and is used to cope with auto-deref.\n-\n-- `mutbl_map`: identifies those local variables which are modified or\n-  moved. This is used by trans to guarantee that such variables are\n-  given a memory location and not used as immediates.\n- */\n-\n-use middle::mem_categorization::*;\n+use mc = middle::mem_categorization;\n use middle::ty;\n use middle::typeck;\n use middle::moves;\n+use middle::dataflow::DataFlowContext;\n+use middle::dataflow::DataFlowOperator;\n use util::common::stmt_set;\n-use util::ppaux::note_and_explain_region;\n+use util::ppaux::{note_and_explain_region, Repr};\n \n use core::hashmap::{HashSet, HashMap};\n-use core::to_bytes;\n-use syntax::ast::{mutability, m_imm};\n+use core::io;\n+use core::result::{Result};\n+use core::ops::{BitOr, BitAnd};\n use syntax::ast;\n+use syntax::ast_map;\n+use syntax::visit;\n use syntax::codemap::span;\n \n+macro_rules! if_ok(\n+    ($inp: expr) => (\n+        match $inp {\n+            Ok(v) => { v }\n+            Err(e) => { return Err(e); }\n+        }\n+    )\n+)\n+\n+pub mod doc;\n+\n pub mod check_loans;\n+\n+#[path=\"gather_loans/mod.rs\"]\n pub mod gather_loans;\n-pub mod loan;\n-pub mod preserve;\n+\n+pub struct LoanDataFlowOperator;\n+pub type LoanDataFlow = DataFlowContext<LoanDataFlowOperator>;\n \n pub fn check_crate(\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n     moves_map: moves::MovesMap,\n+    moved_variables_set: moves::MovedVariablesSet,\n     capture_map: moves::CaptureMap,\n-    crate: @ast::crate) -> (root_map, mutbl_map, write_guard_map)\n+    crate: @ast::crate) -> (root_map, write_guard_map)\n {\n     let bccx = @BorrowckCtxt {\n         tcx: tcx,\n         method_map: method_map,\n         moves_map: moves_map,\n+        moved_variables_set: moved_variables_set,\n         capture_map: capture_map,\n         root_map: root_map(),\n-        mutbl_map: @mut HashSet::new(),\n+        loan_map: @mut HashMap::new(),\n         write_guard_map: @mut HashSet::new(),\n         stmt_map: @mut HashSet::new(),\n         stats: @mut BorrowStats {\n@@ -267,8 +77,9 @@ pub fn check_crate(\n         }\n     };\n \n-    let req_maps = gather_loans::gather_loans(bccx, crate);\n-    check_loans::check_loans(bccx, req_maps, crate);\n+    let v = visit::mk_vt(@visit::Visitor {visit_fn: borrowck_fn,\n+                                          ..*visit::default_visitor()});\n+    visit::visit_crate(crate, bccx, v);\n \n     if tcx.sess.borrowck_stats() {\n         io::println(~\"--- borrowck stats ---\");\n@@ -284,7 +95,7 @@ pub fn check_crate(\n                          make_stat(bccx, bccx.stats.req_pure_paths)));\n     }\n \n-    return (bccx.root_map, bccx.mutbl_map, bccx.write_guard_map);\n+    return (bccx.root_map, bccx.write_guard_map);\n \n     fn make_stat(bccx: &BorrowckCtxt, stat: uint) -> ~str {\n         let stat_f = stat as float;\n@@ -293,16 +104,57 @@ pub fn check_crate(\n     }\n }\n \n+fn borrowck_fn(fk: &visit::fn_kind,\n+               decl: &ast::fn_decl,\n+               body: &ast::blk,\n+               sp: span,\n+               id: ast::node_id,\n+               self: @BorrowckCtxt,\n+               v: visit::vt<@BorrowckCtxt>) {\n+    match fk {\n+        &visit::fk_anon(*) |\n+        &visit::fk_fn_block(*) => {\n+            // Closures are checked as part of their containing fn item.\n+        }\n+\n+        &visit::fk_item_fn(*) |\n+        &visit::fk_method(*) |\n+        &visit::fk_dtor(*) => {\n+            debug!(\"borrowck_fn(id=%?)\", id);\n+\n+            // Check the body of fn items.\n+            let (id_range, all_loans) =\n+                gather_loans::gather_loans(self, body);\n+            let all_loans: &~[Loan] = &*all_loans; // FIXME(#5074)\n+            let mut dfcx =\n+                DataFlowContext::new(self.tcx,\n+                                     self.method_map,\n+                                     LoanDataFlowOperator,\n+                                     id_range,\n+                                     all_loans.len());\n+            for all_loans.eachi |loan_idx, loan| {\n+                dfcx.add_gen(loan.gen_scope, loan_idx);\n+                dfcx.add_kill(loan.kill_scope, loan_idx);\n+            }\n+            dfcx.propagate(body);\n+            check_loans::check_loans(self, &dfcx, *all_loans, body);\n+        }\n+    }\n+\n+    visit::visit_fn(fk, decl, body, sp, id, self, v);\n+}\n+\n // ----------------------------------------------------------------------\n // Type definitions\n \n pub struct BorrowckCtxt {\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n     moves_map: moves::MovesMap,\n+    moved_variables_set: moves::MovedVariablesSet,\n     capture_map: moves::CaptureMap,\n     root_map: root_map,\n-    mutbl_map: mutbl_map,\n+    loan_map: LoanMap,\n     write_guard_map: write_guard_map,\n     stmt_map: stmt_set,\n \n@@ -318,165 +170,260 @@ pub struct BorrowStats {\n     guaranteed_paths: uint\n }\n \n-pub struct RootInfo {\n-    scope: ast::node_id,\n-    // This will be true if we need to freeze this box at runtime. This will\n-    // result in a call to `borrow_as_imm()` and `return_to_mut()`.\n-    freezes: bool   // True if we need to freeze this box at runtime.\n-}\n-\n-// a map mapping id's of expressions of gc'd type (@T, @[], etc) where\n-// the box needs to be kept live to the id of the scope for which they\n-// must stay live.\n-pub type root_map = @mut HashMap<root_map_key, RootInfo>;\n+pub type LoanMap = @mut HashMap<ast::node_id, @Loan>;\n \n // the keys to the root map combine the `id` of the expression with\n-// the number of types that it is autodereferenced.  So, for example,\n+// the number of types that it is autodereferenced. So, for example,\n // if you have an expression `x.f` and x has type ~@T, we could add an\n // entry {id:x, derefs:0} to refer to `x` itself, `{id:x, derefs:1}`\n // to refer to the deref of the unique pointer, and so on.\n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub struct root_map_key {\n     id: ast::node_id,\n     derefs: uint\n }\n \n-// set of ids of local vars / formal arguments that are modified / moved.\n-// this is used in trans for optimization purposes.\n-pub type mutbl_map = @mut HashSet<ast::node_id>;\n-\n // A set containing IDs of expressions of gc'd type that need to have a write\n // guard.\n pub type write_guard_map = @mut HashSet<root_map_key>;\n \n-// Errors that can occur\n-#[deriving(Eq)]\n-pub enum bckerr_code {\n-    err_mut_uniq,\n-    err_mut_variant,\n-    err_root_not_permitted,\n-    err_mutbl(LoanKind),\n-    err_out_of_root_scope(ty::Region, ty::Region), // superscope, subscope\n-    err_out_of_scope(ty::Region, ty::Region) // superscope, subscope\n-}\n+pub type BckResult<T> = Result<T, BckError>;\n \n-// Combination of an error code and the categorization of the expression\n-// that caused it\n #[deriving(Eq)]\n-pub struct bckerr {\n-    cmt: cmt,\n-    code: bckerr_code\n+pub enum PartialTotal {\n+    Partial,   // Loan affects some portion\n+    Total      // Loan affects entire path\n }\n \n-pub enum MoveError {\n-    MoveOk,\n-    MoveFromIllegalCmt(cmt),\n-    MoveWhileBorrowed(/*move*/ cmt, /*loan*/ cmt)\n+///////////////////////////////////////////////////////////////////////////\n+// Loans and loan paths\n+\n+/// Record of a loan that was issued.\n+pub struct Loan {\n+    index: uint,\n+    loan_path: @LoanPath,\n+    cmt: mc::cmt,\n+    mutbl: ast::mutability,\n+    restrictions: ~[Restriction],\n+    gen_scope: ast::node_id,\n+    kill_scope: ast::node_id,\n+    span: span,\n }\n \n-// shorthand for something that fails with `bckerr` or succeeds with `T`\n-pub type bckres<T> = Result<T, bckerr>;\n+#[deriving(Eq)]\n+pub enum LoanPath {\n+    LpVar(ast::node_id),               // `x` in doc.rs\n+    LpExtend(@LoanPath, mc::MutabilityCategory, LoanPathElem)\n+}\n \n #[deriving(Eq)]\n-pub enum LoanKind {\n-    TotalFreeze,   // Entire path is frozen   (borrowed as &T)\n-    PartialFreeze, // Some subpath is frozen  (borrowed as &T)\n-    TotalTake,     // Entire path is \"taken\"  (borrowed as &mut T)\n-    PartialTake,   // Some subpath is \"taken\" (borrowed as &mut T)\n-    Immobile       // Path cannot be moved    (borrowed as &const T)\n+pub enum LoanPathElem {\n+    LpDeref,                      // `*LV` in doc.rs\n+    LpInterior(mc::interior_kind) // `LV.f` in doc.rs\n }\n \n-/// a complete record of a loan that was granted\n-pub struct Loan {\n-    lp: @loan_path,\n-    cmt: cmt,\n-    kind: LoanKind\n+pub impl LoanPath {\n+    fn node_id(&self) -> ast::node_id {\n+        match *self {\n+            LpVar(local_id) => local_id,\n+            LpExtend(base, _, _) => base.node_id()\n+        }\n+    }\n }\n \n-/// maps computed by `gather_loans` that are then used by `check_loans`\n-///\n-/// - `req_loan_map`: map from each block/expr to the required loans needed\n-///   for the duration of that block/expr\n-/// - `pure_map`: map from block/expr that must be pure to the error message\n-///   that should be reported if they are not pure\n-pub struct ReqMaps {\n-    req_loan_map: HashMap<ast::node_id, @mut ~[Loan]>,\n-    pure_map: HashMap<ast::node_id, bckerr>\n+pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n+    //! Computes the `LoanPath` (if any) for a `cmt`.\n+    //! Note that this logic is somewhat duplicated in\n+    //! the method `compute()` found in `gather_loans::restrictions`,\n+    //! which allows it to share common loan path pieces as it\n+    //! traverses the CMT.\n+\n+    match cmt.cat {\n+        mc::cat_rvalue |\n+        mc::cat_static_item |\n+        mc::cat_copied_upvar(_) |\n+        mc::cat_implicit_self |\n+        mc::cat_arg(_, ast::by_ref) => {\n+            None\n+        }\n+\n+        mc::cat_local(id) |\n+        mc::cat_arg(id, ast::by_copy) |\n+        mc::cat_self(id) => {\n+            Some(@LpVar(id))\n+        }\n+\n+        mc::cat_deref(cmt_base, _, _) => {\n+            opt_loan_path(cmt_base).map(\n+                |&lp| @LpExtend(lp, cmt.mutbl, LpDeref))\n+        }\n+\n+        mc::cat_interior(cmt_base, ik) => {\n+            opt_loan_path(cmt_base).map(\n+                |&lp| @LpExtend(lp, cmt.mutbl, LpInterior(ik)))\n+        }\n+\n+        mc::cat_stack_upvar(cmt_base) |\n+        mc::cat_discr(cmt_base, _) => {\n+            opt_loan_path(cmt_base)\n+        }\n+    }\n }\n \n-pub fn save_and_restore<T:Copy,U>(save_and_restore_t: &mut T,\n-                                  f: &fn() -> U) -> U {\n-    let old_save_and_restore_t = *save_and_restore_t;\n-    let u = f();\n-    *save_and_restore_t = old_save_and_restore_t;\n-    u\n+///////////////////////////////////////////////////////////////////////////\n+// Restrictions\n+//\n+// Borrowing an lvalue often results in *restrictions* that limit what\n+// can be done with this lvalue during the scope of the loan:\n+//\n+// - `RESTR_MUTATE`: The lvalue may not be modified and mutable pointers to\n+//                   the value cannot be created.\n+// - `RESTR_FREEZE`: Immutable pointers to the value cannot be created.\n+// - `RESTR_ALIAS`: The lvalue may not be aliased in any way.\n+//\n+// In addition, no value which is restricted may be moved. Therefore,\n+// restrictions are meaningful even if the RestrictionSet is empty,\n+// because the restriction against moves is implied.\n+\n+pub struct Restriction {\n+    loan_path: @LoanPath,\n+    set: RestrictionSet\n }\n \n-pub fn save_and_restore_managed<T:Copy,U>(save_and_restore_t: @mut T,\n-                                          f: &fn() -> U) -> U {\n-    let old_save_and_restore_t = *save_and_restore_t;\n-    let u = f();\n-    *save_and_restore_t = old_save_and_restore_t;\n-    u\n+pub struct RestrictionSet {\n+    bits: u32\n }\n \n-pub impl LoanKind {\n-    fn is_freeze(&self) -> bool {\n-        match *self {\n-            TotalFreeze | PartialFreeze => true,\n-            _ => false\n-        }\n+pub static RESTR_EMPTY: RestrictionSet  = RestrictionSet {bits: 0b000};\n+pub static RESTR_MUTATE: RestrictionSet = RestrictionSet {bits: 0b001};\n+pub static RESTR_FREEZE: RestrictionSet = RestrictionSet {bits: 0b010};\n+pub static RESTR_ALIAS: RestrictionSet  = RestrictionSet {bits: 0b100};\n+\n+pub impl RestrictionSet {\n+    fn intersects(&self, restr: RestrictionSet) -> bool {\n+        (self.bits & restr.bits) != 0\n     }\n \n-    fn is_take(&self) -> bool {\n-        match *self {\n-            TotalTake | PartialTake => true,\n-            _ => false\n-        }\n+    fn contains_all(&self, restr: RestrictionSet) -> bool {\n+        (self.bits & restr.bits) == restr.bits\n     }\n }\n \n-/// Creates and returns a new root_map\n+impl BitOr<RestrictionSet,RestrictionSet> for RestrictionSet {\n+    fn bitor(&self, rhs: &RestrictionSet) -> RestrictionSet {\n+        RestrictionSet {bits: self.bits | rhs.bits}\n+    }\n+}\n \n-impl to_bytes::IterBytes for root_map_key {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.id, &self.derefs, lsb0, f);\n+impl BitAnd<RestrictionSet,RestrictionSet> for RestrictionSet {\n+    fn bitand(&self, rhs: &RestrictionSet) -> RestrictionSet {\n+        RestrictionSet {bits: self.bits & rhs.bits}\n     }\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+// Rooting of managed boxes\n+//\n+// When we borrow the interior of a managed box, it is sometimes\n+// necessary to *root* the box, meaning to stash a copy of the box\n+// somewhere that the garbage collector will find it. This ensures\n+// that the box is not collected for the lifetime of the borrow.\n+//\n+// As part of this rooting, we sometimes also freeze the box at\n+// runtime, meaning that we dynamically detect when the box is\n+// borrowed in incompatible ways.\n+//\n+// Both of these actions are driven through the `root_map`, which maps\n+// from a node to the dynamic rooting action that should be taken when\n+// that node executes. The node is identified through a\n+// `root_map_key`, which pairs a node-id and a deref count---the\n+// problem is that sometimes the box that needs to be rooted is only\n+// uncovered after a certain number of auto-derefs.\n+\n+pub struct RootInfo {\n+    scope: ast::node_id,\n+    freeze: Option<DynaFreezeKind> // Some() if we should freeze box at runtime\n+}\n+\n+pub type root_map = @mut HashMap<root_map_key, RootInfo>;\n+\n pub fn root_map() -> root_map {\n     return @mut HashMap::new();\n }\n \n-// ___________________________________________________________________________\n+pub enum DynaFreezeKind {\n+    DynaImm,\n+    DynaMut\n+}\n+\n+impl ToStr for DynaFreezeKind {\n+    fn to_str(&self) -> ~str {\n+        match *self {\n+            DynaMut => ~\"mutable\",\n+            DynaImm => ~\"immutable\"\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Errors\n+\n+// Errors that can occur\n+#[deriving(Eq)]\n+pub enum bckerr_code {\n+    err_mutbl(ast::mutability),\n+    err_out_of_root_scope(ty::Region, ty::Region), // superscope, subscope\n+    err_out_of_scope(ty::Region, ty::Region), // superscope, subscope\n+    err_freeze_aliasable_const\n+}\n+\n+// Combination of an error code and the categorization of the expression\n+// that caused it\n+#[deriving(Eq)]\n+pub struct BckError {\n+    span: span,\n+    cmt: mc::cmt,\n+    code: bckerr_code\n+}\n+\n+pub enum AliasableViolationKind {\n+    MutabilityViolation,\n+    BorrowViolation\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n // Misc\n \n pub impl BorrowckCtxt {\n     fn is_subregion_of(&self, r_sub: ty::Region, r_sup: ty::Region) -> bool {\n         self.tcx.region_maps.is_subregion_of(r_sub, r_sup)\n     }\n \n-    fn cat_expr(&self, expr: @ast::expr) -> cmt {\n-        cat_expr(self.tcx, self.method_map, expr)\n+    fn is_subscope_of(&self, r_sub: ast::node_id, r_sup: ast::node_id) -> bool {\n+        self.tcx.region_maps.is_subscope_of(r_sub, r_sup)\n+    }\n+\n+    fn cat_expr(&self, expr: @ast::expr) -> mc::cmt {\n+        mc::cat_expr(self.tcx, self.method_map, expr)\n     }\n \n-    fn cat_expr_unadjusted(&self, expr: @ast::expr) -> cmt {\n-        cat_expr_unadjusted(self.tcx, self.method_map, expr)\n+    fn cat_expr_unadjusted(&self, expr: @ast::expr) -> mc::cmt {\n+        mc::cat_expr_unadjusted(self.tcx, self.method_map, expr)\n     }\n \n     fn cat_expr_autoderefd(&self, expr: @ast::expr,\n-                           adj: @ty::AutoAdjustment) -> cmt {\n+                           adj: @ty::AutoAdjustment) -> mc::cmt {\n         match *adj {\n             ty::AutoAddEnv(*) => {\n                 // no autoderefs\n-                cat_expr_unadjusted(self.tcx, self.method_map, expr)\n+                mc::cat_expr_unadjusted(self.tcx, self.method_map, expr)\n             }\n \n             ty::AutoDerefRef(\n                 ty::AutoDerefRef {\n                     autoderefs: autoderefs, _}) => {\n-                cat_expr_autoderefd(self.tcx, self.method_map, expr,\n-                                    autoderefs)\n+                mc::cat_expr_autoderefd(self.tcx, self.method_map, expr,\n+                                        autoderefs)\n             }\n         }\n     }\n@@ -485,43 +432,33 @@ pub impl BorrowckCtxt {\n                id: ast::node_id,\n                span: span,\n                ty: ty::t,\n-               def: ast::def) -> cmt {\n-        cat_def(self.tcx, self.method_map, id, span, ty, def)\n-    }\n-\n-    fn cat_variant<N:ast_node>(&self,\n-                                arg: N,\n-                                enum_did: ast::def_id,\n-                                cmt: cmt) -> cmt {\n-        cat_variant(self.tcx, self.method_map, arg, enum_did, cmt)\n+               def: ast::def) -> mc::cmt {\n+        mc::cat_def(self.tcx, self.method_map, id, span, ty, def)\n     }\n \n-    fn cat_discr(&self, cmt: cmt, match_id: ast::node_id) -> cmt {\n-        return @cmt_ {cat:cat_discr(cmt, match_id),.. *cmt};\n+    fn cat_discr(&self, cmt: mc::cmt, match_id: ast::node_id) -> mc::cmt {\n+        @mc::cmt_ {cat:mc::cat_discr(cmt, match_id),\n+                   mutbl:cmt.mutbl.inherit(),\n+                   ..*cmt}\n     }\n \n-    fn mc_ctxt(&self) -> mem_categorization_ctxt {\n-        mem_categorization_ctxt {tcx: self.tcx,\n+    fn mc_ctxt(&self) -> mc::mem_categorization_ctxt {\n+        mc::mem_categorization_ctxt {tcx: self.tcx,\n                                  method_map: self.method_map}\n     }\n \n-    fn cat_pattern(&self, cmt: cmt, pat: @ast::pat, op: &fn(cmt, @ast::pat)) {\n+    fn cat_pattern(&self,\n+                   cmt: mc::cmt,\n+                   pat: @ast::pat,\n+                   op: &fn(mc::cmt, @ast::pat)) {\n         let mc = self.mc_ctxt();\n         mc.cat_pattern(cmt, pat, op);\n     }\n \n-    fn report_if_err(&self, bres: bckres<()>) {\n-        match bres {\n-          Ok(()) => (),\n-          Err(ref e) => self.report((*e))\n-        }\n-    }\n-\n-    fn report(&self, err: bckerr) {\n+    fn report(&self, err: BckError) {\n         self.span_err(\n-            err.cmt.span,\n-            fmt!(\"illegal borrow: %s\",\n-                 self.bckerr_to_str(err)));\n+            err.span,\n+            self.bckerr_to_str(err));\n         self.note_and_explain_bckerr(err);\n     }\n \n@@ -533,51 +470,75 @@ pub impl BorrowckCtxt {\n         self.tcx.sess.span_note(s, m);\n     }\n \n-    fn add_to_mutbl_map(&self, cmt: cmt) {\n-        match cmt.cat {\n-          cat_local(id) | cat_arg(id) => {\n-            self.mutbl_map.insert(id);\n-          }\n-          cat_stack_upvar(cmt) => {\n-            self.add_to_mutbl_map(cmt);\n-          }\n-          _ => ()\n-        }\n-    }\n-\n-    fn bckerr_to_str(&self, err: bckerr) -> ~str {\n+    fn bckerr_to_str(&self, err: BckError) -> ~str {\n         match err.code {\n             err_mutbl(lk) => {\n-                fmt!(\"creating %s alias to %s\",\n-                     self.loan_kind_to_str(lk),\n-                     self.cmt_to_str(err.cmt))\n+                fmt!(\"cannot borrow %s %s as %s\",\n+                     err.cmt.mutbl.to_user_str(),\n+                     self.cmt_to_str(err.cmt),\n+                     self.mut_to_str(lk))\n             }\n-            err_mut_uniq => {\n-                ~\"unique value in aliasable, mutable location\"\n+            err_out_of_root_scope(*) => {\n+                fmt!(\"cannot root managed value long enough\")\n             }\n-            err_mut_variant => {\n-                ~\"enum variant in aliasable, mutable location\"\n+            err_out_of_scope(*) => {\n+                fmt!(\"borrowed value does not live long enough\")\n             }\n-            err_root_not_permitted => {\n-                // note: I don't expect users to ever see this error\n-                // message, reasons are discussed in attempt_root() in\n-                // preserve.rs.\n-                ~\"rooting is not permitted\"\n+            err_freeze_aliasable_const => {\n+                // Means that the user borrowed a ~T or enum value\n+                // residing in &const or @const pointer.  Terrible\n+                // error message, but then &const and @const are\n+                // supposed to be going away.\n+                fmt!(\"unsafe borrow of aliasable, const value\")\n             }\n-            err_out_of_root_scope(*) => {\n-                ~\"cannot root managed value long enough\"\n+        }\n+    }\n+\n+    fn report_aliasability_violation(&self,\n+                                     span: span,\n+                                     kind: AliasableViolationKind,\n+                                     cause: mc::AliasableReason) {\n+        let prefix = match kind {\n+            MutabilityViolation => \"cannot assign to an `&mut`\",\n+            BorrowViolation => \"cannot borrow an `&mut`\"\n+        };\n+\n+        match cause {\n+            mc::AliasableOther => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    fmt!(\"%s in an aliasable location\", prefix));\n             }\n-            err_out_of_scope(*) => {\n-                ~\"borrowed value does not live long enough\"\n+            mc::AliasableManaged(ast::m_mutbl) => {\n+                // FIXME(#5074) we should prob do this borrow\n+                self.tcx.sess.span_err(\n+                    span,\n+                    fmt!(\"%s in a `@mut` pointer; \\\n+                          try borrowing as `&mut` first\", prefix));\n+            }\n+            mc::AliasableManaged(m) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    fmt!(\"%s in a `@%s` pointer; \\\n+                          try an `@mut` instead\",\n+                         prefix,\n+                         self.mut_to_keyword(m)));\n+            }\n+            mc::AliasableBorrowed(m) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    fmt!(\"%s in a `&%s` pointer; \\\n+                          try an `&mut` instead\",\n+                         prefix,\n+                         self.mut_to_keyword(m)));\n             }\n         }\n     }\n \n-    fn note_and_explain_bckerr(&self, err: bckerr) {\n+    fn note_and_explain_bckerr(&self, err: BckError) {\n         let code = err.code;\n         match code {\n-            err_mutbl(*) | err_mut_uniq | err_mut_variant |\n-            err_root_not_permitted => {}\n+            err_mutbl(*) | err_freeze_aliasable_const(*) => {}\n \n             err_out_of_root_scope(super_scope, sub_scope) => {\n                 note_and_explain_region(\n@@ -607,46 +568,140 @@ pub impl BorrowckCtxt {\n         }\n     }\n \n+    fn append_loan_path_to_str_from_interior(&self,\n+                                             loan_path: &LoanPath,\n+                                             out: &mut ~str) {\n+        match *loan_path {\n+            LpExtend(_, _, LpDeref) => {\n+                str::push_char(out, '(');\n+                self.append_loan_path_to_str(loan_path, out);\n+                str::push_char(out, ')');\n+            }\n+            LpExtend(_, _, LpInterior(_)) |\n+            LpVar(_) => {\n+                self.append_loan_path_to_str(loan_path, out);\n+            }\n+        }\n+    }\n+\n+    fn append_loan_path_to_str(&self, loan_path: &LoanPath, out: &mut ~str) {\n+        match *loan_path {\n+            LpVar(id) => {\n+                match self.tcx.items.find(&id) {\n+                    Some(&ast_map::node_local(ident)) => {\n+                        str::push_str(out, *self.tcx.sess.intr().get(ident));\n+                    }\n+                    r => {\n+                        self.tcx.sess.bug(\n+                            fmt!(\"Loan path LpVar(%?) maps to %?, not local\",\n+                                 id, r));\n+                    }\n+                }\n+            }\n \n-    fn cmt_to_str(&self, cmt: cmt) -> ~str {\n-        let mc = &mem_categorization_ctxt {tcx: self.tcx,\n-                                           method_map: self.method_map};\n-        mc.cmt_to_str(cmt)\n+            LpExtend(lp_base, _, LpInterior(mc::interior_field(fld, _))) => {\n+                self.append_loan_path_to_str_from_interior(lp_base, out);\n+                str::push_char(out, '.');\n+                str::push_str(out, *self.tcx.sess.intr().get(fld));\n+            }\n+\n+            LpExtend(lp_base, _, LpInterior(mc::interior_index(*))) => {\n+                self.append_loan_path_to_str_from_interior(lp_base, out);\n+                str::push_str(out, \"[]\");\n+            }\n+\n+            LpExtend(lp_base, _, LpInterior(mc::interior_tuple)) |\n+            LpExtend(lp_base, _, LpInterior(mc::interior_anon_field)) |\n+            LpExtend(lp_base, _, LpInterior(mc::interior_variant(_))) => {\n+                self.append_loan_path_to_str_from_interior(lp_base, out);\n+                str::push_str(out, \".(tuple)\");\n+            }\n+\n+            LpExtend(lp_base, _, LpDeref) => {\n+                str::push_char(out, '*');\n+                self.append_loan_path_to_str(lp_base, out);\n+            }\n+        }\n+    }\n+\n+    fn loan_path_to_str(&self, loan_path: &LoanPath) -> ~str {\n+        let mut result = ~\"\";\n+        self.append_loan_path_to_str(loan_path, &mut result);\n+        result\n     }\n \n-    fn cmt_to_repr(&self, cmt: cmt) -> ~str {\n-        let mc = &mem_categorization_ctxt {tcx: self.tcx,\n-                                           method_map: self.method_map};\n-        mc.cmt_to_repr(cmt)\n+    fn cmt_to_str(&self, cmt: mc::cmt) -> ~str {\n+        let mc = &mc::mem_categorization_ctxt {tcx: self.tcx,\n+                                               method_map: self.method_map};\n+        mc.cmt_to_str(cmt)\n     }\n \n     fn mut_to_str(&self, mutbl: ast::mutability) -> ~str {\n-        let mc = &mem_categorization_ctxt {tcx: self.tcx,\n-                                           method_map: self.method_map};\n+        let mc = &mc::mem_categorization_ctxt {tcx: self.tcx,\n+                                               method_map: self.method_map};\n         mc.mut_to_str(mutbl)\n     }\n \n-    fn loan_kind_to_str(&self, lk: LoanKind) -> ~str {\n-        match lk {\n-            TotalFreeze | PartialFreeze => ~\"immutable\",\n-            TotalTake | PartialTake => ~\"mutable\",\n-            Immobile => ~\"read-only\"\n+    fn mut_to_keyword(&self, mutbl: ast::mutability) -> &'static str {\n+        match mutbl {\n+            ast::m_imm => \"\",\n+            ast::m_const => \"const\",\n+            ast::m_mutbl => \"mut\"\n         }\n     }\n+}\n+\n+impl DataFlowOperator for LoanDataFlowOperator {\n+    #[inline(always)]\n+    fn initial_value(&self) -> bool {\n+        false // no loans in scope by default\n+    }\n+\n+    #[inline(always)]\n+    fn join(&self, succ: uint, pred: uint) -> uint {\n+        succ | pred // loans from both preds are in scope\n+    }\n+\n+    #[inline(always)]\n+    fn walk_closures(&self) -> bool {\n+        true\n+    }\n+}\n \n-    fn loan_to_repr(&self, loan: &Loan) -> ~str {\n-        fmt!(\"Loan(lp=%?, cmt=%s, kind=%?)\",\n-             loan.lp, self.cmt_to_repr(loan.cmt), loan.kind)\n+impl Repr for Loan {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        fmt!(\"Loan_%?(%s, %?, %?-%?, %s)\",\n+             self.index,\n+             self.loan_path.repr(tcx),\n+             self.mutbl,\n+             self.gen_scope,\n+             self.kill_scope,\n+             self.restrictions.repr(tcx))\n     }\n }\n \n-// The inherent mutability of a component is its default mutability\n-// assuming it is embedded in an immutable context.  In general, the\n-// mutability can be \"overridden\" if the component is embedded in a\n-// mutable structure.\n-pub fn inherent_mutability(ck: comp_kind) -> mutability {\n-    match ck {\n-      comp_tuple | comp_anon_field | comp_variant(_) => m_imm,\n-      comp_field(_, m) | comp_index(_, m)            => m\n+impl Repr for Restriction {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        fmt!(\"Restriction(%s, %x)\",\n+             self.loan_path.repr(tcx),\n+             self.set.bits as uint)\n+    }\n+}\n+\n+impl Repr for LoanPath {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        match self {\n+            &LpVar(id) => {\n+                fmt!(\"$(%?)\", id)\n+            }\n+\n+            &LpExtend(lp, _, LpDeref) => {\n+                fmt!(\"%s.*\", lp.repr(tcx))\n+            }\n+\n+            &LpExtend(lp, _, LpInterior(ref interior)) => {\n+                fmt!(\"%s.%s\", lp.repr(tcx), interior.repr(tcx))\n+            }\n+        }\n     }\n }"}, {"sha": "c44920fffa568d37f6f7392357a9c2f010309d46", "filename": "src/librustc/middle/borrowck/preserve.rs", "status": "removed", "additions": 0, "deletions": 409, "changes": 409, "blob_url": "https://github.com/rust-lang/rust/blob/b5a7e8b35322869b1cf51bd1b35a86e9e721da54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a7e8b35322869b1cf51bd1b35a86e9e721da54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=b5a7e8b35322869b1cf51bd1b35a86e9e721da54", "patch": "@@ -1,409 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ----------------------------------------------------------------------\n-// Preserve(Ex, S) holds if ToAddr(Ex) will remain valid for the entirety of\n-// the scope S.\n-//\n-\n-use middle::borrowck::{RootInfo, bckerr, bckerr_code, bckres, BorrowckCtxt};\n-use middle::borrowck::{err_mut_uniq, err_mut_variant};\n-use middle::borrowck::{err_out_of_root_scope, err_out_of_scope};\n-use middle::borrowck::{err_root_not_permitted, root_map_key};\n-use middle::mem_categorization::{cat_arg, cat_binding, cat_comp, cat_deref};\n-use middle::mem_categorization::{cat_discr, cat_local, cat_self, cat_special};\n-use middle::mem_categorization::{cat_stack_upvar, cmt, comp_field};\n-use middle::mem_categorization::{comp_index, comp_variant, gc_ptr};\n-use middle::mem_categorization::{region_ptr};\n-use middle::ty;\n-use util::common::indenter;\n-\n-use syntax::ast;\n-\n-pub enum PreserveCondition {\n-    PcOk,\n-    PcIfPure(bckerr)\n-}\n-\n-pub impl PreserveCondition {\n-    // combines two preservation conditions such that if either of\n-    // them requires purity, the result requires purity\n-    fn combine(&self, pc: PreserveCondition) -> PreserveCondition {\n-        match *self {\n-            PcOk => {pc}\n-            PcIfPure(_) => {*self}\n-        }\n-    }\n-}\n-\n-pub impl BorrowckCtxt {\n-    fn preserve(&self,\n-                cmt: cmt,\n-                scope_region: ty::Region,\n-                item_ub: ast::node_id,\n-                root_ub: ast::node_id) -> bckres<PreserveCondition>\n-    {\n-        let ctxt = PreserveCtxt {\n-            bccx: self,\n-            scope_region: scope_region,\n-            item_ub: item_ub,\n-            root_ub: root_ub,\n-            root_managed_data: true\n-        };\n-        ctxt.preserve(cmt)\n-    }\n-}\n-\n-struct PreserveCtxt<'self> {\n-    bccx: &'self BorrowckCtxt,\n-\n-    // the region scope for which we must preserve the memory\n-    scope_region: ty::Region,\n-\n-    // the scope for the body of the enclosing fn/method item\n-    item_ub: ast::node_id,\n-\n-    // the upper bound on how long we can root an @T pointer\n-    root_ub: ast::node_id,\n-\n-    // if false, do not attempt to root managed data\n-    root_managed_data: bool\n-}\n-\n-pub impl<'self> PreserveCtxt<'self> {\n-    fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n-\n-    fn preserve(&self, cmt: cmt) -> bckres<PreserveCondition> {\n-        debug!(\"preserve(cmt=%s, root_ub=%?, root_managed_data=%b)\",\n-               self.bccx.cmt_to_repr(cmt), self.root_ub,\n-               self.root_managed_data);\n-        let _i = indenter();\n-\n-        match cmt.cat {\n-          cat_special(sk_implicit_self) |\n-          cat_special(sk_heap_upvar) => {\n-            self.compare_scope(cmt, ty::re_scope(self.item_ub))\n-          }\n-          cat_special(sk_static_item) | cat_special(sk_method) => {\n-            Ok(PcOk)\n-          }\n-          cat_rvalue => {\n-            // when we borrow an rvalue, we can keep it rooted but only\n-            // up to the root_ub point\n-\n-            // When we're in a 'const &x = ...' context, self.root_ub is\n-            // zero and the rvalue is static, not bound to a scope.\n-            let scope_region = if self.root_ub == 0 {\n-                ty::re_static\n-            } else {\n-                // Maybe if we pass in the parent instead here,\n-                // we can prevent the \"scope not found\" error\n-                debug!(\"scope_region thing: %? \", cmt.id);\n-                self.tcx().region_maps.encl_region(cmt.id)\n-            };\n-\n-            self.compare_scope(cmt, scope_region)\n-          }\n-          cat_stack_upvar(cmt) => {\n-            self.preserve(cmt)\n-          }\n-          cat_local(local_id) => {\n-            // Normally, local variables are lendable, and so this\n-            // case should never trigger.  However, if we are\n-            // preserving an expression like a.b where the field `b`\n-            // has @ type, then it will recurse to ensure that the `a`\n-            // is stable to try and avoid rooting the value `a.b`.  In\n-            // this case, root_managed_data will be false.\n-            if self.root_managed_data {\n-                self.tcx().sess.span_bug(\n-                    cmt.span,\n-                    ~\"preserve() called with local and !root_managed_data\");\n-            }\n-            let local_region = self.tcx().region_maps.encl_region(local_id);\n-            self.compare_scope(cmt, local_region)\n-          }\n-          cat_binding(local_id) => {\n-            // Bindings are these kind of weird implicit pointers (cc\n-            // #2329).  We require (in gather_loans) that they be\n-            // rooted in an immutable location.\n-            let local_region = self.tcx().region_maps.encl_region(local_id);\n-            self.compare_scope(cmt, local_region)\n-          }\n-          cat_arg(local_id) => {\n-            // This can happen as not all args are lendable (e.g., &&\n-            // modes).  In that case, the caller guarantees stability\n-            // for at least the scope of the fn.  This is basically a\n-            // deref of a region ptr.\n-            let local_region = self.tcx().region_maps.encl_region(local_id);\n-            self.compare_scope(cmt, local_region)\n-          }\n-          cat_self(local_id) => {\n-            let local_region = self.tcx().region_maps.encl_region(local_id);\n-            self.compare_scope(cmt, local_region)\n-          }\n-          cat_comp(cmt_base, comp_field(*)) |\n-          cat_comp(cmt_base, comp_index(*)) |\n-          cat_comp(cmt_base, comp_tuple) |\n-          cat_comp(cmt_base, comp_anon_field) => {\n-            // Most embedded components: if the base is stable, the\n-            // type never changes.\n-            self.preserve(cmt_base)\n-          }\n-          cat_comp(cmt_base, comp_variant(enum_did)) => {\n-            if ty::enum_is_univariant(self.tcx(), enum_did) {\n-                self.preserve(cmt_base)\n-            } else {\n-                // If there are multiple variants: overwriting the\n-                // base could cause the type of this memory to change,\n-                // so require imm.\n-                self.require_imm(cmt, cmt_base, err_mut_variant)\n-            }\n-          }\n-          cat_deref(cmt_base, _, uniq_ptr) => {\n-            // Overwriting the base could cause this memory to be\n-            // freed, so require imm.\n-            self.require_imm(cmt, cmt_base, err_mut_uniq)\n-          }\n-          cat_deref(_, _, region_ptr(_, region)) => {\n-            // References are always \"stable\" for lifetime `region` by\n-            // induction (when the reference of type &MT was created,\n-            // the memory must have been stable).\n-            self.compare_scope(cmt, region)\n-          }\n-          cat_deref(_, _, unsafe_ptr) => {\n-            // Unsafe pointers are the user's problem\n-            Ok(PcOk)\n-          }\n-          cat_deref(base, derefs, gc_ptr(*)) => {\n-            // GC'd pointers of type @MT: if this pointer lives in\n-            // immutable, stable memory, then everything is fine.  But\n-            // otherwise we have no guarantee the pointer will stay\n-            // live, so we must root the pointer (i.e., inc the ref\n-            // count) for the duration of the loan.\n-            debug!(\"base.mutbl = %?\", base.mutbl);\n-            if cmt.cat.derefs_through_mutable_box() {\n-                self.attempt_root(cmt, base, derefs)\n-            } else if base.mutbl.is_immutable() {\n-                let non_rooting_ctxt = PreserveCtxt {\n-                    root_managed_data: false,\n-                    ..*self\n-                };\n-                match non_rooting_ctxt.preserve(base) {\n-                  Ok(PcOk) => {\n-                    Ok(PcOk)\n-                  }\n-                  Ok(PcIfPure(_)) => {\n-                    debug!(\"must root @T, otherwise purity req'd\");\n-                    self.attempt_root(cmt, base, derefs)\n-                  }\n-                  Err(ref e) => {\n-                    debug!(\"must root @T, err: %s\",\n-                           self.bccx.bckerr_to_str((*e)));\n-                    self.attempt_root(cmt, base, derefs)\n-                  }\n-                }\n-            } else {\n-                self.attempt_root(cmt, base, derefs)\n-            }\n-          }\n-          cat_discr(base, match_id) => {\n-            // Subtle: in a match, we must ensure that each binding\n-            // variable remains valid for the duration of the arm in\n-            // which it appears, presuming that this arm is taken.\n-            // But it is inconvenient in trans to root something just\n-            // for one arm.  Therefore, we insert a cat_discr(),\n-            // basically a special kind of category that says \"if this\n-            // value must be dynamically rooted, root it for the scope\n-            // `match_id`.\n-            //\n-            // As an example, consider this scenario:\n-            //\n-            //    let mut x = @Some(3);\n-            //    match *x { Some(y) {...} None {...} }\n-            //\n-            // Technically, the value `x` need only be rooted\n-            // in the `some` arm.  However, we evaluate `x` in trans\n-            // before we know what arm will be taken, so we just\n-            // always root it for the duration of the match.\n-            //\n-            // As a second example, consider *this* scenario:\n-            //\n-            //    let x = @mut @Some(3);\n-            //    match x { @@Some(y) {...} @@None {...} }\n-            //\n-            // Here again, `x` need only be rooted in the `some` arm.\n-            // In this case, the value which needs to be rooted is\n-            // found only when checking which pattern matches: but\n-            // this check is done before entering the arm.  Therefore,\n-            // even in this case we just choose to keep the value\n-            // rooted for the entire match.  This means the value will be\n-            // rooted even if the none arm is taken.  Oh well.\n-            //\n-            // At first, I tried to optimize the second case to only\n-            // root in one arm, but the result was suboptimal: first,\n-            // it interfered with the construction of phi nodes in the\n-            // arm, as we were adding code to root values before the\n-            // phi nodes were added.  This could have been addressed\n-            // with a second basic block.  However, the naive approach\n-            // also yielded suboptimal results for patterns like:\n-            //\n-            //    let x = @mut @...;\n-            //    match x { @@some_variant(y) | @@some_other_variant(y) =>\n-            //\n-            // The reason is that we would root the value once for\n-            // each pattern and not once per arm.  This is also easily\n-            // fixed, but it's yet more code for what is really quite\n-            // the corner case.\n-            //\n-            // Nonetheless, if you decide to optimize this case in the\n-            // future, you need only adjust where the cat_discr()\n-            // node appears to draw the line between what will be rooted\n-            // in the *arm* vs the *match*.\n-\n-              let match_rooting_ctxt = PreserveCtxt {\n-                  scope_region: ty::re_scope(match_id),\n-                  ..*self\n-              };\n-              match_rooting_ctxt.preserve(base)\n-          }\n-        }\n-    }\n-\n-    /// Reqiures that `cmt` (which is a deref or subcomponent of\n-    /// `base`) be found in an immutable location (that is, `base`\n-    /// must be immutable).  Also requires that `base` itself is\n-    /// preserved.\n-    fn require_imm(&self,\n-                   cmt: cmt,\n-                   cmt_base: cmt,\n-                   code: bckerr_code) -> bckres<PreserveCondition> {\n-        // Variant contents and unique pointers: must be immutably\n-        // rooted to a preserved address.\n-        match self.preserve(cmt_base) {\n-          // the base is preserved, but if we are not mutable then\n-          // purity is required\n-          Ok(PcOk) => {\n-              if !cmt_base.mutbl.is_immutable() {\n-                  Ok(PcIfPure(bckerr {cmt:cmt, code:code}))\n-              } else {\n-                  Ok(PcOk)\n-              }\n-          }\n-\n-          // the base requires purity too, that's fine\n-          Ok(PcIfPure(ref e)) => {\n-            Ok(PcIfPure((*e)))\n-          }\n-\n-          // base is not stable, doesn't matter\n-          Err(ref e) => {\n-            Err((*e))\n-          }\n-        }\n-    }\n-\n-    /// Checks that the scope for which the value must be preserved\n-    /// is a subscope of `scope_ub`; if so, success.\n-    fn compare_scope(&self,\n-                     cmt: cmt,\n-                     scope_ub: ty::Region) -> bckres<PreserveCondition> {\n-        if self.bccx.is_subregion_of(self.scope_region, scope_ub) {\n-            Ok(PcOk)\n-        } else {\n-            Err(bckerr {\n-                cmt:cmt,\n-                code:err_out_of_scope(scope_ub, self.scope_region)\n-            })\n-        }\n-    }\n-\n-    /// Here, `cmt=*base` is always a deref of managed data (if\n-    /// `derefs` != 0, then an auto-deref).  This routine determines\n-    /// whether it is safe to MAKE cmt stable by rooting the pointer\n-    /// `base`.  We can only do the dynamic root if the desired\n-    /// lifetime `self.scope_region` is a subset of `self.root_ub`\n-    /// scope; otherwise, it would either require that we hold the\n-    /// value live for longer than the current fn or else potentially\n-    /// require that an statically unbounded number of values be\n-    /// rooted (if a loop exists).\n-    fn attempt_root(&self, cmt: cmt, base: cmt,\n-                    derefs: uint) -> bckres<PreserveCondition> {\n-        if !self.root_managed_data {\n-            // normally, there is a root_ub; the only time that this\n-            // is none is when a boxed value is stored in an immutable\n-            // location.  In that case, we will test to see if that\n-            // immutable location itself can be preserved long enough\n-            // in which case no rooting is necessary.  But there it\n-            // would be sort of pointless to avoid rooting the inner\n-            // box by rooting an outer box, as it would just keep more\n-            // memory live than necessary, so we set root_ub to none.\n-            return Err(bckerr { cmt: cmt, code: err_root_not_permitted });\n-        }\n-\n-        let root_region = ty::re_scope(self.root_ub);\n-        match self.scope_region {\n-          // we can only root values if the desired region is some concrete\n-          // scope within the fn body\n-          ty::re_scope(scope_id) => {\n-            debug!(\"Considering root map entry for %s: \\\n-                    node %d:%u -> scope_id %?, root_ub %?\",\n-                   self.bccx.cmt_to_repr(cmt), base.id,\n-                   derefs, scope_id, self.root_ub);\n-            if self.bccx.is_subregion_of(self.scope_region, root_region) {\n-                debug!(\"Elected to root\");\n-                let rk = root_map_key { id: base.id, derefs: derefs };\n-                // This code could potentially lead cause boxes to be frozen\n-                // for longer than necessarily at runtime. It prevents an\n-                // ICE in trans; the fundamental problem is that it's hard\n-                // to make sure trans and borrowck have the same notion of\n-                // scope. The real fix is to clean up how trans handles\n-                // cleanups, but that's hard. If this becomes an issue, it's\n-                // an option to just change this to `let scope_to_use =\n-                // scope_id;`. Though that would potentially re-introduce\n-                // the ICE. See #3511 for more details.\n-                let scope_to_use = if\n-                    self.bccx.stmt_map.contains(&scope_id) {\n-                    // Root it in its parent scope, b/c\n-                    // trans won't introduce a new scope for the\n-                    // stmt\n-                    self.root_ub\n-                }\n-                else {\n-                    // Use the more precise scope\n-                    scope_id\n-                };\n-                // We freeze if and only if this is a *mutable* @ box that\n-                // we're borrowing into a pointer.\n-                self.bccx.root_map.insert(rk, RootInfo {\n-                    scope: scope_to_use,\n-                    freezes: cmt.cat.derefs_through_mutable_box()\n-                });\n-                return Ok(PcOk);\n-            } else {\n-                debug!(\"Unable to root\");\n-                return Err(bckerr {\n-                    cmt: cmt,\n-                    code: err_out_of_root_scope(root_region,\n-                                                self.scope_region)\n-                });\n-            }\n-          }\n-\n-          // we won't be able to root long enough\n-          _ => {\n-              return Err(bckerr {\n-                cmt:cmt,\n-                code:err_out_of_root_scope(root_region, self.scope_region)\n-              });\n-          }\n-\n-        }\n-    }\n-}"}, {"sha": "dea08eedb61cf38b4c08dbcf658cc9556fbd066d", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -185,9 +185,7 @@ pub fn lookup_const_by_id(tcx: ty::ctxt,\n         }\n     } else {\n         let maps = astencode::Maps {\n-            mutbl_map: @mut HashSet::new(),\n             root_map: @mut HashMap::new(),\n-            last_use_map: @mut HashMap::new(),\n             method_map: @mut HashMap::new(),\n             vtable_map: @mut HashMap::new(),\n             write_guard_map: @mut HashSet::new(),"}, {"sha": "cfdd7f95030aaeb9f50ffa9163a9cd6e954b6e13", "filename": "src/librustc/middle/dataflow.rs", "status": "added", "additions": 1009, "deletions": 0, "changes": 1009, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -0,0 +1,1009 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+/*!\n+ * A module for propagating forward dataflow information. The analysis\n+ * assumes that the items to be propagated can be represented as bits\n+ * and thus uses bitvectors. Your job is simply to specify the so-called\n+ * GEN and KILL bits for each expression.\n+ */\n+\n+use core::prelude::*;\n+use core::cast;\n+use core::uint;\n+use syntax::ast;\n+use syntax::ast_util;\n+use syntax::ast_util::id_range;\n+use syntax::print::{pp, pprust};\n+use middle::ty;\n+use middle::typeck;\n+use util::ppaux::Repr;\n+\n+pub struct DataFlowContext<O> {\n+    priv tcx: ty::ctxt,\n+    priv method_map: typeck::method_map,\n+\n+    /// the data flow operator\n+    priv oper: O,\n+\n+    /// range of ids that appear within the item in question\n+    priv id_range: id_range,\n+\n+    /// number of bits to propagate per id\n+    priv bits_per_id: uint,\n+\n+    /// number of words we will use to store bits_per_id.\n+    /// equal to bits_per_id/uint::bits rounded up.\n+    priv words_per_id: uint,\n+\n+    // Bit sets per id.  The following three fields (`gens`, `kills`,\n+    // and `on_entry`) all have the same structure. For each id in\n+    // `id_range`, there is a range of words equal to `words_per_id`.\n+    // So, to access the bits for any given id, you take a slice of\n+    // the full vector (see the method `compute_id_range()`).\n+\n+    /// bits generated as we exit the scope `id`. Updated by `add_gen()`.\n+    priv gens: ~[uint],\n+\n+    /// bits killed as we exit the scope `id`. Updated by `add_kill()`.\n+    priv kills: ~[uint],\n+\n+    /// bits that are valid on entry to the scope `id`. Updated by\n+    /// `propagate()`.\n+    priv on_entry: ~[uint]\n+}\n+\n+/// Parameterization for the precise form of data flow that is used.\n+pub trait DataFlowOperator {\n+    /// Specifies the initial value for each bit in the `on_entry` set\n+    fn initial_value(&self) -> bool;\n+\n+    /// Joins two predecessor bits together, typically either `|` or `&`\n+    fn join(&self, succ: uint, pred: uint) -> uint;\n+\n+    /// True if we should propagate through closures\n+    fn walk_closures(&self) -> bool;\n+}\n+\n+struct PropagationContext<'self, O> {\n+    dfcx: &'self mut DataFlowContext<O>,\n+    changed: bool\n+}\n+\n+#[deriving(Eq)]\n+enum LoopKind {\n+    /// A `while` or `loop` loop\n+    TrueLoop,\n+\n+    /// A `for` \"loop\" (i.e., really a func call where `break`, `return`,\n+    /// and `loop` all essentially perform an early return from the closure)\n+    ForLoop\n+}\n+\n+struct LoopScope<'self> {\n+    loop_id: ast::node_id,\n+    loop_kind: LoopKind,\n+    break_bits: ~[uint]\n+}\n+\n+impl<O:DataFlowOperator> DataFlowContext<O> {\n+    pub fn new(tcx: ty::ctxt,\n+               method_map: typeck::method_map,\n+               oper: O,\n+               id_range: id_range,\n+               bits_per_id: uint) -> DataFlowContext<O> {\n+        let words_per_id = (bits_per_id + uint::bits - 1) / uint::bits;\n+\n+        debug!(\"DataFlowContext::new(id_range=%?, bits_per_id=%?, words_per_id=%?)\",\n+               id_range, bits_per_id, words_per_id);\n+\n+        let len = (id_range.max - id_range.min) as uint * words_per_id;\n+        let gens = vec::from_elem(len, 0);\n+        let kills = vec::from_elem(len, 0);\n+        let elem = if oper.initial_value() {uint::max_value} else {0};\n+        let on_entry = vec::from_elem(len, elem);\n+\n+        DataFlowContext {\n+            tcx: tcx,\n+            method_map: method_map,\n+            words_per_id: words_per_id,\n+            bits_per_id: bits_per_id,\n+            oper: oper,\n+            id_range: id_range,\n+            gens: gens,\n+            kills: kills,\n+            on_entry: on_entry\n+        }\n+    }\n+\n+    pub fn add_gen(&mut self, id: ast::node_id, bit: uint) {\n+        //! Indicates that `id` generates `bit`\n+\n+        debug!(\"add_gen(id=%?, bit=%?)\", id, bit);\n+        let (start, end) = self.compute_id_range(id);\n+        {\n+            let gens = vec::mut_slice(self.gens, start, end);\n+            set_bit(gens, bit);\n+        }\n+    }\n+\n+    pub fn add_kill(&mut self, id: ast::node_id, bit: uint) {\n+        //! Indicates that `id` kills `bit`\n+\n+        debug!(\"add_kill(id=%?, bit=%?)\", id, bit);\n+        let (start, end) = self.compute_id_range(id);\n+        {\n+            let kills = vec::mut_slice(self.kills, start, end);\n+            set_bit(kills, bit);\n+        }\n+    }\n+\n+    fn apply_gen_kill(&self, id: ast::node_id, bits: &mut [uint]) {\n+        //! Applies the gen and kill sets for `id` to `bits`\n+\n+        debug!(\"apply_gen_kill(id=%?, bits=%s) [before]\",\n+               id, mut_bits_to_str(bits));\n+        let (start, end) = self.compute_id_range(id);\n+        let gens = self.gens.slice(start, end);\n+        bitwise(bits, gens, |a, b| a | b);\n+        let kills = self.kills.slice(start, end);\n+        bitwise(bits, kills, |a, b| a & !b);\n+\n+        debug!(\"apply_gen_kill(id=%?, bits=%s) [after]\",\n+               id, mut_bits_to_str(bits));\n+    }\n+\n+    fn apply_kill(&self, id: ast::node_id, bits: &mut [uint]) {\n+        debug!(\"apply_kill(id=%?, bits=%s) [before]\",\n+               id, mut_bits_to_str(bits));\n+        let (start, end) = self.compute_id_range(id);\n+        let kills = self.kills.slice(start, end);\n+        bitwise(bits, kills, |a, b| a & !b);\n+        debug!(\"apply_kill(id=%?, bits=%s) [after]\",\n+               id, mut_bits_to_str(bits));\n+    }\n+\n+    fn compute_id_range(&self, absolute_id: ast::node_id) -> (uint, uint) {\n+        assert!(absolute_id >= self.id_range.min);\n+        assert!(absolute_id < self.id_range.max);\n+\n+        let relative_id = absolute_id - self.id_range.min;\n+        let start = (relative_id as uint) * self.words_per_id;\n+        let end = start + self.words_per_id;\n+        (start, end)\n+    }\n+\n+\n+    pub fn each_bit_on_entry(&self,\n+                             id: ast::node_id,\n+                             f: &fn(uint) -> bool) {\n+        //! Iterates through each bit that is set on entry to `id`.\n+        //! Only useful after `propagate()` has been called.\n+\n+        let (start, end) = self.compute_id_range(id);\n+        let on_entry = vec::slice(self.on_entry, start, end);\n+        debug!(\"each_bit_on_entry(id=%?, on_entry=%s)\",\n+               id, bits_to_str(on_entry));\n+        self.each_bit(on_entry, f);\n+    }\n+\n+    pub fn each_gen_bit(&self,\n+                        id: ast::node_id,\n+                        f: &fn(uint) -> bool) {\n+        //! Iterates through each bit in the gen set for `id`.\n+\n+        let (start, end) = self.compute_id_range(id);\n+        let gens = vec::slice(self.gens, start, end);\n+        debug!(\"each_gen_bit(id=%?, gens=%s)\",\n+               id, bits_to_str(gens));\n+        self.each_bit(gens, f)\n+    }\n+\n+    fn each_bit(&self,\n+                words: &[uint],\n+                f: &fn(uint) -> bool) {\n+        //! Helper for iterating over the bits in a bit set.\n+\n+        for words.eachi |word_index, &word| {\n+            if word != 0 {\n+                let base_index = word_index * uint::bits;\n+                for uint::range(0, uint::bits) |offset| {\n+                    let bit = 1 << offset;\n+                    if (word & bit) != 0 {\n+                        // NB: we round up the total number of bits\n+                        // that we store in any given bit set so that\n+                        // it is an even multiple of uint::bits.  This\n+                        // means that there may be some stray bits at\n+                        // the end that do not correspond to any\n+                        // actual value.  So before we callback, check\n+                        // whether the bit_index is greater than the\n+                        // actual value the user specified and stop\n+                        // iterating if so.\n+                        let bit_index = base_index + offset;\n+                        if bit_index >= self.bits_per_id || !f(bit_index) {\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<O:DataFlowOperator+Copy+'static> DataFlowContext<O> {\n+//                      ^^^^^^^^^^^^ only needed for pretty printing\n+    pub fn propagate(&mut self, blk: &ast::blk) {\n+        //! Performs the data flow analysis.\n+\n+        if self.bits_per_id == 0 {\n+            // Optimize the surprisingly common degenerate case.\n+            return;\n+        }\n+\n+        let mut propcx = PropagationContext {\n+            dfcx: self,\n+            changed: true\n+        };\n+\n+        let mut temp = vec::from_elem(self.words_per_id, 0);\n+        let mut loop_scopes = ~[];\n+\n+        while propcx.changed {\n+            propcx.changed = false;\n+            propcx.reset(temp);\n+            propcx.walk_block(blk, temp, &mut loop_scopes);\n+        }\n+\n+        debug!(\"Dataflow result:\");\n+        debug!(\"%s\", {\n+            let this = @copy *self;\n+            this.pretty_print_to(io::stderr(), blk);\n+            \"\"\n+        });\n+    }\n+\n+    fn pretty_print_to(@self, wr: @io::Writer, blk: &ast::blk) {\n+        let pre: @fn(pprust::ann_node) = |node| {\n+            let (ps, id) = match node {\n+                pprust::node_expr(ps, expr) => (ps, expr.id),\n+                pprust::node_block(ps, blk) => (ps, blk.node.id),\n+                pprust::node_item(ps, _) => (ps, 0),\n+                pprust::node_pat(ps, pat) => (ps, pat.id)\n+            };\n+\n+            if id >= self.id_range.min || id < self.id_range.max {\n+                let (start, end) = self.compute_id_range(id);\n+                let on_entry = vec::slice(self.on_entry, start, end);\n+                let entry_str = bits_to_str(on_entry);\n+\n+                let gens = vec::slice(self.gens, start, end);\n+                let gens_str = if gens.any(|&u| u != 0) {\n+                    fmt!(\" gen: %s\", bits_to_str(gens))\n+                } else {\n+                    ~\"\"\n+                };\n+\n+                let kills = vec::slice(self.kills, start, end);\n+                let kills_str = if kills.any(|&u| u != 0) {\n+                    fmt!(\" kill: %s\", bits_to_str(kills))\n+                } else {\n+                    ~\"\"\n+                };\n+\n+                let comment_str = fmt!(\"id %d: %s%s%s\",\n+                                       id, entry_str, gens_str, kills_str);\n+                pprust::synth_comment(ps, comment_str);\n+                pp::space(ps.s);\n+            }\n+        };\n+\n+        let post: @fn(pprust::ann_node) = |_| {\n+        };\n+\n+        let ps = pprust::rust_printer_annotated(\n+            wr, self.tcx.sess.intr(),\n+            pprust::pp_ann {pre:pre, post:post});\n+        pprust::cbox(ps, pprust::indent_unit);\n+        pprust::ibox(ps, 0u);\n+        pprust::print_block(ps, blk);\n+        pp::eof(ps.s);\n+    }\n+}\n+\n+impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n+    fn tcx(&self) -> ty::ctxt {\n+        self.dfcx.tcx\n+    }\n+\n+    fn walk_block(&mut self,\n+                  blk: &ast::blk,\n+                  in_out: &mut [uint],\n+                  loop_scopes: &mut ~[LoopScope]) {\n+        debug!(\"DataFlowContext::walk_block(blk.node.id=%?, in_out=%s)\",\n+               blk.node.id, bits_to_str(reslice(in_out)));\n+\n+        self.merge_with_entry_set(blk.node.id, in_out);\n+\n+        for blk.node.stmts.each |&stmt| {\n+            self.walk_stmt(stmt, in_out, loop_scopes);\n+        }\n+\n+        self.walk_opt_expr(blk.node.expr, in_out, loop_scopes);\n+\n+        self.dfcx.apply_gen_kill(blk.node.id, in_out);\n+    }\n+\n+    fn walk_stmt(&mut self,\n+                 stmt: @ast::stmt,\n+                 in_out: &mut [uint],\n+                 loop_scopes: &mut ~[LoopScope]) {\n+        match stmt.node {\n+            ast::stmt_decl(decl, _) => {\n+                self.walk_decl(decl, in_out, loop_scopes);\n+            }\n+\n+            ast::stmt_expr(expr, _) | ast::stmt_semi(expr, _) => {\n+                self.walk_expr(expr, in_out, loop_scopes);\n+            }\n+\n+            ast::stmt_mac(*) => {\n+                self.tcx().sess.span_bug(stmt.span, ~\"unexpanded macro\");\n+            }\n+        }\n+    }\n+\n+    fn walk_decl(&mut self,\n+                 decl: @ast::decl,\n+                 in_out: &mut [uint],\n+                 loop_scopes: &mut ~[LoopScope]) {\n+        match decl.node {\n+            ast::decl_local(ref locals) => {\n+                for locals.each |local| {\n+                    self.walk_pat(local.node.pat, in_out, loop_scopes);\n+                    self.walk_opt_expr(local.node.init, in_out, loop_scopes);\n+                }\n+            }\n+\n+            ast::decl_item(_) => {}\n+        }\n+    }\n+\n+    fn walk_expr(&mut self,\n+                 expr: @ast::expr,\n+                 in_out: &mut [uint],\n+                 loop_scopes: &mut ~[LoopScope]) {\n+        debug!(\"DataFlowContext::walk_expr(expr=%s, in_out=%s)\",\n+               expr.repr(self.dfcx.tcx), bits_to_str(reslice(in_out)));\n+\n+        self.merge_with_entry_set(expr.id, in_out);\n+\n+        match expr.node {\n+            ast::expr_fn_block(ref decl, ref body) => {\n+                if self.dfcx.oper.walk_closures() {\n+                    // In the absence of once fns, we must assume that\n+                    // every function body will execute more than\n+                    // once. Thus we treat every function body like a\n+                    // loop.\n+                    //\n+                    // What is subtle and a bit tricky, also, is how\n+                    // to deal with the \"output\" bits---that is, what\n+                    // do we consider to be the successor of a\n+                    // function body, given that it could be called\n+                    // from any point within its lifetime? What we do\n+                    // is to add their effects immediately as of the\n+                    // point of creation. Of course we have to ensure\n+                    // that this is sound for the analyses which make\n+                    // use of dataflow.\n+                    //\n+                    // In the case of the initedness checker (which\n+                    // does not currently use dataflow, but I hope to\n+                    // convert at some point), we will simply not walk\n+                    // closures at all, so it's a moot point.\n+                    //\n+                    // In the case of the borrow checker, this means\n+                    // the loans which would be created by calling a\n+                    // function come into effect immediately when the\n+                    // function is created. This is guaranteed to be\n+                    // earlier than the point at which the loan\n+                    // actually comes into scope (which is the point\n+                    // at which the closure is *called*). Because\n+                    // loans persist until the scope of the loans is\n+                    // exited, it is always a safe approximation to\n+                    // have a loan begin earlier than it actually will\n+                    // at runtime, so this should be sound.\n+                    //\n+                    // We stil have to be careful in the region\n+                    // checker and borrow checker to treat function\n+                    // bodies like loops, which implies some\n+                    // limitations. For example, a closure cannot root\n+                    // a managed box for longer than its body.\n+                    //\n+                    // General control flow looks like this:\n+                    //\n+                    //  +- (expr) <----------+\n+                    //  |    |               |\n+                    //  |    v               |\n+                    //  |  (body) -----------+--> (exit)\n+                    //  |    |               |\n+                    //  |    + (break/loop) -+\n+                    //  |                    |\n+                    //  +--------------------+\n+                    //\n+                    // This is a bit more conservative than a loop.\n+                    // Note that we must assume that even after a\n+                    // `break` occurs (e.g., in a `for` loop) that the\n+                    // closure may be reinvoked.\n+                    //\n+                    // One difference from other loops is that `loop`\n+                    // and `break` statements which target a closure\n+                    // both simply add to the `break_bits`.\n+\n+                    // func_bits represents the state when the function\n+                    // returns\n+                    let mut func_bits = reslice(in_out).to_vec();\n+\n+                    loop_scopes.push(LoopScope {\n+                        loop_id: expr.id,\n+                        loop_kind: ForLoop,\n+                        break_bits: reslice(in_out).to_vec()\n+                    });\n+                    for decl.inputs.each |input| {\n+                        self.walk_pat(input.pat, func_bits, loop_scopes);\n+                    }\n+                    self.walk_block(body, func_bits, loop_scopes);\n+\n+                    // add the bits from any early return via `break`,\n+                    // `continue`, or `return` into `func_bits`\n+                    let loop_scope = loop_scopes.pop();\n+                    join_bits(&self.dfcx.oper, loop_scope.break_bits, func_bits);\n+\n+                    // add `func_bits` to the entry bits for `expr`,\n+                    // since we must assume the function may be called\n+                    // more than once\n+                    self.add_to_entry_set(expr.id, reslice(func_bits));\n+\n+                    // the final exit bits include whatever was present\n+                    // in the original, joined with the bits from the function\n+                    join_bits(&self.dfcx.oper, func_bits, in_out);\n+                }\n+            }\n+\n+            ast::expr_if(cond, ref then, els) => {\n+                //\n+                //     (cond)\n+                //       |\n+                //       v\n+                //      ( )\n+                //     /   \\\n+                //    |     |\n+                //    v     v\n+                //  (then)(els)\n+                //    |     |\n+                //    v     v\n+                //   (  succ  )\n+                //\n+                self.walk_expr(cond, in_out, loop_scopes);\n+\n+                let mut then_bits = reslice(in_out).to_vec();\n+                self.walk_block(then, then_bits, loop_scopes);\n+\n+                self.walk_opt_expr(els, in_out, loop_scopes);\n+                join_bits(&self.dfcx.oper, then_bits, in_out);\n+            }\n+\n+            ast::expr_while(cond, ref blk) => {\n+                //\n+                //     (expr) <--+\n+                //       |       |\n+                //       v       |\n+                //  +--(cond)    |\n+                //  |    |       |\n+                //  |    v       |\n+                //  v  (blk) ----+\n+                //       |\n+                //    <--+ (break)\n+                //\n+\n+                self.walk_expr(cond, in_out, loop_scopes);\n+\n+                let mut body_bits = reslice(in_out).to_vec();\n+                loop_scopes.push(LoopScope {\n+                    loop_id: expr.id,\n+                    loop_kind: TrueLoop,\n+                    break_bits: reslice(in_out).to_vec()\n+                });\n+                self.walk_block(blk, body_bits, loop_scopes);\n+                self.add_to_entry_set(expr.id, body_bits);\n+                let new_loop_scope = loop_scopes.pop();\n+                copy_bits(new_loop_scope.break_bits, in_out);\n+            }\n+\n+            ast::expr_loop(ref blk, _) => {\n+                //\n+                //     (expr) <--+\n+                //       |       |\n+                //       v       |\n+                //     (blk) ----+\n+                //       |\n+                //    <--+ (break)\n+                //\n+\n+                let mut body_bits = reslice(in_out).to_vec();\n+                self.reset(in_out);\n+                loop_scopes.push(LoopScope {\n+                    loop_id: expr.id,\n+                    loop_kind: TrueLoop,\n+                    break_bits: reslice(in_out).to_vec()\n+                });\n+                self.walk_block(blk, body_bits, loop_scopes);\n+                self.add_to_entry_set(expr.id, body_bits);\n+\n+                let new_loop_scope = loop_scopes.pop();\n+                assert_eq!(new_loop_scope.loop_id, expr.id);\n+                copy_bits(new_loop_scope.break_bits, in_out);\n+            }\n+\n+            ast::expr_match(discr, ref arms) => {\n+                //\n+                //    (discr)\n+                //     / | \\\n+                //    |  |  |\n+                //    v  v  v\n+                //   (..arms..)\n+                //    |  |  |\n+                //    v  v  v\n+                //   (  succ  )\n+                //\n+                //\n+                self.walk_expr(discr, in_out, loop_scopes);\n+\n+                let mut guards = reslice(in_out).to_vec();\n+\n+                // We know that exactly one arm will be taken, so we\n+                // can start out with a blank slate and just union\n+                // together the bits from each arm:\n+                self.reset(in_out);\n+\n+                for arms.each |arm| {\n+                    // in_out reflects the discr and all guards to date\n+                    self.walk_opt_expr(arm.guard, guards, loop_scopes);\n+\n+                    // determine the bits for the body and then union\n+                    // them into `in_out`, which reflects all bodies to date\n+                    let mut body = reslice(guards).to_vec();\n+                    self.walk_pat_alternatives(arm.pats, body, loop_scopes);\n+                    self.walk_block(&arm.body, body, loop_scopes);\n+                    join_bits(&self.dfcx.oper, body, in_out);\n+                }\n+            }\n+\n+            ast::expr_ret(o_e) => {\n+                self.walk_opt_expr(o_e, in_out, loop_scopes);\n+\n+                // is this a return from a `for`-loop closure?\n+                match loop_scopes.position(|s| s.loop_kind == ForLoop) {\n+                    Some(i) => {\n+                        // if so, add the in_out bits to the state\n+                        // upon exit. Remember that we cannot count\n+                        // upon the `for` loop function not to invoke\n+                        // the closure again etc.\n+                        self.break_from_to(expr, &mut loop_scopes[i], in_out);\n+                    }\n+\n+                    None => {}\n+                }\n+\n+                self.reset(in_out);\n+            }\n+\n+            ast::expr_break(label) => {\n+                let scope = self.find_scope(expr, label, loop_scopes);\n+                self.break_from_to(expr, scope, in_out);\n+                self.reset(in_out);\n+            }\n+\n+            ast::expr_again(label) => {\n+                let scope = self.find_scope(expr, label, loop_scopes);\n+\n+                match scope.loop_kind {\n+                    TrueLoop => {\n+                        self.pop_scopes(expr, scope, in_out);\n+                        self.add_to_entry_set(scope.loop_id, reslice(in_out));\n+                    }\n+\n+                    ForLoop => {\n+                        // If this `loop` construct is looping back to a `for`\n+                        // loop, then `loop` is really just a return from the\n+                        // closure. Therefore, we treat it the same as `break`.\n+                        // See case for `expr_fn_block` for more details.\n+                        self.break_from_to(expr, scope, in_out);\n+                    }\n+                }\n+\n+                self.reset(in_out);\n+            }\n+\n+            ast::expr_assign(l, r) |\n+            ast::expr_assign_op(_, l, r) => {\n+                self.walk_expr(r, in_out, loop_scopes);\n+                self.walk_expr(l, in_out, loop_scopes);\n+            }\n+\n+            ast::expr_swap(l, r) => {\n+                self.walk_expr(l, in_out, loop_scopes);\n+                self.walk_expr(r, in_out, loop_scopes);\n+            }\n+\n+            ast::expr_vec(ref exprs, _) => {\n+                self.walk_exprs(*exprs, in_out, loop_scopes)\n+            }\n+\n+            ast::expr_repeat(l, r, _) => {\n+                self.walk_expr(l, in_out, loop_scopes);\n+                self.walk_expr(r, in_out, loop_scopes);\n+            }\n+\n+            ast::expr_struct(_, ref fields, with_expr) => {\n+                self.walk_opt_expr(with_expr, in_out, loop_scopes);\n+                for fields.each |field| {\n+                    self.walk_expr(field.node.expr, in_out, loop_scopes);\n+                }\n+            }\n+\n+            ast::expr_call(f, ref args, _) => {\n+                self.walk_call(expr.callee_id, expr.id,\n+                               f, *args, in_out, loop_scopes);\n+            }\n+\n+            ast::expr_method_call(rcvr, _, _, ref args, _) => {\n+                self.walk_call(expr.callee_id, expr.id,\n+                               rcvr, *args, in_out, loop_scopes);\n+            }\n+\n+            ast::expr_index(l, r) |\n+            ast::expr_binary(_, l, r) if self.is_method_call(expr) => {\n+                self.walk_call(expr.callee_id, expr.id,\n+                               l, [r], in_out, loop_scopes);\n+            }\n+\n+            ast::expr_unary(_, e) if self.is_method_call(expr) => {\n+                self.walk_call(expr.callee_id, expr.id,\n+                               e, [], in_out, loop_scopes);\n+            }\n+\n+            ast::expr_tup(ref exprs) => {\n+                self.walk_exprs(*exprs, in_out, loop_scopes);\n+            }\n+\n+            ast::expr_binary(op, l, r) if ast_util::lazy_binop(op) => {\n+                self.walk_expr(l, in_out, loop_scopes);\n+                let temp = reslice(in_out).to_vec();\n+                self.walk_expr(r, in_out, loop_scopes);\n+                join_bits(&self.dfcx.oper, temp, in_out);\n+            }\n+\n+            ast::expr_log(l, r) |\n+            ast::expr_index(l, r) |\n+            ast::expr_binary(_, l, r) => {\n+                self.walk_exprs([l, r], in_out, loop_scopes);\n+            }\n+\n+            ast::expr_lit(*) |\n+            ast::expr_path(*) => {\n+            }\n+\n+            ast::expr_addr_of(_, e) |\n+            ast::expr_copy(e) |\n+            ast::expr_loop_body(e) |\n+            ast::expr_do_body(e) |\n+            ast::expr_cast(e, _) |\n+            ast::expr_unary(_, e) |\n+            ast::expr_paren(e) |\n+            ast::expr_vstore(e, _) |\n+            ast::expr_field(e, _, _) => {\n+                self.walk_expr(e, in_out, loop_scopes);\n+            }\n+\n+            ast::expr_inline_asm(ref inline_asm) => {\n+                for inline_asm.inputs.each |&(_, expr)| {\n+                    self.walk_expr(expr, in_out, loop_scopes);\n+                }\n+                for inline_asm.outputs.each |&(_, expr)| {\n+                    self.walk_expr(expr, in_out, loop_scopes);\n+                }\n+            }\n+\n+            ast::expr_block(ref blk) => {\n+                self.walk_block(blk, in_out, loop_scopes);\n+            }\n+\n+            ast::expr_mac(*) => {\n+                self.tcx().sess.span_bug(expr.span, ~\"unexpanded macro\");\n+            }\n+        }\n+\n+        self.dfcx.apply_gen_kill(expr.id, in_out);\n+    }\n+\n+    fn pop_scopes(&mut self,\n+                  from_expr: @ast::expr,\n+                  to_scope: &mut LoopScope,\n+                  in_out: &mut [uint]) {\n+        //! Whenever you have a `break` or a `loop` statement, flow\n+        //! exits through any number of enclosing scopes on its\n+        //! way to the new destination. This function applies the kill\n+        //! sets of those enclosing scopes to `in_out` (those kill sets\n+        //! concern items that are going out of scope).\n+\n+        let tcx = self.tcx();\n+        let region_maps = tcx.region_maps;\n+\n+        debug!(\"pop_scopes(from_expr=%s, to_scope=%?, in_out=%s)\",\n+               from_expr.repr(tcx), to_scope.loop_id,\n+               bits_to_str(reslice(in_out)));\n+\n+        let mut id = from_expr.id;\n+        while id != to_scope.loop_id {\n+            self.dfcx.apply_kill(id, in_out);\n+\n+            match region_maps.opt_encl_scope(id) {\n+                Some(i) => { id = i; }\n+                None => {\n+                    tcx.sess.span_bug(\n+                        from_expr.span,\n+                        fmt!(\"pop_scopes(from_expr=%s, to_scope=%?) \\\n+                              to_scope does not enclose from_expr\",\n+                             from_expr.repr(tcx), to_scope.loop_id));\n+                }\n+            }\n+        }\n+    }\n+\n+    fn break_from_to(&mut self,\n+                     from_expr: @ast::expr,\n+                     to_scope: &mut LoopScope,\n+                     in_out: &mut [uint]) {\n+        self.pop_scopes(from_expr, to_scope, in_out);\n+        self.dfcx.apply_kill(from_expr.id, in_out);\n+        join_bits(&self.dfcx.oper, reslice(in_out), to_scope.break_bits);\n+        debug!(\"break_from_to(from_expr=%s, to_scope=%?) final break_bits=%s\",\n+               from_expr.repr(self.tcx()),\n+               to_scope.loop_id,\n+               bits_to_str(reslice(in_out)));\n+    }\n+\n+    fn walk_exprs(&mut self,\n+                  exprs: &[@ast::expr],\n+                  in_out: &mut [uint],\n+                  loop_scopes: &mut ~[LoopScope]) {\n+        for exprs.each |&expr| {\n+            self.walk_expr(expr, in_out, loop_scopes);\n+        }\n+    }\n+\n+    fn walk_opt_expr(&mut self,\n+                     opt_expr: Option<@ast::expr>,\n+                     in_out: &mut [uint],\n+                     loop_scopes: &mut ~[LoopScope]) {\n+        for opt_expr.each |&expr| {\n+            self.walk_expr(expr, in_out, loop_scopes);\n+        }\n+    }\n+\n+    fn walk_call(&mut self,\n+                 _callee_id: ast::node_id,\n+                 call_id: ast::node_id,\n+                 arg0: @ast::expr,\n+                 args: &[@ast::expr],\n+                 in_out: &mut [uint],\n+                 loop_scopes: &mut ~[LoopScope]) {\n+        self.walk_expr(arg0, in_out, loop_scopes);\n+        self.walk_exprs(args, in_out, loop_scopes);\n+\n+        // FIXME(#5074) nested method calls\n+        // self.merge_with_entry_set(callee_id, in_out);\n+        // self.dfcx.apply_gen_kill(callee_id, in_out);\n+\n+        let return_ty = ty::node_id_to_type(self.tcx(), call_id);\n+        let fails = ty::type_is_bot(return_ty);\n+        if fails {\n+            self.reset(in_out);\n+        }\n+    }\n+\n+    fn walk_pat(&mut self,\n+                pat: @ast::pat,\n+                in_out: &mut [uint],\n+                _loop_scopes: &mut ~[LoopScope]) {\n+        debug!(\"DataFlowContext::walk_pat(pat=%s, in_out=%s)\",\n+               pat.repr(self.dfcx.tcx), bits_to_str(reslice(in_out)));\n+\n+        do ast_util::walk_pat(pat) |p| {\n+            debug!(\"  p.id=%? in_out=%s\", p.id, bits_to_str(reslice(in_out)));\n+            self.merge_with_entry_set(p.id, in_out);\n+            self.dfcx.apply_gen_kill(p.id, in_out);\n+        }\n+    }\n+\n+    fn walk_pat_alternatives(&mut self,\n+                             pats: &[@ast::pat],\n+                             in_out: &mut [uint],\n+                             loop_scopes: &mut ~[LoopScope]) {\n+        if pats.len() == 1 {\n+            // Common special case:\n+            return self.walk_pat(pats[0], in_out, loop_scopes);\n+        }\n+\n+        // In the general case, the patterns in `pats` are\n+        // alternatives, so we must treat this like an N-way select\n+        // statement.\n+        let initial_state = reslice(in_out).to_vec();\n+        self.reset(in_out);\n+        for pats.each |&pat| {\n+            let mut temp = copy initial_state;\n+            self.walk_pat(pat, in_out, loop_scopes);\n+            join_bits(&self.dfcx.oper, temp, in_out);\n+        }\n+    }\n+\n+    fn find_scope<'a>(&self,\n+                      expr: @ast::expr,\n+                      label: Option<ast::ident>,\n+                      loop_scopes: &'a mut ~[LoopScope]) -> &'a mut LoopScope {\n+        let index = match label {\n+            None => {\n+                let len = loop_scopes.len();\n+                len - 1\n+            }\n+\n+            Some(_) => {\n+                match self.tcx().def_map.find(&expr.id) {\n+                    Some(&ast::def_label(loop_id)) => {\n+                        match loop_scopes.position(|l| l.loop_id == loop_id) {\n+                            Some(i) => i,\n+                            None => {\n+                                self.tcx().sess.span_bug(\n+                                    expr.span,\n+                                    fmt!(\"No loop scope for id %?\", loop_id));\n+                            }\n+                        }\n+                    }\n+\n+                    r => {\n+                        self.tcx().sess.span_bug(\n+                            expr.span,\n+                            fmt!(\"Bad entry `%?` in def_map for label\", r));\n+                    }\n+                }\n+            }\n+        };\n+\n+        &mut loop_scopes[index]\n+    }\n+\n+    fn is_method_call(&self, expr: @ast::expr) -> bool {\n+        self.dfcx.method_map.contains_key(&expr.id)\n+    }\n+\n+    fn reset(&mut self, bits: &mut [uint]) {\n+        let e = if self.dfcx.oper.initial_value() {uint::max_value} else {0};\n+        for vec::each_mut(bits) |b| { *b = e; }\n+    }\n+\n+    fn add_to_entry_set(&mut self, id: ast::node_id, pred_bits: &[uint]) {\n+        debug!(\"add_to_entry_set(id=%?, pred_bits=%s)\",\n+               id, bits_to_str(pred_bits));\n+        let (start, end) = self.dfcx.compute_id_range(id);\n+        let changed = { // FIXME(#5074) awkward construction\n+            let on_entry = vec::mut_slice(self.dfcx.on_entry, start, end);\n+            join_bits(&self.dfcx.oper, pred_bits, on_entry)\n+        };\n+        if changed {\n+            debug!(\"changed entry set for %? to %s\",\n+                   id, bits_to_str(self.dfcx.on_entry.slice(start, end)));\n+            self.changed = true;\n+        }\n+    }\n+\n+    fn merge_with_entry_set(&mut self,\n+                            id: ast::node_id,\n+                            pred_bits: &mut [uint]) {\n+        debug!(\"merge_with_entry_set(id=%?, pred_bits=%s)\",\n+               id, mut_bits_to_str(pred_bits));\n+        let (start, end) = self.dfcx.compute_id_range(id);\n+        let changed = { // FIXME(#5074) awkward construction\n+            let on_entry = vec::mut_slice(self.dfcx.on_entry, start, end);\n+            let changed = join_bits(&self.dfcx.oper, reslice(pred_bits), on_entry);\n+            copy_bits(reslice(on_entry), pred_bits);\n+            changed\n+        };\n+        if changed {\n+            debug!(\"changed entry set for %? to %s\",\n+                   id, bits_to_str(self.dfcx.on_entry.slice(start, end)));\n+            self.changed = true;\n+        }\n+    }\n+}\n+\n+fn mut_bits_to_str(words: &mut [uint]) -> ~str {\n+    bits_to_str(reslice(words))\n+}\n+\n+fn bits_to_str(words: &[uint]) -> ~str {\n+    let mut result = ~\"\";\n+    let mut sep = '[';\n+\n+    // Note: this is a little endian printout of bytes.\n+\n+    for words.each |&word| {\n+        let mut v = word;\n+        for uint::range(0, uint::bytes) |_| {\n+            str::push_char(&mut result, sep);\n+            str::push_str(&mut result, fmt!(\"%02x\", v & 0xFF));\n+            v >>= 8;\n+            sep = '-';\n+        }\n+    }\n+    str::push_char(&mut result, ']');\n+    return result;\n+}\n+\n+fn copy_bits(in_vec: &[uint], out_vec: &mut [uint]) -> bool {\n+    bitwise(out_vec, in_vec, |_, b| b)\n+}\n+\n+fn join_bits<O:DataFlowOperator>(oper: &O,\n+                                 in_vec: &[uint],\n+                                 out_vec: &mut [uint]) -> bool {\n+    bitwise(out_vec, in_vec, |a, b| oper.join(a, b))\n+}\n+\n+#[inline(always)]\n+fn bitwise(out_vec: &mut [uint],\n+           in_vec: &[uint],\n+           op: &fn(uint, uint) -> uint) -> bool {\n+    assert_eq!(out_vec.len(), in_vec.len());\n+    let mut changed = false;\n+    for uint::range(0, out_vec.len()) |i| {\n+        let old_val = out_vec[i];\n+        let new_val = op(old_val, in_vec[i]);\n+        out_vec[i] = new_val;\n+        changed |= (old_val != new_val);\n+    }\n+    return changed;\n+}\n+\n+fn set_bit(words: &mut [uint], bit: uint) -> bool {\n+    debug!(\"set_bit: words=%s bit=%s\",\n+           mut_bits_to_str(words), bit_str(bit));\n+    let word = bit / uint::bits;\n+    let bit_in_word = bit % uint::bits;\n+    let bit_mask = 1 << bit_in_word;\n+    debug!(\"word=%u bit_in_word=%u bit_mask=%u\", word, bit_in_word, word);\n+    let oldv = words[word];\n+    let newv = oldv | bit_mask;\n+    words[word] = newv;\n+    oldv != newv\n+}\n+\n+fn bit_str(bit: uint) -> ~str {\n+    let byte = bit >> 8;\n+    let lobits = 1 << (bit & 0xFF);\n+    fmt!(\"[%u:%u-%02x]\", bit, byte, lobits)\n+}\n+\n+fn reslice<'a>(v: &'a mut [uint]) -> &'a [uint] {\n+    // bFIXME(#5074) this function should not be necessary at all\n+    unsafe {\n+        cast::transmute(v)\n+    }\n+}\n+"}, {"sha": "199eb274ab9e1cccb922c1ca4cabef7329e827f2", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -10,7 +10,6 @@\n \n use middle::freevars::freevar_entry;\n use middle::freevars;\n-use middle::liveness;\n use middle::pat_util;\n use middle::ty;\n use middle::typeck;\n@@ -56,19 +55,16 @@ pub static try_adding: &'static str = \"Try adding a move\";\n pub struct Context {\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n-    last_use_map: liveness::last_use_map,\n-    current_item: node_id,\n+    current_item: node_id\n }\n \n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: typeck::method_map,\n-                   last_use_map: liveness::last_use_map,\n                    crate: @crate) {\n     let ctx = Context {\n         tcx: tcx,\n         method_map: method_map,\n-        last_use_map: last_use_map,\n-        current_item: -1,\n+        current_item: -1\n     };\n     let visit = visit::mk_vt(@visit::Visitor {\n         visit_arm: check_arm,"}, {"sha": "784db49a0fd6275197f1166fe7a3bbb17610bf3d", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -252,10 +252,9 @@ pub impl LanguageItems {\n     }\n }\n \n-fn LanguageItemCollector<'r>(crate: @crate,\n-                             session: Session,\n-                             items: &'r mut LanguageItems)\n-                          -> LanguageItemCollector<'r> {\n+fn LanguageItemCollector(crate: @crate,\n+                         session: Session)\n+                      -> LanguageItemCollector {\n     let mut item_refs = HashMap::new();\n \n     item_refs.insert(@~\"const\", ConstTraitLangItem as uint);\n@@ -303,22 +302,22 @@ fn LanguageItemCollector<'r>(crate: @crate,\n     LanguageItemCollector {\n         crate: crate,\n         session: session,\n-        items: items,\n+        items: LanguageItems::new(),\n         item_refs: item_refs\n     }\n }\n \n-struct LanguageItemCollector<'self> {\n-    items: &'self mut LanguageItems,\n+struct LanguageItemCollector {\n+    items: LanguageItems,\n \n     crate: @crate,\n     session: Session,\n \n     item_refs: HashMap<@~str, uint>,\n }\n \n-pub impl<'self> LanguageItemCollector<'self> {\n-    fn match_and_collect_meta_item(&self, item_def_id: def_id,\n+pub impl LanguageItemCollector {\n+    fn match_and_collect_meta_item(&mut self, item_def_id: def_id,\n                                    meta_item: @meta_item) {\n         match meta_item.node {\n             meta_name_value(key, literal) => {\n@@ -333,7 +332,7 @@ pub impl<'self> LanguageItemCollector<'self> {\n         }\n     }\n \n-    fn collect_item(&self, item_index: uint, item_def_id: def_id) {\n+    fn collect_item(&mut self, item_index: uint, item_def_id: def_id) {\n         // Check for duplicates.\n         match self.items.items[item_index] {\n             Some(original_def_id) if original_def_id != item_def_id => {\n@@ -349,42 +348,45 @@ pub impl<'self> LanguageItemCollector<'self> {\n         self.items.items[item_index] = Some(item_def_id);\n     }\n \n-    fn match_and_collect_item(&self,\n+    fn match_and_collect_item(&mut self,\n                               item_def_id: def_id, key: @~str, value: @~str) {\n         if *key != ~\"lang\" {\n             return;    // Didn't match.\n         }\n \n-        match self.item_refs.find(&value) {\n+        let item_index = self.item_refs.find(&value).map(|x| **x);\n+        // prevent borrow checker from considering   ^~~~~~~~~~~\n+        // self to be borrowed (annoying)\n+\n+        match item_index {\n+            Some(item_index) => {\n+                self.collect_item(item_index, item_def_id);\n+            }\n             None => {\n                 // Didn't match.\n-            }\n-            Some(&item_index) => {\n-                self.collect_item(item_index, item_def_id)\n+                return;\n             }\n         }\n     }\n \n-    fn collect_local_language_items(&self) {\n-        unsafe {\n-            let this: *LanguageItemCollector<'self> = transmute(self);\n-            visit_crate(self.crate, (), mk_simple_visitor(@SimpleVisitor {\n-                visit_item: |item| {\n-                    for item.attrs.each |attribute| {\n-                        unsafe {\n-                            (*this).match_and_collect_meta_item(\n-                                local_def(item.id),\n-                                attribute.node.value\n-                            );\n-                        }\n+    fn collect_local_language_items(&mut self) {\n+        let this = ptr::addr_of(&self);\n+        visit_crate(self.crate, (), mk_simple_visitor(@SimpleVisitor {\n+            visit_item: |item| {\n+                for item.attrs.each |attribute| {\n+                    unsafe {\n+                        (*this).match_and_collect_meta_item(\n+                            local_def(item.id),\n+                            attribute.node.value\n+                        );\n                     }\n                 },\n                 .. *default_simple_visitor()\n             }));\n         }\n     }\n \n-    fn collect_external_language_items(&self) {\n+    fn collect_external_language_items(&mut self) {\n         let crate_store = self.session.cstore;\n         do iter_crate_data(crate_store) |crate_number, _crate_metadata| {\n             for each_lang_item(crate_store, crate_number)\n@@ -408,7 +410,7 @@ pub impl<'self> LanguageItemCollector<'self> {\n         }\n     }\n \n-    fn collect(&self) {\n+    fn collect(&mut self) {\n         self.collect_local_language_items();\n         self.collect_external_language_items();\n         self.check_completeness();\n@@ -418,9 +420,9 @@ pub impl<'self> LanguageItemCollector<'self> {\n pub fn collect_language_items(crate: @crate,\n                               session: Session)\n                            -> LanguageItems {\n-    let mut items = LanguageItems::new();\n-    let collector = LanguageItemCollector(crate, session, &mut items);\n+    let mut collector = LanguageItemCollector(crate, session);\n     collector.collect();\n-    copy items\n+    let LanguageItemCollector { items, _ } = collector;\n+    items\n }\n "}, {"sha": "2e2c92abcdc78f4ca4c9780320768fdba97380f9", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 22, "deletions": 83, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -121,16 +121,6 @@ use syntax::visit::{fk_anon, fk_dtor, fk_fn_block, fk_item_fn, fk_method};\n use syntax::visit::{vt};\n use syntax::{visit, ast_util};\n \n-// Maps from an expr id to a list of variable ids for which this expr\n-// is the last use.  Typically, the expr is a path and the node id is\n-// the local/argument/etc that the path refers to.  However, it also\n-// possible for the expr to be a closure, in which case the list is a\n-// list of closed over variables that can be moved into the closure.\n-//\n-// Very subtle (#2633): borrowck will remove entries from this table\n-// if it detects an outstanding loan (that is, the addr is taken).\n-pub type last_use_map = @mut HashMap<node_id, @mut ~[node_id]>;\n-\n #[deriving(Eq)]\n struct Variable(uint);\n #[deriving(Eq)]\n@@ -158,7 +148,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                    method_map: typeck::method_map,\n                    variable_moves_map: moves::VariableMovesMap,\n                    capture_map: moves::CaptureMap,\n-                   crate: @crate) -> last_use_map {\n+                   crate: @crate) {\n     let visitor = visit::mk_vt(@visit::Visitor {\n         visit_fn: visit_fn,\n         visit_local: visit_local,\n@@ -168,16 +158,13 @@ pub fn check_crate(tcx: ty::ctxt,\n         .. *visit::default_visitor()\n     });\n \n-    let last_use_map = @mut HashMap::new();\n     let initial_maps = @mut IrMaps(tcx,\n                                    method_map,\n                                    variable_moves_map,\n                                    capture_map,\n-                                   last_use_map,\n                                    0);\n     visit::visit_crate(crate, initial_maps, visitor);\n     tcx.sess.abort_if_errors();\n-    return last_use_map;\n }\n \n impl to_str::ToStr for LiveNode {\n@@ -241,23 +228,11 @@ enum VarKind {\n     ImplicitRet\n }\n \n-fn relevant_def(def: def) -> Option<node_id> {\n-    match def {\n-        def_binding(nid, _) |\n-        def_arg(nid, _) |\n-        def_local(nid, _) |\n-        def_self(nid, _) => Some(nid),\n-\n-        _ => None\n-    }\n-}\n-\n struct IrMaps {\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n     variable_moves_map: moves::VariableMovesMap,\n     capture_map: moves::CaptureMap,\n-    last_use_map: last_use_map,\n \n     num_live_nodes: uint,\n     num_vars: uint,\n@@ -274,15 +249,13 @@ fn IrMaps(tcx: ty::ctxt,\n           method_map: typeck::method_map,\n           variable_moves_map: moves::VariableMovesMap,\n           capture_map: moves::CaptureMap,\n-          last_use_map: last_use_map,\n           cur_item: node_id)\n        -> IrMaps {\n     IrMaps {\n         tcx: tcx,\n         method_map: method_map,\n         variable_moves_map: variable_moves_map,\n         capture_map: capture_map,\n-        last_use_map: last_use_map,\n         num_live_nodes: 0,\n         num_vars: 0,\n         live_node_map: HashMap::new(),\n@@ -367,29 +340,6 @@ pub impl IrMaps {\n     fn lnk(&mut self, ln: LiveNode) -> LiveNodeKind {\n         self.lnks[*ln]\n     }\n-\n-    fn add_last_use(&mut self, expr_id: node_id, var: Variable) {\n-        let vk = self.var_kinds[*var];\n-        debug!(\"Node %d is a last use of variable %?\", expr_id, vk);\n-        match vk {\n-            Arg(id, _) |\n-            Local(LocalInfo { id: id, kind: FromLetNoInitializer, _ }) |\n-            Local(LocalInfo { id: id, kind: FromLetWithInitializer, _ }) |\n-            Local(LocalInfo { id: id, kind: FromMatch(_), _ }) => {\n-                let v = match self.last_use_map.find(&expr_id) {\n-                    Some(&v) => v,\n-                    None => {\n-                        let v = @mut ~[];\n-                        self.last_use_map.insert(expr_id, v);\n-                        v\n-                    }\n-                };\n-\n-                v.push(id);\n-            }\n-            ImplicitRet => debug!(\"--but it is not owned\"),\n-        }\n-    }\n }\n \n fn visit_item(item: @item, self: @mut IrMaps, v: vt<@mut IrMaps>) {\n@@ -413,7 +363,6 @@ fn visit_fn(fk: &visit::fn_kind,\n                               self.method_map,\n                               self.variable_moves_map,\n                               self.capture_map,\n-                              self.last_use_map,\n                               self.cur_item);\n \n     unsafe {\n@@ -522,7 +471,7 @@ fn visit_expr(expr: @expr, self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n       expr_path(_) => {\n         let def = *self.tcx.def_map.get(&expr.id);\n         debug!(\"expr %d: path that leads to %?\", expr.id, def);\n-        if relevant_def(def).is_some() {\n+        if moves::moved_variable_node_id_from_def(def).is_some() {\n             self.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         }\n         visit::visit_expr(expr, self, vt);\n@@ -539,7 +488,7 @@ fn visit_expr(expr: @expr, self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n         let cvs = self.capture_map.get(&expr.id);\n         let mut call_caps = ~[];\n         for cvs.each |cv| {\n-            match relevant_def(cv.def) {\n+            match moves::moved_variable_node_id_from_def(cv.def) {\n               Some(rv) => {\n                 let cv_ln = self.add_live_node(FreeVarNode(cv.span));\n                 let is_move = match cv.mode {\n@@ -668,7 +617,7 @@ pub impl Liveness {\n         match expr.node {\n           expr_path(_) => {\n             let def = *self.tcx.def_map.get(&expr.id);\n-            relevant_def(def).map(\n+            moves::moved_variable_node_id_from_def(def).map(\n                 |rdef| self.variable(*rdef, expr.span)\n             )\n           }\n@@ -684,7 +633,7 @@ pub impl Liveness {\n                              span: span) -> Option<Variable> {\n         match self.tcx.def_map.find(&node_id) {\n           Some(&def) => {\n-            relevant_def(def).map(\n+            moves::moved_variable_node_id_from_def(def).map(\n                 |rdef| self.variable(*rdef, span)\n             )\n           }\n@@ -1388,7 +1337,7 @@ pub impl Liveness {\n     fn access_path(&self, expr: @expr, succ: LiveNode, acc: uint)\n                   -> LiveNode {\n         let def = *self.tcx.def_map.get(&expr.id);\n-        match relevant_def(def) {\n+        match moves::moved_variable_node_id_from_def(def) {\n           Some(nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n             if acc != 0u {\n@@ -1521,7 +1470,6 @@ fn check_expr(expr: @expr, self: @Liveness, vt: vt<@Liveness>) {\n       expr_path(_) => {\n         for self.variable_from_def_map(expr.id, expr.span).each |var| {\n             let ln = self.live_node(expr.id, expr.span);\n-            self.consider_last_use(expr, ln, *var);\n \n             match self.ir.variable_moves_map.find(&expr.id) {\n                 None => {}\n@@ -1540,7 +1488,6 @@ fn check_expr(expr: @expr, self: @Liveness, vt: vt<@Liveness>) {\n         let caps = self.ir.captures(expr);\n         for caps.each |cap| {\n             let var = self.variable(cap.var_nid, expr.span);\n-            self.consider_last_use(expr, cap.ln, var);\n             if cap.is_move {\n                 self.check_move_from_var(cap.ln, var, expr);\n             }\n@@ -1609,7 +1556,7 @@ enum ReadKind {\n }\n \n pub impl Liveness {\n-    fn check_ret(@self, id: node_id, sp: span, _fk: &visit::fn_kind,\n+    fn check_ret(&self, id: node_id, sp: span, _fk: &visit::fn_kind,\n                  entry_ln: LiveNode) {\n         if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n             // if no_ret_var is live, then we fall off the end of the\n@@ -1629,11 +1576,11 @@ pub impl Liveness {\n         }\n     }\n \n-    fn check_move_from_var(@self, ln: LiveNode,\n+    fn check_move_from_var(&self,\n+                           ln: LiveNode,\n                            var: Variable,\n                            move_expr: @expr) {\n         /*!\n-         *\n          * Checks whether `var` is live on entry to any of the\n          * successors of `ln`.  If it is, report an error.\n          * `move_expr` is the expression which caused the variable\n@@ -1653,16 +1600,6 @@ pub impl Liveness {\n         }\n     }\n \n-    fn consider_last_use(@self, expr: @expr, ln: LiveNode, var: Variable) {\n-        debug!(\"consider_last_use(expr.id=%?, ln=%s, var=%s)\",\n-               expr.id, ln.to_str(), var.to_str());\n-\n-        match self.live_on_exit(ln, var) {\n-          Some(_) => {}\n-          None => self.ir.add_last_use(expr.id, var)\n-       }\n-    }\n-\n     fn check_lvalue(@self, expr: @expr, vt: vt<@Liveness>) {\n         match expr.node {\n           expr_path(_) => {\n@@ -1679,7 +1616,7 @@ pub impl Liveness {\n                 self.warn_about_dead_assign(expr.span, expr.id, ln, var);\n               }\n               def => {\n-                match relevant_def(def) {\n+                match moves::moved_variable_node_id_from_def(def) {\n                   Some(nid) => {\n                     let ln = self.live_node(expr.id, expr.span);\n                     let var = self.variable(nid, expr.span);\n@@ -1699,14 +1636,14 @@ pub impl Liveness {\n        }\n     }\n \n-    fn check_for_reassignments_in_pat(@self, pat: @pat, mutbl: bool) {\n+    fn check_for_reassignments_in_pat(&self, pat: @pat, mutbl: bool) {\n         do self.pat_bindings(pat) |ln, var, sp, id| {\n             self.check_for_reassignment(ln, var, sp,\n                                         if mutbl {Some(id)} else {None});\n         }\n     }\n \n-    fn check_for_reassignment(@self, ln: LiveNode, var: Variable,\n+    fn check_for_reassignment(&self, ln: LiveNode, var: Variable,\n                               orig_span: span, mutbl: Option<node_id>) {\n         match self.assigned_on_exit(ln, var) {\n           Some(ExprNode(span)) => {\n@@ -1731,7 +1668,7 @@ pub impl Liveness {\n         }\n     }\n \n-    fn report_illegal_move(@self, lnk: LiveNodeKind,\n+    fn report_illegal_move(&self, lnk: LiveNodeKind,\n                            var: Variable,\n                            move_expr: @expr) {\n         // the only time that it is possible to have a moved variable\n@@ -1796,7 +1733,8 @@ pub impl Liveness {\n         };\n     }\n \n-    fn report_move_location(@self, move_expr: @expr,\n+    fn report_move_location(&self,\n+                            move_expr: @expr,\n                             var: Variable,\n                             expr_descr: &str,\n                             pronoun: &str) {\n@@ -1810,7 +1748,8 @@ pub impl Liveness {\n                  ty_to_str(self.tcx, move_expr_ty)));\n     }\n \n-    fn report_illegal_read(@self, chk_span: span,\n+    fn report_illegal_read(&self,\n+                           chk_span: span,\n                            lnk: LiveNodeKind,\n                            var: Variable,\n                            rk: ReadKind) {\n@@ -1841,12 +1780,12 @@ pub impl Liveness {\n         }\n     }\n \n-    fn should_warn(@self, var: Variable) -> Option<@~str> {\n+    fn should_warn(&self, var: Variable) -> Option<@~str> {\n         let name = self.ir.variable_name(var);\n         if name[0] == ('_' as u8) { None } else { Some(name) }\n     }\n \n-    fn warn_about_unused_args(@self, decl: &fn_decl, entry_ln: LiveNode) {\n+    fn warn_about_unused_args(&self, decl: &fn_decl, entry_ln: LiveNode) {\n         for decl.inputs.each |arg| {\n             do pat_util::pat_bindings(self.tcx.def_map, arg.pat)\n                     |_bm, p_id, sp, _n| {\n@@ -1856,15 +1795,15 @@ pub impl Liveness {\n         }\n     }\n \n-    fn warn_about_unused_or_dead_vars_in_pat(@self, pat: @pat) {\n+    fn warn_about_unused_or_dead_vars_in_pat(&self, pat: @pat) {\n         do self.pat_bindings(pat) |ln, var, sp, id| {\n             if !self.warn_about_unused(sp, id, ln, var) {\n                 self.warn_about_dead_assign(sp, id, ln, var);\n             }\n         }\n     }\n \n-    fn warn_about_unused(@self, sp: span, id: node_id,\n+    fn warn_about_unused(&self, sp: span, id: node_id,\n                          ln: LiveNode, var: Variable) -> bool {\n         if !self.used_on_entry(ln, var) {\n             for self.should_warn(var).each |name| {\n@@ -1894,7 +1833,7 @@ pub impl Liveness {\n         return false;\n     }\n \n-    fn warn_about_dead_assign(@self, sp: span, id: node_id,\n+    fn warn_about_dead_assign(&self, sp: span, id: node_id,\n                               ln: LiveNode, var: Variable) {\n         if self.live_on_exit(ln, var).is_none() {\n             for self.should_warn(var).each |name| {"}, {"sha": "f525230664a21e2a04d01ce1dcada8426d7c4489", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 257, "deletions": 289, "changes": 546, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -48,7 +48,7 @@\n \n use middle::ty;\n use middle::typeck;\n-use util::ppaux::{ty_to_str, region_to_str};\n+use util::ppaux::{ty_to_str, region_to_str, Repr};\n use util::common::indenter;\n \n use syntax::ast::{m_imm, m_const, m_mutbl};\n@@ -58,50 +58,48 @@ use syntax::print::pprust;\n \n #[deriving(Eq)]\n pub enum categorization {\n-    cat_rvalue,                     // result of eval'ing some misc expr\n-    cat_special(special_kind),      //\n-    cat_local(ast::node_id),        // local variable\n-    cat_binding(ast::node_id),      // pattern binding\n-    cat_arg(ast::node_id),          // formal argument\n-    cat_stack_upvar(cmt),           // upvar in stack closure\n-    cat_deref(cmt, uint, ptr_kind), // deref of a ptr\n-    cat_comp(cmt, comp_kind),       // adjust to locate an internal component\n-    cat_discr(cmt, ast::node_id),   // match discriminant (see preserve())\n-    cat_self(ast::node_id),         // explicit `self`\n+    cat_rvalue,                        // result of eval'ing some misc expr\n+    cat_static_item,\n+    cat_implicit_self,\n+    cat_copied_upvar(CopiedUpvar),     // upvar copied into @fn or ~fn env\n+    cat_stack_upvar(cmt),              // by ref upvar from &fn\n+    cat_local(ast::node_id),           // local variable\n+    cat_arg(ast::node_id, ast::rmode), // formal argument\n+    cat_deref(cmt, uint, ptr_kind),    // deref of a ptr\n+    cat_interior(cmt, interior_kind),          // something interior\n+    cat_discr(cmt, ast::node_id),      // match discriminant (see preserve())\n+    cat_self(ast::node_id),            // explicit `self`\n+}\n+\n+#[deriving(Eq)]\n+struct CopiedUpvar {\n+    upvar_id: ast::node_id,\n+    onceness: ast::Onceness,\n }\n \n // different kinds of pointers:\n #[deriving(Eq)]\n pub enum ptr_kind {\n-    uniq_ptr,\n+    uniq_ptr(ast::mutability),\n     gc_ptr(ast::mutability),\n     region_ptr(ast::mutability, ty::Region),\n     unsafe_ptr\n }\n \n-// I am coining the term \"components\" to mean \"pieces of a data\n-// structure accessible without a dereference\":\n+// We use the term \"interior\" to mean \"something reachable from the\n+// base without a pointer dereference\", e.g. a field\n #[deriving(Eq)]\n-pub enum comp_kind {\n-    comp_tuple,                  // elt in a tuple\n-    comp_anon_field,             // anonymous field (in e.g.\n+pub enum interior_kind {\n+    interior_tuple,                  // elt in a tuple\n+    interior_anon_field,             // anonymous field (in e.g.\n                                  // struct Foo(int, int);\n-    comp_variant(ast::def_id),   // internals to a variant of given enum\n-    comp_field(ast::ident,       // name of field\n+    interior_variant(ast::def_id),   // internals to a variant of given enum\n+    interior_field(ast::ident,       // name of field\n                ast::mutability), // declared mutability of field\n-    comp_index(ty::t,            // type of vec/str/etc being deref'd\n+    interior_index(ty::t,            // type of vec/str/etc being deref'd\n                ast::mutability)  // mutability of vec content\n }\n \n-// different kinds of expressions we might evaluate\n-#[deriving(Eq)]\n-pub enum special_kind {\n-    sk_method,\n-    sk_static_item,\n-    sk_implicit_self,   // old by-reference `self`\n-    sk_heap_upvar\n-}\n-\n #[deriving(Eq)]\n pub enum MutabilityCategory {\n     McImmutable, // Immutable.\n@@ -120,39 +118,29 @@ pub struct cmt_ {\n     id: ast::node_id,          // id of expr/pat producing this value\n     span: span,                // span of same expr/pat\n     cat: categorization,       // categorization of expr\n-    lp: Option<@loan_path>,    // loan path for expr, if any\n     mutbl: MutabilityCategory, // mutability of expr as lvalue\n     ty: ty::t                  // type of the expr\n }\n \n pub type cmt = @cmt_;\n \n-// a loan path is like a category, but it exists only when the data is\n-// interior to the stack frame.  loan paths are used as the key to a\n-// map indicating what is borrowed at any point in time.\n-#[deriving(Eq)]\n-pub enum loan_path {\n-    lp_local(ast::node_id),\n-    lp_arg(ast::node_id),\n-    lp_self,\n-    lp_deref(@loan_path, ptr_kind),\n-    lp_comp(@loan_path, comp_kind)\n-}\n-\n // We pun on *T to mean both actual deref of a ptr as well\n // as accessing of components:\n-pub enum deref_kind {deref_ptr(ptr_kind), deref_comp(comp_kind)}\n+pub enum deref_kind {deref_ptr(ptr_kind), deref_interior(interior_kind)}\n \n // Categorizes a derefable type.  Note that we include vectors and strings as\n // derefable (we model an index as the combination of a deref and then a\n // pointer adjustment).\n pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n     match ty::get(t).sty {\n-        ty::ty_uniq(*) |\n+        ty::ty_uniq(mt) => {\n+            Some(deref_ptr(uniq_ptr(mt.mutbl)))\n+        }\n+\n         ty::ty_evec(_, ty::vstore_uniq) |\n         ty::ty_estr(ty::vstore_uniq) |\n         ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, _}) => {\n-            Some(deref_ptr(uniq_ptr))\n+            Some(deref_ptr(uniq_ptr(m_imm)))\n         }\n \n         ty::ty_rptr(r, mt) |\n@@ -181,19 +169,19 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n         }\n \n         ty::ty_enum(did, _) => {\n-            Some(deref_comp(comp_variant(did)))\n+            Some(deref_interior(interior_variant(did)))\n         }\n \n         ty::ty_struct(_, _) => {\n-            Some(deref_comp(comp_anon_field))\n+            Some(deref_interior(interior_anon_field))\n         }\n \n         ty::ty_evec(mt, ty::vstore_fixed(_)) => {\n-            Some(deref_comp(comp_index(t, mt.mutbl)))\n+            Some(deref_interior(interior_index(t, mt.mutbl)))\n         }\n \n         ty::ty_estr(ty::vstore_fixed(_)) => {\n-            Some(deref_comp(comp_index(t, m_imm)))\n+            Some(deref_interior(interior_index(t, m_imm)))\n         }\n \n         _ => None\n@@ -338,21 +326,11 @@ pub impl MutabilityCategory {\n         }\n     }\n \n-    fn to_user_str(&self) -> ~str {\n+    fn to_user_str(&self) -> &'static str {\n         match *self {\n-            McDeclared | McInherited => ~\"mutable\",\n-            McImmutable => ~\"immutable\",\n-            McReadOnly => ~\"const\"\n-        }\n-    }\n-}\n-\n-pub impl loan_path {\n-    fn node_id(&self) -> Option<ast::node_id> {\n-        match *self {\n-            lp_local(id) | lp_arg(id) => Some(id),\n-            lp_deref(lp, _) | lp_comp(lp, _) => lp.node_id(),\n-            lp_self => None\n+            McDeclared | McInherited => \"mutable\",\n+            McImmutable => \"immutable\",\n+            McReadOnly => \"const\"\n         }\n     }\n }\n@@ -419,9 +397,9 @@ pub impl mem_categorization_ctxt {\n           }\n \n           ast::expr_field(base, f_name, _) => {\n-            if self.method_map.contains_key(&expr.id) {\n-                return self.cat_method_ref(expr, expr_ty);\n-            }\n+            // Method calls are now a special syntactic form,\n+            // so `a.b` should always be a field.\n+            assert!(!self.method_map.contains_key(&expr.id));\n \n             let base_cmt = self.cat_expr(base);\n             self.cat_field(expr, base_cmt, f_name, expr.id)\n@@ -475,8 +453,7 @@ pub impl mem_categorization_ctxt {\n             @cmt_ {\n                 id:id,\n                 span:span,\n-                cat:cat_special(sk_static_item),\n-                lp:None,\n+                cat:cat_static_item,\n                 mutbl: McImmutable,\n                 ty:expr_ty\n             }\n@@ -487,66 +464,71 @@ pub impl mem_categorization_ctxt {\n             // stuff as `&const` and `&mut`?\n \n             // m: mutability of the argument\n-            // lp: loan path, must be none for aliasable things\n             let m = if mutbl {McDeclared} else {McImmutable};\n-            let lp = Some(@lp_arg(vid));\n+            let mode = ty::resolved_mode(self.tcx, mode);\n             @cmt_ {\n-                id:id,\n-                span:span,\n-                cat:cat_arg(vid),\n-                lp:lp,\n+                id: id,\n+                span: span,\n+                cat: cat_arg(vid, mode),\n                 mutbl: m,\n                 ty:expr_ty\n             }\n           }\n \n           ast::def_self(self_id, is_implicit) => {\n-            let cat, loan_path;\n-            if is_implicit {\n-                cat = cat_special(sk_implicit_self);\n-                loan_path = None;\n+            let cat = if is_implicit {\n+                cat_implicit_self\n             } else {\n-                cat = cat_self(self_id);\n-                loan_path = Some(@lp_self);\n+                cat_self(self_id)\n             };\n \n             @cmt_ {\n                 id:id,\n                 span:span,\n                 cat:cat,\n-                lp:loan_path,\n                 mutbl: McImmutable,\n                 ty:expr_ty\n             }\n           }\n \n-          ast::def_upvar(_, inner, fn_node_id, _) => {\n-            let ty = ty::node_id_to_type(self.tcx, fn_node_id);\n-            let sigil = ty::ty_closure_sigil(ty);\n-            match sigil {\n-                ast::BorrowedSigil => {\n-                    let upcmt = self.cat_def(id, span, expr_ty, *inner);\n-                    @cmt_ {\n-                        id:id,\n-                        span:span,\n-                        cat:cat_stack_upvar(upcmt),\n-                        lp:upcmt.lp,\n-                        mutbl:upcmt.mutbl,\n-                        ty:upcmt.ty\n-                    }\n-                }\n-                ast::OwnedSigil | ast::ManagedSigil => {\n-                    // FIXME #2152 allow mutation of moved upvars\n-                    @cmt_ {\n-                        id:id,\n-                        span:span,\n-                        cat:cat_special(sk_heap_upvar),\n-                        lp:None,\n-                        mutbl:McImmutable,\n-                        ty:expr_ty\n-                    }\n-                }\n-            }\n+          ast::def_upvar(upvar_id, inner, fn_node_id, _) => {\n+              let ty = ty::node_id_to_type(self.tcx, fn_node_id);\n+              match ty::get(ty).sty {\n+                  ty::ty_closure(ref closure_ty) => {\n+                      let sigil = closure_ty.sigil;\n+                      match sigil {\n+                          ast::BorrowedSigil => {\n+                              let upvar_cmt =\n+                                  self.cat_def(id, span, expr_ty, *inner);\n+                              @cmt_ {\n+                                  id:id,\n+                                  span:span,\n+                                  cat:cat_stack_upvar(upvar_cmt),\n+                                  mutbl:upvar_cmt.mutbl.inherit(),\n+                                  ty:upvar_cmt.ty\n+                              }\n+                          }\n+                          ast::OwnedSigil | ast::ManagedSigil => {\n+                              // FIXME #2152 allow mutation of moved upvars\n+                              @cmt_ {\n+                                  id:id,\n+                                  span:span,\n+                                  cat:cat_copied_upvar(CopiedUpvar {\n+                                      upvar_id: upvar_id,\n+                                      onceness: closure_ty.onceness}),\n+                                  mutbl:McImmutable,\n+                                  ty:expr_ty\n+                              }\n+                          }\n+                      }\n+                  }\n+                  _ => {\n+                      self.tcx.sess.span_bug(\n+                          span,\n+                          fmt!(\"Upvar of non-closure %? - %s\",\n+                               fn_node_id, ty.repr(self.tcx)));\n+                  }\n+              }\n           }\n \n           ast::def_local(vid, mutbl) => {\n@@ -555,7 +537,6 @@ pub impl mem_categorization_ctxt {\n                 id:id,\n                 span:span,\n                 cat:cat_local(vid),\n-                lp:Some(@lp_local(vid)),\n                 mutbl:m,\n                 ty:expr_ty\n             }\n@@ -567,7 +548,6 @@ pub impl mem_categorization_ctxt {\n                 id:id,\n                 span:span,\n                 cat:cat_local(vid),\n-                lp:Some(@lp_local(vid)),\n                 mutbl:McImmutable,\n                 ty:expr_ty\n             }\n@@ -582,8 +562,7 @@ pub impl mem_categorization_ctxt {\n         @cmt_ {\n             id: arg.id(),\n             span: arg.span(),\n-            cat: cat_comp(cmt, comp_variant(enum_did)),\n-            lp: cmt.lp.map(|l| @lp_comp(*l, comp_variant(enum_did)) ),\n+            cat: cat_interior(cmt, interior_variant(enum_did)),\n             mutbl: cmt.mutbl.inherit(),\n             ty: self.tcx.ty(arg)\n         }\n@@ -594,7 +573,6 @@ pub impl mem_categorization_ctxt {\n             id:elt.id(),\n             span:elt.span(),\n             cat:cat_rvalue,\n-            lp:None,\n             mutbl:McImmutable,\n             ty:expr_ty\n         }\n@@ -606,9 +584,9 @@ pub impl mem_categorization_ctxt {\n     /// or if the container is mutable.\n     fn inherited_mutability(&self,\n                             base_m: MutabilityCategory,\n-                            comp_m: ast::mutability) -> MutabilityCategory\n+                            interior_m: ast::mutability) -> MutabilityCategory\n     {\n-        match comp_m {\n+        match interior_m {\n             m_imm => base_m.inherit(),\n             m_const => McReadOnly,\n             m_mutbl => McDeclared\n@@ -634,13 +612,11 @@ pub impl mem_categorization_ctxt {\n             }\n         };\n         let m = self.inherited_mutability(base_cmt.mutbl, f_mutbl);\n-        let f_comp = comp_field(f_name, f_mutbl);\n-        let lp = base_cmt.lp.map(|lp| @lp_comp(*lp, f_comp) );\n+        let f_interior = interior_field(f_name, f_mutbl);\n         @cmt_ {\n             id: node.id(),\n             span: node.span(),\n-            cat: cat_comp(base_cmt, f_comp),\n-            lp:lp,\n+            cat: cat_interior(base_cmt, f_interior),\n             mutbl: m,\n             ty: self.tcx.ty(node)\n         }\n@@ -688,25 +664,10 @@ pub impl mem_categorization_ctxt {\n     {\n         match deref_kind(self.tcx, base_cmt.ty) {\n             deref_ptr(ptr) => {\n-                let lp = do base_cmt.lp.chain_ref |l| {\n-                    // Given that the ptr itself is loanable, we can\n-                    // loan out deref'd uniq ptrs or mut ptrs as the data\n-                    // they are the only way to mutably reach the data they\n-                    // point at. Other ptr types admit mutable aliases and\n-                    // are therefore not loanable.\n-                    match ptr {\n-                        uniq_ptr => Some(@lp_deref(*l, ptr)),\n-                        region_ptr(ast::m_mutbl, _) => {\n-                            Some(@lp_deref(*l, ptr))\n-                        }\n-                        gc_ptr(*) | region_ptr(_, _) | unsafe_ptr => None\n-                    }\n-                };\n-\n                 // for unique ptrs, we inherit mutability from the\n                 // owning reference.\n                 let m = match ptr {\n-                    uniq_ptr => {\n+                    uniq_ptr(*) => {\n                         self.inherited_mutability(base_cmt.mutbl, mt.mutbl)\n                     }\n                     gc_ptr(*) | region_ptr(_, _) | unsafe_ptr => {\n@@ -718,20 +679,17 @@ pub impl mem_categorization_ctxt {\n                     id:node.id(),\n                     span:node.span(),\n                     cat:cat_deref(base_cmt, deref_cnt, ptr),\n-                    lp:lp,\n                     mutbl:m,\n                     ty:mt.ty\n                 }\n             }\n \n-            deref_comp(comp) => {\n-                let lp = base_cmt.lp.map(|l| @lp_comp(*l, comp) );\n+            deref_interior(interior) => {\n                 let m = self.inherited_mutability(base_cmt.mutbl, mt.mutbl);\n                 @cmt_ {\n                     id:node.id(),\n                     span:node.span(),\n-                    cat:cat_comp(base_cmt, comp),\n-                    lp:lp,\n+                    cat:cat_interior(base_cmt, interior),\n                     mutbl:m,\n                     ty:mt.ty\n                 }\n@@ -754,55 +712,45 @@ pub impl mem_categorization_ctxt {\n \n         return match deref_kind(self.tcx, base_cmt.ty) {\n           deref_ptr(ptr) => {\n-            // (a) the contents are loanable if the base is loanable\n-            // and this is a *unique* vector\n-            let deref_lp = match ptr {\n-              uniq_ptr => {base_cmt.lp.map(|lp| @lp_deref(*lp, uniq_ptr))}\n-              _ => {None}\n-            };\n-\n-            // (b) for unique ptrs, we inherit mutability from the\n+            // for unique ptrs, we inherit mutability from the\n             // owning reference.\n             let m = match ptr {\n-              uniq_ptr => {\n+              uniq_ptr(*) => {\n                 self.inherited_mutability(base_cmt.mutbl, mt.mutbl)\n               }\n               gc_ptr(_) | region_ptr(_, _) | unsafe_ptr => {\n                 MutabilityCategory::from_mutbl(mt.mutbl)\n               }\n             };\n \n-            // (c) the deref is explicit in the resulting cmt\n+            // the deref is explicit in the resulting cmt\n             let deref_cmt = @cmt_ {\n                 id:elt.id(),\n                 span:elt.span(),\n                 cat:cat_deref(base_cmt, 0u, ptr),\n-                lp:deref_lp,\n                 mutbl:m,\n                 ty:mt.ty\n             };\n \n-            comp(elt, deref_cmt, base_cmt.ty, m, mt)\n+            interior(elt, deref_cmt, base_cmt.ty, m, mt)\n           }\n \n-          deref_comp(_) => {\n+          deref_interior(_) => {\n             // fixed-length vectors have no deref\n             let m = self.inherited_mutability(base_cmt.mutbl, mt.mutbl);\n-            comp(elt, base_cmt, base_cmt.ty, m, mt)\n+            interior(elt, base_cmt, base_cmt.ty, m, mt)\n           }\n         };\n \n-        fn comp<N:ast_node>(elt: N, of_cmt: cmt,\n-                             vect: ty::t, mutbl: MutabilityCategory,\n-                             mt: ty::mt) -> cmt\n+        fn interior<N: ast_node>(elt: N, of_cmt: cmt,\n+                                 vect: ty::t, mutbl: MutabilityCategory,\n+                                 mt: ty::mt) -> cmt\n         {\n-            let comp = comp_index(vect, mt.mutbl);\n-            let index_lp = of_cmt.lp.map(|lp| @lp_comp(*lp, comp) );\n+            let interior = interior_index(vect, mt.mutbl);\n             @cmt_ {\n                 id:elt.id(),\n                 span:elt.span(),\n-                cat:cat_comp(of_cmt, comp),\n-                lp:index_lp,\n+                cat:cat_interior(of_cmt, interior),\n                 mutbl:mutbl,\n                 ty:mt.ty\n             }\n@@ -815,8 +763,7 @@ pub impl mem_categorization_ctxt {\n         @cmt_ {\n             id: elt.id(),\n             span: elt.span(),\n-            cat: cat_comp(cmt, comp_tuple),\n-            lp: cmt.lp.map(|l| @lp_comp(*l, comp_tuple) ),\n+            cat: cat_interior(cmt, interior_tuple),\n             mutbl: cmt.mutbl.inherit(),\n             ty: self.tcx.ty(elt)\n         }\n@@ -828,26 +775,12 @@ pub impl mem_categorization_ctxt {\n         @cmt_ {\n             id: elt.id(),\n             span: elt.span(),\n-            cat: cat_comp(cmt, comp_anon_field),\n-            lp: cmt.lp.map(|l| @lp_comp(*l, comp_anon_field)),\n+            cat: cat_interior(cmt, interior_anon_field),\n             mutbl: cmt.mutbl.inherit(),\n             ty: self.tcx.ty(elt)\n         }\n     }\n \n-    fn cat_method_ref(&self,\n-                      expr: @ast::expr,\n-                      expr_ty: ty::t) -> cmt {\n-        @cmt_ {\n-            id:expr.id,\n-            span:expr.span,\n-            cat:cat_special(sk_method),\n-            lp:None,\n-            mutbl:McImmutable,\n-            ty:expr_ty\n-        }\n-    }\n-\n     fn cat_pattern(&self,\n                    cmt: cmt,\n                    pat: @ast::pat,\n@@ -890,7 +823,7 @@ pub impl mem_categorization_ctxt {\n         let tcx = self.tcx;\n         debug!(\"cat_pattern: id=%d pat=%s cmt=%s\",\n                pat.id, pprust::pat_to_str(pat, tcx.sess.intr()),\n-               self.cmt_to_repr(cmt));\n+               cmt.repr(tcx));\n         let _i = indenter();\n \n         op(cmt, pat);\n@@ -986,29 +919,6 @@ pub impl mem_categorization_ctxt {\n         }\n     }\n \n-    fn cat_to_repr(&self, cat: categorization) -> ~str {\n-        match cat {\n-          cat_special(sk_method) => ~\"method\",\n-          cat_special(sk_static_item) => ~\"static_item\",\n-          cat_special(sk_implicit_self) => ~\"implicit-self\",\n-          cat_special(sk_heap_upvar) => ~\"heap-upvar\",\n-          cat_stack_upvar(_) => ~\"stack-upvar\",\n-          cat_rvalue => ~\"rvalue\",\n-          cat_local(node_id) => fmt!(\"local(%d)\", node_id),\n-          cat_binding(node_id) => fmt!(\"binding(%d)\", node_id),\n-          cat_arg(node_id) => fmt!(\"arg(%d)\", node_id),\n-          cat_self(node_id) => fmt!(\"self(%d)\", node_id),\n-          cat_deref(cmt, derefs, ptr) => {\n-            fmt!(\"%s->(%s, %u)\", self.cat_to_repr(cmt.cat),\n-                 self.ptr_sigil(ptr), derefs)\n-          }\n-          cat_comp(cmt, comp) => {\n-            fmt!(\"%s.%s\", self.cat_to_repr(cmt.cat), *self.comp_to_repr(comp))\n-          }\n-          cat_discr(cmt, _) => self.cat_to_repr(cmt.cat)\n-        }\n-    }\n-\n     fn mut_to_str(&self, mutbl: ast::mutability) -> ~str {\n         match mutbl {\n           m_mutbl => ~\"mutable\",\n@@ -1017,84 +927,33 @@ pub impl mem_categorization_ctxt {\n         }\n     }\n \n-    fn ptr_sigil(&self, ptr: ptr_kind) -> ~str {\n-        match ptr {\n-          uniq_ptr => ~\"~\",\n-          gc_ptr(_) => ~\"@\",\n-          region_ptr(_, _) => ~\"&\",\n-          unsafe_ptr => ~\"*\"\n-        }\n-    }\n-\n-    fn comp_to_repr(&self, comp: comp_kind) -> @~str {\n-        match comp {\n-          comp_field(fld, _) => self.tcx.sess.str_of(fld),\n-          comp_index(*) => @~\"[]\",\n-          comp_tuple => @~\"()\",\n-          comp_anon_field => @~\"<anonymous field>\",\n-          comp_variant(_) => @~\"<enum>\"\n-        }\n-    }\n-\n-    fn lp_to_str(&self, lp: @loan_path) -> ~str {\n-        match *lp {\n-          lp_local(node_id) => {\n-            fmt!(\"local(%d)\", node_id)\n-          }\n-          lp_arg(node_id) => {\n-            fmt!(\"arg(%d)\", node_id)\n-          }\n-          lp_self => ~\"self\",\n-          lp_deref(lp, ptr) => {\n-            fmt!(\"%s->(%s)\", self.lp_to_str(lp),\n-                 self.ptr_sigil(ptr))\n-          }\n-          lp_comp(lp, comp) => {\n-            fmt!(\"%s.%s\", self.lp_to_str(lp),\n-                 *self.comp_to_repr(comp))\n-          }\n-        }\n-    }\n-\n-    fn cmt_to_repr(&self, cmt: cmt) -> ~str {\n-        fmt!(\"{%s id:%d m:%? lp:%s ty:%s}\",\n-             self.cat_to_repr(cmt.cat),\n-             cmt.id,\n-             cmt.mutbl,\n-             cmt.lp.map_default(~\"none\", |p| self.lp_to_str(*p) ),\n-             ty_to_str(self.tcx, cmt.ty))\n-    }\n-\n     fn cmt_to_str(&self, cmt: cmt) -> ~str {\n-        let mut_str = cmt.mutbl.to_user_str();\n         match cmt.cat {\n-          cat_special(sk_method) => ~\"method\",\n-          cat_special(sk_static_item) => ~\"static item\",\n-          cat_special(sk_implicit_self) => ~\"self reference\",\n-          cat_special(sk_heap_upvar) => {\n+          cat_static_item => ~\"static item\",\n+          cat_implicit_self => ~\"self reference\",\n+          cat_copied_upvar(_) => {\n               ~\"captured outer variable in a heap closure\"\n           }\n           cat_rvalue => ~\"non-lvalue\",\n-          cat_local(_) => mut_str + ~\" local variable\",\n-          cat_binding(_) => ~\"pattern binding\",\n+          cat_local(_) => ~\"local variable\",\n           cat_self(_) => ~\"self value\",\n-          cat_arg(_) => ~\"argument\",\n-          cat_deref(_, _, pk) => fmt!(\"dereference of %s %s pointer\",\n-                                      mut_str, self.ptr_sigil(pk)),\n-          cat_stack_upvar(_) => {\n-            ~\"captured outer \" + mut_str + ~\" variable in a stack closure\"\n-          }\n-          cat_comp(_, comp_field(*)) => mut_str + ~\" field\",\n-          cat_comp(_, comp_tuple) => ~\"tuple content\",\n-          cat_comp(_, comp_anon_field) => ~\"anonymous field\",\n-          cat_comp(_, comp_variant(_)) => ~\"enum content\",\n-          cat_comp(_, comp_index(t, _)) => {\n+          cat_arg(*) => ~\"argument\",\n+          cat_deref(_, _, pk) => fmt!(\"dereference of %s pointer\",\n+                                      ptr_sigil(pk)),\n+          cat_interior(_, interior_field(*)) => ~\"field\",\n+          cat_interior(_, interior_tuple) => ~\"tuple content\",\n+          cat_interior(_, interior_anon_field) => ~\"anonymous field\",\n+          cat_interior(_, interior_variant(_)) => ~\"enum content\",\n+          cat_interior(_, interior_index(t, _)) => {\n             match ty::get(t).sty {\n-              ty::ty_evec(*) => mut_str + ~\" vec content\",\n-              ty::ty_estr(*) => mut_str + ~\" str content\",\n-              _ => mut_str + ~\" indexed content\"\n+              ty::ty_evec(*) => ~\"vec content\",\n+              ty::ty_estr(*) => ~\"str content\",\n+              _ => ~\"indexed content\"\n             }\n           }\n+          cat_stack_upvar(_) => {\n+              ~\"captured outer variable\"\n+          }\n           cat_discr(cmt, _) => {\n             self.cmt_to_str(cmt)\n           }\n@@ -1149,33 +1008,142 @@ pub fn field_mutbl(tcx: ty::ctxt,\n     return None;\n }\n \n-pub impl categorization {\n-    fn derefs_through_mutable_box(&const self) -> bool {\n-        match *self {\n-            cat_deref(_, _, gc_ptr(ast::m_mutbl)) => {\n-                true\n+pub enum AliasableReason {\n+    AliasableManaged(ast::mutability),\n+    AliasableBorrowed(ast::mutability),\n+    AliasableOther\n+}\n+\n+pub impl cmt_ {\n+    fn guarantor(@self) -> cmt {\n+        //! Returns `self` after stripping away any owned pointer derefs or\n+        //! interior content. The return value is basically the `cmt` which\n+        //! determines how long the value in `self` remains live.\n+\n+        match self.cat {\n+            cat_rvalue |\n+            cat_static_item |\n+            cat_implicit_self |\n+            cat_copied_upvar(*) |\n+            cat_local(*) |\n+            cat_self(*) |\n+            cat_arg(*) |\n+            cat_deref(_, _, unsafe_ptr(*)) |\n+            cat_deref(_, _, gc_ptr(*)) |\n+            cat_deref(_, _, region_ptr(*)) => {\n+                self\n             }\n-            cat_deref(subcmt, _, _) |\n-            cat_comp(subcmt, _) |\n-            cat_discr(subcmt, _) |\n-            cat_stack_upvar(subcmt) => {\n-                subcmt.cat.derefs_through_mutable_box()\n+            cat_stack_upvar(b) |\n+            cat_discr(b, _) |\n+            cat_interior(b, _) |\n+            cat_deref(b, _, uniq_ptr(*)) => {\n+                b.guarantor()\n             }\n+        }\n+    }\n+\n+    fn is_freely_aliasable(&self) -> bool {\n+        self.freely_aliasable().is_some()\n+    }\n+\n+    fn freely_aliasable(&self) -> Option<AliasableReason> {\n+        //! True if this lvalue resides in an area that is\n+        //! freely aliasable, meaning that rustc cannot track\n+        //! the alias//es with precision.\n+\n+        // Maybe non-obvious: copied upvars can only be considered\n+        // non-aliasable in once closures, since any other kind can be\n+        // aliased and eventually recused.\n+\n+        match self.cat {\n+            cat_copied_upvar(CopiedUpvar {onceness: ast::Once, _}) |\n+            cat_rvalue(*) |\n+            cat_local(*) |\n+            cat_arg(_, ast::by_copy) |\n+            cat_self(*) |\n+            cat_deref(_, _, unsafe_ptr(*)) | // of course it is aliasable, but...\n+            cat_deref(_, _, region_ptr(m_mutbl, _)) => {\n+                None\n+            }\n+\n+            cat_copied_upvar(CopiedUpvar {onceness: ast::Many, _}) |\n+            cat_static_item(*) |\n+            cat_implicit_self(*) |\n+            cat_arg(_, ast::by_ref) => {\n+                Some(AliasableOther)\n+            }\n+\n+            cat_deref(_, _, gc_ptr(m)) => {\n+                Some(AliasableManaged(m))\n+            }\n+\n+            cat_deref(_, _, region_ptr(m @ m_const, _)) |\n+            cat_deref(_, _, region_ptr(m @ m_imm, _)) => {\n+                Some(AliasableBorrowed(m))\n+            }\n+\n+            cat_stack_upvar(b) |\n+            cat_deref(b, _, uniq_ptr(*)) |\n+            cat_interior(b, _) |\n+            cat_discr(b, _) => {\n+                b.freely_aliasable()\n+            }\n+        }\n+    }\n+}\n+\n+impl Repr for cmt {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        fmt!(\"{%s id:%d m:%? ty:%s}\",\n+             self.cat.repr(tcx),\n+             self.id,\n+             self.mutbl,\n+             self.ty.repr(tcx))\n+    }\n+}\n+\n+impl Repr for categorization {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        match *self {\n+            cat_static_item |\n+            cat_implicit_self |\n             cat_rvalue |\n-            cat_special(*) |\n+            cat_copied_upvar(*) |\n             cat_local(*) |\n-            cat_binding(*) |\n-            cat_arg(*) |\n-            cat_self(*) => {\n-                false\n+            cat_self(*) |\n+            cat_arg(*) => fmt!(\"%?\", *self),\n+            cat_deref(cmt, derefs, ptr) => {\n+                fmt!(\"%s->(%s, %u)\", cmt.cat.repr(tcx),\n+                     ptr_sigil(ptr), derefs)\n+            }\n+            cat_interior(cmt, interior) => {\n+                fmt!(\"%s.%s\",\n+                     cmt.cat.repr(tcx),\n+                     interior.repr(tcx))\n             }\n+            cat_stack_upvar(cmt) |\n+            cat_discr(cmt, _) => cmt.cat.repr(tcx)\n         }\n     }\n+}\n+\n+pub fn ptr_sigil(ptr: ptr_kind) -> ~str {\n+    match ptr {\n+        uniq_ptr(_) => ~\"~\",\n+        gc_ptr(_) => ~\"@\",\n+        region_ptr(_, _) => ~\"&\",\n+        unsafe_ptr => ~\"*\"\n+    }\n+}\n \n-    fn is_mutable_box(&const self) -> bool {\n+impl Repr for interior_kind {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {\n-            cat_deref(_, _, gc_ptr(ast::m_mutbl)) => true,\n-            _ => false\n+            interior_field(fld, _) => copy *tcx.sess.str_of(fld),\n+            interior_index(*) => ~\"[]\",\n+            interior_tuple => ~\"()\",\n+            interior_anon_field => ~\"<anonymous field>\",\n+            interior_variant(_) => ~\"<enum>\"\n         }\n     }\n }"}, {"sha": "d8a0e6bacf4896a6dc43660db5af36467b7c7329", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -246,10 +246,19 @@ pub type MovesMap = @mut HashSet<node_id>;\n  * expression */\n pub type VariableMovesMap = @mut HashMap<node_id, @expr>;\n \n+/**\n+ * Set of variable node-ids that are moved.\n+ *\n+ * Note: The `VariableMovesMap` stores expression ids that\n+ * are moves, whereas this set stores the ids of the variables\n+ * that are moved at some point */\n+pub type MovedVariablesSet = @mut HashSet<node_id>;\n+\n /** See the section Output on the module comment for explanation. */\n pub struct MoveMaps {\n     moves_map: MovesMap,\n     variable_moves_map: VariableMovesMap,\n+    moved_variables_set: MovedVariablesSet,\n     capture_map: CaptureMap\n }\n \n@@ -279,13 +288,25 @@ pub fn compute_moves(tcx: ty::ctxt,\n         move_maps: MoveMaps {\n             moves_map: @mut HashSet::new(),\n             variable_moves_map: @mut HashMap::new(),\n-            capture_map: @mut HashMap::new()\n+            capture_map: @mut HashMap::new(),\n+            moved_variables_set: @mut HashSet::new()\n         }\n     };\n     visit::visit_crate(crate, visit_cx, visitor);\n     return visit_cx.move_maps;\n }\n \n+pub fn moved_variable_node_id_from_def(def: def) -> Option<node_id> {\n+    match def {\n+      def_binding(nid, _) |\n+      def_arg(nid, _, _) |\n+      def_local(nid, _) |\n+      def_self(nid, _) => Some(nid),\n+\n+      _ => None\n+    }\n+}\n+\n // ______________________________________________________________________\n // Expressions\n \n@@ -419,6 +440,11 @@ pub impl VisitContext {\n                     MoveInPart(entire_expr) => {\n                         self.move_maps.variable_moves_map.insert(\n                             expr.id, entire_expr);\n+\n+                        let def = *self.tcx.def_map.get(&expr.id);\n+                        for moved_variable_node_id_from_def(def).each |&id| {\n+                            self.move_maps.moved_variables_set.insert(id);\n+                        }\n                     }\n                     Read => {}\n                     MoveInWhole => {"}, {"sha": "ea21ab0527b4de8ac61e2695587e526255cede6b", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 164, "deletions": 154, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -47,59 +47,27 @@ The region maps encode information about region relationships.\n   - the free region map is populated during type check as we check\n     each function. See the function `relate_free_regions` for\n     more information.\n+- `cleanup_scopes` includes scopes where trans cleanups occur\n+  - this is intended to reflect the current state of trans, not\n+    necessarily how I think things ought to work\n */\n pub struct RegionMaps {\n     priv scope_map: HashMap<ast::node_id, ast::node_id>,\n     priv free_region_map: HashMap<FreeRegion, ~[FreeRegion]>,\n+    priv cleanup_scopes: HashSet<ast::node_id>\n }\n \n-pub struct ctxt {\n+pub struct Context {\n     sess: Session,\n     def_map: resolve::DefMap,\n \n     // Generated maps:\n     region_maps: @mut RegionMaps,\n \n-    // Generally speaking, expressions are parented to their innermost\n-    // enclosing block. But some kinds of expressions serve as\n-    // parents: calls, methods, etc.  In addition, some expressions\n-    // serve as parents by virtue of where they appear.  For example,\n-    // the condition in a while loop is always a parent.  In those\n-    // cases, we add the node id of such an expression to this set so\n-    // that when we visit it we can view it as a parent.\n-    root_exprs: @mut HashSet<ast::node_id>,\n-\n-    // The parent scope is the innermost block, statement, call, or match\n-    // expression during the execution of which the current expression\n-    // will be evaluated.  Generally speaking, the innermost parent\n-    // scope is also the closest suitable ancestor in the AST tree.\n-    //\n-    // There is a subtle point concerning call arguments.  Imagine\n-    // you have a call:\n-    //\n-    // { // block a\n-    //     foo( // call b\n-    //        x,\n-    //        y);\n-    // }\n-    //\n-    // In what lifetime are the expressions `x` and `y` evaluated?  At\n-    // first, I imagine the answer was the block `a`, as the arguments\n-    // are evaluated before the call takes place.  But this turns out\n-    // to be wrong.  The lifetime of the call must encompass the\n-    // argument evaluation as well.\n-    //\n-    // The reason is that evaluation of an earlier argument could\n-    // create a borrow which exists during the evaluation of later\n-    // arguments.  Consider this torture test, for example,\n-    //\n-    // fn test1(x: @mut ~int) {\n-    //     foo(&**x, *x = ~5);\n-    // }\n-    //\n-    // Here, the first argument `&**x` will be a borrow of the `~int`,\n-    // but the second argument overwrites that very value! Bad.\n-    // (This test is borrowck-pure-scope-in-call.rs, btw)\n+    // Scope where variables should be parented to\n+    var_parent: parent,\n+\n+    // Innermost enclosing expression\n     parent: parent,\n }\n \n@@ -128,10 +96,22 @@ pub impl RegionMaps {\n                      sup: ast::node_id)\n     {\n         debug!(\"record_parent(sub=%?, sup=%?)\", sub, sup);\n+        assert!(sub != sup);\n \n         self.scope_map.insert(sub, sup);\n     }\n \n+    pub fn record_cleanup_scope(&mut self,\n+                                scope_id: ast::node_id)\n+    {\n+        //! Records that a scope is a CLEANUP SCOPE.  This is invoked\n+        //! from within regionck.  We wait until regionck because we do\n+        //! not know which operators are overloaded until that point,\n+        //! and only overloaded operators result in cleanup scopes.\n+\n+        self.cleanup_scopes.insert(scope_id);\n+    }\n+\n     fn opt_encl_scope(&self,\n                       id: ast::node_id) -> Option<ast::node_id>\n     {\n@@ -151,6 +131,22 @@ pub impl RegionMaps {\n         }\n     }\n \n+    fn is_cleanup_scope(&self, scope_id: ast::node_id) -> bool {\n+        self.cleanup_scopes.contains(&scope_id)\n+    }\n+\n+    fn cleanup_scope(&self,\n+                     expr_id: ast::node_id) -> ast::node_id\n+    {\n+        //! Returns the scope when temps in expr will be cleaned up\n+\n+        let mut id = self.encl_scope(expr_id);\n+        while !self.cleanup_scopes.contains(&id) {\n+            id = self.encl_scope(id);\n+        }\n+        return id;\n+    }\n+\n     fn encl_region(&self,\n                    id: ast::node_id) -> ty::Region\n     {\n@@ -159,22 +155,38 @@ pub impl RegionMaps {\n         ty::re_scope(self.encl_scope(id))\n     }\n \n-    fn is_sub_scope(&self,\n-                    sub_scope: ast::node_id,\n-                    superscope: ast::node_id) -> bool\n+    pub fn scopes_intersect(&self,\n+                            scope1: ast::node_id,\n+                            scope2: ast::node_id) -> bool\n+    {\n+        self.is_subscope_of(scope1, scope2) || self.is_subscope_of(scope2, scope1)\n+    }\n+\n+    fn is_subscope_of(&self,\n+                      subscope: ast::node_id,\n+                      superscope: ast::node_id) -> bool\n     {\n         /*!\n-         * Returns true if `sub_scope` is equal to or is lexically\n+         * Returns true if `subscope` is equal to or is lexically\n          * nested inside `superscope` and false otherwise.\n          */\n \n-        let mut sub_scope = sub_scope;\n-        while superscope != sub_scope {\n-            match self.scope_map.find(&sub_scope) {\n-                None => return false,\n-                Some(&scope) => sub_scope = scope\n+        let mut s = subscope;\n+        while superscope != s {\n+            match self.scope_map.find(&s) {\n+                None => {\n+                    debug!(\"is_subscope_of(%?, %?, s=%?)=false\",\n+                           subscope, superscope, s);\n+\n+                    return false;\n+                }\n+                Some(&scope) => s = scope\n             }\n         }\n+\n+        debug!(\"is_subscope_of(%?, %?)=true\",\n+               subscope, superscope);\n+\n         return true;\n     }\n \n@@ -239,11 +251,11 @@ pub impl RegionMaps {\n                 }\n \n                 (ty::re_scope(sub_scope), ty::re_scope(super_scope)) => {\n-                    self.is_sub_scope(sub_scope, super_scope)\n+                    self.is_subscope_of(sub_scope, super_scope)\n                 }\n \n                 (ty::re_scope(sub_scope), ty::re_free(ref fr)) => {\n-                    self.is_sub_scope(sub_scope, fr.scope_id)\n+                    self.is_subscope_of(sub_scope, fr.scope_id)\n                 }\n \n                 (ty::re_free(sub_fr), ty::re_free(super_fr)) => {\n@@ -301,6 +313,7 @@ pub impl RegionMaps {\n         fn ancestors_of(self: &RegionMaps, scope: ast::node_id)\n             -> ~[ast::node_id]\n         {\n+            // debug!(\"ancestors_of(scope=%d)\", scope);\n             let mut result = ~[scope];\n             let mut scope = scope;\n             loop {\n@@ -311,13 +324,14 @@ pub impl RegionMaps {\n                         scope = superscope;\n                     }\n                 }\n+                // debug!(\"ancestors_of_loop(scope=%d)\", scope);\n             }\n         }\n     }\n }\n \n /// Extracts that current parent from cx, failing if there is none.\n-pub fn parent_id(cx: ctxt, span: span) -> ast::node_id {\n+pub fn parent_id(cx: Context, span: span) -> ast::node_id {\n     match cx.parent {\n       None => {\n         cx.sess.span_bug(span, ~\"crate should not be parent here\");\n@@ -329,144 +343,137 @@ pub fn parent_id(cx: ctxt, span: span) -> ast::node_id {\n }\n \n /// Records the current parent (if any) as the parent of `child_id`.\n-pub fn record_parent(cx: ctxt, child_id: ast::node_id) {\n+pub fn parent_to_expr(cx: Context, child_id: ast::node_id) {\n     for cx.parent.each |parent_id| {\n         cx.region_maps.record_parent(child_id, *parent_id);\n     }\n }\n \n-pub fn resolve_block(blk: &ast::blk, cx: ctxt, visitor: visit::vt<ctxt>) {\n+pub fn resolve_block(blk: &ast::blk, cx: Context, visitor: visit::vt<Context>) {\n     // Record the parent of this block.\n-    record_parent(cx, blk.node.id);\n+    parent_to_expr(cx, blk.node.id);\n \n     // Descend.\n-    let new_cx: ctxt = ctxt {parent: Some(blk.node.id),.. cx};\n+    let new_cx = Context {var_parent: Some(blk.node.id),\n+                          parent: Some(blk.node.id),\n+                          ..cx};\n     visit::visit_block(blk, new_cx, visitor);\n }\n \n-pub fn resolve_arm(arm: &ast::arm, cx: ctxt, visitor: visit::vt<ctxt>) {\n+pub fn resolve_arm(arm: &ast::arm, cx: Context, visitor: visit::vt<Context>) {\n     visit::visit_arm(arm, cx, visitor);\n }\n \n-pub fn resolve_pat(pat: @ast::pat, cx: ctxt, visitor: visit::vt<ctxt>) {\n-    match pat.node {\n-      ast::pat_ident(*) => {\n-        let defn_opt = cx.def_map.find(&pat.id);\n-        match defn_opt {\n-          Some(&ast::def_variant(_,_)) => {\n-            /* Nothing to do; this names a variant. */\n-          }\n-          _ => {\n-            /* This names a local. Bind it to the containing scope. */\n-            record_parent(cx, pat.id);\n-          }\n-        }\n-      }\n-      _ => { /* no-op */ }\n-    }\n-\n+pub fn resolve_pat(pat: @ast::pat, cx: Context, visitor: visit::vt<Context>) {\n+    assert!(cx.var_parent == cx.parent);\n+    parent_to_expr(cx, pat.id);\n     visit::visit_pat(pat, cx, visitor);\n }\n \n-pub fn resolve_stmt(stmt: @ast::stmt, cx: ctxt, visitor: visit::vt<ctxt>) {\n+pub fn resolve_stmt(stmt: @ast::stmt, cx: Context, visitor: visit::vt<Context>) {\n     match stmt.node {\n-      ast::stmt_decl(*) => {\n-        visit::visit_stmt(stmt, cx, visitor);\n-      }\n-      // This code has to be kept consistent with trans::base::trans_stmt\n-      ast::stmt_expr(_, stmt_id) |\n-      ast::stmt_semi(_, stmt_id) => {\n-        record_parent(cx, stmt_id);\n-        let mut expr_cx = cx;\n-        expr_cx.parent = Some(stmt_id);\n-        visit::visit_stmt(stmt, expr_cx, visitor);\n-      }\n-      ast::stmt_mac(*) => cx.sess.bug(~\"unexpanded macro\")\n+        ast::stmt_decl(*) => {\n+            visit::visit_stmt(stmt, cx, visitor);\n+        }\n+        ast::stmt_expr(_, stmt_id) |\n+        ast::stmt_semi(_, stmt_id) => {\n+            parent_to_expr(cx, stmt_id);\n+            let expr_cx = Context {parent: Some(stmt_id), ..cx};\n+            visit::visit_stmt(stmt, expr_cx, visitor);\n+        }\n+        ast::stmt_mac(*) => cx.sess.bug(~\"unexpanded macro\")\n     }\n }\n \n-pub fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n-    record_parent(cx, expr.id);\n+pub fn resolve_expr(expr: @ast::expr, cx: Context, visitor: visit::vt<Context>) {\n+    parent_to_expr(cx, expr.id);\n \n     let mut new_cx = cx;\n+    new_cx.parent = Some(expr.id);\n     match expr.node {\n-      // Calls or overloadable operators\n-      // FIXME #3387\n-      // ast::expr_index(*) | ast::expr_binary(*) |\n-      // ast::expr_unary(*) |\n-      ast::expr_call(*) | ast::expr_method_call(*) => {\n-        debug!(\"node %d: %s\", expr.id, pprust::expr_to_str(expr,\n-                                                           cx.sess.intr()));\n-        new_cx.parent = Some(expr.id);\n-      }\n-      ast::expr_match(*) => {\n-        debug!(\"node %d: %s\", expr.id, pprust::expr_to_str(expr,\n-                                                           cx.sess.intr()));\n-        new_cx.parent = Some(expr.id);\n-      }\n-      ast::expr_while(cond, _) => {\n-        new_cx.root_exprs.insert(cond.id);\n-      }\n-      _ => {}\n+        ast::expr_assign_op(*) | ast::expr_index(*) | ast::expr_binary(*) |\n+        ast::expr_unary(*) | ast::expr_call(*) | ast::expr_method_call(*) => {\n+            // FIXME(#5074) Nested method calls\n+            //\n+            // The lifetimes for a call or method call look as follows:\n+            //\n+            // call.id\n+            // - arg0.id\n+            // - ...\n+            // - argN.id\n+            // - call.callee_id\n+            //\n+            // The idea is that call.callee_id represents *the time when\n+            // the invoked function is actually running* and call.id\n+            // represents *the time to prepare the arguments and make the\n+            // call*.  See the section \"Borrows in Calls\" borrowck/doc.rs\n+            // for an extended explanantion of why this distinction is\n+            // important.\n+            //\n+            // parent_to_expr(new_cx, expr.callee_id);\n+        }\n+\n+        ast::expr_match(*) => {\n+            new_cx.var_parent = Some(expr.id);\n+        }\n+\n+        _ => {}\n     };\n \n-    if new_cx.root_exprs.contains(&expr.id) {\n-        new_cx.parent = Some(expr.id);\n-    }\n \n     visit::visit_expr(expr, new_cx, visitor);\n }\n \n pub fn resolve_local(local: @ast::local,\n-                     cx: ctxt,\n-                     visitor: visit::vt<ctxt>) {\n-    record_parent(cx, local.node.id);\n+                     cx: Context,\n+                     visitor: visit::vt<Context>) {\n+    assert!(cx.var_parent == cx.parent);\n+    parent_to_expr(cx, local.node.id);\n     visit::visit_local(local, cx, visitor);\n }\n \n-pub fn resolve_item(item: @ast::item, cx: ctxt, visitor: visit::vt<ctxt>) {\n+pub fn resolve_item(item: @ast::item, cx: Context, visitor: visit::vt<Context>) {\n     // Items create a new outer block scope as far as we're concerned.\n-    let new_cx: ctxt = ctxt {parent: None,.. cx};\n+    let new_cx = Context {var_parent: None, parent: None, ..cx};\n     visit::visit_item(item, new_cx, visitor);\n }\n \n pub fn resolve_fn(fk: &visit::fn_kind,\n                   decl: &ast::fn_decl,\n                   body: &ast::blk,\n-                  sp: span,\n+                  _sp: span,\n                   id: ast::node_id,\n-                  cx: ctxt,\n-                  visitor: visit::vt<ctxt>) {\n-    let fn_cx = match *fk {\n-        visit::fk_item_fn(*) | visit::fk_method(*) |\n-        visit::fk_dtor(*) => {\n-            // Top-level functions are a root scope.\n-            ctxt {parent: Some(id),.. cx}\n-        }\n-\n-        visit::fk_anon(*) | visit::fk_fn_block(*) => {\n-            // Closures continue with the inherited scope.\n-            cx\n-        }\n-    };\n-\n-    // Record the ID of `self`.\n+                  cx: Context,\n+                  visitor: visit::vt<Context>) {\n+    debug!(\"region::resolve_fn(id=%?, body.node.id=%?, cx.parent=%?)\",\n+           id, body.node.id, cx.parent);\n+\n+    // The arguments and `self` are parented to the body of the fn.\n+    let decl_cx = Context {parent: Some(body.node.id),\n+                           var_parent: Some(body.node.id),\n+                           ..cx};\n     match *fk {\n         visit::fk_method(_, _, method) => {\n             cx.region_maps.record_parent(method.self_id, body.node.id);\n         }\n         _ => {}\n     }\n+    visit::visit_fn_decl(decl, decl_cx, visitor);\n \n-    debug!(\"visiting fn with body %d. cx.parent: %? \\\n-            fn_cx.parent: %?\",\n-           body.node.id, cx.parent, fn_cx.parent);\n-\n-    for decl.inputs.each |input| {\n-        cx.region_maps.record_parent(input.id, body.node.id);\n-    }\n-\n-    visit::visit_fn(fk, decl, body, sp, id, fn_cx, visitor);\n+    // The body of the fn itself is either a root scope (top-level fn)\n+    // or it continues with the inherited scope (closures).\n+    let body_cx = match *fk {\n+        visit::fk_item_fn(*) |\n+        visit::fk_method(*) |\n+        visit::fk_dtor(*) => {\n+            Context {parent: None, var_parent: None, ..cx}\n+        }\n+        visit::fk_anon(*) |\n+        visit::fk_fn_block(*) => {\n+            cx\n+        }\n+    };\n+    (visitor.visit_block)(body, body_cx, visitor);\n }\n \n pub fn resolve_crate(sess: Session,\n@@ -475,13 +482,14 @@ pub fn resolve_crate(sess: Session,\n {\n     let region_maps = @mut RegionMaps {\n         scope_map: HashMap::new(),\n-        free_region_map: HashMap::new()\n+        free_region_map: HashMap::new(),\n+        cleanup_scopes: HashSet::new(),\n     };\n-    let cx: ctxt = ctxt {sess: sess,\n-                         def_map: def_map,\n-                         region_maps: region_maps,\n-                         root_exprs: @mut HashSet::new(),\n-                         parent: None};\n+    let cx = Context {sess: sess,\n+                      def_map: def_map,\n+                      region_maps: region_maps,\n+                      parent: None,\n+                      var_parent: None};\n     let visitor = visit::mk_vt(@visit::Visitor {\n         visit_block: resolve_block,\n         visit_item: resolve_item,\n@@ -772,7 +780,8 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n                    pprust::ty_to_str(ty, sess.intr()));\n \n             if cx.region_is_relevant(r) {\n-                cx.add_rp(cx.item_id, cx.add_variance(rv_contravariant))\n+                let rv = cx.add_variance(rv_contravariant);\n+                cx.add_rp(cx.item_id, rv)\n             }\n         }\n \n@@ -782,14 +791,14 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n             match f.region {\n                 Some(_) => {\n                     if cx.region_is_relevant(f.region) {\n-                        cx.add_rp(cx.item_id,\n-                                  cx.add_variance(rv_contravariant))\n+                        let rv = cx.add_variance(rv_contravariant);\n+                        cx.add_rp(cx.item_id, rv)\n                     }\n                 }\n                 None => {\n                     if f.sigil == ast::BorrowedSigil && cx.anon_implies_rp {\n-                        cx.add_rp(cx.item_id,\n-                                  cx.add_variance(rv_contravariant));\n+                        let rv = cx.add_variance(rv_contravariant);\n+                        cx.add_rp(cx.item_id, rv)\n                     }\n                 }\n             }\n@@ -820,7 +829,8 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n                     debug!(\"reference to external, rp'd type %s\",\n                            pprust::ty_to_str(ty, sess.intr()));\n                     if cx.region_is_relevant(path.rp) {\n-                        cx.add_rp(cx.item_id, cx.add_variance(variance))\n+                        let rv = cx.add_variance(variance);\n+                        cx.add_rp(cx.item_id, rv)\n                     }\n                   }\n                 }"}, {"sha": "ffc9d1488cf138e1682cd919ef7dd7ba6992875b", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -971,7 +971,7 @@ pub impl Resolver {\n                 module_.children.insert(name, child);\n                 return (child, new_parent);\n             }\n-            Some(child) => {\n+            Some(&child) => {\n                 // Enforce the duplicate checking mode:\n                 //\n                 // * If we're requesting duplicate module checking, check that\n@@ -1033,7 +1033,7 @@ pub impl Resolver {\n                                   *self.session.str_of(name)));\n                     }\n                 }\n-                return (*child, new_parent);\n+                return (child, new_parent);\n             }\n         }\n     }\n@@ -1864,7 +1864,7 @@ pub impl Resolver {\n                        *self.session.str_of(target));\n \n                 match module_.import_resolutions.find(&target) {\n-                    Some(resolution) => {\n+                    Some(&resolution) => {\n                         debug!(\"(building import directive) bumping \\\n                                 reference\");\n                         resolution.outstanding_references += 1;\n@@ -2395,7 +2395,7 @@ pub impl Resolver {\n                         (*ident, new_import_resolution);\n                 }\n                 None => { /* continue ... */ }\n-                Some(dest_import_resolution) => {\n+                Some(&dest_import_resolution) => {\n                     // Merge the two import resolutions at a finer-grained\n                     // level.\n \n@@ -2433,8 +2433,8 @@ pub impl Resolver {\n                     module_.import_resolutions.insert\n                         (*ident, dest_import_resolution);\n                 }\n-                Some(existing_import_resolution) => {\n-                    dest_import_resolution = *existing_import_resolution;\n+                Some(&existing_import_resolution) => {\n+                    dest_import_resolution = existing_import_resolution;\n                 }\n             }\n "}, {"sha": "785bb3edc07cd3c56248779cfdc60ef0f9d69176", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -1114,7 +1114,8 @@ pub fn compare_values(cx: block,\n pub fn store_non_ref_bindings(bcx: block,\n                               data: &ArmData,\n                               opt_temp_cleanups: Option<&mut ~[ValueRef]>)\n-                           -> block {\n+    -> block\n+{\n     /*!\n      *\n      * For each copy/move binding, copy the value from the value\n@@ -1125,6 +1126,7 @@ pub fn store_non_ref_bindings(bcx: block,\n      */\n \n     let mut bcx = bcx;\n+    let mut opt_temp_cleanups = opt_temp_cleanups;\n     for data.bindings_map.each_value |&binding_info| {\n         match binding_info.trmode {\n             TrByValue(is_move, lldest) => {\n@@ -1139,9 +1141,10 @@ pub fn store_non_ref_bindings(bcx: block,\n                     }\n                 };\n \n-                for opt_temp_cleanups.each |temp_cleanups| {\n+                do opt_temp_cleanups.mutate |temp_cleanups| {\n                     add_clean_temp_mem(bcx, lldest, binding_info.ty);\n                     temp_cleanups.push(lldest);\n+                    temp_cleanups\n                 }\n             }\n             TrByRef | TrByImplicitRef => {}"}, {"sha": "7be6bdb654e1f900edf44c99ec3534b296e324ab", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 60, "deletions": 49, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -391,14 +391,16 @@ pub fn get_tydesc_simple(ccx: @CrateContext, t: ty::t) -> ValueRef {\n \n pub fn get_tydesc(ccx: @CrateContext, t: ty::t) -> @mut tydesc_info {\n     match ccx.tydescs.find(&t) {\n-      Some(&inf) => inf,\n-      _ => {\n-        ccx.stats.n_static_tydescs += 1u;\n-        let inf = glue::declare_tydesc(ccx, t);\n-        ccx.tydescs.insert(t, inf);\n-        inf\n-      }\n+        Some(&inf) => {\n+            return inf;\n+        }\n+        _ => { }\n     }\n+\n+    ccx.stats.n_static_tydescs += 1u;\n+    let inf = glue::declare_tydesc(ccx, t);\n+    ccx.tydescs.insert(t, inf);\n+    return inf;\n }\n \n pub fn set_optimize_for_size(f: ValueRef) {\n@@ -888,18 +890,18 @@ pub fn need_invoke(bcx: block) -> bool {\n         let current = &mut *cur;\n         let kind = &mut *current.kind;\n         match *kind {\n-          block_scope(ref mut inf) => {\n-            for vec::each((*inf).cleanups) |cleanup| {\n-                match *cleanup {\n-                  clean(_, cleanup_type) | clean_temp(_, _, cleanup_type) => {\n-                    if cleanup_type == normal_exit_and_unwind {\n-                        return true;\n+            block_scope(ref mut inf) => {\n+                for vec::each((*inf).cleanups) |cleanup| {\n+                    match *cleanup {\n+                        clean(_, cleanup_type) | clean_temp(_, _, cleanup_type) => {\n+                            if cleanup_type == normal_exit_and_unwind {\n+                                return true;\n+                            }\n+                        }\n                     }\n-                  }\n                 }\n             }\n-          }\n-          _ => ()\n+            _ => ()\n         }\n         cur = match current.parent {\n           Some(next) => next,\n@@ -1011,12 +1013,12 @@ pub fn add_root_cleanup(bcx: block,\n                              ty=%s)\",\n            bcx.to_str(),\n            root_info.scope,\n-           root_info.freezes,\n+           root_info.freeze,\n            val_str(bcx.ccx().tn, root_loc),\n            ppaux::ty_to_str(bcx.ccx().tcx, ty));\n \n     let bcx_scope = find_bcx_for_scope(bcx, root_info.scope);\n-    if root_info.freezes {\n+    if root_info.freeze.is_some() {\n         add_clean_frozen_root(bcx_scope, root_loc, ty);\n     } else {\n         add_clean_temp_mem(bcx_scope, root_loc, ty);\n@@ -1029,6 +1031,12 @@ pub fn add_root_cleanup(bcx: block,\n               Some(NodeInfo { id, _ }) if id == scope_id => {\n                 return bcx_sid\n               }\n+\n+              // NOTE This is messier than it ought to be and not really right\n+              Some(NodeInfo { callee_id: Some(id), _ }) if id == scope_id => {\n+                return bcx_sid\n+              }\n+\n               _ => {\n                 match bcx_sid.parent {\n                   None => bcx.tcx().sess.bug(\n@@ -2484,37 +2492,40 @@ pub fn get_dtor_symbol(ccx: @CrateContext,\n                        id: ast::node_id,\n                        substs: Option<@param_substs>)\n                     -> ~str {\n-  let t = ty::node_id_to_type(ccx.tcx, id);\n-  match ccx.item_symbols.find(&id) {\n-     Some(s) => (/*bad*/copy *s),\n-     None if substs.is_none() => {\n-       let s = mangle_exported_name(\n-           ccx,\n-           vec::append(path, ~[path_name((ccx.names)(~\"dtor\"))]),\n-           t);\n-       // XXX: Bad copy, use `@str`?\n-       ccx.item_symbols.insert(id, copy s);\n-       s\n-     }\n-     None   => {\n-       // Monomorphizing, so just make a symbol, don't add\n-       // this to item_symbols\n-       match substs {\n-         Some(ss) => {\n-           let mono_ty = ty::subst_tps(ccx.tcx, ss.tys, ss.self_ty, t);\n-           mangle_exported_name(\n-               ccx,\n-               vec::append(path,\n-                           ~[path_name((ccx.names)(~\"dtor\"))]),\n-               mono_ty)\n-         }\n-         None => {\n-             ccx.sess.bug(fmt!(\"get_dtor_symbol: not monomorphizing and \\\n-               couldn't find a symbol for dtor %?\", path));\n-         }\n-       }\n-     }\n-  }\n+    let t = ty::node_id_to_type(ccx.tcx, id);\n+    match ccx.item_symbols.find(&id) {\n+        Some(s) => {\n+            return /*bad*/copy *s;\n+        }\n+        None => { }\n+    }\n+\n+    return if substs.is_none() {\n+        let s = mangle_exported_name(\n+            ccx,\n+            vec::append(path, ~[path_name((ccx.names)(~\"dtor\"))]),\n+            t);\n+        // XXX: Bad copy, use `@str`?\n+        ccx.item_symbols.insert(id, copy s);\n+        s\n+    } else {\n+        // Monomorphizing, so just make a symbol, don't add\n+        // this to item_symbols\n+        match substs {\n+            Some(ss) => {\n+                let mono_ty = ty::subst_tps(ccx.tcx, ss.tys, ss.self_ty, t);\n+                mangle_exported_name(\n+                    ccx,\n+                    vec::append(path,\n+                                ~[path_name((ccx.names)(~\"dtor\"))]),\n+                    mono_ty)\n+            }\n+            None => {\n+                ccx.sess.bug(fmt!(\"get_dtor_symbol: not monomorphizing and \\\n+                                   couldn't find a symbol for dtor %?\", path));\n+            }\n+        }\n+    };\n }\n \n pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {"}, {"sha": "af00257fe16035549cc3216f2f94162808e91772", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -39,7 +39,6 @@ use middle::trans::monomorphize;\n use middle::trans::type_of;\n use middle::ty;\n use middle::typeck;\n-use util::common::indenter;\n use util::ppaux::Repr;\n \n use syntax::ast;\n@@ -689,7 +688,6 @@ pub fn trans_arg_expr(bcx: block,\n            self_mode,\n            arg_expr.repr(bcx.tcx()),\n            ret_flag.map(|v| bcx.val_str(*v)));\n-    let _indenter = indenter();\n \n     // translate the arg expr to a datum\n     let arg_datumblock = match ret_flag {"}, {"sha": "2ebd696dbfdef8fe2440a7727c2e94519e69e54c", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -574,13 +574,17 @@ pub trait get_node_info {\n \n impl get_node_info for @ast::expr {\n     fn info(&self) -> Option<NodeInfo> {\n-        Some(NodeInfo { id: self.id, span: self.span })\n+        Some(NodeInfo {id: self.id,\n+                       callee_id: Some(self.callee_id),\n+                       span: self.span})\n     }\n }\n \n impl get_node_info for ast::blk {\n     fn info(&self) -> Option<NodeInfo> {\n-        Some(NodeInfo { id: self.node.id, span: self.span })\n+        Some(NodeInfo {id: self.node.id,\n+                       callee_id: None,\n+                       span: self.span})\n     }\n }\n \n@@ -592,6 +596,7 @@ impl get_node_info for Option<@ast::expr> {\n \n pub struct NodeInfo {\n     id: ast::node_id,\n+    callee_id: Option<ast::node_id>,\n     span: span\n }\n "}, {"sha": "3a331e8791ba2d4f5b1fff8674f423541a30f890", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -195,18 +195,19 @@ pub fn const_expr(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n             match adj.autoref {\n                 None => { }\n                 Some(ref autoref) => {\n-                    assert!(autoref.region == ty::re_static);\n-                    assert!(autoref.mutbl != ast::m_mutbl);\n                     // Don't copy data to do a deref+ref.\n                     let llptr = match maybe_ptr {\n                         Some(ptr) => ptr,\n                         None => const_addr_of(cx, llconst)\n                     };\n-                    match autoref.kind {\n-                        ty::AutoPtr => {\n+                    match *autoref {\n+                        ty::AutoUnsafe(m) |\n+                        ty::AutoPtr(ty::re_static, m) => {\n+                            assert!(m != ast::m_mutbl);\n                             llconst = llptr;\n                         }\n-                        ty::AutoBorrowVec => {\n+                        ty::AutoBorrowVec(ty::re_static, m) => {\n+                            assert!(m != ast::m_mutbl);\n                             let size = machine::llsize_of(cx,\n                                                           val_ty(llconst));\n                             assert!(abi::slice_elt_base == 0);"}, {"sha": "705d443b1155d1ce25c6b4ab4ed8dd67748500f6", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -524,8 +524,8 @@ pub impl Datum {\n          * case, we will call this function, which will stash a copy\n          * away until we exit the scope `scope_id`. */\n \n-        debug!(\"root(scope_id=%?, freezes=%?, self=%?)\",\n-               root_info.scope, root_info.freezes, self.to_str(bcx.ccx()));\n+        debug!(\"root(root_info=%?, self=%?)\",\n+               root_info, self.to_str(bcx.ccx()));\n \n         if bcx.sess().trace() {\n             trans_trace(\n@@ -539,7 +539,8 @@ pub impl Datum {\n         add_root_cleanup(bcx, root_info, scratch.val, scratch.ty);\n \n         // If we need to freeze the box, do that now.\n-        if root_info.freezes {\n+        if root_info.freeze.is_some() {\n+            // NOTE distinguish the two kinds of freezing here\n             callee::trans_lang_call(\n                 bcx,\n                 bcx.tcx().lang_items.borrow_as_imm_fn(),"}, {"sha": "ac6fa7a5a1c4f10aafe9a776886bbc9b7c7792d7", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -146,9 +146,9 @@ use middle::trans::type_of;\n use middle::ty;\n use middle::ty::struct_mutable_fields;\n use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn,\n-                 AutoDerefRef, AutoAddEnv};\n+                 AutoDerefRef, AutoAddEnv, AutoUnsafe};\n use util::common::indenter;\n-use util::ppaux::ty_to_str;\n+use util::ppaux::Repr;\n \n use core::cast::transmute;\n use core::hashmap::HashMap;\n@@ -201,6 +201,8 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n                 trans_to_datum_unadjusted(bcx, expr)\n             });\n \n+            debug!(\"unadjusted datum: %s\", datum.to_str(bcx.ccx()));\n+\n             if adj.autoderefs > 0 {\n                 let DatumBlock { bcx: new_bcx, datum: new_datum } =\n                     datum.autoderef(bcx, expr.id, adj.autoderefs);\n@@ -209,25 +211,24 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n             }\n \n             datum = match adj.autoref {\n-                None => datum,\n-                Some(ref autoref) => {\n-                    match autoref.kind {\n-                        AutoPtr => {\n-                            unpack_datum!(bcx, auto_ref(bcx, datum))\n-                        }\n-                        AutoBorrowVec => {\n-                            unpack_datum!(bcx, auto_slice(bcx, datum))\n-                        }\n-                        AutoBorrowVecRef => {\n-                            unpack_datum!(bcx, auto_slice_and_ref(bcx, datum))\n-                        }\n-                        AutoBorrowFn => {\n-                            // currently, all closure types are\n-                            // represented precisely the same, so no\n-                            // runtime adjustment is required:\n-                            datum\n-                        }\n-                    }\n+                None => {\n+                    datum\n+                }\n+                Some(AutoUnsafe(*)) | // region + unsafe ptrs have same repr\n+                Some(AutoPtr(*)) => {\n+                    unpack_datum!(bcx, auto_ref(bcx, datum))\n+                }\n+                Some(AutoBorrowVec(*)) => {\n+                    unpack_datum!(bcx, auto_slice(bcx, datum))\n+                }\n+                Some(AutoBorrowVecRef(*)) => {\n+                    unpack_datum!(bcx, auto_slice_and_ref(bcx, datum))\n+                }\n+                Some(AutoBorrowFn(*)) => {\n+                    // currently, all closure types are\n+                    // represented precisely the same, so no\n+                    // runtime adjustment is required:\n+                    datum\n                 }\n             };\n \n@@ -273,7 +274,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n \n         let tcx = bcx.tcx();\n         let closure_ty = expr_ty_adjusted(bcx, expr);\n-        debug!(\"add_env(closure_ty=%s)\", ty_to_str(tcx, closure_ty));\n+        debug!(\"add_env(closure_ty=%s)\", closure_ty.repr(tcx));\n         let scratch = scratch_datum(bcx, closure_ty, false);\n         let llfn = GEPi(bcx, scratch.val, [0u, abi::fn_field_code]);\n         assert!(datum.appropriate_mode() == ByValue);\n@@ -612,7 +613,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n             let sigil = ty::ty_closure_sigil(expr_ty);\n             debug!(\"translating fn_block %s with type %s\",\n                    expr_to_str(expr, tcx.sess.intr()),\n-                   ty_to_str(tcx, expr_ty));\n+                   expr_ty.repr(tcx));\n             return closure::trans_expr_fn(bcx, sigil, decl, body,\n                                           expr.id, expr.id,\n                                           None, dest);\n@@ -1088,6 +1089,9 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n                 }\n             };\n \n+            debug!(\"def_self() reference, self_info.t=%s\",\n+                   self_info.t.repr(bcx.tcx()));\n+\n             // This cast should not be necessary. We should cast self *once*,\n             // but right now this conflicts with default methods.\n             let real_self_ty = monomorphize_type(bcx, self_info.t);\n@@ -1151,7 +1155,7 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n                     tcx.sess.bug(fmt!(\n                         \"cannot get field types from the enum type %s \\\n                          without a node ID\",\n-                        ty_to_str(tcx, ty)));\n+                        ty.repr(tcx)));\n                 }\n                 Some(node_id) => {\n                     match *tcx.def_map.get(&node_id) {\n@@ -1173,7 +1177,7 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n         _ => {\n             tcx.sess.bug(fmt!(\n                 \"cannot get field types from the type %s\",\n-                ty_to_str(tcx, ty)));\n+                ty.repr(tcx)));\n         }\n     }\n }"}, {"sha": "40b7a444a3e97ad8f6706672632a2dc20afdf9c6", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -29,26 +29,33 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::def_id,\n     -> ast::def_id {\n     let _icx = ccx.insn_ctxt(\"maybe_instantiate_inline\");\n     match ccx.external.find(&fn_id) {\n-      Some(&Some(node_id)) => {\n-        // Already inline\n-        debug!(\"maybe_instantiate_inline(%s): already inline as node id %d\",\n-               ty::item_path_str(ccx.tcx, fn_id), node_id);\n-        local_def(node_id)\n-      }\n-      Some(&None) => fn_id, // Not inlinable\n-      None => { // Not seen yet\n-        match csearch::maybe_get_item_ast(\n+        Some(&Some(node_id)) => {\n+            // Already inline\n+            debug!(\"maybe_instantiate_inline(%s): already inline as node id %d\",\n+                   ty::item_path_str(ccx.tcx, fn_id), node_id);\n+            return local_def(node_id);\n+        }\n+        Some(&None) => {\n+            return fn_id; // Not inlinable\n+        }\n+        None => {\n+            // Not seen yet\n+        }\n+    }\n+\n+    let csearch_result =\n+        csearch::maybe_get_item_ast(\n             ccx.tcx, fn_id,\n             |a,b,c,d| {\n                 astencode::decode_inlined_item(a, b, ccx.maps,\n                                                /*bad*/ copy c, d)\n-            }) {\n-\n-          csearch::not_found => {\n+            });\n+    return match csearch_result {\n+        csearch::not_found => {\n             ccx.external.insert(fn_id, None);\n             fn_id\n-          }\n-          csearch::found(ast::ii_item(item)) => {\n+        }\n+        csearch::found(ast::ii_item(item)) => {\n             ccx.external.insert(fn_id, Some(item.id));\n             ccx.stats.n_inlines += 1;\n             if translate { trans_item(ccx, item); }\n@@ -122,8 +129,6 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::def_id,\n               ccx.external.insert(fn_id, Some((*dtor).node.id));\n               local_def((*dtor).node.id)\n           }\n-        }\n-      }\n-    }\n+    };\n }\n "}, {"sha": "86b087b937f25314590bfdb2cdfb3579d592462e", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -44,6 +44,11 @@ pub fn trans_impl(ccx: @CrateContext, path: path, name: ast::ident,\n                   methods: &[@ast::method], generics: &ast::Generics,\n                   self_ty: Option<ty::t>, id: ast::node_id) {\n     let _icx = ccx.insn_ctxt(\"impl::trans_impl\");\n+    let tcx = ccx.tcx;\n+\n+    debug!(\"trans_impl(path=%s, name=%s, self_ty=%s, id=%?)\",\n+           path.repr(tcx), name.repr(tcx), self_ty.repr(tcx), id);\n+\n     if !generics.ty_params.is_empty() { return; }\n     let sub_path = vec::append_one(path, path_name(name));\n     for vec::each(methods) |method| {"}, {"sha": "98db829370c0c95ca72a49ee126f8fddc9b3582b", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -137,6 +137,9 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n       ast_map::node_local(*) => {\n           ccx.tcx.sess.bug(~\"Can't monomorphize a local\")\n       }\n+      ast_map::node_callee_scope(*) => {\n+          ccx.tcx.sess.bug(~\"Can't monomorphize a callee-scope\")\n+      }\n       ast_map::node_struct_ctor(_, i, pt) => (pt, i.ident, i.span)\n     };\n \n@@ -279,6 +282,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n       ast_map::node_trait_method(*) |\n       ast_map::node_arg(*) |\n       ast_map::node_block(*) |\n+      ast_map::node_callee_scope(*) |\n       ast_map::node_local(*) => {\n         ccx.tcx.sess.bug(fmt!(\"Can't monomorphize a %?\", map_node))\n       }"}, {"sha": "a446408d00a10057bdc707d5b8a842ae524d0afd", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -42,19 +42,19 @@ pub fn find_reachable(crate_mod: &_mod, exp_map2: resolve::ExportMap2,\n                       tcx: ty::ctxt, method_map: typeck::method_map) -> map {\n     let mut rmap = HashSet::new();\n     {\n-        let cx = ctx {\n+        let mut cx = @mut ctx {\n             exp_map2: exp_map2,\n             tcx: tcx,\n             method_map: method_map,\n             rmap: &mut rmap\n         };\n-        traverse_public_mod(&cx, ast::crate_node_id, crate_mod);\n-        traverse_all_resources_and_impls(&cx, crate_mod);\n+        traverse_public_mod(cx, ast::crate_node_id, crate_mod);\n+        traverse_all_resources_and_impls(cx, crate_mod);\n     }\n     return @rmap;\n }\n \n-fn traverse_exports(cx: &ctx, mod_id: node_id) -> bool {\n+fn traverse_exports(cx: @mut ctx, mod_id: node_id) -> bool {\n     let mut found_export = false;\n     match cx.exp_map2.find(&mod_id) {\n       Some(ref exp2s) => {\n@@ -68,23 +68,25 @@ fn traverse_exports(cx: &ctx, mod_id: node_id) -> bool {\n     return found_export;\n }\n \n-fn traverse_def_id(cx: &ctx, did: def_id) {\n+fn traverse_def_id(cx: @mut ctx, did: def_id) {\n     if did.crate != local_crate { return; }\n     match cx.tcx.items.find(&did.node) {\n         None => (), // This can happen for self, for example\n         Some(&ast_map::node_item(item, _)) => traverse_public_item(cx, item),\n         Some(&ast_map::node_method(_, impl_id, _)) => traverse_def_id(cx, impl_id),\n         Some(&ast_map::node_foreign_item(item, _, _, _)) => {\n+            let cx = &mut *cx; // NOTE reborrow @mut\n             cx.rmap.insert(item.id);\n         }\n         Some(&ast_map::node_variant(ref v, _, _)) => {\n+            let cx = &mut *cx; // NOTE reborrow @mut\n             cx.rmap.insert(v.node.id);\n         }\n         _ => ()\n     }\n }\n \n-fn traverse_public_mod(cx: &ctx, mod_id: node_id, m: &_mod) {\n+fn traverse_public_mod(cx: @mut ctx, mod_id: node_id, m: &_mod) {\n     if !traverse_exports(cx, mod_id) {\n         // No exports, so every local item is exported\n         for m.items.each |item| {\n@@ -93,17 +95,21 @@ fn traverse_public_mod(cx: &ctx, mod_id: node_id, m: &_mod) {\n     }\n }\n \n-fn traverse_public_item(cx: &ctx, item: @item) {\n-    // FIXME #6021: naming rmap shouldn't be necessary\n-    let rmap: &mut HashSet<node_id> = cx.rmap;\n-    if rmap.contains(&item.id) { return; }\n-    rmap.insert(item.id);\n+fn traverse_public_item(cx: @mut ctx, item: @item) {\n+    {\n+        // FIXME #6021: naming rmap shouldn't be necessary\n+        let cx = &mut *cx;\n+        let rmap: &mut HashSet<node_id> = cx.rmap;\n+        if rmap.contains(&item.id) { return; }\n+        rmap.insert(item.id);\n+    }\n+\n     match item.node {\n       item_mod(ref m) => traverse_public_mod(cx, item.id, m),\n       item_foreign_mod(ref nm) => {\n           if !traverse_exports(cx, item.id) {\n               for nm.items.each |item| {\n-                  cx.rmap.insert(item.id);\n+                  (&mut *cx).rmap.insert(item.id); // NOTE reborrow @mut\n               }\n           }\n       }\n@@ -119,17 +125,17 @@ fn traverse_public_item(cx: &ctx, item: @item) {\n                 m.generics.ty_params.len() > 0u ||\n                 attr::find_inline_attr(m.attrs) != attr::ia_none\n             {\n-                cx.rmap.insert(m.id);\n+                (&mut *cx).rmap.insert(m.id); // NOTE reborrow @mut\n                 traverse_inline_body(cx, &m.body);\n             }\n         }\n       }\n       item_struct(ref struct_def, ref generics) => {\n         for struct_def.ctor_id.each |&ctor_id| {\n-            cx.rmap.insert(ctor_id);\n+            (&mut *cx).rmap.insert(ctor_id); // NOTE reborrow @mut\n         }\n         for struct_def.dtor.each |dtor| {\n-            cx.rmap.insert(dtor.node.id);\n+            (&mut *cx).rmap.insert(dtor.node.id);\n             if generics.ty_params.len() > 0u ||\n                 attr::find_inline_attr(dtor.node.attrs) != attr::ia_none\n             {\n@@ -148,11 +154,13 @@ fn traverse_public_item(cx: &ctx, item: @item) {\n     }\n }\n \n-fn traverse_ty<'a, 'b>(ty: @Ty, cx: &'b ctx<'a>, v: visit::vt<&'b ctx<'a>>) {\n-    // FIXME #6021: naming rmap shouldn't be necessary\n-    let rmap: &mut HashSet<node_id> = cx.rmap;\n-    if rmap.contains(&ty.id) { return; }\n-    rmap.insert(ty.id);\n+fn traverse_ty<'a>(ty: @Ty, cx: @mut ctx<'a>, v: visit::vt<@mut ctx<'a>>) {\n+    {\n+        // FIXME #6021: naming rmap shouldn't be necessary\n+        let cx = &mut *cx;\n+        if cx.rmap.contains(&ty.id) { return; }\n+        cx.rmap.insert(ty.id);\n+    }\n \n     match ty.node {\n       ty_path(p, p_id) => {\n@@ -171,9 +179,9 @@ fn traverse_ty<'a, 'b>(ty: @Ty, cx: &'b ctx<'a>, v: visit::vt<&'b ctx<'a>>) {\n     }\n }\n \n-fn traverse_inline_body(cx: &ctx, body: &blk) {\n-    fn traverse_expr<'a, 'b>(e: @expr, cx: &'b ctx<'a>,\n-                             v: visit::vt<&'b ctx<'a>>) {\n+fn traverse_inline_body(cx: @mut ctx, body: &blk) {\n+    fn traverse_expr<'a>(e: @expr, cx: @mut ctx<'a>,\n+                         v: visit::vt<@mut ctx<'a>>) {\n         match e.node {\n           expr_path(_) => {\n             match cx.tcx.def_map.find(&e.id) {\n@@ -218,7 +226,7 @@ fn traverse_inline_body(cx: &ctx, body: &blk) {\n     // Don't ignore nested items: for example if a generic fn contains a\n     // generic impl (as in deque::create), we need to monomorphize the\n     // impl as well\n-    fn traverse_item(i: @item, cx: &ctx, _v: visit::vt<&ctx>) {\n+    fn traverse_item(i: @item, cx: @mut ctx, _v: visit::vt<@mut ctx>) {\n       traverse_public_item(cx, i);\n     }\n     visit::visit_block(body, cx, visit::mk_vt(@visit::Visitor {\n@@ -228,7 +236,7 @@ fn traverse_inline_body(cx: &ctx, body: &blk) {\n     }));\n }\n \n-fn traverse_all_resources_and_impls(cx: &ctx, crate_mod: &_mod) {\n+fn traverse_all_resources_and_impls(cx: @mut ctx, crate_mod: &_mod) {\n     visit::visit_mod(\n         crate_mod,\n         codemap::dummy_sp(),"}, {"sha": "28705ac49320a42b971b62d13a4f2c95e379e5a1", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 63, "deletions": 37, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -183,26 +183,21 @@ pub struct AutoDerefRef {\n \n #[auto_encode]\n #[auto_decode]\n-pub struct AutoRef {\n-    kind: AutoRefKind,\n-    region: Region,\n-    mutbl: ast::mutability\n-}\n-\n-#[auto_encode]\n-#[auto_decode]\n-pub enum AutoRefKind {\n+pub enum AutoRef {\n     /// Convert from T to &T\n-    AutoPtr,\n+    AutoPtr(Region, ast::mutability),\n \n     /// Convert from @[]/~[]/&[] to &[] (or str)\n-    AutoBorrowVec,\n+    AutoBorrowVec(Region, ast::mutability),\n \n     /// Convert from @[]/~[]/&[] to &&[] (or str)\n-    AutoBorrowVecRef,\n+    AutoBorrowVecRef(Region, ast::mutability),\n \n     /// Convert from @fn()/~fn()/&fn() to &fn()\n-    AutoBorrowFn\n+    AutoBorrowFn(Region),\n+\n+    /// Convert from T to *T\n+    AutoUnsafe(ast::mutability)\n }\n \n // Stores information about provided methods (a.k.a. default methods) in\n@@ -432,11 +427,20 @@ pub enum Region {\n     /// A concrete region naming some expression within the current function.\n     re_scope(node_id),\n \n-    /// Static data that has an \"infinite\" lifetime.\n+    /// Static data that has an \"infinite\" lifetime. Top in the region lattice.\n     re_static,\n \n     /// A region variable.  Should not exist after typeck.\n-    re_infer(InferRegion)\n+    re_infer(InferRegion),\n+\n+    /// Empty lifetime is for data that is never accessed.\n+    /// Bottom in the region lattice. We treat re_empty somewhat\n+    /// specially; at least right now, we do not generate instances of\n+    /// it during the GLB computations, but rather\n+    /// generate an error instead. This is to improve error messages.\n+    /// The only way to get an instance of re_empty is to have a region\n+    /// variable with no constraints.\n+    re_empty,\n }\n \n pub impl Region {\n@@ -2874,6 +2878,17 @@ pub fn ty_region(tcx: ctxt,\n     }\n }\n \n+pub fn replace_fn_sig(cx: ctxt, fsty: &sty, new_sig: FnSig) -> t {\n+    match *fsty {\n+        ty_bare_fn(ref f) => mk_bare_fn(cx, BareFnTy {sig: new_sig, ..*f}),\n+        ty_closure(ref f) => mk_closure(cx, ClosureTy {sig: new_sig, ..*f}),\n+        ref s => {\n+            cx.sess.bug(\n+                fmt!(\"ty_fn_sig() called on non-fn type: %?\", s));\n+        }\n+    }\n+}\n+\n pub fn replace_closure_return_type(tcx: ctxt, fn_type: t, ret_type: t) -> t {\n     /*!\n      *\n@@ -2993,26 +3008,26 @@ pub fn adjust_ty(cx: ctxt,\n             match adj.autoref {\n                 None => adjusted_ty,\n                 Some(ref autoref) => {\n-                    match autoref.kind {\n-                        AutoPtr => {\n-                            mk_rptr(cx, autoref.region,\n-                                    mt {ty: adjusted_ty,\n-                                        mutbl: autoref.mutbl})\n+                    match *autoref {\n+                        AutoPtr(r, m) => {\n+                            mk_rptr(cx, r, mt {ty: adjusted_ty, mutbl: m})\n                         }\n \n-                        AutoBorrowVec => {\n-                            borrow_vec(cx, span, autoref, adjusted_ty)\n+                        AutoBorrowVec(r, m) => {\n+                            borrow_vec(cx, span, r, m, adjusted_ty)\n                         }\n \n-                        AutoBorrowVecRef => {\n-                            adjusted_ty = borrow_vec(cx, span, autoref,\n-                                                     adjusted_ty);\n-                            mk_rptr(cx, autoref.region,\n-                                    mt {ty: adjusted_ty, mutbl: ast::m_imm})\n+                        AutoBorrowVecRef(r, m) => {\n+                            adjusted_ty = borrow_vec(cx, span, r, m, adjusted_ty);\n+                            mk_rptr(cx, r, mt {ty: adjusted_ty, mutbl: ast::m_imm})\n                         }\n \n-                        AutoBorrowFn => {\n-                            borrow_fn(cx, span, autoref, adjusted_ty)\n+                        AutoBorrowFn(r) => {\n+                            borrow_fn(cx, span, r, adjusted_ty)\n+                        }\n+\n+                        AutoUnsafe(m) => {\n+                            mk_ptr(cx, mt {ty: adjusted_ty, mutbl: m})\n                         }\n                     }\n                 }\n@@ -3021,15 +3036,15 @@ pub fn adjust_ty(cx: ctxt,\n     };\n \n     fn borrow_vec(cx: ctxt, span: span,\n-                  autoref: &AutoRef, ty: ty::t) -> ty::t {\n+                  r: Region, m: ast::mutability,\n+                  ty: ty::t) -> ty::t {\n         match get(ty).sty {\n             ty_evec(mt, _) => {\n-                ty::mk_evec(cx, mt {ty: mt.ty, mutbl: autoref.mutbl},\n-                            vstore_slice(autoref.region))\n+                ty::mk_evec(cx, mt {ty: mt.ty, mutbl: m}, vstore_slice(r))\n             }\n \n             ty_estr(_) => {\n-                ty::mk_estr(cx, vstore_slice(autoref.region))\n+                ty::mk_estr(cx, vstore_slice(r))\n             }\n \n             ref s => {\n@@ -3041,13 +3056,12 @@ pub fn adjust_ty(cx: ctxt,\n         }\n     }\n \n-    fn borrow_fn(cx: ctxt, span: span,\n-                 autoref: &AutoRef, ty: ty::t) -> ty::t {\n+    fn borrow_fn(cx: ctxt, span: span, r: Region, ty: ty::t) -> ty::t {\n         match get(ty).sty {\n             ty_closure(ref fty) => {\n                 ty::mk_closure(cx, ClosureTy {\n                     sigil: BorrowedSigil,\n-                    region: autoref.region,\n+                    region: r,\n                     ..copy *fty\n                 })\n             }\n@@ -3062,6 +3076,18 @@ pub fn adjust_ty(cx: ctxt,\n     }\n }\n \n+pub impl AutoRef {\n+    fn map_region(&self, f: &fn(Region) -> Region) -> AutoRef {\n+        match *self {\n+            ty::AutoPtr(r, m) => ty::AutoPtr(f(r), m),\n+            ty::AutoBorrowVec(r, m) => ty::AutoBorrowVec(f(r), m),\n+            ty::AutoBorrowVecRef(r, m) => ty::AutoBorrowVecRef(f(r), m),\n+            ty::AutoBorrowFn(r) => ty::AutoBorrowFn(f(r)),\n+            ty::AutoUnsafe(m) => ty::AutoUnsafe(m),\n+        }\n+    }\n+}\n+\n pub struct ParamsTy {\n     params: ~[t],\n     ty: t\n@@ -3986,7 +4012,7 @@ pub fn lookup_field_type(tcx: ctxt,\n     }\n     else {\n         match tcx.tcache.find(&id) {\n-           Some(tpt) => tpt.ty,\n+           Some(&ty_param_bounds_and_ty {ty, _}) => ty,\n            None => {\n                let tpt = csearch::get_field_type(tcx, struct_id, id);\n                tcx.tcache.insert(id, tpt);"}, {"sha": "0c9b61164d231db6e29139c8037c2b7e95f37627", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -118,8 +118,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n \n             // Assign the pattern the type of the *enum*, not the variant.\n             let enum_tpt = ty::lookup_item_type(tcx, enm);\n-            instantiate_path(pcx.fcx, path, enum_tpt, pat.span, pat.id,\n-                             pcx.block_region);\n+            instantiate_path(pcx.fcx, path, enum_tpt, pat.span, pat.id);\n \n             // check that the type of the value being matched is a subtype\n             // of the type of the pattern:\n@@ -159,8 +158,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n             } else {\n                 ctor_tpt\n             };\n-            instantiate_path(pcx.fcx, path, struct_tpt, pat.span, pat.id,\n-                             pcx.block_region);\n+            instantiate_path(pcx.fcx, path, struct_tpt, pat.span, pat.id);\n \n             // Check that the type of the value being matched is a subtype of\n             // the type of the pattern."}, {"sha": "0cc2ddd32b46a3c1541abd3ebaa490243557ce89", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 17, "deletions": 30, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -119,23 +119,24 @@ pub fn lookup(\n         // In a call `a.b::<X, Y, ...>(...)`:\n         expr: @ast::expr,                   // The expression `a.b(...)`.\n         self_expr: @ast::expr,              // The expression `a`.\n-        callee_id: node_id,                 // Where to store `a.b`'s type\n+        callee_id: node_id,                 /* Where to store `a.b`'s type,\n+                                             * also the scope of the call */ \n         m_name: ast::ident,                 // The ident `b`.\n         self_ty: ty::t,                     // The type of `a`.\n         supplied_tps: &[ty::t],             // The list of types X, Y, ... .\n         deref_args: check::DerefArgs,       // Whether we autopointer first.\n         check_traits: CheckTraitsFlag,      // Whether we check traits only.\n         autoderef_receiver: AutoderefReceiverFlag)\n      -> Option<method_map_entry> {\n-    let mut impl_dups = HashSet::new();\n+    let mut impl_dups = @mut HashSet::new();\n     let lcx = LookupContext {\n         fcx: fcx,\n         expr: expr,\n         self_expr: self_expr,\n         callee_id: callee_id,\n         m_name: m_name,\n         supplied_tps: supplied_tps,\n-        impl_dups: &mut impl_dups,\n+        impl_dups: impl_dups,\n         inherent_candidates: @mut ~[],\n         extension_candidates: @mut ~[],\n         deref_args: deref_args,\n@@ -154,7 +155,7 @@ pub struct LookupContext<'self> {\n     callee_id: node_id,\n     m_name: ast::ident,\n     supplied_tps: &'self [ty::t],\n-    impl_dups: &'self mut HashSet<def_id>,\n+    impl_dups: @mut HashSet<def_id>,\n     inherent_candidates: @mut ~[Candidate],\n     extension_candidates: @mut ~[Candidate],\n     deref_args: check::DerefArgs,\n@@ -640,7 +641,7 @@ pub impl<'self> LookupContext<'self> {\n         /*!\n          *\n          * In the event that we are invoking a method with a receiver\n-         * of a linear borrowed type like `&mut T` or `&mut [T]`,\n+         * of a borrowed type like `&T`, `&mut T`, or `&mut [T]`,\n          * we will \"reborrow\" the receiver implicitly.  For example, if\n          * you have a call `r.inc()` and where `r` has type `&mut T`,\n          * then we treat that like `(&mut *r).inc()`.  This avoids\n@@ -657,26 +658,19 @@ pub impl<'self> LookupContext<'self> {\n \n         let tcx = self.tcx();\n         return match ty::get(self_ty).sty {\n-            ty::ty_rptr(_, self_mt) if self_mt.mutbl == m_mutbl => {\n-                let region = self.infcx().next_region_var(self.expr.span,\n-                                                          self.expr.id);\n+            ty::ty_rptr(_, self_mt) => {\n+                let region = self.infcx().next_region_var_nb(self.expr.span);\n                 (ty::mk_rptr(tcx, region, self_mt),\n                  ty::AutoDerefRef(ty::AutoDerefRef {\n                      autoderefs: autoderefs+1,\n-                     autoref: Some(ty::AutoRef {kind: AutoPtr,\n-                                                region: region,\n-                                                mutbl: self_mt.mutbl})}))\n+                     autoref: Some(ty::AutoPtr(region, self_mt.mutbl))}))\n             }\n-            ty::ty_evec(self_mt, vstore_slice(_))\n-            if self_mt.mutbl == m_mutbl => {\n-                let region = self.infcx().next_region_var(self.expr.span,\n-                                                          self.expr.id);\n+            ty::ty_evec(self_mt, vstore_slice(_)) => {\n+                let region = self.infcx().next_region_var_nb(self.expr.span);\n                 (ty::mk_evec(tcx, self_mt, vstore_slice(region)),\n                  ty::AutoDerefRef(ty::AutoDerefRef {\n-                    autoderefs: autoderefs,\n-                    autoref: Some(ty::AutoRef {kind: AutoBorrowVec,\n-                                               region: region,\n-                                               mutbl: self_mt.mutbl})}))\n+                     autoderefs: autoderefs,\n+                     autoref: Some(ty::AutoBorrowVec(region, self_mt.mutbl))}))\n             }\n             _ => {\n                 (self_ty,\n@@ -793,16 +787,15 @@ pub impl<'self> LookupContext<'self> {\n \n     fn search_for_some_kind_of_autorefd_method(\n         &self,\n-        kind: AutoRefKind,\n+        kind: &fn(Region, ast::mutability) -> ty::AutoRef,\n         autoderefs: uint,\n         mutbls: &[ast::mutability],\n         mk_autoref_ty: &fn(ast::mutability, ty::Region) -> ty::t)\n         -> Option<method_map_entry>\n     {\n         // This is hokey. We should have mutability inference as a\n         // variable.  But for now, try &const, then &, then &mut:\n-        let region = self.infcx().next_region_var(self.expr.span,\n-                                                  self.expr.id);\n+        let region = self.infcx().next_region_var_nb(self.expr.span);\n         for mutbls.each |mutbl| {\n             let autoref_ty = mk_autoref_ty(*mutbl, region);\n             match self.search_for_method(autoref_ty) {\n@@ -812,12 +805,7 @@ pub impl<'self> LookupContext<'self> {\n                         self.self_expr.id,\n                         @ty::AutoDerefRef(ty::AutoDerefRef {\n                             autoderefs: autoderefs,\n-                            autoref: Some(ty::AutoRef {\n-                                kind: kind,\n-                                region: region,\n-                                mutbl: *mutbl,\n-                            }),\n-                        }));\n+                            autoref: Some(kind(region, *mutbl))}));\n                     return Some(mme);\n                 }\n             }\n@@ -1024,8 +1012,7 @@ pub impl<'self> LookupContext<'self> {\n         let (_, opt_transformed_self_ty, fn_sig) =\n             replace_bound_regions_in_fn_sig(\n                 tcx, @Nil, Some(transformed_self_ty), &bare_fn_ty.sig,\n-                |_br| self.fcx.infcx().next_region_var(\n-                    self.expr.span, self.expr.id));\n+                |_br| self.fcx.infcx().next_region_var_nb(self.expr.span));\n         let transformed_self_ty = opt_transformed_self_ty.get();\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {sig: fn_sig, ..bare_fn_ty});\n         debug!(\"after replacing bound regions, fty=%s\", self.ty_to_str(fty));"}, {"sha": "84fc40f6954a8bd808fbaf228cef9172a9d23c12", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -923,11 +923,9 @@ pub impl FnCtxt {\n \n     fn region_var_if_parameterized(&self,\n                                    rp: Option<ty::region_variance>,\n-                                   span: span,\n-                                   lower_bound: ty::Region)\n+                                   span: span)\n                                 -> Option<ty::Region> {\n-        rp.map(\n-            |_rp| self.infcx().next_region_var_with_lb(span, lower_bound))\n+        rp.map(|_rp| self.infcx().next_region_var_nb(span))\n     }\n \n     fn type_error_message(&self,\n@@ -1108,8 +1106,7 @@ pub fn impl_self_ty(vcx: &VtableContext,\n     };\n \n     let self_r = if region_param.is_some() {\n-        Some(vcx.infcx.next_region_var(location_info.span,\n-                                         location_info.id))\n+        Some(vcx.infcx.next_region_var_nb(location_info.span))\n     } else {\n         None\n     };\n@@ -1317,9 +1314,18 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // that they appear in call position.\n         check_expr(fcx, f);\n \n+        // Store the type of `f` as the type of the callee\n+        let fn_ty = fcx.expr_ty(f);\n+\n+        // NOTE here we write the callee type before regions have been\n+        // substituted; in the method case, we write the type after\n+        // regions have been substituted. Methods are correct, but it\n+        // is awkward to deal with this now. Best thing would I think\n+        // be to just have a separate \"callee table\" that contains the\n+        // FnSig and not a general purpose ty::t\n+        fcx.write_ty(call_expr.callee_id, fn_ty);\n \n         // Extract the function signature from `in_fty`.\n-        let fn_ty = fcx.expr_ty(f);\n         let fn_sty = structure_of(fcx, f.span, fn_ty);\n \n         // FIXME(#3678) For now, do not permit calls to C abi functions.\n@@ -1356,7 +1362,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let (_, _, fn_sig) =\n             replace_bound_regions_in_fn_sig(\n                 fcx.tcx(), @Nil, None, &fn_sig,\n-                |_br| fcx.infcx().next_region_var(call_expr.span, call_expr.id));\n+                |_br| fcx.infcx().next_region_var_nb(call_expr.span));\n \n         // Call the generic checker.\n         check_argument_types(fcx, call_expr.span, fn_sig.inputs, f,\n@@ -1936,9 +1942,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         // Generate the struct type.\n         let self_region =\n-            fcx.region_var_if_parameterized(region_parameterized,\n-                                            span,\n-                                            ty::re_scope(id));\n+            fcx.region_var_if_parameterized(region_parameterized, span);\n         let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n         let substitutions = substs {\n             self_r: self_region,\n@@ -2024,9 +2028,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         // Generate the enum type.\n         let self_region =\n-            fcx.region_var_if_parameterized(region_parameterized,\n-                                            span,\n-                                            ty::re_scope(id));\n+            fcx.region_var_if_parameterized(region_parameterized, span);\n         let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n         let substitutions = substs {\n             self_r: self_region,\n@@ -2366,13 +2368,12 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // (and how long it is valid), which we don't know yet until type\n         // inference is complete.\n         //\n-        // Therefore, here we simply generate a region variable with\n-        // the current expression as a lower bound.  The region\n-        // inferencer will then select the ultimate value.  Finally,\n-        // borrowck is charged with guaranteeing that the value whose\n-        // address was taken can actually be made to live as long as\n-        // it needs to live.\n-        let region = fcx.infcx().next_region_var(expr.span, expr.id);\n+        // Therefore, here we simply generate a region variable.  The\n+        // region inferencer will then select the ultimate value.\n+        // Finally, borrowck is charged with guaranteeing that the\n+        // value whose address was taken can actually be made to live\n+        // as long as it needs to live.\n+        let region = fcx.infcx().next_region_var_nb(expr.span);\n \n         let tm = ty::mt { ty: fcx.expr_ty(oprnd), mutbl: mutbl };\n         let oprnd_t = if ty::type_is_error(tm.ty) {\n@@ -2389,8 +2390,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let defn = lookup_def(fcx, pth.span, id);\n \n         let tpt = ty_param_bounds_and_ty_for_def(fcx, expr.span, defn);\n-        let region_lb = ty::re_scope(expr.id);\n-        instantiate_path(fcx, pth, tpt, expr.span, expr.id, region_lb);\n+        instantiate_path(fcx, pth, tpt, expr.span, expr.id);\n       }\n       ast::expr_inline_asm(ref ia) => {\n           fcx.require_unsafe(expr.span, ~\"use of inline assembly\");\n@@ -3258,8 +3258,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n                         pth: @ast::Path,\n                         tpt: ty_param_bounds_and_ty,\n                         span: span,\n-                        node_id: ast::node_id,\n-                        region_lb: ty::Region) {\n+                        node_id: ast::node_id) {\n     debug!(\">>> instantiate_path\");\n \n     let ty_param_count = tpt.generics.type_param_defs.len();\n@@ -3285,8 +3284,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n         }\n       }\n       None => { // no lifetime parameter supplied, insert default\n-        fcx.region_var_if_parameterized(\n-            tpt.generics.region_param, span, region_lb)\n+        fcx.region_var_if_parameterized(tpt.generics.region_param, span)\n       }\n     };\n \n@@ -3370,7 +3368,7 @@ pub fn ast_expr_vstore_to_vstore(fcx: @mut FnCtxt,\n         ast::expr_vstore_uniq => ty::vstore_uniq,\n         ast::expr_vstore_box | ast::expr_vstore_mut_box => ty::vstore_box,\n         ast::expr_vstore_slice | ast::expr_vstore_mut_slice => {\n-            let r = fcx.infcx().next_region_var(e.span, e.id);\n+            let r = fcx.infcx().next_region_var_nb(e.span);\n             ty::vstore_slice(r)\n         }\n     }"}, {"sha": "1c35c911b14cd4a9c7351d69e7da1e2b5cbfb128", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 346, "deletions": 225, "changes": 571, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -28,16 +28,15 @@ this point a bit better.\n */\n \n use middle::freevars::get_freevars;\n-use middle::pat_util::pat_bindings;\n use middle::ty::{re_scope};\n use middle::ty;\n use middle::typeck::check::FnCtxt;\n-use middle::typeck::check::lookup_def;\n use middle::typeck::check::regionmanip::relate_nested_regions;\n use middle::typeck::infer::resolve_and_force_all_but_regions;\n use middle::typeck::infer::resolve_type;\n use util::ppaux::{note_and_explain_region, ty_to_str,\n                   region_to_str};\n+use middle::pat_util;\n \n use syntax::ast::{ManagedSigil, OwnedSigil, BorrowedSigil};\n use syntax::ast::{def_arg, def_binding, def_local, def_self, def_upvar};\n@@ -73,7 +72,11 @@ fn encl_region_of_def(fcx: @mut FnCtxt, def: ast::def) -> ty::Region {\n }\n \n pub impl Rcx {\n-    fn resolve_type(@mut self, unresolved_ty: ty::t) -> ty::t {\n+    fn tcx(&self) -> ty::ctxt {\n+        self.fcx.ccx.tcx\n+    }\n+\n+    fn resolve_type(&mut self, unresolved_ty: ty::t) -> ty::t {\n         /*!\n          * Try to resolve the type for the given node, returning\n          * t_err if an error results.  Note that we never care\n@@ -149,55 +152,121 @@ pub fn regionck_fn(fcx: @mut FnCtxt, blk: &ast::blk) {\n \n fn regionck_visitor() -> rvt {\n     visit::mk_vt(@visit::Visitor {visit_item: visit_item,\n-                                  visit_stmt: visit_stmt,\n                                   visit_expr: visit_expr,\n-                                  visit_block: visit_block,\n+\n+                                  // NOTE this should be visit_pat\n+                                  // but causes errors in formal\n+                                  // arguments in closures due to\n+                                  // #XYZ!\n+                                  //visit_pat: visit_pat,\n+                                  visit_arm: visit_arm,\n                                   visit_local: visit_local,\n+\n+                                  visit_block: visit_block,\n                                   .. *visit::default_visitor()})\n }\n \n fn visit_item(_item: @ast::item, _rcx: @mut Rcx, _v: rvt) {\n     // Ignore items\n }\n \n-fn visit_local(l: @ast::local, rcx: @mut Rcx, v: rvt) {\n-    // Check to make sure that the regions in all local variables are\n-    // within scope.\n-    //\n-    // Note: we do this here rather than in visit_pat because we do\n-    // not wish to constrain the regions in *patterns* in quite the\n-    // same way.  `visit_node()` guarantees that the region encloses\n-    // the node in question, which ultimately constrains the regions\n-    // in patterns to enclose the match expression as a whole.  But we\n-    // want them to enclose the *arm*.  However, regions in patterns\n-    // must either derive from the discriminant or a ref pattern: in\n-    // the case of the discriminant, the regions will be constrained\n-    // when the type of the discriminant is checked.  In the case of a\n-    // ref pattern, the variable is created with a suitable lower\n-    // bound.\n-    let e = rcx.errors_reported;\n-    (v.visit_pat)(l.node.pat, rcx, v);\n-    let def_map = rcx.fcx.ccx.tcx.def_map;\n-    do pat_bindings(def_map, l.node.pat) |_bm, id, sp, _path| {\n-        visit_node(id, sp, rcx);\n-    }\n-    if e != rcx.errors_reported {\n-        return; // if decl has errors, skip initializer expr\n-    }\n+fn visit_block(b: &ast::blk, rcx: @mut Rcx, v: rvt) {\n+    rcx.fcx.tcx().region_maps.record_cleanup_scope(b.node.id);\n+    visit::visit_block(b, rcx, v);\n+}\n \n-    (v.visit_ty)(l.node.ty, rcx, v);\n-    for l.node.init.each |i| {\n-        (v.visit_expr)(*i, rcx, v);\n+fn visit_arm(arm: &ast::arm, rcx: @mut Rcx, v: rvt) {\n+    // see above\n+    for arm.pats.each |&p| {\n+        constrain_bindings_in_pat(p, rcx);\n     }\n+\n+    visit::visit_arm(arm, rcx, v);\n }\n \n-fn visit_block(b: &ast::blk, rcx: @mut Rcx, v: rvt) {\n-    visit::visit_block(b, rcx, v);\n+fn visit_local(l: @ast::local, rcx: @mut Rcx, v: rvt) {\n+    // see above\n+    constrain_bindings_in_pat(l.node.pat, rcx);\n+    visit::visit_local(l, rcx, v);\n+}\n+\n+fn constrain_bindings_in_pat(pat: @ast::pat, rcx: @mut Rcx) {\n+    let tcx = rcx.fcx.tcx();\n+    debug!(\"regionck::visit_pat(pat=%s)\", pat.repr(tcx));\n+    do pat_util::pat_bindings(tcx.def_map, pat) |_, id, span, _| {\n+        // If we have a variable that contains region'd data, that\n+        // data will be accessible from anywhere that the variable is\n+        // accessed. We must be wary of loops like this:\n+        //\n+        //     // from src/test/compile-fail/borrowck-lend-flow.rs\n+        //     let mut v = ~3, w = ~4;\n+        //     let mut x = &mut w;\n+        //     loop {\n+        //         **x += 1;   // (2)\n+        //         borrow(v);  //~ ERROR cannot borrow\n+        //         x = &mut v; // (1)\n+        //     }\n+        //\n+        // Typically, we try to determine the region of a borrow from\n+        // those points where it is dereferenced. In this case, one\n+        // might imagine that the lifetime of `x` need only be the\n+        // body of the loop. But of course this is incorrect because\n+        // the pointer that is created at point (1) is consumed at\n+        // point (2), meaning that it must be live across the loop\n+        // iteration. The easiest way to guarantee this is to require\n+        // that the lifetime of any regions that appear in a\n+        // variable's type enclose at least the variable's scope.\n+\n+        let encl_region = tcx.region_maps.encl_region(id);\n+        constrain_regions_in_type_of_node(rcx, id, encl_region, span);\n+    }\n }\n \n fn visit_expr(expr: @ast::expr, rcx: @mut Rcx, v: rvt) {\n     debug!(\"regionck::visit_expr(e=%s)\", rcx.fcx.expr_to_str(expr));\n \n+    let has_method_map = rcx.fcx.inh.method_map.contains_key(&expr.id);\n+\n+    // Record cleanup scopes, which are used by borrowck to decide the\n+    // maximum lifetime of a temporary rvalue.  These were derived by\n+    // examining where trans creates block scopes, not because this\n+    // reflects some principled decision around temporary lifetimes.\n+    // Ordinarily this would seem like something that should be setup\n+    // in region, but we need to know which uses of operators are\n+    // overloaded.  See #3511.\n+    let tcx = rcx.fcx.tcx();\n+    match expr.node {\n+        ast::expr_index(*) |\n+        ast::expr_binary(*) |\n+        ast::expr_assign_op(*) |\n+        ast::expr_unary(*) if has_method_map => {\n+            tcx.region_maps.record_cleanup_scope(expr.id);\n+        }\n+        ast::expr_binary(ast::and, lhs, rhs) |\n+        ast::expr_binary(ast::or, lhs, rhs) => {\n+            tcx.region_maps.record_cleanup_scope(lhs.id);\n+            tcx.region_maps.record_cleanup_scope(rhs.id);\n+        }\n+        ast::expr_call(*) |\n+        ast::expr_method_call(*) => {\n+            tcx.region_maps.record_cleanup_scope(expr.id);\n+        }\n+        ast::expr_match(_, ref arms) => {\n+            tcx.region_maps.record_cleanup_scope(expr.id);\n+            for arms.each |arm| {\n+                for arm.guard.each |guard| {\n+                    tcx.region_maps.record_cleanup_scope(guard.id);\n+                }\n+            }\n+        }\n+        ast::expr_while(cond, ref body) => {\n+            tcx.region_maps.record_cleanup_scope(cond.id);\n+            tcx.region_maps.record_cleanup_scope(body.node.id);\n+        }\n+        _ => {}\n+    }\n+\n+    // Check any autoderefs or autorefs that appear.\n     for rcx.fcx.inh.adjustments.find(&expr.id).each |&adjustment| {\n         debug!(\"adjustment=%?\", adjustment);\n         match *adjustment {\n@@ -208,65 +277,54 @@ fn visit_expr(expr: @ast::expr, rcx: @mut Rcx, v: rvt) {\n                 constrain_derefs(rcx, expr, autoderefs, expr_ty);\n                 for opt_autoref.each |autoref| {\n                     guarantor::for_autoref(rcx, expr, autoderefs, autoref);\n+\n+                    // Require that the resulting region encompasses\n+                    // the current node.\n+                    //\n+                    // FIXME(#5074) remove to support nested method calls\n+                    constrain_regions_in_type_of_node(\n+                        rcx, expr.id, ty::re_scope(expr.id), expr.span);\n                 }\n             }\n             _ => {}\n         }\n     }\n \n     match expr.node {\n-        ast::expr_path(*) => {\n-            // Avoid checking the use of local variables, as we\n-            // already check their definitions.  The def'n always\n-            // encloses the use.  So if the def'n is enclosed by the\n-            // region, then the uses will also be enclosed (and\n-            // otherwise, an error will have been reported at the\n-            // def'n site).\n-            match lookup_def(rcx.fcx, expr.span, expr.id) {\n-                ast::def_local(*) | ast::def_arg(*) |\n-                ast::def_upvar(*) => return,\n-                _ => ()\n-            }\n+        ast::expr_call(callee, ref args, _) => {\n+            constrain_callee(rcx, expr, callee);\n+            constrain_call(rcx, expr, None, *args, false);\n         }\n \n-        ast::expr_call(callee, ref args, _) => {\n-            // Check for a.b() where b is a method.  Ensure that\n-            // any types in the callee are valid for the entire\n-            // method call.\n-\n-            // FIXME(#3387)--we should really invoke\n-            // `constrain_auto_ref()` on all exprs.  But that causes a\n-            // lot of spurious errors because of how the region\n-            // hierarchy is setup.\n-            if rcx.fcx.inh.method_map.contains_key(&callee.id) {\n-                match callee.node {\n-                    ast::expr_field(base, _, _) => {\n-                        constrain_auto_ref(rcx, base);\n-                    }\n-                    _ => {\n-                        // This can happen if you have code like\n-                        // (x[0])() where `x[0]` is overloaded.  Just\n-                        // ignore it.\n-                    }\n-                }\n-            } else {\n-                constrain_auto_ref(rcx, callee);\n-            }\n+        ast::expr_method_call(arg0, _, _, ref args, _) => {\n+            constrain_call(rcx, expr, Some(arg0), *args, false);\n+        }\n \n-            for args.each |arg| {\n-                constrain_auto_ref(rcx, *arg);\n-            }\n+        ast::expr_index(lhs, rhs) |\n+        ast::expr_assign_op(_, lhs, rhs) |\n+        ast::expr_binary(_, lhs, rhs) if has_method_map => {\n+            // As `expr_method_call`, but the call is via an\n+            // overloaded op.  Note that we (sadly) currently use an\n+            // implicit \"by ref\" sort of passing style here.  This\n+            // should be converted to an adjustment!\n+            constrain_call(rcx, expr, Some(lhs), [rhs], true);\n         }\n \n-        ast::expr_method_call(rcvr, _, _, ref args, _) => {\n-            // Check for a.b() where b is a method.  Ensure that\n-            // any types in the callee are valid for the entire\n-            // method call.\n+        ast::expr_unary(_, lhs) if has_method_map => {\n+            // As above.\n+            constrain_call(rcx, expr, Some(lhs), [], true);\n+        }\n \n-            constrain_auto_ref(rcx, rcvr);\n-            for args.each |arg| {\n-                constrain_auto_ref(rcx, *arg);\n-            }\n+        ast::expr_unary(ast::deref, base) => {\n+            // For *a, the lifetime of a must enclose the deref\n+            let base_ty = rcx.resolve_node_type(base.id);\n+            constrain_derefs(rcx, expr, 1, base_ty);\n+        }\n+\n+        ast::expr_index(vec_expr, _) => {\n+            // For a[b], the lifetime of a must enclose the deref\n+            let vec_type = rcx.resolve_expr_type_adjusted(vec_expr);\n+            constrain_index(rcx, expr, vec_type);\n         }\n \n         ast::expr_cast(source, _) => {\n@@ -294,25 +352,27 @@ fn visit_expr(expr: @ast::expr, rcx: @mut Rcx, v: rvt) {\n             }\n         }\n \n-        ast::expr_index(vec_expr, _) => {\n-            let vec_type = rcx.resolve_expr_type_adjusted(vec_expr);\n-            constrain_index(rcx, expr, vec_type);\n-        }\n-\n-        ast::expr_unary(ast::deref, base) => {\n-            let base_ty = rcx.resolve_node_type(base.id);\n-            constrain_derefs(rcx, expr, 1, base_ty);\n-        }\n-\n         ast::expr_addr_of(_, base) => {\n             guarantor::for_addr_of(rcx, expr, base);\n+\n+            // Require that when you write a `&expr` expression, the\n+            // resulting pointer has a lifetime that encompasses the\n+            // `&expr` expression itself. Note that we constraining\n+            // the type of the node expr.id here *before applying\n+            // adjustments*.\n+            //\n+            // FIXME(#5074) nested method calls requires that this rule change\n+            let ty0 = rcx.resolve_node_type(expr.id);\n+            constrain_regions_in_type(rcx, ty::re_scope(expr.id), expr.span, ty0);\n         }\n \n         ast::expr_match(discr, ref arms) => {\n             guarantor::for_match(rcx, discr, *arms);\n         }\n \n         ast::expr_fn_block(*) => {\n+            // The lifetime of a block fn must not outlive the variables\n+            // it closes over\n             let function_type = rcx.resolve_node_type(expr.id);\n             match ty::get(function_type).sty {\n                 ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil,\n@@ -326,46 +386,107 @@ fn visit_expr(expr: @ast::expr, rcx: @mut Rcx, v: rvt) {\n         _ => ()\n     }\n \n-    if !visit_node(expr.id, expr.span, rcx) { return; }\n     visit::visit_expr(expr, rcx, v);\n }\n \n-fn visit_stmt(s: @ast::stmt, rcx: @mut Rcx, v: rvt) {\n-    visit::visit_stmt(s, rcx, v);\n-}\n+fn constrain_callee(rcx: @mut Rcx,\n+                    call_expr: @ast::expr,\n+                    callee_expr: @ast::expr)\n+{\n+    let tcx = rcx.fcx.tcx();\n \n-fn visit_node(id: ast::node_id, span: span, rcx: @mut Rcx) -> bool {\n-    /*!\n-     *\n-     * checks the type of the node `id` and reports an error if it\n-     * references a region that is not in scope for that node.\n-     * Returns false if an error is reported; this is used to cause us\n-     * to cut off region checking for that subtree to avoid reporting\n-     * tons of errors. */\n-\n-    let fcx = rcx.fcx;\n-\n-    // find the region where this expr evaluation is taking place\n-    let tcx = fcx.ccx.tcx;\n-    let encl_region = match tcx.region_maps.opt_encl_scope(id) {\n-        None => ty::re_static,\n-        Some(r) => ty::re_scope(r)\n-    };\n-\n-    // Otherwise, look at the type and see if it is a region pointer.\n-    constrain_regions_in_type_of_node(rcx, id, encl_region, span)\n+    let call_region = ty::re_scope(call_expr.id);\n+\n+    let callee_ty = rcx.resolve_node_type(call_expr.callee_id);\n+    if ty::type_is_error(callee_ty) {\n+        return;\n+    }\n+\n+    match ty::get(callee_ty).sty {\n+        ty::ty_bare_fn(*) => { }\n+        ty::ty_closure(ref closure_ty) => {\n+            match rcx.fcx.mk_subr(true, callee_expr.span,\n+                                  call_region, closure_ty.region) {\n+                result::Err(_) => {\n+                    tcx.sess.span_err(\n+                        callee_expr.span,\n+                        fmt!(\"cannot invoke closure outside of its lifetime\"));\n+                    note_and_explain_region(\n+                        tcx,\n+                        \"the closure is only valid for \",\n+                        closure_ty.region,\n+                        \"\");\n+                }\n+                result::Ok(_) => {}\n+            }\n+        }\n+        _ => {\n+            tcx.sess.span_bug(\n+                callee_expr.span,\n+                fmt!(\"Calling non-function: %s\", callee_ty.repr(tcx)));\n+        }\n+    }\n }\n \n-fn encl_region_or_static(rcx: @mut Rcx, expr: @ast::expr) -> ty::Region {\n-    // FIXME(#3850) --- interactions with modes compel overly large granularity\n-    // that is, we would probably prefer to just return re_scope(expr.id)\n-    // here but we cannot just yet.\n+fn constrain_call(rcx: @mut Rcx,\n+                  // might be expr_call, expr_method_call, or an overloaded\n+                  // operator\n+                  call_expr: @ast::expr,\n+                  receiver: Option<@ast::expr>,\n+                  arg_exprs: &[@ast::expr],\n+                  implicitly_ref_args: bool)\n+{\n+    //! Invoked on every call site (i.e., normal calls, method calls,\n+    //! and overloaded operators). Constrains the regions which appear\n+    //! in the type of the function. Also constrains the regions that\n+    //! appear in the arguments appropriately.\n \n     let tcx = rcx.fcx.tcx();\n-    match tcx.region_maps.opt_encl_scope(expr.id) {\n-        Some(s) => ty::re_scope(s),\n-        None => ty::re_static // occurs in constants\n+    debug!(\"constrain_call(call_expr=%s, implicitly_ref_args=%?)\",\n+           call_expr.repr(tcx), implicitly_ref_args);\n+    let callee_ty = rcx.resolve_node_type(call_expr.callee_id);\n+    if ty::type_is_error(callee_ty) {\n+        return;\n     }\n+    let fn_sig = ty::ty_fn_sig(callee_ty);\n+\n+    // `callee_region` is the scope representing the time in which the\n+    // call occurs.\n+    //\n+    // FIXME(#5074) to support nested method calls, should be callee_id\n+    let callee_scope = call_expr.id;\n+    let callee_region = ty::re_scope(callee_scope);\n+\n+    for fn_sig.inputs.eachi |i, input| {\n+        // ensure that any regions appearing in the argument type are\n+        // valid for at least the lifetime of the function:\n+        constrain_regions_in_type_of_node(\n+            rcx, arg_exprs[i].id, callee_region, arg_exprs[i].span);\n+\n+        // unfortunately, there are two means of taking implicit\n+        // references, and we need to propagate constraints as a\n+        // result. modes are going away and the \"DerefArgs\" code\n+        // should be ported to use adjustments\n+        ty::set_default_mode(tcx, input.mode, ast::by_copy);\n+        let is_by_ref = ty::resolved_mode(tcx, input.mode) == ast::by_ref;\n+        if implicitly_ref_args || is_by_ref {\n+            guarantor::for_by_ref(rcx, arg_exprs[i], callee_scope);\n+        }\n+    }\n+\n+    // as loop above, but for receiver\n+    for receiver.each |&r| {\n+        constrain_regions_in_type_of_node(\n+            rcx, r.id, callee_region, r.span);\n+        if implicitly_ref_args {\n+            guarantor::for_by_ref(rcx, r, callee_scope);\n+        }\n+    }\n+\n+    // constrain regions that may appear in the return type to be\n+    // valid for the function call:\n+    constrain_regions_in_type(\n+        rcx, callee_region, call_expr.span, fn_sig.output);\n }\n \n fn constrain_derefs(rcx: @mut Rcx,\n@@ -379,9 +500,8 @@ fn constrain_derefs(rcx: @mut Rcx,\n      * pointer being derefenced, the lifetime of the pointer includes\n      * the deref expr.\n      */\n-\n     let tcx = rcx.fcx.tcx();\n-    let r_deref_expr = encl_region_or_static(rcx, deref_expr);\n+    let r_deref_expr = ty::re_scope(deref_expr.id);\n     for uint::range(0, derefs) |i| {\n         debug!(\"constrain_derefs(deref_expr=%s, derefd_ty=%s, derefs=%?/%?\",\n                rcx.fcx.expr_to_str(deref_expr),\n@@ -390,19 +510,8 @@ fn constrain_derefs(rcx: @mut Rcx,\n \n         match ty::get(derefd_ty).sty {\n             ty::ty_rptr(r_ptr, _) => {\n-                match rcx.fcx.mk_subr(true, deref_expr.span, r_deref_expr, r_ptr) {\n-                    result::Ok(*) => {}\n-                    result::Err(*) => {\n-                        tcx.sess.span_err(\n-                            deref_expr.span,\n-                            fmt!(\"dereference of reference outside its lifetime\"));\n-                        note_and_explain_region(\n-                            tcx,\n-                            \"the reference is only valid for \",\n-                            r_ptr,\n-                            \"\");\n-                    }\n-                }\n+                mk_subregion_due_to_derefence(rcx, deref_expr.span,\n+                                              r_deref_expr, r_ptr);\n             }\n \n             _ => {}\n@@ -417,6 +526,27 @@ fn constrain_derefs(rcx: @mut Rcx,\n     }\n }\n \n+pub fn mk_subregion_due_to_derefence(rcx: @mut Rcx,\n+                                     deref_span: span,\n+                                     minimum_lifetime: ty::Region,\n+                                     maximum_lifetime: ty::Region) {\n+    match rcx.fcx.mk_subr(true, deref_span,\n+                          minimum_lifetime, maximum_lifetime) {\n+        result::Ok(*) => {}\n+        result::Err(*) => {\n+            rcx.tcx().sess.span_err(\n+                deref_span,\n+                fmt!(\"dereference of reference outside its lifetime\"));\n+            note_and_explain_region(\n+                rcx.tcx(),\n+                \"the reference is only valid for \",\n+                maximum_lifetime,\n+                \"\");\n+        }\n+    }\n+}\n+\n+\n fn constrain_index(rcx: @mut Rcx,\n                    index_expr: @ast::expr,\n                    indexed_ty: ty::t)\n@@ -433,7 +563,7 @@ fn constrain_index(rcx: @mut Rcx,\n            rcx.fcx.expr_to_str(index_expr),\n            rcx.fcx.infcx().ty_to_str(indexed_ty));\n \n-    let r_index_expr = encl_region_or_static(rcx, index_expr);\n+    let r_index_expr = ty::re_scope(index_expr.id);\n     match ty::get(indexed_ty).sty {\n         ty::ty_estr(ty::vstore_slice(r_ptr)) |\n         ty::ty_evec(_, ty::vstore_slice(r_ptr)) => {\n@@ -456,66 +586,22 @@ fn constrain_index(rcx: @mut Rcx,\n     }\n }\n \n-fn constrain_auto_ref(rcx: @mut Rcx, expr: @ast::expr) {\n-    /*!\n-     *\n-     * If `expr` is auto-ref'd (e.g., as part of a borrow), then this\n-     * function ensures that the lifetime of the resulting borrowed\n-     * ptr includes at least the expression `expr`. */\n-\n-    debug!(\"constrain_auto_ref(expr=%s)\", rcx.fcx.expr_to_str(expr));\n-\n-    let adjustment = rcx.fcx.inh.adjustments.find(&expr.id);\n-    let region = match adjustment {\n-        Some(&@ty::AutoDerefRef(\n-            ty::AutoDerefRef {\n-                autoref: Some(ref auto_ref), _})) => {\n-            auto_ref.region\n-        }\n-        _ => { return; }\n-    };\n-\n-    let tcx = rcx.fcx.tcx();\n-    let encl_region = tcx.region_maps.encl_region(expr.id);\n-    match rcx.fcx.mk_subr(true, expr.span, encl_region, region) {\n-        result::Ok(()) => {}\n-        result::Err(_) => {\n-            // In practice, this cannot happen: `region` is always a\n-            // region variable, and constraints on region variables\n-            // are collected and then resolved later.  However, I\n-            // included the span_err() here (rather than, say,\n-            // span_bug()) because it seemed more future-proof: if,\n-            // for some reason, the code were to change so that in\n-            // some cases `region` is not a region variable, then\n-            // reporting an error would be the correct path.\n-            tcx.sess.span_err(\n-                expr.span,\n-                ~\"lifetime of borrowed pointer does not include \\\n-                  the expression being borrowed\");\n-            note_and_explain_region(\n-                tcx,\n-                ~\"lifetime of the borrowed pointer is\",\n-                region,\n-                ~\"\");\n-            rcx.errors_reported += 1;\n-        }\n-    }\n-}\n-\n-fn constrain_free_variables(\n-    rcx: @mut Rcx,\n-    region: ty::Region,\n-    expr: @ast::expr) {\n+fn constrain_free_variables(rcx: @mut Rcx,\n+                            region: ty::Region,\n+                            expr: @ast::expr) {\n     /*!\n-     *\n      * Make sure that all free variables referenced inside the closure\n-     * outlive the closure itself. */\n+     * outlive the closure itself.\n+     */\n \n     let tcx = rcx.fcx.ccx.tcx;\n+    debug!(\"constrain_free_variables(%s, %s)\",\n+           region.repr(tcx), expr.repr(tcx));\n     for get_freevars(tcx, expr.id).each |freevar| {\n         debug!(\"freevar def is %?\", freevar.def);\n         let def = freevar.def;\n         let en_region = encl_region_of_def(rcx.fcx, def);\n+        debug!(\"en_region = %s\", en_region.repr(tcx));\n         match rcx.fcx.mk_subr(true, freevar.span,\n                               region, en_region) {\n           result::Ok(()) => {}\n@@ -541,9 +627,13 @@ fn constrain_free_variables(\n fn constrain_regions_in_type_of_node(\n     rcx: @mut Rcx,\n     id: ast::node_id,\n-    encl_region: ty::Region,\n+    minimum_lifetime: ty::Region,\n     span: span) -> bool\n {\n+    //! Guarantees that any lifetimes which appear in the type of\n+    //! the node `id` (after applying adjustments) are valid for at\n+    //! least `minimum_lifetime`\n+\n     let tcx = rcx.fcx.tcx();\n \n     // Try to resolve the type.  If we encounter an error, then typeck\n@@ -553,22 +643,21 @@ fn constrain_regions_in_type_of_node(\n     let adjustment = rcx.fcx.inh.adjustments.find(&id);\n     let ty = ty::adjust_ty(tcx, span, ty0, adjustment);\n     debug!(\"constrain_regions_in_type_of_node(\\\n-            ty=%s, ty0=%s, id=%d, encl_region=%?, adjustment=%?)\",\n+            ty=%s, ty0=%s, id=%d, minimum_lifetime=%?, adjustment=%?)\",\n            ty_to_str(tcx, ty), ty_to_str(tcx, ty0),\n-           id, encl_region, adjustment);\n-    constrain_regions_in_type(rcx, encl_region, span, ty)\n+           id, minimum_lifetime, adjustment);\n+    constrain_regions_in_type(rcx, minimum_lifetime, span, ty)\n }\n \n fn constrain_regions_in_type(\n     rcx: @mut Rcx,\n-    encl_region: ty::Region,\n+    minimum_lifetime: ty::Region,\n     span: span,\n     ty: ty::t) -> bool\n {\n     /*!\n-     *\n      * Requires that any regions which appear in `ty` must be\n-     * superregions of `encl_region`.  Also enforces the constraint\n+     * superregions of `minimum_lifetime`.  Also enforces the constraint\n      * that given a pointer type `&'r T`, T must not contain regions\n      * that outlive 'r, as well as analogous constraints for other\n      * lifetime'd types.\n@@ -583,24 +672,24 @@ fn constrain_regions_in_type(\n     let e = rcx.errors_reported;\n     let tcx = rcx.fcx.ccx.tcx;\n \n-    debug!(\"constrain_regions_in_type(encl_region=%s, ty=%s)\",\n-           region_to_str(tcx, encl_region),\n+    debug!(\"constrain_regions_in_type(minimum_lifetime=%s, ty=%s)\",\n+           region_to_str(tcx, minimum_lifetime),\n            ty_to_str(tcx, ty));\n \n-    do relate_nested_regions(tcx, Some(encl_region), ty) |r_sub, r_sup| {\n+    do relate_nested_regions(tcx, Some(minimum_lifetime), ty) |r_sub, r_sup| {\n         debug!(\"relate(r_sub=%s, r_sup=%s)\",\n                region_to_str(tcx, r_sub),\n                region_to_str(tcx, r_sup));\n \n         if r_sup.is_bound() || r_sub.is_bound() {\n             // a bound region is one which appears inside an fn type.\n             // (e.g., the `&` in `fn(&T)`).  Such regions need not be\n-            // constrained by `encl_region` as they are placeholders\n+            // constrained by `minimum_lifetime` as they are placeholders\n             // for regions that are as-yet-unknown.\n         } else {\n             match rcx.fcx.mk_subr(true, span, r_sub, r_sup) {\n                 result::Err(_) => {\n-                    if r_sub == encl_region {\n+                    if r_sub == minimum_lifetime {\n                         tcx.sess.span_err(\n                             span,\n                             fmt!(\"reference is not valid outside of its lifetime\"));\n@@ -639,7 +728,6 @@ fn constrain_regions_in_type(\n \n pub mod guarantor {\n     /*!\n-     *\n      * The routines in this module are aiming to deal with the case\n      * where a the contents of a borrowed pointer are re-borrowed.\n      * Imagine you have a borrowed pointer `b` with lifetime L1 and\n@@ -686,35 +774,35 @@ pub mod guarantor {\n      */\n \n     use middle::typeck::check::regionck::{Rcx, infallibly_mk_subr};\n+    use middle::typeck::check::regionck::mk_subregion_due_to_derefence;\n     use middle::ty;\n     use syntax::ast;\n     use syntax::codemap::span;\n     use util::ppaux::{ty_to_str};\n \n     pub fn for_addr_of(rcx: @mut Rcx, expr: @ast::expr, base: @ast::expr) {\n         /*!\n-         *\n          * Computes the guarantor for an expression `&base` and then\n          * ensures that the lifetime of the resulting pointer is linked\n          * to the lifetime of its guarantor (if any).\n          */\n \n         debug!(\"guarantor::for_addr_of(base=%s)\", rcx.fcx.expr_to_str(base));\n-        let _i = ::util::common::indenter();\n \n         let guarantor = guarantor(rcx, base);\n         link(rcx, expr.span, expr.id, guarantor);\n     }\n \n     pub fn for_match(rcx: @mut Rcx, discr: @ast::expr, arms: &[ast::arm]) {\n         /*!\n-         *\n          * Computes the guarantors for any ref bindings in a match and\n          * then ensures that the lifetime of the resulting pointer is\n          * linked to the lifetime of its guarantor (if any).\n          */\n \n+        debug!(\"regionck::for_match()\");\n         let discr_guarantor = guarantor(rcx, discr);\n+        debug!(\"discr_guarantor=%s\", discr_guarantor.repr(rcx.tcx()));\n         for arms.each |arm| {\n             for arm.pats.each |pat| {\n                 link_ref_bindings_in_pat(rcx, *pat, discr_guarantor);\n@@ -727,7 +815,6 @@ pub mod guarantor {\n                        autoderefs: uint,\n                        autoref: &ty::AutoRef) {\n         /*!\n-         *\n          * Computes the guarantor for an expression that has an\n          * autoref adjustment and links it to the lifetime of the\n          * autoref.  This is only important when auto re-borrowing\n@@ -736,30 +823,30 @@ pub mod guarantor {\n \n         debug!(\"guarantor::for_autoref(expr=%s, autoref=%?)\",\n                rcx.fcx.expr_to_str(expr), autoref);\n-        let _i = ::util::common::indenter();\n \n         let mut expr_ct = categorize_unadjusted(rcx, expr);\n         debug!(\"    unadjusted cat=%?\", expr_ct.cat);\n         expr_ct = apply_autoderefs(\n             rcx, expr, autoderefs, expr_ct);\n \n-        match autoref.kind {\n-            ty::AutoPtr => {\n+        match *autoref {\n+            ty::AutoPtr(r, _) => {\n                 // In this case, we are implicitly adding an `&`.\n-                maybe_make_subregion(rcx, expr, autoref.region,\n-                                     expr_ct.cat.guarantor);\n+                maybe_make_subregion(rcx, expr, r, expr_ct.cat.guarantor);\n             }\n \n-            ty::AutoBorrowVec |\n-            ty::AutoBorrowVecRef |\n-            ty::AutoBorrowFn => {\n+            ty::AutoBorrowVec(r, _) |\n+            ty::AutoBorrowVecRef(r, _) |\n+            ty::AutoBorrowFn(r) => {\n                 // In each of these cases, what is being borrowed is\n                 // not the (autoderef'd) expr itself but rather the\n                 // contents of the autoderef'd expression (i.e., what\n                 // the pointer points at).\n-                maybe_make_subregion(rcx, expr, autoref.region,\n+                maybe_make_subregion(rcx, expr, r,\n                                      guarantor_of_deref(&expr_ct.cat));\n             }\n+\n+            ty::AutoUnsafe(_) => {}\n         }\n \n         fn maybe_make_subregion(\n@@ -774,6 +861,28 @@ pub mod guarantor {\n         }\n     }\n \n+    pub fn for_by_ref(rcx: @mut Rcx,\n+                      expr: @ast::expr,\n+                      callee_scope: ast::node_id) {\n+        /*!\n+         * Computes the guarantor for cases where the `expr` is\n+         * being passed by implicit reference and must outlive\n+         * `callee_scope`.\n+         */\n+\n+        let tcx = rcx.tcx();\n+        debug!(\"guarantor::for_by_ref(expr=%s, callee_scope=%?)\",\n+               expr.repr(tcx), callee_scope);\n+        let mut expr_cat = categorize(rcx, expr);\n+        debug!(\"guarantor::for_by_ref(expr=%?, callee_scope=%?) category=%?\",\n+               expr.id, callee_scope, expr_cat);\n+        let minimum_lifetime = ty::re_scope(callee_scope);\n+        for expr_cat.guarantor.each |guarantor| {\n+            mk_subregion_due_to_derefence(rcx, expr.span,\n+                                          minimum_lifetime, *guarantor);\n+        }\n+    }\n+\n     fn link(\n         rcx: @mut Rcx,\n         span: span,\n@@ -907,7 +1016,6 @@ pub mod guarantor {\n \n     fn categorize(rcx: @mut Rcx, expr: @ast::expr) -> ExprCategorization {\n         debug!(\"categorize(expr=%s)\", rcx.fcx.expr_to_str(expr));\n-        let _i = ::util::common::indenter();\n \n         let mut expr_ct = categorize_unadjusted(rcx, expr);\n         debug!(\"before adjustments, cat=%?\", expr_ct.cat);\n@@ -928,12 +1036,24 @@ pub mod guarantor {\n                 expr_ct = apply_autoderefs(\n                     rcx, expr, adjustment.autoderefs, expr_ct);\n \n-                for adjustment.autoref.each |autoref| {\n-                    // If there is an autoref, then the result of this\n-                    // expression will be some sort of borrowed pointer.\n-                    expr_ct.cat.guarantor = None;\n-                    expr_ct.cat.pointer = BorrowedPointer(autoref.region);\n-                    debug!(\"autoref, cat=%?\", expr_ct.cat);\n+                match adjustment.autoref {\n+                    None => {\n+                    }\n+                    Some(ty::AutoUnsafe(_)) => {\n+                        expr_ct.cat.guarantor = None;\n+                        expr_ct.cat.pointer = OtherPointer;\n+                        debug!(\"autoref, cat=%?\", expr_ct.cat);\n+                    }\n+                    Some(ty::AutoPtr(r, _)) |\n+                    Some(ty::AutoBorrowVec(r, _)) |\n+                    Some(ty::AutoBorrowVecRef(r, _)) |\n+                    Some(ty::AutoBorrowFn(r)) => {\n+                        // If there is an autoref, then the result of this\n+                        // expression will be some sort of borrowed pointer.\n+                        expr_ct.cat.guarantor = None;\n+                        expr_ct.cat.pointer = BorrowedPointer(r);\n+                        debug!(\"autoref, cat=%?\", expr_ct.cat);\n+                    }\n                 }\n             }\n \n@@ -948,7 +1068,6 @@ pub mod guarantor {\n                              expr: @ast::expr)\n                           -> ExprCategorizationType {\n         debug!(\"categorize_unadjusted(expr=%s)\", rcx.fcx.expr_to_str(expr));\n-        let _i = ::util::common::indenter();\n \n         let guarantor = {\n             if rcx.fcx.inh.method_map.contains_key(&expr.id) {\n@@ -1053,7 +1172,6 @@ pub mod guarantor {\n \n         debug!(\"link_ref_bindings_in_pat(pat=%s, guarantor=%?)\",\n                rcx.fcx.pat_to_str(pat), guarantor);\n-        let _i = ::util::common::indenter();\n \n         match pat.node {\n             ast::pat_wild => {}\n@@ -1069,7 +1187,10 @@ pub mod guarantor {\n                     link_ref_bindings_in_pat(rcx, *p, guarantor);\n                 }\n             }\n-            ast::pat_enum(*) => {}\n+            ast::pat_enum(_, None) => {}\n+            ast::pat_enum(_, Some(ref pats)) => {\n+                link_ref_bindings_in_pats(rcx, pats, guarantor);\n+            }\n             ast::pat_struct(_, ref fpats, _) => {\n                 for fpats.each |fpat| {\n                     link_ref_bindings_in_pat(rcx, fpat.pat, guarantor);"}, {"sha": "cfbd012b7b7cd7b23f71094d2ccf6c5bd2cef2af", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -87,7 +87,7 @@ pub fn replace_bound_regions_in_fn_sig(\n                       to_r: &fn(ty::bound_region) -> ty::Region,\n                       r: ty::Region) -> isr_alist {\n             match r {\n-              ty::re_free(*) | ty::re_static | ty::re_scope(_) |\n+              ty::re_empty | ty::re_free(*) | ty::re_static | ty::re_scope(_) |\n               ty::re_infer(_) => {\n                 isr\n               }\n@@ -153,6 +153,7 @@ pub fn replace_bound_regions_in_fn_sig(\n               }\n \n               // Free regions like these just stay the same:\n+              ty::re_empty |\n               ty::re_static |\n               ty::re_scope(_) |\n               ty::re_free(*) |"}, {"sha": "b7713eaa2fd6e92e8437220e5df3c6c1b96168c7", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -134,23 +134,22 @@ fn resolve_type_vars_for_node(wbcx: @mut WbCtxt, sp: span, id: ast::node_id)\n         }\n \n         Some(&@ty::AutoDerefRef(adj)) => {\n-            let resolved_autoref = match adj.autoref {\n-                Some(ref autoref) => {\n-                    match resolve_region(fcx.infcx(), autoref.region,\n-                                         resolve_all | force_all) {\n-                        Err(e) => {\n-                            // This should not, I think, happen.\n-                            fcx.ccx.tcx.sess.span_err(\n-                                sp, fmt!(\"cannot resolve scope of borrow: %s\",\n-                                         infer::fixup_err_to_str(e)));\n-                            Some(*autoref)\n-                        }\n-                        Ok(r) => {\n-                            Some(ty::AutoRef {region: r, ..*autoref})\n-                        }\n+            let fixup_region = |r| {\n+                match resolve_region(fcx.infcx(), r, resolve_all | force_all) {\n+                    Ok(r1) => r1,\n+                    Err(e) => {\n+                        // This should not, I think, happen.\n+                        fcx.ccx.tcx.sess.span_err(\n+                            sp, fmt!(\"cannot resolve scope of borrow: %s\",\n+                                     infer::fixup_err_to_str(e)));\n+                        r\n                     }\n                 }\n-                None => None\n+            };\n+\n+            let resolved_autoref = match adj.autoref {\n+                None => None,\n+                Some(ref r) => Some(r.map_region(fixup_region))\n             };\n \n             let resolved_adj = @ty::AutoDerefRef(ty::AutoDerefRef {"}, {"sha": "573e4bd579011404e35d1952c5b54c88e1f3a399", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -393,7 +393,7 @@ pub impl CoherenceChecker {\n \n             let pmm = self.crate_context.tcx.provided_methods;\n             match pmm.find(&local_def(impl_id)) {\n-                Some(mis) => {\n+                Some(&mis) => {\n                     // If the trait already has an entry in the\n                     // provided_methods_map, we just need to add this\n                     // method to that entry.\n@@ -426,8 +426,8 @@ pub impl CoherenceChecker {\n                 self.crate_context.coherence_info.inherent_methods\n                     .insert(base_def_id, implementation_list);\n             }\n-            Some(existing_implementation_list) => {\n-                implementation_list = *existing_implementation_list;\n+            Some(&existing_implementation_list) => {\n+                implementation_list = existing_implementation_list;\n             }\n         }\n \n@@ -443,8 +443,8 @@ pub impl CoherenceChecker {\n                 self.crate_context.coherence_info.extension_methods\n                     .insert(trait_id, implementation_list);\n             }\n-            Some(existing_implementation_list) => {\n-                implementation_list = *existing_implementation_list;\n+            Some(&existing_implementation_list) => {\n+                implementation_list = existing_implementation_list;\n             }\n         }\n \n@@ -507,7 +507,7 @@ pub impl CoherenceChecker {\n                 m.insert(self_t, the_impl);\n                 self.crate_context.tcx.trait_impls.insert(trait_t, m);\n             }\n-            Some(m) => {\n+            Some(&m) => {\n                 m.insert(self_t, the_impl);\n             }\n         }"}, {"sha": "3620b609edf3bb4764c27b60bc820be9584d90ab", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -65,7 +65,7 @@ we may want to adjust precisely when coercions occur.\n */\n \n use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowFn};\n-use middle::ty::{AutoDerefRef, AutoRef};\n+use middle::ty::{AutoDerefRef};\n use middle::ty::{vstore_slice, vstore_box, vstore_uniq};\n use middle::ty::{mt};\n use middle::ty;\n@@ -120,9 +120,9 @@ pub impl Coerce {\n                 };\n             }\n \n-            ty::ty_ptr(_) => {\n+            ty::ty_ptr(mt_b) => {\n                 return do self.unpack_actual_value(a) |sty_a| {\n-                    self.coerce_unsafe_ptr(a, sty_a, b)\n+                    self.coerce_unsafe_ptr(a, sty_a, b, mt_b)\n                 };\n             }\n \n@@ -205,11 +205,7 @@ pub impl Coerce {\n         if_ok!(sub.tys(a_borrowed, b));\n         Ok(Some(@AutoDerefRef(AutoDerefRef {\n             autoderefs: 1,\n-            autoref: Some(AutoRef {\n-                kind: AutoPtr,\n-                region: r_borrow,\n-                mutbl: mt_b.mutbl\n-            })\n+            autoref: Some(AutoPtr(r_borrow, mt_b.mutbl))\n         })))\n     }\n \n@@ -235,11 +231,7 @@ pub impl Coerce {\n         if_ok!(self.subtype(a_borrowed, b));\n         Ok(Some(@AutoDerefRef(AutoDerefRef {\n             autoderefs: 0,\n-            autoref: Some(AutoRef {\n-                kind: AutoBorrowVec,\n-                region: r_a,\n-                mutbl: m_imm\n-            })\n+            autoref: Some(AutoBorrowVec(r_a, m_imm))\n         })))\n     }\n \n@@ -268,11 +260,7 @@ pub impl Coerce {\n         if_ok!(sub.tys(a_borrowed, b));\n         Ok(Some(@AutoDerefRef(AutoDerefRef {\n             autoderefs: 0,\n-            autoref: Some(AutoRef {\n-                kind: AutoBorrowVec,\n-                region: r_borrow,\n-                mutbl: mt_b.mutbl\n-            })\n+            autoref: Some(AutoBorrowVec(r_borrow, mt_b.mutbl))\n         })))\n     }\n \n@@ -308,11 +296,7 @@ pub impl Coerce {\n         if_ok!(self.subtype(a_borrowed, b));\n         Ok(Some(@AutoDerefRef(AutoDerefRef {\n             autoderefs: 0,\n-            autoref: Some(AutoRef {\n-                kind: AutoBorrowFn,\n-                region: r_borrow,\n-                mutbl: m_imm\n-            })\n+            autoref: Some(AutoBorrowFn(r_borrow))\n         })))\n     }\n \n@@ -363,7 +347,8 @@ pub impl Coerce {\n     fn coerce_unsafe_ptr(&self,\n                          a: ty::t,\n                          sty_a: &ty::sty,\n-                         b: ty::t) -> CoerceResult\n+                         b: ty::t,\n+                         mt_b: ty::mt) -> CoerceResult\n     {\n         debug!(\"coerce_unsafe_ptr(a=%s, sty_a=%?, b=%s)\",\n                a.inf_str(self.infcx), sty_a,\n@@ -376,10 +361,17 @@ pub impl Coerce {\n             }\n         };\n \n-        // borrowed pointers and unsafe pointers have the same\n-        // representation, so just check that the types which they\n-        // point at are compatible:\n+        // check that the types which they point at are compatible\n         let a_unsafe = ty::mk_ptr(self.infcx.tcx, mt_a);\n-        self.subtype(a_unsafe, b)\n+        if_ok!(self.subtype(a_unsafe, b));\n+\n+        // although borrowed ptrs and unsafe ptrs have the same\n+        // representation, we still register an AutoDerefRef so that\n+        // regionck knows that that the region for `a` must be valid\n+        // here\n+        Ok(Some(@AutoDerefRef(AutoDerefRef {\n+            autoderefs: 1,\n+            autoref: Some(ty::AutoUnsafe(mt_b.mutbl))\n+        })))\n     }\n }"}, {"sha": "4491b04b382ec3b27c03ee9caeddd35f065b748b", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 30, "deletions": 51, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -339,7 +339,7 @@ pub fn fixup_err_to_str(f: fixup_err) -> ~str {\n \n fn new_ValsAndBindings<V:Copy,T:Copy>() -> ValsAndBindings<V, T> {\n     ValsAndBindings {\n-        vals: @mut SmallIntMap::new(),\n+        vals: SmallIntMap::new(),\n         bindings: ~[]\n     }\n }\n@@ -469,28 +469,6 @@ pub fn resolve_region(cx: @mut InferCtxt, r: ty::Region, modes: uint)\n     resolver.resolve_region_chk(r)\n }\n \n-/*\n-fn resolve_borrowings(cx: @mut InferCtxt) {\n-    for cx.borrowings.each |item| {\n-        match resolve_region(cx, item.scope, resolve_all|force_all) {\n-          Ok(region) => {\n-            debug!(\"borrowing for expr %d resolved to region %?, mutbl %?\",\n-                   item.expr_id, region, item.mutbl);\n-            cx.tcx.borrowings.insert(\n-                item.expr_id, {region: region, mutbl: item.mutbl});\n-          }\n-\n-          Err(e) => {\n-            let str = fixup_err_to_str(e);\n-            cx.tcx.sess.span_err(\n-                item.span,\n-                fmt!(\"could not resolve lifetime for borrow: %s\", str));\n-          }\n-        }\n-    }\n-}\n-*/\n-\n trait then {\n     fn then<T:Copy>(&self, f: &fn() -> Result<T,ty::type_err>)\n         -> Result<T,ty::type_err>;\n@@ -554,7 +532,8 @@ struct Snapshot {\n }\n \n pub impl InferCtxt {\n-    fn combine_fields(@mut self, a_is_expected: bool,\n+    fn combine_fields(@mut self,\n+                      a_is_expected: bool,\n                       span: span) -> CombineFields {\n         CombineFields {infcx: self,\n                        a_is_expected: a_is_expected,\n@@ -565,25 +544,24 @@ pub impl InferCtxt {\n         Sub(self.combine_fields(a_is_expected, span))\n     }\n \n-    fn in_snapshot(@mut self) -> bool {\n+    fn in_snapshot(&self) -> bool {\n         self.region_vars.in_snapshot()\n     }\n \n-    fn start_snapshot(@mut self) -> Snapshot {\n-        let this = &mut *self;\n+    fn start_snapshot(&mut self) -> Snapshot {\n         Snapshot {\n             ty_var_bindings_len:\n-                this.ty_var_bindings.bindings.len(),\n+                self.ty_var_bindings.bindings.len(),\n             int_var_bindings_len:\n-                this.int_var_bindings.bindings.len(),\n+                self.int_var_bindings.bindings.len(),\n             float_var_bindings_len:\n-                this.float_var_bindings.bindings.len(),\n+                self.float_var_bindings.bindings.len(),\n             region_vars_snapshot:\n-                this.region_vars.start_snapshot(),\n+                self.region_vars.start_snapshot(),\n         }\n     }\n \n-    fn rollback_to(@mut self, snapshot: &Snapshot) {\n+    fn rollback_to(&mut self, snapshot: &Snapshot) {\n         debug!(\"rollback!\");\n         rollback_to(&mut self.ty_var_bindings, snapshot.ty_var_bindings_len);\n \n@@ -596,7 +574,7 @@ pub impl InferCtxt {\n     }\n \n     /// Execute `f` and commit the bindings if successful\n-    fn commit<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n+    fn commit<T,E>(&mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n         assert!(!self.in_snapshot());\n \n         debug!(\"commit()\");\n@@ -611,7 +589,7 @@ pub impl InferCtxt {\n     }\n \n     /// Execute `f`, unroll bindings on failure\n-    fn try<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n+    fn try<T,E>(&mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n         debug!(\"try()\");\n         do indent {\n             let snapshot = self.start_snapshot();\n@@ -625,7 +603,7 @@ pub impl InferCtxt {\n     }\n \n     /// Execute `f` then unroll any bindings it creates\n-    fn probe<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n+    fn probe<T,E>(&mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n         debug!(\"probe()\");\n         do indent {\n             let snapshot = self.start_snapshot();\n@@ -647,45 +625,47 @@ fn next_simple_var<V:Copy,T:Copy>(\n }\n \n pub impl InferCtxt {\n-    fn next_ty_var_id(@mut self) -> TyVid {\n+    fn next_ty_var_id(&mut self) -> TyVid {\n         let id = self.ty_var_counter;\n         self.ty_var_counter += 1;\n-        let vals = self.ty_var_bindings.vals;\n-        vals.insert(id, Root(Bounds { lb: None, ub: None }, 0u));\n+        {\n+            let vals = &mut self.ty_var_bindings.vals;\n+            vals.insert(id, Root(Bounds { lb: None, ub: None }, 0u));\n+        }\n         return TyVid(id);\n     }\n \n-    fn next_ty_var(@mut self) -> ty::t {\n+    fn next_ty_var(&mut self) -> ty::t {\n         ty::mk_var(self.tcx, self.next_ty_var_id())\n     }\n \n-    fn next_ty_vars(@mut self, n: uint) -> ~[ty::t] {\n+    fn next_ty_vars(&mut self, n: uint) -> ~[ty::t] {\n         vec::from_fn(n, |_i| self.next_ty_var())\n     }\n \n-    fn next_int_var_id(@mut self) -> IntVid {\n+    fn next_int_var_id(&mut self) -> IntVid {\n         IntVid(next_simple_var(&mut self.int_var_counter,\n                                &mut self.int_var_bindings))\n     }\n \n-    fn next_int_var(@mut self) -> ty::t {\n+    fn next_int_var(&mut self) -> ty::t {\n         ty::mk_int_var(self.tcx, self.next_int_var_id())\n     }\n \n-    fn next_float_var_id(@mut self) -> FloatVid {\n+    fn next_float_var_id(&mut self) -> FloatVid {\n         FloatVid(next_simple_var(&mut self.float_var_counter,\n                                  &mut self.float_var_bindings))\n     }\n \n-    fn next_float_var(@mut self) -> ty::t {\n+    fn next_float_var(&mut self) -> ty::t {\n         ty::mk_float_var(self.tcx, self.next_float_var_id())\n     }\n \n-    fn next_region_var_nb(@mut self, span: span) -> ty::Region {\n+    fn next_region_var_nb(&mut self, span: span) -> ty::Region {\n         ty::re_infer(ty::ReVar(self.region_vars.new_region_var(span)))\n     }\n \n-    fn next_region_var_with_lb(@mut self, span: span,\n+    fn next_region_var_with_lb(&mut self, span: span,\n                                lb_region: ty::Region) -> ty::Region {\n         let region_var = self.next_region_var_nb(span);\n \n@@ -697,12 +677,12 @@ pub impl InferCtxt {\n         return region_var;\n     }\n \n-    fn next_region_var(@mut self, span: span, scope_id: ast::node_id)\n+    fn next_region_var(&mut self, span: span, scope_id: ast::node_id)\n                       -> ty::Region {\n         self.next_region_var_with_lb(span, ty::re_scope(scope_id))\n     }\n \n-    fn resolve_regions(@mut self) {\n+    fn resolve_regions(&mut self) {\n         self.region_vars.resolve_regions();\n     }\n \n@@ -722,7 +702,6 @@ pub impl InferCtxt {\n           result::Err(_) => typ\n         }\n     }\n-\n     fn resolve_type_vars_in_trait_ref_if_possible(@mut self,\n                                                   trait_ref: &ty::TraitRef)\n         -> ty::TraitRef\n@@ -786,7 +765,7 @@ pub impl InferCtxt {\n         self.type_error_message(sp, mk_msg, a, Some(err));\n     }\n \n-    fn replace_bound_regions_with_fresh_regions(@mut self,\n+    fn replace_bound_regions_with_fresh_regions(&mut self,\n             span: span,\n             fsig: &ty::FnSig)\n          -> (ty::FnSig, isr_alist) {\n@@ -806,7 +785,7 @@ pub impl InferCtxt {\n     }\n \n     fn fold_regions_in_sig(\n-        @mut self,\n+        &mut self,\n         fn_sig: &ty::FnSig,\n         fldr: &fn(r: ty::Region, in_fn: bool) -> ty::Region) -> ty::FnSig\n     {"}, {"sha": "0761ad5c7b8197f50bd6d8eeaa797be2e6bd923a", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 150, "deletions": 103, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -24,7 +24,7 @@ it's worth spending more time on a more involved analysis.  Moreover,\n regions are a simpler case than types: they don't have aggregate\n structure, for example.\n \n-Unlike normal type inference, which is similar in spirit H-M and thus\n+Unlike normal type inference, which is similar in spirit to H-M and thus\n works progressively, the region type inference works by accumulating\n constraints over the course of a function.  Finally, at the end of\n processing a function, we process and solve the constraints all at\n@@ -130,7 +130,7 @@ of these variables can effectively be unified into a single variable.\n Once SCCs are removed, we are left with a DAG.  At this point, we can\n walk the DAG in toplogical order once to compute the expanding nodes,\n and again in reverse topological order to compute the contracting\n-nodes.The main reason I did not write it this way is that I did not\n+nodes. The main reason I did not write it this way is that I did not\n feel like implementing the SCC and toplogical sort algorithms at the\n moment.\n \n@@ -538,7 +538,7 @@ more convincing in the future.\n \n use middle::ty;\n use middle::ty::{FreeRegion, Region, RegionVid};\n-use middle::ty::{re_static, re_infer, re_free, re_bound};\n+use middle::ty::{re_empty, re_static, re_infer, re_free, re_bound};\n use middle::ty::{re_scope, ReVar, ReSkolemized, br_fresh};\n use middle::typeck::infer::cres;\n use util::common::indenter;\n@@ -547,6 +547,9 @@ use util::ppaux::note_and_explain_region;\n use core::cell::{Cell, empty_cell};\n use core::hashmap::{HashMap, HashSet};\n use core::to_bytes;\n+use core::uint;\n+use core::vec;\n+use core;\n use syntax::codemap::span;\n use syntax::ast;\n \n@@ -572,18 +575,12 @@ impl to_bytes::IterBytes for Constraint {\n     }\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n struct TwoRegions {\n     a: Region,\n     b: Region,\n }\n \n-impl to_bytes::IterBytes for TwoRegions {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.a, &self.b, lsb0, f)\n-    }\n-}\n-\n enum UndoLogEntry {\n     Snapshot,\n     AddVar(RegionVid),\n@@ -637,7 +634,7 @@ pub fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n }\n \n pub impl RegionVarBindings {\n-    fn in_snapshot(&mut self) -> bool {\n+    fn in_snapshot(&self) -> bool {\n         self.undo_log.len() > 0\n     }\n \n@@ -832,7 +829,6 @@ pub impl RegionVarBindings {\n     }\n \n     fn resolve_var(&mut self, rid: RegionVid) -> ty::Region {\n-        debug!(\"RegionVarBindings: resolve_var(%?=%u)\", rid, rid.to_uint());\n         if self.values.is_empty() {\n             self.tcx.sess.span_bug(\n                 self.var_spans[rid.to_uint()],\n@@ -841,29 +837,14 @@ pub impl RegionVarBindings {\n         }\n \n         let v = self.values.with_ref(|values| values[rid.to_uint()]);\n+        debug!(\"RegionVarBindings: resolve_var(%?=%u)=%?\",\n+               rid, rid.to_uint(), v);\n         match v {\n             Value(r) => r,\n \n             NoValue => {\n-                // No constraints, report an error.  It is plausible\n-                // that we could select an arbitrary region here\n-                // instead.  At the moment I am not doing this because\n-                // this generally masks bugs in the inference\n-                // algorithm, and given our syntax one cannot create\n-                // generally create a lifetime variable that isn't\n-                // used in some type, and hence all lifetime variables\n-                // should ultimately have some bounds.\n-\n-                self.tcx.sess.span_err(\n-                    self.var_spans[rid.to_uint()],\n-                    fmt!(\"Unconstrained region variable #%u\", rid.to_uint()));\n-\n-                // Touch of a hack: to suppress duplicate messages,\n-                // replace the NoValue entry with ErrorValue.\n-                let mut values = self.values.take();\n-                values[rid.to_uint()] = ErrorValue;\n-                self.values.put_back(values);\n-                re_static\n+                // No constraints, return ty::re_empty\n+                re_empty\n             }\n \n             ErrorValue => {\n@@ -1031,6 +1012,10 @@ priv impl RegionVarBindings {\n             re_static // nothing lives longer than static\n           }\n \n+          (re_empty, r) | (r, re_empty) => {\n+            r // everything lives longer than empty\n+          }\n+\n           (re_infer(ReVar(v_id)), _) | (_, re_infer(ReVar(v_id))) => {\n             self.tcx.sess.span_bug(\n                 self.var_spans[v_id.to_uint()],\n@@ -1127,6 +1112,11 @@ priv impl RegionVarBindings {\n                 Ok(r)\n             }\n \n+            (re_empty, _) | (_, re_empty) => {\n+                // nothing lives shorter than everything else\n+                Ok(re_empty)\n+            }\n+\n             (re_infer(ReVar(v_id)), _) |\n             (_, re_infer(ReVar(v_id))) => {\n                 self.tcx.sess.span_bug(\n@@ -1266,8 +1256,6 @@ struct SpannedRegion {\n     span: span,\n }\n \n-type TwoRegionsMap = HashSet<TwoRegions>;\n-\n pub impl RegionVarBindings {\n     fn infer_variable_values(&mut self) -> ~[GraphNodeValue] {\n         let mut graph = self.construct_graph();\n@@ -1329,11 +1317,15 @@ pub impl RegionVarBindings {\n                        node_id: RegionVid,\n                        edge_dir: Direction,\n                        edge_idx: uint) {\n+            //! Insert edge `edge_idx` on the link list of edges in direction\n+            //! `edge_dir` for the node `node_id`\n             let edge_dir = edge_dir as uint;\n-            graph.edges[edge_idx].next_edge[edge_dir] =\n-                graph.nodes[node_id.to_uint()].head_edge[edge_dir];\n-            graph.nodes[node_id.to_uint()].head_edge[edge_dir] =\n-                edge_idx;\n+            assert_eq!(graph.edges[edge_idx].next_edge[edge_dir],\n+                       uint::max_value);\n+            let n = node_id.to_uint();\n+            let prev_head = graph.nodes[n].head_edge[edge_dir];\n+            graph.edges[edge_idx].next_edge[edge_dir] = prev_head;\n+            graph.nodes[n].head_edge[edge_dir] = edge_idx;\n         }\n     }\n \n@@ -1484,6 +1476,8 @@ pub impl RegionVarBindings {\n                     }\n                 }\n                 Err(_) => {\n+                    debug!(\"Setting %? to ErrorValue: no glb of %?, %?\",\n+                           a_vid, a_region, b_region);\n                     a_node.value = ErrorValue;\n                     false\n                 }\n@@ -1495,7 +1489,21 @@ pub impl RegionVarBindings {\n         &mut self,\n         graph: &Graph) -> ~[GraphNodeValue]\n     {\n-        let mut dup_map = HashSet::new();\n+        debug!(\"extract_values_and_report_conflicts()\");\n+\n+        // This is the best way that I have found to suppress\n+        // duplicate and related errors. Basically we keep a set of\n+        // flags for every node. Whenever an error occurs, we will\n+        // walk some portion of the graph looking to find pairs of\n+        // conflicting regions to report to the user. As we walk, we\n+        // trip the flags from false to true, and if we find that\n+        // we've already reported an error involving any particular\n+        // node we just stop and don't report the current error.  The\n+        // idea is to report errors that derive from independent\n+        // regions of the graph, but not those that derive from\n+        // overlapping locations.\n+        let mut dup_vec = graph.nodes.map(|_| uint::max_value);\n+\n         graph.nodes.mapi(|idx, node| {\n             match node.value {\n                 Value(_) => {\n@@ -1530,15 +1538,16 @@ pub impl RegionVarBindings {\n                        that is not used is not a problem, so if this rule\n                        starts to create problems we'll have to revisit\n                        this portion of the code and think hard about it. =) */\n+\n                     let node_vid = RegionVid { id: idx };\n                     match node.classification {\n                         Expanding => {\n                             self.report_error_for_expanding_node(\n-                                graph, &mut dup_map, node_vid);\n+                                graph, dup_vec, node_vid);\n                         }\n                         Contracting => {\n                             self.report_error_for_contracting_node(\n-                                graph, &mut dup_map, node_vid);\n+                                graph, dup_vec, node_vid);\n                         }\n                     }\n                 }\n@@ -1548,38 +1557,26 @@ pub impl RegionVarBindings {\n         })\n     }\n \n-    // Used to suppress reporting the same basic error over and over\n-    fn is_reported(&mut self,\n-                   dup_map: &mut TwoRegionsMap,\n-                   r_a: Region,\n-                   r_b: Region)\n-                -> bool {\n-        let key = TwoRegions { a: r_a, b: r_b };\n-        !dup_map.insert(key)\n-    }\n-\n     fn report_error_for_expanding_node(&mut self,\n                                        graph: &Graph,\n-                                       dup_map: &mut TwoRegionsMap,\n+                                       dup_vec: &mut [uint],\n                                        node_idx: RegionVid) {\n         // Errors in expanding nodes result from a lower-bound that is\n         // not contained by an upper-bound.\n-        let lower_bounds =\n-            self.collect_concrete_regions(graph, node_idx, Incoming);\n-        let upper_bounds =\n-            self.collect_concrete_regions(graph, node_idx, Outgoing);\n+        let (lower_bounds, lower_dup) =\n+            self.collect_concrete_regions(graph, node_idx, Incoming, dup_vec);\n+        let (upper_bounds, upper_dup) =\n+            self.collect_concrete_regions(graph, node_idx, Outgoing, dup_vec);\n+\n+        if lower_dup || upper_dup {\n+            return;\n+        }\n \n         for vec::each(lower_bounds) |lower_bound| {\n             for vec::each(upper_bounds) |upper_bound| {\n                 if !self.is_subregion_of(lower_bound.region,\n                                          upper_bound.region) {\n \n-                    if self.is_reported(dup_map,\n-                                        lower_bound.region,\n-                                        upper_bound.region) {\n-                        return;\n-                    }\n-\n                     self.tcx.sess.span_err(\n                         self.var_spans[node_idx.to_uint()],\n                         fmt!(\"cannot infer an appropriate lifetime \\\n@@ -1609,16 +1606,28 @@ pub impl RegionVarBindings {\n                 }\n             }\n         }\n+\n+        self.tcx.sess.span_bug(\n+            self.var_spans[node_idx.to_uint()],\n+            fmt!(\"report_error_for_expanding_node() could not find error \\\n+                  for var %?, lower_bounds=%s, upper_bounds=%s\",\n+                 node_idx,\n+                 lower_bounds.map(|x| x.region).repr(self.tcx),\n+                 upper_bounds.map(|x| x.region).repr(self.tcx)));\n     }\n \n     fn report_error_for_contracting_node(&mut self,\n                                          graph: &Graph,\n-                                         dup_map: &mut TwoRegionsMap,\n+                                         dup_vec: &mut [uint],\n                                          node_idx: RegionVid) {\n         // Errors in contracting nodes result from two upper-bounds\n         // that have no intersection.\n-        let upper_bounds = self.collect_concrete_regions(graph, node_idx,\n-                                                         Outgoing);\n+        let (upper_bounds, dup_found) =\n+            self.collect_concrete_regions(graph, node_idx, Outgoing, dup_vec);\n+\n+        if dup_found {\n+            return;\n+        }\n \n         for vec::each(upper_bounds) |upper_bound_1| {\n             for vec::each(upper_bounds) |upper_bound_2| {\n@@ -1627,12 +1636,6 @@ pub impl RegionVarBindings {\n                   Ok(_) => {}\n                   Err(_) => {\n \n-                    if self.is_reported(dup_map,\n-                                        upper_bound_1.region,\n-                                        upper_bound_2.region) {\n-                        return;\n-                    }\n-\n                     self.tcx.sess.span_err(\n                         self.var_spans[node_idx.to_uint()],\n                         fmt!(\"cannot infer an appropriate lifetime \\\n@@ -1663,50 +1666,94 @@ pub impl RegionVarBindings {\n                 }\n             }\n         }\n+\n+        self.tcx.sess.span_bug(\n+            self.var_spans[node_idx.to_uint()],\n+            fmt!(\"report_error_for_contracting_node() could not find error \\\n+                  for var %?, upper_bounds=%s\",\n+                 node_idx,\n+                 upper_bounds.map(|x| x.region).repr(self.tcx)));\n     }\n \n     fn collect_concrete_regions(&mut self,\n                                 graph: &Graph,\n                                 orig_node_idx: RegionVid,\n-                                dir: Direction)\n-                             -> ~[SpannedRegion] {\n-        let mut set = HashSet::new();\n-        let mut stack = ~[orig_node_idx];\n-        set.insert(orig_node_idx.to_uint());\n-        let mut result = ~[];\n-        while !vec::is_empty(stack) {\n-            let node_idx = stack.pop();\n-            for self.each_edge(graph, node_idx, dir) |edge| {\n+                                dir: Direction,\n+                                dup_vec: &mut [uint])\n+                             -> (~[SpannedRegion], bool) {\n+        struct WalkState {\n+            set: HashSet<RegionVid>,\n+            stack: ~[RegionVid],\n+            result: ~[SpannedRegion],\n+            dup_found: bool\n+        }\n+        let mut state = WalkState {\n+            set: HashSet::new(),\n+            stack: ~[orig_node_idx],\n+            result: ~[],\n+            dup_found: false\n+        };\n+        state.set.insert(orig_node_idx);\n+\n+        // to start off the process, walk the source node in the\n+        // direction specified\n+        process_edges(self, &mut state, graph, orig_node_idx, dir);\n+\n+        while !state.stack.is_empty() {\n+            let node_idx = state.stack.pop();\n+            let classification = graph.nodes[node_idx.to_uint()].classification;\n+\n+            // check whether we've visited this node on some previous walk\n+            if dup_vec[node_idx.to_uint()] == uint::max_value {\n+                dup_vec[node_idx.to_uint()] = orig_node_idx.to_uint();\n+            } else if dup_vec[node_idx.to_uint()] != orig_node_idx.to_uint() {\n+                state.dup_found = true;\n+            }\n+\n+            debug!(\"collect_concrete_regions(orig_node_idx=%?, node_idx=%?, \\\n+                    classification=%?)\",\n+                   orig_node_idx, node_idx, classification);\n+\n+            // figure out the direction from which this node takes its\n+            // values, and search for concrete regions etc in that direction\n+            let dir = match classification {\n+                Expanding => Incoming,\n+                Contracting => Outgoing\n+            };\n+\n+            process_edges(self, &mut state, graph, node_idx, dir);\n+        }\n+\n+        let WalkState {result, dup_found, _} = state;\n+        return (result, dup_found);\n+\n+        fn process_edges(self: &mut RegionVarBindings,\n+                         state: &mut WalkState,\n+                         graph: &Graph,\n+                         source_vid: RegionVid,\n+                         dir: Direction) {\n+            debug!(\"process_edges(source_vid=%?, dir=%?)\", source_vid, dir);\n+\n+            for self.each_edge(graph, source_vid, dir) |edge| {\n                 match edge.constraint {\n-                  ConstrainVarSubVar(from_vid, to_vid) => {\n-                    let vid = match dir {\n-                      Incoming => from_vid,\n-                      Outgoing => to_vid\n-                    };\n-                    if set.insert(vid.to_uint()) {\n-                        stack.push(vid);\n+                    ConstrainVarSubVar(from_vid, to_vid) => {\n+                        let opp_vid =\n+                            if from_vid == source_vid {to_vid} else {from_vid};\n+                        if state.set.insert(opp_vid) {\n+                            state.stack.push(opp_vid);\n+                        }\n                     }\n-                  }\n-\n-                  ConstrainRegSubVar(region, _) => {\n-                    assert!(dir == Incoming);\n-                    result.push(SpannedRegion {\n-                        region: region,\n-                        span: edge.span\n-                    });\n-                  }\n \n-                  ConstrainVarSubReg(_, region) => {\n-                    assert!(dir == Outgoing);\n-                    result.push(SpannedRegion {\n-                        region: region,\n-                        span: edge.span\n-                    });\n-                  }\n+                    ConstrainRegSubVar(region, _) |\n+                    ConstrainVarSubReg(_, region) => {\n+                        state.result.push(SpannedRegion {\n+                            region: region,\n+                            span: edge.span\n+                        });\n+                    }\n                 }\n             }\n         }\n-        return result;\n     }\n \n     fn each_edge(&mut self,"}, {"sha": "8db4774322a05cce76cdb0201001c04776b8b558", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -23,7 +23,7 @@ pub enum VarValue<V, T> {\n }\n \n pub struct ValsAndBindings<V, T> {\n-    vals: @mut SmallIntMap<VarValue<V, T>>,\n+    vals: SmallIntMap<VarValue<V, T>>,\n     bindings: ~[(V, VarValue<V, T>)],\n }\n \n@@ -60,26 +60,25 @@ pub impl InferCtxt {\n             vid: V) -> Node<V, T>\n         {\n             let vid_u = vid.to_uint();\n-            match vb.vals.find(&vid_u) {\n+            let var_val = match vb.vals.find(&vid_u) {\n+                Some(&var_val) => var_val,\n                 None => {\n                     tcx.sess.bug(fmt!(\n                         \"failed lookup of vid `%u`\", vid_u));\n                 }\n-                Some(var_val) => {\n-                    match *var_val {\n-                        Redirect(vid) => {\n-                            let node: Node<V,T> = helper(tcx, vb, vid);\n-                            if node.root != vid {\n-                                // Path compression\n-                                vb.vals.insert(vid.to_uint(),\n-                                               Redirect(node.root));\n-                            }\n-                            node\n-                        }\n-                        Root(ref pt, rk) => {\n-                            Node {root: vid, possible_types: *pt, rank: rk}\n-                        }\n+            };\n+            match var_val {\n+                Redirect(vid) => {\n+                    let node: Node<V,T> = helper(tcx, vb, vid);\n+                    if node.root != vid {\n+                        // Path compression\n+                        vb.vals.insert(vid.to_uint(),\n+                                       Redirect(node.root));\n                     }\n+                    node\n+                }\n+                Root(pt, rk) => {\n+                    Node {root: vid, possible_types: pt, rank: rk}\n                 }\n             }\n         }\n@@ -99,8 +98,8 @@ pub impl InferCtxt {\n \n         { // FIXME(#4903)---borrow checker is not flow sensitive\n             let vb = UnifyVid::appropriate_vals_and_bindings(self);\n-            let old_v = vb.vals.get(&vid.to_uint());\n-            vb.bindings.push((vid, *old_v));\n+            let old_v = { *vb.vals.get(&vid.to_uint()) }; // FIXME(#4903)\n+            vb.bindings.push((vid, old_v));\n             vb.vals.insert(vid.to_uint(), new_v);\n         }\n     }"}, {"sha": "d99d87231becec681a5b1af6ed370da149a87316", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -65,6 +65,9 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n           Some(&ast_map::node_block(ref blk)) => {\n             explain_span(cx, \"block\", blk.span)\n           }\n+          Some(&ast_map::node_callee_scope(expr)) => {\n+              explain_span(cx, \"callee\", expr.span)\n+          }\n           Some(&ast_map::node_expr(expr)) => {\n             match expr.node {\n               ast::expr_call(*) => explain_span(cx, \"call\", expr.span),\n@@ -113,6 +116,8 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n \n       re_static => { (~\"the static lifetime\", None) }\n \n+      re_empty => { (~\"the empty lifetime\", None) }\n+\n       // I believe these cases should not occur (except when debugging,\n       // perhaps)\n       re_infer(_) | re_bound(_) => {\n@@ -212,7 +217,8 @@ pub fn region_to_str_space(cx: ctxt, prefix: &str, region: Region) -> ~str {\n             bound_region_to_str_space(cx, prefix, br)\n         }\n         re_infer(ReVar(_)) => prefix.to_str(),\n-        re_static => fmt!(\"%s'static \", prefix)\n+        re_static => fmt!(\"%s'static \", prefix),\n+        re_empty => fmt!(\"%s'<empty> \", prefix)\n     }\n }\n \n@@ -740,6 +746,15 @@ impl Repr for ty::vstore {\n     }\n }\n \n+impl Repr for ast_map::path_elt {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        match *self {\n+            ast_map::path_mod(id) => id.repr(tcx),\n+            ast_map::path_name(id) => id.repr(tcx)\n+        }\n+    }\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "027bf93b4814f43dc405a1c7e2f2bc5ecb58406e", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -419,26 +419,26 @@ pub struct RWReadMode<'self, T> {\n \n pub impl<'self, T:Const + Owned> RWWriteMode<'self, T> {\n     /// Access the pre-downgrade RWARC in write mode.\n-    fn write<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n+    fn write<U>(&mut self, blk: &fn(x: &mut T) -> U) -> U {\n         match *self {\n             RWWriteMode {\n-                data: ref data,\n+                data: &ref mut data,\n                 token: ref token,\n                 poison: _\n             } => {\n                 do token.write {\n-                    blk(&mut **data)\n+                    blk(data)\n                 }\n             }\n         }\n     }\n     /// Access the pre-downgrade RWARC in write mode with a condvar.\n-    fn write_cond<'x, 'c, U>(&self,\n+    fn write_cond<'x, 'c, U>(&mut self,\n                              blk: &fn(x: &'x mut T, c: &'c Condvar) -> U)\n                           -> U {\n         match *self {\n             RWWriteMode {\n-                data: ref data,\n+                data: &ref mut data,\n                 token: ref token,\n                 poison: ref poison\n             } => {\n@@ -449,7 +449,7 @@ pub impl<'self, T:Const + Owned> RWWriteMode<'self, T> {\n                             failed: &mut *poison.failed,\n                             cond: cond\n                         };\n-                        blk(&mut **data, &cvar)\n+                        blk(data, &cvar)\n                     }\n                 }\n             }"}, {"sha": "d48d7af354b41df3fbb15a15c2e8ec9499ab9106", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -215,16 +215,16 @@ pub struct Bitv {\n     nbits: uint\n }\n \n-priv impl Bitv {\n+fn die() -> ! {\n+    fail!(~\"Tried to do operation on bit vectors with different sizes\");\n+}\n \n-    fn die(&self) -> ! {\n-        fail!(~\"Tried to do operation on bit vectors with different sizes\");\n-    }\n+priv impl Bitv {\n \n     #[inline(always)]\n     fn do_op(&mut self, op: Op, other: &Bitv) -> bool {\n         if self.nbits != other.nbits {\n-            self.die();\n+            die();\n         }\n         match self.rep {\n           Small(ref mut s) => match other.rep {\n@@ -234,10 +234,10 @@ priv impl Bitv {\n               Assign     => s.become(*s1,     self.nbits),\n               Difference => s.difference(*s1, self.nbits)\n             },\n-            Big(_) => self.die()\n+            Big(_) => die()\n           },\n           Big(ref mut s) => match other.rep {\n-            Small(_) => self.die(),\n+            Small(_) => die(),\n             Big(ref s1) => match op {\n               Union      => s.union(*s1,      self.nbits),\n               Intersect  => s.intersect(*s1,  self.nbits),"}, {"sha": "ec4c025180c7f1763357db275d14548aa0dc0575", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -885,8 +885,8 @@ impl io::Reader for TcpSocketBuf {\n                     let ncopy = uint::min(nbuffered, needed);\n                     let dst = ptr::mut_offset(\n                         vec::raw::to_mut_ptr(buf), count);\n-                    let src = ptr::const_offset(\n-                        vec::raw::to_const_ptr(self.data.buf),\n+                    let src = ptr::offset(\n+                        vec::raw::to_ptr(self.data.buf),\n                         self.data.buf_off);\n                     ptr::copy_memory(dst, src, ncopy);\n                     self.data.buf_off += ncopy;\n@@ -969,7 +969,7 @@ impl io::Reader for TcpSocketBuf {\n \n /// Implementation of `io::Reader` trait for a buffered `net::tcp::TcpSocket`\n impl io::Writer for TcpSocketBuf {\n-    pub fn write(&self, data: &const [u8]) {\n+    pub fn write(&self, data: &[u8]) {\n         unsafe {\n             let socket_data_ptr: *TcpSocketData =\n                 &(*((*(self.data)).sock).socket_data);"}, {"sha": "29d108e3ac2b1b9b82faf78c1b3fd15a9d73d122", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -20,9 +20,6 @@ use core::hashmap::{HashMap, HashSet};\n use core::trie::{TrieMap, TrieSet};\n use deque::Deque;\n use dlist::DList;\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n use treemap::{TreeMap, TreeSet};\n \n pub trait Encoder {\n@@ -730,9 +727,6 @@ impl<D: Decoder> Decodable<D> for TrieSet {\n     }\n }\n \n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n impl<\n     E: Encoder,\n     K: Encodable<E> + Eq + TotalOrd,\n@@ -750,9 +744,6 @@ impl<\n     }\n }\n \n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n impl<\n     D: Decoder,\n     K: Decodable<D> + Eq + TotalOrd,\n@@ -771,9 +762,6 @@ impl<\n     }\n }\n \n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n impl<\n     S: Encoder,\n     T: Encodable<S> + Eq + TotalOrd\n@@ -789,9 +777,6 @@ impl<\n     }\n }\n \n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n impl<\n     D: Decoder,\n     T: Decodable<D> + Eq + TotalOrd"}, {"sha": "c153d7f22c0348b8d62ade1ae893faa2d736783e", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 49, "deletions": 21, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -61,6 +61,7 @@ pub fn merge_sort<T:Copy>(v: &const [T], le: Le<T>) -> ~[T] {\n     }\n }\n \n+#[cfg(stage0)]\n fn part<T>(arr: &mut [T], left: uint,\n            right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n     arr[pivot] <-> arr[right];\n@@ -79,6 +80,23 @@ fn part<T>(arr: &mut [T], left: uint,\n     return storage_index;\n }\n \n+#[cfg(not(stage0))]\n+fn part<T>(arr: &mut [T], left: uint,\n+           right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n+    arr[pivot] <-> arr[right];\n+    let mut storage_index: uint = left;\n+    let mut i: uint = left;\n+    while i < right {\n+        if compare_func(&arr[i], &arr[right]) {\n+            arr[i] <-> arr[storage_index];\n+            storage_index += 1;\n+        }\n+        i += 1;\n+    }\n+    arr[storage_index] <-> arr[right];\n+    return storage_index;\n+}\n+\n fn qsort<T>(arr: &mut [T], left: uint,\n             right: uint, compare_func: Le<T>) {\n     if right > left {\n@@ -162,7 +180,8 @@ fn qsort3<T:Copy + Ord + Eq>(arr: &mut [T], left: int, right: int) {\n  */\n pub fn quick_sort3<T:Copy + Ord + Eq>(arr: &mut [T]) {\n     if arr.len() <= 1 { return; }\n-    qsort3(arr, 0, (arr.len() - 1) as int);\n+    let len = arr.len() - 1; // FIXME(#5074) nested calls\n+    qsort3(arr, 0, (len - 1) as int);\n }\n \n pub trait Sort {\n@@ -195,15 +214,20 @@ pub fn tim_sort<T:Copy + Ord>(array: &mut [T]) {\n     let mut idx = 0;\n     let mut remaining = size;\n     loop {\n-        let arr = vec::mut_slice(array, idx, size);\n-        let mut run_len: uint = count_run_ascending(arr);\n-\n-        if run_len < min_run {\n-            let force = if remaining <= min_run {remaining} else {min_run};\n-            let slice = vec::mut_slice(arr, 0, force);\n-            binarysort(slice, run_len);\n-            run_len = force;\n-        }\n+        let run_len: uint = {\n+            // This scope contains the slice `arr` here:\n+            let arr = vec::mut_slice(array, idx, size);\n+            let mut run_len: uint = count_run_ascending(arr);\n+\n+            if run_len < min_run {\n+                let force = if remaining <= min_run {remaining} else {min_run};\n+                let slice = vec::mut_slice(arr, 0, force);\n+                binarysort(slice, run_len);\n+                run_len = force;\n+            }\n+\n+            run_len\n+        };\n \n         ms.push_run(idx, run_len);\n         ms.merge_collapse(array);\n@@ -250,7 +274,7 @@ fn binarysort<T:Copy + Ord>(array: &mut [T], start: uint) {\n fn reverse_slice<T>(v: &mut [T], start: uint, end:uint) {\n     let mut i = start;\n     while i < end / 2 {\n-        util::swap(&mut v[i], &mut v[end - i - 1]);\n+        v[i] <-> v[end - i - 1];\n         i += 1;\n     }\n }\n@@ -433,14 +457,17 @@ impl<T:Copy + Ord> MergeState<T> {\n             self.runs[n+1].len = self.runs[n+2].len;\n         }\n \n-        let slice = vec::mut_slice(array, b1, b1+l1);\n-        let k = gallop_right(&const array[b2], slice, 0);\n+        let k = { // constrain lifetime of slice below\n+            let slice = vec::mut_slice(array, b1, b1+l1);\n+            gallop_right(&const array[b2], slice, 0)\n+        };\n         b1 += k;\n         l1 -= k;\n         if l1 != 0 {\n-            let slice = vec::mut_slice(array, b2, b2+l2);\n-            let l2 = gallop_left(\n-                &const array[b1+l1-1],slice,l2-1);\n+            let l2 = { // constrain lifetime of slice below\n+                let slice = vec::mut_slice(array, b2, b2+l2);\n+                gallop_left(&const array[b1+l1-1],slice,l2-1)\n+            };\n             if l2 > 0 {\n                 if l1 <= l2 {\n                     self.merge_lo(array, b1, l1, b2, l2);\n@@ -621,9 +648,11 @@ impl<T:Copy + Ord> MergeState<T> {\n             loop {\n                 assert!(len2 > 1 && len1 != 0);\n \n-                let tmp_view = vec::mut_slice(array, base1, base1+len1);\n-                count1 = len1 - gallop_right(\n-                    &const tmp[c2], tmp_view, len1-1);\n+                { // constrain scope of tmp_view:\n+                    let tmp_view = vec::mut_slice (array, base1, base1+len1);\n+                    count1 = len1 - gallop_right(\n+                        &const tmp[c2], tmp_view, len1-1);\n+                }\n \n                 if count1 != 0 {\n                     dest -= count1; c1 -= count1; len1 -= count1;\n@@ -636,12 +665,11 @@ impl<T:Copy + Ord> MergeState<T> {\n                 if len2 == 1 { break_outer = true; break; }\n \n                 let count2;\n-                {\n+                { // constrain scope of tmp_view\n                     let tmp_view = vec::mut_slice(tmp, 0, len2);\n                     count2 = len2 - gallop_left(&const array[c1],\n                                                 tmp_view,\n                                                 len2-1);\n-                    // Make tmp_view go out of scope to appease borrowck.\n                 }\n \n                 if count2 != 0 {"}, {"sha": "d9af8b111bba7395ebd76d6a51d1882133c3129b", "filename": "src/libstd/std.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -71,7 +71,6 @@ pub mod rope;\n pub mod smallintmap;\n pub mod sort;\n pub mod dlist;\n-#[cfg(not(stage0))]\n pub mod treemap;\n \n // And ... other stuff"}, {"sha": "eb131b17c2f39ead87049548769d4a1b91ea99a9", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -19,6 +19,7 @@ use diagnostic::span_handler;\n use parse::token::ident_interner;\n use print::pprust;\n use visit;\n+use syntax::parse::token::special_idents;\n \n use core::hashmap::HashMap;\n \n@@ -89,22 +90,20 @@ pub enum ast_node {\n     node_variant(variant, @item, @path),\n     node_expr(@expr),\n     node_stmt(@stmt),\n-    // Locals are numbered, because the alias analysis needs to know in which\n-    // order they are introduced.\n-    node_arg(arg, uint),\n-    node_local(uint),\n+    node_arg,\n+    node_local(ident),\n     // Destructor for a struct\n     node_dtor(Generics, @struct_dtor, def_id, @path),\n     node_block(blk),\n     node_struct_ctor(@struct_def, @item, @path),\n+    node_callee_scope(@expr)\n }\n \n pub type map = @mut HashMap<node_id, ast_node>;\n \n pub struct Ctx {\n     map: map,\n     path: path,\n-    local_id: uint,\n     diag: @span_handler,\n }\n \n@@ -120,9 +119,8 @@ pub fn mk_ast_map_visitor() -> vt {\n         visit_expr: map_expr,\n         visit_stmt: map_stmt,\n         visit_fn: map_fn,\n-        visit_local: map_local,\n-        visit_arm: map_arm,\n         visit_block: map_block,\n+        visit_pat: map_pat,\n         .. *visit::default_visitor()\n     });\n }\n@@ -131,7 +129,6 @@ pub fn map_crate(diag: @span_handler, c: @crate) -> map {\n     let cx = @mut Ctx {\n         map: @mut HashMap::new(),\n         path: ~[],\n-        local_id: 0u,\n         diag: diag,\n     };\n     visit::visit_crate(c, cx, mk_ast_map_visitor());\n@@ -154,7 +151,6 @@ pub fn map_decoded_item(diag: @span_handler,\n     let cx = @mut Ctx {\n         map: map,\n         path: copy path,\n-        local_id: 0,\n         diag: diag,\n     };\n     let v = mk_ast_map_visitor();\n@@ -189,9 +185,7 @@ pub fn map_fn(\n     v: visit::vt<@mut Ctx>\n ) {\n     for decl.inputs.each |a| {\n-        cx.map.insert(a.id,\n-                      node_arg(/* FIXME (#2543) */ copy *a, cx.local_id));\n-        cx.local_id += 1u;\n+        cx.map.insert(a.id, node_arg);\n     }\n     match *fk {\n         visit::fk_dtor(generics, ref attrs, self_id, parent_id) => {\n@@ -222,33 +216,22 @@ pub fn map_block(b: &blk, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     visit::visit_block(b, cx, v);\n }\n \n-pub fn number_pat(cx: @mut Ctx, pat: @pat) {\n-    do ast_util::walk_pat(pat) |p| {\n-        match p.node {\n-          pat_ident(*) => {\n-            cx.map.insert(p.id, node_local(cx.local_id));\n-            cx.local_id += 1u;\n-          }\n-          _ => ()\n+pub fn map_pat(pat: @pat, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n+    match pat.node {\n+        pat_ident(_, path, _) => {\n+            // Note: this is at least *potentially* a pattern...\n+            cx.map.insert(pat.id, node_local(ast_util::path_to_ident(path)));\n         }\n-    };\n-}\n-\n-pub fn map_local(loc: @local, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n-    number_pat(cx, loc.node.pat);\n-    visit::visit_local(loc, cx, v);\n-}\n+        _ => ()\n+    }\n \n-pub fn map_arm(arm: &arm, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n-    number_pat(cx, arm.pats[0]);\n-    visit::visit_arm(arm, cx, v);\n+    visit::visit_pat(pat, cx, v);\n }\n \n pub fn map_method(impl_did: def_id, impl_path: @path,\n                   m: @method, cx: @mut Ctx) {\n     cx.map.insert(m.id, node_method(m, impl_did, impl_path));\n-    cx.map.insert(m.self_id, node_local(cx.local_id));\n-    cx.local_id += 1u;\n+    cx.map.insert(m.self_id, node_local(special_idents::self_));\n }\n \n pub fn map_item(i: @item, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n@@ -317,6 +300,7 @@ pub fn map_item(i: @item, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n         }\n         _ => ()\n     }\n+\n     match i.node {\n         item_mod(_) | item_foreign_mod(_) => {\n             cx.path.push(path_mod(i.ident));\n@@ -352,6 +336,18 @@ pub fn map_struct_def(\n \n pub fn map_expr(ex: @expr, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     cx.map.insert(ex.id, node_expr(ex));\n+    match ex.node {\n+        // Expressions which are or might be calls:\n+        ast::expr_call(*) |\n+        ast::expr_method_call(*) |\n+        ast::expr_index(*) |\n+        ast::expr_binary(*) |\n+        ast::expr_assign_op(*) |\n+        ast::expr_unary(*) => {\n+            cx.map.insert(ex.callee_id, node_callee_scope(ex));\n+        }\n+        _ => {}\n+    }\n     visit::visit_expr(ex, cx, v);\n }\n \n@@ -401,15 +397,18 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n       Some(&node_expr(expr)) => {\n         fmt!(\"expr %s (id=%?)\", pprust::expr_to_str(expr, itr), id)\n       }\n+      Some(&node_callee_scope(expr)) => {\n+        fmt!(\"callee_scope %s (id=%?)\", pprust::expr_to_str(expr, itr), id)\n+      }\n       Some(&node_stmt(stmt)) => {\n         fmt!(\"stmt %s (id=%?)\",\n              pprust::stmt_to_str(stmt, itr), id)\n       }\n-      Some(&node_arg(_, _)) => { // add more info here\n+      Some(&node_arg) => {\n         fmt!(\"arg (id=%?)\", id)\n       }\n-      Some(&node_local(_)) => { // add more info here\n-        fmt!(\"local (id=%?)\", id)\n+      Some(&node_local(ident)) => {\n+        fmt!(\"local (id=%?, name=%s)\", id, *itr.get(ident))\n       }\n       Some(&node_dtor(*)) => { // add more info here\n         fmt!(\"node_dtor (id=%?)\", id)"}, {"sha": "7e24adabdb04831a246c15b44f77fd4d4ea8d850", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -388,8 +388,20 @@ pub struct id_range {\n     max: node_id,\n }\n \n-pub fn empty(range: id_range) -> bool {\n-    range.min >= range.max\n+pub impl id_range {\n+    fn max() -> id_range {\n+        id_range {min: int::max_value,\n+                  max: int::min_value}\n+    }\n+\n+    fn empty(&self) -> bool {\n+        self.min >= self.max\n+    }\n+\n+    fn add(&mut self, id: node_id) {\n+        self.min = int::min(self.min, id);\n+        self.max = int::max(self.max, id + 1);\n+    }\n }\n \n pub fn id_visitor(vfn: @fn(node_id)) -> visit::vt<()> {\n@@ -493,13 +505,11 @@ pub fn visit_ids_for_inlined_item(item: &inlined_item, vfn: @fn(node_id)) {\n }\n \n pub fn compute_id_range(visit_ids_fn: &fn(@fn(node_id))) -> id_range {\n-    let min = @mut int::max_value;\n-    let max = @mut int::min_value;\n+    let result = @mut id_range::max();\n     do visit_ids_fn |id| {\n-        *min = int::min(*min, id);\n-        *max = int::max(*max, id + 1);\n+        result.add(id);\n     }\n-    id_range { min: *min, max: *max }\n+    *result\n }\n \n pub fn compute_id_range_for_inlined_item(item: &inlined_item) -> id_range {"}, {"sha": "7facc181effec23e3952e163d998e5995261bd24", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -246,7 +246,7 @@ pub impl FileMap {\n         // the new charpos must be > the last one (or it's the first one).\n         let lines = &mut *self.lines;\n         assert!((lines.len() == 0) || (lines[lines.len() - 1] < pos));\n-        self.lines.push(pos);\n+        lines.push(pos);\n     }\n \n     // get a line from the list of pre-computed line-beginnings\n@@ -308,7 +308,7 @@ pub impl CodeMap {\n             multibyte_chars: @mut ~[],\n         };\n \n-        self.files.push(filemap);\n+        files.push(filemap);\n \n         return filemap;\n     }"}, {"sha": "7d058f22e4c45c19d86f6318c577b781ab3198bd", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 57, "deletions": 51, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -210,29 +210,29 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n // when a macro expansion occurs, the resulting nodes have the backtrace()\n // -> expn_info of their expansion context stored into their span.\n pub trait ext_ctxt {\n-    fn codemap(@mut self) -> @CodeMap;\n-    fn parse_sess(@mut self) -> @mut parse::ParseSess;\n-    fn cfg(@mut self) -> ast::crate_cfg;\n-    fn call_site(@mut self) -> span;\n-    fn print_backtrace(@mut self);\n-    fn backtrace(@mut self) -> Option<@ExpnInfo>;\n-    fn mod_push(@mut self, mod_name: ast::ident);\n-    fn mod_pop(@mut self);\n-    fn mod_path(@mut self) -> ~[ast::ident];\n-    fn bt_push(@mut self, ei: codemap::ExpnInfo);\n-    fn bt_pop(@mut self);\n-    fn span_fatal(@mut self, sp: span, msg: &str) -> !;\n-    fn span_err(@mut self, sp: span, msg: &str);\n-    fn span_warn(@mut self, sp: span, msg: &str);\n-    fn span_unimpl(@mut self, sp: span, msg: &str) -> !;\n-    fn span_bug(@mut self, sp: span, msg: &str) -> !;\n-    fn bug(@mut self, msg: &str) -> !;\n-    fn next_id(@mut self) -> ast::node_id;\n-    fn trace_macros(@mut self) -> bool;\n-    fn set_trace_macros(@mut self, x: bool);\n+    fn codemap(&self) -> @CodeMap;\n+    fn parse_sess(&self) -> @mut parse::ParseSess;\n+    fn cfg(&self) -> ast::crate_cfg;\n+    fn call_site(&self) -> span;\n+    fn print_backtrace(&self);\n+    fn backtrace(&self) -> Option<@ExpnInfo>;\n+    fn mod_push(&self, mod_name: ast::ident);\n+    fn mod_pop(&self);\n+    fn mod_path(&self) -> ~[ast::ident];\n+    fn bt_push(&self, ei: codemap::ExpnInfo);\n+    fn bt_pop(&self);\n+    fn span_fatal(&self, sp: span, msg: &str) -> !;\n+    fn span_err(&self, sp: span, msg: &str);\n+    fn span_warn(&self, sp: span, msg: &str);\n+    fn span_unimpl(&self, sp: span, msg: &str) -> !;\n+    fn span_bug(&self, sp: span, msg: &str) -> !;\n+    fn bug(&self, msg: &str) -> !;\n+    fn next_id(&self) -> ast::node_id;\n+    fn trace_macros(&self) -> bool;\n+    fn set_trace_macros(&self, x: bool);\n     /* for unhygienic identifier transformation */\n-    fn str_of(@mut self, id: ast::ident) -> ~str;\n-    fn ident_of(@mut self, st: ~str) -> ast::ident;\n+    fn str_of(&self, id: ast::ident) -> ~str;\n+    fn ident_of(&self, st: ~str) -> ast::ident;\n }\n \n pub fn mk_ctxt(parse_sess: @mut parse::ParseSess, cfg: ast::crate_cfg)\n@@ -241,25 +241,31 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess, cfg: ast::crate_cfg)\n         parse_sess: @mut parse::ParseSess,\n         cfg: ast::crate_cfg,\n         backtrace: @mut Option<@ExpnInfo>,\n-        mod_path: ~[ast::ident],\n-        trace_mac: bool\n+\n+        // These two @mut's should really not be here,\n+        // but the self types for CtxtRepr are all wrong\n+        // and there are bugs in the code for object\n+        // types that make this hard to get right at the\n+        // moment. - nmatsakis\n+        mod_path: @mut ~[ast::ident],\n+        trace_mac: @mut bool\n     }\n     impl ext_ctxt for CtxtRepr {\n-        fn codemap(@mut self) -> @CodeMap { self.parse_sess.cm }\n-        fn parse_sess(@mut self) -> @mut parse::ParseSess { self.parse_sess }\n-        fn cfg(@mut self) -> ast::crate_cfg { copy self.cfg }\n-        fn call_site(@mut self) -> span {\n+        fn codemap(&self) -> @CodeMap { self.parse_sess.cm }\n+        fn parse_sess(&self) -> @mut parse::ParseSess { self.parse_sess }\n+        fn cfg(&self) -> ast::crate_cfg { copy self.cfg }\n+        fn call_site(&self) -> span {\n             match *self.backtrace {\n                 Some(@ExpandedFrom(CallInfo {call_site: cs, _})) => cs,\n                 None => self.bug(~\"missing top span\")\n             }\n         }\n-        fn print_backtrace(@mut self) { }\n-        fn backtrace(@mut self) -> Option<@ExpnInfo> { *self.backtrace }\n-        fn mod_push(@mut self, i: ast::ident) { self.mod_path.push(i); }\n-        fn mod_pop(@mut self) { self.mod_path.pop(); }\n-        fn mod_path(@mut self) -> ~[ast::ident] { copy self.mod_path }\n-        fn bt_push(@mut self, ei: codemap::ExpnInfo) {\n+        fn print_backtrace(&self) { }\n+        fn backtrace(&self) -> Option<@ExpnInfo> { *self.backtrace }\n+        fn mod_push(&self, i: ast::ident) { self.mod_path.push(i); }\n+        fn mod_pop(&self) { self.mod_path.pop(); }\n+        fn mod_path(&self) -> ~[ast::ident] { copy *self.mod_path }\n+        fn bt_push(&self, ei: codemap::ExpnInfo) {\n             match ei {\n               ExpandedFrom(CallInfo {call_site: cs, callee: ref callee}) => {\n                 *self.backtrace =\n@@ -270,7 +276,7 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess, cfg: ast::crate_cfg)\n               }\n             }\n         }\n-        fn bt_pop(@mut self) {\n+        fn bt_pop(&self) {\n             match *self.backtrace {\n               Some(@ExpandedFrom(CallInfo {\n                   call_site: span {expn_info: prev, _}, _\n@@ -280,52 +286,52 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess, cfg: ast::crate_cfg)\n               _ => self.bug(~\"tried to pop without a push\")\n             }\n         }\n-        fn span_fatal(@mut self, sp: span, msg: &str) -> ! {\n+        fn span_fatal(&self, sp: span, msg: &str) -> ! {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_fatal(sp, msg);\n         }\n-        fn span_err(@mut self, sp: span, msg: &str) {\n+        fn span_err(&self, sp: span, msg: &str) {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_err(sp, msg);\n         }\n-        fn span_warn(@mut self, sp: span, msg: &str) {\n+        fn span_warn(&self, sp: span, msg: &str) {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_warn(sp, msg);\n         }\n-        fn span_unimpl(@mut self, sp: span, msg: &str) -> ! {\n+        fn span_unimpl(&self, sp: span, msg: &str) -> ! {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_unimpl(sp, msg);\n         }\n-        fn span_bug(@mut self, sp: span, msg: &str) -> ! {\n+        fn span_bug(&self, sp: span, msg: &str) -> ! {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_bug(sp, msg);\n         }\n-        fn bug(@mut self, msg: &str) -> ! {\n+        fn bug(&self, msg: &str) -> ! {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.handler().bug(msg);\n         }\n-        fn next_id(@mut self) -> ast::node_id {\n+        fn next_id(&self) -> ast::node_id {\n             return parse::next_node_id(self.parse_sess);\n         }\n-        fn trace_macros(@mut self) -> bool {\n-            self.trace_mac\n+        fn trace_macros(&self) -> bool {\n+            *self.trace_mac\n         }\n-        fn set_trace_macros(@mut self, x: bool) {\n-            self.trace_mac = x\n+        fn set_trace_macros(&self, x: bool) {\n+            *self.trace_mac = x\n         }\n-        fn str_of(@mut self, id: ast::ident) -> ~str {\n+        fn str_of(&self, id: ast::ident) -> ~str {\n             copy *self.parse_sess.interner.get(id)\n         }\n-        fn ident_of(@mut self, st: ~str) -> ast::ident {\n+        fn ident_of(&self, st: ~str) -> ast::ident {\n             self.parse_sess.interner.intern(@/*bad*/ copy st)\n         }\n     }\n-    let imp: @mut CtxtRepr = @mut CtxtRepr {\n+    let imp: @CtxtRepr = @CtxtRepr {\n         parse_sess: parse_sess,\n         cfg: cfg,\n         backtrace: @mut None,\n-        mod_path: ~[],\n-        trace_mac: false\n+        mod_path: @mut ~[],\n+        trace_mac: @mut false\n     };\n     ((imp) as @ext_ctxt)\n }"}, {"sha": "841f64e0b05023177aaa240af8320b7acb289535", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -27,6 +27,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                    fld: @ast_fold,\n                    orig: @fn(&expr_, span, @ast_fold) -> (expr_, span))\n                 -> (expr_, span) {\n+    let mut cx = cx;\n     match *e {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n@@ -112,6 +113,8 @@ pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n                         fld: @ast_fold,\n                         orig: @fn(&ast::_mod, @ast_fold) -> ast::_mod)\n                      -> ast::_mod {\n+    let mut cx = cx;\n+\n     // Fold the contents first:\n     let module_ = orig(module_, fld);\n "}, {"sha": "7843db55789295d278daf292243de9c13b346408", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -38,11 +38,11 @@ updating the states using rule (2) until there are no changes.\n */\n \n use ext::base::ext_ctxt;\n-use ext::pipes::proto::protocol;\n+use ext::pipes::proto::{protocol_};\n \n use std::bitv::Bitv;\n \n-pub fn analyze(proto: protocol, _cx: @ext_ctxt) {\n+pub fn analyze(proto: &mut protocol_, _cx: @ext_ctxt) {\n     debug!(\"initializing colive analysis\");\n     let num_states = proto.num_states();\n     let mut colive = do (copy proto.states).map_to_vec |state| {"}, {"sha": "ffb55ee50d9924545f12b8a2552f9174cf34a30c", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -138,34 +138,34 @@ pub struct protocol_ {\n \n pub impl protocol_ {\n     /// Get a state.\n-    fn get_state(&mut self, name: ~str) -> state {\n+    fn get_state(&self, name: ~str) -> state {\n         self.states.find(|i| i.name == name).get()\n     }\n \n-    fn get_state_by_id(&mut self, id: uint) -> state { self.states[id] }\n+    fn get_state_by_id(&self, id: uint) -> state { self.states[id] }\n \n-    fn has_state(&mut self, name: ~str) -> bool {\n+    fn has_state(&self, name: ~str) -> bool {\n         self.states.find(|i| i.name == name).is_some()\n     }\n \n-    fn filename(&mut self) -> ~str {\n+    fn filename(&self) -> ~str {\n         ~\"proto://\" + self.name\n     }\n \n-    fn num_states(&mut self) -> uint {\n+    fn num_states(&self) -> uint {\n         let states = &mut *self.states;\n         states.len()\n     }\n \n-    fn has_ty_params(&mut self) -> bool {\n+    fn has_ty_params(&self) -> bool {\n         for self.states.each |s| {\n             if s.generics.ty_params.len() > 0 {\n                 return true;\n             }\n         }\n         false\n     }\n-    fn is_bounded(&mut self) -> bool {\n+    fn is_bounded(&self) -> bool {\n         let bounded = self.bounded.get();\n         bounded\n     }\n@@ -179,7 +179,7 @@ pub impl protocol_ {\n                       generics: ast::Generics)\n                    -> state {\n         let messages = @mut ~[];\n-        let states = &*self.states;\n+        let states = &mut *self.states;\n \n         let state = @state_ {\n             id: states.len(),\n@@ -192,7 +192,7 @@ pub impl protocol_ {\n             proto: self\n         };\n \n-        self.states.push(state);\n+        states.push(state);\n         state\n     }\n }"}, {"sha": "c1acee8e2cd961895bd44d1d094cd56dd274c816", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -491,9 +491,9 @@ pub impl Printer {\n           }\n           END => {\n             debug!(\"print END -> pop END\");\n-            let print_stack = &*self.print_stack;\n+            let print_stack = &mut *self.print_stack;\n             assert!((print_stack.len() != 0u));\n-            self.print_stack.pop();\n+            print_stack.pop();\n           }\n           BREAK(b) => {\n             let top = self.get_top();"}, {"sha": "ff8259e8996999d0358ce3145da8a80cecc6a2a0", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -72,6 +72,12 @@ pub fn end(s: @ps) {\n }\n \n pub fn rust_printer(writer: @io::Writer, intr: @ident_interner) -> @ps {\n+    return rust_printer_annotated(writer, intr, no_ann());\n+}\n+\n+pub fn rust_printer_annotated(writer: @io::Writer,\n+                              intr: @ident_interner,\n+                              ann: pp_ann) -> @ps {\n     return @ps {\n         s: pp::mk_printer(writer, default_columns),\n         cm: None::<@CodeMap>,\n@@ -83,7 +89,7 @@ pub fn rust_printer(writer: @io::Writer, intr: @ident_interner) -> @ps {\n             cur_lit: 0\n         },\n         boxes: @mut ~[],\n-        ann: no_ann()\n+        ann: ann\n     };\n }\n "}, {"sha": "e3a87277622184d6ca2afee42a0b0a2faa7b676a", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -44,10 +44,10 @@ pub impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n             None => (),\n         }\n \n-        let vect = &*self.vect;\n+        let vect = &mut *self.vect;\n         let new_idx = vect.len();\n         self.map.insert(val, new_idx);\n-        self.vect.push(val);\n+        vect.push(val);\n         new_idx\n     }\n "}, {"sha": "a42f640a175a7fbc320c7acfae4a0bce32bd8635", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -22,6 +22,12 @@ use opt_vec::OptVec;\n // children (potentially passing in different contexts to each), call\n // visit::visit_* to apply the default traversal algorithm (again, it can\n // override the context), or prevent deeper traversal by doing nothing.\n+//\n+// Note: it is an important invariant that the default visitor walks the body\n+// of a function in \"execution order\" (more concretely, reverse post-order\n+// with respect to the CFG implied by the AST), meaning that if AST node A may\n+// execute before AST node B, then A is visited first.  The borrow checker in\n+// particular relies on this property.\n \n // Our typesystem doesn't do circular types, so the visitor record can not\n // hold functions that take visitors. A vt enum is used to break the cycle."}, {"sha": "61fb754f7619fa9814e65d634b7a3339c01845f2", "filename": "src/test/compile-fail/access-mode-in-closures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Faccess-mode-in-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Faccess-mode-in-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Faccess-mode-in-closures.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -16,6 +16,6 @@ fn unpack(_unpack: &fn(v: &sty) -> ~[int]) {}\n fn main() {\n     let _foo = unpack(|s| {\n         // Test that `s` is moved here.\n-        match *s { sty(v) => v } //~ ERROR moving out of dereference of immutable & pointer\n+        match *s { sty(v) => v } //~ ERROR cannot move out\n     });\n }"}, {"sha": "85f60f34bdb805d68acb18130deec888ace3ce2a", "filename": "src/test/compile-fail/arc-rw-read-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -17,6 +17,7 @@ fn main() {\n         y = Some(x.downgrade(write_mode));\n         //~^ ERROR cannot infer an appropriate lifetime\n     }\n+    y.get();\n     // Adding this line causes a method unification failure instead\n     // do (&option::unwrap(y)).read |state| { assert!(*state == 1); }\n }"}, {"sha": "c7ae6a0dc6c52ff9b351e4c3a73bb9355cad94bb", "filename": "src/test/compile-fail/arc-rw-write-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -17,6 +17,7 @@ fn main() {\n     do x.write_downgrade |write_mode| {\n         y = Some(write_mode);\n     }\n+    y.get();\n     // Adding this line causes a method unification failure instead\n     // do (&option::unwrap(y)).write |state| { assert!(*state == 1); }\n }"}, {"sha": "1d9249bc17b1fff82291554020d58821b45471bb", "filename": "src/test/compile-fail/attempted-access-non-fatal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fattempted-access-non-fatal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fattempted-access-non-fatal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattempted-access-non-fatal.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -11,6 +11,6 @@\n // Check that bogus field access is non-fatal\n fn main() {\n     let x = 0;\n-    debug!(x.foo); //~ ERROR attempted access of field\n-    debug!(x.bar); //~ ERROR attempted access of field\n+    let _ = x.foo; //~ ERROR attempted access of field\n+    let _ = x.bar; //~ ERROR attempted access of field\n }"}, {"sha": "83baedc78927718371cb00840480a1c6c4532ca9", "filename": "src/test/compile-fail/borrowck-addr-of-upvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-addr-of-upvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-addr-of-upvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-addr-of-upvar.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n fn foo(x: @int) -> @fn() -> &'static int {\n-    let result: @fn() -> &'static int = || &*x;  //~ ERROR illegal borrow\n+    let result: @fn() -> &'static int = || &*x;  //~ ERROR cannot root\n     result\n }\n \n fn bar(x: @int) -> @fn() -> &int {\n-    let result: @fn() -> &int = || &*x; //~ ERROR illegal borrow\n+    let result: @fn() -> &int = || &*x; //~ ERROR cannot root\n     result\n }\n "}, {"sha": "d447d9e4a2288c845fe8dd475fe530a3398673c5", "filename": "src/test/compile-fail/borrowck-assign-comp-idx.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -17,9 +17,11 @@ fn a() {\n     let mut p = ~[1];\n \n     // Create an immutable pointer into p's contents:\n-    let _q: &int = &p[0]; //~ NOTE loan of mutable vec content granted here\n+    let q: &int = &p[0];\n \n-    p[0] = 5; //~ ERROR assigning to mutable vec content prohibited due to outstanding loan\n+    p[0] = 5; //~ ERROR cannot assign\n+\n+    debug!(\"%d\", *q);\n }\n \n fn borrow(_x: &[int], _f: &fn()) {}\n@@ -30,8 +32,8 @@ fn b() {\n \n     let mut p = ~[1];\n \n-    do borrow(p) { //~ NOTE loan of mutable vec content granted here\n-        p[0] = 5; //~ ERROR assigning to mutable vec content prohibited due to outstanding loan\n+    do borrow(p) {\n+        p[0] = 5; //~ ERROR cannot assign to\n     }\n }\n "}, {"sha": "b8c0cbe97433e3cdcd66b9875d897f8f53802da0", "filename": "src/test/compile-fail/borrowck-assign-comp.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -12,32 +12,34 @@ struct point { x: int, y: int }\n \n fn a() {\n     let mut p = point {x: 3, y: 4};\n-    let _q = &p; //~ NOTE loan of mutable local variable granted here\n+    let q = &p;\n \n     // This assignment is illegal because the field x is not\n     // inherently mutable; since `p` was made immutable, `p.x` is now\n     // immutable.  Otherwise the type of &_q.x (&int) would be wrong.\n-    p.x = 5; //~ ERROR assigning to mutable field prohibited due to outstanding loan\n+    p.x = 5; //~ ERROR cannot assign to `p.x`\n+    q.x;\n }\n \n fn c() {\n     // this is sort of the opposite.  We take a loan to the interior of `p`\n     // and then try to overwrite `p` as a whole.\n \n     let mut p = point {x: 3, y: 4};\n-    let _q = &p.y; //~ NOTE loan of mutable local variable granted here\n-    p = point {x: 5, y: 7};//~ ERROR assigning to mutable local variable prohibited due to outstanding loan\n-    copy p;\n+    let q = &p.y;\n+    p = point {x: 5, y: 7};//~ ERROR cannot assign to `p`\n+    p.x; // silence warning\n+    *q; // stretch loan\n }\n \n fn d() {\n     // just for completeness's sake, the easy case, where we take the\n     // address of a subcomponent and then modify that subcomponent:\n \n     let mut p = point {x: 3, y: 4};\n-    let _q = &p.y; //~ NOTE loan of mutable field granted here\n-    p.y = 5; //~ ERROR assigning to mutable field prohibited due to outstanding loan\n-    copy p;\n+    let q = &p.y;\n+    p.y = 5; //~ ERROR cannot assign to `p.y`\n+    *q;\n }\n \n fn main() {"}, {"sha": "f0dc28b736d1668f8e3f86634f26660d6be5225c", "filename": "src/test/compile-fail/borrowck-assign-to-constants.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-constants.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -12,6 +12,6 @@ static foo: int = 5;\n \n fn main() {\n     // assigning to various global constants\n-    None = Some(3); //~ ERROR assigning to static item\n-    foo = 6; //~ ERROR assigning to static item\n+    None = Some(3); //~ ERROR cannot assign to immutable static item\n+    foo = 6; //~ ERROR cannot assign to immutable static item\n }"}, {"sha": "fcaba0adc46eb710860019d8cbaf437e51c5ca90", "filename": "src/test/compile-fail/borrowck-assign-to-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-enum.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -12,5 +12,5 @@ struct foo(int);\n \n fn main() {\n     let x = foo(3);\n-    *x = 4; //~ ERROR assigning to anonymous field\n+    *x = 4; //~ ERROR cannot assign to immutable anonymous field\n }"}, {"sha": "2ee5ecfcb9ce0402496aa90a66bf75862a8b858a", "filename": "src/test/compile-fail/borrowck-assign-to-subfield.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-subfield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-subfield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-subfield.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -34,6 +34,6 @@ fn main() {\n \n     // in these cases we pass through a box, so the mut\n     // of the box is dominant\n-    p.x.a = 2;     //~ ERROR assigning to immutable field\n+    p.x.a = 2;     //~ ERROR cannot assign to immutable field\n     p.z.a = 2;\n }"}, {"sha": "ce95ee94f4252882ff3970b00af53980d5c33af4", "filename": "src/test/compile-fail/borrowck-auto-mut-ref-to-immut-var.rs", "status": "renamed", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-auto-mut-ref-to-immut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-auto-mut-ref-to-immut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-auto-mut-ref-to-immut-var.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -14,18 +14,14 @@ struct Foo {\n     x: int\n }\n \n-trait Stuff {\n-    fn printme(self);\n-}\n-\n-impl<'self> Stuff for &'self mut Foo {\n-    fn printme(self) {\n+pub impl Foo {\n+    fn printme(&mut self) {\n         io::println(fmt!(\"%d\", self.x));\n     }\n }\n \n fn main() {\n     let x = Foo { x: 3 };\n-    x.printme();    //~ ERROR illegal borrow\n+    x.printme();    //~ ERROR cannot borrow\n }\n ", "previous_filename": "src/test/compile-fail/auto-ref-borrowck-failure.rs"}, {"sha": "192fe669f57aedd165ba8af791c12b87bba72d6b", "filename": "src/test/compile-fail/borrowck-autoref-3261.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -17,10 +17,10 @@ pub impl X {\n }\n fn main() {\n     let mut x = X(Right(main));\n-    do (&mut x).with |opt| {  //~ ERROR illegal borrow\n+    do (&mut x).with |opt| {\n         match opt {\n             &Right(ref f) => {\n-                x = X(Left((0,0))); //~ ERROR assigning to captured outer mutable variable\n+                x = X(Left((0,0))); //~ ERROR cannot assign to `x`\n                 (*f)()\n             },\n             _ => fail!()"}, {"sha": "ff1ec38ad6406b992e61475073a98ded1eb6f548", "filename": "src/test/compile-fail/borrowck-bad-nested-calls-free.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-free.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we detect nested calls that could free pointers evaluated\n+// for earlier arguments.\n+\n+fn rewrite(v: &mut ~uint) -> uint {\n+    *v = ~22;\n+    **v\n+}\n+\n+fn add(v: &uint, w: uint) -> uint {\n+    *v + w\n+}\n+\n+fn implicit() {\n+    let mut a = ~1;\n+\n+    // Note the danger here:\n+    //\n+    //    the pointer for the first argument has already been\n+    //    evaluated, but it gets freed when evaluating the second\n+    //    argument!\n+    add(\n+        a,\n+        rewrite(&mut a)); //~ ERROR cannot borrow\n+}\n+\n+fn explicit() {\n+    let mut a = ~1;\n+    add(\n+        &*a,\n+        rewrite(&mut a)); //~ ERROR cannot borrow\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "0adf486b8b3ab30b011b45c82e3e3e089f19cf91", "filename": "src/test/compile-fail/borrowck-bad-nested-calls-move.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-move.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we detect nested calls that could free pointers evaluated\n+// for earlier arguments.\n+\n+fn rewrite(v: &mut ~uint) -> uint {\n+    *v = ~22;\n+    **v\n+}\n+\n+fn add(v: &uint, w: ~uint) -> uint {\n+    *v + *w\n+}\n+\n+fn implicit() {\n+    let mut a = ~1;\n+\n+    // Note the danger here:\n+    //\n+    //    the pointer for the first argument has already been\n+    //    evaluated, but it gets moved when evaluating the second\n+    //    argument!\n+    add(\n+        a,\n+        a); //~ ERROR cannot move\n+}\n+\n+fn explicit() {\n+    let mut a = ~1;\n+    add(\n+        &*a,\n+        a); //~ ERROR cannot move\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "1051c5829ec387cd9e5957a6b48e8f042a13bdec", "filename": "src/test/compile-fail/borrowck-borrow-from-owned-ptr.rs", "status": "modified", "additions": 43, "deletions": 27, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -22,32 +22,37 @@ fn make_foo() -> ~Foo { fail!() }\n \n fn borrow_same_field_twice_mut_mut() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1;\n-    let _bar2 = &mut foo.bar1;  //~ ERROR conflicts with prior loan\n+    let bar1 = &mut foo.bar1;\n+    let _bar2 = &mut foo.bar1;  //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_same_field_twice_mut_imm() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1;\n-    let _bar2 = &foo.bar1;  //~ ERROR conflicts with prior loan\n+    let bar1 = &mut foo.bar1;\n+    let _bar2 = &foo.bar1;  //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_same_field_twice_imm_mut() {\n     let mut foo = make_foo();\n-    let _bar1 = &foo.bar1;\n-    let _bar2 = &mut foo.bar1;  //~ ERROR conflicts with prior loan\n+    let bar1 = &foo.bar1;\n+    let _bar2 = &mut foo.bar1;  //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_same_field_twice_imm_imm() {\n     let mut foo = make_foo();\n-    let _bar1 = &foo.bar1;\n+    let bar1 = &foo.bar1;\n     let _bar2 = &foo.bar1;\n+    *bar1;\n }\n \n-fn borrow_both_mut() {\n+fn borrow_both_fields_mut() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1;\n+    let bar1 = &mut foo.bar1;\n     let _bar2 = &mut foo.bar2;\n+    *bar1;\n }\n \n fn borrow_both_mut_pattern() {\n@@ -59,66 +64,77 @@ fn borrow_both_mut_pattern() {\n \n fn borrow_var_and_pattern() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1;\n+    let bar1 = &mut foo.bar1;\n     match *foo {\n         Foo { bar1: ref mut _bar1, bar2: _ } => {}\n-        //~^ ERROR conflicts with prior loan\n+        //~^ ERROR cannot borrow\n     }\n+    *bar1;\n }\n \n fn borrow_mut_and_base_imm() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1.int1;\n-    let _foo1 = &foo.bar1; //~ ERROR conflicts with prior loan\n-    let _foo2 = &*foo; //~ ERROR conflicts with prior loan\n+    let bar1 = &mut foo.bar1.int1;\n+    let _foo1 = &foo.bar1; //~ ERROR cannot borrow\n+    let _foo2 = &*foo; //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_mut_and_base_mut() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1.int1;\n-    let _foo1 = &mut foo.bar1; //~ ERROR conflicts with prior loan\n+    let bar1 = &mut foo.bar1.int1;\n+    let _foo1 = &mut foo.bar1; //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_mut_and_base_mut2() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1.int1;\n-    let _foo2 = &mut *foo; //~ ERROR conflicts with prior loan\n+    let bar1 = &mut foo.bar1.int1;\n+    let _foo2 = &mut *foo; //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_imm_and_base_mut() {\n     let mut foo = make_foo();\n-    let _bar1 = &foo.bar1.int1;\n-    let _foo1 = &mut foo.bar1; //~ ERROR conflicts with prior loan\n+    let bar1 = &foo.bar1.int1;\n+    let _foo1 = &mut foo.bar1; //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_imm_and_base_mut2() {\n     let mut foo = make_foo();\n-    let _bar1 = &foo.bar1.int1;\n-    let _foo2 = &mut *foo; //~ ERROR conflicts with prior loan\n+    let bar1 = &foo.bar1.int1;\n+    let _foo2 = &mut *foo; //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_imm_and_base_imm() {\n     let mut foo = make_foo();\n-    let _bar1 = &foo.bar1.int1;\n+    let bar1 = &foo.bar1.int1;\n     let _foo1 = &foo.bar1;\n     let _foo2 = &*foo;\n+    *bar1;\n }\n \n fn borrow_mut_and_imm() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1;\n+    let bar1 = &mut foo.bar1;\n     let _foo1 = &foo.bar2;\n+    *bar1;\n }\n \n fn borrow_mut_from_imm() {\n     let foo = make_foo();\n-    let _bar1 = &mut foo.bar1; //~ ERROR illegal borrow\n+    let bar1 = &mut foo.bar1; //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_long_path_both_mut() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1.int1;\n-    let _foo1 = &mut foo.bar2.int2;\n+    let bar1 = &mut foo.bar1.int1;\n+    let foo1 = &mut foo.bar2.int2;\n+    *bar1;\n+    *foo1;\n }\n \n fn main() {}"}, {"sha": "cdcf50c906e3655234f3a9cdd276d505a8e99355", "filename": "src/test/compile-fail/borrowck-borrow-from-stack-variable.rs", "status": "modified", "additions": 41, "deletions": 26, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-stack-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-stack-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-stack-variable.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -22,32 +22,37 @@ fn make_foo() -> Foo { fail!() }\n \n fn borrow_same_field_twice_mut_mut() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1;\n-    let _bar2 = &mut foo.bar1;  //~ ERROR conflicts with prior loan\n+    let bar1 = &mut foo.bar1;\n+    let _bar2 = &mut foo.bar1;  //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_same_field_twice_mut_imm() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1;\n-    let _bar2 = &foo.bar1;  //~ ERROR conflicts with prior loan\n+    let bar1 = &mut foo.bar1;\n+    let _bar2 = &foo.bar1;  //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_same_field_twice_imm_mut() {\n     let mut foo = make_foo();\n-    let _bar1 = &foo.bar1;\n-    let _bar2 = &mut foo.bar1;  //~ ERROR conflicts with prior loan\n+    let bar1 = &foo.bar1;\n+    let _bar2 = &mut foo.bar1;  //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_same_field_twice_imm_imm() {\n     let mut foo = make_foo();\n-    let _bar1 = &foo.bar1;\n+    let bar1 = &foo.bar1;\n     let _bar2 = &foo.bar1;\n+    *bar1;\n }\n \n fn borrow_both_mut() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1;\n+    let bar1 = &mut foo.bar1;\n     let _bar2 = &mut foo.bar2;\n+    *bar1;\n }\n \n fn borrow_both_mut_pattern() {\n@@ -59,66 +64,76 @@ fn borrow_both_mut_pattern() {\n \n fn borrow_var_and_pattern() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1;\n+    let bar1 = &mut foo.bar1;\n     match foo {\n-        Foo { bar1: ref mut _bar1, bar2: _ } => {}\n-        //~^ ERROR conflicts with prior loan\n+        Foo { bar1: ref mut _bar1, bar2: _ } => {} //\n+        //~^ ERROR cannot borrow\n     }\n+    *bar1;\n }\n \n fn borrow_mut_and_base_imm() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1.int1;\n-    let _foo1 = &foo.bar1; //~ ERROR conflicts with prior loan\n-    let _foo2 = &foo; //~ ERROR conflicts with prior loan\n+    let bar1 = &mut foo.bar1.int1;\n+    let _foo1 = &foo.bar1; //~ ERROR cannot borrow\n+    let _foo2 = &foo; //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_mut_and_base_mut() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1.int1;\n-    let _foo1 = &mut foo.bar1; //~ ERROR conflicts with prior loan\n+    let bar1 = &mut foo.bar1.int1;\n+    let _foo1 = &mut foo.bar1; //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_mut_and_base_mut2() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1.int1;\n-    let _foo2 = &mut foo; //~ ERROR conflicts with prior loan\n+    let bar1 = &mut foo.bar1.int1;\n+    let _foo2 = &mut foo; //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_imm_and_base_mut() {\n     let mut foo = make_foo();\n-    let _bar1 = &foo.bar1.int1;\n-    let _foo1 = &mut foo.bar1; //~ ERROR conflicts with prior loan\n+    let bar1 = &foo.bar1.int1;\n+    let _foo1 = &mut foo.bar1; //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_imm_and_base_mut2() {\n     let mut foo = make_foo();\n-    let _bar1 = &foo.bar1.int1;\n-    let _foo2 = &mut foo; //~ ERROR conflicts with prior loan\n+    let bar1 = &foo.bar1.int1;\n+    let _foo2 = &mut foo; //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_imm_and_base_imm() {\n     let mut foo = make_foo();\n-    let _bar1 = &foo.bar1.int1;\n+    let bar1 = &foo.bar1.int1;\n     let _foo1 = &foo.bar1;\n     let _foo2 = &foo;\n+    *bar1;\n }\n \n fn borrow_mut_and_imm() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1;\n+    let bar1 = &mut foo.bar1;\n     let _foo1 = &foo.bar2;\n+    *bar1;\n }\n \n fn borrow_mut_from_imm() {\n     let foo = make_foo();\n-    let _bar1 = &mut foo.bar1; //~ ERROR illegal borrow\n+    let bar1 = &mut foo.bar1; //~ ERROR cannot borrow\n+    *bar1;\n }\n \n fn borrow_long_path_both_mut() {\n     let mut foo = make_foo();\n-    let _bar1 = &mut foo.bar1.int1;\n+    let bar1 = &mut foo.bar1.int1;\n     let _foo1 = &mut foo.bar2.int2;\n+    *bar1;\n }\n \n fn main() {}"}, {"sha": "1e5c4c5cc410c4300769e68505e2cc5e635c740b", "filename": "src/test/compile-fail/borrowck-borrowed-uniq-rvalue-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -28,5 +28,6 @@ fn defer<'r>(x: &'r [&'r str]) -> defer<'r> {\n }\n \n fn main() {\n-    let _x = defer(~[\"Goodbye\", \"world!\"]); //~ ERROR illegal borrow\n+    let x = defer(~[\"Goodbye\", \"world!\"]); //~ ERROR borrowed value does not live long enough\n+    x.x[0];\n }"}, {"sha": "887cb59930ebccc8358662b99a0cc5ed83f99f56", "filename": "src/test/compile-fail/borrowck-borrowed-uniq-rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -15,7 +15,7 @@ use core::hashmap::HashMap;\n fn main() {\n     let mut buggy_map :HashMap<uint, &uint> =\n       HashMap::new::<uint, &uint>();\n-    buggy_map.insert(42, &*~1); //~ ERROR illegal borrow\n+    buggy_map.insert(42, &*~1); //~ ERROR borrowed value does not live long enough\n \n     // but it is ok if we use a temporary\n     let tmp = ~2;"}, {"sha": "be51091c1fd1e0cca2550271df19ef44adaf44c7", "filename": "src/test/compile-fail/borrowck-call-method-from-mut-aliasable.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-call-method-from-mut-aliasable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-call-method-from-mut-aliasable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-call-method-from-mut-aliasable.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -27,13 +27,15 @@ fn a(x: &mut Foo) {\n fn b(x: &Foo) {\n     x.f();\n     x.g();\n-    x.h(); //~ ERROR illegal borrow\n+    x.h(); //~ ERROR cannot borrow\n }\n \n fn c(x: &const Foo) {\n-    x.f(); //~ ERROR illegal borrow unless pure\n+    x.f(); //~ ERROR cannot borrow\n+    //~^ ERROR unsafe borrow\n     x.g();\n-    x.h(); //~ ERROR illegal borrow\n+    x.h(); //~ ERROR cannot borrow\n+    //~^ ERROR unsafe borrow\n }\n \n fn main() {"}, {"sha": "8af10231921aaac5a5774be33bd53ad7c65161e1", "filename": "src/test/compile-fail/borrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -10,9 +10,9 @@\n \n fn main() {\n     let mut _a = 3;\n-    let _b = &mut _a; //~ NOTE loan of mutable local variable granted here\n+    let _b = &mut _a;\n     {\n         let _c = &*_b;\n-        _a = 4; //~ ERROR assigning to mutable local variable prohibited\n+        _a = 4; //~ ERROR cannot assign to `_a`\n     }\n }"}, {"sha": "109753b38e70b09b7d8ed93c1942b5aaf5561975", "filename": "src/test/compile-fail/borrowck-insert-during-each.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -23,8 +23,8 @@ pub impl Foo {\n }\n \n fn bar(f: &mut Foo) {\n-  do f.foo |a| { //~ NOTE prior loan as mutable granted here\n-    f.n.insert(*a); //~ ERROR conflicts with prior loan\n+  do f.foo |a| {\n+    f.n.insert(*a); //~ ERROR cannot borrow\n   }\n }\n "}, {"sha": "8bcd5f9a72e70989164dbc4074cfa7f133070d4a", "filename": "src/test/compile-fail/borrowck-issue-2657-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -10,9 +10,9 @@\n \n fn main() {\n let x = Some(~1);\n-match x { //~ NOTE loan of immutable local variable granted here\n+match x {\n   Some(ref _y) => {\n-    let _a = x; //~ ERROR moving out of immutable local variable prohibited due to outstanding loan\n+    let _a = x; //~ ERROR cannot move\n   }\n   _ => {}\n }"}, {"sha": "fac805c57ca09a3ed53457be72f05c0e0d496c01", "filename": "src/test/compile-fail/borrowck-issue-2657-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-2.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -12,7 +12,7 @@ fn main() {\n let x = Some(~1);\n match x {\n   Some(ref y) => {\n-    let _b = *y; //~ ERROR moving out of dereference of immutable & pointer\n+    let _b = *y; //~ ERROR cannot move out\n   }\n   _ => {}\n }"}, {"sha": "563f63b98be05528580535b642cbc6bc77fd11f6", "filename": "src/test/compile-fail/borrowck-lend-flow-if.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-if.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Note: the borrowck analysis is currently flow-insensitive.\n+// Therefore, some of these errors are marked as spurious and could be\n+// corrected by a simple change to the analysis.  The others are\n+// either genuine or would require more advanced changes.  The latter\n+// cases are noted.\n+\n+fn borrow(_v: &int) {}\n+fn borrow_mut(_v: &mut int) {}\n+fn cond() -> bool { fail!() }\n+fn for_func(_f: &fn() -> bool) { fail!() }\n+fn produce<T>() -> T { fail!(); }\n+\n+fn inc(v: &mut ~int) {\n+    *v = ~(**v + 1);\n+}\n+\n+fn pre_freeze_cond() {\n+    // In this instance, the freeze is conditional and starts before\n+    // the mut borrow.\n+\n+    let mut v = ~3;\n+    let _w;\n+    if cond() {\n+        _w = &v;\n+    }\n+    borrow_mut(v); //~ ERROR cannot borrow\n+}\n+\n+fn pre_freeze_else() {\n+    // In this instance, the freeze and mut borrow are on separate sides\n+    // of the if.\n+\n+    let mut v = ~3;\n+    let _w;\n+    if cond() {\n+        _w = &v;\n+    } else {\n+        borrow_mut(v);\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "b6384ad9590abd826d00dd206ca85f5465d5c623", "filename": "src/test/compile-fail/borrowck-lend-flow-loop.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -0,0 +1,164 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Note: the borrowck analysis is currently flow-insensitive.\n+// Therefore, some of these errors are marked as spurious and could be\n+// corrected by a simple change to the analysis.  The others are\n+// either genuine or would require more advanced changes.  The latter\n+// cases are noted.\n+\n+fn borrow(_v: &int) {}\n+fn borrow_mut(_v: &mut int) {}\n+fn cond() -> bool { fail!() }\n+fn for_func(_f: &fn() -> bool) { fail!() }\n+fn produce<T>() -> T { fail!(); }\n+\n+fn inc(v: &mut ~int) {\n+    *v = ~(**v + 1);\n+}\n+\n+fn loop_overarching_alias_mut() {\n+    // In this instance, the borrow encompasses the entire loop.\n+\n+    let mut v = ~3;\n+    let mut x = &mut v;\n+    **x += 1;\n+    loop {\n+        borrow(v); //~ ERROR cannot borrow\n+    }\n+}\n+\n+fn block_overarching_alias_mut() {\n+    // In this instance, the borrow encompasses the entire closure call.\n+\n+    let mut v = ~3;\n+    let mut x = &mut v;\n+    for 3.times {\n+        borrow(v); //~ ERROR cannot borrow\n+    }\n+    *x = ~5;\n+}\n+\n+fn loop_aliased_mut() {\n+    // In this instance, the borrow is carried through the loop.\n+\n+    let mut v = ~3, w = ~4;\n+    let mut _x = &w;\n+    loop {\n+        borrow_mut(v); //~ ERROR cannot borrow\n+        _x = &v;\n+    }\n+}\n+\n+fn while_aliased_mut() {\n+    // In this instance, the borrow is carried through the loop.\n+\n+    let mut v = ~3, w = ~4;\n+    let mut _x = &w;\n+    while cond() {\n+        borrow_mut(v); //~ ERROR cannot borrow\n+        _x = &v;\n+    }\n+}\n+\n+fn for_loop_aliased_mut() {\n+    // In this instance, the borrow is carried through the loop.\n+\n+    let mut v = ~3, w = ~4;\n+    let mut _x = &w;\n+    for for_func {\n+        borrow_mut(v); //~ ERROR cannot borrow\n+        _x = &v;\n+    }\n+}\n+\n+fn loop_aliased_mut_break() {\n+    // In this instance, the borrow is carried through the loop.\n+\n+    let mut v = ~3, w = ~4;\n+    let mut _x = &w;\n+    loop {\n+        borrow_mut(v);\n+        _x = &v;\n+        break;\n+    }\n+    borrow_mut(v); //~ ERROR cannot borrow\n+}\n+\n+fn while_aliased_mut_break() {\n+    // In this instance, the borrow is carried through the loop.\n+\n+    let mut v = ~3, w = ~4;\n+    let mut _x = &w;\n+    while cond() {\n+        borrow_mut(v);\n+        _x = &v;\n+        break;\n+    }\n+    borrow_mut(v); //~ ERROR cannot borrow\n+}\n+\n+fn for_aliased_mut_break() {\n+    // In this instance, the borrow is carried through the loop.\n+\n+    let mut v = ~3, w = ~4;\n+    let mut _x = &w;\n+    for for_func {\n+        // here we cannot be sure that `for_func` respects the break below\n+        borrow_mut(v); //~ ERROR cannot borrow\n+        _x = &v;\n+        break;\n+    }\n+    borrow_mut(v); //~ ERROR cannot borrow\n+}\n+\n+fn while_aliased_mut_cond(cond: bool, cond2: bool) {\n+    let mut v = ~3, w = ~4;\n+    let mut x = &mut w;\n+    while cond {\n+        **x += 1;\n+        borrow(v); //~ ERROR cannot borrow\n+        if cond2 {\n+            x = &mut v; //~ ERROR cannot borrow\n+        }\n+    }\n+}\n+\n+fn loop_break_pops_scopes<'r>(_v: &'r mut [uint], f: &fn(&'r mut uint) -> bool) {\n+    // Here we check that when you break out of an inner loop, the\n+    // borrows that go out of scope as you exit the inner loop are\n+    // removed from the bitset.\n+\n+    while cond() {\n+        while cond() {\n+            // this borrow is limited to the scope of `r`...\n+            let r: &'r mut uint = produce();\n+            if !f(&mut *r) {\n+                break; // ...so it is not live as exit the `while` loop here\n+            }\n+        }\n+    }\n+}\n+\n+fn loop_loop_pops_scopes<'r>(_v: &'r mut [uint], f: &fn(&'r mut uint) -> bool) {\n+    // Similar to `loop_break_pops_scopes` but for the `loop` keyword\n+\n+    while cond() {\n+        while cond() {\n+            // this borrow is limited to the scope of `r`...\n+            let r: &'r mut uint = produce();\n+            if !f(&mut *r) {\n+                loop; // ...so it is not live as exit (and re-enter) the `while` loop here\n+            }\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "7603fdc82a824c91c632b42b5ea5b439654bcb4c", "filename": "src/test/compile-fail/borrowck-lend-flow-match.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-pretty -- comments are infaithfully preserved\n+\n+#[allow(unused_variable)];\n+#[allow(dead_assignment)];\n+\n+fn cond() -> bool { fail!() }\n+fn link<'a>(v: &'a uint, w: &mut &'a uint) -> bool { *w = v; true }\n+\n+fn separate_arms() {\n+    // Here both arms perform assignments, but only is illegal.\n+\n+    let mut x = None;\n+    match x {\n+        None => {\n+            // It is ok to reassign x here, because there is in\n+            // fact no outstanding loan of x!\n+            x = Some(0);\n+        }\n+        Some(ref _i) => {\n+            x = Some(1); //~ ERROR cannot assign\n+        }\n+    }\n+    copy x; // just to prevent liveness warnings\n+}\n+\n+fn guard() {\n+    // Here the guard performs a borrow. This borrow \"infects\" all\n+    // subsequent arms (but not the prior ones).\n+\n+    let mut a = ~3;\n+    let mut b = ~4;\n+    let mut w = &*a;\n+    match 22 {\n+        _ if cond() => {\n+            b = ~5;\n+        }\n+\n+        _ if link(&*b, &mut w) => {\n+            b = ~6; //~ ERROR cannot assign\n+        }\n+\n+        _ => {\n+            b = ~7; //~ ERROR cannot assign\n+        }\n+    }\n+\n+    b = ~8; //~ ERROR cannot assign\n+}\n+\n+fn main() {}"}, {"sha": "59cac0c5d953a8f8f180f4d533c15ff5eac32d99", "filename": "src/test/compile-fail/borrowck-lend-flow.rs", "status": "modified", "additions": 17, "deletions": 76, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -15,96 +15,37 @@\n // cases are noted.\n \n fn borrow(_v: &int) {}\n+fn borrow_mut(_v: &mut int) {}\n+fn cond() -> bool { fail!() }\n+fn for_func(_f: &fn() -> bool) { fail!() }\n+fn produce<T>() -> T { fail!(); }\n \n fn inc(v: &mut ~int) {\n     *v = ~(**v + 1);\n }\n \n-fn post_aliased_const() {\n-    let mut v = ~3;\n-    borrow(v);\n-    let _w = &const v;\n-}\n-\n-fn post_aliased_mut() {\n-    // SPURIOUS--flow\n-    let mut v = ~3;\n-    borrow(v); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n-    let _w = &mut v; //~ NOTE prior loan as mutable granted here\n-}\n+fn pre_freeze() {\n+    // In this instance, the freeze starts before the mut borrow.\n \n-fn post_aliased_scope(cond: bool) {\n     let mut v = ~3;\n-    borrow(v);\n-    if cond { inc(&mut v); }\n+    let _w = &v;\n+    borrow_mut(v); //~ ERROR cannot borrow\n }\n \n-fn loop_overarching_alias_mut() {\n-    let mut v = ~3;\n-    let mut _x = &mut v; //~ NOTE prior loan as mutable granted here\n-    loop {\n-        borrow(v); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n-    }\n-}\n+fn pre_const() {\n+    // In this instance, the freeze starts before the mut borrow.\n \n-fn block_overarching_alias_mut() {\n     let mut v = ~3;\n-    let mut _x = &mut v; //~ NOTE prior loan as mutable granted here\n-    for 3.times {\n-        borrow(v); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n-    }\n-}\n-\n-fn loop_aliased_mut() {\n-    let mut v = ~3, w = ~4;\n-    let mut _x = &mut w;\n-    loop {\n-        borrow(v); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n-        _x = &mut v; //~ NOTE prior loan as mutable granted here\n-    }\n-}\n-\n-fn while_aliased_mut(cond: bool) {\n-    let mut v = ~3, w = ~4;\n-    let mut _x = &mut w;\n-    while cond {\n-        borrow(v); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n-        _x = &mut v; //~ NOTE prior loan as mutable granted here\n-    }\n-}\n-\n-fn while_aliased_mut_cond(cond: bool, cond2: bool) {\n-    let mut v = ~3, w = ~4;\n-    let mut _x = &mut w;\n-    while cond {\n-        borrow(v); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n-        if cond2 {\n-            _x = &mut v; //~ NOTE prior loan as mutable granted here\n-        }\n-    }\n-}\n-\n-fn loop_in_block() {\n-    let mut v = ~3, w = ~4;\n-    let mut _x = &mut w;\n-    for uint::range(0u, 10u) |_i| {\n-        borrow(v); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n-        _x = &mut v; //~ NOTE prior loan as mutable granted here\n-    }\n+    let _w = &const v;\n+    borrow_mut(v);\n }\n \n-fn at_most_once_block() {\n-    fn at_most_once(f: &fn()) { f() }\n+fn post_freeze() {\n+    // In this instance, the const alias starts after the borrow.\n \n-    // Here, the borrow check has no way of knowing that the block is\n-    // executed at most once.\n-\n-    let mut v = ~3, w = ~4;\n-    let mut _x = &mut w;\n-    do at_most_once {\n-        borrow(v); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n-        _x = &mut v; //~ NOTE prior loan as mutable granted here\n-    }\n+    let mut v = ~3;\n+    borrow_mut(v);\n+    let _w = &v;\n }\n \n fn main() {}"}, {"sha": "50dd815d4930234c55a9714011caef2a0f9201ee", "filename": "src/test/compile-fail/borrowck-loan-blocks-move-cc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -14,17 +14,17 @@ fn borrow(v: &int, f: &fn(x: &int)) {\n \n fn box_imm() {\n     let v = ~3;\n-    let _w = &v; //~ NOTE loan of immutable local variable granted here\n+    let _w = &v;\n     do task::spawn {\n         debug!(\"v=%d\", *v);\n-        //~^ ERROR by-move capture of immutable local variable prohibited due to outstanding loan\n+        //~^ ERROR cannot move `v` into closure\n     }\n \n     let v = ~3;\n-    let _w = &v; //~ NOTE loan of immutable local variable granted here\n+    let _w = &v;\n     task::spawn(|| {\n         debug!(\"v=%d\", *v);\n-        //~^ ERROR by-move capture of immutable local variable prohibited due to outstanding loan\n+        //~^ ERROR cannot move\n     });\n }\n "}, {"sha": "b9a79f4f3b1b182d79ce1006a3813b178c63ee65", "filename": "src/test/compile-fail/borrowck-loan-blocks-move.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -13,8 +13,8 @@ fn take(_v: ~int) {\n \n fn box_imm() {\n     let v = ~3;\n-    let _w = &v; //~ NOTE loan of immutable local variable granted here\n-    take(v); //~ ERROR moving out of immutable local variable prohibited due to outstanding loan\n+    let _w = &v;\n+    take(v); //~ ERROR cannot move out of `v` because it is borrowed\n }\n \n fn main() {"}, {"sha": "f8415a38573c438e8a693ef22712b09ac97609dc", "filename": "src/test/compile-fail/borrowck-loan-blocks-mut-uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -14,8 +14,8 @@ fn borrow(v: &int, f: &fn(x: &int)) {\n \n fn box_imm() {\n     let mut v = ~3;\n-    do borrow(v) |w| { //~ NOTE loan of mutable local variable granted here\n-        v = ~4; //~ ERROR assigning to captured outer mutable variable in a stack closure prohibited due to outstanding loan\n+    do borrow(v) |w| {\n+        v = ~4; //~ ERROR cannot assign to `v` because it is borrowed\n         assert!(*v == 3);\n         assert!(*w == 4);\n     }"}, {"sha": "f369bf208c2ce12b186e4bca4f1ab4f4737a558f", "filename": "src/test/compile-fail/borrowck-loan-local-as-both-mut-and-imm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -22,13 +22,13 @@ use core::either::{Either, Left, Right};\n \n     fn g() {\n         let mut x: Either<int,float> = Left(3);\n-        io::println(f(&mut x, &x).to_str()); //~ ERROR conflicts with prior loan\n+        io::println(f(&mut x, &x).to_str()); //~ ERROR cannot borrow\n     }\n \n     fn h() {\n         let mut x: Either<int,float> = Left(3);\n         let y: &Either<int, float> = &x;\n-        let z: &mut Either<int, float> = &mut x; //~ ERROR conflicts with prior loan\n+        let z: &mut Either<int, float> = &mut x; //~ ERROR cannot borrow\n         *z = *y;\n     } \n "}, {"sha": "8c9d3009e5e67f3820f18ebefad67cf4f8b13bae", "filename": "src/test/compile-fail/borrowck-loan-rcvr-overloaded-op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct Point { \n+struct Point {\n     x: int,\n     y: int,\n }\n@@ -38,10 +38,10 @@ fn b() {\n \n     // Here I create an outstanding loan and check that we get conflicts:\n \n-    let q = &mut p; //~ NOTE prior loan as mutable granted here\n+    let q = &mut p;\n \n     p + 3;  // ok for pure fns\n-    p.times(3); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n+    p.times(3); //~ ERROR cannot borrow `p`\n \n     q.x += 1;\n }"}, {"sha": "decf6228fc65845611ed7b91b2fb7f3345531247", "filename": "src/test/compile-fail/borrowck-loan-rcvr.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -13,30 +13,25 @@ struct point { x: int, y: int }\n trait methods {\n     fn impurem(&self);\n     fn blockm(&self, f: &fn());\n-    fn purem(&self);\n }\n \n impl methods for point {\n     fn impurem(&self) {\n     }\n \n     fn blockm(&self, f: &fn()) { f() }\n-\n-    fn purem(&self) {\n-    }\n }\n \n fn a() {\n     let mut p = point {x: 3, y: 4};\n \n     // Here: it's ok to call even though receiver is mutable, because we\n     // can loan it out.\n-    p.purem();\n     p.impurem();\n \n     // But in this case we do not honor the loan:\n-    do p.blockm { //~ NOTE loan of mutable local variable granted here\n-        p.x = 10; //~ ERROR assigning to mutable field prohibited due to outstanding loan\n+    do p.blockm {\n+        p.x = 10; //~ ERROR cannot assign\n     }\n }\n \n@@ -45,20 +40,21 @@ fn b() {\n \n     // Here I create an outstanding loan and check that we get conflicts:\n \n-    let l = &mut p; //~ NOTE prior loan as mutable granted here\n-    //~^ NOTE prior loan as mutable granted here\n-\n-    p.purem(); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n-    p.impurem(); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n+    let l = &mut p;\n+    p.impurem(); //~ ERROR cannot borrow\n \n     l.x += 1;\n }\n \n fn c() {\n-    // Loaning @mut as & is considered legal due to dynamic checks:\n+    // Loaning @mut as & is considered legal due to dynamic checks...\n     let q = @mut point {x: 3, y: 4};\n-    q.purem();\n     q.impurem();\n+\n+    // ...but we still detect errors statically when we can.\n+    do q.blockm {\n+        q.x = 10; //~ ERROR cannot assign\n+    }\n }\n \n fn main() {"}, {"sha": "6a8e64377aab22898a4afd171b5a370c8952cc51", "filename": "src/test/compile-fail/borrowck-loan-vec-content.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -24,8 +24,8 @@ fn has_mut_vec_and_does_not_try_to_change_it() {\n \n fn has_mut_vec_but_tries_to_change_it() {\n     let mut v = ~[1, 2, 3];\n-    do takes_imm_elt(&v[0]) { //~ NOTE loan of mutable vec content granted here\n-        v[1] = 4; //~ ERROR assigning to mutable vec content prohibited due to outstanding loan\n+    do takes_imm_elt(&v[0]) {\n+        v[1] = 4; //~ ERROR cannot assign\n     }\n }\n "}, {"sha": "c199c8795756dd72c9217b41c71fa0a36ea7bc1d", "filename": "src/test/compile-fail/borrowck-move-by-capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -4,7 +4,7 @@ fn main() {\n     let foo = ~3;\n     let _pfoo = &foo;\n     let _f: @fn() -> int = || *foo + 5;\n-    //~^ ERROR by-move capture\n+    //~^ ERROR cannot move `foo`\n \n     let bar = ~3;\n     let _g = || {"}, {"sha": "e4e449822768b6fdb397012a5f4d651ae22063bc", "filename": "src/test/compile-fail/borrowck-mut-addr-of-imm-var.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-addr-of-imm-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-addr-of-imm-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-addr-of-imm-var.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -10,7 +10,7 @@\n \n fn main() {\n     let x: int = 3;\n-    let y: &mut int = &mut x; //~ ERROR illegal borrow\n+    let y: &mut int = &mut x; //~ ERROR cannot borrow\n     *y = 5;\n     debug!(*y);\n }"}, {"sha": "a69edebce51fb39d69b4191835ac12cdf594e19f", "filename": "src/test/compile-fail/borrowck-mut-boxed-vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-boxed-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-boxed-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-boxed-vec.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -10,8 +10,8 @@\n \n fn main() {\n     let v = @mut [ 1, 2, 3 ];\n-    for v.each |_x| {   //~ ERROR illegal borrow\n-        v[1] = 4;\n+    for v.each |_x| {\n+        v[1] = 4; //~ ERROR cannot assign\n     }\n }\n "}, {"sha": "d1dc29619789227067f6207a2d9d8d704dd9ecab", "filename": "src/test/compile-fail/borrowck-mut-deref-comp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-deref-comp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-deref-comp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-deref-comp.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -11,8 +11,8 @@\n struct foo(~int);\n \n fn borrow(x: @mut foo) {\n-    let _y = &***x; //~ ERROR illegal borrow unless pure\n-    *x = foo(~4); //~ NOTE impure due to assigning to dereference of mutable @ pointer\n+    let _y = &***x;\n+    *x = foo(~4); //~ ERROR cannot assign\n }\n \n fn main() {"}, {"sha": "ec17976c5065cb891b2b5a899f1616381f24bf4a", "filename": "src/test/compile-fail/borrowck-mut-slice-of-imm-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-slice-of-imm-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-slice-of-imm-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-slice-of-imm-vec.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -14,5 +14,5 @@ fn write(v: &mut [int]) {\n \n fn main() {\n     let v = ~[1, 2, 3];\n-    write(v); //~ ERROR illegal borrow\n+    write(v); //~ ERROR cannot borrow\n }"}, {"sha": "ed270de51e2ed886a3698043262db09327f210a8", "filename": "src/test/compile-fail/borrowck-no-cycle-in-exchange-heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-no-cycle-in-exchange-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-no-cycle-in-exchange-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-no-cycle-in-exchange-heap.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -19,9 +19,9 @@ enum cycle {\n fn main() {\n     let mut x = ~node(node_ {a: ~empty});\n     // Create a cycle!\n-    match *x { //~ NOTE loan of mutable local variable granted here\n+    match *x {\n       node(ref mut y) => {\n-        y.a = x; //~ ERROR moving out of mutable local variable prohibited due to outstanding loan\n+        y.a = x; //~ ERROR cannot move out of\n       }\n       empty => {}\n     };"}, {"sha": "d60ed3d0e372b5f67f9ff0b8e2e2b4e6224e3c8c", "filename": "src/test/compile-fail/borrowck-pat-by-value-binding.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-by-value-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-by-value-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-by-value-binding.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -12,23 +12,24 @@ fn process<T>(_t: T) {}\n \n fn match_const_opt_by_mut_ref(v: &const Option<int>) {\n     match *v {\n-      Some(ref mut i) => process(i), //~ ERROR illegal borrow\n+      Some(ref mut i) => process(i), //~ ERROR cannot borrow\n+        //~^ ERROR unsafe borrow of aliasable, const value\n       None => ()\n     }\n }\n \n fn match_const_opt_by_const_ref(v: &const Option<int>) {\n     match *v {\n-      Some(ref const i) => process(i), //~ ERROR illegal borrow unless pure\n-      //~^ NOTE impure due to\n+      Some(ref const i) => process(i),\n+        //~^ ERROR unsafe borrow of aliasable, const value\n       None => ()\n     }\n }\n \n fn match_const_opt_by_imm_ref(v: &const Option<int>) {\n     match *v {\n-      Some(ref i) => process(i), //~ ERROR illegal borrow unless pure\n-      //~^ NOTE impure due to\n+      Some(ref i) => process(i), //~ ERROR cannot borrow\n+        //~^ ERROR unsafe borrow of aliasable, const value\n       None => ()\n     }\n }"}, {"sha": "c50357e8b9c6208c8cff020ed19bd033fe7be91c", "filename": "src/test/compile-fail/borrowck-pat-enum.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -26,7 +26,8 @@ fn match_ref_unused(&&v: Option<int>) {\n \n fn match_const_reg(v: &const Option<int>) -> int {\n     match *v {\n-      Some(ref i) => {*i} // OK because this is pure\n+      Some(ref i) => {*i} //~ ERROR cannot borrow\n+        //~^ ERROR unsafe borrow\n       None => {0}\n     }\n }\n@@ -43,8 +44,8 @@ fn match_const_reg_unused(v: &const Option<int>) {\n \n fn match_const_reg_impure(v: &const Option<int>) {\n     match *v {\n-      Some(ref i) => {impure(*i)} //~ ERROR illegal borrow unless pure\n-      //~^ NOTE impure due to access to impure function\n+      Some(ref i) => {impure(*i)} //~ ERROR cannot borrow\n+        //~^ ERROR unsafe borrow\n       None => {}\n     }\n }\n@@ -56,5 +57,12 @@ fn match_imm_reg(v: &Option<int>) {\n     }\n }\n \n+fn match_mut_reg(v: &mut Option<int>) {\n+    match *v {\n+      Some(ref i) => {impure(*i)} // OK, frozen\n+      None => {}\n+    }\n+}\n+\n fn main() {\n }"}, {"sha": "d05160132c6c2bf790fbb0d154986486d37563a6", "filename": "src/test/compile-fail/borrowck-pat-reassign-binding.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -12,11 +12,14 @@\n \n fn main() {\n     let mut x: Option<int> = None;\n-    match x { //~ NOTE loan of mutable local variable granted here\n-      None => {}\n+    match x {\n+      None => {\n+          // Note: on this branch, no borrow has occurred.\n+          x = Some(0);\n+      }\n       Some(ref i) => {\n-        // Not ok: i is an outstanding ptr into x.\n-        x = Some(*i+1); //~ ERROR assigning to mutable local variable prohibited due to outstanding loan\n+          // But on this branch, `i` is an outstanding borrow\n+          x = Some(*i+1); //~ ERROR cannot assign to `x`\n       }\n     }\n     copy x; // just to prevent liveness warnings"}, {"sha": "dd6eca951b8f3ba22c0b9f496e148c9f79015625", "filename": "src/test/compile-fail/borrowck-pat-reassign-sometimes-binding.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b5a7e8b35322869b1cf51bd1b35a86e9e721da54/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a7e8b35322869b1cf51bd1b35a86e9e721da54/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs?ref=b5a7e8b35322869b1cf51bd1b35a86e9e721da54", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-pretty -- comments are infaithfully preserved\n-\n-fn main() {\n-    let mut x = None;\n-    match x { //~ NOTE loan of mutable local variable granted here\n-      None => {\n-        // It is ok to reassign x here, because there is in\n-        // fact no outstanding loan of x!\n-        x = Some(0);\n-      }\n-      Some(ref _i) => {\n-        x = Some(1); //~ ERROR assigning to mutable local variable prohibited due to outstanding loan\n-      }\n-    }\n-    copy x; // just to prevent liveness warnings\n-}"}, {"sha": "b4bd64f21358621be700d436afa9100a0d879430", "filename": "src/test/compile-fail/borrowck-reborrow-from-mut.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-reborrow-from-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-reborrow-from-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-reborrow-from-mut.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -20,17 +20,17 @@ struct Bar {\n \n fn borrow_same_field_twice_mut_mut(foo: &mut Foo) {\n     let _bar1 = &mut foo.bar1;\n-    let _bar2 = &mut foo.bar1;  //~ ERROR conflicts with prior loan\n+    let _bar2 = &mut foo.bar1;  //~ ERROR cannot borrow\n }\n \n fn borrow_same_field_twice_mut_imm(foo: &mut Foo) {\n     let _bar1 = &mut foo.bar1;\n-    let _bar2 = &foo.bar1;  //~ ERROR conflicts with prior loan\n+    let _bar2 = &foo.bar1;  //~ ERROR cannot borrow\n }\n \n fn borrow_same_field_twice_imm_mut(foo: &mut Foo) {\n     let _bar1 = &foo.bar1;\n-    let _bar2 = &mut foo.bar1;  //~ ERROR conflicts with prior loan\n+    let _bar2 = &mut foo.bar1;  //~ ERROR cannot borrow\n }\n \n fn borrow_same_field_twice_imm_imm(foo: &mut Foo) {\n@@ -53,34 +53,34 @@ fn borrow_var_and_pattern(foo: &mut Foo) {\n     let _bar1 = &mut foo.bar1;\n     match *foo {\n         Foo { bar1: ref mut _bar1, bar2: _ } => {}\n-        //~^ ERROR conflicts with prior loan\n+        //~^ ERROR cannot borrow\n     }\n }\n \n fn borrow_mut_and_base_imm(foo: &mut Foo) {\n     let _bar1 = &mut foo.bar1.int1;\n-    let _foo1 = &foo.bar1; //~ ERROR conflicts with prior loan\n-    let _foo2 = &*foo; //~ ERROR conflicts with prior loan\n+    let _foo1 = &foo.bar1; //~ ERROR cannot borrow\n+    let _foo2 = &*foo; //~ ERROR cannot borrow\n }\n \n fn borrow_mut_and_base_mut(foo: &mut Foo) {\n     let _bar1 = &mut foo.bar1.int1;\n-    let _foo1 = &mut foo.bar1; //~ ERROR conflicts with prior loan\n+    let _foo1 = &mut foo.bar1; //~ ERROR cannot borrow\n }\n \n fn borrow_mut_and_base_mut2(foo: &mut Foo) {\n     let _bar1 = &mut foo.bar1.int1;\n-    let _foo2 = &mut *foo; //~ ERROR conflicts with prior loan\n+    let _foo2 = &mut *foo; //~ ERROR cannot borrow\n }\n \n fn borrow_imm_and_base_mut(foo: &mut Foo) {\n     let _bar1 = &foo.bar1.int1;\n-    let _foo1 = &mut foo.bar1; //~ ERROR conflicts with prior loan\n+    let _foo1 = &mut foo.bar1; //~ ERROR cannot borrow\n }\n \n fn borrow_imm_and_base_mut2(foo: &mut Foo) {\n     let _bar1 = &foo.bar1.int1;\n-    let _foo2 = &mut *foo; //~ ERROR conflicts with prior loan\n+    let _foo2 = &mut *foo; //~ ERROR cannot borrow\n }\n \n fn borrow_imm_and_base_imm(foo: &mut Foo) {\n@@ -95,7 +95,7 @@ fn borrow_mut_and_imm(foo: &mut Foo) {\n }\n \n fn borrow_mut_from_imm(foo: &Foo) {\n-    let _bar1 = &mut foo.bar1; //~ ERROR illegal borrow\n+    let _bar1 = &mut foo.bar1; //~ ERROR cannot borrow\n }\n \n fn borrow_long_path_both_mut(foo: &mut Foo) {"}, {"sha": "18865ad7d54d86c7100cedbf650471b8395143c7", "filename": "src/test/compile-fail/borrowck-ref-into-rvalue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-into-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-into-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-into-rvalue.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -10,12 +10,12 @@\n \n fn main() {\n     let msg;\n-    match Some(~\"Hello\") { //~ ERROR illegal borrow\n-        Some(ref m) => {\n+    match Some(~\"Hello\") {\n+        Some(ref m) => { //~ ERROR borrowed value does not live long enough\n             msg = m;\n-        },  \n+        },\n         None => { fail!() }\n-    }   \n+    }\n     io::println(*msg);\n }\n "}, {"sha": "3a37116a1664d604755f01bbdc0e97eac91ed7a5", "filename": "src/test/compile-fail/borrowck-ref-mut-of-imm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-mut-of-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-mut-of-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-mut-of-imm.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -11,7 +11,7 @@\n fn destructure(x: Option<int>) -> int {\n     match x {\n       None => 0,\n-      Some(ref mut v) => *v //~ ERROR illegal borrow\n+      Some(ref mut v) => *v //~ ERROR cannot borrow\n     }\n }\n "}, {"sha": "898830bbe55ba483d5150aab17bb990360724e02", "filename": "src/test/compile-fail/borrowck-unary-move-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move-2.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -28,5 +28,5 @@ struct wrapper(noncopyable);\n \n fn main() {\n     let x1 = wrapper(noncopyable());\n-    let _x2 = *x1; //~ ERROR moving out of anonymous field\n+    let _x2 = *x1; //~ ERROR cannot move out\n }"}, {"sha": "107e478004abb327b3e565cf9e736a8b0ac19e15", "filename": "src/test/compile-fail/borrowck-unary-move.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n fn foo(+x: ~int) -> int {\n-    let y = &*x; //~ NOTE loan of argument granted here\n-    free(x); //~ ERROR moving out of argument prohibited due to outstanding loan\n+    let y = &*x;\n+    free(x); //~ ERROR cannot move out of `*x` because it is borrowed\n     *y\n }\n "}, {"sha": "e1c0e67ff8dcc93907b7779f06d615c5d58228a1", "filename": "src/test/compile-fail/borrowck-uniq-via-box.rs", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b5a7e8b35322869b1cf51bd1b35a86e9e721da54/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a7e8b35322869b1cf51bd1b35a86e9e721da54/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs?ref=b5a7e8b35322869b1cf51bd1b35a86e9e721da54", "patch": "@@ -1,55 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct Rec {\n-    f: ~int,\n-}\n-\n-struct Outer {\n-    f: Inner\n-}\n-\n-struct Inner {\n-    g: Innermost\n-}\n-\n-struct Innermost {\n-    h: ~int,\n-}\n-\n-fn borrow(_v: &int) {}\n-\n-fn box_mut(v: @mut ~int) {\n-    borrow(*v); //~ ERROR illegal borrow unless pure\n-}\n-\n-fn box_mut_rec(v: @mut Rec) {\n-    borrow(v.f); //~ ERROR illegal borrow unless pure\n-}\n-\n-fn box_mut_recs(v: @mut Outer) {\n-    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure\n-}\n-\n-fn box_imm(v: @~int) {\n-    borrow(*v); // OK\n-}\n-\n-fn box_imm_rec(v: @Rec) {\n-    borrow(v.f); // OK\n-}\n-\n-fn box_imm_recs(v: @Outer) {\n-    borrow(v.f.g.h); // OK\n-}\n-\n-fn main() {\n-}\n-"}, {"sha": "80ba1968bc751cd180fcea5596997e113201f5c1", "filename": "src/test/compile-fail/borrowck-uniq-via-lend.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -43,8 +43,8 @@ fn aliased_const() {\n \n fn aliased_mut() {\n     let mut v = ~3;\n-    let _w = &mut v; //~ NOTE prior loan as mutable granted here\n-    borrow(v); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n+    let _w = &mut v;\n+    borrow(v); //~ ERROR cannot borrow `*v`\n }\n \n fn aliased_other() {\n@@ -56,8 +56,8 @@ fn aliased_other() {\n fn aliased_other_reassign() {\n     let mut v = ~3, w = ~4;\n     let mut _x = &mut w;\n-    _x = &mut v; //~ NOTE prior loan as mutable granted here\n-    borrow(v); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n+    _x = &mut v;\n+    borrow(v); //~ ERROR cannot borrow `*v`\n }\n \n fn main() {"}, {"sha": "8bf627d991911343b24ed042b99581677cf03327", "filename": "src/test/compile-fail/borrowck-uniq-via-ref.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -25,6 +25,7 @@ struct Innermost {\n }\n \n fn borrow(_v: &int) {}\n+fn borrow_const(_v: &const int) {}\n \n fn box_mut(v: &mut ~int) {\n     borrow(*v); // OK: &mut -> &imm\n@@ -51,15 +52,15 @@ fn box_imm_recs(v: &Outer) {\n }\n \n fn box_const(v: &const ~int) {\n-    borrow(*v); //~ ERROR illegal borrow unless pure\n+    borrow_const(*v); //~ ERROR unsafe borrow\n }\n \n fn box_const_rec(v: &const Rec) {\n-    borrow(v.f); //~ ERROR illegal borrow unless pure\n+    borrow_const(v.f); //~ ERROR unsafe borrow\n }\n \n fn box_const_recs(v: &const Outer) {\n-    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure\n+    borrow_const(v.f.g.h); //~ ERROR unsafe borrow\n }\n \n fn main() {"}, {"sha": "0c21b64bb0fb0a0d56fc54774b3ec4df70587b8b", "filename": "src/test/compile-fail/borrowck-vec-pattern-element-loan.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -1,25 +1,25 @@\n fn a() -> &[int] {\n     let vec = [1, 2, 3, 4];\n-    let tail = match vec { //~ ERROR illegal borrow\n-        [_, ..tail] => tail,\n+    let tail = match vec {\n+        [_, ..tail] => tail, //~ ERROR does not live long enough\n         _ => fail!(~\"a\")\n     };\n     tail\n }\n \n fn b() -> &[int] {\n     let vec = [1, 2, 3, 4];\n-    let init = match vec { //~ ERROR illegal borrow\n-        [..init, _] => init,\n+    let init = match vec {\n+        [..init, _] => init, //~ ERROR does not live long enough\n         _ => fail!(~\"b\")\n     };\n     init\n }\n \n fn c() -> &[int] {\n     let vec = [1, 2, 3, 4];\n-    let slice = match vec { //~ ERROR illegal borrow\n-        [_, ..slice, _] => slice,\n+    let slice = match vec {\n+        [_, ..slice, _] => slice, //~ ERROR does not live long enough\n         _ => fail!(~\"c\")\n     };\n     slice"}, {"sha": "6b51fc8f5b3d7127e347ec5a5e720cf81bc7a39b", "filename": "src/test/compile-fail/borrowck-vec-pattern-loan-from-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-loan-from-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-loan-from-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-loan-from-mut.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -2,7 +2,7 @@ fn a() {\n     let mut v = ~[1, 2, 3];\n     match v {\n         [_a, ..tail] => {\n-            v.push(tail[0] + tail[1]); //~ ERROR conflicts with prior loan\n+            v.push(tail[0] + tail[1]); //~ ERROR cannot borrow\n         }\n         _ => {}\n     };"}, {"sha": "2898e312930fe5e04199343ffdd3f5db74d4a5bc", "filename": "src/test/compile-fail/borrowck-vec-pattern-move-tail.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -1,8 +1,9 @@\n fn main() {\n     let mut a = [1, 2, 3, 4];\n-    let _ = match a {\n+    let t = match a {\n         [1, 2, ..tail] => tail,\n         _ => core::util::unreachable()\n     };\n-    a[0] = 0; //~ ERROR: assigning to mutable vec content prohibited due to outstanding loan\n+    a[0] = 0; //~ ERROR cannot assign to `a[]` because it is borrowed\n+    t[0];\n }"}, {"sha": "16711ea61ffac1b8bf9c7f531628bd2bf70ab3e4", "filename": "src/test/compile-fail/borrowck-vec-pattern-nesting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -2,7 +2,7 @@ fn a() {\n     let mut vec = [~1, ~2, ~3];\n     match vec {\n         [~ref _a] => {\n-            vec[0] = ~4; //~ ERROR prohibited due to outstanding loan\n+            vec[0] = ~4; //~ ERROR cannot assign to `vec[]` because it is borrowed\n         }\n         _ => fail!(~\"foo\")\n     }\n@@ -12,7 +12,7 @@ fn b() {\n     let mut vec = [~1, ~2, ~3];\n     match vec {\n         [.._b] => {\n-            vec[0] = ~4; //~ ERROR prohibited due to outstanding loan\n+            vec[0] = ~4; //~ ERROR cannot assign to `vec[]` because it is borrowed\n         }\n     }\n }"}, {"sha": "dbdd8f0809a6e1a17c812e4bdfc84f145dde1c8a", "filename": "src/test/compile-fail/borrowck-vec-pattern-tail-element-loan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -1,7 +1,7 @@\n fn a() -> &int {\n     let vec = [1, 2, 3, 4];\n-    let tail = match vec { //~ ERROR illegal borrow\n-        [_a, ..tail] => &tail[0],\n+    let tail = match vec {\n+        [_a, ..tail] => &tail[0], //~ ERROR borrowed value does not live long enough\n         _ => fail!(~\"foo\")\n     };\n     tail"}, {"sha": "5ef23897ec0d3614f9f71286b8754e22e2c1847a", "filename": "src/test/compile-fail/borrowck-wg-borrow-mut-to-imm-fail-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail-2.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     let mut b = ~3;\n-    let _x = &mut *b;   //~ NOTE prior loan as mutable granted here\n-    let _y = &mut *b;   //~ ERROR loan of dereference of mutable ~ pointer as mutable conflicts with prior loan\n+    let _x = &mut *b;\n+    let _y = &mut *b; //~ ERROR cannot borrow\n }\n "}, {"sha": "a744127a600dbc63fd01af72ca97de01d2362f3a", "filename": "src/test/compile-fail/borrowck-wg-borrow-mut-to-imm-fail-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail-3.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -1,8 +1,8 @@\n fn main() {\n     let mut a = ~3;\n-    let mut b = &mut a; //~ NOTE loan of mutable local variable granted here\n+    let mut b = &mut a;\n     let _c = &mut *b;\n-    let mut d = /*move*/ a; //~ ERROR moving out of mutable local variable prohibited due to outstanding loan\n+    let mut d = /*move*/ a; //~ ERROR cannot move out\n     *d += 1;\n }\n "}, {"sha": "44da00d8d170782eed82e3bedaea509700a5a575", "filename": "src/test/compile-fail/borrowck-wg-borrow-mut-to-imm-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -1,7 +1,7 @@\n fn main() {\n     let mut b = ~3;\n-    let _x = &mut *b;   //~ NOTE loan of mutable local variable granted here\n-    let mut y = /*move*/ b; //~ ERROR moving out of mutable local variable prohibited\n+    let _x = &mut *b;\n+    let mut y = /*move*/ b; //~ ERROR cannot move out\n     *y += 1;\n }\n "}, {"sha": "8a2187714534a4f66dfc47421121079a676898e1", "filename": "src/test/compile-fail/borrowck-wg-move-base-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-move-base-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-move-base-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-move-base-2.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -2,7 +2,7 @@ fn foo(x: &mut int) {\n     let mut a = 3;\n     let mut _y = &mut *x;\n     let _z = &mut *_y;\n-    _y = &mut a; //~ ERROR assigning to mutable local variable prohibited\n+    _y = &mut a; //~ ERROR cannot assign\n }\n \n fn main() {"}, {"sha": "4d145d3f9ea3aff34b3e0db1784816aa67c790b1", "filename": "src/test/compile-fail/fn-variance-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -31,5 +31,5 @@ fn main() {\n     // mutability check will fail, because the\n     // type of r has been inferred to be\n     // fn(@const int) -> @const int\n-    *r(@mut 3) = 4; //~ ERROR assigning to dereference of const @ pointer\n+    *r(@mut 3) = 4; //~ ERROR cannot assign to const dereference of @ pointer\n }"}, {"sha": "66b5bd172cace9e5b2cee9e3960ea10b9a6aded0", "filename": "src/test/compile-fail/immut-function-arguments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fimmut-function-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fimmut-function-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimmut-function-arguments.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n fn f(y: ~int) {\n-    *y = 5; //~ ERROR assigning to dereference of immutable ~ pointer\n+    *y = 5; //~ ERROR cannot assign\n }\n \n fn g() {\n-    let _frob: &fn(~int) = |q| { *q = 2; }; //~ ERROR assigning to dereference of immutable ~ pointer\n+    let _frob: &fn(~int) = |q| { *q = 2; }; //~ ERROR cannot assign\n \n }\n "}, {"sha": "26dd98757a8c2c5e4cbf79dd2c20dff38d593f30", "filename": "src/test/compile-fail/index_message.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Findex_message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Findex_message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Findex_message.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -10,5 +10,5 @@\n \n fn main() {\n     let z = ();\n-    debug!(z[0]); //~ ERROR cannot index a value of type `()`\n+    let _ = z[0]; //~ ERROR cannot index a value of type `()`\n }"}, {"sha": "13adcd42da2b804bd3c056e47a0de1ffbc1cd840", "filename": "src/test/compile-fail/issue-1896-1.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test that we require managed closures to be rooted when borrowed.\n+\n struct boxedFn<'self> { theFn: &'self fn() -> uint }\n \n fn createClosure (closedUint: uint) -> boxedFn {\n     let theFn: @fn() -> uint = || closedUint;\n-    boxedFn {theFn: theFn} //~ ERROR illegal borrow\n+    boxedFn {theFn: theFn} //~ ERROR cannot root\n }\n \n fn main () {"}, {"sha": "cdc8d546dd84801e074d5f496dd1d65f691cb864", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -23,5 +23,4 @@ impl<A> vec_monad<A> for ~[A] {\n fn main() {\n     [\"hi\"].bind(|x| [x] );\n     //~^ ERROR type `[&'static str, .. 1]` does not implement any method in scope named `bind`\n-    //~^^ ERROR Unconstrained region variable\n }"}, {"sha": "bb6d47a47622b10e94af9b3a44c0aceb8fd17295", "filename": "src/test/compile-fail/issue-2151.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -10,7 +10,6 @@\n \n fn main() {\n     for vec::each(fail!()) |i| {\n-        debug!(i * 2);\n-        //~^ ERROR the type of this value must be known\n+        let _ = i * 2; //~ ERROR the type of this value must be known\n    };\n }"}, {"sha": "a0b967d59593a2f4a2147c8ac83442744402fc1c", "filename": "src/test/compile-fail/issue-2590.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -18,7 +18,7 @@ trait parse {\n \n impl parse for parser {\n     fn parse(&self) -> ~[int] {\n-        self.tokens //~ ERROR moving out of immutable field\n+        self.tokens //~ ERROR cannot move out of field\n     }\n }\n "}, {"sha": "23b11bbe409e1c00c3d1ca0a21dfdef47161bafc", "filename": "src/test/compile-fail/issue-3044.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -11,7 +11,6 @@\n fn main() {\n     let needlesArr: ~[char] = ~['a', 'f'];\n     do vec::foldr(needlesArr) |x, y| {\n-        //~^ ERROR Unconstrained region variable #2\n     }\n     //~^ ERROR 2 parameters were supplied (including the closure passed by the `do` keyword)\n     //"}, {"sha": "c872f89d88450ec37e5329841ab250be37d79090", "filename": "src/test/compile-fail/issue-511.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-511.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -17,5 +17,5 @@ fn f<T:Eq>(o: &mut Option<T>) {\n \n fn main() {\n     f::<int>(&mut option::None);\n-    //~^ ERROR illegal borrow: creating mutable alias to static item\n+    //~^ ERROR cannot borrow\n }"}, {"sha": "6bb90bff228d4eb51804841f3424058754dd21dd", "filename": "src/test/compile-fail/kindck-owned-trait-contains.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -29,4 +29,7 @@ fn main() {\n     };\n     assert!(3 == *(y.get())); //~ ERROR dereference of reference outside its lifetime\n     //~^ ERROR reference is not valid outside of its lifetime\n+    //~^^ ERROR reference is not valid outside of its lifetime\n+    //~^^^ ERROR reference is not valid outside of its lifetime\n+    //~^^^^ ERROR cannot infer an appropriate lifetime\n }"}, {"sha": "bfd1e12f3a6e05fce6d9ebcceae5876474ab2396", "filename": "src/test/compile-fail/lambda-mutate-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Flambda-mutate-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Flambda-mutate-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flambda-mutate-nested.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:assigning to captured outer immutable variable in a stack closure\n // Make sure that nesting a block within a @fn doesn't let us\n // mutate upvars from a @fn.\n fn f2(x: &fn()) { x(); }\n \n fn main() {\n     let i = 0;\n     let ctr: @fn() -> int = || { f2(|| i = i + 1 ); i };\n+    //~^ ERROR cannot assign\n     error!(ctr());\n     error!(ctr());\n     error!(ctr());"}, {"sha": "a848d8698a3d6d07cbe70cfc4c86f66610cac7b8", "filename": "src/test/compile-fail/lambda-mutate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Flambda-mutate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Flambda-mutate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flambda-mutate.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:assigning to captured outer variable in a heap closure\n // Make sure we can't write to upvars from @fns\n fn main() {\n     let i = 0;\n     let ctr: @fn() -> int = || { i = i + 1; i };\n+    //~^ ERROR cannot assign\n     error!(ctr());\n     error!(ctr());\n     error!(ctr());"}, {"sha": "feeaadeea8263b4ef1fa69de613bddfdd02d3887", "filename": "src/test/compile-fail/moves-based-on-type-block-bad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-block-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-block-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-block-bad.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -16,7 +16,7 @@ fn main() {\n     let s = S { x: ~Bar(~42) };\n     loop {\n         do f(&s) |hellothere| {\n-            match hellothere.x {    //~ ERROR moving out of immutable field\n+            match hellothere.x {    //~ ERROR cannot move out\n                 ~Foo(_) => {}\n                 ~Bar(x) => io::println(x.to_str()),\n                 ~Baz => {}"}, {"sha": "ecd58d485a89dc11b6ceb78cb11bae9029e725a9", "filename": "src/test/compile-fail/moves-based-on-type-move-out-of-closure-env-issue-1965.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-move-out-of-closure-env-issue-1965.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-move-out-of-closure-env-issue-1965.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-move-out-of-closure-env-issue-1965.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -13,6 +13,6 @@ fn test(_x: ~uint) {}\n fn main() {\n     let i = ~3;\n     for uint::range(0, 10) |_x| {\n-        test(i); //~ ERROR moving out of captured outer immutable variable in a stack closure\n+        test(i); //~ ERROR cannot move out\n     }\n }"}, {"sha": "f5d24b316414e69e0b13e545fc2b5880bc7ccf51", "filename": "src/test/compile-fail/mutable-class-fields-2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fmutable-class-fields-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fmutable-class-fields-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-class-fields-2.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:assigning to immutable field\n struct cat {\n   priv mut meows : uint,\n \n@@ -17,7 +16,7 @@ struct cat {\n \n pub impl cat {\n   fn eat(&self) {\n-    self.how_hungry -= 5;\n+    self.how_hungry -= 5; //~ ERROR cannot assign\n   }\n \n }"}, {"sha": "8bebec7134cc36ff626c109e687e7654269d68c1", "filename": "src/test/compile-fail/mutable-class-fields.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fmutable-class-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fmutable-class-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-class-fields.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -8,12 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:assigning to immutable field\n struct cat {\n   priv mut meows : uint,\n-\n   how_hungry : int,\n-\n }\n \n fn cat(in_x : uint, in_y : int) -> cat {\n@@ -25,5 +22,5 @@ fn cat(in_x : uint, in_y : int) -> cat {\n \n fn main() {\n   let nyan : cat = cat(52u, 99);\n-  nyan.how_hungry = 0;\n+  nyan.how_hungry = 0; //~ ERROR cannot assign\n }"}, {"sha": "6b3fd4f715384cc6d50ee9b3f3b8aee36cc26e85", "filename": "src/test/compile-fail/mutable-huh-ptr-assign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fmutable-huh-ptr-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fmutable-huh-ptr-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-ptr-assign.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -12,7 +12,7 @@ extern mod std;\n \n fn main() {\n     unsafe fn f(&&v: *const int) {\n-        *v = 1 //~ ERROR assigning to dereference of const * pointer\n+        *v = 1 //~ ERROR cannot assign\n     }\n \n     unsafe {"}, {"sha": "4fff5a6f87c786ea5047bacbeabefc30f275044a", "filename": "src/test/compile-fail/regions-addr-of-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-arg.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn foo(a: int) {\n-    let _p: &'static int = &a; //~ ERROR illegal borrow\n+    let _p: &'static int = &a; //~ ERROR borrowed value does not live long enough\n }\n \n fn bar(a: int) {"}, {"sha": "2ab0c14b49b656d743dcc60ce2aedc8a66693e70", "filename": "src/test/compile-fail/regions-creating-enums.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -30,12 +30,12 @@ fn compute(x: &ast) -> uint {\n fn map_nums(x: &ast, f: &fn(uint) -> uint) -> &ast {\n     match *x {\n       num(x) => {\n-        return &num(f(x)); //~ ERROR illegal borrow\n+        return &num(f(x)); //~ ERROR borrowed value does not live long enough\n       }\n       add(x, y) => {\n         let m_x = map_nums(x, f);\n         let m_y = map_nums(y, f);\n-        return &add(m_x, m_y);  //~ ERROR illegal borrow\n+        return &add(m_x, m_y);  //~ ERROR borrowed value does not live long enough\n       }\n     }\n }"}, {"sha": "8f764745697c7a87302cfaafe527ac3d16c5f125", "filename": "src/test/compile-fail/regions-creating-enums4.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums4.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -14,8 +14,7 @@ enum ast<'self> {\n }\n \n fn mk_add_bad2<'a>(x: &'a ast<'a>, y: &'a ast<'a>, z: &ast) -> ast {\n-    add(x, y)\n-         //~^ ERROR cannot infer an appropriate lifetime\n+    add(x, y) //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() {"}, {"sha": "5ac5e334be23d1e5b4d5ba531c2c5e497f943f80", "filename": "src/test/compile-fail/regions-escape-bound-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -14,6 +14,6 @@ fn with_int(f: &fn(x: &int)) {\n }\n \n fn main() {\n-    let mut x: Option<&int> = None; //~ ERROR cannot infer\n+    let mut x: Option<&int> = None;   //~ ERROR cannot infer\n     with_int(|y| x = Some(y));\n }"}, {"sha": "19bd0bf9747bbdb70f56cca7110ba487f5506b24", "filename": "src/test/compile-fail/regions-escape-loop-via-variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-variable.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -18,6 +18,6 @@ fn main() {\n \n     loop {\n         let x = 1 + *p;\n-        p = &x; //~ ERROR illegal borrow\n+        p = &x; //~ ERROR borrowed value does not live long enough\n     }\n }"}, {"sha": "92e2cd73dfbd8c13ca5bb6cc655c258dcfda6ced", "filename": "src/test/compile-fail/regions-escape-loop-via-vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -14,8 +14,8 @@ fn broken() {\n     let mut _y = ~[&mut x];\n     while x < 10 {\n         let mut z = x;\n-        _y.push(&mut z); //~ ERROR illegal borrow\n-        x += 1; //~ ERROR assigning to mutable local variable prohibited due to outstanding loan\n+        _y.push(&mut z); //~ ERROR borrowed value does not live long enough\n+        x += 1; //~ ERROR cannot assign\n     }\n }\n "}, {"sha": "aa431d6b81c6e7162084febd5a53ef5871ff135c", "filename": "src/test/compile-fail/regions-escape-via-trait-or-not.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -23,13 +23,8 @@ fn with<R:deref>(f: &fn(x: &int) -> R) -> int {\n }\n \n fn return_it() -> int {\n-    with(|o| o)\n-    //~^ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n-    //~^^ ERROR reference is not valid outside of its lifetime\n-    //~^^^ ERROR reference is not valid outside of its lifetime\n+    with(|o| o) //~ ERROR reference is not valid outside of its lifetime\n }\n \n fn main() {\n-    let x = return_it();\n-    debug!(\"foo=%d\", x);\n }"}, {"sha": "6e9d6c1ef0fde823c091b7146fc4c958bb88d8fd", "filename": "src/test/compile-fail/regions-infer-borrow-scope-too-big.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -18,7 +18,7 @@ fn x_coord<'r>(p: &'r point) -> &'r int {\n }\n \n fn foo(p: @point) -> &int {\n-    let xc = x_coord(p); //~ ERROR illegal borrow\n+    let xc = x_coord(p); //~ ERROR cannot root\n     assert!(*xc == 3);\n     return xc;\n }"}, {"sha": "d23e20130f782f4bcd78efefc2f3586af33e1b43", "filename": "src/test/compile-fail/regions-infer-borrow-scope-within-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -17,7 +17,7 @@ fn foo(cond: &fn() -> bool, box: &fn() -> @int) {\n \n \t// Here we complain because the resulting region\n \t// of this borrow is the fn body as a whole.\n-        y = borrow(x); //~ ERROR illegal borrow: cannot root managed value long enough\n+        y = borrow(x); //~ ERROR cannot root\n \n         assert!(*x == *y);\n         if cond() { break; }"}, {"sha": "fe995052c52e4a961a2eaf4ca9cf7375139b168d", "filename": "src/test/compile-fail/regions-nested-fns-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -13,7 +13,7 @@ fn ignore(_f: &fn<'z>(&'z int) -> &'z int) {}\n fn nested() {\n     let y = 3;\n     ignore(|z| {\n-        if false { &y } else { z } //~ ERROR illegal borrow\n+        if false { &y } else { z } //~ ERROR borrowed value does not live long enough\n     });\n }\n "}, {"sha": "74399967446eaa9675cf8c07ffeb2237c20045f0", "filename": "src/test/compile-fail/regions-nested-fns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -16,7 +16,7 @@ fn nested<'x>(x: &'x int) {\n \n     ignore::<&fn<'z>(&'z int)>(|z| {\n         ay = x;\n-        ay = &y;  //~ ERROR cannot infer an appropriate lifetime\n+        ay = &y;\n         ay = z;\n     });\n "}, {"sha": "f600f6f6edd92e2f04ffd13ed1e1a7bb70fc5b35", "filename": "src/test/compile-fail/regions-ret-borrowed-1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -19,6 +19,7 @@ fn with<'a, R>(f: &fn(x: &'a int) -> R) -> R {\n fn return_it<'a>() -> &'a int {\n     with(|o| o) //~ ERROR mismatched types\n         //~^ ERROR reference is not valid outside of its lifetime\n+        //~^^ ERROR reference is not valid outside of its lifetime\n }\n \n fn main() {"}, {"sha": "a3540f8f931f95e48a8c5cb1295ba5bbe6cbd124", "filename": "src/test/compile-fail/regions-ret-borrowed.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -22,6 +22,7 @@ fn with<R>(f: &fn(x: &int) -> R) -> R {\n fn return_it() -> &int {\n     with(|o| o) //~ ERROR mismatched types\n         //~^ ERROR reference is not valid outside of its lifetime\n+        //~^^ ERROR reference is not valid outside of its lifetime\n }\n \n fn main() {"}, {"sha": "f1a7bdf228166d5176d7c5a521a132da2ac57562", "filename": "src/test/compile-fail/regions-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn f<'a>(_x : &'a int) -> &'a int {\n-    return &3; //~ ERROR illegal borrow\n+    return &3; //~ ERROR borrowed value does not live long enough\n }\n \n fn main() {"}, {"sha": "addf20fd70249b6fbaa63e1ce1ca69d214607d50", "filename": "src/test/compile-fail/regions-var-type-out-of-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-var-type-out-of-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fregions-var-type-out-of-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-var-type-out-of-scope.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -14,7 +14,7 @@ fn foo(cond: bool) {\n     let mut x;\n \n     if cond {\n-        x = &3; //~ ERROR illegal borrow: borrowed value does not live long enough\n+        x = &3; //~ ERROR borrowed value does not live long enough\n         assert!((*x == 3));\n     }\n }"}, {"sha": "eca5fb0d315d87aa2c83bde0a0462d1c21f7c829", "filename": "src/test/compile-fail/swap-no-lval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fswap-no-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fswap-no-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fswap-no-lval.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -10,6 +10,6 @@\n \n fn main() {\n     5 <-> 3;\n-    //~^ ERROR swapping to and from non-lvalue\n-    //~^^ ERROR swapping to and from non-lvalue\n+    //~^ ERROR cannot assign\n+    //~^^ ERROR cannot assign\n }"}, {"sha": "faa3d6cfe47e70751c0bcc4269d15162058390a0", "filename": "src/test/compile-fail/writing-to-immutable-vec.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -8,5 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:assigning to immutable vec content\n-fn main() { let v: ~[int] = ~[1, 2, 3]; v[1] = 4; }\n+fn main() {\n+    let v: ~[int] = ~[1, 2, 3];\n+    v[1] = 4; //~ ERROR cannot assign\n+}"}, {"sha": "4494f5f2fa337be078fd797ab9afeae7ff5648d2", "filename": "src/test/run-pass/borrowck-nested-calls.rs", "status": "renamed", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Frun-pass%2Fborrowck-nested-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Frun-pass%2Fborrowck-nested-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-nested-calls.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -8,7 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn main () {\n-    let mut _p: & int = & 4;\n-    _p = &*~3; //~ ERROR illegal borrow\n+// xfail-test #5074 nested method calls\n+\n+// Test that (safe) nested calls with `&mut` receivers are permitted.\n+\n+struct Foo {a: uint, b: uint}\n+\n+pub impl Foo {\n+    fn inc_a(&mut self, v: uint) { self.a += v; }\n+\n+    fn next_b(&mut self) -> uint {\n+        let b = self.b;\n+        self.b += 1;\n+        b\n+    }\n+}\n+\n+fn main() {\n+    let mut f = Foo {a: 22, b: 23};\n+    f.inc_a(f.next_b());\n+    assert_eq!(f.a, 22+23);\n+    assert_eq!(f.b, 24);\n }", "previous_filename": "src/test/compile-fail/issue-4500.rs"}, {"sha": "b0d06dae10dc0b6fd6be0889519e432e24ced5e1", "filename": "src/test/run-pass/coerce-reborrow-mut-vec-rcvr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -1,10 +1,10 @@\n trait Reverser {\n-    fn reverse(&self);\n+    fn reverse(self);\n }\n \n impl<'self> Reverser for &'self mut [uint] {\n-    fn reverse(&self) {\n-        vec::reverse(*self);\n+    fn reverse(self) {\n+        vec::reverse(self);\n     }\n }\n "}, {"sha": "ca584e1a6e3b811082d7929dca6514e87ecf06ca", "filename": "src/test/run-pass/issue-2735-2.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Frun-pass%2Fissue-2735-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Frun-pass%2Fissue-2735-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2735-2.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -9,27 +9,25 @@\n // except according to those terms.\n \n // This test should behave exactly like issue-2735-3\n-struct defer<'self> {\n-    b: &'self mut bool,\n+struct defer {\n+    b: @mut bool,\n }\n \n #[unsafe_destructor]\n-impl<'self> Drop for defer<'self> {\n+impl Drop for defer {\n     fn finalize(&self) {\n-        unsafe {\n-            *(self.b) = true;\n-        }\n+        *self.b = true;\n     }\n }\n \n-fn defer<'r>(b: &'r mut bool) -> defer<'r> {\n+fn defer(b: @mut bool) -> defer {\n     defer {\n         b: b\n     }\n }\n \n pub fn main() {\n-    let mut dtor_ran = false;\n-    let _  = defer(&mut dtor_ran);\n-    assert!((dtor_ran));\n+    let dtor_ran = @mut false;\n+    let _  = defer(dtor_ran);\n+    assert!(*dtor_ran);\n }"}, {"sha": "44ca5d6929bd671b15b11ce5de8616744a1e431d", "filename": "src/test/run-pass/issue-2735-3.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Frun-pass%2Fissue-2735-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a896440ca1b93cc5dc6edd827ea2ae89602bfa9e/src%2Ftest%2Frun-pass%2Fissue-2735-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2735-3.rs?ref=a896440ca1b93cc5dc6edd827ea2ae89602bfa9e", "patch": "@@ -9,27 +9,25 @@\n // except according to those terms.\n \n // This test should behave exactly like issue-2735-2\n-struct defer<'self> {\n-    b: &'self mut bool,\n+struct defer {\n+    b: @mut bool,\n }\n \n #[unsafe_destructor]\n-impl<'self> Drop for defer<'self> {\n+impl Drop for defer {\n     fn finalize(&self) {\n-        unsafe {\n-            *(self.b) = true;\n-        }\n+        *self.b = true;\n     }\n }\n \n-fn defer<'r>(b: &'r mut bool) -> defer<'r> {\n+fn defer(b: @mut bool) -> defer {\n     defer {\n         b: b\n     }\n }\n \n pub fn main() {\n-    let mut dtor_ran = false;\n-    defer(&mut dtor_ran);\n-    assert!((dtor_ran));\n+    let dtor_ran = @mut false;\n+    defer(dtor_ran);\n+    assert!(*dtor_ran);\n }"}]}