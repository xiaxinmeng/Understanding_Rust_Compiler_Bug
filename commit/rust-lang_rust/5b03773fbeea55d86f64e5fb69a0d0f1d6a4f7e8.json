{"sha": "5b03773fbeea55d86f64e5fb69a0d0f1d6a4f7e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViMDM3NzNmYmVlYTU1ZDg2ZjY0ZTVmYjY5YTBkMGYxZDZhNGY3ZTg=", "commit": {"author": {"name": "Ekaterina Babshukova", "email": "ekaterina.babshukova@yandex.ru", "date": "2019-10-10T15:51:51Z"}, "committer": {"name": "Ekaterina Babshukova", "email": "ekaterina.babshukova@yandex.ru", "date": "2019-10-22T20:47:31Z"}, "message": "implement search of references", "tree": {"sha": "1f3ce5c71343535ae0ca0751982a1d0f89480e45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f3ce5c71343535ae0ca0751982a1d0f89480e45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b03773fbeea55d86f64e5fb69a0d0f1d6a4f7e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b03773fbeea55d86f64e5fb69a0d0f1d6a4f7e8", "html_url": "https://github.com/rust-lang/rust/commit/5b03773fbeea55d86f64e5fb69a0d0f1d6a4f7e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b03773fbeea55d86f64e5fb69a0d0f1d6a4f7e8/comments", "author": {"login": "viorina", "id": 6714973, "node_id": "MDQ6VXNlcjY3MTQ5NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6714973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/viorina", "html_url": "https://github.com/viorina", "followers_url": "https://api.github.com/users/viorina/followers", "following_url": "https://api.github.com/users/viorina/following{/other_user}", "gists_url": "https://api.github.com/users/viorina/gists{/gist_id}", "starred_url": "https://api.github.com/users/viorina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/viorina/subscriptions", "organizations_url": "https://api.github.com/users/viorina/orgs", "repos_url": "https://api.github.com/users/viorina/repos", "events_url": "https://api.github.com/users/viorina/events{/privacy}", "received_events_url": "https://api.github.com/users/viorina/received_events", "type": "User", "site_admin": false}, "committer": {"login": "viorina", "id": 6714973, "node_id": "MDQ6VXNlcjY3MTQ5NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6714973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/viorina", "html_url": "https://github.com/viorina", "followers_url": "https://api.github.com/users/viorina/followers", "following_url": "https://api.github.com/users/viorina/following{/other_user}", "gists_url": "https://api.github.com/users/viorina/gists{/gist_id}", "starred_url": "https://api.github.com/users/viorina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/viorina/subscriptions", "organizations_url": "https://api.github.com/users/viorina/orgs", "repos_url": "https://api.github.com/users/viorina/repos", "events_url": "https://api.github.com/users/viorina/events{/privacy}", "received_events_url": "https://api.github.com/users/viorina/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01853e8d6c6f4b44801c74f4fcdef735d9e77b48", "url": "https://api.github.com/repos/rust-lang/rust/commits/01853e8d6c6f4b44801c74f4fcdef735d9e77b48", "html_url": "https://github.com/rust-lang/rust/commit/01853e8d6c6f4b44801c74f4fcdef735d9e77b48"}], "stats": {"total": 210, "additions": 134, "deletions": 76}, "files": [{"sha": "8eef540f6a565156a9cbddc794b46bfea4772488", "filename": "crates/ra_ide_api/src/name_kind.rs", "status": "modified", "additions": 43, "deletions": 40, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/5b03773fbeea55d86f64e5fb69a0d0f1d6a4f7e8/crates%2Fra_ide_api%2Fsrc%2Fname_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b03773fbeea55d86f64e5fb69a0d0f1d6a4f7e8/crates%2Fra_ide_api%2Fsrc%2Fname_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fname_kind.rs?ref=5b03773fbeea55d86f64e5fb69a0d0f1d6a4f7e8", "patch": "@@ -10,6 +10,7 @@ use ra_syntax::{ast, ast::VisibilityOwner, AstNode, AstPtr};\n \n use crate::db::RootDatabase;\n \n+#[derive(PartialEq, Eq)]\n pub enum NameKind {\n     Macro(MacroDef),\n     FieldAccess(StructField),\n@@ -21,23 +22,24 @@ pub enum NameKind {\n     GenericParam(u32),\n }\n \n-pub(crate) struct Declaration {\n+#[derive(PartialEq, Eq)]\n+pub(crate) struct Definition {\n     pub visibility: Option<ast::Visibility>,\n     pub container: Module,\n     pub item: NameKind,\n }\n \n-trait HasDeclaration {\n+trait HasDefinition {\n     type Def;\n     type Ref;\n \n-    fn declaration(self, db: &RootDatabase) -> Declaration;\n-    fn from_def(db: &RootDatabase, file_id: HirFileId, def: Self::Def) -> Option<Declaration>;\n+    fn definition(self, db: &RootDatabase) -> Definition;\n+    fn from_def(db: &RootDatabase, file_id: HirFileId, def: Self::Def) -> Option<Definition>;\n     fn from_ref(\n         db: &RootDatabase,\n         analyzer: &SourceAnalyzer,\n         refer: Self::Ref,\n-    ) -> Option<Declaration>;\n+    ) -> Option<Definition>;\n }\n \n macro_rules! match_ast {\n@@ -55,7 +57,7 @@ pub(crate) fn classify_name_ref(\n     file_id: FileId,\n     analyzer: &SourceAnalyzer,\n     name_ref: &ast::NameRef,\n-) -> Option<Declaration> {\n+) -> Option<Definition> {\n     let parent = name_ref.syntax().parent()?;\n     match_ast! {\n         match parent {\n@@ -64,7 +66,7 @@ pub(crate) fn classify_name_ref(\n             },\n             ast::FieldExpr(it) => {\n                 if let Some(field) = analyzer.resolve_field(&it) {\n-                    return Some(field.declaration(db));\n+                    return Some(field.definition(db));\n                 }\n             },\n             ast::RecordField(it) => {\n@@ -73,7 +75,7 @@ pub(crate) fn classify_name_ref(\n                     let hir_path = Path::from_name_ref(name_ref);\n                     let hir_name = hir_path.as_ident()?;\n                     let field = variant_def.field(db, hir_name)?;\n-                    return Some(field.declaration(db));\n+                    return Some(field.definition(db));\n                 }\n             },\n             _ => (),\n@@ -83,45 +85,46 @@ pub(crate) fn classify_name_ref(\n     let ast = ModuleSource::from_child_node(db, file_id, &parent);\n     let file_id = file_id.into();\n     let container = Module::from_definition(db, Source { file_id, ast })?;\n+    let visibility = None;\n \n     if let Some(macro_call) =\n         parent.parent().and_then(|node| node.parent()).and_then(ast::MacroCall::cast)\n     {\n         if let Some(mac) = analyzer.resolve_macro_call(db, &macro_call) {\n-            return Some(Declaration { item: NameKind::Macro(mac), container, visibility: None });\n+            return Some(Definition { item: NameKind::Macro(mac), container, visibility });\n         }\n     }\n \n     // General case, a path or a local:\n     let path = name_ref.syntax().ancestors().find_map(ast::Path::cast)?;\n     let resolved = analyzer.resolve_path(db, &path)?;\n     match resolved {\n-        PathResolution::Def(def) => Some(def.declaration(db)),\n+        PathResolution::Def(def) => Some(def.definition(db)),\n         PathResolution::LocalBinding(Either::A(pat)) => decl_from_pat(db, file_id, pat),\n         PathResolution::LocalBinding(Either::B(par)) => {\n-            Some(Declaration { item: NameKind::SelfParam(par), container, visibility: None })\n+            Some(Definition { item: NameKind::SelfParam(par), container, visibility })\n         }\n         PathResolution::GenericParam(par) => {\n             // FIXME: get generic param def\n-            Some(Declaration { item: NameKind::GenericParam(par), container, visibility: None })\n+            Some(Definition { item: NameKind::GenericParam(par), container, visibility })\n         }\n         PathResolution::Macro(def) => {\n-            Some(Declaration { item: NameKind::Macro(def), container, visibility: None })\n+            Some(Definition { item: NameKind::Macro(def), container, visibility })\n         }\n         PathResolution::SelfType(impl_block) => {\n             let ty = impl_block.target_ty(db);\n             let container = impl_block.module();\n-            Some(Declaration { item: NameKind::SelfType(ty), container, visibility: None })\n+            Some(Definition { item: NameKind::SelfType(ty), container, visibility })\n         }\n-        PathResolution::AssocItem(assoc) => Some(assoc.declaration(db)),\n+        PathResolution::AssocItem(assoc) => Some(assoc.definition(db)),\n     }\n }\n \n pub(crate) fn classify_name(\n     db: &RootDatabase,\n     file_id: FileId,\n     name: &ast::Name,\n-) -> Option<Declaration> {\n+) -> Option<Definition> {\n     let parent = name.syntax().parent()?;\n     let file_id = file_id.into();\n \n@@ -145,7 +148,7 @@ pub(crate) fn classify_name(\n             ast::EnumVariant(it) => {\n                 let src = hir::Source { file_id, ast: it.clone() };\n                 let def: ModuleDef = EnumVariant::from_source(db, src)?.into();\n-                Some(def.declaration(db))\n+                Some(def.definition(db))\n             },\n             ast::ModuleItem(it) => {\n                 ModuleDef::from_def(db, file_id, it)\n@@ -159,7 +162,7 @@ fn decl_from_pat(\n     db: &RootDatabase,\n     file_id: HirFileId,\n     pat: AstPtr<ast::BindPat>,\n-) -> Option<Declaration> {\n+) -> Option<Definition> {\n     let root = db.parse_or_expand(file_id)?;\n     // FIXME: use match_ast!\n     let def = pat.to_node(&root).syntax().ancestors().find_map(|node| {\n@@ -178,76 +181,76 @@ fn decl_from_pat(\n     })?;\n     let item = NameKind::Pat((def, pat));\n     let container = def.module(db);\n-    Some(Declaration { item, container, visibility: None })\n+    Some(Definition { item, container, visibility: None })\n }\n \n-impl HasDeclaration for StructField {\n+impl HasDefinition for StructField {\n     type Def = ast::RecordFieldDef;\n     type Ref = ast::FieldExpr;\n \n-    fn declaration(self, db: &RootDatabase) -> Declaration {\n+    fn definition(self, db: &RootDatabase) -> Definition {\n         let item = NameKind::FieldAccess(self);\n         let parent = self.parent_def(db);\n         let container = parent.module(db);\n         let visibility = match parent {\n             VariantDef::Struct(s) => s.source(db).ast.visibility(),\n             VariantDef::EnumVariant(e) => e.source(db).ast.parent_enum().visibility(),\n         };\n-        Declaration { item, container, visibility }\n+        Definition { item, container, visibility }\n     }\n \n-    fn from_def(db: &RootDatabase, file_id: HirFileId, def: Self::Def) -> Option<Declaration> {\n+    fn from_def(db: &RootDatabase, file_id: HirFileId, def: Self::Def) -> Option<Definition> {\n         let src = hir::Source { file_id, ast: hir::FieldSource::Named(def) };\n         let field = StructField::from_source(db, src)?;\n-        Some(field.declaration(db))\n+        Some(field.definition(db))\n     }\n \n     fn from_ref(\n         db: &RootDatabase,\n         analyzer: &SourceAnalyzer,\n         refer: Self::Ref,\n-    ) -> Option<Declaration> {\n+    ) -> Option<Definition> {\n         let field = analyzer.resolve_field(&refer)?;\n-        Some(field.declaration(db))\n+        Some(field.definition(db))\n     }\n }\n \n-impl HasDeclaration for AssocItem {\n+impl HasDefinition for AssocItem {\n     type Def = ast::ImplItem;\n     type Ref = ast::MethodCallExpr;\n \n-    fn declaration(self, db: &RootDatabase) -> Declaration {\n+    fn definition(self, db: &RootDatabase) -> Definition {\n         let item = NameKind::AssocItem(self);\n         let container = self.module(db);\n         let visibility = match self {\n             AssocItem::Function(f) => f.source(db).ast.visibility(),\n             AssocItem::Const(c) => c.source(db).ast.visibility(),\n             AssocItem::TypeAlias(a) => a.source(db).ast.visibility(),\n         };\n-        Declaration { item, container, visibility }\n+        Definition { item, container, visibility }\n     }\n \n-    fn from_def(db: &RootDatabase, file_id: HirFileId, def: Self::Def) -> Option<Declaration> {\n+    fn from_def(db: &RootDatabase, file_id: HirFileId, def: Self::Def) -> Option<Definition> {\n         let src = hir::Source { file_id, ast: def };\n         let item = AssocItem::from_source(db, src)?;\n-        Some(item.declaration(db))\n+        Some(item.definition(db))\n     }\n \n     fn from_ref(\n         db: &RootDatabase,\n         analyzer: &SourceAnalyzer,\n         refer: Self::Ref,\n-    ) -> Option<Declaration> {\n+    ) -> Option<Definition> {\n         let func: AssocItem = analyzer.resolve_method_call(&refer)?.into();\n-        Some(func.declaration(db))\n+        Some(func.definition(db))\n     }\n }\n \n-impl HasDeclaration for ModuleDef {\n+impl HasDefinition for ModuleDef {\n     type Def = ast::ModuleItem;\n     type Ref = ast::Path;\n \n-    fn declaration(self, db: &RootDatabase) -> Declaration {\n+    fn definition(self, db: &RootDatabase) -> Definition {\n         let (container, visibility) = match self {\n             ModuleDef::Module(it) => {\n                 let container = it.parent(db).or_else(|| Some(it)).unwrap();\n@@ -270,22 +273,22 @@ impl HasDeclaration for ModuleDef {\n             ModuleDef::BuiltinType(..) => unreachable!(),\n         };\n         let item = NameKind::Def(self);\n-        Declaration { item, container, visibility }\n+        Definition { item, container, visibility }\n     }\n \n-    fn from_def(db: &RootDatabase, file_id: HirFileId, def: Self::Def) -> Option<Declaration> {\n+    fn from_def(db: &RootDatabase, file_id: HirFileId, def: Self::Def) -> Option<Definition> {\n         let src = hir::Source { file_id, ast: def };\n         let def = ModuleDef::from_source(db, src)?;\n-        Some(def.declaration(db))\n+        Some(def.definition(db))\n     }\n \n     fn from_ref(\n         db: &RootDatabase,\n         analyzer: &SourceAnalyzer,\n         refer: Self::Ref,\n-    ) -> Option<Declaration> {\n+    ) -> Option<Definition> {\n         None\n     }\n }\n \n-// FIXME: impl HasDeclaration for hir::MacroDef\n+// FIXME: impl HasDefinition for hir::MacroDef"}, {"sha": "24cd7e8275478452a0d81e4285e69d4156dd1030", "filename": "crates/ra_ide_api/src/references.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5b03773fbeea55d86f64e5fb69a0d0f1d6a4f7e8/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b03773fbeea55d86f64e5fb69a0d0f1d6a4f7e8/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences.rs?ref=5b03773fbeea55d86f64e5fb69a0d0f1d6a4f7e8", "patch": "@@ -7,10 +7,8 @@ use relative_path::{RelativePath, RelativePathBuf};\n \n use crate::{\n     db::RootDatabase,\n-    name_kind::{\n-        classify_name, classify_name_ref,\n-        NameKind::{self, *},\n-    },\n+    name_kind::{classify_name, classify_name_ref, Definition, NameKind::*},\n+    search_scope::find_refs,\n     FileId, FilePosition, FileRange, FileSystemEdit, NavigationTarget, RangeInfo, SourceChange,\n     SourceFileEdit, TextRange,\n };\n@@ -58,9 +56,9 @@ pub(crate) fn find_all_refs(\n ) -> Option<RangeInfo<ReferenceSearchResult>> {\n     let parse = db.parse(position.file_id);\n     let syntax = parse.tree().syntax().clone();\n-    let RangeInfo { range, info: (analyzer, name_kind) } = find_name(db, &syntax, position)?;\n+    let RangeInfo { range, info: (name, def) } = find_name(db, &syntax, position)?;\n \n-    let declaration = match name_kind {\n+    let declaration = match def.item {\n         Macro(mac) => NavigationTarget::from_macro_def(db, mac),\n         FieldAccess(field) => NavigationTarget::from_field(db, field),\n         AssocItem(assoc) => NavigationTarget::from_assoc_item(db, assoc),\n@@ -74,33 +72,37 @@ pub(crate) fn find_all_refs(\n         GenericParam(_) => return None,\n     };\n \n-    let references = match name_kind {\n-        Pat((_, pat)) => analyzer\n-            .find_all_refs(&pat.to_node(&syntax))\n-            .into_iter()\n-            .map(move |ref_desc| FileRange { file_id: position.file_id, range: ref_desc.range })\n-            .collect::<Vec<_>>(),\n-        _ => vec![],\n-    };\n+    // let references = match name_kind {\n+    //     Pat((_, pat)) => analyzer\n+    //         .find_all_refs(&pat.to_node(&syntax))\n+    //         .into_iter()\n+    //         .map(move |ref_desc| FileRange { file_id: position.file_id, range: ref_desc.range })\n+    //         .collect::<Vec<_>>(),\n+    //     _ => vec![],\n+    // };\n+    let references = find_refs(db, def, name);\n+    let references = references\n+        .into_iter()\n+        .map(move |ref_desc| FileRange { file_id: position.file_id, range: ref_desc.range })\n+        .collect::<Vec<_>>();\n \n     return Some(RangeInfo::new(range, ReferenceSearchResult { declaration, references }));\n \n     fn find_name<'a>(\n         db: &RootDatabase,\n         syntax: &SyntaxNode,\n         position: FilePosition,\n-    ) -> Option<RangeInfo<(hir::SourceAnalyzer, NameKind)>> {\n+    ) -> Option<RangeInfo<(String, Definition)>> {\n         if let Some(name) = find_node_at_offset::<ast::Name>(&syntax, position.offset) {\n-            let analyzer = hir::SourceAnalyzer::new(db, position.file_id, name.syntax(), None);\n-            let name_kind = classify_name(db, position.file_id, &name)?.item;\n+            let def = classify_name(db, position.file_id, &name)?;\n             let range = name.syntax().text_range();\n-            return Some(RangeInfo::new(range, (analyzer, name_kind)));\n+            return Some(RangeInfo::new(range, (name.text().to_string(), def)));\n         }\n         let name_ref = find_node_at_offset::<ast::NameRef>(&syntax, position.offset)?;\n         let range = name_ref.syntax().text_range();\n         let analyzer = hir::SourceAnalyzer::new(db, position.file_id, name_ref.syntax(), None);\n-        let name_kind = classify_name_ref(db, position.file_id, &analyzer, &name_ref)?.item;\n-        Some(RangeInfo::new(range, (analyzer, name_kind)))\n+        let def = classify_name_ref(db, position.file_id, &analyzer, &name_ref)?;\n+        Some(RangeInfo::new(range, (name_ref.text().to_string(), def)))\n     }\n }\n \n@@ -271,12 +273,16 @@ mod tests {\n         let code = r#\"\n             //- /lib.rs\n             struct Foo {\n-                spam<|>: u32,\n+                pub spam<|>: u32,\n+            }\n+\n+            fn main(s: Foo) {\n+                let f = s.spam;\n             }\n         \"#;\n \n         let refs = get_all_refs(code);\n-        assert_eq!(refs.len(), 1);\n+        assert_eq!(refs.len(), 2);\n     }\n \n     #[test]"}, {"sha": "9fcbdcc3a4c13574807bb763e22eb3d63a343336", "filename": "crates/ra_ide_api/src/search_scope.rs", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/5b03773fbeea55d86f64e5fb69a0d0f1d6a4f7e8/crates%2Fra_ide_api%2Fsrc%2Fsearch_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b03773fbeea55d86f64e5fb69a0d0f1d6a4f7e8/crates%2Fra_ide_api%2Fsrc%2Fsearch_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsearch_scope.rs?ref=5b03773fbeea55d86f64e5fb69a0d0f1d6a4f7e8", "patch": "@@ -1,18 +1,69 @@\n-use hir::{DefWithBody, HasSource, ModuleSource};\n+use hir::{\n+    source_binder::ReferenceDescriptor, DefWithBody, HasSource, ModuleSource, SourceAnalyzer,\n+};\n use ra_db::{FileId, SourceDatabase};\n-use ra_syntax::{AstNode, TextRange};\n+use ra_syntax::{algo::find_node_at_offset, ast, AstNode, SourceFile, TextRange, TextUnit};\n \n use crate::{\n     db::RootDatabase,\n-    name_kind::{Declaration, NameKind},\n+    name_kind::{classify_name_ref, Definition, NameKind},\n };\n \n-pub struct SearchScope {\n+pub(crate) struct SearchScope {\n     pub scope: Vec<(FileId, Option<TextRange>)>,\n }\n \n-impl Declaration {\n-    pub fn scope(self, db: &RootDatabase) -> Option<SearchScope> {\n+pub(crate) fn find_refs(\n+    db: &RootDatabase,\n+    def: Definition,\n+    name: String,\n+) -> Vec<ReferenceDescriptor> {\n+    let pat = name.as_str();\n+    let scope = def.scope(db).scope;\n+    let mut refs = vec![];\n+\n+    let is_match = |file_id: FileId, name_ref: &ast::NameRef| -> bool {\n+        let analyzer = SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n+        let classified = classify_name_ref(db, file_id, &analyzer, &name_ref);\n+        if let Some(d) = classified {\n+            d == def\n+        } else {\n+            false\n+        }\n+    };\n+\n+    for (file_id, text_range) in scope {\n+        let text = db.file_text(file_id);\n+        let parse = SourceFile::parse(&text);\n+        let syntax = parse.tree().syntax().clone();\n+\n+        for (idx, _) in text.match_indices(pat) {\n+            let offset = TextUnit::from_usize(idx);\n+            if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(&syntax, offset) {\n+                let name_range = name_ref.syntax().text_range();\n+\n+                if let Some(range) = text_range {\n+                    if name_range.is_subrange(&range) && is_match(file_id, &name_ref) {\n+                        refs.push(ReferenceDescriptor {\n+                            name: name_ref.text().to_string(),\n+                            range: name_ref.syntax().text_range(),\n+                        });\n+                    }\n+                } else if is_match(file_id, &name_ref) {\n+                    refs.push(ReferenceDescriptor {\n+                        name: name_ref.text().to_string(),\n+                        range: name_ref.syntax().text_range(),\n+                    });\n+                }\n+            }\n+        }\n+    }\n+\n+    return refs;\n+}\n+\n+impl Definition {\n+    pub fn scope(&self, db: &RootDatabase) -> SearchScope {\n         let module_src = self.container.definition_source(db);\n         let file_id = module_src.file_id.original_file(db);\n \n@@ -22,16 +73,16 @@ impl Declaration {\n                 DefWithBody::Const(c) => c.source(db).ast.syntax().text_range(),\n                 DefWithBody::Static(s) => s.source(db).ast.syntax().text_range(),\n             };\n-            return Some(SearchScope { scope: vec![(file_id, Some(range))] });\n+            return SearchScope { scope: vec![(file_id, Some(range))] };\n         }\n \n-        if let Some(vis) = self.visibility {\n+        if let Some(ref vis) = self.visibility {\n             let source_root_id = db.file_source_root(file_id);\n             let source_root = db.source_root(source_root_id);\n             let mut files = source_root.walk().map(|id| (id.into(), None)).collect::<Vec<_>>();\n \n             if vis.syntax().text() == \"pub(crate)\" {\n-                return Some(SearchScope { scope: files });\n+                return SearchScope { scope: files };\n             }\n             if vis.syntax().text() == \"pub\" {\n                 let krate = self.container.krate(db).unwrap();\n@@ -48,17 +99,15 @@ impl Declaration {\n                     }\n                 }\n \n-                return Some(SearchScope { scope: files });\n+                return SearchScope { scope: files };\n             }\n-            // FIXME: extend to \"pub(super)\" and \"pub(in path)\" cases,\n-            // then remove `Option`\n-            return None;\n+            // FIXME: \"pub(super)\", \"pub(in path)\"\n         }\n \n         let range = match module_src.ast {\n             ModuleSource::Module(m) => Some(m.syntax().text_range()),\n             ModuleSource::SourceFile(_) => None,\n         };\n-        Some(SearchScope { scope: vec![(file_id, range)] })\n+        SearchScope { scope: vec![(file_id, range)] }\n     }\n }"}]}