{"sha": "329f7a17e2162807d62b5f1f4c3d97da1317d192", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyOWY3YTE3ZTIxNjI4MDdkNjJiNWYxZjRjM2Q5N2RhMTMxN2QxOTI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-26T09:11:35Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-29T00:22:15Z"}, "message": "Update docs on the formal basis of the borrow checker.", "tree": {"sha": "7a0bd1b57dbd2885647f47445c91b38fcc32cdc7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a0bd1b57dbd2885647f47445c91b38fcc32cdc7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/329f7a17e2162807d62b5f1f4c3d97da1317d192", "comment_count": 2, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/329f7a17e2162807d62b5f1f4c3d97da1317d192", "html_url": "https://github.com/rust-lang/rust/commit/329f7a17e2162807d62b5f1f4c3d97da1317d192", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/329f7a17e2162807d62b5f1f4c3d97da1317d192/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "url": "https://api.github.com/repos/rust-lang/rust/commits/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "html_url": "https://github.com/rust-lang/rust/commit/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62"}], "stats": {"total": 1162, "additions": 527, "deletions": 635}, "files": [{"sha": "2151c86519a099f459c059152ea655613a9b3f65", "filename": "src/librustc/middle/borrowck/doc.rs", "status": "modified", "additions": 502, "deletions": 627, "changes": 1129, "blob_url": "https://github.com/rust-lang/rust/blob/329f7a17e2162807d62b5f1f4c3d97da1317d192/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329f7a17e2162807d62b5f1f4c3d97da1317d192/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs?ref=329f7a17e2162807d62b5f1f4c3d97da1317d192", "patch": "@@ -13,8 +13,31 @@\n # The Borrow Checker\n \n This pass has the job of enforcing memory safety. This is a subtle\n-topic. The only way I know how to explain it is terms of a formal\n-model, so that's what I'll do.\n+topic. This docs aim to explain both the practice and the theory\n+behind the borrow checker. They start with a high-level overview of\n+how it works, and then proceed to dive into the theoretical\n+background. Finally, they go into detail on some of the more subtle\n+aspects.\n+\n+# Overview\n+\n+The borrow checker checks one function at a time. It operates in two\n+passes. The first pass, called `gather_loans`, walks over the function\n+and identifies all of the places where borrows occur (e.g., `&`\n+expressions and `ref` bindings). For each borrow, we check various\n+basic safety conditions at this time (for example, that the lifetime\n+of the borrow doesn't exceed the lifetime of the value being\n+borrowed).\n+\n+It then uses the dataflow module to propagate which of those borrows\n+may be in scope at each point in the procedure. A loan is considered\n+to come into scope at the expression that caused it and to go out of\n+scope when the lifetime of the resulting borrowed pointer expires.\n+\n+Once the in-scope loans are known for each point in the program, the\n+borrow checker walks the IR again in a second pass called\n+`check_loans`. This pass examines each statement and makes sure that\n+it is safe with respect to the in-scope loans.\n \n # Formal model\n \n@@ -60,691 +83,543 @@ This is of course dangerous because mutating `x` will free the old\n value and hence invalidate `y`. The borrow checker aims to prevent\n this sort of thing.\n \n-### Loans\n+### Loans and restrictions\n \n The way the borrow checker works is that it analyzes each borrow\n expression (in our simple model, that's stuff like `&LV`, though in\n real life there are a few other cases to consider). For each borrow\n-expression, it computes a vector of loans:\n+expression, it computes a `Loan`, which is a data structure that\n+records (1) the value being borrowed, (2) the mutability and scope of\n+the borrow, and (3) a set of restrictions. In the code, `Loan` is a\n+struct defined in `middle::borrowck`. Formally, we define `LOAN` as\n+follows:\n+\n+    LOAN = (LV, LT, MQ, RESTRICTION*)\n+    RESTRICTION = (LV, ACTION*)\n+    ACTION = MUTATE | CLAIM | FREEZE | ALIAS\n+\n+Here the `LOAN` tuple defines the lvalue `LV` being borrowed; the\n+lifetime `LT` of that borrow; the mutability `MQ` of the borrow; and a\n+list of restrictions. The restrictions indicate actions which, if\n+taken, could invalidate the loan and lead to type safety violations.\n+\n+Each `RESTRICTION` is a pair of a restrictive lvalue `LV` (which will\n+either be the path that was borrowed or some prefix of the path that\n+was borrowed) and a set of restricted actions.  There are three kinds\n+of actions that may be restricted for the path `LV`:\n+\n+- `MUTATE` means that `LV` cannot be assigned to;\n+- `CLAIM` means that the `LV` cannot be borrowed mutably;\n+- `FREEZE` means that the `LV` cannot be borrowed immutably;\n+- `ALIAS` means that `LV` cannot be aliased in any way (not even `&const`).\n+\n+Finally, it is never possible to move from an lvalue that appears in a\n+restriction. This implies that the \"empty restriction\" `(LV, [])`,\n+which contains an empty set of actions, still has a purpose---it\n+prevents moves from `LV`. I chose not to make `MOVE` a fourth kind of\n+action because that would imply that sometimes moves are permitted\n+from restrictived values, which is not the case.\n \n-    LOAN = (LV, LT, PT, LK)\n-    PT = Partial | Total\n-    LK = MQ | RESERVE\n+### Example\n \n-Each `LOAN` tuple indicates some sort of restriction on what can be\n-done to the lvalue `LV`; `LV` will always be a path owned by the\n-current stack frame. These restrictions are called \"loans\" because\n-they are always the result of a borrow expression.\n+To give you a better feeling for what kind of restrictions derived\n+from a loan, let's look at the loan `L` that would be issued as a\n+result of the borrow `&mut (*x).f` in the example above:\n+\n+    L = ((*x).f, 'a, mut, RS) where\n+        RS = [((*x).f, [MUTATE, CLAIM, FREEZE]),\n+              (*x, [MUTATE, CLAIM, FREEZE]),\n+              (x, [MUTATE, CLAIM, FREEZE])]\n+\n+The loan states that the expression `(*x).f` has been loaned as\n+mutable for the lifetime `'a`. Because the loan is mutable, that means\n+that the value `(*x).f` may be mutated via the newly created borrowed\n+pointer (and *only* via that pointer). This is reflected in the\n+restrictions `RS` that accompany the loan.\n+\n+The first restriction `((*x).f, [MUTATE, CLAIM, FREEZE])` states that\n+the lender may not mutate nor freeze `(*x).f`. Mutation is illegal\n+because `(*x).f` is only supposed to be mutated via the new borrowed\n+pointer, not by mutating the original path `(*x).f`. Freezing is\n+illegal because the path now has an `&mut` alias; so even if we the\n+lender were to consider `(*x).f` to be immutable, it might be mutated\n+via this alias. Both of these restrictions are temporary. They will be\n+enforced for the lifetime `'a` of the loan. After the loan expires,\n+the restrictions no longer apply.\n+\n+The second restriction on `*x` is interesting because it does not\n+apply to the path that was lent (`(*x).f`) but rather to a prefix of\n+the borrowed path. This is due to the rules of inherited mutability:\n+if the user were to assign to (or freeze) `*x`, they would indirectly\n+overwrite (or freeze) `(*x).f`, and thus invalidate the borrowed\n+pointer that was created. In general it holds that when a path is\n+lent, restrictions are issued for all the owning prefixes of that\n+path. In this case, the path `*x` owns the path `(*x).f` and,\n+because `x` is an owned pointer, the path `x` owns the path `*x`.\n+Therefore, borrowing `(*x).f` yields restrictions on both\n+`*x` and `x`.\n \n-Every loan has a lifetime `LT` during which those restrictions are in\n-effect.  The indicator `PT` distinguishes between *total* loans, in\n-which the LV itself was borrowed, and *partial* loans, which means\n-that some content ownwed by LV was borrowed.\n+## Checking for illegal assignments, moves, and reborrows\n \n-The final element in the loan tuple is the *loan kind* `LK`.  There\n-are four kinds: mutable, immutable, const, and reserve:\n+Once we have computed the loans introduced by each borrow, the borrow\n+checker uses a data flow propagation to compute the full set of loans\n+in scope at each expression and then uses that set to decide whether\n+that expression is legal.  Remember that the scope of loan is defined\n+by its lifetime LT.  We sometimes say that a loan which is in-scope at\n+a particular point is an \"outstanding loan\", aand the set of\n+restrictions included in those loans as the \"outstanding\n+restrictions\".\n+\n+The kinds of expressions which in-scope loans can render illegal are:\n+- *assignments* (`lv = v`): illegal if there is an in-scope restriction\n+  against mutating `lv`;\n+- *moves*: illegal if there is any in-scope restriction on `lv` at all;\n+- *mutable borrows* (`&mut lv`): illegal there is an in-scope restriction\n+  against mutating `lv` or aliasing `lv`;\n+- *immutable borrows* (`&lv`): illegal there is an in-scope restriction\n+  against freezing `lv` or aliasing `lv`;\n+- *read-only borrows* (`&const lv`): illegal there is an in-scope restriction\n+  against aliasing `lv`.\n \n-- A \"mutable\" loan means that LV may be written to through an alias, and\n-  thus LV cannot be written to directly or immutably aliased (remember\n-  that we preserve the invariant that any given value can only be\n-  written to through one path at a time; hence if there is a mutable\n-  alias to LV, then LV cannot be written directly until this alias is\n-  out of scope).\n+# Formal rules\n \n-- An \"immutable\" loan means that LV must remain immutable.  Hence it\n-  cannot be written, but other immutable aliases are permitted.\n+Now that we hopefully have some kind of intuitive feeling for how the\n+borrow checker works, let's look a bit more closely now at the precise\n+conditions that it uses. For simplicity I will ignore const loans.\n \n-- A \"const\" loan means that an alias to LV exists.  LV may still be\n-  written or frozen.\n+I will present the rules in a modified form of standard inference\n+rules, which looks as as follows:\n \n-- A \"reserve\" loan is the strongest case.  It prevents both mutation\n-  and aliasing of any kind, including `&const` loans.  Reserve loans\n-  are a side-effect of borrowing an `&mut` loan.\n+    PREDICATE(X, Y, Z)                  // Rule-Name\n+      Condition 1\n+      Condition 2\n+      Condition 3\n+\n+The initial line states the predicate that is to be satisfied.  The\n+indented lines indicate the conditions that must be met for the\n+predicate to be satisfied. The right-justified comment states the name\n+of this rule: there are comments in the borrowck source referencing\n+these names, so that you can cross reference to find the actual code\n+that corresponds to the formal rule.\n+\n+## The `gather_loans` pass\n \n-In addition to affecting mutability, a loan of any kind implies that\n-LV cannot be moved.\n+We start with the `gather_loans` pass, which walks the AST looking for\n+borrows.  For each borrow, there are three bits of information: the\n+lvalue `LV` being borrowed and the mutability `MQ` and lifetime `LT`\n+of the resulting pointer. Given those, `gather_loans` applies three\n+validity tests:\n \n-### Example\n+1. `MUTABILITY(LV, MQ)`: The mutability of the borrowed pointer is\n+compatible with the mutability of `LV` (i.e., not borrowing immutable\n+data as mutable).\n \n-To give you a better feeling for what a loan is, let's look at three\n-loans that would be issued as a result of the borrow `&(*x).f` in the\n-example above:\n-\n-    ((*x).f, Total, mut, 'a)\n-    (*x, Partial, mut, 'a)\n-    (x, Partial, mut, 'a)\n-\n-The first loan states that the expression `(*x).f` has been loaned\n-totally as mutable for the lifetime `'a`. This first loan would\n-prevent an assignment `(*x).f = ...` from occurring during the\n-lifetime `'a`.\n-\n-Now let's look at the second loan. You may have expected that each\n-borrow would result in only one loan. But this is not the case.\n-Instead, there will be loans for every path where mutation might\n-affect the validity of the borrowed pointer that is created (in some\n-cases, there can even be multiple loans per path, see the section on\n-\"Borrowing in Calls\" below for the gory details). The reason for this\n-is to prevent actions that would indirectly affect the borrowed path.\n-In this case, we wish to ensure that `(*x).f` is not mutated except\n-through the mutable alias `y`.  Therefore, we must not only prevent an\n-assignment to `(*x).f` but also an assignment like `*x = Foo {...}`,\n-as this would also mutate the field `f`.  To do so, we issue a\n-*partial* mutable loan for `*x` (the loan is partial because `*x`\n-itself was not borrowed).  This partial loan will cause any attempt to\n-assign to `*x` to be flagged as an error.\n-\n-Because both partial and total loans prevent assignments, you may\n-wonder why we bother to distinguish between them.  The reason for this\n-distinction has to do with preventing double borrows. In particular,\n-it is legal to borrow both `&mut x.f` and `&mut x.g` simultaneously,\n-but it is not legal to borrow `&mut x.f` twice. In the borrow checker,\n-the first case would result in two *partial* mutable loans of `x`\n-(along with one total mutable loan of `x.f` and one of `x.g) whereas\n-the second would result in two *total* mutable loans of `x.f` (along\n-with two partial mutable loans of `x`).  Multiple *total mutable* loan\n-for the same path are not permitted, but multiple *partial* loans (of\n-any mutability) are permitted.\n-\n-Finally, we come to the third loan. This loan is a partial mutable\n-loan of `x`.  This loan prevents us from reassigning `x`, which would\n-be bad for two reasons.  First, it would change the value of `(*x).f`\n-but, even worse, it would cause the pointer `y` to become a dangling\n-pointer.  Bad all around.\n+2. `LIFETIME(LV, LT, MQ)`: The lifetime of the borrow does not exceed\n+the lifetime of the value being borrowed. This pass is also\n+responsible for inserting root annotations to keep managed values\n+alive and for dynamically freezing `@mut` boxes.\n \n-## Checking for illegal assignments, moves, and reborrows\n+3. `RESTRICTIONS(LV, ACTIONS) = RS`: This pass checks and computes the\n+restrictions to maintain memory safety. These are the restrictions\n+that will go into the final loan. We'll discuss in more detail below.\n \n-Once we have computed the loans introduced by each borrow, the borrow\n-checker will determine the full set of loans in scope at each\n-expression and use that to decide whether that expression is legal.\n-Remember that the scope of loan is defined by its lifetime LT.  We\n-sometimes say that a loan which is in-scope at a particular point is\n-an \"outstanding loan\".\n-\n-The kinds of expressions which in-scope loans can render illegal are\n-*assignments*, *moves*, and *borrows*.\n-\n-An assignments to an lvalue LV is illegal if there is in-scope mutable\n-or immutable loan for LV.  Assignment with an outstanding mutable loan\n-is illegal because then the `&mut` pointer is supposed to be the only\n-way to mutate the value.  Assignment with an outstanding immutable\n-loan is illegal because the value is supposed to be immutable at that\n-point.\n-\n-A move from an lvalue LV is illegal if there is any sort of\n-outstanding loan.\n-\n-A borrow expression may be illegal if any of the loans which it\n-produces conflict with other outstanding loans.  Two loans are\n-considered compatible if one of the following conditions holds:\n-\n-- At least one loan is a const loan.\n-- Both loans are partial loans.\n-- Both loans are immutable.\n-\n-Any other combination of loans is illegal.\n-\n-# The set of loans that results from a borrow expression\n-\n-Here we'll define four functions---MUTATE, FREEZE, ALIAS, and\n-TAKE---which are all used to compute the set of LOANs that result\n-from a borrow expression.  The first three functions each have\n-a similar type signature:\n-\n-    MUTATE(LV, LT, PT) -> LOANS\n-    FREEZE(LV, LT, PT) -> LOANS\n-    ALIAS(LV, LT, PT) -> LOANS\n-\n-MUTATE, FREEZE, and ALIAS are used when computing the loans result\n-from mutable, immutable, and const loans respectively.  For example,\n-the loans resulting from an expression like `&mut (*x).f` would be\n-computed by `MUTATE((*x).f, LT, Total)`, where `LT` is the lifetime of\n-the resulting pointer.  Similarly the loans for `&(*x).f` and `&const\n-(*x).f` would be computed by `FREEZE((*x).f, LT, Total)` and\n-`ALIAS((*x).f, LT, Total)` respectively. (Actually this is a slight\n-simplification; see the section below on Borrows in Calls for the full\n-gory details)\n-\n-The names MUTATE, FREEZE, and ALIAS are intended to suggest the\n-semantics of `&mut`, `&`, and `&const` borrows respectively.  `&mut`,\n-for example, creates a mutable alias of LV.  `&` causes the borrowed\n-value to be frozen (immutable).  `&const` does neither but does\n-introduce an alias to be the borrowed value.\n-\n-Each of these three functions is only defined for some inputs.  That\n-is, it may occur that some particular borrow is not legal.  For\n-example, it is illegal to make an `&mut` loan of immutable data.  In\n-that case, the MUTATE() function is simply not defined (in the code,\n-it returns a Result<> condition to indicate when a loan would be\n-illegal).\n-\n-The final function, RESERVE, is used as part of borrowing an `&mut`\n-pointer.  Due to the fact that it is used for one very particular\n-purpose, it has a rather simpler signature than the others:\n-\n-    RESERVE(LV, LT) -> LOANS\n-\n-It is explained when we come to that case.\n-\n-## The function MUTATE()\n-\n-Here we use [inference rules][ir] to define the MUTATE() function.\n-We will go case by case for the various kinds of lvalues that\n-can be borrowed.\n-\n-[ir]: http://en.wikipedia.org/wiki/Rule_of_inference\n-\n-### Mutating local variables\n-\n-The rule for mutating local variables is as follows:\n-\n-    Mutate-Variable:\n-      LT <= Scope(x)\n-      Mut(x) = Mut\n-      --------------------------------------------------\n-      MUTATE(x, LT, PT) = (x, LT, PT, mut)\n-\n-Here `Scope(x)` is the lifetime of the block in which `x` was declared\n-and `Mut(x)` indicates the mutability with which `x` was declared.\n-This rule simply states that you can only create a mutable alias\n-to a variable if it is mutable, and that alias cannot outlive the\n-stack frame in which the variable is declared.\n-\n-### Mutating fields and owned pointers\n-\n-As it turns out, the rules for mutating fields and mutating owned\n-pointers turn out to be quite similar.  The reason is that the\n-expressions `LV.f` and `*LV` are both owned by their base expression\n-`LV`.  So basically the result of mutating `LV.f` or `*LV` is computed\n-by adding a loan for `LV.f` or `*LV` and then the loans for a partial\n-take of `LV`:\n-\n-    Mutate-Field:\n-      MUTATE(LV, LT, Partial) = LOANS\n-      ------------------------------------------------------------\n-      MUTATE(LV.f, LT, PT) = LOANS, (LV.F, LT, PT, mut)\n-\n-    Mutate-Owned-Ptr:\n-      Type(LV) = ~Ty\n-      MUTATE(LV, LT, Partial) = LOANS\n-      ------------------------------------------------------------\n-      MUTATE(*LV, LT, PT) = LOANS, (*LV, LT, PT, mut)\n-\n-Note that while our micro-language only has fields, the slight\n-variations on the `Mutate-Field` rule are used for any interior content\n-that appears in the full Rust language, such as the contents of a\n-tuple, fields in a struct, or elements of a fixed-length vector.\n-\n-### Mutating dereferenced borrowed pointers\n-\n-The rule for borrowed pointers is by far the most complicated:\n-\n-    Mutate-Mut-Borrowed-Ptr:\n-      Type(LV) = &LT_P mut Ty             // (1)\n-      LT <= LT_P                          // (2)\n-      RESERVE(LV, LT) = LOANS             // (3)\n-      ------------------------------------------------------------\n-      MUTATE(*LV, LT, PT) = LOANS, (*LV, LT, PT, Mut)\n-\n-Condition (1) states that only a mutable borrowed pointer can be\n-taken.  Condition (2) states that the lifetime of the alias must be\n-less than the lifetime of the borrowed pointer being taken.\n-\n-Conditions (3) and (4) are where things get interesting.  The intended\n-semantics of the borrow is that the new `&mut` pointer is the only one\n-which has the right to modify the data; the original `&mut` pointer\n-must not be used for mutation.  Because borrowed pointers do not own\n-their content nor inherit mutability, we must be particularly cautious\n-of aliases, which could permit the original borrowed pointer to be\n-reached from another path and thus circumvent our loans.\n-\n-Here is one example of what could go wrong if we ignore clause (4):\n-\n-    let x: &mut T;\n-    ...\n-    let y = &mut *x;   // Only *y should be able to mutate...\n-    let z = &const x;\n-    **z = ...;         // ...but here **z is still able to mutate!\n+# Checking mutability\n \n-Another possible error could occur with moves:\n+Checking mutability is fairly straightforward. We just want to prevent\n+immutable data from being borrowed as mutable. Note that it is ok to\n+borrow mutable data as immutable, since that is simply a\n+freeze. Formally we define a predicate `MUTABLE(LV, MQ)` which, if\n+defined, means that \"borrowing `LV` with mutability `MQ` is ok. The\n+Rust code corresponding to this predicate is the function\n+`check_mutability` in `middle::borrowck::gather_loans`.\n \n-    let x: &mut T;\n-    ...\n-    let y = &mut *x;   // Issues loan: (*x, LT, Total, Mut)\n-    let z = x;         // moves from x\n-    *z = ...;          // Mutates *y indirectly! Bad.\n-\n-In both of these cases, the problem is that when creating the alias\n-`y` we would only issue a loan preventing assignment through `*x`.\n-But this loan can be easily circumvented by moving from `x` or\n-aliasing it.  Note that, in the first example, the alias of `x` was\n-created using `&const`, which is a particularly weak form of alias.\n-\n-The danger of aliases can also occur when the `&mut` pointer itself\n-is already located in an alias location, as here:\n-\n-    let x: @mut &mut T; // or &mut &mut T, &&mut T,\n-    ...                 // &const &mut T, @&mut T, etc\n-    let y = &mut **x;   // Only *y should be able to mutate...\n-    let z = x;\n-    **z = ...;          // ...but here **z is still able to mutate!\n-\n-When we cover the rules for RESERVE, we will see that it would\n-disallow this case, because MUTATE can only be applied to canonical\n-lvalues which are owned by the current stack frame.\n-\n-It might be the case that if `&const` and `@const` pointers were\n-removed, we could do away with RESERVE and simply use MUTATE instead.\n-But we have to be careful about the final example in particular, since\n-dynamic freezing would not be sufficient to prevent this example.\n-Perhaps a combination of MUTATE with a predicate OWNED(LV).\n-\n-One final detail: unlike every other case, when we calculate the loans\n-using RESERVE we do not use the original lifetime `LT` but rather\n-`GLB(Scope(LV), LT)`.  What this says is:\n-\n-### Mutating dereferenced managed pointers\n-\n-Because the correctness of managed pointer loans is checked dynamically,\n-the rule is quite simple:\n-\n-    Mutate-Mut-Managed-Ptr:\n-      Type(LV) = @mut Ty\n-      Add ROOT-FREEZE annotation for *LV with lifetime LT\n-      ------------------------------------------------------------\n-      MUTATE(*LV, LT, Total) = []\n-\n-No loans are issued.  Instead, we add a side annotation that causes\n-`*LV` to be rooted and frozen on entry to LV.  You could rephrase\n-these rules as having multiple returns values, or rephrase this as a\n-kind of loan, but whatever.\n-\n-One interesting point is that *partial takes* of `@mut` are forbidden.\n-This is not for any soundness reason but just because it is clearer\n-for users when `@mut` values are either lent completely or not at all.\n-\n-## The function FREEZE\n-\n-The rules for FREEZE are pretty similar to MUTATE.  The first four\n-cases I'll just present without discussion, as the reasoning is\n-quite analogous to the MUTATE case:\n-\n-    Freeze-Variable:\n-      LT <= Scope(x)\n-      --------------------------------------------------\n-      FREEZE(x, LT, PT) = (x, LT, PT, imm)\n-\n-    Freeze-Field:\n-      FREEZE(LV, LT, Partial) = LOANS\n-      ------------------------------------------------------------\n-      FREEZE(LV.f, LT, PT) = LOANS, (LV.F, LT, PT, imm)\n-\n-    Freeze-Owned-Ptr:\n-      Type(LV) = ~Ty\n-      FREEZE(LV, LT, Partial) = LOANS\n-      ------------------------------------------------------------\n-      FREEZE(*LV, LT, PT) = LOANS, (*LV, LT, PT, imm)\n-\n-    Freeze-Mut-Borrowed-Ptr:\n-      Type(LV) = &LT_P mut Ty\n-      LT <= LT_P\n-      RESERVE(LV, LT) = LOANS\n-      ------------------------------------------------------------\n-      FREEZE(*LV, LT, PT) = LOANS, (*LV, LT, PT, Imm)\n-\n-    Freeze-Mut-Managed-Ptr:\n-      Type(LV) = @mut Ty\n-      Add ROOT-FREEZE annotation for *LV with lifetime LT\n-      ------------------------------------------------------------\n-      Freeze(*LV, LT, Total) = []\n-\n-The rule to \"freeze\" an immutable borrowed pointer is quite\n-simple, since the content is already immutable:\n-\n-    Freeze-Imm-Borrowed-Ptr:\n-      Type(LV) = &LT_P Ty                 // (1)\n-      LT <= LT_P                          // (2)\n-      ------------------------------------------------------------\n-      FREEZE(*LV, LT, PT) = LOANS, (*LV, LT, PT, Mut)\n-\n-The final two rules pertain to borrows of `@Ty`.  There is a bit of\n-subtlety here.  The main problem is that we must guarantee that the\n-managed box remains live for the entire borrow.  We can either do this\n-dynamically, by rooting it, or (better) statically, and hence there\n-are two rules:\n-\n-    Freeze-Imm-Managed-Ptr-1:\n-      Type(LV) = @Ty\n-      Add ROOT annotation for *LV\n-      ------------------------------------------------------------\n-      FREEZE(*LV, LT, PT) = []\n-\n-    Freeze-Imm-Managed-Ptr-2:\n-      Type(LV) = @Ty\n-      LT <= Scope(LV)\n-      Mut(LV) = imm\n-      LV is not moved\n-      ------------------------------------------------------------\n-      FREEZE(*LV, LT, PT) = []\n-\n-The intention of the second rule is to avoid an extra root if LV\n-serves as a root.  In that case, LV must (1) outlive the borrow; (2)\n-be immutable; and (3) not be moved.\n-\n-## The ALIAS function\n-\n-The function ALIAS is used for `&const` loans but also to handle one\n-corner case concerning function arguments (covered in the section\n-\"Borrows in Calls\" below).  It computes the loans that result from\n-observing that there is a pointer to `LV` and thus that pointer must\n-remain valid.\n-\n-The first two rules are simple:\n-\n-    Alias-Variable:\n-      LT <= Scope(x)\n-      --------------------------------------------------\n-      ALIAS(x, LT, PT) = (x, LT, PT, Const)\n-\n-    Alias-Field:\n-      ALIAS(LV, LT, Partial) = LOANS\n-      ------------------------------------------------------------\n-      ALIAS(LV.f, LT, PT) = LOANS, (LV.F, LT, PT, Const)\n-\n-### Aliasing owned pointers\n-\n-The rule for owned pointers is somewhat interesting:\n-\n-    Alias-Owned-Ptr:\n-      Type(LV) = ~Ty\n-      FREEZE(LV, LT, Partial) = LOANS\n-      ------------------------------------------------------------\n-      ALIAS(*LV, LT, PT) = LOANS, (*LV, LT, PT, Const)\n-\n-Here we *freeze* the base `LV`.  The reason is that if an owned\n-pointer is mutated it frees its content, which means that the alias to\n-`*LV` would become a dangling pointer.\n-\n-### Aliasing borrowed pointers\n-\n-The rule for borrowed pointers is quite simple, because borrowed\n-pointers do not own their content and thus do not play a role in\n-keeping it live:\n-\n-    Alias-Borrowed-Ptr:\n-      Type(LV) = &LT_P MQ Ty\n-      LT <= LT_P\n-      ------------------------------------------------------------\n-      ALIAS(*LV, LT, PT) = []\n-\n-Basically, the existence of a borrowed pointer to some memory with\n-lifetime LT_P is proof that the memory can safely be aliased for any\n-lifetime LT <= LT_P.\n-\n-### Aliasing managed pointers\n-\n-The rules for aliasing managed pointers are similar to those\n-used with FREEZE, except that they apply to all manager pointers\n-regardles of mutability:\n-\n-    Alias-Managed-Ptr-1:\n-      Type(LV) = @MQ Ty\n-      Add ROOT annotation for *LV\n-      ------------------------------------------------------------\n-      ALIAS(*LV, LT, PT) = []\n-\n-    Alias-Managed-Ptr-2:\n-      Type(LV) = @MQ Ty\n-      LT <= Scope(LV)\n-      Mut(LV) = imm\n-      LV is not moved\n-      ------------------------------------------------------------\n-      ALIAS(*LV, LT, PT) = []\n-\n-## The RESERVE function\n-\n-The final function, RESERVE, is used for loans of `&mut` pointers.  As\n-discussed in the section on the function MUTATE, we must be quite\n-careful when \"re-borrowing\" an `&mut` pointer to ensure that the original\n-`&mut` pointer can no longer be used to mutate.\n-\n-There are a couple of dangers to be aware of:\n-\n-- `&mut` pointers do not inherit mutability.  Therefore, if you have\n-  an lvalue LV with type `&mut T` and you freeze `LV`, you do *not*\n-  freeze `*LV`.  This is quite different from an `LV` with type `~T`.\n-\n-- Also, because they do not inherit mutability, if the `&mut` pointer\n-  lives in an aliased location, then *any alias* can be used to write!\n-\n-As a consequence of these two rules, RESERVE can only be successfully\n-invoked on an lvalue LV that is *owned by the current stack frame*.\n-This ensures that there are no aliases that are not visible from the\n-outside.  Moreover, Reserve loans are incompatible with all other\n-loans, even Const loans.  This prevents any aliases from being created\n-within the current function.\n+## Checking mutability of variables\n \n-### Reserving local variables\n+*Code pointer:* Function `check_mutability()` in `gather_loans/mod.rs`,\n+but also the code in `mem_categorization`.\n \n-The rule for reserving a variable is generally straightforward but\n-with one interesting twist:\n+Let's begin with the rules for variables, which state that if a\n+variable is declared as mutable, it may be borrowed any which way, but\n+otherwise the variable must be borrowed as immutable or const:\n \n-    Reserve-Variable:\n-      --------------------------------------------------\n-      RESERVE(x, LT) = (x, LT, Total, Reserve)\n+    MUTABILITY(X, MQ)                   // M-Var-Mut\n+      DECL(X) = mut\n \n-The twist here is that the incoming lifetime is not required to\n-be a subset of the incoming variable, unlike every other case.  To\n-see the reason for this, imagine the following function:\n+    MUTABILITY(X, MQ)                   // M-Var-Imm\n+      DECL(X) = imm\n+      MQ = imm | const\n \n-    struct Foo { count: uint }\n-    fn count_field(x: &'a mut Foo) -> &'a mut count {\n-        &mut (*x).count\n-    }\n+## Checking mutability of owned content\n \n-This function consumes one `&mut` pointer and returns another with the\n-same lifetime pointing at a particular field.  The borrow for the\n-`&mut` expression will result in a call to `RESERVE(x, 'a)`, which is\n-intended to guarantee that `*x` is not later aliased or used to\n-mutate.  But the lifetime of `x` is limited to the current function,\n-which is a sublifetime of the parameter `'a`, so the rules used for\n-MUTATE, FREEZE, and ALIAS (which require that the lifetime of the loan\n-not exceed the lifetime of the variable) would result in an error.\n+Fields and owned pointers inherit their mutability from\n+their base expressions, so both of their rules basically\n+delegate the check to the base expression `LV`:\n \n-Nonetheless this function is perfectly legitimate.  After all, the\n-caller has moved in an `&mut` pointer with lifetime `'a`, and thus has\n-given up their right to mutate the value for the remainder of `'a`.\n-So it is fine for us to return a pointer with the same lifetime.\n+    MUTABILITY(LV.f, MQ)                // M-Field\n+      MUTABILITY(LV, MQ)\n \n-The reason that RESERVE differs from the other functions is that\n-RESERVE is not responsible for guaranteeing that the pointed-to data\n-will outlive the borrowed pointer being created.  After all, `&mut`\n-values do not own the data they point at.\n+    MUTABILITY(*LV, MQ)                 // M-Deref-Unique\n+      TYPE(LV) = ~Ty\n+      MUTABILITY(LV, MQ)\n \n-### Reserving owned content\n+## Checking mutability of immutable pointer types\n \n-The rules for fields and owned pointers are very straightforward:\n+Immutable pointer types like `&T` and `@T` can only\n+be borrowed if MQ is immutable or const:\n \n-    Reserve-Field:\n-      RESERVE(LV, LT) = LOANS\n-      ------------------------------------------------------------\n-      RESERVE(LV.f, LT) = LOANS, (LV.F, LT, Total, Reserve)\n+    MUTABILITY(*LV, MQ)                // M-Deref-Borrowed-Imm\n+      TYPE(LV) = &Ty\n+      MQ == imm | const\n \n-    Reserve-Owned-Ptr:\n-      Type(LV) = ~Ty\n-      RESERVE(LV, LT) = LOANS\n-      ------------------------------------------------------------\n-      RESERVE(*LV, LT) = LOANS, (*LV, LT, Total, Reserve)\n+    MUTABILITY(*LV, MQ)                // M-Deref-Managed-Imm\n+      TYPE(LV) = @Ty\n+      MQ == imm | const\n \n-### Reserving `&mut` borrowed pointers\n+## Checking mutability of mutable pointer types\n \n-Unlike other borrowed pointers, `&mut` pointers are unaliasable,\n-so we can reserve them like everything else:\n+`&mut T` and `@mut T` can be frozen, so it is acceptable to borrow\n+them as either imm or mut:\n \n-    Reserve-Mut-Borrowed-Ptr:\n-      Type(LV) = &LT_P mut Ty\n-      RESERVE(LV, LT) = LOANS\n-      ------------------------------------------------------------\n-      RESERVE(*LV, LT) = LOANS, (*LV, LT, Total, Reserve)\n+    MUTABILITY(*LV, MQ)                 // M-Deref-Borrowed-Mut\n+      TYPE(LV) = &mut Ty\n \n-## Borrows in calls\n+    MUTABILITY(*LV, MQ)                 // M-Deref-Managed-Mut\n+      TYPE(LV) = @mut Ty\n \n-Earlier we said that the MUTATE, FREEZE, and ALIAS functions were used\n-to compute the loans resulting from a borrow expression.  But this is\n-not strictly correct, there is a slight complication that occurs with\n-calls by which additional loans may be necessary.  We will explain\n-that here and give the full details.\n+# Checking lifetime\n \n-Imagine a call expression `'a: E1(E2, E3)`, where `Ei` are some\n-expressions. If we break this down to something a bit lower-level, it\n-is kind of short for:\n+These rules aim to ensure that no data is borrowed for a scope that\n+exceeds its lifetime. In addition, these rules manage the rooting and\n+dynamic freezing of `@` and `@mut` values. These two computations wind\n+up being intimately related. Formally, we define a predicate\n+`LIFETIME(LV, LT, MQ)`, which states that \"the lvalue `LV` can be\n+safely borrowed for the lifetime `LT` with mutability `MQ`\". The Rust\n+code corresponding to this predicate is the module\n+`middle::borrowck::gather_loans::lifetime`.\n \n-    'a: {\n-        'a_arg1: let temp1: ... = E1;\n-        'a_arg2: let temp2: ... = E2;\n-        'a_arg3: let temp3: ... = E3;\n-        'a_call: temp1(temp2, temp3)\n-    }\n+## The Scope function\n \n-Here the lifetime labels indicate the various lifetimes. As you can\n-see there are in fact four relevant lifetimes (only one of which was\n-named by the user): `'a` corresponds to the expression `E1(E2, E3)` as\n-a whole. `'a_arg1`, `'a_arg2`, and `'a_arg3` correspond to the\n-evaluations of `E1`, `E2`, and `E3` respectively. Finally, `'a_call`\n-corresponds to the *actual call*, which is the point where the values\n-of the parameters will be used.\n+Several of the rules refer to a helper function `SCOPE(LV)=LT`.  The\n+`SCOPE(LV)` yields the lifetime `LT` for which the lvalue `LV` is\n+guaranteed to exist, presuming that no mutations occur.\n \n-Now, let's look at a (contrived, but representative) example to see\n-why all this matters:\n+The scope of a local variable is the block where it is declared:\n \n-    struct Foo { f: uint, g: uint }\n-    ...\n-    fn add(p: &mut uint, v: uint) {\n-        *p += v;\n-    }\n-    ...\n-    fn inc(p: &mut uint) -> uint {\n-        *p += 1; *p\n-    }\n-    fn weird() {\n-        let mut x: ~Foo = ~Foo { ... };\n-        'a: add(&mut (*x).f,\n-                'b: inc(&mut (*x).f)) // (*)\n-    }\n+      SCOPE(X) = block where X is declared\n \n-The important part is the line marked `(*)` which contains a call to\n-`add()`. The first argument is a mutable borrow of the field `f`.\n-The second argument *always borrows* the field `f`. Now, if these two\n-borrows overlapped in time, this would be illegal, because there would\n-be two `&mut` pointers pointing at `f`. And, in a way, they *do*\n-overlap in time, since the first argument will be evaluated first,\n-meaning that the pointer will exist when the second argument executes.\n-But in another important way they do not overlap in time. Let's\n-expand out that final call to `add()` as we did before:\n+The scope of a field is the scope of the struct:\n \n-    'a: {\n-        'a_arg1: let a_temp1: ... = add;\n-        'a_arg2: let a_temp2: &'a_call mut uint = &'a_call mut (*x).f;\n-        'a_arg3_: let a_temp3: uint = {\n-            let b_temp1: ... = inc;\n-            let b_temp2: &'b_call = &'b_call mut (*x).f;\n-            'b_call: b_temp1(b_temp2)\n-        };\n-        'a_call: a_temp1(a_temp2, a_temp3)\n-    }\n+      SCOPE(LV.f) = SCOPE(LV)\n \n-When it's written this way, we can see that although there are two\n-borrows, the first has lifetime `'a_call` and the second has lifetime\n-`'b_call` and in fact these lifetimes do not overlap. So everything\n-is fine.\n+The scope of a unique pointee is the scope of the pointer, since\n+(barring mutation or moves) the pointer will not be freed until\n+the pointer itself `LV` goes out of scope:\n \n-But this does not mean that there isn't reason for caution!  Imagine a\n-devious program like *this* one:\n+      SCOPE(*LV) = SCOPE(LV) if LV has type ~T\n \n-    struct Foo { f: uint, g: uint }\n-    ...\n-    fn add(p: &mut uint, v: uint) {\n-        *p += v;\n-    }\n-    ...\n-    fn consume(x: ~Foo) -> uint {\n-        x.f + x.g\n-    }\n-    fn weird() {\n-        let mut x: ~Foo = ~Foo { ... };\n-        'a: add(&mut (*x).f, consume(x)) // (*)\n-    }\n+The scope of a managed pointee is also the scope of the pointer.  This\n+is a conservative approximation, since there may be other aliases fo\n+that same managed box that would cause it to live longer:\n \n-In this case, there is only one borrow, but the second argument is\n-`consume(x)` instead of a second borrow. Because `consume()` is\n-declared to take a `~Foo`, it will in fact free the pointer `x` when\n-it has finished executing. If it is not obvious why this is\n-troublesome, consider this expanded version of that call:\n+      SCOPE(*LV) = SCOPE(LV) if LV has type @T or @mut T\n \n-    'a: {\n-        'a_arg1: let a_temp1: ... = add;\n-        'a_arg2: let a_temp2: &'a_call mut uint = &'a_call mut (*x).f;\n-        'a_arg3_: let a_temp3: uint = {\n-            let b_temp1: ... = consume;\n-            let b_temp2: ~Foo = x;\n-            'b_call: b_temp1(x)\n-        };\n-        'a_call: a_temp1(a_temp2, a_temp3)\n-    }\n+The scope of a borrowed pointee is the scope associated with the\n+pointer.  This is a conservative approximation, since the data that\n+the pointer points at may actually live longer:\n+\n+      SCOPE(*LV) = LT if LV has type &'LT T or &'LT mut T\n+\n+## Checking lifetime of variables\n+\n+The rule for variables states that a variable can only be borrowed a\n+lifetime `LT` that is a subregion of the variable's scope:\n+\n+    LIFETIME(X, LT, MQ)                 // L-Local\n+      LT <= SCOPE(X)\n+\n+## Checking lifetime for owned content\n+\n+The lifetime of a field or owned pointer is the same as the lifetime\n+of its owner:\n \n-In this example, we will have borrowed the first argument before `x`\n-is freed and then free `x` during evaluation of the second\n-argument. This causes `a_temp2` to be invalidated.\n+    LIFETIME(LV.f, LT, MQ)              // L-Field\n+      LIFETIME(LV, LT, MQ)\n \n-Of course the loans computed from the borrow expression are supposed\n-to prevent this situation.  But if we just considered the loans from\n-`MUTATE((*x).f, 'a_call, Total)`, the resulting loans would be:\n+    LIFETIME(*LV, LT, MQ)               // L-Deref-Owned\n+      TYPE(LV) = ~Ty\n+      LIFETIME(LV, LT, MQ)\n \n-    ((*x).f, 'a_call, Total,   Mut)\n-    (*x,     'a_call, Partial, Mut)\n-    (x,      'a_call, Partial, Mut)\n+## Checking lifetime for derefs of borrowed pointers\n \n-Because these loans are only in scope for `'a_call`, they do nothing\n-to prevent the move that occurs evaluating the second argument.\n+Borrowed pointers have a lifetime `LT'` associated with them.  The\n+data they point at has been guaranteed to be valid for at least this\n+lifetime. Therefore, the borrow is valid so long as the lifetime `LT`\n+of the borrow is shorter than the lifetime `LT'` of the pointer\n+itself:\n \n-The way that we solve this is to say that if you have a borrow\n-expression `&'LT_P mut LV` which itself occurs in the lifetime\n-`'LT_B`, then the resulting loans are:\n+    LIFETIME(*LV, LT, MQ)               // L-Deref-Borrowed\n+      TYPE(LV) = &LT' Ty OR &LT' mut Ty\n+      LT <= LT'\n \n-    MUTATE(LV, LT_P, Total) + ALIAS(LV, LUB(LT_P, LT_B), Total)\n+## Checking lifetime for derefs of managed, immutable pointers\n \n-The call to MUTATE is what we've seen so far.  The second part\n-expresses the idea that the expression LV will be evaluated starting\n-at LT_B until the end of LT_P.  Now, in the normal case, LT_P >= LT_B,\n-and so the second set of loans that result from a ALIAS are basically\n-a no-op.  However, in the case of an argument where the evaluation of\n-the borrow occurs before the interval where the resulting pointer will\n-be used, this ALIAS is important.\n+Managed pointers are valid so long as the data within them is\n+*rooted*. There are two ways that this can be achieved. The first is\n+when the user guarantees such a root will exist. For this to be true,\n+three conditions must be met:\n+\n+    LIFETIME(*LV, LT, MQ)               // L-Deref-Managed-Imm-User-Root\n+      TYPE(LV) = @Ty\n+      LT <= SCOPE(LV)                   // (1)\n+      LV is immutable                   // (2)\n+      LV is not moved or not movable    // (3)\n+\n+Condition (1) guarantees that the managed box will be rooted for at\n+least the lifetime `LT` of the borrow, presuming that no mutation or\n+moves occur. Conditions (2) and (3) then serve to guarantee that the\n+value is not mutated or moved. Note that lvalues are either\n+(ultimately) owned by a local variable, in which case we can check\n+whether that local variable is ever moved in its scope, or they are\n+owned by the pointee of an (immutable, due to condition 2) managed or\n+borrowed pointer, in which case moves are not permitted because the\n+location is aliasable.\n+\n+If the conditions of `L-Deref-Managed-Imm-User-Root` are not met, then\n+there is a second alternative. The compiler can attempt to root the\n+managed pointer itself. This permits great flexibility, because the\n+location `LV` where the managed pointer is found does not matter, but\n+there are some limitations. The lifetime of the borrow can only extend\n+to the innermost enclosing loop or function body. This guarantees that\n+the compiler never requires an unbounded amount of stack space to\n+perform the rooting; if this condition were violated, the compiler\n+might have to accumulate a list of rooted objects, for example if the\n+borrow occurred inside the body of a loop but the scope of the borrow\n+extended outside the loop. More formally, the requirement is that\n+there is no path starting from the borrow that leads back to the\n+borrow without crossing the exit from the scope `LT`.\n+\n+The rule for compiler rooting is as follows:\n+\n+    LIFETIME(*LV, LT, MQ)               // L-Deref-Managed-Imm-Compiler-Root\n+      TYPE(LV) = @Ty\n+      LT <= innermost enclosing loop/func\n+      ROOT LV at *LV for LT\n+\n+Here I have written `ROOT LV at *LV FOR LT` to indicate that the code\n+makes a note in a side-table that the box `LV` must be rooted into the\n+stack when `*LV` is evaluated, and that this root can be released when\n+the scope `LT` exits.\n+\n+## Checking lifetime for derefs of managed, mutable pointers\n+\n+Loans of the contents of mutable managed pointers are simpler in some\n+ways that loans of immutable managed pointers, because we can never\n+rely on the user to root them (since the contents are, after all,\n+mutable). This means that the burden always falls to the compiler, so\n+there is only one rule:\n+\n+    LIFETIME(*LV, LT, MQ)              // L-Deref-Managed-Mut-Compiler-Root\n+      TYPE(LV) = @mut Ty\n+      LT <= innermost enclosing loop/func\n+      ROOT LV at *LV for LT\n+      LOCK LV at *LV as MQ for LT\n+\n+Note that there is an additional clause this time `LOCK LV at *LV as\n+MQ for LT`.  This clause states that in addition to rooting `LV`, the\n+compiler should also \"lock\" the box dynamically, meaning that we\n+register that the box has been borrowed as mutable or immutable,\n+depending on `MQ`. This lock will fail if the box has already been\n+borrowed and either the old loan or the new loan is a mutable loan\n+(multiple immutable loans are okay). The lock is released as we exit\n+the scope `LT`.\n+\n+# Computing the restrictions\n+\n+The final rules govern the computation of *restrictions*, meaning that\n+we compute the set of actions that will be illegal for the life of the\n+loan. The predicate is written `RESTRICTIONS(LV, ACTIONS) =\n+RESTRICTION*`, which can be read \"in order to prevent `ACTIONS` from\n+occuring on `LV`, the restrictions `RESTRICTION*` must be respected\n+for the lifetime of the loan\".\n+\n+Note that there is an initial set of restrictions: these restrictions\n+are computed based on the kind of borrow:\n+\n+    &mut LV =>   RESTRICTIONS(LV, MUTATE|CLAIM|FREEZE)\n+    &LV =>       RESTRICTIONS(LV, MUTATE|CLAIM)\n+    &const LV => RESTRICTIONS(LV, [])\n+\n+The reasoning here is that a mutable borrow must be the only writer,\n+therefore it prevents other writes (`MUTATE`), mutable borrows\n+(`CLAIM`), and immutable borrows (`FREEZE`). An immutable borrow\n+permits other immutable borows but forbids writes and mutable borows.\n+Finally, a const borrow just wants to be sure that the value is not\n+moved out from under it, so no actions are forbidden.\n+\n+## Restrictions for loans of a local variable\n+\n+The simplest case is a borrow of a local variable `X`:\n+\n+    RESTRICTIONS(X, ACTIONS) = (X, ACTIONS)            // R-Variable\n+\n+In such cases we just record the actions that are not permitted.\n+\n+## Restrictions for loans of fields\n+\n+Restricting a field is the same as restricting the owner of that\n+field:\n+\n+    RESTRICTIONS(LV.f, ACTIONS) = RS, (LV.f, ACTIONS)  // R-Field\n+      RESTRICTIONS(LV, ACTIONS) = RS\n+\n+The reasoning here is as follows. If the field must not be mutated,\n+then you must not mutate the owner of the field either, since that\n+would indirectly modify the field. Similarly, if the field cannot be\n+frozen or aliased, we cannot allow the owner to be frozen or aliased,\n+since doing so indirectly freezes/aliases the field. This is the\n+origin of inherited mutability.\n+\n+## Restrictions for loans of owned pointees\n+\n+Because the mutability of owned pointees is inherited, restricting an\n+owned pointee is similar to restricting a field, in that it implies\n+restrictions on the pointer. However, owned pointers have an important\n+twist: if the owner `LV` is mutated, that causes the owned pointee\n+`*LV` to be freed! So whenever an owned pointee `*LV` is borrowed, we\n+must prevent the owned pointer `LV` from being mutated, which means\n+that we always add `MUTATE` and `CLAIM` to the restriction set imposed\n+on `LV`:\n+\n+    RESTRICTIONS(*LV, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Owned-Pointer\n+      TYPE(LV) = ~Ty\n+      RESTRICTIONS(LV, ACTIONS|MUTATE|CLAIM) = RS\n+\n+## Restrictions for loans of immutable managed/borrowed pointees\n+\n+Immutable managed/borrowed pointees are freely aliasable, meaning that\n+the compiler does not prevent you from copying the pointer.  This\n+implies that issuing restrictions is useless. We might prevent the\n+user from acting on `*LV` itself, but there could be another path\n+`*LV1` that refers to the exact same memory, and we would not be\n+restricting that path. Therefore, the rule for `&Ty` and `@Ty`\n+pointers always returns an empty set of restrictions, and it only\n+permits restricting `MUTATE` and `CLAIM` actions:\n+\n+    RESTRICTIONS(*LV, ACTIONS) = []                    // R-Deref-Imm-Borrowed\n+      TYPE(LV) = &Ty or @Ty\n+      ACTIONS subset of [MUTATE, CLAIM]\n+\n+The reason that we can restrict `MUTATE` and `CLAIM` actions even\n+without a restrictions list is that it is never legal to mutate nor to\n+borrow mutably the contents of a `&Ty` or `@Ty` pointer. In other\n+words, those restrictions are already inherent in the type.\n+\n+Typically, this limitation is not an issue, because restrictions other\n+than `MUTATE` or `CLAIM` typically arise due to `&mut` borrow, and as\n+we said, that is already illegal for `*LV`. However, there is one case\n+where we can be asked to enforce an `ALIAS` restriction on `*LV`,\n+which is when you have a type like `&&mut T`. In such cases we will\n+report an error because we cannot enforce a lack of aliases on a `&Ty`\n+or `@Ty` type. That case is described in more detail in the section on\n+mutable borrowed pointers.\n+\n+## Restrictions for loans of const aliasable pointees\n+\n+Const pointers are read-only. There may be `&mut` or `&` aliases, and\n+we can not prevent *anything* but moves in that case. So the\n+`RESTRICTIONS` function is only defined if `ACTIONS` is the empty set.\n+Because moves from a `&const` or `@const` lvalue are never legal, it\n+is not necessary to add any restrictions at all to the final\n+result.\n+\n+    RESTRICTIONS(*LV, []) = []                         // R-Deref-Const-Borrowed\n+      TYPE(LV) = &const Ty or @const Ty\n+\n+## Restrictions for loans of mutable borrowed pointees\n+\n+Borrowing mutable borrowed pointees is a bit subtle because we permit\n+users to freeze or claim `&mut` pointees. To see what I mean, consider this\n+(perfectly safe) code example:\n+\n+    fn foo(t0: &mut T, op: fn(&T)) {\n+        let t1: &T = &*t0; // (1)\n+        op(t1);\n+    }\n+\n+In the borrow marked `(1)`, the data at `*t0` is *frozen* as part of a\n+re-borrow. Therefore, for the lifetime of `t1`, `*t0` must not be\n+mutated. This is the same basic idea as when we freeze a mutable local\n+variable, but unlike in that case `t0` is a *pointer* to the data, and\n+thus we must enforce some subtle restrictions in order to guarantee\n+soundness.\n+\n+Intuitively, we must ensure that `*t0` is the only *mutable* path to\n+reach the memory that was frozen. The reason that we are so concerned\n+with *mutable* paths is that those are the paths through which the\n+user could mutate the data that was frozen and hence invalidate the\n+`t1` pointer. Note that const aliases to `*t0` are acceptable (and in\n+fact we can't prevent them without unacceptable performance cost, more\n+on that later) because\n+\n+There are two rules governing `&mut` pointers, but we'll begin with\n+the first. This rule governs cases where we are attempting to prevent\n+an `&mut` pointee from being mutated, claimed, or frozen, as occurs\n+whenever the `&mut` pointee `*LV` is reborrowed as mutable or\n+immutable:\n+\n+    RESTRICTIONS(*LV, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Mut-Borrowed-1\n+      TYPE(LV) = &mut Ty\n+      RESTRICTIONS(LV, MUTATE|CLAIM|ALIAS) = RS\n+\n+The main interesting part of the rule is the final line, which\n+requires that the `&mut` *pointer* `LV` be restricted from being\n+mutated, claimed, or aliased. The goal of these restrictions is to\n+ensure that, not considering the pointer that will result from this\n+borrow, `LV` remains the *sole pointer with mutable access* to `*LV`.\n+\n+Restrictions against mutations and claims are necessary because if the\n+pointer in `LV` were to be somehow copied or moved to a different\n+location, then the restriction issued for `*LV` would not apply to the\n+new location. Consider this example, where `*t0` is frozen, but then\n+`t0` and `t1` are swapped, so by mutating `*t1` the user can mutate\n+the frozen memory that was originally found at `*t0`:\n+\n+    fn foo(t0: &mut T,\n+           t1: &mut T) {\n+        let p: &T = &*t0;     // Freezes `*t0`\n+        t0 <-> t1;\n+        *t1 = ...;            // Invalidates `p`\n+    }\n+\n+The restriction against *aliasing* (and, in turn, freezing) is\n+necessary because, if an alias were of `LV` were to be produced, then\n+`LV` would no longer be the sole path to access the `&mut`\n+pointee. Since we are only issuing restrictions against `*LV`, these\n+other aliases would be unrestricted, and the result would be\n+unsound. For example:\n+\n+    fn foo(t0: &mut T) {\n+        let p: &T = &*t0;     // Freezes *t0\n+        let q: &&mut T = &t0;\n+        **q = ...;            // Invalidates `p`\n+    }\n \n-In the case of our example, it would produce a set of loans like:\n+The second rule for `&mut` handles the case where we are not adding\n+any restrictions (beyond the default of \"no move\"):\n \n-    ((*x).f, 'a, Total, Const)\n-    (*x, 'a, Total, Const)\n-    (x, 'a, Total, Imm)\n+    RESTRICTIONS(*LV, []) = []                    // R-Deref-Mut-Borrowed-2\n+      TYPE(LV) = &mut Ty\n \n-The scope of these loans is `'a = LUB('a_arg2, 'a_call)`, and so they\n-encompass all subsequent arguments.  The first set of loans are Const\n-loans, which basically just prevent moves.  However, when we cross\n-over the dereference of the owned pointer `x`, the rule for ALIAS\n-specifies that `x` must be frozen, and hence the final loan is an Imm\n-loan.  In any case the troublesome second argument would be flagged\n-as an error.\n+Moving from an `&mut` pointee is never legal, so no special\n+restrictions are needed.\n \n-# Maps that are created\n+## Restrictions for loans of mutable managed pointees\n \n-Borrowck results in two maps.\n+With `@mut` pointees, we don't make any static guarantees.  But as a\n+convenience, we still register a restriction against `*LV`, because\n+that way if we *can* find a simple static error, we will:\n \n-- `root_map`: identifies those expressions or patterns whose result\n-  needs to be rooted. Conceptually the root_map maps from an\n-  expression or pattern node to a `node_id` identifying the scope for\n-  which the expression must be rooted (this `node_id` should identify\n-  a block or call). The actual key to the map is not an expression id,\n-  however, but a `root_map_key`, which combines an expression id with a\n-  deref count and is used to cope with auto-deref.\n+    RESTRICTIONS(*LV, ACTIONS) = [*LV, ACTIONS]   // R-Deref-Managed-Borrowed\n+      TYPE(LV) = @mut Ty\n \n */"}, {"sha": "9455340268eff0a6c50d9ea234bd674546d149b0", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/329f7a17e2162807d62b5f1f4c3d97da1317d192/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329f7a17e2162807d62b5f1f4c3d97da1317d192/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=329f7a17e2162807d62b5f1f4c3d97da1317d192", "patch": "@@ -70,11 +70,11 @@ impl GuaranteeLifetimeContext {\n         match cmt.cat {\n             mc::cat_rvalue |\n             mc::cat_implicit_self |\n-            mc::cat_copied_upvar(*) |\n-            mc::cat_local(*) |\n-            mc::cat_arg(*) |\n-            mc::cat_self(*) |\n-            mc::cat_deref(_, _, mc::region_ptr(*)) |\n+            mc::cat_copied_upvar(*) |                  // L-Local\n+            mc::cat_local(*) |                         // L-Local\n+            mc::cat_arg(*) |                           // L-Local\n+            mc::cat_self(*) |                          // L-Local\n+            mc::cat_deref(_, _, mc::region_ptr(*)) |   // L-Deref-Borrowed\n             mc::cat_deref(_, _, mc::unsafe_ptr) => {\n                 let scope = self.scope(cmt);\n                 self.check_scope(scope)\n@@ -90,7 +90,7 @@ impl GuaranteeLifetimeContext {\n             mc::cat_deref(base, derefs, mc::gc_ptr(ptr_mutbl)) => {\n                 let base_scope = self.scope(base);\n \n-                // See rule Freeze-Imm-Managed-Ptr-2 in doc.rs\n+                // L-Deref-Managed-Imm-User-Root\n                 let omit_root = (\n                     ptr_mutbl == m_imm &&\n                     self.bccx.is_subregion_of(self.loan_region, base_scope) &&\n@@ -99,6 +99,8 @@ impl GuaranteeLifetimeContext {\n                 );\n \n                 if !omit_root {\n+                    // L-Deref-Managed-Imm-Compiler-Root\n+                    // L-Deref-Managed-Mut-Compiler-Root\n                     self.check_root(cmt, base, derefs, ptr_mutbl, discr_scope);\n                 } else {\n                     debug!(\"omitting root, base=%s, base_scope=%?\",\n@@ -107,8 +109,8 @@ impl GuaranteeLifetimeContext {\n             }\n \n             mc::cat_downcast(base) |\n-            mc::cat_deref(base, _, mc::uniq_ptr(*)) |\n-            mc::cat_interior(base, _) => {\n+            mc::cat_deref(base, _, mc::uniq_ptr(*)) |  // L-Deref-Owned\n+            mc::cat_interior(base, _) => {             // L-Field\n                 self.check(base, discr_scope)\n             }\n \n@@ -321,6 +323,8 @@ impl GuaranteeLifetimeContext {\n         //! lvalue `cmt` is guaranteed to be valid without any\n         //! rooting etc, and presuming `cmt` is not mutated.\n \n+        // See the SCOPE(LV) function in doc.rs\n+\n         match cmt.cat {\n             mc::cat_rvalue => {\n                 ty::re_scope(self.bccx.tcx.region_maps.cleanup_scope(cmt.id))"}, {"sha": "f733d57573c1a2958ca638669d5e0f9365af21d1", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329f7a17e2162807d62b5f1f4c3d97da1317d192/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329f7a17e2162807d62b5f1f4c3d97da1317d192/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=329f7a17e2162807d62b5f1f4c3d97da1317d192", "patch": "@@ -481,6 +481,8 @@ pub impl GatherLoanCtxt {\n                             borrow_span: span,\n                             cmt: mc::cmt,\n                             req_mutbl: ast::mutability) {\n+            //! Implements the M-* rules in doc.rs.\n+\n             match req_mutbl {\n                 m_const => {\n                     // Data of any mutability can be lent as const."}, {"sha": "bf054b72ecf2127491b9ed339bd3b18195e036bf", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/329f7a17e2162807d62b5f1f4c3d97da1317d192/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329f7a17e2162807d62b5f1f4c3d97da1317d192/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=329f7a17e2162807d62b5f1f4c3d97da1317d192", "patch": "@@ -76,6 +76,7 @@ impl RestrictionsContext {\n             mc::cat_local(local_id) |\n             mc::cat_arg(local_id) |\n             mc::cat_self(local_id) => {\n+                // R-Variable\n                 let lp = @LpVar(local_id);\n                 SafeIf(lp, ~[Restriction {loan_path: lp,\n                                           set: restrictions}])\n@@ -89,6 +90,8 @@ impl RestrictionsContext {\n             }\n \n             mc::cat_interior(cmt_base, i) => {\n+                // R-Field\n+                //\n                 // Overwriting the base would not change the type of\n                 // the memory, so no additional restrictions are\n                 // needed.\n@@ -97,6 +100,8 @@ impl RestrictionsContext {\n             }\n \n             mc::cat_deref(cmt_base, _, mc::uniq_ptr(*)) => {\n+                // R-Deref-Owned-Pointer\n+                //\n                 // When we borrow the interior of an owned pointer, we\n                 // cannot permit the base to be mutated, because that\n                 // would cause the unique pointer to be freed.\n@@ -109,16 +114,20 @@ impl RestrictionsContext {\n             mc::cat_implicit_self(*) |\n             mc::cat_deref(_, _, mc::region_ptr(m_imm, _)) |\n             mc::cat_deref(_, _, mc::gc_ptr(m_imm)) => {\n+                // R-Deref-Imm-Borrowed\n                 Safe\n             }\n \n             mc::cat_deref(_, _, mc::region_ptr(m_const, _)) |\n             mc::cat_deref(_, _, mc::gc_ptr(m_const)) => {\n+                // R-Deref-Const-Borrowed\n                 self.check_no_mutability_control(cmt, restrictions);\n                 Safe\n             }\n \n             mc::cat_deref(cmt_base, _, mc::gc_ptr(m_mutbl)) => {\n+                // R-Deref-Managed-Borrowed\n+                //\n                 // Technically, no restrictions are *necessary* here.\n                 // The validity of the borrow is guaranteed\n                 // dynamically.  However, nonetheless we add a\n@@ -170,9 +179,11 @@ impl RestrictionsContext {\n                 // freezing if it is not aliased. Therefore, in such\n                 // cases we restrict aliasing on `cmt_base`.\n                 if restrictions.intersects(RESTR_MUTATE | RESTR_FREEZE) {\n+                    // R-Deref-Mut-Borrowed-1\n                     let result = self.compute(cmt_base, restrictions | RESTR_ALIAS);\n                     self.extend(result, cmt.mutbl, LpDeref, restrictions)\n                 } else {\n+                    // R-Deref-Mut-Borrowed-2\n                     let result = self.compute(cmt_base, restrictions);\n                     self.extend(result, cmt.mutbl, LpDeref, restrictions)\n                 }"}]}