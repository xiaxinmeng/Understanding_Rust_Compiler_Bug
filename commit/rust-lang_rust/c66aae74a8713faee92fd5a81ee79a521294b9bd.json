{"sha": "c66aae74a8713faee92fd5a81ee79a521294b9bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2NmFhZTc0YTg3MTNmYWVlOTJmZDVhODFlZTc5YTUyMTI5NGI5YmQ=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2016-02-14T21:17:11Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2016-02-14T21:17:11Z"}, "message": "Merge pull request #820 from rust-lang-nursery/patterns\n\nFormat all patterns (well, except macros)", "tree": {"sha": "5f11bb5b1f22e991c25885235cca6a9ba3fbd480", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f11bb5b1f22e991c25885235cca6a9ba3fbd480"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c66aae74a8713faee92fd5a81ee79a521294b9bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c66aae74a8713faee92fd5a81ee79a521294b9bd", "html_url": "https://github.com/rust-lang/rust/commit/c66aae74a8713faee92fd5a81ee79a521294b9bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c66aae74a8713faee92fd5a81ee79a521294b9bd/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c906b656e61d0413cd411dcb6dbe8a4222bf3ab3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c906b656e61d0413cd411dcb6dbe8a4222bf3ab3", "html_url": "https://github.com/rust-lang/rust/commit/c906b656e61d0413cd411dcb6dbe8a4222bf3ab3"}, {"sha": "160eb73baab57cbe0dbb221f5220fc4475ccd1da", "url": "https://api.github.com/repos/rust-lang/rust/commits/160eb73baab57cbe0dbb221f5220fc4475ccd1da", "html_url": "https://github.com/rust-lang/rust/commit/160eb73baab57cbe0dbb221f5220fc4475ccd1da"}], "stats": {"total": 204, "additions": 165, "deletions": 39}, "files": [{"sha": "70351ca8d792ed10b368662affda1ae17820314d", "filename": "src/imports.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c66aae74a8713faee92fd5a81ee79a521294b9bd/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66aae74a8713faee92fd5a81ee79a521294b9bd/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=c66aae74a8713faee92fd5a81ee79a521294b9bd", "patch": "@@ -51,7 +51,7 @@ impl Rewrite for ast::ViewPath {\n }\n \n fn rewrite_single_use_list(path_str: String, vpi: &ast::PathListItem) -> String {\n-    let path_item_str = if let ast::PathListItem_::PathListIdent{ name, .. } = vpi.node {\n+    let path_item_str = if let ast::PathListItem_::PathListIdent { name, .. } = vpi.node {\n         // A name.\n         if path_str.is_empty() {\n             name.to_string()\n@@ -74,17 +74,17 @@ fn rewrite_single_use_list(path_str: String, vpi: &ast::PathListItem) -> String\n \n fn rewrite_path_item(vpi: &&ast::PathListItem) -> Option<String> {\n     let path_item_str = match vpi.node {\n-        ast::PathListItem_::PathListIdent{ name, .. } => name.to_string(),\n-        ast::PathListItem_::PathListMod{ .. } => \"self\".to_owned(),\n+        ast::PathListItem_::PathListIdent { name, .. } => name.to_string(),\n+        ast::PathListItem_::PathListMod { .. } => \"self\".to_owned(),\n     };\n \n     Some(append_alias(path_item_str, vpi))\n }\n \n fn append_alias(path_item_str: String, vpi: &ast::PathListItem) -> String {\n     match vpi.node {\n-        ast::PathListItem_::PathListIdent{ rename: Some(rename), .. } |\n-        ast::PathListItem_::PathListMod{ rename: Some(rename), .. } => {\n+        ast::PathListItem_::PathListIdent { rename: Some(rename), .. } |\n+        ast::PathListItem_::PathListMod { rename: Some(rename), .. } => {\n             format!(\"{} as {}\", path_item_str, rename)\n         }\n         _ => path_item_str,"}, {"sha": "a5f0982321220275c061b408ad2397bdcd718d6c", "filename": "src/patterns.rs", "status": "modified", "additions": 126, "deletions": 33, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/c66aae74a8713faee92fd5a81ee79a521294b9bd/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66aae74a8713faee92fd5a81ee79a521294b9bd/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=c66aae74a8713faee92fd5a81ee79a521294b9bd", "patch": "@@ -15,20 +15,32 @@ use lists::{format_item_list, itemize_list};\n use expr::{rewrite_unary_prefix, rewrite_pair, rewrite_tuple};\n use types::rewrite_path;\n \n-use syntax::ast::{BindingMode, Pat, Pat_};\n+use syntax::ast::{BindingMode, Pat, Pat_, FieldPat};\n \n-// FIXME(#18): implement pattern formatting.\n impl Rewrite for Pat {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         match self.node {\n             Pat_::PatBox(ref pat) => rewrite_unary_prefix(context, \"box \", &**pat, width, offset),\n-            Pat_::PatIdent(binding_mode, ident, None) => {\n+            Pat_::PatIdent(binding_mode, ident, ref sub_pat) => {\n                 let (prefix, mutability) = match binding_mode {\n                     BindingMode::BindByRef(mutability) => (\"ref \", mutability),\n                     BindingMode::BindByValue(mutability) => (\"\", mutability),\n                 };\n                 let mut_infix = format_mutability(mutability);\n-                let result = format!(\"{}{}{}\", prefix, mut_infix, ident.node);\n+                let id_str = ident.node.to_string();\n+\n+                let sub_pat = match *sub_pat {\n+                    Some(ref p) => {\n+                        // 3 - ` @ `.\n+                        let width = try_opt!(width.checked_sub(prefix.len() + mut_infix.len() +\n+                                                               id_str.len() +\n+                                                               3));\n+                        format!(\" @ {}\", try_opt!(p.rewrite(context, width, offset)))\n+                    }\n+                    None => \"\".to_owned(),\n+                };\n+\n+                let result = format!(\"{}{}{}{}\", prefix, mut_infix, id_str, sub_pat);\n                 wrap_str(result, context.config.max_width, width, offset)\n             }\n             Pat_::PatWild => {\n@@ -55,39 +67,106 @@ impl Rewrite for Pat {\n                               width,\n                               offset)\n             }\n-            Pat_::PatEnum(ref path, Some(ref pat_vec)) => {\n-                let path_str = try_opt!(::types::rewrite_path(context,\n-                                                              true,\n-                                                              None,\n-                                                              path,\n-                                                              width,\n-                                                              offset));\n+            Pat_::PatEnum(ref path, ref pat_vec) => {\n+                let path_str = try_opt!(rewrite_path(context, true, None, path, width, offset));\n \n-                if pat_vec.is_empty() {\n-                    Some(path_str)\n-                } else {\n-                    // 1 = (\n-                    let width = try_opt!(width.checked_sub(path_str.len() + 1));\n-                    let offset = offset + path_str.len() + 1;\n-                    let items = itemize_list(context.codemap,\n-                                             pat_vec.iter(),\n-                                             \")\",\n-                                             |item| item.span.lo,\n-                                             |item| item.span.hi,\n-                                             |item| item.rewrite(context, width, offset),\n-                                             span_after(self.span, \"(\", context.codemap),\n-                                             self.span.hi);\n-                    Some(format!(\"{}({})\",\n-                                 path_str,\n-                                 try_opt!(format_item_list(items, width, offset, context.config))))\n+                match *pat_vec {\n+                    Some(ref pat_vec) => {\n+                        if pat_vec.is_empty() {\n+                            Some(path_str)\n+                        } else {\n+                            // 1 = (\n+                            let width = try_opt!(width.checked_sub(path_str.len() + 1));\n+                            let offset = offset + path_str.len() + 1;\n+                            let items = itemize_list(context.codemap,\n+                                                     pat_vec.iter(),\n+                                                     \")\",\n+                                                     |item| item.span.lo,\n+                                                     |item| item.span.hi,\n+                                                     |item| item.rewrite(context, width, offset),\n+                                                     span_after(self.span, \"(\", context.codemap),\n+                                                     self.span.hi);\n+                            Some(format!(\"{}({})\",\n+                                         path_str,\n+                                         try_opt!(format_item_list(items,\n+                                                                   width,\n+                                                                   offset,\n+                                                                   context.config))))\n+                        }\n+                    }\n+                    None => Some(format!(\"{}(..)\", path_str)),\n                 }\n             }\n             Pat_::PatLit(ref expr) => expr.rewrite(context, width, offset),\n-            // FIXME(#8): format remaining pattern variants.\n-            Pat_::PatIdent(_, _, Some(..)) |\n-            Pat_::PatEnum(_, None) |\n-            Pat_::PatStruct(..) |\n-            Pat_::PatVec(..) |\n+            Pat_::PatVec(ref prefix, ref slice_pat, ref suffix) => {\n+                // Rewrite all the sub-patterns.\n+                let prefix = prefix.iter().map(|p| p.rewrite(context, width, offset));\n+                let slice_pat = slice_pat.as_ref().map(|p| {\n+                    Some(format!(\"{}..\", try_opt!(p.rewrite(context, width, offset))))\n+                });\n+                let suffix = suffix.iter().map(|p| p.rewrite(context, width, offset));\n+\n+                // Munge them together.\n+                let pats: Option<Vec<String>> = prefix.chain(slice_pat.into_iter())\n+                                                      .chain(suffix)\n+                                                      .collect();\n+\n+                // Check that all the rewrites succeeded, and if not return None.\n+                let pats = try_opt!(pats);\n+\n+                // Unwrap all the sub-strings and join them with commas.\n+                let result = format!(\"[{}]\", pats.join(\", \"));\n+                wrap_str(result, context.config.max_width, width, offset)\n+            }\n+            Pat_::PatStruct(ref path, ref fields, elipses) => {\n+                let path = try_opt!(rewrite_path(context, true, None, path, width, offset));\n+\n+                let (elipses_str, terminator) = if elipses {\n+                    (\", ..\", \"..\")\n+                } else {\n+                    (\"\", \"}\")\n+                };\n+\n+                // 5 = `{` plus space before and after plus `}` plus space before.\n+                let budget = try_opt!(width.checked_sub(path.len() + 5 + elipses_str.len()));\n+                // FIXME Using visual indenting, should use block or visual to match\n+                // struct lit preference (however, in practice I think it is rare\n+                // for struct patterns to be multi-line).\n+                // 3 = `{` plus space before and after.\n+                let offset = offset + path.len() + 3;\n+\n+                let items = itemize_list(context.codemap,\n+                                         fields.iter(),\n+                                         terminator,\n+                                         |f| f.span.lo,\n+                                         |f| f.span.hi,\n+                                         |f| f.node.rewrite(context, budget, offset),\n+                                         span_after(self.span, \"{\", context.codemap),\n+                                         self.span.hi);\n+                let mut field_string = try_opt!(format_item_list(items,\n+                                                                 budget,\n+                                                                 offset,\n+                                                                 context.config));\n+                if elipses {\n+                    if field_string.contains('\\n') {\n+                        field_string.push_str(\",\\n\");\n+                        field_string.push_str(&offset.to_string(context.config));\n+                        field_string.push_str(\"..\");\n+                    } else {\n+                        if field_string.len() > 0 {\n+                            field_string.push_str(\", \");\n+                        }\n+                        field_string.push_str(\"..\");\n+                    }\n+                }\n+\n+                if field_string.is_empty() {\n+                    Some(format!(\"{} {{}}\", path))\n+                } else {\n+                    Some(format!(\"{} {{ {} }}\", path, field_string))\n+                }\n+            }\n+            // FIXME(#819) format pattern macros.\n             Pat_::PatMac(..) => {\n                 wrap_str(context.snippet(self.span),\n                          context.config.max_width,\n@@ -97,3 +176,17 @@ impl Rewrite for Pat {\n         }\n     }\n }\n+\n+impl Rewrite for FieldPat {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n+        let pat = self.pat.rewrite(context, width, offset);\n+        if self.is_shorthand {\n+            pat\n+        } else {\n+            wrap_str(format!(\"{}: {}\", self.ident.to_string(), try_opt!(pat)),\n+                     context.config.max_width,\n+                     width,\n+                     offset)\n+        }\n+    }\n+}"}, {"sha": "75f65806167b5aee82b2be66b129bae93b6c49a0", "filename": "tests/source/pattern.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c66aae74a8713faee92fd5a81ee79a521294b9bd/tests%2Fsource%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66aae74a8713faee92fd5a81ee79a521294b9bd/tests%2Fsource%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fpattern.rs?ref=c66aae74a8713faee92fd5a81ee79a521294b9bd", "patch": "@@ -11,6 +11,20 @@ fn main() {\n     let Some ( ref   xyz  /*   comment!   */) = opt;\n \n     if let  None  =   opt2 { panic!(\"oh noes\"); }\n+\n+    let foo@bar (f) = 42;\n+    let a::foo ( ..) = 42;\n+    let [ ] = 42;\n+    let [a..,     b,c ] = 42;\n+    let [ a,b,c.. ] = 42;\n+    let [a,    b, c, d..,e,f,     g] = 42;\n+    let foo {   } = 42;\n+    let foo {..} = 42;\n+    let foo { x, y: ref foo,     .. } = 42;\n+    let foo { x, yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy: ref foo,     .. } = 42;\n+    let foo { x,       yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy: ref foo,      } = 42;\n+    let foo { x, yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy: ref foo,     .. };\n+    let foo { x,       yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy: ref foo,      };\n }\n \n impl<'a,'b> ResolveGeneratedContentFragmentMutator<'a,'b> {"}, {"sha": "bc5298ae22db1de3744e55b0fad6545c38540754", "filename": "tests/system.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c66aae74a8713faee92fd5a81ee79a521294b9bd/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66aae74a8713faee92fd5a81ee79a521294b9bd/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=c66aae74a8713faee92fd5a81ee79a521294b9bd", "patch": "@@ -287,6 +287,8 @@ fn handle_result(result: HashMap<String, String>,\n \n         if fmt_text != text {\n             let diff = make_diff(&text, &fmt_text, DIFF_CONTEXT_SIZE);\n+            assert!(!diff.is_empty(),\n+                    \"Empty diff? Maybe due to a missing a newline at the end of a file?\");\n             failures.insert(file_name, diff);\n         }\n     }"}, {"sha": "defcc13ef51adacbaefff2e558ba522bffc331b8", "filename": "tests/target/match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c66aae74a8713faee92fd5a81ee79a521294b9bd/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66aae74a8713faee92fd5a81ee79a521294b9bd/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=c66aae74a8713faee92fd5a81ee79a521294b9bd", "patch": "@@ -251,7 +251,7 @@ fn issue280() {\n \n fn issue383() {\n     match resolution.last_private {\n-        LastImport{..} => false,\n+        LastImport { .. } => false,\n         _ => true,\n     };\n }"}, {"sha": "d77cb59f4984738b7d8b1b4147424b8e9582a308", "filename": "tests/target/pattern.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c66aae74a8713faee92fd5a81ee79a521294b9bd/tests%2Ftarget%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66aae74a8713faee92fd5a81ee79a521294b9bd/tests%2Ftarget%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fpattern.rs?ref=c66aae74a8713faee92fd5a81ee79a521294b9bd", "patch": "@@ -13,6 +13,23 @@ fn main() {\n     if let None = opt2 {\n         panic!(\"oh noes\");\n     }\n+\n+    let foo @ bar(f) = 42;\n+    let a::foo(..) = 42;\n+    let [] = 42;\n+    let [a.., b, c] = 42;\n+    let [a, b, c..] = 42;\n+    let [a, b, c, d.., e, f, g] = 42;\n+    let foo {} = 42;\n+    let foo { .. } = 42;\n+    let foo { x, y: ref foo, .. } = 42;\n+    let foo { x, yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy: ref foo, .. } = 42;\n+    let foo { x, yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy: ref foo } = 42;\n+    let foo { x,\n+              yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy: ref foo,\n+              .. };\n+    let foo { x,\n+              yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy: ref foo };\n }\n \n impl<'a, 'b> ResolveGeneratedContentFragmentMutator<'a, 'b> {"}]}