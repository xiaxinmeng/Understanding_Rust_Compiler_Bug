{"sha": "8800413f52f427d41da193f7139e8d1a5038c836", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4MDA0MTNmNTJmNDI3ZDQxZGExOTNmNzEzOWU4ZDFhNTAzOGM4MzY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-26T23:09:22Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-27T15:50:50Z"}, "message": "wip: add a sendable hashmap to stdlib\n\ncaveats:\n- not efficient nor heavily tested\n- API subject to change and currently incompatible with map", "tree": {"sha": "5b5f0843dc2a70bd64cc4b01ff063d1b2967d9bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b5f0843dc2a70bd64cc4b01ff063d1b2967d9bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8800413f52f427d41da193f7139e8d1a5038c836", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8800413f52f427d41da193f7139e8d1a5038c836", "html_url": "https://github.com/rust-lang/rust/commit/8800413f52f427d41da193f7139e8d1a5038c836", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8800413f52f427d41da193f7139e8d1a5038c836/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97d59a8ade04bec36ad99a5649d91fd8a97e7d30", "url": "https://api.github.com/repos/rust-lang/rust/commits/97d59a8ade04bec36ad99a5649d91fd8a97e7d30", "html_url": "https://github.com/rust-lang/rust/commit/97d59a8ade04bec36ad99a5649d91fd8a97e7d30"}], "stats": {"total": 346, "additions": 346, "deletions": 0}, "files": [{"sha": "90d99adad89656dbc1000df1f7c548cca105d76c", "filename": "src/libstd/send_map.rs", "status": "added", "additions": 345, "deletions": 0, "changes": 345, "blob_url": "https://github.com/rust-lang/rust/blob/8800413f52f427d41da193f7139e8d1a5038c836/src%2Flibstd%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8800413f52f427d41da193f7139e8d1a5038c836/src%2Flibstd%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsend_map.rs?ref=8800413f52f427d41da193f7139e8d1a5038c836", "patch": "@@ -0,0 +1,345 @@\n+/*!\n+\n+Sendable hash maps.  Very much a work in progress.\n+\n+*/\n+\n+\n+/**\n+ * A function that returns a hash of a value\n+ *\n+ * The hash should concentrate entropy in the lower bits.\n+ */\n+type hashfn<K> = pure fn~(K) -> uint;\n+type eqfn<K> = pure fn~(K, K) -> bool;\n+\n+/// Open addressing with linear probing.\n+mod linear {\n+    export linear_map, linear_map_with_capacity;\n+\n+    const initial_capacity: uint = 32u; // 2^5\n+    type bucket<K,V> = {hash: uint, key: K, value: V};\n+    enum linear_map<K,V> {\n+        linear_map_({\n+            hashfn: pure fn~(x: &K) -> uint,\n+            eqfn: pure fn~(x: &K, y: &K) -> bool,\n+            resize_at: uint,\n+            size: uint,\n+            buckets: ~[option<bucket<K,V>>]})\n+    }\n+\n+    // FIXME(#2979) -- with #2979 we could rewrite found_entry\n+    // to have type option<&bucket<K,V>> which would be nifty\n+    enum search_result {\n+        found_entry(uint), found_hole(uint), table_full\n+    }\n+\n+    fn resize_at(capacity: uint) -> uint {\n+        ((capacity as float) * 3. / 4.) as uint\n+    }\n+\n+    fn linear_map<K,V>(\n+        +hashfn: pure fn~(x: &K) -> uint,\n+        +eqfn: pure fn~(x: &K, y: &K) -> bool) -> linear_map<K,V> {\n+\n+        linear_map_with_capacity(hashfn, eqfn, 32)\n+    }\n+\n+    fn linear_map_with_capacity<K,V>(\n+        +hashfn: pure fn~(x: &K) -> uint,\n+        +eqfn: pure fn~(x: &K, y: &K) -> bool,\n+        initial_capacity: uint) -> linear_map<K,V> {\n+\n+        linear_map_({\n+            hashfn: hashfn,\n+            eqfn: eqfn,\n+            resize_at: resize_at(initial_capacity),\n+            size: 0,\n+            buckets: vec::from_fn(initial_capacity, |_i| none)})\n+    }\n+\n+    // FIXME(#2979) would allow us to use region type for k\n+    unsafe fn borrow<K>(&&k: K) -> &K {\n+        let p: *K = ptr::addr_of(k);\n+        p as &K\n+    }\n+\n+    impl private_const_methods<K,V> for &const linear_map<K,V> {\n+        #[inline(always)]\n+        pure fn to_bucket(h: uint) -> uint {\n+            // FIXME(#3041) borrow a more sophisticated technique here from\n+            // Gecko, for example borrowing from Knuth, as Eich so\n+            // colorfully argues for here:\n+            // https://bugzilla.mozilla.org/show_bug.cgi?id=743107#c22\n+            h % self.buckets.len()\n+        }\n+\n+        #[inline(always)]\n+        pure fn next_bucket(idx: uint, len_buckets: uint) -> uint {\n+            let n = (idx + 1) % len_buckets;\n+            unsafe{ // argh. log not considered pure.\n+                #debug[\"next_bucket(%?, %?) = %?\", idx, len_buckets, n];\n+            }\n+            ret n;\n+        }\n+\n+        #[inline(always)]\n+        pure fn bucket_sequence(hash: uint, op: fn(uint) -> bool) -> uint {\n+            let start_idx = self.to_bucket(hash);\n+            let len_buckets = self.buckets.len();\n+            let mut idx = start_idx;\n+            loop {\n+                if !op(idx) {\n+                    ret idx;\n+                }\n+                idx = self.next_bucket(idx, len_buckets);\n+                if idx == start_idx {\n+                    ret start_idx;\n+                }\n+            }\n+        }\n+\n+        #[inline(always)]\n+        pure fn bucket_for_key(\n+            buckets: &[option<bucket<K,V>>],\n+            k: &K) -> search_result {\n+\n+            let hash = self.hashfn(k);\n+            self.bucket_for_key_with_hash(buckets, hash, k)\n+        }\n+\n+        #[inline(always)]\n+        pure fn bucket_for_key_with_hash(\n+            buckets: &[option<bucket<K,V>>],\n+            hash: uint,\n+            k: &K) -> search_result {\n+\n+            let _ = for self.bucket_sequence(hash) |i| {\n+                alt buckets[i] {\n+                  some(bkt) {\n+                    if bkt.hash == hash && self.eqfn(k, &bkt.key) {\n+                        ret found_entry(i);\n+                    }\n+                  }\n+                  none => {\n+                    ret found_hole(i);\n+                  }\n+                }\n+            };\n+            ret table_full;\n+        }\n+    }\n+\n+    impl private_mut_methods<K,V> for &mut linear_map<K,V> {\n+        /// Expands the capacity of the array and re-inserts each\n+        /// of the existing buckets.\n+        fn expand() {\n+            let old_capacity = self.buckets.len();\n+            let new_capacity = old_capacity * 2;\n+            self.resize_at = ((new_capacity as float) * 3.0 / 4.0) as uint;\n+\n+            let mut old_buckets = vec::from_fn(new_capacity, |_i| none);\n+            self.buckets <-> old_buckets;\n+\n+            for uint::range(0, old_capacity) |i| {\n+                let mut bucket = none;\n+                bucket <-> old_buckets[i];\n+                if bucket.is_some() {\n+                    self.insert_bucket(bucket);\n+                }\n+            }\n+        }\n+\n+        fn insert_bucket(+bucket: option<bucket<K,V>>) {\n+            let {hash, key, value} <- option::unwrap(bucket);\n+            let _ = self.insert_internal(hash, key, value);\n+        }\n+\n+        /// Inserts the key value pair into the buckets.\n+        /// Assumes that there will be a bucket.\n+        /// True if there was no previous entry with that key\n+        fn insert_internal(hash: uint, +k: K, +v: V) -> bool {\n+            alt self.bucket_for_key_with_hash(self.buckets, hash,\n+                                              unsafe{borrow(k)}) {\n+              table_full => {fail ~\"Internal logic error\";}\n+              found_hole(idx) {\n+                #debug[\"insert fresh (%?->%?) at idx %?, hash %?\",\n+                       k, v, idx, hash];\n+                self.buckets[idx] = some({hash: hash, key: k, value: v});\n+                self.size += 1;\n+                ret true;\n+              }\n+              found_entry(idx) => {\n+                #debug[\"insert overwrite (%?->%?) at idx %?, hash %?\",\n+                       k, v, idx, hash];\n+                self.buckets[idx] = some({hash: hash, key: k, value: v});\n+                ret false;\n+              }\n+            }\n+        }\n+    }\n+\n+    impl mut_methods<K,V> for &mut linear_map<K,V> {\n+        fn insert(+k: K, +v: V) -> bool {\n+            if self.size >= self.resize_at {\n+                // n.b.: We could also do this after searching, so\n+                // that we do not resize if this call to insert is\n+                // simply going to update a key in place.  My sense\n+                // though is that it's worse to have to search through\n+                // buckets to find the right spot twice than to just\n+                // resize in this corner case.\n+                self.expand();\n+            }\n+\n+            let hash = self.hashfn(unsafe{borrow(k)});\n+            self.insert_internal(hash, k, v)\n+        }\n+\n+        fn remove(k: &K) -> bool {\n+            // Removing from an open-addressed hashtable\n+            // is, well, painful.  The problem is that\n+            // the entry may lie on the probe path for other\n+            // entries, so removing it would make you think that\n+            // those probe paths are empty.\n+            //\n+            // To address this we basically have to keep walking,\n+            // re-inserting entries we find until we reach an empty\n+            // bucket.  We know we will eventually reach one because\n+            // we insert one ourselves at the beginning (the removed\n+            // entry).\n+            //\n+            // I found this explanation elucidating:\n+            // http://www.maths.lse.ac.uk/Courses/MA407/del-hash.pdf\n+\n+            let mut idx = alt self.bucket_for_key(self.buckets, k) {\n+              table_full | found_hole(_) => {\n+                ret false;\n+              }\n+              found_entry(idx) => {\n+                idx\n+              }\n+            };\n+\n+            let len_buckets = self.buckets.len();\n+            self.buckets[idx] = none;\n+            idx = self.next_bucket(idx, len_buckets);\n+            while self.buckets[idx].is_some() {\n+                let mut bucket = none;\n+                bucket <-> self.buckets[idx];\n+                self.insert_bucket(bucket);\n+                idx = self.next_bucket(idx, len_buckets);\n+            }\n+            ret true;\n+        }\n+    }\n+\n+    impl private_imm_methods<K,V> for &linear_map<K,V> {\n+        fn search(hash: uint, op: fn(x: &option<bucket<K,V>>) -> bool) {\n+            let _ = self.bucket_sequence(hash, |i| op(&self.buckets[i]));\n+        }\n+    }\n+\n+    impl const_methods<K,V> for &const linear_map<K,V> {\n+        fn size() -> uint {\n+            self.size\n+        }\n+\n+        fn contains_key(k: &K) -> bool {\n+            alt self.bucket_for_key(self.buckets, k) {\n+              found_entry(_) => {true}\n+              table_full | found_hole(_) => {false}\n+            }\n+        }\n+    }\n+\n+    impl const_methods<K,V: copy> for &const linear_map<K,V> {\n+        fn find(k: &K) -> option<V> {\n+            alt self.bucket_for_key(self.buckets, k) {\n+              found_entry(idx) => {\n+                alt check self.buckets[idx] {\n+                  some(bkt) => {some(copy bkt.value)}\n+                }\n+              }\n+              table_full | found_hole(_) => {\n+                none\n+              }\n+            }\n+        }\n+\n+        fn get(k: &K) -> V {\n+            let value = self.find(k);\n+            if value.is_none() {\n+                fail #fmt[\"No entry found for key: %?\", k];\n+            }\n+            option::unwrap(value)\n+        }\n+\n+        fn [](k: &K) -> V {\n+            self.get(k)\n+        }\n+    }\n+\n+    /*\n+    FIXME --- #2979 must be fixed to typecheck this\n+    impl imm_methods<K,V> for &linear_map<K,V> {\n+        fn find_ptr(k: K) -> option<&V> {\n+            //XXX this should not type check as written, but it should\n+            //be *possible* to typecheck it...\n+            self.with_ptr(k, |v| v)\n+        }\n+    }\n+    */\n+}\n+\n+#[test]\n+mod test {\n+\n+    import linear::linear_map;\n+\n+    pure fn uint_hash(x: &uint) -> uint { *x }\n+    pure fn uint_eq(x: &uint, y: &uint) -> bool { *x == *y }\n+\n+    fn int_linear_map<V>() -> linear_map<uint,V> {\n+        ret linear_map(uint_hash, uint_eq);\n+    }\n+\n+    #[test]\n+    fn inserts() {\n+        let mut m = int_linear_map();\n+        assert (&mut m).insert(1, 2);\n+        assert (&mut m).insert(2, 4);\n+        assert (&m).get(&1) == 2;\n+        assert (&m).get(&2) == 4;\n+    }\n+\n+    #[test]\n+    fn overwrite() {\n+        let mut m = int_linear_map();\n+        assert (&mut m).insert(1, 2);\n+        assert (&m).get(&1) == 2;\n+        assert !(&mut m).insert(1, 3);\n+        assert (&m).get(&1) == 3;\n+    }\n+\n+    #[test]\n+    fn conflicts() {\n+        let mut m = linear::linear_map_with_capacity(uint_hash, uint_eq, 4);\n+        assert (&mut m).insert(1, 2);\n+        assert (&mut m).insert(5, 3);\n+        assert (&mut m).insert(9, 4);\n+        assert (&m).get(&9) == 4;\n+        assert (&m).get(&5) == 3;\n+        assert (&m).get(&1) == 2;\n+    }\n+\n+    #[test]\n+    fn conflict_remove() {\n+        let mut m = linear::linear_map_with_capacity(uint_hash, uint_eq, 4);\n+        assert (&mut m).insert(1, 2);\n+        assert (&mut m).insert(5, 3);\n+        assert (&mut m).insert(9, 4);\n+        assert (&mut m).remove(&1);\n+        assert (&m).get(&9) == 4;\n+        assert (&m).get(&5) == 3;\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "c1da4b0bd06630f4178e7a41a6d7f0593c6e4786", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8800413f52f427d41da193f7139e8d1a5038c836/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/8800413f52f427d41da193f7139e8d1a5038c836/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=8800413f52f427d41da193f7139e8d1a5038c836", "patch": "@@ -58,6 +58,7 @@ mod deque;\n mod fun_treemap;\n mod list;\n mod map;\n+mod send_map;\n mod rope;\n mod smallintmap;\n mod sort;"}]}