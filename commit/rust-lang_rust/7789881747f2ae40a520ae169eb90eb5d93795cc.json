{"sha": "7789881747f2ae40a520ae169eb90eb5d93795cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3ODk4ODE3NDdmMmFlNDBhNTIwYWUxNjllYjkwZWI1ZDkzNzk1Y2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-13T23:56:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-13T23:56:11Z"}, "message": "Auto merge of #39030 - GuillaumeGomez:rollup, r=GuillaumeGomez\n\nRollup of 10 pull requests\n\n- Successful merges: #38362, #38636, #38877, #38946, #38965, #38986, #38994, #38995, #39024, #39027\n- Failed merges:", "tree": {"sha": "23a0869fa4113ddad3d0003b3e68d8a7bda30503", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23a0869fa4113ddad3d0003b3e68d8a7bda30503"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7789881747f2ae40a520ae169eb90eb5d93795cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7789881747f2ae40a520ae169eb90eb5d93795cc", "html_url": "https://github.com/rust-lang/rust/commit/7789881747f2ae40a520ae169eb90eb5d93795cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7789881747f2ae40a520ae169eb90eb5d93795cc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8780962828858c5b858b847430514505497a2b5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8780962828858c5b858b847430514505497a2b5c", "html_url": "https://github.com/rust-lang/rust/commit/8780962828858c5b858b847430514505497a2b5c"}, {"sha": "a861eb0aac22dc149fdace5d6e095160ae3efe01", "url": "https://api.github.com/repos/rust-lang/rust/commits/a861eb0aac22dc149fdace5d6e095160ae3efe01", "html_url": "https://github.com/rust-lang/rust/commit/a861eb0aac22dc149fdace5d6e095160ae3efe01"}], "stats": {"total": 411, "additions": 337, "deletions": 74}, "files": [{"sha": "50d4d0170fc70809c82b2dc392b3373f50b81f4c", "filename": "src/doc/book/ffi.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Fdoc%2Fbook%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Fdoc%2Fbook%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fffi.md?ref=7789881747f2ae40a520ae169eb90eb5d93795cc", "patch": "@@ -309,7 +309,7 @@ However it is often desired that the callback is targeted to a special\n Rust object. This could be the object that represents the wrapper for the\n respective C object.\n \n-This can be achieved by passing an raw pointer to the object down to the\n+This can be achieved by passing a raw pointer to the object down to the\n C library. The C library can then include the pointer to the Rust object in\n the notification. This will allow the callback to unsafely access the\n referenced Rust object."}, {"sha": "f54933827b3305cff1b1864ce3bdac7c227beda3", "filename": "src/doc/nomicon/dropck.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Fdoc%2Fnomicon%2Fdropck.md", "raw_url": "https://github.com/rust-lang/rust/raw/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Fdoc%2Fnomicon%2Fdropck.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fdropck.md?ref=7789881747f2ae40a520ae169eb90eb5d93795cc", "patch": "@@ -125,7 +125,7 @@ is that some Drop implementations will not access borrowed data even\n though their type gives them the capability for such access.\n \n For example, this variant of the above `Inspector` example will never\n-accessed borrowed data:\n+access borrowed data:\n \n ```rust,ignore\n struct Inspector<'a>(&'a u8, &'static str);"}, {"sha": "1f3693f542f357848605fe9586678cbeac9f50c0", "filename": "src/doc/nomicon/unbounded-lifetimes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Fdoc%2Fnomicon%2Funbounded-lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Fdoc%2Fnomicon%2Funbounded-lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Funbounded-lifetimes.md?ref=7789881747f2ae40a520ae169eb90eb5d93795cc", "patch": "@@ -11,7 +11,7 @@ lifetime can be regarded as `'static`.\n \n Almost no reference is `'static`, so this is probably wrong. `transmute` and\n `transmute_copy` are the two other primary offenders. One should endeavor to\n-bound an unbounded lifetime as quick as possible, especially across function\n+bound an unbounded lifetime as quickly as possible, especially across function\n boundaries.\n \n Given a function, any output lifetimes that don't derive from inputs are"}, {"sha": "85e1e133b7d9afae99aa91de58c5d9aa18b0425e", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=7789881747f2ae40a520ae169eb90eb5d93795cc", "patch": "@@ -1990,11 +1990,11 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map: BTreeMap<&str, String> = BTreeMap::new();\n-    /// let s = \"hoho\".to_owned();\n+    /// let s = \"hoho\".to_string();\n     ///\n     /// map.entry(\"poneyland\").or_insert_with(|| s);\n     ///\n-    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_owned());\n+    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {"}, {"sha": "805021516db713b8b98370a879aef52a82216a2e", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=7789881747f2ae40a520ae169eb90eb5d93795cc", "patch": "@@ -423,7 +423,7 @@ impl<T> [T] {\n         core_slice::SliceExt::get_unchecked_mut(self, index)\n     }\n \n-    /// Returns an raw pointer to the slice's buffer.\n+    /// Returns a raw pointer to the slice's buffer.\n     ///\n     /// The caller must ensure that the slice outlives the pointer this\n     /// function returns, or else it will end up pointing to garbage."}, {"sha": "ab9a71e1ec6a68e462dc5da38d45344c9053db26", "filename": "src/libcompiler_builtins/build.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Flibcompiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Flibcompiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Fbuild.rs?ref=7789881747f2ae40a520ae169eb90eb5d93795cc", "patch": "@@ -236,10 +236,6 @@ fn main() {\n                          \"atomic_thread_fence.c\"]);\n     }\n \n-    if !target.contains(\"redox\") && !target.contains(\"windows\") {\n-        sources.extend(&[\"emutls.c\"]);\n-    }\n-\n     if target.contains(\"msvc\") {\n         if target.contains(\"x86_64\") {\n             sources.extend(&[\"x86_64/floatdidf.c\", \"x86_64/floatdisf.c\", \"x86_64/floatdixf.c\"]);"}, {"sha": "78f3cd5576e1e9f8a77fe0de0804d8a81f144199", "filename": "src/libcore/any.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=7789881747f2ae40a520ae169eb90eb5d93795cc", "patch": "@@ -101,7 +101,7 @@ pub trait Any: 'static {\n     ///\n     /// fn main() {\n     ///     assert_eq!(is_string(&0), false);\n-    ///     assert_eq!(is_string(&\"cookie monster\".to_owned()), true);\n+    ///     assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n     /// }\n     /// ```\n     #[unstable(feature = \"get_type_id\",\n@@ -154,7 +154,7 @@ impl Any {\n     ///\n     /// fn main() {\n     ///     is_string(&0);\n-    ///     is_string(&\"cookie monster\".to_owned());\n+    ///     is_string(&\"cookie monster\".to_string());\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -188,7 +188,7 @@ impl Any {\n     ///\n     /// fn main() {\n     ///     print_if_string(&0);\n-    ///     print_if_string(&\"cookie monster\".to_owned());\n+    ///     print_if_string(&\"cookie monster\".to_string());\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -219,7 +219,7 @@ impl Any {\n     ///\n     /// fn main() {\n     ///     let mut x = 10u32;\n-    ///     let mut s = \"starlord\".to_owned();\n+    ///     let mut s = \"starlord\".to_string();\n     ///\n     ///     modify_if_u32(&mut x);\n     ///     modify_if_u32(&mut s);\n@@ -259,7 +259,7 @@ impl Any+Send {\n     ///\n     /// fn main() {\n     ///     is_string(&0);\n-    ///     is_string(&\"cookie monster\".to_owned());\n+    ///     is_string(&\"cookie monster\".to_string());\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -285,7 +285,7 @@ impl Any+Send {\n     ///\n     /// fn main() {\n     ///     print_if_string(&0);\n-    ///     print_if_string(&\"cookie monster\".to_owned());\n+    ///     print_if_string(&\"cookie monster\".to_string());\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -309,7 +309,7 @@ impl Any+Send {\n     ///\n     /// fn main() {\n     ///     let mut x = 10u32;\n-    ///     let mut s = \"starlord\".to_owned();\n+    ///     let mut s = \"starlord\".to_string();\n     ///\n     ///     modify_if_u32(&mut x);\n     ///     modify_if_u32(&mut s);\n@@ -359,7 +359,7 @@ impl TypeId {\n     ///\n     /// fn main() {\n     ///     assert_eq!(is_string(&0), false);\n-    ///     assert_eq!(is_string(&\"cookie monster\".to_owned()), true);\n+    ///     assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "91c09c5530565144660d761ae36784e17d7fcec0", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=7789881747f2ae40a520ae169eb90eb5d93795cc", "patch": "@@ -1612,7 +1612,7 @@ pub trait Iterator {\n \n     /// Returns the maximum element of an iterator.\n     ///\n-    /// If the two elements are equally maximum, the latest element is\n+    /// If several elements are equally maximum, the last element is\n     /// returned.\n     ///\n     /// # Examples\n@@ -1638,7 +1638,7 @@ pub trait Iterator {\n \n     /// Returns the minimum element of an iterator.\n     ///\n-    /// If the two elements are equally minimum, the first element is\n+    /// If several elements are equally minimum, the first element is\n     /// returned.\n     ///\n     /// # Examples\n@@ -1665,8 +1665,8 @@ pub trait Iterator {\n     /// Returns the element that gives the maximum value from the\n     /// specified function.\n     ///\n-    /// Returns the rightmost element if the comparison determines two elements\n-    /// to be equally maximum.\n+    /// If several elements are equally maximum, the last element is\n+    /// returned.\n     ///\n     /// # Examples\n     ///\n@@ -1690,8 +1690,8 @@ pub trait Iterator {\n     /// Returns the element that gives the maximum value with respect to the\n     /// specified comparison function.\n     ///\n-    /// Returns the rightmost element if the comparison determines two elements\n-    /// to be equally maximum.\n+    /// If several elements are equally maximum, the last element is\n+    /// returned.\n     ///\n     /// # Examples\n     ///\n@@ -1715,8 +1715,8 @@ pub trait Iterator {\n     /// Returns the element that gives the minimum value from the\n     /// specified function.\n     ///\n-    /// Returns the latest element if the comparison determines two elements\n-    /// to be equally minimum.\n+    /// If several elements are equally minimum, the first element is\n+    /// returned.\n     ///\n     /// # Examples\n     ///\n@@ -1739,8 +1739,8 @@ pub trait Iterator {\n     /// Returns the element that gives the minimum value with respect to the\n     /// specified comparison function.\n     ///\n-    /// Returns the latest element if the comparison determines two elements\n-    /// to be equally minimum.\n+    /// If several elements are equally minimum, the first element is\n+    /// returned.\n     ///\n     /// # Examples\n     ///"}, {"sha": "1e127148300678661582bb50771ca60ca275a98d", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=7789881747f2ae40a520ae169eb90eb5d93795cc", "patch": "@@ -260,7 +260,10 @@ impl<I: Iterator> IntoIterator for I {\n ///\n /// Iterators produce a series of values, and collections can also be thought\n /// of as a series of values. The `Extend` trait bridges this gap, allowing you\n-/// to extend a collection by including the contents of that iterator.\n+/// to extend a collection by including the contents of that iterator. When\n+/// extending a collection with an already existing key, that entry is updated\n+/// or, in the case of collections that permit multiple entries with equal\n+/// keys, that entry is inserted.\n ///\n /// # Examples\n ///"}, {"sha": "a314717a8772b222524bd660ca7b8248c1adbf60", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=7789881747f2ae40a520ae169eb90eb5d93795cc", "patch": "@@ -1779,11 +1779,11 @@ impl<'a, K, V> Entry<'a, K, V> {\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map: HashMap<&str, String> = HashMap::new();\n-    /// let s = \"hoho\".to_owned();\n+    /// let s = \"hoho\".to_string();\n     ///\n     /// map.entry(\"poneyland\").or_insert_with(|| s);\n     ///\n-    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_owned());\n+    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n     /// ```\n     pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n         match self {"}, {"sha": "434f522cc1ea63c4264762b6cf1919e5e6ec2201", "filename": "src/libstd/io/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=7789881747f2ae40a520ae169eb90eb5d93795cc", "patch": "@@ -388,12 +388,12 @@ impl Error {\n     /// impl MyError {\n     ///     fn new() -> MyError {\n     ///         MyError {\n-    ///             v: \"oh no!\".to_owned()\n+    ///             v: \"oh no!\".to_string()\n     ///         }\n     ///     }\n     ///\n     ///     fn change_message(&mut self, new_message: &str) {\n-    ///         self.v = new_message.to_owned();\n+    ///         self.v = new_message.to_string();\n     ///     }\n     /// }\n     ///"}, {"sha": "a9a19aee5d18d6b7767defdb9922d9b8189b92c1", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=7789881747f2ae40a520ae169eb90eb5d93795cc", "patch": "@@ -883,11 +883,23 @@ mod tests {\n \n     #[test]\n     fn set_nonblocking() {\n-        let addr = next_test_ip4();\n+        each_ip(&mut |addr, _| {\n+            let socket = t!(UdpSocket::bind(&addr));\n \n-        let stream = t!(UdpSocket::bind(&addr));\n+            t!(socket.set_nonblocking(true));\n+            t!(socket.set_nonblocking(false));\n+\n+            t!(socket.connect(addr));\n \n-        t!(stream.set_nonblocking(true));\n-        t!(stream.set_nonblocking(false));\n+            t!(socket.set_nonblocking(false));\n+            t!(socket.set_nonblocking(true));\n+\n+            let mut buf = [0];\n+            match socket.recv(&mut buf) {\n+                Ok(_) => panic!(\"expected error\"),\n+                Err(ref e) if e.kind() == ErrorKind::WouldBlock => {}\n+                Err(e) => panic!(\"unexpected error {}\", e),\n+            }\n+        })\n     }\n }"}, {"sha": "bf105a50d64cecb44a0d64c54f23498d1456a217", "filename": "src/libstd/path.rs", "status": "modified", "additions": 95, "deletions": 22, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=7789881747f2ae40a520ae169eb90eb5d93795cc", "patch": "@@ -10,20 +10,20 @@\n \n //! Cross-platform path manipulation.\n //!\n-//! This module provides two types, `PathBuf` and `Path` (akin to `String` and\n-//! `str`), for working with paths abstractly. These types are thin wrappers\n-//! around `OsString` and `OsStr` respectively, meaning that they work directly\n+//! This module provides two types, [`PathBuf`] and [`Path`][`Path`] (akin to [`String`]\n+//! and [`str`]), for working with paths abstractly. These types are thin wrappers\n+//! around [`OsString`] and [`OsStr`] respectively, meaning that they work directly\n //! on strings according to the local platform's path syntax.\n //!\n //! ## Simple usage\n //!\n //! Path manipulation includes both parsing components from slices and building\n //! new owned paths.\n //!\n-//! To parse a path, you can create a `Path` slice from a `str`\n+//! To parse a path, you can create a [`Path`] slice from a [`str`]\n //! slice and start asking questions:\n //!\n-//! ```rust\n+//! ```\n //! use std::path::Path;\n //! use std::ffi::OsStr;\n //!\n@@ -39,9 +39,9 @@\n //! assert_eq!(extension, Some(OsStr::new(\"txt\")));\n //! ```\n //!\n-//! To build or modify paths, use `PathBuf`:\n+//! To build or modify paths, use [`PathBuf`]:\n //!\n-//! ```rust\n+//! ```\n //! use std::path::PathBuf;\n //!\n //! let mut path = PathBuf::from(\"c:\\\\\");\n@@ -103,6 +103,13 @@\n //! that `b` is a symbolic link (so its parent isn't `a`). Further\n //! normalization is possible to build on top of the components APIs,\n //! and will be included in this library in the near future.\n+//!\n+//! [`PathBuf`]: ../../std/path/struct.PathBuf.html\n+//! [`Path`]: ../../std/path/struct.Path.html\n+//! [`String`]: ../../std/string/struct.String.html\n+//! [`str`]: ../../std/primitive.str.html\n+//! [`OsString`]: ../../std/ffi/struct.OsString.html\n+//! [`OsStr`]: ../../std/ffi/struct.OsStr.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -527,7 +534,9 @@ pub struct Components<'a> {\n     back: State,\n }\n \n-/// An iterator over the components of a path, as `OsStr` slices.\n+/// An iterator over the components of a path, as [`OsStr`] slices.\n+///\n+/// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a> {\n@@ -1089,10 +1098,11 @@ impl PathBuf {\n \n     /// Updates [`self.file_name()`] to `file_name`.\n     ///\n-    /// If [`self.file_name()`] was `None`, this is equivalent to pushing\n+    /// If [`self.file_name()`] was [`None`], this is equivalent to pushing\n     /// `file_name`.\n     ///\n     /// [`self.file_name()`]: struct.PathBuf.html#method.file_name\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n@@ -1124,11 +1134,12 @@ impl PathBuf {\n     ///\n     /// If [`self.file_name()`] is `None`, does nothing and returns `false`.\n     ///\n-    /// Otherwise, returns `true`; if [`self.extension()`] is `None`, the\n+    /// Otherwise, returns `true`; if [`self.extension()`] is [`None`], the\n     /// extension is added; otherwise it is replaced.\n     ///\n     /// [`self.file_name()`]: struct.PathBuf.html#method.file_name\n     /// [`self.extension()`]: struct.PathBuf.html#method.extension\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n@@ -1356,8 +1367,10 @@ pub struct Path {\n     inner: OsStr,\n }\n \n-/// An error returned from the `Path::strip_prefix` method indicating that the\n+/// An error returned from the [`Path::strip_prefix`] method indicating that the\n /// prefix was not found in `self`.\n+///\n+/// [`Path::strip_prefix`]: struct.Path.html#method.strip_prefix\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[stable(since = \"1.7.0\", feature = \"strip_prefix\")]\n pub struct StripPrefixError(());\n@@ -1539,7 +1552,9 @@ impl Path {\n \n     /// The path without its final component, if any.\n     ///\n-    /// Returns `None` if the path terminates in a root or prefix.\n+    /// Returns [`None`] if the path terminates in a root or prefix.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n@@ -1570,7 +1585,9 @@ impl Path {\n \n     /// The final component of the path, if it is a normal file.\n     ///\n-    /// If the path terminates in `..`, `file_name` will return `None`.\n+    /// If the path terminates in `..`, `file_name` will return [`None`].\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n@@ -1608,8 +1625,11 @@ impl Path {\n     ///\n     /// # Errors\n     ///\n-    /// If `base` is not a prefix of `self` (i.e. `starts_with`\n-    /// returns `false`), returns `Err`.\n+    /// If `base` is not a prefix of `self` (i.e. [`starts_with`]\n+    /// returns `false`), returns [`Err`].\n+    ///\n+    /// [`starts_with`]: #method.starts_with\n+    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -1689,11 +1709,13 @@ impl Path {\n     ///\n     /// The stem is:\n     ///\n-    /// * None, if there is no file name;\n+    /// * [`None`], if there is no file name;\n     /// * The entire file name if there is no embedded `.`;\n     /// * The entire file name if the file name begins with `.` and has no other `.`s within;\n     /// * Otherwise, the portion of the file name before the final `.`\n     ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1710,15 +1732,16 @@ impl Path {\n \n     /// Extracts the extension of [`self.file_name()`], if possible.\n     ///\n-    /// [`self.file_name()`]: struct.Path.html#method.file_name\n-    ///\n     /// The extension is:\n     ///\n-    /// * None, if there is no file name;\n-    /// * None, if there is no embedded `.`;\n-    /// * None, if the file name begins with `.` and has no other `.`s within;\n+    /// * [`None`], if there is no file name;\n+    /// * [`None`], if there is no embedded `.`;\n+    /// * [`None`], if the file name begins with `.` and has no other `.`s within;\n     /// * Otherwise, the portion of the file name after the final `.`\n     ///\n+    /// [`self.file_name()`]: struct.Path.html#method.file_name\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1877,7 +1900,6 @@ impl Path {\n         Display { path: self }\n     }\n \n-\n     /// Query the file system to get information about a file, directory, etc.\n     ///\n     /// This function will traverse symbolic links to query information about the\n@@ -1886,6 +1908,16 @@ impl Path {\n     /// This is an alias to [`fs::metadata`].\n     ///\n     /// [`fs::metadata`]: ../fs/fn.metadata.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/Minas/tirith\");\n+    /// let metadata = path.metadata().expect(\"metadata call failed\");\n+    /// println!(\"{:?}\", metadata.file_type());\n+    /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn metadata(&self) -> io::Result<fs::Metadata> {\n         fs::metadata(self)\n@@ -1896,6 +1928,16 @@ impl Path {\n     /// This is an alias to [`fs::symlink_metadata`].\n     ///\n     /// [`fs::symlink_metadata`]: ../fs/fn.symlink_metadata.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/Minas/tirith\");\n+    /// let metadata = path.symlink_metadata().expect(\"symlink_metadata call failed\");\n+    /// println!(\"{:?}\", metadata.file_type());\n+    /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn symlink_metadata(&self) -> io::Result<fs::Metadata> {\n         fs::symlink_metadata(self)\n@@ -1907,6 +1949,15 @@ impl Path {\n     /// This is an alias to [`fs::canonicalize`].\n     ///\n     /// [`fs::canonicalize`]: ../fs/fn.canonicalize.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::path::{Path, PathBuf};\n+    ///\n+    /// let path = Path::new(\"/foo/test/../test/bar.rs\");\n+    /// assert_eq!(path.canonicalize().unwrap(), PathBuf::from(\"/foo/test/bar.rs\"));\n+    /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn canonicalize(&self) -> io::Result<PathBuf> {\n         fs::canonicalize(self)\n@@ -1917,6 +1968,15 @@ impl Path {\n     /// This is an alias to [`fs::read_link`].\n     ///\n     /// [`fs::read_link`]: ../fs/fn.read_link.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/laputa/sky_castle.rs\");\n+    /// let path_link = path.read_link().expect(\"read_link call failed\");\n+    /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn read_link(&self) -> io::Result<PathBuf> {\n         fs::read_link(self)\n@@ -1932,6 +1992,19 @@ impl Path {\n     /// [`io::Result`]: ../io/type.Result.html\n     /// [`DirEntry`]: ../fs/struct.DirEntry.html\n     /// [`fs::read_dir`]: ../fs/fn.read_dir.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/laputa\");\n+    /// for entry in path.read_dir().expect(\"read_dir call failed\") {\n+    ///     if let Ok(entry) = entry {\n+    ///         println!(\"{:?}\", entry.path());\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn read_dir(&self) -> io::Result<fs::ReadDir> {\n         fs::read_dir(self)"}, {"sha": "2efddeb4610dd6211cb7ea06b5c2ae91073cde85", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=7789881747f2ae40a520ae169eb90eb5d93795cc", "patch": "@@ -155,6 +155,14 @@ impl<'a, T: ?Sized> !marker::Send for MutexGuard<'a, T> {}\n \n impl<T> Mutex<T> {\n     /// Creates a new mutex in an unlocked state ready for use.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Mutex;\n+    ///\n+    /// let mutex = Mutex::new(0);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(t: T) -> Mutex<T> {\n         let mut m = Mutex {\n@@ -190,6 +198,21 @@ impl<T: ?Sized> Mutex<T> {\n     ///\n     /// This function might panic when called if the lock is already held by\n     /// the current thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::{Arc, Mutex};\n+    /// use std::thread;\n+    ///\n+    /// let mutex = Arc::new(Mutex::new(0));\n+    /// let c_mutex = mutex.clone();\n+    ///\n+    /// thread::spawn(move || {\n+    ///     *c_mutex.lock().unwrap() = 10;\n+    /// }).join().expect(\"thread::spawn failed\");\n+    /// assert_eq!(*mutex.lock().unwrap(), 10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> LockResult<MutexGuard<T>> {\n         unsafe {\n@@ -211,6 +234,26 @@ impl<T: ?Sized> Mutex<T> {\n     /// If another user of this mutex panicked while holding the mutex, then\n     /// this call will return failure if the mutex would otherwise be\n     /// acquired.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::{Arc, Mutex};\n+    /// use std::thread;\n+    ///\n+    /// let mutex = Arc::new(Mutex::new(0));\n+    /// let c_mutex = mutex.clone();\n+    ///\n+    /// thread::spawn(move || {\n+    ///     let mut lock = c_mutex.try_lock();\n+    ///     if let Ok(ref mut mutex) = lock {\n+    ///         **mutex = 10;\n+    ///     } else {\n+    ///         println!(\"try_lock failed\");\n+    ///     }\n+    /// }).join().expect(\"thread::spawn failed\");\n+    /// assert_eq!(*mutex.lock().unwrap(), 10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_lock(&self) -> TryLockResult<MutexGuard<T>> {\n         unsafe {\n@@ -225,8 +268,24 @@ impl<T: ?Sized> Mutex<T> {\n     /// Determines whether the lock is poisoned.\n     ///\n     /// If another thread is active, the lock can still become poisoned at any\n-    /// time.  You should not trust a `false` value for program correctness\n+    /// time. You should not trust a `false` value for program correctness\n     /// without additional synchronization.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::{Arc, Mutex};\n+    /// use std::thread;\n+    ///\n+    /// let mutex = Arc::new(Mutex::new(0));\n+    /// let c_mutex = mutex.clone();\n+    ///\n+    /// let _ = thread::spawn(move || {\n+    ///     let _lock = c_mutex.lock().unwrap();\n+    ///     panic!(); // the mutex gets poisoned\n+    /// }).join();\n+    /// assert_eq!(mutex.is_poisoned(), true);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n     pub fn is_poisoned(&self) -> bool {\n@@ -239,6 +298,15 @@ impl<T: ?Sized> Mutex<T> {\n     ///\n     /// If another user of this mutex panicked while holding the mutex, then\n     /// this call will return an error instead.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Mutex;\n+    ///\n+    /// let mutex = Mutex::new(0);\n+    /// assert_eq!(mutex.into_inner().unwrap(), 0);\n+    /// ```\n     #[stable(feature = \"mutex_into_inner\", since = \"1.6.0\")]\n     pub fn into_inner(self) -> LockResult<T> where T: Sized {\n         // We know statically that there are no outstanding references to\n@@ -270,6 +338,16 @@ impl<T: ?Sized> Mutex<T> {\n     ///\n     /// If another user of this mutex panicked while holding the mutex, then\n     /// this call will return an error instead.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Mutex;\n+    ///\n+    /// let mut mutex = Mutex::new(0);\n+    /// *mutex.get_mut().unwrap() = 10;\n+    /// assert_eq!(*mutex.lock().unwrap(), 10);\n+    /// ```\n     #[stable(feature = \"mutex_get_mut\", since = \"1.6.0\")]\n     pub fn get_mut(&mut self) -> LockResult<&mut T> {\n         // We know statically that there are no other references to `self`, so"}, {"sha": "e4b8d457e2d29dcee1dd107fdc4706231b5ad413", "filename": "src/libstd/time/mod.rs", "status": "modified", "additions": 115, "deletions": 14, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Flibstd%2Ftime%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7789881747f2ae40a520ae169eb90eb5d93795cc/src%2Flibstd%2Ftime%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fmod.rs?ref=7789881747f2ae40a520ae169eb90eb5d93795cc", "patch": "@@ -34,7 +34,7 @@ pub use self::duration::Duration;\n mod duration;\n \n /// A measurement of a monotonically increasing clock.\n-///  Opaque and useful only with `Duration`.\n+/// Opaque and useful only with `Duration`.\n ///\n /// Instants are always guaranteed to be greater than any previously measured\n /// instant when created, and are often useful for tasks such as measuring\n@@ -73,23 +73,28 @@ pub struct Instant(time::Instant);\n /// A measurement of the system clock, useful for talking to\n /// external entities like the file system or other processes.\n ///\n-/// Distinct from the `Instant` type, this time measurement **is not\n+/// Distinct from the [`Instant`] type, this time measurement **is not\n /// monotonic**. This means that you can save a file to the file system, then\n /// save another file to the file system, **and the second file has a\n /// `SystemTime` measurement earlier than the first**. In other words, an\n /// operation that happens after another operation in real time may have an\n /// earlier `SystemTime`!\n ///\n /// Consequently, comparing two `SystemTime` instances to learn about the\n-/// duration between them returns a `Result` instead of an infallible `Duration`\n+/// duration between them returns a [`Result`] instead of an infallible [`Duration`]\n /// to indicate that this sort of time drift may happen and needs to be handled.\n ///\n-/// Although a `SystemTime` cannot be directly inspected, the `UNIX_EPOCH`\n+/// Although a `SystemTime` cannot be directly inspected, the [`UNIX_EPOCH`]\n /// constant is provided in this module as an anchor in time to learn\n /// information about a `SystemTime`. By calculating the duration from this\n /// fixed point in time, a `SystemTime` can be converted to a human-readable time,\n /// or perhaps some other string representation.\n ///\n+/// [`Instant`]: ../../std/time/struct.Instant.html\n+/// [`Result`]: ../../std/result/enum.Result.html\n+/// [`Duration`]: ../../std/time/struct.Duration.html\n+/// [`UNIX_EPOCH`]: ../../std/time/constant.UNIX_EPOCH.html\n+///\n /// Example:\n ///\n /// ```no_run\n@@ -117,14 +122,38 @@ pub struct Instant(time::Instant);\n #[stable(feature = \"time2\", since = \"1.8.0\")]\n pub struct SystemTime(time::SystemTime);\n \n-/// An error returned from the `duration_since` method on `SystemTime`,\n-/// used to learn how far in the opposite direction a system time lies.\n+/// An error returned from the `duration_since` and `elapsed` methods on\n+/// `SystemTime`, used to learn how far in the opposite direction a system time\n+/// lies.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::thread::sleep;\n+/// use std::time::{Duration, SystemTime};\n+///\n+/// let sys_time = SystemTime::now();\n+/// sleep(Duration::from_secs(1));\n+/// let new_sys_time = SystemTime::now();\n+/// match sys_time.duration_since(new_sys_time) {\n+///     Ok(_) => {}\n+///     Err(e) => println!(\"SystemTimeError difference: {:?}\", e.duration()),\n+/// }\n+/// ```\n #[derive(Clone, Debug)]\n #[stable(feature = \"time2\", since = \"1.8.0\")]\n pub struct SystemTimeError(Duration);\n \n impl Instant {\n     /// Returns an instant corresponding to \"now\".\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::time::Instant;\n+    ///\n+    /// let now = Instant::now();\n+    /// ```\n     #[stable(feature = \"time2\", since = \"1.8.0\")]\n     pub fn now() -> Instant {\n         Instant(time::Instant::now())\n@@ -138,6 +167,18 @@ impl Instant {\n     /// only be possible if `earlier` was created after `self`. Because\n     /// `Instant` is monotonic, the only time that this should happen should be\n     /// a bug.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::time::{Duration, Instant};\n+    /// use std::thread::sleep;\n+    ///\n+    /// let now = Instant::now();\n+    /// sleep(Duration::new(1, 0));\n+    /// let new_now = Instant::now();\n+    /// println!(\"{:?}\", new_now.duration_since(now));\n+    /// ```\n     #[stable(feature = \"time2\", since = \"1.8.0\")]\n     pub fn duration_since(&self, earlier: Instant) -> Duration {\n         self.0.sub_instant(&earlier.0)\n@@ -218,6 +259,14 @@ impl fmt::Debug for Instant {\n \n impl SystemTime {\n     /// Returns the system time corresponding to \"now\".\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::time::SystemTime;\n+    ///\n+    /// let sys_time = SystemTime::now();\n+    /// ```\n     #[stable(feature = \"time2\", since = \"1.8.0\")]\n     pub fn now() -> SystemTime {\n         SystemTime(time::SystemTime::now())\n@@ -229,11 +278,26 @@ impl SystemTime {\n     /// guaranteed to always be before later measurements (due to anomalies such\n     /// as the system clock being adjusted either forwards or backwards).\n     ///\n-    /// If successful, `Ok(Duration)` is returned where the duration represents\n+    /// If successful, [`Ok`]`(`[`Duration`]`)` is returned where the duration represents\n     /// the amount of time elapsed from the specified measurement to this one.\n     ///\n-    /// Returns an `Err` if `earlier` is later than `self`, and the error\n+    /// Returns an [`Err`] if `earlier` is later than `self`, and the error\n     /// contains how far from `self` the time is.\n+    ///\n+    /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n+    /// [`Duration`]: ../../std/time/struct.Duration.html\n+    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::time::SystemTime;\n+    ///\n+    /// let sys_time = SystemTime::now();\n+    /// let difference = sys_time.duration_since(sys_time)\n+    ///                          .expect(\"SystemTime::duration_since failed\");\n+    /// println!(\"{:?}\", difference);\n+    /// ```\n     #[stable(feature = \"time2\", since = \"1.8.0\")]\n     pub fn duration_since(&self, earlier: SystemTime)\n                           -> Result<Duration, SystemTimeError> {\n@@ -244,12 +308,28 @@ impl SystemTime {\n     ///\n     /// This function may fail as the underlying system clock is susceptible to\n     /// drift and updates (e.g. the system clock could go backwards), so this\n-    /// function may not always succeed. If successful, `Ok(duration)` is\n+    /// function may not always succeed. If successful, [`Ok`]`(`[`Duration`]`)` is\n     /// returned where the duration represents the amount of time elapsed from\n     /// this time measurement to the current time.\n     ///\n-    /// Returns an `Err` if `self` is later than the current system time, and\n+    /// Returns an [`Err`] if `self` is later than the current system time, and\n     /// the error contains how far from the current system time `self` is.\n+    ///\n+    /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n+    /// [`Duration`]: ../../std/time/struct.Duration.html\n+    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::thread::sleep;\n+    /// use std::time::{Duration, SystemTime};\n+    ///\n+    /// let sys_time = SystemTime::now();\n+    /// let one_sec = Duration::from_secs(1);\n+    /// sleep(one_sec);\n+    /// assert!(sys_time.elapsed().unwrap() >= one_sec);\n+    /// ```\n     #[stable(feature = \"time2\", since = \"1.8.0\")]\n     pub fn elapsed(&self) -> Result<Duration, SystemTimeError> {\n         SystemTime::now().duration_since(*self)\n@@ -300,19 +380,40 @@ impl fmt::Debug for SystemTime {\n ///\n /// This constant is defined to be \"1970-01-01 00:00:00 UTC\" on all systems with\n /// respect to the system clock. Using `duration_since` on an existing\n-/// `SystemTime` instance can tell how far away from this point in time a\n+/// [`SystemTime`] instance can tell how far away from this point in time a\n /// measurement lies, and using `UNIX_EPOCH + duration` can be used to create a\n-/// `SystemTime` instance to represent another fixed point in time.\n+/// [`SystemTime`] instance to represent another fixed point in time.\n+///\n+/// [`SystemTime`]: ../../std/time/struct.SystemTime.html\n #[stable(feature = \"time2\", since = \"1.8.0\")]\n pub const UNIX_EPOCH: SystemTime = SystemTime(time::UNIX_EPOCH);\n \n impl SystemTimeError {\n     /// Returns the positive duration which represents how far forward the\n     /// second system time was from the first.\n     ///\n-    /// A `SystemTimeError` is returned from the `duration_since`\n-    /// operation whenever the second system time represents a point later\n+    /// A `SystemTimeError` is returned from the [`duration_since`] and [`elapsed`]\n+    /// methods of [`SystemTime`] whenever the second system time represents a point later\n     /// in time than the `self` of the method call.\n+    ///\n+    /// [`duration_since`]: ../../std/time/struct.SystemTime.html#method.duration_since\n+    /// [`elapsed`]: ../../std/time/struct.SystemTime.html#method.elapsed\n+    /// [`SystemTime`]: ../../std/time/struct.SystemTime.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::thread::sleep;\n+    /// use std::time::{Duration, SystemTime};\n+    ///\n+    /// let sys_time = SystemTime::now();\n+    /// sleep(Duration::from_secs(1));\n+    /// let new_sys_time = SystemTime::now();\n+    /// match sys_time.duration_since(new_sys_time) {\n+    ///     Ok(_) => {}\n+    ///     Err(e) => println!(\"SystemTimeError difference: {:?}\", e.duration()),\n+    /// }\n+    /// ```\n     #[stable(feature = \"time2\", since = \"1.8.0\")]\n     pub fn duration(&self) -> Duration {\n         self.0"}]}