{"sha": "9966bbd1b11fcd2866cdbd21146f5e9a0d8ea66c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5NjZiYmQxYjExZmNkMjg2NmNkYmQyMTE0NmY1ZTlhMGQ4ZWE2NmM=", "commit": {"author": {"name": "Austin Hicks", "email": "camlorn@camlorn.net", "date": "2016-12-03T00:24:24Z"}, "committer": {"name": "Austin Hicks", "email": "camlorn@camlorn.net", "date": "2016-12-14T17:28:26Z"}, "message": "Fix computation of enum names based off the discrfield in the case of the null pointer optimization.  This functionality is needed by pretty printers for gdb and lldb.", "tree": {"sha": "dd2e5d55dae54f7bfc9a8a07b605f7969ce49df9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd2e5d55dae54f7bfc9a8a07b605f7969ce49df9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9966bbd1b11fcd2866cdbd21146f5e9a0d8ea66c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9966bbd1b11fcd2866cdbd21146f5e9a0d8ea66c", "html_url": "https://github.com/rust-lang/rust/commit/9966bbd1b11fcd2866cdbd21146f5e9a0d8ea66c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9966bbd1b11fcd2866cdbd21146f5e9a0d8ea66c/comments", "author": {"login": "ahicks92", "id": 6968705, "node_id": "MDQ6VXNlcjY5Njg3MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/6968705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ahicks92", "html_url": "https://github.com/ahicks92", "followers_url": "https://api.github.com/users/ahicks92/followers", "following_url": "https://api.github.com/users/ahicks92/following{/other_user}", "gists_url": "https://api.github.com/users/ahicks92/gists{/gist_id}", "starred_url": "https://api.github.com/users/ahicks92/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ahicks92/subscriptions", "organizations_url": "https://api.github.com/users/ahicks92/orgs", "repos_url": "https://api.github.com/users/ahicks92/repos", "events_url": "https://api.github.com/users/ahicks92/events{/privacy}", "received_events_url": "https://api.github.com/users/ahicks92/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ahicks92", "id": 6968705, "node_id": "MDQ6VXNlcjY5Njg3MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/6968705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ahicks92", "html_url": "https://github.com/ahicks92", "followers_url": "https://api.github.com/users/ahicks92/followers", "following_url": "https://api.github.com/users/ahicks92/following{/other_user}", "gists_url": "https://api.github.com/users/ahicks92/gists{/gist_id}", "starred_url": "https://api.github.com/users/ahicks92/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ahicks92/subscriptions", "organizations_url": "https://api.github.com/users/ahicks92/orgs", "repos_url": "https://api.github.com/users/ahicks92/repos", "events_url": "https://api.github.com/users/ahicks92/events{/privacy}", "received_events_url": "https://api.github.com/users/ahicks92/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a65cc1ea546bca6cccf4e479e4acd09a8a839ce0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a65cc1ea546bca6cccf4e479e4acd09a8a839ce0", "html_url": "https://github.com/rust-lang/rust/commit/a65cc1ea546bca6cccf4e479e4acd09a8a839ce0"}], "stats": {"total": 59, "additions": 36, "deletions": 23}, "files": [{"sha": "7a8a34788d2779562cee43ba11c3c5cd2a19ef1d", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9966bbd1b11fcd2866cdbd21146f5e9a0d8ea66c/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9966bbd1b11fcd2866cdbd21146f5e9a0d8ea66c/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=9966bbd1b11fcd2866cdbd21146f5e9a0d8ea66c", "patch": "@@ -717,16 +717,18 @@ impl<'a, 'gcx, 'tcx> Struct {\n \n     /// Find the path leading to a non-zero leaf field, starting from\n     /// the given type and recursing through aggregates.\n+    /// The tuple is `(path, source_path)1,\n+    /// where `path` is in memory order and `source_path` in source order.\n     // FIXME(eddyb) track value ranges and traverse already optimized enums.\n     fn non_zero_field_in_type(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                   ty: Ty<'gcx>)\n-                                  -> Result<Option<FieldPath>, LayoutError<'gcx>> {\n+                                  -> Result<Option<(FieldPath, FieldPath)>, LayoutError<'gcx>> {\n         let tcx = infcx.tcx.global_tcx();\n         match (ty.layout(infcx)?, &ty.sty) {\n             (&Scalar { non_zero: true, .. }, _) |\n-            (&CEnum { non_zero: true, .. }, _) => Ok(Some(vec![])),\n+            (&CEnum { non_zero: true, .. }, _) => Ok(Some((vec![], vec![]))),\n             (&FatPointer { non_zero: true, .. }, _) => {\n-                Ok(Some(vec![FAT_PTR_ADDR as u32]))\n+                Ok(Some((vec![FAT_PTR_ADDR as u32], vec![FAT_PTR_ADDR as u32])))\n             }\n \n             // Is this the NonZero lang item wrapping a pointer or integer type?\n@@ -737,10 +739,11 @@ impl<'a, 'gcx, 'tcx> Struct {\n                     // FIXME(eddyb) also allow floating-point types here.\n                     Scalar { value: Int(_), non_zero: false } |\n                     Scalar { value: Pointer, non_zero: false } => {\n-                        Ok(Some(vec![0]))\n+                        Ok(Some((vec![0], vec![0])))\n                     }\n                     FatPointer { non_zero: false, .. } => {\n-                        Ok(Some(vec![FAT_PTR_ADDR as u32, 0]))\n+                        let tmp = vec![FAT_PTR_ADDR as u32, 0];\n+                        Ok(Some((tmp.clone(), tmp)))\n                     }\n                     _ => Ok(None)\n                 }\n@@ -749,7 +752,7 @@ impl<'a, 'gcx, 'tcx> Struct {\n             // Perhaps one of the fields of this struct is non-zero\n             // let's recurse and find out\n             (&Univariant { ref variant, .. }, &ty::TyAdt(def, substs)) if def.is_struct() => {\n-                Struct::non_zero_field_path(infcx, def.struct_variant().fields\n+                Struct::non_zero_field_paths(infcx, def.struct_variant().fields\n                                                       .iter().map(|field| {\n                     field.ty(tcx, substs)\n                 }),\n@@ -759,19 +762,19 @@ impl<'a, 'gcx, 'tcx> Struct {\n             // Perhaps one of the upvars of this closure is non-zero\n             (&Univariant { ref variant, .. }, &ty::TyClosure(def, substs)) => {\n                 let upvar_tys = substs.upvar_tys(def, tcx);\n-                Struct::non_zero_field_path(infcx, upvar_tys,\n+                Struct::non_zero_field_paths(infcx, upvar_tys,\n                     Some(&variant.memory_index[..]))\n             }\n             // Can we use one of the fields in this tuple?\n             (&Univariant { ref variant, .. }, &ty::TyTuple(tys)) => {\n-                Struct::non_zero_field_path(infcx, tys.iter().cloned(),\n+                Struct::non_zero_field_paths(infcx, tys.iter().cloned(),\n                     Some(&variant.memory_index[..]))\n             }\n \n             // Is this a fixed-size array of something non-zero\n             // with at least one element?\n             (_, &ty::TyArray(ety, d)) if d > 0 => {\n-                Struct::non_zero_field_path(infcx, Some(ety).into_iter(), None)\n+                Struct::non_zero_field_paths(infcx, Some(ety).into_iter(), None)\n             }\n \n             (_, &ty::TyProjection(_)) | (_, &ty::TyAnon(..)) => {\n@@ -789,20 +792,23 @@ impl<'a, 'gcx, 'tcx> Struct {\n \n     /// Find the path leading to a non-zero leaf field, starting from\n     /// the given set of fields and recursing through aggregates.\n-    fn non_zero_field_path<I>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    // / Returns Some((path, source_path)) on success.\n+    /// `path` is translated to memory order. `source_path` is not.\n+    fn non_zero_field_paths<I>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                   fields: I,\n                                   permutation: Option<&[u32]>)\n-                                  -> Result<Option<FieldPath>, LayoutError<'gcx>>\n+                                  -> Result<Option<(FieldPath, FieldPath)>, LayoutError<'gcx>>\n     where I: Iterator<Item=Ty<'gcx>> {\n         for (i, ty) in fields.enumerate() {\n-            if let Some(mut path) = Struct::non_zero_field_in_type(infcx, ty)? {\n+            if let Some((mut path, mut source_path)) = Struct::non_zero_field_in_type(infcx, ty)? {\n+                source_path.push(i as u32);\n                 let index = if let Some(p) = permutation {\n                     p[i] as usize\n                 } else {\n                     i\n                 };\n                 path.push(index as u32);\n-                return Ok(Some(path));\n+                return Ok(Some((path, source_path)));\n             }\n         }\n         Ok(None)\n@@ -965,7 +971,9 @@ pub enum Layout {\n         nndiscr: u64,\n         nonnull: Struct,\n         // N.B. There is a 0 at the start, for LLVM GEP through a pointer.\n-        discrfield: FieldPath\n+        discrfield: FieldPath,\n+        // Like discrfield, but in source order. For debuginfo.\n+        discrfield_source: FieldPath\n     }\n }\n \n@@ -1242,10 +1250,11 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         if !Struct::would_be_zero_sized(dl, other_fields)? {\n                             continue;\n                         }\n-                        let path = Struct::non_zero_field_path(infcx,\n+                        let paths = Struct::non_zero_field_paths(infcx,\n                             variants[discr].iter().cloned(),\n                             None)?;\n-                        let mut path = if let Some(p) = path { p } else { continue };\n+                        let (mut path, mut path_source) = if let Some(p) = paths { p }\n+                          else { continue };\n \n                         // FIXME(eddyb) should take advantage of a newtype.\n                         if path == &[0] && variants[discr].len() == 1 {\n@@ -1273,11 +1282,14 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         *path.last_mut().unwrap() = i;\n                         path.push(0); // For GEP through a pointer.\n                         path.reverse();\n+                        path_source.push(0);\n+                        path_source.reverse();\n \n                         return success(StructWrappedNullablePointer {\n                             nndiscr: discr as u64,\n                             nonnull: st,\n-                            discrfield: path\n+                            discrfield: path,\n+                            discrfield_source: path_source\n                         });\n                     }\n                 }"}, {"sha": "c7f21427a0ceb656c5e6731acbc635dd25ba80cb", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9966bbd1b11fcd2866cdbd21146f5e9a0d8ea66c/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9966bbd1b11fcd2866cdbd21146f5e9a0d8ea66c/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=9966bbd1b11fcd2866cdbd21146f5e9a0d8ea66c", "patch": "@@ -1870,7 +1870,8 @@ fn gather_type_sizes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         match **layout {\n             Layout::StructWrappedNullablePointer { nonnull: ref variant_layout,\n                                                    nndiscr,\n-                                                   discrfield: _ } => {\n+                                                   discrfield: _,\n+                                                   discrfield_source: _ } => {\n                 debug!(\"print-type-size t: `{:?}` adt struct-wrapped nullable nndiscr {} is {:?}\",\n                        ty, nndiscr, variant_layout);\n                 let variant_def = &adt_def.variants[nndiscr as usize];"}, {"sha": "f9600be1c6618de0f191152526793cb96c3bebbd", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9966bbd1b11fcd2866cdbd21146f5e9a0d8ea66c/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9966bbd1b11fcd2866cdbd21146f5e9a0d8ea66c/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=9966bbd1b11fcd2866cdbd21146f5e9a0d8ea66c", "patch": "@@ -1258,7 +1258,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n             },\n             layout::StructWrappedNullablePointer { nonnull: ref struct_def,\n                                                 nndiscr,\n-                                                ref discrfield, ..} => {\n+                                                ref discrfield_source, ..} => {\n                 // Create a description of the non-null variant\n                 let (variant_type_metadata, variant_llvm_type, member_description_factory) =\n                     describe_enum_variant(cx,\n@@ -1281,12 +1281,12 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // member's name.\n                 let null_variant_index = (1 - nndiscr) as usize;\n                 let null_variant_name = adt.variants[null_variant_index].name;\n-                let discrfield = discrfield.iter()\n+                let discrfield_source = discrfield_source.iter()\n                                            .skip(1)\n                                            .map(|x| x.to_string())\n                                            .collect::<Vec<_>>().join(\"$\");\n                 let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n-                                                discrfield,\n+                                                discrfield_source,\n                                                 null_variant_name);\n \n                 // Create the (singleton) list of descriptions of union members."}, {"sha": "ffd36ae14ad7cd75d3a2659e099d740281d0e8cd", "filename": "src/test/debuginfo/struct-in-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9966bbd1b11fcd2866cdbd21146f5e9a0d8ea66c/src%2Ftest%2Fdebuginfo%2Fstruct-in-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9966bbd1b11fcd2866cdbd21146f5e9a0d8ea66c/src%2Ftest%2Fdebuginfo%2Fstruct-in-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-in-enum.rs?ref=9966bbd1b11fcd2866cdbd21146f5e9a0d8ea66c", "patch": "@@ -19,11 +19,11 @@\n // gdb-command:run\n \n // gdb-command:print case1\n-// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, __0 = 0, __1 = {x = 2088533116, y = 2088533116, z = 31868}}, {RUST$ENUM$DISR = Case1, __0 = 0, __1 = 8970181431921507452, __2 = 31868}}\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, __0 = 0, __1 = {x = 2088533116, y = 2088533116, z = 31868}}, {RUST$ENUM$DISR = Case1, [...]}}\n // gdbr-check:$1 = struct_in_enum::Regular::Case1(0, struct_in_enum::Struct {x: 2088533116, y: 2088533116, z: 31868})\n \n // gdb-command:print case2\n-// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, __0 = 0, __1 = {x = 286331153, y = 286331153, z = 4369}}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 1229782938247303441, __2 = 4369}}\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, [...]}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 1229782938247303441, __2 = 4369}}\n // gdbr-check:$2 = struct_in_enum::Regular::Case2(0, 1229782938247303441, 4369)\n \n // gdb-command:print univariant"}]}