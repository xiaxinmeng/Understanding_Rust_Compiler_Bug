{"sha": "e29f42025513374f1a88404491d1b40386acf994", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyOWY0MjAyNTUxMzM3NGYxYTg4NDA0NDkxZDFiNDAzODZhY2Y5OTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-11T17:59:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-11T17:59:37Z"}, "message": "Auto merge of #21972 - pnkfelix:new-dtor-semantics-6, r=nikomatsakis\n\nThis is a resurrection and heavy revision/expansion of a PR that pcwalton did to resolve #8861.\r\n\r\nThe most relevant, user-visible semantic change is this: #[unsafe_destructor] is gone. Instead, if a type expression for some value has a destructor, then any lifetimes referenced within that type expression must strictly outlive the scope of the value.\r\n\r\nSee discussion on https://github.com/rust-lang/rfcs/pull/769", "tree": {"sha": "a6459e62987a6c3b80cdf7c9810c9405d1d1fe1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6459e62987a6c3b80cdf7c9810c9405d1d1fe1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e29f42025513374f1a88404491d1b40386acf994", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e29f42025513374f1a88404491d1b40386acf994", "html_url": "https://github.com/rust-lang/rust/commit/e29f42025513374f1a88404491d1b40386acf994", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e29f42025513374f1a88404491d1b40386acf994/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "446bc899b28e988f4252beca0d1858e7f7d866b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/446bc899b28e988f4252beca0d1858e7f7d866b1", "html_url": "https://github.com/rust-lang/rust/commit/446bc899b28e988f4252beca0d1858e7f7d866b1"}, {"sha": "2c9d81b2d47d1c8d0e4c771b778238948c269c20", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c9d81b2d47d1c8d0e4c771b778238948c269c20", "html_url": "https://github.com/rust-lang/rust/commit/2c9d81b2d47d1c8d0e4c771b778238948c269c20"}], "stats": {"total": 1999, "additions": 1863, "deletions": 136}, "files": [{"sha": "4cd3d587580f05ed183efc54d8e268dbdb4ea051", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 50, "deletions": 21, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -42,6 +42,7 @@ use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::intrinsics::{TyDesc, get_tydesc};\n use std::intrinsics;\n+use std::marker;\n use std::mem;\n use std::num::{Int, UnsignedInt};\n use std::ptr;\n@@ -88,27 +89,29 @@ impl Chunk {\n /// than objects without destructors. This reduces overhead when initializing\n /// plain-old-data (`Copy` types) and means we don't need to waste time running\n /// their destructors.\n-pub struct Arena {\n+pub struct Arena<'longer_than_self> {\n     // The head is separated out from the list as a unbenchmarked\n     // microoptimization, to avoid needing to case on the list to access the\n     // head.\n     head: RefCell<Chunk>,\n     copy_head: RefCell<Chunk>,\n     chunks: RefCell<Vec<Chunk>>,\n+    _invariant: marker::InvariantLifetime<'longer_than_self>,\n }\n \n-impl Arena {\n+impl<'a> Arena<'a> {\n     /// Allocates a new Arena with 32 bytes preallocated.\n-    pub fn new() -> Arena {\n+    pub fn new() -> Arena<'a> {\n         Arena::new_with_size(32)\n     }\n \n     /// Allocates a new Arena with `initial_size` bytes preallocated.\n-    pub fn new_with_size(initial_size: usize) -> Arena {\n+    pub fn new_with_size(initial_size: usize) -> Arena<'a> {\n         Arena {\n             head: RefCell::new(chunk(initial_size, false)),\n             copy_head: RefCell::new(chunk(initial_size, true)),\n             chunks: RefCell::new(Vec::new()),\n+            _invariant: marker::InvariantLifetime,\n         }\n     }\n }\n@@ -122,7 +125,7 @@ fn chunk(size: usize, is_copy: bool) -> Chunk {\n }\n \n #[unsafe_destructor]\n-impl Drop for Arena {\n+impl<'longer_than_self> Drop for Arena<'longer_than_self> {\n     fn drop(&mut self) {\n         unsafe {\n             destroy_chunk(&*self.head.borrow());\n@@ -180,7 +183,7 @@ fn un_bitpack_tydesc_ptr(p: usize) -> (*const TyDesc, bool) {\n     ((p & !1) as *const TyDesc, p & 1 == 1)\n }\n \n-impl Arena {\n+impl<'longer_than_self> Arena<'longer_than_self> {\n     fn chunk_size(&self) -> usize {\n         self.copy_head.borrow().capacity()\n     }\n@@ -293,7 +296,7 @@ impl Arena {\n     /// Allocates a new item in the arena, using `op` to initialize the value,\n     /// and returns a reference to it.\n     #[inline]\n-    pub fn alloc<T, F>(&self, op: F) -> &mut T where F: FnOnce() -> T {\n+    pub fn alloc<T:'longer_than_self, F>(&self, op: F) -> &mut T where F: FnOnce() -> T {\n         unsafe {\n             if intrinsics::needs_drop::<T>() {\n                 self.alloc_noncopy(op)\n@@ -317,20 +320,6 @@ fn test_arena_destructors() {\n     }\n }\n \n-#[test]\n-fn test_arena_alloc_nested() {\n-    struct Inner { value: usize }\n-    struct Outer<'a> { inner: &'a Inner }\n-\n-    let arena = Arena::new();\n-\n-    let result = arena.alloc(|| Outer {\n-        inner: arena.alloc(|| Inner { value: 10 })\n-    });\n-\n-    assert_eq!(result.inner.value, 10);\n-}\n-\n #[test]\n #[should_fail]\n fn test_arena_destructors_fail() {\n@@ -365,6 +354,10 @@ pub struct TypedArena<T> {\n \n     /// A pointer to the first arena segment.\n     first: RefCell<*mut TypedArenaChunk<T>>,\n+\n+    /// Marker indicating that dropping the arena causes its owned\n+    /// instances of `T` to be dropped.\n+    _own: marker::PhantomData<T>,\n }\n \n struct TypedArenaChunk<T> {\n@@ -460,6 +453,7 @@ impl<T> TypedArena<T> {\n                 ptr: Cell::new((*chunk).start() as *const T),\n                 end: Cell::new((*chunk).end() as *const T),\n                 first: RefCell::new(chunk),\n+                _own: marker::PhantomData,\n             }\n         }\n     }\n@@ -523,6 +517,41 @@ mod tests {\n         z: i32,\n     }\n \n+    #[test]\n+    fn test_arena_alloc_nested() {\n+        struct Inner { value: u8 }\n+        struct Outer<'a> { inner: &'a Inner }\n+        enum EI<'e> { I(Inner), O(Outer<'e>) }\n+\n+        struct Wrap<'a>(TypedArena<EI<'a>>);\n+\n+        impl<'a> Wrap<'a> {\n+            fn alloc_inner<F:Fn() -> Inner>(&self, f: F) -> &Inner {\n+                let r: &EI = self.0.alloc(EI::I(f()));\n+                if let &EI::I(ref i) = r {\n+                    i\n+                } else {\n+                    panic!(\"mismatch\");\n+                }\n+            }\n+            fn alloc_outer<F:Fn() -> Outer<'a>>(&self, f: F) -> &Outer {\n+                let r: &EI = self.0.alloc(EI::O(f()));\n+                if let &EI::O(ref o) = r {\n+                    o\n+                } else {\n+                    panic!(\"mismatch\");\n+                }\n+            }\n+        }\n+\n+        let arena = Wrap(TypedArena::new());\n+\n+        let result = arena.alloc_outer(|| Outer {\n+            inner: arena.alloc_inner(|| Inner { value: 10 }) });\n+\n+        assert_eq!(result.inner.value, 10);\n+    }\n+\n     #[test]\n     pub fn test_copy() {\n         let arena = TypedArena::new();"}, {"sha": "24523d4dcc9d327c57edba07739f1390a56c9ab8", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -278,7 +278,7 @@ impl<T> Drop for RawItems<T> {\n #[unsafe_destructor]\n impl<K, V> Drop for Node<K, V> {\n     fn drop(&mut self) {\n-        if self.keys.0.is_null() {\n+        if self.keys.ptr.is_null() {\n             // We have already cleaned up this node.\n             return;\n         }\n@@ -292,7 +292,7 @@ impl<K, V> Drop for Node<K, V> {\n             self.destroy();\n         }\n \n-        self.keys.0 = ptr::null_mut();\n+        self.keys.ptr = ptr::null_mut();\n     }\n }\n \n@@ -337,18 +337,18 @@ impl<K, V> Node<K, V> {\n     unsafe fn destroy(&mut self) {\n         let (alignment, size) =\n                 calculate_allocation_generic::<K, V>(self.capacity(), self.is_leaf());\n-        heap::deallocate(self.keys.0 as *mut u8, size, alignment);\n+        heap::deallocate(self.keys.ptr as *mut u8, size, alignment);\n     }\n \n     #[inline]\n     pub fn as_slices<'a>(&'a self) -> (&'a [K], &'a [V]) {\n         unsafe {(\n             mem::transmute(raw::Slice {\n-                data: self.keys.0,\n+                data: self.keys.ptr,\n                 len: self.len()\n             }),\n             mem::transmute(raw::Slice {\n-                data: self.vals.0,\n+                data: self.vals.ptr,\n                 len: self.len()\n             })\n         )}\n@@ -368,7 +368,7 @@ impl<K, V> Node<K, V> {\n         } else {\n             unsafe {\n                 mem::transmute(raw::Slice {\n-                    data: self.edges.0,\n+                    data: self.edges.ptr,\n                     len: self.len() + 1\n                 })\n             }\n@@ -586,7 +586,7 @@ impl <K, V> Node<K, V> {\n \n     /// If the node has any children\n     pub fn is_leaf(&self) -> bool {\n-        self.edges.0.is_null()\n+        self.edges.ptr.is_null()\n     }\n \n     /// if the node has too few elements\n@@ -1064,7 +1064,7 @@ impl<K, V> Node<K, V> {\n                     vals: RawItems::from_slice(self.vals()),\n                     edges: RawItems::from_slice(self.edges()),\n \n-                    ptr: self.keys.0 as *mut u8,\n+                    ptr: self.keys.ptr as *mut u8,\n                     capacity: self.capacity(),\n                     is_leaf: self.is_leaf()\n                 },"}, {"sha": "341d91538adb6773d1adca78b1083a3c80506620", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -57,7 +57,7 @@ use core::default::Default;\n use core::fmt;\n use core::hash::{self, Hash};\n use core::iter::{repeat, FromIterator, IntoIterator};\n-use core::marker::{ContravariantLifetime, InvariantType};\n+use core::marker::{self, ContravariantLifetime, InvariantType};\n use core::mem;\n use core::nonzero::NonZero;\n use core::num::{Int, UnsignedInt};\n@@ -140,6 +140,7 @@ pub struct Vec<T> {\n     ptr: NonZero<*mut T>,\n     len: usize,\n     cap: usize,\n+    _own: marker::PhantomData<T>,\n }\n \n unsafe impl<T: Send> Send for Vec<T> { }\n@@ -166,7 +167,7 @@ impl<T> Vec<T> {\n         // non-null value which is fine since we never call deallocate on the ptr\n         // if cap is 0. The reason for this is because the pointer of a slice\n         // being NULL would break the null pointer optimization for enums.\n-        Vec { ptr: unsafe { NonZero::new(EMPTY as *mut T) }, len: 0, cap: 0 }\n+        unsafe { Vec::from_raw_parts(EMPTY as *mut T, 0, 0) }\n     }\n \n     /// Constructs a new, empty `Vec<T>` with the specified capacity.\n@@ -198,15 +199,15 @@ impl<T> Vec<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: usize) -> Vec<T> {\n         if mem::size_of::<T>() == 0 {\n-            Vec { ptr: unsafe { NonZero::new(EMPTY as *mut T) }, len: 0, cap: usize::MAX }\n+            unsafe { Vec::from_raw_parts(EMPTY as *mut T, 0, usize::MAX) }\n         } else if capacity == 0 {\n             Vec::new()\n         } else {\n             let size = capacity.checked_mul(mem::size_of::<T>())\n                                .expect(\"capacity overflow\");\n             let ptr = unsafe { allocate(size, mem::min_align_of::<T>()) };\n             if ptr.is_null() { ::alloc::oom() }\n-            Vec { ptr: unsafe { NonZero::new(ptr as *mut T) }, len: 0, cap: capacity }\n+            unsafe { Vec::from_raw_parts(ptr as *mut T, 0, capacity) }\n         }\n     }\n \n@@ -247,7 +248,12 @@ impl<T> Vec<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_raw_parts(ptr: *mut T, length: usize,\n                                  capacity: usize) -> Vec<T> {\n-        Vec { ptr: NonZero::new(ptr), len: length, cap: capacity }\n+        Vec {\n+            ptr: NonZero::new(ptr),\n+            len: length,\n+            cap: capacity,\n+            _own: marker::PhantomData,\n+        }\n     }\n \n     /// Creates a vector by copying the elements from a raw pointer.\n@@ -1626,7 +1632,7 @@ impl<T> IntoIter<T> {\n             for _x in self.by_ref() { }\n             let IntoIter { allocation, cap, ptr: _ptr, end: _end } = self;\n             mem::forget(self);\n-            Vec { ptr: NonZero::new(allocation), cap: cap, len: 0 }\n+            Vec::from_raw_parts(allocation, 0, cap)\n         }\n     }\n }"}, {"sha": "da93d4f6ca44e172a8c53d2a5e34260d7ecce63d", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -202,6 +202,24 @@ pub unsafe trait Sync {\n     // Empty\n }\n \n+/// A marker type that indicates to the compiler that the instances\n+/// of the type itself owns instances of the type parameter `T`.\n+///\n+/// This is used to indicate that one or more instances of the type\n+/// `T` could be dropped when instances of the type itself is dropped,\n+/// though that may not be apparent from the other structure of the\n+/// type itself. For example, the type may hold a `*mut T`, which the\n+/// compiler does not automatically treat as owned.\n+#[unstable(feature = \"core\",\n+           reason = \"Newly added to deal with scoping and destructor changes\")]\n+#[lang=\"phantom_data\"]\n+#[derive(PartialEq, Eq, PartialOrd, Ord)]\n+pub struct PhantomData<T: ?Sized>;\n+\n+impl<T: ?Sized> Copy for PhantomData<T> {}\n+impl<T: ?Sized> Clone for PhantomData<T> {\n+    fn clone(&self) -> PhantomData<T> { *self }\n+}\n \n /// A marker type whose type parameter `T` is considered to be\n /// covariant with respect to the type itself. This is (typically)"}, {"sha": "1b8ec048f8de72334a92dad3aa2ddae454545935", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -92,7 +92,7 @@ use mem;\n use clone::Clone;\n use intrinsics;\n use option::Option::{self, Some, None};\n-use marker::{Send, Sized, Sync};\n+use marker::{self, Send, Sized, Sync};\n \n use cmp::{PartialEq, Eq, Ord, PartialOrd};\n use cmp::Ordering::{self, Less, Equal, Greater};\n@@ -522,7 +522,11 @@ impl<T> PartialOrd for *mut T {\n /// Useful for building abstractions like `Vec<T>` or `Box<T>`, which\n /// internally use raw pointers to manage the memory that they own.\n #[unstable(feature = \"core\", reason = \"recently added to this module\")]\n-pub struct Unique<T: ?Sized>(pub *mut T);\n+pub struct Unique<T: ?Sized> {\n+    /// The wrapped `*mut T`.\n+    pub ptr: *mut T,\n+    _own: marker::PhantomData<T>,\n+}\n \n /// `Unique` pointers are `Send` if `T` is `Send` because the data they\n /// reference is unaliased. Note that this aliasing invariant is\n@@ -550,6 +554,13 @@ impl<T> Unique<T> {\n     #[unstable(feature = \"core\",\n                reason = \"recently added to this module\")]\n     pub unsafe fn offset(self, offset: int) -> *mut T {\n-        self.0.offset(offset)\n+        self.ptr.offset(offset)\n     }\n }\n+\n+/// Creates a `Unique` wrapped around `ptr`, taking ownership of the\n+/// data referenced by `ptr`.\n+#[allow(non_snake_case)]\n+pub fn Unique<T: ?Sized>(ptr: *mut T) -> Unique<T> {\n+    Unique { ptr: ptr, _own: marker::PhantomData }\n+}"}, {"sha": "797c150e8591a7d21652e589457738ee0cca0278", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -172,7 +172,7 @@ fn test_set_memory() {\n fn test_unsized_unique() {\n     let xs: &mut [_] = &mut [1, 2, 3];\n     let ptr = Unique(xs as *mut [_]);\n-    let ys = unsafe { &mut *ptr.0 };\n+    let ys = unsafe { &mut *ptr.ptr };\n     let zs: &mut [_] = &mut [1, 2, 3];\n     assert!(ys == zs);\n }"}, {"sha": "ff6400a11dfe8b3b7c620228240dafe590ebc81d", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -45,13 +45,13 @@ pub struct Bytes {\n impl Deref for Bytes {\n     type Target = [u8];\n     fn deref(&self) -> &[u8] {\n-        unsafe { slice::from_raw_parts_mut(self.ptr.0, self.len) }\n+        unsafe { slice::from_raw_parts_mut(self.ptr.ptr, self.len) }\n     }\n }\n \n impl Drop for Bytes {\n     fn drop(&mut self) {\n-        unsafe { libc::free(self.ptr.0 as *mut _); }\n+        unsafe { libc::free(self.ptr.ptr as *mut _); }\n     }\n }\n "}, {"sha": "9962f49dfcfd362ad5f5b9fc75c7c8604732ab7f", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -349,7 +349,7 @@ fn parse_region_<F>(st: &mut PState, conv: &mut F) -> ty::Region where\n       }\n       'f' => {\n         assert_eq!(next(st), '[');\n-        let scope = parse_scope(st);\n+        let scope = parse_destruction_scope_data(st);\n         assert_eq!(next(st), '|');\n         let br = parse_bound_region_(st, conv);\n         assert_eq!(next(st), ']');\n@@ -377,6 +377,10 @@ fn parse_scope(st: &mut PState) -> region::CodeExtent {\n             let node_id = parse_uint(st) as ast::NodeId;\n             region::CodeExtent::Misc(node_id)\n         }\n+        'D' => {\n+            let node_id = parse_uint(st) as ast::NodeId;\n+            region::CodeExtent::DestructionScope(node_id)\n+        }\n         'B' => {\n             let node_id = parse_uint(st) as ast::NodeId;\n             let first_stmt_index = parse_uint(st);\n@@ -389,6 +393,11 @@ fn parse_scope(st: &mut PState) -> region::CodeExtent {\n     }\n }\n \n+fn parse_destruction_scope_data(st: &mut PState) -> region::DestructionScopeData {\n+    let node_id = parse_uint(st) as ast::NodeId;\n+    region::DestructionScopeData::new(node_id)\n+}\n+\n fn parse_opt<'a, 'tcx, T, F>(st: &mut PState<'a, 'tcx>, f: F) -> Option<T> where\n     F: FnOnce(&mut PState<'a, 'tcx>) -> T,\n {"}, {"sha": "640b9649286c1c524b9cda3dacb9aed88fd4df7f", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -251,7 +251,7 @@ pub fn enc_region(w: &mut SeekableMemWriter, cx: &ctxt, r: ty::Region) {\n         }\n         ty::ReFree(ref fr) => {\n             mywrite!(w, \"f[\");\n-            enc_scope(w, cx, fr.scope);\n+            enc_destruction_scope_data(w, fr.scope);\n             mywrite!(w, \"|\");\n             enc_bound_region(w, cx, fr.bound_region);\n             mywrite!(w, \"]\");\n@@ -279,9 +279,15 @@ fn enc_scope(w: &mut SeekableMemWriter, _cx: &ctxt, scope: region::CodeExtent) {\n         region::CodeExtent::Misc(node_id) => mywrite!(w, \"M{}\", node_id),\n         region::CodeExtent::Remainder(region::BlockRemainder {\n             block: b, first_statement_index: i }) => mywrite!(w, \"B{}{}\", b, i),\n+        region::CodeExtent::DestructionScope(node_id) => mywrite!(w, \"D{}\", node_id),\n     }\n }\n \n+fn enc_destruction_scope_data(w: &mut SeekableMemWriter,\n+                              d: region::DestructionScopeData) {\n+    mywrite!(w, \"{}\", d.node_id);\n+}\n+\n fn enc_bound_region(w: &mut SeekableMemWriter, cx: &ctxt, br: ty::BoundRegion) {\n     match br {\n         ty::BrAnon(idx) => {"}, {"sha": "8e3bf0fa28d235fa7584fa919d3c83945c5d76db", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -499,6 +499,12 @@ impl tr for region::CodeExtent {\n     }\n }\n \n+impl tr for region::DestructionScopeData {\n+    fn tr(&self, dcx: &DecodeContext) -> region::DestructionScopeData {\n+        region::DestructionScopeData { node_id: dcx.tr_id(self.node_id) }\n+    }\n+}\n+\n impl tr for ty::BoundRegion {\n     fn tr(&self, dcx: &DecodeContext) -> ty::BoundRegion {\n         match *self {"}, {"sha": "5d7a56ef0e6c6a846963cde229085bf7445b4bea", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -242,7 +242,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     }\n                 }\n                 SubSupConflict(var_origin, _, sub_r, _, sup_r) => {\n-                    debug!(\"processing SubSupConflict\");\n+                    debug!(\"processing SubSupConflict sub: {:?} sup: {:?}\", sub_r, sup_r);\n                     match free_regions_from_same_fn(self.tcx, sub_r, sup_r) {\n                         Some(ref same_frs) => {\n                             var_origins.push(var_origin);\n@@ -304,7 +304,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                         return None\n                     }\n                     assert!(fr1.scope == fr2.scope);\n-                    (fr1.scope.node_id(), fr1, fr2)\n+                    (fr1.scope.node_id, fr1, fr2)\n                 },\n                 _ => return None\n             };\n@@ -709,6 +709,23 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     sup,\n                     \"\");\n             }\n+            infer::SafeDestructor(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"unsafe use of destructor: destructor might be called \\\n+                     while references are dead\");\n+                // FIXME (22171): terms \"super/subregion\" are suboptimal\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"superregion: \",\n+                    sup,\n+                    \"\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"subregion: \",\n+                    sub,\n+                    \"\");\n+            }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n                 self.tcx.sess.span_err(\n                     span,\n@@ -1629,6 +1646,12 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\"...so that the declared lifetime parameter bounds \\\n                                 are satisfied\")[]);\n             }\n+            infer::SafeDestructor(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that references are valid when the destructor \\\n+                     runs\")\n+            }\n         }\n     }\n }"}, {"sha": "41310f055887a65e5120a39a9bcce00a3c8fd4d4", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -215,6 +215,9 @@ pub enum SubregionOrigin<'tcx> {\n \n     // An auto-borrow that does not enclose the expr where it occurs\n     AutoBorrow(Span),\n+\n+    // Region constraint arriving from destructor safety\n+    SafeDestructor(Span),\n }\n \n /// Times when we replace late-bound regions with variables:\n@@ -1197,6 +1200,7 @@ impl<'tcx> SubregionOrigin<'tcx> {\n             CallReturn(a) => a,\n             AddrOf(a) => a,\n             AutoBorrow(a) => a,\n+            SafeDestructor(a) => a,\n         }\n     }\n }\n@@ -1259,6 +1263,7 @@ impl<'tcx> Repr<'tcx> for SubregionOrigin<'tcx> {\n             CallReturn(a) => format!(\"CallReturn({})\", a.repr(tcx)),\n             AddrOf(a) => format!(\"AddrOf({})\", a.repr(tcx)),\n             AutoBorrow(a) => format!(\"AutoBorrow({})\", a.repr(tcx)),\n+            SafeDestructor(a) => format!(\"SafeDestructor({})\", a.repr(tcx)),\n         }\n     }\n }"}, {"sha": "3dba8045d60c88e54ae3476e6563fcd805e730bb", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -760,11 +760,12 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             // A \"free\" region can be interpreted as \"some region\n             // at least as big as the block fr.scope_id\".  So, we can\n             // reasonably compare free regions and scopes:\n-            match self.tcx.region_maps.nearest_common_ancestor(fr.scope, s_id) {\n+            let fr_scope = fr.scope.to_code_extent();\n+            match self.tcx.region_maps.nearest_common_ancestor(fr_scope, s_id) {\n               // if the free region's scope `fr.scope_id` is bigger than\n               // the scope region `s_id`, then the LUB is the free\n               // region itself:\n-              Some(r_id) if r_id == fr.scope => f,\n+              Some(r_id) if r_id == fr_scope => f,\n \n               // otherwise, we don't know what the free region is,\n               // so we must conservatively say the LUB is static:\n@@ -865,8 +866,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 // than the scope `s_id`, then we can say that the GLB\n                 // is the scope `s_id`.  Otherwise, as we do not know\n                 // big the free region is precisely, the GLB is undefined.\n-                match self.tcx.region_maps.nearest_common_ancestor(fr.scope, s_id) {\n-                    Some(r_id) if r_id == fr.scope => Ok(s),\n+                let fr_scope = fr.scope.to_code_extent();\n+                match self.tcx.region_maps.nearest_common_ancestor(fr_scope, s_id) {\n+                    Some(r_id) if r_id == fr_scope => Ok(s),\n                     _ => Err(ty::terr_regions_no_overlap(b, a))\n                 }\n             }\n@@ -915,7 +917,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 Ok(ty::ReFree(*b))\n             } else {\n                 this.intersect_scopes(ty::ReFree(*a), ty::ReFree(*b),\n-                                      a.scope, b.scope)\n+                                      a.scope.to_code_extent(),\n+                                      b.scope.to_code_extent())\n             }\n         }\n     }\n@@ -1396,6 +1399,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             for upper_bound in &upper_bounds {\n                 if !self.is_subregion_of(lower_bound.region,\n                                          upper_bound.region) {\n+                    debug!(\"pushing SubSupConflict sub: {:?} sup: {:?}\",\n+                           lower_bound.region, upper_bound.region);\n                     errors.push(SubSupConflict(\n                         (*self.var_origins.borrow())[node_idx.index as uint].clone(),\n                         lower_bound.origin.clone(),"}, {"sha": "ef72c2242c1e70a48490ba635dad3949a2d6abd0", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -312,6 +312,8 @@ lets_do_this! {\n     ExchangeHeapLangItem,            \"exchange_heap\",           exchange_heap;\n     OwnedBoxLangItem,                \"owned_box\",               owned_box;\n \n+    PhantomDataItem,                 \"phantom_data\",            phantom_data;\n+\n     CovariantTypeItem,               \"covariant_type\",          covariant_type;\n     ContravariantTypeItem,           \"contravariant_type\",      contravariant_type;\n     InvariantTypeItem,               \"invariant_type\",          invariant_type;"}, {"sha": "d4fe09793131f29d8117f8e35942c1762e1874cf", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -112,7 +112,7 @@ use self::VarKind::*;\n use middle::def::*;\n use middle::mem_categorization::Typer;\n use middle::pat_util;\n-use middle::region::CodeExtent;\n+use middle::region;\n use middle::ty;\n use middle::ty::ClosureTyper;\n use lint;\n@@ -1514,7 +1514,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let fn_ret =\n             ty::liberate_late_bound_regions(\n                 self.ir.tcx,\n-                CodeExtent::from_node_id(body.id),\n+                region::DestructionScopeData::new(body.id),\n                 &self.fn_ret(id));\n \n         match fn_ret {"}, {"sha": "fed2f7d92458a009ecd7136e7535c716a7f45871", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -760,7 +760,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         // Region of environment pointer\n         let env_region = ty::ReFree(ty::FreeRegion {\n-            scope: region::CodeExtent::from_node_id(fn_body_id),\n+            // The environment of a closure is guaranteed to\n+            // outlive any bindings introduced in the body of the\n+            // closure itself.\n+            scope: region::DestructionScopeData::new(fn_body_id),\n             bound_region: ty::BrEnv\n         });\n "}, {"sha": "2f0462ab8c338177692ca3314e247c5c3e467e71", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 123, "deletions": 16, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -27,11 +27,66 @@ use syntax::{ast, visit};\n use syntax::ast::{Block, Item, FnDecl, NodeId, Arm, Pat, Stmt, Expr, Local};\n use syntax::ast_util::{stmt_id};\n use syntax::ast_map;\n+use syntax::ptr::P;\n use syntax::visit::{Visitor, FnKind};\n \n /// CodeExtent represents a statically-describable extent that can be\n /// used to bound the lifetime/region for values.\n ///\n+/// `Misc(node_id)`: Any AST node that has any extent at all has the\n+/// `Misc(node_id)` extent. Other variants represent special cases not\n+/// immediately derivable from the abstract syntax tree structure.\n+///\n+/// `DestructionScope(node_id)` represents the extent of destructors\n+/// implicitly-attached to `node_id` that run immediately after the\n+/// expression for `node_id` itself. Not every AST node carries a\n+/// `DestructionScope`, but those that are `terminating_scopes` do;\n+/// see discussion with `RegionMaps`.\n+///\n+/// `Remainder(BlockRemainder { block, statement_index })` represents\n+/// the extent of user code running immediately after the initializer\n+/// expression for the indexed statement, until the end of the block.\n+///\n+/// So: the following code can be broken down into the extents beneath:\n+/// ```\n+/// let a = f().g( 'b: { let x = d(); let y = d(); x.h(y)  }   ) ;\n+/// ```\n+///\n+///                                                              +-+ (D12.)\n+///                                                        +-+       (D11.)\n+///                                              +---------+         (R10.)\n+///                                              +-+                  (D9.)\n+///                                   +----------+                    (M8.)\n+///                                 +----------------------+          (R7.)\n+///                                 +-+                               (D6.)\n+///                      +----------+                                 (M5.)\n+///                    +-----------------------------------+          (M4.)\n+///         +--------------------------------------------------+      (M3.)\n+///         +--+                                                      (M2.)\n+/// +-----------------------------------------------------------+     (M1.)\n+///\n+///  (M1.): Misc extent of the whole `let a = ...;` statement.\n+///  (M2.): Misc extent of the `f()` expression.\n+///  (M3.): Misc extent of the `f().g(..)` expression.\n+///  (M4.): Misc extent of the block labelled `'b:`.\n+///  (M5.): Misc extent of the `let x = d();` statement\n+///  (D6.): DestructionScope for temporaries created during M5.\n+///  (R7.): Remainder extent for block `'b:`, stmt 0 (let x = ...).\n+///  (M8.): Misc Extent of the `let y = d();` statement.\n+///  (D9.): DestructionScope for temporaries created during M8.\n+/// (R10.): Remainder extent for block `'b:`, stmt 1 (let y = ...).\n+/// (D11.): DestructionScope for temporaries and bindings from block `'b:`.\n+/// (D12.): DestructionScope for temporaries created during M1 (e.g. f()).\n+///\n+/// Note that while the above picture shows the destruction scopes\n+/// as following their corresponding misc extents, in the internal\n+/// data structures of the compiler the destruction scopes are\n+/// represented as enclosing parents. This is sound because we use the\n+/// enclosing parent relationship just to ensure that referenced\n+/// values live long enough; phrased another way, the starting point\n+/// of each range is not really the important thing in the above\n+/// picture, but rather the ending point.\n+///\n /// FIXME (pnkfelix): This currently derives `PartialOrd` and `Ord` to\n /// placate the same deriving in `ty::FreeRegion`, but we may want to\n /// actually attach a more meaningful ordering to scopes than the one\n@@ -40,7 +95,24 @@ use syntax::visit::{Visitor, FnKind};\n            RustcDecodable, Debug, Copy)]\n pub enum CodeExtent {\n     Misc(ast::NodeId),\n-    Remainder(BlockRemainder),\n+    DestructionScope(ast::NodeId), // extent of destructors for temporaries of node-id\n+    Remainder(BlockRemainder)\n+}\n+\n+/// extent of destructors for temporaries of node-id\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n+           RustcDecodable, Debug, Copy)]\n+pub struct DestructionScopeData {\n+    pub node_id: ast::NodeId\n+}\n+\n+impl DestructionScopeData {\n+    pub fn new(node_id: ast::NodeId) -> DestructionScopeData {\n+        DestructionScopeData { node_id: node_id }\n+    }\n+    pub fn to_code_extent(&self) -> CodeExtent {\n+        CodeExtent::DestructionScope(self.node_id)\n+    }\n }\n \n /// Represents a subscope of `block` for a binding that is introduced\n@@ -82,6 +154,7 @@ impl CodeExtent {\n         match *self {\n             CodeExtent::Misc(node_id) => node_id,\n             CodeExtent::Remainder(br) => br.block,\n+            CodeExtent::DestructionScope(node_id) => node_id,\n         }\n     }\n \n@@ -95,6 +168,8 @@ impl CodeExtent {\n             CodeExtent::Remainder(br) =>\n                 CodeExtent::Remainder(BlockRemainder {\n                     block: f_id(br.block), first_statement_index: br.first_statement_index }),\n+            CodeExtent::DestructionScope(node_id) =>\n+                CodeExtent::DestructionScope(f_id(node_id)),\n         }\n     }\n \n@@ -105,7 +180,8 @@ impl CodeExtent {\n         match ast_map.find(self.node_id()) {\n             Some(ast_map::NodeBlock(ref blk)) => {\n                 match *self {\n-                    CodeExtent::Misc(_) => Some(blk.span),\n+                    CodeExtent::Misc(_) |\n+                    CodeExtent::DestructionScope(_) => Some(blk.span),\n \n                     CodeExtent::Remainder(r) => {\n                         assert_eq!(r.block, blk.id);\n@@ -455,7 +531,7 @@ impl RegionMaps {\n                 }\n \n                 (ty::ReScope(sub_scope), ty::ReFree(ref fr)) => {\n-                    self.is_subscope_of(sub_scope, fr.scope)\n+                    self.is_subscope_of(sub_scope, fr.scope.to_code_extent())\n                 }\n \n                 (ty::ReFree(sub_fr), ty::ReFree(super_fr)) => {\n@@ -567,7 +643,18 @@ fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &ast::Block) {\n     let prev_cx = visitor.cx;\n \n     let blk_scope = CodeExtent::Misc(blk.id);\n-    record_superlifetime(visitor, blk_scope, blk.span);\n+    // If block was previously marked as a terminating scope during\n+    // the recursive visit of its parent node in the AST, then we need\n+    // to account for the destruction scope representing the extent of\n+    // the destructors that run immediately after the the block itself\n+    // completes.\n+    if visitor.region_maps.terminating_scopes.borrow().contains(&blk_scope) {\n+        let dtor_scope = CodeExtent::DestructionScope(blk.id);\n+        record_superlifetime(visitor, dtor_scope, blk.span);\n+        visitor.region_maps.record_encl_scope(blk_scope, dtor_scope);\n+    } else {\n+        record_superlifetime(visitor, blk_scope, blk.span);\n+    }\n \n     // We treat the tail expression in the block (if any) somewhat\n     // differently from the statements. The issue has to do with\n@@ -675,7 +762,9 @@ fn resolve_stmt(visitor: &mut RegionResolutionVisitor, stmt: &ast::Stmt) {\n     // statement plus its destructors, and thus the extent for which\n     // regions referenced by the destructors need to survive.\n     visitor.region_maps.mark_as_terminating_scope(stmt_scope);\n-    record_superlifetime(visitor, stmt_scope, stmt.span);\n+    let dtor_scope = CodeExtent::DestructionScope(stmt_id);\n+    visitor.region_maps.record_encl_scope(stmt_scope, dtor_scope);\n+    record_superlifetime(visitor, dtor_scope, stmt.span);\n \n     let prev_parent = visitor.cx.parent;\n     visitor.cx.parent = InnermostEnclosingExpr::Some(stmt_id);\n@@ -687,15 +776,30 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n     debug!(\"resolve_expr(expr.id={:?})\", expr.id);\n \n     let expr_scope = CodeExtent::Misc(expr.id);\n-    record_superlifetime(visitor, expr_scope, expr.span);\n+    // If expr was previously marked as a terminating scope during the\n+    // recursive visit of its parent node in the AST, then we need to\n+    // account for the destruction scope representing the extent of\n+    // the destructors that run immediately after the the expression\n+    // itself completes.\n+    if visitor.region_maps.terminating_scopes.borrow().contains(&expr_scope) {\n+        let dtor_scope = CodeExtent::DestructionScope(expr.id);\n+        record_superlifetime(visitor, dtor_scope, expr.span);\n+        visitor.region_maps.record_encl_scope(expr_scope, dtor_scope);\n+    } else {\n+        record_superlifetime(visitor, expr_scope, expr.span);\n+    }\n \n     let prev_cx = visitor.cx;\n     visitor.cx.parent = InnermostEnclosingExpr::Some(expr.id);\n \n     {\n         let region_maps = &mut visitor.region_maps;\n-        let terminating = |id| {\n-            let scope = CodeExtent::from_node_id(id);\n+        let terminating = |e: &P<ast::Expr>| {\n+            let scope = CodeExtent::from_node_id(e.id);\n+            region_maps.mark_as_terminating_scope(scope)\n+        };\n+        let terminating_block = |b: &P<ast::Block>| {\n+            let scope = CodeExtent::from_node_id(b.id);\n             region_maps.mark_as_terminating_scope(scope)\n         };\n         match expr.node {\n@@ -707,26 +811,26 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n             ast::ExprBinary(codemap::Spanned { node: ast::BiOr, .. }, _, ref r) => {\n                 // For shortcircuiting operators, mark the RHS as a terminating\n                 // scope since it only executes conditionally.\n-                terminating(r.id);\n+                terminating(r);\n             }\n \n             ast::ExprIf(_, ref then, Some(ref otherwise)) => {\n-                terminating(then.id);\n-                terminating(otherwise.id);\n+                terminating_block(then);\n+                terminating(otherwise);\n             }\n \n             ast::ExprIf(ref expr, ref then, None) => {\n-                terminating(expr.id);\n-                terminating(then.id);\n+                terminating(expr);\n+                terminating_block(then);\n             }\n \n             ast::ExprLoop(ref body, _) => {\n-                terminating(body.id);\n+                terminating_block(body);\n             }\n \n             ast::ExprWhile(ref expr, ref body, _) => {\n-                terminating(expr.id);\n-                terminating(body.id);\n+                terminating(expr);\n+                terminating_block(body);\n             }\n \n             ast::ExprMatch(..) => {\n@@ -1021,6 +1125,9 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n \n     let body_scope = CodeExtent::from_node_id(body.id);\n     visitor.region_maps.mark_as_terminating_scope(body_scope);\n+    let dtor_scope = CodeExtent::DestructionScope(body.id);\n+    visitor.region_maps.record_encl_scope(body_scope, dtor_scope);\n+    record_superlifetime(visitor, dtor_scope, body.span);\n \n     let outer_cx = visitor.cx;\n "}, {"sha": "e91d7d8c52cde8fcbe52af0d0ce6b4797dde80c3", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -41,7 +41,7 @@ pub enum DefRegion {\n                         /* lifetime decl */ ast::NodeId),\n     DefLateBoundRegion(ty::DebruijnIndex,\n                        /* lifetime decl */ ast::NodeId),\n-    DefFreeRegion(/* block scope */ region::CodeExtent,\n+    DefFreeRegion(/* block scope */ region::DestructionScopeData,\n                   /* lifetime decl */ ast::NodeId),\n }\n \n@@ -81,7 +81,7 @@ enum ScopeChain<'a> {\n     LateScope(&'a Vec<ast::LifetimeDef>, Scope<'a>),\n     /// lifetimes introduced by items within a code block are scoped\n     /// to that block.\n-    BlockScope(region::CodeExtent, Scope<'a>),\n+    BlockScope(region::DestructionScopeData, Scope<'a>),\n     RootScope\n }\n \n@@ -191,7 +191,8 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     }\n \n     fn visit_block(&mut self, b: &ast::Block) {\n-        self.with(BlockScope(region::CodeExtent::from_node_id(b.id), self.scope),\n+        self.with(BlockScope(region::DestructionScopeData::new(b.id),\n+                             self.scope),\n                   |_, this| visit::walk_block(this, b));\n     }\n \n@@ -393,16 +394,23 @@ impl<'a> LifetimeContext<'a> {\n     }\n \n     fn resolve_free_lifetime_ref(&mut self,\n-                                 scope_data: region::CodeExtent,\n+                                 scope_data: region::DestructionScopeData,\n                                  lifetime_ref: &ast::Lifetime,\n                                  scope: Scope) {\n+        debug!(\"resolve_free_lifetime_ref \\\n+                scope_data: {:?} lifetime_ref: {:?} scope: {:?}\",\n+               scope_data, lifetime_ref, scope);\n+\n         // Walk up the scope chain, tracking the outermost free scope,\n         // until we encounter a scope that contains the named lifetime\n         // or we run out of scopes.\n         let mut scope_data = scope_data;\n         let mut scope = scope;\n         let mut search_result = None;\n         loop {\n+            debug!(\"resolve_free_lifetime_ref \\\n+                    scope_data: {:?} scope: {:?} search_result: {:?}\",\n+                   scope_data, scope, search_result);\n             match *scope {\n                 BlockScope(blk_scope_data, s) => {\n                     scope_data = blk_scope_data;"}, {"sha": "8e94991f6569191209d895e292be044befbb952a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 65, "deletions": 20, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -72,6 +72,8 @@ use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::fmt;\n use std::hash::{Hash, Writer, SipHasher, Hasher};\n+#[cfg(stage0)]\n+use std::marker;\n use std::mem;\n use std::ops;\n use std::rc::Rc;\n@@ -931,6 +933,26 @@ pub struct TyS<'tcx> {\n \n     // the maximal depth of any bound regions appearing in this type.\n     region_depth: u32,\n+\n+    // force the lifetime to be invariant to work-around\n+    // region-inference issues with a covariant lifetime.\n+    #[cfg(stage0)]\n+    marker: ShowInvariantLifetime<'tcx>,\n+}\n+\n+#[cfg(stage0)]\n+struct ShowInvariantLifetime<'a>(marker::InvariantLifetime<'a>);\n+#[cfg(stage0)]\n+impl<'a> ShowInvariantLifetime<'a> {\n+    fn new() -> ShowInvariantLifetime<'a> {\n+        ShowInvariantLifetime(marker::InvariantLifetime)\n+    }\n+}\n+#[cfg(stage0)]\n+impl<'a> fmt::Debug for ShowInvariantLifetime<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"InvariantLifetime\")\n+    }\n }\n \n impl fmt::Debug for TypeFlags {\n@@ -939,11 +961,20 @@ impl fmt::Debug for TypeFlags {\n     }\n }\n \n+#[cfg(stage0)]\n impl<'tcx> PartialEq for TyS<'tcx> {\n-    fn eq(&self, other: &TyS<'tcx>) -> bool {\n+    fn eq<'a,'b>(&'a self, other: &'b TyS<'tcx>) -> bool {\n+        let other: &'a TyS<'tcx> = unsafe { mem::transmute(other) };\n         (self as *const _) == (other as *const _)\n     }\n }\n+#[cfg(not(stage0))]\n+impl<'tcx> PartialEq for TyS<'tcx> {\n+    fn eq(&self, other: &TyS<'tcx>) -> bool {\n+        // (self as *const _) == (other as *const _)\n+        (self as *const TyS<'tcx>) == (other as *const TyS<'tcx>)\n+    }\n+}\n impl<'tcx> Eq for TyS<'tcx> {}\n \n impl<'tcx, S: Writer + Hasher> Hash<S> for TyS<'tcx> {\n@@ -1174,7 +1205,9 @@ pub enum Region {\n     /// region parameters.\n     ReFree(FreeRegion),\n \n-    /// A concrete region naming some expression within the current function.\n+    /// A concrete region naming some statically determined extent\n+    /// (e.g. an expression or sequence of statements) within the\n+    /// current function.\n     ReScope(region::CodeExtent),\n \n     /// Static data that has an \"infinite\" lifetime. Top in the region lattice.\n@@ -1296,7 +1329,7 @@ impl Region {\n /// A \"free\" region `fr` can be interpreted as \"some region\n /// at least as big as the scope `fr.scope`\".\n pub struct FreeRegion {\n-    pub scope: region::CodeExtent,\n+    pub scope: region::DestructionScopeData,\n     pub bound_region: BoundRegion\n }\n \n@@ -2473,11 +2506,17 @@ fn intern_ty<'tcx>(type_arena: &'tcx TypedArena<TyS<'tcx>>,\n \n     let flags = FlagComputation::for_sty(&st);\n \n-    let ty = type_arena.alloc(TyS {\n-        sty: st,\n-        flags: flags.flags,\n-        region_depth: flags.depth,\n-    });\n+    let ty = match () {\n+        #[cfg(stage0)]\n+        () => type_arena.alloc(TyS { sty: st,\n+                                     flags: flags.flags,\n+                                     region_depth: flags.depth,\n+                                     marker: ShowInvariantLifetime::new(), }),\n+        #[cfg(not(stage0))]\n+        () => type_arena.alloc(TyS { sty: st,\n+                                     flags: flags.flags,\n+                                     region_depth: flags.depth, }),\n+    };\n \n     debug!(\"Interned type: {:?} Pointer: {:?}\",\n            ty, ty as *const _);\n@@ -4192,12 +4231,16 @@ pub fn ty_region(tcx: &ctxt,\n     }\n }\n \n-pub fn free_region_from_def(free_id: ast::NodeId, def: &RegionParameterDef)\n+pub fn free_region_from_def(outlives_extent: region::DestructionScopeData,\n+                            def: &RegionParameterDef)\n     -> ty::Region\n {\n-    ty::ReFree(ty::FreeRegion { scope: region::CodeExtent::from_node_id(free_id),\n-                                bound_region: ty::BrNamed(def.def_id,\n-                                                          def.name) })\n+    let ret =\n+        ty::ReFree(ty::FreeRegion { scope: outlives_extent,\n+                                    bound_region: ty::BrNamed(def.def_id,\n+                                                              def.name) });\n+    debug!(\"free_region_from_def returns {:?}\", ret);\n+    ret\n }\n \n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n@@ -6252,21 +6295,23 @@ pub fn construct_free_substs<'a,'tcx>(\n     let mut types = VecPerParamSpace::empty();\n     push_types_from_defs(tcx, &mut types, generics.types.as_slice());\n \n+    let free_id_outlive = region::DestructionScopeData::new(free_id);\n+\n     // map bound 'a => free 'a\n     let mut regions = VecPerParamSpace::empty();\n-    push_region_params(&mut regions, free_id, generics.regions.as_slice());\n+    push_region_params(&mut regions, free_id_outlive, generics.regions.as_slice());\n \n     return Substs {\n         types: types,\n         regions: subst::NonerasedRegions(regions)\n     };\n \n     fn push_region_params(regions: &mut VecPerParamSpace<ty::Region>,\n-                          free_id: ast::NodeId,\n+                          all_outlive_extent: region::DestructionScopeData,\n                           region_params: &[RegionParameterDef])\n     {\n         for r in region_params {\n-            regions.push(r.space, ty::free_region_from_def(free_id, r));\n+            regions.push(r.space, ty::free_region_from_def(all_outlive_extent, r));\n         }\n     }\n \n@@ -6295,14 +6340,14 @@ pub fn construct_parameter_environment<'a,'tcx>(\n     //\n \n     let free_substs = construct_free_substs(tcx, generics, free_id);\n-    let free_id_scope = region::CodeExtent::from_node_id(free_id);\n+    let free_id_outlive = region::DestructionScopeData::new(free_id);\n \n     //\n     // Compute the bounds on Self and the type parameters.\n     //\n \n     let bounds = generics.to_bounds(tcx, &free_substs);\n-    let bounds = liberate_late_bound_regions(tcx, free_id_scope, &ty::Binder(bounds));\n+    let bounds = liberate_late_bound_regions(tcx, free_id_outlive, &ty::Binder(bounds));\n     let predicates = bounds.predicates.into_vec();\n \n     //\n@@ -6335,7 +6380,7 @@ pub fn construct_parameter_environment<'a,'tcx>(\n     let unnormalized_env = ty::ParameterEnvironment {\n         tcx: tcx,\n         free_substs: free_substs,\n-        implicit_region_bound: ty::ReScope(free_id_scope),\n+        implicit_region_bound: ty::ReScope(free_id_outlive.to_code_extent()),\n         caller_bounds: predicates,\n         selection_cache: traits::SelectionCache::new(),\n     };\n@@ -6603,14 +6648,14 @@ impl<'tcx> AutoDerefRef<'tcx> {\n /// `scope_id`.\n pub fn liberate_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n-    scope: region::CodeExtent,\n+    all_outlive_scope: region::DestructionScopeData,\n     value: &Binder<T>)\n     -> T\n     where T : TypeFoldable<'tcx> + Repr<'tcx>\n {\n     replace_late_bound_regions(\n         tcx, value,\n-        |br| ty::ReFree(ty::FreeRegion{scope: scope, bound_region: br})).0\n+        |br| ty::ReFree(ty::FreeRegion{scope: all_outlive_scope, bound_region: br})).0\n }\n \n pub fn count_late_bound_regions<'tcx, T>("}, {"sha": "397d27db3b96171dfdb08a033460f341f1688ad5", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -113,6 +113,10 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n         };\n         let scope_decorated_tag = match scope {\n             region::CodeExtent::Misc(_) => tag,\n+            region::CodeExtent::DestructionScope(_) => {\n+                new_string = format!(\"destruction scope surrounding {}\", tag);\n+                new_string.as_slice()\n+            }\n             region::CodeExtent::Remainder(r) => {\n                 new_string = format!(\"block suffix following statement {}\",\n                                      r.first_statement_index);\n@@ -135,7 +139,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n           }\n         };\n \n-        match cx.map.find(fr.scope.node_id()) {\n+        match cx.map.find(fr.scope.node_id) {\n           Some(ast_map::NodeBlock(ref blk)) => {\n               let (msg, opt_span) = explain_span(cx, \"block\", blk.span);\n               (format!(\"{} {}\", prefix, msg), opt_span)\n@@ -921,7 +925,7 @@ impl<'tcx> UserString<'tcx> for ty::Region {\n impl<'tcx> Repr<'tcx> for ty::FreeRegion {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"ReFree({}, {})\",\n-                self.scope.node_id(),\n+                self.scope.repr(tcx),\n                 self.bound_region.repr(tcx))\n     }\n }\n@@ -931,12 +935,23 @@ impl<'tcx> Repr<'tcx> for region::CodeExtent {\n         match *self {\n             region::CodeExtent::Misc(node_id) =>\n                 format!(\"Misc({})\", node_id),\n+            region::CodeExtent::DestructionScope(node_id) =>\n+                format!(\"DestructionScope({})\", node_id),\n             region::CodeExtent::Remainder(rem) =>\n                 format!(\"Remainder({}, {})\", rem.block, rem.first_statement_index),\n         }\n     }\n }\n \n+impl<'tcx> Repr<'tcx> for region::DestructionScopeData {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n+        match *self {\n+            region::DestructionScopeData{ node_id } =>\n+                format!(\"DestructionScopeData {{ node_id: {} }}\", node_id),\n+        }\n+    }\n+}\n+\n impl<'tcx> Repr<'tcx> for ast::DefId {\n     fn repr(&self, tcx: &ctxt) -> String {\n         // Unfortunately, there seems to be no way to attempt to print"}, {"sha": "4e308c5809f45ba96657628d891ba0b2fe36ea52", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -286,7 +286,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                 let loan_scope = match loan_region {\n                     ty::ReScope(scope) => scope,\n \n-                    ty::ReFree(ref fr) => fr.scope,\n+                    ty::ReFree(ref fr) => fr.scope.to_code_extent(),\n \n                     ty::ReStatic => {\n                         // If we get here, an error must have been"}, {"sha": "7105a6cc488821e0e30460cdcc7c83329a69a0e6", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -15,7 +15,7 @@ use diagnostic::Emitter;\n use driver;\n use rustc_resolve as resolve;\n use rustc_typeck::middle::lang_items;\n-use rustc_typeck::middle::region::{self, CodeExtent};\n+use rustc_typeck::middle::region::{self, CodeExtent, DestructionScopeData};\n use rustc_typeck::middle::resolve_lifetime;\n use rustc_typeck::middle::stability;\n use rustc_typeck::middle::subst;\n@@ -325,7 +325,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     pub fn re_free(&self, nid: ast::NodeId, id: u32) -> ty::Region {\n-        ty::ReFree(ty::FreeRegion { scope: CodeExtent::from_node_id(nid),\n+        ty::ReFree(ty::FreeRegion { scope: DestructionScopeData::new(nid),\n                                     bound_region: ty::BrAnon(id)})\n     }\n "}, {"sha": "0913a245c1b50f2c50c2e14866893c1d5520a048", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -2196,7 +2196,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Search for external modules.\n         if namespace == TypeNS {\n-            if let Some(module) = module_.external_module_children.borrow().get(&name).cloned() {\n+            // FIXME (21114): In principle unclear `child` *has* to be lifted.\n+            let child = module_.external_module_children.borrow().get(&name).cloned();\n+            if let Some(module) = child {\n                 let name_bindings =\n                     Rc::new(Resolver::create_name_bindings_from_module(module));\n                 debug!(\"lower name bindings succeeded\");\n@@ -2481,7 +2483,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Finally, search through external children.\n         if namespace == TypeNS {\n-            if let Some(module) = module_.external_module_children.borrow().get(&name).cloned() {\n+            // FIXME (21114): In principle unclear `child` *has* to be lifted.\n+            let child = module_.external_module_children.borrow().get(&name).cloned();\n+            if let Some(module) = child {\n                 let name_bindings =\n                     Rc::new(Resolver::create_name_bindings_from_module(module));\n                 return Success((Target::new(module_,"}, {"sha": "f7e37b6f6331e26546b382ea7cf8a3ad8e4552f7", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -130,12 +130,17 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         // this new AST scope had better be its immediate child.\n         let top_scope = self.top_ast_scope();\n         if top_scope.is_some() {\n-            assert_eq!(self.ccx\n-                           .tcx()\n-                           .region_maps\n-                           .opt_encl_scope(region::CodeExtent::from_node_id(debug_loc.id))\n-                           .map(|s|s.node_id()),\n-                       top_scope);\n+            assert!((self.ccx\n+                     .tcx()\n+                     .region_maps\n+                     .opt_encl_scope(region::CodeExtent::from_node_id(debug_loc.id))\n+                     .map(|s|s.node_id()) == top_scope)\n+                    ||\n+                    (self.ccx\n+                     .tcx()\n+                     .region_maps\n+                     .opt_encl_scope(region::CodeExtent::DestructionScope(debug_loc.id))\n+                     .map(|s|s.node_id()) == top_scope));\n         }\n \n         self.push_scope(CleanupScope::new(AstScopeKind(debug_loc.id),"}, {"sha": "0b7c5b04aaa44d5802f117f8312ed294b6018ad9", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -13,7 +13,7 @@\n use super::{check_fn, Expectation, FnCtxt};\n \n use astconv;\n-use middle::region::CodeExtent;\n+use middle::region;\n use middle::subst;\n use middle::ty::{self, ToPolyTraitRef, Ty};\n use rscope::RegionScope;\n@@ -78,7 +78,9 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     fcx.write_ty(expr.id, closure_type);\n \n     let fn_sig =\n-        ty::liberate_late_bound_regions(fcx.tcx(), CodeExtent::from_node_id(body.id), &fn_ty.sig);\n+        ty::liberate_late_bound_regions(fcx.tcx(),\n+                                        region::DestructionScopeData::new(body.id),\n+                                        &fn_ty.sig);\n \n     check_fn(fcx.ccx,\n              ast::Unsafety::Normal,"}, {"sha": "1be6bf05c9962eceaff15c76ebbc60c74f847195", "filename": "src/librustc_typeck/check/dropck.rs", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -0,0 +1,292 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use check::regionck::{self, Rcx};\n+\n+use middle::infer;\n+use middle::region;\n+use middle::subst;\n+use middle::ty::{self, Ty};\n+use util::ppaux::{Repr};\n+\n+use syntax::codemap::Span;\n+\n+pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n+                                                     typ: ty::Ty<'tcx>,\n+                                                     span: Span,\n+                                                     scope: region::CodeExtent) {\n+    debug!(\"check_safety_of_destructor_if_necessary typ: {} scope: {:?}\",\n+           typ.repr(rcx.tcx()), scope);\n+\n+    // types that have been traversed so far by `traverse_type_if_unseen`\n+    let mut breadcrumbs: Vec<Ty<'tcx>> = Vec::new();\n+\n+    iterate_over_potentially_unsafe_regions_in_type(\n+        rcx,\n+        &mut breadcrumbs,\n+        typ,\n+        span,\n+        scope,\n+        0);\n+}\n+\n+fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n+    rcx: &mut Rcx<'a, 'tcx>,\n+    breadcrumbs: &mut Vec<Ty<'tcx>>,\n+    ty_root: ty::Ty<'tcx>,\n+    span: Span,\n+    scope: region::CodeExtent,\n+    depth: uint)\n+{\n+    let origin = |&:| infer::SubregionOrigin::SafeDestructor(span);\n+    let mut walker = ty_root.walk();\n+    let opt_phantom_data_def_id = rcx.tcx().lang_items.phantom_data();\n+\n+    let destructor_for_type = rcx.tcx().destructor_for_type.borrow();\n+\n+    while let Some(typ) = walker.next() {\n+        // Avoid recursing forever.\n+        if breadcrumbs.contains(&typ) {\n+            continue;\n+        }\n+        breadcrumbs.push(typ);\n+\n+        // If we encounter `PhantomData<T>`, then we should replace it\n+        // with `T`, the type it represents as owned by the\n+        // surrounding context, before doing further analysis.\n+        let typ = if let ty::ty_struct(struct_did, substs) = typ.sty {\n+            if opt_phantom_data_def_id == Some(struct_did) {\n+                let item_type = ty::lookup_item_type(rcx.tcx(), struct_did);\n+                let tp_def = item_type.generics.types\n+                    .opt_get(subst::TypeSpace, 0).unwrap();\n+                let new_typ = substs.type_for_def(tp_def);\n+                debug!(\"replacing phantom {} with {}\",\n+                       typ.repr(rcx.tcx()), new_typ.repr(rcx.tcx()));\n+                new_typ\n+            } else {\n+                typ\n+            }\n+        } else {\n+            typ\n+        };\n+\n+        let opt_type_did = match typ.sty {\n+            ty::ty_struct(struct_did, _) => Some(struct_did),\n+            ty::ty_enum(enum_did, _) => Some(enum_did),\n+            _ => None,\n+        };\n+\n+        let opt_dtor =\n+            opt_type_did.and_then(|did| destructor_for_type.get(&did));\n+\n+        debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n+                {}typ: {} scope: {:?} opt_dtor: {:?}\",\n+               (0..depth).map(|_| ' ').collect::<String>(),\n+               typ.repr(rcx.tcx()), scope, opt_dtor);\n+\n+        // If `typ` has a destructor, then we must ensure that all\n+        // borrowed data reachable via `typ` must outlive the parent\n+        // of `scope`. This is handled below.\n+        //\n+        // However, there is an important special case: by\n+        // parametricity, any generic type parameters have *no* trait\n+        // bounds in the Drop impl can not be used in any way (apart\n+        // from being dropped), and thus we can treat data borrowed\n+        // via such type parameters remains unreachable.\n+        //\n+        // For example, consider `impl<T> Drop for Vec<T> { ... }`,\n+        // which does have to be able to drop instances of `T`, but\n+        // otherwise cannot read data from `T`.\n+        //\n+        // Of course, for the type expression passed in for any such\n+        // unbounded type parameter `T`, we must resume the recursive\n+        // analysis on `T` (since it would be ignored by\n+        // type_must_outlive).\n+        //\n+        // FIXME (pnkfelix): Long term, we could be smart and actually\n+        // feed which generic parameters can be ignored *into* `fn\n+        // type_must_outlive` (or some generalization thereof). But\n+        // for the short term, it probably covers most cases of\n+        // interest to just special case Drop impls where: (1.) there\n+        // are no generic lifetime parameters and (2.)  *all* generic\n+        // type parameters are unbounded.  If both conditions hold, we\n+        // simply skip the `type_must_outlive` call entirely (but\n+        // resume the recursive checking of the type-substructure).\n+\n+        let has_dtor_of_interest;\n+\n+        if let Some(&dtor_method_did) = opt_dtor {\n+            let impl_did = ty::impl_of_method(rcx.tcx(), dtor_method_did)\n+                .unwrap_or_else(|| {\n+                    rcx.tcx().sess.span_bug(\n+                        span, \"no Drop impl found for drop method\")\n+                });\n+\n+            let dtor_typescheme = ty::lookup_item_type(rcx.tcx(), impl_did);\n+            let dtor_generics = dtor_typescheme.generics;\n+\n+            let has_pred_of_interest = dtor_generics.predicates.iter().any(|pred| {\n+                // In `impl<T> Drop where ...`, we automatically\n+                // assume some predicate will be meaningful and thus\n+                // represents a type through which we could reach\n+                // borrowed data. However, there can be implicit\n+                // predicates (namely for Sized), and so we still need\n+                // to walk through and filter out those cases.\n+\n+                let result = match *pred {\n+                    ty::Predicate::Trait(ty::Binder(ref t_pred)) => {\n+                        let def_id = t_pred.trait_ref.def_id;\n+                        match rcx.tcx().lang_items.to_builtin_kind(def_id) {\n+                            Some(ty::BoundSend) |\n+                            Some(ty::BoundSized) |\n+                            Some(ty::BoundCopy) |\n+                            Some(ty::BoundSync) => false,\n+                            _ => true,\n+                        }\n+                    }\n+                    ty::Predicate::Equate(..) |\n+                    ty::Predicate::RegionOutlives(..) |\n+                    ty::Predicate::TypeOutlives(..) |\n+                    ty::Predicate::Projection(..) => {\n+                        // we assume all of these where-clauses may\n+                        // give the drop implementation the capabilty\n+                        // to access borrowed data.\n+                        true\n+                    }\n+                };\n+\n+                if result {\n+                    debug!(\"typ: {} has interesting dtor due to generic preds, e.g. {}\",\n+                           typ.repr(rcx.tcx()), pred.repr(rcx.tcx()));\n+                }\n+\n+                result\n+            });\n+\n+            // In `impl<'a> Drop ...`, we automatically assume\n+            // `'a` is meaningful and thus represents a bound\n+            // through which we could reach borrowed data.\n+            //\n+            // FIXME (pnkfelix): In the future it would be good to\n+            // extend the language to allow the user to express,\n+            // in the impl signature, that a lifetime is not\n+            // actually used (something like `where 'a: ?Live`).\n+            let has_region_param_of_interest =\n+                dtor_generics.has_region_params(subst::TypeSpace);\n+\n+            has_dtor_of_interest =\n+                has_region_param_of_interest ||\n+                has_pred_of_interest;\n+\n+            if has_dtor_of_interest {\n+                debug!(\"typ: {} has interesting dtor, due to \\\n+                        region params: {} or pred: {}\",\n+                       typ.repr(rcx.tcx()),\n+                       has_region_param_of_interest,\n+                       has_pred_of_interest);\n+            } else {\n+                debug!(\"typ: {} has dtor, but it is uninteresting\",\n+                       typ.repr(rcx.tcx()));\n+            }\n+\n+        } else {\n+            debug!(\"typ: {} has no dtor, and thus is uninteresting\",\n+                   typ.repr(rcx.tcx()));\n+            has_dtor_of_interest = false;\n+        }\n+\n+        if has_dtor_of_interest {\n+            // If `typ` has a destructor, then we must ensure that all\n+            // borrowed data reachable via `typ` must outlive the\n+            // parent of `scope`. (It does not suffice for it to\n+            // outlive `scope` because that could imply that the\n+            // borrowed data is torn down in between the end of\n+            // `scope` and when the destructor itself actually runs.)\n+\n+            let parent_region =\n+                match rcx.tcx().region_maps.opt_encl_scope(scope) {\n+                    Some(parent_scope) => ty::ReScope(parent_scope),\n+                    None => rcx.tcx().sess.span_bug(\n+                        span, format!(\"no enclosing scope found for scope: {:?}\",\n+                                      scope).as_slice()),\n+                };\n+\n+            regionck::type_must_outlive(rcx, origin(), typ, parent_region);\n+\n+        } else {\n+            // Okay, `typ` itself is itself not reachable by a\n+            // destructor; but it may contain substructure that has a\n+            // destructor.\n+\n+            match typ.sty {\n+                ty::ty_struct(struct_did, substs) => {\n+                    // Don't recurse; we extract type's substructure,\n+                    // so do not process subparts of type expression.\n+                    walker.skip_current_subtree();\n+\n+                    let fields =\n+                        ty::lookup_struct_fields(rcx.tcx(), struct_did);\n+                    for field in fields.iter() {\n+                        let field_type =\n+                            ty::lookup_field_type(rcx.tcx(),\n+                                                  struct_did,\n+                                                  field.id,\n+                                                  substs);\n+                        iterate_over_potentially_unsafe_regions_in_type(\n+                            rcx,\n+                            breadcrumbs,\n+                            field_type,\n+                            span,\n+                            scope,\n+                            depth+1)\n+                    }\n+                }\n+\n+                ty::ty_enum(enum_did, substs) => {\n+                    // Don't recurse; we extract type's substructure,\n+                    // so do not process subparts of type expression.\n+                    walker.skip_current_subtree();\n+\n+                    let all_variant_info =\n+                        ty::substd_enum_variants(rcx.tcx(),\n+                                                 enum_did,\n+                                                 substs);\n+                    for variant_info in all_variant_info.iter() {\n+                        for argument_type in variant_info.args.iter() {\n+                            iterate_over_potentially_unsafe_regions_in_type(\n+                                rcx,\n+                                breadcrumbs,\n+                                *argument_type,\n+                                span,\n+                                scope,\n+                                depth+1)\n+                        }\n+                    }\n+                }\n+\n+                ty::ty_rptr(..) | ty::ty_ptr(_) | ty::ty_bare_fn(..) => {\n+                    // Don't recurse, since references, pointers,\n+                    // boxes, and bare functions don't own instances\n+                    // of the types appearing within them.\n+                    walker.skip_current_subtree();\n+                }\n+                _ => {}\n+            };\n+\n+            // You might be tempted to pop breadcrumbs here after\n+            // processing type's internals above, but then you hit\n+            // exponential time blowup e.g. on\n+            // compile-fail/huge-struct.rs. Instead, we do not remove\n+            // anything from the breadcrumbs vector during any particular\n+            // traversal, and instead clear it after the whole traversal\n+            // is done.\n+        }\n+    }\n+}"}, {"sha": "cfc04a9a92fb6e4d37cab86cf5ff5d647c70323a", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -525,7 +525,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                             trait_def_id);\n \n         let trait_impls = self.tcx().trait_impls.borrow();\n-        let impl_def_ids = match trait_impls.get(&trait_def_id) {\n+        let impl_def_ids = trait_impls.get(&trait_def_id);\n+        let impl_def_ids = match impl_def_ids {\n             None => { return; }\n             Some(impls) => impls,\n         };"}, {"sha": "d90ed7eda599e2441a284b48aca9ada43bdf18cd", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -90,7 +90,7 @@ use middle::infer;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n use middle::pat_util::{self, pat_id_map};\n-use middle::region::CodeExtent;\n+use middle::region::{self, CodeExtent};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace, TypeSpace};\n use middle::traits;\n use middle::ty::{FnSig, VariantInfo, TypeScheme};\n@@ -127,6 +127,7 @@ use syntax::ptr::P;\n use syntax::visit::{self, Visitor};\n \n mod assoc;\n+pub mod dropck;\n pub mod _match;\n pub mod vtable;\n pub mod writeback;\n@@ -495,7 +496,9 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             let fn_sig =\n                 fn_ty.sig.subst(ccx.tcx, &inh.param_env.free_substs);\n             let fn_sig =\n-                liberate_late_bound_regions(ccx.tcx, CodeExtent::from_node_id(body.id), &fn_sig);\n+                liberate_late_bound_regions(ccx.tcx,\n+                                            region::DestructionScopeData::new(body.id),\n+                                            &fn_sig);\n             let fn_sig =\n                 inh.normalize_associated_types_in(&inh.param_env, body.span, body.id, &fn_sig);\n \n@@ -1686,7 +1689,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let mut bounds_checker = wf::BoundsChecker::new(self,\n                                                         ast_t.span,\n-                                                        CodeExtent::from_node_id(self.body_id),\n+                                                        self.body_id,\n                                                         None);\n         bounds_checker.check_ty(t);\n "}, {"sha": "80f6e3800f7131c375349630172877eb991294e1", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 70, "deletions": 2, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -83,6 +83,7 @@\n //! contents.\n \n use astconv::AstConv;\n+use check::dropck;\n use check::FnCtxt;\n use check::regionmanip;\n use check::vtable;\n@@ -171,6 +172,7 @@ pub struct Rcx<'a, 'tcx: 'a> {\n \n     // id of AST node being analyzed (the subject of the analysis).\n     subject: SubjectNode,\n+\n }\n \n /// Returns the validity region of `def` -- that is, how long is `def` valid?\n@@ -198,7 +200,8 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         Rcx { fcx: fcx,\n               repeating_scope: initial_repeating_scope,\n               subject: subject,\n-              region_bound_pairs: Vec::new() }\n+              region_bound_pairs: Vec::new()\n+        }\n     }\n \n     pub fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n@@ -469,6 +472,10 @@ fn constrain_bindings_in_pat(pat: &ast::Pat, rcx: &mut Rcx) {\n         type_of_node_must_outlive(\n             rcx, infer::BindingTypeIsNotValidAtDecl(span),\n             id, var_region);\n+\n+        let var_scope = tcx.region_maps.var_scope(id);\n+        let typ = rcx.resolve_node_type(id);\n+        dropck::check_safety_of_destructor_if_necessary(rcx, typ, span, var_scope);\n     })\n }\n \n@@ -517,6 +524,40 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             */\n             _ => {}\n         }\n+\n+        // If necessary, constrain destructors in the unadjusted form of this\n+        // expression.\n+        let cmt_result = {\n+            let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+            mc.cat_expr_unadjusted(expr)\n+        };\n+        match cmt_result {\n+            Ok(head_cmt) => {\n+                check_safety_of_rvalue_destructor_if_necessary(rcx,\n+                                                               head_cmt,\n+                                                               expr.span);\n+            }\n+            Err(..) => {\n+                rcx.fcx.tcx().sess.span_note(expr.span,\n+                                             \"cat_expr_unadjusted Errd during dtor check\");\n+            }\n+        }\n+    }\n+\n+    // If necessary, constrain destructors in this expression. This will be\n+    // the adjusted form if there is an adjustment.\n+    let cmt_result = {\n+        let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+        mc.cat_expr(expr)\n+    };\n+    match cmt_result {\n+        Ok(head_cmt) => {\n+            check_safety_of_rvalue_destructor_if_necessary(rcx, head_cmt, expr.span);\n+        }\n+        Err(..) => {\n+            rcx.fcx.tcx().sess.span_note(expr.span,\n+                                         \"cat_expr Errd during dtor check\");\n+        }\n     }\n \n     match expr.node {\n@@ -995,6 +1036,33 @@ pub fn mk_subregion_due_to_dereference(rcx: &mut Rcx,\n                     minimum_lifetime, maximum_lifetime)\n }\n \n+fn check_safety_of_rvalue_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n+                                                            cmt: mc::cmt<'tcx>,\n+                                                            span: Span) {\n+    match cmt.cat {\n+        mc::cat_rvalue(region) => {\n+            match region {\n+                ty::ReScope(rvalue_scope) => {\n+                    let typ = rcx.resolve_type(cmt.ty);\n+                    dropck::check_safety_of_destructor_if_necessary(rcx,\n+                                                                    typ,\n+                                                                    span,\n+                                                                    rvalue_scope);\n+                }\n+                ty::ReStatic => {}\n+                region => {\n+                    rcx.tcx()\n+                       .sess\n+                       .span_bug(span,\n+                                 format!(\"unexpected rvalue region in rvalue \\\n+                                          destructor safety checking: `{}`\",\n+                                         region.repr(rcx.tcx())).as_slice());\n+                }\n+            }\n+        }\n+        _ => {}\n+    }\n+}\n \n /// Invoked on any index expression that occurs. Checks that if this is a slice being indexed, the\n /// lifetime of the pointer includes the deref expr.\n@@ -1404,7 +1472,7 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n }\n \n /// Ensures that all borrowed data reachable via `ty` outlives `region`.\n-fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n+pub fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                origin: infer::SubregionOrigin<'tcx>,\n                                ty: Ty<'tcx>,\n                                region: ty::Region)"}, {"sha": "923614f9e8a74c7a7dbb3634cda1b07613b06e22", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -145,9 +145,11 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             let variants = lookup_fields(fcx);\n             let mut bounds_checker = BoundsChecker::new(fcx,\n                                                         item.span,\n-                                                        region::CodeExtent::from_node_id(item.id),\n+                                                        item.id,\n                                                         Some(&mut this.cache));\n-            for variant in &variants {\n+            debug!(\"check_type_defn at bounds_checker.scope: {:?}\", bounds_checker.scope);\n+\n+             for variant in &variants {\n                 for field in &variant.fields {\n                     // Regions are checked below.\n                     bounds_checker.check_traits_in_ty(field.ty);\n@@ -180,8 +182,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         self.with_fcx(item, |this, fcx| {\n             let mut bounds_checker = BoundsChecker::new(fcx,\n                                                         item.span,\n-                                                        region::CodeExtent::from_node_id(item.id),\n+                                                        item.id,\n                                                         Some(&mut this.cache));\n+            debug!(\"check_item_type at bounds_checker.scope: {:?}\", bounds_checker.scope);\n \n             let type_scheme = ty::lookup_item_type(fcx.tcx(), local_def(item.id));\n             let item_ty = fcx.instantiate_type_scheme(item.span,\n@@ -196,12 +199,11 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                   item: &ast::Item)\n     {\n         self.with_fcx(item, |this, fcx| {\n-            let item_scope = region::CodeExtent::from_node_id(item.id);\n-\n             let mut bounds_checker = BoundsChecker::new(fcx,\n                                                         item.span,\n-                                                        item_scope,\n+                                                        item.id,\n                                                         Some(&mut this.cache));\n+            debug!(\"check_impl at bounds_checker.scope: {:?}\", bounds_checker.scope);\n \n             // Find the impl self type as seen from the \"inside\" --\n             // that is, with all type parameters converted from bound\n@@ -383,15 +385,20 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n pub struct BoundsChecker<'cx,'tcx:'cx> {\n     fcx: &'cx FnCtxt<'cx,'tcx>,\n     span: Span,\n-    scope: region::CodeExtent,\n+\n+    // This field is often attached to item impls; it is not clear\n+    // that `CodeExtent` is well-defined for such nodes, so pnkfelix\n+    // has left it as a NodeId rather than porting to CodeExtent.\n+    scope: ast::NodeId,\n+\n     binding_count: uint,\n     cache: Option<&'cx mut HashSet<Ty<'tcx>>>,\n }\n \n impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n     pub fn new(fcx: &'cx FnCtxt<'cx,'tcx>,\n                span: Span,\n-               scope: region::CodeExtent,\n+               scope: ast::NodeId,\n                cache: Option<&'cx mut HashSet<Ty<'tcx>>>)\n                -> BoundsChecker<'cx,'tcx> {\n         BoundsChecker { fcx: fcx, span: span, scope: scope,\n@@ -446,9 +453,12 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n         where T : TypeFoldable<'tcx> + Repr<'tcx>\n     {\n         self.binding_count += 1;\n-        let value = liberate_late_bound_regions(self.fcx.tcx(), self.scope, binder);\n-        debug!(\"BoundsChecker::fold_binder: late-bound regions replaced: {}\",\n-               value.repr(self.tcx()));\n+        let value = liberate_late_bound_regions(\n+            self.fcx.tcx(),\n+            region::DestructionScopeData::new(self.scope),\n+            binder);\n+        debug!(\"BoundsChecker::fold_binder: late-bound regions replaced: {} at scope: {:?}\",\n+               value.repr(self.tcx()), self.scope);\n         let value = value.fold_with(self);\n         self.binding_count -= 1;\n         ty::Binder(value)"}, {"sha": "55fa47760bbf0a471b7a64d39958d14510ee29cd", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -1564,7 +1564,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n             _ => typ,\n         };\n \n-        let body_scope = region::CodeExtent::from_node_id(body_id);\n+        let body_scope = region::DestructionScopeData::new(body_id);\n \n         // \"Required type\" comes from the trait definition. It may\n         // contain late-bound regions from the method, but not the\n@@ -1608,7 +1608,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n \n     fn liberate_early_bound_regions<'tcx,T>(\n         tcx: &ty::ctxt<'tcx>,\n-        scope: region::CodeExtent,\n+        scope: region::DestructionScopeData,\n         value: &T)\n         -> T\n         where T : TypeFoldable<'tcx> + Repr<'tcx>"}, {"sha": "219da8f44eb31948243bbf03278aafd668c64213", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -50,7 +50,8 @@\n //!     ```rust\n //!     use std::old_io as io;\n //!\n-//!     for line in io::stdin().lock().lines() {\n+//!     let mut stdin = io::stdin();\n+//!     for line in stdin.lock().lines() {\n //!         print!(\"{}\", line.unwrap());\n //!     }\n //!     ```"}, {"sha": "4b3811bbe38daaac3daf184b6289d38644eea9e9", "filename": "src/libstd/old_io/stdio.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Flibstd%2Fold_io%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Flibstd%2Fold_io%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fstdio.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -143,7 +143,8 @@ impl StdinReader {\n     /// ```rust\n     /// use std::old_io;\n     ///\n-    /// for line in old_io::stdin().lock().lines() {\n+    /// let mut stdin = old_io::stdin();\n+    /// for line in stdin.lock().lines() {\n     ///     println!(\"{}\", line.unwrap());\n     /// }\n     /// ```"}, {"sha": "dd1ad413a3d279a873f299ec853c7e03dbf68c1a", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -19,5 +19,6 @@ pub type header_map = HashMap<String, Rc<RefCell<Vec<Rc<String>>>>>;\n \n // the unused ty param is necessary so this gets monomorphized\n pub fn request<T>(req: &header_map) {\n-  let _x = req[\"METHOD\".to_string()].clone().borrow().clone()[0].clone();\n+  let data = req[\"METHOD\".to_string()].clone();\n+  let _x = data.borrow().clone()[0].clone();\n }"}, {"sha": "74d2168797296f12dd740477c948331911e055e9", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -295,7 +295,9 @@ fn main() {\n         let fd = std::old_io::File::open(&Path::new(\"shootout-k-nucleotide.data\"));\n         get_sequence(&mut std::old_io::BufferedReader::new(fd), \">THREE\")\n     } else {\n-        get_sequence(&mut *std::old_io::stdin().lock(), \">THREE\")\n+        let mut stdin = std::old_io::stdin();\n+        let mut stdin = stdin.lock();\n+        get_sequence(&mut *stdin, \">THREE\")\n     };\n     let input = Arc::new(input);\n "}, {"sha": "c5a64db95e6a3071632a5a3cfdbae46ab3309f28", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -274,7 +274,9 @@ fn main() {\n     let mut sudoku = if use_default {\n         Sudoku::from_vec(&DEFAULT_SUDOKU)\n     } else {\n-        Sudoku::read(&mut *old_io::stdin().lock())\n+        let mut stdin = old_io::stdin();\n+        let mut stdin = stdin.lock();\n+        Sudoku::read(&mut *stdin)\n     };\n     sudoku.solve();\n     sudoku.write(&mut old_io::stdout());"}, {"sha": "0836cd1695de38e62625eca6a46143a950d20949", "filename": "src/test/compile-fail/destructor-restrictions.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Fcompile-fail%2Fdestructor-restrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Fcompile-fail%2Fdestructor-restrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdestructor-restrictions.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests the new destructor semantics.\n+\n+use std::cell::RefCell;\n+\n+fn main() {\n+    let b = {\n+        let a = Box::new(RefCell::new(4i8));\n+        *a.borrow() + 1i8    //~ ERROR `*a` does not live long enough\n+    };\n+    println!(\"{}\", b);\n+}"}, {"sha": "3aa2fae282693fd3b42bdfe69ae64e7012c6f11a", "filename": "src/test/compile-fail/dropck_arr_cycle_checked.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Fcompile-fail%2Fdropck_arr_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Fcompile-fail%2Fdropck_arr_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_arr_cycle_checked.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Reject mixing cyclic structure and Drop when using fixed length\n+// arrays.\n+//\n+// (Compare against compile-fail/dropck_vec_cycle_checked.rs)\n+\n+#![feature(unsafe_destructor)]\n+\n+use std::cell::Cell;\n+use id::Id;\n+\n+mod s {\n+    #![allow(unstable)]\n+    use std::sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n+\n+    static S_COUNT: AtomicUint = ATOMIC_UINT_INIT;\n+\n+    pub fn next_count() -> usize {\n+        S_COUNT.fetch_add(1, Ordering::SeqCst) + 1\n+    }\n+}\n+\n+mod id {\n+    use s;\n+    #[derive(Debug)]\n+    pub struct Id {\n+        orig_count: usize,\n+        count: usize,\n+    }\n+\n+    impl Id {\n+        pub fn new() -> Id {\n+            let c = s::next_count();\n+            println!(\"building Id {}\", c);\n+            Id { orig_count: c, count: c }\n+        }\n+        pub fn count(&self) -> usize {\n+            println!(\"Id::count on {} returns {}\", self.orig_count, self.count);\n+            self.count\n+        }\n+    }\n+\n+    impl Drop for Id {\n+        fn drop(&mut self) {\n+            println!(\"dropping Id {}\", self.count);\n+            self.count = 0;\n+        }\n+    }\n+}\n+\n+trait HasId {\n+    fn count(&self) -> usize;\n+}\n+\n+#[derive(Debug)]\n+struct CheckId<T:HasId> {\n+    v: T\n+}\n+\n+#[allow(non_snake_case)]\n+fn CheckId<T:HasId>(t: T) -> CheckId<T> { CheckId{ v: t } }\n+\n+#[unsafe_destructor]\n+impl<T:HasId> Drop for CheckId<T> {\n+    fn drop(&mut self) {\n+        assert!(self.v.count() > 0);\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct B<'a> {\n+    id: Id,\n+    a: [CheckId<Cell<Option<&'a B<'a>>>>; 2]\n+}\n+\n+impl<'a> HasId for Cell<Option<&'a B<'a>>> {\n+    fn count(&self) -> usize {\n+        match self.get() {\n+            None => 1,\n+            Some(b) => b.id.count(),\n+        }\n+    }\n+}\n+\n+impl<'a> B<'a> {\n+    fn new() -> B<'a> {\n+        B { id: Id::new(), a: [CheckId(Cell::new(None)), CheckId(Cell::new(None))] }\n+    }\n+}\n+\n+fn f() {\n+    let (b1, b2, b3);\n+    b1 = B::new();\n+    b2 = B::new();\n+    b3 = B::new();\n+    b1.a[0].v.set(Some(&b2)); //~ ERROR `b2` does not live long enough\n+    b1.a[1].v.set(Some(&b3)); //~ ERROR `b3` does not live long enough\n+    b2.a[0].v.set(Some(&b2)); //~ ERROR `b2` does not live long enough\n+    b2.a[1].v.set(Some(&b3)); //~ ERROR `b3` does not live long enough\n+    b3.a[0].v.set(Some(&b1)); //~ ERROR `b1` does not live long enough\n+    b3.a[1].v.set(Some(&b2)); //~ ERROR `b2` does not live long enough\n+}\n+\n+fn main() {\n+    f();\n+}"}, {"sha": "b9df71322ad83a240b2d95ae5a0a2dd6cdf10e0a", "filename": "src/test/compile-fail/dropck_direct_cycle_with_drop.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Fcompile-fail%2Fdropck_direct_cycle_with_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Fcompile-fail%2Fdropck_direct_cycle_with_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_direct_cycle_with_drop.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A simple example of an unsound mixing of cyclic structure and Drop.\n+//\n+// Each `D` has a name and an optional reference to another `D`\n+// sibling, but also implements a drop method that prints out its own\n+// name as well as the name of its sibling.\n+//\n+// By setting up a cyclic structure, the drop code cannot possibly\n+// work. Therefore this code must be rejected.\n+//\n+// (As it turns out, essentially any attempt to install a sibling here\n+//  will be rejected, regardless of whether it forms a cyclic\n+//  structure or not. This is because the use of the same lifetime\n+//  `'a` in `&'a D<'a>` cannot be satisfied when `D<'a>` implements\n+//  `Drop`.)\n+\n+#![feature(unsafe_destructor)]\n+\n+use std::cell::Cell;\n+\n+struct D<'a> {\n+    name: String,\n+    p: Cell<Option<&'a D<'a>>>,\n+}\n+\n+impl<'a> D<'a> {\n+    fn new(name: String) -> D<'a> { D { name: name, p: Cell::new(None) } }\n+}\n+\n+#[unsafe_destructor]\n+impl<'a> Drop for D<'a> {\n+    fn drop(&mut self) {\n+        println!(\"dropping {} whose sibling is {:?}\",\n+                 self.name, self.p.get().map(|d| &d.name));\n+    }\n+}\n+\n+fn g() {\n+    let (d1, d2) = (D::new(format!(\"d1\")), D::new(format!(\"d2\")));\n+    d1.p.set(Some(&d2)); //~ ERROR `d2` does not live long enough\n+    d2.p.set(Some(&d1)); //~ ERROR `d1` does not live long enough\n+}\n+\n+fn main() {\n+    g();\n+}"}, {"sha": "74e3c724b676daa75bec403ad02e31762476faed", "filename": "src/test/compile-fail/dropck_tarena_cycle_checked.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_cycle_checked.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -0,0 +1,130 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Reject mixing cyclic structure and Drop when using TypedArena.\n+//\n+// (Compare against compile-fail/dropck_vec_cycle_checked.rs)\n+//\n+// (Also compare against compile-fail/dropck_tarena_unsound_drop.rs,\n+//  which is a reduction of this code to more directly show the reason\n+//  for the error message we see here.)\n+\n+#![allow(unstable)]\n+#![feature(unsafe_destructor)]\n+\n+extern crate arena;\n+\n+use arena::TypedArena;\n+use std::cell::Cell;\n+use id::Id;\n+\n+mod s {\n+    #![allow(unstable)]\n+    use std::sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n+\n+    static S_COUNT: AtomicUint = ATOMIC_UINT_INIT;\n+\n+    pub fn next_count() -> usize {\n+        S_COUNT.fetch_add(1, Ordering::SeqCst) + 1\n+    }\n+}\n+\n+mod id {\n+    use s;\n+    #[derive(Debug)]\n+    pub struct Id {\n+        orig_count: usize,\n+        count: usize,\n+    }\n+\n+    impl Id {\n+        pub fn new() -> Id {\n+            let c = s::next_count();\n+            println!(\"building Id {}\", c);\n+            Id { orig_count: c, count: c }\n+        }\n+        pub fn count(&self) -> usize {\n+            println!(\"Id::count on {} returns {}\", self.orig_count, self.count);\n+            self.count\n+        }\n+    }\n+\n+    impl Drop for Id {\n+        fn drop(&mut self) {\n+            println!(\"dropping Id {}\", self.count);\n+            self.count = 0;\n+        }\n+    }\n+}\n+\n+trait HasId {\n+    fn count(&self) -> usize;\n+}\n+\n+#[derive(Debug)]\n+struct CheckId<T:HasId> {\n+    v: T\n+}\n+\n+#[allow(non_snake_case)]\n+fn CheckId<T:HasId>(t: T) -> CheckId<T> { CheckId{ v: t } }\n+\n+#[unsafe_destructor]\n+impl<T:HasId> Drop for CheckId<T> {\n+    fn drop(&mut self) {\n+        assert!(self.v.count() > 0);\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct C<'a> {\n+    id: Id,\n+    v: Vec<CheckId<Cell<Option<&'a C<'a>>>>>,\n+}\n+\n+impl<'a> HasId for Cell<Option<&'a C<'a>>> {\n+    fn count(&self) -> usize {\n+        match self.get() {\n+            None => 1,\n+            Some(c) => c.id.count(),\n+        }\n+    }\n+}\n+\n+impl<'a> C<'a> {\n+    fn new() -> C<'a> {\n+        C { id: Id::new(), v: Vec::new() }\n+    }\n+}\n+\n+fn f<'a>(arena: &'a TypedArena<C<'a>>) {\n+    let c1 = arena.alloc(C::new());\n+    let c2 = arena.alloc(C::new());\n+    let c3 = arena.alloc(C::new());\n+\n+    c1.v.push(CheckId(Cell::new(None)));\n+    c1.v.push(CheckId(Cell::new(None)));\n+    c2.v.push(CheckId(Cell::new(None)));\n+    c2.v.push(CheckId(Cell::new(None)));\n+    c3.v.push(CheckId(Cell::new(None)));\n+    c3.v.push(CheckId(Cell::new(None)));\n+\n+    c1.v[0].v.set(Some(c2));\n+    c1.v[1].v.set(Some(c3));\n+    c2.v[0].v.set(Some(c2));\n+    c2.v[1].v.set(Some(c3));\n+    c3.v[0].v.set(Some(c1));\n+    c3.v[1].v.set(Some(c2));\n+}\n+\n+fn main() {\n+    let arena = TypedArena::new();\n+    f(&arena); //~ ERROR `arena` does not live long enough\n+}"}, {"sha": "64d77e97fa7f6f2f49def9a47c6a67bf20b54c9f", "filename": "src/test/compile-fail/dropck_tarena_unsound_drop.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_unsound_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_unsound_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_unsound_drop.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that a arena (TypedArena) cannot carry elements whose drop\n+// methods might access borrowed data of lifetime that does not\n+// strictly outlive the arena itself.\n+//\n+// Compare against run-pass/dropck_tarena_sound_drop.rs, which shows a\n+// similar setup, but loosens `f` so that the struct `C<'a>` can be\n+// fed a lifetime longer than that of the arena.\n+//\n+// (Also compare against dropck_tarena_cycle_checked.rs, from which\n+// this was reduced to better understand its error message.)\n+\n+#![allow(unstable)]\n+#![feature(unsafe_destructor)]\n+\n+extern crate arena;\n+\n+use arena::TypedArena;\n+\n+trait HasId { fn count(&self) -> usize; }\n+\n+struct CheckId<T:HasId> { v: T }\n+\n+// In the code below, the impl of HasId for `&'a usize` does not\n+// actually access the borrowed data, but the point is that the\n+// interface to CheckId does not (and cannot) know that, and therefore\n+// when encountering the a value V of type CheckId<S>, we must\n+// conservatively force the type S to strictly outlive V.\n+#[unsafe_destructor]\n+impl<T:HasId> Drop for CheckId<T> {\n+    fn drop(&mut self) {\n+        assert!(self.v.count() > 0);\n+    }\n+}\n+\n+struct C<'a> { v: CheckId<&'a usize>, }\n+\n+impl<'a> HasId for &'a usize { fn count(&self) -> usize { 1 } }\n+\n+fn f<'a>(_arena: &'a TypedArena<C<'a>>) {}\n+\n+fn main() {\n+    let arena: TypedArena<C> = TypedArena::new();\n+    f(&arena); //~ ERROR `arena` does not live long enough\n+}"}, {"sha": "3f69c7d1a9c3ee1755f3bb3682fcf9b5be7ba572", "filename": "src/test/compile-fail/dropck_vec_cycle_checked.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Fcompile-fail%2Fdropck_vec_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Fcompile-fail%2Fdropck_vec_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_vec_cycle_checked.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -0,0 +1,122 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Reject mixing cyclic structure and Drop when using Vec.\n+//\n+// (Compare against compile-fail/dropck_arr_cycle_checked.rs)\n+\n+#![feature(unsafe_destructor)]\n+\n+use std::cell::Cell;\n+use id::Id;\n+\n+mod s {\n+    #![allow(unstable)]\n+    use std::sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n+\n+    static S_COUNT: AtomicUint = ATOMIC_UINT_INIT;\n+\n+    pub fn next_count() -> usize {\n+        S_COUNT.fetch_add(1, Ordering::SeqCst) + 1\n+    }\n+}\n+\n+mod id {\n+    use s;\n+    #[derive(Debug)]\n+    pub struct Id {\n+        orig_count: usize,\n+        count: usize,\n+    }\n+\n+    impl Id {\n+        pub fn new() -> Id {\n+            let c = s::next_count();\n+            println!(\"building Id {}\", c);\n+            Id { orig_count: c, count: c }\n+        }\n+        pub fn count(&self) -> usize {\n+            println!(\"Id::count on {} returns {}\", self.orig_count, self.count);\n+            self.count\n+        }\n+    }\n+\n+    impl Drop for Id {\n+        fn drop(&mut self) {\n+            println!(\"dropping Id {}\", self.count);\n+            self.count = 0;\n+        }\n+    }\n+}\n+\n+trait HasId {\n+    fn count(&self) -> usize;\n+}\n+\n+#[derive(Debug)]\n+struct CheckId<T:HasId> {\n+    v: T\n+}\n+\n+#[allow(non_snake_case)]\n+fn CheckId<T:HasId>(t: T) -> CheckId<T> { CheckId{ v: t } }\n+\n+#[unsafe_destructor]\n+impl<T:HasId> Drop for CheckId<T> {\n+    fn drop(&mut self) {\n+        assert!(self.v.count() > 0);\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct C<'a> {\n+    id: Id,\n+    v: Vec<CheckId<Cell<Option<&'a C<'a>>>>>,\n+}\n+\n+impl<'a> HasId for Cell<Option<&'a C<'a>>> {\n+    fn count(&self) -> usize {\n+        match self.get() {\n+            None => 1,\n+            Some(c) => c.id.count(),\n+        }\n+    }\n+}\n+\n+impl<'a> C<'a> {\n+    fn new() -> C<'a> {\n+        C { id: Id::new(), v: Vec::new() }\n+    }\n+}\n+\n+fn f() {\n+    let (mut c1, mut c2, mut c3);\n+    c1 = C::new();\n+    c2 = C::new();\n+    c3 = C::new();\n+\n+    c1.v.push(CheckId(Cell::new(None)));\n+    c1.v.push(CheckId(Cell::new(None)));\n+    c2.v.push(CheckId(Cell::new(None)));\n+    c2.v.push(CheckId(Cell::new(None)));\n+    c3.v.push(CheckId(Cell::new(None)));\n+    c3.v.push(CheckId(Cell::new(None)));\n+\n+    c1.v[0].v.set(Some(&c2)); //~ ERROR `c2` does not live long enough\n+    c1.v[1].v.set(Some(&c3)); //~ ERROR `c3` does not live long enough\n+    c2.v[0].v.set(Some(&c2)); //~ ERROR `c2` does not live long enough\n+    c2.v[1].v.set(Some(&c3)); //~ ERROR `c3` does not live long enough\n+    c3.v[0].v.set(Some(&c1)); //~ ERROR `c1` does not live long enough\n+    c3.v[1].v.set(Some(&c2)); //~ ERROR `c2` does not live long enough\n+}\n+\n+fn main() {\n+    f();\n+}"}, {"sha": "6aaf51278afd8ac1d1c77294b8789f617b90d83f", "filename": "src/test/compile-fail/vec-must-not-hide-type-from-dropck.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Fcompile-fail%2Fvec-must-not-hide-type-from-dropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Fcompile-fail%2Fvec-must-not-hide-type-from-dropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-must-not-hide-type-from-dropck.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -0,0 +1,135 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Checking that `Vec<T>` cannot hide lifetimes within `T` when `T`\n+// implements `Drop` and might access methods of values that have\n+// since been deallocated.\n+//\n+// In this case, the values in question hold (non-zero) unique-ids\n+// that zero themselves out when dropped, and are wrapped in another\n+// type with a destructor that asserts that the ids it references are\n+// indeed non-zero (i.e., effectively checking that the id's are not\n+// dropped while there are still any outstanding references).\n+//\n+// However, the values in question are also formed into a\n+// cyclic-structure, ensuring that there is no way for all of the\n+// conditions above to be satisfied, meaning that if the dropck is\n+// sound, it should reject this code.\n+\n+#![feature(unsafe_destructor)]\n+\n+use std::cell::Cell;\n+use id::Id;\n+\n+mod s {\n+    #![allow(unstable)]\n+    use std::sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n+\n+    static S_COUNT: AtomicUint = ATOMIC_UINT_INIT;\n+\n+    /// generates globally unique count (global across the current\n+    /// process, that is)\n+    pub fn next_count() -> usize {\n+        S_COUNT.fetch_add(1, Ordering::SeqCst) + 1\n+    }\n+}\n+\n+mod id {\n+    use s;\n+\n+    /// Id represents a globally unique identifier (global across the\n+    /// current process, that is). When dropped, it automatically\n+    /// clears its `count` field, but leaves `orig_count` untouched,\n+    /// so that if there are subsequent (erroneous) invocations of its\n+    /// method (which is unsound), we can observe it by seeing that\n+    /// the `count` is 0 while the `orig_count` is non-zero.\n+    #[derive(Debug)]\n+    pub struct Id {\n+        orig_count: usize,\n+        count: usize,\n+    }\n+\n+    impl Id {\n+        /// Creates an `Id` with a globally unique count.\n+        pub fn new() -> Id {\n+            let c = s::next_count();\n+            println!(\"building Id {}\", c);\n+            Id { orig_count: c, count: c }\n+        }\n+        /// returns the `count` of self; should be non-zero if\n+        /// everything is working.\n+        pub fn count(&self) -> usize {\n+            println!(\"Id::count on {} returns {}\", self.orig_count, self.count);\n+            self.count\n+        }\n+    }\n+\n+    impl Drop for Id {\n+        fn drop(&mut self) {\n+            println!(\"dropping Id {}\", self.count);\n+            self.count = 0;\n+        }\n+    }\n+}\n+\n+trait HasId {\n+    fn count(&self) -> usize;\n+}\n+\n+#[derive(Debug)]\n+struct CheckId<T:HasId> {\n+    v: T\n+}\n+\n+#[allow(non_snake_case)]\n+fn CheckId<T:HasId>(t: T) -> CheckId<T> { CheckId{ v: t } }\n+\n+#[unsafe_destructor]\n+impl<T:HasId> Drop for CheckId<T> {\n+    fn drop(&mut self) {\n+        assert!(self.v.count() > 0);\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct C<'a> {\n+    id: Id,\n+    v: Vec<CheckId<Cell<Option<&'a C<'a>>>>>,\n+}\n+\n+impl<'a> HasId for Cell<Option<&'a C<'a>>> {\n+    fn count(&self) -> usize {\n+        match self.get() {\n+            None => 1,\n+            Some(c) => c.id.count(),\n+        }\n+    }\n+}\n+\n+impl<'a> C<'a> {\n+    fn new() -> C<'a> {\n+        C { id: Id::new(), v: Vec::new() }\n+    }\n+}\n+\n+fn f() {\n+    let (mut c1, mut c2);\n+    c1 = C::new();\n+    c2 = C::new();\n+\n+    c1.v.push(CheckId(Cell::new(None)));\n+    c2.v.push(CheckId(Cell::new(None)));\n+    c1.v[0].v.set(Some(&c2)); //~ ERROR `c2` does not live long enough\n+    c2.v[0].v.set(Some(&c1)); //~ ERROR `c1` does not live long enough\n+}\n+\n+fn main() {\n+    f();\n+}"}, {"sha": "a191b3e56c41754fd3274c0be3ecca3cb7c63e54", "filename": "src/test/compile-fail/vec_refs_data_with_early_death.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Fcompile-fail%2Fvec_refs_data_with_early_death.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Fcompile-fail%2Fvec_refs_data_with_early_death.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec_refs_data_with_early_death.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test is a simple example of code that violates the dropck\n+// rules: it pushes `&x` and `&y` into `v`, but the referenced data\n+// will be dropped before the vector itself is.\n+\n+// (In principle we know that `Vec` does not reference the data it\n+//  owns from within its drop code, apart from calling drop on each\n+//  element it owns; thus, for data like this, it seems like we could\n+//  loosen the restrictions here if we wanted. But it also is not\n+//  clear whether such loosening is terribly important.)\n+\n+fn main() {\n+    let mut v = Vec::new();\n+\n+    let x: i8 = 3;\n+    let y: i8 = 4;\n+\n+    v.push(&x); //~ ERROR `x` does not live long enough\n+    v.push(&y); //~ ERROR `y` does not live long enough\n+\n+    assert_eq!(v.as_slice(), [&3, &4]);\n+}"}, {"sha": "80434f36b42d53e552c41b9b3b883a9a069af5f6", "filename": "src/test/run-pass/arr_cycle.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-pass%2Farr_cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-pass%2Farr_cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farr_cycle.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::Cell;\n+\n+#[derive(Show)]\n+struct B<'a> {\n+    a: [Cell<Option<&'a B<'a>>>; 2]\n+}\n+\n+impl<'a> B<'a> {\n+    fn new() -> B<'a> {\n+        B { a: [Cell::new(None), Cell::new(None)] }\n+    }\n+}\n+\n+fn f() {\n+    let (b1, b2, b3);\n+    b1 = B::new();\n+    b2 = B::new();\n+    b3 = B::new();\n+    b1.a[0].set(Some(&b2));\n+    b1.a[1].set(Some(&b3));\n+    b2.a[0].set(Some(&b2));\n+    b2.a[1].set(Some(&b3));\n+    b3.a[0].set(Some(&b1));\n+    b3.a[1].set(Some(&b2));\n+}\n+\n+fn main() {\n+    f();\n+}"}, {"sha": "ad71f725864f9f9c5ba1a578ee4dc169c125ae68", "filename": "src/test/run-pass/dropck_tarena_sound_drop.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-pass%2Fdropck_tarena_sound_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-pass%2Fdropck_tarena_sound_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdropck_tarena_sound_drop.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that a arena (TypedArena) can carry elements whose drop\n+// methods might access borrowed data, as long as the borrowed data\n+// has lifetime that strictly outlives the arena itself.\n+//\n+// Compare against compile-fail/dropck_tarena_unsound_drop.rs, which\n+// shows a similar setup, but restricts `f` so that the struct `C<'a>`\n+// is force-fed a lifetime equal to that of the borrowed arena.\n+\n+#![allow(unstable)]\n+#![feature(unsafe_destructor)]\n+\n+extern crate arena;\n+\n+use arena::TypedArena;\n+\n+trait HasId { fn count(&self) -> usize; }\n+\n+struct CheckId<T:HasId> { v: T }\n+\n+// In the code below, the impl of HasId for `&'a usize` does not\n+// actually access the borrowed data, but the point is that the\n+// interface to CheckId does not (and cannot) know that, and therefore\n+// when encountering the a value V of type CheckId<S>, we must\n+// conservatively force the type S to strictly outlive V.\n+#[unsafe_destructor]\n+impl<T:HasId> Drop for CheckId<T> {\n+    fn drop(&mut self) {\n+        assert!(self.v.count() > 0);\n+    }\n+}\n+\n+struct C<'a> { _v: CheckId<&'a usize>, }\n+\n+impl<'a> HasId for &'a usize { fn count(&self) -> usize { 1 } }\n+\n+fn f<'a, 'b>(_arena: &'a TypedArena<C<'b>>) {}\n+\n+fn main() {\n+    let arena: TypedArena<C> = TypedArena::new();\n+    f(&arena);\n+}"}, {"sha": "4dc824d9068e52043fb20eb0bceed96e466d2fdc", "filename": "src/test/run-pass/issue-13304.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13304.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -37,7 +37,8 @@ fn parent() {\n }\n \n fn child() {\n-    for line in old_io::stdin().lock().lines() {\n+    let mut stdin = old_io::stdin();\n+    for line in stdin.lock().lines() {\n         println!(\"{}\", line.unwrap());\n     }\n }"}, {"sha": "1c8066bc3c98511e35a989ad8729e45d082be66b", "filename": "src/test/run-pass/issue-14456.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-pass%2Fissue-14456.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-pass%2Fissue-14456.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14456.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -27,7 +27,8 @@ fn main() {\n fn child() {\n     old_io::stdout().write_line(\"foo\").unwrap();\n     old_io::stderr().write_line(\"bar\").unwrap();\n-    assert_eq!(old_io::stdin().lock().read_line().err().unwrap().kind, old_io::EndOfFile);\n+    let mut stdin = old_io::stdin();\n+    assert_eq!(stdin.lock().read_line().err().unwrap().kind, old_io::EndOfFile);\n }\n \n fn test() {"}, {"sha": "49ecef9c7359aab92e44df37b2e4fb8c5430e4d8", "filename": "src/test/run-pass/multidispatch-conditional-impl-not-considered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-pass%2Fmultidispatch-conditional-impl-not-considered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-pass%2Fmultidispatch-conditional-impl-not-considered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmultidispatch-conditional-impl-not-considered.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -29,5 +29,5 @@ impl Bar {\n \n fn main() {\n     let b = RefCell::new(Bar);\n-    b.borrow().foo()\n+    b.borrow().foo();\n }"}, {"sha": "bbce9a8f4a6ad20db285f21fd2ef7c87ae94fb3b", "filename": "src/test/run-pass/nondrop-cycle.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-pass%2Fnondrop-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-pass%2Fnondrop-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnondrop-cycle.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::Cell;\n+\n+struct C<'a> {\n+    p: Cell<Option<&'a C<'a>>>,\n+}\n+\n+impl<'a> C<'a> {\n+    fn new() -> C<'a> { C { p: Cell::new(None) } }\n+}\n+\n+fn f1() {\n+    let (c1, c2) = (C::new(), C::new());\n+    c1.p.set(Some(&c2));\n+    c2.p.set(Some(&c1));\n+}\n+\n+fn f2() {\n+    let (c1, c2);\n+    c1 = C::new();\n+    c2 = C::new();\n+    c1.p.set(Some(&c2));\n+    c2.p.set(Some(&c1));\n+}\n+\n+fn main() {\n+    f1();\n+    f2();\n+}"}, {"sha": "faa79f71d9e018d3c7d905513c5c0fe7d332de80", "filename": "src/test/run-pass/overloaded-autoderef.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -22,8 +22,9 @@ struct Point {\n }\n \n pub fn main() {\n+    let box_5 = box 5u;\n     assert_eq!(Rc::new(5u).to_uint(), Some(5));\n-    assert_eq!((box &box &Rc::new(box box &box 5u)).to_uint(), Some(5));\n+    assert_eq!((box &box &Rc::new(box box &box_5)).to_uint(), Some(5));\n     let point = Rc::new(Point {x: 2, y: 4});\n     assert_eq!(point.x, 2);\n     assert_eq!(point.y, 4);"}, {"sha": "019db2a977e4f07797fbe1b102b8047bdd5688ca", "filename": "src/test/run-pass/regions-refcell.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-pass%2Fregions-refcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-pass%2Fregions-refcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-refcell.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is a regression test for something that only came up while\n+// attempting to bootstrap librustc with new destructor lifetime\n+// semantics.\n+\n+use std::collections::HashMap;\n+use std::cell::RefCell;\n+\n+// This version does not yet work (associated type issues)...\n+#[cfg(cannot_use_this_yet)]\n+fn foo<'a>(map: RefCell<HashMap<&'static str, &'a [u8]>>) {\n+    let one = [1u];\n+    assert_eq!(map.borrow().get(\"one\"), Some(&one[]));\n+}\n+\n+#[cfg(cannot_use_this_yet_either)]\n+// ... and this version does not work (the lifetime of `one` is\n+// supposed to match the lifetime `'a`) ...\n+fn foo<'a>(map: RefCell<HashMap<&'static str, &'a [u8]>>) {\n+    let one = [1u];\n+    assert_eq!(map.borrow().get(\"one\"), Some(&one.as_slice()));\n+}\n+\n+#[cfg(all(not(cannot_use_this_yet),not(cannot_use_this_yet_either)))]\n+fn foo<'a>(map: RefCell<HashMap<&'static str, &'a [u8]>>) {\n+    // ...so instead we walk through the trivial slice and make sure\n+    // it contains the element we expect.\n+\n+    for (i, &x) in map.borrow().get(\"one\").unwrap().iter().enumerate() {\n+        assert_eq!((i, x), (0, 1));\n+    }\n+}\n+\n+fn main() {\n+    let zer = [0u8];\n+    let one = [1u8];\n+    let two = [2u8];\n+    let mut map = HashMap::new();\n+    map.insert(\"zero\", &zer[]);\n+    map.insert(\"one\",  &one[]);\n+    map.insert(\"two\",  &two[]);\n+    let map = RefCell::new(map);\n+    foo(map);\n+}"}, {"sha": "eb3bec773266670d241bb68fbbbb6ec4bb43b803", "filename": "src/test/run-pass/regions-trait-object-1.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-pass%2Fregions-trait-object-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-pass%2Fregions-trait-object-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-trait-object-1.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is a regression test for something that only came up while\n+// attempting to bootstrap libsyntax; it is adapted from\n+// `syntax::ext::tt::generic_extension`.\n+\n+pub struct E<'a> {\n+    pub f: &'a u8,\n+}\n+impl<'b> E<'b> {\n+    pub fn m(&self) -> &'b u8 { self.f }\n+}\n+\n+pub struct P<'c> {\n+    pub g: &'c u8,\n+}\n+pub trait M {\n+    fn n(&self) -> u8;\n+}\n+impl<'d> M for P<'d> {\n+    fn n(&self) -> u8 { *self.g }\n+}\n+\n+fn extension<'e>(x: &'e E<'e>) -> Box<M+'e> {\n+    loop {\n+        let p = P { g: x.m() };\n+        return Box::new(p) as Box<M+'e>;\n+    }\n+}\n+\n+fn main() {\n+    let w = E { f: &10u8 };\n+    let o = extension(&w);\n+    assert_eq!(o.n(), 10u8);\n+}"}, {"sha": "4e481910aa98fd215d9657ce77fb28cf6fa0832b", "filename": "src/test/run-pass/trait-object-with-lifetime-bound.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-pass%2Ftrait-object-with-lifetime-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-pass%2Ftrait-object-with-lifetime-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-object-with-lifetime-bound.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Uncovered during work on new scoping rules for safe destructors\n+// as an important use case to support properly.\n+\n+pub struct E<'a> {\n+    pub f: &'a u8,\n+}\n+impl<'b> E<'b> {\n+    pub fn m(&self) -> &'b u8 { self.f }\n+}\n+\n+pub struct P<'c> {\n+    pub g: &'c u8,\n+}\n+pub trait M {\n+    fn n(&self) -> u8;\n+}\n+impl<'d> M for P<'d> {\n+    fn n(&self) -> u8 { *self.g }\n+}\n+\n+fn extension<'e>(x: &'e E<'e>) -> Box<M+'e> {\n+    loop {\n+        let p = P { g: x.m() };\n+        return Box::new(p) as Box<M+'e>;\n+    }\n+}\n+\n+fn main() {\n+    let w = E { f: &10u8 };\n+    let o = extension(&w);\n+    assert_eq!(o.n(), 10u8);\n+}"}, {"sha": "65522bd95df7fc0af6d2faa0eed458285bbe06e3", "filename": "src/test/run-pass/vec_cycle.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-pass%2Fvec_cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-pass%2Fvec_cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec_cycle.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::Cell;\n+\n+#[derive(Show)]\n+struct C<'a> {\n+    v: Vec<Cell<Option<&'a C<'a>>>>,\n+}\n+\n+impl<'a> C<'a> {\n+    fn new() -> C<'a> {\n+        C { v: Vec::new() }\n+    }\n+}\n+\n+fn f() {\n+    let (mut c1, mut c2, mut c3);\n+    c1 = C::new();\n+    c2 = C::new();\n+    c3 = C::new();\n+\n+    c1.v.push(Cell::new(None));\n+    c1.v.push(Cell::new(None));\n+    c2.v.push(Cell::new(None));\n+    c2.v.push(Cell::new(None));\n+    c3.v.push(Cell::new(None));\n+    c3.v.push(Cell::new(None));\n+\n+    c1.v[0].set(Some(&c2));\n+    c1.v[1].set(Some(&c3));\n+    c2.v[0].set(Some(&c2));\n+    c2.v[1].set(Some(&c3));\n+    c3.v[0].set(Some(&c1));\n+    c3.v[1].set(Some(&c2));\n+}\n+\n+fn main() {\n+    f();\n+}"}, {"sha": "f179df90b34cabce9deee49e5446a9ec4c9cefaa", "filename": "src/test/run-pass/vec_cycle_wrapped.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-pass%2Fvec_cycle_wrapped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-pass%2Fvec_cycle_wrapped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec_cycle_wrapped.rs?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::Cell;\n+\n+#[derive(Show)]\n+struct Refs<'a> {\n+    v: Vec<Cell<Option<&'a C<'a>>>>,\n+}\n+\n+#[derive(Show)]\n+struct C<'a> {\n+    refs: Refs<'a>,\n+}\n+\n+impl<'a> Refs<'a> {\n+    fn new() -> Refs<'a> {\n+        Refs { v: Vec::new() }\n+    }\n+}\n+\n+impl<'a> C<'a> {\n+    fn new() -> C<'a> {\n+        C { refs: Refs::new() }\n+    }\n+}\n+\n+fn f() {\n+    let (mut c1, mut c2, mut c3);\n+    c1 = C::new();\n+    c2 = C::new();\n+    c3 = C::new();\n+\n+    c1.refs.v.push(Cell::new(None));\n+    c1.refs.v.push(Cell::new(None));\n+    c2.refs.v.push(Cell::new(None));\n+    c2.refs.v.push(Cell::new(None));\n+    c3.refs.v.push(Cell::new(None));\n+    c3.refs.v.push(Cell::new(None));\n+\n+    c1.refs.v[0].set(Some(&c2));\n+    c1.refs.v[1].set(Some(&c3));\n+    c2.refs.v[0].set(Some(&c2));\n+    c2.refs.v[1].set(Some(&c3));\n+    c3.refs.v[0].set(Some(&c1));\n+    c3.refs.v[1].set(Some(&c2));\n+}\n+\n+fn main() {\n+    f();\n+}"}]}