{"sha": "935fc3642a61e1545e1b98bf4716acbb7bf12e91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzNWZjMzY0MmE2MWUxNTQ1ZTFiOThiZjQ3MTZhY2JiN2JmMTJlOTE=", "commit": {"author": {"name": "Ayrton", "email": "a.munoz3327@gmail.com", "date": "2020-10-21T21:19:21Z"}, "committer": {"name": "Ayrton", "email": "a.munoz3327@gmail.com", "date": "2020-10-27T15:04:04Z"}, "message": "Added documentation for `function_item_references` lint\n\nAdded documentation for `function_item_references` lint to the rustc book and\nfixed comments in the lint checker itself.", "tree": {"sha": "2b7c3e0fd656b9c28fdcac2baf5ce829624d3997", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b7c3e0fd656b9c28fdcac2baf5ce829624d3997"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/935fc3642a61e1545e1b98bf4716acbb7bf12e91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/935fc3642a61e1545e1b98bf4716acbb7bf12e91", "html_url": "https://github.com/rust-lang/rust/commit/935fc3642a61e1545e1b98bf4716acbb7bf12e91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/935fc3642a61e1545e1b98bf4716acbb7bf12e91/comments", "author": {"login": "ayrtonm", "id": 4975834, "node_id": "MDQ6VXNlcjQ5NzU4MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4975834?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ayrtonm", "html_url": "https://github.com/ayrtonm", "followers_url": "https://api.github.com/users/ayrtonm/followers", "following_url": "https://api.github.com/users/ayrtonm/following{/other_user}", "gists_url": "https://api.github.com/users/ayrtonm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ayrtonm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ayrtonm/subscriptions", "organizations_url": "https://api.github.com/users/ayrtonm/orgs", "repos_url": "https://api.github.com/users/ayrtonm/repos", "events_url": "https://api.github.com/users/ayrtonm/events{/privacy}", "received_events_url": "https://api.github.com/users/ayrtonm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ayrtonm", "id": 4975834, "node_id": "MDQ6VXNlcjQ5NzU4MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4975834?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ayrtonm", "html_url": "https://github.com/ayrtonm", "followers_url": "https://api.github.com/users/ayrtonm/followers", "following_url": "https://api.github.com/users/ayrtonm/following{/other_user}", "gists_url": "https://api.github.com/users/ayrtonm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ayrtonm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ayrtonm/subscriptions", "organizations_url": "https://api.github.com/users/ayrtonm/orgs", "repos_url": "https://api.github.com/users/ayrtonm/repos", "events_url": "https://api.github.com/users/ayrtonm/events{/privacy}", "received_events_url": "https://api.github.com/users/ayrtonm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6fa7e15d6679a1c01a6b4c32400f571d04c6a6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6fa7e15d6679a1c01a6b4c32400f571d04c6a6c", "html_url": "https://github.com/rust-lang/rust/commit/d6fa7e15d6679a1c01a6b4c32400f571d04c6a6c"}], "stats": {"total": 178, "additions": 105, "deletions": 73}, "files": [{"sha": "3a30b41d6816f937f487e208222e708163635db7", "filename": "compiler/rustc_mir/src/transform/function_item_references.rs", "status": "renamed", "additions": 50, "deletions": 42, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/935fc3642a61e1545e1b98bf4716acbb7bf12e91/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Ffunction_item_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/935fc3642a61e1545e1b98bf4716acbb7bf12e91/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Ffunction_item_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Ffunction_item_references.rs?ref=935fc3642a61e1545e1b98bf4716acbb7bf12e91", "patch": "@@ -3,7 +3,7 @@ use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{\n     self,\n-    subst::{GenericArgKind, Subst},\n+    subst::{GenericArgKind, Subst, SubstsRef},\n     PredicateAtom, Ty, TyCtxt, TyS,\n };\n use rustc_session::lint::builtin::FUNCTION_ITEM_REFERENCES;\n@@ -27,6 +27,9 @@ struct FunctionItemRefChecker<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for FunctionItemRefChecker<'a, 'tcx> {\n+    /// Emits a lint for function reference arguments bound by `fmt::Pointer` or passed to\n+    /// `transmute`. This only handles arguments in calls outside macro expansions to avoid double\n+    /// counting function references formatted as pointers by macros.\n     fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n         if let TerminatorKind::Call {\n             func,\n@@ -38,11 +41,11 @@ impl<'a, 'tcx> Visitor<'tcx> for FunctionItemRefChecker<'a, 'tcx> {\n         } = &terminator.kind\n         {\n             let source_info = *self.body.source_info(location);\n-            //this handles all function calls outside macros\n+            // Only handle function calls outside macros\n             if !source_info.span.from_expansion() {\n                 let func_ty = func.ty(self.body, self.tcx);\n                 if let ty::FnDef(def_id, substs_ref) = *func_ty.kind() {\n-                    //handle `std::mem::transmute`\n+                    // Handle calls to `transmute`\n                     if self.tcx.is_diagnostic_item(sym::transmute, def_id) {\n                         let arg_ty = args[0].ty(self.body, self.tcx);\n                         for generic_inner_ty in arg_ty.walk() {\n@@ -55,48 +58,16 @@ impl<'a, 'tcx> Visitor<'tcx> for FunctionItemRefChecker<'a, 'tcx> {\n                             }\n                         }\n                     } else {\n-                        //handle any function call with `std::fmt::Pointer` as a bound trait\n-                        //this includes calls to `std::fmt::Pointer::fmt` outside of macros\n-                        let param_env = self.tcx.param_env(def_id);\n-                        let bounds = param_env.caller_bounds();\n-                        for bound in bounds {\n-                            if let Some(bound_ty) = self.is_pointer_trait(&bound.skip_binders()) {\n-                                //get the argument types as they appear in the function signature\n-                                let arg_defs = self.tcx.fn_sig(def_id).skip_binder().inputs();\n-                                for (arg_num, arg_def) in arg_defs.iter().enumerate() {\n-                                    //for all types reachable from the argument type in the fn sig\n-                                    for generic_inner_ty in arg_def.walk() {\n-                                        if let GenericArgKind::Type(inner_ty) =\n-                                            generic_inner_ty.unpack()\n-                                        {\n-                                            //if the inner type matches the type bound by `Pointer`\n-                                            if TyS::same_type(inner_ty, bound_ty) {\n-                                                //do a substitution using the parameters from the callsite\n-                                                let subst_ty = inner_ty.subst(self.tcx, substs_ref);\n-                                                if let Some(fn_id) =\n-                                                    FunctionItemRefChecker::is_fn_ref(subst_ty)\n-                                                {\n-                                                    let ident =\n-                                                        self.tcx.item_name(fn_id).to_ident_string();\n-                                                    let span = self.nth_arg_span(&args, arg_num);\n-                                                    self.emit_lint(ident, fn_id, source_info, span);\n-                                                }\n-                                            }\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                        }\n+                        self.check_bound_args(def_id, substs_ref, &args, source_info);\n                     }\n                 }\n             }\n         }\n         self.super_terminator(terminator, location);\n     }\n-    //This handles `std::fmt::Pointer::fmt` when it's used in the formatting macros.\n-    //It's handled as an operand instead of a Call terminator so it won't depend on\n-    //whether the formatting macros call `fmt` directly, transmute it first or other\n-    //internal fmt details.\n+    /// Emits a lint for function references formatted with `fmt::Pointer::fmt` by macros. These\n+    /// cases are handled as operands instead of call terminators to avoid any dependence on\n+    /// unstable, internal formatting details like whether `fmt` is called directly or not.\n     fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n         let source_info = *self.body.source_info(location);\n         if source_info.span.from_expansion() {\n@@ -105,8 +76,8 @@ impl<'a, 'tcx> Visitor<'tcx> for FunctionItemRefChecker<'a, 'tcx> {\n                 if self.tcx.is_diagnostic_item(sym::pointer_trait_fmt, def_id) {\n                     let param_ty = substs_ref.type_at(0);\n                     if let Some(fn_id) = FunctionItemRefChecker::is_fn_ref(param_ty) {\n-                        //the operand's ctxt wouldn't display the lint since it's inside a macro\n-                        //so we have to use the callsite's ctxt\n+                        // The operand's ctxt wouldn't display the lint since it's inside a macro so\n+                        // we have to use the callsite's ctxt.\n                         let callsite_ctxt = source_info.span.source_callsite().ctxt();\n                         let span = source_info.span.with_ctxt(callsite_ctxt);\n                         let ident = self.tcx.item_name(fn_id).to_ident_string();\n@@ -120,7 +91,42 @@ impl<'a, 'tcx> Visitor<'tcx> for FunctionItemRefChecker<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> FunctionItemRefChecker<'a, 'tcx> {\n-    //return the bound parameter type if the trait is `std::fmt::Pointer`\n+    /// Emits a lint for function reference arguments bound by `fmt::Pointer` in calls to the\n+    /// function defined by `def_id` with the substitutions `substs_ref`.\n+    fn check_bound_args(\n+        &self,\n+        def_id: DefId,\n+        substs_ref: SubstsRef<'tcx>,\n+        args: &Vec<Operand<'tcx>>,\n+        source_info: SourceInfo,\n+    ) {\n+        let param_env = self.tcx.param_env(def_id);\n+        let bounds = param_env.caller_bounds();\n+        for bound in bounds {\n+            if let Some(bound_ty) = self.is_pointer_trait(&bound.skip_binders()) {\n+                // Get the argument types as they appear in the function signature.\n+                let arg_defs = self.tcx.fn_sig(def_id).skip_binder().inputs();\n+                for (arg_num, arg_def) in arg_defs.iter().enumerate() {\n+                    // For all types reachable from the argument type in the fn sig\n+                    for generic_inner_ty in arg_def.walk() {\n+                        if let GenericArgKind::Type(inner_ty) = generic_inner_ty.unpack() {\n+                            // If the inner type matches the type bound by `Pointer`\n+                            if TyS::same_type(inner_ty, bound_ty) {\n+                                // Do a substitution using the parameters from the callsite\n+                                let subst_ty = inner_ty.subst(self.tcx, substs_ref);\n+                                if let Some(fn_id) = FunctionItemRefChecker::is_fn_ref(subst_ty) {\n+                                    let ident = self.tcx.item_name(fn_id).to_ident_string();\n+                                    let span = self.nth_arg_span(args, arg_num);\n+                                    self.emit_lint(ident, fn_id, source_info, span);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    /// If the given predicate is the trait `fmt::Pointer`, returns the bound parameter type.\n     fn is_pointer_trait(&self, bound: &PredicateAtom<'tcx>) -> Option<Ty<'tcx>> {\n         if let ty::PredicateAtom::Trait(predicate, _) = bound {\n             if self.tcx.is_diagnostic_item(sym::pointer_trait, predicate.def_id()) {\n@@ -132,6 +138,8 @@ impl<'a, 'tcx> FunctionItemRefChecker<'a, 'tcx> {\n             None\n         }\n     }\n+    /// If a type is a reference or raw pointer to the anonymous type of a function definition,\n+    /// returns that function's `DefId`.\n     fn is_fn_ref(ty: Ty<'tcx>) -> Option<DefId> {\n         let referent_ty = match ty.kind() {\n             ty::Ref(_, referent_ty, _) => Some(referent_ty),", "previous_filename": "compiler/rustc_mir/src/transform/function_references.rs"}, {"sha": "89db6bb13cad355d2bf5a9c9e1be2519a93e4631", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/935fc3642a61e1545e1b98bf4716acbb7bf12e91/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/935fc3642a61e1545e1b98bf4716acbb7bf12e91/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=935fc3642a61e1545e1b98bf4716acbb7bf12e91", "patch": "@@ -27,7 +27,7 @@ pub mod dest_prop;\n pub mod dump_mir;\n pub mod early_otherwise_branch;\n pub mod elaborate_drops;\n-pub mod function_references;\n+pub mod function_item_references;\n pub mod generator;\n pub mod inline;\n pub mod instcombine;\n@@ -267,7 +267,7 @@ fn mir_const<'tcx>(\n             // MIR-level lints.\n             &check_packed_ref::CheckPackedRef,\n             &check_const_item_mutation::CheckConstItemMutation,\n-            &function_references::FunctionItemReferences,\n+            &function_item_references::FunctionItemReferences,\n             // What we need to do constant evaluation.\n             &simplify::SimplifyCfg::new(\"initial\"),\n             &rustc_peek::SanityCheck,"}, {"sha": "806f79af277b0e8eb3592f04f0de0bae5be52472", "filename": "compiler/rustc_session/src/lint/builtin.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/935fc3642a61e1545e1b98bf4716acbb7bf12e91/compiler%2Frustc_session%2Fsrc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/935fc3642a61e1545e1b98bf4716acbb7bf12e91/compiler%2Frustc_session%2Fsrc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Flint%2Fbuiltin.rs?ref=935fc3642a61e1545e1b98bf4716acbb7bf12e91", "patch": "@@ -2648,6 +2648,30 @@ declare_lint! {\n }\n \n declare_lint! {\n+    /// The `function_item_references` lint detects function references that are\n+    /// formatted with [`fmt::Pointer`] or transmuted.\n+    ///\n+    /// [`fmt::Pointer`]: https://doc.rust-lang.org/std/fmt/trait.Pointer.html\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// fn foo() { }\n+    ///\n+    /// fn main() {\n+    ///     println!(\"{:p}\", &foo);\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Taking a reference to a function may be mistaken as a way to obtain a\n+    /// pointer to that function. This can give unexpected results when\n+    /// formatting the reference as a pointer or transmuting it. This lint is\n+    /// issued when function references are formatted as pointers, passed as\n+    /// arguments bound by [`fmt::Pointer`] or transmuted.\n     pub FUNCTION_ITEM_REFERENCES,\n     Warn,\n     \"suggest casting functions to pointers when attempting to take references\","}, {"sha": "28c66a31322c46d75b25e3472d5cf925c8581498", "filename": "src/test/ui/lint/function-item-references.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/935fc3642a61e1545e1b98bf4716acbb7bf12e91/src%2Ftest%2Fui%2Flint%2Ffunction-item-references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/935fc3642a61e1545e1b98bf4716acbb7bf12e91/src%2Ftest%2Fui%2Flint%2Ffunction-item-references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ffunction-item-references.rs?ref=935fc3642a61e1545e1b98bf4716acbb7bf12e91", "previous_filename": "src/test/ui/lint/function-references.rs"}, {"sha": "a96b134ed580fd4457f58900ccc03807fa7d5cef", "filename": "src/test/ui/lint/function-item-references.stderr", "status": "renamed", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/935fc3642a61e1545e1b98bf4716acbb7bf12e91/src%2Ftest%2Fui%2Flint%2Ffunction-item-references.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/935fc3642a61e1545e1b98bf4716acbb7bf12e91/src%2Ftest%2Fui%2Flint%2Ffunction-item-references.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ffunction-item-references.stderr?ref=935fc3642a61e1545e1b98bf4716acbb7bf12e91", "patch": "@@ -1,173 +1,173 @@\n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:40:18\n+  --> $DIR/function-item-references.rs:40:18\n    |\n LL |     Pointer::fmt(&zst_ref, f)\n    |                  ^^^^^^^^\n    |\n note: the lint level is defined here\n-  --> $DIR/function-references.rs:3:9\n+  --> $DIR/function-item-references.rs:3:9\n    |\n LL | #![warn(function_item_references)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:77:22\n+  --> $DIR/function-item-references.rs:77:22\n    |\n LL |     println!(\"{:p}\", &foo);\n    |                      ^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:79:20\n+  --> $DIR/function-item-references.rs:79:20\n    |\n LL |     print!(\"{:p}\", &foo);\n    |                    ^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:81:21\n+  --> $DIR/function-item-references.rs:81:21\n    |\n LL |     format!(\"{:p}\", &foo);\n    |                     ^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:84:22\n+  --> $DIR/function-item-references.rs:84:22\n    |\n LL |     println!(\"{:p}\", &foo as *const _);\n    |                      ^^^^^^^^^^^^^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:86:22\n+  --> $DIR/function-item-references.rs:86:22\n    |\n LL |     println!(\"{:p}\", zst_ref);\n    |                      ^^^^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:88:22\n+  --> $DIR/function-item-references.rs:88:22\n    |\n LL |     println!(\"{:p}\", cast_zst_ptr);\n    |                      ^^^^^^^^^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:90:22\n+  --> $DIR/function-item-references.rs:90:22\n    |\n LL |     println!(\"{:p}\", coerced_zst_ptr);\n    |                      ^^^^^^^^^^^^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:93:22\n+  --> $DIR/function-item-references.rs:93:22\n    |\n LL |     println!(\"{:p}\", &fn_item);\n    |                      ^^^^^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:95:22\n+  --> $DIR/function-item-references.rs:95:22\n    |\n LL |     println!(\"{:p}\", indirect_ref);\n    |                      ^^^^^^^^^^^^\n \n warning: cast `nop` with `as fn()` to obtain a function pointer\n-  --> $DIR/function-references.rs:98:22\n+  --> $DIR/function-item-references.rs:98:22\n    |\n LL |     println!(\"{:p}\", &nop);\n    |                      ^^^^\n \n warning: cast `bar` with `as fn(_) -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:100:22\n+  --> $DIR/function-item-references.rs:100:22\n    |\n LL |     println!(\"{:p}\", &bar);\n    |                      ^^^^\n \n warning: cast `baz` with `as fn(_, _) -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:102:22\n+  --> $DIR/function-item-references.rs:102:22\n    |\n LL |     println!(\"{:p}\", &baz);\n    |                      ^^^^\n \n warning: cast `unsafe_fn` with `as unsafe fn()` to obtain a function pointer\n-  --> $DIR/function-references.rs:104:22\n+  --> $DIR/function-item-references.rs:104:22\n    |\n LL |     println!(\"{:p}\", &unsafe_fn);\n    |                      ^^^^^^^^^^\n \n warning: cast `c_fn` with `as extern \"C\" fn()` to obtain a function pointer\n-  --> $DIR/function-references.rs:106:22\n+  --> $DIR/function-item-references.rs:106:22\n    |\n LL |     println!(\"{:p}\", &c_fn);\n    |                      ^^^^^\n \n warning: cast `unsafe_c_fn` with `as unsafe extern \"C\" fn()` to obtain a function pointer\n-  --> $DIR/function-references.rs:108:22\n+  --> $DIR/function-item-references.rs:108:22\n    |\n LL |     println!(\"{:p}\", &unsafe_c_fn);\n    |                      ^^^^^^^^^^^^\n \n warning: cast `variadic` with `as unsafe extern \"C\" fn(_, ...)` to obtain a function pointer\n-  --> $DIR/function-references.rs:110:22\n+  --> $DIR/function-item-references.rs:110:22\n    |\n LL |     println!(\"{:p}\", &variadic);\n    |                      ^^^^^^^^^\n \n warning: cast `var` with `as fn(_) -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:112:22\n+  --> $DIR/function-item-references.rs:112:22\n    |\n LL |     println!(\"{:p}\", &std::env::var::<String>);\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: cast `nop` with `as fn()` to obtain a function pointer\n-  --> $DIR/function-references.rs:115:32\n+  --> $DIR/function-item-references.rs:115:32\n    |\n LL |     println!(\"{:p} {:p} {:p}\", &nop, &foo, &bar);\n    |                                ^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:115:38\n+  --> $DIR/function-item-references.rs:115:38\n    |\n LL |     println!(\"{:p} {:p} {:p}\", &nop, &foo, &bar);\n    |                                      ^^^^\n \n warning: cast `bar` with `as fn(_) -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:115:44\n+  --> $DIR/function-item-references.rs:115:44\n    |\n LL |     println!(\"{:p} {:p} {:p}\", &nop, &foo, &bar);\n    |                                            ^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:130:41\n+  --> $DIR/function-item-references.rs:130:41\n    |\n LL |         std::mem::transmute::<_, usize>(&foo);\n    |                                         ^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:132:50\n+  --> $DIR/function-item-references.rs:132:50\n    |\n LL |         std::mem::transmute::<_, (usize, usize)>((&foo, &bar));\n    |                                                  ^^^^^^^^^^^^\n \n warning: cast `bar` with `as fn(_) -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:132:50\n+  --> $DIR/function-item-references.rs:132:50\n    |\n LL |         std::mem::transmute::<_, (usize, usize)>((&foo, &bar));\n    |                                                  ^^^^^^^^^^^^\n \n warning: cast `bar` with `as fn(_) -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:142:15\n+  --> $DIR/function-item-references.rs:142:15\n    |\n LL |     print_ptr(&bar);\n    |               ^^^^\n \n warning: cast `bar` with `as fn(_) -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:144:24\n+  --> $DIR/function-item-references.rs:144:24\n    |\n LL |     bound_by_ptr_trait(&bar);\n    |                        ^^^^\n \n warning: cast `bar` with `as fn(_) -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:146:30\n+  --> $DIR/function-item-references.rs:146:30\n    |\n LL |     bound_by_ptr_trait_tuple((&foo, &bar));\n    |                              ^^^^^^^^^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:146:30\n+  --> $DIR/function-item-references.rs:146:30\n    |\n LL |     bound_by_ptr_trait_tuple((&foo, &bar));\n    |                              ^^^^^^^^^^^^", "previous_filename": "src/test/ui/lint/function-references.stderr"}]}