{"sha": "3d588c528685fa0590ff91f189f0ef44a3815ec2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkNTg4YzUyODY4NWZhMDU5MGZmOTFmMTg5ZjBlZjQ0YTM4MTVlYzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-26T22:07:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-26T22:07:07Z"}, "message": "auto merge of #5555 : Kimundi/rust/str-dealloc-3, r=catamorphism\n\n- Most functions that used to return `~[~str]` for a list of substrings got turned into iterators over `&str` slices\r\n- Some cleanup of apis, docs and code layout", "tree": {"sha": "888656fb3e0e3ab7a5c4931c49487acf39a6d414", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/888656fb3e0e3ab7a5c4931c49487acf39a6d414"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d588c528685fa0590ff91f189f0ef44a3815ec2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d588c528685fa0590ff91f189f0ef44a3815ec2", "html_url": "https://github.com/rust-lang/rust/commit/3d588c528685fa0590ff91f189f0ef44a3815ec2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d588c528685fa0590ff91f189f0ef44a3815ec2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f7c74d0225354b93bf7649fed8cdd2774480106", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f7c74d0225354b93bf7649fed8cdd2774480106", "html_url": "https://github.com/rust-lang/rust/commit/3f7c74d0225354b93bf7649fed8cdd2774480106"}, {"sha": "de468c8cd2f55124f98ae67941bc4c11dee92c14", "url": "https://api.github.com/repos/rust-lang/rust/commits/de468c8cd2f55124f98ae67941bc4c11dee92c14", "html_url": "https://github.com/rust-lang/rust/commit/de468c8cd2f55124f98ae67941bc4c11dee92c14"}], "stats": {"total": 870, "additions": 461, "deletions": 409}, "files": [{"sha": "5a35c56c075a7b61350badb5ca155738057a399b", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -142,7 +142,8 @@ fn parse_check_line(line: ~str) -> Option<~str> {\n fn parse_exec_env(line: ~str) -> Option<(~str, ~str)> {\n     do parse_name_value_directive(line, ~\"exec-env\").map |nv| {\n         // nv is either FOO or FOO=BAR\n-        let strs = str::splitn_char(*nv, '=', 1u);\n+        let mut strs = ~[];\n+        for str::each_splitn_char(*nv, '=', 1u) |s| { strs.push(s.to_owned()); }\n         match strs.len() {\n           1u => (strs[0], ~\"\"),\n           2u => (strs[0], strs[1]),"}, {"sha": "ed66aea4f0ce7d56ef75e15b799882705e275cc4", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -267,7 +267,7 @@ fn run_debuginfo_test(config: config, props: TestProps, testfile: &Path) {\n         // check if each line in props.check_lines appears in the\n         // output (in order)\n         let mut i = 0u;\n-        for str::lines_each(ProcRes.stdout) |line| {\n+        for str::each_line(ProcRes.stdout) |line| {\n             if props.check_lines[i].trim() == line.trim() {\n                 i += 1u;\n             }\n@@ -297,7 +297,7 @@ fn check_error_patterns(props: TestProps,\n     let mut next_err_idx = 0u;\n     let mut next_err_pat = props.error_patterns[next_err_idx];\n     let mut done = false;\n-    for str::lines_each(ProcRes.stderr) |line| {\n+    for str::each_line(ProcRes.stderr) |line| {\n         if str::contains(line, next_err_pat) {\n             debug!(\"found error pattern %s\", next_err_pat);\n             next_err_idx += 1u;\n@@ -347,7 +347,7 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n     //    filename:line1:col1: line2:col2: *warning:* msg\n     // where line1:col1: is the starting point, line2:col2:\n     // is the ending point, and * represents ANSI color codes.\n-    for str::lines_each(ProcRes.stderr) |line| {\n+    for str::each_line(ProcRes.stderr) |line| {\n         let mut was_expected = false;\n         for vec::eachi(expected_errors) |i, ee| {\n             if !found_flags[i] {\n@@ -596,8 +596,12 @@ fn split_maybe_args(argstr: Option<~str>) -> ~[~str] {\n     }\n \n     match argstr {\n-      Some(s) => rm_whitespace(str::split_char(s, ' ')),\n-      None => ~[]\n+        Some(s) => {\n+            let mut ss = ~[];\n+            for str::each_split_char(s, ' ') |s| { ss.push(s.to_owned()) }\n+            rm_whitespace(ss)\n+        }\n+        None => ~[]\n     }\n }\n "}, {"sha": "ce6c015c13168e7609ed7fd6a7a9d054da478964", "filename": "src/libcore/num/strconv.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibcore%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibcore%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fstrconv.rs?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -130,6 +130,13 @@ impl_NumStrConv_Integer!(u16)\n impl_NumStrConv_Integer!(u32)\n impl_NumStrConv_Integer!(u64)\n \n+\n+// Special value strings as [u8] consts.\n+static inf_buf:          [u8*3] = ['i' as u8, 'n' as u8, 'f' as u8];\n+static positive_inf_buf: [u8*4] = ['+' as u8, 'i' as u8, 'n' as u8, 'f' as u8];\n+static negative_inf_buf: [u8*4] = ['-' as u8, 'i' as u8, 'n' as u8, 'f' as u8];\n+static nan_buf:          [u8*3] = ['N' as u8, 'a' as u8, 'N' as u8];\n+\n /**\n  * Converts a number to its string representation as a byte vector.\n  * This is meant to be a common base implementation for all numeric string\n@@ -479,15 +486,15 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+\n     }\n \n     if special {\n-        if buf == str::inf_buf || buf == str::positive_inf_buf {\n+        if buf == inf_buf || buf == positive_inf_buf {\n             return NumStrConv::inf();\n-        } else if buf == str::negative_inf_buf {\n+        } else if buf == negative_inf_buf {\n             if negative {\n                 return NumStrConv::neg_inf();\n             } else {\n                 return None;\n             }\n-        } else if buf == str::nan_buf {\n+        } else if buf == nan_buf {\n             return NumStrConv::NaN();\n         }\n     }"}, {"sha": "9aa00e8e4576c5b7f22d4b866de9d90bd392a41a", "filename": "src/libcore/os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -218,7 +218,8 @@ pub fn env() -> ~[(~str,~str)] {\n         fn env_convert(input: ~[~str]) -> ~[(~str, ~str)] {\n             let mut pairs = ~[];\n             for input.each |p| {\n-                let vs = str::splitn_char(*p, '=', 1);\n+                let mut vs = ~[];\n+                for str::each_splitn_char(*p, '=', 1) |s| { vs.push(s.to_owned()) }\n                 debug!(\"splitting: len: %u\",\n                     vs.len());\n                 fail_unless!(vs.len() == 2);"}, {"sha": "3d06809a4523ef6baf805aedf6a93552893b7e71", "filename": "src/libcore/path.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -381,7 +381,8 @@ impl ToStr for PosixPath {\n impl GenericPath for PosixPath {\n \n     fn from_str(s: &str) -> PosixPath {\n-        let mut components = str::split_nonempty(s, |c| c == '/');\n+        let mut components = ~[];\n+        for str::each_split_nonempty(s, |c| c == '/') |s| { components.push(s.to_owned()) }\n         let is_absolute = (s.len() != 0 && s[0] == '/' as u8);\n         return PosixPath { is_absolute: is_absolute,\n                            components: components }\n@@ -504,9 +505,10 @@ impl GenericPath for PosixPath {\n     fn push_many(&self, cs: &[~str]) -> PosixPath {\n         let mut v = copy self.components;\n         for cs.each |e| {\n-            let mut ss = str::split_nonempty(\n-                *e,\n-                |c| windows::is_sep(c as u8));\n+            let mut ss = ~[];\n+            for str::each_split_nonempty(*e, |c| windows::is_sep(c as u8)) |s| {\n+                ss.push(s.to_owned())\n+            }\n             unsafe { v.push_all_move(ss); }\n         }\n         PosixPath { is_absolute: self.is_absolute,\n@@ -515,7 +517,10 @@ impl GenericPath for PosixPath {\n \n     fn push(&self, s: &str) -> PosixPath {\n         let mut v = copy self.components;\n-        let mut ss = str::split_nonempty(s, |c| windows::is_sep(c as u8));\n+        let mut ss = ~[];\n+        for str::each_split_nonempty(s, |c| windows::is_sep(c as u8)) |s| {\n+            ss.push(s.to_owned())\n+        }\n         unsafe { v.push_all_move(ss); }\n         PosixPath { components: v, ..copy *self }\n     }\n@@ -590,8 +595,10 @@ impl GenericPath for WindowsPath {\n           }\n         }\n \n-        let mut components =\n-            str::split_nonempty(rest, |c| windows::is_sep(c as u8));\n+        let mut components = ~[];\n+        for str::each_split_nonempty(rest, |c| windows::is_sep(c as u8)) |s| {\n+            components.push(s.to_owned())\n+        }\n         let is_absolute = (rest.len() != 0 && windows::is_sep(rest[0]));\n         return WindowsPath { host: host,\n                              device: device,\n@@ -759,9 +766,10 @@ impl GenericPath for WindowsPath {\n     fn push_many(&self, cs: &[~str]) -> WindowsPath {\n         let mut v = copy self.components;\n         for cs.each |e| {\n-            let mut ss = str::split_nonempty(\n-                *e,\n-                |c| windows::is_sep(c as u8));\n+            let mut ss = ~[];\n+            for str::each_split_nonempty(*e, |c| windows::is_sep(c as u8)) |s| {\n+                ss.push(s.to_owned())\n+            }\n             unsafe { v.push_all_move(ss); }\n         }\n         // tedious, but as-is, we can't use ..self\n@@ -775,7 +783,10 @@ impl GenericPath for WindowsPath {\n \n     fn push(&self, s: &str) -> WindowsPath {\n         let mut v = copy self.components;\n-        let mut ss = str::split_nonempty(s, |c| windows::is_sep(c as u8));\n+        let mut ss = ~[];\n+        for str::each_split_nonempty(s, |c| windows::is_sep(c as u8)) |s| {\n+            ss.push(s.to_owned())\n+        }\n         unsafe { v.push_all_move(ss); }\n         return WindowsPath { components: v, ..copy *self }\n     }"}, {"sha": "afa4ea66ca677cd08f03909cd69ea1a3fd26f797", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -327,7 +327,9 @@ impl RngUtil for @Rng {\n      */\n     fn gen_char_from(&self, chars: &str) -> char {\n         fail_unless!(!chars.is_empty());\n-        self.choose(str::chars(chars))\n+        let mut cs = ~[];\n+        for str::each_char(chars) |c| { cs.push(c) }\n+        self.choose(cs)\n     }\n \n     /// Return a random bool"}, {"sha": "0f393dee597790ed874ed64819a4140118f78314", "filename": "src/libcore/str.rs", "status": "modified", "additions": 306, "deletions": 329, "changes": 635, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -56,15 +56,15 @@ pub fn from_slice(s: &str) -> ~str {\n \n impl ToStr for ~str {\n     #[inline(always)]\n-    fn to_str(&self) -> ~str { copy *self }\n+    fn to_str(&self) -> ~str { from_slice(*self) }\n }\n impl ToStr for &'self str {\n     #[inline(always)]\n-    fn to_str(&self) -> ~str { ::str::from_slice(*self) }\n+    fn to_str(&self) -> ~str { from_slice(*self) }\n }\n impl ToStr for @str {\n     #[inline(always)]\n-    fn to_str(&self) -> ~str { ::str::from_slice(*self) }\n+    fn to_str(&self) -> ~str { from_slice(*self) }\n }\n \n /**\n@@ -186,6 +186,7 @@ pub fn push_str_no_overallocate(lhs: &mut ~str, rhs: &str) {\n         raw::set_len(lhs, llen + rlen);\n     }\n }\n+\n /// Appends a string slice to the back of a string\n #[inline(always)]\n pub fn push_str(lhs: &mut ~str, rhs: &str) {\n@@ -214,7 +215,6 @@ pub fn append(lhs: ~str, rhs: &str) -> ~str {\n     v\n }\n \n-\n /// Concatenate a vector of strings\n pub fn concat(v: &[~str]) -> ~str {\n     let mut s: ~str = ~\"\";\n@@ -383,7 +383,7 @@ Section: Transforming strings\n */\n \n /**\n- * Converts a string to a vector of bytes\n+ * Converts a string to a unique vector of bytes\n  *\n  * The result vector is not null-terminated.\n  */\n@@ -403,22 +403,19 @@ pub fn byte_slice<T>(s: &str, f: &fn(v: &[u8]) -> T) -> T {\n     }\n }\n \n-/// Convert a string to a vector of characters\n-pub fn chars(s: &str) -> ~[char] {\n-    let mut buf = ~[], i = 0;\n-    let len = len(s);\n-    while i < len {\n-        let CharRange {ch, next} = char_range_at(s, i);\n-        unsafe { buf.push(ch); }\n-        i = next;\n+/// Convert a string to a unique vector of characters\n+pub fn to_chars(s: &str) -> ~[char] {\n+    let mut buf = ~[];\n+    for each_char(s) |c| {\n+        buf.push(c);\n     }\n     buf\n }\n \n /**\n  * Take a substring of another.\n  *\n- * Returns a string containing `n` characters starting at byte offset\n+ * Returns a slice pointing at `n` characters starting from byte offset\n  * `begin`.\n  */\n pub fn substr(s: &'a str, begin: uint, n: uint) -> &'a str {\n@@ -437,121 +434,101 @@ pub fn slice(s: &'a str, begin: uint, end: uint) -> &'a str {\n     unsafe { raw::slice_bytes(s, begin, end) }\n }\n \n-/// Splits a string into substrings at each occurrence of a given\n-/// character.\n-pub fn split_char(s: &str, sep: char) -> ~[~str] {\n-    split_char_inner(s, sep, len(s), true, true)\n+/// Splits a string into substrings at each occurrence of a given character\n+pub fn each_split_char(s: &'a str, sep: char, it: &fn(&'a str) -> bool) {\n+    each_split_char_inner(s, sep, len(s), true, true, it)\n+}\n+\n+/// Like `each_split_char`, but a trailing empty string is omitted\n+pub fn each_split_char_no_trailing(s: &'a str, sep: char, it: &fn(&'a str) -> bool) {\n+    each_split_char_inner(s, sep, len(s), true, false, it)\n }\n \n /**\n  * Splits a string into substrings at each occurrence of a given\n  * character up to 'count' times.\n  *\n- * The byte must be a valid UTF-8/ASCII byte\n+ * The character must be a valid UTF-8/ASCII character\n  */\n-pub fn splitn_char(s: &str, sep: char, count: uint) -> ~[~str] {\n-    split_char_inner(s, sep, count, true, true)\n+pub fn each_splitn_char(s: &'a str, sep: char, count: uint, it: &fn(&'a str) -> bool) {\n+    each_split_char_inner(s, sep, count, true, true, it)\n }\n \n-/// Like `split_char`, but omits empty strings from the returned vector\n-pub fn split_char_nonempty(s: &str, sep: char) -> ~[~str] {\n-    split_char_inner(s, sep, len(s), false, false)\n+/// Like `each_split_char`, but omits empty strings\n+pub fn each_split_char_nonempty(s: &'a str, sep: char, it: &fn(&'a str) -> bool) {\n+    each_split_char_inner(s, sep, len(s), false, false, it)\n }\n \n-/**\n- * Like `split_char`, but a trailing empty string is omitted\n- * (e.g. `split_char_no_trailing(\"A B \",' ') == ~[~\"A\",~\"B\"]`)\n- */\n-pub fn split_char_no_trailing(s: &str, sep: char) -> ~[~str] {\n-    split_char_inner(s, sep, len(s), true, false)\n-}\n-\n-fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool,\n-                    allow_trailing_empty: bool) -> ~[~str] {\n+fn each_split_char_inner(s: &'a str, sep: char, count: uint, allow_empty: bool,\n+                         allow_trailing_empty: bool, it: &fn(&'a str) -> bool) {\n     if sep < 128u as char {\n         let b = sep as u8, l = len(s);\n-        let mut result = ~[], done = 0u;\n+        let mut done = 0u;\n         let mut i = 0u, start = 0u;\n         while i < l && done < count {\n             if s[i] == b {\n                 if allow_empty || start < i {\n-                    unsafe {\n-                        result.push(raw::slice_bytes_unique(s, start, i));\n-                    }\n+                    if !it( unsafe{ raw::slice_bytes(s, start, i) } ) { return; }\n                 }\n                 start = i + 1u;\n                 done += 1u;\n             }\n             i += 1u;\n         }\n-        // only push a non-empty trailing substring\n+        // only slice a non-empty trailing substring\n         if allow_trailing_empty || start < l {\n-            unsafe { result.push(raw::slice_bytes_unique(s, start, l) ) };\n+            if !it( unsafe{ raw::slice_bytes(s, start, l) } ) { return; }\n         }\n-        result\n     } else {\n-        split_inner(s, |cur| cur == sep, count, allow_empty, allow_trailing_empty)\n+        each_split_inner(s, |cur| cur == sep, count, allow_empty, allow_trailing_empty, it)\n     }\n }\n \n-\n /// Splits a string into substrings using a character function\n-pub fn split(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n-    split_inner(s, sepfn, len(s), true, true)\n+pub fn each_split(s: &'a str, sepfn: &fn(char) -> bool, it: &fn(&'a str) -> bool) {\n+    each_split_inner(s, sepfn, len(s), true, true, it)\n+}\n+\n+/// Like `each_split`, but a trailing empty string is omitted\n+pub fn each_split_no_trailing(s: &'a str, sepfn: &fn(char) -> bool, it: &fn(&'a str) -> bool) {\n+    each_split_inner(s, sepfn, len(s), true, false, it)\n }\n \n /**\n  * Splits a string into substrings using a character function, cutting at\n  * most `count` times.\n  */\n-pub fn splitn(s: &str,\n-                   sepfn: &fn(char) -> bool,\n-                   count: uint)\n-                -> ~[~str] {\n-    split_inner(s, sepfn, count, true, true)\n-}\n-\n-/// Like `split`, but omits empty strings from the returned vector\n-pub fn split_nonempty(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n-    split_inner(s, sepfn, len(s), false, false)\n+pub fn each_splitn(s: &'a str, sepfn: &fn(char) -> bool, count: uint, it: &fn(&'a str) -> bool) {\n+    each_split_inner(s, sepfn, count, true, true, it)\n }\n \n-\n-/**\n- * Like `split`, but a trailing empty string is omitted\n- * (e.g. `split_no_trailing(\"A B \",' ') == ~[~\"A\",~\"B\"]`)\n- */\n-pub fn split_no_trailing(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n-    split_inner(s, sepfn, len(s), true, false)\n+/// Like `each_split`, but omits empty strings\n+pub fn each_split_nonempty(s: &'a str, sepfn: &fn(char) -> bool, it: &fn(&'a str) -> bool) {\n+    each_split_inner(s, sepfn, len(s), false, false, it)\n }\n \n-fn split_inner(s: &str, sepfn: &fn(cc: char) -> bool, count: uint,\n-               allow_empty: bool, allow_trailing_empty: bool) -> ~[~str] {\n+fn each_split_inner(s: &'a str, sepfn: &fn(cc: char) -> bool, count: uint,\n+                    allow_empty: bool, allow_trailing_empty: bool, it: &fn(&'a str) -> bool) {\n     let l = len(s);\n-    let mut result = ~[], i = 0u, start = 0u, done = 0u;\n+    let mut i = 0u, start = 0u, done = 0u;\n     while i < l && done < count {\n         let CharRange {ch, next} = char_range_at(s, i);\n         if sepfn(ch) {\n             if allow_empty || start < i {\n-                unsafe {\n-                    result.push(raw::slice_bytes_unique(s, start, i));\n-                }\n+                if !it( unsafe{ raw::slice_bytes(s, start, i) } ) { return; }\n             }\n             start = next;\n             done += 1u;\n         }\n         i = next;\n     }\n     if allow_trailing_empty || start < l {\n-        unsafe {\n-            result.push(raw::slice_bytes_unique(s, start, l));\n-        }\n+        if !it( unsafe{ raw::slice_bytes(s, start, l) } ) { return;  }\n     }\n-    result\n }\n \n // See Issue #1932 for why this is a naive search\n-fn iter_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n+fn iter_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint) -> bool) {\n     let sep_len = len(sep), l = len(s);\n     fail_unless!(sep_len > 0u);\n     let mut i = 0u, match_start = 0u, match_i = 0u;\n@@ -562,7 +539,7 @@ fn iter_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n             match_i += 1u;\n             // Found a match\n             if match_i == sep_len {\n-                f(match_start, i + 1u);\n+                if !f(match_start, i + 1u) { return; }\n                 match_i = 0u;\n             }\n             i += 1u;\n@@ -578,10 +555,10 @@ fn iter_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n     }\n }\n \n-fn iter_between_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n+fn iter_between_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint) -> bool) {\n     let mut last_end = 0u;\n-    do iter_matches(s, sep) |from, to| {\n-        f(last_end, from);\n+    for iter_matches(s, sep) |from, to| {\n+        if !f(last_end, from) { return; }\n         last_end = to;\n     }\n     f(last_end, len(s));\n@@ -593,25 +570,23 @@ fn iter_between_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n  * # Example\n  *\n  * ~~~\n- * fail_unless!([\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\"))\n+ * let mut v = ~[];\n+ * for each_split_str(\".XXX.YYY.\", \".\") |subs| { v.push(subs); }\n+ * fail_unless!(v == [\"\", \"XXX\", \"YYY\", \"\"]);\n  * ~~~\n  */\n-pub fn split_str(s: &'a str, sep: &'b str) -> ~[~str] {\n-    let mut result = ~[];\n-    do iter_between_matches(s, sep) |from, to| {\n-        unsafe { result.push(raw::slice_bytes_unique(s, from, to)); }\n+pub fn each_split_str(s: &'a str, sep: &'b str, it: &fn(&'a str) -> bool) {\n+    for iter_between_matches(s, sep) |from, to| {\n+        if !it( unsafe { raw::slice_bytes(s, from, to) } ) { return; }\n     }\n-    result\n }\n \n-pub fn split_str_nonempty(s: &'a str, sep: &'b str) -> ~[~str] {\n-    let mut result = ~[];\n-    do iter_between_matches(s, sep) |from, to| {\n+pub fn each_split_str_nonempty(s: &'a str, sep: &'b str, it: &fn(&'a str) -> bool) {\n+    for iter_between_matches(s, sep) |from, to| {\n         if to > from {\n-            unsafe { result.push(raw::slice_bytes_unique(s, from, to)); }\n+            if !it( unsafe { raw::slice_bytes(s, from, to) } ) { return; }\n         }\n     }\n-    result\n }\n \n /// Levenshtein Distance between two strings\n@@ -649,65 +624,99 @@ pub fn levdistance(s: &str, t: &str) -> uint {\n }\n \n /**\n- * Splits a string into a vector of the substrings separated by LF ('\\n').\n+ * Splits a string into substrings separated by LF ('\\n').\n  */\n-pub fn lines(s: &str) -> ~[~str] {\n-    split_char_no_trailing(s, '\\n')\n+pub fn each_line(s: &'a str, it: &fn(&'a str) -> bool) {\n+    each_split_char_no_trailing(s, '\\n', it)\n }\n \n /**\n- * Splits a string into a vector of the substrings separated by LF ('\\n')\n+ * Splits a string into substrings separated by LF ('\\n')\n  * and/or CR LF (\"\\r\\n\")\n  */\n-pub fn lines_any(s: &str) -> ~[~str] {\n-    vec::map(lines(s), |s| {\n-        let l = len(*s);\n-        let mut cp = copy *s;\n+pub fn each_line_any(s: &'a str, it: &fn(&'a str) -> bool) {\n+    for each_line(s) |s| {\n+        let l = s.len();\n         if l > 0u && s[l - 1u] == '\\r' as u8 {\n-            unsafe { raw::set_len(&mut cp, l - 1u); }\n+            if !it( unsafe { raw::slice_bytes(s, 0, l - 1) } ) { return; }\n+        } else {\n+            if !it( s ) { return; }\n         }\n-        cp\n-    })\n+    }\n }\n \n-/// Splits a string into a vector of the substrings separated by whitespace\n-pub fn words(s: &str) -> ~[~str] {\n-    split_nonempty(s, char::is_whitespace)\n+/// Splits a string into substrings separated by whitespace\n+pub fn each_word(s: &'a str, it: &fn(&'a str) -> bool) {\n+    each_split_nonempty(s, char::is_whitespace, it)\n }\n \n-/** Split a string into a vector of substrings,\n- *  each of which is less than a limit\n+/** Splits a string into substrings with possibly internal whitespace,\n+ *  each of them at most `lim` bytes long. The substrings have leading and trailing\n+ *  whitespace removed, and are only cut at whitespace boundaries.\n+ *\n+ *  #Failure:\n+ *\n+ *  Fails during iteration if the string contains a non-whitespace\n+ *  sequence longer than the limit.\n  */\n-pub fn split_within(ss: &str, lim: uint) -> ~[~str] {\n-    let words = str::words(ss);\n+pub fn each_split_within(ss: &'a str, lim: uint, it: &fn(&'a str) -> bool) {\n+    // Just for fun, let's write this as an state machine:\n \n-    // empty?\n-    if words == ~[] { return ~[]; }\n+    enum SplitWithinState {\n+        A,  // leading whitespace, initial state\n+        B,  // words\n+        C,  // internal and trailing whitespace\n+    }\n+    enum Whitespace {\n+        Ws, // current char is whitespace\n+        Cr  // current char is not whitespace\n+    }\n+    enum LengthLimit {\n+        UnderLim, // current char makes current substring still fit in limit\n+        OverLim   // current char makes current substring no longer fit in limit\n+    }\n \n-    let mut rows : ~[~str] = ~[];\n-    let mut row  : ~str    = ~\"\";\n+    let mut slice_start = 0;\n+    let mut last_start = 0;\n+    let mut last_end = 0;\n+    let mut state = A;\n \n-    for words.each |wptr| {\n-        let word = copy *wptr;\n+    let mut cont = true;\n+    let slice: &fn() = || { cont = it(slice(ss, slice_start, last_end)) };\n \n-        // if adding this word to the row would go over the limit,\n-        // then start a new row\n-        if row.len() + word.len() + 1 > lim {\n-            rows.push(copy row); // save previous row\n-            row = word;    // start a new one\n-        } else {\n-            if row.len() > 0 { row += ~\" \" } // separate words\n-            row += word;  // append to this row\n-        }\n-    }\n+    let machine: &fn(uint, char) -> bool = |i, c| {\n+        let whitespace = if char::is_whitespace(c)       { Ws }       else { Cr };\n+        let limit      = if (i - slice_start + 1) <= lim { UnderLim } else { OverLim };\n \n-    // save the last row\n-    if row != ~\"\" { rows.push(row); }\n+        state = match (state, whitespace, limit) {\n+            (A, Ws, _)        => { A }\n+            (A, Cr, _)        => { slice_start = i; last_start = i; B }\n \n-    rows\n-}\n+            (B, Cr, UnderLim) => { B }\n+            (B, Cr, OverLim)  if (i - last_start + 1) > lim\n+                              => { fail!(~\"word longer than limit!\") }\n+            (B, Cr, OverLim)  => { slice(); slice_start = last_start; B }\n+            (B, Ws, UnderLim) => { last_end = i; C }\n+            (B, Ws, OverLim)  => { last_end = i; slice(); A }\n+\n+            (C, Cr, UnderLim) => { last_start = i; B }\n+            (C, Cr, OverLim)  => { slice(); slice_start = i; last_start = i; last_end = i; B }\n+            (C, Ws, OverLim)  => { slice(); A }\n+            (C, Ws, UnderLim) => { C }\n+        };\n+\n+        cont\n+    };\n \n+    str::each_chari(ss, machine);\n \n+    // Let the automaton 'run out' by supplying trailing whitespace\n+    let mut fake_i = ss.len();\n+    while cont && match state { B | C => true, A => false } {\n+        machine(fake_i, ' ');\n+        fake_i += 1;\n+    }\n+}\n \n /// Convert a string to lowercase. ASCII only\n pub fn to_lower(s: &str) -> ~str {\n@@ -738,7 +747,7 @@ pub fn to_upper(s: &str) -> ~str {\n  */\n pub fn replace(s: &str, from: &str, to: &str) -> ~str {\n     let mut result = ~\"\", first = true;\n-    do iter_between_matches(s, from) |start, end| {\n+    for iter_between_matches(s, from) |start, end| {\n         if first {\n             first = false;\n         } else {\n@@ -997,10 +1006,16 @@ pub fn eachi_reverse(s: &str, it: &fn(uint, u8) -> bool) {\n     }\n }\n \n-/// Iterates over the chars in a string\n+/// Iterate over each char of a string, without allocating\n #[inline(always)]\n pub fn each_char(s: &str, it: &fn(char) -> bool) {\n-    each_chari(s, |_i, c| it(c))\n+    let mut i = 0;\n+    let len = len(s);\n+    while i < len {\n+        let CharRange {ch, next} = char_range_at(s, i);\n+        if !it(ch) { return; }\n+        i = next;\n+    }\n }\n \n /// Iterates over the chars in a string, with indices\n@@ -1038,32 +1053,6 @@ pub fn each_chari_reverse(s: &str, it: &fn(uint, char) -> bool) {\n     }\n }\n \n-/// Apply a function to each substring after splitting by character\n-pub fn split_char_each(ss: &str, cc: char, ff: &fn(v: &str) -> bool) {\n-    vec::each(split_char(ss, cc), |s| ff(*s))\n-}\n-\n-/**\n- * Apply a function to each substring after splitting by character, up to\n- * `count` times\n- */\n-pub fn splitn_char_each(ss: &str, sep: char, count: uint,\n-                         ff: &fn(v: &str) -> bool) {\n-    vec::each(splitn_char(ss, sep, count), |s| ff(*s))\n-}\n-\n-/// Apply a function to each word\n-pub fn words_each(ss: &str, ff: &fn(v: &str) -> bool) {\n-    vec::each(words(ss), |s| ff(*s))\n-}\n-\n-/**\n- * Apply a function to each line (by '\\n')\n- */\n-pub fn lines_each(ss: &str, ff: &fn(v: &str) -> bool) {\n-    vec::each(lines(ss), |s| ff(*s))\n-}\n-\n /*\n Section: Searching\n */\n@@ -1209,8 +1198,7 @@ pub fn rfind_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n  * or equal to `len(s)`. `start` must be the index of a character boundary,\n  * as defined by `is_char_boundary`.\n  */\n-pub fn rfind_char_between(s: &str, c: char, start: uint, end: uint)\n-    -> Option<uint> {\n+pub fn rfind_char_between(s: &str, c: char, start: uint, end: uint) -> Option<uint> {\n     if c < 128u as char {\n         fail_unless!(start >= end);\n         fail_unless!(start <= len(s));\n@@ -1291,11 +1279,7 @@ pub fn find_from(s: &str, start: uint, f: &fn(char)\n  * or equal to `len(s)`. `start` must be the index of a character\n  * boundary, as defined by `is_char_boundary`.\n  */\n-pub fn find_between(s: &str,\n-                         start: uint,\n-                         end: uint,\n-                         f: &fn(char) -> bool)\n-                      -> Option<uint> {\n+pub fn find_between(s: &str, start: uint, end: uint, f: &fn(char) -> bool) -> Option<uint> {\n     fail_unless!(start <= end);\n     fail_unless!(end <= len(s));\n     fail_unless!(is_char_boundary(s, start));\n@@ -1346,8 +1330,7 @@ pub fn rfind(s: &str, f: &fn(char) -> bool) -> Option<uint> {\n  * `start` must be less than or equal to `len(s)', `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`\n  */\n-pub fn rfind_from(s: &str, start: uint, f: &fn(char) -> bool)\n-    -> Option<uint> {\n+pub fn rfind_from(s: &str, start: uint, f: &fn(char) -> bool) -> Option<uint> {\n     rfind_between(s, start, 0u, f)\n }\n \n@@ -1373,9 +1356,7 @@ pub fn rfind_from(s: &str, start: uint, f: &fn(char) -> bool)\n  * than or equal to `len(s)`. `start` must be the index of a character\n  * boundary, as defined by `is_char_boundary`\n  */\n-pub fn rfind_between(s: &str, start: uint, end: uint,\n-                          f: &fn(char) -> bool)\n-    -> Option<uint> {\n+pub fn rfind_between(s: &str, start: uint, end: uint, f: &fn(char) -> bool) -> Option<uint> {\n     fail_unless!(start >= end);\n     fail_unless!(start <= len(s));\n     fail_unless!(is_char_boundary(s, start));\n@@ -1431,8 +1412,7 @@ pub fn find_str(haystack: &'a str, needle: &'b str) -> Option<uint> {\n  *\n  * `start` must be less than or equal to `len(s)`\n  */\n-pub fn find_str_from(haystack: &'a str, needle: &'b str, start: uint)\n-  -> Option<uint> {\n+pub fn find_str_from(haystack: &'a str, needle: &'b str, start: uint) -> Option<uint> {\n     find_str_between(haystack, needle, start, len(haystack))\n }\n \n@@ -1456,9 +1436,8 @@ pub fn find_str_from(haystack: &'a str, needle: &'b str, start: uint)\n  * `start` must be less than or equal to `end` and `end` must be less than\n  * or equal to `len(s)`.\n  */\n-pub fn find_str_between(haystack: &'a str, needle: &'b str, start: uint,\n-                         end:uint)\n-  -> Option<uint> {\n+pub fn find_str_between(haystack: &'a str, needle: &'b str, start: uint, end:uint)\n+        -> Option<uint> {\n     // See Issue #1932 for why this is a naive search\n     fail_unless!(end <= len(haystack));\n     let needle_len = len(needle);\n@@ -1661,7 +1640,6 @@ pub fn utf16_chars(v: &[u16], f: &fn(char)) {\n     }\n }\n \n-\n pub fn from_utf16(v: &[u16]) -> ~str {\n     let mut buf = ~\"\";\n     unsafe {\n@@ -1919,14 +1897,6 @@ static tag_five_b: uint = 248u;\n static max_five_b: uint = 67108864u;\n static tag_six_b: uint = 252u;\n \n-// Constants used for converting strs to floats\n-pub static inf_buf: [u8*3] = ['i' as u8, 'n' as u8, 'f' as u8];\n-pub static positive_inf_buf: [u8*4] = ['+' as u8, 'i' as u8,\n-                                       'n' as u8, 'f' as u8];\n-pub static negative_inf_buf: [u8*4] = ['-' as u8, 'i' as u8,\n-                                       'n' as u8, 'f' as u8];\n-pub static nan_buf: [u8*3] = ['N' as u8, 'a' as u8, 'N' as u8];\n-\n /**\n  * Work with the byte buffer of a string.\n  *\n@@ -1986,7 +1956,6 @@ pub fn as_c_str<T>(s: &str, f: &fn(*libc::c_char) -> T) -> T {\n     }\n }\n \n-\n /**\n  * Work with the byte buffer and length of a slice.\n  *\n@@ -2271,7 +2240,7 @@ pub mod traits {\n #[cfg(test)]\n pub mod traits {}\n \n-pub trait StrSlice {\n+pub trait StrSlice<'self> {\n     fn all(&self, it: &fn(char) -> bool) -> bool;\n     fn any(&self, it: &fn(char) -> bool) -> bool;\n     fn contains(&self, needle: &'a str) -> bool;\n@@ -2291,9 +2260,9 @@ pub trait StrSlice {\n     fn len(&self) -> uint;\n     fn char_len(&self) -> uint;\n     fn slice(&self, begin: uint, end: uint) -> &'self str;\n-    fn split(&self, sepfn: &fn(char) -> bool) -> ~[~str];\n-    fn split_char(&self, sep: char) -> ~[~str];\n-    fn split_str(&self, sep: &'a str) -> ~[~str];\n+    fn each_split(&self, sepfn: &fn(char) -> bool, it: &fn(&'self str) -> bool);\n+    fn each_split_char(&self, sep: char, it: &fn(&'self str) -> bool);\n+    fn each_split_str(&self, sep: &'a str, it: &fn(&'self str) -> bool);\n     fn starts_with(&self, needle: &'a str) -> bool;\n     fn substr(&self, begin: uint, n: uint) -> &'self str;\n     fn to_lower(&self) -> ~str;\n@@ -2314,7 +2283,7 @@ pub trait StrSlice {\n }\n \n /// Extension methods for strings\n-impl StrSlice for &'self str {\n+impl StrSlice<'self> for &'self str {\n     /**\n      * Return true if a predicate matches all characters or if the string\n      * contains no characters\n@@ -2413,20 +2382,24 @@ impl StrSlice for &'self str {\n     }\n     /// Splits a string into substrings using a character function\n     #[inline]\n-    fn split(&self, sepfn: &fn(char) -> bool) -> ~[~str] {\n-        split(*self, sepfn)\n+    fn each_split(&self, sepfn: &fn(char) -> bool, it: &fn(&'self str) -> bool) {\n+        each_split(*self, sepfn, it)\n     }\n     /**\n      * Splits a string into substrings at each occurrence of a given character\n      */\n     #[inline]\n-    fn split_char(&self, sep: char) -> ~[~str] { split_char(*self, sep) }\n+    fn each_split_char(&self, sep: char, it: &fn(&'self str) -> bool) {\n+        each_split_char(*self, sep, it)\n+    }\n     /**\n      * Splits a string into a vector of the substrings separated by a given\n      * string\n      */\n     #[inline]\n-    fn split_str(&self, sep: &'a str) -> ~[~str] { split_str(*self, sep) }\n+    fn each_split_str(&self, sep: &'a str, it: &fn(&'self str) -> bool)  {\n+        each_split_str(*self, sep, it)\n+    }\n     /// Returns true if one string starts with another\n     #[inline]\n     fn starts_with(&self, needle: &'a str) -> bool {\n@@ -2519,7 +2492,7 @@ impl OwnedStr for ~str {\n impl Clone for ~str {\n     #[inline(always)]\n     fn clone(&self) -> ~str {\n-        self.to_str()  // hilarious\n+        from_slice(*self)\n     }\n }\n \n@@ -2613,36 +2586,40 @@ mod tests {\n     fn test_split_char() {\n         fn t(s: &str, c: char, u: &[~str]) {\n             debug!(~\"split_byte: \" + s);\n-            let v = split_char(s, c);\n+            let mut v = ~[];\n+            for each_split_char(s, c) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n             fail_unless!(vec::all2(v, u, |a,b| a == b));\n         }\n         t(~\"abc.hello.there\", '.', ~[~\"abc\", ~\"hello\", ~\"there\"]);\n         t(~\".hello.there\", '.', ~[~\"\", ~\"hello\", ~\"there\"]);\n         t(~\"...hello.there.\", '.', ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]);\n \n-        fail_unless!(~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]\n-                     == split_char(~\"...hello.there.\", '.'));\n-\n-        fail_unless!(~[~\"\"] == split_char(~\"\", 'z'));\n-        fail_unless!(~[~\"\",~\"\"] == split_char(~\"z\", 'z'));\n-        fail_unless!(~[~\"ok\"] == split_char(~\"ok\", 'z'));\n+        t(~\"\", 'z', ~[~\"\"]);\n+        t(~\"z\", 'z', ~[~\"\",~\"\"]);\n+        t(~\"ok\", 'z', ~[~\"ok\"]);\n     }\n \n     #[test]\n     fn test_split_char_2() {\n+        fn t(s: &str, c: char, u: &[~str]) {\n+            debug!(~\"split_byte: \" + s);\n+            let mut v = ~[];\n+            for each_split_char(s, c) |s| { v.push(s.to_owned()) }\n+            debug!(\"split_byte to: %?\", v);\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+        }\n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]\n-                     == split_char(data, 'V'));\n-        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\", ~\"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]\n-                     == split_char(data, '\u0e17'));\n+        t(data, 'V', ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]);\n+        t(data, '\u0e17', ~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\", ~\"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]);\n     }\n \n     #[test]\n     fn test_splitn_char() {\n         fn t(s: &str, c: char, n: uint, u: &[~str]) {\n             debug!(~\"splitn_byte: \" + s);\n-            let v = splitn_char(s, c, n);\n+            let mut v = ~[];\n+            for each_splitn_char(s, c, n) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n             debug!(\"comparing vs. %?\", u);\n             fail_unless!(vec::all2(v, u, |a,b| a == b));\n@@ -2654,188 +2631,188 @@ mod tests {\n         t(~\".hello.there\", '.', 0u, ~[~\".hello.there\"]);\n         t(~\".hello.there\", '.', 1u, ~[~\"\", ~\"hello.there\"]);\n         t(~\"...hello.there.\", '.', 3u, ~[~\"\", ~\"\", ~\"\", ~\"hello.there.\"]);\n-        t(~\"...hello.there.\", '.', 5u,\n-          ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]);\n+        t(~\"...hello.there.\", '.', 5u, ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]);\n \n-        fail_unless!(~[~\"\"] == splitn_char(~\"\", 'z', 5u));\n-        fail_unless!(~[~\"\",~\"\"] == splitn_char(~\"z\", 'z', 5u));\n-        fail_unless!(~[~\"ok\"] == splitn_char(~\"ok\", 'z', 5u));\n-        fail_unless!(~[~\"z\"] == splitn_char(~\"z\", 'z', 0u));\n-        fail_unless!(~[~\"w.x.y\"] == splitn_char(~\"w.x.y\", '.', 0u));\n-        fail_unless!(~[~\"w\",~\"x.y\"] == splitn_char(~\"w.x.y\", '.', 1u));\n+        t(~\"\", 'z', 5u, ~[~\"\"]);\n+        t(~\"z\", 'z', 5u, ~[~\"\",~\"\"]);\n+        t(~\"ok\", 'z', 5u, ~[~\"ok\"]);\n+        t(~\"z\", 'z', 0u, ~[~\"z\"]);\n+        t(~\"w.x.y\", '.', 0u, ~[~\"w.x.y\"]);\n+        t(~\"w.x.y\", '.', 1u, ~[~\"w\",~\"x.y\"]);\n     }\n \n     #[test]\n     fn test_splitn_char_2 () {\n-        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]\n-                     == splitn_char(data, '\u534e', 1u));\n+        fn t(s: &str, c: char, n: uint, u: &[~str]) {\n+            debug!(~\"splitn_byte: \" + s);\n+            let mut v = ~[];\n+            for each_splitn_char(s, c, n) |s| { v.push(s.to_owned()) }\n+            debug!(\"split_byte to: %?\", v);\n+            debug!(\"comparing vs. %?\", u);\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+        }\n \n-        fail_unless!(~[~\"\", ~\"\", ~\"XXX\", ~\"YYYzWWWz\"]\n-                     == splitn_char(~\"zzXXXzYYYzWWWz\", 'z', 3u));\n-        fail_unless!(~[~\"\",~\"\"] == splitn_char(~\"z\", 'z', 5u));\n-        fail_unless!(~[~\"\"] == splitn_char(~\"\", 'z', 5u));\n-        fail_unless!(~[~\"ok\"] == splitn_char(~\"ok\", 'z', 5u));\n+        t(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e', 1u, ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]);\n+        t(~\"zzXXXzYYYzWWWz\", 'z', 3u, ~[~\"\", ~\"\", ~\"XXX\", ~\"YYYzWWWz\"]);\n+        t(~\"z\", 'z', 5u, ~[~\"\",~\"\"]);\n+        t(~\"\", 'z', 5u, ~[~\"\"]);\n+        t(~\"ok\", 'z', 5u, ~[~\"ok\"]);\n     }\n \n \n     #[test]\n     fn test_splitn_char_3() {\n+        fn t(s: &str, c: char, n: uint, u: &[~str]) {\n+            debug!(~\"splitn_byte: \" + s);\n+            let mut v = ~[];\n+            for each_splitn_char(s, c, n) |s| { v.push(s.to_owned()) }\n+            debug!(\"split_byte to: %?\", v);\n+            debug!(\"comparing vs. %?\", u);\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+        }\n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]\n-                     == splitn_char(data, 'V', 1u));\n-        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]\n-                     == splitn_char(data, '\u0e17', 1u));\n-\n+        t(data, 'V', 1u, ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]);\n+        t(data, '\u0e17', 1u, ~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]);\n     }\n \n     #[test]\n     fn test_split_char_no_trailing() {\n-     fn t(s: &str, c: char, u: &[~str]) {\n+        fn t(s: &str, c: char, u: &[~str]) {\n             debug!(~\"split_byte: \" + s);\n-            let v = split_char_no_trailing(s, c);\n+            let mut v = ~[];\n+            for each_split_char_no_trailing(s, c) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n             fail_unless!(vec::all2(v, u, |a,b| a == b));\n         }\n         t(~\"abc.hello.there\", '.', ~[~\"abc\", ~\"hello\", ~\"there\"]);\n         t(~\".hello.there\", '.', ~[~\"\", ~\"hello\", ~\"there\"]);\n         t(~\"...hello.there.\", '.', ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\"]);\n \n-        fail_unless!(~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\"]\n-                     == split_char_no_trailing(~\"...hello.there.\", '.'));\n-\n-        fail_unless!(~[] == split_char_no_trailing(~\"\", 'z'));\n-        fail_unless!(~[~\"\"] == split_char_no_trailing(~\"z\", 'z'));\n-        fail_unless!(~[~\"ok\"] == split_char_no_trailing(~\"ok\", 'z'));\n+        t(~\"...hello.there.\", '.', ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\"]);\n+        t(~\"\", 'z', ~[]);\n+        t(~\"z\", 'z', ~[~\"\"]);\n+        t(~\"ok\", 'z', ~[~\"ok\"]);\n     }\n \n     #[test]\n     fn test_split_char_no_trailing_2() {\n+        fn t(s: &str, c: char, u: &[~str]) {\n+            debug!(~\"split_byte: \" + s);\n+            let mut v = ~[];\n+            for each_split_char_no_trailing(s, c) |s| { v.push(s.to_owned()) }\n+            debug!(\"split_byte to: %?\", v);\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+        }\n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]\n-                     == split_char_no_trailing(data, 'V'));\n-        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\", ~\"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]\n-                     == split_char_no_trailing(data, '\u0e17'));\n+        t(data, 'V', ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]);\n+        t(data, '\u0e17', ~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\", ~\"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]);\n     }\n \n     #[test]\n     fn test_split_str() {\n-        fn t(s: &str, sep: &'a str, i: int, k: &str) {\n-            fn borrow(x: &'a str) -> &'a str { x }\n-            let v = split_str(s, sep);\n-            fail_unless!(borrow(v[i]) == k);\n+        fn t(s: &str, sep: &'a str, u: &[~str]) {\n+            let mut v = ~[];\n+            for each_split_str(s, sep) |s| { v.push(s.to_owned()) }\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n         }\n-\n-        t(~\"--1233345--\", ~\"12345\", 0, ~\"--1233345--\");\n-        t(~\"abc::hello::there\", ~\"::\", 0, ~\"abc\");\n-        t(~\"abc::hello::there\", ~\"::\", 1, ~\"hello\");\n-        t(~\"abc::hello::there\", ~\"::\", 2, ~\"there\");\n-        t(~\"::hello::there\", ~\"::\", 0, ~\"\");\n-        t(~\"hello::there::\", ~\"::\", 2, ~\"\");\n-        t(~\"::hello::there::\", ~\"::\", 3, ~\"\");\n-\n-        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", ~\"Vi\u1ec7t Nam\"]\n-                     == split_str (data, ~\"\u4e2d\u534e\"));\n-\n-        fail_unless!(~[~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]\n-                     == split_str(~\"zzXXXzzYYYzz\", ~\"zz\"));\n-\n-        fail_unless!(~[~\"zz\", ~\"zYYYz\"] == split_str(~\"zzXXXzYYYz\", ~\"XXX\"));\n-\n-\n-        fail_unless!(~[~\"\", ~\"XXX\", ~\"YYY\", ~\"\"] ==\n-                     split_str(~\".XXX.YYY.\", ~\".\"));\n-        fail_unless!(~[~\"\"] == split_str(~\"\", ~\".\"));\n-        fail_unless!(~[~\"\",~\"\"] == split_str(~\"zz\", ~\"zz\"));\n-        fail_unless!(~[~\"ok\"] == split_str(~\"ok\", ~\"z\"));\n-        fail_unless!(~[~\"\",~\"z\"] == split_str(~\"zzz\", ~\"zz\"));\n-        fail_unless!(~[~\"\",~\"\",~\"z\"] == split_str(~\"zzzzz\", ~\"zz\"));\n+        t(~\"--1233345--\", ~\"12345\", ~[~\"--1233345--\"]);\n+        t(~\"abc::hello::there\", ~\"::\", ~[~\"abc\", ~\"hello\", ~\"there\"]);\n+        t(~\"::hello::there\", ~\"::\", ~[~\"\", ~\"hello\", ~\"there\"]);\n+        t(~\"hello::there::\", ~\"::\", ~[~\"hello\", ~\"there\", ~\"\"]);\n+        t(~\"::hello::there::\", ~\"::\", ~[~\"\", ~\"hello\", ~\"there\", ~\"\"]);\n+        t(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", ~\"\u4e2d\u534e\", ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", ~\"Vi\u1ec7t Nam\"]);\n+        t(~\"zzXXXzzYYYzz\", ~\"zz\", ~[~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]);\n+        t(~\"zzXXXzYYYz\", ~\"XXX\", ~[~\"zz\", ~\"zYYYz\"]);\n+        t(~\".XXX.YYY.\", ~\".\", ~[~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]);\n+        t(~\"\", ~\".\", ~[~\"\"]);\n+        t(~\"zz\", ~\"zz\", ~[~\"\",~\"\"]);\n+        t(~\"ok\", ~\"z\", ~[~\"ok\"]);\n+        t(~\"zzz\", ~\"zz\", ~[~\"\",~\"z\"]);\n+        t(~\"zzzzz\", ~\"zz\", ~[~\"\",~\"\",~\"z\"]);\n     }\n \n \n     #[test]\n     fn test_split() {\n-        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]\n-                     == split (data, |cc| cc == '\u534e'));\n-\n-        fail_unless!(~[~\"\", ~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]\n-                     == split(~\"zzXXXzYYYz\", char::is_lowercase));\n-\n-        fail_unless!(~[~\"zz\", ~\"\", ~\"\", ~\"z\", ~\"\", ~\"\", ~\"z\"]\n-                     == split(~\"zzXXXzYYYz\", char::is_uppercase));\n+        fn t(s: &str, sepf: &fn(char) -> bool, u: &[~str]) {\n+            let mut v = ~[];\n+            for each_split(s, sepf) |s| { v.push(s.to_owned()) }\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+        }\n \n-        fail_unless!(~[~\"\",~\"\"] == split(~\"z\", |cc| cc == 'z'));\n-        fail_unless!(~[~\"\"] == split(~\"\", |cc| cc == 'z'));\n-        fail_unless!(~[~\"ok\"] == split(~\"ok\", |cc| cc == 'z'));\n+        t(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", |cc| cc == '\u534e', ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]);\n+        t(~\"zzXXXzYYYz\", char::is_lowercase, ~[~\"\", ~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]);\n+        t(~\"zzXXXzYYYz\", char::is_uppercase, ~[~\"zz\", ~\"\", ~\"\", ~\"z\", ~\"\", ~\"\", ~\"z\"]);\n+        t(~\"z\", |cc| cc == 'z', ~[~\"\",~\"\"]);\n+        t(~\"\", |cc| cc == 'z', ~[~\"\"]);\n+        t(~\"ok\", |cc| cc == 'z', ~[~\"ok\"]);\n     }\n \n     #[test]\n     fn test_split_no_trailing() {\n-        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]\n-                     == split_no_trailing (data, |cc| cc == '\u534e'));\n-\n-        fail_unless!(~[~\"\", ~\"\", ~\"XXX\", ~\"YYY\"]\n-                     == split_no_trailing(~\"zzXXXzYYYz\", char::is_lowercase));\n-\n-        fail_unless!(~[~\"zz\", ~\"\", ~\"\", ~\"z\", ~\"\", ~\"\", ~\"z\"]\n-                     == split_no_trailing(~\"zzXXXzYYYz\", char::is_uppercase));\n+        fn t(s: &str, sepf: &fn(char) -> bool, u: &[~str]) {\n+            let mut v = ~[];\n+            for each_split_no_trailing(s, sepf) |s| { v.push(s.to_owned()) }\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+        }\n \n-        fail_unless!(~[~\"\"] == split_no_trailing(~\"z\", |cc| cc == 'z'));\n-        fail_unless!(~[] == split_no_trailing(~\"\", |cc| cc == 'z'));\n-        fail_unless!(~[~\"ok\"] == split_no_trailing(~\"ok\", |cc| cc == 'z'));\n+        t(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", |cc| cc == '\u534e', ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]);\n+        t(~\"zzXXXzYYYz\", char::is_lowercase, ~[~\"\", ~\"\", ~\"XXX\", ~\"YYY\"]);\n+        t(~\"zzXXXzYYYz\", char::is_uppercase, ~[~\"zz\", ~\"\", ~\"\", ~\"z\", ~\"\", ~\"\", ~\"z\"]);\n+        t(~\"z\", |cc| cc == 'z', ~[~\"\"]);\n+        t(~\"\", |cc| cc == 'z', ~[]);\n+        t(~\"ok\", |cc| cc == 'z', ~[~\"ok\"]);\n     }\n \n     #[test]\n     fn test_lines() {\n         let lf = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n         let crlf = ~\"\\r\\nMary had a little lamb\\r\\nLittle lamb\\r\\n\";\n \n-        fail_unless!(~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]\n-                     == lines(lf));\n-\n-        fail_unless!(~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]\n-                     == lines_any(lf));\n-\n-        fail_unless!(~[~\"\\r\", ~\"Mary had a little lamb\\r\",\n-                       ~\"Little lamb\\r\"]\n-            == lines(crlf));\n-\n-        fail_unless!(~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]\n-            == lines_any(crlf));\n+        fn t(s: &str, f: &fn(&str, &fn(&str) -> bool), u: &[~str]) {\n+            let mut v = ~[];\n+            for f(s) |s| { v.push(s.to_owned()) }\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+        }\n \n-        fail_unless!(~[] == lines    (~\"\"));\n-        fail_unless!(~[] == lines_any(~\"\"));\n-        fail_unless!(~[~\"\"] == lines    (~\"\\n\"));\n-        fail_unless!(~[~\"\"] == lines_any(~\"\\n\"));\n-        fail_unless!(~[~\"banana\"] == lines    (~\"banana\"));\n-        fail_unless!(~[~\"banana\"] == lines_any(~\"banana\"));\n+        t(lf, each_line ,~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]);\n+        t(lf, each_line_any, ~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]);\n+        t(crlf, each_line, ~[~\"\\r\", ~\"Mary had a little lamb\\r\", ~\"Little lamb\\r\"]);\n+        t(crlf, each_line_any, ~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]);\n+        t(~\"\", each_line, ~[]);\n+        t(~\"\", each_line_any, ~[]);\n+        t(~\"\\n\", each_line, ~[~\"\"]);\n+        t(~\"\\n\", each_line_any, ~[~\"\"]);\n+        t(~\"banana\", each_line, ~[~\"banana\"]);\n+        t(~\"banana\", each_line_any, ~[~\"banana\"]);\n     }\n \n     #[test]\n     fn test_words () {\n+        fn t(s: &str, f: &fn(&str, &fn(&str) -> bool), u: &[~str]) {\n+            let mut v = ~[];\n+            for f(s) |s| { v.push(s.to_owned()) }\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+        }\n         let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n-        fail_unless!(~[\n-            ~\"Mary\",~\"had\",~\"a\",~\"little\",~\"lamb\",~\"Little\",~\"lamb\"]\n-            == words(data));\n \n-        fail_unless!(~[~\"ok\"] == words(~\"ok\"));\n-        fail_unless!(~[] == words(~\"\"));\n+        t(data, each_word, ~[~\"Mary\",~\"had\",~\"a\",~\"little\",~\"lamb\",~\"Little\",~\"lamb\"]);\n+        t(~\"ok\", each_word, ~[~\"ok\"]);\n+        t(~\"\", each_word, ~[]);\n     }\n \n     #[test]\n     fn test_split_within() {\n-        fail_unless!(split_within(~\"\", 0) == ~[]);\n-        fail_unless!(split_within(~\"\", 15) == ~[]);\n-        fail_unless!(split_within(~\"hello\", 15) == ~[~\"hello\"]);\n-\n-        let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n-        error!(\"~~~~ %?\", split_within(data, 15));\n-        fail_unless!(split_within(data, 15) == ~[~\"Mary had a\",\n-                                                 ~\"little lamb\",\n-                                                 ~\"Little lamb\"]);\n+        fn t(s: &str, i: uint, u: &[~str]) {\n+            let mut v = ~[];\n+            for each_split_within(s, i) |s| { v.push(s.to_owned()) }\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+        }\n+        t(~\"\", 0, ~[]);\n+        t(~\"\", 15, ~[]);\n+        t(~\"hello\", 15, ~[~\"hello\"]);\n+        t(~\"\\nMary had a little lamb\\nLittle lamb\\n\", 15,\n+            ~[~\"Mary had a\", ~\"little lamb\", ~\"Little lamb\"]);\n     }\n \n     #[test]\n@@ -3365,7 +3342,7 @@ mod tests {\n \n         let mut ii = 0;\n \n-        for split_char_each(data, ' ') |xx| {\n+        for each_split_char(data, ' ') |xx| {\n             match ii {\n               0 => fail_unless!(\"\\nMary\" == xx),\n               1 => fail_unless!(\"had\"    == xx),\n@@ -3383,7 +3360,7 @@ mod tests {\n \n         let mut ii = 0;\n \n-        for splitn_char_each(data, ' ', 2u) |xx| {\n+        for each_splitn_char(data, ' ', 2u) |xx| {\n             match ii {\n               0 => fail_unless!(\"\\nMary\" == xx),\n               1 => fail_unless!(\"had\"    == xx),\n@@ -3400,7 +3377,7 @@ mod tests {\n \n         let mut ii = 0;\n \n-        for words_each(data) |ww| {\n+        for each_word(data) |ww| {\n             match ii {\n               0 => fail_unless!(\"Mary\"   == ww),\n               1 => fail_unless!(\"had\"    == ww),\n@@ -3411,7 +3388,7 @@ mod tests {\n             ii += 1;\n         }\n \n-        words_each(~\"\", |_x| fail!()); // should not fail\n+        each_word(~\"\", |_x| fail!()); // should not fail\n     }\n \n     #[test]\n@@ -3420,7 +3397,7 @@ mod tests {\n \n         let mut ii = 0;\n \n-        for lines_each(lf) |x| {\n+        for each_line(lf) |x| {\n             match ii {\n                 0 => fail_unless!(\"\" == x),\n                 1 => fail_unless!(\"Mary had a little lamb\" == x),\n@@ -3464,7 +3441,7 @@ mod tests {\n         let ss = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         fail_unless!(~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a',\n                        'm']\n-            == chars(ss));\n+            == to_chars(ss));\n     }\n \n     #[test]"}, {"sha": "ffd7669c2d2eebe948cc339f9c888ac7393e5a48", "filename": "src/librust/rust.rc", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibrust%2Frust.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibrust%2Frust.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rc?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // rust - central access to other rust tools\n-// FIXME #2238 Make commands run and test emit proper file endings on winds\n+// FIXME #2238 Make commands run and test emit proper file endings on windows\n // FIXME #2238 Make run only accept source that emits an executable\n \n #[link(name = \"rust\",\n@@ -29,10 +29,12 @@ enum ValidUsage {\n }\n \n impl ValidUsage {\n-    fn is_valid(&self) -> bool { match *self {\n-        Valid   => true,\n-        Invalid => false\n-    }}\n+    fn is_valid(&self) -> bool {\n+        match *self {\n+            Valid   => true,\n+            Invalid => false\n+        }\n+    }\n }\n \n enum Action {\n@@ -128,7 +130,9 @@ fn cmd_help(args: &[~str]) -> ValidUsage {\n                 match command.usage_full {\n                     UsgStr(msg)          => io::println(fmt!(\"%s\\n\", msg)),\n                     UsgExec(commandline) => {\n-                        let words = str::words(commandline);\n+                        let mut words = ~[];\n+                        for str::each_word(commandline) |word| { words.push(word.to_owned()) }\n+                        let words = words;\n                         let (prog, args) = (words.head(), words.tail());\n                         run::run_program(*prog, args);\n                     }\n@@ -184,7 +188,9 @@ fn do_command(command: &Command, args: &[~str]) -> ValidUsage {\n     match command.action {\n         Call(f) => f(args),\n         Exec(commandline) => {\n-            let words = str::words(commandline);\n+            let mut words = ~[];\n+            for str::each_word(commandline) |word| { words.push(word.to_owned()) }\n+            let words = words;\n             let (prog, prog_args) = (words.head(), words.tail());\n             let exitstatus = run::run_program(\n                 *prog,"}, {"sha": "018a365f37f5268d043cffa1cc3bf19da05e446f", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -120,7 +120,9 @@ pub fn get_used_libraries(cstore: @mut CStore) -> ~[~str] {\n }\n \n pub fn add_used_link_args(cstore: @mut CStore, args: &str) {\n-    cstore.used_link_args.push_all(args.split_char(' '));\n+    for args.each_split_char(' ') |s| {\n+        cstore.used_link_args.push(s.to_owned());\n+    }\n }\n \n pub fn get_used_link_args(cstore: @mut CStore) -> ~[~str] {"}, {"sha": "079110e67f511a3209482776b1a2c898ca48d7c2", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -76,7 +76,7 @@ use syntax::visit::{visit_mod, visit_ty, vt};\n use syntax::opt_vec::OptVec;\n \n use core::option::{Some, get, is_some, is_none};\n-use core::str::{connect, split_str};\n+use core::str::{connect, each_split_str};\n use core::hashmap::linear::LinearMap;\n use std::oldmap::HashMap;\n \n@@ -1696,7 +1696,8 @@ pub impl Resolver {\n                         entry: %s (%?)\",\n                     path_string, def_like);\n \n-            let mut pieces = split_str(path_string, ~\"::\");\n+            let mut pieces = ~[];\n+            for each_split_str(path_string, \"::\") |s| { pieces.push(s.to_owned()) }\n             let final_ident_str = pieces.pop();\n             let final_ident = self.session.ident_of(final_ident_str);\n "}, {"sha": "012a56c5b720a8cce5ae660afc5852ca27435a24", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -183,7 +183,8 @@ fn first_sentence_(s: &str) -> ~str {\n }\n \n fn paragraphs(s: &str) -> ~[~str] {\n-    let lines = str::lines_any(s);\n+    let mut lines = ~[];\n+    for str::each_line_any(s) |line| { lines.push(line.to_owned()); }\n     let mut whitespace_lines = 0;\n     let mut accum = ~\"\";\n     let paras = do vec::foldl(~[], lines) |paras, line| {"}, {"sha": "4b1b92221c0e6261654dd4bb1d4ab523dfb91558", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -551,9 +551,11 @@ fn write_sig(ctxt: &Ctxt, sig: Option<~str>) {\n }\n \n fn code_block_indent(s: ~str) -> ~str {\n-    let lines = str::lines_any(s);\n-    let indented = vec::map(lines, |line| fmt!(\"    %s\", *line) );\n-    str::connect(indented, ~\"\\n\")\n+    let mut indented = ~[];\n+    for str::each_line_any(s) |line| {\n+        indented.push(fmt!(\"    %s\", line));\n+    }\n+    str::connect(indented, \"\\n\")\n }\n \n #[test]"}, {"sha": "33003a59611d41a301e9d45ff088eb461e253a1b", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -104,8 +104,8 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n     if desc.is_none() {\n         return (None, ~[]);\n     }\n-\n-    let lines = str::lines((copy desc).get());\n+    let mut lines = ~[];\n+    for str::each_line_any(*desc.get_ref()) |line| { lines.push(line.to_owned()); }\n \n     let mut new_desc = None::<~str>;\n     let mut current_section = None;"}, {"sha": "6207e2252e40bd49c12373797fd044ebfa586e38", "filename": "src/librustdoc/unindent_pass.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -33,7 +33,8 @@ pub fn mk_pass() -> Pass {\n }\n \n fn unindent(s: &str) -> ~str {\n-    let lines = str::lines_any(s);\n+    let mut lines = ~[];\n+    for str::each_line_any(s) |line| { lines.push(line.to_owned()); }\n     let mut saw_first_line = false;\n     let mut saw_second_line = false;\n     let min_indent = do vec::foldl(uint::max_value, lines)"}, {"sha": "ddde66157bb4452d2d4418b64593a474d0a16a73", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -337,7 +337,8 @@ fn run_line(repl: &mut Repl, in: @io::Reader, out: @io::Writer, line: ~str)\n     -> Option<Repl> {\n     if line.starts_with(~\":\") {\n         let full = line.substr(1, line.len() - 1);\n-        let split = str::words(full);\n+        let mut split = ~[];\n+        for str::each_word(full) |word| { split.push(word.to_owned()) }\n         let len = split.len();\n \n         if len > 0 {"}, {"sha": "35698bb235a38f277458d59b24453f4310ffa5c0", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -270,14 +270,11 @@ impl Ctx {\n         fn sep_name_vers(in: ~str) -> (Option<~str>, Option<~str>) {\n             let mut name = None;\n             let mut vers = None;\n-            let parts = str::split_char(in, '@');\n \n-            if parts.len() >= 1 {\n-                name = Some(parts[0]);\n-\n-                if parts.len() >= 2 {\n-                    vers = Some(parts[1]);\n-                }\n+            for str::each_split_char(in, '@') |s| {\n+                if      name.is_none() { name = Some(s.to_owned()); }\n+                else if vers.is_none() { vers = Some(s.to_owned()); }\n+                else                   { break;               }\n             }\n \n             (name, vers)\n@@ -733,8 +730,12 @@ impl Ctx {\n \n         for package.bins.each |&bin| {\n             let path = Path(bin);\n-            let name = str::split_char(path.file_path().to_str(), '-')[0];\n-            let out = bin_dir.push(name);\n+            let mut name = None;\n+            for str::each_split_char(path.file_path().to_str(), '-') |s| {\n+                name = Some(s.to_owned());\n+                break;\n+            }\n+            let out = bin_dir.push(name.unwrap());\n \n             util::link_exe(&path, &out);\n             util::note(fmt!(\"linked %s\", out.to_str()));\n@@ -847,8 +848,12 @@ impl Ctx {\n \n         for package.bins.each |&bin| {\n             let path = Path(bin);\n-            let name = str::split_char(path.file_path().to_str(), '-')[0];\n-            let out = bin_dir.push(name);\n+            let mut name = None;\n+            for str::each_split_char(path.file_path().to_str(), '-') |s| {\n+                name = Some(s.to_owned());\n+                break;\n+            }\n+            let out = bin_dir.push(name.unwrap());\n \n             if os::path_exists(&out) {\n                 if os::remove_file(&out) {"}, {"sha": "58a286a1854ee4e62f19b581d78d29a864b66047", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -44,10 +44,10 @@ pub fn is_cmd(cmd: ~str) -> bool {\n }\n \n pub fn parse_name(id: ~str) -> result::Result<~str, ~str> {\n-    let parts = str::split_char(id, '.');\n+    let mut last_part = None;\n \n-    for parts.each |&part| {\n-        for str::chars(part).each |&char| {\n+    for str::each_split_char(id, '.') |part| {\n+        for str::each_char(part) |char| {\n             if char::is_whitespace(char) {\n                 return result::Err(\n                     ~\"could not parse id: contains whitespace\");\n@@ -56,9 +56,11 @@ pub fn parse_name(id: ~str) -> result::Result<~str, ~str> {\n                     ~\"could not parse id: should be all lowercase\");\n             }\n         }\n+        last_part = Some(part.to_owned());\n     }\n+    if last_part.is_none() { return result::Err(~\"could not parse id: is empty\"); }\n \n-    result::Ok(copy *parts.last())\n+    result::Ok(last_part.unwrap())\n }\n \n struct ListenerFn {"}, {"sha": "02858de9b347fffca6015ef1a3e6a542e2771ce4", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -16,12 +16,16 @@ pub trait ToBase64 {\n     fn to_base64(&self) -> ~str;\n }\n \n+static CHARS: [char * 64] = [\n+    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n+    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n+];\n+\n impl ToBase64 for &'self [u8] {\n     fn to_base64(&self) -> ~str {\n-        let chars = str::chars(\n-          ~\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n-        );\n-\n         let mut s = ~\"\";\n         unsafe {\n             let len = self.len();\n@@ -35,10 +39,10 @@ impl ToBase64 for &'self [u8] {\n                         (self[i + 2u] as uint);\n \n                 // This 24-bit number gets separated into four 6-bit numbers.\n-                str::push_char(&mut s, chars[(n >> 18u) & 63u]);\n-                str::push_char(&mut s, chars[(n >> 12u) & 63u]);\n-                str::push_char(&mut s, chars[(n >> 6u) & 63u]);\n-                str::push_char(&mut s, chars[n & 63u]);\n+                str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n+                str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n+                str::push_char(&mut s, CHARS[(n >> 6u) & 63u]);\n+                str::push_char(&mut s, CHARS[n & 63u]);\n \n                 i += 3u;\n             }\n@@ -49,17 +53,17 @@ impl ToBase64 for &'self [u8] {\n               0 => (),\n               1 => {\n                 let n = (self[i] as uint) << 16u;\n-                str::push_char(&mut s, chars[(n >> 18u) & 63u]);\n-                str::push_char(&mut s, chars[(n >> 12u) & 63u]);\n+                str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n+                str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n                 str::push_char(&mut s, '=');\n                 str::push_char(&mut s, '=');\n               }\n               2 => {\n                 let n = (self[i] as uint) << 16u |\n                     (self[i + 1u] as uint) << 8u;\n-                str::push_char(&mut s, chars[(n >> 18u) & 63u]);\n-                str::push_char(&mut s, chars[(n >> 12u) & 63u]);\n-                str::push_char(&mut s, chars[(n >> 6u) & 63u]);\n+                str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n+                str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n+                str::push_char(&mut s, CHARS[(n >> 6u) & 63u]);\n                 str::push_char(&mut s, '=');\n               }\n               _ => fail!(~\"Algebra is broken, please alert the math police\")"}, {"sha": "ae783fb9b697de69b89e3eed697e018a2f18f0ed", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -244,7 +244,8 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n                 let mut i_arg = None;\n                 if cur[1] == '-' as u8 {\n                     let tail = str::slice(cur, 2, curlen).to_owned();\n-                    let tail_eq = str::splitn_char(tail, '=', 1);\n+                    let mut tail_eq = ~[];\n+                    for str::each_splitn_char(tail, '=', 1) |s| { tail_eq.push(s.to_owned()) }\n                     if tail_eq.len() <= 1 {\n                         names = ~[Long(tail)];\n                     } else {\n@@ -601,7 +602,7 @@ pub mod groups {\n             row += match short_name.len() {\n                 0 => ~\"\",\n                 1 => ~\"-\" + short_name + \" \",\n-                _ => fail!(~\"the short name should only be 1 char long\"),\n+                _ => fail!(~\"the short name should only be 1 ascii char long\"),\n             };\n \n             // long option\n@@ -617,6 +618,7 @@ pub mod groups {\n                 Maybe => ~\"[\" + hint + ~\"]\",\n             };\n \n+            // FIXME: #5516\n             // here we just need to indent the start of the description\n             let rowlen = row.len();\n             row += if rowlen < 24 {\n@@ -625,8 +627,22 @@ pub mod groups {\n                 desc_sep\n             };\n \n+            // Normalize desc to contain words seperated by one space character\n+            let mut desc_normalized_whitespace = ~\"\";\n+            for str::each_word(desc) |word| {\n+                desc_normalized_whitespace.push_str(word);\n+                desc_normalized_whitespace.push_char(' ');\n+            }\n+\n+            // FIXME: #5516\n+            let mut desc_rows = ~[];\n+            for str::each_split_within(desc_normalized_whitespace, 54) |substr| {\n+                desc_rows.push(substr.to_owned());\n+            }\n+\n+            // FIXME: #5516\n             // wrapped description\n-            row += str::connect(str::split_within(desc, 54), desc_sep);\n+            row += str::connect(desc_rows, desc_sep);\n \n             row\n         });"}, {"sha": "f39e406bc0060b5e05c3ce9f9e5f6c892cc39059", "filename": "src/libstd/json.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -806,7 +806,8 @@ impl serialize::Decoder for Decoder<'self> {\n     }\n \n     fn read_char(&self) -> char {\n-        let v = str::chars(self.read_owned_str());\n+        let mut v = ~[];\n+        for str::each_char(self.read_owned_str()) |c| { v.push(c) }\n         if v.len() != 1 { fail!(~\"string must have one character\") }\n         v[0]\n     }"}, {"sha": "4d82d35cc32062f39c5b92a8325a31de8f8bed62", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -197,7 +197,9 @@ pub mod v4 {\n         }\n     }\n     pub fn parse_to_ipv4_rep(ip: &str) -> result::Result<Ipv4Rep, ~str> {\n-        let parts = vec::map(str::split_char(ip, '.'), |s| {\n+        let mut parts = ~[];\n+        for str::each_split_char(ip, '.') |s| { parts.push(s.to_owned()) }\n+        let parts = vec::map(parts, |s| {\n             match uint::from_str(*s) {\n               Some(n) if n <= 255 => n,\n               _ => 256"}, {"sha": "9caab11d6434ed38752f2a44939b1e80104fd026", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -344,8 +344,8 @@ fn userinfo_to_str(userinfo: &UserInfo) -> ~str {\n fn query_from_str(rawquery: &str) -> Query {\n     let mut query: Query = ~[];\n     if str::len(rawquery) != 0 {\n-        for str::split_char(rawquery, '&').each |p| {\n-            let (k, v) = split_char_first(*p, '=');\n+        for str::each_split_char(rawquery, '&') |p| {\n+            let (k, v) = split_char_first(p, '=');\n             // FIXME(#3722): unsafe only because decode_inner does (string) IO\n             unsafe {query.push((decode_component(k), decode_component(v)));}\n         };"}, {"sha": "1b6b25db38ad640248bd049ca8777a5f4bcbfd40", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -99,7 +99,8 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         }\n \n         return do lines.map |line| {\n-            let chars = str::chars(*line);\n+            let mut chars = ~[];\n+            for str::each_char(*line) |c| { chars.push(c) }\n             if i > chars.len() {\n                 ~\"\"\n             } else {\n@@ -116,7 +117,10 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n     }\n \n     if comment.starts_with(~\"/*\") {\n-        let lines = str::lines_any(comment.slice(3u, comment.len() - 2u).to_owned());\n+        let mut lines = ~[];\n+        for str::each_line_any(comment.slice(3u, comment.len() - 2u)) |line| {\n+            lines.push(line.to_owned())\n+        }\n         let lines = vertical_trim(lines);\n         let lines = block_trim(lines, ~\"\\t \", None);\n         let lines = block_trim(lines, ~\"*\", Some(1u));"}, {"sha": "dcc5fe58755228c2585fa0c6fc044994ec5b7d58", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -68,7 +68,8 @@ pub impl Sudoku {\n         let mut g = vec::from_fn(10u, { |_i| ~[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8] });\n         while !reader.eof() {\n             let line = reader.read_line();\n-            let comps = str::split_char(line.trim(), ',');\n+            let mut comps = ~[];\n+            for str::each_split_char(line.trim(), ',') |s| { comps.push(s.to_owned()) }\n             if vec::len(comps) == 3u {\n                 let row     = uint::from_str(comps[0]).get() as u8;\n                 let col     = uint::from_str(comps[1]).get() as u8;"}, {"sha": "247fd2d712a16349b012b11501e18b68533ab04c", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d588c528685fa0590ff91f189f0ef44a3815ec2/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=3d588c528685fa0590ff91f189f0ef44a3815ec2", "patch": "@@ -17,8 +17,8 @@ pub fn main() {\n \n     fail_unless!((str::len(s) == 10u));\n     fail_unless!((str::char_len(s) == 4u));\n-    fail_unless!((vec::len(str::chars(s)) == 4u));\n-    fail_unless!((str::from_chars(str::chars(s)) == s));\n+    fail_unless!((vec::len(str::to_chars(s)) == 4u));\n+    fail_unless!((str::from_chars(str::to_chars(s)) == s));\n     fail_unless!((str::char_at(s, 0u) == 'e'));\n     fail_unless!((str::char_at(s, 1u) == '\u00e9'));\n "}]}