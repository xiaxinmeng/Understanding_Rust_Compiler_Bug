{"sha": "e43f99ce576152d4b2f7315d491c4210211228d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0M2Y5OWNlNTc2MTUyZDRiMmY3MzE1ZDQ5MWM0MjEwMjExMjI4ZDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-04T08:26:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-04T08:26:18Z"}, "message": "Auto merge of #59517 - Zoxc:new-queries, r=oli-obk\n\nMove query definitions over to the proc macro\n\nr? @oli-obk", "tree": {"sha": "23a38ead4e2d6caa995b02fe4221d96dcdba37fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23a38ead4e2d6caa995b02fe4221d96dcdba37fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e43f99ce576152d4b2f7315d491c4210211228d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e43f99ce576152d4b2f7315d491c4210211228d6", "html_url": "https://github.com/rust-lang/rust/commit/e43f99ce576152d4b2f7315d491c4210211228d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e43f99ce576152d4b2f7315d491c4210211228d6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f717b58dd70829f105960a071c7992b440720482", "url": "https://api.github.com/repos/rust-lang/rust/commits/f717b58dd70829f105960a071c7992b440720482", "html_url": "https://github.com/rust-lang/rust/commit/f717b58dd70829f105960a071c7992b440720482"}, {"sha": "45580684825c1855a4be5a7b4cd28525b24e7322", "url": "https://api.github.com/repos/rust-lang/rust/commits/45580684825c1855a4be5a7b4cd28525b24e7322", "html_url": "https://github.com/rust-lang/rust/commit/45580684825c1855a4be5a7b4cd28525b24e7322"}], "stats": {"total": 3590, "additions": 1274, "deletions": 2316}, "files": [{"sha": "e5bf9a27ab0500b40d1b5bde87e152e07b72d3ff", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 9, "deletions": 202, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -65,8 +65,7 @@ use crate::traits::query::{\n     CanonicalTypeOpEqGoal, CanonicalTypeOpSubtypeGoal, CanonicalPredicateGoal,\n     CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpNormalizeGoal,\n };\n-use crate::ty::{TyCtxt, FnSig, Instance, InstanceDef,\n-         ParamEnv, ParamEnvAnd, Predicate, PolyFnSig, PolyTraitRef, Ty};\n+use crate::ty::{self, TyCtxt, ParamEnvAnd, Ty};\n use crate::ty::subst::SubstsRef;\n \n // erase!() just makes tokens go away. It's used to specify which macro argument\n@@ -432,211 +431,13 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n     // Represents metadata from an extern crate.\n     [eval_always] CrateMetadata(CrateNum),\n \n-    // Represents different phases in the compiler.\n-    [] RegionScopeTree(DefId),\n-    [eval_always] Coherence,\n-    [eval_always] CoherenceInherentImplOverlapCheck,\n-    [] CoherenceCheckTrait(DefId),\n-    [eval_always] PrivacyAccessLevels(CrateNum),\n-    [eval_always] CheckPrivateInPublic(CrateNum),\n-    [eval_always] Analysis(CrateNum),\n-\n-    // Represents the MIR for a fn; also used as the task node for\n-    // things read/modify that MIR.\n-    [] MirShim { instance_def: InstanceDef<'tcx> },\n-\n-    [] BorrowCheckKrate,\n-    [] BorrowCheck(DefId),\n-    [] MirBorrowCheck(DefId),\n-    [] UnsafetyCheckResult(DefId),\n-    [] UnsafeDeriveOnReprPacked(DefId),\n-\n-    [] LintMod(DefId),\n-    [] CheckModAttrs(DefId),\n-    [] CheckModLoops(DefId),\n-    [] CheckModUnstableApiUsage(DefId),\n-    [] CheckModItemTypes(DefId),\n-    [] CheckModPrivacy(DefId),\n-    [] CheckModIntrinsics(DefId),\n-    [] CheckModLiveness(DefId),\n-    [] CheckModImplWf(DefId),\n-    [] CollectModItemTypes(DefId),\n-\n-    [] Reachability,\n-    [] CrateVariances,\n-\n-    // Nodes representing bits of computed IR in the tcx. Each shared\n-    // table in the tcx (or elsewhere) maps to one of these\n-    // nodes.\n-    [] AssociatedItems(DefId),\n-    [] ExplicitPredicatesOfItem(DefId),\n-    [] PredicatesDefinedOnItem(DefId),\n-    [] InferredOutlivesOf(DefId),\n-    [] InferredOutlivesCrate(CrateNum),\n-    [] SuperPredicatesOfItem(DefId),\n-    [] TraitDefOfItem(DefId),\n-    [] AdtDefOfItem(DefId),\n-    [] ImplTraitRef(DefId),\n-    [] ImplPolarity(DefId),\n-    [] Issue33140SelfTy(DefId),\n-    [] FnSignature(DefId),\n-    [] CoerceUnsizedInfo(DefId),\n-\n-    [] ItemVarianceConstraints(DefId),\n-    [] ItemVariances(DefId),\n-    [] IsConstFn(DefId),\n-    [] IsPromotableConstFn(DefId),\n-    [] IsForeignItem(DefId),\n-    [] TypeParamPredicates { item_id: DefId, param_id: DefId },\n-    [] SizedConstraint(DefId),\n-    [] DtorckConstraint(DefId),\n-    [] AdtDestructor(DefId),\n-    [] AssociatedItemDefIds(DefId),\n-    [eval_always] InherentImpls(DefId),\n-    [] TypeckBodiesKrate,\n-    [] TypeckTables(DefId),\n-    [] UsedTraitImports(DefId),\n-    [] HasTypeckTables(DefId),\n-    [] ConstEval { param_env: ParamEnvAnd<'tcx, GlobalId<'tcx>> },\n-    [] ConstEvalRaw { param_env: ParamEnvAnd<'tcx, GlobalId<'tcx>> },\n-    [] CheckMatch(DefId),\n-    [] SymbolName { instance: Instance<'tcx> },\n-    [] SpecializationGraph(DefId),\n-    [] ObjectSafety(DefId),\n-    [] FulfillObligation { param_env: ParamEnv<'tcx>, trait_ref: PolyTraitRef<'tcx> },\n-    [] VtableMethods { trait_ref: PolyTraitRef<'tcx> },\n-\n-    [] IsCopy { param_env: ParamEnvAnd<'tcx, Ty<'tcx>> },\n-    [] IsSized { param_env: ParamEnvAnd<'tcx, Ty<'tcx>> },\n-    [] IsFreeze { param_env: ParamEnvAnd<'tcx, Ty<'tcx>> },\n-    [] NeedsDrop { param_env: ParamEnvAnd<'tcx, Ty<'tcx>> },\n-    [] Layout { param_env: ParamEnvAnd<'tcx, Ty<'tcx>> },\n-\n-    // The set of impls for a given trait.\n-    [] TraitImpls(DefId),\n-\n     [eval_always] AllLocalTraitImpls,\n \n     [anon] TraitSelect,\n \n-    [] ParamEnv(DefId),\n-    [] DescribeDef(DefId),\n-\n-    // FIXME(mw): DefSpans are not really inputs since they are derived from\n-    // HIR. But at the moment HIR hashing still contains some hacks that allow\n-    // to make type debuginfo to be source location independent. Declaring\n-    // DefSpan an input makes sure that changes to these are always detected\n-    // regardless of HIR hashing.\n-    [eval_always] DefSpan(DefId),\n-    [] LookupStability(DefId),\n-    [] LookupDeprecationEntry(DefId),\n-    [] ConstIsRvaluePromotableToStatic(DefId),\n-    [] RvaluePromotableMap(DefId),\n-    [] ImplParent(DefId),\n-    [] TraitOfItem(DefId),\n-    [] IsReachableNonGeneric(DefId),\n-    [] IsUnreachableLocalDefinition(DefId),\n-    [] IsMirAvailable(DefId),\n-    [] ItemAttrs(DefId),\n-    [] CodegenFnAttrs(DefId),\n-    [] FnArgNames(DefId),\n-    [] RenderedConst(DefId),\n-    [] DylibDepFormats(CrateNum),\n-    [] IsCompilerBuiltins(CrateNum),\n-    [] HasGlobalAllocator(CrateNum),\n-    [] HasPanicHandler(CrateNum),\n-    [eval_always] ExternCrate(DefId),\n-    [] Specializes { impl1: DefId, impl2: DefId },\n-    [eval_always] InScopeTraits(DefIndex),\n-    [eval_always] ModuleExports(DefId),\n-    [] IsSanitizerRuntime(CrateNum),\n-    [] IsProfilerRuntime(CrateNum),\n-    [] GetPanicStrategy(CrateNum),\n-    [] IsNoBuiltins(CrateNum),\n-    [] ImplDefaultness(DefId),\n-    [] CheckItemWellFormed(DefId),\n-    [] CheckTraitItemWellFormed(DefId),\n-    [] CheckImplItemWellFormed(DefId),\n-    [] ReachableNonGenerics(CrateNum),\n-    [] EntryFn(CrateNum),\n-    [] PluginRegistrarFn(CrateNum),\n-    [] ProcMacroDeclsStatic(CrateNum),\n-    [eval_always] CrateDisambiguator(CrateNum),\n-    [eval_always] CrateHash(CrateNum),\n-    [eval_always] OriginalCrateName(CrateNum),\n-    [eval_always] ExtraFileName(CrateNum),\n-\n-    [] ImplementationsOfTrait { krate: CrateNum, trait_id: DefId },\n-    [] AllTraitImplementations(CrateNum),\n-\n-    [] DllimportForeignItems(CrateNum),\n-    [] IsDllimportForeignItem(DefId),\n-    [] IsStaticallyIncludedForeignItem(DefId),\n-    [] NativeLibraryKind(DefId),\n-    [eval_always] LinkArgs,\n-\n-    [] ResolveLifetimes(CrateNum),\n-    [] NamedRegion(DefIndex),\n-    [] IsLateBound(DefIndex),\n-    [] ObjectLifetimeDefaults(DefIndex),\n-\n-    [] Visibility(DefId),\n-    [eval_always] DepKind(CrateNum),\n-    [eval_always] CrateName(CrateNum),\n-    [] ItemChildren(DefId),\n-    [] ExternModStmtCnum(DefId),\n-    [eval_always] GetLibFeatures,\n-    [] DefinedLibFeatures(CrateNum),\n-    [eval_always] GetLangItems,\n-    [] DefinedLangItems(CrateNum),\n-    [] MissingLangItems(CrateNum),\n-    [] VisibleParentMap,\n-    [eval_always] MissingExternCrateItem(CrateNum),\n-    [eval_always] UsedCrateSource(CrateNum),\n-    [eval_always] PostorderCnums,\n-\n-    [eval_always] Freevars(DefId),\n-    [eval_always] MaybeUnusedTraitImport(DefId),\n-    [eval_always] MaybeUnusedExternCrates,\n-    [eval_always] NamesImportedByGlobUse(DefId),\n-    [eval_always] StabilityIndex,\n-    [eval_always] AllTraits,\n-    [eval_always] AllCrateNums,\n-    [] ExportedSymbols(CrateNum),\n-    [eval_always] CollectAndPartitionMonoItems,\n-    [] IsCodegenedItem(DefId),\n-    [] CodegenUnit(InternedString),\n-    [] BackendOptimizationLevel(CrateNum),\n     [] CompileCodegenUnit(InternedString),\n-    [eval_always] OutputFilenames,\n-    [] NormalizeProjectionTy(CanonicalProjectionGoal<'tcx>),\n-    [] NormalizeTyAfterErasingRegions(ParamEnvAnd<'tcx, Ty<'tcx>>),\n-    [] ImpliedOutlivesBounds(CanonicalTyGoal<'tcx>),\n-    [] DropckOutlives(CanonicalTyGoal<'tcx>),\n-    [] EvaluateObligation(CanonicalPredicateGoal<'tcx>),\n-    [] EvaluateGoal(traits::ChalkCanonicalGoal<'tcx>),\n-    [] TypeOpAscribeUserType(CanonicalTypeOpAscribeUserTypeGoal<'tcx>),\n-    [] TypeOpEq(CanonicalTypeOpEqGoal<'tcx>),\n-    [] TypeOpSubtype(CanonicalTypeOpSubtypeGoal<'tcx>),\n-    [] TypeOpProvePredicate(CanonicalTypeOpProvePredicateGoal<'tcx>),\n-    [] TypeOpNormalizeTy(CanonicalTypeOpNormalizeGoal<'tcx, Ty<'tcx>>),\n-    [] TypeOpNormalizePredicate(CanonicalTypeOpNormalizeGoal<'tcx, Predicate<'tcx>>),\n-    [] TypeOpNormalizePolyFnSig(CanonicalTypeOpNormalizeGoal<'tcx, PolyFnSig<'tcx>>),\n-    [] TypeOpNormalizeFnSig(CanonicalTypeOpNormalizeGoal<'tcx, FnSig<'tcx>>),\n-\n-    [] SubstituteNormalizeAndTestPredicates { key: (DefId, SubstsRef<'tcx>) },\n-    [] MethodAutoderefSteps(CanonicalTyGoal<'tcx>),\n-\n-    [eval_always] TargetFeaturesWhitelist,\n-\n-    [] InstanceDefSizeEstimate { instance_def: InstanceDef<'tcx> },\n-\n-    [eval_always] Features,\n-\n-    [] ForeignModules(CrateNum),\n-\n-    [] UpstreamMonomorphizations(CrateNum),\n-    [] UpstreamMonomorphizationsFor(DefId),\n+\n+    [eval_always] Analysis(CrateNum),\n ]);\n \n pub trait RecoverKey<'tcx>: Sized {\n@@ -655,6 +456,12 @@ impl RecoverKey<'tcx> for DefId {\n     }\n }\n \n+impl RecoverKey<'tcx> for DefIndex {\n+    fn recover(tcx: TyCtxt<'_, 'tcx, 'tcx>, dep_node: &DepNode) -> Option<Self> {\n+        dep_node.extract_def_id(tcx).map(|id| id.index)\n+    }\n+}\n+\n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool;\n "}, {"sha": "8896f9f9728814e4b1ac4562e3fa0e438d3335b7", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 920, "deletions": 2, "changes": 922, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -1,10 +1,21 @@\n use crate::ty::query::QueryDescription;\n use crate::ty::query::queries;\n-use crate::ty::{self, Ty, TyCtxt};\n-use crate::hir::def_id::{DefId, CrateNum};\n+use crate::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n+use crate::ty::subst::SubstsRef;\n use crate::dep_graph::SerializedDepNodeIndex;\n+use crate::hir::def_id::{CrateNum, DefId, DefIndex};\n+use crate::mir::interpret::GlobalId;\n use crate::traits;\n+use crate::traits::query::{\n+    CanonicalPredicateGoal, CanonicalProjectionGoal,\n+    CanonicalTyGoal, CanonicalTypeOpAscribeUserTypeGoal,\n+    CanonicalTypeOpEqGoal, CanonicalTypeOpSubtypeGoal, CanonicalTypeOpProvePredicateGoal,\n+    CanonicalTypeOpNormalizeGoal,\n+};\n+\n use std::borrow::Cow;\n+use syntax_pos::symbol::InternedString;\n+\n \n // Each of these queries corresponds to a function pointer field in the\n // `Providers` struct for requesting a value of that type, and a method\n@@ -148,4 +159,911 @@ rustc_queries! {\n             desc { \"wasm import module map\" }\n         }\n     }\n+\n+    Other {\n+        /// Maps from the `DefId` of an item (trait/struct/enum/fn) to the\n+        /// predicates (where-clauses) directly defined on it. This is\n+        /// equal to the `explicit_predicates_of` predicates plus the\n+        /// `inferred_outlives_of` predicates.\n+        query predicates_defined_on(_: DefId)\n+            -> Lrc<ty::GenericPredicates<'tcx>> {}\n+\n+        /// Returns the predicates written explicit by the user.\n+        query explicit_predicates_of(_: DefId)\n+            -> Lrc<ty::GenericPredicates<'tcx>> {}\n+\n+        /// Returns the inferred outlives predicates (e.g., for `struct\n+        /// Foo<'a, T> { x: &'a T }`, this would return `T: 'a`).\n+        query inferred_outlives_of(_: DefId) -> Lrc<Vec<ty::Predicate<'tcx>>> {}\n+\n+        /// Maps from the `DefId` of a trait to the list of\n+        /// super-predicates. This is a subset of the full list of\n+        /// predicates. We store these in a separate map because we must\n+        /// evaluate them even during type conversion, often before the\n+        /// full predicates are available (note that supertraits have\n+        /// additional acyclicity requirements).\n+        query super_predicates_of(key: DefId) -> Lrc<ty::GenericPredicates<'tcx>> {\n+            desc { |tcx| \"computing the supertraits of `{}`\", tcx.def_path_str(key) }\n+        }\n+\n+        /// To avoid cycles within the predicates of a single item we compute\n+        /// per-type-parameter predicates for resolving `T::AssocTy`.\n+        query type_param_predicates(key: (DefId, DefId))\n+            -> Lrc<ty::GenericPredicates<'tcx>> {\n+            no_force\n+            desc { |tcx| \"computing the bounds for type parameter `{}`\", {\n+                let id = tcx.hir().as_local_hir_id(key.1).unwrap();\n+                tcx.hir().ty_param_name(id)\n+            }}\n+        }\n+\n+        query trait_def(_: DefId) -> &'tcx ty::TraitDef {}\n+        query adt_def(_: DefId) -> &'tcx ty::AdtDef {}\n+        query adt_destructor(_: DefId) -> Option<ty::Destructor> {}\n+\n+        // The cycle error here should be reported as an error by `check_representable`.\n+        // We consider the type as Sized in the meanwhile to avoid\n+        // further errors (done in impl Value for AdtSizedConstraint).\n+        // Use `cycle_delay_bug` to delay the cycle error here to be emitted later\n+        // in case we accidentally otherwise don't emit an error.\n+        query adt_sized_constraint(\n+            _: DefId\n+        ) -> AdtSizedConstraint<'tcx> {\n+            cycle_delay_bug\n+        }\n+\n+        query adt_dtorck_constraint(\n+            _: DefId\n+        ) -> Result<DtorckConstraint<'tcx>, NoSolution> {}\n+\n+        /// True if this is a const fn, use the `is_const_fn` to know whether your crate actually\n+        /// sees it as const fn (e.g., the const-fn-ness might be unstable and you might not have\n+        /// the feature gate active)\n+        ///\n+        /// **Do not call this function manually.** It is only meant to cache the base data for the\n+        /// `is_const_fn` function.\n+        query is_const_fn_raw(key: DefId) -> bool {\n+            desc { |tcx| \"checking if item is const fn: `{}`\", tcx.def_path_str(key) }\n+        }\n+\n+        /// Returns true if calls to the function may be promoted\n+        ///\n+        /// This is either because the function is e.g., a tuple-struct or tuple-variant\n+        /// constructor, or because it has the `#[rustc_promotable]` attribute. The attribute should\n+        /// be removed in the future in favour of some form of check which figures out whether the\n+        /// function does not inspect the bits of any of its arguments (so is essentially just a\n+        /// constructor function).\n+        query is_promotable_const_fn(_: DefId) -> bool {}\n+\n+        /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n+        query is_foreign_item(_: DefId) -> bool {}\n+\n+        /// Get a map with the variance of every item; use `item_variance`\n+        /// instead.\n+        query crate_variances(_: CrateNum) -> Lrc<ty::CrateVariancesMap> {\n+            desc { \"computing the variances for items in this crate\" }\n+        }\n+\n+        /// Maps from def-id of a type or region parameter to its\n+        /// (inferred) variance.\n+        query variances_of(_: DefId) -> Lrc<Vec<ty::Variance>> {}\n+    }\n+\n+    TypeChecking {\n+        /// Maps from def-id of a type to its (inferred) outlives.\n+        query inferred_outlives_crate(_: CrateNum)\n+            -> Lrc<ty::CratePredicatesMap<'tcx>> {\n+            desc { \"computing the inferred outlives predicates for items in this crate\" }\n+        }\n+    }\n+\n+    Other {\n+        /// Maps from an impl/trait def-id to a list of the def-ids of its items\n+        query associated_item_def_ids(_: DefId) -> Lrc<Vec<DefId>> {}\n+\n+        /// Maps from a trait item to the trait item \"descriptor\"\n+        query associated_item(_: DefId) -> ty::AssociatedItem {}\n+\n+        query impl_trait_ref(_: DefId) -> Option<ty::TraitRef<'tcx>> {}\n+        query impl_polarity(_: DefId) -> hir::ImplPolarity {}\n+\n+        query issue33140_self_ty(_: DefId) -> Option<ty::Ty<'tcx>> {}\n+    }\n+\n+    TypeChecking {\n+        /// Maps a DefId of a type to a list of its inherent impls.\n+        /// Contains implementations of methods that are inherent to a type.\n+        /// Methods in these implementations don't need to be exported.\n+        query inherent_impls(_: DefId) -> Lrc<Vec<DefId>> {\n+            eval_always\n+        }\n+    }\n+\n+    TypeChecking {\n+        /// The result of unsafety-checking this `DefId`.\n+        query unsafety_check_result(_: DefId) -> mir::UnsafetyCheckResult {}\n+\n+        /// HACK: when evaluated, this reports a \"unsafe derive on repr(packed)\" error\n+        query unsafe_derive_on_repr_packed(_: DefId) -> () {}\n+\n+        /// The signature of functions and closures.\n+        query fn_sig(_: DefId) -> ty::PolyFnSig<'tcx> {}\n+    }\n+\n+    Other {\n+        query lint_mod(key: DefId) -> () {\n+            desc { |tcx| \"linting {}\", key.describe_as_module(tcx) }\n+        }\n+\n+        /// Checks the attributes in the module\n+        query check_mod_attrs(key: DefId) -> () {\n+            desc { |tcx| \"checking attributes in {}\", key.describe_as_module(tcx) }\n+        }\n+\n+        query check_mod_unstable_api_usage(key: DefId) -> () {\n+            desc { |tcx| \"checking for unstable API usage in {}\", key.describe_as_module(tcx) }\n+        }\n+\n+        /// Checks the loops in the module\n+        query check_mod_loops(key: DefId) -> () {\n+            desc { |tcx| \"checking loops in {}\", key.describe_as_module(tcx) }\n+        }\n+\n+        query check_mod_item_types(key: DefId) -> () {\n+            desc { |tcx| \"checking item types in {}\", key.describe_as_module(tcx) }\n+        }\n+\n+        query check_mod_privacy(key: DefId) -> () {\n+            desc { |tcx| \"checking privacy in {}\", key.describe_as_module(tcx) }\n+        }\n+\n+        query check_mod_intrinsics(key: DefId) -> () {\n+            desc { |tcx| \"checking intrinsics in {}\", key.describe_as_module(tcx) }\n+        }\n+\n+        query check_mod_liveness(key: DefId) -> () {\n+            desc { |tcx| \"checking liveness of variables in {}\", key.describe_as_module(tcx) }\n+        }\n+\n+        query check_mod_impl_wf(key: DefId) -> () {\n+            desc { |tcx| \"checking that impls are well-formed in {}\", key.describe_as_module(tcx) }\n+        }\n+\n+        query collect_mod_item_types(key: DefId) -> () {\n+            desc { |tcx| \"collecting item types in {}\", key.describe_as_module(tcx) }\n+        }\n+\n+        /// Caches CoerceUnsized kinds for impls on custom types.\n+        query coerce_unsized_info(_: DefId)\n+            -> ty::adjustment::CoerceUnsizedInfo {}\n+    }\n+\n+    TypeChecking {\n+        query typeck_item_bodies(_: CrateNum) -> () {\n+            desc { \"type-checking all item bodies\" }\n+        }\n+\n+        query typeck_tables_of(key: DefId) -> &'tcx ty::TypeckTables<'tcx> {\n+            cache { key.is_local() }\n+            load_cached(tcx, id) {\n+                let typeck_tables: Option<ty::TypeckTables<'tcx>> = tcx\n+                    .queries.on_disk_cache\n+                    .try_load_query_result(tcx, id);\n+\n+                typeck_tables.map(|tables| tcx.alloc_tables(tables))\n+            }\n+        }\n+    }\n+\n+    Other {\n+        query used_trait_imports(_: DefId) -> Lrc<DefIdSet> {}\n+    }\n+\n+    TypeChecking {\n+        query has_typeck_tables(_: DefId) -> bool {}\n+\n+        query coherent_trait(def_id: DefId) -> () {\n+            no_force\n+            desc { |tcx| \"coherence checking all impls of trait `{}`\", tcx.def_path_str(def_id) }\n+        }\n+    }\n+\n+    BorrowChecking {\n+        query borrowck(_: DefId) -> Lrc<BorrowCheckResult> {}\n+\n+        /// Borrow checks the function body. If this is a closure, returns\n+        /// additional requirements that the closure's creator must verify.\n+        query mir_borrowck(_: DefId) -> mir::BorrowCheckResult<'tcx> {}\n+    }\n+\n+    TypeChecking {\n+        /// Gets a complete map from all types to their inherent impls.\n+        /// Not meant to be used directly outside of coherence.\n+        /// (Defined only for `LOCAL_CRATE`.)\n+        query crate_inherent_impls(k: CrateNum)\n+            -> Lrc<CrateInherentImpls> {\n+            eval_always\n+            desc { \"all inherent impls defined in crate `{:?}`\", k }\n+        }\n+\n+        /// Checks all types in the crate for overlap in their inherent impls. Reports errors.\n+        /// Not meant to be used directly outside of coherence.\n+        /// (Defined only for `LOCAL_CRATE`.)\n+        query crate_inherent_impls_overlap_check(_: CrateNum)\n+            -> () {\n+            eval_always\n+            desc { \"check for overlap between inherent impls defined in this crate\" }\n+        }\n+    }\n+\n+    Other {\n+        /// Evaluate a constant without running sanity checks\n+        ///\n+        /// **Do not use this** outside const eval. Const eval uses this to break query cycles\n+        /// during validation. Please add a comment to every use site explaining why using\n+        /// `const_eval` isn't sufficient\n+        query const_eval_raw(key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n+            -> ConstEvalRawResult<'tcx> {\n+            no_force\n+            desc { |tcx|\n+                \"const-evaluating `{}`\",\n+                tcx.def_path_str(key.value.instance.def.def_id())\n+            }\n+            cache { true }\n+            load_cached(tcx, id) {\n+                tcx.queries.on_disk_cache.try_load_query_result(tcx, id).map(Ok)\n+            }\n+        }\n+\n+        /// Results of evaluating const items or constants embedded in\n+        /// other items (such as enum variant explicit discriminants).\n+        query const_eval(key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n+            -> ConstEvalResult<'tcx> {\n+            no_force\n+            desc { |tcx|\n+                \"const-evaluating + checking `{}`\",\n+                tcx.def_path_str(key.value.instance.def.def_id())\n+            }\n+            cache { true }\n+            load_cached(tcx, id) {\n+                tcx.queries.on_disk_cache.try_load_query_result(tcx, id).map(Ok)\n+            }\n+        }\n+    }\n+\n+    TypeChecking {\n+        query check_match(_: DefId) -> () {}\n+\n+        /// Performs part of the privacy check and computes \"access levels\".\n+        query privacy_access_levels(_: CrateNum) -> Lrc<AccessLevels> {\n+            eval_always\n+            desc { \"privacy access levels\" }\n+        }\n+        query check_private_in_public(_: CrateNum) -> () {\n+            eval_always\n+            desc { \"checking for private elements in public interfaces\" }\n+        }\n+    }\n+\n+    Other {\n+        query reachable_set(_: CrateNum) -> ReachableSet {\n+            desc { \"reachability\" }\n+        }\n+\n+        /// Per-body `region::ScopeTree`. The `DefId` should be the owner `DefId` for the body;\n+        /// in the case of closures, this will be redirected to the enclosing function.\n+        query region_scope_tree(_: DefId) -> Lrc<region::ScopeTree> {}\n+\n+        query mir_shims(key: ty::InstanceDef<'tcx>) -> &'tcx mir::Mir<'tcx> {\n+            no_force\n+            desc { |tcx| \"generating MIR shim for `{}`\", tcx.def_path_str(key.def_id()) }\n+        }\n+\n+        query symbol_name(key: ty::Instance<'tcx>) -> ty::SymbolName {\n+            no_force\n+            desc { \"computing the symbol for `{}`\", key }\n+            cache { true }\n+        }\n+\n+        query describe_def(_: DefId) -> Option<Def> {}\n+        query def_span(_: DefId) -> Span {\n+            // FIXME(mw): DefSpans are not really inputs since they are derived from\n+            // HIR. But at the moment HIR hashing still contains some hacks that allow\n+            // to make type debuginfo to be source location independent. Declaring\n+            // DefSpan an input makes sure that changes to these are always detected\n+            // regardless of HIR hashing.\n+            eval_always\n+        }\n+        query lookup_stability(_: DefId) -> Option<&'tcx attr::Stability> {}\n+        query lookup_deprecation_entry(_: DefId) -> Option<DeprecationEntry> {}\n+        query item_attrs(_: DefId) -> Lrc<[ast::Attribute]> {}\n+    }\n+\n+    Codegen {\n+        query codegen_fn_attrs(_: DefId) -> CodegenFnAttrs {}\n+    }\n+\n+    Other {\n+        query fn_arg_names(_: DefId) -> Vec<ast::Name> {}\n+        /// Gets the rendered value of the specified constant or associated constant.\n+        /// Used by rustdoc.\n+        query rendered_const(_: DefId) -> String {}\n+        query impl_parent(_: DefId) -> Option<DefId> {}\n+    }\n+\n+    TypeChecking {\n+        query trait_of_item(_: DefId) -> Option<DefId> {}\n+        query const_is_rvalue_promotable_to_static(key: DefId) -> bool {\n+            desc { |tcx|\n+                \"const checking if rvalue is promotable to static `{}`\",\n+                tcx.def_path_str(key)\n+            }\n+            cache { true }\n+        }\n+        query rvalue_promotable_map(key: DefId) -> Lrc<ItemLocalSet> {\n+            desc { |tcx|\n+                \"checking which parts of `{}` are promotable to static\",\n+                tcx.def_path_str(key)\n+            }\n+        }\n+    }\n+\n+    Codegen {\n+        query is_mir_available(key: DefId) -> bool {\n+            desc { |tcx| \"checking if item has mir available: `{}`\", tcx.def_path_str(key) }\n+        }\n+    }\n+\n+    Other {\n+        query vtable_methods(key: ty::PolyTraitRef<'tcx>)\n+                            -> Lrc<Vec<Option<(DefId, SubstsRef<'tcx>)>>> {\n+            no_force\n+            desc { |tcx| \"finding all methods for trait {}\", tcx.def_path_str(key.def_id()) }\n+        }\n+    }\n+\n+    Codegen {\n+        query codegen_fulfill_obligation(\n+            key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)\n+        ) -> Vtable<'tcx, ()> {\n+            no_force\n+            cache { true }\n+            desc { |tcx|\n+                \"checking if `{}` fulfills its obligations\",\n+                tcx.def_path_str(key.1.def_id())\n+            }\n+        }\n+    }\n+\n+    TypeChecking {\n+        query trait_impls_of(key: DefId) -> Lrc<ty::trait_def::TraitImpls> {\n+            desc { |tcx| \"trait impls of `{}`\", tcx.def_path_str(key) }\n+        }\n+        query specialization_graph_of(_: DefId)\n+            -> Lrc<specialization_graph::Graph> {}\n+        query is_object_safe(key: DefId) -> bool {\n+            desc { |tcx| \"determine object safety of trait `{}`\", tcx.def_path_str(key) }\n+        }\n+\n+        /// Gets the ParameterEnvironment for a given item; this environment\n+        /// will be in \"user-facing\" mode, meaning that it is suitabe for\n+        /// type-checking etc, and it does not normalize specializable\n+        /// associated types. This is almost always what you want,\n+        /// unless you are doing MIR optimizations, in which case you\n+        /// might want to use `reveal_all()` method to change modes.\n+        query param_env(_: DefId) -> ty::ParamEnv<'tcx> {}\n+\n+        /// Trait selection queries. These are best used by invoking `ty.is_copy_modulo_regions()`,\n+        /// `ty.is_copy()`, etc, since that will prune the environment where possible.\n+        query is_copy_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n+            no_force\n+            desc { \"computing whether `{}` is `Copy`\", env.value }\n+        }\n+        query is_sized_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n+            no_force\n+            desc { \"computing whether `{}` is `Sized`\", env.value }\n+        }\n+        query is_freeze_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n+            no_force\n+            desc { \"computing whether `{}` is freeze\", env.value }\n+        }\n+\n+        // The cycle error here should be reported as an error by `check_representable`.\n+        // We consider the type as not needing drop in the meanwhile to avoid\n+        // further errors (done in impl Value for NeedsDrop).\n+        // Use `cycle_delay_bug` to delay the cycle error here to be emitted later\n+        // in case we accidentally otherwise don't emit an error.\n+        query needs_drop_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> NeedsDrop {\n+            cycle_delay_bug\n+            no_force\n+            desc { \"computing whether `{}` needs drop\", env.value }\n+        }\n+\n+        query layout_raw(\n+            env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n+        ) -> Result<&'tcx ty::layout::LayoutDetails, ty::layout::LayoutError<'tcx>> {\n+            no_force\n+            desc { \"computing layout of `{}`\", env.value }\n+        }\n+    }\n+\n+    Other {\n+        query dylib_dependency_formats(_: CrateNum)\n+                                        -> Lrc<Vec<(CrateNum, LinkagePreference)>> {\n+            desc { \"dylib dependency formats of crate\" }\n+        }\n+    }\n+\n+    Codegen {\n+        query is_compiler_builtins(_: CrateNum) -> bool {\n+            fatal_cycle\n+            desc { \"checking if the crate is_compiler_builtins\" }\n+        }\n+        query has_global_allocator(_: CrateNum) -> bool {\n+            fatal_cycle\n+            desc { \"checking if the crate has_global_allocator\" }\n+        }\n+        query has_panic_handler(_: CrateNum) -> bool {\n+            fatal_cycle\n+            desc { \"checking if the crate has_panic_handler\" }\n+        }\n+        query is_sanitizer_runtime(_: CrateNum) -> bool {\n+            fatal_cycle\n+            desc { \"query a crate is #![sanitizer_runtime]\" }\n+        }\n+        query is_profiler_runtime(_: CrateNum) -> bool {\n+            fatal_cycle\n+            desc { \"query a crate is #![profiler_runtime]\" }\n+        }\n+        query panic_strategy(_: CrateNum) -> PanicStrategy {\n+            fatal_cycle\n+            desc { \"query a crate's configured panic strategy\" }\n+        }\n+        query is_no_builtins(_: CrateNum) -> bool {\n+            fatal_cycle\n+            desc { \"test whether a crate has #![no_builtins]\" }\n+        }\n+\n+        query extern_crate(_: DefId) -> Lrc<Option<ExternCrate>> {\n+            eval_always\n+            desc { \"getting crate's ExternCrateData\" }\n+        }\n+    }\n+\n+    TypeChecking {\n+        query specializes(_: (DefId, DefId)) -> bool {\n+            no_force\n+            desc { \"computing whether impls specialize one another\" }\n+        }\n+        query in_scope_traits_map(_: DefIndex)\n+            -> Option<Lrc<FxHashMap<ItemLocalId, Lrc<StableVec<TraitCandidate>>>>> {\n+            eval_always\n+            desc { \"traits in scope at a block\" }\n+        }\n+    }\n+\n+    Other {\n+        query module_exports(_: DefId) -> Option<Lrc<Vec<Export>>> {\n+            eval_always\n+        }\n+    }\n+\n+    TypeChecking {\n+        query impl_defaultness(_: DefId) -> hir::Defaultness {}\n+\n+        query check_item_well_formed(_: DefId) -> () {}\n+        query check_trait_item_well_formed(_: DefId) -> () {}\n+        query check_impl_item_well_formed(_: DefId) -> () {}\n+    }\n+\n+    Linking {\n+        // The DefIds of all non-generic functions and statics in the given crate\n+        // that can be reached from outside the crate.\n+        //\n+        // We expect this items to be available for being linked to.\n+        //\n+        // This query can also be called for LOCAL_CRATE. In this case it will\n+        // compute which items will be reachable to other crates, taking into account\n+        // the kind of crate that is currently compiled. Crates with only a\n+        // C interface have fewer reachable things.\n+        //\n+        // Does not include external symbols that don't have a corresponding DefId,\n+        // like the compiler-generated `main` function and so on.\n+        query reachable_non_generics(_: CrateNum)\n+            -> Lrc<DefIdMap<SymbolExportLevel>> {\n+            desc { \"looking up the exported symbols of a crate\" }\n+        }\n+        query is_reachable_non_generic(_: DefId) -> bool {}\n+        query is_unreachable_local_definition(_: DefId) -> bool {}\n+    }\n+\n+    Codegen {\n+        query upstream_monomorphizations(\n+            k: CrateNum\n+        ) -> Lrc<DefIdMap<Lrc<FxHashMap<SubstsRef<'tcx>, CrateNum>>>> {\n+            desc { \"collecting available upstream monomorphizations `{:?}`\", k }\n+        }\n+        query upstream_monomorphizations_for(_: DefId)\n+            -> Option<Lrc<FxHashMap<SubstsRef<'tcx>, CrateNum>>> {}\n+    }\n+\n+    Other {\n+        query foreign_modules(_: CrateNum) -> Lrc<Vec<ForeignModule>> {\n+            desc { \"looking up the foreign modules of a linked crate\" }\n+        }\n+\n+        /// Identifies the entry-point (e.g., the `main` function) for a given\n+        /// crate, returning `None` if there is no entry point (such as for library crates).\n+        query entry_fn(_: CrateNum) -> Option<(DefId, EntryFnType)> {\n+            desc { \"looking up the entry function of a crate\" }\n+        }\n+        query plugin_registrar_fn(_: CrateNum) -> Option<DefId> {\n+            desc { \"looking up the plugin registrar for a crate\" }\n+        }\n+        query proc_macro_decls_static(_: CrateNum) -> Option<DefId> {\n+            desc { \"looking up the derive registrar for a crate\" }\n+        }\n+        query crate_disambiguator(_: CrateNum) -> CrateDisambiguator {\n+            eval_always\n+            desc { \"looking up the disambiguator a crate\" }\n+        }\n+        query crate_hash(_: CrateNum) -> Svh {\n+            eval_always\n+            desc { \"looking up the hash a crate\" }\n+        }\n+        query original_crate_name(_: CrateNum) -> Symbol {\n+            eval_always\n+            desc { \"looking up the original name a crate\" }\n+        }\n+        query extra_filename(_: CrateNum) -> String {\n+            eval_always\n+            desc { \"looking up the extra filename for a crate\" }\n+        }\n+    }\n+\n+    TypeChecking {\n+        query implementations_of_trait(_: (CrateNum, DefId))\n+            -> Lrc<Vec<DefId>> {\n+            no_force\n+            desc { \"looking up implementations of a trait in a crate\" }\n+        }\n+        query all_trait_implementations(_: CrateNum)\n+            -> Lrc<Vec<DefId>> {\n+            desc { \"looking up all (?) trait implementations\" }\n+        }\n+    }\n+\n+    Other {\n+        query dllimport_foreign_items(_: CrateNum)\n+            -> Lrc<FxHashSet<DefId>> {\n+            desc { \"dllimport_foreign_items\" }\n+        }\n+        query is_dllimport_foreign_item(_: DefId) -> bool {}\n+        query is_statically_included_foreign_item(_: DefId) -> bool {}\n+        query native_library_kind(_: DefId)\n+            -> Option<NativeLibraryKind> {}\n+    }\n+\n+    Linking {\n+        query link_args(_: CrateNum) -> Lrc<Vec<String>> {\n+            eval_always\n+            desc { \"looking up link arguments for a crate\" }\n+        }\n+    }\n+\n+    BorrowChecking {\n+        // Lifetime resolution. See `middle::resolve_lifetimes`.\n+        query resolve_lifetimes(_: CrateNum) -> Lrc<ResolveLifetimes> {\n+            desc { \"resolving lifetimes\" }\n+        }\n+        query named_region_map(_: DefIndex) ->\n+            Option<Lrc<FxHashMap<ItemLocalId, Region>>> {\n+            desc { \"looking up a named region\" }\n+        }\n+        query is_late_bound_map(_: DefIndex) ->\n+            Option<Lrc<FxHashSet<ItemLocalId>>> {\n+            desc { \"testing if a region is late bound\" }\n+        }\n+        query object_lifetime_defaults_map(_: DefIndex)\n+            -> Option<Lrc<FxHashMap<ItemLocalId, Lrc<Vec<ObjectLifetimeDefault>>>>> {\n+            desc { \"looking up lifetime defaults for a region\" }\n+        }\n+    }\n+\n+    TypeChecking {\n+        query visibility(_: DefId) -> ty::Visibility {}\n+    }\n+\n+    Other {\n+        query dep_kind(_: CrateNum) -> DepKind {\n+            eval_always\n+            desc { \"fetching what a dependency looks like\" }\n+        }\n+        query crate_name(_: CrateNum) -> Symbol {\n+            eval_always\n+            desc { \"fetching what a crate is named\" }\n+        }\n+        query item_children(_: DefId) -> Lrc<Vec<Export>> {}\n+        query extern_mod_stmt_cnum(_: DefId) -> Option<CrateNum> {}\n+\n+        query get_lib_features(_: CrateNum) -> Lrc<LibFeatures> {\n+            eval_always\n+            desc { \"calculating the lib features map\" }\n+        }\n+        query defined_lib_features(_: CrateNum)\n+            -> Lrc<Vec<(Symbol, Option<Symbol>)>> {\n+            desc { \"calculating the lib features defined in a crate\" }\n+        }\n+        query get_lang_items(_: CrateNum) -> Lrc<LanguageItems> {\n+            eval_always\n+            desc { \"calculating the lang items map\" }\n+        }\n+        query defined_lang_items(_: CrateNum) -> Lrc<Vec<(DefId, usize)>> {\n+            desc { \"calculating the lang items defined in a crate\" }\n+        }\n+        query missing_lang_items(_: CrateNum) -> Lrc<Vec<LangItem>> {\n+            desc { \"calculating the missing lang items in a crate\" }\n+        }\n+        query visible_parent_map(_: CrateNum)\n+            -> Lrc<DefIdMap<DefId>> {\n+            desc { \"calculating the visible parent map\" }\n+        }\n+        query missing_extern_crate_item(_: CrateNum) -> bool {\n+            eval_always\n+            desc { \"seeing if we're missing an `extern crate` item for this crate\" }\n+        }\n+        query used_crate_source(_: CrateNum) -> Lrc<CrateSource> {\n+            eval_always\n+            desc { \"looking at the source for a crate\" }\n+        }\n+        query postorder_cnums(_: CrateNum) -> Lrc<Vec<CrateNum>> {\n+            eval_always\n+            desc { \"generating a postorder list of CrateNums\" }\n+        }\n+\n+        query freevars(_: DefId) -> Option<Lrc<Vec<hir::Freevar>>> {\n+            eval_always\n+        }\n+        query maybe_unused_trait_import(_: DefId) -> bool {\n+            eval_always\n+        }\n+        query maybe_unused_extern_crates(_: CrateNum)\n+            -> Lrc<Vec<(DefId, Span)>> {\n+            eval_always\n+            desc { \"looking up all possibly unused extern crates\" }\n+        }\n+        query names_imported_by_glob_use(_: DefId)\n+            -> Lrc<FxHashSet<ast::Name>> {\n+            eval_always\n+        }\n+\n+        query stability_index(_: CrateNum) -> Lrc<stability::Index<'tcx>> {\n+            eval_always\n+            desc { \"calculating the stability index for the local crate\" }\n+        }\n+        query all_crate_nums(_: CrateNum) -> Lrc<Vec<CrateNum>> {\n+            eval_always\n+            desc { \"fetching all foreign CrateNum instances\" }\n+        }\n+\n+        /// A vector of every trait accessible in the whole crate\n+        /// (i.e., including those from subcrates). This is used only for\n+        /// error reporting.\n+        query all_traits(_: CrateNum) -> Lrc<Vec<DefId>> {\n+            desc { \"fetching all foreign and local traits\" }\n+        }\n+    }\n+\n+    Linking {\n+        query exported_symbols(_: CrateNum)\n+            -> Arc<Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)>> {\n+            desc { \"exported_symbols\" }\n+        }\n+    }\n+\n+    Codegen {\n+        query collect_and_partition_mono_items(_: CrateNum)\n+            -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>) {\n+            eval_always\n+            desc { \"collect_and_partition_mono_items\" }\n+        }\n+        query is_codegened_item(_: DefId) -> bool {}\n+        query codegen_unit(_: InternedString) -> Arc<CodegenUnit<'tcx>> {\n+            no_force\n+            desc { \"codegen_unit\" }\n+        }\n+        query backend_optimization_level(_: CrateNum) -> OptLevel {\n+            desc { \"optimization level used by backend\" }\n+        }\n+    }\n+\n+    Other {\n+        query output_filenames(_: CrateNum) -> Arc<OutputFilenames> {\n+            eval_always\n+            desc { \"output_filenames\" }\n+        }\n+    }\n+\n+    TypeChecking {\n+        /// Do not call this query directly: invoke `normalize` instead.\n+        query normalize_projection_ty(\n+            goal: CanonicalProjectionGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, NormalizationResult<'tcx>>>>,\n+            NoSolution,\n+        > {\n+            no_force\n+            desc { \"normalizing `{:?}`\", goal }\n+        }\n+\n+        /// Do not call this query directly: invoke `normalize_erasing_regions` instead.\n+        query normalize_ty_after_erasing_regions(\n+            goal: ParamEnvAnd<'tcx, Ty<'tcx>>\n+        ) -> Ty<'tcx> {\n+            no_force\n+            desc { \"normalizing `{:?}`\", goal }\n+        }\n+\n+        query implied_outlives_bounds(\n+            goal: CanonicalTyGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, Vec<OutlivesBound<'tcx>>>>>,\n+            NoSolution,\n+        > {\n+            no_force\n+            desc { \"computing implied outlives bounds for `{:?}`\", goal }\n+        }\n+\n+        /// Do not call this query directly: invoke `infcx.at().dropck_outlives()` instead.\n+        query dropck_outlives(\n+            goal: CanonicalTyGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, DropckOutlivesResult<'tcx>>>>,\n+            NoSolution,\n+        > {\n+            no_force\n+            desc { \"computing dropck types for `{:?}`\", goal }\n+        }\n+\n+        /// Do not call this query directly: invoke `infcx.predicate_may_hold()` or\n+        /// `infcx.predicate_must_hold()` instead.\n+        query evaluate_obligation(\n+            goal: CanonicalPredicateGoal<'tcx>\n+        ) -> Result<traits::EvaluationResult, traits::OverflowError> {\n+            no_force\n+            desc { \"evaluating trait selection obligation `{}`\", goal.value.value }\n+        }\n+\n+        query evaluate_goal(\n+            goal: traits::ChalkCanonicalGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n+            NoSolution\n+        > {\n+            no_force\n+            desc { \"evaluating trait selection obligation `{}`\", goal.value.goal }\n+        }\n+\n+        /// Do not call this query directly: part of the `Eq` type-op\n+        query type_op_ascribe_user_type(\n+            goal: CanonicalTypeOpAscribeUserTypeGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n+            NoSolution,\n+        > {\n+            no_force\n+            desc { \"evaluating `type_op_ascribe_user_type` `{:?}`\", goal }\n+        }\n+\n+        /// Do not call this query directly: part of the `Eq` type-op\n+        query type_op_eq(\n+            goal: CanonicalTypeOpEqGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n+            NoSolution,\n+        > {\n+            no_force\n+            desc { \"evaluating `type_op_eq` `{:?}`\", goal }\n+        }\n+\n+        /// Do not call this query directly: part of the `Subtype` type-op\n+        query type_op_subtype(\n+            goal: CanonicalTypeOpSubtypeGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n+            NoSolution,\n+        > {\n+            no_force\n+            desc { \"evaluating `type_op_subtype` `{:?}`\", goal }\n+        }\n+\n+        /// Do not call this query directly: part of the `ProvePredicate` type-op\n+        query type_op_prove_predicate(\n+            goal: CanonicalTypeOpProvePredicateGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n+            NoSolution,\n+        > {\n+            no_force\n+            desc { \"evaluating `type_op_prove_predicate` `{:?}`\", goal }\n+        }\n+\n+        /// Do not call this query directly: part of the `Normalize` type-op\n+        query type_op_normalize_ty(\n+            goal: CanonicalTypeOpNormalizeGoal<'tcx, Ty<'tcx>>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, Ty<'tcx>>>>,\n+            NoSolution,\n+        > {\n+            no_force\n+            desc { \"normalizing `{:?}`\", goal }\n+        }\n+\n+        /// Do not call this query directly: part of the `Normalize` type-op\n+        query type_op_normalize_predicate(\n+            goal: CanonicalTypeOpNormalizeGoal<'tcx, ty::Predicate<'tcx>>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ty::Predicate<'tcx>>>>,\n+            NoSolution,\n+        > {\n+            no_force\n+            desc { \"normalizing `{:?}`\", goal }\n+        }\n+\n+        /// Do not call this query directly: part of the `Normalize` type-op\n+        query type_op_normalize_poly_fn_sig(\n+            goal: CanonicalTypeOpNormalizeGoal<'tcx, ty::PolyFnSig<'tcx>>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ty::PolyFnSig<'tcx>>>>,\n+            NoSolution,\n+        > {\n+            no_force\n+            desc { \"normalizing `{:?}`\", goal }\n+        }\n+\n+        /// Do not call this query directly: part of the `Normalize` type-op\n+        query type_op_normalize_fn_sig(\n+            goal: CanonicalTypeOpNormalizeGoal<'tcx, ty::FnSig<'tcx>>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ty::FnSig<'tcx>>>>,\n+            NoSolution,\n+        > {\n+            no_force\n+            desc { \"normalizing `{:?}`\", goal }\n+        }\n+\n+        query substitute_normalize_and_test_predicates(key: (DefId, SubstsRef<'tcx>)) -> bool {\n+            no_force\n+            desc { |tcx|\n+                \"testing substituted normalized predicates:`{}`\",\n+                tcx.def_path_str(key.0)\n+            }\n+        }\n+\n+        query method_autoderef_steps(\n+            goal: CanonicalTyGoal<'tcx>\n+        ) -> MethodAutoderefStepsResult<'tcx> {\n+            no_force\n+            desc { \"computing autoderef types for `{:?}`\", goal }\n+        }\n+    }\n+\n+    Other {\n+        query target_features_whitelist(_: CrateNum) -> Lrc<FxHashMap<String, Option<String>>> {\n+            eval_always\n+            desc { \"looking up the whitelist of target features\" }\n+        }\n+\n+        // Get an estimate of the size of an InstanceDef based on its MIR for CGU partitioning.\n+        query instance_def_size_estimate(def: ty::InstanceDef<'tcx>)\n+            -> usize {\n+            no_force\n+            desc { |tcx| \"estimating size for `{}`\", tcx.def_path_str(def.def_id()) }\n+        }\n+\n+        query features_query(_: CrateNum) -> Lrc<feature_gate::Features> {\n+            eval_always\n+            desc { \"looking up enabled feature gates\" }\n+        }\n+    }\n }"}, {"sha": "73b79027972427a4ad8dcd47f7b2a2b038807b90", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 2, "deletions": 842, "changes": 844, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -1,15 +1,7 @@\n use crate::dep_graph::SerializedDepNodeIndex;\n use crate::dep_graph::DepNode;\n-use crate::hir::def_id::{CrateNum, DefId, DefIndex};\n-use crate::mir::interpret::GlobalId;\n-use crate::traits;\n-use crate::traits::query::{\n-    CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal,\n-    CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpNormalizeGoal,\n-    CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpSubtypeGoal,\n-};\n-use crate::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n-use crate::ty::subst::SubstsRef;\n+use crate::hir::def_id::{CrateNum, DefId};\n+use crate::ty::TyCtxt;\n use crate::ty::query::queries;\n use crate::ty::query::Query;\n use crate::ty::query::QueryCache;\n@@ -19,7 +11,6 @@ use crate::util::profiling::ProfileCategory;\n use std::borrow::Cow;\n use std::hash::Hash;\n use std::fmt::Debug;\n-use syntax_pos::symbol::InternedString;\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::fingerprint::Fingerprint;\n use crate::ich::StableHashingContext;\n@@ -79,843 +70,12 @@ impl<'tcx, M: QueryAccessors<'tcx, Key=DefId>> QueryDescription<'tcx> for M {\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::check_mod_attrs<'tcx> {\n-    fn describe(\n-        tcx: TyCtxt<'_, '_, '_>,\n-        key: DefId,\n-    ) -> Cow<'static, str> {\n-        format!(\"checking attributes in {}\", key.describe_as_module(tcx)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::check_mod_unstable_api_usage<'tcx> {\n-    fn describe(\n-        tcx: TyCtxt<'_, '_, '_>,\n-        key: DefId,\n-    ) -> Cow<'static, str> {\n-        format!(\"checking for unstable API usage in {}\", key.describe_as_module(tcx)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::check_mod_loops<'tcx> {\n-    fn describe(\n-        tcx: TyCtxt<'_, '_, '_>,\n-        key: DefId,\n-    ) -> Cow<'static, str> {\n-        format!(\"checking loops in {}\", key.describe_as_module(tcx)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::check_mod_item_types<'tcx> {\n-    fn describe(\n-        tcx: TyCtxt<'_, '_, '_>,\n-        key: DefId,\n-    ) -> Cow<'static, str> {\n-        format!(\"checking item types in {}\", key.describe_as_module(tcx)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::check_mod_privacy<'tcx> {\n-    fn describe(\n-        tcx: TyCtxt<'_, '_, '_>,\n-        key: DefId,\n-    ) -> Cow<'static, str> {\n-        format!(\"checking privacy in {}\", key.describe_as_module(tcx)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::check_mod_intrinsics<'tcx> {\n-    fn describe(\n-        tcx: TyCtxt<'_, '_, '_>,\n-        key: DefId,\n-    ) -> Cow<'static, str> {\n-        format!(\"checking intrinsics in {}\", key.describe_as_module(tcx)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::check_mod_liveness<'tcx> {\n-    fn describe(\n-        tcx: TyCtxt<'_, '_, '_>,\n-        key: DefId,\n-    ) -> Cow<'static, str> {\n-        format!(\"checking liveness of variables in {}\", key.describe_as_module(tcx)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::check_mod_impl_wf<'tcx> {\n-    fn describe(\n-        tcx: TyCtxt<'_, '_, '_>,\n-        key: DefId,\n-    ) -> Cow<'static, str> {\n-        format!(\"checking that impls are well-formed in {}\", key.describe_as_module(tcx)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::collect_mod_item_types<'tcx> {\n-    fn describe(\n-        tcx: TyCtxt<'_, '_, '_>,\n-        key: DefId,\n-    ) -> Cow<'static, str> {\n-        format!(\"collecting item types in {}\", key.describe_as_module(tcx)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::normalize_projection_ty<'tcx> {\n-    fn describe(\n-        _tcx: TyCtxt<'_, '_, '_>,\n-        goal: CanonicalProjectionGoal<'tcx>,\n-    ) -> Cow<'static, str> {\n-        format!(\"normalizing `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::implied_outlives_bounds<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTyGoal<'tcx>) -> Cow<'static, str> {\n-        format!(\"computing implied outlives bounds for `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::dropck_outlives<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTyGoal<'tcx>) -> Cow<'static, str> {\n-        format!(\"computing dropck types for `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::normalize_ty_after_erasing_regions<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: ParamEnvAnd<'tcx, Ty<'tcx>>) -> Cow<'static, str> {\n-        format!(\"normalizing `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::evaluate_obligation<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalPredicateGoal<'tcx>) -> Cow<'static, str> {\n-        format!(\"evaluating trait selection obligation `{}`\", goal.value.value).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::evaluate_goal<'tcx> {\n-    fn describe(\n-        _tcx: TyCtxt<'_, '_, '_>,\n-        goal: traits::ChalkCanonicalGoal<'tcx>\n-    ) -> Cow<'static, str> {\n-        format!(\"evaluating trait selection obligation `{}`\", goal.value.goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::type_op_ascribe_user_type<'tcx> {\n-    fn describe(\n-        _tcx: TyCtxt<'_, '_, '_>,\n-        goal: CanonicalTypeOpAscribeUserTypeGoal<'tcx>,\n-    ) -> Cow<'static, str> {\n-        format!(\"evaluating `type_op_ascribe_user_type` `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::type_op_eq<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTypeOpEqGoal<'tcx>) -> Cow<'static, str> {\n-        format!(\"evaluating `type_op_eq` `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::type_op_subtype<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTypeOpSubtypeGoal<'tcx>)\n-                -> Cow<'static, str> {\n-        format!(\"evaluating `type_op_subtype` `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::type_op_prove_predicate<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTypeOpProvePredicateGoal<'tcx>)\n-                -> Cow<'static, str> {\n-        format!(\"evaluating `type_op_prove_predicate` `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::type_op_normalize_ty<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>,\n-                goal: CanonicalTypeOpNormalizeGoal<'tcx, Ty<'tcx>>) -> Cow<'static, str> {\n-        format!(\"normalizing `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::type_op_normalize_predicate<'tcx> {\n-    fn describe(\n-        _tcx: TyCtxt<'_, '_, '_>,\n-        goal: CanonicalTypeOpNormalizeGoal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Cow<'static, str> {\n-        format!(\"normalizing `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::type_op_normalize_poly_fn_sig<'tcx> {\n-    fn describe(\n-        _tcx: TyCtxt<'_, '_, '_>,\n-        goal: CanonicalTypeOpNormalizeGoal<'tcx, ty::PolyFnSig<'tcx>>,\n-    ) -> Cow<'static, str> {\n-        format!(\"normalizing `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::type_op_normalize_fn_sig<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>,\n-                goal: CanonicalTypeOpNormalizeGoal<'tcx, ty::FnSig<'tcx>>) -> Cow<'static, str> {\n-        format!(\"normalizing `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::is_copy_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                -> Cow<'static, str> {\n-        format!(\"computing whether `{}` is `Copy`\", env.value).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::is_sized_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                -> Cow<'static, str> {\n-        format!(\"computing whether `{}` is `Sized`\", env.value).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::is_freeze_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                -> Cow<'static, str> {\n-        format!(\"computing whether `{}` is freeze\", env.value).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::needs_drop_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                -> Cow<'static, str> {\n-        format!(\"computing whether `{}` needs drop\", env.value).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::layout_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                -> Cow<'static, str> {\n-        format!(\"computing layout of `{}`\", env.value).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::super_predicates_of<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n-        format!(\"computing the supertraits of `{}`\",\n-                tcx.def_path_str(def_id)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::type_param_predicates<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, (_, def_id): (DefId, DefId)) -> Cow<'static, str> {\n-        let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-        format!(\"computing the bounds for type parameter `{}`\",\n-                tcx.hir().ty_param_name(id)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::coherent_trait<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n-        format!(\"coherence checking all impls of trait `{}`\",\n-                tcx.def_path_str(def_id)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::upstream_monomorphizations<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, k: CrateNum) -> Cow<'static, str> {\n-        format!(\"collecting available upstream monomorphizations `{:?}`\", k).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::crate_inherent_impls<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, k: CrateNum) -> Cow<'static, str> {\n-        format!(\"all inherent impls defined in crate `{:?}`\", k).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::crate_inherent_impls_overlap_check<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"check for overlap between inherent impls defined in this crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::crate_variances<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"computing the variances for items in this crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::inferred_outlives_crate<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"computing the inferred outlives predicates for items in this crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::mir_shims<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def: ty::InstanceDef<'tcx>) -> Cow<'static, str> {\n-        format!(\"generating MIR shim for `{}`\",\n-                tcx.def_path_str(def.def_id())).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::privacy_access_levels<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"privacy access levels\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::check_private_in_public<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"checking for private elements in public interfaces\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::typeck_item_bodies<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"type-checking all item bodies\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::reachable_set<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"reachability\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::const_eval<'tcx> {\n-    fn describe(\n-        tcx: TyCtxt<'_, '_, '_>,\n-        key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n-    ) -> Cow<'static, str> {\n-        format!(\n-            \"const-evaluating + checking `{}`\",\n-            tcx.def_path_str(key.value.instance.def.def_id()),\n-        ).into()\n-    }\n-\n-    #[inline]\n-    fn cache_on_disk(_: TyCtxt<'_, 'tcx, 'tcx>, _key: Self::Key) -> bool {\n-        true\n-    }\n-\n-    #[inline]\n-    fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              id: SerializedDepNodeIndex)\n-                              -> Option<Self::Value> {\n-        tcx.queries.on_disk_cache.try_load_query_result(tcx, id).map(Ok)\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::const_eval_raw<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n-        -> Cow<'static, str>\n-    {\n-        format!(\"const-evaluating `{}`\", tcx.def_path_str(key.value.instance.def.def_id())).into()\n-    }\n-\n-    #[inline]\n-    fn cache_on_disk(_: TyCtxt<'_, 'tcx, 'tcx>, _key: Self::Key) -> bool {\n-        true\n-    }\n-\n-    #[inline]\n-    fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              id: SerializedDepNodeIndex)\n-                              -> Option<Self::Value> {\n-        tcx.queries.on_disk_cache.try_load_query_result(tcx, id).map(Ok)\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::symbol_name<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, instance: ty::Instance<'tcx>) -> Cow<'static, str> {\n-        format!(\"computing the symbol for `{}`\", instance).into()\n-    }\n-\n-    #[inline]\n-    fn cache_on_disk(_: TyCtxt<'_, 'tcx, 'tcx>, _: Self::Key) -> bool {\n-        true\n-    }\n-\n-    #[inline]\n-    fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              id: SerializedDepNodeIndex)\n-                              -> Option<Self::Value> {\n-        tcx.queries.on_disk_cache.try_load_query_result(tcx, id)\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::describe_def<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n-        bug!(\"describe_def\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::def_span<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n-        bug!(\"def_span\")\n-    }\n-}\n-\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::lookup_stability<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n-        bug!(\"stability\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::lookup_deprecation_entry<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n-        bug!(\"deprecation\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::item_attrs<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n-        bug!(\"item_attrs\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::is_reachable_non_generic<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n-        bug!(\"is_reachable_non_generic\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::fn_arg_names<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n-        bug!(\"fn_arg_names\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::impl_parent<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n-        bug!(\"impl_parent\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::trait_of_item<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n-        bug!(\"trait_of_item\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::const_is_rvalue_promotable_to_static<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n-        format!(\"const checking if rvalue is promotable to static `{}`\",\n-            tcx.def_path_str(def_id)).into()\n-    }\n-\n-    #[inline]\n-    fn cache_on_disk(_: TyCtxt<'_, 'tcx, 'tcx>, _: Self::Key) -> bool {\n-        true\n-    }\n-\n-    #[inline]\n-    fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              id: SerializedDepNodeIndex)\n-                              -> Option<Self::Value> {\n-        tcx.queries.on_disk_cache.try_load_query_result(tcx, id)\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::rvalue_promotable_map<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n-        format!(\"checking which parts of `{}` are promotable to static\",\n-                tcx.def_path_str(def_id)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::is_mir_available<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n-        format!(\"checking if item is mir available: `{}`\",\n-                tcx.def_path_str(def_id)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::codegen_fulfill_obligation<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>,\n-                key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> Cow<'static, str> {\n-        format!(\"checking if `{}` fulfills its obligations\", tcx.def_path_str(key.1.def_id()))\n-            .into()\n-    }\n-\n-    #[inline]\n-    fn cache_on_disk(_: TyCtxt<'_, 'tcx, 'tcx>, _: Self::Key) -> bool {\n-        true\n-    }\n-\n-    #[inline]\n-    fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              id: SerializedDepNodeIndex)\n-                              -> Option<Self::Value> {\n-        tcx.queries.on_disk_cache.try_load_query_result(tcx, id)\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::trait_impls_of<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n-        format!(\"trait impls of `{}`\", tcx.def_path_str(def_id)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::is_object_safe<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n-        format!(\"determine object safety of trait `{}`\", tcx.def_path_str(def_id)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::is_const_fn_raw<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n-        format!(\"checking if item is const fn: `{}`\", tcx.def_path_str(def_id)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::dylib_dependency_formats<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"dylib dependency formats of crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::is_compiler_builtins<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"checking if the crate is_compiler_builtins\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::has_global_allocator<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"checking if the crate has_global_allocator\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::has_panic_handler<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"checking if the crate has_panic_handler\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::extern_crate<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n-        \"getting crate's ExternCrateData\".into()\n-    }\n-}\n-\n impl<'tcx> QueryDescription<'tcx> for queries::analysis<'tcx> {\n     fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n         \"running analysis passes on this crate\".into()\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::specializes<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: (DefId, DefId)) -> Cow<'static, str> {\n-        \"computing whether impls specialize one another\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::in_scope_traits_map<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefIndex) -> Cow<'static, str> {\n-        \"traits in scope at a block\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::is_no_builtins<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"test whether a crate has #![no_builtins]\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::panic_strategy<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"query a crate's configured panic strategy\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::is_profiler_runtime<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"query a crate is #![profiler_runtime]\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::is_sanitizer_runtime<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"query a crate is #![sanitizer_runtime]\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::reachable_non_generics<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up the exported symbols of a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::foreign_modules<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up the foreign modules of a linked crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::entry_fn<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up the entry function of a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::plugin_registrar_fn<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up the plugin registrar for a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::proc_macro_decls_static<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up the derive registrar for a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::crate_disambiguator<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up the disambiguator a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::crate_hash<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up the hash a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::original_crate_name<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up the original name a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::extra_filename<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up the extra filename for a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::implementations_of_trait<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: (CrateNum, DefId)) -> Cow<'static, str> {\n-        \"looking up implementations of a trait in a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::all_trait_implementations<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up all (?) trait implementations\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::link_args<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up link arguments for a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::resolve_lifetimes<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"resolving lifetimes\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::named_region_map<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefIndex) -> Cow<'static, str> {\n-        \"looking up a named region\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::is_late_bound_map<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefIndex) -> Cow<'static, str> {\n-        \"testing if a region is late bound\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::object_lifetime_defaults_map<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefIndex) -> Cow<'static, str> {\n-        \"looking up lifetime defaults for a region\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::dep_kind<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"fetching what a dependency looks like\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::crate_name<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"fetching what a crate is named\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::get_lib_features<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"calculating the lib features map\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::defined_lib_features<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"calculating the lib features defined in a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::get_lang_items<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"calculating the lang items map\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::defined_lang_items<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"calculating the lang items defined in a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::missing_lang_items<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"calculating the missing lang items in a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::visible_parent_map<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"calculating the visible parent map\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::missing_extern_crate_item<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"seeing if we're missing an `extern crate` item for this crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::used_crate_source<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking at the source for a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::postorder_cnums<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"generating a postorder list of CrateNums\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::maybe_unused_extern_crates<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up all possibly unused extern crates\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::stability_index<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"calculating the stability index for the local crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::all_traits<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"fetching all foreign and local traits\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::all_crate_nums<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"fetching all foreign CrateNum instances\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::exported_symbols<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"exported_symbols\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::collect_and_partition_mono_items<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"collect_and_partition_mono_items\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::codegen_unit<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: InternedString) -> Cow<'static, str> {\n-        \"codegen_unit\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::output_filenames<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"output_filenames\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::vtable_methods<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, key: ty::PolyTraitRef<'tcx> ) -> Cow<'static, str> {\n-        format!(\"finding all methods for trait {}\", tcx.def_path_str(key.def_id())).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::features_query<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up enabled feature gates\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::typeck_tables_of<'tcx> {\n-    #[inline]\n-    fn cache_on_disk(_: TyCtxt<'_, 'tcx, 'tcx>, def_id: Self::Key) -> bool {\n-        def_id.is_local()\n-    }\n-\n-    fn try_load_from_disk(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-                          id: SerializedDepNodeIndex)\n-                          -> Option<Self::Value> {\n-        let typeck_tables: Option<ty::TypeckTables<'tcx>> = tcx\n-            .queries.on_disk_cache\n-            .try_load_query_result(tcx, id);\n-\n-        typeck_tables.map(|tables| tcx.alloc_tables(tables))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::substitute_normalize_and_test_predicates<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, key: (DefId, SubstsRef<'tcx>)) -> Cow<'static, str> {\n-        format!(\"testing substituted normalized predicates:`{}`\", tcx.def_path_str(key.0)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::method_autoderef_steps<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTyGoal<'tcx>) -> Cow<'static, str> {\n-        format!(\"computing autoderef types for `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::target_features_whitelist<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up the whitelist of target features\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::instance_def_size_estimate<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def: ty::InstanceDef<'tcx>) -> Cow<'static, str> {\n-        format!(\"estimating size for `{}`\", tcx.def_path_str(def.def_id())).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::dllimport_foreign_items<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"dllimport_foreign_items\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::backend_optimization_level<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"optimization level used by backend\".into()\n-    }\n-}\n-\n macro_rules! impl_disk_cacheable_query(\n     ($query_name:ident, |$tcx:tt, $key:tt| $cond:expr) => {\n         impl<'tcx> QueryDescription<'tcx> for queries::$query_name<'tcx> {"}, {"sha": "c4bc35fff66b8ec11aac57b16440d8c1ff907b62", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 734, "changes": 735, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -1,4 +1,4 @@\n-use crate::dep_graph::{self, DepConstructor, DepNode};\n+use crate::dep_graph::{self, DepNode};\n use crate::hir::def_id::{CrateNum, DefId, DefIndex};\n use crate::hir::def::{Def, Export};\n use crate::hir::{self, TraitCandidate, ItemLocalId, CodegenFnAttrs};\n@@ -104,738 +104,5 @@ rustc_query_append! { [define_queries!][ <'tcx>\n         /// Run analysis passes on the crate\n         [] fn analysis: Analysis(CrateNum) -> Result<(), ErrorReported>,\n \n-        /// Maps from the `DefId` of an item (trait/struct/enum/fn) to the\n-        /// predicates (where-clauses) directly defined on it. This is\n-        /// equal to the `explicit_predicates_of` predicates plus the\n-        /// `inferred_outlives_of` predicates.\n-        [] fn predicates_defined_on: PredicatesDefinedOnItem(DefId)\n-            -> Lrc<ty::GenericPredicates<'tcx>>,\n-\n-        /// Returns the predicates written explicit by the user.\n-        [] fn explicit_predicates_of: ExplicitPredicatesOfItem(DefId)\n-            -> Lrc<ty::GenericPredicates<'tcx>>,\n-\n-        /// Returns the inferred outlives predicates (e.g., for `struct\n-        /// Foo<'a, T> { x: &'a T }`, this would return `T: 'a`).\n-        [] fn inferred_outlives_of: InferredOutlivesOf(DefId) -> Lrc<Vec<ty::Predicate<'tcx>>>,\n-\n-        /// Maps from the `DefId` of a trait to the list of\n-        /// super-predicates. This is a subset of the full list of\n-        /// predicates. We store these in a separate map because we must\n-        /// evaluate them even during type conversion, often before the\n-        /// full predicates are available (note that supertraits have\n-        /// additional acyclicity requirements).\n-        [] fn super_predicates_of: SuperPredicatesOfItem(DefId) -> Lrc<ty::GenericPredicates<'tcx>>,\n-\n-        /// To avoid cycles within the predicates of a single item we compute\n-        /// per-type-parameter predicates for resolving `T::AssocTy`.\n-        [] fn type_param_predicates: type_param_predicates((DefId, DefId))\n-            -> Lrc<ty::GenericPredicates<'tcx>>,\n-\n-        [] fn trait_def: TraitDefOfItem(DefId) -> &'tcx ty::TraitDef,\n-        [] fn adt_def: AdtDefOfItem(DefId) -> &'tcx ty::AdtDef,\n-        [] fn adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n-\n-        // The cycle error here should be reported as an error by `check_representable`.\n-        // We consider the type as Sized in the meanwhile to avoid\n-        // further errors (done in impl Value for AdtSizedConstraint).\n-        // Use `cycle_delay_bug` to delay the cycle error here to be emitted later\n-        // in case we accidentally otherwise don't emit an error.\n-        [cycle_delay_bug] fn adt_sized_constraint: SizedConstraint(\n-            DefId\n-        ) -> AdtSizedConstraint<'tcx>,\n-\n-        [] fn adt_dtorck_constraint: DtorckConstraint(\n-            DefId\n-        ) -> Result<DtorckConstraint<'tcx>, NoSolution>,\n-\n-        /// True if this is a const fn, use the `is_const_fn` to know whether your crate actually\n-        /// sees it as const fn (e.g., the const-fn-ness might be unstable and you might not have\n-        /// the feature gate active)\n-        ///\n-        /// **Do not call this function manually.** It is only meant to cache the base data for the\n-        /// `is_const_fn` function.\n-        [] fn is_const_fn_raw: IsConstFn(DefId) -> bool,\n-\n-\n-        /// Returns true if calls to the function may be promoted\n-        ///\n-        /// This is either because the function is e.g., a tuple-struct or tuple-variant\n-        /// constructor, or because it has the `#[rustc_promotable]` attribute. The attribute should\n-        /// be removed in the future in favour of some form of check which figures out whether the\n-        /// function does not inspect the bits of any of its arguments (so is essentially just a\n-        /// constructor function).\n-        [] fn is_promotable_const_fn: IsPromotableConstFn(DefId) -> bool,\n-\n-        /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n-        [] fn is_foreign_item: IsForeignItem(DefId) -> bool,\n-\n-        /// Get a map with the variance of every item; use `item_variance`\n-        /// instead.\n-        [] fn crate_variances: crate_variances(CrateNum) -> Lrc<ty::CrateVariancesMap>,\n-\n-        /// Maps from def-id of a type or region parameter to its\n-        /// (inferred) variance.\n-        [] fn variances_of: ItemVariances(DefId) -> Lrc<Vec<ty::Variance>>,\n-    },\n-\n-    TypeChecking {\n-        /// Maps from def-id of a type to its (inferred) outlives.\n-        [] fn inferred_outlives_crate: InferredOutlivesCrate(CrateNum)\n-            -> Lrc<ty::CratePredicatesMap<'tcx>>,\n-    },\n-\n-    Other {\n-        /// Maps from an impl/trait def-id to a list of the def-ids of its items\n-        [] fn associated_item_def_ids: AssociatedItemDefIds(DefId) -> Lrc<Vec<DefId>>,\n-\n-        /// Maps from a trait item to the trait item \"descriptor\"\n-        [] fn associated_item: AssociatedItems(DefId) -> ty::AssociatedItem,\n-\n-        [] fn impl_trait_ref: ImplTraitRef(DefId) -> Option<ty::TraitRef<'tcx>>,\n-        [] fn impl_polarity: ImplPolarity(DefId) -> hir::ImplPolarity,\n-\n-        [] fn issue33140_self_ty: Issue33140SelfTy(DefId) -> Option<ty::Ty<'tcx>>,\n-    },\n-\n-    TypeChecking {\n-        /// Maps a DefId of a type to a list of its inherent impls.\n-        /// Contains implementations of methods that are inherent to a type.\n-        /// Methods in these implementations don't need to be exported.\n-        [] fn inherent_impls: InherentImpls(DefId) -> Lrc<Vec<DefId>>,\n-    },\n-\n-    TypeChecking {\n-        /// The result of unsafety-checking this `DefId`.\n-        [] fn unsafety_check_result: UnsafetyCheckResult(DefId) -> mir::UnsafetyCheckResult,\n-\n-        /// HACK: when evaluated, this reports a \"unsafe derive on repr(packed)\" error\n-        [] fn unsafe_derive_on_repr_packed: UnsafeDeriveOnReprPacked(DefId) -> (),\n-\n-        /// The signature of functions and closures.\n-        [] fn fn_sig: FnSignature(DefId) -> ty::PolyFnSig<'tcx>,\n-    },\n-\n-    Other {\n-        [] fn lint_mod: LintMod(DefId) -> (),\n-\n-        /// Checks the attributes in the module\n-        [] fn check_mod_attrs: CheckModAttrs(DefId) -> (),\n-\n-        [] fn check_mod_unstable_api_usage: CheckModUnstableApiUsage(DefId) -> (),\n-\n-        /// Checks the loops in the module\n-        [] fn check_mod_loops: CheckModLoops(DefId) -> (),\n-\n-        [] fn check_mod_item_types: CheckModItemTypes(DefId) -> (),\n-\n-        [] fn check_mod_privacy: CheckModPrivacy(DefId) -> (),\n-\n-        [] fn check_mod_intrinsics: CheckModIntrinsics(DefId) -> (),\n-\n-        [] fn check_mod_liveness: CheckModLiveness(DefId) -> (),\n-\n-        [] fn check_mod_impl_wf: CheckModImplWf(DefId) -> (),\n-\n-        [] fn collect_mod_item_types: CollectModItemTypes(DefId) -> (),\n-\n-        /// Caches CoerceUnsized kinds for impls on custom types.\n-        [] fn coerce_unsized_info: CoerceUnsizedInfo(DefId)\n-            -> ty::adjustment::CoerceUnsizedInfo,\n-    },\n-\n-    TypeChecking {\n-        [] fn typeck_item_bodies:\n-                typeck_item_bodies_dep_node(CrateNum) -> (),\n-\n-        [] fn typeck_tables_of: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n-    },\n-\n-    Other {\n-        [] fn used_trait_imports: UsedTraitImports(DefId) -> Lrc<DefIdSet>,\n-    },\n-\n-    TypeChecking {\n-        [] fn has_typeck_tables: HasTypeckTables(DefId) -> bool,\n-\n-        [] fn coherent_trait: CoherenceCheckTrait(DefId) -> (),\n-    },\n-\n-    BorrowChecking {\n-        [] fn borrowck: BorrowCheck(DefId) -> Lrc<BorrowCheckResult>,\n-\n-        /// Borrow checks the function body. If this is a closure, returns\n-        /// additional requirements that the closure's creator must verify.\n-        [] fn mir_borrowck: MirBorrowCheck(DefId) -> mir::BorrowCheckResult<'tcx>,\n-    },\n-\n-    TypeChecking {\n-        /// Gets a complete map from all types to their inherent impls.\n-        /// Not meant to be used directly outside of coherence.\n-        /// (Defined only for `LOCAL_CRATE`.)\n-        [] fn crate_inherent_impls: crate_inherent_impls_dep_node(CrateNum)\n-            -> Lrc<CrateInherentImpls>,\n-\n-        /// Checks all types in the crate for overlap in their inherent impls. Reports errors.\n-        /// Not meant to be used directly outside of coherence.\n-        /// (Defined only for `LOCAL_CRATE`.)\n-        [] fn crate_inherent_impls_overlap_check: inherent_impls_overlap_check_dep_node(CrateNum)\n-            -> (),\n-    },\n-\n-    Other {\n-        /// Evaluate a constant without running sanity checks\n-        ///\n-        /// **Do not use this** outside const eval. Const eval uses this to break query cycles\n-        /// during validation. Please add a comment to every use site explaining why using\n-        /// `const_eval` isn't sufficient\n-        [] fn const_eval_raw: const_eval_raw_dep_node(ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n-            -> ConstEvalRawResult<'tcx>,\n-\n-        /// Results of evaluating const items or constants embedded in\n-        /// other items (such as enum variant explicit discriminants).\n-        [] fn const_eval: const_eval_dep_node(ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n-            -> ConstEvalResult<'tcx>,\n-    },\n-\n-    TypeChecking {\n-        [] fn check_match: CheckMatch(DefId) -> (),\n-\n-        /// Performs part of the privacy check and computes \"access levels\".\n-        [] fn privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Lrc<AccessLevels>,\n-        [] fn check_private_in_public: CheckPrivateInPublic(CrateNum) -> (),\n-    },\n-\n-    Other {\n-        [] fn reachable_set: reachability_dep_node(CrateNum) -> ReachableSet,\n-\n-        /// Per-body `region::ScopeTree`. The `DefId` should be the owner `DefId` for the body;\n-        /// in the case of closures, this will be redirected to the enclosing function.\n-        [] fn region_scope_tree: RegionScopeTree(DefId) -> Lrc<region::ScopeTree>,\n-\n-        [] fn mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx mir::Mir<'tcx>,\n-\n-        [] fn symbol_name: symbol_name_dep_node(ty::Instance<'tcx>) -> ty::SymbolName,\n-\n-        [] fn describe_def: DescribeDef(DefId) -> Option<Def>,\n-        [] fn def_span: DefSpan(DefId) -> Span,\n-        [] fn lookup_stability: LookupStability(DefId) -> Option<&'tcx attr::Stability>,\n-        [] fn lookup_deprecation_entry: LookupDeprecationEntry(DefId) -> Option<DeprecationEntry>,\n-        [] fn item_attrs: ItemAttrs(DefId) -> Lrc<[ast::Attribute]>,\n-    },\n-\n-    Codegen {\n-        [] fn codegen_fn_attrs: codegen_fn_attrs(DefId) -> CodegenFnAttrs,\n-    },\n-\n-    Other {\n-        [] fn fn_arg_names: FnArgNames(DefId) -> Vec<ast::Name>,\n-        /// Gets the rendered value of the specified constant or associated constant.\n-        /// Used by rustdoc.\n-        [] fn rendered_const: RenderedConst(DefId) -> String,\n-        [] fn impl_parent: ImplParent(DefId) -> Option<DefId>,\n-    },\n-\n-    TypeChecking {\n-        [] fn trait_of_item: TraitOfItem(DefId) -> Option<DefId>,\n-        [] fn const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n-        [] fn rvalue_promotable_map: RvaluePromotableMap(DefId) -> Lrc<ItemLocalSet>,\n-    },\n-\n-    Codegen {\n-        [] fn is_mir_available: IsMirAvailable(DefId) -> bool,\n-    },\n-\n-    Other {\n-        [] fn vtable_methods: vtable_methods_node(ty::PolyTraitRef<'tcx>)\n-                            -> Lrc<Vec<Option<(DefId, SubstsRef<'tcx>)>>>,\n-    },\n-\n-    Codegen {\n-        [] fn codegen_fulfill_obligation: fulfill_obligation_dep_node(\n-            (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> Vtable<'tcx, ()>,\n-    },\n-\n-    TypeChecking {\n-        [] fn trait_impls_of: TraitImpls(DefId) -> Lrc<ty::trait_def::TraitImpls>,\n-        [] fn specialization_graph_of: SpecializationGraph(DefId)\n-            -> Lrc<specialization_graph::Graph>,\n-        [] fn is_object_safe: ObjectSafety(DefId) -> bool,\n-\n-        /// Gets the ParameterEnvironment for a given item; this environment\n-        /// will be in \"user-facing\" mode, meaning that it is suitabe for\n-        /// type-checking etc, and it does not normalize specializable\n-        /// associated types. This is almost always what you want,\n-        /// unless you are doing MIR optimizations, in which case you\n-        /// might want to use `reveal_all()` method to change modes.\n-        [] fn param_env: ParamEnv(DefId) -> ty::ParamEnv<'tcx>,\n-\n-        /// Trait selection queries. These are best used by invoking `ty.is_copy_modulo_regions()`,\n-        /// `ty.is_copy()`, etc, since that will prune the environment where possible.\n-        [] fn is_copy_raw: is_copy_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-        [] fn is_sized_raw: is_sized_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-        [] fn is_freeze_raw: is_freeze_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-\n-        // The cycle error here should be reported as an error by `check_representable`.\n-        // We consider the type as not needing drop in the meanwhile to avoid\n-        // further errors (done in impl Value for NeedsDrop).\n-        // Use `cycle_delay_bug` to delay the cycle error here to be emitted later\n-        // in case we accidentally otherwise don't emit an error.\n-        [cycle_delay_bug] fn needs_drop_raw: needs_drop_dep_node(\n-            ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n-        ) -> NeedsDrop,\n-\n-        [] fn layout_raw: layout_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                                    -> Result<&'tcx ty::layout::LayoutDetails,\n-                                                ty::layout::LayoutError<'tcx>>,\n-    },\n-\n-    Other {\n-        [] fn dylib_dependency_formats: DylibDepFormats(CrateNum)\n-                                        -> Lrc<Vec<(CrateNum, LinkagePreference)>>,\n-    },\n-\n-    Codegen {\n-        [fatal_cycle] fn is_compiler_builtins: IsCompilerBuiltins(CrateNum) -> bool,\n-        [fatal_cycle] fn has_global_allocator: HasGlobalAllocator(CrateNum) -> bool,\n-        [fatal_cycle] fn has_panic_handler: HasPanicHandler(CrateNum) -> bool,\n-        [fatal_cycle] fn is_sanitizer_runtime: IsSanitizerRuntime(CrateNum) -> bool,\n-        [fatal_cycle] fn is_profiler_runtime: IsProfilerRuntime(CrateNum) -> bool,\n-        [fatal_cycle] fn panic_strategy: GetPanicStrategy(CrateNum) -> PanicStrategy,\n-        [fatal_cycle] fn is_no_builtins: IsNoBuiltins(CrateNum) -> bool,\n-\n-        [] fn extern_crate: ExternCrate(DefId) -> Lrc<Option<ExternCrate>>,\n-    },\n-\n-    TypeChecking {\n-        [] fn specializes: specializes_node((DefId, DefId)) -> bool,\n-        [] fn in_scope_traits_map: InScopeTraits(DefIndex)\n-            -> Option<Lrc<FxHashMap<ItemLocalId, Lrc<StableVec<TraitCandidate>>>>>,\n-    },\n-\n-    Other {\n-        [] fn module_exports: ModuleExports(DefId) -> Option<Lrc<Vec<Export>>>,\n-    },\n-\n-    TypeChecking {\n-        [] fn impl_defaultness: ImplDefaultness(DefId) -> hir::Defaultness,\n-\n-        [] fn check_item_well_formed: CheckItemWellFormed(DefId) -> (),\n-        [] fn check_trait_item_well_formed: CheckTraitItemWellFormed(DefId) -> (),\n-        [] fn check_impl_item_well_formed: CheckImplItemWellFormed(DefId) -> (),\n-    },\n-\n-    Linking {\n-        // The DefIds of all non-generic functions and statics in the given crate\n-        // that can be reached from outside the crate.\n-        //\n-        // We expect this items to be available for being linked to.\n-        //\n-        // This query can also be called for LOCAL_CRATE. In this case it will\n-        // compute which items will be reachable to other crates, taking into account\n-        // the kind of crate that is currently compiled. Crates with only a\n-        // C interface have fewer reachable things.\n-        //\n-        // Does not include external symbols that don't have a corresponding DefId,\n-        // like the compiler-generated `main` function and so on.\n-        [] fn reachable_non_generics: ReachableNonGenerics(CrateNum)\n-            -> Lrc<DefIdMap<SymbolExportLevel>>,\n-        [] fn is_reachable_non_generic: IsReachableNonGeneric(DefId) -> bool,\n-        [] fn is_unreachable_local_definition: IsUnreachableLocalDefinition(DefId) -> bool,\n-    },\n-\n-    Codegen {\n-        [] fn upstream_monomorphizations: UpstreamMonomorphizations(CrateNum)\n-            -> Lrc<DefIdMap<Lrc<FxHashMap<SubstsRef<'tcx>, CrateNum>>>>,\n-        [] fn upstream_monomorphizations_for: UpstreamMonomorphizationsFor(DefId)\n-            -> Option<Lrc<FxHashMap<SubstsRef<'tcx>, CrateNum>>>,\n-    },\n-\n-    Other {\n-        [] fn foreign_modules: ForeignModules(CrateNum) -> Lrc<Vec<ForeignModule>>,\n-\n-        /// Identifies the entry-point (e.g., the `main` function) for a given\n-        /// crate, returning `None` if there is no entry point (such as for library crates).\n-        [] fn entry_fn: EntryFn(CrateNum) -> Option<(DefId, EntryFnType)>,\n-        [] fn plugin_registrar_fn: PluginRegistrarFn(CrateNum) -> Option<DefId>,\n-        [] fn proc_macro_decls_static: ProcMacroDeclsStatic(CrateNum) -> Option<DefId>,\n-        [] fn crate_disambiguator: CrateDisambiguator(CrateNum) -> CrateDisambiguator,\n-        [] fn crate_hash: CrateHash(CrateNum) -> Svh,\n-        [] fn original_crate_name: OriginalCrateName(CrateNum) -> Symbol,\n-        [] fn extra_filename: ExtraFileName(CrateNum) -> String,\n-    },\n-\n-    TypeChecking {\n-        [] fn implementations_of_trait: implementations_of_trait_node((CrateNum, DefId))\n-            -> Lrc<Vec<DefId>>,\n-        [] fn all_trait_implementations: AllTraitImplementations(CrateNum)\n-            -> Lrc<Vec<DefId>>,\n-    },\n-\n-    Other {\n-        [] fn dllimport_foreign_items: DllimportForeignItems(CrateNum)\n-            -> Lrc<FxHashSet<DefId>>,\n-        [] fn is_dllimport_foreign_item: IsDllimportForeignItem(DefId) -> bool,\n-        [] fn is_statically_included_foreign_item: IsStaticallyIncludedForeignItem(DefId) -> bool,\n-        [] fn native_library_kind: NativeLibraryKind(DefId)\n-            -> Option<NativeLibraryKind>,\n-    },\n-\n-    Linking {\n-        [] fn link_args: link_args_node(CrateNum) -> Lrc<Vec<String>>,\n-    },\n-\n-    BorrowChecking {\n-        // Lifetime resolution. See `middle::resolve_lifetimes`.\n-        [] fn resolve_lifetimes: ResolveLifetimes(CrateNum) -> Lrc<ResolveLifetimes>,\n-        [] fn named_region_map: NamedRegion(DefIndex) ->\n-            Option<Lrc<FxHashMap<ItemLocalId, Region>>>,\n-        [] fn is_late_bound_map: IsLateBound(DefIndex) ->\n-            Option<Lrc<FxHashSet<ItemLocalId>>>,\n-        [] fn object_lifetime_defaults_map: ObjectLifetimeDefaults(DefIndex)\n-            -> Option<Lrc<FxHashMap<ItemLocalId, Lrc<Vec<ObjectLifetimeDefault>>>>>,\n-    },\n-\n-    TypeChecking {\n-        [] fn visibility: Visibility(DefId) -> ty::Visibility,\n-    },\n-\n-    Other {\n-        [] fn dep_kind: DepKind(CrateNum) -> DepKind,\n-        [] fn crate_name: CrateName(CrateNum) -> Symbol,\n-        [] fn item_children: ItemChildren(DefId) -> Lrc<Vec<Export>>,\n-        [] fn extern_mod_stmt_cnum: ExternModStmtCnum(DefId) -> Option<CrateNum>,\n-\n-        [] fn get_lib_features: get_lib_features_node(CrateNum) -> Lrc<LibFeatures>,\n-        [] fn defined_lib_features: DefinedLibFeatures(CrateNum)\n-            -> Lrc<Vec<(Symbol, Option<Symbol>)>>,\n-        [] fn get_lang_items: get_lang_items_node(CrateNum) -> Lrc<LanguageItems>,\n-        [] fn defined_lang_items: DefinedLangItems(CrateNum) -> Lrc<Vec<(DefId, usize)>>,\n-        [] fn missing_lang_items: MissingLangItems(CrateNum) -> Lrc<Vec<LangItem>>,\n-        [] fn visible_parent_map: visible_parent_map_node(CrateNum)\n-            -> Lrc<DefIdMap<DefId>>,\n-        [] fn missing_extern_crate_item: MissingExternCrateItem(CrateNum) -> bool,\n-        [] fn used_crate_source: UsedCrateSource(CrateNum) -> Lrc<CrateSource>,\n-        [] fn postorder_cnums: postorder_cnums_node(CrateNum) -> Lrc<Vec<CrateNum>>,\n-\n-        [] fn freevars: Freevars(DefId) -> Option<Lrc<Vec<hir::Freevar>>>,\n-        [] fn maybe_unused_trait_import: MaybeUnusedTraitImport(DefId) -> bool,\n-        [] fn maybe_unused_extern_crates: maybe_unused_extern_crates_node(CrateNum)\n-            -> Lrc<Vec<(DefId, Span)>>,\n-        [] fn names_imported_by_glob_use: NamesImportedByGlobUse(DefId)\n-            -> Lrc<FxHashSet<ast::Name>>,\n-\n-        [] fn stability_index: stability_index_node(CrateNum) -> Lrc<stability::Index<'tcx>>,\n-        [] fn all_crate_nums: all_crate_nums_node(CrateNum) -> Lrc<Vec<CrateNum>>,\n-\n-        /// A vector of every trait accessible in the whole crate\n-        /// (i.e., including those from subcrates). This is used only for\n-        /// error reporting.\n-        [] fn all_traits: all_traits_node(CrateNum) -> Lrc<Vec<DefId>>,\n-    },\n-\n-    Linking {\n-        [] fn exported_symbols: ExportedSymbols(CrateNum)\n-            -> Arc<Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)>>,\n-    },\n-\n-    Codegen {\n-        [] fn collect_and_partition_mono_items:\n-            collect_and_partition_mono_items_node(CrateNum)\n-            -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>),\n-        [] fn is_codegened_item: IsCodegenedItem(DefId) -> bool,\n-        [] fn codegen_unit: CodegenUnit(InternedString) -> Arc<CodegenUnit<'tcx>>,\n-        [] fn backend_optimization_level: BackendOptimizationLevel(CrateNum) -> OptLevel,\n-    },\n-\n-    Other {\n-        [] fn output_filenames: output_filenames_node(CrateNum)\n-            -> Arc<OutputFilenames>,\n-    },\n-\n-    TypeChecking {\n-        /// Do not call this query directly: invoke `normalize` instead.\n-        [] fn normalize_projection_ty: NormalizeProjectionTy(\n-            CanonicalProjectionGoal<'tcx>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, NormalizationResult<'tcx>>>>,\n-            NoSolution,\n-        >,\n-\n-        /// Do not call this query directly: invoke `normalize_erasing_regions` instead.\n-        [] fn normalize_ty_after_erasing_regions: NormalizeTyAfterErasingRegions(\n-            ParamEnvAnd<'tcx, Ty<'tcx>>\n-        ) -> Ty<'tcx>,\n-\n-        [] fn implied_outlives_bounds: ImpliedOutlivesBounds(\n-            CanonicalTyGoal<'tcx>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, Vec<OutlivesBound<'tcx>>>>>,\n-            NoSolution,\n-        >,\n-\n-        /// Do not call this query directly: invoke `infcx.at().dropck_outlives()` instead.\n-        [] fn dropck_outlives: DropckOutlives(\n-            CanonicalTyGoal<'tcx>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, DropckOutlivesResult<'tcx>>>>,\n-            NoSolution,\n-        >,\n-\n-        /// Do not call this query directly: invoke `infcx.predicate_may_hold()` or\n-        /// `infcx.predicate_must_hold()` instead.\n-        [] fn evaluate_obligation: EvaluateObligation(\n-            CanonicalPredicateGoal<'tcx>\n-        ) -> Result<traits::EvaluationResult, traits::OverflowError>,\n-\n-        [] fn evaluate_goal: EvaluateGoal(\n-            traits::ChalkCanonicalGoal<'tcx>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n-            NoSolution\n-        >,\n-\n-        /// Do not call this query directly: part of the `Eq` type-op\n-        [] fn type_op_ascribe_user_type: TypeOpAscribeUserType(\n-            CanonicalTypeOpAscribeUserTypeGoal<'tcx>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n-            NoSolution,\n-        >,\n-\n-        /// Do not call this query directly: part of the `Eq` type-op\n-        [] fn type_op_eq: TypeOpEq(\n-            CanonicalTypeOpEqGoal<'tcx>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n-            NoSolution,\n-        >,\n-\n-        /// Do not call this query directly: part of the `Subtype` type-op\n-        [] fn type_op_subtype: TypeOpSubtype(\n-            CanonicalTypeOpSubtypeGoal<'tcx>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n-            NoSolution,\n-        >,\n-\n-        /// Do not call this query directly: part of the `ProvePredicate` type-op\n-        [] fn type_op_prove_predicate: TypeOpProvePredicate(\n-            CanonicalTypeOpProvePredicateGoal<'tcx>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n-            NoSolution,\n-        >,\n-\n-        /// Do not call this query directly: part of the `Normalize` type-op\n-        [] fn type_op_normalize_ty: TypeOpNormalizeTy(\n-            CanonicalTypeOpNormalizeGoal<'tcx, Ty<'tcx>>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, Ty<'tcx>>>>,\n-            NoSolution,\n-        >,\n-\n-        /// Do not call this query directly: part of the `Normalize` type-op\n-        [] fn type_op_normalize_predicate: TypeOpNormalizePredicate(\n-            CanonicalTypeOpNormalizeGoal<'tcx, ty::Predicate<'tcx>>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ty::Predicate<'tcx>>>>,\n-            NoSolution,\n-        >,\n-\n-        /// Do not call this query directly: part of the `Normalize` type-op\n-        [] fn type_op_normalize_poly_fn_sig: TypeOpNormalizePolyFnSig(\n-            CanonicalTypeOpNormalizeGoal<'tcx, ty::PolyFnSig<'tcx>>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ty::PolyFnSig<'tcx>>>>,\n-            NoSolution,\n-        >,\n-\n-        /// Do not call this query directly: part of the `Normalize` type-op\n-        [] fn type_op_normalize_fn_sig: TypeOpNormalizeFnSig(\n-            CanonicalTypeOpNormalizeGoal<'tcx, ty::FnSig<'tcx>>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ty::FnSig<'tcx>>>>,\n-            NoSolution,\n-        >,\n-\n-        [] fn substitute_normalize_and_test_predicates:\n-            substitute_normalize_and_test_predicates_node((DefId, SubstsRef<'tcx>)) -> bool,\n-\n-        [] fn method_autoderef_steps: MethodAutoderefSteps(\n-            CanonicalTyGoal<'tcx>\n-        ) -> MethodAutoderefStepsResult<'tcx>,\n-    },\n-\n-    Other {\n-        [] fn target_features_whitelist:\n-            target_features_whitelist_node(CrateNum) -> Lrc<FxHashMap<String, Option<String>>>,\n-\n-        // Get an estimate of the size of an InstanceDef based on its MIR for CGU partitioning.\n-        [] fn instance_def_size_estimate: instance_def_size_estimate_dep_node(ty::InstanceDef<'tcx>)\n-            -> usize,\n-\n-        [] fn features_query: features_node(CrateNum) -> Lrc<feature_gate::Features>,\n     },\n ]}\n-\n-//////////////////////////////////////////////////////////////////////\n-// These functions are little shims used to find the dep-node for a\n-// given query when there is not a *direct* mapping:\n-\n-\n-fn features_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::Features\n-}\n-\n-fn codegen_fn_attrs<'tcx>(id: DefId) -> DepConstructor<'tcx> {\n-    DepConstructor::CodegenFnAttrs { 0: id }\n-}\n-\n-fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {\n-    DepConstructor::TypeParamPredicates {\n-        item_id,\n-        param_id\n-    }\n-}\n-\n-fn fulfill_obligation_dep_node<'tcx>((param_env, trait_ref):\n-    (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> DepConstructor<'tcx> {\n-    DepConstructor::FulfillObligation {\n-        param_env,\n-        trait_ref\n-    }\n-}\n-\n-fn crate_inherent_impls_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::Coherence\n-}\n-\n-fn inherent_impls_overlap_check_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::CoherenceInherentImplOverlapCheck\n-}\n-\n-fn reachability_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::Reachability\n-}\n-\n-fn mir_shim_dep_node<'tcx>(instance_def: ty::InstanceDef<'tcx>) -> DepConstructor<'tcx> {\n-    DepConstructor::MirShim {\n-        instance_def\n-    }\n-}\n-\n-fn symbol_name_dep_node<'tcx>(instance: ty::Instance<'tcx>) -> DepConstructor<'tcx> {\n-    DepConstructor::SymbolName { instance }\n-}\n-\n-fn typeck_item_bodies_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::TypeckBodiesKrate\n-}\n-\n-fn const_eval_dep_node<'tcx>(param_env: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n-                             -> DepConstructor<'tcx> {\n-    DepConstructor::ConstEval { param_env }\n-}\n-fn const_eval_raw_dep_node<'tcx>(param_env: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n-                             -> DepConstructor<'tcx> {\n-    DepConstructor::ConstEvalRaw { param_env }\n-}\n-\n-fn crate_variances<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::CrateVariances\n-}\n-\n-fn is_copy_dep_node<'tcx>(param_env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n-    DepConstructor::IsCopy { param_env }\n-}\n-\n-fn is_sized_dep_node<'tcx>(param_env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n-    DepConstructor::IsSized { param_env }\n-}\n-\n-fn is_freeze_dep_node<'tcx>(param_env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n-    DepConstructor::IsFreeze { param_env }\n-}\n-\n-fn needs_drop_dep_node<'tcx>(param_env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n-    DepConstructor::NeedsDrop { param_env }\n-}\n-\n-fn layout_dep_node<'tcx>(param_env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n-    DepConstructor::Layout { param_env }\n-}\n-\n-fn specializes_node<'tcx>((a, b): (DefId, DefId)) -> DepConstructor<'tcx> {\n-    DepConstructor::Specializes { impl1: a, impl2: b }\n-}\n-\n-fn implementations_of_trait_node<'tcx>((krate, trait_id): (CrateNum, DefId))\n-    -> DepConstructor<'tcx>\n-{\n-    DepConstructor::ImplementationsOfTrait { krate, trait_id }\n-}\n-\n-fn link_args_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::LinkArgs\n-}\n-\n-fn get_lib_features_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::GetLibFeatures\n-}\n-\n-fn get_lang_items_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::GetLangItems\n-}\n-\n-fn visible_parent_map_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::VisibleParentMap\n-}\n-\n-fn postorder_cnums_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::PostorderCnums\n-}\n-\n-fn maybe_unused_extern_crates_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::MaybeUnusedExternCrates\n-}\n-\n-fn stability_index_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::StabilityIndex\n-}\n-\n-fn all_crate_nums_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::AllCrateNums\n-}\n-\n-fn all_traits_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::AllTraits\n-}\n-\n-fn collect_and_partition_mono_items_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::CollectAndPartitionMonoItems\n-}\n-\n-fn output_filenames_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::OutputFilenames\n-}\n-\n-fn vtable_methods_node<'tcx>(trait_ref: ty::PolyTraitRef<'tcx>) -> DepConstructor<'tcx> {\n-    DepConstructor::VtableMethods{ trait_ref }\n-}\n-\n-fn substitute_normalize_and_test_predicates_node<'tcx>(key: (DefId, SubstsRef<'tcx>))\n-                                            -> DepConstructor<'tcx> {\n-    DepConstructor::SubstituteNormalizeAndTestPredicates { key }\n-}\n-\n-fn target_features_whitelist_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::TargetFeaturesWhitelist\n-}\n-\n-fn instance_def_size_estimate_dep_node<'tcx>(instance_def: ty::InstanceDef<'tcx>)\n-                                              -> DepConstructor<'tcx> {\n-    DepConstructor::InstanceDefSizeEstimate {\n-        instance_def\n-    }\n-}"}, {"sha": "a03cfd19b9165c6f17d7fb8b54594290a4847acb", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 14, "deletions": 230, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -1139,12 +1139,11 @@ pub fn force_from_dep_node<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     dep_node: &DepNode\n ) -> bool {\n-    use crate::hir::def_id::LOCAL_CRATE;\n     use crate::dep_graph::RecoverKey;\n \n     // We must avoid ever having to call force_from_dep_node() for a\n-    // DepNode::CodegenUnit:\n-    // Since we cannot reconstruct the query key of a DepNode::CodegenUnit, we\n+    // DepNode::codegen_unit:\n+    // Since we cannot reconstruct the query key of a DepNode::codegen_unit, we\n     // would always end up having to evaluate the first caller of the\n     // `codegen_unit` query that *is* reconstructible. This might very well be\n     // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n@@ -1155,8 +1154,8 @@ pub fn force_from_dep_node<'tcx>(\n     // each CGU, right after partitioning. This way `try_mark_green` will always\n     // hit the cache instead of having to go through `force_from_dep_node`.\n     // This assertion makes sure, we actually keep applying the solution above.\n-    debug_assert!(dep_node.kind != DepKind::CodegenUnit,\n-                  \"calling force_from_dep_node() on DepKind::CodegenUnit\");\n+    debug_assert!(dep_node.kind != DepKind::codegen_unit,\n+                  \"calling force_from_dep_node() on DepKind::codegen_unit\");\n \n     if !dep_node.kind.can_reconstruct_query_key() {\n         return false\n@@ -1193,9 +1192,6 @@ pub fn force_from_dep_node<'tcx>(\n         ($query:ident, $key:expr) => { force_ex!(tcx, $query, $key) }\n     };\n \n-    // FIXME(#45015): We should try move this boilerplate code into a macro\n-    //                somehow.\n-\n     rustc_dep_node_force!([dep_node, tcx]\n         // These are inputs that are expected to be pre-allocated and that\n         // should therefore always be red or green already\n@@ -1210,223 +1206,11 @@ pub fn force_from_dep_node<'tcx>(\n \n         // We don't have enough information to reconstruct the query key of\n         // these\n-        DepKind::IsCopy |\n-        DepKind::IsSized |\n-        DepKind::IsFreeze |\n-        DepKind::NeedsDrop |\n-        DepKind::Layout |\n-        DepKind::ConstEval |\n-        DepKind::ConstEvalRaw |\n-        DepKind::SymbolName |\n-        DepKind::MirShim |\n-        DepKind::BorrowCheckKrate |\n-        DepKind::Specializes |\n-        DepKind::ImplementationsOfTrait |\n-        DepKind::TypeParamPredicates |\n-        DepKind::CodegenUnit |\n-        DepKind::CompileCodegenUnit |\n-        DepKind::FulfillObligation |\n-        DepKind::VtableMethods |\n-        DepKind::NormalizeProjectionTy |\n-        DepKind::NormalizeTyAfterErasingRegions |\n-        DepKind::ImpliedOutlivesBounds |\n-        DepKind::DropckOutlives |\n-        DepKind::EvaluateObligation |\n-        DepKind::EvaluateGoal |\n-        DepKind::TypeOpAscribeUserType |\n-        DepKind::TypeOpEq |\n-        DepKind::TypeOpSubtype |\n-        DepKind::TypeOpProvePredicate |\n-        DepKind::TypeOpNormalizeTy |\n-        DepKind::TypeOpNormalizePredicate |\n-        DepKind::TypeOpNormalizePolyFnSig |\n-        DepKind::TypeOpNormalizeFnSig |\n-        DepKind::SubstituteNormalizeAndTestPredicates |\n-        DepKind::MethodAutoderefSteps |\n-        DepKind::InstanceDefSizeEstimate => {\n+        DepKind::CompileCodegenUnit => {\n             bug!(\"force_from_dep_node() - Encountered {:?}\", dep_node)\n         }\n \n-        // These are not queries\n-        DepKind::CoherenceCheckTrait |\n-        DepKind::ItemVarianceConstraints => {\n-            return false\n-        }\n-\n-        DepKind::RegionScopeTree => { force!(region_scope_tree, def_id!()); }\n-\n-        DepKind::Coherence => { force!(crate_inherent_impls, LOCAL_CRATE); }\n-        DepKind::CoherenceInherentImplOverlapCheck => {\n-            force!(crate_inherent_impls_overlap_check, LOCAL_CRATE)\n-        },\n-        DepKind::PrivacyAccessLevels => { force!(privacy_access_levels, LOCAL_CRATE); }\n-        DepKind::CheckPrivateInPublic => { force!(check_private_in_public, LOCAL_CRATE); }\n-\n-        DepKind::BorrowCheck => { force!(borrowck, def_id!()); }\n-        DepKind::MirBorrowCheck => { force!(mir_borrowck, def_id!()); }\n-        DepKind::UnsafetyCheckResult => { force!(unsafety_check_result, def_id!()); }\n-        DepKind::UnsafeDeriveOnReprPacked => { force!(unsafe_derive_on_repr_packed, def_id!()); }\n-        DepKind::LintMod => { force!(lint_mod, def_id!()); }\n-        DepKind::CheckModAttrs => { force!(check_mod_attrs, def_id!()); }\n-        DepKind::CheckModLoops => { force!(check_mod_loops, def_id!()); }\n-        DepKind::CheckModUnstableApiUsage => { force!(check_mod_unstable_api_usage, def_id!()); }\n-        DepKind::CheckModItemTypes => { force!(check_mod_item_types, def_id!()); }\n-        DepKind::CheckModPrivacy => { force!(check_mod_privacy, def_id!()); }\n-        DepKind::CheckModIntrinsics => { force!(check_mod_intrinsics, def_id!()); }\n-        DepKind::CheckModLiveness => { force!(check_mod_liveness, def_id!()); }\n-        DepKind::CheckModImplWf => { force!(check_mod_impl_wf, def_id!()); }\n-        DepKind::CollectModItemTypes => { force!(collect_mod_item_types, def_id!()); }\n-        DepKind::Reachability => { force!(reachable_set, LOCAL_CRATE); }\n-        DepKind::CrateVariances => { force!(crate_variances, LOCAL_CRATE); }\n-        DepKind::AssociatedItems => { force!(associated_item, def_id!()); }\n-        DepKind::PredicatesDefinedOnItem => { force!(predicates_defined_on, def_id!()); }\n-        DepKind::ExplicitPredicatesOfItem => { force!(explicit_predicates_of, def_id!()); }\n-        DepKind::InferredOutlivesOf => { force!(inferred_outlives_of, def_id!()); }\n-        DepKind::InferredOutlivesCrate => { force!(inferred_outlives_crate, LOCAL_CRATE); }\n-        DepKind::SuperPredicatesOfItem => { force!(super_predicates_of, def_id!()); }\n-        DepKind::TraitDefOfItem => { force!(trait_def, def_id!()); }\n-        DepKind::AdtDefOfItem => { force!(adt_def, def_id!()); }\n-        DepKind::ImplTraitRef => { force!(impl_trait_ref, def_id!()); }\n-        DepKind::ImplPolarity => { force!(impl_polarity, def_id!()); }\n-        DepKind::Issue33140SelfTy => { force!(issue33140_self_ty, def_id!()); }\n-        DepKind::FnSignature => { force!(fn_sig, def_id!()); }\n-        DepKind::CoerceUnsizedInfo => { force!(coerce_unsized_info, def_id!()); }\n-        DepKind::ItemVariances => { force!(variances_of, def_id!()); }\n-        DepKind::IsConstFn => { force!(is_const_fn_raw, def_id!()); }\n-        DepKind::IsPromotableConstFn => { force!(is_promotable_const_fn, def_id!()); }\n-        DepKind::IsForeignItem => { force!(is_foreign_item, def_id!()); }\n-        DepKind::SizedConstraint => { force!(adt_sized_constraint, def_id!()); }\n-        DepKind::DtorckConstraint => { force!(adt_dtorck_constraint, def_id!()); }\n-        DepKind::AdtDestructor => { force!(adt_destructor, def_id!()); }\n-        DepKind::AssociatedItemDefIds => { force!(associated_item_def_ids, def_id!()); }\n-        DepKind::InherentImpls => { force!(inherent_impls, def_id!()); }\n-        DepKind::TypeckBodiesKrate => { force!(typeck_item_bodies, LOCAL_CRATE); }\n-        DepKind::TypeckTables => { force!(typeck_tables_of, def_id!()); }\n-        DepKind::UsedTraitImports => { force!(used_trait_imports, def_id!()); }\n-        DepKind::HasTypeckTables => { force!(has_typeck_tables, def_id!()); }\n-        DepKind::SpecializationGraph => { force!(specialization_graph_of, def_id!()); }\n-        DepKind::ObjectSafety => { force!(is_object_safe, def_id!()); }\n-        DepKind::TraitImpls => { force!(trait_impls_of, def_id!()); }\n-        DepKind::CheckMatch => { force!(check_match, def_id!()); }\n-\n-        DepKind::ParamEnv => { force!(param_env, def_id!()); }\n-        DepKind::DescribeDef => { force!(describe_def, def_id!()); }\n-        DepKind::DefSpan => { force!(def_span, def_id!()); }\n-        DepKind::LookupStability => { force!(lookup_stability, def_id!()); }\n-        DepKind::LookupDeprecationEntry => {\n-            force!(lookup_deprecation_entry, def_id!());\n-        }\n-        DepKind::ConstIsRvaluePromotableToStatic => {\n-            force!(const_is_rvalue_promotable_to_static, def_id!());\n-        }\n-        DepKind::RvaluePromotableMap => { force!(rvalue_promotable_map, def_id!()); }\n-        DepKind::ImplParent => { force!(impl_parent, def_id!()); }\n-        DepKind::TraitOfItem => { force!(trait_of_item, def_id!()); }\n-        DepKind::IsReachableNonGeneric => { force!(is_reachable_non_generic, def_id!()); }\n-        DepKind::IsUnreachableLocalDefinition => {\n-            force!(is_unreachable_local_definition, def_id!());\n-        }\n-        DepKind::IsMirAvailable => { force!(is_mir_available, def_id!()); }\n-        DepKind::ItemAttrs => { force!(item_attrs, def_id!()); }\n-        DepKind::CodegenFnAttrs => { force!(codegen_fn_attrs, def_id!()); }\n-        DepKind::FnArgNames => { force!(fn_arg_names, def_id!()); }\n-        DepKind::RenderedConst => { force!(rendered_const, def_id!()); }\n-        DepKind::DylibDepFormats => { force!(dylib_dependency_formats, krate!()); }\n-        DepKind::IsCompilerBuiltins => { force!(is_compiler_builtins, krate!()); }\n-        DepKind::HasGlobalAllocator => { force!(has_global_allocator, krate!()); }\n-        DepKind::HasPanicHandler => { force!(has_panic_handler, krate!()); }\n-        DepKind::ExternCrate => { force!(extern_crate, def_id!()); }\n-        DepKind::InScopeTraits => { force!(in_scope_traits_map, def_id!().index); }\n-        DepKind::ModuleExports => { force!(module_exports, def_id!()); }\n-        DepKind::IsSanitizerRuntime => { force!(is_sanitizer_runtime, krate!()); }\n-        DepKind::IsProfilerRuntime => { force!(is_profiler_runtime, krate!()); }\n-        DepKind::GetPanicStrategy => { force!(panic_strategy, krate!()); }\n-        DepKind::IsNoBuiltins => { force!(is_no_builtins, krate!()); }\n-        DepKind::ImplDefaultness => { force!(impl_defaultness, def_id!()); }\n-        DepKind::CheckItemWellFormed => { force!(check_item_well_formed, def_id!()); }\n-        DepKind::CheckTraitItemWellFormed => { force!(check_trait_item_well_formed, def_id!()); }\n-        DepKind::CheckImplItemWellFormed => { force!(check_impl_item_well_formed, def_id!()); }\n-        DepKind::ReachableNonGenerics => { force!(reachable_non_generics, krate!()); }\n-        DepKind::EntryFn => { force!(entry_fn, krate!()); }\n-        DepKind::PluginRegistrarFn => { force!(plugin_registrar_fn, krate!()); }\n-        DepKind::ProcMacroDeclsStatic => { force!(proc_macro_decls_static, krate!()); }\n-        DepKind::CrateDisambiguator => { force!(crate_disambiguator, krate!()); }\n-        DepKind::CrateHash => { force!(crate_hash, krate!()); }\n-        DepKind::OriginalCrateName => { force!(original_crate_name, krate!()); }\n-        DepKind::ExtraFileName => { force!(extra_filename, krate!()); }\n         DepKind::Analysis => { force!(analysis, krate!()); }\n-\n-        DepKind::AllTraitImplementations => {\n-            force!(all_trait_implementations, krate!());\n-        }\n-\n-        DepKind::DllimportForeignItems => {\n-            force!(dllimport_foreign_items, krate!());\n-        }\n-        DepKind::IsDllimportForeignItem => {\n-            force!(is_dllimport_foreign_item, def_id!());\n-        }\n-        DepKind::IsStaticallyIncludedForeignItem => {\n-            force!(is_statically_included_foreign_item, def_id!());\n-        }\n-        DepKind::NativeLibraryKind => { force!(native_library_kind, def_id!()); }\n-        DepKind::LinkArgs => { force!(link_args, LOCAL_CRATE); }\n-\n-        DepKind::ResolveLifetimes => { force!(resolve_lifetimes, krate!()); }\n-        DepKind::NamedRegion => { force!(named_region_map, def_id!().index); }\n-        DepKind::IsLateBound => { force!(is_late_bound_map, def_id!().index); }\n-        DepKind::ObjectLifetimeDefaults => {\n-            force!(object_lifetime_defaults_map, def_id!().index);\n-        }\n-\n-        DepKind::Visibility => { force!(visibility, def_id!()); }\n-        DepKind::DepKind => { force!(dep_kind, krate!()); }\n-        DepKind::CrateName => { force!(crate_name, krate!()); }\n-        DepKind::ItemChildren => { force!(item_children, def_id!()); }\n-        DepKind::ExternModStmtCnum => { force!(extern_mod_stmt_cnum, def_id!()); }\n-        DepKind::GetLibFeatures => { force!(get_lib_features, LOCAL_CRATE); }\n-        DepKind::DefinedLibFeatures => { force!(defined_lib_features, krate!()); }\n-        DepKind::GetLangItems => { force!(get_lang_items, LOCAL_CRATE); }\n-        DepKind::DefinedLangItems => { force!(defined_lang_items, krate!()); }\n-        DepKind::MissingLangItems => { force!(missing_lang_items, krate!()); }\n-        DepKind::VisibleParentMap => { force!(visible_parent_map, LOCAL_CRATE); }\n-        DepKind::MissingExternCrateItem => {\n-            force!(missing_extern_crate_item, krate!());\n-        }\n-        DepKind::UsedCrateSource => { force!(used_crate_source, krate!()); }\n-        DepKind::PostorderCnums => { force!(postorder_cnums, LOCAL_CRATE); }\n-\n-        DepKind::Freevars => { force!(freevars, def_id!()); }\n-        DepKind::MaybeUnusedTraitImport => {\n-            force!(maybe_unused_trait_import, def_id!());\n-        }\n-        DepKind::NamesImportedByGlobUse => { force!(names_imported_by_glob_use, def_id!()); }\n-        DepKind::MaybeUnusedExternCrates => { force!(maybe_unused_extern_crates, LOCAL_CRATE); }\n-        DepKind::StabilityIndex => { force!(stability_index, LOCAL_CRATE); }\n-        DepKind::AllTraits => { force!(all_traits, LOCAL_CRATE); }\n-        DepKind::AllCrateNums => { force!(all_crate_nums, LOCAL_CRATE); }\n-        DepKind::ExportedSymbols => { force!(exported_symbols, krate!()); }\n-        DepKind::CollectAndPartitionMonoItems => {\n-            force!(collect_and_partition_mono_items, LOCAL_CRATE);\n-        }\n-        DepKind::IsCodegenedItem => { force!(is_codegened_item, def_id!()); }\n-        DepKind::OutputFilenames => { force!(output_filenames, LOCAL_CRATE); }\n-\n-        DepKind::TargetFeaturesWhitelist => { force!(target_features_whitelist, LOCAL_CRATE); }\n-\n-        DepKind::Features => { force!(features_query, LOCAL_CRATE); }\n-\n-        DepKind::ForeignModules => { force!(foreign_modules, krate!()); }\n-\n-        DepKind::UpstreamMonomorphizations => {\n-            force!(upstream_monomorphizations, krate!());\n-        }\n-        DepKind::UpstreamMonomorphizationsFor => {\n-            force!(upstream_monomorphizations_for, def_id!());\n-        }\n-        DepKind::BackendOptimizationLevel => {\n-            force!(backend_optimization_level, krate!());\n-        }\n     );\n \n     true\n@@ -1479,18 +1263,18 @@ macro_rules! impl_load_from_cache {\n }\n \n impl_load_from_cache!(\n-    TypeckTables => typeck_tables_of,\n+    typeck_tables_of => typeck_tables_of,\n     optimized_mir => optimized_mir,\n-    UnsafetyCheckResult => unsafety_check_result,\n-    BorrowCheck => borrowck,\n-    MirBorrowCheck => mir_borrowck,\n+    unsafety_check_result => unsafety_check_result,\n+    borrowck => borrowck,\n+    mir_borrowck => mir_borrowck,\n     mir_const_qualif => mir_const_qualif,\n-    ConstIsRvaluePromotableToStatic => const_is_rvalue_promotable_to_static,\n-    CheckMatch => check_match,\n+    const_is_rvalue_promotable_to_static => const_is_rvalue_promotable_to_static,\n+    check_match => check_match,\n     type_of => type_of,\n     generics_of => generics_of,\n     predicates_of => predicates_of,\n-    UsedTraitImports => used_trait_imports,\n-    CodegenFnAttrs => codegen_fn_attrs,\n-    SpecializationGraph => specialization_graph_of,\n+    used_trait_imports => used_trait_imports,\n+    codegen_fn_attrs => codegen_fn_attrs,\n+    specialization_graph_of => specialization_graph_of,\n );"}, {"sha": "5c4fd9dba7af47dc9a92c961bf0443a7b7411224", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -3,9 +3,9 @@\n //! we will compare the fingerprint from the current and from the previous\n //! compilation session as appropriate:\n //!\n-//! - `#[rustc_clean(cfg=\"rev2\", except=\"TypeckTables\")]` if we are\n+//! - `#[rustc_clean(cfg=\"rev2\", except=\"typeck_tables_of\")]` if we are\n //!   in `#[cfg(rev2)]`, then the fingerprints associated with\n-//!   `DepNode::TypeckTables(X)` must be DIFFERENT (`X` is the `DefId` of the\n+//!   `DepNode::typeck_tables_of(X)` must be DIFFERENT (`X` is the `DefId` of the\n //!   current node).\n //! - `#[rustc_clean(cfg=\"rev2\")]` same as above, except that the\n //!   fingerprints must be the SAME (along with all other fingerprints).\n@@ -42,14 +42,14 @@ const BASE_CONST: &[&str] = &[\n /// DepNodes for functions + methods\n const BASE_FN: &[&str] = &[\n     // Callers will depend on the signature of these items, so we better test\n-    label_strs::FnSignature,\n+    label_strs::fn_sig,\n     label_strs::generics_of,\n     label_strs::predicates_of,\n     label_strs::type_of,\n \n     // And a big part of compilation (that we eventually want to cache) is type inference\n     // information:\n-    label_strs::TypeckTables,\n+    label_strs::typeck_tables_of,\n ];\n \n /// DepNodes for Hir, which is pretty much everything\n@@ -61,9 +61,9 @@ const BASE_HIR: &[&str] = &[\n \n /// `impl` implementation of struct/trait\n const BASE_IMPL: &[&str] = &[\n-    label_strs::AssociatedItemDefIds,\n+    label_strs::associated_item_def_ids,\n     label_strs::generics_of,\n-    label_strs::ImplTraitRef,\n+    label_strs::impl_trait_ref,\n ];\n \n /// DepNodes for mir_built/Optimized, which is relevant in \"executable\"\n@@ -85,22 +85,22 @@ const BASE_STRUCT: &[&str] = &[\n \n /// Trait definition `DepNode`s.\n const BASE_TRAIT_DEF: &[&str] = &[\n-    label_strs::AssociatedItemDefIds,\n+    label_strs::associated_item_def_ids,\n     label_strs::generics_of,\n-    label_strs::ObjectSafety,\n+    label_strs::is_object_safe,\n     label_strs::predicates_of,\n-    label_strs::SpecializationGraph,\n-    label_strs::TraitDefOfItem,\n-    label_strs::TraitImpls,\n+    label_strs::specialization_graph_of,\n+    label_strs::trait_def,\n+    label_strs::trait_impls_of,\n ];\n \n /// Extra `DepNode`s for functions and methods.\n const EXTRA_ASSOCIATED: &[&str] = &[\n-    label_strs::AssociatedItems,\n+    label_strs::associated_item,\n ];\n \n const EXTRA_TRAIT: &[&str] = &[\n-    label_strs::TraitOfItem,\n+    label_strs::trait_of_item,\n ];\n \n // Fully Built Labels"}, {"sha": "e4a6dfcd4e85e877e8ed86f8dfa1d91e69b4a382", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -43,6 +43,9 @@ enum QueryModifier {\n     /// A cycle error for this query aborting the compilation with a fatal error.\n     FatalCycle,\n \n+    /// A cycle error results in a delay_bug call\n+    CycleDelayBug,\n+\n     /// Don't hash the result, instead just mark a query red if it runs\n     NoHash,\n \n@@ -101,6 +104,8 @@ impl Parse for QueryModifier {\n             Ok(QueryModifier::LoadCached(tcx, id, block))\n         } else if modifier == \"fatal_cycle\" {\n             Ok(QueryModifier::FatalCycle)\n+        } else if modifier == \"cycle_delay_bug\" {\n+            Ok(QueryModifier::CycleDelayBug)\n         } else if modifier == \"no_hash\" {\n             Ok(QueryModifier::NoHash)\n         } else if modifier == \"no_force\" {\n@@ -207,6 +212,9 @@ struct QueryModifiers {\n     /// A cycle error for this query aborting the compilation with a fatal error.\n     fatal_cycle: bool,\n \n+    /// A cycle error results in a delay_bug call\n+    cycle_delay_bug: bool,\n+\n     /// Don't hash the result, instead just mark a query red if it runs\n     no_hash: bool,\n \n@@ -226,6 +234,7 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n     let mut cache = None;\n     let mut desc = None;\n     let mut fatal_cycle = false;\n+    let mut cycle_delay_bug = false;\n     let mut no_hash = false;\n     let mut no_force = false;\n     let mut anon = false;\n@@ -256,6 +265,12 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n                 }\n                 fatal_cycle = true;\n             }\n+            QueryModifier::CycleDelayBug => {\n+                if cycle_delay_bug {\n+                    panic!(\"duplicate modifier `cycle_delay_bug` for query `{}`\", query.name);\n+                }\n+                cycle_delay_bug = true;\n+            }\n             QueryModifier::NoHash => {\n                 if no_hash {\n                     panic!(\"duplicate modifier `no_hash` for query `{}`\", query.name);\n@@ -287,6 +302,7 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n         cache,\n         desc,\n         fatal_cycle,\n+        cycle_delay_bug,\n         no_hash,\n         no_force,\n         anon,\n@@ -333,6 +349,7 @@ fn add_query_description_impl(\n         let tcx = tcx.as_ref().map(|t| quote! { #t }).unwrap_or(quote! { _ });\n         quote! {\n             #[inline]\n+            #[allow(unused_variables)]\n             fn cache_on_disk(#tcx: TyCtxt<'_, 'tcx, 'tcx>, #key: Self::Key) -> bool {\n                 #expr\n             }\n@@ -348,6 +365,7 @@ fn add_query_description_impl(\n     let desc = modifiers.desc.as_ref().map(|(tcx, desc)| {\n         let tcx = tcx.as_ref().map(|t| quote! { #t }).unwrap_or(quote! { _ });\n         quote! {\n+            #[allow(unused_variables)]\n             fn describe(\n                 #tcx: TyCtxt<'_, '_, '_>,\n                 #key: #arg,\n@@ -397,6 +415,10 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n             if modifiers.fatal_cycle {\n                 attributes.push(quote! { fatal_cycle });\n             };\n+            // Pass on the cycle_delay_bug modifier\n+            if modifiers.cycle_delay_bug {\n+                attributes.push(quote! { cycle_delay_bug });\n+            };\n             // Pass on the no_hash modifier\n             if modifiers.no_hash {\n                 attributes.push(quote! { no_hash });"}, {"sha": "13daa72a4d1f40f0ecd7eefa0b70d59a93c5c988", "filename": "src/test/incremental/add_private_fn_at_krate_root_cc/struct_point.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fadd_private_fn_at_krate_root_cc%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fadd_private_fn_at_krate_root_cc%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fadd_private_fn_at_krate_root_cc%2Fstruct_point.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -24,7 +24,7 @@ extern crate point;\n pub mod fn_calls_methods_in_same_impl {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn check() {\n         let x = Point { x: 2.0, y: 2.0 };\n         x.distance_from_origin();\n@@ -35,7 +35,7 @@ pub mod fn_calls_methods_in_same_impl {\n pub mod fn_calls_free_fn {\n     use point::{self, Point};\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn check() {\n         let x = Point { x: 2.0, y: 2.0 };\n         point::distance_squared(&x);\n@@ -46,7 +46,7 @@ pub mod fn_calls_free_fn {\n pub mod fn_make_struct {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn make_origin() -> Point {\n         Point { x: 2.0, y: 2.0 }\n     }\n@@ -56,7 +56,7 @@ pub mod fn_make_struct {\n pub mod fn_read_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn get_x(p: Point) -> f32 {\n         p.x\n     }\n@@ -66,7 +66,7 @@ pub mod fn_read_field {\n pub mod fn_write_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn inc_x(p: &mut Point) {\n         p.x += 1.0;\n     }"}, {"sha": "b49731b26e78f6664f6180b11eb60b98c7ec0cb1", "filename": "src/test/incremental/callee_caller_cross_crate/b.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fb.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -6,12 +6,12 @@\n \n extern crate a;\n \n-#[rustc_dirty(label=\"TypeckTables\", cfg=\"rpass2\")]\n+#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n pub fn call_function0() {\n     a::function0(77);\n }\n \n-#[rustc_clean(label=\"TypeckTables\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n pub fn call_function1() {\n     a::function1(77);\n }"}, {"sha": "9e34aedbed307a1d3002f410de26521216406b9c", "filename": "src/test/incremental/change_add_field/struct_point.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fchange_add_field%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fchange_add_field%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_add_field%2Fstruct_point.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -70,7 +70,7 @@ pub mod point {\n pub mod fn_with_type_in_sig {\n     use point::Point;\n \n-    #[rustc_dirty(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_dirty(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn boop(p: Option<&Point>) -> f32 {\n         p.map(|p| p.total()).unwrap_or(0.0)\n     }\n@@ -86,7 +86,7 @@ pub mod fn_with_type_in_sig {\n pub mod call_fn_with_type_in_sig {\n     use fn_with_type_in_sig;\n \n-    #[rustc_dirty(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_dirty(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn bip() -> f32 {\n         fn_with_type_in_sig::boop(None)\n     }\n@@ -102,7 +102,7 @@ pub mod call_fn_with_type_in_sig {\n pub mod fn_with_type_in_body {\n     use point::Point;\n \n-    #[rustc_dirty(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_dirty(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn boop() -> f32 {\n         Point::origin().total()\n     }\n@@ -115,7 +115,7 @@ pub mod fn_with_type_in_body {\n pub mod call_fn_with_type_in_body {\n     use fn_with_type_in_body;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn bip() -> f32 {\n         fn_with_type_in_body::boop()\n     }\n@@ -125,7 +125,7 @@ pub mod call_fn_with_type_in_body {\n pub mod fn_make_struct {\n     use point::Point;\n \n-    #[rustc_dirty(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_dirty(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn make_origin(p: Point) -> Point {\n         Point { ..p }\n     }\n@@ -135,7 +135,7 @@ pub mod fn_make_struct {\n pub mod fn_read_field {\n     use point::Point;\n \n-    #[rustc_dirty(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_dirty(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn get_x(p: Point) -> f32 {\n         p.x\n     }\n@@ -145,7 +145,7 @@ pub mod fn_read_field {\n pub mod fn_write_field {\n     use point::Point;\n \n-    #[rustc_dirty(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_dirty(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn inc_x(p: &mut Point) {\n         p.x += 1.0;\n     }"}, {"sha": "c167cf6e035d6b505152cb588ff4356c62159e97", "filename": "src/test/incremental/change_crate_order/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fchange_crate_order%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fchange_crate_order%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_crate_order%2Fmain.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -18,7 +18,7 @@ extern crate a;\n use a::A;\n use b::B;\n \n-//? #[rustc_clean(label=\"TypeckTables\", cfg=\"rpass2\")]\n+//? #[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n pub fn main() {\n     A + B;\n }"}, {"sha": "be287b86bbcbac2e1eff894754ee772f154df817", "filename": "src/test/incremental/change_private_fn/struct_point.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fchange_private_fn%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fchange_private_fn%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_fn%2Fstruct_point.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -51,7 +51,7 @@ pub mod point {\n pub mod fn_calls_methods_in_same_impl {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn check() {\n         let x = Point { x: 2.0, y: 2.0 };\n         x.distance_from_origin();\n@@ -62,7 +62,7 @@ pub mod fn_calls_methods_in_same_impl {\n pub mod fn_calls_methods_in_another_impl {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn check() {\n         let mut x = Point { x: 2.0, y: 2.0 };\n         x.translate(3.0, 3.0);\n@@ -73,7 +73,7 @@ pub mod fn_calls_methods_in_another_impl {\n pub mod fn_make_struct {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn make_origin() -> Point {\n         Point { x: 2.0, y: 2.0 }\n     }\n@@ -83,7 +83,7 @@ pub mod fn_make_struct {\n pub mod fn_read_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn get_x(p: Point) -> f32 {\n         p.x\n     }\n@@ -93,7 +93,7 @@ pub mod fn_read_field {\n pub mod fn_write_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn inc_x(p: &mut Point) {\n         p.x += 1.0;\n     }"}, {"sha": "521fe99ebc2eb278e782f378abf7ad5a0af3a0d6", "filename": "src/test/incremental/change_private_fn_cc/struct_point.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fstruct_point.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -23,7 +23,7 @@ extern crate point;\n pub mod fn_calls_methods_in_same_impl {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn check() {\n         let x = Point { x: 2.0, y: 2.0 };\n         x.distance_from_origin();\n@@ -34,7 +34,7 @@ pub mod fn_calls_methods_in_same_impl {\n pub mod fn_calls_methods_in_another_impl {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn check() {\n         let mut x = Point { x: 2.0, y: 2.0 };\n         x.translate(3.0, 3.0);\n@@ -45,7 +45,7 @@ pub mod fn_calls_methods_in_another_impl {\n pub mod fn_make_struct {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn make_origin() -> Point {\n         Point { x: 2.0, y: 2.0 }\n     }\n@@ -55,7 +55,7 @@ pub mod fn_make_struct {\n pub mod fn_read_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn get_x(p: Point) -> f32 {\n         p.x\n     }\n@@ -65,7 +65,7 @@ pub mod fn_read_field {\n pub mod fn_write_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn inc_x(p: &mut Point) {\n         p.x += 1.0;\n     }"}, {"sha": "c2796b5e3c90a7e3a3f4d6540b42a4ed6324f076", "filename": "src/test/incremental/change_private_impl_method/struct_point.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fchange_private_impl_method%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fchange_private_impl_method%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_impl_method%2Fstruct_point.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -51,7 +51,7 @@ pub mod point {\n pub mod fn_calls_methods_in_same_impl {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn check() {\n         let x = Point { x: 2.0, y: 2.0 };\n         x.distance_from_origin();\n@@ -62,7 +62,7 @@ pub mod fn_calls_methods_in_same_impl {\n pub mod fn_calls_methods_in_another_impl {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn check() {\n         let mut x = Point { x: 2.0, y: 2.0 };\n         x.translate(3.0, 3.0);\n@@ -73,7 +73,7 @@ pub mod fn_calls_methods_in_another_impl {\n pub mod fn_make_struct {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn make_origin() -> Point {\n         Point { x: 2.0, y: 2.0 }\n     }\n@@ -83,7 +83,7 @@ pub mod fn_make_struct {\n pub mod fn_read_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn get_x(p: Point) -> f32 {\n         p.x\n     }\n@@ -93,7 +93,7 @@ pub mod fn_read_field {\n pub mod fn_write_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn inc_x(p: &mut Point) {\n         p.x += 1.0;\n     }"}, {"sha": "731dcdf78c933c74239974d1111e93d49cb88fae", "filename": "src/test/incremental/change_private_impl_method_cc/struct_point.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -24,7 +24,7 @@ extern crate point;\n pub mod fn_calls_methods_in_same_impl {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn check() {\n         let x = Point { x: 2.0, y: 2.0 };\n         x.distance_from_origin();\n@@ -35,7 +35,7 @@ pub mod fn_calls_methods_in_same_impl {\n pub mod fn_calls_methods_in_another_impl {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn dirty() {\n         let mut x = Point { x: 2.0, y: 2.0 };\n         x.translate(3.0, 3.0);\n@@ -46,7 +46,7 @@ pub mod fn_calls_methods_in_another_impl {\n pub mod fn_make_struct {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn make_origin() -> Point {\n         Point { x: 2.0, y: 2.0 }\n     }\n@@ -56,7 +56,7 @@ pub mod fn_make_struct {\n pub mod fn_read_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn get_x(p: Point) -> f32 {\n         p.x\n     }\n@@ -66,7 +66,7 @@ pub mod fn_read_field {\n pub mod fn_write_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn inc_x(p: &mut Point) {\n         p.x += 1.0;\n     }"}, {"sha": "76dcff848caf7f189766520bdfb662ed0ce40eb0", "filename": "src/test/incremental/change_pub_inherent_method_body/struct_point.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_body%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_body%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_body%2Fstruct_point.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -42,7 +42,7 @@ pub mod point {\n pub mod fn_calls_changed_method {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn check() {\n         let p = Point { x: 2.0, y: 2.0 };\n         p.distance_from_origin();\n@@ -53,7 +53,7 @@ pub mod fn_calls_changed_method {\n pub mod fn_calls_another_method {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn check() {\n         let p = Point { x: 2.0, y: 2.0 };\n         p.x();\n@@ -64,7 +64,7 @@ pub mod fn_calls_another_method {\n pub mod fn_make_struct {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn make_origin() -> Point {\n         Point { x: 2.0, y: 2.0 }\n     }\n@@ -74,7 +74,7 @@ pub mod fn_make_struct {\n pub mod fn_read_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn get_x(p: Point) -> f32 {\n         p.x\n     }\n@@ -84,7 +84,7 @@ pub mod fn_read_field {\n pub mod fn_write_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn inc_x(p: &mut Point) {\n         p.x += 1.0;\n     }"}, {"sha": "9c95d4cc2a9a50245607aa7acece6b5ae1789edd", "filename": "src/test/incremental/change_pub_inherent_method_sig/struct_point.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_sig%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_sig%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_sig%2Fstruct_point.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -52,7 +52,7 @@ pub mod point {\n pub mod fn_calls_changed_method {\n     use point::Point;\n \n-    #[rustc_dirty(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_dirty(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn check() {\n         let p = Point { x: 2.0, y: 2.0 };\n         p.distance_from_point(None);\n@@ -63,7 +63,7 @@ pub mod fn_calls_changed_method {\n pub mod fn_calls_another_method {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn check() {\n         let p = Point { x: 2.0, y: 2.0 };\n         p.x();\n@@ -74,7 +74,7 @@ pub mod fn_calls_another_method {\n pub mod fn_make_struct {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn make_origin() -> Point {\n         Point { x: 2.0, y: 2.0 }\n     }\n@@ -84,7 +84,7 @@ pub mod fn_make_struct {\n pub mod fn_read_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn get_x(p: Point) -> f32 {\n         p.x\n     }\n@@ -94,7 +94,7 @@ pub mod fn_read_field {\n pub mod fn_write_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn inc_x(p: &mut Point) {\n         p.x += 1.0;\n     }"}, {"sha": "b9a1846b37d44ba93e948f08f0f68b33e1ec30da", "filename": "src/test/incremental/dirty_clean.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fdirty_clean.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -25,16 +25,16 @@ mod x {\n mod y {\n     use x;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn y() {\n-        //[cfail2]~^ ERROR `TypeckTables(y::y)` should be clean but is not\n+        //[cfail2]~^ ERROR `typeck_tables_of(y::y)` should be clean but is not\n         x::x();\n     }\n }\n \n mod z {\n-    #[rustc_dirty(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_dirty(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     pub fn z() {\n-        //[cfail2]~^ ERROR `TypeckTables(z::z)` should be dirty but is not\n+        //[cfail2]~^ ERROR `typeck_tables_of(z::z)` should be dirty but is not\n     }\n }"}, {"sha": "55dd37451235a8254e67afd03cb908d94afb267e", "filename": "src/test/incremental/hashes/call_expressions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Fcall_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Fcall_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fcall_expressions.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -25,7 +25,7 @@ pub fn change_callee_function() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_callee_function() {\n     callee2(1, 2)\n@@ -81,7 +81,7 @@ pub fn change_callee_method() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_callee_method() {\n     let s = Struct;\n@@ -115,7 +115,7 @@ pub fn change_ufcs_callee_method() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_ufcs_callee_method() {\n     let s = Struct;\n@@ -149,7 +149,7 @@ pub fn change_to_ufcs() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n // One might think this would be expanded in the HirBody/Mir, but it actually\n // results in slightly different Hir/Mir.\n@@ -171,7 +171,7 @@ pub mod change_ufcs_callee_indirectly {\n     #[cfg(not(cfail1))]\n     use super::Struct2 as Struct;\n \n-    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir,typeck_tables_of\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n \n "}, {"sha": "5bfd540eca63ec7c9c5ebec63f3b525bc7599133", "filename": "src/test/incremental/hashes/closure_expressions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -37,7 +37,7 @@ pub fn add_parameter() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_parameter() {\n     let x = 0u32;\n@@ -53,7 +53,7 @@ pub fn change_parameter_pattern() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_parameter_pattern() {\n     let _ = |&x: &u32| x;\n@@ -84,7 +84,7 @@ pub fn add_type_ascription_to_parameter() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_type_ascription_to_parameter() {\n     let closure = |x: u32| x + 1u32;\n@@ -101,7 +101,7 @@ pub fn change_parameter_type() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_parameter_type() {\n     let closure = |x: u16| (x as u64) + 1;"}, {"sha": "f553b2d1b5123a91bfbc8790c1f37432621b2b39", "filename": "src/test/incremental/hashes/enum_constructors.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Fenum_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Fenum_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fenum_constructors.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -57,7 +57,7 @@ pub fn change_field_order_struct_like() -> Enum {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n // FIXME(michaelwoerister):Interesting. I would have thought that that changes the MIR. And it\n // would if it were not all constants\n@@ -96,7 +96,7 @@ pub fn change_constructor_path_struct_like() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_constructor_path_struct_like() {\n     let _ = Enum2::Struct {\n@@ -139,8 +139,8 @@ pub mod change_constructor_path_indirectly_struct_like {\n \n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"FnSignature,Hir,HirBody,optimized_mir,mir_built,\\\n-                TypeckTables\"\n+        except=\"fn_sig,Hir,HirBody,optimized_mir,mir_built,\\\n+                typeck_tables_of\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn function() -> TheEnum {\n@@ -197,7 +197,7 @@ pub fn change_constructor_path_tuple_like() {\n #[cfg(not(cfail1))]\n #[rustc_clean(\n     cfg=\"cfail2\",\n-    except=\"HirBody,optimized_mir,mir_built,TypeckTables\"\n+    except=\"HirBody,optimized_mir,mir_built,typeck_tables_of\"\n )]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_constructor_path_tuple_like() {\n@@ -215,7 +215,7 @@ pub fn change_constructor_variant_tuple_like() {\n #[cfg(not(cfail1))]\n #[rustc_clean(\n     cfg=\"cfail2\",\n-    except=\"HirBody,optimized_mir,mir_built,TypeckTables\"\n+    except=\"HirBody,optimized_mir,mir_built,typeck_tables_of\"\n )]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_constructor_variant_tuple_like() {\n@@ -232,8 +232,8 @@ pub mod change_constructor_path_indirectly_tuple_like {\n \n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"FnSignature,Hir,HirBody,optimized_mir,mir_built,\\\n-                TypeckTables\"\n+        except=\"fn_sig,Hir,HirBody,optimized_mir,mir_built,\\\n+                typeck_tables_of\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn function() -> TheEnum {\n@@ -251,7 +251,7 @@ pub mod change_constructor_variant_indirectly_tuple_like {\n     #[cfg(not(cfail1))]\n     use super::Enum2::Tuple2 as Variant;\n \n-    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,TypeckTables\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,typeck_tables_of\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn function() -> Enum2 {\n         Variant(0, 1, 2)\n@@ -278,7 +278,7 @@ pub fn change_constructor_path_c_like() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_constructor_path_c_like() {\n     let _ = Clike2::B;\n@@ -309,8 +309,8 @@ pub mod change_constructor_path_indirectly_c_like {\n \n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"FnSignature,Hir,HirBody,optimized_mir,mir_built,\\\n-                TypeckTables\"\n+        except=\"fn_sig,Hir,HirBody,optimized_mir,mir_built,\\\n+                typeck_tables_of\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn function() -> TheEnum {"}, {"sha": "503cb8732ef70ca72af773b2c60c651b132b4faf", "filename": "src/test/incremental/hashes/for_loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -71,7 +71,7 @@ pub fn change_iteration_variable_pattern() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_iteration_variable_pattern() {\n     let mut _x = 0;\n@@ -116,7 +116,7 @@ pub fn add_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_break() {\n     let mut _x = 0;"}, {"sha": "7850291fc565ab789cfc4cfae746f583cdff33a5", "filename": "src/test/incremental/hashes/function_interfaces.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -24,7 +24,7 @@ pub fn add_parameter() {}\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg = \"cfail2\",\n-              except = \"Hir, HirBody, mir_built, optimized_mir, TypeckTables, FnSignature\")]\n+              except = \"Hir, HirBody, mir_built, optimized_mir, typeck_tables_of, fn_sig\")]\n #[rustc_clean(cfg = \"cfail3\")]\n pub fn add_parameter(p: i32) {}\n \n@@ -47,7 +47,7 @@ pub fn type_of_parameter(p: i32) {}\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg = \"cfail2\",\n-              except = \"Hir, HirBody, mir_built, optimized_mir, TypeckTables, FnSignature\")]\n+              except = \"Hir, HirBody, mir_built, optimized_mir, typeck_tables_of, fn_sig\")]\n #[rustc_clean(cfg = \"cfail3\")]\n pub fn type_of_parameter(p: i64) {}\n \n@@ -59,7 +59,7 @@ pub fn type_of_parameter_ref(p: &i32) {}\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg = \"cfail2\",\n-              except = \"Hir, HirBody, mir_built, optimized_mir, TypeckTables, FnSignature\")]\n+              except = \"Hir, HirBody, mir_built, optimized_mir, typeck_tables_of, fn_sig\")]\n #[rustc_clean(cfg = \"cfail3\")]\n pub fn type_of_parameter_ref(p: &mut i32) {}\n \n@@ -71,7 +71,7 @@ pub fn order_of_parameters(p1: i32, p2: i64) {}\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg = \"cfail2\",\n-              except = \"Hir, HirBody, mir_built, optimized_mir, TypeckTables, FnSignature\")]\n+              except = \"Hir, HirBody, mir_built, optimized_mir, typeck_tables_of, fn_sig\")]\n #[rustc_clean(cfg = \"cfail3\")]\n pub fn order_of_parameters(p2: i64, p1: i32) {}\n \n@@ -83,7 +83,7 @@ pub fn make_unsafe() {}\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg = \"cfail2\",\n-              except = \"Hir, HirBody, mir_built, optimized_mir, TypeckTables, FnSignature\")]\n+              except = \"Hir, HirBody, mir_built, optimized_mir, typeck_tables_of, fn_sig\")]\n #[rustc_clean(cfg = \"cfail3\")]\n pub unsafe fn make_unsafe() {}\n \n@@ -94,7 +94,7 @@ pub unsafe fn make_unsafe() {}\n pub fn make_extern() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody, mir_built, TypeckTables, FnSignature\")]\n+#[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody, mir_built, typeck_tables_of, fn_sig\")]\n #[rustc_clean(cfg = \"cfail3\")]\n pub extern \"C\" fn make_extern() {}\n \n@@ -105,7 +105,7 @@ pub extern \"C\" fn make_extern() {}\n pub extern \"C\" fn make_intrinsic() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody, TypeckTables, FnSignature\")]\n+#[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody, typeck_tables_of, fn_sig\")]\n #[rustc_clean(cfg = \"cfail3\")]\n pub extern \"rust-intrinsic\" fn make_intrinsic() {}\n \n@@ -258,7 +258,7 @@ pub fn return_impl_trait() -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody, TypeckTables, FnSignature\")]\n+#[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody, typeck_tables_of, fn_sig\")]\n #[rustc_clean(cfg = \"cfail3\")]\n pub fn return_impl_trait() -> impl Clone {\n     0\n@@ -292,7 +292,7 @@ pub mod change_return_type_indirectly {\n     use super::ReferencedType2 as ReturnType;\n \n     #[rustc_clean(cfg = \"cfail2\",\n-                  except = \"Hir, HirBody, mir_built, optimized_mir, TypeckTables, FnSignature\")]\n+                  except = \"Hir, HirBody, mir_built, optimized_mir, typeck_tables_of, fn_sig\")]\n     #[rustc_clean(cfg = \"cfail3\")]\n     pub fn indirect_return_type() -> ReturnType {\n         ReturnType {}\n@@ -309,7 +309,7 @@ pub mod change_parameter_type_indirectly {\n     use super::ReferencedType2 as ParameterType;\n \n     #[rustc_clean(cfg = \"cfail2\",\n-                  except = \"Hir, HirBody, mir_built, optimized_mir, TypeckTables, FnSignature\")]\n+                  except = \"Hir, HirBody, mir_built, optimized_mir, typeck_tables_of, fn_sig\")]\n     #[rustc_clean(cfg = \"cfail3\")]\n     pub fn indirect_parameter_type(p: ParameterType) {}\n }"}, {"sha": "fba7869af42f25f1b3aa669da1d099a29bfd1cf3", "filename": "src/test/incremental/hashes/if_expressions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -25,7 +25,7 @@ pub fn change_condition(x: bool) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_condition(x: bool) -> u32 {\n     if !x {\n@@ -94,7 +94,7 @@ pub fn add_else_branch(x: bool) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_else_branch(x: bool) -> u32 {\n     let mut ret = 1;\n@@ -120,7 +120,7 @@ pub fn change_condition_if_let(x: Option<u32>) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_condition_if_let(x: Option<u32>) -> u32 {\n     if let Some(_) = x {\n@@ -143,7 +143,7 @@ pub fn change_then_branch_if_let(x: Option<u32>) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_then_branch_if_let(x: Option<u32>) -> u32 {\n     if let Some(x) = x {\n@@ -191,7 +191,7 @@ pub fn add_else_branch_if_let(x: Option<u32>) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_else_branch_if_let(x: Option<u32>) -> u32 {\n     let mut ret = 1;"}, {"sha": "268c37508a73c0a62605ff76d77604627ab330cb", "filename": "src/test/incremental/hashes/inherent_impls.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -23,7 +23,7 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,AssociatedItemDefIds\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,associated_item_def_ids\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n     #[rustc_clean(cfg=\"cfail3\")]\n@@ -42,7 +42,7 @@ impl Foo {\n #[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,TypeckTables\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,typeck_tables_of\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn method_body() {\n         println!(\"Hello, world!\");\n@@ -63,7 +63,7 @@ impl Foo {\n #[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,TypeckTables\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,typeck_tables_of\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     #[inline]\n     pub fn method_body_inlined() {\n@@ -82,7 +82,7 @@ impl Foo {\n #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_clean(cfg=\"cfail2\", except=\"AssociatedItems,Hir,HirBody\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"associated_item,Hir,HirBody\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     fn method_privacy() { }\n }\n@@ -114,7 +114,7 @@ impl Foo {\n impl Foo {\n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"Hir,HirBody,FnSignature,TypeckTables,optimized_mir,mir_built\"\n+        except=\"Hir,HirBody,fn_sig,typeck_tables_of,optimized_mir,mir_built\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn method_selfmutness(&mut self) { }\n@@ -129,7 +129,7 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,AssociatedItemDefIds\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,associated_item_def_ids\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n     #[rustc_clean(cfg=\"cfail2\")]\n@@ -154,7 +154,7 @@ impl Foo {\n impl Foo {\n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"Hir,HirBody,FnSignature,TypeckTables,optimized_mir,mir_built\"\n+        except=\"Hir,HirBody,fn_sig,typeck_tables_of,optimized_mir,mir_built\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn add_method_parameter(&self, _: i32) { }\n@@ -191,7 +191,7 @@ impl Foo {\n impl Foo {\n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"Hir,HirBody,FnSignature,optimized_mir,mir_built,TypeckTables\")]\n+        except=\"Hir,HirBody,fn_sig,optimized_mir,mir_built,typeck_tables_of\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn change_method_return_type(&self) -> u8 { 0 }\n }\n@@ -245,7 +245,7 @@ impl Foo {\n impl Foo {\n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"Hir,HirBody,FnSignature,TypeckTables,optimized_mir,mir_built\"\n+        except=\"Hir,HirBody,fn_sig,typeck_tables_of,optimized_mir,mir_built\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub unsafe fn make_method_unsafe(&self) { }\n@@ -263,7 +263,7 @@ impl Foo {\n #[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,mir_built,FnSignature,TypeckTables\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,mir_built,fn_sig,typeck_tables_of\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub extern fn make_method_extern(&self) { }\n }\n@@ -280,7 +280,7 @@ impl Foo {\n #[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,FnSignature,TypeckTables\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,fn_sig,typeck_tables_of\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub extern \"system\" fn change_method_calling_convention(&self) { }\n }\n@@ -297,15 +297,15 @@ impl Foo {\n #[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n-    // Warning: Note that `TypeckTables` are coming up clean here.\n+    // Warning: Note that `typeck_tables_of` are coming up clean here.\n     // The addition or removal of lifetime parameters that don't\n     // appear in the arguments or fn body in any way does not, in\n-    // fact, affect the `TypeckTables` in any semantic way (at least\n+    // fact, affect the `typeck_tables_of` in any semantic way (at least\n     // as of this writing). **However,** altering the order of\n-    // lowering **can** cause it appear to affect the `TypeckTables`:\n+    // lowering **can** cause it appear to affect the `typeck_tables_of`:\n     // if we lower generics before the body, then the `HirId` for\n     // things in the body will be affected. So if you start to see\n-    // `TypeckTables` appear dirty, that might be the cause. -nmatsakis\n+    // `typeck_tables_of` appear dirty, that might be the cause. -nmatsakis\n     #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn add_lifetime_parameter_to_method<'a>(&self) { }\n@@ -323,14 +323,14 @@ impl Foo {\n #[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n-    // Warning: Note that `TypeckTables` are coming up clean here.\n+    // Warning: Note that `typeck_tables_of` are coming up clean here.\n     // The addition or removal of type parameters that don't appear in\n     // the arguments or fn body in any way does not, in fact, affect\n-    // the `TypeckTables` in any semantic way (at least as of this\n+    // the `typeck_tables_of` in any semantic way (at least as of this\n     // writing). **However,** altering the order of lowering **can**\n-    // cause it appear to affect the `TypeckTables`: if we lower\n+    // cause it appear to affect the `typeck_tables_of`: if we lower\n     // generics before the body, then the `HirId` for things in the\n-    // body will be affected. So if you start to see `TypeckTables`\n+    // body will be affected. So if you start to see `typeck_tables_of`\n     // appear dirty, that might be the cause. -nmatsakis\n     #[rustc_clean(\n         cfg=\"cfail2\",\n@@ -354,7 +354,7 @@ impl Foo {\n impl Foo {\n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"Hir,HirBody,generics_of,predicates_of,type_of,TypeckTables\"\n+        except=\"Hir,HirBody,generics_of,predicates_of,type_of,typeck_tables_of\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn add_lifetime_bound_to_lifetime_param_of_method<'a, 'b: 'a>(&self) { }\n@@ -372,14 +372,14 @@ impl Foo {\n #[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n-    // Warning: Note that `TypeckTables` are coming up clean here.\n+    // Warning: Note that `typeck_tables_of` are coming up clean here.\n     // The addition or removal of bounds that don't appear in the\n     // arguments or fn body in any way does not, in fact, affect the\n-    // `TypeckTables` in any semantic way (at least as of this\n+    // `typeck_tables_of` in any semantic way (at least as of this\n     // writing). **However,** altering the order of lowering **can**\n-    // cause it appear to affect the `TypeckTables`: if we lower\n+    // cause it appear to affect the `typeck_tables_of`: if we lower\n     // generics before the body, then the `HirId` for things in the\n-    // body will be affected. So if you start to see `TypeckTables`\n+    // body will be affected. So if you start to see `typeck_tables_of`\n     // appear dirty, that might be the cause. -nmatsakis\n     #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,generics_of,predicates_of,\\\n                                         type_of\")]\n@@ -399,14 +399,14 @@ impl Foo {\n #[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n-    // Warning: Note that `TypeckTables` are coming up clean here.\n+    // Warning: Note that `typeck_tables_of` are coming up clean here.\n     // The addition or removal of bounds that don't appear in the\n     // arguments or fn body in any way does not, in fact, affect the\n-    // `TypeckTables` in any semantic way (at least as of this\n+    // `typeck_tables_of` in any semantic way (at least as of this\n     // writing). **However,** altering the order of lowering **can**\n-    // cause it appear to affect the `TypeckTables`: if we lower\n+    // cause it appear to affect the `typeck_tables_of`: if we lower\n     // generics before the body, then the `HirId` for things in the\n-    // body will be affected. So if you start to see `TypeckTables`\n+    // body will be affected. So if you start to see `typeck_tables_of`\n     // appear dirty, that might be the cause. -nmatsakis\n     #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,predicates_of\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n@@ -447,7 +447,7 @@ impl Bar<u32> {\n impl<T> Bar<T> {\n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"generics_of,FnSignature,TypeckTables,type_of,optimized_mir,mir_built\"\n+        except=\"generics_of,fn_sig,typeck_tables_of,type_of,optimized_mir,mir_built\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn add_type_parameter_to_impl(&self) { }\n@@ -465,7 +465,7 @@ impl Bar<u32> {\n #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Bar<u64> {\n-    #[rustc_clean(cfg=\"cfail2\", except=\"FnSignature,optimized_mir,mir_built,TypeckTables\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"fn_sig,optimized_mir,mir_built,typeck_tables_of\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn change_impl_self_type(&self) { }\n }"}, {"sha": "e016b92a9ebdf6951a6e691643f3eaffae33d8a9", "filename": "src/test/incremental/hashes/let_expressions.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -38,7 +38,7 @@ pub fn add_type() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,TypeckTables,mir_built,optimized_mir\")]\n+    except=\"HirBody,typeck_tables_of,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_type() {\n     let _x: u32 = 2u32;\n@@ -54,7 +54,7 @@ pub fn change_type() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,TypeckTables,mir_built,optimized_mir\")]\n+    except=\"HirBody,typeck_tables_of,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_type() {\n     let _x: u8 = 2;\n@@ -70,7 +70,7 @@ pub fn change_mutability_of_reference_type() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,TypeckTables,mir_built,optimized_mir\")]\n+    except=\"HirBody,typeck_tables_of,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_mutability_of_reference_type() {\n     let _x: &mut u64;\n@@ -86,7 +86,7 @@ pub fn change_mutability_of_slot() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,TypeckTables,mir_built,optimized_mir\")]\n+    except=\"HirBody,typeck_tables_of,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_mutability_of_slot() {\n     let _x: u64 = 0;\n@@ -102,7 +102,7 @@ pub fn change_simple_binding_to_pattern() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,TypeckTables,mir_built,optimized_mir\")]\n+    except=\"HirBody,typeck_tables_of,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_simple_binding_to_pattern() {\n     let (_a, _b) = (0u8, 'x');\n@@ -134,7 +134,7 @@ pub fn add_ref_in_pattern() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,TypeckTables,mir_built,optimized_mir\")]\n+    except=\"HirBody,typeck_tables_of,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_ref_in_pattern() {\n     let (ref _a, _b) = (1u8, 'y');\n@@ -150,7 +150,7 @@ pub fn add_amp_in_pattern() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,TypeckTables,mir_built,optimized_mir\")]\n+    except=\"HirBody,typeck_tables_of,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_amp_in_pattern() {\n     let (&_a, _b) = (&1u8, 'y');\n@@ -166,7 +166,7 @@ pub fn change_mutability_of_binding_in_pattern() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,TypeckTables,mir_built,optimized_mir\")]\n+    except=\"HirBody,typeck_tables_of,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_mutability_of_binding_in_pattern() {\n     let (mut _a, _b) = (99u8, 'q');\n@@ -182,7 +182,7 @@ pub fn add_initializer() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,TypeckTables,mir_built,optimized_mir\")]\n+    except=\"HirBody,typeck_tables_of,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_initializer() {\n     let _x: i16 = 3i16;"}, {"sha": "c04bdd43a9528b2622eb783fef174c135707c4ae", "filename": "src/test/incremental/hashes/loop_expressions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -47,7 +47,7 @@ pub fn add_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_break() {\n     let mut _x = 0;\n@@ -118,7 +118,7 @@ pub fn change_break_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_break_label() {\n     let mut _x = 0;\n@@ -168,7 +168,7 @@ pub fn change_continue_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_continue_label() {\n     let mut _x = 0;\n@@ -193,7 +193,7 @@ pub fn change_continue_to_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_continue_to_break() {\n     let mut _x = 0;"}, {"sha": "02f2cd6634daf2e430d0ad5e72be3b92e285e9e7", "filename": "src/test/incremental/hashes/match_expressions.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Fmatch_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Fmatch_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fmatch_expressions.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -26,7 +26,7 @@ pub fn add_arm(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n+    except=\"HirBody,mir_built,optimized_mir,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_arm(x: u32) -> u32 {\n     match x {\n@@ -75,7 +75,7 @@ pub fn add_guard_clause(x: u32, y: bool) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n+    except=\"HirBody,mir_built,optimized_mir,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_guard_clause(x: u32, y: bool) -> u32 {\n     match x {\n@@ -99,7 +99,7 @@ pub fn change_guard_clause(x: u32, y: bool) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n+    except=\"HirBody,mir_built,optimized_mir,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_guard_clause(x: u32, y: bool) -> u32 {\n     match x {\n@@ -123,7 +123,7 @@ pub fn add_at_binding(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n+    except=\"HirBody,mir_built,optimized_mir,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_at_binding(x: u32) -> u32 {\n     match x {\n@@ -170,7 +170,7 @@ pub fn change_simple_name_to_pattern(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n+    except=\"HirBody,mir_built,optimized_mir,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_simple_name_to_pattern(x: u32) -> u32 {\n     match (x, x & 1) {\n@@ -216,7 +216,7 @@ pub fn change_mutability_of_binding_in_pattern(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n+    except=\"HirBody,mir_built,optimized_mir,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_mutability_of_binding_in_pattern(x: u32) -> u32 {\n     match (x, x & 1) {\n@@ -238,7 +238,7 @@ pub fn add_ref_to_binding_in_pattern(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n+    except=\"HirBody,mir_built,optimized_mir,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_ref_to_binding_in_pattern(x: u32) -> u32 {\n     match (x, x & 1) {\n@@ -260,7 +260,7 @@ pub fn add_amp_to_binding_in_pattern(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n+except=\"HirBody,mir_built,optimized_mir,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_amp_to_binding_in_pattern(x: u32) -> u32 {\n     match (&x, x & 1) {\n@@ -307,7 +307,7 @@ pub fn add_alternative_to_arm(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n+    except=\"HirBody,mir_built,optimized_mir,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_alternative_to_arm(x: u32) -> u32 {\n     match x {"}, {"sha": "e478ff96c32768bf8c60ad3182f8a0acc98df25e", "filename": "src/test/incremental/hashes/struct_constructors.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -54,7 +54,7 @@ pub fn change_field_order_regular_struct() -> RegularStruct {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_field_order_regular_struct() -> RegularStruct {\n     RegularStruct {\n@@ -82,7 +82,7 @@ pub fn add_field_regular_struct() -> RegularStruct {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_field_regular_struct() -> RegularStruct {\n     let struct1 = RegularStruct {\n@@ -117,7 +117,7 @@ pub fn change_field_label_regular_struct() -> RegularStruct {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_field_label_regular_struct() -> RegularStruct {\n     let struct1 = RegularStruct {\n@@ -152,7 +152,7 @@ pub fn change_constructor_path_regular_struct() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_constructor_path_regular_struct() {\n     let _ = RegularStruct2 {\n@@ -173,7 +173,7 @@ pub mod change_constructor_path_indirectly_regular_struct {\n \n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"FnSignature,Hir,HirBody,optimized_mir,mir_built,TypeckTables\"\n+        except=\"fn_sig,Hir,HirBody,optimized_mir,mir_built,typeck_tables_of\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn function() -> Struct {\n@@ -213,7 +213,7 @@ pub fn change_constructor_path_tuple_struct() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_constructor_path_tuple_struct() {\n     let _ = TupleStruct2(0, 1, 2);\n@@ -230,7 +230,7 @@ pub mod change_constructor_path_indirectly_tuple_struct {\n \n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"FnSignature,Hir,HirBody,optimized_mir,mir_built,TypeckTables\"\n+        except=\"fn_sig,Hir,HirBody,optimized_mir,mir_built,typeck_tables_of\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn function() -> Struct {"}, {"sha": "8c53ae6a03854e04b3ed962df18c666d1588aacd", "filename": "src/test/incremental/hashes/unary_and_binary_exprs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Funary_and_binary_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Funary_and_binary_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Funary_and_binary_exprs.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -81,7 +81,7 @@ pub fn var_deref(x: &i32, y: &i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,optimized_mir,mir_built,TypeckTables\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built,typeck_tables_of\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn var_deref(x: &i32, y: &i32) -> i32 {\n     *y\n@@ -368,7 +368,7 @@ pub fn type_cast(a: u8) -> u64 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,optimized_mir,mir_built,TypeckTables\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built,typeck_tables_of\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn type_cast(a: u8) -> u64 {\n     let b = a as u32;"}, {"sha": "2d48707561c2903bc470d55a74e5d0aa6c4687d8", "filename": "src/test/incremental/hashes/while_let_loops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -70,7 +70,7 @@ pub fn add_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_break() {\n     let mut _x = 0;\n@@ -141,7 +141,7 @@ pub fn change_break_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_break_label() {\n     let mut _x = 0;\n@@ -191,7 +191,7 @@ pub fn change_continue_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_continue_label() {\n     let mut _x = 0;"}, {"sha": "79a3bc9b20504250da6a06475fc8edcf0d3b65d6", "filename": "src/test/incremental/hashes/while_loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -70,7 +70,7 @@ pub fn add_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_break() {\n     let mut _x = 0;"}, {"sha": "e4d8c56752c7889335fc004caa008543f39099ae", "filename": "src/test/incremental/hello_world.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fhello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhello_world.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -21,7 +21,7 @@ mod x {\n mod y {\n     use x;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n     pub fn yyyy() {\n         x::xxxx();\n     }\n@@ -30,7 +30,7 @@ mod y {\n mod z {\n     use y;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n     pub fn z() {\n         y::yyyy();\n     }"}, {"sha": "9dfd2ae2511b15b009f79b3d9552fe3f742ddf30", "filename": "src/test/incremental/ich_method_call_trait_scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fich_method_call_trait_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fich_method_call_trait_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fich_method_call_trait_scope.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -28,14 +28,14 @@ mod mod3 {\n \n     #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n     #[rustc_clean(label=\"HirBody\", cfg=\"rpass2\")]\n-    #[rustc_dirty(label=\"TypeckTables\", cfg=\"rpass2\")]\n+    #[rustc_dirty(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n     fn bar() {\n         ().method();\n     }\n \n     #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n     #[rustc_clean(label=\"HirBody\", cfg=\"rpass2\")]\n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n     fn baz() {\n         22; // no method call, traits in scope don't matter\n     }"}, {"sha": "81b84ba741dc87e190e773b19032837d700c6e09", "filename": "src/test/incremental/rlib_cross_crate/b.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -12,15 +12,15 @@\n \n extern crate a;\n \n-#[rustc_dirty(label=\"TypeckTables\", cfg=\"rpass2\")]\n-#[rustc_clean(label=\"TypeckTables\", cfg=\"rpass3\")]\n+#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass3\")]\n pub fn use_X() -> u32 {\n     let x: a::X = 22;\n     x as u32\n }\n \n-#[rustc_clean(label=\"TypeckTables\", cfg=\"rpass2\")]\n-#[rustc_clean(label=\"TypeckTables\", cfg=\"rpass3\")]\n+#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass3\")]\n pub fn use_Y() {\n     let x: a::Y = 'c';\n }"}, {"sha": "c39d4145b586f13808f86a56e7add59c6dccb4ab", "filename": "src/test/incremental/string_constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fstring_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fstring_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstring_constant.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -28,7 +28,7 @@ pub mod x {\n pub mod y {\n     use x;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"optimized_mir\", cfg=\"cfail2\")]\n     pub fn y() {\n         x::x();\n@@ -38,7 +38,7 @@ pub mod y {\n pub mod z {\n     use y;\n \n-    #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"optimized_mir\", cfg=\"cfail2\")]\n     pub fn z() {\n         y::y();"}, {"sha": "d2e1e7decf54e8d6448ac5a9a16743c0ff5b8f70", "filename": "src/test/incremental/struct_add_field.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fstruct_add_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fstruct_add_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_add_field.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -21,17 +21,17 @@ pub struct Y {\n     pub y: char\n }\n \n-#[rustc_dirty(label=\"TypeckTables\", cfg=\"rpass2\")]\n+#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n pub fn use_X(x: X) -> u32 {\n     x.x as u32\n }\n \n-#[rustc_dirty(label=\"TypeckTables\", cfg=\"rpass2\")]\n+#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n pub fn use_EmbedX(embed: EmbedX) -> u32 {\n     embed.x.x as u32\n }\n \n-#[rustc_clean(label=\"TypeckTables\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n pub fn use_Y() {\n     let x: Y = Y { y: 'c' };\n }"}, {"sha": "68356f703bcf8e7b2ae6cf2eab2acbe65ea459d1", "filename": "src/test/incremental/struct_change_field_name.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fstruct_change_field_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fstruct_change_field_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_change_field_name.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -24,21 +24,21 @@ pub struct Y {\n     pub y: char\n }\n \n-#[rustc_dirty(label=\"TypeckTables\", cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n pub fn use_X() -> u32 {\n     let x: X = X { x: 22 };\n     //[cfail2]~^ ERROR struct `X` has no field named `x`\n     x.x as u32\n     //[cfail2]~^ ERROR no field `x` on type `X`\n }\n \n-#[rustc_dirty(label=\"TypeckTables\", cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n pub fn use_EmbedX(embed: EmbedX) -> u32 {\n     embed.x.x as u32\n     //[cfail2]~^ ERROR no field `x` on type `X`\n }\n \n-#[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n pub fn use_Y() {\n     let x: Y = Y { y: 'c' };\n }"}, {"sha": "308ec84fa72effa56ae57252c3b26db767c913b1", "filename": "src/test/incremental/struct_change_field_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fstruct_change_field_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fstruct_change_field_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_change_field_type.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -24,19 +24,19 @@ pub struct Y {\n     pub y: char\n }\n \n-#[rustc_dirty(label=\"TypeckTables\", cfg=\"rpass2\")]\n+#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n pub fn use_X() -> u32 {\n     let x: X = X { x: 22 };\n     x.x as u32\n }\n \n-#[rustc_dirty(label=\"TypeckTables\", cfg=\"rpass2\")]\n+#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n pub fn use_EmbedX(x: EmbedX) -> u32 {\n     let x: X = X { x: 22 };\n     x.x as u32\n }\n \n-#[rustc_clean(label=\"TypeckTables\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n pub fn use_Y() {\n     let x: Y = Y { y: 'c' };\n }"}, {"sha": "9d84c2cf773b8cccb19315cbc64c0b8da20912ad", "filename": "src/test/incremental/struct_change_field_type_cross_crate/b.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fb.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -8,18 +8,18 @@ extern crate a;\n \n use a::*;\n \n-#[rustc_dirty(label=\"TypeckTables\", cfg=\"rpass2\")]\n+#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n pub fn use_X() -> u32 {\n     let x: X = X { x: 22 };\n     x.x as u32\n }\n \n-#[rustc_dirty(label=\"TypeckTables\", cfg=\"rpass2\")]\n+#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n pub fn use_EmbedX(embed: EmbedX) -> u32 {\n     embed.x.x as u32\n }\n \n-#[rustc_clean(label=\"TypeckTables\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n pub fn use_Y() {\n     let x: Y = Y { y: 'c' };\n }"}, {"sha": "bbded1da2161999e9e813c8b2aaf406f2e4500b1", "filename": "src/test/incremental/struct_change_nothing.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fstruct_change_nothing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fstruct_change_nothing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_change_nothing.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -24,19 +24,19 @@ pub struct Y {\n     pub y: char\n }\n \n-#[rustc_clean(label=\"TypeckTables\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n pub fn use_X() -> u32 {\n     let x: X = X { x: 22 };\n     x.x as u32\n }\n \n-#[rustc_clean(label=\"TypeckTables\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n pub fn use_EmbedX(x: EmbedX) -> u32 {\n     let x: X = X { x: 22 };\n     x.x as u32\n }\n \n-#[rustc_clean(label=\"TypeckTables\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n pub fn use_Y() {\n     let x: Y = Y { y: 'c' };\n }"}, {"sha": "4c4028bbe5bdda2ea14ef79f1ce0344f5d9202e6", "filename": "src/test/incremental/struct_remove_field.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fstruct_remove_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Fstruct_remove_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_remove_field.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -25,17 +25,17 @@ pub struct Y {\n     pub y: char\n }\n \n-#[rustc_dirty(label=\"TypeckTables\", cfg=\"rpass2\")]\n+#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n pub fn use_X(x: X) -> u32 {\n     x.x as u32\n }\n \n-#[rustc_dirty(label=\"TypeckTables\", cfg=\"rpass2\")]\n+#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n pub fn use_EmbedX(embed: EmbedX) -> u32 {\n     embed.x.x as u32\n }\n \n-#[rustc_clean(label=\"TypeckTables\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n pub fn use_Y() {\n     let x: Y = Y { y: 'c' };\n }"}, {"sha": "cef2e4bab12d722653dc408011748ed985b80ca4", "filename": "src/test/incremental/type_alias_cross_crate/b.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -6,15 +6,15 @@\n \n extern crate a;\n \n-#[rustc_dirty(label=\"TypeckTables\", cfg=\"rpass2\")]\n-#[rustc_clean(label=\"TypeckTables\", cfg=\"rpass3\")]\n+#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass3\")]\n pub fn use_X() -> u32 {\n     let x: a::X = 22;\n     x as u32\n }\n \n-#[rustc_clean(label=\"TypeckTables\", cfg=\"rpass2\")]\n-#[rustc_clean(label=\"TypeckTables\", cfg=\"rpass3\")]\n+#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass3\")]\n pub fn use_Y() {\n     let x: a::Y = 'c';\n }"}, {"sha": "bcf7e3e6608eaa810d00124f4e54954ce68b461d", "filename": "src/test/ui/dep-graph/dep-graph-assoc-type-codegen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-assoc-type-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-assoc-type-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-assoc-type-codegen.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -25,7 +25,7 @@ mod x {\n mod y {\n     use Foo;\n \n-    #[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK\n+    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n     pub fn use_char_assoc() {\n         // Careful here: in the representation, <char as Foo>::T gets\n         // normalized away, so at a certain point we had no edge to"}, {"sha": "a603d71596ba627c0ef636ab1e8a6417a316bba0", "filename": "src/test/ui/dep-graph/dep-graph-assoc-type-codegen.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-assoc-type-codegen.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-assoc-type-codegen.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-assoc-type-codegen.stderr?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -1,8 +1,8 @@\n error: OK\n   --> $DIR/dep-graph-assoc-type-codegen.rs:28:5\n    |\n-LL |     #[rustc_then_this_would_need(TypeckTables)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "18b4252a06b8443889501c3ceeb0ed1d100ab509", "filename": "src/test/ui/dep-graph/dep-graph-caller-callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-caller-callee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-caller-callee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-caller-callee.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -17,7 +17,7 @@ mod y {\n     use x;\n \n     // These dependencies SHOULD exist:\n-    #[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK\n+    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n     pub fn y() {\n         x::x();\n     }\n@@ -28,7 +28,7 @@ mod z {\n \n     // These are expected to yield errors, because changes to `x`\n     // affect the BODY of `y`, but not its signature.\n-    #[rustc_then_this_would_need(TypeckTables)] //~ ERROR no path\n+    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR no path\n     pub fn z() {\n         y::y();\n     }"}, {"sha": "de041e600672d47b8050ee5482ad56e187686efe", "filename": "src/test/ui/dep-graph/dep-graph-caller-callee.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-caller-callee.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-caller-callee.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-caller-callee.stderr?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -1,14 +1,14 @@\n error: OK\n   --> $DIR/dep-graph-caller-callee.rs:20:5\n    |\n-LL |     #[rustc_then_this_would_need(TypeckTables)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: no path from `x::x` to `TypeckTables`\n+error: no path from `x::x` to `typeck_tables_of`\n   --> $DIR/dep-graph-caller-callee.rs:31:5\n    |\n-LL |     #[rustc_then_this_would_need(TypeckTables)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "8b78d39ecae332ba72d50fb9e542cc5a9d0803e2", "filename": "src/test/ui/dep-graph/dep-graph-struct-signature.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-struct-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-struct-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-struct-signature.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -25,34 +25,34 @@ mod signatures {\n     use WillChange;\n \n     #[rustc_then_this_would_need(type_of)] //~ ERROR no path\n-    #[rustc_then_this_would_need(AssociatedItems)] //~ ERROR no path\n-    #[rustc_then_this_would_need(TraitDefOfItem)] //~ ERROR no path\n+    #[rustc_then_this_would_need(associated_item)] //~ ERROR no path\n+    #[rustc_then_this_would_need(trait_def)] //~ ERROR no path\n     trait Bar {\n-        #[rustc_then_this_would_need(FnSignature)] //~ ERROR OK\n+        #[rustc_then_this_would_need(fn_sig)] //~ ERROR OK\n         fn do_something(x: WillChange);\n     }\n \n-    #[rustc_then_this_would_need(FnSignature)] //~ ERROR OK\n-    #[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK\n+    #[rustc_then_this_would_need(fn_sig)] //~ ERROR OK\n+    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n     fn some_fn(x: WillChange) { }\n \n-    #[rustc_then_this_would_need(FnSignature)] //~ ERROR OK\n-    #[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK\n+    #[rustc_then_this_would_need(fn_sig)] //~ ERROR OK\n+    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n     fn new_foo(x: u32, y: u32) -> WillChange {\n         WillChange { x: x, y: y }\n     }\n \n     #[rustc_then_this_would_need(type_of)] //~ ERROR OK\n     impl WillChange {\n-        #[rustc_then_this_would_need(FnSignature)] //~ ERROR OK\n-        #[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK\n+        #[rustc_then_this_would_need(fn_sig)] //~ ERROR OK\n+        #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n         fn new(x: u32, y: u32) -> WillChange { loop { } }\n     }\n \n     #[rustc_then_this_would_need(type_of)] //~ ERROR OK\n     impl WillChange {\n-        #[rustc_then_this_would_need(FnSignature)] //~ ERROR OK\n-        #[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK\n+        #[rustc_then_this_would_need(fn_sig)] //~ ERROR OK\n+        #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n         fn method(&self, x: u32) { }\n     }\n \n@@ -73,14 +73,14 @@ mod invalid_signatures {\n \n     #[rustc_then_this_would_need(type_of)] //~ ERROR no path\n     trait A {\n-        #[rustc_then_this_would_need(FnSignature)] //~ ERROR no path\n+        #[rustc_then_this_would_need(fn_sig)] //~ ERROR no path\n         fn do_something_else_twice(x: WontChange);\n     }\n \n-    #[rustc_then_this_would_need(FnSignature)] //~ ERROR no path\n+    #[rustc_then_this_would_need(fn_sig)] //~ ERROR no path\n     fn b(x: WontChange) { }\n \n-    #[rustc_then_this_would_need(FnSignature)] //~ ERROR no path from `WillChange`\n-    #[rustc_then_this_would_need(TypeckTables)] //~ ERROR no path from `WillChange`\n+    #[rustc_then_this_would_need(fn_sig)] //~ ERROR no path from `WillChange`\n+    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR no path from `WillChange`\n     fn c(x: u32) { }\n }"}, {"sha": "2e00e5a2cbd2f07144d38e7858d342f9e3a2f09d", "filename": "src/test/ui/dep-graph/dep-graph-struct-signature.stderr", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-struct-signature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-struct-signature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-struct-signature.stderr?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -4,41 +4,41 @@ error: no path from `WillChange` to `type_of`\n LL |     #[rustc_then_this_would_need(type_of)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: no path from `WillChange` to `AssociatedItems`\n+error: no path from `WillChange` to `associated_item`\n   --> $DIR/dep-graph-struct-signature.rs:28:5\n    |\n-LL |     #[rustc_then_this_would_need(AssociatedItems)]\n+LL |     #[rustc_then_this_would_need(associated_item)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: no path from `WillChange` to `TraitDefOfItem`\n+error: no path from `WillChange` to `trait_def`\n   --> $DIR/dep-graph-struct-signature.rs:29:5\n    |\n-LL |     #[rustc_then_this_would_need(TraitDefOfItem)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(trait_def)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-struct-signature.rs:35:5\n    |\n-LL |     #[rustc_then_this_would_need(FnSignature)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(fn_sig)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-struct-signature.rs:36:5\n    |\n-LL |     #[rustc_then_this_would_need(TypeckTables)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-struct-signature.rs:39:5\n    |\n-LL |     #[rustc_then_this_would_need(FnSignature)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(fn_sig)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-struct-signature.rs:40:5\n    |\n-LL |     #[rustc_then_this_would_need(TypeckTables)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-struct-signature.rs:45:5\n@@ -76,59 +76,59 @@ error: no path from `WillChange` to `type_of`\n LL |     #[rustc_then_this_would_need(type_of)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: no path from `WillChange` to `FnSignature`\n+error: no path from `WillChange` to `fn_sig`\n   --> $DIR/dep-graph-struct-signature.rs:80:5\n    |\n-LL |     #[rustc_then_this_would_need(FnSignature)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(fn_sig)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: no path from `WillChange` to `FnSignature`\n+error: no path from `WillChange` to `fn_sig`\n   --> $DIR/dep-graph-struct-signature.rs:83:5\n    |\n-LL |     #[rustc_then_this_would_need(FnSignature)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(fn_sig)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: no path from `WillChange` to `TypeckTables`\n+error: no path from `WillChange` to `typeck_tables_of`\n   --> $DIR/dep-graph-struct-signature.rs:84:5\n    |\n-LL |     #[rustc_then_this_would_need(TypeckTables)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-struct-signature.rs:31:9\n    |\n-LL |         #[rustc_then_this_would_need(FnSignature)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         #[rustc_then_this_would_need(fn_sig)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: no path from `WillChange` to `FnSignature`\n+error: no path from `WillChange` to `fn_sig`\n   --> $DIR/dep-graph-struct-signature.rs:76:9\n    |\n-LL |         #[rustc_then_this_would_need(FnSignature)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         #[rustc_then_this_would_need(fn_sig)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-struct-signature.rs:47:9\n    |\n-LL |         #[rustc_then_this_would_need(FnSignature)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         #[rustc_then_this_would_need(fn_sig)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-struct-signature.rs:48:9\n    |\n-LL |         #[rustc_then_this_would_need(TypeckTables)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         #[rustc_then_this_would_need(typeck_tables_of)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-struct-signature.rs:54:9\n    |\n-LL |         #[rustc_then_this_would_need(FnSignature)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         #[rustc_then_this_would_need(fn_sig)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-struct-signature.rs:55:9\n    |\n-LL |         #[rustc_then_this_would_need(TypeckTables)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         #[rustc_then_this_would_need(typeck_tables_of)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 22 previous errors\n "}, {"sha": "38622a754ddb2cb339542757677d440b0082bedc", "filename": "src/test/ui/dep-graph/dep-graph-trait-impl-two-traits-same-method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits-same-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits-same-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits-same-method.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -29,7 +29,7 @@ mod x {\n mod y {\n     use {Foo, Bar};\n \n-    #[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK\n+    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n     pub fn with_char() {\n         char::method('a');\n     }\n@@ -38,7 +38,7 @@ mod y {\n mod z {\n     use y;\n \n-    #[rustc_then_this_would_need(TypeckTables)] //~ ERROR no path\n+    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR no path\n     pub fn z() {\n         y::with_char();\n     }"}, {"sha": "3384fd7b4acf570583964d1d6069a36971fed979", "filename": "src/test/ui/dep-graph/dep-graph-trait-impl-two-traits-same-method.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits-same-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits-same-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits-same-method.stderr?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -1,14 +1,14 @@\n error: OK\n   --> $DIR/dep-graph-trait-impl-two-traits-same-method.rs:32:5\n    |\n-LL |     #[rustc_then_this_would_need(TypeckTables)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: no path from `x::<impl Foo for u32>` to `TypeckTables`\n+error: no path from `x::<impl Foo for u32>` to `typeck_tables_of`\n   --> $DIR/dep-graph-trait-impl-two-traits-same-method.rs:41:5\n    |\n-LL |     #[rustc_then_this_would_need(TypeckTables)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "82306b6539c155263abd6eb158b8399eb82ceb63", "filename": "src/test/ui/dep-graph/dep-graph-trait-impl-two-traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -28,7 +28,7 @@ mod x {\n mod y {\n     use {Foo, Bar};\n \n-    #[rustc_then_this_would_need(TypeckTables)] //~ ERROR no path\n+    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR no path\n     pub fn call_bar() {\n         char::bar('a');\n     }\n@@ -37,7 +37,7 @@ mod y {\n mod z {\n     use y;\n \n-    #[rustc_then_this_would_need(TypeckTables)] //~ ERROR no path\n+    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR no path\n     pub fn z() {\n         y::call_bar();\n     }"}, {"sha": "d8a1f05dcaa7920143370e70dc097f51fdf2cb54", "filename": "src/test/ui/dep-graph/dep-graph-trait-impl-two-traits.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.stderr?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -1,14 +1,14 @@\n-error: no path from `x::<impl Foo for char>` to `TypeckTables`\n+error: no path from `x::<impl Foo for char>` to `typeck_tables_of`\n   --> $DIR/dep-graph-trait-impl-two-traits.rs:31:5\n    |\n-LL |     #[rustc_then_this_would_need(TypeckTables)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: no path from `x::<impl Foo for char>` to `TypeckTables`\n+error: no path from `x::<impl Foo for char>` to `typeck_tables_of`\n   --> $DIR/dep-graph-trait-impl-two-traits.rs:40:5\n    |\n-LL |     #[rustc_then_this_would_need(TypeckTables)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "e4483b9f71ddb22a95cb50d09eb6afd2655902c3", "filename": "src/test/ui/dep-graph/dep-graph-trait-impl.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -24,22 +24,22 @@ mod x {\n mod y {\n     use Foo;\n \n-    #[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK\n+    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n     pub fn with_char() {\n         char::method('a');\n     }\n \n-    #[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK\n+    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n     pub fn take_foo_with_char() {\n         take_foo::<char>('a');\n     }\n \n-    #[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK\n+    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n     pub fn with_u32() {\n         u32::method(22);\n     }\n \n-    #[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK\n+    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n     pub fn take_foo_with_u32() {\n         take_foo::<u32>(22);\n     }\n@@ -52,7 +52,7 @@ mod z {\n \n     // These are expected to yield errors, because changes to `x`\n     // affect the BODY of `y`, but not its signature.\n-    #[rustc_then_this_would_need(TypeckTables)] //~ ERROR no path\n+    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR no path\n     pub fn z() {\n         y::with_char();\n         y::with_u32();"}, {"sha": "ca9676a9478e4c826f9d34fb2131db629657a0b6", "filename": "src/test/ui/dep-graph/dep-graph-trait-impl.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl.stderr?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -1,32 +1,32 @@\n error: OK\n   --> $DIR/dep-graph-trait-impl.rs:27:5\n    |\n-LL |     #[rustc_then_this_would_need(TypeckTables)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-trait-impl.rs:32:5\n    |\n-LL |     #[rustc_then_this_would_need(TypeckTables)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-trait-impl.rs:37:5\n    |\n-LL |     #[rustc_then_this_would_need(TypeckTables)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-trait-impl.rs:42:5\n    |\n-LL |     #[rustc_then_this_would_need(TypeckTables)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: no path from `x::<impl Foo for char>` to `TypeckTables`\n+error: no path from `x::<impl Foo for char>` to `typeck_tables_of`\n   --> $DIR/dep-graph-trait-impl.rs:55:5\n    |\n-LL |     #[rustc_then_this_would_need(TypeckTables)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 5 previous errors\n "}, {"sha": "2d4a18f2818b57d71bfe8a78d0f175ec016177cf", "filename": "src/test/ui/dep-graph/dep-graph-type-alias.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-type-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-type-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-type-alias.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -32,24 +32,24 @@ enum Enum {\n \n #[rustc_then_this_would_need(type_of)] //~ ERROR no path\n trait Trait {\n-    #[rustc_then_this_would_need(FnSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(fn_sig)] //~ ERROR OK\n     fn method(&self, _: TypeAlias);\n }\n \n struct SomeType;\n \n #[rustc_then_this_would_need(type_of)] //~ ERROR no path\n impl SomeType {\n-    #[rustc_then_this_would_need(FnSignature)] //~ ERROR OK\n-    #[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK\n+    #[rustc_then_this_would_need(fn_sig)] //~ ERROR OK\n+    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n     fn method(&self, _: TypeAlias) {}\n }\n \n #[rustc_then_this_would_need(type_of)] //~ ERROR OK\n type TypeAlias2 = TypeAlias;\n \n-#[rustc_then_this_would_need(FnSignature)] //~ ERROR OK\n-#[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK\n+#[rustc_then_this_would_need(fn_sig)] //~ ERROR OK\n+#[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n fn function(_: TypeAlias) {\n \n }"}, {"sha": "393e4badc160847447f08c3608a7eadb45a94118", "filename": "src/test/ui/dep-graph/dep-graph-type-alias.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-type-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-type-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-type-alias.stderr?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -43,32 +43,32 @@ LL | #[rustc_then_this_would_need(type_of)]\n error: OK\n   --> $DIR/dep-graph-type-alias.rs:51:1\n    |\n-LL | #[rustc_then_this_would_need(FnSignature)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[rustc_then_this_would_need(fn_sig)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-type-alias.rs:52:1\n    |\n-LL | #[rustc_then_this_would_need(TypeckTables)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[rustc_then_this_would_need(typeck_tables_of)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-type-alias.rs:35:5\n    |\n-LL |     #[rustc_then_this_would_need(FnSignature)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(fn_sig)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-type-alias.rs:43:5\n    |\n-LL |     #[rustc_then_this_would_need(FnSignature)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(fn_sig)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-type-alias.rs:44:5\n    |\n-LL |     #[rustc_then_this_would_need(TypeckTables)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 12 previous errors\n "}, {"sha": "95645687307a37f07fa3527ddb78baee46e7924e", "filename": "src/test/ui/dep-graph/dep-graph-variance-alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-variance-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-variance-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-variance-alias.rs?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -16,7 +16,7 @@ struct Foo<T> {\n #[rustc_if_this_changed(Krate)]\n type TypeAlias<T> = Foo<T>;\n \n-#[rustc_then_this_would_need(ItemVariances)] //~ ERROR OK\n+#[rustc_then_this_would_need(variances_of)] //~ ERROR OK\n struct Use<T> {\n     x: TypeAlias<T>\n }"}, {"sha": "554ff455a2073580156b905e8ed63021bd50bdbf", "filename": "src/test/ui/dep-graph/dep-graph-variance-alias.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-variance-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e43f99ce576152d4b2f7315d491c4210211228d6/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-variance-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-variance-alias.stderr?ref=e43f99ce576152d4b2f7315d491c4210211228d6", "patch": "@@ -1,8 +1,8 @@\n error: OK\n   --> $DIR/dep-graph-variance-alias.rs:19:1\n    |\n-LL | #[rustc_then_this_would_need(ItemVariances)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[rustc_then_this_would_need(variances_of)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}]}