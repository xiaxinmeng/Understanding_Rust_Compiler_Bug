{"sha": "e6739fe27448e1f85820d80a6a75292b39446d08", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2NzM5ZmUyNzQ0OGUxZjg1ODIwZDgwYTZhNzUyOTJiMzk0NDZkMDg=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-11-03T19:02:36Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-11-18T10:51:13Z"}, "message": "resolve: Resolve multi-segment imports using in-scope resolution on 2018 edition", "tree": {"sha": "9f9af9eab96d44287ba678b43648d4d0702e518b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f9af9eab96d44287ba678b43648d4d0702e518b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6739fe27448e1f85820d80a6a75292b39446d08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6739fe27448e1f85820d80a6a75292b39446d08", "html_url": "https://github.com/rust-lang/rust/commit/e6739fe27448e1f85820d80a6a75292b39446d08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6739fe27448e1f85820d80a6a75292b39446d08/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67feeebfadbb69b437281ad2e0b30b27289b436d", "url": "https://api.github.com/repos/rust-lang/rust/commits/67feeebfadbb69b437281ad2e0b30b27289b436d", "html_url": "https://github.com/rust-lang/rust/commit/67feeebfadbb69b437281ad2e0b30b27289b436d"}], "stats": {"total": 113, "additions": 47, "deletions": 66}, "files": [{"sha": "777543bcf37eba4abb420cc431f7677e4f784432", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e6739fe27448e1f85820d80a6a75292b39446d08/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6739fe27448e1f85820d80a6a75292b39446d08/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=e6739fe27448e1f85820d80a6a75292b39446d08", "patch": "@@ -125,36 +125,24 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         debug!(\"build_reduced_graph_for_use_tree(parent_prefix={:?}, use_tree={:?}, nested={})\",\n                parent_prefix, use_tree, nested);\n \n-        let uniform_paths =\n-            self.session.rust_2018() &&\n-            self.session.features_untracked().uniform_paths;\n-\n-        let prefix_iter = || parent_prefix.iter().cloned()\n-            .chain(use_tree.prefix.segments.iter().map(|seg| seg.into()));\n-        let prefix_start = prefix_iter().next();\n-        let starts_with_non_keyword = prefix_start.map_or(false, |seg| {\n-            !seg.ident.is_path_segment_keyword()\n-        });\n-\n-        // Imports are resolved as global by default, prepend `CrateRoot`,\n-        // unless `#![feature(uniform_paths)]` is enabled.\n-        let inject_crate_root =\n-            !uniform_paths &&\n-            match use_tree.kind {\n-                // HACK(eddyb) special-case `use *` to mean `use ::*`.\n-                ast::UseTreeKind::Glob if prefix_start.is_none() => true,\n-                _ => starts_with_non_keyword,\n-            };\n-        let root = if inject_crate_root {\n-            let span = use_tree.prefix.span.shrink_to_lo();\n-            Some(Segment::from_ident(Ident::new(keywords::CrateRoot.name(), span)))\n+        let mut prefix_iter = parent_prefix.iter().cloned()\n+            .chain(use_tree.prefix.segments.iter().map(|seg| seg.ident)).peekable();\n+\n+        // On 2015 edition imports are resolved as crate-relative by default,\n+        // so prefixes are prepended with crate root segment if necessary.\n+        // The root is prepended lazily, when the first non-empty prefix or terminating glob\n+        // appears, so imports in braced groups can have roots prepended independently.\n+        let is_glob = if let ast::UseTreeKind::Glob = use_tree.kind { true } else { false };\n+        let crate_root = if !self.session.rust_2018() &&\n+                prefix_iter.peek().map_or(is_glob, |ident| !ident.is_path_segment_keyword()) {\n+            Some(Ident::new(keywords::CrateRoot.name(), use_tree.prefix.span.shrink_to_lo()))\n         } else {\n             None\n         };\n \n-        let prefix: Vec<_> = root.into_iter().chain(prefix_iter()).collect();\n-\n+        let prefix = crate_root.into_iter().chain(prefix_iter).collect::<Vec<_>>();\n         debug!(\"build_reduced_graph_for_use_tree: prefix={:?}\", prefix);\n+\n         let empty_for_self = |prefix: &[Segment]| {\n             prefix.is_empty() ||\n             prefix.len() == 1 && prefix[0].ident.name == keywords::CrateRoot.name()"}, {"sha": "49661954e580956cfcaf2315f5b9430c7b41daec", "filename": "src/librustc_resolve/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e6739fe27448e1f85820d80a6a75292b39446d08/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6739fe27448e1f85820d80a6a75292b39446d08/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=e6739fe27448e1f85820d80a6a75292b39446d08", "patch": "@@ -68,7 +68,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Replace first ident with `self` and check if that is valid.\n         path[0].ident.name = keywords::SelfValue.name();\n-        let result = self.resolve_path(None, &path, None, parent_scope, false, span, CrateLint::No);\n+        let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((path, None))\n@@ -92,7 +92,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = keywords::Crate.name();\n-        let result = self.resolve_path(None, &path, None, parent_scope, false, span, CrateLint::No);\n+        let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((\n@@ -123,7 +123,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = keywords::Super.name();\n-        let result = self.resolve_path(None, &path, None, parent_scope, false, span, CrateLint::No);\n+        let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((path, None))\n@@ -164,8 +164,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             // Replace the first after root (a placeholder we inserted) with a crate name\n             // and check if that is valid.\n             path[1].ident.name = *name;\n-            let result =\n-                self.resolve_path(None, &path, None, parent_scope, false, span, CrateLint::No);\n+            let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n             debug!(\"make_external_crate_suggestion: name={:?} path={:?} result={:?}\",\n                     name, path, result);\n             if let PathResult::Module(..) = result {"}, {"sha": "279fbafdcd7a73e5e1144651fb7738c0401c6b58", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e6739fe27448e1f85820d80a6a75292b39446d08/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6739fe27448e1f85820d80a6a75292b39446d08/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e6739fe27448e1f85820d80a6a75292b39446d08", "patch": "@@ -1661,8 +1661,8 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         let segments = &path.segments;\n         let path = Segment::from_path(&path);\n         // FIXME (Manishearth): Intra doc links won't get warned of epoch changes\n-        let def = match self.resolve_path_without_parent_scope(None, &path, Some(namespace),\n-                                                               true, span, CrateLint::No) {\n+        match self.resolve_path_without_parent_scope(&path, Some(namespace), true, span,\n+                                                     CrateLint::No) {\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n                 module.def().unwrap(),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n@@ -2466,7 +2466,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 let span = trait_ref.path.span;\n                 if let PathResult::Module(ModuleOrUniformRoot::Module(module)) =\n                     self.resolve_path_without_parent_scope(\n-                        None,\n                         &path,\n                         Some(TypeNS),\n                         false,\n@@ -2991,7 +2990,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 } else {\n                     let mod_path = &path[..path.len() - 1];\n                     let mod_prefix = match this.resolve_path_without_parent_scope(\n-                        None, mod_path, Some(TypeNS), false, span, CrateLint::No\n+                        mod_path, Some(TypeNS), false, span, CrateLint::No\n                     ) {\n                         PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n                             module.def(),\n@@ -3480,7 +3479,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         }\n \n         let result = match self.resolve_path_without_parent_scope(\n-            None,\n             &path,\n             Some(ns),\n             true,\n@@ -3527,7 +3525,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n            path[0].ident.name != keywords::DollarCrate.name() {\n             let unqualified_result = {\n                 match self.resolve_path_without_parent_scope(\n-                    None,\n                     &[*path.last().unwrap()],\n                     Some(ns),\n                     false,\n@@ -3551,9 +3548,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n     fn resolve_path_without_parent_scope(\n         &mut self,\n-        base_module: Option<ModuleOrUniformRoot<'a>>,\n         path: &[Segment],\n-        opt_ns: Option<Namespace>, // `None` indicates a module path\n+        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n         record_used: bool,\n         path_span: Span,\n         crate_lint: CrateLint,\n@@ -3562,21 +3558,19 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         // other paths will do okay with parent module alone.\n         assert!(opt_ns != None && opt_ns != Some(MacroNS));\n         let parent_scope = ParentScope { module: self.current_module, ..self.dummy_parent_scope() };\n-        self.resolve_path(base_module, path, opt_ns, &parent_scope,\n-                          record_used, path_span, crate_lint)\n+        self.resolve_path(path, opt_ns, &parent_scope, record_used, path_span, crate_lint)\n     }\n \n     fn resolve_path(\n         &mut self,\n-        base_module: Option<ModuleOrUniformRoot<'a>>,\n         path: &[Segment],\n-        opt_ns: Option<Namespace>, // `None` indicates a module path\n+        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n         parent_scope: &ParentScope<'a>,\n         record_used: bool,\n         path_span: Span,\n         crate_lint: CrateLint,\n     ) -> PathResult<'a> {\n-        let mut module = base_module;\n+        let mut module = None;\n         let mut allow_super = true;\n         let mut second_binding = None;\n         self.current_module = parent_scope.module;\n@@ -3673,10 +3667,11 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n             let binding = if let Some(module) = module {\n                 self.resolve_ident_in_module(module, ident, ns, record_used, path_span)\n-            } else if opt_ns == Some(MacroNS) {\n+            } else if opt_ns.is_none() || opt_ns == Some(MacroNS) {\n                 assert!(ns == TypeNS);\n-                self.early_resolve_ident_in_lexical_scope(ident, ns, None, parent_scope,\n-                                                          record_used, record_used, path_span)\n+                self.early_resolve_ident_in_lexical_scope(ident, ns, None, opt_ns.is_none(),\n+                                                          parent_scope, record_used, record_used,\n+                                                          path_span)\n             } else {\n                 let record_used_id =\n                     if record_used { crate_lint.node_id().or(Some(CRATE_NODE_ID)) } else { None };\n@@ -3763,9 +3758,11 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n         self.lint_if_path_starts_with_module(crate_lint, path, path_span, second_binding);\n \n-        PathResult::Module(module.unwrap_or_else(|| {\n-            span_bug!(path_span, \"resolve_path: empty(?) path {:?} has no module\", path);\n-        }))\n+        PathResult::Module(match module {\n+            Some(module) => module,\n+            None if path.is_empty() => ModuleOrUniformRoot::UniformRoot(keywords::Invalid.name()),\n+            _ => span_bug!(path_span, \"resolve_path: non-empty path `{:?}` has no module\", path),\n+        })\n     }\n \n     fn lint_if_path_starts_with_module(\n@@ -4050,7 +4047,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             // Search in module.\n             let mod_path = &path[..path.len() - 1];\n             if let PathResult::Module(module) = self.resolve_path_without_parent_scope(\n-                None, mod_path, Some(TypeNS), false, span, CrateLint::No\n+                mod_path, Some(TypeNS), false, span, CrateLint::No\n             ) {\n                 if let ModuleOrUniformRoot::Module(module) = module {\n                     add_module_candidates(module, &mut names);"}, {"sha": "4348f91a63e2decd50a116897e04d60a725dc32a", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e6739fe27448e1f85820d80a6a75292b39446d08/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6739fe27448e1f85820d80a6a75292b39446d08/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=e6739fe27448e1f85820d80a6a75292b39446d08", "patch": "@@ -477,7 +477,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n \n         if path.len() > 1 {\n-            let def = match self.resolve_path(None, &path, Some(MacroNS), parent_scope,\n+            let def = match self.resolve_path(&path, Some(MacroNS), parent_scope,\n                                               false, path_span, CrateLint::No) {\n                 PathResult::NonModule(path_res) => match path_res.base_def() {\n                     Def::Err => Err(Determinacy::Determined),\n@@ -506,7 +506,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             def\n         } else {\n             let binding = self.early_resolve_ident_in_lexical_scope(\n-                path[0].ident, MacroNS, Some(kind), parent_scope, false, force, path_span\n+                path[0].ident, MacroNS, Some(kind), false, parent_scope, false, force, path_span\n             );\n             match binding {\n                 Ok(..) => {}\n@@ -525,12 +525,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n     // This is a variation of `fn resolve_ident_in_lexical_scope` that can be run during\n     // expansion and import resolution (perhaps they can be merged in the future).\n     // The function is used for resolving initial segments of macro paths (e.g. `foo` in\n-    // `foo::bar!(); or `foo!();`) and can be used for \"uniform path\" imports in the future.\n+    // `foo::bar!(); or `foo!();`) and also for import paths on 2018 edition.\n     crate fn early_resolve_ident_in_lexical_scope(\n         &mut self,\n         mut ident: Ident,\n         ns: Namespace,\n-        kind: Option<MacroKind>,\n+        macro_kind: Option<MacroKind>,\n+        is_import: bool,\n         parent_scope: &ParentScope<'a>,\n         record_used: bool,\n         force: bool,\n@@ -604,6 +605,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n \n         assert!(force || !record_used); // `record_used` implies `force`\n+        assert!(macro_kind.is_none() || !is_import); // `is_import` implies no macro kind\n         ident = ident.modern();\n \n         // This is *the* result, resolution from the scope closest to the resolved identifier.\n@@ -792,7 +794,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n             match result {\n                 Ok((binding, flags, ambig_flags)) => {\n-                    if sub_namespace_mismatch(kind, binding.macro_kind()) {\n+                    if sub_namespace_mismatch(macro_kind, binding.macro_kind()) {\n                         continue_search!();\n                     }\n \n@@ -804,7 +806,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                             = innermost_result {\n                         // Found another solution, if the first one was \"weak\", report an error.\n                         if binding.def() != innermost_binding.def() &&\n-                           (innermost_binding.is_glob_import() ||\n+                           (is_import ||\n+                            innermost_binding.is_glob_import() ||\n                             innermost_binding.may_appear_after(parent_scope.expansion, binding) ||\n                             innermost_flags.intersects(ambig_flags) ||\n                             flags.intersects(innermost_ambig_flags) ||\n@@ -838,7 +841,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n \n         let determinacy = Determinacy::determined(force);\n-        if determinacy == Determinacy::Determined && kind == Some(MacroKind::Attr) {\n+        if determinacy == Determinacy::Determined && macro_kind == Some(MacroKind::Attr) {\n             // For single-segment attributes interpret determinate \"no resolution\" as a custom\n             // attribute. (Lexical resolution implies the first segment and attr kind should imply\n             // the last segment, so we are certainly working with a single-segment attribute here.)\n@@ -860,7 +863,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         for (mut path, parent_scope, path_span) in macro_resolutions {\n             // FIXME: Path resolution will ICE if segment IDs present.\n             for seg in &mut path { seg.id = None; }\n-            match self.resolve_path(None, &path, Some(MacroNS), &parent_scope,\n+            match self.resolve_path(&path, Some(MacroNS), &parent_scope,\n                                     true, path_span, CrateLint::No) {\n                 PathResult::NonModule(_) => {},\n                 PathResult::Failed(span, msg, _) => {\n@@ -874,7 +877,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             mem::replace(&mut *module.legacy_macro_resolutions.borrow_mut(), Vec::new());\n         for (ident, kind, parent_scope, initial_binding) in legacy_macro_resolutions {\n             let binding = self.early_resolve_ident_in_lexical_scope(\n-                ident, MacroNS, Some(kind), &parent_scope, true, true, ident.span\n+                ident, MacroNS, Some(kind), false, &parent_scope, true, true, ident.span\n             );\n             match binding {\n                 Ok(binding) => {\n@@ -915,7 +918,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         let builtin_attrs = mem::replace(&mut *module.builtin_attrs.borrow_mut(), Vec::new());\n         for (ident, parent_scope) in builtin_attrs {\n             let binding = self.early_resolve_ident_in_lexical_scope(\n-                ident, MacroNS, Some(MacroKind::Attr), &parent_scope, true, true, ident.span\n+                ident, MacroNS, Some(MacroKind::Attr), false, &parent_scope, true, true, ident.span\n             );\n             if let Ok(binding) = binding {\n                 if binding.def_ignoring_ambiguity() !="}, {"sha": "60d6bb7bdc912e3f06606122657db8702f86d3d1", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6739fe27448e1f85820d80a6a75292b39446d08/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6739fe27448e1f85820d80a6a75292b39446d08/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=e6739fe27448e1f85820d80a6a75292b39446d08", "patch": "@@ -152,10 +152,6 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                 let can_be_relative = !ident.is_path_segment_keyword() &&\n                     root == keywords::Invalid.name();\n                 if can_be_relative {\n-                    // Relative paths should only get here if the feature-gate is on.\n-                    assert!(self.session.rust_2018() &&\n-                            self.session.features_untracked().uniform_paths);\n-\n                     // Try first to resolve relatively.\n                     let mut ctxt = ident.span.ctxt().modern();\n                     let self_module = self.resolve_self(&mut ctxt, self.current_module);\n@@ -750,7 +746,6 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             // while resolving its module path.\n             directive.vis.set(ty::Visibility::Invisible);\n             let result = self.resolve_path(\n-                Some(ModuleOrUniformRoot::UniformRoot(keywords::Invalid.name())),\n                 &directive.module_path[..],\n                 None,\n                 &directive.parent_scope,\n@@ -829,7 +824,6 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         let ImportDirective { ref module_path, span, .. } = *directive;\n \n         let module_result = self.resolve_path(\n-            Some(ModuleOrUniformRoot::UniformRoot(keywords::Invalid.name())),\n             &module_path,\n             None,\n             &directive.parent_scope,"}]}