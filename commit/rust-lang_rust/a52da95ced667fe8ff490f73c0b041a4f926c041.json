{"sha": "a52da95ced667fe8ff490f73c0b041a4f926c041", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1MmRhOTVjZWQ2NjdmZThmZjQ5MGY3M2MwYjA0MWE0ZjkyNmMwNDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-20T13:31:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-20T13:31:10Z"}, "message": "Auto merge of #39062 - martinhath:placement-in-binaryheap, r=nagisa\n\nImplement placement-in protocol for `BinaryHeap`\n\nRelated to #30172, and loosley based on #38551.\n\nAt the moment, this PR is in a pretty rough state, but I wanted to get some feedback to see if I'm going in the right direction.\n\nI hope the Mentor label of #30172 is still applicable, even though it's a year old \ud83d\ude04", "tree": {"sha": "47ddc462587966f85127bc05492fcaff9fc07a49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47ddc462587966f85127bc05492fcaff9fc07a49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a52da95ced667fe8ff490f73c0b041a4f926c041", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a52da95ced667fe8ff490f73c0b041a4f926c041", "html_url": "https://github.com/rust-lang/rust/commit/a52da95ced667fe8ff490f73c0b041a4f926c041", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a52da95ced667fe8ff490f73c0b041a4f926c041/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7ca2b9e143248c8fc33353636c0051f91d7f77f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7ca2b9e143248c8fc33353636c0051f91d7f77f", "html_url": "https://github.com/rust-lang/rust/commit/b7ca2b9e143248c8fc33353636c0051f91d7f77f"}, {"sha": "90fbe155f2104c9cbbec5ff1e79ee513e112fa9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/90fbe155f2104c9cbbec5ff1e79ee513e112fa9c", "html_url": "https://github.com/rust-lang/rust/commit/90fbe155f2104c9cbbec5ff1e79ee513e112fa9c"}], "stats": {"total": 79, "additions": 77, "deletions": 2}, "files": [{"sha": "b7c2a708baf492f91dfdc0976ac8d7dced7dbbbe", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a52da95ced667fe8ff490f73c0b041a4f926c041/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a52da95ced667fe8ff490f73c0b041a4f926c041/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=a52da95ced667fe8ff490f73c0b041a4f926c041", "patch": "@@ -151,7 +151,7 @@\n #![allow(missing_docs)]\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use core::ops::{Deref, DerefMut};\n+use core::ops::{Deref, DerefMut, Place, Placer, InPlace};\n use core::iter::{FromIterator, FusedIterator};\n use core::mem::{swap, size_of};\n use core::ptr;\n@@ -673,7 +673,7 @@ impl<T: Ord> BinaryHeap<T> {\n     // the hole is filled back at the end of its scope, even on panic.\n     // Using a hole reduces the constant factor compared to using swaps,\n     // which involves twice as many moves.\n-    fn sift_up(&mut self, start: usize, pos: usize) {\n+    fn sift_up(&mut self, start: usize, pos: usize) -> usize {\n         unsafe {\n             // Take out the value at `pos` and create a hole.\n             let mut hole = Hole::new(&mut self.data, pos);\n@@ -685,6 +685,7 @@ impl<T: Ord> BinaryHeap<T> {\n                 }\n                 hole.move_to(parent);\n             }\n+            hole.pos()\n         }\n     }\n \n@@ -1189,3 +1190,56 @@ impl<'a, T: 'a + Ord + Copy> Extend<&'a T> for BinaryHeap<T> {\n         self.extend(iter.into_iter().cloned());\n     }\n }\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+pub struct BinaryHeapPlace<'a, T: 'a>\n+where T: Clone + Ord {\n+    heap: *mut BinaryHeap<T>,\n+    place: vec::PlaceBack<'a, T>,\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, T: 'a> Placer<T> for &'a mut BinaryHeap<T>\n+where T: Clone + Ord {\n+    type Place = BinaryHeapPlace<'a, T>;\n+\n+    fn make_place(self) -> Self::Place {\n+        let ptr = self as *mut BinaryHeap<T>;\n+        let place = Placer::make_place(self.data.place_back());\n+        BinaryHeapPlace {\n+            heap: ptr,\n+            place: place,\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, T> Place<T> for BinaryHeapPlace<'a, T>\n+where T: Clone + Ord {\n+    fn pointer(&mut self) -> *mut T {\n+        self.place.pointer()\n+    }\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, T> InPlace<T> for BinaryHeapPlace<'a, T>\n+where T: Clone + Ord {\n+    type Owner = &'a T;\n+\n+    unsafe fn finalize(self) -> &'a T {\n+        self.place.finalize();\n+\n+        let heap: &mut BinaryHeap<T> = &mut *self.heap;\n+        let len = heap.len();\n+        let i = heap.sift_up(0, len - 1);\n+        heap.data.get_unchecked(i)\n+    }\n+}"}, {"sha": "d284937a9e676a0a56ce4824c3b8abb2dd62f8b1", "filename": "src/libcollectionstest/binary_heap.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a52da95ced667fe8ff490f73c0b041a4f926c041/src%2Flibcollectionstest%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a52da95ced667fe8ff490f73c0b041a4f926c041/src%2Flibcollectionstest%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbinary_heap.rs?ref=a52da95ced667fe8ff490f73c0b041a4f926c041", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::panic;\n use std::collections::BinaryHeap;\n use std::collections::binary_heap::{Drain, PeekMut};\n \n@@ -310,6 +311,26 @@ fn test_extend_specialization() {\n     assert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);\n }\n \n+#[test]\n+fn test_placement() {\n+    let mut a = BinaryHeap::new();\n+    &mut a <- 2;\n+    &mut a <- 4;\n+    &mut a <- 3;\n+    assert_eq!(a.peek(), Some(&4));\n+    assert_eq!(a.len(), 3);\n+    &mut a <- 1;\n+    assert_eq!(a.into_sorted_vec(), vec![1, 2, 3, 4]);\n+}\n+\n+#[test]\n+fn test_placement_panic() {\n+    let mut heap = BinaryHeap::from(vec![1, 2, 3]);\n+    fn mkpanic() -> usize { panic!() }\n+    let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| { &mut heap <- mkpanic(); }));\n+    assert_eq!(heap.len(), 3);\n+}\n+\n #[allow(dead_code)]\n fn assert_covariance() {\n     fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> {"}]}