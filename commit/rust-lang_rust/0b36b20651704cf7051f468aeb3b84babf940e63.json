{"sha": "0b36b20651704cf7051f468aeb3b84babf940e63", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiMzZiMjA2NTE3MDRjZjcwNTFmNDY4YWViM2I4NGJhYmY5NDBlNjM=", "commit": {"author": {"name": "Yukio Siraichi", "email": "yukio.siraichi@gmail.com", "date": "2018-03-18T13:05:20Z"}, "committer": {"name": "Yukio Siraichi", "email": "yukio.siraichi@gmail.com", "date": "2018-03-18T23:46:29Z"}, "message": "CodeMap functions refactored.\n\n- Using `span_take_while` to implement others.", "tree": {"sha": "ce4377462869d6d1bd305ffff5c7055f8c8bde34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce4377462869d6d1bd305ffff5c7055f8c8bde34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b36b20651704cf7051f468aeb3b84babf940e63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b36b20651704cf7051f468aeb3b84babf940e63", "html_url": "https://github.com/rust-lang/rust/commit/0b36b20651704cf7051f468aeb3b84babf940e63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b36b20651704cf7051f468aeb3b84babf940e63/comments", "author": {"login": "ysiraichi", "id": 3337141, "node_id": "MDQ6VXNlcjMzMzcxNDE=", "avatar_url": "https://avatars.githubusercontent.com/u/3337141?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ysiraichi", "html_url": "https://github.com/ysiraichi", "followers_url": "https://api.github.com/users/ysiraichi/followers", "following_url": "https://api.github.com/users/ysiraichi/following{/other_user}", "gists_url": "https://api.github.com/users/ysiraichi/gists{/gist_id}", "starred_url": "https://api.github.com/users/ysiraichi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ysiraichi/subscriptions", "organizations_url": "https://api.github.com/users/ysiraichi/orgs", "repos_url": "https://api.github.com/users/ysiraichi/repos", "events_url": "https://api.github.com/users/ysiraichi/events{/privacy}", "received_events_url": "https://api.github.com/users/ysiraichi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ysiraichi", "id": 3337141, "node_id": "MDQ6VXNlcjMzMzcxNDE=", "avatar_url": "https://avatars.githubusercontent.com/u/3337141?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ysiraichi", "html_url": "https://github.com/ysiraichi", "followers_url": "https://api.github.com/users/ysiraichi/followers", "following_url": "https://api.github.com/users/ysiraichi/following{/other_user}", "gists_url": "https://api.github.com/users/ysiraichi/gists{/gist_id}", "starred_url": "https://api.github.com/users/ysiraichi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ysiraichi/subscriptions", "organizations_url": "https://api.github.com/users/ysiraichi/orgs", "repos_url": "https://api.github.com/users/ysiraichi/repos", "events_url": "https://api.github.com/users/ysiraichi/events{/privacy}", "received_events_url": "https://api.github.com/users/ysiraichi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74a4928ed49d000dee9827c21f68148ad3aa271e", "url": "https://api.github.com/repos/rust-lang/rust/commits/74a4928ed49d000dee9827c21f68148ad3aa271e", "html_url": "https://github.com/rust-lang/rust/commit/74a4928ed49d000dee9827c21f68148ad3aa271e"}], "stats": {"total": 88, "additions": 38, "deletions": 50}, "files": [{"sha": "73924c4270e669706b2fc027bff54c3fb4a9bce6", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 38, "deletions": 50, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/0b36b20651704cf7051f468aeb3b84babf940e63/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b36b20651704cf7051f468aeb3b84babf940e63/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=0b36b20651704cf7051f468aeb3b84babf940e63", "patch": "@@ -597,21 +597,6 @@ impl CodeMap {\n         self.span_to_source(sp, |src, start_index, _| src[..start_index].to_string())\n     }\n \n-    /// Given a `Span`, try to get a shorter span ending before the first occurrence of `c` `char`\n-    pub fn span_until_char(&self, sp: Span, c: char) -> Span {\n-        match self.span_to_snippet(sp) {\n-            Ok(snippet) => {\n-                let snippet = snippet.split(c).nth(0).unwrap_or(\"\").trim_right();\n-                if !snippet.is_empty() && !snippet.contains('\\n') {\n-                    sp.with_hi(BytePos(sp.lo().0 + snippet.len() as u32))\n-                } else {\n-                    sp\n-                }\n-            }\n-            _ => sp,\n-        }\n-    }\n-\n     /// Extend the given `Span` to just after the previous occurrence of `c`. Return the same span\n     /// if no character could be found or if an error occurred while retrieving the code snippet.\n     pub fn span_extend_to_prev_char(&self, sp: Span, c: char) -> Span {\n@@ -646,55 +631,58 @@ impl CodeMap {\n         sp\n     }\n \n+    /// Given a `Span`, try to get a shorter span ending before the first occurrence of `c` `char`\n+    pub fn span_until_char(&self, sp: Span, c: char) -> Span {\n+        match self.span_to_snippet(sp) {\n+            Ok(snippet) => {\n+                let snippet = snippet.split(c).nth(0).unwrap_or(\"\").trim_right();\n+                if !snippet.is_empty() && !snippet.contains('\\n') {\n+                    sp.with_hi(BytePos(sp.lo().0 + snippet.len() as u32))\n+                } else {\n+                    sp\n+                }\n+            }\n+            _ => sp,\n+        }\n+    }\n+\n+    /// Given a `Span`, try to get a shorter span ending just after the first occurrence of `char`\n+    /// `c`.\n+    pub fn span_through_char(&self, sp: Span, c: char) -> Span {\n+        if let Ok(snippet) = self.span_to_snippet(sp) {\n+            if let Some(offset) = snippet.find(c) {\n+                return sp.with_hi(BytePos(sp.lo().0 + (offset + c.len_utf8()) as u32));\n+            }\n+        }\n+        sp\n+    }\n+\n     /// Given a `Span`, get a new `Span` covering the first token and all its trailing whitespace or\n     /// the original `Span`.\n     ///\n     /// If `sp` points to `\"let mut x\"`, then a span pointing at `\"let \"` will be returned.\n     pub fn span_until_non_whitespace(&self, sp: Span) -> Span {\n-        if let Ok(snippet) = self.span_to_snippet(sp) {\n-            let mut offset = 0;\n-            // get the bytes width of all the non-whitespace characters\n-            for c in snippet.chars().take_while(|c| !c.is_whitespace()) {\n-                offset += c.len_utf8();\n-            }\n-            // get the bytes width of all the whitespace characters after that\n-            for c in snippet[offset..].chars().take_while(|c| c.is_whitespace()) {\n-                offset += c.len_utf8();\n+        let mut whitespace_found = false;\n+\n+        self.span_take_while(sp, |c| {\n+            if !whitespace_found && c.is_whitespace() {\n+                whitespace_found = true;\n             }\n-            if offset > 1 {\n-                return sp.with_hi(BytePos(sp.lo().0 + offset as u32));\n+\n+            if whitespace_found && !c.is_whitespace() {\n+                false\n+            } else {\n+                true\n             }\n-        }\n-        sp\n+        })\n     }\n \n     /// Given a `Span`, get a new `Span` covering the first token without its trailing whitespace or\n     /// the original `Span` in case of error.\n     ///\n     /// If `sp` points to `\"let mut x\"`, then a span pointing at `\"let\"` will be returned.\n     pub fn span_until_whitespace(&self, sp: Span) -> Span {\n-        if let Ok(snippet) = self.span_to_snippet(sp) {\n-            let mut offset = 0;\n-            // Get the bytes width of all the non-whitespace characters\n-            for c in snippet.chars().take_while(|c| !c.is_whitespace()) {\n-                offset += c.len_utf8();\n-            }\n-            if offset > 1 {\n-                return sp.with_hi(BytePos(sp.lo().0 + offset as u32));\n-            }\n-        }\n-        sp\n-    }\n-\n-    /// Given a `Span`, try to get a shorter span ending just after the first occurrence of `char`\n-    /// `c`.\n-    pub fn span_through_char(&self, sp: Span, c: char) -> Span {\n-        if let Ok(snippet) = self.span_to_snippet(sp) {\n-            if let Some(offset) = snippet.find(c) {\n-                return sp.with_hi(BytePos(sp.lo().0 + (offset + c.len_utf8()) as u32));\n-            }\n-        }\n-        sp\n+        self.span_take_while(sp, |c| !c.is_whitespace())\n     }\n \n     /// Given a `Span`, get a shorter one until `predicate` yields false."}]}