{"sha": "159cc8413cf0f228a5e590a1d3a88f84c6e6cc4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1OWNjODQxM2NmMGYyMjhhNWU1OTBhMWQzYTg4Zjg0YzZlNmNjNGE=", "commit": {"author": {"name": "sinkuu", "email": "sinkuu@sinkuu.xyz", "date": "2017-10-05T14:57:31Z"}, "committer": {"name": "sinkuu", "email": "sinkuu@sinkuu.xyz", "date": "2017-10-11T03:10:26Z"}, "message": "Add implicit_hasher lint (#2101)", "tree": {"sha": "1a8ed870e13ce807286a6cc664862bd1b79563bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a8ed870e13ce807286a6cc664862bd1b79563bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/159cc8413cf0f228a5e590a1d3a88f84c6e6cc4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/159cc8413cf0f228a5e590a1d3a88f84c6e6cc4a", "html_url": "https://github.com/rust-lang/rust/commit/159cc8413cf0f228a5e590a1d3a88f84c6e6cc4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/159cc8413cf0f228a5e590a1d3a88f84c6e6cc4a/comments", "author": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b491d5bb3f3e0a95720504daac141a979cf2512", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b491d5bb3f3e0a95720504daac141a979cf2512", "html_url": "https://github.com/rust-lang/rust/commit/2b491d5bb3f3e0a95720504daac141a979cf2512"}], "stats": {"total": 578, "additions": 563, "deletions": 15}, "files": [{"sha": "d8f99ae6cb387b1d5ea5bd81c881a12bb6ce6b60", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/159cc8413cf0f228a5e590a1d3a88f84c6e6cc4a/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159cc8413cf0f228a5e590a1d3a88f84c6e6cc4a/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=159cc8413cf0f228a5e590a1d3a88f84c6e6cc4a", "patch": "@@ -333,6 +333,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box infinite_iter::Pass);\n     reg.register_late_lint_pass(box invalid_ref::InvalidRef);\n     reg.register_late_lint_pass(box identity_conversion::IdentityConversion::default());\n+    reg.register_late_lint_pass(box types::ImplicitHasher);\n \n     reg.register_lint_group(\"clippy_restrictions\", vec![\n         arithmetic::FLOAT_ARITHMETIC,\n@@ -555,6 +556,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         types::BOX_VEC,\n         types::CAST_LOSSLESS,\n         types::CHAR_LIT_AS_U8,\n+        types::IMPLICIT_HASHER,\n         types::LET_UNIT_VALUE,\n         types::LINKEDLIST,\n         types::TYPE_COMPLEXITY,"}, {"sha": "006833ba9349e867d4e98ae309745bd0dfa53831", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 339, "deletions": 15, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/159cc8413cf0f228a5e590a1d3a88f84c6e6cc4a/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159cc8413cf0f228a5e590a1d3a88f84c6e6cc4a/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=159cc8413cf0f228a5e590a1d3a88f84c6e6cc4a", "patch": "@@ -1,16 +1,19 @@\n use reexport::*;\n use rustc::hir;\n use rustc::hir::*;\n-use rustc::hir::intravisit::{walk_ty, FnKind, NestedVisitorMap, Visitor};\n+use rustc::hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n use rustc::lint::*;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n use std::cmp::Ordering;\n+use std::collections::BTreeMap;\n+use std::borrow::Cow;\n use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::attr::IntType;\n use syntax::codemap::Span;\n use utils::{comparisons, higher, in_external_macro, in_macro, last_path_segment, match_def_path, match_path,\n-            opt_def_id, snippet, snippet_opt, span_help_and_lint, span_lint, span_lint_and_sugg, type_size};\n+            opt_def_id, same_tys, snippet, snippet_opt, span_help_and_lint, span_lint, span_lint_and_sugg,\n+            span_lint_and_then, type_size};\n use utils::paths;\n \n /// Handles all the linting of funky types\n@@ -182,21 +185,19 @@ fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n             match *qpath {\n                 QPath::Resolved(Some(ref ty), ref p) => {\n                     check_ty(cx, ty, is_local);\n-                    for ty in p.segments\n-                        .iter()\n-                        .flat_map(|seg| seg.parameters.as_ref()\n-                                           .map_or_else(|| [].iter(),\n-                                                        |params| params.types.iter()))\n-                    {\n+                    for ty in p.segments.iter().flat_map(|seg| {\n+                        seg.parameters\n+                            .as_ref()\n+                            .map_or_else(|| [].iter(), |params| params.types.iter())\n+                    }) {\n                         check_ty(cx, ty, is_local);\n                     }\n                 },\n-                QPath::Resolved(None, ref p) => for ty in p.segments\n-                    .iter()\n-                    .flat_map(|seg| seg.parameters.as_ref()\n-                                       .map_or_else(|| [].iter(),\n-                                                    |params| params.types.iter()))\n-                {\n+                QPath::Resolved(None, ref p) => for ty in p.segments.iter().flat_map(|seg| {\n+                    seg.parameters\n+                        .as_ref()\n+                        .map_or_else(|| [].iter(), |params| params.types.iter())\n+                }) {\n                     check_ty(cx, ty, is_local);\n                 },\n                 QPath::TypeRelative(ref ty, ref seg) => {\n@@ -605,7 +606,7 @@ fn span_lossless_lint(cx: &LateContext, expr: &Expr, op: &Expr, cast_from: Ty, c\n     let opt = snippet_opt(cx, op.span);\n     let sugg = if let Some(ref snip) = opt {\n         if should_strip_parens(op, snip) {\n-            &snip[1..snip.len()-1]\n+            &snip[1..snip.len() - 1]\n         } else {\n             snip.as_str()\n         }\n@@ -1449,3 +1450,326 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidUpcastComparisons {\n         }\n     }\n }\n+\n+/// **What it does:** Checks for `impl` or `fn` missing generalization over\n+/// different hashers and implicitly defaulting to the default hashing\n+/// algorithm (SipHash). This lint ignores private free-functions.\n+///\n+/// **Why is this bad?** `HashMap` or `HashSet` with custom hashers cannot be\n+/// used with them.\n+///\n+/// **Known problems:** Suggestions for replacing constructors are not always\n+/// accurate.\n+///\n+/// **Example:**\n+/// ```rust\n+/// impl<K: Hash + Eq, V> Serialize for HashMap<K, V> { ... }\n+///\n+/// pub foo(map: &mut HashMap<i32, i32>) { .. }\n+/// ```\n+declare_lint! {\n+    pub IMPLICIT_HASHER,\n+    Warn,\n+    \"missing generalization over different hashers\"\n+}\n+\n+pub struct ImplicitHasher;\n+\n+impl LintPass for ImplicitHasher {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(IMPLICIT_HASHER)\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitHasher {\n+    #[allow(cast_possible_truncation)]\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n+        if let ItemImpl(_, _, _, ref generics, _, ref ty, ref items) = item.node {\n+            let mut vis = ImplicitHasherTypeVisitor::new(cx);\n+            vis.visit_ty(ty);\n+\n+            for target in vis.found {\n+                let generics_snip = snippet(cx, generics.span, \"\");\n+                let generics_snip_trimmed = if generics_snip.len() == 0 {\n+                    \"\"\n+                } else {\n+                    // trim `<` `>`\n+                    &generics_snip[1..generics_snip.len() - 1]\n+                };\n+                let generics_span = generics.span.substitute_dummy({\n+                    let pos = snippet_opt(cx, item.span.until(target.span()))\n+                        .and_then(|snip| {\n+                            Some(item.span.lo() + ::syntax_pos::BytePos(snip.find(\"impl\")? as u32 + 4))\n+                        })\n+                        .expect(\"failed to create span for type arguments\");\n+                    Span::new(pos, pos, item.span.data().ctxt)\n+                });\n+\n+                let mut vis = ImplicitHasherConstructorVisitor::new(cx, target.clone());\n+                for item in items.iter().map(|item| cx.tcx.hir.impl_item(item.id)) {\n+                    vis.visit_impl_item(item);\n+                }\n+\n+                span_lint_and_then(\n+                    cx,\n+                    IMPLICIT_HASHER,\n+                    target.span(),\n+                    &format!(\"impl for `{}` should be generarized over different hashers\", target.type_name()),\n+                    move |db| {\n+                        db.span_suggestion(\n+                            generics_span,\n+                            \"consider adding a type parameter\",\n+                            format!(\n+                                \"<{}{}S: ::std::hash::BuildHasher{}>\",\n+                                generics_snip_trimmed,\n+                                if generics_snip_trimmed.is_empty() {\n+                                    \"\"\n+                                } else {\n+                                    \", \"\n+                                },\n+                                if vis.suggestions.is_empty() {\n+                                    \"\"\n+                                } else {\n+                                    // request users to add `Default` bound so that generic constructors can be used\n+                                    \" + Default\"\n+                                },\n+                            ),\n+                        );\n+\n+                        db.span_suggestion(\n+                            target.span(),\n+                            \"...and change the type to\",\n+                            format!(\"{}<{}, S>\", target.type_name(), target.type_arguments(),),\n+                        );\n+\n+                        for (span, sugg) in vis.suggestions {\n+                            db.span_suggestion(span, \"...and use generic constructor here\", sugg);\n+                        }\n+                    },\n+                );\n+            }\n+        }\n+\n+        if let ItemFn(ref decl, .., ref generics, body) = item.node {\n+            if item.vis != Public {\n+                return;\n+            }\n+\n+            for ty in &decl.inputs {\n+                let mut vis = ImplicitHasherTypeVisitor::new(cx);\n+                vis.visit_ty(ty);\n+\n+                for target in vis.found {\n+                    let generics_snip = snippet(cx, generics.span, \"\");\n+                    let generics_snip_trimmed = if generics_snip.len() == 0 {\n+                        \"\"\n+                    } else {\n+                        // trim `<` `>`\n+                        &generics_snip[1..generics_snip.len() - 1]\n+                    };\n+                    let generics_span = generics.span.substitute_dummy({\n+                        let pos = snippet_opt(cx, item.span.until(ty.span))\n+                            .and_then(|snip| {\n+                                let i = snip.find(\"fn\")?;\n+                                Some(item.span.lo() + ::syntax_pos::BytePos(i as u32 + (&snip[i..]).find('(')? as u32))\n+                            })\n+                            .expect(\"failed to create span for type parameters\");\n+                        Span::new(pos, pos, item.span.data().ctxt)\n+                    });\n+\n+                    let mut ctr_vis = ImplicitHasherConstructorVisitor::new(cx, target.clone());\n+                    ctr_vis.visit_body(cx.tcx.hir.body(body));\n+                    assert!(ctr_vis.suggestions.is_empty());\n+\n+                    span_lint_and_then(\n+                        cx,\n+                        IMPLICIT_HASHER,\n+                        target.span(),\n+                        &format!(\n+                            \"parameter of type `{}` should be generarized over different hashers\",\n+                            target.type_name()\n+                        ),\n+                        move |db| {\n+                            db.span_suggestion(\n+                                generics_span,\n+                                \"consider adding a type parameter\",\n+                                format!(\n+                                    \"<{}{}S: ::std::hash::BuildHasher>\",\n+                                    generics_snip_trimmed,\n+                                    if generics_snip_trimmed.is_empty() {\n+                                        \"\"\n+                                    } else {\n+                                        \", \"\n+                                    },\n+                                ),\n+                            );\n+\n+                            db.span_suggestion(\n+                                target.span(),\n+                                \"...and change the type to\",\n+                                format!(\"{}<{}, S>\", target.type_name(), target.type_arguments(),),\n+                            );\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Clone)]\n+enum ImplicitHasherType<'tcx> {\n+    HashMap(Span, Ty<'tcx>, Cow<'static, str>, Cow<'static, str>),\n+    HashSet(Span, Ty<'tcx>, Cow<'static, str>),\n+}\n+\n+impl<'tcx> ImplicitHasherType<'tcx> {\n+    /// Checks that `ty` is a target type without a BuildHasher.\n+    fn new<'a>(cx: &LateContext<'a, 'tcx>, hir_ty: &hir::Ty) -> Option<Self> {\n+        if let TyPath(QPath::Resolved(None, ref path)) = hir_ty.node {\n+            let params = &path.segments.last().as_ref()?.parameters.as_ref()?.types;\n+            let params_len = params.len();\n+\n+            let ty = cx.tcx.type_of(opt_def_id(path.def)?);\n+\n+            if match_path(path, &paths::HASHMAP) && params_len == 2 {\n+                Some(ImplicitHasherType::HashMap(\n+                    hir_ty.span,\n+                    ty,\n+                    snippet(cx, params[0].span, \"K\"),\n+                    snippet(cx, params[1].span, \"V\"),\n+                ))\n+            } else if match_path(path, &paths::HASHSET) && params_len == 1 {\n+                Some(ImplicitHasherType::HashSet(hir_ty.span, ty, snippet(cx, params[0].span, \"T\")))\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn type_name(&self) -> &'static str {\n+        match *self {\n+            ImplicitHasherType::HashMap(..) => \"HashMap\",\n+            ImplicitHasherType::HashSet(..) => \"HashSet\",\n+        }\n+    }\n+\n+    fn type_arguments(&self) -> String {\n+        match *self {\n+            ImplicitHasherType::HashMap(.., ref k, ref v) => format!(\"{}, {}\", k, v),\n+            ImplicitHasherType::HashSet(.., ref t) => format!(\"{}\", t),\n+        }\n+    }\n+\n+    fn ty(&self) -> Ty<'tcx> {\n+        match *self {\n+            ImplicitHasherType::HashMap(_, ty, ..) | ImplicitHasherType::HashSet(_, ty, ..) => ty,\n+        }\n+    }\n+\n+    fn span(&self) -> Span {\n+        match *self {\n+            ImplicitHasherType::HashMap(span, ..) | ImplicitHasherType::HashSet(span, ..) => span,\n+        }\n+    }\n+}\n+\n+struct ImplicitHasherTypeVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    found: Vec<ImplicitHasherType<'tcx>>,\n+}\n+\n+impl<'a, 'tcx: 'a> ImplicitHasherTypeVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'a, 'tcx>) -> Self {\n+        Self { cx, found: vec![] }\n+    }\n+}\n+\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for ImplicitHasherTypeVisitor<'a, 'tcx> {\n+    fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n+        if let Some(target) = ImplicitHasherType::new(self.cx, t) {\n+            self.found.push(target);\n+        }\n+\n+        walk_ty(self, t);\n+    }\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// Looks for default-hasher-dependent constructors like `HashMap::new`.\n+struct ImplicitHasherConstructorVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    body: Option<BodyId>,\n+    target: ImplicitHasherType<'tcx>,\n+    suggestions: BTreeMap<Span, String>,\n+}\n+\n+impl<'a, 'tcx: 'a> ImplicitHasherConstructorVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'a, 'tcx>, target: ImplicitHasherType<'tcx>) -> Self {\n+        Self {\n+            cx,\n+            body: None,\n+            target,\n+            suggestions: BTreeMap::new(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'tcx> {\n+    fn visit_body(&mut self, body: &'tcx Body) {\n+        self.body = Some(body.id());\n+        walk_body(self, body);\n+    }\n+\n+    fn visit_expr(&mut self, e: &'tcx Expr) {\n+        if_let_chain!{[\n+            let Some(body) = self.body,\n+            let ExprCall(ref fun, ref args) = e.node,\n+            let ExprPath(QPath::TypeRelative(ref ty, ref method)) = fun.node,\n+            let TyPath(QPath::Resolved(None, ref ty_path)) = ty.node,\n+        ], {\n+            if same_tys(self.cx, self.cx.tcx.body_tables(body).expr_ty(e), self.target.ty()) {\n+                return;\n+            }\n+\n+            if match_path(ty_path, &paths::HASHMAP) {\n+                if method.name == \"new\" {\n+                    self.suggestions\n+                        .insert(e.span, \"HashMap::default()\".to_string());\n+                } else if method.name == \"with_capacity\" {\n+                    self.suggestions.insert(\n+                        e.span,\n+                        format!(\n+                            \"HashMap::with_capacity_and_hasher({}, Default::default())\",\n+                            snippet(self.cx, args[0].span, \"capacity\"),\n+                        ),\n+                    );\n+                }\n+            } else if match_path(ty_path, &paths::HASHSET) {\n+                if method.name == \"new\" {\n+                    self.suggestions\n+                        .insert(e.span, \"HashSet::default()\".to_string());\n+                } else if method.name == \"with_capacity\" {\n+                    self.suggestions.insert(\n+                        e.span,\n+                        format!(\n+                            \"HashSet::with_capacity_and_hasher({}, Default::default())\",\n+                            snippet(self.cx, args[0].span, \"capacity\"),\n+                        ),\n+                    );\n+                }\n+            }\n+        }}\n+\n+        walk_expr(self, e);\n+    }\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.cx.tcx.hir)\n+    }\n+}"}, {"sha": "7e1eef9b11cf929e2f10fd47c92dd6c05b9e43da", "filename": "tests/ui/implicit_hasher.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/159cc8413cf0f228a5e590a1d3a88f84c6e6cc4a/tests%2Fui%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159cc8413cf0f228a5e590a1d3a88f84c6e6cc4a/tests%2Fui%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_hasher.rs?ref=159cc8413cf0f228a5e590a1d3a88f84c6e6cc4a", "patch": "@@ -0,0 +1,68 @@\n+#![allow(unused)]\n+//#![feature(plugin)]#![plugin(clippy)]\n+use std::collections::{HashMap, HashSet};\n+use std::cmp::Eq;\n+use std::hash::{Hash, BuildHasher};\n+\n+trait Foo<T>: Sized {\n+    fn make() -> (Self, Self);\n+}\n+\n+impl<K: Hash + Eq, V> Foo<i8> for HashMap<K, V> {\n+    fn make() -> (Self, Self) {\n+        // OK, don't suggest to modify these\n+        let _: HashMap<i32, i32> = HashMap::new();\n+        let _: HashSet<i32> = HashSet::new();\n+\n+        (HashMap::new(), HashMap::with_capacity(10))\n+    }\n+}\n+impl<K: Hash + Eq, V> Foo<i8> for (HashMap<K, V>,) {\n+    fn make() -> (Self, Self) {\n+        ((HashMap::new(),), (HashMap::with_capacity(10),))\n+    }\n+}\n+impl Foo<i16> for HashMap<String, String> {\n+    fn make() -> (Self, Self) {\n+        (HashMap::new(), HashMap::with_capacity(10))\n+    }\n+}\n+\n+impl<K: Hash + Eq, V, S: BuildHasher + Default> Foo<i32> for HashMap<K, V, S> {\n+    fn make() -> (Self, Self) {\n+        (HashMap::default(), HashMap::with_capacity_and_hasher(10, Default::default()))\n+    }\n+}\n+impl<S: BuildHasher + Default> Foo<i64> for HashMap<String, String, S> {\n+    fn make() -> (Self, Self) {\n+        (HashMap::default(), HashMap::with_capacity_and_hasher(10, Default::default()))\n+    }\n+}\n+\n+\n+impl<T: Hash + Eq> Foo<i8> for HashSet<T> {\n+    fn make() -> (Self, Self) {\n+        (HashSet::new(), HashSet::with_capacity(10))\n+    }\n+}\n+impl Foo<i16> for HashSet<String> {\n+    fn make() -> (Self, Self) {\n+        (HashSet::new(), HashSet::with_capacity(10))\n+    }\n+}\n+\n+impl<T: Hash + Eq, S: BuildHasher + Default> Foo<i32> for HashSet<T, S> {\n+    fn make() -> (Self, Self) {\n+        (HashSet::default(), HashSet::with_capacity_and_hasher(10, Default::default()))\n+    }\n+}\n+impl<S: BuildHasher + Default> Foo<i64> for HashSet<String, S> {\n+    fn make() -> (Self, Self) {\n+        (HashSet::default(), HashSet::with_capacity_and_hasher(10, Default::default()))\n+    }\n+}\n+\n+pub fn foo(_map: &mut HashMap<i32, i32>, _set: &mut HashSet<i32>) {\n+}\n+\n+fn main() {}"}, {"sha": "086362185cf94a5871e27487c11a292e93a90aef", "filename": "tests/ui/implicit_hasher.stderr", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/159cc8413cf0f228a5e590a1d3a88f84c6e6cc4a/tests%2Fui%2Fimplicit_hasher.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/159cc8413cf0f228a5e590a1d3a88f84c6e6cc4a/tests%2Fui%2Fimplicit_hasher.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_hasher.stderr?ref=159cc8413cf0f228a5e590a1d3a88f84c6e6cc4a", "patch": "@@ -0,0 +1,154 @@\n+error: impl for `HashMap` should be generarized over different hashers\n+  --> $DIR/implicit_hasher.rs:11:35\n+   |\n+11 | impl<K: Hash + Eq, V> Foo<i8> for HashMap<K, V> {\n+   |                                   ^^^^^^^^^^^^^\n+   |\n+   = note: `-D implicit-hasher` implied by `-D warnings`\n+help: consider adding a type parameter\n+   |\n+11 | impl<K: Hash + Eq, V, S: ::std::hash::BuildHasher + Default> Foo<i8> for HashMap<K, V> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: ...and change the type to\n+   |\n+11 | impl<K: Hash + Eq, V> Foo<i8> for HashMap<K, V, S> {\n+   |                                   ^^^^^^^^^^^^^^^^\n+help: ...and use generic constructor here\n+   |\n+14 |         let _: HashMap<i32, i32> = HashMap::default();\n+   |                                    ^^^^^^^^^^^^^^^^^^\n+help: ...and use generic constructor here\n+   |\n+15 |         let _: HashSet<i32> = HashSet::default();\n+   |                               ^^^^^^^^^^^^^^^^^^\n+help: ...and use generic constructor here\n+   |\n+17 |         (HashMap::default(), HashMap::with_capacity(10))\n+   |          ^^^^^^^^^^^^^^^^^^\n+help: ...and use generic constructor here\n+   |\n+17 |         (HashMap::new(), HashMap::with_capacity_and_hasher(10, Default::default()))\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: impl for `HashMap` should be generarized over different hashers\n+  --> $DIR/implicit_hasher.rs:20:36\n+   |\n+20 | impl<K: Hash + Eq, V> Foo<i8> for (HashMap<K, V>,) {\n+   |                                    ^^^^^^^^^^^^^\n+   |\n+help: consider adding a type parameter\n+   |\n+20 | impl<K: Hash + Eq, V, S: ::std::hash::BuildHasher + Default> Foo<i8> for (HashMap<K, V>,) {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: ...and change the type to\n+   |\n+20 | impl<K: Hash + Eq, V> Foo<i8> for (HashMap<K, V, S>,) {\n+   |                                    ^^^^^^^^^^^^^^^^\n+help: ...and use generic constructor here\n+   |\n+22 |         ((HashMap::default(),), (HashMap::with_capacity(10),))\n+   |           ^^^^^^^^^^^^^^^^^^\n+help: ...and use generic constructor here\n+   |\n+22 |         ((HashMap::new(),), (HashMap::with_capacity_and_hasher(10, Default::default()),))\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: impl for `HashMap` should be generarized over different hashers\n+  --> $DIR/implicit_hasher.rs:25:19\n+   |\n+25 | impl Foo<i16> for HashMap<String, String> {\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider adding a type parameter\n+   |\n+25 | impl<S: ::std::hash::BuildHasher + Default> Foo<i16> for HashMap<String, String> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: ...and change the type to\n+   |\n+25 | impl Foo<i16> for HashMap<String, String, S> {\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: ...and use generic constructor here\n+   |\n+27 |         (HashMap::default(), HashMap::with_capacity(10))\n+   |          ^^^^^^^^^^^^^^^^^^\n+help: ...and use generic constructor here\n+   |\n+27 |         (HashMap::new(), HashMap::with_capacity_and_hasher(10, Default::default()))\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: impl for `HashSet` should be generarized over different hashers\n+  --> $DIR/implicit_hasher.rs:43:32\n+   |\n+43 | impl<T: Hash + Eq> Foo<i8> for HashSet<T> {\n+   |                                ^^^^^^^^^^\n+   |\n+help: consider adding a type parameter\n+   |\n+43 | impl<T: Hash + Eq, S: ::std::hash::BuildHasher + Default> Foo<i8> for HashSet<T> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: ...and change the type to\n+   |\n+43 | impl<T: Hash + Eq> Foo<i8> for HashSet<T, S> {\n+   |                                ^^^^^^^^^^^^^\n+help: ...and use generic constructor here\n+   |\n+45 |         (HashSet::default(), HashSet::with_capacity(10))\n+   |          ^^^^^^^^^^^^^^^^^^\n+help: ...and use generic constructor here\n+   |\n+45 |         (HashSet::new(), HashSet::with_capacity_and_hasher(10, Default::default()))\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: impl for `HashSet` should be generarized over different hashers\n+  --> $DIR/implicit_hasher.rs:48:19\n+   |\n+48 | impl Foo<i16> for HashSet<String> {\n+   |                   ^^^^^^^^^^^^^^^\n+   |\n+help: consider adding a type parameter\n+   |\n+48 | impl<S: ::std::hash::BuildHasher + Default> Foo<i16> for HashSet<String> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: ...and change the type to\n+   |\n+48 | impl Foo<i16> for HashSet<String, S> {\n+   |                   ^^^^^^^^^^^^^^^^^^\n+help: ...and use generic constructor here\n+   |\n+50 |         (HashSet::default(), HashSet::with_capacity(10))\n+   |          ^^^^^^^^^^^^^^^^^^\n+help: ...and use generic constructor here\n+   |\n+50 |         (HashSet::new(), HashSet::with_capacity_and_hasher(10, Default::default()))\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: parameter of type `HashMap` should be generarized over different hashers\n+  --> $DIR/implicit_hasher.rs:65:23\n+   |\n+65 | pub fn foo(_map: &mut HashMap<i32, i32>, _set: &mut HashSet<i32>) {\n+   |                       ^^^^^^^^^^^^^^^^^\n+   |\n+help: consider adding a type parameter\n+   |\n+65 | pub fn foo<S: ::std::hash::BuildHasher>(_map: &mut HashMap<i32, i32>, _set: &mut HashSet<i32>) {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: ...and change the type to\n+   |\n+65 | pub fn foo(_map: &mut HashMap<i32, i32, S>, _set: &mut HashSet<i32>) {\n+   |                       ^^^^^^^^^^^^^^^^^^^^\n+\n+error: parameter of type `HashSet` should be generarized over different hashers\n+  --> $DIR/implicit_hasher.rs:65:53\n+   |\n+65 | pub fn foo(_map: &mut HashMap<i32, i32>, _set: &mut HashSet<i32>) {\n+   |                                                     ^^^^^^^^^^^^\n+   |\n+help: consider adding a type parameter\n+   |\n+65 | pub fn foo<S: ::std::hash::BuildHasher>(_map: &mut HashMap<i32, i32>, _set: &mut HashSet<i32>) {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: ...and change the type to\n+   |\n+65 | pub fn foo(_map: &mut HashMap<i32, i32>, _set: &mut HashSet<i32, S>) {\n+   |                                                     ^^^^^^^^^^^^^^^\n+"}]}