{"sha": "e7ed997d87a1769bd68a86412ae2a417e4d36b99", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3ZWQ5OTdkODdhMTc2OWJkNjhhODY0MTJhZTJhNDE3ZTRkMzZiOTk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-15T20:21:37Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-15T20:24:46Z"}, "message": "extract `type_relate` into the inference context as `nll_relate`\n\nThe name is not great. Nor is the existence of this code great.  It\nshould be merged with the main \"type relating code\" at some point.", "tree": {"sha": "6f477c890f185ea5d8ff7b4fbc4af96391274564", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f477c890f185ea5d8ff7b4fbc4af96391274564"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7ed997d87a1769bd68a86412ae2a417e4d36b99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7ed997d87a1769bd68a86412ae2a417e4d36b99", "html_url": "https://github.com/rust-lang/rust/commit/e7ed997d87a1769bd68a86412ae2a417e4d36b99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7ed997d87a1769bd68a86412ae2a417e4d36b99/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6a080e9d7d5d50642b2dee07c81ec30fcef3e74", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6a080e9d7d5d50642b2dee07c81ec30fcef3e74", "html_url": "https://github.com/rust-lang/rust/commit/b6a080e9d7d5d50642b2dee07c81ec30fcef3e74"}], "stats": {"total": 1332, "additions": 681, "deletions": 651}, "files": [{"sha": "9d56cf5aabec4a18599d393c669bf52831b0b9f4", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7ed997d87a1769bd68a86412ae2a417e4d36b99/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7ed997d87a1769bd68a86412ae2a417e4d36b99/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=e7ed997d87a1769bd68a86412ae2a417e4d36b99", "patch": "@@ -62,6 +62,7 @@ mod higher_ranked;\n pub mod lattice;\n mod lexical_region_resolve;\n mod lub;\n+pub mod nll_relate;\n pub mod opaque_types;\n pub mod outlives;\n pub mod region_constraints;\n@@ -1239,7 +1240,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// sidesteps a number of important checks, such as the \"occurs\n     /// check\" that prevents cyclic types, so it is important not to\n     /// use this method during regular type-check.\n-    pub fn force_instantiate_unchecked(&self, var: Ty<'tcx>, value: Ty<'tcx>) {\n+    fn force_instantiate_unchecked(&self, var: Ty<'tcx>, value: Ty<'tcx>) {\n         match (&var.sty, &value.sty) {\n             (&ty::Infer(ty::TyVar(vid)), _) => {\n                 let mut type_variables = self.type_variables.borrow_mut();"}, {"sha": "bd126b179718e5d0300f1028db8d3295218bbd90", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "added", "additions": 675, "deletions": 0, "changes": 675, "blob_url": "https://github.com/rust-lang/rust/blob/e7ed997d87a1769bd68a86412ae2a417e4d36b99/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7ed997d87a1769bd68a86412ae2a417e4d36b99/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=e7ed997d87a1769bd68a86412ae2a417e4d36b99", "patch": "@@ -0,0 +1,675 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This code is kind of an alternate way of doing subtyping,\n+//! supertyping, and type equating, distinct from the `combine.rs`\n+//! code but very similar in its effect and design. Eventually the two\n+//! ought to be merged. This code is intended for use in NLL.\n+//!\n+//! Here are the key differences:\n+//!\n+//! - This code generally assumes that there are no unbound type\n+//!   inferences variables, because at NLL\n+//!   time types are fully inferred up-to regions.\n+//!   - Actually, to support user-given type annotations like\n+//!     `Vec<_>`, we do have some measure of support for type\n+//!     inference variables, but we impose some simplifying\n+//!     assumptions on them that would not be suitable for the infer\n+//!     code more generally. This could be fixed.\n+//! - This code uses \"universes\" to handle higher-ranked regions and\n+//!   not the leak-check. This is \"more correct\" than what rustc does\n+//!   and we are generally migrating in this direction, but NLL had to\n+//!   get there first.\n+\n+use crate::infer::InferCtxt;\n+use crate::ty::fold::{TypeFoldable, TypeVisitor};\n+use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use crate::ty::subst::Kind;\n+use crate::ty::{self, Ty, TyCtxt};\n+use rustc_data_structures::fx::FxHashMap;\n+\n+pub struct TypeRelating<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n+where\n+    D: TypeRelatingDelegate<'tcx>,\n+{\n+    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+\n+    /// Callback to use when we deduce an outlives relationship\n+    delegate: D,\n+\n+    /// How are we relating `a` and `b`?\n+    ///\n+    /// - covariant means `a <: b`\n+    /// - contravariant means `b <: a`\n+    /// - invariant means `a == b\n+    /// - bivariant means that it doesn't matter\n+    ambient_variance: ty::Variance,\n+\n+    /// When we pass through a set of binders (e.g., when looking into\n+    /// a `fn` type), we push a new bound region scope onto here.  This\n+    /// will contain the instantiated region for each region in those\n+    /// binders. When we then encounter a `ReLateBound(d, br)`, we can\n+    /// use the debruijn index `d` to find the right scope, and then\n+    /// bound region name `br` to find the specific instantiation from\n+    /// within that scope. See `replace_bound_region`.\n+    ///\n+    /// This field stores the instantiations for late-bound regions in\n+    /// the `a` type.\n+    a_scopes: Vec<BoundRegionScope<'tcx>>,\n+\n+    /// Same as `a_scopes`, but for the `b` type.\n+    b_scopes: Vec<BoundRegionScope<'tcx>>,\n+}\n+\n+pub trait TypeRelatingDelegate<'tcx> {\n+    /// Push a constraint `sup: sub` -- this constraint must be\n+    /// satisfied for the two types to be related. `sub` and `sup` may\n+    /// be regions from the type or new variables created through the\n+    /// delegate.\n+    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>);\n+\n+    /// Creates a new universe index. Used when instantiating placeholders.\n+    fn create_next_universe(&mut self) -> ty::UniverseIndex;\n+\n+    /// Creates a new region variable representing a higher-ranked\n+    /// region that is instantiated existentially. This creates an\n+    /// inference variable, typically.\n+    ///\n+    /// So e.g. if you have `for<'a> fn(..) <: for<'b> fn(..)`, then\n+    /// we will invoke this method to instantiate `'a` with an\n+    /// inference variable (though `'b` would be instantiated first,\n+    /// as a placeholder).\n+    fn next_existential_region_var(&mut self) -> ty::Region<'tcx>;\n+\n+    /// Creates a new region variable representing a\n+    /// higher-ranked region that is instantiated universally.\n+    /// This creates a new region placeholder, typically.\n+    ///\n+    /// So e.g. if you have `for<'a> fn(..) <: for<'b> fn(..)`, then\n+    /// we will invoke this method to instantiate `'b` with a\n+    /// placeholder region.\n+    fn next_placeholder_region(&mut self, placeholder: ty::Placeholder) -> ty::Region<'tcx>;\n+\n+    /// Creates a new existential region in the given universe. This\n+    /// is used when handling subtyping and type variables -- if we\n+    /// have that `?X <: Foo<'a>`, for example, we would instantiate\n+    /// `?X` with a type like `Foo<'?0>` where `'?0` is a fresh\n+    /// existential variable created by this function. We would then\n+    /// relate `Foo<'?0>` with `Foo<'a>` (and probably add an outlives\n+    /// relation stating that `'?0: 'a`).\n+    fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx>;\n+}\n+\n+#[derive(Clone, Debug)]\n+struct ScopesAndKind<'tcx> {\n+    scopes: Vec<BoundRegionScope<'tcx>>,\n+    kind: Kind<'tcx>,\n+}\n+\n+#[derive(Clone, Debug, Default)]\n+struct BoundRegionScope<'tcx> {\n+    map: FxHashMap<ty::BoundRegion, ty::Region<'tcx>>,\n+}\n+\n+#[derive(Copy, Clone)]\n+struct UniversallyQuantified(bool);\n+\n+impl<'me, 'gcx, 'tcx, D> TypeRelating<'me, 'gcx, 'tcx, D>\n+where\n+    D: TypeRelatingDelegate<'tcx>,\n+{\n+    pub fn new(\n+        infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+        delegate: D,\n+        ambient_variance: ty::Variance,\n+    ) -> Self {\n+        Self {\n+            infcx,\n+            delegate,\n+            ambient_variance,\n+            a_scopes: vec![],\n+            b_scopes: vec![],\n+        }\n+    }\n+\n+    fn ambient_covariance(&self) -> bool {\n+        match self.ambient_variance {\n+            ty::Variance::Covariant | ty::Variance::Invariant => true,\n+            ty::Variance::Contravariant | ty::Variance::Bivariant => false,\n+        }\n+    }\n+\n+    fn ambient_contravariance(&self) -> bool {\n+        match self.ambient_variance {\n+            ty::Variance::Contravariant | ty::Variance::Invariant => true,\n+            ty::Variance::Covariant | ty::Variance::Bivariant => false,\n+        }\n+    }\n+\n+    fn create_scope(\n+        &mut self,\n+        value: &ty::Binder<impl TypeFoldable<'tcx>>,\n+        universally_quantified: UniversallyQuantified,\n+    ) -> BoundRegionScope<'tcx> {\n+        let mut scope = BoundRegionScope::default();\n+\n+        // Create a callback that creates (via the delegate) either an\n+        // existential or placeholder region as needed.\n+        let mut next_region = {\n+            let delegate = &mut self.delegate;\n+            let mut lazy_universe = None;\n+            move |br: ty::BoundRegion| {\n+                if universally_quantified.0 {\n+                    // The first time this closure is called, create a\n+                    // new universe for the placeholders we will make\n+                    // from here out.\n+                    let universe = lazy_universe.unwrap_or_else(|| {\n+                        let universe = delegate.create_next_universe();\n+                        lazy_universe = Some(universe);\n+                        universe\n+                    });\n+\n+                    let placeholder = ty::Placeholder { universe, name: br };\n+                    delegate.next_placeholder_region(placeholder)\n+                } else {\n+                    delegate.next_existential_region_var()\n+                }\n+            }\n+        };\n+\n+        value.skip_binder().visit_with(&mut ScopeInstantiator {\n+            next_region: &mut next_region,\n+            target_index: ty::INNERMOST,\n+            bound_region_scope: &mut scope,\n+        });\n+\n+        scope\n+    }\n+\n+    /// When we encounter binders during the type traversal, we record\n+    /// the value to substitute for each of the things contained in\n+    /// that binder. (This will be either a universal placeholder or\n+    /// an existential inference variable.) Given the debruijn index\n+    /// `debruijn` (and name `br`) of some binder we have now\n+    /// encountered, this routine finds the value that we instantiated\n+    /// the region with; to do so, it indexes backwards into the list\n+    /// of ambient scopes `scopes`.\n+    fn lookup_bound_region(\n+        debruijn: ty::DebruijnIndex,\n+        br: &ty::BoundRegion,\n+        first_free_index: ty::DebruijnIndex,\n+        scopes: &[BoundRegionScope<'tcx>],\n+    ) -> ty::Region<'tcx> {\n+        // The debruijn index is a \"reverse index\" into the\n+        // scopes listing. So when we have INNERMOST (0), we\n+        // want the *last* scope pushed, and so forth.\n+        let debruijn_index = debruijn.index() - first_free_index.index();\n+        let scope = &scopes[scopes.len() - debruijn_index - 1];\n+\n+        // Find this bound region in that scope to map to a\n+        // particular region.\n+        scope.map[br]\n+    }\n+\n+    /// If `r` is a bound region, find the scope in which it is bound\n+    /// (from `scopes`) and return the value that we instantiated it\n+    /// with. Otherwise just return `r`.\n+    fn replace_bound_region(\n+        &self,\n+        r: ty::Region<'tcx>,\n+        first_free_index: ty::DebruijnIndex,\n+        scopes: &[BoundRegionScope<'tcx>],\n+    ) -> ty::Region<'tcx> {\n+        if let ty::ReLateBound(debruijn, br) = r {\n+            Self::lookup_bound_region(*debruijn, br, first_free_index, scopes)\n+        } else {\n+            r\n+        }\n+    }\n+\n+    /// Push a new outlives requirement into our output set of\n+    /// constraints.\n+    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>) {\n+        debug!(\"push_outlives({:?}: {:?})\", sup, sub);\n+\n+        self.delegate.push_outlives(sup, sub);\n+    }\n+\n+    /// When we encounter a canonical variable `var` in the output,\n+    /// equate it with `kind`. If the variable has been previously\n+    /// equated, then equate it again.\n+    fn relate_var(&mut self, var_ty: Ty<'tcx>, value_ty: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        debug!(\"equate_var(var_ty={:?}, value_ty={:?})\", var_ty, value_ty);\n+\n+        let generalized_ty = self.generalize_value(value_ty);\n+        self.infcx\n+            .force_instantiate_unchecked(var_ty, generalized_ty);\n+\n+        // The generalized values we extract from `canonical_var_values` have\n+        // been fully instantiated and hence the set of scopes we have\n+        // doesn't matter -- just to be sure, put an empty vector\n+        // in there.\n+        let old_a_scopes = ::std::mem::replace(&mut self.a_scopes, vec![]);\n+\n+        // Relate the generalized kind to the original one.\n+        let result = self.relate(&generalized_ty, &value_ty);\n+\n+        // Restore the old scopes now.\n+        self.a_scopes = old_a_scopes;\n+\n+        debug!(\"equate_var: complete, result = {:?}\", result);\n+        result\n+    }\n+\n+    fn generalize_value<T: Relate<'tcx>>(&mut self, value: T) -> T {\n+        TypeGeneralizer {\n+            tcx: self.infcx.tcx,\n+            delegate: &mut self.delegate,\n+            first_free_index: ty::INNERMOST,\n+            ambient_variance: self.ambient_variance,\n+\n+            // These always correspond to an `_` or `'_` written by\n+            // user, and those are always in the root universe.\n+            universe: ty::UniverseIndex::ROOT,\n+        }.relate(&value, &value)\n+            .unwrap()\n+    }\n+}\n+\n+impl<D> TypeRelation<'me, 'gcx, 'tcx> for TypeRelating<'me, 'gcx, 'tcx, D>\n+where\n+    D: TypeRelatingDelegate<'tcx>,\n+{\n+    fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn tag(&self) -> &'static str {\n+        \"nll::subtype\"\n+    }\n+\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    }\n+\n+    fn relate_with_variance<T: Relate<'tcx>>(\n+        &mut self,\n+        variance: ty::Variance,\n+        a: &T,\n+        b: &T,\n+    ) -> RelateResult<'tcx, T> {\n+        debug!(\n+            \"relate_with_variance(variance={:?}, a={:?}, b={:?})\",\n+            variance, a, b\n+        );\n+\n+        let old_ambient_variance = self.ambient_variance;\n+        self.ambient_variance = self.ambient_variance.xform(variance);\n+\n+        debug!(\n+            \"relate_with_variance: ambient_variance = {:?}\",\n+            self.ambient_variance\n+        );\n+\n+        let r = self.relate(a, b)?;\n+\n+        self.ambient_variance = old_ambient_variance;\n+\n+        debug!(\"relate_with_variance: r={:?}\", r);\n+\n+        Ok(r)\n+    }\n+\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        let a = self.infcx.shallow_resolve(a);\n+        match a.sty {\n+            ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) => {\n+                self.relate_var(a.into(), b.into())\n+            }\n+\n+            _ => {\n+                debug!(\n+                    \"tys(a={:?}, b={:?}, variance={:?})\",\n+                    a, b, self.ambient_variance\n+                );\n+\n+                relate::super_relate_tys(self, a, b)\n+            }\n+        }\n+    }\n+\n+    fn regions(\n+        &mut self,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        debug!(\n+            \"regions(a={:?}, b={:?}, variance={:?})\",\n+            a, b, self.ambient_variance\n+        );\n+\n+        let v_a = self.replace_bound_region(a, ty::INNERMOST, &self.a_scopes);\n+        let v_b = self.replace_bound_region(b, ty::INNERMOST, &self.b_scopes);\n+\n+        debug!(\"regions: v_a = {:?}\", v_a);\n+        debug!(\"regions: v_b = {:?}\", v_b);\n+\n+        if self.ambient_covariance() {\n+            // Covariance: a <= b. Hence, `b: a`.\n+            self.push_outlives(v_b, v_a);\n+        }\n+\n+        if self.ambient_contravariance() {\n+            // Contravariant: b <= a. Hence, `a: b`.\n+            self.push_outlives(v_a, v_b);\n+        }\n+\n+        Ok(a)\n+    }\n+\n+    fn binders<T>(\n+        &mut self,\n+        a: &ty::Binder<T>,\n+        b: &ty::Binder<T>,\n+    ) -> RelateResult<'tcx, ty::Binder<T>>\n+    where\n+        T: Relate<'tcx>,\n+    {\n+        // We want that\n+        //\n+        // ```\n+        // for<'a> fn(&'a u32) -> &'a u32 <:\n+        //   fn(&'b u32) -> &'b u32\n+        // ```\n+        //\n+        // but not\n+        //\n+        // ```\n+        // fn(&'a u32) -> &'a u32 <:\n+        //   for<'b> fn(&'b u32) -> &'b u32\n+        // ```\n+        //\n+        // We therefore proceed as follows:\n+        //\n+        // - Instantiate binders on `b` universally, yielding a universe U1.\n+        // - Instantiate binders on `a` existentially in U1.\n+\n+        debug!(\n+            \"binders({:?}: {:?}, ambient_variance={:?})\",\n+            a, b, self.ambient_variance\n+        );\n+\n+        if self.ambient_covariance() {\n+            // Covariance, so we want `for<..> A <: for<..> B` --\n+            // therefore we compare any instantiation of A (i.e., A\n+            // instantiated with existentials) against every\n+            // instantiation of B (i.e., B instantiated with\n+            // universals).\n+\n+            let b_scope = self.create_scope(b, UniversallyQuantified(true));\n+            let a_scope = self.create_scope(a, UniversallyQuantified(false));\n+\n+            debug!(\"binders: a_scope = {:?} (existential)\", a_scope);\n+            debug!(\"binders: b_scope = {:?} (universal)\", b_scope);\n+\n+            self.b_scopes.push(b_scope);\n+            self.a_scopes.push(a_scope);\n+\n+            // Reset the ambient variance to covariant. This is needed\n+            // to correctly handle cases like\n+            //\n+            //     for<'a> fn(&'a u32, &'a u3) == for<'b, 'c> fn(&'b u32, &'c u32)\n+            //\n+            // Somewhat surprisingly, these two types are actually\n+            // **equal**, even though the one on the right looks more\n+            // polymorphic. The reason is due to subtyping. To see it,\n+            // consider that each function can call the other:\n+            //\n+            // - The left function can call the right with `'b` and\n+            //   `'c` both equal to `'a`\n+            //\n+            // - The right function can call the left with `'a` set to\n+            //   `{P}`, where P is the point in the CFG where the call\n+            //   itself occurs. Note that `'b` and `'c` must both\n+            //   include P. At the point, the call works because of\n+            //   subtyping (i.e., `&'b u32 <: &{P} u32`).\n+            let variance = ::std::mem::replace(&mut self.ambient_variance, ty::Variance::Covariant);\n+\n+            self.relate(a.skip_binder(), b.skip_binder())?;\n+\n+            self.ambient_variance = variance;\n+\n+            self.b_scopes.pop().unwrap();\n+            self.a_scopes.pop().unwrap();\n+        }\n+\n+        if self.ambient_contravariance() {\n+            // Contravariance, so we want `for<..> A :> for<..> B`\n+            // -- therefore we compare every instantiation of A (i.e.,\n+            // A instantiated with universals) against any\n+            // instantiation of B (i.e., B instantiated with\n+            // existentials). Opposite of above.\n+\n+            let a_scope = self.create_scope(a, UniversallyQuantified(true));\n+            let b_scope = self.create_scope(b, UniversallyQuantified(false));\n+\n+            debug!(\"binders: a_scope = {:?} (universal)\", a_scope);\n+            debug!(\"binders: b_scope = {:?} (existential)\", b_scope);\n+\n+            self.a_scopes.push(a_scope);\n+            self.b_scopes.push(b_scope);\n+\n+            // Reset ambient variance to contravariance. See the\n+            // covariant case above for an explanation.\n+            let variance =\n+                ::std::mem::replace(&mut self.ambient_variance, ty::Variance::Contravariant);\n+\n+            self.relate(a.skip_binder(), b.skip_binder())?;\n+\n+            self.ambient_variance = variance;\n+\n+            self.b_scopes.pop().unwrap();\n+            self.a_scopes.pop().unwrap();\n+        }\n+\n+        Ok(a.clone())\n+    }\n+}\n+\n+/// When we encounter a binder like `for<..> fn(..)`, we actually have\n+/// to walk the `fn` value to find all the values bound by the `for`\n+/// (these are not explicitly present in the ty representation right\n+/// now). This visitor handles that: it descends the type, tracking\n+/// binder depth, and finds late-bound regions targeting the\n+/// `for<..`>.  For each of those, it creates an entry in\n+/// `bound_region_scope`.\n+struct ScopeInstantiator<'me, 'tcx: 'me> {\n+    next_region: &'me mut dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n+    // The debruijn index of the scope we are instantiating.\n+    target_index: ty::DebruijnIndex,\n+    bound_region_scope: &'me mut BoundRegionScope<'tcx>,\n+}\n+\n+impl<'me, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx> {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n+        self.target_index.shift_in(1);\n+        t.super_visit_with(self);\n+        self.target_index.shift_out(1);\n+\n+        false\n+    }\n+\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+        let ScopeInstantiator {\n+            bound_region_scope,\n+            next_region,\n+            ..\n+        } = self;\n+\n+        match r {\n+            ty::ReLateBound(debruijn, br) if *debruijn == self.target_index => {\n+                bound_region_scope\n+                    .map\n+                    .entry(*br)\n+                    .or_insert_with(|| next_region(*br));\n+            }\n+\n+            _ => {}\n+        }\n+\n+        false\n+    }\n+}\n+\n+/// The \"type generalize\" is used when handling inference variables.\n+///\n+/// The basic strategy for handling a constraint like `?A <: B` is to\n+/// apply a \"generalization strategy\" to the type `B` -- this replaces\n+/// all the lifetimes in the type `B` with fresh inference\n+/// variables. (You can read more about the strategy in this [blog\n+/// post].)\n+///\n+/// As an example, if we had `?A <: &'x u32`, we would generalize `&'x\n+/// u32` to `&'0 u32` where `'0` is a fresh variable. This becomes the\n+/// value of `A`. Finally, we relate `&'0 u32 <: &'x u32`, which\n+/// establishes `'0: 'x` as a constraint.\n+///\n+/// As a side-effect of this generalization procedure, we also replace\n+/// all the bound regions that we have traversed with concrete values,\n+/// so that the resulting generalized type is independent from the\n+/// scopes.\n+///\n+/// [blog post]: https://is.gd/0hKvIr\n+struct TypeGeneralizer<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n+where\n+    D: TypeRelatingDelegate<'tcx> + 'me,\n+{\n+    tcx: TyCtxt<'me, 'gcx, 'tcx>,\n+\n+    delegate: &'me mut D,\n+\n+    /// After we generalize this type, we are going to relative it to\n+    /// some other type. What will be the variance at this point?\n+    ambient_variance: ty::Variance,\n+\n+    first_free_index: ty::DebruijnIndex,\n+\n+    universe: ty::UniverseIndex,\n+}\n+\n+impl<D> TypeRelation<'me, 'gcx, 'tcx> for TypeGeneralizer<'me, 'gcx, 'tcx, D>\n+where\n+    D: TypeRelatingDelegate<'tcx>,\n+{\n+    fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn tag(&self) -> &'static str {\n+        \"nll::generalizer\"\n+    }\n+\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    }\n+\n+    fn relate_with_variance<T: Relate<'tcx>>(\n+        &mut self,\n+        variance: ty::Variance,\n+        a: &T,\n+        b: &T,\n+    ) -> RelateResult<'tcx, T> {\n+        debug!(\n+            \"TypeGeneralizer::relate_with_variance(variance={:?}, a={:?}, b={:?})\",\n+            variance, a, b\n+        );\n+\n+        let old_ambient_variance = self.ambient_variance;\n+        self.ambient_variance = self.ambient_variance.xform(variance);\n+\n+        debug!(\n+            \"TypeGeneralizer::relate_with_variance: ambient_variance = {:?}\",\n+            self.ambient_variance\n+        );\n+\n+        let r = self.relate(a, b)?;\n+\n+        self.ambient_variance = old_ambient_variance;\n+\n+        debug!(\"TypeGeneralizer::relate_with_variance: r={:?}\", r);\n+\n+        Ok(r)\n+    }\n+\n+    fn tys(&mut self, a: Ty<'tcx>, _: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        debug!(\"TypeGeneralizer::tys(a={:?})\", a,);\n+\n+        match a.sty {\n+            ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) => {\n+                bug!(\n+                    \"unexpected inference variable encountered in NLL generalization: {:?}\",\n+                    a\n+                );\n+            }\n+\n+            _ => relate::super_relate_tys(self, a, a),\n+        }\n+    }\n+\n+    fn regions(\n+        &mut self,\n+        a: ty::Region<'tcx>,\n+        _: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        debug!(\"TypeGeneralizer::regions(a={:?})\", a,);\n+\n+        if let ty::ReLateBound(debruijn, _) = a {\n+            if *debruijn < self.first_free_index {\n+                return Ok(a);\n+            }\n+        }\n+\n+        // For now, we just always create a fresh region variable to\n+        // replace all the regions in the source type. In the main\n+        // type checker, we special case the case where the ambient\n+        // variance is `Invariant` and try to avoid creating a fresh\n+        // region variable, but since this comes up so much less in\n+        // NLL (only when users use `_` etc) it is much less\n+        // important.\n+        //\n+        // As an aside, since these new variables are created in\n+        // `self.universe` universe, this also serves to enforce the\n+        // universe scoping rules.\n+        //\n+        // FIXME(#54105) -- if the ambient variance is bivariant,\n+        // though, we may however need to check well-formedness or\n+        // risk a problem like #41677 again.\n+\n+        let replacement_region_vid = self.delegate.generalize_existential(self.universe);\n+\n+        Ok(replacement_region_vid)\n+    }\n+\n+    fn binders<T>(\n+        &mut self,\n+        a: &ty::Binder<T>,\n+        _: &ty::Binder<T>,\n+    ) -> RelateResult<'tcx, ty::Binder<T>>\n+    where\n+        T: Relate<'tcx>,\n+    {\n+        debug!(\"TypeGeneralizer::binders(a={:?})\", a,);\n+\n+        self.first_free_index.shift_in(1);\n+        let result = self.relate(a.skip_binder(), a.skip_binder())?;\n+        self.first_free_index.shift_out(1);\n+        Ok(ty::Binder::bind(result))\n+    }\n+}"}, {"sha": "99e47663997653f5c795a4cd8a0641f807eb925d", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 4, "deletions": 650, "changes": 654, "blob_url": "https://github.com/rust-lang/rust/blob/e7ed997d87a1769bd68a86412ae2a417e4d36b99/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7ed997d87a1769bd68a86412ae2a417e4d36b99/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=e7ed997d87a1769bd68a86412ae2a417e4d36b99", "patch": "@@ -11,14 +11,12 @@\n use borrow_check::nll::constraints::OutlivesConstraint;\n use borrow_check::nll::type_check::{BorrowCheckContext, Locations};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n+use rustc::infer::nll_relate::{TypeRelating, TypeRelatingDelegate};\n use rustc::mir::ConstraintCategory;\n use rustc::traits::query::Fallible;\n-use rustc::ty::fold::{TypeFoldable, TypeVisitor};\n-use rustc::ty::relate::{self, Relate, RelateResult, TypeRelation};\n-use rustc::ty::subst::Kind;\n-use rustc::ty::{self, CanonicalTy, Ty, TyCtxt};\n-use rustc_data_structures::fx::FxHashMap;\n-use syntax::source_map::DUMMY_SP;\n+use rustc::ty::relate::TypeRelation;\n+use rustc::ty::{self, CanonicalTy, Ty};\n+use syntax_pos::DUMMY_SP;\n \n /// Adds sufficient constraints to ensure that `a <: b`.\n pub(super) fn sub_types<'tcx>(\n@@ -93,78 +91,6 @@ pub(super) fn relate_type_and_user_type<'tcx>(\n     Ok(b)\n }\n \n-struct TypeRelating<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n-where\n-    D: TypeRelatingDelegate<'tcx>,\n-{\n-    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n-\n-    /// Callback to use when we deduce an outlives relationship\n-    delegate: D,\n-\n-    /// How are we relating `a` and `b`?\n-    ///\n-    /// - covariant means `a <: b`\n-    /// - contravariant means `b <: a`\n-    /// - invariant means `a == b\n-    /// - bivariant means that it doesn't matter\n-    ambient_variance: ty::Variance,\n-\n-    /// When we pass through a set of binders (e.g., when looking into\n-    /// a `fn` type), we push a new bound region scope onto here.  This\n-    /// will contain the instantiated region for each region in those\n-    /// binders. When we then encounter a `ReLateBound(d, br)`, we can\n-    /// use the debruijn index `d` to find the right scope, and then\n-    /// bound region name `br` to find the specific instantiation from\n-    /// within that scope. See `replace_bound_region`.\n-    ///\n-    /// This field stores the instantiations for late-bound regions in\n-    /// the `a` type.\n-    a_scopes: Vec<BoundRegionScope<'tcx>>,\n-\n-    /// Same as `a_scopes`, but for the `b` type.\n-    b_scopes: Vec<BoundRegionScope<'tcx>>,\n-}\n-\n-trait TypeRelatingDelegate<'tcx> {\n-    /// Push a constraint `sup: sub` -- this constraint must be\n-    /// satisfied for the two types to be related. `sub` and `sup` may\n-    /// be regions from the type or new variables created through the\n-    /// delegate.\n-    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>);\n-\n-    /// Creates a new universe index. Used when instantiating placeholders.\n-    fn create_next_universe(&mut self) -> ty::UniverseIndex;\n-\n-    /// Creates a new region variable representing a higher-ranked\n-    /// region that is instantiated existentially. This creates an\n-    /// inference variable, typically.\n-    ///\n-    /// So e.g. if you have `for<'a> fn(..) <: for<'b> fn(..)`, then\n-    /// we will invoke this method to instantiate `'a` with an\n-    /// inference variable (though `'b` would be instantiated first,\n-    /// as a placeholder).\n-    fn next_existential_region_var(&mut self) -> ty::Region<'tcx>;\n-\n-    /// Creates a new region variable representing a\n-    /// higher-ranked region that is instantiated universally.\n-    /// This creates a new region placeholder, typically.\n-    ///\n-    /// So e.g. if you have `for<'a> fn(..) <: for<'b> fn(..)`, then\n-    /// we will invoke this method to instantiate `'b` with a\n-    /// placeholder region.\n-    fn next_placeholder_region(&mut self, placeholder: ty::Placeholder) -> ty::Region<'tcx>;\n-\n-    /// Creates a new existential region in the given universe. This\n-    /// is used when handling subtyping and type variables -- if we\n-    /// have that `?X <: Foo<'a>`, for example, we would instantiate\n-    /// `?X` with a type like `Foo<'?0>` where `'?0` is a fresh\n-    /// existential variable created by this function. We would then\n-    /// relate `Foo<'?0>` with `Foo<'a>` (and probably add an outlives\n-    /// relation stating that `'?0: 'a`).\n-    fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx>;\n-}\n-\n struct NllTypeRelatingDelegate<'me, 'bccx: 'me, 'gcx: 'tcx, 'tcx: 'bccx> {\n     infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n     borrowck_context: Option<&'me mut BorrowCheckContext<'bccx, 'tcx>>,\n@@ -231,575 +157,3 @@ impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, '_, 'tcx> {\n         }\n     }\n }\n-\n-#[derive(Clone, Debug)]\n-struct ScopesAndKind<'tcx> {\n-    scopes: Vec<BoundRegionScope<'tcx>>,\n-    kind: Kind<'tcx>,\n-}\n-\n-#[derive(Clone, Debug, Default)]\n-struct BoundRegionScope<'tcx> {\n-    map: FxHashMap<ty::BoundRegion, ty::Region<'tcx>>,\n-}\n-\n-#[derive(Copy, Clone)]\n-struct UniversallyQuantified(bool);\n-\n-impl<'me, 'gcx, 'tcx, D> TypeRelating<'me, 'gcx, 'tcx, D>\n-where\n-    D: TypeRelatingDelegate<'tcx>,\n-{\n-    fn new(\n-        infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n-        delegate: D,\n-        ambient_variance: ty::Variance,\n-    ) -> Self {\n-        Self {\n-            infcx,\n-            delegate,\n-            ambient_variance,\n-            a_scopes: vec![],\n-            b_scopes: vec![],\n-        }\n-    }\n-\n-    fn ambient_covariance(&self) -> bool {\n-        match self.ambient_variance {\n-            ty::Variance::Covariant | ty::Variance::Invariant => true,\n-            ty::Variance::Contravariant | ty::Variance::Bivariant => false,\n-        }\n-    }\n-\n-    fn ambient_contravariance(&self) -> bool {\n-        match self.ambient_variance {\n-            ty::Variance::Contravariant | ty::Variance::Invariant => true,\n-            ty::Variance::Covariant | ty::Variance::Bivariant => false,\n-        }\n-    }\n-\n-    fn create_scope(\n-        &mut self,\n-        value: &ty::Binder<impl TypeFoldable<'tcx>>,\n-        universally_quantified: UniversallyQuantified,\n-    ) -> BoundRegionScope<'tcx> {\n-        let mut scope = BoundRegionScope::default();\n-\n-        // Create a callback that creates (via the delegate) either an\n-        // existential or placeholder region as needed.\n-        let mut next_region = {\n-            let delegate = &mut self.delegate;\n-            let mut lazy_universe = None;\n-            move |br: ty::BoundRegion| {\n-                if universally_quantified.0 {\n-                    // The first time this closure is called, create a\n-                    // new universe for the placeholders we will make\n-                    // from here out.\n-                    let universe = lazy_universe.unwrap_or_else(|| {\n-                        let universe = delegate.create_next_universe();\n-                        lazy_universe = Some(universe);\n-                        universe\n-                    });\n-\n-                    let placeholder = ty::Placeholder { universe, name: br };\n-                    delegate.next_placeholder_region(placeholder)\n-                } else {\n-                    delegate.next_existential_region_var()\n-                }\n-            }\n-        };\n-\n-        value.skip_binder().visit_with(&mut ScopeInstantiator {\n-            next_region: &mut next_region,\n-            target_index: ty::INNERMOST,\n-            bound_region_scope: &mut scope,\n-        });\n-\n-        scope\n-    }\n-\n-    /// When we encounter binders during the type traversal, we record\n-    /// the value to substitute for each of the things contained in\n-    /// that binder. (This will be either a universal placeholder or\n-    /// an existential inference variable.) Given the debruijn index\n-    /// `debruijn` (and name `br`) of some binder we have now\n-    /// encountered, this routine finds the value that we instantiated\n-    /// the region with; to do so, it indexes backwards into the list\n-    /// of ambient scopes `scopes`.\n-    fn lookup_bound_region(\n-        debruijn: ty::DebruijnIndex,\n-        br: &ty::BoundRegion,\n-        first_free_index: ty::DebruijnIndex,\n-        scopes: &[BoundRegionScope<'tcx>],\n-    ) -> ty::Region<'tcx> {\n-        // The debruijn index is a \"reverse index\" into the\n-        // scopes listing. So when we have INNERMOST (0), we\n-        // want the *last* scope pushed, and so forth.\n-        let debruijn_index = debruijn.index() - first_free_index.index();\n-        let scope = &scopes[scopes.len() - debruijn_index - 1];\n-\n-        // Find this bound region in that scope to map to a\n-        // particular region.\n-        scope.map[br]\n-    }\n-\n-    /// If `r` is a bound region, find the scope in which it is bound\n-    /// (from `scopes`) and return the value that we instantiated it\n-    /// with. Otherwise just return `r`.\n-    fn replace_bound_region(\n-        &self,\n-        r: ty::Region<'tcx>,\n-        first_free_index: ty::DebruijnIndex,\n-        scopes: &[BoundRegionScope<'tcx>],\n-    ) -> ty::Region<'tcx> {\n-        if let ty::ReLateBound(debruijn, br) = r {\n-            Self::lookup_bound_region(*debruijn, br, first_free_index, scopes)\n-        } else {\n-            r\n-        }\n-    }\n-\n-    /// Push a new outlives requirement into our output set of\n-    /// constraints.\n-    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>) {\n-        debug!(\"push_outlives({:?}: {:?})\", sup, sub);\n-\n-        self.delegate.push_outlives(sup, sub);\n-    }\n-\n-    /// When we encounter a canonical variable `var` in the output,\n-    /// equate it with `kind`. If the variable has been previously\n-    /// equated, then equate it again.\n-    fn relate_var(\n-        &mut self,\n-        var_ty: Ty<'tcx>,\n-        value_ty: Ty<'tcx>,\n-    ) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"equate_var(var_ty={:?}, value_ty={:?})\", var_ty, value_ty);\n-\n-        let generalized_ty = self.generalize_value(value_ty);\n-        self.infcx.force_instantiate_unchecked(var_ty, generalized_ty);\n-\n-        // The generalized values we extract from `canonical_var_values` have\n-        // been fully instantiated and hence the set of scopes we have\n-        // doesn't matter -- just to be sure, put an empty vector\n-        // in there.\n-        let old_a_scopes = ::std::mem::replace(&mut self.a_scopes, vec![]);\n-\n-        // Relate the generalized kind to the original one.\n-        let result = self.relate(&generalized_ty, &value_ty);\n-\n-        // Restore the old scopes now.\n-        self.a_scopes = old_a_scopes;\n-\n-        debug!(\"equate_var: complete, result = {:?}\", result);\n-        result\n-    }\n-\n-    fn generalize_value<T: Relate<'tcx>>(&mut self, value: T) -> T {\n-        TypeGeneralizer {\n-            tcx: self.infcx.tcx,\n-            delegate: &mut self.delegate,\n-            first_free_index: ty::INNERMOST,\n-            ambient_variance: self.ambient_variance,\n-\n-            // These always correspond to an `_` or `'_` written by\n-            // user, and those are always in the root universe.\n-            universe: ty::UniverseIndex::ROOT,\n-        }.relate(&value, &value)\n-            .unwrap()\n-    }\n-}\n-\n-impl<D> TypeRelation<'me, 'gcx, 'tcx> for TypeRelating<'me, 'gcx, 'tcx, D>\n-where\n-    D: TypeRelatingDelegate<'tcx>,\n-{\n-    fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n-        self.infcx.tcx\n-    }\n-\n-    fn tag(&self) -> &'static str {\n-        \"nll::subtype\"\n-    }\n-\n-    fn a_is_expected(&self) -> bool {\n-        true\n-    }\n-\n-    fn relate_with_variance<T: Relate<'tcx>>(\n-        &mut self,\n-        variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n-    ) -> RelateResult<'tcx, T> {\n-        debug!(\n-            \"relate_with_variance(variance={:?}, a={:?}, b={:?})\",\n-            variance, a, b\n-        );\n-\n-        let old_ambient_variance = self.ambient_variance;\n-        self.ambient_variance = self.ambient_variance.xform(variance);\n-\n-        debug!(\n-            \"relate_with_variance: ambient_variance = {:?}\",\n-            self.ambient_variance\n-        );\n-\n-        let r = self.relate(a, b)?;\n-\n-        self.ambient_variance = old_ambient_variance;\n-\n-        debug!(\"relate_with_variance: r={:?}\", r);\n-\n-        Ok(r)\n-    }\n-\n-    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        let a = self.infcx.shallow_resolve(a);\n-        match a.sty {\n-            ty::Infer(ty::TyVar(_)) |\n-            ty::Infer(ty::IntVar(_)) |\n-            ty::Infer(ty::FloatVar(_)) => {\n-                self.relate_var(a.into(), b.into())\n-            }\n-\n-            _ => {\n-                debug!(\n-                    \"tys(a={:?}, b={:?}, variance={:?})\",\n-                    a, b, self.ambient_variance\n-                );\n-\n-                relate::super_relate_tys(self, a, b)\n-            }\n-        }\n-    }\n-\n-    fn regions(\n-        &mut self,\n-        a: ty::Region<'tcx>,\n-        b: ty::Region<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        debug!(\n-            \"regions(a={:?}, b={:?}, variance={:?})\",\n-            a, b, self.ambient_variance\n-        );\n-\n-        let v_a = self.replace_bound_region(a, ty::INNERMOST, &self.a_scopes);\n-        let v_b = self.replace_bound_region(b, ty::INNERMOST, &self.b_scopes);\n-\n-        debug!(\"regions: v_a = {:?}\", v_a);\n-        debug!(\"regions: v_b = {:?}\", v_b);\n-\n-        if self.ambient_covariance() {\n-            // Covariance: a <= b. Hence, `b: a`.\n-            self.push_outlives(v_b, v_a);\n-        }\n-\n-        if self.ambient_contravariance() {\n-            // Contravariant: b <= a. Hence, `a: b`.\n-            self.push_outlives(v_a, v_b);\n-        }\n-\n-        Ok(a)\n-    }\n-\n-    fn binders<T>(\n-        &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n-    where\n-        T: Relate<'tcx>,\n-    {\n-        // We want that\n-        //\n-        // ```\n-        // for<'a> fn(&'a u32) -> &'a u32 <:\n-        //   fn(&'b u32) -> &'b u32\n-        // ```\n-        //\n-        // but not\n-        //\n-        // ```\n-        // fn(&'a u32) -> &'a u32 <:\n-        //   for<'b> fn(&'b u32) -> &'b u32\n-        // ```\n-        //\n-        // We therefore proceed as follows:\n-        //\n-        // - Instantiate binders on `b` universally, yielding a universe U1.\n-        // - Instantiate binders on `a` existentially in U1.\n-\n-        debug!(\n-            \"binders({:?}: {:?}, ambient_variance={:?})\",\n-            a, b, self.ambient_variance\n-        );\n-\n-        if self.ambient_covariance() {\n-            // Covariance, so we want `for<..> A <: for<..> B` --\n-            // therefore we compare any instantiation of A (i.e., A\n-            // instantiated with existentials) against every\n-            // instantiation of B (i.e., B instantiated with\n-            // universals).\n-\n-            let b_scope = self.create_scope(b, UniversallyQuantified(true));\n-            let a_scope = self.create_scope(a, UniversallyQuantified(false));\n-\n-            debug!(\"binders: a_scope = {:?} (existential)\", a_scope);\n-            debug!(\"binders: b_scope = {:?} (universal)\", b_scope);\n-\n-            self.b_scopes.push(b_scope);\n-            self.a_scopes.push(a_scope);\n-\n-            // Reset the ambient variance to covariant. This is needed\n-            // to correctly handle cases like\n-            //\n-            //     for<'a> fn(&'a u32, &'a u3) == for<'b, 'c> fn(&'b u32, &'c u32)\n-            //\n-            // Somewhat surprisingly, these two types are actually\n-            // **equal**, even though the one on the right looks more\n-            // polymorphic. The reason is due to subtyping. To see it,\n-            // consider that each function can call the other:\n-            //\n-            // - The left function can call the right with `'b` and\n-            //   `'c` both equal to `'a`\n-            //\n-            // - The right function can call the left with `'a` set to\n-            //   `{P}`, where P is the point in the CFG where the call\n-            //   itself occurs. Note that `'b` and `'c` must both\n-            //   include P. At the point, the call works because of\n-            //   subtyping (i.e., `&'b u32 <: &{P} u32`).\n-            let variance = ::std::mem::replace(&mut self.ambient_variance, ty::Variance::Covariant);\n-\n-            self.relate(a.skip_binder(), b.skip_binder())?;\n-\n-            self.ambient_variance = variance;\n-\n-            self.b_scopes.pop().unwrap();\n-            self.a_scopes.pop().unwrap();\n-        }\n-\n-        if self.ambient_contravariance() {\n-            // Contravariance, so we want `for<..> A :> for<..> B`\n-            // -- therefore we compare every instantiation of A (i.e.,\n-            // A instantiated with universals) against any\n-            // instantiation of B (i.e., B instantiated with\n-            // existentials). Opposite of above.\n-\n-            let a_scope = self.create_scope(a, UniversallyQuantified(true));\n-            let b_scope = self.create_scope(b, UniversallyQuantified(false));\n-\n-            debug!(\"binders: a_scope = {:?} (universal)\", a_scope);\n-            debug!(\"binders: b_scope = {:?} (existential)\", b_scope);\n-\n-            self.a_scopes.push(a_scope);\n-            self.b_scopes.push(b_scope);\n-\n-            // Reset ambient variance to contravariance. See the\n-            // covariant case above for an explanation.\n-            let variance =\n-                ::std::mem::replace(&mut self.ambient_variance, ty::Variance::Contravariant);\n-\n-            self.relate(a.skip_binder(), b.skip_binder())?;\n-\n-            self.ambient_variance = variance;\n-\n-            self.b_scopes.pop().unwrap();\n-            self.a_scopes.pop().unwrap();\n-        }\n-\n-        Ok(a.clone())\n-    }\n-}\n-\n-/// When we encounter a binder like `for<..> fn(..)`, we actually have\n-/// to walk the `fn` value to find all the values bound by the `for`\n-/// (these are not explicitly present in the ty representation right\n-/// now). This visitor handles that: it descends the type, tracking\n-/// binder depth, and finds late-bound regions targeting the\n-/// `for<..`>.  For each of those, it creates an entry in\n-/// `bound_region_scope`.\n-struct ScopeInstantiator<'me, 'tcx: 'me> {\n-    next_region: &'me mut dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n-    // The debruijn index of the scope we are instantiating.\n-    target_index: ty::DebruijnIndex,\n-    bound_region_scope: &'me mut BoundRegionScope<'tcx>,\n-}\n-\n-impl<'me, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx> {\n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n-        self.target_index.shift_in(1);\n-        t.super_visit_with(self);\n-        self.target_index.shift_out(1);\n-\n-        false\n-    }\n-\n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n-        let ScopeInstantiator {\n-            bound_region_scope,\n-            next_region,\n-            ..\n-        } = self;\n-\n-        match r {\n-            ty::ReLateBound(debruijn, br) if *debruijn == self.target_index => {\n-                bound_region_scope\n-                    .map\n-                    .entry(*br)\n-                    .or_insert_with(|| next_region(*br));\n-            }\n-\n-            _ => {}\n-        }\n-\n-        false\n-    }\n-}\n-\n-/// The \"type generalize\" is used when handling inference variables.\n-///\n-/// The basic strategy for handling a constraint like `?A <: B` is to\n-/// apply a \"generalization strategy\" to the type `B` -- this replaces\n-/// all the lifetimes in the type `B` with fresh inference\n-/// variables. (You can read more about the strategy in this [blog\n-/// post].)\n-///\n-/// As an example, if we had `?A <: &'x u32`, we would generalize `&'x\n-/// u32` to `&'0 u32` where `'0` is a fresh variable. This becomes the\n-/// value of `A`. Finally, we relate `&'0 u32 <: &'x u32`, which\n-/// establishes `'0: 'x` as a constraint.\n-///\n-/// As a side-effect of this generalization procedure, we also replace\n-/// all the bound regions that we have traversed with concrete values,\n-/// so that the resulting generalized type is independent from the\n-/// scopes.\n-///\n-/// [blog post]: https://is.gd/0hKvIr\n-struct TypeGeneralizer<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n-where\n-    D: TypeRelatingDelegate<'tcx> + 'me,\n-{\n-    tcx: TyCtxt<'me, 'gcx, 'tcx>,\n-\n-    delegate: &'me mut D,\n-\n-    /// After we generalize this type, we are going to relative it to\n-    /// some other type. What will be the variance at this point?\n-    ambient_variance: ty::Variance,\n-\n-    first_free_index: ty::DebruijnIndex,\n-\n-    universe: ty::UniverseIndex,\n-}\n-\n-impl<D> TypeRelation<'me, 'gcx, 'tcx> for TypeGeneralizer<'me, 'gcx, 'tcx, D>\n-where\n-    D: TypeRelatingDelegate<'tcx>,\n-{\n-    fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n-        self.tcx\n-    }\n-\n-    fn tag(&self) -> &'static str {\n-        \"nll::generalizer\"\n-    }\n-\n-    fn a_is_expected(&self) -> bool {\n-        true\n-    }\n-\n-    fn relate_with_variance<T: Relate<'tcx>>(\n-        &mut self,\n-        variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n-    ) -> RelateResult<'tcx, T> {\n-        debug!(\n-            \"TypeGeneralizer::relate_with_variance(variance={:?}, a={:?}, b={:?})\",\n-            variance, a, b\n-        );\n-\n-        let old_ambient_variance = self.ambient_variance;\n-        self.ambient_variance = self.ambient_variance.xform(variance);\n-\n-        debug!(\n-            \"TypeGeneralizer::relate_with_variance: ambient_variance = {:?}\",\n-            self.ambient_variance\n-        );\n-\n-        let r = self.relate(a, b)?;\n-\n-        self.ambient_variance = old_ambient_variance;\n-\n-        debug!(\"TypeGeneralizer::relate_with_variance: r={:?}\", r);\n-\n-        Ok(r)\n-    }\n-\n-    fn tys(&mut self, a: Ty<'tcx>, _: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"TypeGeneralizer::tys(a={:?})\", a,);\n-\n-        match a.sty {\n-            ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) => {\n-                bug!(\n-                    \"unexpected inference variable encountered in NLL generalization: {:?}\",\n-                    a\n-                );\n-            }\n-\n-            _ => relate::super_relate_tys(self, a, a),\n-        }\n-    }\n-\n-    fn regions(\n-        &mut self,\n-        a: ty::Region<'tcx>,\n-        _: ty::Region<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        debug!(\"TypeGeneralizer::regions(a={:?})\", a,);\n-\n-        if let ty::ReLateBound(debruijn, _) = a {\n-            if *debruijn < self.first_free_index {\n-                return Ok(a);\n-            }\n-        }\n-\n-        // For now, we just always create a fresh region variable to\n-        // replace all the regions in the source type. In the main\n-        // type checker, we special case the case where the ambient\n-        // variance is `Invariant` and try to avoid creating a fresh\n-        // region variable, but since this comes up so much less in\n-        // NLL (only when users use `_` etc) it is much less\n-        // important.\n-        //\n-        // As an aside, since these new variables are created in\n-        // `self.universe` universe, this also serves to enforce the\n-        // universe scoping rules.\n-        //\n-        // FIXME(#54105) -- if the ambient variance is bivariant,\n-        // though, we may however need to check well-formedness or\n-        // risk a problem like #41677 again.\n-\n-        let replacement_region_vid = self.delegate.generalize_existential(self.universe);\n-\n-        Ok(replacement_region_vid)\n-    }\n-\n-    fn binders<T>(\n-        &mut self,\n-        a: &ty::Binder<T>,\n-        _: &ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n-    where\n-        T: Relate<'tcx>,\n-    {\n-        debug!(\"TypeGeneralizer::binders(a={:?})\", a,);\n-\n-        self.first_free_index.shift_in(1);\n-        let result = self.relate(a.skip_binder(), a.skip_binder())?;\n-        self.first_free_index.shift_out(1);\n-        Ok(ty::Binder::bind(result))\n-    }\n-}"}]}