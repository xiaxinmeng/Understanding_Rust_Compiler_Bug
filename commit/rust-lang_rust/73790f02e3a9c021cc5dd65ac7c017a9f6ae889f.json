{"sha": "73790f02e3a9c021cc5dd65ac7c017a9f6ae889f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczNzkwZjAyZTNhOWMwMjFjYzVkZDY1YWM3YzAxN2E5ZjZhZTg4OWY=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2016-04-06T05:57:42Z"}, "committer": {"name": "James Miller", "email": "james@aatch.net", "date": "2016-04-06T05:57:42Z"}, "message": "Move ReturnDest creation into a method\n\nIt's quite a large amount of code, and moving it into a method allowed\nfor some refactoring to make the logic a little easier to understand", "tree": {"sha": "1cd90faa775b935ce912706f79d1de213f1f5c49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1cd90faa775b935ce912706f79d1de213f1f5c49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73790f02e3a9c021cc5dd65ac7c017a9f6ae889f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73790f02e3a9c021cc5dd65ac7c017a9f6ae889f", "html_url": "https://github.com/rust-lang/rust/commit/73790f02e3a9c021cc5dd65ac7c017a9f6ae889f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73790f02e3a9c021cc5dd65ac7c017a9f6ae889f/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4d4fa3295bf5bfd8a798557d5cf0158ca453f84", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4d4fa3295bf5bfd8a798557d5cf0158ca453f84", "html_url": "https://github.com/rust-lang/rust/commit/e4d4fa3295bf5bfd8a798557d5cf0158ca453f84"}], "stats": {"total": 126, "additions": 61, "deletions": 65}, "files": [{"sha": "7234bff4397240abdcc46a37e04d7d6b51e87a25", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 58, "deletions": 64, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/73790f02e3a9c021cc5dd65ac7c017a9f6ae889f/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73790f02e3a9c021cc5dd65ac7c017a9f6ae889f/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=73790f02e3a9c021cc5dd65ac7c017a9f6ae889f", "patch": "@@ -211,70 +211,13 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let mut llargs = Vec::with_capacity(arg_count);\n \n                 // Prepare the return value destination\n-                let ret_dest = if let Some((ref d, _)) = *destination {\n-                    match *d {\n-                        // Handle temporary lvalues, specifically Operand ones, as\n-                        // they don't have allocas\n-                        mir::Lvalue::Temp(idx) => {\n-                            let lvalue_ty = self.mir.lvalue_ty(bcx.tcx(), d);\n-                            let ret_ty = lvalue_ty.to_ty(bcx.tcx());\n-                            match self.temps[idx as usize] {\n-                                TempRef::Lvalue(dest) => {\n-                                    if fn_ty.ret.is_indirect() {\n-                                        llargs.push(dest.llval);\n-                                        ReturnDest::Nothing\n-                                    } else if fn_ty.ret.is_ignore() {\n-                                        ReturnDest::Nothing\n-                                    } else {\n-                                        ReturnDest::Store(dest.llval)\n-                                    }\n-                                }\n-                                TempRef::Operand(None) => {\n-                                    let is_intrinsic = if let Intrinsic = callee.data {\n-                                        true\n-                                    } else {\n-                                        false\n-                                    };\n-\n-                                    if fn_ty.ret.is_indirect() {\n-                                        // Odd, but possible, case, we have an operand temporary,\n-                                        // but the calling convention has an indirect return.\n-                                        let tmp = bcx.with_block(|bcx| {\n-                                            base::alloc_ty(bcx, ret_ty, \"tmp_ret\")\n-                                        });\n-                                        llargs.push(tmp);\n-                                        ReturnDest::IndirectOperand(tmp, idx)\n-                                    } else if is_intrinsic {\n-                                        // Currently, intrinsics always need a location to store\n-                                        // the result. so we create a temporary alloca for the\n-                                        // result\n-                                        let tmp = bcx.with_block(|bcx| {\n-                                            base::alloc_ty(bcx, ret_ty, \"tmp_ret\")\n-                                        });\n-                                        ReturnDest::IndirectOperand(tmp, idx)\n-                                    } else if fn_ty.ret.is_ignore() {\n-                                        ReturnDest::Nothing\n-                                    } else {\n-                                        ReturnDest::DirectOperand(idx)\n-                                    }\n-                                }\n-                                TempRef::Operand(Some(_)) => {\n-                                    bug!(\"lvalue temp already assigned to\");\n-                                }\n-                            }\n-                        }\n-                        _ => {\n-                            let dest = self.trans_lvalue(&bcx, d);\n-                            if fn_ty.ret.is_indirect() {\n-                                llargs.push(dest.llval);\n-                                ReturnDest::Nothing\n-                            } else if fn_ty.ret.is_ignore() {\n-                                ReturnDest::Nothing\n-                            } else {\n-                                ReturnDest::Store(dest.llval)\n-                            }\n-                        }\n-                    }\n+                let ret_dest = if let Some((ref dest, _)) = *destination {\n+                    let is_intrinsic = if let Intrinsic = callee.data {\n+                        true\n+                    } else {\n+                        false\n+                    };\n+                    self.make_return_dest(&bcx, dest, &fn_ty.ret, &mut llargs, is_intrinsic)\n                 } else {\n                     ReturnDest::Nothing\n                 };\n@@ -601,6 +544,57 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         self.blocks[bb.index()].llbb\n     }\n \n+    fn make_return_dest(&mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                        dest: &mir::Lvalue<'tcx>, fn_ret_ty: &ArgType,\n+                        llargs: &mut Vec<ValueRef>, is_intrinsic: bool) -> ReturnDest {\n+        // If the return is ignored, we can just return a do-nothing ReturnDest\n+        if fn_ret_ty.is_ignore() {\n+            return ReturnDest::Nothing;\n+        }\n+        let dest = match *dest {\n+            mir::Lvalue::Temp(idx) => {\n+                let lvalue_ty = self.mir.lvalue_ty(bcx.tcx(), dest);\n+                let ret_ty = lvalue_ty.to_ty(bcx.tcx());\n+                match self.temps[idx as usize] {\n+                    TempRef::Lvalue(dest) => dest,\n+                    TempRef::Operand(None) => {\n+                        // Handle temporary lvalues, specifically Operand ones, as\n+                        // they don't have allocas\n+                        return if fn_ret_ty.is_indirect() {\n+                            // Odd, but possible, case, we have an operand temporary,\n+                            // but the calling convention has an indirect return.\n+                            let tmp = bcx.with_block(|bcx| {\n+                                base::alloc_ty(bcx, ret_ty, \"tmp_ret\")\n+                            });\n+                            llargs.push(tmp);\n+                            ReturnDest::IndirectOperand(tmp, idx)\n+                        } else if is_intrinsic {\n+                            // Currently, intrinsics always need a location to store\n+                            // the result. so we create a temporary alloca for the\n+                            // result\n+                            let tmp = bcx.with_block(|bcx| {\n+                                base::alloc_ty(bcx, ret_ty, \"tmp_ret\")\n+                            });\n+                            ReturnDest::IndirectOperand(tmp, idx)\n+                        } else {\n+                            ReturnDest::DirectOperand(idx)\n+                        };\n+                    }\n+                    TempRef::Operand(Some(_)) => {\n+                        bug!(\"lvalue temp already assigned to\");\n+                    }\n+                }\n+            }\n+            _ => self.trans_lvalue(bcx, dest)\n+        };\n+        if fn_ret_ty.is_indirect() {\n+            llargs.push(dest.llval);\n+            ReturnDest::Nothing\n+        } else {\n+            ReturnDest::Store(dest.llval)\n+        }\n+    }\n+\n     fn trans_transmute(&mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                        src: &mir::Operand<'tcx>, dst: LvalueRef<'tcx>) {\n         let mut val = self.trans_operand(bcx, src);"}, {"sha": "13e1894df16af7fe5b87ad8b68f1eed7aa92b2d1", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73790f02e3a9c021cc5dd65ac7c017a9f6ae889f/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73790f02e3a9c021cc5dd65ac7c017a9f6ae889f/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=73790f02e3a9c021cc5dd65ac7c017a9f6ae889f", "patch": "@@ -220,7 +220,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     TempRef::Lvalue(lvalue) => f(self, lvalue),\n                     TempRef::Operand(None) => {\n                         let lvalue_ty = self.mir.lvalue_ty(bcx.tcx(), lvalue);\n-                        let lvalue = LvalueRef::alloca(bcx, lvalue_ty.to_ty(bcx.tcx()), \"lvalue_temp\");\n+                        let lvalue = LvalueRef::alloca(bcx,\n+                                                       lvalue_ty.to_ty(bcx.tcx()),\n+                                                       \"lvalue_temp\");\n                         let ret = f(self, lvalue);\n                         let op = self.trans_load(bcx, lvalue.llval, lvalue_ty.to_ty(bcx.tcx()));\n                         self.temps[idx as usize] = TempRef::Operand(Some(op));"}]}