{"sha": "9f0080801da75c596cd8548ffb539bb8f046fa62", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmMDA4MDgwMWRhNzVjNTk2Y2Q4NTQ4ZmZiNTM5YmI4ZjA0NmZhNjI=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-07-14T05:05:26Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-07-16T22:28:19Z"}, "message": "Remove `ExtCtxt::ident_of`.\n\nIt's equivalent to `Ident::from_str_and_span`. The commit also\nintroduces some more static symbols so that `Ident::new` can be used in\nvarious places instead of `Ident::from_str_and_span`.\n\nThe commit also changes `Path::path` from a `&str` to a `Symbol`, which\nthen allows the lifetime annotation to be removed from `Ty`. Also, the\nuse of `Symbol` in `Bounds` removes the need for its lifetime\nannotation.", "tree": {"sha": "cd4ea8ad2ed0c746778d800b1c4dcf0d04e8e5ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd4ea8ad2ed0c746778d800b1c4dcf0d04e8e5ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f0080801da75c596cd8548ffb539bb8f046fa62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f0080801da75c596cd8548ffb539bb8f046fa62", "html_url": "https://github.com/rust-lang/rust/commit/9f0080801da75c596cd8548ffb539bb8f046fa62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f0080801da75c596cd8548ffb539bb8f046fa62/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bccff14a2084784d70bb3caefb24f1694212c0b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/bccff14a2084784d70bb3caefb24f1694212c0b4", "html_url": "https://github.com/rust-lang/rust/commit/bccff14a2084784d70bb3caefb24f1694212c0b4"}], "stats": {"total": 343, "additions": 209, "deletions": 134}, "files": [{"sha": "3bf3860d32307d52c3f53d07fccf571f58ddf346", "filename": "src/librustc_builtin_macros/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Ford.rs?ref=9f0080801da75c596cd8548ffb539bb8f046fa62", "patch": "@@ -29,7 +29,7 @@ pub fn expand_deriving_ord(\n             name: sym::cmp,\n             generics: Bounds::empty(),\n             explicit_self: borrowed_explicit_self(),\n-            args: vec![(borrowed_self(), \"other\")],\n+            args: vec![(borrowed_self(), sym::other)],\n             ret_ty: Literal(path_std!(cmp::Ordering)),\n             attributes: attrs,\n             is_unsafe: false,"}, {"sha": "d8edd641acd52dd945f038f942d2ce7ed61877d6", "filename": "src/librustc_builtin_macros/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=9f0080801da75c596cd8548ffb539bb8f046fa62", "patch": "@@ -71,7 +71,7 @@ pub fn expand_deriving_partial_eq(\n                 name: $name,\n                 generics: Bounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec![(borrowed_self(), \"other\")],\n+                args: vec![(borrowed_self(), sym::other)],\n                 ret_ty: Literal(path_local!(bool)),\n                 attributes: attrs,\n                 is_unsafe: false,"}, {"sha": "39a747c856839455077a808c190eb83224299072", "filename": "src/librustc_builtin_macros/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=9f0080801da75c596cd8548ffb539bb8f046fa62", "patch": "@@ -25,7 +25,7 @@ pub fn expand_deriving_partial_ord(\n                 name: $name,\n                 generics: Bounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec![(borrowed_self(), \"other\")],\n+                args: vec![(borrowed_self(), sym::other)],\n                 ret_ty: Literal(path_local!(bool)),\n                 attributes: attrs,\n                 is_unsafe: false,\n@@ -52,7 +52,7 @@ pub fn expand_deriving_partial_ord(\n         name: sym::partial_cmp,\n         generics: Bounds::empty(),\n         explicit_self: borrowed_explicit_self(),\n-        args: vec![(borrowed_self(), \"other\")],\n+        args: vec![(borrowed_self(), sym::other)],\n         ret_ty,\n         attributes: attrs,\n         is_unsafe: false,"}, {"sha": "76e21bc43c52d84ec614ded321737770031e515d", "filename": "src/librustc_builtin_macros/deriving/debug.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fdebug.rs?ref=9f0080801da75c596cd8548ffb539bb8f046fa62", "patch": "@@ -32,7 +32,7 @@ pub fn expand_deriving_debug(\n             name: sym::fmt,\n             generics: Bounds::empty(),\n             explicit_self: borrowed_explicit_self(),\n-            args: vec![(fmtr, \"f\")],\n+            args: vec![(fmtr, sym::f)],\n             ret_ty: Literal(path_std!(fmt::Result)),\n             attributes: Vec::new(),\n             is_unsafe: false,\n@@ -62,7 +62,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     // We want to make sure we have the ctxt set so that we can use unstable methods\n     let span = cx.with_def_site_ctxt(span);\n     let name = cx.expr_lit(span, ast::LitKind::Str(ident.name, ast::StrStyle::Cooked));\n-    let builder = cx.ident_of(\"debug_trait_builder\", span);\n+    let builder = Ident::new(sym::debug_trait_builder, span);\n     let builder_expr = cx.expr_ident(span, builder);\n \n     let fmt = substr.nonself_args[0].clone();\n@@ -71,7 +71,8 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     match vdata {\n         ast::VariantData::Tuple(..) | ast::VariantData::Unit(..) => {\n             // tuple struct/\"normal\" variant\n-            let expr = cx.expr_method_call(span, fmt, cx.ident_of(\"debug_tuple\", span), vec![name]);\n+            let expr =\n+                cx.expr_method_call(span, fmt, Ident::new(sym::debug_tuple, span), vec![name]);\n             stmts.push(cx.stmt_let(span, true, builder, expr));\n \n             for field in fields {\n@@ -94,7 +95,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         ast::VariantData::Struct(..) => {\n             // normal struct/struct variant\n             let expr =\n-                cx.expr_method_call(span, fmt, cx.ident_of(\"debug_struct\", span), vec![name]);\n+                cx.expr_method_call(span, fmt, Ident::new(sym::debug_struct, span), vec![name]);\n             stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n \n             for field in fields {\n@@ -117,7 +118,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         }\n     }\n \n-    let expr = cx.expr_method_call(span, builder_expr, cx.ident_of(\"finish\", span), vec![]);\n+    let expr = cx.expr_method_call(span, builder_expr, Ident::new(sym::finish, span), vec![]);\n \n     stmts.push(cx.stmt_expr(expr));\n     let block = cx.block(span, stmts);"}, {"sha": "ce8c2dfe4d5a099ebc5890ab5b4ea9e40db82a4f", "filename": "src/librustc_builtin_macros/deriving/decodable.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fdecodable.rs?ref=9f0080801da75c596cd8548ffb539bb8f046fa62", "patch": "@@ -8,7 +8,7 @@ use rustc_ast::ast;\n use rustc_ast::ast::{Expr, MetaItem, Mutability};\n use rustc_ast::ptr::P;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n \n pub fn expand_deriving_rustc_decodable(\n@@ -18,13 +18,13 @@ pub fn expand_deriving_rustc_decodable(\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n-    let krate = \"rustc_serialize\";\n-    let typaram = \"__D\";\n+    let krate = sym::rustc_serialize;\n+    let typaram = sym::__D;\n \n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n-        path: Path::new_(vec![krate, \"Decodable\"], None, vec![], PathKind::Global),\n+        path: Path::new_(vec![krate, sym::Decodable], None, vec![], PathKind::Global),\n         additional_bounds: Vec::new(),\n         generics: Bounds::empty(),\n         is_unsafe: false,\n@@ -34,21 +34,21 @@ pub fn expand_deriving_rustc_decodable(\n             generics: Bounds {\n                 bounds: vec![(\n                     typaram,\n-                    vec![Path::new_(vec![krate, \"Decoder\"], None, vec![], PathKind::Global)],\n+                    vec![Path::new_(vec![krate, sym::Decoder], None, vec![], PathKind::Global)],\n                 )],\n             },\n             explicit_self: None,\n             args: vec![(\n                 Ptr(Box::new(Literal(Path::new_local(typaram))), Borrowed(None, Mutability::Mut)),\n-                \"d\",\n+                sym::d,\n             )],\n             ret_ty: Literal(Path::new_(\n                 pathvec_std!(result::Result),\n                 None,\n                 vec![\n                     Box::new(Self_),\n                     Box::new(Literal(Path::new_(\n-                        vec![typaram, \"Error\"],\n+                        vec![typaram, sym::Error],\n                         None,\n                         vec![],\n                         PathKind::Local,\n@@ -73,17 +73,17 @@ fn decodable_substructure(\n     cx: &mut ExtCtxt<'_>,\n     trait_span: Span,\n     substr: &Substructure<'_>,\n-    krate: &str,\n+    krate: Symbol,\n ) -> P<Expr> {\n     let decoder = substr.nonself_args[0].clone();\n     let recurse = vec![\n-        cx.ident_of(krate, trait_span),\n-        cx.ident_of(\"Decodable\", trait_span),\n-        cx.ident_of(\"decode\", trait_span),\n+        Ident::new(krate, trait_span),\n+        Ident::new(sym::Decodable, trait_span),\n+        Ident::new(sym::decode, trait_span),\n     ];\n     let exprdecode = cx.expr_path(cx.path_global(trait_span, recurse));\n     // throw an underscore in front to suppress unused variable warnings\n-    let blkarg = cx.ident_of(\"_d\", trait_span);\n+    let blkarg = Ident::new(sym::_d, trait_span);\n     let blkdecoder = cx.expr_ident(trait_span, blkarg);\n \n     match *substr.fields {\n@@ -92,7 +92,7 @@ fn decodable_substructure(\n                 Unnamed(ref fields, _) => fields.len(),\n                 Named(ref fields) => fields.len(),\n             };\n-            let read_struct_field = cx.ident_of(\"read_struct_field\", trait_span);\n+            let read_struct_field = Ident::new(sym::read_struct_field, trait_span);\n \n             let path = cx.path_ident(trait_span, substr.type_ident);\n             let result =\n@@ -115,7 +115,7 @@ fn decodable_substructure(\n             cx.expr_method_call(\n                 trait_span,\n                 decoder,\n-                cx.ident_of(\"read_struct\", trait_span),\n+                Ident::new(sym::read_struct, trait_span),\n                 vec![\n                     cx.expr_str(trait_span, substr.type_ident.name),\n                     cx.expr_usize(trait_span, nfields),\n@@ -124,11 +124,11 @@ fn decodable_substructure(\n             )\n         }\n         StaticEnum(_, ref fields) => {\n-            let variant = cx.ident_of(\"i\", trait_span);\n+            let variant = Ident::new(sym::i, trait_span);\n \n             let mut arms = Vec::with_capacity(fields.len() + 1);\n             let mut variants = Vec::with_capacity(fields.len());\n-            let rvariant_arg = cx.ident_of(\"read_enum_variant_arg\", trait_span);\n+            let rvariant_arg = Ident::new(sym::read_enum_variant_arg, trait_span);\n \n             for (i, &(ident, v_span, ref parts)) in fields.iter().enumerate() {\n                 variants.push(cx.expr_str(v_span, ident.name));\n@@ -163,13 +163,13 @@ fn decodable_substructure(\n             let result = cx.expr_method_call(\n                 trait_span,\n                 blkdecoder,\n-                cx.ident_of(\"read_enum_variant\", trait_span),\n+                Ident::new(sym::read_enum_variant, trait_span),\n                 vec![variant_vec, lambda],\n             );\n             cx.expr_method_call(\n                 trait_span,\n                 decoder,\n-                cx.ident_of(\"read_enum\", trait_span),\n+                Ident::new(sym::read_enum, trait_span),\n                 vec![\n                     cx.expr_str(trait_span, substr.type_ident.name),\n                     cx.lambda1(trait_span, result, blkarg),"}, {"sha": "8ca1be1efb635f7685382e853d35e7e57e34d55f", "filename": "src/librustc_builtin_macros/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fdefault.rs?ref=9f0080801da75c596cd8548ffb539bb8f046fa62", "patch": "@@ -1,6 +1,5 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n-use crate::deriving::path_std;\n \n use rustc_ast::ast::{Expr, MetaItem};\n use rustc_ast::ptr::P;\n@@ -21,7 +20,7 @@ pub fn expand_deriving_default(\n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n-        path: path_std!(default::Default),\n+        path: Path::new(vec![kw::Default, sym::Default]),\n         additional_bounds: Vec::new(),\n         generics: Bounds::empty(),\n         is_unsafe: false,"}, {"sha": "7a880357a594740939a7fd55bfe129668047d994", "filename": "src/librustc_builtin_macros/deriving/encodable.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fencodable.rs?ref=9f0080801da75c596cd8548ffb539bb8f046fa62", "patch": "@@ -92,7 +92,7 @@ use crate::deriving::pathvec_std;\n use rustc_ast::ast::{Expr, ExprKind, MetaItem, Mutability};\n use rustc_ast::ptr::P;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n \n pub fn expand_deriving_rustc_encodable(\n@@ -102,13 +102,13 @@ pub fn expand_deriving_rustc_encodable(\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n-    let krate = \"rustc_serialize\";\n-    let typaram = \"__S\";\n+    let krate = sym::rustc_serialize;\n+    let typaram = sym::__S;\n \n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n-        path: Path::new_(vec![krate, \"Encodable\"], None, vec![], PathKind::Global),\n+        path: Path::new_(vec![krate, sym::Encodable], None, vec![], PathKind::Global),\n         additional_bounds: Vec::new(),\n         generics: Bounds::empty(),\n         is_unsafe: false,\n@@ -118,21 +118,26 @@ pub fn expand_deriving_rustc_encodable(\n             generics: Bounds {\n                 bounds: vec![(\n                     typaram,\n-                    vec![Path::new_(vec![krate, \"Encoder\"], None, vec![], PathKind::Global)],\n+                    vec![Path::new_(vec![krate, sym::Encoder], None, vec![], PathKind::Global)],\n                 )],\n             },\n             explicit_self: borrowed_explicit_self(),\n             args: vec![(\n                 Ptr(Box::new(Literal(Path::new_local(typaram))), Borrowed(None, Mutability::Mut)),\n-                \"s\",\n+                // FIXME: we could use `sym::s` here, but making `s` a static\n+                // symbol changes the symbol index ordering in a way that makes\n+                // ui/lint/rfc-2457-non-ascii-idents/lint-confusable-idents.rs\n+                // fail. The linting code should be fixed so that its output\n+                // does not depend on the symbol index ordering.\n+                Symbol::intern(\"s\"),\n             )],\n             ret_ty: Literal(Path::new_(\n                 pathvec_std!(result::Result),\n                 None,\n                 vec![\n                     Box::new(Tuple(Vec::new())),\n                     Box::new(Literal(Path::new_(\n-                        vec![typaram, \"Error\"],\n+                        vec![typaram, sym::Error],\n                         None,\n                         vec![],\n                         PathKind::Local,\n@@ -157,24 +162,24 @@ fn encodable_substructure(\n     cx: &mut ExtCtxt<'_>,\n     trait_span: Span,\n     substr: &Substructure<'_>,\n-    krate: &'static str,\n+    krate: Symbol,\n ) -> P<Expr> {\n     let encoder = substr.nonself_args[0].clone();\n     // throw an underscore in front to suppress unused variable warnings\n-    let blkarg = cx.ident_of(\"_e\", trait_span);\n+    let blkarg = Ident::new(sym::_e, trait_span);\n     let blkencoder = cx.expr_ident(trait_span, blkarg);\n     let fn_path = cx.expr_path(cx.path_global(\n         trait_span,\n         vec![\n-            cx.ident_of(krate, trait_span),\n-            cx.ident_of(\"Encodable\", trait_span),\n-            cx.ident_of(\"encode\", trait_span),\n+            Ident::new(krate, trait_span),\n+            Ident::new(sym::Encodable, trait_span),\n+            Ident::new(sym::encode, trait_span),\n         ],\n     ));\n \n     match *substr.fields {\n         Struct(_, ref fields) => {\n-            let emit_struct_field = cx.ident_of(\"emit_struct_field\", trait_span);\n+            let emit_struct_field = Ident::new(sym::emit_struct_field, trait_span);\n             let mut stmts = Vec::new();\n             for (i, &FieldInfo { name, ref self_, span, .. }) in fields.iter().enumerate() {\n                 let name = match name {\n@@ -214,7 +219,7 @@ fn encodable_substructure(\n             cx.expr_method_call(\n                 trait_span,\n                 encoder,\n-                cx.ident_of(\"emit_struct\", trait_span),\n+                Ident::new(sym::emit_struct, trait_span),\n                 vec![\n                     cx.expr_str(trait_span, substr.type_ident.name),\n                     cx.expr_usize(trait_span, fields.len()),\n@@ -230,7 +235,7 @@ fn encodable_substructure(\n             // actually exist.\n             let me = cx.stmt_let(trait_span, false, blkarg, encoder);\n             let encoder = cx.expr_ident(trait_span, blkarg);\n-            let emit_variant_arg = cx.ident_of(\"emit_enum_variant_arg\", trait_span);\n+            let emit_variant_arg = Ident::new(sym::emit_enum_variant_arg, trait_span);\n             let mut stmts = Vec::new();\n             if !fields.is_empty() {\n                 let last = fields.len() - 1;\n@@ -263,7 +268,7 @@ fn encodable_substructure(\n             let call = cx.expr_method_call(\n                 trait_span,\n                 blkencoder,\n-                cx.ident_of(\"emit_enum_variant\", trait_span),\n+                Ident::new(sym::emit_enum_variant, trait_span),\n                 vec![\n                     name,\n                     cx.expr_usize(trait_span, idx),\n@@ -275,7 +280,7 @@ fn encodable_substructure(\n             let ret = cx.expr_method_call(\n                 trait_span,\n                 encoder,\n-                cx.ident_of(\"emit_enum\", trait_span),\n+                Ident::new(sym::emit_enum, trait_span),\n                 vec![cx.expr_str(trait_span, substr.type_ident.name), blk],\n             );\n             cx.expr_block(cx.block(trait_span, vec![me, cx.stmt_expr(ret)]))"}, {"sha": "c43d1cf1888c494a012873b554e5c6b1a004a9c4", "filename": "src/librustc_builtin_macros/deriving/generic/mod.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs?ref=9f0080801da75c596cd8548ffb539bb8f046fa62", "patch": "@@ -204,14 +204,14 @@ pub struct TraitDef<'a> {\n     pub attributes: Vec<ast::Attribute>,\n \n     /// Path of the trait, including any type parameters\n-    pub path: Path<'a>,\n+    pub path: Path,\n \n     /// Additional bounds required of any type parameters of the type,\n     /// other than the current trait\n-    pub additional_bounds: Vec<Ty<'a>>,\n+    pub additional_bounds: Vec<Ty>,\n \n     /// Any extra lifetimes and/or bounds, e.g., `D: serialize::Decoder`\n-    pub generics: Bounds<'a>,\n+    pub generics: Bounds,\n \n     /// Is it an `unsafe` trait?\n     pub is_unsafe: bool,\n@@ -221,25 +221,25 @@ pub struct TraitDef<'a> {\n \n     pub methods: Vec<MethodDef<'a>>,\n \n-    pub associated_types: Vec<(Ident, Ty<'a>)>,\n+    pub associated_types: Vec<(Ident, Ty)>,\n }\n \n pub struct MethodDef<'a> {\n     /// name of the method\n     pub name: Symbol,\n     /// List of generics, e.g., `R: rand::Rng`\n-    pub generics: Bounds<'a>,\n+    pub generics: Bounds,\n \n     /// Whether there is a self argument (outer Option) i.e., whether\n     /// this is a static function, and whether it is a pointer (inner\n     /// Option)\n     pub explicit_self: Option<Option<PtrTy>>,\n \n     /// Arguments other than the self argument\n-    pub args: Vec<(Ty<'a>, &'a str)>,\n+    pub args: Vec<(Ty, Symbol)>,\n \n     /// Returns type\n-    pub ret_ty: Ty<'a>,\n+    pub ret_ty: Ty,\n \n     pub attributes: Vec<ast::Attribute>,\n \n@@ -865,7 +865,7 @@ impl<'a> MethodDef<'a> {\n \n         for (ty, name) in self.args.iter() {\n             let ast_ty = ty.to_ty(cx, trait_.span, type_ident, generics);\n-            let ident = cx.ident_of(name, trait_.span);\n+            let ident = Ident::new(*name, trait_.span);\n             arg_tys.push((ident, ast_ty));\n \n             let arg_expr = cx.expr_ident(trait_.span, ident);\n@@ -1170,8 +1170,10 @@ impl<'a> MethodDef<'a> {\n             )\n             .collect::<Vec<String>>();\n \n-        let self_arg_idents =\n-            self_arg_names.iter().map(|name| cx.ident_of(name, sp)).collect::<Vec<Ident>>();\n+        let self_arg_idents = self_arg_names\n+            .iter()\n+            .map(|name| Ident::from_str_and_span(name, sp))\n+            .collect::<Vec<Ident>>();\n \n         // The `vi_idents` will be bound, solely in the catch-all, to\n         // a series of let statements mapping each self_arg to an int\n@@ -1180,7 +1182,7 @@ impl<'a> MethodDef<'a> {\n             .iter()\n             .map(|name| {\n                 let vi_suffix = format!(\"{}_vi\", &name[..]);\n-                cx.ident_of(&vi_suffix[..], trait_.span)\n+                Ident::from_str_and_span(&vi_suffix, trait_.span)\n             })\n             .collect::<Vec<Ident>>();\n \n@@ -1568,7 +1570,7 @@ impl<'a> TraitDef<'a> {\n         let mut ident_exprs = Vec::new();\n         for (i, struct_field) in struct_def.fields().iter().enumerate() {\n             let sp = struct_field.span.with_ctxt(self.span.ctxt());\n-            let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i), self.span);\n+            let ident = Ident::from_str_and_span(&format!(\"{}_{}\", prefix, i), self.span);\n             paths.push(ident.with_span_pos(sp));\n             let val = cx.expr_path(cx.path_ident(sp, ident));\n             let val = if use_temporaries { val } else { cx.expr_deref(sp, val) };"}, {"sha": "51314dbcffc06e5d50358f6f846632f16a53d499", "filename": "src/librustc_builtin_macros/deriving/generic/ty.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fty.rs?ref=9f0080801da75c596cd8548ffb539bb8f046fa62", "patch": "@@ -8,7 +8,7 @@ use rustc_ast::ast::{self, Expr, GenericArg, GenericParamKind, Generics, SelfKin\n use rustc_ast::ptr::P;\n use rustc_expand::base::ExtCtxt;\n use rustc_span::source_map::{respan, DUMMY_SP};\n-use rustc_span::symbol::{kw, Ident};\n+use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::Span;\n \n /// The types of pointers\n@@ -24,10 +24,10 @@ pub enum PtrTy {\n /// A path, e.g., `::std::option::Option::<i32>` (global). Has support\n /// for type parameters and a lifetime.\n #[derive(Clone)]\n-pub struct Path<'a> {\n-    path: Vec<&'a str>,\n+pub struct Path {\n+    path: Vec<Symbol>,\n     lifetime: Option<Ident>,\n-    params: Vec<Box<Ty<'a>>>,\n+    params: Vec<Box<Ty>>,\n     kind: PathKind,\n }\n \n@@ -38,19 +38,19 @@ pub enum PathKind {\n     Std,\n }\n \n-impl<'a> Path<'a> {\n-    pub fn new(path: Vec<&str>) -> Path<'_> {\n+impl Path {\n+    pub fn new(path: Vec<Symbol>) -> Path {\n         Path::new_(path, None, Vec::new(), PathKind::Std)\n     }\n-    pub fn new_local(path: &str) -> Path<'_> {\n+    pub fn new_local(path: Symbol) -> Path {\n         Path::new_(vec![path], None, Vec::new(), PathKind::Local)\n     }\n-    pub fn new_<'r>(\n-        path: Vec<&'r str>,\n+    pub fn new_(\n+        path: Vec<Symbol>,\n         lifetime: Option<Ident>,\n-        params: Vec<Box<Ty<'r>>>,\n+        params: Vec<Box<Ty>>,\n         kind: PathKind,\n-    ) -> Path<'r> {\n+    ) -> Path {\n         Path { path, lifetime, params, kind }\n     }\n \n@@ -70,7 +70,7 @@ impl<'a> Path<'a> {\n         self_ty: Ident,\n         self_generics: &Generics,\n     ) -> ast::Path {\n-        let mut idents = self.path.iter().map(|s| cx.ident_of(*s, span)).collect();\n+        let mut idents = self.path.iter().map(|s| Ident::new(*s, span)).collect();\n         let lt = mk_lifetimes(cx, span, &self.lifetime);\n         let tys: Vec<P<ast::Ty>> =\n             self.params.iter().map(|t| t.to_ty(cx, span, self_ty, self_generics)).collect();\n@@ -94,33 +94,33 @@ impl<'a> Path<'a> {\n \n /// A type. Supports pointers, Self, and literals.\n #[derive(Clone)]\n-pub enum Ty<'a> {\n+pub enum Ty {\n     Self_,\n     /// &/Box/ Ty\n-    Ptr(Box<Ty<'a>>, PtrTy),\n+    Ptr(Box<Ty>, PtrTy),\n     /// `mod::mod::Type<[lifetime], [Params...]>`, including a plain type\n     /// parameter, and things like `i32`\n-    Literal(Path<'a>),\n+    Literal(Path),\n     /// includes unit\n-    Tuple(Vec<Ty<'a>>),\n+    Tuple(Vec<Ty>),\n }\n \n pub fn borrowed_ptrty() -> PtrTy {\n     Borrowed(None, ast::Mutability::Not)\n }\n-pub fn borrowed(ty: Box<Ty<'_>>) -> Ty<'_> {\n+pub fn borrowed(ty: Box<Ty>) -> Ty {\n     Ptr(ty, borrowed_ptrty())\n }\n \n pub fn borrowed_explicit_self() -> Option<Option<PtrTy>> {\n     Some(Some(borrowed_ptrty()))\n }\n \n-pub fn borrowed_self<'r>() -> Ty<'r> {\n+pub fn borrowed_self() -> Ty {\n     borrowed(Box::new(Self_))\n }\n \n-pub fn nil_ty<'r>() -> Ty<'r> {\n+pub fn nil_ty() -> Ty {\n     Tuple(Vec::new())\n }\n \n@@ -132,7 +132,7 @@ fn mk_lifetimes(cx: &ExtCtxt<'_>, span: Span, lt: &Option<Ident>) -> Vec<ast::Li\n     mk_lifetime(cx, span, lt).into_iter().collect()\n }\n \n-impl<'a> Ty<'a> {\n+impl Ty {\n     pub fn to_ty(\n         &self,\n         cx: &ExtCtxt<'_>,\n@@ -199,9 +199,9 @@ impl<'a> Ty<'a> {\n fn mk_ty_param(\n     cx: &ExtCtxt<'_>,\n     span: Span,\n-    name: &str,\n+    name: Symbol,\n     attrs: &[ast::Attribute],\n-    bounds: &[Path<'_>],\n+    bounds: &[Path],\n     self_ident: Ident,\n     self_generics: &Generics,\n ) -> ast::GenericParam {\n@@ -212,7 +212,7 @@ fn mk_ty_param(\n             cx.trait_bound(path)\n         })\n         .collect();\n-    cx.typaram(span, cx.ident_of(name, span), attrs.to_owned(), bounds, None)\n+    cx.typaram(span, Ident::new(name, span), attrs.to_owned(), bounds, None)\n }\n \n fn mk_generics(params: Vec<ast::GenericParam>, span: Span) -> Generics {\n@@ -225,12 +225,12 @@ fn mk_generics(params: Vec<ast::GenericParam>, span: Span) -> Generics {\n \n /// Bounds on type parameters.\n #[derive(Clone)]\n-pub struct Bounds<'a> {\n-    pub bounds: Vec<(&'a str, Vec<Path<'a>>)>,\n+pub struct Bounds {\n+    pub bounds: Vec<(Symbol, Vec<Path>)>,\n }\n \n-impl<'a> Bounds<'a> {\n-    pub fn empty() -> Bounds<'a> {\n+impl Bounds {\n+    pub fn empty() -> Bounds {\n         Bounds { bounds: Vec::new() }\n     }\n     pub fn to_generics("}, {"sha": "d7195188085f01fc3df926a2c77b92e42329fd44", "filename": "src/librustc_builtin_macros/deriving/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fhash.rs?ref=9f0080801da75c596cd8548ffb539bb8f046fa62", "patch": "@@ -17,7 +17,7 @@ pub fn expand_deriving_hash(\n ) {\n     let path = Path::new_(pathvec_std!(hash::Hash), None, vec![], PathKind::Std);\n \n-    let typaram = \"__H\";\n+    let typaram = sym::__H;\n \n     let arg = Path::new_local(typaram);\n     let hash_trait_def = TraitDef {\n@@ -32,7 +32,7 @@ pub fn expand_deriving_hash(\n             name: sym::hash,\n             generics: Bounds { bounds: vec![(typaram, vec![path_std!(hash::Hasher)])] },\n             explicit_self: borrowed_explicit_self(),\n-            args: vec![(Ptr(Box::new(Literal(arg)), Borrowed(None, Mutability::Mut)), \"state\")],\n+            args: vec![(Ptr(Box::new(Literal(arg)), Borrowed(None, Mutability::Mut)), sym::state)],\n             ret_ty: nil_ty(),\n             attributes: vec![],\n             is_unsafe: false,"}, {"sha": "33c0edde98f0ba91854e82dcffe64aa32090c9b0", "filename": "src/librustc_builtin_macros/deriving/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs?ref=9f0080801da75c596cd8548ffb539bb8f046fa62", "patch": "@@ -7,11 +7,11 @@ use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n \n macro path_local($x:ident) {\n-    generic::ty::Path::new_local(stringify!($x))\n+    generic::ty::Path::new_local(sym::$x)\n }\n \n macro pathvec_std($($rest:ident)::+) {{\n-    vec![ $( stringify!($rest) ),+ ]\n+    vec![ $( sym::$rest ),+ ]\n }}\n \n macro path_std($($x:tt)*) {\n@@ -84,7 +84,7 @@ fn inject_impl_of_structural_trait(\n     cx: &mut ExtCtxt<'_>,\n     span: Span,\n     item: &Annotatable,\n-    structural_path: generic::ty::Path<'_>,\n+    structural_path: generic::ty::Path,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n     let item = match *item {"}, {"sha": "55eab24b8a5105def8d34e6bfc591bd39c721bff", "filename": "src/librustc_builtin_macros/format.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fformat.rs?ref=9f0080801da75c596cd8548ffb539bb8f046fa62", "patch": "@@ -578,31 +578,31 @@ impl<'a, 'b> Context<'a, 'b> {\n         self.count_args_index_offset = sofar;\n     }\n \n-    fn rtpath(ecx: &ExtCtxt<'_>, s: &str) -> Vec<Ident> {\n-        ecx.std_path(&[sym::fmt, sym::rt, sym::v1, Symbol::intern(s)])\n+    fn rtpath(ecx: &ExtCtxt<'_>, s: Symbol) -> Vec<Ident> {\n+        ecx.std_path(&[sym::fmt, sym::rt, sym::v1, s])\n     }\n \n     fn build_count(&self, c: parse::Count) -> P<ast::Expr> {\n         let sp = self.macsp;\n         let count = |c, arg| {\n-            let mut path = Context::rtpath(self.ecx, \"Count\");\n-            path.push(self.ecx.ident_of(c, sp));\n+            let mut path = Context::rtpath(self.ecx, sym::Count);\n+            path.push(Ident::new(c, sp));\n             match arg {\n                 Some(arg) => self.ecx.expr_call_global(sp, path, vec![arg]),\n                 None => self.ecx.expr_path(self.ecx.path_global(sp, path)),\n             }\n         };\n         match c {\n-            parse::CountIs(i) => count(\"Is\", Some(self.ecx.expr_usize(sp, i))),\n+            parse::CountIs(i) => count(sym::Is, Some(self.ecx.expr_usize(sp, i))),\n             parse::CountIsParam(i) => {\n                 // This needs mapping too, as `i` is referring to a macro\n                 // argument. If `i` is not found in `count_positions` then\n                 // the error had already been emitted elsewhere.\n                 let i = self.count_positions.get(&i).cloned().unwrap_or(0)\n                     + self.count_args_index_offset;\n-                count(\"Param\", Some(self.ecx.expr_usize(sp, i)))\n+                count(sym::Param, Some(self.ecx.expr_usize(sp, i)))\n             }\n-            parse::CountImplied => count(\"Implied\", None),\n+            parse::CountImplied => count(sym::Implied, None),\n             // should never be the case, names are already resolved\n             parse::CountIsName(_) => panic!(\"should never happen\"),\n         }\n@@ -690,40 +690,40 @@ impl<'a, 'b> Context<'a, 'b> {\n                 // Build the format\n                 let fill = self.ecx.expr_lit(sp, ast::LitKind::Char(fill));\n                 let align = |name| {\n-                    let mut p = Context::rtpath(self.ecx, \"Alignment\");\n-                    p.push(self.ecx.ident_of(name, sp));\n+                    let mut p = Context::rtpath(self.ecx, sym::Alignment);\n+                    p.push(Ident::new(name, sp));\n                     self.ecx.path_global(sp, p)\n                 };\n                 let align = match arg.format.align {\n-                    parse::AlignLeft => align(\"Left\"),\n-                    parse::AlignRight => align(\"Right\"),\n-                    parse::AlignCenter => align(\"Center\"),\n-                    parse::AlignUnknown => align(\"Unknown\"),\n+                    parse::AlignLeft => align(sym::Left),\n+                    parse::AlignRight => align(sym::Right),\n+                    parse::AlignCenter => align(sym::Center),\n+                    parse::AlignUnknown => align(sym::Unknown),\n                 };\n                 let align = self.ecx.expr_path(align);\n                 let flags = self.ecx.expr_u32(sp, arg.format.flags);\n                 let prec = self.build_count(arg.format.precision);\n                 let width = self.build_count(arg.format.width);\n-                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"FormatSpec\"));\n+                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, sym::FormatSpec));\n                 let fmt = self.ecx.expr_struct(\n                     sp,\n                     path,\n                     vec![\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\", sp), fill),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"align\", sp), align),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"flags\", sp), flags),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"precision\", sp), prec),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"width\", sp), width),\n+                        self.ecx.field_imm(sp, Ident::new(sym::fill, sp), fill),\n+                        self.ecx.field_imm(sp, Ident::new(sym::align, sp), align),\n+                        self.ecx.field_imm(sp, Ident::new(sym::flags, sp), flags),\n+                        self.ecx.field_imm(sp, Ident::new(sym::precision, sp), prec),\n+                        self.ecx.field_imm(sp, Ident::new(sym::width, sp), width),\n                     ],\n                 );\n \n-                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"Argument\"));\n+                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, sym::Argument));\n                 Some(self.ecx.expr_struct(\n                     sp,\n                     path,\n                     vec![\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"position\", sp), pos),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"format\", sp), fmt),\n+                        self.ecx.field_imm(sp, Ident::new(sym::position, sp), pos),\n+                        self.ecx.field_imm(sp, Ident::new(sym::format, sp), fmt),\n                     ],\n                 ))\n             }\n@@ -740,7 +740,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         let mut heads = Vec::with_capacity(self.args.len());\n \n         let names_pos: Vec<_> = (0..self.args.len())\n-            .map(|i| self.ecx.ident_of(&format!(\"arg{}\", i), self.macsp))\n+            .map(|i| Ident::from_str_and_span(&format!(\"arg{}\", i), self.macsp))\n             .collect();\n \n         // First, build up the static array which will become our precompiled"}, {"sha": "89446a1aa96f9a79346ef5421910b41154890f61", "filename": "src/librustc_builtin_macros/global_allocator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs?ref=9f0080801da75c596cd8548ffb539bb8f046fa62", "patch": "@@ -58,7 +58,7 @@ impl AllocFnFactory<'_, '_> {\n         let mut abi_args = Vec::new();\n         let mut i = 0;\n         let mut mk = || {\n-            let name = self.cx.ident_of(&format!(\"arg{}\", i), self.span);\n+            let name = Ident::from_str_and_span(&format!(\"arg{}\", i), self.span);\n             i += 1;\n             name\n         };\n@@ -72,7 +72,7 @@ impl AllocFnFactory<'_, '_> {\n         let kind = ItemKind::Fn(ast::Defaultness::Final, sig, Generics::default(), block);\n         let item = self.cx.item(\n             self.span,\n-            self.cx.ident_of(&self.kind.fn_name(method.name), self.span),\n+            Ident::from_str_and_span(&self.kind.fn_name(method.name), self.span),\n             self.attrs(),\n             kind,\n         );"}, {"sha": "f044ce41e879ee8ff3782550c620f334beddcd9e", "filename": "src/librustc_builtin_macros/proc_macro_harness.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs?ref=9f0080801da75c596cd8548ffb539bb8f046fa62", "patch": "@@ -384,12 +384,12 @@ fn mk_decls(\n     let proc_macro = Ident::new(sym::proc_macro, span);\n     let krate = cx.item(span, proc_macro, Vec::new(), ast::ItemKind::ExternCrate(None));\n \n-    let bridge = cx.ident_of(\"bridge\", span);\n-    let client = cx.ident_of(\"client\", span);\n-    let proc_macro_ty = cx.ident_of(\"ProcMacro\", span);\n-    let custom_derive = cx.ident_of(\"custom_derive\", span);\n-    let attr = cx.ident_of(\"attr\", span);\n-    let bang = cx.ident_of(\"bang\", span);\n+    let bridge = Ident::new(sym::bridge, span);\n+    let client = Ident::new(sym::client, span);\n+    let proc_macro_ty = Ident::new(sym::ProcMacro, span);\n+    let custom_derive = Ident::new(sym::custom_derive, span);\n+    let attr = Ident::new(sym::attr, span);\n+    let bang = Ident::new(sym::bang, span);\n \n     let krate_ref = RefCell::new(ast_krate);\n \n@@ -447,7 +447,7 @@ fn mk_decls(\n     let decls_static = cx\n         .item_static(\n             span,\n-            cx.ident_of(\"_DECLS\", span),\n+            Ident::new(sym::_DECLS, span),\n             cx.ty_rptr(\n                 span,\n                 cx.ty("}, {"sha": "460f947a792af5975b7627f6e7f003ec7b81d021", "filename": "src/librustc_builtin_macros/test.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest.rs?ref=9f0080801da75c596cd8548ffb539bb8f046fa62", "patch": "@@ -108,22 +108,38 @@ pub fn expand_test_or_bench(\n     let test_id = Ident::new(sym::test, attr_sp);\n \n     // creates test::$name\n-    let test_path = |name| cx.path(sp, vec![test_id, cx.ident_of(name, sp)]);\n+    let test_path = |name| cx.path(sp, vec![test_id, Ident::from_str_and_span(name, sp)]);\n \n     // creates test::ShouldPanic::$name\n-    let should_panic_path =\n-        |name| cx.path(sp, vec![test_id, cx.ident_of(\"ShouldPanic\", sp), cx.ident_of(name, sp)]);\n+    let should_panic_path = |name| {\n+        cx.path(\n+            sp,\n+            vec![\n+                test_id,\n+                Ident::from_str_and_span(\"ShouldPanic\", sp),\n+                Ident::from_str_and_span(name, sp),\n+            ],\n+        )\n+    };\n \n     // creates test::TestType::$name\n-    let test_type_path =\n-        |name| cx.path(sp, vec![test_id, cx.ident_of(\"TestType\", sp), cx.ident_of(name, sp)]);\n+    let test_type_path = |name| {\n+        cx.path(\n+            sp,\n+            vec![\n+                test_id,\n+                Ident::from_str_and_span(\"TestType\", sp),\n+                Ident::from_str_and_span(name, sp),\n+            ],\n+        )\n+    };\n \n     // creates $name: $expr\n-    let field = |name, expr| cx.field_imm(sp, cx.ident_of(name, sp), expr);\n+    let field = |name, expr| cx.field_imm(sp, Ident::from_str_and_span(name, sp), expr);\n \n     let test_fn = if is_bench {\n         // A simple ident for a lambda\n-        let b = cx.ident_of(\"b\", attr_sp);\n+        let b = Ident::from_str_and_span(\"b\", attr_sp);\n \n         cx.expr_call(\n             sp,"}, {"sha": "98c5c6936d779d07199d701029e647d529e8700f", "filename": "src/librustc_builtin_macros/test_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest_harness.rs?ref=9f0080801da75c596cd8548ffb539bb8f046fa62", "patch": "@@ -270,7 +270,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     let mut test_runner = cx\n         .test_runner\n         .clone()\n-        .unwrap_or(ecx.path(sp, vec![test_id, ecx.ident_of(runner_name, sp)]));\n+        .unwrap_or(ecx.path(sp, vec![test_id, Ident::from_str_and_span(runner_name, sp)]));\n \n     test_runner.span = sp;\n "}, {"sha": "64e2d5b3a467c84fd18b28223e40141680d8431b", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=9f0080801da75c596cd8548ffb539bb8f046fa62", "patch": "@@ -1061,9 +1061,6 @@ impl<'a> ExtCtxt<'a> {\n     pub fn set_trace_macros(&mut self, x: bool) {\n         self.ecfg.trace_mac = x\n     }\n-    pub fn ident_of(&self, st: &str, sp: Span) -> Ident {\n-        Ident::from_str_and_span(st, sp)\n-    }\n     pub fn std_path(&self, components: &[Symbol]) -> Vec<Ident> {\n         let def_site = self.with_def_site_ctxt(DUMMY_SP);\n         iter::once(Ident::new(kw::DollarCrate, def_site))"}, {"sha": "81ff4b3157845e94b65b29cf19aa757ba8265a92", "filename": "src/librustc_expand/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_expand%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_expand%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbuild.rs?ref=9f0080801da75c596cd8548ffb539bb8f046fa62", "patch": "@@ -368,7 +368,7 @@ impl<'a> ExtCtxt<'a> {\n         let err = self.std_path(&[sym::result, sym::Result, sym::Err]);\n         let err_path = self.path_global(sp, err);\n \n-        let binding_variable = self.ident_of(\"__try_var\", sp);\n+        let binding_variable = Ident::new(sym::__try_var, sp);\n         let binding_pat = self.pat_ident(sp, binding_variable);\n         let binding_expr = self.expr_ident(sp, binding_variable);\n "}, {"sha": "c4c6fcec4dc5ac1e18337c2d963bb12465b929b2", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f0080801da75c596cd8548ffb539bb8f046fa62/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=9f0080801da75c596cd8548ffb539bb8f046fa62", "patch": "@@ -122,19 +122,28 @@ symbols! {\n     // There is currently no checking that all symbols are used; that would be\n     // nice to have.\n     Symbols {\n+        Alignment,\n         Arc,\n+        Argument,\n         ArgumentV1,\n         Arguments,\n         C,\n+        Center,\n         Clone,\n         Copy,\n+        Count,\n         Debug,\n         Decodable,\n+        Decoder,\n         Default,\n         Encodable,\n+        Encoder,\n         Eq,\n         Equal,\n         Err,\n+        Error,\n+        FormatSpec,\n+        Formatter,\n         From,\n         Future,\n         FxHashMap,\n@@ -143,23 +152,29 @@ symbols! {\n         Hash,\n         HashMap,\n         HashSet,\n+        Hasher,\n+        Implied,\n         Input,\n         IntoIterator,\n+        Is,\n         ItemContext,\n         Iterator,\n         Layout,\n+        Left,\n         LintPass,\n         None,\n         Ok,\n         Option,\n         Ord,\n         Ordering,\n         Output,\n+        Param,\n         PartialEq,\n         PartialOrd,\n         Pending,\n         Pin,\n         Poll,\n+        ProcMacro,\n         ProcMacroHack,\n         ProceduralMasqueradeDummyType,\n         Range,\n@@ -172,20 +187,31 @@ symbols! {\n         Ready,\n         Result,\n         Return,\n+        Right,\n         RustcDecodable,\n         RustcEncodable,\n         Send,\n         Some,\n+        StructuralEq,\n+        StructuralPartialEq,\n         Sync,\n         Target,\n         Try,\n         Ty,\n         TyCtxt,\n         TyKind,\n+        Unknown,\n         Vec,\n         Yield,\n+        _DECLS,\n         _Self,\n+        __D,\n+        __H,\n+        __S,\n         __next,\n+        __try_var,\n+        _d,\n+        _e,\n         _task_context,\n         aarch64_target_feature,\n         abi,\n@@ -256,6 +282,7 @@ symbols! {\n         automatically_derived,\n         avx512_target_feature,\n         await_macro,\n+        bang,\n         begin_panic,\n         bench,\n         bin,\n@@ -278,6 +305,7 @@ symbols! {\n         box_syntax,\n         braced_empty_structs,\n         breakpoint,\n+        bridge,\n         bswap,\n         c_variadic,\n         call,\n@@ -299,6 +327,7 @@ symbols! {\n         cfg_target_vendor,\n         cfg_version,\n         char,\n+        client,\n         clippy,\n         clone,\n         clone_closures,\n@@ -370,11 +399,15 @@ symbols! {\n         custom_derive,\n         custom_inner_attributes,\n         custom_test_frameworks,\n+        d,\n         dead_code,\n         dealloc,\n         debug,\n         debug_assertions,\n+        debug_struct,\n         debug_trait,\n+        debug_trait_builder,\n+        debug_tuple,\n         decl_macro,\n         declare_lint_pass,\n         decode,\n@@ -420,6 +453,11 @@ symbols! {\n         dyn_trait,\n         eh_catch_typeinfo,\n         eh_personality,\n+        emit_enum,\n+        emit_enum_variant,\n+        emit_enum_variant_arg,\n+        emit_struct,\n+        emit_struct_field,\n         enable,\n         enclosing_scope,\n         encode,\n@@ -447,6 +485,7 @@ symbols! {\n         extern_prelude,\n         extern_types,\n         external_doc,\n+        f,\n         f16c_target_feature,\n         f32,\n         f32_runtime,\n@@ -463,6 +502,9 @@ symbols! {\n         field,\n         field_init_shorthand,\n         file,\n+        fill,\n+        finish,\n+        flags,\n         float_to_int_unchecked,\n         floorf32,\n         floorf64,\n@@ -477,6 +519,7 @@ symbols! {\n         fn_once_output,\n         forbid,\n         forget,\n+        format,\n         format_args,\n         format_args_capture,\n         format_args_nl,\n@@ -518,6 +561,7 @@ symbols! {\n         html_no_source,\n         html_playground_url,\n         html_root_url,\n+        i,\n         i128,\n         i128_type,\n         i16,\n@@ -707,6 +751,7 @@ symbols! {\n         options,\n         or,\n         or_patterns,\n+        other,\n         out,\n         overlapping_marker_traits,\n         owned_box,\n@@ -738,6 +783,7 @@ symbols! {\n         plugins,\n         pointer,\n         poll,\n+        position,\n         post_dash_lto: \"post-lto\",\n         powerpc_target_feature,\n         powf32,\n@@ -746,6 +792,7 @@ symbols! {\n         powif64,\n         pre_dash_lto: \"pre-lto\",\n         precise_pointer_size_matching,\n+        precision,\n         pref_align_of,\n         prefetch_read_data,\n         prefetch_read_instruction,\n@@ -782,6 +829,11 @@ symbols! {\n         raw_identifiers,\n         raw_ref_op,\n         re_rebalance_coherence,\n+        read_enum,\n+        read_enum_variant,\n+        read_enum_variant_arg,\n+        read_struct,\n+        read_struct_field,\n         readonly,\n         realloc,\n         reason,\n@@ -871,6 +923,7 @@ symbols! {\n         rustc_promotable,\n         rustc_regions,\n         rustc_reservation_impl,\n+        rustc_serialize,\n         rustc_specialization_trait,\n         rustc_stable,\n         rustc_std_internal_symbol,\n@@ -974,6 +1027,7 @@ symbols! {\n         stable,\n         staged_api,\n         start,\n+        state,\n         static_in_const,\n         static_nobundle,\n         static_recursion,\n@@ -1121,6 +1175,7 @@ symbols! {\n         wasm_import_module,\n         wasm_target_feature,\n         while_let,\n+        width,\n         windows,\n         windows_subsystem,\n         wrapping_add,"}]}