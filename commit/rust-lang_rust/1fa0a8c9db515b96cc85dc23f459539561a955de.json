{"sha": "1fa0a8c9db515b96cc85dc23f459539561a955de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmYTBhOGM5ZGI1MTViOTZjYzg1ZGMyM2Y0NTk1Mzk1NjFhOTU1ZGU=", "commit": {"author": {"name": "Dmitry Ermolov", "email": "epdmitry@yandex.ru", "date": "2013-08-06T07:08:50Z"}, "committer": {"name": "Dmitry Ermolov", "email": "epdmitry@yandex.ru", "date": "2013-08-06T19:59:51Z"}, "message": "Hide stuff that are not used outside of _match.rs", "tree": {"sha": "9aa899da72e35a8eae3d02cd45011d0a6271e4f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9aa899da72e35a8eae3d02cd45011d0a6271e4f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fa0a8c9db515b96cc85dc23f459539561a955de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fa0a8c9db515b96cc85dc23f459539561a955de", "html_url": "https://github.com/rust-lang/rust/commit/1fa0a8c9db515b96cc85dc23f459539561a955de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fa0a8c9db515b96cc85dc23f459539561a955de/comments", "author": {"login": "dim-an", "id": 88889, "node_id": "MDQ6VXNlcjg4ODg5", "avatar_url": "https://avatars.githubusercontent.com/u/88889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dim-an", "html_url": "https://github.com/dim-an", "followers_url": "https://api.github.com/users/dim-an/followers", "following_url": "https://api.github.com/users/dim-an/following{/other_user}", "gists_url": "https://api.github.com/users/dim-an/gists{/gist_id}", "starred_url": "https://api.github.com/users/dim-an/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dim-an/subscriptions", "organizations_url": "https://api.github.com/users/dim-an/orgs", "repos_url": "https://api.github.com/users/dim-an/repos", "events_url": "https://api.github.com/users/dim-an/events{/privacy}", "received_events_url": "https://api.github.com/users/dim-an/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dim-an", "id": 88889, "node_id": "MDQ6VXNlcjg4ODg5", "avatar_url": "https://avatars.githubusercontent.com/u/88889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dim-an", "html_url": "https://github.com/dim-an", "followers_url": "https://api.github.com/users/dim-an/followers", "following_url": "https://api.github.com/users/dim-an/following{/other_user}", "gists_url": "https://api.github.com/users/dim-an/gists{/gist_id}", "starred_url": "https://api.github.com/users/dim-an/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dim-an/subscriptions", "organizations_url": "https://api.github.com/users/dim-an/orgs", "repos_url": "https://api.github.com/users/dim-an/repos", "events_url": "https://api.github.com/users/dim-an/events{/privacy}", "received_events_url": "https://api.github.com/users/dim-an/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d3c62af9f560866dd8fafc950177b87098bedab", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d3c62af9f560866dd8fafc950177b87098bedab", "html_url": "https://github.com/rust-lang/rust/commit/8d3c62af9f560866dd8fafc950177b87098bedab"}], "stats": {"total": 84, "additions": 42, "deletions": 42}, "files": [{"sha": "e5d45d6ca2185e32f470138b4115f63b50e09020", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/1fa0a8c9db515b96cc85dc23f459539561a955de/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fa0a8c9db515b96cc85dc23f459539561a955de/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=1fa0a8c9db515b96cc85dc23f459539561a955de", "patch": "@@ -183,23 +183,23 @@ use syntax::codemap::{span, dummy_sp};\n \n // An option identifying a literal: either a unit-like struct or an\n // expression.\n-pub enum Lit {\n+enum Lit {\n     UnitLikeStructLit(ast::NodeId),    // the node ID of the pattern\n     ExprLit(@ast::expr),\n     ConstLit(ast::def_id),              // the def ID of the constant\n }\n \n // An option identifying a branch (either a literal, a enum variant or a\n // range)\n-pub enum Opt {\n+enum Opt {\n     lit(Lit),\n     var(/* disr val */ uint, @adt::Repr),\n     range(@ast::expr, @ast::expr),\n     vec_len_eq(uint),\n     vec_len_ge(uint, /* slice */uint)\n }\n \n-pub fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n+fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n     match (a, b) {\n         (&lit(a), &lit(b)) => {\n             match (a, b) {\n@@ -258,7 +258,7 @@ pub enum opt_result {\n     lower_bound(Result),\n     range_result(Result, Result),\n }\n-pub fn trans_opt(bcx: @mut Block, o: &Opt) -> opt_result {\n+fn trans_opt(bcx: @mut Block, o: &Opt) -> opt_result {\n     let _icx = push_ctxt(\"match::trans_opt\");\n     let ccx = bcx.ccx();\n     let bcx = bcx;\n@@ -292,7 +292,7 @@ pub fn trans_opt(bcx: @mut Block, o: &Opt) -> opt_result {\n     }\n }\n \n-pub fn variant_opt(bcx: @mut Block, pat_id: ast::NodeId)\n+fn variant_opt(bcx: @mut Block, pat_id: ast::NodeId)\n     -> Opt {\n     let ccx = bcx.ccx();\n     match ccx.tcx.def_map.get_copy(&pat_id) {\n@@ -317,7 +317,7 @@ pub fn variant_opt(bcx: @mut Block, pat_id: ast::NodeId)\n }\n \n #[deriving(Clone)]\n-pub enum TransBindingMode {\n+enum TransBindingMode {\n     TrByValue(/*llbinding:*/ ValueRef),\n     TrByRef,\n }\n@@ -331,24 +331,24 @@ pub enum TransBindingMode {\n  * - `id` is the node id of the binding\n  * - `ty` is the Rust type of the binding */\n  #[deriving(Clone)]\n-pub struct BindingInfo {\n+struct BindingInfo {\n     llmatch: ValueRef,\n     trmode: TransBindingMode,\n     id: ast::NodeId,\n     ty: ty::t,\n }\n \n-pub type BindingsMap = HashMap<ident, BindingInfo>;\n+type BindingsMap = HashMap<ident, BindingInfo>;\n \n #[deriving(Clone)]\n-pub struct ArmData<'self> {\n+struct ArmData<'self> {\n     bodycx: @mut Block,\n     arm: &'self ast::arm,\n     bindings_map: @BindingsMap\n }\n \n #[deriving(Clone)]\n-pub struct Match<'self> {\n+struct Match<'self> {\n     pats: ~[@ast::pat],\n     data: ArmData<'self>\n }\n@@ -364,7 +364,7 @@ impl<'self> Repr for Match<'self> {\n     }\n }\n \n-pub fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n+fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n     for br in m.iter() {\n         match br.pats[col].node {\n           ast::pat_ident(_, _, Some(_)) => return true,\n@@ -374,7 +374,7 @@ pub fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n     return false;\n }\n \n-pub fn expand_nested_bindings<'r>(bcx: @mut Block,\n+fn expand_nested_bindings<'r>(bcx: @mut Block,\n                                   m: &[Match<'r>],\n                                   col: uint,\n                                   val: ValueRef)\n@@ -409,7 +409,7 @@ pub fn expand_nested_bindings<'r>(bcx: @mut Block,\n     }\n }\n \n-pub fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::pat) {\n+fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::pat) {\n     if !pat_is_binding_or_wild(bcx.tcx().def_map, p) {\n         bcx.sess().span_bug(\n             p.span,\n@@ -418,9 +418,9 @@ pub fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::pat) {\n     }\n }\n \n-pub type enter_pat<'self> = &'self fn(@ast::pat) -> Option<~[@ast::pat]>;\n+type enter_pat<'self> = &'self fn(@ast::pat) -> Option<~[@ast::pat]>;\n \n-pub fn enter_match<'r>(bcx: @mut Block,\n+fn enter_match<'r>(bcx: @mut Block,\n                        dm: DefMap,\n                        m: &[Match<'r>],\n                        col: uint,\n@@ -470,7 +470,7 @@ pub fn enter_match<'r>(bcx: @mut Block,\n     return result;\n }\n \n-pub fn enter_default<'r>(bcx: @mut Block,\n+fn enter_default<'r>(bcx: @mut Block,\n                          dm: DefMap,\n                          m: &[Match<'r>],\n                          col: uint,\n@@ -516,7 +516,7 @@ pub fn enter_default<'r>(bcx: @mut Block,\n // <nmatsakis> so all patterns must either be records (resp. tuples) or\n //             wildcards\n \n-pub fn enter_opt<'r>(bcx: @mut Block,\n+fn enter_opt<'r>(bcx: @mut Block,\n                      m: &[Match<'r>],\n                      opt: &Opt,\n                      col: uint,\n@@ -628,7 +628,7 @@ pub fn enter_opt<'r>(bcx: @mut Block,\n     }\n }\n \n-pub fn enter_rec_or_struct<'r>(bcx: @mut Block,\n+fn enter_rec_or_struct<'r>(bcx: @mut Block,\n                                dm: DefMap,\n                                m: &[Match<'r>],\n                                col: uint,\n@@ -663,7 +663,7 @@ pub fn enter_rec_or_struct<'r>(bcx: @mut Block,\n     }\n }\n \n-pub fn enter_tup<'r>(bcx: @mut Block,\n+fn enter_tup<'r>(bcx: @mut Block,\n                      dm: DefMap,\n                      m: &[Match<'r>],\n                      col: uint,\n@@ -689,7 +689,7 @@ pub fn enter_tup<'r>(bcx: @mut Block,\n     }\n }\n \n-pub fn enter_tuple_struct<'r>(bcx: @mut Block,\n+fn enter_tuple_struct<'r>(bcx: @mut Block,\n                               dm: DefMap,\n                               m: &[Match<'r>],\n                               col: uint,\n@@ -715,7 +715,7 @@ pub fn enter_tuple_struct<'r>(bcx: @mut Block,\n     }\n }\n \n-pub fn enter_box<'r>(bcx: @mut Block,\n+fn enter_box<'r>(bcx: @mut Block,\n                      dm: DefMap,\n                      m: &[Match<'r>],\n                      col: uint,\n@@ -742,7 +742,7 @@ pub fn enter_box<'r>(bcx: @mut Block,\n     }\n }\n \n-pub fn enter_uniq<'r>(bcx: @mut Block,\n+fn enter_uniq<'r>(bcx: @mut Block,\n                       dm: DefMap,\n                       m: &[Match<'r>],\n                       col: uint,\n@@ -769,7 +769,7 @@ pub fn enter_uniq<'r>(bcx: @mut Block,\n     }\n }\n \n-pub fn enter_region<'r>(bcx: @mut Block,\n+fn enter_region<'r>(bcx: @mut Block,\n                         dm: DefMap,\n                         m: &[Match<'r>],\n                         col: uint,\n@@ -799,7 +799,7 @@ pub fn enter_region<'r>(bcx: @mut Block,\n // Returns the options in one column of matches. An option is something that\n // needs to be conditionally matched at runtime; for example, the discriminant\n // on a set of enum variants or a literal.\n-pub fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n+fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n     let ccx = bcx.ccx();\n     fn add_to_set(tcx: ty::ctxt, set: &mut ~[Opt], val: Opt) {\n         if set.iter().any(|l| opt_eq(tcx, l, &val)) {return;}\n@@ -865,12 +865,12 @@ pub fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n     return found;\n }\n \n-pub struct ExtractedBlock {\n+struct ExtractedBlock {\n     vals: ~[ValueRef],\n     bcx: @mut Block\n }\n \n-pub fn extract_variant_args(bcx: @mut Block,\n+fn extract_variant_args(bcx: @mut Block,\n                             repr: &adt::Repr,\n                             disr_val: uint,\n                             val: ValueRef)\n@@ -893,7 +893,7 @@ fn match_datum(bcx: @mut Block, val: ValueRef, pat_id: ast::NodeId) -> Datum {\n }\n \n \n-pub fn extract_vec_elems(bcx: @mut Block,\n+fn extract_vec_elems(bcx: @mut Block,\n                          pat_span: span,\n                          pat_id: ast::NodeId,\n                          elem_count: uint,\n@@ -948,7 +948,7 @@ pub fn extract_vec_elems(bcx: @mut Block,\n }\n \n // NB: This function does not collect fields from struct-like enum variants.\n-pub fn collect_record_or_struct_fields(bcx: @mut Block,\n+fn collect_record_or_struct_fields(bcx: @mut Block,\n                                        m: &[Match],\n                                        col: uint)\n                                     -> ~[ast::ident] {\n@@ -976,7 +976,7 @@ pub fn collect_record_or_struct_fields(bcx: @mut Block,\n     }\n }\n \n-pub fn pats_require_rooting(bcx: @mut Block,\n+fn pats_require_rooting(bcx: @mut Block,\n                             m: &[Match],\n                             col: uint)\n                          -> bool {\n@@ -987,7 +987,7 @@ pub fn pats_require_rooting(bcx: @mut Block,\n     }\n }\n \n-pub fn root_pats_as_necessary(mut bcx: @mut Block,\n+fn root_pats_as_necessary(mut bcx: @mut Block,\n                               m: &[Match],\n                               col: uint,\n                               val: ValueRef)\n@@ -1018,23 +1018,23 @@ macro_rules! any_pat (\n     )\n )\n \n-pub fn any_box_pat(m: &[Match], col: uint) -> bool {\n+fn any_box_pat(m: &[Match], col: uint) -> bool {\n     any_pat!(m, ast::pat_box(_))\n }\n \n-pub fn any_uniq_pat(m: &[Match], col: uint) -> bool {\n+fn any_uniq_pat(m: &[Match], col: uint) -> bool {\n     any_pat!(m, ast::pat_uniq(_))\n }\n \n-pub fn any_region_pat(m: &[Match], col: uint) -> bool {\n+fn any_region_pat(m: &[Match], col: uint) -> bool {\n     any_pat!(m, ast::pat_region(_))\n }\n \n-pub fn any_tup_pat(m: &[Match], col: uint) -> bool {\n+fn any_tup_pat(m: &[Match], col: uint) -> bool {\n     any_pat!(m, ast::pat_tup(_))\n }\n \n-pub fn any_tuple_struct_pat(bcx: @mut Block, m: &[Match], col: uint) -> bool {\n+fn any_tuple_struct_pat(bcx: @mut Block, m: &[Match], col: uint) -> bool {\n     do m.iter().any |br| {\n         let pat = br.pats[col];\n         match pat.node {\n@@ -1050,9 +1050,9 @@ pub fn any_tuple_struct_pat(bcx: @mut Block, m: &[Match], col: uint) -> bool {\n     }\n }\n \n-pub type mk_fail = @fn() -> BasicBlockRef;\n+type mk_fail = @fn() -> BasicBlockRef;\n \n-pub fn pick_col(m: &[Match]) -> uint {\n+fn pick_col(m: &[Match]) -> uint {\n     fn score(p: &ast::pat) -> uint {\n         match p.node {\n           ast::pat_lit(_) | ast::pat_enum(_, _) | ast::pat_range(_, _) => 1u,\n@@ -1088,7 +1088,7 @@ pub enum branch_kind { no_branch, single, switch, compare, compare_vec_len, }\n // Compiles a comparison between two things.\n //\n // NB: This must produce an i1, not a Rust bool (i8).\n-pub fn compare_values(cx: @mut Block,\n+fn compare_values(cx: @mut Block,\n                       lhs: ValueRef,\n                       rhs: ValueRef,\n                       rhs_t: ty::t)\n@@ -1204,7 +1204,7 @@ fn insert_lllocals(bcx: @mut Block,\n     return bcx;\n }\n \n-pub fn compile_guard(bcx: @mut Block,\n+fn compile_guard(bcx: @mut Block,\n                      guard_expr: @ast::expr,\n                      data: &ArmData,\n                      m: &[Match],\n@@ -1261,7 +1261,7 @@ pub fn compile_guard(bcx: @mut Block,\n     }\n }\n \n-pub fn compile_submatch(bcx: @mut Block,\n+fn compile_submatch(bcx: @mut Block,\n                         m: &[Match],\n                         vals: &[ValueRef],\n                         chk: Option<mk_fail>) {\n@@ -1670,7 +1670,7 @@ fn create_bindings_map(bcx: @mut Block, pat: @ast::pat) -> BindingsMap {\n     return bindings_map;\n }\n \n-pub fn trans_match_inner(scope_cx: @mut Block,\n+fn trans_match_inner(scope_cx: @mut Block,\n                          discr_expr: @ast::expr,\n                          arms: &[ast::arm],\n                          dest: Dest) -> @mut Block {\n@@ -1752,7 +1752,7 @@ pub fn trans_match_inner(scope_cx: @mut Block,\n     }\n }\n \n-pub enum IrrefutablePatternBindingMode {\n+enum IrrefutablePatternBindingMode {\n     // Stores the association between node ID and LLVM value in `lllocals`.\n     BindLocal,\n     // Stores the association between node ID and LLVM value in `llargs`."}]}