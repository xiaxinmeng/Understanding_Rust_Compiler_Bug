{"sha": "498e0fba7f5d614c8165b41204e05c5ad461d25d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5OGUwZmJhN2Y1ZDYxNGM4MTY1YjQxMjA0ZTA1YzVhZDQ2MWQyNWQ=", "commit": {"author": {"name": "Taylor Cramer", "email": "cramertj@cs.washington.edu", "date": "2016-03-25T09:42:27Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-04-02T13:32:36Z"}, "message": "Initial attempt at linting invalid upcast comparisons", "tree": {"sha": "e0f1117485abf48b95c9eb49ab3b1ede6d516e98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0f1117485abf48b95c9eb49ab3b1ede6d516e98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/498e0fba7f5d614c8165b41204e05c5ad461d25d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/498e0fba7f5d614c8165b41204e05c5ad461d25d", "html_url": "https://github.com/rust-lang/rust/commit/498e0fba7f5d614c8165b41204e05c5ad461d25d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/498e0fba7f5d614c8165b41204e05c5ad461d25d/comments", "author": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c150ae782414da13ee6202b153c38aee50eb4ea4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c150ae782414da13ee6202b153c38aee50eb4ea4", "html_url": "https://github.com/rust-lang/rust/commit/c150ae782414da13ee6202b153c38aee50eb4ea4"}], "stats": {"total": 240, "additions": 228, "deletions": 12}, "files": [{"sha": "6834753adf0e5a44e215677350735734aca27f89", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/498e0fba7f5d614c8165b41204e05c5ad461d25d/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e0fba7f5d614c8165b41204e05c5ad461d25d/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=498e0fba7f5d614c8165b41204e05c5ad461d25d", "patch": "@@ -221,6 +221,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     });\n     reg.register_late_lint_pass(box drop_ref::DropRefPass);\n     reg.register_late_lint_pass(box types::AbsurdExtremeComparisons);\n+    reg.register_late_lint_pass(box types::InvalidUpcastComparisons);\n     reg.register_late_lint_pass(box regex::RegexPass::default());\n     reg.register_late_lint_pass(box copies::CopyAndPaste);\n     reg.register_late_lint_pass(box format::FormatMacLint);\n@@ -367,6 +368,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         transmute::TRANSMUTE_PTR_TO_REF,\n         transmute::USELESS_TRANSMUTE,\n         types::ABSURD_EXTREME_COMPARISONS,\n+        types::INVALID_UPCAST_COMPARISONS,\n         types::BOX_VEC,\n         types::CHAR_LIT_AS_U8,\n         types::LET_UNIT_VALUE,"}, {"sha": "6f08b57b55ada65ca04b2b725a0191f6dd83584c", "filename": "src/types.rs", "status": "modified", "additions": 211, "deletions": 12, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/498e0fba7f5d614c8165b41204e05c5ad461d25d/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e0fba7f5d614c8165b41204e05c5ad461d25d/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=498e0fba7f5d614c8165b41204e05c5ad461d25d", "patch": "@@ -1,14 +1,18 @@\n use reexport::*;\n+use rustc_const_eval::*;\n use rustc::lint::*;\n use rustc::middle::def;\n use rustc::ty;\n+use rustc::middle::const_eval::ConstVal::Integral;\n+use rustc_const_eval;\n use rustc_front::hir::*;\n use rustc_front::intravisit::{FnKind, Visitor, walk_ty};\n use rustc_front::util::{is_comparison_binop, binop_to_string};\n use syntax::ast::{IntTy, UintTy, FloatTy};\n use syntax::codemap::Span;\n use utils::*;\n \n+\n /// Handles all the linting of funky types\n #[allow(missing_copy_implementations)]\n pub struct TypePass;\n@@ -640,24 +644,32 @@ enum AbsurdComparisonResult {\n     InequalityImpossible,\n }\n \n+enum Rel {\n+    Lt,\n+    Le,\n+}\n+\n+// Put the expression in the form lhs < rhs or lhs <= rhs.\n+fn normalize_comparison<'a>(op: BinOp_, lhs: &'a Expr, rhs: &'a Expr)\n+                                -> Option<(Rel, &'a Expr, &'a Expr)> {\n+    match op {\n+        BiLt => Some((Rel::Lt, lhs, rhs)),\n+        BiLe => Some((Rel::Le, lhs, rhs)),\n+        BiGt => Some((Rel::Lt, rhs, lhs)),\n+        BiGe => Some((Rel::Le, rhs, lhs)),\n+        _ => return None,\n+    }\n+}\n+\n fn detect_absurd_comparison<'a>(cx: &LateContext, op: BinOp_, lhs: &'a Expr, rhs: &'a Expr)\n                                 -> Option<(ExtremeExpr<'a>, AbsurdComparisonResult)> {\n     use types::ExtremeType::*;\n     use types::AbsurdComparisonResult::*;\n     type Extr<'a> = ExtremeExpr<'a>;\n \n-    // Put the expression in the form lhs < rhs or lhs <= rhs.\n-    enum Rel {\n-        Lt,\n-        Le,\n-    };\n-    let (rel, normalized_lhs, normalized_rhs) = match op {\n-        BiLt => (Rel::Lt, lhs, rhs),\n-        BiLe => (Rel::Le, lhs, rhs),\n-        BiGt => (Rel::Lt, rhs, lhs),\n-        BiGe => (Rel::Le, rhs, lhs),\n-        _ => return None,\n-    };\n+    let normalized = normalize_comparison(op, lhs, rhs);\n+    if normalized.is_none() { return None; } // Could be an if let, but this prevents rightward drift\n+    let (rel, normalized_lhs, normalized_rhs) = normalized.unwrap();\n \n     let lx = detect_extreme_expr(cx, normalized_lhs);\n     let rx = detect_extreme_expr(cx, normalized_rhs);\n@@ -778,3 +790,190 @@ impl LateLintPass for AbsurdExtremeComparisons {\n         }\n     }\n }\n+\n+/// **What it does:** This lint checks for comparisons where the relation is always either true or false, but where one side has been upcast so that the comparison is necessary. Only integer types are checked.\n+///\n+/// **Why is this bad?** An expression like `let x : u8 = ...; (x as u32) > 300` will mistakenly imply that it is possible for `x` to be outside the range of `u8`.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `let x : u8 = ...; (x as u32) > 300`\n+declare_lint! {\n+    pub INVALID_UPCAST_COMPARISONS, Warn,\n+    \"a comparison involving an term's upcasting to be within the range of the other side of the \\\n+    term is always true or false\"\n+}\n+\n+pub struct InvalidUpcastComparisons;\n+\n+impl LintPass for InvalidUpcastComparisons {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(INVALID_UPCAST_COMPARISONS)\n+    }\n+}\n+\n+enum FullInt {\n+    S(i64),\n+    U(u64),\n+}\n+\n+use std;\n+use self::FullInt::*;\n+use std::cmp::Ordering::*;\n+\n+impl FullInt {\n+    fn cmp_s_u(s: &i64, u: &u64) -> std::cmp::Ordering {\n+        if *s < 0 {\n+            Less\n+        } else if *u > (i64::max_value() as u64) {\n+            Greater\n+        } else {\n+            (*s as u64).cmp(u)\n+        }\n+    }\n+}\n+\n+impl PartialEq for FullInt {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.cmp(other) == Equal\n+    }\n+}\n+impl Eq for FullInt {}\n+\n+impl PartialOrd for FullInt {\n+    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n+        Some(match (self, other) {\n+            (&S(ref s), &S(ref o)) => s.cmp(o),\n+            (&U(ref s), &U(ref o)) => s.cmp(o),\n+            (&S(ref s), &U(ref o)) => Self::cmp_s_u(s, o),\n+            (&U(ref s), &S(ref o)) => Self::cmp_s_u(o, s).reverse(),\n+        })\n+    }\n+}\n+impl Ord for FullInt {\n+    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n+        self.partial_cmp(other).unwrap()\n+    }\n+}\n+\n+\n+fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(FullInt, FullInt)> {\n+    use rustc::middle::const_eval::EvalHint::ExprTypeChecked;\n+\n+    if let ExprCast(ref cast_exp,_) = expr.node {\n+        let cv = match const_eval::eval_const_expr_partial(cx.tcx, cast_exp, ExprTypeChecked, None) {\n+            Ok(val) => val,\n+            Err(_) => return None,\n+        };\n+\n+        if let Integral(const_int) = cv {\n+            Some(match const_int {\n+                I8(_) => (S(i8::min_value() as i64), S(i8::max_value() as i64)),\n+                I16(_) => (S(i16::min_value() as i64), S(i16::max_value() as i64)),\n+                I32(_) => (S(i32::min_value() as i64), S(i32::max_value() as i64)),\n+                Isize(_) |\n+                I64(_) |\n+                InferSigned(_) => (S(i64::max_value()), S(i64::max_value())),\n+                U8(_) => (U(u8::min_value() as u64), U(u8::max_value() as u64)),\n+                U16(_) => (U(u16::min_value() as u64), U(u16::max_value() as u64)),\n+                U32(_) => (U(u32::min_value() as u64), U(u32::max_value() as u64)),\n+                Usize(_) |\n+                U64(_) |\n+                Infer(_) => (U(u64::max_value()), U(u64::max_value())),\n+            })\n+        } else {\n+            None\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+fn node_as_const_fullint(cx: &LateContext, expr: &Expr) -> Option<FullInt> {\n+    use rustc::middle::const_eval::EvalHint::ExprTypeChecked;\n+\n+    match const_eval::eval_const_expr_partial(cx.tcx, expr, ExprTypeChecked, None) {\n+        Ok(val) => {\n+            if let Integral(const_int) = val {\n+                Some(match const_int {\n+                    I8(x) => S(x as i64),\n+                    I16(x) => S(x as i64),\n+                    I32(x) => S(x as i64),\n+                    Isize(x) => S(match x {\n+                        Is32(x_) => x_ as i64,\n+                        Is64(x_) => x_\n+                    }),\n+                    I64(x) => S(x),\n+                    InferSigned(x) => S(x as i64),\n+                    U8(x) => U(x as u64),\n+                    U16(x) => U(x as u64),\n+                    U32(x) => U(x as u64),\n+                    Usize(x) => U(match x {\n+                        Us32(x_) => x_ as u64,\n+                        Us64(x_) => x_,\n+                    }),\n+                    U64(x) => U(x),\n+                    Infer(x) => U(x as u64),\n+                })\n+            } else {\n+                None\n+            }\n+        },\n+        Err(_) => return None,\n+    }\n+}\n+\n+impl LateLintPass for InvalidUpcastComparisons {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+        if let ExprBinary(ref cmp, ref lhs, ref rhs) = expr.node {\n+            let normalized = normalize_comparison(cmp.node, lhs, rhs);\n+            if normalized.is_none() { return; }\n+            let (rel, normalized_lhs, normalized_rhs) = normalized.unwrap();\n+\n+            let norm_lhs_bounds = numeric_cast_precast_bounds(cx, normalized_lhs);\n+            let norm_rhs_bounds = numeric_cast_precast_bounds(cx, normalized_rhs);\n+\n+            if let Some(nlb) = norm_lhs_bounds {\n+                if let Some(norm_rhs_val) = node_as_const_fullint(cx, normalized_rhs) {\n+                    if match rel {\n+                        Rel::Lt => nlb.1 < norm_rhs_val,\n+                        Rel::Le => nlb.1 <= norm_rhs_val,\n+                    } {\n+                        // Expression is always true\n+                        cx.span_lint(INVALID_UPCAST_COMPARISONS,\n+                                     expr.span,\n+                                     &format!(\"\"));\n+                    } else if match rel {\n+                        Rel::Lt => nlb.0 >= norm_rhs_val,\n+                        Rel::Le => nlb.0 > norm_rhs_val,\n+                    } {\n+                        // Expression is always false\n+                        cx.span_lint(INVALID_UPCAST_COMPARISONS,\n+                                     expr.span,\n+                                     &format!(\"\"));\n+                    }\n+                }\n+            } else if let Some(nrb) = norm_rhs_bounds {\n+                if let Some(norm_lhs_val) = node_as_const_fullint(cx, normalized_lhs) {\n+                    if match rel {\n+                        Rel::Lt => norm_lhs_val < nrb.0,\n+                        Rel::Le => norm_lhs_val <= nrb.0,\n+                    } {\n+                        // Expression is always true\n+                        cx.span_lint(INVALID_UPCAST_COMPARISONS,\n+                                     expr.span,\n+                                     &format!(\"\"));\n+                    } else if match rel {\n+                        Rel::Lt => norm_lhs_val >= nrb.1,\n+                        Rel::Le => norm_lhs_val > nrb.1,\n+                    } {\n+                        // Expression is always false\n+                        cx.span_lint(INVALID_UPCAST_COMPARISONS,\n+                                     expr.span,\n+                                     &format!(\"\"));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "63ccb6efd9df14ce0ab8478806fcd78a091f2f57", "filename": "tests/compile-fail/invalid_upcast_comparisons.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/498e0fba7f5d614c8165b41204e05c5ad461d25d/tests%2Fcompile-fail%2Finvalid_upcast_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e0fba7f5d614c8165b41204e05c5ad461d25d/tests%2Fcompile-fail%2Finvalid_upcast_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Finvalid_upcast_comparisons.rs?ref=498e0fba7f5d614c8165b41204e05c5ad461d25d", "patch": "@@ -0,0 +1,15 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#![deny(invalid_upcast_comparisons)]\n+#![allow(unused, eq_op, no_effect)]\n+fn main() {\n+    let zero: u32 = 0;\n+    let u8_max: u8 = 255;\n+\n+    (u8_max as u32) > 300; //~ERROR\n+    (u8_max as u32) > 20;\n+\n+    (zero as i32) < -5; //~ERROR\n+    (zero as i32) < 10;\n+}"}]}