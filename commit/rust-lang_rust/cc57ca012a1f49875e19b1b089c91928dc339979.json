{"sha": "cc57ca012a1f49875e19b1b089c91928dc339979", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjNTdjYTAxMmExZjQ5ODc1ZTE5YjFiMDg5YzkxOTI4ZGMzMzk5Nzk=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2013-05-19T02:02:45Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2013-05-19T12:16:02Z"}, "message": "Use assert_eq! rather than assert! where possible", "tree": {"sha": "9f10c27962dbb7c844bc3abb7e20119d75f02aa6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f10c27962dbb7c844bc3abb7e20119d75f02aa6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc57ca012a1f49875e19b1b089c91928dc339979", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc57ca012a1f49875e19b1b089c91928dc339979", "html_url": "https://github.com/rust-lang/rust/commit/cc57ca012a1f49875e19b1b089c91928dc339979", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc57ca012a1f49875e19b1b089c91928dc339979/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3acf37897a4ca7f019ed8894ec3878801377773d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3acf37897a4ca7f019ed8894ec3878801377773d", "html_url": "https://github.com/rust-lang/rust/commit/3acf37897a4ca7f019ed8894ec3878801377773d"}], "stats": {"total": 5662, "additions": 2831, "deletions": 2831}, "files": [{"sha": "44c55563ac57f6599127c661508c555416864c35", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -294,30 +294,30 @@ mod test {\n         }\n \n         assert_eq!(seq_range(10, 15), @[10, 11, 12, 13, 14]);\n-        assert!(from_fn(5, |x| x+1) == @[1, 2, 3, 4, 5]);\n-        assert!(from_elem(5, 3.14) == @[3.14, 3.14, 3.14, 3.14, 3.14]);\n+        assert_eq!(from_fn(5, |x| x+1), @[1, 2, 3, 4, 5]);\n+        assert_eq!(from_elem(5, 3.14), @[3.14, 3.14, 3.14, 3.14, 3.14]);\n     }\n \n     #[test]\n     fn append_test() {\n-        assert!(@[1,2,3] + @[4,5,6] == @[1,2,3,4,5,6]);\n+        assert_eq!(@[1,2,3] + @[4,5,6], @[1,2,3,4,5,6]);\n     }\n \n     #[test]\n     fn test_to_managed_consume() {\n-        assert!(to_managed_consume::<int>(~[]) == @[]);\n-        assert!(to_managed_consume(~[true]) == @[true]);\n-        assert!(to_managed_consume(~[1, 2, 3, 4, 5]) == @[1, 2, 3, 4, 5]);\n-        assert!(to_managed_consume(~[~\"abc\", ~\"123\"]) == @[~\"abc\", ~\"123\"]);\n-        assert!(to_managed_consume(~[~[42]]) == @[~[42]]);\n+        assert_eq!(to_managed_consume::<int>(~[]), @[]);\n+        assert_eq!(to_managed_consume(~[true]), @[true]);\n+        assert_eq!(to_managed_consume(~[1, 2, 3, 4, 5]), @[1, 2, 3, 4, 5]);\n+        assert_eq!(to_managed_consume(~[~\"abc\", ~\"123\"]), @[~\"abc\", ~\"123\"]);\n+        assert_eq!(to_managed_consume(~[~[42]]), @[~[42]]);\n     }\n \n     #[test]\n     fn test_to_managed() {\n-        assert!(to_managed::<int>([]) == @[]);\n-        assert!(to_managed([true]) == @[true]);\n-        assert!(to_managed([1, 2, 3, 4, 5]) == @[1, 2, 3, 4, 5]);\n-        assert!(to_managed([@\"abc\", @\"123\"]) == @[@\"abc\", @\"123\"]);\n-        assert!(to_managed([@[42]]) == @[@[42]]);\n+        assert_eq!(to_managed::<int>([]), @[]);\n+        assert_eq!(to_managed([true]), @[true]);\n+        assert_eq!(to_managed([1, 2, 3, 4, 5]), @[1, 2, 3, 4, 5]);\n+        assert_eq!(to_managed([@\"abc\", @\"123\"]), @[@\"abc\", @\"123\"]);\n+        assert_eq!(to_managed([@[42]]), @[@[42]]);\n     }\n }"}, {"sha": "5ab7f838a57cc6ca24e53dfcb1a8ae50de572d53", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -113,14 +113,14 @@ mod tests {\n \n     #[test]\n     fn test_bool_to_str() {\n-        assert!(to_str(false) == ~\"false\");\n-        assert!(to_str(true) == ~\"true\");\n+        assert_eq!(to_str(false), ~\"false\");\n+        assert_eq!(to_str(true), ~\"true\");\n     }\n \n     #[test]\n     fn test_bool_to_bit() {\n         do all_values |v| {\n-            assert!(to_bit(v) == if is_true(v) { 1u8 } else { 0u8 });\n+            assert_eq!(to_bit(v), if is_true(v) { 1u8 } else { 0u8 });\n         }\n     }\n "}, {"sha": "8b48376caac5e7f6f53afdfb3bc9372dc5b6a498", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -145,7 +145,7 @@ mod tests {\n \n     #[test]\n     fn test_transmute_copy() {\n-        assert!(1u == unsafe { ::cast::transmute_copy(&1) });\n+        assert_eq!(1u, unsafe { ::cast::transmute_copy(&1) });\n     }\n \n     #[test]\n@@ -177,7 +177,7 @@ mod tests {\n     #[test]\n     fn test_transmute2() {\n         unsafe {\n-            assert!(~[76u8, 0u8] == transmute(~\"L\"));\n+            assert_eq!(~[76u8, 0u8], transmute(~\"L\"));\n         }\n     }\n }"}, {"sha": "b707e3bbb9efa7fe714bb5d373427508d18cbfc8", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -122,7 +122,7 @@ fn test_with_ref() {\n     let good = 6;\n     let c = Cell(~[1, 2, 3, 4, 5, 6]);\n     let l = do c.with_ref() |v| { v.len() };\n-    assert!(l == good);\n+    assert_eq!(l, good);\n }\n \n #[test]\n@@ -132,5 +132,5 @@ fn test_with_mut_ref() {\n     let c = Cell(v);\n     do c.with_mut_ref() |v| { v.push(3); }\n     let v = c.take();\n-    assert!(v == good);\n+    assert_eq!(v, good);\n }"}, {"sha": "2650b96c4083cd265bd95059bf94946a2fb00692", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -146,14 +146,14 @@ deep_clone_impl!(char)\n fn test_owned_clone() {\n     let a = ~5i;\n     let b: ~int = a.clone();\n-    assert!(a == b);\n+    assert_eq!(a, b);\n }\n \n #[test]\n fn test_managed_clone() {\n     let a = @5i;\n     let b: @int = a.clone();\n-    assert!(a == b);\n+    assert_eq!(a, b);\n }\n \n #[test]\n@@ -168,9 +168,9 @@ fn test_managed_mut_deep_clone() {\n fn test_managed_mut_clone() {\n     let a = @mut 5i;\n     let b: @mut int = a.clone();\n-    assert!(a == b);\n+    assert_eq!(a, b);\n     *b = 10;\n-    assert!(a == b);\n+    assert_eq!(a, b);\n }\n \n #[test]"}, {"sha": "ebc15174c5c731ab55ba6d91f692e0b58d81a7e8", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -490,7 +490,7 @@ mod tests {\n             let vec = u8to64_le!(vecs[t], 0);\n             let out = buf.hash_keyed(k0, k1);\n             debug!(\"got %?, expected %?\", out, vec);\n-            assert!(vec == out);\n+            assert_eq!(vec, out);\n \n             stream_full.reset();\n             stream_full.input(buf);\n@@ -512,19 +512,19 @@ mod tests {\n     fn test_hash_uint() {\n         let val = 0xdeadbeef_deadbeef_u64;\n         assert!((val as u64).hash() != (val as uint).hash());\n-        assert!((val as u32).hash() == (val as uint).hash());\n+        assert_eq!((val as u32).hash(), (val as uint).hash());\n     }\n     #[test] #[cfg(target_arch = \"x86_64\")]\n     fn test_hash_uint() {\n         let val = 0xdeadbeef_deadbeef_u64;\n-        assert!((val as u64).hash() == (val as uint).hash());\n+        assert_eq!((val as u64).hash(), (val as uint).hash());\n         assert!((val as u32).hash() != (val as uint).hash());\n     }\n     #[test] #[cfg(target_arch = \"x86\")]\n     fn test_hash_uint() {\n         let val = 0xdeadbeef_deadbeef_u64;\n         assert!((val as u64).hash() != (val as uint).hash());\n-        assert!((val as u32).hash() == (val as uint).hash());\n+        assert_eq!((val as u32).hash(), (val as uint).hash());\n     }\n \n     #[test]"}, {"sha": "fe44bfba1140d2e744bb58ab069690593abee5a0", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -842,8 +842,8 @@ mod test_map {\n         let mut m = HashMap::new();\n         assert!(m.insert(1, 2));\n         assert!(m.insert(2, 4));\n-        assert!(*m.get(&1) == 2);\n-        assert!(*m.get(&2) == 4);\n+        assert_eq!(*m.get(&1), 2);\n+        assert_eq!(*m.get(&2), 4);\n     }\n \n     #[test]\n@@ -863,9 +863,9 @@ mod test_map {\n     fn test_insert_overwrite() {\n         let mut m = HashMap::new();\n         assert!(m.insert(1, 2));\n-        assert!(*m.get(&1) == 2);\n+        assert_eq!(*m.get(&1), 2);\n         assert!(!m.insert(1, 3));\n-        assert!(*m.get(&1) == 3);\n+        assert_eq!(*m.get(&1), 3);\n     }\n \n     #[test]\n@@ -874,9 +874,9 @@ mod test_map {\n         assert!(m.insert(1, 2));\n         assert!(m.insert(5, 3));\n         assert!(m.insert(9, 4));\n-        assert!(*m.get(&9) == 4);\n-        assert!(*m.get(&5) == 3);\n-        assert!(*m.get(&1) == 2);\n+        assert_eq!(*m.get(&9), 4);\n+        assert_eq!(*m.get(&5), 3);\n+        assert_eq!(*m.get(&1), 2);\n     }\n \n     #[test]\n@@ -886,8 +886,8 @@ mod test_map {\n         assert!(m.insert(5, 3));\n         assert!(m.insert(9, 4));\n         assert!(m.remove(&1));\n-        assert!(*m.get(&9) == 4);\n-        assert!(*m.get(&5) == 3);\n+        assert_eq!(*m.get(&9), 4);\n+        assert_eq!(*m.get(&5), 3);\n     }\n \n     #[test]\n@@ -903,30 +903,30 @@ mod test_map {\n     fn test_pop() {\n         let mut m = HashMap::new();\n         m.insert(1, 2);\n-        assert!(m.pop(&1) == Some(2));\n-        assert!(m.pop(&1) == None);\n+        assert_eq!(m.pop(&1), Some(2));\n+        assert_eq!(m.pop(&1), None);\n     }\n \n     #[test]\n     fn test_swap() {\n         let mut m = HashMap::new();\n-        assert!(m.swap(1, 2) == None);\n-        assert!(m.swap(1, 3) == Some(2));\n-        assert!(m.swap(1, 4) == Some(3));\n+        assert_eq!(m.swap(1, 2), None);\n+        assert_eq!(m.swap(1, 3), Some(2));\n+        assert_eq!(m.swap(1, 4), Some(3));\n     }\n \n     #[test]\n     fn test_find_or_insert() {\n         let mut m = HashMap::new::<int, int>();\n-        assert!(m.find_or_insert(1, 2) == &2);\n-        assert!(m.find_or_insert(1, 3) == &2);\n+        assert_eq!(m.find_or_insert(1, 2), &2);\n+        assert_eq!(m.find_or_insert(1, 3), &2);\n     }\n \n     #[test]\n     fn test_find_or_insert_with() {\n         let mut m = HashMap::new::<int, int>();\n-        assert!(m.find_or_insert_with(1, |_| 2) == &2);\n-        assert!(m.find_or_insert_with(1, |_| 3) == &2);\n+        assert_eq!(m.find_or_insert_with(1, |_| 2), &2);\n+        assert_eq!(m.find_or_insert_with(1, |_| 3), &2);\n     }\n \n     #[test]\n@@ -938,10 +938,10 @@ mod test_map {\n         do m.consume |k, v| {\n             m2.insert(k, v);\n         }\n-        assert!(m.len() == 0);\n-        assert!(m2.len() == 2);\n-        assert!(m2.get(&1) == &2);\n-        assert!(m2.get(&2) == &3);\n+        assert_eq!(m.len(), 0);\n+        assert_eq!(m2.len(), 2);\n+        assert_eq!(m2.get(&1), &2);\n+        assert_eq!(m2.get(&2), &3);\n     }\n \n     #[test]\n@@ -952,10 +952,10 @@ mod test_map {\n         }\n         let mut observed = 0;\n         for m.each |k, v| {\n-            assert!(*v == *k * 2);\n+            assert_eq!(*v, *k * 2);\n             observed |= (1 << *k);\n         }\n-        assert!(observed == 0xFFFF_FFFF);\n+        assert_eq!(observed, 0xFFFF_FFFF);\n     }\n \n     #[test]\n@@ -984,14 +984,14 @@ mod test_map {\n \n         m2.insert(3, 4);\n \n-        assert!(m1 == m2);\n+        assert_eq!(m1, m2);\n     }\n \n     #[test]\n     fn test_expand() {\n         let mut m = HashMap::new();\n \n-        assert!(m.len() == 0);\n+        assert_eq!(m.len(), 0);\n         assert!(m.is_empty());\n \n         let mut i = 0u;\n@@ -1001,7 +1001,7 @@ mod test_map {\n             i += 1;\n         }\n \n-        assert!(m.len() == i);\n+        assert_eq!(m.len(), i);\n         assert!(!m.is_empty());\n     }\n }\n@@ -1090,7 +1090,7 @@ mod test_set {\n             assert!(vec::contains(expected, x));\n             i += 1\n         }\n-        assert!(i == expected.len());\n+        assert_eq!(i, expected.len());\n     }\n \n     #[test]\n@@ -1113,7 +1113,7 @@ mod test_set {\n             assert!(vec::contains(expected, x));\n             i += 1\n         }\n-        assert!(i == expected.len());\n+        assert_eq!(i, expected.len());\n     }\n \n     #[test]\n@@ -1139,7 +1139,7 @@ mod test_set {\n             assert!(vec::contains(expected, x));\n             i += 1\n         }\n-        assert!(i == expected.len());\n+        assert_eq!(i, expected.len());\n     }\n \n     #[test]\n@@ -1169,6 +1169,6 @@ mod test_set {\n             assert!(vec::contains(expected, x));\n             i += 1\n         }\n-        assert!(i == expected.len());\n+        assert_eq!(i, expected.len());\n     }\n }"}, {"sha": "77b486ca44619f3710bc8a18ddef464980c181ef", "filename": "src/libcore/io.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -635,7 +635,7 @@ impl<T:Reader> ReaderUtil for T {\n                     let next = bytes[i] as int;\n                     i += 1;\n                     assert!((next > -1));\n-                    assert!((next & 192 == 128));\n+                    assert_eq!(next & 192, 128);\n                     val <<= 6;\n                     val += (next & 63) as uint;\n                 }\n@@ -676,7 +676,7 @@ impl<T:Reader> ReaderUtil for T {\n         if c.len() == 0 {\n             return -1 as char; // FIXME will this stay valid? // #2004\n         }\n-        assert!(c.len() == 1);\n+        assert_eq!(c.len(), 1);\n         return c[0];\n     }\n \n@@ -1795,33 +1795,33 @@ mod tests {\n         let inp: @io::Reader = result::get(&io::file_reader(tmpfile));\n         let frood2: ~str = inp.read_c_str();\n         debug!(copy frood2);\n-        assert!(frood == frood2);\n+        assert_eq!(frood, frood2);\n     }\n \n     #[test]\n     fn test_readchars_empty() {\n         do io::with_str_reader(~\"\") |inp| {\n             let res : ~[char] = inp.read_chars(128);\n-            assert!(res.len() == 0);\n+            assert_eq!(res.len(), 0);\n         }\n     }\n \n     #[test]\n     fn test_read_line_utf8() {\n         do io::with_str_reader(~\"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\") |inp| {\n             let line = inp.read_line();\n-            assert!(line == ~\"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\");\n+            assert_eq!(line, ~\"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\");\n         }\n     }\n \n     #[test]\n     fn test_read_lines() {\n         do io::with_str_reader(~\"a\\nb\\nc\\n\") |inp| {\n-            assert!(inp.read_lines() == ~[~\"a\", ~\"b\", ~\"c\"]);\n+            assert_eq!(inp.read_lines(), ~[~\"a\", ~\"b\", ~\"c\"]);\n         }\n \n         do io::with_str_reader(~\"a\\nb\\nc\") |inp| {\n-            assert!(inp.read_lines() == ~[~\"a\", ~\"b\", ~\"c\"]);\n+            assert_eq!(inp.read_lines(), ~[~\"a\", ~\"b\", ~\"c\"]);\n         }\n \n         do io::with_str_reader(~\"\") |inp| {\n@@ -1842,7 +1842,7 @@ mod tests {\n             do io::with_str_reader(s) |inp| {\n                 let res : ~[char] = inp.read_chars(len);\n                 if len <= ivals.len() {\n-                    assert!(res.len() == len);\n+                    assert_eq!(res.len(), len);\n                 }\n                 assert!(vec::slice(ivals, 0u, res.len()) ==\n                              vec::map(res, |x| *x as int));\n@@ -1861,23 +1861,23 @@ mod tests {\n     fn test_readchar() {\n         do io::with_str_reader(~\"\u751f\") |inp| {\n             let res : char = inp.read_char();\n-            assert!((res as int == 29983));\n+            assert_eq!(res as int, 29983);\n         }\n     }\n \n     #[test]\n     fn test_readchar_empty() {\n         do io::with_str_reader(~\"\") |inp| {\n             let res : char = inp.read_char();\n-            assert!((res as int == -1));\n+            assert_eq!(res as int, -1);\n         }\n     }\n \n     #[test]\n     fn file_reader_not_exist() {\n         match io::file_reader(&Path(\"not a file\")) {\n           result::Err(copy e) => {\n-            assert!(e == ~\"error opening not a file\");\n+            assert_eq!(e, ~\"error opening not a file\");\n           }\n           result::Ok(_) => fail!()\n         }\n@@ -1966,7 +1966,7 @@ mod tests {\n         {\n             let file = io::file_reader(&path).get();\n             for uints.each |i| {\n-                assert!(file.read_le_u64() == *i);\n+                assert_eq!(file.read_le_u64(), *i);\n             }\n         }\n     }\n@@ -1988,7 +1988,7 @@ mod tests {\n         {\n             let file = io::file_reader(&path).get();\n             for uints.each |i| {\n-                assert!(file.read_be_u64() == *i);\n+                assert_eq!(file.read_be_u64(), *i);\n             }\n         }\n     }\n@@ -2012,7 +2012,7 @@ mod tests {\n             for ints.each |i| {\n                 // this tests that the sign extension is working\n                 // (comparing the values as i32 would not test this)\n-                assert!(file.read_be_int_n(4) == *i as i64);\n+                assert_eq!(file.read_be_int_n(4), *i as i64);\n             }\n         }\n     }\n@@ -2031,7 +2031,7 @@ mod tests {\n         {\n             let file = io::file_reader(&path).get();\n             let f = file.read_be_f32();\n-            assert!(f == 8.1250);\n+            assert_eq!(f, 8.1250);\n         }\n     }\n \n@@ -2048,8 +2048,8 @@ mod tests {\n \n         {\n             let file = io::file_reader(&path).get();\n-            assert!(file.read_be_f32() == 8.1250);\n-            assert!(file.read_le_f32() == 8.1250);\n+            assert_eq!(file.read_be_f32(), 8.1250);\n+            assert_eq!(file.read_le_f32(), 8.1250);\n         }\n     }\n }"}, {"sha": "64f6f2d2a9a9bc22d979a48913e6a7a4bcf5d725", "filename": "src/libcore/num/int-template/int.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -85,20 +85,20 @@ mod inst {\n \n     #[test]\n     fn test_pow() {\n-        assert!((pow(0, 0u) == 1));\n-        assert!((pow(0, 1u) == 0));\n-        assert!((pow(0, 2u) == 0));\n-        assert!((pow(-1, 0u) == 1));\n-        assert!((pow(1, 0u) == 1));\n-        assert!((pow(-3, 2u) == 9));\n-        assert!((pow(-3, 3u) == -27));\n-        assert!((pow(4, 9u) == 262144));\n+        assert_eq!(pow(0, 0u), 1);\n+        assert_eq!(pow(0, 1u), 0);\n+        assert_eq!(pow(0, 2u), 0);\n+        assert_eq!(pow(-1, 0u), 1);\n+        assert_eq!(pow(1, 0u), 1);\n+        assert_eq!(pow(-3, 2u), 9);\n+        assert_eq!(pow(-3, 3u), -27);\n+        assert_eq!(pow(4, 9u), 262144);\n     }\n \n     #[test]\n     fn test_overflows() {\n         assert!((::int::max_value > 0));\n         assert!((::int::min_value <= 0));\n-        assert!((::int::min_value + ::int::max_value + 1 == 0));\n+        assert_eq!(::int::min_value + ::int::max_value + 1, 0);\n     }\n }"}, {"sha": "b4c9bb653712e5b2a9d18c052ae2cb279f0311fe", "filename": "src/libcore/num/uint-template/uint.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -211,61 +211,61 @@ pub mod inst {\n \n     #[test]\n     fn test_next_power_of_two() {\n-        assert!((next_power_of_two(0u) == 0u));\n-        assert!((next_power_of_two(1u) == 1u));\n-        assert!((next_power_of_two(2u) == 2u));\n-        assert!((next_power_of_two(3u) == 4u));\n-        assert!((next_power_of_two(4u) == 4u));\n-        assert!((next_power_of_two(5u) == 8u));\n-        assert!((next_power_of_two(6u) == 8u));\n-        assert!((next_power_of_two(7u) == 8u));\n-        assert!((next_power_of_two(8u) == 8u));\n-        assert!((next_power_of_two(9u) == 16u));\n-        assert!((next_power_of_two(10u) == 16u));\n-        assert!((next_power_of_two(11u) == 16u));\n-        assert!((next_power_of_two(12u) == 16u));\n-        assert!((next_power_of_two(13u) == 16u));\n-        assert!((next_power_of_two(14u) == 16u));\n-        assert!((next_power_of_two(15u) == 16u));\n-        assert!((next_power_of_two(16u) == 16u));\n-        assert!((next_power_of_two(17u) == 32u));\n-        assert!((next_power_of_two(18u) == 32u));\n-        assert!((next_power_of_two(19u) == 32u));\n-        assert!((next_power_of_two(20u) == 32u));\n-        assert!((next_power_of_two(21u) == 32u));\n-        assert!((next_power_of_two(22u) == 32u));\n-        assert!((next_power_of_two(23u) == 32u));\n-        assert!((next_power_of_two(24u) == 32u));\n-        assert!((next_power_of_two(25u) == 32u));\n-        assert!((next_power_of_two(26u) == 32u));\n-        assert!((next_power_of_two(27u) == 32u));\n-        assert!((next_power_of_two(28u) == 32u));\n-        assert!((next_power_of_two(29u) == 32u));\n-        assert!((next_power_of_two(30u) == 32u));\n-        assert!((next_power_of_two(31u) == 32u));\n-        assert!((next_power_of_two(32u) == 32u));\n-        assert!((next_power_of_two(33u) == 64u));\n-        assert!((next_power_of_two(34u) == 64u));\n-        assert!((next_power_of_two(35u) == 64u));\n-        assert!((next_power_of_two(36u) == 64u));\n-        assert!((next_power_of_two(37u) == 64u));\n-        assert!((next_power_of_two(38u) == 64u));\n-        assert!((next_power_of_two(39u) == 64u));\n+        assert_eq!(next_power_of_two(0u), 0u);\n+        assert_eq!(next_power_of_two(1u), 1u);\n+        assert_eq!(next_power_of_two(2u), 2u);\n+        assert_eq!(next_power_of_two(3u), 4u);\n+        assert_eq!(next_power_of_two(4u), 4u);\n+        assert_eq!(next_power_of_two(5u), 8u);\n+        assert_eq!(next_power_of_two(6u), 8u);\n+        assert_eq!(next_power_of_two(7u), 8u);\n+        assert_eq!(next_power_of_two(8u), 8u);\n+        assert_eq!(next_power_of_two(9u), 16u);\n+        assert_eq!(next_power_of_two(10u), 16u);\n+        assert_eq!(next_power_of_two(11u), 16u);\n+        assert_eq!(next_power_of_two(12u), 16u);\n+        assert_eq!(next_power_of_two(13u), 16u);\n+        assert_eq!(next_power_of_two(14u), 16u);\n+        assert_eq!(next_power_of_two(15u), 16u);\n+        assert_eq!(next_power_of_two(16u), 16u);\n+        assert_eq!(next_power_of_two(17u), 32u);\n+        assert_eq!(next_power_of_two(18u), 32u);\n+        assert_eq!(next_power_of_two(19u), 32u);\n+        assert_eq!(next_power_of_two(20u), 32u);\n+        assert_eq!(next_power_of_two(21u), 32u);\n+        assert_eq!(next_power_of_two(22u), 32u);\n+        assert_eq!(next_power_of_two(23u), 32u);\n+        assert_eq!(next_power_of_two(24u), 32u);\n+        assert_eq!(next_power_of_two(25u), 32u);\n+        assert_eq!(next_power_of_two(26u), 32u);\n+        assert_eq!(next_power_of_two(27u), 32u);\n+        assert_eq!(next_power_of_two(28u), 32u);\n+        assert_eq!(next_power_of_two(29u), 32u);\n+        assert_eq!(next_power_of_two(30u), 32u);\n+        assert_eq!(next_power_of_two(31u), 32u);\n+        assert_eq!(next_power_of_two(32u), 32u);\n+        assert_eq!(next_power_of_two(33u), 64u);\n+        assert_eq!(next_power_of_two(34u), 64u);\n+        assert_eq!(next_power_of_two(35u), 64u);\n+        assert_eq!(next_power_of_two(36u), 64u);\n+        assert_eq!(next_power_of_two(37u), 64u);\n+        assert_eq!(next_power_of_two(38u), 64u);\n+        assert_eq!(next_power_of_two(39u), 64u);\n     }\n \n     #[test]\n     fn test_overflows() {\n         use uint;\n         assert!((uint::max_value > 0u));\n         assert!((uint::min_value <= 0u));\n-        assert!((uint::min_value + uint::max_value + 1u == 0u));\n+        assert_eq!(uint::min_value + uint::max_value + 1u, 0u);\n     }\n \n     #[test]\n     fn test_div() {\n-        assert!((div_floor(3u, 4u) == 0u));\n-        assert!((div_ceil(3u, 4u)  == 1u));\n-        assert!((div_round(3u, 4u) == 1u));\n+        assert_eq!(div_floor(3u, 4u), 0u);\n+        assert_eq!(div_ceil(3u, 4u), 1u);\n+        assert_eq!(div_round(3u, 4u), 1u);\n     }\n \n     #[test]\n@@ -274,6 +274,6 @@ pub mod inst {\n         let ten = 10 as uint;\n         let mut accum = 0;\n         for ten.times { accum += 1; }\n-        assert!((accum == 10));\n+        assert_eq!(accum, 10);\n     }\n }"}, {"sha": "71c242bb69b3c4f34c6ed7553021966012b066e1", "filename": "src/libcore/option.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -405,7 +405,7 @@ fn test_unwrap_ptr() {\n         let opt = Some(x);\n         let y = opt.unwrap();\n         let addr_y: *int = ::cast::transmute(&*y);\n-        assert!(addr_x == addr_y);\n+        assert_eq!(addr_x, addr_y);\n     }\n }\n \n@@ -416,7 +416,7 @@ fn test_unwrap_str() {\n     let opt = Some(x);\n     let y = opt.unwrap();\n     let addr_y = str::as_buf(y, |buf, _len| buf);\n-    assert!(addr_x == addr_y);\n+    assert_eq!(addr_x, addr_y);\n }\n \n #[test]\n@@ -442,7 +442,7 @@ fn test_unwrap_resource() {\n         let opt = Some(x);\n         let _y = opt.unwrap();\n     }\n-    assert!(*i == 1);\n+    assert_eq!(*i, 1);\n }\n \n #[test]\n@@ -453,7 +453,7 @@ fn test_option_dance() {\n     for x.each |_x| {\n         y2 = y.swap_unwrap();\n     }\n-    assert!(y2 == 5);\n+    assert_eq!(y2, 5);\n     assert!(y.is_none());\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -474,13 +474,13 @@ fn test_option_while_some() {\n             None\n         }\n     }\n-    assert!(i == 11);\n+    assert_eq!(i, 11);\n }\n \n #[test]\n fn test_get_or_zero() {\n     let some_stuff = Some(42);\n-    assert!(some_stuff.get_or_zero() == 42);\n+    assert_eq!(some_stuff.get_or_zero(), 42);\n     let no_stuff: Option<int> = None;\n-    assert!(no_stuff.get_or_zero() == 0);\n+    assert_eq!(no_stuff.get_or_zero(), 0);\n }"}, {"sha": "2625d03588be93920632e4185084dd954d8a91c3", "filename": "src/libcore/os.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -221,7 +221,7 @@ pub fn env() -> ~[(~str,~str)] {\n                 for str::each_splitn_char(*p, '=', 1) |s| { vs.push(s.to_owned()) }\n                 debug!(\"splitting: len: %u\",\n                     vs.len());\n-                assert!(vs.len() == 2);\n+                assert_eq!(vs.len(), 2);\n                 pairs.push((copy vs[0], copy vs[1]));\n             }\n             pairs\n@@ -388,7 +388,7 @@ pub fn pipe() -> Pipe {\n     unsafe {\n         let mut fds = Pipe {in: 0 as c_int,\n                             out: 0 as c_int };\n-        assert!((libc::pipe(&mut fds.in) == (0 as c_int)));\n+        assert_eq!(libc::pipe(&mut fds.in), (0 as c_int));\n         return Pipe {in: fds.in, out: fds.out};\n     }\n }\n@@ -407,7 +407,7 @@ pub fn pipe() -> Pipe {\n                     out: 0 as c_int };\n         let res = libc::pipe(&mut fds.in, 1024 as ::libc::c_uint,\n                              (libc::O_BINARY | libc::O_NOINHERIT) as c_int);\n-        assert!((res == 0 as c_int));\n+        assert_eq!(res, 0 as c_int);\n         assert!((fds.in != -1 as c_int && fds.in != 0 as c_int));\n         assert!((fds.out != -1 as c_int && fds.in != 0 as c_int));\n         return Pipe {in: fds.in, out: fds.out};\n@@ -1474,15 +1474,15 @@ mod tests {\n     fn test_setenv() {\n         let n = make_rand_name();\n         setenv(n, ~\"VALUE\");\n-        assert!(getenv(n) == option::Some(~\"VALUE\"));\n+        assert_eq!(getenv(n), option::Some(~\"VALUE\"));\n     }\n \n     #[test]\n     fn test_unsetenv() {\n         let n = make_rand_name();\n         setenv(n, ~\"VALUE\");\n         unsetenv(n);\n-        assert!(getenv(n) == option::None);\n+        assert_eq!(getenv(n), option::None);\n     }\n \n     #[test]\n@@ -1492,9 +1492,9 @@ mod tests {\n         let n = make_rand_name();\n         setenv(n, ~\"1\");\n         setenv(n, ~\"2\");\n-        assert!(getenv(n) == option::Some(~\"2\"));\n+        assert_eq!(getenv(n), option::Some(~\"2\"));\n         setenv(n, ~\"\");\n-        assert!(getenv(n) == option::Some(~\"\"));\n+        assert_eq!(getenv(n), option::Some(~\"\"));\n     }\n \n     // Windows GetEnvironmentVariable requires some extra work to make sure\n@@ -1509,7 +1509,7 @@ mod tests {\n         let n = make_rand_name();\n         setenv(n, s);\n         debug!(copy s);\n-        assert!(getenv(n) == option::Some(s));\n+        assert_eq!(getenv(n), option::Some(s));\n     }\n \n     #[test]\n@@ -1567,7 +1567,7 @@ mod tests {\n         let oldhome = getenv(~\"HOME\");\n \n         setenv(~\"HOME\", ~\"/home/MountainView\");\n-        assert!(os::homedir() == Some(Path(\"/home/MountainView\")));\n+        assert_eq!(os::homedir(), Some(Path(\"/home/MountainView\")));\n \n         setenv(~\"HOME\", ~\"\");\n         assert!(os::homedir().is_none());\n@@ -1588,16 +1588,16 @@ mod tests {\n         assert!(os::homedir().is_none());\n \n         setenv(~\"HOME\", ~\"/home/MountainView\");\n-        assert!(os::homedir() == Some(Path(\"/home/MountainView\")));\n+        assert_eq!(os::homedir(), Some(Path(\"/home/MountainView\")));\n \n         setenv(~\"HOME\", ~\"\");\n \n         setenv(~\"USERPROFILE\", ~\"/home/MountainView\");\n-        assert!(os::homedir() == Some(Path(\"/home/MountainView\")));\n+        assert_eq!(os::homedir(), Some(Path(\"/home/MountainView\")));\n \n         setenv(~\"HOME\", ~\"/home/MountainView\");\n         setenv(~\"USERPROFILE\", ~\"/home/PaloAlto\");\n-        assert!(os::homedir() == Some(Path(\"/home/MountainView\")));\n+        assert_eq!(os::homedir(), Some(Path(\"/home/MountainView\")));\n \n         oldhome.each(|s| {setenv(~\"HOME\", *s);true});\n         olduserprofile.each(|s| {setenv(~\"USERPROFILE\", *s);true});\n@@ -1668,16 +1668,16 @@ mod tests {\n                                    (str::len(s) + 1u) as size_t, ostream)\n                       == buf.len() as size_t))\n           }\n-          assert!((libc::fclose(ostream) == (0u as c_int)));\n+          assert_eq!(libc::fclose(ostream), (0u as c_int));\n           let in_mode = in.get_mode();\n           let rs = os::copy_file(&in, &out);\n           if (!os::path_exists(&in)) {\n             fail!(\"%s doesn't exist\", in.to_str());\n           }\n           assert!((rs));\n           let rslt = run::run_program(~\"diff\", ~[in.to_str(), out.to_str()]);\n-          assert!((rslt == 0));\n-          assert!(out.get_mode() == in_mode);\n+          assert_eq!(rslt, 0);\n+          assert_eq!(out.get_mode(), in_mode);\n           assert!((remove_file(&in)));\n           assert!((remove_file(&out)));\n         }"}, {"sha": "ed9ef864f8039e285f49e94af6df7061e1fcc41f", "filename": "src/libcore/path.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -952,30 +952,30 @@ mod tests {\n         let path = PosixPath(\"tmp/\");\n         let path = path.push(\"/hmm\");\n         let path = path.normalize();\n-        assert!(~\"tmp/hmm\" == path.to_str());\n+        assert_eq!(~\"tmp/hmm\", path.to_str());\n \n         let path = WindowsPath(\"tmp/\");\n         let path = path.push(\"/hmm\");\n         let path = path.normalize();\n-        assert!(~\"tmp\\\\hmm\" == path.to_str());\n+        assert_eq!(~\"tmp\\\\hmm\", path.to_str());\n     }\n \n     #[test]\n     fn test_filetype_foo_bar() {\n         let wp = PosixPath(\"foo.bar\");\n-        assert!(wp.filetype() == Some(~\".bar\"));\n+        assert_eq!(wp.filetype(), Some(~\".bar\"));\n \n         let wp = WindowsPath(\"foo.bar\");\n-        assert!(wp.filetype() == Some(~\".bar\"));\n+        assert_eq!(wp.filetype(), Some(~\".bar\"));\n     }\n \n     #[test]\n     fn test_filetype_foo() {\n         let wp = PosixPath(\"foo\");\n-        assert!(wp.filetype() == None);\n+        assert_eq!(wp.filetype(), None);\n \n         let wp = WindowsPath(\"foo\");\n-        assert!(wp.filetype() == None);\n+        assert_eq!(wp.filetype(), None);\n     }\n \n     #[test]\n@@ -986,7 +986,7 @@ mod tests {\n             if (ss != sss) {\n                 debug!(\"got %s\", ss);\n                 debug!(\"expected %s\", sss);\n-                assert!(ss == sss);\n+                assert_eq!(ss, sss);\n             }\n         }\n \n@@ -1044,7 +1044,7 @@ mod tests {\n             if (ss != sss) {\n                 debug!(\"got %s\", ss);\n                 debug!(\"expected %s\", sss);\n-                assert!(ss == sss);\n+                assert_eq!(ss, sss);\n             }\n         }\n \n@@ -1107,7 +1107,7 @@ mod tests {\n             if (ss != sss) {\n                 debug!(\"got %s\", ss);\n                 debug!(\"expected %s\", sss);\n-                assert!(ss == sss);\n+                assert_eq!(ss, sss);\n             }\n         }\n \n@@ -1192,9 +1192,9 @@ mod tests {\n \n     #[test]\n     fn test_windows_path_restrictions() {\n-        assert!(WindowsPath(\"hi\").is_restricted() == false);\n-        assert!(WindowsPath(\"C:\\\\NUL\").is_restricted() == true);\n-        assert!(WindowsPath(\"C:\\\\COM1.TXT\").is_restricted() == true);\n-        assert!(WindowsPath(\"c:\\\\prn.exe\").is_restricted() == true);\n+        assert_eq!(WindowsPath(\"hi\").is_restricted(), false);\n+        assert_eq!(WindowsPath(\"C:\\\\NUL\").is_restricted(), true);\n+        assert_eq!(WindowsPath(\"C:\\\\COM1.TXT\").is_restricted(), true);\n+        assert_eq!(WindowsPath(\"c:\\\\prn.exe\").is_restricted(), true);\n     }\n }"}, {"sha": "1c2b57bb2dffbbb88581114ef401bdd4d969c663", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -353,7 +353,7 @@ pub fn send<T,Tbuffer>(mut p: SendPacketBuffered<T,Tbuffer>,\n     let header = p.header();\n     let p_ = p.unwrap();\n     let p = unsafe { &mut *p_ };\n-    assert!(ptr::to_unsafe_ptr(&(p.header)) == header);\n+    assert_eq!(ptr::to_unsafe_ptr(&(p.header)), header);\n     assert!(p.payload.is_none());\n     p.payload = Some(payload);\n     let old_state = swap_state_rel(&mut p.header.state, Full);\n@@ -494,7 +494,7 @@ fn try_recv_<T:Owned>(p: &mut Packet<T>) -> Option<T> {\n           Terminated => {\n             // This assert detects when we've accidentally unsafely\n             // casted too big of a number to a state.\n-            assert!(old_state == Terminated);\n+            assert_eq!(old_state, Terminated);\n \n             let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n             if !old_task.is_null() {\n@@ -566,7 +566,7 @@ fn receiver_terminate<T:Owned>(p: *mut Packet<T>) {\n         if !old_task.is_null() {\n             unsafe {\n                 rustrt::rust_task_deref(old_task);\n-                assert!(old_task == rustrt::rust_get_task());\n+                assert_eq!(old_task, rustrt::rust_get_task());\n             }\n         }\n       }"}, {"sha": "9d40f1b639cd8b532f10fbe2802c05b112f35993", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -343,15 +343,15 @@ pub mod ptr_tests {\n             let mut p = Pair {fst: 10, snd: 20};\n             let pptr: *mut Pair = &mut p;\n             let iptr: *mut int = cast::transmute(pptr);\n-            assert!((*iptr == 10));;\n+            assert_eq!(*iptr, 10);\n             *iptr = 30;\n-            assert!((*iptr == 30));\n-            assert!((p.fst == 30));;\n+            assert_eq!(*iptr, 30);\n+            assert_eq!(p.fst, 30);\n \n             *pptr = Pair {fst: 50, snd: 60};\n-            assert!((*iptr == 50));\n-            assert!((p.fst == 50));\n-            assert!((p.snd == 60));\n+            assert_eq!(*iptr, 50);\n+            assert_eq!(p.fst, 50);\n+            assert_eq!(p.snd, 60);\n \n             let v0 = ~[32000u16, 32001u16, 32002u16];\n             let mut v1 = ~[0u16, 0u16, 0u16];\n@@ -396,8 +396,8 @@ pub mod ptr_tests {\n                 do str::as_c_str(s2) |p2| {\n                     let v = ~[p0, p1, p2, null()];\n                     do vec::as_imm_buf(v) |vp, len| {\n-                        assert!(unsafe { buf_len(vp) } == 3u);\n-                        assert!(len == 4u);\n+                        assert_eq!(unsafe { buf_len(vp) }, 3u);\n+                        assert_eq!(len, 4u);\n                     }\n                 }\n             }\n@@ -448,11 +448,11 @@ pub mod ptr_tests {\n                                          debug!(\n                                              \"test_ptr_array_each e: %s, a: %s\",\n                                              expected, actual);\n-                                         assert!(actual == expected);\n+                                         assert_eq!(actual, expected);\n                                          ctr += 1;\n                                          iteration_count += 1;\n                                      });\n-            assert!(iteration_count == 3u);\n+            assert_eq!(iteration_count, 3u);\n         }\n     }\n     #[test]\n@@ -480,11 +480,11 @@ pub mod ptr_tests {\n                 debug!(\n                     \"test_ptr_array_each e: %s, a: %s\",\n                     expected, actual);\n-                assert!(actual == expected);\n+                assert_eq!(actual, expected);\n                 ctr += 1;\n                 iteration_count += 1;\n             });\n-            assert!(iteration_count == 3);\n+            assert_eq!(iteration_count, 3);\n         }\n     }\n     #[test]"}, {"sha": "84dd7d187e4b1e736069d8ae90cab9f9f9f4b764", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -880,7 +880,7 @@ mod tests {\n         let seed = seed();\n         let mut ra = IsaacRng::new_seeded(seed);\n         let mut rb = IsaacRng::new_seeded(seed);\n-        assert!(ra.gen_str(100u) == rb.gen_str(100u));\n+        assert_eq!(ra.gen_str(100u), rb.gen_str(100u));\n     }\n \n     #[test]\n@@ -889,7 +889,7 @@ mod tests {\n         let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n         let mut ra = IsaacRng::new_seeded(seed);\n         let mut rb = IsaacRng::new_seeded(seed);\n-        assert!(ra.gen_str(100u) == rb.gen_str(100u));\n+        assert_eq!(ra.gen_str(100u), rb.gen_str(100u));\n     }\n \n     #[test]\n@@ -908,8 +908,8 @@ mod tests {\n         let mut r = rng();\n         let a = r.gen_int_range(-3, 42);\n         assert!(a >= -3 && a < 42);\n-        assert!(r.gen_int_range(0, 1) == 0);\n-        assert!(r.gen_int_range(-12, -11) == -12);\n+        assert_eq!(r.gen_int_range(0, 1), 0);\n+        assert_eq!(r.gen_int_range(-12, -11), -12);\n     }\n \n     #[test]\n@@ -925,8 +925,8 @@ mod tests {\n         let mut r = rng();\n         let a = r.gen_uint_range(3u, 42u);\n         assert!(a >= 3u && a < 42u);\n-        assert!(r.gen_uint_range(0u, 1u) == 0u);\n-        assert!(r.gen_uint_range(12u, 13u) == 12u);\n+        assert_eq!(r.gen_uint_range(0u, 1u), 0u);\n+        assert_eq!(r.gen_uint_range(12u, 13u), 12u);\n     }\n \n     #[test]\n@@ -948,8 +948,8 @@ mod tests {\n     #[test]\n     fn test_gen_weighted_bool() {\n         let mut r = rng();\n-        assert!(r.gen_weighted_bool(0u) == true);\n-        assert!(r.gen_weighted_bool(1u) == true);\n+        assert_eq!(r.gen_weighted_bool(0u), true);\n+        assert_eq!(r.gen_weighted_bool(1u), true);\n     }\n \n     #[test]\n@@ -958,31 +958,31 @@ mod tests {\n         debug!(r.gen_str(10u));\n         debug!(r.gen_str(10u));\n         debug!(r.gen_str(10u));\n-        assert!(r.gen_str(0u).len() == 0u);\n-        assert!(r.gen_str(10u).len() == 10u);\n-        assert!(r.gen_str(16u).len() == 16u);\n+        assert_eq!(r.gen_str(0u).len(), 0u);\n+        assert_eq!(r.gen_str(10u).len(), 10u);\n+        assert_eq!(r.gen_str(16u).len(), 16u);\n     }\n \n     #[test]\n     fn test_gen_bytes() {\n         let mut r = rng();\n-        assert!(r.gen_bytes(0u).len() == 0u);\n-        assert!(r.gen_bytes(10u).len() == 10u);\n-        assert!(r.gen_bytes(16u).len() == 16u);\n+        assert_eq!(r.gen_bytes(0u).len(), 0u);\n+        assert_eq!(r.gen_bytes(10u).len(), 10u);\n+        assert_eq!(r.gen_bytes(16u).len(), 16u);\n     }\n \n     #[test]\n     fn test_choose() {\n         let mut r = rng();\n-        assert!(r.choose([1, 1, 1]) == 1);\n+        assert_eq!(r.choose([1, 1, 1]), 1);\n     }\n \n     #[test]\n     fn test_choose_option() {\n         let mut r = rng();\n         let x: Option<int> = r.choose_option([]);\n         assert!(x.is_none());\n-        assert!(r.choose_option([1, 1, 1]) == Some(1));\n+        assert_eq!(r.choose_option([1, 1, 1]), Some(1));\n     }\n \n     #[test]\n@@ -1015,7 +1015,7 @@ mod tests {\n     fn test_weighted_vec() {\n         let mut r = rng();\n         let empty: ~[int] = ~[];\n-        assert!(r.weighted_vec(~[]) == empty);\n+        assert_eq!(r.weighted_vec(~[]), empty);\n         assert!(r.weighted_vec(~[\n             Weighted { weight: 0u, item: 3u },\n             Weighted { weight: 1u, item: 2u },\n@@ -1027,16 +1027,16 @@ mod tests {\n     fn test_shuffle() {\n         let mut r = rng();\n         let empty: ~[int] = ~[];\n-        assert!(r.shuffle(~[]) == empty);\n-        assert!(r.shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n+        assert_eq!(r.shuffle(~[]), empty);\n+        assert_eq!(r.shuffle(~[1, 1, 1]), ~[1, 1, 1]);\n     }\n \n     #[test]\n     fn test_task_rng() {\n         let mut r = task_rng();\n         r.gen::<int>();\n-        assert!(r.shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n-        assert!(r.gen_uint_range(0u, 1u) == 0u);\n+        assert_eq!(r.shuffle(~[1, 1, 1]), ~[1, 1, 1]);\n+        assert_eq!(r.gen_uint_range(0u, 1u), 0u);\n     }\n \n     #[test]"}, {"sha": "a05009e375cf998c1b0072ecce115b371ee4e73b", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -220,7 +220,7 @@ pub impl ReprVisitor {\n         } else if mtbl == 1 {\n             // skip, this is ast::m_imm\n         } else {\n-            assert!(mtbl == 2);\n+            assert_eq!(mtbl, 2);\n             self.writer.write_str(\"const \");\n         }\n     }\n@@ -592,7 +592,7 @@ fn test_repr() {\n             error!(\"expected '%s', got '%s'\",\n                    e, s);\n         }\n-        assert!(s == e);\n+        assert_eq!(s, e);\n     }\n \n     exact_test(&10, \"10\");"}, {"sha": "cda2fe13e37663f9621eb76ede3b43d889a9673b", "filename": "src/libcore/result.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -407,12 +407,12 @@ mod tests {\n \n     #[test]\n     pub fn chain_success() {\n-        assert!(get(&chain(op1(), op2)) == 667u);\n+        assert_eq!(get(&chain(op1(), op2)), 667u);\n     }\n \n     #[test]\n     pub fn chain_failure() {\n-        assert!(get_err(&chain(op3(), op2)) == ~\"sadface\");\n+        assert_eq!(get_err(&chain(op3(), op2)), ~\"sadface\");\n     }\n \n     #[test]\n@@ -438,19 +438,19 @@ mod tests {\n \n     #[test]\n     pub fn test_impl_map() {\n-        assert!(Ok::<~str, ~str>(~\"a\").map(|_x| ~\"b\") == Ok(~\"b\"));\n-        assert!(Err::<~str, ~str>(~\"a\").map(|_x| ~\"b\") == Err(~\"a\"));\n+        assert_eq!(Ok::<~str, ~str>(~\"a\").map(|_x| ~\"b\"), Ok(~\"b\"));\n+        assert_eq!(Err::<~str, ~str>(~\"a\").map(|_x| ~\"b\"), Err(~\"a\"));\n     }\n \n     #[test]\n     pub fn test_impl_map_err() {\n-        assert!(Ok::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\") == Ok(~\"a\"));\n-        assert!(Err::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\") == Err(~\"b\"));\n+        assert_eq!(Ok::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\"), Ok(~\"a\"));\n+        assert_eq!(Err::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\"), Err(~\"b\"));\n     }\n \n     #[test]\n     pub fn test_get_ref_method() {\n         let foo: Result<int, ()> = Ok(100);\n-        assert!(*foo.get_ref() == 100);\n+        assert_eq!(*foo.get_ref(), 100);\n     }\n }"}, {"sha": "db2683dc85d837fd88a6c36629a21fe3e552c78d", "filename": "src/libcore/rt/io/flate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frt%2Fio%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frt%2Fio%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fflate.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -114,8 +114,8 @@ mod test {\n         let mut inflate_reader = InflateReader::new(mem_reader);\n         let mut out_bytes = [0, .. 100];\n         let bytes_read = inflate_reader.read(out_bytes).get();\n-        assert!(bytes_read == in_bytes.len());\n+        assert_eq!(bytes_read, in_bytes.len());\n         let out_msg = str::from_bytes(out_bytes);\n         assert!(in_msg == out_msg);\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "b2701c1fdc392b9df56b88bf6e90bf73d9116713", "filename": "src/libcore/rt/io/mem.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frt%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frt%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmem.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -86,7 +86,7 @@ impl Reader for MemReader {\n         {\n             let input = self.buf.slice(self.pos, self.pos + write_len);\n             let output = vec::mut_slice(buf, 0, write_len);\n-            assert!(input.len() == output.len());\n+            assert_eq!(input.len(), output.len());\n             vec::bytes::copy_memory(output, input, write_len);\n         }\n         self.pos += write_len;\n@@ -189,33 +189,33 @@ mod test {\n     #[test]\n     fn test_mem_writer() {\n         let mut writer = MemWriter::new();\n-        assert!(writer.tell() == 0);\n+        assert_eq!(writer.tell(), 0);\n         writer.write([0]);\n-        assert!(writer.tell() == 1);\n+        assert_eq!(writer.tell(), 1);\n         writer.write([1, 2, 3]);\n         writer.write([4, 5, 6, 7]);\n-        assert!(writer.tell() == 8);\n-        assert!(writer.inner() == ~[0, 1, 2, 3, 4, 5 , 6, 7]);\n+        assert_eq!(writer.tell(), 8);\n+        assert_eq!(writer.inner(), ~[0, 1, 2, 3, 4, 5 , 6, 7]);\n     }\n \n     #[test]\n     fn test_mem_reader() {\n         let mut reader = MemReader::new(~[0, 1, 2, 3, 4, 5, 6, 7]);\n         let mut buf = [];\n-        assert!(reader.read(buf) == Some(0));\n-        assert!(reader.tell() == 0);\n+        assert_eq!(reader.read(buf), Some(0));\n+        assert_eq!(reader.tell(), 0);\n         let mut buf = [0];\n-        assert!(reader.read(buf) == Some(1));\n-        assert!(reader.tell() == 1);\n-        assert!(buf == [0]);\n+        assert_eq!(reader.read(buf), Some(1));\n+        assert_eq!(reader.tell(), 1);\n+        assert_eq!(buf, [0]);\n         let mut buf = [0, ..4];\n-        assert!(reader.read(buf) == Some(4));\n-        assert!(reader.tell() == 5);\n-        assert!(buf == [1, 2, 3, 4]);\n-        assert!(reader.read(buf) == Some(3));\n-        assert!(buf.slice(0, 3) == [5, 6, 7]);\n+        assert_eq!(reader.read(buf), Some(4));\n+        assert_eq!(reader.tell(), 5);\n+        assert_eq!(buf, [1, 2, 3, 4]);\n+        assert_eq!(reader.read(buf), Some(3));\n+        assert_eq!(buf.slice(0, 3), [5, 6, 7]);\n         assert!(reader.eof());\n-        assert!(reader.read(buf) == None);\n+        assert_eq!(reader.read(buf), None);\n         assert!(reader.eof());\n     }\n }"}, {"sha": "a5fd7a395de7ff7fef8f6fe940146fa61c793634", "filename": "src/libcore/rt/io/net/tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -262,7 +262,7 @@ mod test {\n                     let mut stream = listener.accept();\n                     let mut buf = [0];\n                     stream.read(buf);\n-                    assert!(buf[0] == 99);\n+                    assert_eq!(buf[0], 99);\n                 }\n             }\n "}, {"sha": "d71ef55d3ad971839e0677742e92f3174dddb84e", "filename": "src/libcore/rt/io/option.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frt%2Fio%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frt%2Fio%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Foption.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -87,7 +87,7 @@ mod test {\n             let mut writer: Option<MemWriter> = Some(MemWriter::new());\n             writer.write([0, 1, 2]);\n             writer.flush();\n-            assert!(writer.unwrap().inner() == ~[0, 1, 2]);\n+            assert_eq!(writer.unwrap().inner(), ~[0, 1, 2]);\n         }\n     }\n \n@@ -98,7 +98,7 @@ mod test {\n \n             let mut called = false;\n             do io_error::cond.trap(|err| {\n-                assert!(err.kind == PreviousIoError);\n+                assert_eq!(err.kind, PreviousIoError);\n                 called = true;\n             }).in {\n                 writer.write([0, 0, 0]);\n@@ -107,7 +107,7 @@ mod test {\n \n             let mut called = false;\n             do io_error::cond.trap(|err| {\n-                assert!(err.kind == PreviousIoError);\n+                assert_eq!(err.kind, PreviousIoError);\n                 called = true;\n             }).in {\n                 writer.flush();\n@@ -122,7 +122,7 @@ mod test {\n             let mut reader: Option<MemReader> = Some(MemReader::new(~[0, 1, 2, 3]));\n             let mut buf = [0, 0];\n             reader.read(buf);\n-            assert!(buf == [0, 1]);\n+            assert_eq!(buf, [0, 1]);\n             assert!(!reader.eof());\n         }\n     }\n@@ -134,7 +134,7 @@ mod test {\n \n         let mut called = false;\n         do read_error::cond.trap(|err| {\n-            assert!(err.kind == PreviousIoError);\n+            assert_eq!(err.kind, PreviousIoError);\n             called = true;\n         }).in {\n             reader.read(buf);\n@@ -143,7 +143,7 @@ mod test {\n \n         let mut called = false;\n         do io_error::cond.trap(|err| {\n-            assert!(err.kind == PreviousIoError);\n+            assert_eq!(err.kind, PreviousIoError);\n             called = true;\n         }).in {\n             assert!(reader.eof());"}, {"sha": "4dce9da505b5fa6830fbc2d99447e616b3b74c53", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -217,15 +217,15 @@ fn test_context() {\n     use rt::uv::uvio::UvEventLoop;\n     use cell::Cell;\n \n-    assert!(context() == OldTaskContext);\n+    assert_eq!(context(), OldTaskContext);\n     do run_in_bare_thread {\n-        assert!(context() == GlobalContext);\n+        assert_eq!(context(), GlobalContext);\n         let mut sched = ~UvEventLoop::new_scheduler();\n         let task = ~do Coroutine::new(&mut sched.stack_pool) {\n-            assert!(context() == TaskContext);\n+            assert_eq!(context(), TaskContext);\n             let sched = local_sched::take();\n             do sched.deschedule_running_task_and_then() |task| {\n-                assert!(context() == SchedulerContext);\n+                assert_eq!(context(), SchedulerContext);\n                 let task = Cell(task);\n                 do local_sched::borrow |sched| {\n                     sched.enqueue_task(task.take());"}, {"sha": "7fd40fb329f4794a6da5d897fb3f8668ec8b27ce", "filename": "src/libcore/rt/sched.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -445,7 +445,7 @@ mod test {\n                 sched.enqueue_task(task);\n             }\n             sched.run();\n-            assert!(task_count == total);\n+            assert_eq!(task_count, total);\n         }\n     }\n \n@@ -473,7 +473,7 @@ mod test {\n             };\n             sched.enqueue_task(task1);\n             sched.run();\n-            assert!(count == 3);\n+            assert_eq!(count, 3);\n         }\n     }\n \n@@ -492,7 +492,7 @@ mod test {\n             sched.enqueue_task(start_task);\n             sched.run();\n \n-            assert!(count == MAX);\n+            assert_eq!(count, MAX);\n \n             fn run_task(count_ptr: *mut int) {\n                 do local_sched::borrow |sched| {"}, {"sha": "7187d2db41cac492f2ad33b2539b9d10b891ce8e", "filename": "src/libcore/rt/thread_local_storage.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fthread_local_storage.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -21,12 +21,12 @@ pub type Key = pthread_key_t;\n \n #[cfg(unix)]\n pub unsafe fn create(key: &mut Key) {\n-    assert!(0 == pthread_key_create(key, null()));\n+    assert_eq!(0, pthread_key_create(key, null()));\n }\n \n #[cfg(unix)]\n pub unsafe fn set(key: Key, value: *mut c_void) {\n-    assert!(0 == pthread_setspecific(key, value));\n+    assert_eq!(0, pthread_setspecific(key, value));\n }\n \n #[cfg(unix)]\n@@ -91,10 +91,10 @@ fn tls_smoke_test() {\n         create(&mut key);\n         set(key, transmute(value));\n         let value: ~int = transmute(get(key));\n-        assert!(value == ~20);\n+        assert_eq!(value, ~20);\n         let value = ~30;\n         set(key, transmute(value));\n         let value: ~int = transmute(get(key));\n-        assert!(value == ~30);\n+        assert_eq!(value, ~30);\n     }\n }"}, {"sha": "ad59305830311376a083013bf9352f12a2c05a17", "filename": "src/libcore/rt/uv/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fmod.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -231,7 +231,7 @@ impl ToStr for UvError {\n fn error_smoke_test() {\n     let err = uvll::uv_err_t { code: 1, sys_errno_: 1 };\n     let err: UvError = UvError(err);\n-    assert!(err.to_str() == ~\"EOF: end of file\");\n+    assert_eq!(err.to_str(), ~\"EOF: end of file\");\n }\n \n pub fn last_uv_error<H, W: Watcher + NativeHandle<*H>>(watcher: &W) -> UvError {\n@@ -397,7 +397,7 @@ fn idle_smoke_test() {\n         }\n         loop_.run();\n         loop_.close();\n-        assert!(count == 10);\n+        assert_eq!(count, 10);\n     }\n }\n "}, {"sha": "68b871e6b31184b4f234beb151e31248a848c515", "filename": "src/libcore/rt/uv/net.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fnet.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -114,7 +114,7 @@ pub impl StreamWatcher {\n         let self_handle = self.native_handle() as *c_void;\n         let stream_handle = stream.native_handle() as *c_void;\n         unsafe {\n-            assert!(0 == uvll::accept(self_handle, stream_handle));\n+            assert_eq!(0, uvll::accept(self_handle, stream_handle));\n         }\n     }\n \n@@ -158,7 +158,7 @@ pub impl TcpWatcher {\n         unsafe {\n             let handle = malloc_handle(UV_TCP);\n             assert!(handle.is_not_null());\n-            assert!(0 == uvll::tcp_init(loop_.native_handle(), handle));\n+            assert_eq!(0, uvll::tcp_init(loop_.native_handle(), handle));\n             let mut watcher: TcpWatcher = NativeHandle::from_native_handle(handle);\n             watcher.install_watcher_data();\n             return watcher;\n@@ -350,7 +350,7 @@ mod test {\n             do tcp_watcher.connect(addr) |stream_watcher, status| {\n                 rtdebug!(\"tcp_watcher.connect!\");\n                 assert!(status.is_some());\n-                assert!(status.get().name() == ~\"ECONNREFUSED\");\n+                assert_eq!(status.get().name(), ~\"ECONNREFUSED\");\n                 stream_watcher.close(||());\n             }\n             loop_.run();\n@@ -397,7 +397,7 @@ mod test {\n                             count += 1;\n                         }\n                     } else {\n-                        assert!(count == MAX);\n+                        assert_eq!(count, MAX);\n                         do stream_watcher.close {\n                             server_stream_watcher.close(||());\n                         }"}, {"sha": "8666d43a1004825a75a516c0532d368e7b6ca248", "filename": "src/libcore/rt/uv/uvio.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -97,7 +97,7 @@ fn test_callback_run_once() {\n             unsafe { *count_ptr += 1 }\n         }\n         event_loop.run();\n-        assert!(count == 1);\n+        assert_eq!(count, 1);\n     }\n }\n \n@@ -379,10 +379,10 @@ fn test_simple_tcp_server_and_client() {\n                 let mut stream = listener.accept().unwrap();\n                 let mut buf = [0, .. 2048];\n                 let nread = stream.read(buf).unwrap();\n-                assert!(nread == 8);\n+                assert_eq!(nread, 8);\n                 for uint::range(0, nread) |i| {\n                     rtdebug!(\"%u\", buf[i] as uint);\n-                    assert!(buf[i] == i as u8);\n+                    assert_eq!(buf[i], i as u8);\n                 }\n             }\n         }\n@@ -416,7 +416,7 @@ fn test_read_and_block() {\n                 let nread = stream.read(buf).unwrap();\n                 for uint::range(0, nread) |i| {\n                     let val = buf[i] as uint;\n-                    assert!(val == current % 8);\n+                    assert_eq!(val, current % 8);\n                     current += 1;\n                 }\n                 reads += 1;\n@@ -482,7 +482,7 @@ fn test_read_read_read() {\n                     rtdebug!(\"read %u bytes\", nread as uint);\n                     total_bytes_read += nread;\n                     for uint::range(0, nread) |i| {\n-                        assert!(buf[i] == 1);\n+                        assert_eq!(buf[i], 1);\n                     }\n                 }\n                 rtdebug!(\"read %u bytes total\", total_bytes_read as uint);"}, {"sha": "ddc9040d730915da8e2b8e58910355e65da5e5d9", "filename": "src/libcore/rt/uv/uvll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fuvll.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -132,14 +132,14 @@ pub unsafe fn free_req(v: *c_void) {\n #[test]\n fn handle_sanity_check() {\n     unsafe {\n-        assert!(UV_HANDLE_TYPE_MAX as uint == rust_uv_handle_type_max());\n+        assert_eq!(UV_HANDLE_TYPE_MAX as uint, rust_uv_handle_type_max());\n     }\n }\n \n #[test]\n fn request_sanity_check() {\n     unsafe {\n-        assert!(UV_REQ_TYPE_MAX as uint == rust_uv_req_type_max());\n+        assert_eq!(UV_REQ_TYPE_MAX as uint, rust_uv_req_type_max());\n     }\n }\n "}, {"sha": "02757ab489903c6abdb9b3326c1c15226149f09f", "filename": "src/libcore/run.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -835,7 +835,7 @@ mod tests {\n \n         debug!(copy expected);\n         debug!(copy actual);\n-        assert!((expected == actual));\n+        assert_eq!(expected, actual);\n     }\n \n     #[test]\n@@ -844,7 +844,7 @@ mod tests {\n                                      &None, &None,\n                                      0i32, 0i32, 0i32);\n         let status = run::waitpid(pid);\n-        assert!(status == 1);\n+        assert_eq!(status, 1);\n     }\n \n     #[test]"}, {"sha": "a3cb180ed2653d6af45bbad0a5e29d38fdc91266", "filename": "src/libcore/str.rs", "status": "modified", "additions": 179, "deletions": 179, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -67,7 +67,7 @@ pub fn from_bytes(vv: &const [u8]) -> ~str {\n  * Fails if not null terminated\n  */\n pub fn from_bytes_with_null<'a>(vv: &'a [u8]) -> &'a str {\n-    assert!(vv[vv.len() - 1] == 0);\n+    assert_eq!(vv[vv.len() - 1], 0);\n     assert!(is_utf8(vv));\n     return unsafe { raw::from_bytes_with_null(vv) };\n }\n@@ -2247,7 +2247,7 @@ pub fn char_range_at(s: &str, i: uint) -> CharRange {\n     let mut i = i + 1u;\n     while i < end {\n         let byte = s[i];\n-        assert!((byte & 192u8 == tag_cont_u8));\n+        assert_eq!(byte & 192u8, tag_cont_u8);\n         val <<= 6u;\n         val += (byte & 63u8) as uint;\n         i += 1u;\n@@ -2733,7 +2733,7 @@ pub mod raw {\n             let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n             let b = vec::raw::to_ptr(a);\n             let c = from_buf_len(b, 3u);\n-            assert!((c == ~\"AAA\"));\n+            assert_eq!(c, ~\"AAA\");\n         }\n     }\n \n@@ -3160,47 +3160,47 @@ mod tests {\n \n     #[test]\n     fn test_len() {\n-        assert!((len(~\"\") == 0u));\n-        assert!((len(~\"hello world\") == 11u));\n-        assert!((len(~\"\\x63\") == 1u));\n-        assert!((len(~\"\\xa2\") == 2u));\n-        assert!((len(~\"\\u03c0\") == 2u));\n-        assert!((len(~\"\\u2620\") == 3u));\n-        assert!((len(~\"\\U0001d11e\") == 4u));\n-\n-        assert!((char_len(~\"\") == 0u));\n-        assert!((char_len(~\"hello world\") == 11u));\n-        assert!((char_len(~\"\\x63\") == 1u));\n-        assert!((char_len(~\"\\xa2\") == 1u));\n-        assert!((char_len(~\"\\u03c0\") == 1u));\n-        assert!((char_len(~\"\\u2620\") == 1u));\n-        assert!((char_len(~\"\\U0001d11e\") == 1u));\n-        assert!((char_len(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\") == 19u));\n+        assert_eq!(len(~\"\"), 0u);\n+        assert_eq!(len(~\"hello world\"), 11u);\n+        assert_eq!(len(~\"\\x63\"), 1u);\n+        assert_eq!(len(~\"\\xa2\"), 2u);\n+        assert_eq!(len(~\"\\u03c0\"), 2u);\n+        assert_eq!(len(~\"\\u2620\"), 3u);\n+        assert_eq!(len(~\"\\U0001d11e\"), 4u);\n+\n+        assert_eq!(char_len(~\"\"), 0u);\n+        assert_eq!(char_len(~\"hello world\"), 11u);\n+        assert_eq!(char_len(~\"\\x63\"), 1u);\n+        assert_eq!(char_len(~\"\\xa2\"), 1u);\n+        assert_eq!(char_len(~\"\\u03c0\"), 1u);\n+        assert_eq!(char_len(~\"\\u2620\"), 1u);\n+        assert_eq!(char_len(~\"\\U0001d11e\"), 1u);\n+        assert_eq!(char_len(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"), 19u);\n     }\n \n     #[test]\n     fn test_rfind_char() {\n-        assert!(rfind_char(~\"hello\", 'l') == Some(3u));\n-        assert!(rfind_char(~\"hello\", 'o') == Some(4u));\n-        assert!(rfind_char(~\"hello\", 'h') == Some(0u));\n+        assert_eq!(rfind_char(~\"hello\", 'l'), Some(3u));\n+        assert_eq!(rfind_char(~\"hello\", 'o'), Some(4u));\n+        assert_eq!(rfind_char(~\"hello\", 'h'), Some(0u));\n         assert!(rfind_char(~\"hello\", 'z').is_none());\n-        assert!(rfind_char(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e') == Some(30u));\n+        assert_eq!(rfind_char(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e'), Some(30u));\n     }\n \n     #[test]\n     fn test_pop_char() {\n         let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n         let cc = pop_char(&mut data);\n-        assert!(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\" == data);\n-        assert!('\u534e' == cc);\n+        assert_eq!(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", data);\n+        assert_eq!('\u534e', cc);\n     }\n \n     #[test]\n     fn test_pop_char_2() {\n         let mut data2 = ~\"\u534e\";\n         let cc2 = pop_char(&mut data2);\n-        assert!(~\"\" == data2);\n-        assert!('\u534e' == cc2);\n+        assert_eq!(~\"\", data2);\n+        assert_eq!('\u534e', cc2);\n     }\n \n     #[test]\n@@ -3448,58 +3448,58 @@ mod tests {\n     fn test_find_str() {\n         // byte positions\n         assert!(find_str(~\"banana\", ~\"apple pie\").is_none());\n-        assert!(find_str(~\"\", ~\"\") == Some(0u));\n+        assert_eq!(find_str(~\"\", ~\"\"), Some(0u));\n \n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert!(find_str(data, ~\"\")     == Some(0u));\n-        assert!(find_str(data, ~\"\u0e1b\u0e23\u0e30\u0e40\") == Some( 0u));\n-        assert!(find_str(data, ~\"\u0e30\u0e40\")   == Some( 6u));\n-        assert!(find_str(data, ~\"\u4e2d\u534e\") == Some(27u));\n+        assert_eq!(find_str(data, ~\"\"), Some(0u));\n+        assert_eq!(find_str(data, ~\"\u0e1b\u0e23\u0e30\u0e40\"), Some( 0u));\n+        assert_eq!(find_str(data, ~\"\u0e30\u0e40\"), Some( 6u));\n+        assert_eq!(find_str(data, ~\"\u4e2d\u534e\"), Some(27u));\n         assert!(find_str(data, ~\"\u0e44\u0e17\u534e\").is_none());\n     }\n \n     #[test]\n     fn test_find_str_between() {\n         // byte positions\n-        assert!(find_str_between(~\"\", ~\"\", 0u, 0u) == Some(0u));\n+        assert_eq!(find_str_between(~\"\", ~\"\", 0u, 0u), Some(0u));\n \n         let data = ~\"abcabc\";\n-        assert!(find_str_between(data, ~\"ab\", 0u, 6u) == Some(0u));\n-        assert!(find_str_between(data, ~\"ab\", 2u, 6u) == Some(3u));\n+        assert_eq!(find_str_between(data, ~\"ab\", 0u, 6u), Some(0u));\n+        assert_eq!(find_str_between(data, ~\"ab\", 2u, 6u), Some(3u));\n         assert!(find_str_between(data, ~\"ab\", 2u, 4u).is_none());\n \n         let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         data = data + data;\n-        assert!(find_str_between(data, ~\"\", 0u, 43u) == Some(0u));\n-        assert!(find_str_between(data, ~\"\", 6u, 43u) == Some(6u));\n+        assert_eq!(find_str_between(data, ~\"\", 0u, 43u), Some(0u));\n+        assert_eq!(find_str_between(data, ~\"\", 6u, 43u), Some(6u));\n \n-        assert!(find_str_between(data, ~\"\u0e1b\u0e23\u0e30\", 0u, 43u) == Some( 0u));\n-        assert!(find_str_between(data, ~\"\u0e17\u0e28\u0e44\", 0u, 43u) == Some(12u));\n-        assert!(find_str_between(data, ~\"\u0e22\u4e2d\", 0u, 43u) == Some(24u));\n-        assert!(find_str_between(data, ~\"i\u1ec7t\", 0u, 43u) == Some(34u));\n-        assert!(find_str_between(data, ~\"Nam\", 0u, 43u) == Some(40u));\n+        assert_eq!(find_str_between(data, ~\"\u0e1b\u0e23\u0e30\", 0u, 43u), Some( 0u));\n+        assert_eq!(find_str_between(data, ~\"\u0e17\u0e28\u0e44\", 0u, 43u), Some(12u));\n+        assert_eq!(find_str_between(data, ~\"\u0e22\u4e2d\", 0u, 43u), Some(24u));\n+        assert_eq!(find_str_between(data, ~\"i\u1ec7t\", 0u, 43u), Some(34u));\n+        assert_eq!(find_str_between(data, ~\"Nam\", 0u, 43u), Some(40u));\n \n-        assert!(find_str_between(data, ~\"\u0e1b\u0e23\u0e30\", 43u, 86u) == Some(43u));\n-        assert!(find_str_between(data, ~\"\u0e17\u0e28\u0e44\", 43u, 86u) == Some(55u));\n-        assert!(find_str_between(data, ~\"\u0e22\u4e2d\", 43u, 86u) == Some(67u));\n-        assert!(find_str_between(data, ~\"i\u1ec7t\", 43u, 86u) == Some(77u));\n-        assert!(find_str_between(data, ~\"Nam\", 43u, 86u) == Some(83u));\n+        assert_eq!(find_str_between(data, ~\"\u0e1b\u0e23\u0e30\", 43u, 86u), Some(43u));\n+        assert_eq!(find_str_between(data, ~\"\u0e17\u0e28\u0e44\", 43u, 86u), Some(55u));\n+        assert_eq!(find_str_between(data, ~\"\u0e22\u4e2d\", 43u, 86u), Some(67u));\n+        assert_eq!(find_str_between(data, ~\"i\u1ec7t\", 43u, 86u), Some(77u));\n+        assert_eq!(find_str_between(data, ~\"Nam\", 43u, 86u), Some(83u));\n     }\n \n     #[test]\n     fn test_substr() {\n         fn t(a: &str, b: &str, start: int) {\n-            assert!(substr(a, start as uint, len(b)) == b);\n+            assert_eq!(substr(a, start as uint, len(b)), b);\n         }\n         t(\"hello\", \"llo\", 2);\n         t(\"hello\", \"el\", 1);\n-        assert!(\"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\" == substr(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", 6u, 6u));\n+        assert_eq!(\"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\", substr(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", 6u, 6u));\n     }\n \n     #[test]\n     fn test_concat() {\n         fn t(v: &[~str], s: &str) {\n-            assert!(concat(v) == s.to_str());\n+            assert_eq!(concat(v), s.to_str());\n         }\n         t(~[~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"], ~\"youknowI'mnogood\");\n         let v: ~[~str] = ~[];\n@@ -3510,7 +3510,7 @@ mod tests {\n     #[test]\n     fn test_connect() {\n         fn t(v: &[~str], sep: &str, s: &str) {\n-            assert!(connect(v, sep) == s.to_str());\n+            assert_eq!(connect(v, sep), s.to_str());\n         }\n         t(~[~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"],\n           ~\" \", ~\"you know I'm no good\");\n@@ -3522,7 +3522,7 @@ mod tests {\n     #[test]\n     fn test_connect_slices() {\n         fn t(v: &[&str], sep: &str, s: &str) {\n-            assert!(connect_slices(v, sep) == s.to_str());\n+            assert_eq!(connect_slices(v, sep), s.to_str());\n         }\n         t([\"you\", \"know\", \"I'm\", \"no\", \"good\"],\n           \" \", \"you know I'm no good\");\n@@ -3532,18 +3532,18 @@ mod tests {\n \n     #[test]\n     fn test_repeat() {\n-        assert!(repeat(~\"x\", 4) == ~\"xxxx\");\n-        assert!(repeat(~\"hi\", 4) == ~\"hihihihi\");\n-        assert!(repeat(~\"\u0e44\u0e17\u534e\", 3) == ~\"\u0e44\u0e17\u534e\u0e44\u0e17\u534e\u0e44\u0e17\u534e\");\n-        assert!(repeat(~\"\", 4) == ~\"\");\n-        assert!(repeat(~\"hi\", 0) == ~\"\");\n+        assert_eq!(repeat(~\"x\", 4), ~\"xxxx\");\n+        assert_eq!(repeat(~\"hi\", 4), ~\"hihihihi\");\n+        assert_eq!(repeat(~\"\u0e44\u0e17\u534e\", 3), ~\"\u0e44\u0e17\u534e\u0e44\u0e17\u534e\u0e44\u0e17\u534e\");\n+        assert_eq!(repeat(~\"\", 4), ~\"\");\n+        assert_eq!(repeat(~\"hi\", 0), ~\"\");\n     }\n \n     #[test]\n     fn test_unsafe_slice() {\n-        assert!(\"ab\" == unsafe {raw::slice_bytes(\"abc\", 0, 2)});\n-        assert!(\"bc\" == unsafe {raw::slice_bytes(\"abc\", 1, 3)});\n-        assert!(\"\" == unsafe {raw::slice_bytes(\"abc\", 1, 1)});\n+        assert_eq!(\"ab\", unsafe {raw::slice_bytes(\"abc\", 0, 2)});\n+        assert_eq!(\"bc\", unsafe {raw::slice_bytes(\"abc\", 1, 3)});\n+        assert_eq!(\"\", unsafe {raw::slice_bytes(\"abc\", 1, 1)});\n         fn a_million_letter_a() -> ~str {\n             let mut i = 0;\n             let mut rs = ~\"\";\n@@ -3588,13 +3588,13 @@ mod tests {\n     #[test]\n     fn test_replace() {\n         let a = ~\"a\";\n-        assert!(replace(~\"\", a, ~\"b\") == ~\"\");\n-        assert!(replace(~\"a\", a, ~\"b\") == ~\"b\");\n-        assert!(replace(~\"ab\", a, ~\"b\") == ~\"bb\");\n+        assert_eq!(replace(~\"\", a, ~\"b\"), ~\"\");\n+        assert_eq!(replace(~\"a\", a, ~\"b\"), ~\"b\");\n+        assert_eq!(replace(~\"ab\", a, ~\"b\"), ~\"bb\");\n         let test = ~\"test\";\n         assert!(replace(~\" test test \", test, ~\"toast\") ==\n             ~\" toast toast \");\n-        assert!(replace(~\" test test \", test, ~\"\") == ~\"   \");\n+        assert_eq!(replace(~\" test test \", test, ~\"\"), ~\"   \");\n     }\n \n     #[test]\n@@ -3604,7 +3604,7 @@ mod tests {\n \n         let a = ~\"\u0e1b\u0e23\u0e30\u0e40\";\n         let A = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert!((replace(data, a, repl) ==  A));\n+        assert_eq!(replace(data, a, repl), A);\n     }\n \n     #[test]\n@@ -3614,7 +3614,7 @@ mod tests {\n \n         let b = ~\"\u0e30\u0e40\";\n         let B = ~\"\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert!((replace(data, b,   repl) ==  B));\n+        assert_eq!(replace(data, b,   repl), B);\n     }\n \n     #[test]\n@@ -3624,7 +3624,7 @@ mod tests {\n \n         let c = ~\"\u4e2d\u534e\";\n         let C = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n-        assert!((replace(data, c, repl) ==  C));\n+        assert_eq!(replace(data, c, repl), C);\n     }\n \n     #[test]\n@@ -3633,21 +3633,21 @@ mod tests {\n         let repl = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n \n         let d = ~\"\u0e44\u0e17\u534e\";\n-        assert!((replace(data, d, repl) == data));\n+        assert_eq!(replace(data, d, repl), data);\n     }\n \n     #[test]\n     fn test_slice() {\n-        assert!(\"ab\" == slice(\"abc\", 0, 2));\n-        assert!(\"bc\" == slice(\"abc\", 1, 3));\n-        assert!(\"\" == slice(\"abc\", 1, 1));\n-        assert!(\"\\u65e5\" == slice(\"\\u65e5\\u672c\", 0, 3));\n+        assert_eq!(\"ab\", slice(\"abc\", 0, 2));\n+        assert_eq!(\"bc\", slice(\"abc\", 1, 3));\n+        assert_eq!(\"\", slice(\"abc\", 1, 1));\n+        assert_eq!(\"\\u65e5\", slice(\"\\u65e5\\u672c\", 0, 3));\n \n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert!(\"\u0e1b\" == slice(data, 0, 3));\n-        assert!(\"\u0e23\" == slice(data, 3, 6));\n-        assert!(\"\" == slice(data, 3, 3));\n-        assert!(\"\u534e\" == slice(data, 30, 33));\n+        assert_eq!(\"\u0e1b\", slice(data, 0, 3));\n+        assert_eq!(\"\u0e23\", slice(data, 3, 6));\n+        assert_eq!(\"\", slice(data, 3, 3));\n+        assert_eq!(\"\u534e\", slice(data, 30, 33));\n \n         fn a_million_letter_X() -> ~str {\n             let mut i = 0;\n@@ -3673,16 +3673,16 @@ mod tests {\n     fn test_slice_2() {\n         let ss = \"\u4e2d\u534eVi\u1ec7t Nam\";\n \n-        assert!(\"\u534e\" == slice(ss, 3u, 6u));\n-        assert!(\"Vi\u1ec7t Nam\" == slice(ss, 6u, 16u));\n+        assert_eq!(\"\u534e\", slice(ss, 3u, 6u));\n+        assert_eq!(\"Vi\u1ec7t Nam\", slice(ss, 6u, 16u));\n \n-        assert!(\"ab\" == slice(\"abc\", 0u, 2u));\n-        assert!(\"bc\" == slice(\"abc\", 1u, 3u));\n-        assert!(\"\" == slice(\"abc\", 1u, 1u));\n+        assert_eq!(\"ab\", slice(\"abc\", 0u, 2u));\n+        assert_eq!(\"bc\", slice(\"abc\", 1u, 3u));\n+        assert_eq!(\"\", slice(\"abc\", 1u, 1u));\n \n-        assert!(\"\u4e2d\" == slice(ss, 0u, 3u));\n-        assert!(\"\u534eV\" == slice(ss, 3u, 7u));\n-        assert!(\"\" == slice(ss, 3u, 3u));\n+        assert_eq!(\"\u4e2d\", slice(ss, 0u, 3u));\n+        assert_eq!(\"\u534eV\", slice(ss, 3u, 7u));\n+        assert_eq!(\"\", slice(ss, 3u, 3u));\n         /*0: \u4e2d\n           3: \u534e\n           6: V\n@@ -3708,7 +3708,7 @@ mod tests {\n                      \" *** foo *** \");\n         assert!(trim_left_chars(\" *** foo *** \", ~['*', ' ']) ==\n                      \"foo *** \");\n-        assert!(trim_left_chars(\" ***  *** \", ~['*', ' ']) == \"\");\n+        assert_eq!(trim_left_chars(\" ***  *** \", ~['*', ' ']), \"\");\n         assert!(trim_left_chars(\"foo *** \", ~['*', ' ']) ==\n                      \"foo *** \");\n     }\n@@ -3719,47 +3719,47 @@ mod tests {\n                      \" *** foo *** \");\n         assert!(trim_right_chars(\" *** foo *** \", ~['*', ' ']) ==\n                      \" *** foo\");\n-        assert!(trim_right_chars(\" ***  *** \", ~['*', ' ']) == \"\");\n+        assert_eq!(trim_right_chars(\" ***  *** \", ~['*', ' ']), \"\");\n         assert!(trim_right_chars(\" *** foo\", ~['*', ' ']) ==\n                      \" *** foo\");\n     }\n \n     #[test]\n     fn test_trim_chars() {\n-        assert!(trim_chars(\" *** foo *** \", ~[]) == \" *** foo *** \");\n-        assert!(trim_chars(\" *** foo *** \", ~['*', ' ']) == \"foo\");\n-        assert!(trim_chars(\" ***  *** \", ~['*', ' ']) == \"\");\n-        assert!(trim_chars(\"foo\", ~['*', ' ']) == \"foo\");\n+        assert_eq!(trim_chars(\" *** foo *** \", ~[]), \" *** foo *** \");\n+        assert_eq!(trim_chars(\" *** foo *** \", ~['*', ' ']), \"foo\");\n+        assert_eq!(trim_chars(\" ***  *** \", ~['*', ' ']), \"\");\n+        assert_eq!(trim_chars(\"foo\", ~['*', ' ']), \"foo\");\n     }\n \n     #[test]\n     fn test_trim_left() {\n-        assert!((trim_left(\"\") == \"\"));\n-        assert!((trim_left(\"a\") == \"a\"));\n-        assert!((trim_left(\"    \") == \"\"));\n-        assert!((trim_left(\"     blah\") == \"blah\"));\n-        assert!((trim_left(\"   \\u3000  wut\") == \"wut\"));\n-        assert!((trim_left(\"hey \") == \"hey \"));\n+        assert_eq!(trim_left(\"\"), \"\");\n+        assert_eq!(trim_left(\"a\"), \"a\");\n+        assert_eq!(trim_left(\"    \"), \"\");\n+        assert_eq!(trim_left(\"     blah\"), \"blah\");\n+        assert_eq!(trim_left(\"   \\u3000  wut\"), \"wut\");\n+        assert_eq!(trim_left(\"hey \"), \"hey \");\n     }\n \n     #[test]\n     fn test_trim_right() {\n-        assert!((trim_right(\"\") == \"\"));\n-        assert!((trim_right(\"a\") == \"a\"));\n-        assert!((trim_right(\"    \") == \"\"));\n-        assert!((trim_right(\"blah     \") == \"blah\"));\n-        assert!((trim_right(\"wut   \\u3000  \") == \"wut\"));\n-        assert!((trim_right(\" hey\") == \" hey\"));\n+        assert_eq!(trim_right(\"\"), \"\");\n+        assert_eq!(trim_right(\"a\"), \"a\");\n+        assert_eq!(trim_right(\"    \"), \"\");\n+        assert_eq!(trim_right(\"blah     \"), \"blah\");\n+        assert_eq!(trim_right(\"wut   \\u3000  \"), \"wut\");\n+        assert_eq!(trim_right(\" hey\"), \" hey\");\n     }\n \n     #[test]\n     fn test_trim() {\n-        assert!((trim(\"\") == \"\"));\n-        assert!((trim(\"a\") == \"a\"));\n-        assert!((trim(\"    \") == \"\"));\n-        assert!((trim(\"    blah     \") == \"blah\"));\n-        assert!((trim(\"\\nwut   \\u3000  \") == \"wut\"));\n-        assert!((trim(\" hey dude \") == \"hey dude\"));\n+        assert_eq!(trim(\"\"), \"\");\n+        assert_eq!(trim(\"a\"), \"a\");\n+        assert_eq!(trim(\"    \"), \"\");\n+        assert_eq!(trim(\"    blah     \"), \"blah\");\n+        assert_eq!(trim(\"\\nwut   \\u3000  \"), \"wut\");\n+        assert_eq!(trim(\" hey dude \"), \"hey dude\");\n     }\n \n     #[test]\n@@ -3775,23 +3775,23 @@ mod tests {\n     fn test_shift_byte() {\n         let mut s = ~\"ABC\";\n         let b = unsafe{raw::shift_byte(&mut s)};\n-        assert!((s == ~\"BC\"));\n-        assert!((b == 65u8));\n+        assert_eq!(s, ~\"BC\");\n+        assert_eq!(b, 65u8);\n     }\n \n     #[test]\n     fn test_pop_byte() {\n         let mut s = ~\"ABC\";\n         let b = unsafe{raw::pop_byte(&mut s)};\n-        assert!((s == ~\"AB\"));\n-        assert!((b == 67u8));\n+        assert_eq!(s, ~\"AB\");\n+        assert_eq!(b, 67u8);\n     }\n \n     #[test]\n     fn test_unsafe_from_bytes() {\n         let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8];\n         let b = unsafe { raw::from_bytes(a) };\n-        assert!((b == ~\"AAAAAAA\"));\n+        assert_eq!(b, ~\"AAAAAAA\");\n     }\n \n     #[test]\n@@ -3808,7 +3808,7 @@ mod tests {\n                   0x20_u8, 0x4e_u8, 0x61_u8,\n                   0x6d_u8];\n \n-        assert!(ss == from_bytes(bb));\n+        assert_eq!(ss, from_bytes(bb));\n     }\n \n     #[test]\n@@ -3895,7 +3895,7 @@ mod tests {\n             let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n             let b = vec::raw::to_ptr(a);\n             let c = raw::from_buf(b);\n-            assert!((c == ~\"AAAAAAA\"));\n+            assert_eq!(c, ~\"AAAAAAA\");\n         }\n     }\n \n@@ -3911,20 +3911,20 @@ mod tests {\n     fn test_as_buf() {\n         let a = ~\"Abcdefg\";\n         let b = as_buf(a, |buf, _l| {\n-            assert!(unsafe { *buf } == 65u8);\n+            assert_eq!(unsafe { *buf }, 65u8);\n             100\n         });\n-        assert!((b == 100));\n+        assert_eq!(b, 100);\n     }\n \n     #[test]\n     fn test_as_buf_small() {\n         let a = ~\"A\";\n         let b = as_buf(a, |buf, _l| {\n-            assert!(unsafe { *buf } == 65u8);\n+            assert_eq!(unsafe { *buf }, 65u8);\n             100\n         });\n-        assert!((b == 100));\n+        assert_eq!(b, 100);\n     }\n \n     #[test]\n@@ -3933,7 +3933,7 @@ mod tests {\n             let s = ~\"hello\";\n             let sb = as_buf(s, |b, _l| b);\n             let s_cstr = raw::from_buf(sb);\n-            assert!(s_cstr == s);\n+            assert_eq!(s_cstr, s);\n         }\n     }\n \n@@ -3942,11 +3942,11 @@ mod tests {\n         let a = ~\"hello\";\n         do as_buf(a) |buf, len| {\n             unsafe {\n-                assert!(a[0] == 'h' as u8);\n-                assert!(*buf == 'h' as u8);\n-                assert!(len == 6u);\n-                assert!(*ptr::offset(buf,4u) == 'o' as u8);\n-                assert!(*ptr::offset(buf,5u) == 0u8);\n+                assert_eq!(a[0], 'h' as u8);\n+                assert_eq!(*buf, 'h' as u8);\n+                assert_eq!(len, 6u);\n+                assert_eq!(*ptr::offset(buf,4u), 'o' as u8);\n+                assert_eq!(*ptr::offset(buf,5u), 0u8);\n             }\n         }\n     }\n@@ -3956,15 +3956,15 @@ mod tests {\n         let a = \"kernelsprite\";\n         let b = slice(a, 7, len(a));\n         let c = slice(a, 0, len(a) - 6);\n-        assert!(subslice_offset(a, b) == 7);\n-        assert!(subslice_offset(a, c) == 0);\n+        assert_eq!(subslice_offset(a, b), 7);\n+        assert_eq!(subslice_offset(a, c), 0);\n \n         let string = \"a\\nb\\nc\";\n         let mut lines = ~[];\n         for each_line(string) |line| { lines.push(line) }\n-        assert!(subslice_offset(string, lines[0]) == 0);\n-        assert!(subslice_offset(string, lines[1]) == 2);\n-        assert!(subslice_offset(string, lines[2]) == 4);\n+        assert_eq!(subslice_offset(string, lines[0]), 0);\n+        assert_eq!(subslice_offset(string, lines[1]), 2);\n+        assert_eq!(subslice_offset(string, lines[2]), 4);\n     }\n \n     #[test]\n@@ -3984,13 +3984,13 @@ mod tests {\n         let mut i: uint = 0u;\n         let n1: uint = len(s1);\n         let n2: uint = vec::len::<u8>(v);\n-        assert!((n1 == n2));\n+        assert_eq!(n1, n2);\n         while i < n1 {\n             let a: u8 = s1[i];\n             let b: u8 = s2[i];\n             debug!(a);\n             debug!(b);\n-            assert!((a == b));\n+            assert_eq!(a, b);\n             i += 1u;\n         }\n     }\n@@ -4094,26 +4094,26 @@ mod tests {\n \n     #[test]\n     fn test_map() {\n-        assert!(~\"\" == map(~\"\", |c| unsafe {libc::toupper(c as c_char)} as char));\n-        assert!(~\"YMCA\" == map(~\"ymca\", |c| unsafe {libc::toupper(c as c_char)} as char));\n+        assert_eq!(~\"\", map(~\"\", |c| unsafe {libc::toupper(c as c_char)} as char));\n+        assert_eq!(~\"YMCA\", map(~\"ymca\", |c| unsafe {libc::toupper(c as c_char)} as char));\n     }\n \n     #[test]\n     fn test_all() {\n-        assert!(true  == all(~\"\", char::is_uppercase));\n-        assert!(false == all(~\"ymca\", char::is_uppercase));\n-        assert!(true  == all(~\"YMCA\", char::is_uppercase));\n-        assert!(false == all(~\"yMCA\", char::is_uppercase));\n-        assert!(false == all(~\"YMCy\", char::is_uppercase));\n+        assert_eq!(true, all(~\"\", char::is_uppercase));\n+        assert_eq!(false, all(~\"ymca\", char::is_uppercase));\n+        assert_eq!(true, all(~\"YMCA\", char::is_uppercase));\n+        assert_eq!(false, all(~\"yMCA\", char::is_uppercase));\n+        assert_eq!(false, all(~\"YMCy\", char::is_uppercase));\n     }\n \n     #[test]\n     fn test_any() {\n-        assert!(false == any(~\"\", char::is_uppercase));\n-        assert!(false == any(~\"ymca\", char::is_uppercase));\n-        assert!(true  == any(~\"YMCA\", char::is_uppercase));\n-        assert!(true  == any(~\"yMCA\", char::is_uppercase));\n-        assert!(true  == any(~\"Ymcy\", char::is_uppercase));\n+        assert_eq!(false, any(~\"\", char::is_uppercase));\n+        assert_eq!(false, any(~\"ymca\", char::is_uppercase));\n+        assert_eq!(true, any(~\"YMCA\", char::is_uppercase));\n+        assert_eq!(true, any(~\"yMCA\", char::is_uppercase));\n+        assert_eq!(true, any(~\"Ymcy\", char::is_uppercase));\n     }\n \n     #[test]\n@@ -4205,15 +4205,15 @@ mod tests {\n         let mut pos = 0;\n \n         for s.each |b| {\n-            assert!(b == v[pos]);\n+            assert_eq!(b, v[pos]);\n             pos += 1;\n         }\n     }\n \n     #[test]\n     fn test_each_empty() {\n         for \"\".each |b| {\n-            assert!(b == 0u8);\n+            assert_eq!(b, 0u8);\n         }\n     }\n \n@@ -4228,17 +4228,17 @@ mod tests {\n         let mut pos = 0;\n \n         for s.eachi |i, b| {\n-            assert!(pos == i);\n-            assert!(b == v[pos]);\n+            assert_eq!(pos, i);\n+            assert_eq!(b, v[pos]);\n             pos += 1;\n         }\n     }\n \n     #[test]\n     fn test_eachi_empty() {\n         for \"\".eachi |i, b| {\n-            assert!(i == 0);\n-            assert!(b == 0);\n+            assert_eq!(i, 0);\n+            assert_eq!(b, 0);\n         }\n     }\n \n@@ -4254,14 +4254,14 @@ mod tests {\n \n         for s.each_reverse |b| {\n             pos -= 1;\n-            assert!(b == v[pos]);\n+            assert_eq!(b, v[pos]);\n         }\n     }\n \n     #[test]\n     fn test_each_empty_reverse() {\n         for \"\".each_reverse |b| {\n-            assert!(b == 0u8);\n+            assert_eq!(b, 0u8);\n         }\n     }\n \n@@ -4277,16 +4277,16 @@ mod tests {\n \n         for s.eachi_reverse |i, b| {\n             pos -= 1;\n-            assert!(pos == i);\n-            assert!(b == v[pos]);\n+            assert_eq!(pos, i);\n+            assert_eq!(b, v[pos]);\n         }\n     }\n \n     #[test]\n     fn test_eachi_reverse_empty() {\n         for \"\".eachi_reverse |i, b| {\n-            assert!(i == 0);\n-            assert!(b == 0);\n+            assert_eq!(i, 0);\n+            assert_eq!(b, 0);\n         }\n     }\n \n@@ -4296,7 +4296,7 @@ mod tests {\n         let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n         let mut pos = 0;\n         for s.each_char |ch| {\n-            assert!(ch == v[pos]);\n+            assert_eq!(ch, v[pos]);\n             pos += 1;\n         }\n     }\n@@ -4307,8 +4307,8 @@ mod tests {\n         let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n         let mut pos = 0;\n         for s.each_chari |i, ch| {\n-            assert!(pos == i);\n-            assert!(ch == v[pos]);\n+            assert_eq!(pos, i);\n+            assert_eq!(ch, v[pos]);\n             pos += 1;\n         }\n     }\n@@ -4320,7 +4320,7 @@ mod tests {\n         let mut pos = v.len();\n         for s.each_char_reverse |ch| {\n             pos -= 1;\n-            assert!(ch == v[pos]);\n+            assert_eq!(ch, v[pos]);\n         }\n     }\n \n@@ -4331,43 +4331,43 @@ mod tests {\n         let mut pos = v.len();\n         for s.each_chari_reverse |i, ch| {\n             pos -= 1;\n-            assert!(pos == i);\n-            assert!(ch == v[pos]);\n+            assert_eq!(pos, i);\n+            assert_eq!(ch, v[pos]);\n         }\n     }\n \n     #[test]\n     fn test_escape_unicode() {\n-        assert!(escape_unicode(~\"abc\") == ~\"\\\\x61\\\\x62\\\\x63\");\n-        assert!(escape_unicode(~\"a c\") == ~\"\\\\x61\\\\x20\\\\x63\");\n-        assert!(escape_unicode(~\"\\r\\n\\t\") == ~\"\\\\x0d\\\\x0a\\\\x09\");\n-        assert!(escape_unicode(~\"'\\\"\\\\\") == ~\"\\\\x27\\\\x22\\\\x5c\");\n+        assert_eq!(escape_unicode(~\"abc\"), ~\"\\\\x61\\\\x62\\\\x63\");\n+        assert_eq!(escape_unicode(~\"a c\"), ~\"\\\\x61\\\\x20\\\\x63\");\n+        assert_eq!(escape_unicode(~\"\\r\\n\\t\"), ~\"\\\\x0d\\\\x0a\\\\x09\");\n+        assert_eq!(escape_unicode(~\"'\\\"\\\\\"), ~\"\\\\x27\\\\x22\\\\x5c\");\n         assert!(escape_unicode(~\"\\x00\\x01\\xfe\\xff\") ==\n                      ~\"\\\\x00\\\\x01\\\\xfe\\\\xff\");\n-        assert!(escape_unicode(~\"\\u0100\\uffff\") == ~\"\\\\u0100\\\\uffff\");\n+        assert_eq!(escape_unicode(~\"\\u0100\\uffff\"), ~\"\\\\u0100\\\\uffff\");\n         assert!(escape_unicode(~\"\\U00010000\\U0010ffff\") ==\n             ~\"\\\\U00010000\\\\U0010ffff\");\n-        assert!(escape_unicode(~\"ab\\ufb00\") == ~\"\\\\x61\\\\x62\\\\ufb00\");\n-        assert!(escape_unicode(~\"\\U0001d4ea\\r\") == ~\"\\\\U0001d4ea\\\\x0d\");\n+        assert_eq!(escape_unicode(~\"ab\\ufb00\"), ~\"\\\\x61\\\\x62\\\\ufb00\");\n+        assert_eq!(escape_unicode(~\"\\U0001d4ea\\r\"), ~\"\\\\U0001d4ea\\\\x0d\");\n     }\n \n     #[test]\n     fn test_escape_default() {\n-        assert!(escape_default(~\"abc\") == ~\"abc\");\n-        assert!(escape_default(~\"a c\") == ~\"a c\");\n-        assert!(escape_default(~\"\\r\\n\\t\") == ~\"\\\\r\\\\n\\\\t\");\n-        assert!(escape_default(~\"'\\\"\\\\\") == ~\"\\\\'\\\\\\\"\\\\\\\\\");\n-        assert!(escape_default(~\"\\u0100\\uffff\") == ~\"\\\\u0100\\\\uffff\");\n+        assert_eq!(escape_default(~\"abc\"), ~\"abc\");\n+        assert_eq!(escape_default(~\"a c\"), ~\"a c\");\n+        assert_eq!(escape_default(~\"\\r\\n\\t\"), ~\"\\\\r\\\\n\\\\t\");\n+        assert_eq!(escape_default(~\"'\\\"\\\\\"), ~\"\\\\'\\\\\\\"\\\\\\\\\");\n+        assert_eq!(escape_default(~\"\\u0100\\uffff\"), ~\"\\\\u0100\\\\uffff\");\n         assert!(escape_default(~\"\\U00010000\\U0010ffff\") ==\n             ~\"\\\\U00010000\\\\U0010ffff\");\n-        assert!(escape_default(~\"ab\\ufb00\") == ~\"ab\\\\ufb00\");\n-        assert!(escape_default(~\"\\U0001d4ea\\r\") == ~\"\\\\U0001d4ea\\\\r\");\n+        assert_eq!(escape_default(~\"ab\\ufb00\"), ~\"ab\\\\ufb00\");\n+        assert_eq!(escape_default(~\"\\U0001d4ea\\r\"), ~\"\\\\U0001d4ea\\\\r\");\n     }\n \n     #[test]\n     fn test_to_managed() {\n-        assert!((~\"abc\").to_managed() == @\"abc\");\n-        assert!(slice(\"abcdef\", 1, 5).to_managed() == @\"bcde\");\n+        assert_eq!((~\"abc\").to_managed(), @\"abc\");\n+        assert_eq!(slice(\"abcdef\", 1, 5).to_managed(), @\"bcde\");\n     }\n \n     #[test]\n@@ -4381,7 +4381,7 @@ mod tests {\n \n     #[test]\n     fn test_char_range_at_reverse_underflow() {\n-        assert!(char_range_at_reverse(\"abc\", 0).next == 0);\n+        assert_eq!(char_range_at_reverse(\"abc\", 0).next, 0);\n     }\n \n     #[test]"}, {"sha": "fc57cf40d1e01333561768eb84614fc5416a62fa", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -251,26 +251,26 @@ mod tests {\n \n     #[test]\n     fn size_of_basic() {\n-        assert!(size_of::<u8>() == 1u);\n-        assert!(size_of::<u16>() == 2u);\n-        assert!(size_of::<u32>() == 4u);\n-        assert!(size_of::<u64>() == 8u);\n+        assert_eq!(size_of::<u8>(), 1u);\n+        assert_eq!(size_of::<u16>(), 2u);\n+        assert_eq!(size_of::<u32>(), 4u);\n+        assert_eq!(size_of::<u64>(), 8u);\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86\")]\n     #[cfg(target_arch = \"arm\")]\n     #[cfg(target_arch = \"mips\")]\n     fn size_of_32() {\n-        assert!(size_of::<uint>() == 4u);\n-        assert!(size_of::<*uint>() == 4u);\n+        assert_eq!(size_of::<uint>(), 4u);\n+        assert_eq!(size_of::<*uint>(), 4u);\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86_64\")]\n     fn size_of_64() {\n-        assert!(size_of::<uint>() == 8u);\n-        assert!(size_of::<*uint>() == 8u);\n+        assert_eq!(size_of::<uint>(), 8u);\n+        assert_eq!(size_of::<*uint>(), 8u);\n     }\n \n     #[test]\n@@ -284,9 +284,9 @@ mod tests {\n     #[test]\n     fn nonzero_size_of_basic() {\n         type Z = [i8, ..0];\n-        assert!(size_of::<Z>() == 0u);\n-        assert!(nonzero_size_of::<Z>() == 1u);\n-        assert!(nonzero_size_of::<uint>() == size_of::<uint>());\n+        assert_eq!(size_of::<Z>(), 0u);\n+        assert_eq!(nonzero_size_of::<Z>(), 1u);\n+        assert_eq!(nonzero_size_of::<uint>(), size_of::<uint>());\n     }\n \n     #[test]\n@@ -299,25 +299,25 @@ mod tests {\n \n     #[test]\n     fn align_of_basic() {\n-        assert!(pref_align_of::<u8>() == 1u);\n-        assert!(pref_align_of::<u16>() == 2u);\n-        assert!(pref_align_of::<u32>() == 4u);\n+        assert_eq!(pref_align_of::<u8>(), 1u);\n+        assert_eq!(pref_align_of::<u16>(), 2u);\n+        assert_eq!(pref_align_of::<u32>(), 4u);\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86\")]\n     #[cfg(target_arch = \"arm\")]\n     #[cfg(target_arch = \"mips\")]\n     fn align_of_32() {\n-        assert!(pref_align_of::<uint>() == 4u);\n-        assert!(pref_align_of::<*uint>() == 4u);\n+        assert_eq!(pref_align_of::<uint>(), 4u);\n+        assert_eq!(pref_align_of::<*uint>(), 4u);\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86_64\")]\n     fn align_of_64() {\n-        assert!(pref_align_of::<uint>() == 8u);\n-        assert!(pref_align_of::<*uint>() == 8u);\n+        assert_eq!(pref_align_of::<uint>(), 8u);\n+        assert_eq!(pref_align_of::<*uint>(), 8u);\n     }\n \n     #[test]\n@@ -333,7 +333,7 @@ mod tests {\n             let x = 10;\n             let f: &fn(int) -> int = |y| x + y;\n \n-            assert!(f(20) == 30);\n+            assert_eq!(f(20), 30);\n \n             let original_closure: Closure = cast::transmute(f);\n \n@@ -346,7 +346,7 @@ mod tests {\n             };\n \n             let new_f: &fn(int) -> int = cast::transmute(new_closure);\n-            assert!(new_f(20) == 30);\n+            assert_eq!(new_f(20), 30);\n         }\n     }\n "}, {"sha": "e96da3b08c9ce9b6b0db3c30826a548136ee0bc3", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -805,7 +805,7 @@ fn test_future_result() {\n     let mut builder = task();\n     builder.future_result(|r| result = Some(r));\n     do builder.spawn {}\n-    assert!(result.unwrap().recv() == Success);\n+    assert_eq!(result.unwrap().recv(), Success);\n \n     result = None;\n     let mut builder = task();\n@@ -814,7 +814,7 @@ fn test_future_result() {\n     do builder.spawn {\n         fail!();\n     }\n-    assert!(result.unwrap().recv() == Failure);\n+    assert_eq!(result.unwrap().recv(), Failure);\n }\n \n #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -891,7 +891,7 @@ fn test_spawn_sched_childs_on_default_sched() {\n             let ch = ch.take();\n             let child_sched_id = unsafe { rt::rust_get_sched_id() };\n             assert!(parent_sched_id != child_sched_id);\n-            assert!(child_sched_id == default_id);\n+            assert_eq!(child_sched_id, default_id);\n             ch.send(());\n         };\n     };\n@@ -985,7 +985,7 @@ fn avoid_copying_the_body(spawnfn: &fn(v: ~fn())) {\n     }\n \n     let x_in_child = p.recv();\n-    assert!(x_in_parent == x_in_child);\n+    assert_eq!(x_in_parent, x_in_child);\n }\n \n #[test]\n@@ -1143,7 +1143,7 @@ fn test_sched_thread_per_core() {\n         unsafe {\n             let cores = rt::rust_num_threads();\n             let reported_threads = rt::rust_sched_threads();\n-            assert!((cores as uint == reported_threads as uint));\n+            assert_eq!(cores as uint, reported_threads as uint);\n             chan.send(());\n         }\n     }\n@@ -1158,9 +1158,9 @@ fn test_spawn_thread_on_demand() {\n     do spawn_sched(ManualThreads(2)) || {\n         unsafe {\n             let max_threads = rt::rust_sched_threads();\n-            assert!((max_threads as int == 2));\n+            assert_eq!(max_threads as int, 2);\n             let running_threads = rt::rust_sched_current_nonlazy_threads();\n-            assert!((running_threads as int == 1));\n+            assert_eq!(running_threads as int, 1);\n \n             let (port2, chan2) = comm::stream();\n \n@@ -1169,7 +1169,7 @@ fn test_spawn_thread_on_demand() {\n             }\n \n             let running_threads2 = rt::rust_sched_current_nonlazy_threads();\n-            assert!((running_threads2 as int == 2));\n+            assert_eq!(running_threads2 as int, 2);\n \n             port2.recv();\n             chan.send(());"}, {"sha": "2ac8fc5f073ec713d337bac74f93b49ebf81eaaa", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -774,7 +774,7 @@ fn test_spawn_raw_notify_success() {\n     };\n     do spawn_raw(opts) {\n     }\n-    assert!(notify_po.recv() == Success);\n+    assert_eq!(notify_po.recv(), Success);\n }\n \n #[test]\n@@ -791,5 +791,5 @@ fn test_spawn_raw_notify_failure() {\n     do spawn_raw(opts) {\n         fail!();\n     }\n-    assert!(notify_po.recv() == Failure);\n+    assert_eq!(notify_po.recv(), Failure);\n }"}, {"sha": "1469471b7cef3551dd9920f2904f821eb2c10737", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -182,30 +182,30 @@ mod tests {\n     use container::Set;\n     #[test]\n     fn test_simple_types() {\n-        assert!(1i.to_str() == ~\"1\");\n-        assert!((-1i).to_str() == ~\"-1\");\n-        assert!(200u.to_str() == ~\"200\");\n-        assert!(2u8.to_str() == ~\"2\");\n-        assert!(true.to_str() == ~\"true\");\n-        assert!(false.to_str() == ~\"false\");\n-        assert!(().to_str() == ~\"()\");\n-        assert!((~\"hi\").to_str() == ~\"hi\");\n-        assert!((@\"hi\").to_str() == ~\"hi\");\n+        assert_eq!(1i.to_str(), ~\"1\");\n+        assert_eq!((-1i).to_str(), ~\"-1\");\n+        assert_eq!(200u.to_str(), ~\"200\");\n+        assert_eq!(2u8.to_str(), ~\"2\");\n+        assert_eq!(true.to_str(), ~\"true\");\n+        assert_eq!(false.to_str(), ~\"false\");\n+        assert_eq!(().to_str(), ~\"()\");\n+        assert_eq!((~\"hi\").to_str(), ~\"hi\");\n+        assert_eq!((@\"hi\").to_str(), ~\"hi\");\n     }\n \n     #[test]\n     fn test_tuple_types() {\n-        assert!((1, 2).to_str() == ~\"(1, 2)\");\n-        assert!((~\"a\", ~\"b\", false).to_str() == ~\"(a, b, false)\");\n-        assert!(((), ((), 100)).to_str() == ~\"((), ((), 100))\");\n+        assert_eq!((1, 2).to_str(), ~\"(1, 2)\");\n+        assert_eq!((~\"a\", ~\"b\", false).to_str(), ~\"(a, b, false)\");\n+        assert_eq!(((), ((), 100)).to_str(), ~\"((), ((), 100))\");\n     }\n \n     #[test]\n     fn test_vectors() {\n         let x: ~[int] = ~[];\n-        assert!(x.to_str() == ~\"[]\");\n-        assert!((~[1]).to_str() == ~\"[1]\");\n-        assert!((~[1, 2, 3]).to_str() == ~\"[1, 2, 3]\");\n+        assert_eq!(x.to_str(), ~\"[]\");\n+        assert_eq!((~[1]).to_str(), ~\"[1]\");\n+        assert_eq!((~[1, 2, 3]).to_str(), ~\"[1, 2, 3]\");\n         assert!((~[~[], ~[1], ~[1, 1]]).to_str() ==\n                ~\"[[], [1], [1, 1]]\");\n     }\n@@ -221,7 +221,7 @@ mod tests {\n         let table_str = table.to_str();\n \n         assert!(table_str == ~\"{1: 2, 3: 4}\" || table_str == ~\"{3: 4, 1: 2}\");\n-        assert!(empty.to_str() == ~\"{}\");\n+        assert_eq!(empty.to_str(), ~\"{}\");\n     }\n \n     #[test]\n@@ -235,6 +235,6 @@ mod tests {\n         let set_str = set.to_str();\n \n         assert!(set_str == ~\"{1, 2}\" || set_str == ~\"{2, 1}\");\n-        assert!(empty_set.to_str() == ~\"{}\");\n+        assert_eq!(empty_set.to_str(), ~\"{}\");\n     }\n }"}, {"sha": "c9485654b50e47e830f1b5b2f0429c57221087ec", "filename": "src/libcore/trie.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -451,7 +451,7 @@ pub fn check_integrity<T>(trie: &TrieNode<T>) {\n         }\n     }\n \n-    assert!(sum == trie.count);\n+    assert_eq!(sum, trie.count);\n }\n \n #[cfg(test)]\n@@ -521,8 +521,8 @@ mod tests {\n \n         let mut n = 0;\n         for m.each |k, v| {\n-            assert!(*k == n);\n-            assert!(*v == n * 2);\n+            assert_eq!(*k, n);\n+            assert_eq!(*v, n * 2);\n             n += 1;\n         }\n     }\n@@ -540,8 +540,8 @@ mod tests {\n             if n == uint::max_value - 5000 { break }\n             assert!(n < uint::max_value - 5000);\n \n-            assert!(*k == n);\n-            assert!(*v == n / 2);\n+            assert_eq!(*k, n);\n+            assert_eq!(*v, n / 2);\n             n += 1;\n         }\n     }\n@@ -558,8 +558,8 @@ mod tests {\n \n         let mut n = 4;\n         for m.each_reverse |k, v| {\n-            assert!(*k == n);\n-            assert!(*v == n * 2);\n+            assert_eq!(*k, n);\n+            assert_eq!(*v, n * 2);\n             n -= 1;\n         }\n     }\n@@ -577,8 +577,8 @@ mod tests {\n             if n == uint::max_value - 5000 { break }\n             assert!(n > uint::max_value - 5000);\n \n-            assert!(*k == n);\n-            assert!(*v == n / 2);\n+            assert_eq!(*k, n);\n+            assert_eq!(*v, n / 2);\n             n -= 1;\n         }\n     }\n@@ -593,31 +593,31 @@ mod tests {\n         assert!(trie.insert(x));\n         assert!(trie.insert(y));\n \n-        assert!(trie.len() == 2);\n+        assert_eq!(trie.len(), 2);\n \n         let expected = [x, y];\n \n         let mut i = 0;\n \n         for trie.each |x| {\n-            assert!(expected[i] == *x);\n+            assert_eq!(expected[i], *x);\n             i += 1;\n         }\n     }\n \n     #[test]\n     fn test_swap() {\n         let mut m = TrieMap::new();\n-        assert!(m.swap(1, 2) == None);\n-        assert!(m.swap(1, 3) == Some(2));\n-        assert!(m.swap(1, 4) == Some(3));\n+        assert_eq!(m.swap(1, 2), None);\n+        assert_eq!(m.swap(1, 3), Some(2));\n+        assert_eq!(m.swap(1, 4), Some(3));\n     }\n \n     #[test]\n     fn test_pop() {\n         let mut m = TrieMap::new();\n         m.insert(1, 2);\n-        assert!(m.pop(&1) == Some(2));\n-        assert!(m.pop(&1) == None);\n+        assert_eq!(m.pop(&1), Some(2));\n+        assert_eq!(m.pop(&1), None);\n     }\n }"}, {"sha": "d214b509dfbf9d2810d7f34906902b0f97f801dc", "filename": "src/libcore/unstable/at_exit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Funstable%2Fat_exit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Funstable%2Fat_exit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fat_exit.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -83,7 +83,7 @@ fn test_at_exit() {\n     let i = 10;\n     do at_exit {\n         debug!(\"at_exit1\");\n-        assert!(i == 10);\n+        assert_eq!(i, 10);\n     }\n }\n \n@@ -93,7 +93,7 @@ fn test_at_exit_many() {\n     for uint::range(20, 100) |j| {\n         do at_exit {\n             debug!(\"at_exit2\");\n-            assert!(i == 10);\n+            assert_eq!(i, 10);\n             assert!(j > i);\n         }\n     }"}, {"sha": "1a1a89a413fcc95e956f5bedd1d349f0c2f8c16f", "filename": "src/libcore/unstable/extfmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fextfmt.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -355,8 +355,8 @@ pub mod ct {\n \n         fn test(s: &str, flags: &[Flag], next: uint) {\n             let f = parse_flags(s, 0, s.len());\n-            assert!(pack(f.val) == pack(flags));\n-            assert!(f.next == next);\n+            assert_eq!(pack(f.val), pack(flags));\n+            assert_eq!(f.next, next);\n         }\n \n         test(\"\", [], 0);\n@@ -459,10 +459,10 @@ pub mod ct {\n         assert!(peek_num(s2, 0, s2.len()).is_none());\n \n         let s3 = \"123\";\n-        assert!(peek_num(s3, 0, s3.len()) == Some(Parsed::new(123, 3)));\n+        assert_eq!(peek_num(s3, 0, s3.len()), Some(Parsed::new(123, 3)));\n \n         let s4 = \"123foo\";\n-        assert!(peek_num(s4, 0, s4.len()) == Some(Parsed::new(123, 3)));\n+        assert_eq!(peek_num(s4, 0, s4.len()), Some(Parsed::new(123, 3)));\n     }\n }\n "}, {"sha": "5001fb421cd86e33199de205fe80df5e7cffa467", "filename": "src/libcore/unstable/finally.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Ffinally.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -79,10 +79,10 @@ fn test_success() {\n         i = 10;\n     }).finally {\n         assert!(!failing());\n-        assert!(i == 10);\n+        assert_eq!(i, 10);\n         i = 20;\n     }\n-    assert!(i == 20);\n+    assert_eq!(i, 20);\n }\n \n #[test]\n@@ -95,15 +95,15 @@ fn test_fail() {\n         fail!();\n     }).finally {\n         assert!(failing());\n-        assert!(i == 10);\n+        assert_eq!(i, 10);\n     }\n }\n \n #[test]\n fn test_retval() {\n     let closure: &fn() -> int = || 10;\n     let i = do closure.finally { };\n-    assert!(i == 10);\n+    assert_eq!(i, 10);\n }\n \n #[test]\n@@ -134,6 +134,6 @@ fn test_managed() {\n         *i += 10;\n         r\n     };\n-    assert!(do managed.finally {} == 10);\n-    assert!(*i == 20);\n+    assert_eq!(do managed.finally {}, 10);\n+    assert_eq!(*i, 20);\n }\n\\ No newline at end of file"}, {"sha": "96549a83a8cf397620d7896deb03c0a504072dac", "filename": "src/libcore/unstable/global.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Funstable%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Funstable%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fglobal.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -200,7 +200,7 @@ fn get_global_state() -> Exclusive<GlobalState> {\n                 let prev_i = unsafe {\n                     atomic_cxchg(&mut *global_ptr, state_i, POISON)\n                 };\n-                assert!(prev_i == state_i);\n+                assert_eq!(prev_i, state_i);\n \n                 // Capture the global state object in the at_exit closure\n                 // so that it is destroyed at the right time"}, {"sha": "9681a3f36fcee4924491f178f040371f68b11f73", "filename": "src/libcore/unstable/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fmod.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -55,7 +55,7 @@ pub fn run_in_bare_thread(f: ~fn()) {\n fn test_run_in_bare_thread() {\n     let i = 100;\n     do run_in_bare_thread {\n-        assert!(i == 100);\n+        assert_eq!(i, 100);\n     }\n }\n "}, {"sha": "091031f51fd8a5b43177b04b9b23f76be5d41f30", "filename": "src/libcore/unstable/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fsync.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -275,11 +275,11 @@ mod tests {\n         let x2 = x.clone();\n         do task::try || {\n             do x2.with |one| {\n-                assert!(*one == 2);\n+                assert_eq!(*one, 2);\n             }\n         };\n         do x.with |one| {\n-            assert!(*one == 1);\n+            assert_eq!(*one, 1);\n         }\n     }\n }"}, {"sha": "eaf1e31d403ad55e359ee21420e5eca41d4fa648", "filename": "src/libcore/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -193,8 +193,8 @@ mod tests {\n         let mut x = 31337;\n         let mut y = 42;\n         swap(&mut x, &mut y);\n-        assert!(x == 42);\n-        assert!(y == 31337);\n+        assert_eq!(x, 42);\n+        assert_eq!(y, 31337);\n     }\n     #[test]\n     pub fn test_replace() {"}, {"sha": "f12e70faa8f80e5d089335f2dd489142ac72e061", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 288, "deletions": 288, "changes": 576, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -1389,7 +1389,7 @@ pub fn zip_slice<T:Copy,U:Copy>(v: &const [T], u: &const [U])\n     let mut zipped = ~[];\n     let sz = len(v);\n     let mut i = 0u;\n-    assert!(sz == len(u));\n+    assert_eq!(sz, len(u));\n     while i < sz {\n         zipped.push((v[i], u[i]));\n         i += 1u;\n@@ -1405,7 +1405,7 @@ pub fn zip_slice<T:Copy,U:Copy>(v: &const [T], u: &const [U])\n  */\n pub fn zip<T, U>(mut v: ~[T], mut u: ~[U]) -> ~[(T, U)] {\n     let mut i = len(v);\n-    assert!(i == len(u));\n+    assert_eq!(i, len(u));\n     let mut w = with_capacity(i);\n     while i > 0 {\n         w.push((v.pop(),u.pop()));\n@@ -1723,7 +1723,7 @@ pub fn eachi_reverse<'r,T>(v: &'r [T],\n  */\n #[inline]\n pub fn _each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) -> bool {\n-    assert!(v1.len() == v2.len());\n+    assert_eq!(v1.len(), v2.len());\n     for uint::range(0u, v1.len()) |i| {\n         if !f(&v1[i], &v2[i]) {\n             return false;\n@@ -1751,7 +1751,7 @@ pub fn each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) -> bool {\n  */\n #[inline]\n pub fn _each2_mut<U, T>(v1: &mut [U], v2: &mut [T], f: &fn(u: &mut U, t: &mut T) -> bool) -> bool {\n-    assert!(v1.len() == v2.len());\n+    assert_eq!(v1.len(), v2.len());\n     for uint::range(0u, v1.len()) |i| {\n         if !f(&mut v1[i], &mut v2[i]) {\n             return false;\n@@ -3139,59 +3139,59 @@ mod tests {\n             let a = ~[1, 2, 3];\n             let mut ptr = raw::to_ptr(a);\n             let b = from_buf(ptr, 3u);\n-            assert!(b.len() == 3u);\n-            assert!(b[0] == 1);\n-            assert!(b[1] == 2);\n-            assert!(b[2] == 3);\n+            assert_eq!(b.len(), 3u);\n+            assert_eq!(b[0], 1);\n+            assert_eq!(b[1], 2);\n+            assert_eq!(b[2], 3);\n \n             // Test on-heap copy-from-buf.\n             let c = ~[1, 2, 3, 4, 5];\n             ptr = raw::to_ptr(c);\n             let d = from_buf(ptr, 5u);\n-            assert!(d.len() == 5u);\n-            assert!(d[0] == 1);\n-            assert!(d[1] == 2);\n-            assert!(d[2] == 3);\n-            assert!(d[3] == 4);\n-            assert!(d[4] == 5);\n+            assert_eq!(d.len(), 5u);\n+            assert_eq!(d[0], 1);\n+            assert_eq!(d[1], 2);\n+            assert_eq!(d[2], 3);\n+            assert_eq!(d[3], 4);\n+            assert_eq!(d[4], 5);\n         }\n     }\n \n     #[test]\n     fn test_from_fn() {\n         // Test on-stack from_fn.\n         let mut v = from_fn(3u, square);\n-        assert!(v.len() == 3u);\n-        assert!(v[0] == 0u);\n-        assert!(v[1] == 1u);\n-        assert!(v[2] == 4u);\n+        assert_eq!(v.len(), 3u);\n+        assert_eq!(v[0], 0u);\n+        assert_eq!(v[1], 1u);\n+        assert_eq!(v[2], 4u);\n \n         // Test on-heap from_fn.\n         v = from_fn(5u, square);\n-        assert!(v.len() == 5u);\n-        assert!(v[0] == 0u);\n-        assert!(v[1] == 1u);\n-        assert!(v[2] == 4u);\n-        assert!(v[3] == 9u);\n-        assert!(v[4] == 16u);\n+        assert_eq!(v.len(), 5u);\n+        assert_eq!(v[0], 0u);\n+        assert_eq!(v[1], 1u);\n+        assert_eq!(v[2], 4u);\n+        assert_eq!(v[3], 9u);\n+        assert_eq!(v[4], 16u);\n     }\n \n     #[test]\n     fn test_from_elem() {\n         // Test on-stack from_elem.\n         let mut v = from_elem(2u, 10u);\n-        assert!(v.len() == 2u);\n-        assert!(v[0] == 10u);\n-        assert!(v[1] == 10u);\n+        assert_eq!(v.len(), 2u);\n+        assert_eq!(v[0], 10u);\n+        assert_eq!(v[1], 10u);\n \n         // Test on-heap from_elem.\n         v = from_elem(6u, 20u);\n-        assert!(v[0] == 20u);\n-        assert!(v[1] == 20u);\n-        assert!(v[2] == 20u);\n-        assert!(v[3] == 20u);\n-        assert!(v[4] == 20u);\n-        assert!(v[5] == 20u);\n+        assert_eq!(v[0], 20u);\n+        assert_eq!(v[1], 20u);\n+        assert_eq!(v[2], 20u);\n+        assert_eq!(v[3], 20u);\n+        assert_eq!(v[4], 20u);\n+        assert_eq!(v[5], 20u);\n     }\n \n     #[test]\n@@ -3206,18 +3206,18 @@ mod tests {\n         let v0 : &[Z] = &[];\n         let v1 : &[Z] = &[[]];\n         let v2 : &[Z] = &[[], []];\n-        assert!(sys::size_of::<Z>() == 0);\n-        assert!(v0.len() == 0);\n-        assert!(v1.len() == 1);\n-        assert!(v2.len() == 2);\n+        assert_eq!(sys::size_of::<Z>(), 0);\n+        assert_eq!(v0.len(), 0);\n+        assert_eq!(v1.len(), 1);\n+        assert_eq!(v2.len(), 2);\n     }\n \n     #[test]\n     fn test_head() {\n         let mut a = ~[11];\n-        assert!(a.head() == &11);\n+        assert_eq!(a.head(), &11);\n         a = ~[11, 12];\n-        assert!(a.head() == &11);\n+        assert_eq!(a.head(), &11);\n     }\n \n     #[test]\n@@ -3231,19 +3231,19 @@ mod tests {\n     #[test]\n     fn test_head_opt() {\n         let mut a = ~[];\n-        assert!(a.head_opt() == None);\n+        assert_eq!(a.head_opt(), None);\n         a = ~[11];\n-        assert!(a.head_opt().unwrap() == &11);\n+        assert_eq!(a.head_opt().unwrap(), &11);\n         a = ~[11, 12];\n-        assert!(a.head_opt().unwrap() == &11);\n+        assert_eq!(a.head_opt().unwrap(), &11);\n     }\n \n     #[test]\n     fn test_tail() {\n         let mut a = ~[11];\n-        assert!(a.tail() == &[]);\n+        assert_eq!(a.tail(), &[]);\n         a = ~[11, 12];\n-        assert!(a.tail() == &[12]);\n+        assert_eq!(a.tail(), &[12]);\n     }\n \n     #[test]\n@@ -3257,9 +3257,9 @@ mod tests {\n     #[test]\n     fn test_tailn() {\n         let mut a = ~[11, 12, 13];\n-        assert!(a.tailn(0) == &[11, 12, 13]);\n+        assert_eq!(a.tailn(0), &[11, 12, 13]);\n         a = ~[11, 12, 13];\n-        assert!(a.tailn(2) == &[13]);\n+        assert_eq!(a.tailn(2), &[13]);\n     }\n \n     #[test]\n@@ -3273,9 +3273,9 @@ mod tests {\n     #[test]\n     fn test_init() {\n         let mut a = ~[11];\n-        assert!(a.init() == &[]);\n+        assert_eq!(a.init(), &[]);\n         a = ~[11, 12];\n-        assert!(a.init() == &[11]);\n+        assert_eq!(a.init(), &[11]);\n     }\n \n     #[init]\n@@ -3289,9 +3289,9 @@ mod tests {\n     #[test]\n     fn test_initn() {\n         let mut a = ~[11, 12, 13];\n-        assert!(a.initn(0) == &[11, 12, 13]);\n+        assert_eq!(a.initn(0), &[11, 12, 13]);\n         a = ~[11, 12, 13];\n-        assert!(a.initn(2) == &[11]);\n+        assert_eq!(a.initn(2), &[11]);\n     }\n \n     #[init]\n@@ -3305,9 +3305,9 @@ mod tests {\n     #[test]\n     fn test_last() {\n         let mut a = ~[11];\n-        assert!(a.last() == &11);\n+        assert_eq!(a.last(), &11);\n         a = ~[11, 12];\n-        assert!(a.last() == &12);\n+        assert_eq!(a.last(), &12);\n     }\n \n     #[test]\n@@ -3321,75 +3321,75 @@ mod tests {\n     #[test]\n     fn test_last_opt() {\n         let mut a = ~[];\n-        assert!(a.last_opt() == None);\n+        assert_eq!(a.last_opt(), None);\n         a = ~[11];\n-        assert!(a.last_opt().unwrap() == &11);\n+        assert_eq!(a.last_opt().unwrap(), &11);\n         a = ~[11, 12];\n-        assert!(a.last_opt().unwrap() == &12);\n+        assert_eq!(a.last_opt().unwrap(), &12);\n     }\n \n     #[test]\n     fn test_slice() {\n         // Test fixed length vector.\n         let vec_fixed = [1, 2, 3, 4];\n         let v_a = slice(vec_fixed, 1u, vec_fixed.len()).to_vec();\n-        assert!(v_a.len() == 3u);\n-        assert!(v_a[0] == 2);\n-        assert!(v_a[1] == 3);\n-        assert!(v_a[2] == 4);\n+        assert_eq!(v_a.len(), 3u);\n+        assert_eq!(v_a[0], 2);\n+        assert_eq!(v_a[1], 3);\n+        assert_eq!(v_a[2], 4);\n \n         // Test on stack.\n         let vec_stack = &[1, 2, 3];\n         let v_b = slice(vec_stack, 1u, 3u).to_vec();\n-        assert!(v_b.len() == 2u);\n-        assert!(v_b[0] == 2);\n-        assert!(v_b[1] == 3);\n+        assert_eq!(v_b.len(), 2u);\n+        assert_eq!(v_b[0], 2);\n+        assert_eq!(v_b[1], 3);\n \n         // Test on managed heap.\n         let vec_managed = @[1, 2, 3, 4, 5];\n         let v_c = slice(vec_managed, 0u, 3u).to_vec();\n-        assert!(v_c.len() == 3u);\n-        assert!(v_c[0] == 1);\n-        assert!(v_c[1] == 2);\n-        assert!(v_c[2] == 3);\n+        assert_eq!(v_c.len(), 3u);\n+        assert_eq!(v_c[0], 1);\n+        assert_eq!(v_c[1], 2);\n+        assert_eq!(v_c[2], 3);\n \n         // Test on exchange heap.\n         let vec_unique = ~[1, 2, 3, 4, 5, 6];\n         let v_d = slice(vec_unique, 1u, 6u).to_vec();\n-        assert!(v_d.len() == 5u);\n-        assert!(v_d[0] == 2);\n-        assert!(v_d[1] == 3);\n-        assert!(v_d[2] == 4);\n-        assert!(v_d[3] == 5);\n-        assert!(v_d[4] == 6);\n+        assert_eq!(v_d.len(), 5u);\n+        assert_eq!(v_d[0], 2);\n+        assert_eq!(v_d[1], 3);\n+        assert_eq!(v_d[2], 4);\n+        assert_eq!(v_d[3], 5);\n+        assert_eq!(v_d[4], 6);\n     }\n \n     #[test]\n     fn test_pop() {\n         // Test on-heap pop.\n         let mut v = ~[1, 2, 3, 4, 5];\n         let e = v.pop();\n-        assert!(v.len() == 4u);\n-        assert!(v[0] == 1);\n-        assert!(v[1] == 2);\n-        assert!(v[2] == 3);\n-        assert!(v[3] == 4);\n-        assert!(e == 5);\n+        assert_eq!(v.len(), 4u);\n+        assert_eq!(v[0], 1);\n+        assert_eq!(v[1], 2);\n+        assert_eq!(v[2], 3);\n+        assert_eq!(v[3], 4);\n+        assert_eq!(e, 5);\n     }\n \n     #[test]\n     fn test_swap_remove() {\n         let mut v = ~[1, 2, 3, 4, 5];\n         let mut e = v.swap_remove(0);\n-        assert!(v.len() == 4);\n-        assert!(e == 1);\n-        assert!(v[0] == 5);\n+        assert_eq!(v.len(), 4);\n+        assert_eq!(e, 1);\n+        assert_eq!(v[0], 5);\n         e = v.swap_remove(3);\n-        assert!(v.len() == 3);\n-        assert!(e == 4);\n-        assert!(v[0] == 5);\n-        assert!(v[1] == 2);\n-        assert!(v[2] == 3);\n+        assert_eq!(v.len(), 3);\n+        assert_eq!(e, 4);\n+        assert_eq!(v[0], 5);\n+        assert_eq!(v[1], 2);\n+        assert_eq!(v[2], 3);\n     }\n \n     #[test]\n@@ -3399,83 +3399,83 @@ mod tests {\n                       ::unstable::sync::exclusive(()),\n                       ::unstable::sync::exclusive(())];\n         let mut _e = v.swap_remove(0);\n-        assert!(v.len() == 2);\n+        assert_eq!(v.len(), 2);\n         _e = v.swap_remove(1);\n-        assert!(v.len() == 1);\n+        assert_eq!(v.len(), 1);\n         _e = v.swap_remove(0);\n-        assert!(v.len() == 0);\n+        assert_eq!(v.len(), 0);\n     }\n \n     #[test]\n     fn test_push() {\n         // Test on-stack push().\n         let mut v = ~[];\n         v.push(1);\n-        assert!(v.len() == 1u);\n-        assert!(v[0] == 1);\n+        assert_eq!(v.len(), 1u);\n+        assert_eq!(v[0], 1);\n \n         // Test on-heap push().\n         v.push(2);\n-        assert!(v.len() == 2u);\n-        assert!(v[0] == 1);\n-        assert!(v[1] == 2);\n+        assert_eq!(v.len(), 2u);\n+        assert_eq!(v[0], 1);\n+        assert_eq!(v[1], 2);\n     }\n \n     #[test]\n     fn test_grow() {\n         // Test on-stack grow().\n         let mut v = ~[];\n         v.grow(2u, &1);\n-        assert!(v.len() == 2u);\n-        assert!(v[0] == 1);\n-        assert!(v[1] == 1);\n+        assert_eq!(v.len(), 2u);\n+        assert_eq!(v[0], 1);\n+        assert_eq!(v[1], 1);\n \n         // Test on-heap grow().\n         v.grow(3u, &2);\n-        assert!(v.len() == 5u);\n-        assert!(v[0] == 1);\n-        assert!(v[1] == 1);\n-        assert!(v[2] == 2);\n-        assert!(v[3] == 2);\n-        assert!(v[4] == 2);\n+        assert_eq!(v.len(), 5u);\n+        assert_eq!(v[0], 1);\n+        assert_eq!(v[1], 1);\n+        assert_eq!(v[2], 2);\n+        assert_eq!(v[3], 2);\n+        assert_eq!(v[4], 2);\n     }\n \n     #[test]\n     fn test_grow_fn() {\n         let mut v = ~[];\n         v.grow_fn(3u, square);\n-        assert!(v.len() == 3u);\n-        assert!(v[0] == 0u);\n-        assert!(v[1] == 1u);\n-        assert!(v[2] == 4u);\n+        assert_eq!(v.len(), 3u);\n+        assert_eq!(v[0], 0u);\n+        assert_eq!(v[1], 1u);\n+        assert_eq!(v[2], 4u);\n     }\n \n     #[test]\n     fn test_grow_set() {\n         let mut v = ~[1, 2, 3];\n         v.grow_set(4u, &4, 5);\n-        assert!(v.len() == 5u);\n-        assert!(v[0] == 1);\n-        assert!(v[1] == 2);\n-        assert!(v[2] == 3);\n-        assert!(v[3] == 4);\n-        assert!(v[4] == 5);\n+        assert_eq!(v.len(), 5u);\n+        assert_eq!(v[0], 1);\n+        assert_eq!(v[1], 2);\n+        assert_eq!(v[2], 3);\n+        assert_eq!(v[3], 4);\n+        assert_eq!(v[4], 5);\n     }\n \n     #[test]\n     fn test_truncate() {\n         let mut v = ~[@6,@5,@4];\n         v.truncate(1);\n-        assert!(v.len() == 1);\n-        assert!(*(v[0]) == 6);\n+        assert_eq!(v.len(), 1);\n+        assert_eq!(*(v[0]), 6);\n         // If the unsafe block didn't drop things properly, we blow up here.\n     }\n \n     #[test]\n     fn test_clear() {\n         let mut v = ~[@6,@5,@4];\n         v.clear();\n-        assert!(v.len() == 0);\n+        assert_eq!(v.len(), 0);\n         // If the unsafe block didn't drop things properly, we blow up here.\n     }\n \n@@ -3484,7 +3484,7 @@ mod tests {\n         fn case(a: ~[uint], b: ~[uint]) {\n             let mut v = a;\n             v.dedup();\n-            assert!(v == b);\n+            assert_eq!(v, b);\n         }\n         case(~[], ~[]);\n         case(~[1], ~[1]);\n@@ -3529,20 +3529,20 @@ mod tests {\n         // Test on-stack map.\n         let mut v = ~[1u, 2u, 3u];\n         let mut w = map(v, square_ref);\n-        assert!(w.len() == 3u);\n-        assert!(w[0] == 1u);\n-        assert!(w[1] == 4u);\n-        assert!(w[2] == 9u);\n+        assert_eq!(w.len(), 3u);\n+        assert_eq!(w[0], 1u);\n+        assert_eq!(w[1], 4u);\n+        assert_eq!(w[2], 9u);\n \n         // Test on-heap map.\n         v = ~[1u, 2u, 3u, 4u, 5u];\n         w = map(v, square_ref);\n-        assert!(w.len() == 5u);\n-        assert!(w[0] == 1u);\n-        assert!(w[1] == 4u);\n-        assert!(w[2] == 9u);\n-        assert!(w[3] == 16u);\n-        assert!(w[4] == 25u);\n+        assert_eq!(w.len(), 5u);\n+        assert_eq!(w[0], 1u);\n+        assert_eq!(w[1], 4u);\n+        assert_eq!(w[2], 9u);\n+        assert_eq!(w[3], 16u);\n+        assert_eq!(w[4], 25u);\n     }\n \n     #[test]\n@@ -3561,17 +3561,17 @@ mod tests {\n         // Test on-stack filter-map.\n         let mut v = ~[1u, 2u, 3u];\n         let mut w = filter_mapped(v, square_if_odd_r);\n-        assert!(w.len() == 2u);\n-        assert!(w[0] == 1u);\n-        assert!(w[1] == 9u);\n+        assert_eq!(w.len(), 2u);\n+        assert_eq!(w[0], 1u);\n+        assert_eq!(w[1], 9u);\n \n         // Test on-heap filter-map.\n         v = ~[1u, 2u, 3u, 4u, 5u];\n         w = filter_mapped(v, square_if_odd_r);\n-        assert!(w.len() == 3u);\n-        assert!(w[0] == 1u);\n-        assert!(w[1] == 9u);\n-        assert!(w[2] == 25u);\n+        assert_eq!(w.len(), 3u);\n+        assert_eq!(w[0], 1u);\n+        assert_eq!(w[1], 9u);\n+        assert_eq!(w[2], 25u);\n \n         fn halve(i: &int) -> Option<int> {\n             if *i % 2 == 0 {\n@@ -3588,27 +3588,27 @@ mod tests {\n         let mix_dest: ~[int] = ~[1, 3, 0, 0];\n         assert!(filter_mapped(all_even, halve) ==\n                      map(all_even, halve_for_sure));\n-        assert!(filter_mapped(all_odd1, halve) == ~[]);\n-        assert!(filter_mapped(all_odd2, halve) == ~[]);\n-        assert!(filter_mapped(mix, halve) == mix_dest);\n+        assert_eq!(filter_mapped(all_odd1, halve), ~[]);\n+        assert_eq!(filter_mapped(all_odd2, halve), ~[]);\n+        assert_eq!(filter_mapped(mix, halve), mix_dest);\n     }\n \n     #[test]\n     fn test_filter_map() {\n         // Test on-stack filter-map.\n         let mut v = ~[1u, 2u, 3u];\n         let mut w = filter_map(v, square_if_odd_v);\n-        assert!(w.len() == 2u);\n-        assert!(w[0] == 1u);\n-        assert!(w[1] == 9u);\n+        assert_eq!(w.len(), 2u);\n+        assert_eq!(w[0], 1u);\n+        assert_eq!(w[1], 9u);\n \n         // Test on-heap filter-map.\n         v = ~[1u, 2u, 3u, 4u, 5u];\n         w = filter_map(v, square_if_odd_v);\n-        assert!(w.len() == 3u);\n-        assert!(w[0] == 1u);\n-        assert!(w[1] == 9u);\n-        assert!(w[2] == 25u);\n+        assert_eq!(w.len(), 3u);\n+        assert_eq!(w[0], 1u);\n+        assert_eq!(w[1], 9u);\n+        assert_eq!(w[2], 25u);\n \n         fn halve(i: int) -> Option<int> {\n             if i % 2 == 0 {\n@@ -3626,35 +3626,35 @@ mod tests {\n         let mix_dest: ~[int] = ~[1, 3, 0, 0];\n         assert!(filter_map(all_even, halve) ==\n                      map(all_even0, halve_for_sure));\n-        assert!(filter_map(all_odd1, halve) == ~[]);\n-        assert!(filter_map(all_odd2, halve) == ~[]);\n-        assert!(filter_map(mix, halve) == mix_dest);\n+        assert_eq!(filter_map(all_odd1, halve), ~[]);\n+        assert_eq!(filter_map(all_odd2, halve), ~[]);\n+        assert_eq!(filter_map(mix, halve), mix_dest);\n     }\n \n     #[test]\n     fn test_filter() {\n-        assert!(filter(~[1u, 2u, 3u], is_odd) == ~[1u, 3u]);\n-        assert!(filter(~[1u, 2u, 4u, 8u, 16u], is_three) == ~[]);\n+        assert_eq!(filter(~[1u, 2u, 3u], is_odd), ~[1u, 3u]);\n+        assert_eq!(filter(~[1u, 2u, 4u, 8u, 16u], is_three), ~[]);\n     }\n \n     #[test]\n     fn test_retain() {\n         let mut v = ~[1, 2, 3, 4, 5];\n         v.retain(is_odd);\n-        assert!(v == ~[1, 3, 5]);\n+        assert_eq!(v, ~[1, 3, 5]);\n     }\n \n     #[test]\n     fn test_foldl() {\n         // Test on-stack fold.\n         let mut v = ~[1u, 2u, 3u];\n         let mut sum = foldl(0u, v, add);\n-        assert!(sum == 6u);\n+        assert_eq!(sum, 6u);\n \n         // Test on-heap fold.\n         v = ~[1u, 2u, 3u, 4u, 5u];\n         sum = foldl(0u, v, add);\n-        assert!(sum == 15u);\n+        assert_eq!(sum, 15u);\n     }\n \n     #[test]\n@@ -3664,7 +3664,7 @@ mod tests {\n         }\n         let v = ~[1, 2, 3, 4];\n         let sum = foldl(0, v, sub);\n-        assert!(sum == -10);\n+        assert_eq!(sum, -10);\n     }\n \n     #[test]\n@@ -3674,7 +3674,7 @@ mod tests {\n         }\n         let v = ~[1, 2, 3, 4];\n         let sum = foldr(v, 0, sub);\n-        assert!(sum == -2);\n+        assert_eq!(sum, -2);\n     }\n \n     #[test]\n@@ -3690,18 +3690,18 @@ mod tests {\n         for each(~[1, 2, 3]) |v| {\n             i += *v;\n         }\n-        assert!(i == 6);\n+        assert_eq!(i, 6);\n     }\n \n     #[test]\n     fn test_eachi() {\n         let mut i = 0;\n         for eachi(~[1, 2, 3]) |j, v| {\n             if i == 0 { assert!(*v == 1); }\n-            assert!(j + 1u == *v as uint);\n+            assert_eq!(j + 1u, *v as uint);\n             i += *v;\n         }\n-        assert!(i == 6);\n+        assert_eq!(i, 6);\n     }\n \n     #[test]\n@@ -3719,18 +3719,18 @@ mod tests {\n             if i == 0 { assert!(*v == 3); }\n             i += *v\n         }\n-        assert!(i == 6);\n+        assert_eq!(i, 6);\n     }\n \n     #[test]\n     fn test_eachi_reverse() {\n         let mut i = 0;\n         for eachi_reverse(~[0, 1, 2]) |j, v| {\n             if i == 0 { assert!(*v == 2); }\n-            assert!(j == *v as uint);\n+            assert_eq!(j, *v as uint);\n             i += *v;\n         }\n-        assert!(i == 3);\n+        assert_eq!(i, 3);\n     }\n \n     #[test]\n@@ -3747,15 +3747,15 @@ mod tests {\n \n         results = ~[];\n         for each_permutation(~[]) |v| { results.push(to_owned(v)); }\n-        assert!(results == ~[~[]]);\n+        assert_eq!(results, ~[~[]]);\n \n         results = ~[];\n         for each_permutation(~[7]) |v| { results.push(to_owned(v)); }\n-        assert!(results == ~[~[7]]);\n+        assert_eq!(results, ~[~[7]]);\n \n         results = ~[];\n         for each_permutation(~[1,1]) |v| { results.push(to_owned(v)); }\n-        assert!(results == ~[~[1,1],~[1,1]]);\n+        assert_eq!(results, ~[~[1,1],~[1,1]]);\n \n         results = ~[];\n         for each_permutation(~[5,2,0]) |v| { results.push(to_owned(v)); }\n@@ -3797,25 +3797,25 @@ mod tests {\n \n         let z1 = zip(v1, v2);\n \n-        assert!((1, 4) == z1[0]);\n-        assert!((2, 5) == z1[1]);\n-        assert!((3, 6) == z1[2]);\n+        assert_eq!((1, 4), z1[0]);\n+        assert_eq!((2, 5), z1[1]);\n+        assert_eq!((3, 6), z1[2]);\n \n         let (left, right) = unzip(z1);\n \n-        assert!((1, 4) == (left[0], right[0]));\n-        assert!((2, 5) == (left[1], right[1]));\n-        assert!((3, 6) == (left[2], right[2]));\n+        assert_eq!((1, 4), (left[0], right[0]));\n+        assert_eq!((2, 5), (left[1], right[1]));\n+        assert_eq!((3, 6), (left[2], right[2]));\n     }\n \n     #[test]\n     fn test_position_elem() {\n         assert!(position_elem(~[], &1).is_none());\n \n         let v1 = ~[1, 2, 3, 3, 2, 5];\n-        assert!(position_elem(v1, &1) == Some(0u));\n-        assert!(position_elem(v1, &2) == Some(1u));\n-        assert!(position_elem(v1, &5) == Some(5u));\n+        assert_eq!(position_elem(v1, &1), Some(0u));\n+        assert_eq!(position_elem(v1, &2), Some(1u));\n+        assert_eq!(position_elem(v1, &5), Some(5u));\n         assert!(position_elem(v1, &4).is_none());\n     }\n \n@@ -3827,7 +3827,7 @@ mod tests {\n         assert!(position(~[], less_than_three).is_none());\n \n         let v1 = ~[5, 4, 3, 2, 1];\n-        assert!(position(v1, less_than_three) == Some(3u));\n+        assert_eq!(position(v1, less_than_three), Some(3u));\n         assert!(position(v1, is_eighteen).is_none());\n     }\n \n@@ -3840,21 +3840,21 @@ mod tests {\n \n         assert!(position_between(v, 0u, 0u, f).is_none());\n         assert!(position_between(v, 0u, 1u, f).is_none());\n-        assert!(position_between(v, 0u, 2u, f) == Some(1u));\n-        assert!(position_between(v, 0u, 3u, f) == Some(1u));\n-        assert!(position_between(v, 0u, 4u, f) == Some(1u));\n+        assert_eq!(position_between(v, 0u, 2u, f), Some(1u));\n+        assert_eq!(position_between(v, 0u, 3u, f), Some(1u));\n+        assert_eq!(position_between(v, 0u, 4u, f), Some(1u));\n \n         assert!(position_between(v, 1u, 1u, f).is_none());\n-        assert!(position_between(v, 1u, 2u, f) == Some(1u));\n-        assert!(position_between(v, 1u, 3u, f) == Some(1u));\n-        assert!(position_between(v, 1u, 4u, f) == Some(1u));\n+        assert_eq!(position_between(v, 1u, 2u, f), Some(1u));\n+        assert_eq!(position_between(v, 1u, 3u, f), Some(1u));\n+        assert_eq!(position_between(v, 1u, 4u, f), Some(1u));\n \n         assert!(position_between(v, 2u, 2u, f).is_none());\n         assert!(position_between(v, 2u, 3u, f).is_none());\n-        assert!(position_between(v, 2u, 4u, f) == Some(3u));\n+        assert_eq!(position_between(v, 2u, 4u, f), Some(3u));\n \n         assert!(position_between(v, 3u, 3u, f).is_none());\n-        assert!(position_between(v, 3u, 4u, f) == Some(3u));\n+        assert_eq!(position_between(v, 3u, 4u, f), Some(3u));\n \n         assert!(position_between(v, 4u, 4u, f).is_none());\n     }\n@@ -3867,7 +3867,7 @@ mod tests {\n         fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n         let v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert!(find(v, f) == Some((1, 'b')));\n+        assert_eq!(find(v, f), Some((1, 'b')));\n         assert!(find(v, g).is_none());\n     }\n \n@@ -3880,21 +3880,21 @@ mod tests {\n \n         assert!(find_between(v, 0u, 0u, f).is_none());\n         assert!(find_between(v, 0u, 1u, f).is_none());\n-        assert!(find_between(v, 0u, 2u, f) == Some((1, 'b')));\n-        assert!(find_between(v, 0u, 3u, f) == Some((1, 'b')));\n-        assert!(find_between(v, 0u, 4u, f) == Some((1, 'b')));\n+        assert_eq!(find_between(v, 0u, 2u, f), Some((1, 'b')));\n+        assert_eq!(find_between(v, 0u, 3u, f), Some((1, 'b')));\n+        assert_eq!(find_between(v, 0u, 4u, f), Some((1, 'b')));\n \n         assert!(find_between(v, 1u, 1u, f).is_none());\n-        assert!(find_between(v, 1u, 2u, f) == Some((1, 'b')));\n-        assert!(find_between(v, 1u, 3u, f) == Some((1, 'b')));\n-        assert!(find_between(v, 1u, 4u, f) == Some((1, 'b')));\n+        assert_eq!(find_between(v, 1u, 2u, f), Some((1, 'b')));\n+        assert_eq!(find_between(v, 1u, 3u, f), Some((1, 'b')));\n+        assert_eq!(find_between(v, 1u, 4u, f), Some((1, 'b')));\n \n         assert!(find_between(v, 2u, 2u, f).is_none());\n         assert!(find_between(v, 2u, 3u, f).is_none());\n-        assert!(find_between(v, 2u, 4u, f) == Some((3, 'b')));\n+        assert_eq!(find_between(v, 2u, 4u, f), Some((3, 'b')));\n \n         assert!(find_between(v, 3u, 3u, f).is_none());\n-        assert!(find_between(v, 3u, 4u, f) == Some((3, 'b')));\n+        assert_eq!(find_between(v, 3u, 4u, f), Some((3, 'b')));\n \n         assert!(find_between(v, 4u, 4u, f).is_none());\n     }\n@@ -3907,7 +3907,7 @@ mod tests {\n         fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n         let v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert!(position(v, f) == Some(1u));\n+        assert_eq!(position(v, f), Some(1u));\n         assert!(position(v, g).is_none());\n     }\n \n@@ -3920,21 +3920,21 @@ mod tests {\n \n         assert!(rposition_between(v, 0u, 0u, f).is_none());\n         assert!(rposition_between(v, 0u, 1u, f).is_none());\n-        assert!(rposition_between(v, 0u, 2u, f) == Some(1u));\n-        assert!(rposition_between(v, 0u, 3u, f) == Some(1u));\n-        assert!(rposition_between(v, 0u, 4u, f) == Some(3u));\n+        assert_eq!(rposition_between(v, 0u, 2u, f), Some(1u));\n+        assert_eq!(rposition_between(v, 0u, 3u, f), Some(1u));\n+        assert_eq!(rposition_between(v, 0u, 4u, f), Some(3u));\n \n         assert!(rposition_between(v, 1u, 1u, f).is_none());\n-        assert!(rposition_between(v, 1u, 2u, f) == Some(1u));\n-        assert!(rposition_between(v, 1u, 3u, f) == Some(1u));\n-        assert!(rposition_between(v, 1u, 4u, f) == Some(3u));\n+        assert_eq!(rposition_between(v, 1u, 2u, f), Some(1u));\n+        assert_eq!(rposition_between(v, 1u, 3u, f), Some(1u));\n+        assert_eq!(rposition_between(v, 1u, 4u, f), Some(3u));\n \n         assert!(rposition_between(v, 2u, 2u, f).is_none());\n         assert!(rposition_between(v, 2u, 3u, f).is_none());\n-        assert!(rposition_between(v, 2u, 4u, f) == Some(3u));\n+        assert_eq!(rposition_between(v, 2u, 4u, f), Some(3u));\n \n         assert!(rposition_between(v, 3u, 3u, f).is_none());\n-        assert!(rposition_between(v, 3u, 4u, f) == Some(3u));\n+        assert_eq!(rposition_between(v, 3u, 4u, f), Some(3u));\n \n         assert!(rposition_between(v, 4u, 4u, f).is_none());\n     }\n@@ -3947,7 +3947,7 @@ mod tests {\n         fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n         let v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert!(rfind(v, f) == Some((3, 'b')));\n+        assert_eq!(rfind(v, f), Some((3, 'b')));\n         assert!(rfind(v, g).is_none());\n     }\n \n@@ -3960,117 +3960,117 @@ mod tests {\n \n         assert!(rfind_between(v, 0u, 0u, f).is_none());\n         assert!(rfind_between(v, 0u, 1u, f).is_none());\n-        assert!(rfind_between(v, 0u, 2u, f) == Some((1, 'b')));\n-        assert!(rfind_between(v, 0u, 3u, f) == Some((1, 'b')));\n-        assert!(rfind_between(v, 0u, 4u, f) == Some((3, 'b')));\n+        assert_eq!(rfind_between(v, 0u, 2u, f), Some((1, 'b')));\n+        assert_eq!(rfind_between(v, 0u, 3u, f), Some((1, 'b')));\n+        assert_eq!(rfind_between(v, 0u, 4u, f), Some((3, 'b')));\n \n         assert!(rfind_between(v, 1u, 1u, f).is_none());\n-        assert!(rfind_between(v, 1u, 2u, f) == Some((1, 'b')));\n-        assert!(rfind_between(v, 1u, 3u, f) == Some((1, 'b')));\n-        assert!(rfind_between(v, 1u, 4u, f) == Some((3, 'b')));\n+        assert_eq!(rfind_between(v, 1u, 2u, f), Some((1, 'b')));\n+        assert_eq!(rfind_between(v, 1u, 3u, f), Some((1, 'b')));\n+        assert_eq!(rfind_between(v, 1u, 4u, f), Some((3, 'b')));\n \n         assert!(rfind_between(v, 2u, 2u, f).is_none());\n         assert!(rfind_between(v, 2u, 3u, f).is_none());\n-        assert!(rfind_between(v, 2u, 4u, f) == Some((3, 'b')));\n+        assert_eq!(rfind_between(v, 2u, 4u, f), Some((3, 'b')));\n \n         assert!(rfind_between(v, 3u, 3u, f).is_none());\n-        assert!(rfind_between(v, 3u, 4u, f) == Some((3, 'b')));\n+        assert_eq!(rfind_between(v, 3u, 4u, f), Some((3, 'b')));\n \n         assert!(rfind_between(v, 4u, 4u, f).is_none());\n     }\n \n     #[test]\n     fn test_bsearch_elem() {\n-        assert!(bsearch_elem([1,2,3,4,5], &5) == Some(4));\n-        assert!(bsearch_elem([1,2,3,4,5], &4) == Some(3));\n-        assert!(bsearch_elem([1,2,3,4,5], &3) == Some(2));\n-        assert!(bsearch_elem([1,2,3,4,5], &2) == Some(1));\n-        assert!(bsearch_elem([1,2,3,4,5], &1) == Some(0));\n-\n-        assert!(bsearch_elem([2,4,6,8,10], &1) == None);\n-        assert!(bsearch_elem([2,4,6,8,10], &5) == None);\n-        assert!(bsearch_elem([2,4,6,8,10], &4) == Some(1));\n-        assert!(bsearch_elem([2,4,6,8,10], &10) == Some(4));\n-\n-        assert!(bsearch_elem([2,4,6,8], &1) == None);\n-        assert!(bsearch_elem([2,4,6,8], &5) == None);\n-        assert!(bsearch_elem([2,4,6,8], &4) == Some(1));\n-        assert!(bsearch_elem([2,4,6,8], &8) == Some(3));\n-\n-        assert!(bsearch_elem([2,4,6], &1) == None);\n-        assert!(bsearch_elem([2,4,6], &5) == None);\n-        assert!(bsearch_elem([2,4,6], &4) == Some(1));\n-        assert!(bsearch_elem([2,4,6], &6) == Some(2));\n-\n-        assert!(bsearch_elem([2,4], &1) == None);\n-        assert!(bsearch_elem([2,4], &5) == None);\n-        assert!(bsearch_elem([2,4], &2) == Some(0));\n-        assert!(bsearch_elem([2,4], &4) == Some(1));\n-\n-        assert!(bsearch_elem([2], &1) == None);\n-        assert!(bsearch_elem([2], &5) == None);\n-        assert!(bsearch_elem([2], &2) == Some(0));\n-\n-        assert!(bsearch_elem([], &1) == None);\n-        assert!(bsearch_elem([], &5) == None);\n+        assert_eq!(bsearch_elem([1,2,3,4,5], &5), Some(4));\n+        assert_eq!(bsearch_elem([1,2,3,4,5], &4), Some(3));\n+        assert_eq!(bsearch_elem([1,2,3,4,5], &3), Some(2));\n+        assert_eq!(bsearch_elem([1,2,3,4,5], &2), Some(1));\n+        assert_eq!(bsearch_elem([1,2,3,4,5], &1), Some(0));\n+\n+        assert_eq!(bsearch_elem([2,4,6,8,10], &1), None);\n+        assert_eq!(bsearch_elem([2,4,6,8,10], &5), None);\n+        assert_eq!(bsearch_elem([2,4,6,8,10], &4), Some(1));\n+        assert_eq!(bsearch_elem([2,4,6,8,10], &10), Some(4));\n+\n+        assert_eq!(bsearch_elem([2,4,6,8], &1), None);\n+        assert_eq!(bsearch_elem([2,4,6,8], &5), None);\n+        assert_eq!(bsearch_elem([2,4,6,8], &4), Some(1));\n+        assert_eq!(bsearch_elem([2,4,6,8], &8), Some(3));\n+\n+        assert_eq!(bsearch_elem([2,4,6], &1), None);\n+        assert_eq!(bsearch_elem([2,4,6], &5), None);\n+        assert_eq!(bsearch_elem([2,4,6], &4), Some(1));\n+        assert_eq!(bsearch_elem([2,4,6], &6), Some(2));\n+\n+        assert_eq!(bsearch_elem([2,4], &1), None);\n+        assert_eq!(bsearch_elem([2,4], &5), None);\n+        assert_eq!(bsearch_elem([2,4], &2), Some(0));\n+        assert_eq!(bsearch_elem([2,4], &4), Some(1));\n+\n+        assert_eq!(bsearch_elem([2], &1), None);\n+        assert_eq!(bsearch_elem([2], &5), None);\n+        assert_eq!(bsearch_elem([2], &2), Some(0));\n+\n+        assert_eq!(bsearch_elem([], &1), None);\n+        assert_eq!(bsearch_elem([], &5), None);\n \n         assert!(bsearch_elem([1,1,1,1,1], &1) != None);\n         assert!(bsearch_elem([1,1,1,1,2], &1) != None);\n         assert!(bsearch_elem([1,1,1,2,2], &1) != None);\n         assert!(bsearch_elem([1,1,2,2,2], &1) != None);\n-        assert!(bsearch_elem([1,2,2,2,2], &1) == Some(0));\n+        assert_eq!(bsearch_elem([1,2,2,2,2], &1), Some(0));\n \n-        assert!(bsearch_elem([1,2,3,4,5], &6) == None);\n-        assert!(bsearch_elem([1,2,3,4,5], &0) == None);\n+        assert_eq!(bsearch_elem([1,2,3,4,5], &6), None);\n+        assert_eq!(bsearch_elem([1,2,3,4,5], &0), None);\n     }\n \n     #[test]\n     fn reverse_and_reversed() {\n         let mut v: ~[int] = ~[10, 20];\n-        assert!(v[0] == 10);\n-        assert!(v[1] == 20);\n+        assert_eq!(v[0], 10);\n+        assert_eq!(v[1], 20);\n         reverse(v);\n-        assert!(v[0] == 20);\n-        assert!(v[1] == 10);\n+        assert_eq!(v[0], 20);\n+        assert_eq!(v[1], 10);\n         let v2 = reversed::<int>(~[10, 20]);\n-        assert!(v2[0] == 20);\n-        assert!(v2[1] == 10);\n+        assert_eq!(v2[0], 20);\n+        assert_eq!(v2[1], 10);\n         v[0] = 30;\n-        assert!(v2[0] == 20);\n+        assert_eq!(v2[0], 20);\n         // Make sure they work with 0-length vectors too.\n \n         let v4 = reversed::<int>(~[]);\n-        assert!(v4 == ~[]);\n+        assert_eq!(v4, ~[]);\n         let mut v3: ~[int] = ~[];\n         reverse::<int>(v3);\n     }\n \n     #[test]\n     fn reversed_mut() {\n         let v2 = reversed::<int>(~[10, 20]);\n-        assert!(v2[0] == 20);\n-        assert!(v2[1] == 10);\n+        assert_eq!(v2[0], 20);\n+        assert_eq!(v2[1], 10);\n     }\n \n     #[test]\n     fn test_split() {\n         fn f(x: &int) -> bool { *x == 3 }\n \n-        assert!(split(~[], f) == ~[]);\n-        assert!(split(~[1, 2], f) == ~[~[1, 2]]);\n-        assert!(split(~[3, 1, 2], f) == ~[~[], ~[1, 2]]);\n-        assert!(split(~[1, 2, 3], f) == ~[~[1, 2], ~[]]);\n-        assert!(split(~[1, 2, 3, 4, 3, 5], f) == ~[~[1, 2], ~[4], ~[5]]);\n+        assert_eq!(split(~[], f), ~[]);\n+        assert_eq!(split(~[1, 2], f), ~[~[1, 2]]);\n+        assert_eq!(split(~[3, 1, 2], f), ~[~[], ~[1, 2]]);\n+        assert_eq!(split(~[1, 2, 3], f), ~[~[1, 2], ~[]]);\n+        assert_eq!(split(~[1, 2, 3, 4, 3, 5], f), ~[~[1, 2], ~[4], ~[5]]);\n     }\n \n     #[test]\n     fn test_splitn() {\n         fn f(x: &int) -> bool { *x == 3 }\n \n-        assert!(splitn(~[], 1u, f) == ~[]);\n-        assert!(splitn(~[1, 2], 1u, f) == ~[~[1, 2]]);\n-        assert!(splitn(~[3, 1, 2], 1u, f) == ~[~[], ~[1, 2]]);\n-        assert!(splitn(~[1, 2, 3], 1u, f) == ~[~[1, 2], ~[]]);\n+        assert_eq!(splitn(~[], 1u, f), ~[]);\n+        assert_eq!(splitn(~[1, 2], 1u, f), ~[~[1, 2]]);\n+        assert_eq!(splitn(~[3, 1, 2], 1u, f), ~[~[], ~[1, 2]]);\n+        assert_eq!(splitn(~[1, 2, 3], 1u, f), ~[~[1, 2], ~[]]);\n         assert!(splitn(~[1, 2, 3, 4, 3, 5], 1u, f) ==\n                       ~[~[1, 2], ~[4, 3, 5]]);\n     }\n@@ -4079,9 +4079,9 @@ mod tests {\n     fn test_rsplit() {\n         fn f(x: &int) -> bool { *x == 3 }\n \n-        assert!(rsplit(~[], f) == ~[]);\n-        assert!(rsplit(~[1, 2], f) == ~[~[1, 2]]);\n-        assert!(rsplit(~[1, 2, 3], f) == ~[~[1, 2], ~[]]);\n+        assert_eq!(rsplit(~[], f), ~[]);\n+        assert_eq!(rsplit(~[1, 2], f), ~[~[1, 2]]);\n+        assert_eq!(rsplit(~[1, 2, 3], f), ~[~[1, 2], ~[]]);\n         assert!(rsplit(~[1, 2, 3, 4, 3, 5], f) ==\n             ~[~[1, 2], ~[4], ~[5]]);\n     }\n@@ -4090,17 +4090,17 @@ mod tests {\n     fn test_rsplitn() {\n         fn f(x: &int) -> bool { *x == 3 }\n \n-        assert!(rsplitn(~[], 1u, f) == ~[]);\n-        assert!(rsplitn(~[1, 2], 1u, f) == ~[~[1, 2]]);\n-        assert!(rsplitn(~[1, 2, 3], 1u, f) == ~[~[1, 2], ~[]]);\n+        assert_eq!(rsplitn(~[], 1u, f), ~[]);\n+        assert_eq!(rsplitn(~[1, 2], 1u, f), ~[~[1, 2]]);\n+        assert_eq!(rsplitn(~[1, 2, 3], 1u, f), ~[~[1, 2], ~[]]);\n         assert!(rsplitn(~[1, 2, 3, 4, 3, 5], 1u, f) ==\n                        ~[~[1, 2, 3, 4], ~[5]]);\n     }\n \n     #[test]\n     fn test_partition() {\n         // FIXME (#4355 maybe): using v.partition here crashes\n-        assert!(partition(~[], |x: &int| *x < 3) == (~[], ~[]));\n+        assert_eq!(partition(~[], |x: &int| *x < 3), (~[], ~[]));\n         assert!(partition(~[1, 2, 3], |x: &int| *x < 4) ==\n             (~[1, 2, 3], ~[]));\n         assert!(partition(~[1, 2, 3], |x: &int| *x < 2) ==\n@@ -4111,7 +4111,7 @@ mod tests {\n \n     #[test]\n     fn test_partitioned() {\n-        assert!((~[]).partitioned(|x: &int| *x < 3) == (~[], ~[]));\n+        assert_eq!((~[]).partitioned(|x: &int| *x < 3), (~[], ~[]))\n         assert!((~[1, 2, 3]).partitioned(|x: &int| *x < 4) ==\n                      (~[1, 2, 3], ~[]));\n         assert!((~[1, 2, 3]).partitioned(|x: &int| *x < 2) ==\n@@ -4122,14 +4122,14 @@ mod tests {\n \n     #[test]\n     fn test_concat() {\n-        assert!(concat(~[~[1], ~[2,3]]) == ~[1, 2, 3]);\n+        assert_eq!(concat(~[~[1], ~[2,3]]), ~[1, 2, 3]);\n     }\n \n     #[test]\n     fn test_connect() {\n-        assert!(connect(~[], &0) == ~[]);\n-        assert!(connect(~[~[1], ~[2, 3]], &0) == ~[1, 0, 2, 3]);\n-        assert!(connect(~[~[1], ~[2], ~[3]], &0) == ~[1, 0, 2, 0, 3]);\n+        assert_eq!(connect(~[], &0), ~[]);\n+        assert_eq!(connect(~[~[1], ~[2, 3]], &0), ~[1, 0, 2, 3]);\n+        assert_eq!(connect(~[~[1], ~[2], ~[3]], &0), ~[1, 0, 2, 0, 3]);\n     }\n \n     #[test]\n@@ -4161,26 +4161,26 @@ mod tests {\n     fn test_unshift() {\n         let mut x = ~[1, 2, 3];\n         x.unshift(0);\n-        assert!(x == ~[0, 1, 2, 3]);\n+        assert_eq!(x, ~[0, 1, 2, 3]);\n     }\n \n     #[test]\n     fn test_insert() {\n         let mut a = ~[1, 2, 4];\n         a.insert(2, 3);\n-        assert!(a == ~[1, 2, 3, 4]);\n+        assert_eq!(a, ~[1, 2, 3, 4]);\n \n         let mut a = ~[1, 2, 3];\n         a.insert(0, 0);\n-        assert!(a == ~[0, 1, 2, 3]);\n+        assert_eq!(a, ~[0, 1, 2, 3]);\n \n         let mut a = ~[1, 2, 3];\n         a.insert(3, 4);\n-        assert!(a == ~[1, 2, 3, 4]);\n+        assert_eq!(a, ~[1, 2, 3, 4]);\n \n         let mut a = ~[];\n         a.insert(0, 1);\n-        assert!(a == ~[1]);\n+        assert_eq!(a, ~[1]);\n     }\n \n     #[test]\n@@ -4195,15 +4195,15 @@ mod tests {\n     fn test_remove() {\n         let mut a = ~[1, 2, 3, 4];\n         a.remove(2);\n-        assert!(a == ~[1, 2, 4]);\n+        assert_eq!(a, ~[1, 2, 4]);\n \n         let mut a = ~[1, 2, 3];\n         a.remove(0);\n-        assert!(a == ~[2, 3]);\n+        assert_eq!(a, ~[2, 3]);\n \n         let mut a = ~[1];\n         a.remove(0);\n-        assert!(a == ~[]);\n+        assert_eq!(a, ~[]);\n     }\n \n     #[test]\n@@ -4218,19 +4218,19 @@ mod tests {\n     fn test_capacity() {\n         let mut v = ~[0u64];\n         reserve(&mut v, 10u);\n-        assert!(capacity(&v) == 10u);\n+        assert_eq!(capacity(&v), 10u);\n         let mut v = ~[0u32];\n         reserve(&mut v, 10u);\n-        assert!(capacity(&v) == 10u);\n+        assert_eq!(capacity(&v), 10u);\n     }\n \n     #[test]\n     fn test_slice_2() {\n         let v = ~[1, 2, 3, 4, 5];\n         let v = v.slice(1u, 3u);\n-        assert!(v.len() == 2u);\n-        assert!(v[0] == 2);\n-        assert!(v[1] == 3);\n+        assert_eq!(v.len(), 2u);\n+        assert_eq!(v[0], 2);\n+        assert_eq!(v[1], 3);\n     }\n \n \n@@ -4844,6 +4844,6 @@ mod tests {\n         for [1, 2, 3].each_val |v| {\n             i += v;\n         }\n-        assert!(i == 6);\n+        assert_eq!(i, 6);\n     }\n }"}, {"sha": "4b3ed4c70f596c0e44a47c89edeb33e18c9d0a05", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -209,7 +209,7 @@ mod test {\n     fn test_rpaths_to_flags() {\n         let flags = rpaths_to_flags(~[Path(\"path1\"),\n                                       Path(\"path2\")]);\n-        assert!(flags == ~[~\"-Wl,-rpath,path1\", ~\"-Wl,-rpath,path2\"]);\n+        assert_eq!(flags, ~[~\"-Wl,-rpath,path1\", ~\"-Wl,-rpath,path2\"]);\n     }\n \n     #[test]\n@@ -234,7 +234,7 @@ mod test {\n         let res = minimize_rpaths([Path(\"rpath1\"),\n                                    Path(\"rpath2\"),\n                                    Path(\"rpath1\")]);\n-        assert!(res == ~[Path(\"rpath1\"), Path(\"rpath2\")]);\n+        assert_eq!(res, ~[Path(\"rpath1\"), Path(\"rpath2\")]);\n     }\n \n     #[test]\n@@ -243,63 +243,63 @@ mod test {\n                                     Path(\"1a\"), Path(\"4a\"),Path(\"1a\"),\n                                     Path(\"2\"), Path(\"3\"), Path(\"4a\"),\n                                     Path(\"3\")]);\n-        assert!(res == ~[Path(\"1a\"), Path(\"2\"), Path(\"4a\"), Path(\"3\")]);\n+        assert_eq!(res, ~[Path(\"1a\"), Path(\"2\"), Path(\"4a\"), Path(\"3\")]);\n     }\n \n     #[test]\n     fn test_relative_to1() {\n         let p1 = Path(\"/usr/bin/rustc\");\n         let p2 = Path(\"/usr/lib/mylib\");\n         let res = get_relative_to(&p1, &p2);\n-        assert!(res == Path(\"../lib\"));\n+        assert_eq!(res, Path(\"../lib\"));\n     }\n \n     #[test]\n     fn test_relative_to2() {\n         let p1 = Path(\"/usr/bin/rustc\");\n         let p2 = Path(\"/usr/bin/../lib/mylib\");\n         let res = get_relative_to(&p1, &p2);\n-        assert!(res == Path(\"../lib\"));\n+        assert_eq!(res, Path(\"../lib\"));\n     }\n \n     #[test]\n     fn test_relative_to3() {\n         let p1 = Path(\"/usr/bin/whatever/rustc\");\n         let p2 = Path(\"/usr/lib/whatever/mylib\");\n         let res = get_relative_to(&p1, &p2);\n-        assert!(res == Path(\"../../lib/whatever\"));\n+        assert_eq!(res, Path(\"../../lib/whatever\"));\n     }\n \n     #[test]\n     fn test_relative_to4() {\n         let p1 = Path(\"/usr/bin/whatever/../rustc\");\n         let p2 = Path(\"/usr/lib/whatever/mylib\");\n         let res = get_relative_to(&p1, &p2);\n-        assert!(res == Path(\"../lib/whatever\"));\n+        assert_eq!(res, Path(\"../lib/whatever\"));\n     }\n \n     #[test]\n     fn test_relative_to5() {\n         let p1 = Path(\"/usr/bin/whatever/../rustc\");\n         let p2 = Path(\"/usr/lib/whatever/../mylib\");\n         let res = get_relative_to(&p1, &p2);\n-        assert!(res == Path(\"../lib\"));\n+        assert_eq!(res, Path(\"../lib\"));\n     }\n \n     #[test]\n     fn test_relative_to6() {\n         let p1 = Path(\"/1\");\n         let p2 = Path(\"/2/3\");\n         let res = get_relative_to(&p1, &p2);\n-        assert!(res == Path(\"2\"));\n+        assert_eq!(res, Path(\"2\"));\n     }\n \n     #[test]\n     fn test_relative_to7() {\n         let p1 = Path(\"/1/2\");\n         let p2 = Path(\"/3\");\n         let res = get_relative_to(&p1, &p2);\n-        assert!(res == Path(\"..\"));\n+        assert_eq!(res, Path(\"..\"));\n     }\n \n     #[test]\n@@ -312,7 +312,7 @@ mod test {\n         debug!(\"test_relative_tu8: %s vs. %s\",\n                res.to_str(),\n                Path(\".\").to_str());\n-        assert!(res == Path(\".\"));\n+        assert_eq!(res, Path(\".\"));\n     }\n \n     #[test]\n@@ -322,7 +322,7 @@ mod test {\n       let o = session::os_linux;\n       let res = get_rpath_relative_to_output(o,\n             &Path(\"bin/rustc\"), &Path(\"lib/libstd.so\"));\n-      assert!(res.to_str() == ~\"$ORIGIN/../lib\");\n+      assert_eq!(res.to_str(), ~\"$ORIGIN/../lib\");\n     }\n \n     #[test]\n@@ -331,7 +331,7 @@ mod test {\n         let o = session::os_freebsd;\n         let res = get_rpath_relative_to_output(o,\n             &Path(\"bin/rustc\"), &Path(\"lib/libstd.so\"));\n-        assert!(res.to_str() == ~\"$ORIGIN/../lib\");\n+        assert_eq!(res.to_str(), ~\"$ORIGIN/../lib\");\n     }\n \n     #[test]\n@@ -342,7 +342,7 @@ mod test {\n         let res = get_rpath_relative_to_output(o,\n                                                &Path(\"bin/rustc\"),\n                                                &Path(\"lib/libstd.so\"));\n-        assert!(res.to_str() == ~\"@executable_path/../lib\");\n+        assert_eq!(res.to_str(), ~\"@executable_path/../lib\");\n     }\n \n     #[test]\n@@ -352,6 +352,6 @@ mod test {\n                res.to_str(),\n                os::make_absolute(&Path(\"lib\")).to_str());\n \n-        assert!(res == os::make_absolute(&Path(\"lib\")));\n+        assert_eq!(res, os::make_absolute(&Path(\"lib\")));\n     }\n }"}, {"sha": "572397b7f8af25aafccb2ea8885fe96b2634ec39", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -938,6 +938,6 @@ mod test {\n         let sess = build_session(sessopts, diagnostic::emit);\n         let cfg = build_configuration(sess, @~\"whatever\", &str_input(~\"\"));\n         let test_items = attr::find_meta_items_by_name(cfg, ~\"test\");\n-        assert!(test_items.len() == 1u);\n+        assert_eq!(test_items.len(), 1u);\n     }\n }"}, {"sha": "8779cab87f62f4afaa9ad0825969f220dda86875", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -1064,7 +1064,7 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::attribute] {\n             let meta_items = get_meta_items(attr_doc);\n             // Currently it's only possible to have a single meta item on\n             // an attribute\n-            assert!(meta_items.len() == 1u);\n+            assert_eq!(meta_items.len(), 1u);\n             let meta_item = meta_items[0];\n             attrs.push(\n                 codemap::spanned {"}, {"sha": "8c21998768e95fb9c5d131e1e4df393aa2ff11cb", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -946,7 +946,7 @@ fn encode_info_for_item(ecx: @EncodeContext,\n \n         // Now output the method info for each method.\n         for ty::trait_method_def_ids(tcx, local_def(item.id)).eachi |i, &method_def_id| {\n-            assert!(method_def_id.crate == ast::local_crate);\n+            assert_eq!(method_def_id.crate, ast::local_crate);\n \n             let method_ty = ty::method(tcx, method_def_id);\n \n@@ -1278,7 +1278,7 @@ fn encode_crate_deps(ecx: @EncodeContext,\n         // Sanity-check the crate numbers\n         let mut expected_cnum = 1;\n         for deps.each |n| {\n-            assert!((n.cnum == expected_cnum));\n+            assert_eq!(n.cnum, expected_cnum);\n             expected_cnum += 1;\n         }\n "}, {"sha": "ad5bd2447a6f04bf22895c67950d4772fc8206be", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -156,12 +156,12 @@ fn parse_sigil(st: @mut PState) -> ast::Sigil {\n }\n \n fn parse_vstore(st: @mut PState) -> ty::vstore {\n-    assert!(next(st) == '/');\n+    assert_eq!(next(st), '/');\n \n     let c = peek(st);\n     if '0' <= c && c <= '9' {\n         let n = parse_uint(st);\n-        assert!(next(st) == '|');\n+        assert_eq!(next(st), '|');\n         return ty::vstore_fixed(n);\n     }\n \n@@ -187,7 +187,7 @@ fn parse_substs(st: @mut PState, conv: conv_did) -> ty::substs {\n \n     let self_ty = parse_opt(st, || parse_ty(st, conv) );\n \n-    assert!(next(st) == '[');\n+    assert_eq!(next(st), '[');\n     let mut params: ~[ty::t] = ~[];\n     while peek(st) != ']' { params.push(parse_ty(st, conv)); }\n     st.pos = st.pos + 1u;\n@@ -204,13 +204,13 @@ fn parse_bound_region(st: @mut PState) -> ty::bound_region {\n       's' => ty::br_self,\n       'a' => {\n         let id = parse_uint(st);\n-        assert!(next(st) == '|');\n+        assert_eq!(next(st), '|');\n         ty::br_anon(id)\n       }\n       '[' => ty::br_named(st.tcx.sess.ident_of(parse_str(st, ']'))),\n       'c' => {\n         let id = parse_uint(st) as int;\n-        assert!(next(st) == '|');\n+        assert_eq!(next(st), '|');\n         ty::br_cap_avoid(id, @parse_bound_region(st))\n       },\n       _ => fail!(\"parse_bound_region: bad input\")\n@@ -223,17 +223,17 @@ fn parse_region(st: @mut PState) -> ty::Region {\n         ty::re_bound(parse_bound_region(st))\n       }\n       'f' => {\n-        assert!(next(st) == '[');\n+        assert_eq!(next(st), '[');\n         let id = parse_uint(st) as int;\n-        assert!(next(st) == '|');\n+        assert_eq!(next(st), '|');\n         let br = parse_bound_region(st);\n-        assert!(next(st) == ']');\n+        assert_eq!(next(st), ']');\n         ty::re_free(ty::FreeRegion {scope_id: id,\n                                     bound_region: br})\n       }\n       's' => {\n         let id = parse_uint(st) as int;\n-        assert!(next(st) == '|');\n+        assert_eq!(next(st), '|');\n         ty::re_scope(id)\n       }\n       't' => {\n@@ -294,19 +294,19 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n       }\n       'c' => return ty::mk_char(),\n       't' => {\n-        assert!((next(st) == '['));\n+        assert_eq!(next(st), '[');\n         let def = parse_def(st, NominalType, conv);\n         let substs = parse_substs(st, conv);\n-        assert!(next(st) == ']');\n+        assert_eq!(next(st), ']');\n         return ty::mk_enum(st.tcx, def, substs);\n       }\n       'x' => {\n-        assert!(next(st) == '[');\n+        assert_eq!(next(st), '[');\n         let def = parse_def(st, NominalType, conv);\n         let substs = parse_substs(st, conv);\n         let store = parse_trait_store(st);\n         let mt = parse_mutability(st);\n-        assert!(next(st) == ']');\n+        assert_eq!(next(st), ']');\n         return ty::mk_trait(st.tcx, def, substs, store, mt);\n       }\n       'p' => {\n@@ -337,7 +337,7 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n         return ty::mk_estr(st.tcx, v);\n       }\n       'T' => {\n-        assert!((next(st) == '['));\n+        assert_eq!(next(st), '[');\n         let mut params = ~[];\n         while peek(st) != ']' { params.push(parse_ty(st, conv)); }\n         st.pos = st.pos + 1u;\n@@ -356,9 +356,9 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n       }\n       '#' => {\n         let pos = parse_hex(st);\n-        assert!((next(st) == ':'));\n+        assert_eq!(next(st), ':');\n         let len = parse_hex(st);\n-        assert!((next(st) == '#'));\n+        assert_eq!(next(st), '#');\n         let key = ty::creader_cache_key {cnum: st.crate,\n                                          pos: pos,\n                                          len: len };\n@@ -379,10 +379,10 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n       }\n       'B' => ty::mk_opaque_box(st.tcx),\n       'a' => {\n-          assert!((next(st) == '['));\n+          assert_eq!(next(st), '[');\n           let did = parse_def(st, NominalType, conv);\n           let substs = parse_substs(st, conv);\n-          assert!((next(st) == ']'));\n+          assert_eq!(next(st), ']');\n           return ty::mk_struct(st.tcx, did, substs);\n       }\n       c => { error!(\"unexpected char in type string: %c\", c); fail!();}\n@@ -445,15 +445,15 @@ fn parse_purity(c: char) -> purity {\n }\n \n fn parse_abi_set(st: @mut PState) -> AbiSet {\n-    assert!(next(st) == '[');\n+    assert_eq!(next(st), '[');\n     let mut abis = AbiSet::empty();\n     while peek(st) != ']' {\n         // FIXME(#5422) str API should not force this copy\n         let abi_str = scan(st, |c| c == ',', str::from_bytes);\n         let abi = abi::lookup(abi_str).expect(abi_str);\n         abis.add(abi);\n     }\n-    assert!(next(st) == ']');\n+    assert_eq!(next(st), ']');\n     return abis;\n }\n \n@@ -494,7 +494,7 @@ fn parse_bare_fn_ty(st: @mut PState, conv: conv_did) -> ty::BareFnTy {\n }\n \n fn parse_sig(st: @mut PState, conv: conv_did) -> ty::FnSig {\n-    assert!((next(st) == '['));\n+    assert_eq!(next(st), '[');\n     let mut inputs = ~[];\n     while peek(st) != ']' {\n         inputs.push(parse_ty(st, conv));"}, {"sha": "0235ab47967d79966c2a9edea2be04f202cdd3a7", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -206,7 +206,7 @@ pub impl ExtendedDecodeContext {\n          * refer to the current crate and to the new, inlined node-id.\n          */\n \n-        assert!(did.crate == ast::local_crate);\n+        assert_eq!(did.crate, ast::local_crate);\n         ast::def_id { crate: ast::local_crate, node: self.tr_id(did.node) }\n     }\n     fn tr_span(&self, _span: span) -> span {"}, {"sha": "a422d99b6f5cf404ce3916dcfbfa09065ff6fb22", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -218,7 +218,7 @@ pub impl GatherLoanCtxt {\n \n     fn pop_repeating_id(&mut self, id: ast::node_id) {\n         let popped = self.repeating_ids.pop();\n-        assert!(id == popped);\n+        assert_eq!(id, popped);\n     }\n \n     fn guarantee_adjustments(&mut self,"}, {"sha": "f4b9e4b62fc4b6908085eb488268d41b17fa25ac", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -144,7 +144,7 @@ fn configure_main(ctxt: @mut EntryContext) {\n         } else {\n             // If we *are* building a library, then we're on android where we still might\n             // optionally want to translate main $4404\n-            assert!(this.session.targ_cfg.os == session::os_android);\n+            assert_eq!(this.session.targ_cfg.os, session::os_android);\n         }\n     }\n }"}, {"sha": "fce078a708f1a755f23b6582672515cc2a8b2066", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -365,7 +365,7 @@ pub fn resolve_arm(arm: &ast::arm, cx: Context, visitor: visit::vt<Context>) {\n }\n \n pub fn resolve_pat(pat: @ast::pat, cx: Context, visitor: visit::vt<Context>) {\n-    assert!(cx.var_parent == cx.parent);\n+    assert_eq!(cx.var_parent, cx.parent);\n     parent_to_expr(cx, pat.id);\n     visit::visit_pat(pat, cx, visitor);\n }\n@@ -427,7 +427,7 @@ pub fn resolve_expr(expr: @ast::expr, cx: Context, visitor: visit::vt<Context>)\n pub fn resolve_local(local: @ast::local,\n                      cx: Context,\n                      visitor: visit::vt<Context>) {\n-    assert!(cx.var_parent == cx.parent);\n+    assert_eq!(cx.var_parent, cx.parent);\n     parent_to_expr(cx, local.node.id);\n     visit::visit_local(local, cx, visitor);\n }"}, {"sha": "1568c3e55352f11f4da5dc862ce738ae15b8493e", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -2321,7 +2321,7 @@ pub impl Resolver {\n             return Indeterminate;\n         }\n \n-        assert!(containing_module.glob_count == 0);\n+        assert_eq!(containing_module.glob_count, 0);\n \n         // Add all resolved imports from the containing module.\n         for containing_module.import_resolutions.each\n@@ -2903,7 +2903,7 @@ pub impl Resolver {\n         // If this is a search of all imports, we should be done with glob\n         // resolution at this point.\n         if name_search_type == SearchItemsAndAllImports {\n-            assert!(module_.glob_count == 0);\n+            assert_eq!(module_.glob_count, 0);\n         }\n \n         // Check the list of resolved imports."}, {"sha": "aefbcbaa87e960bdd0b170d51f1a88e98625e602", "filename": "src/librustc/middle/resolve_stage0.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -2368,7 +2368,7 @@ pub impl Resolver {\n             return Indeterminate;\n         }\n \n-        assert!(containing_module.glob_count == 0);\n+        assert_eq!(containing_module.glob_count, 0);\n \n         // Add all resolved imports from the containing module.\n         for containing_module.import_resolutions.each\n@@ -2932,7 +2932,7 @@ pub impl Resolver {\n         // If this is a search of all imports, we should be done with glob\n         // resolution at this point.\n         if name_search_type == SearchItemsAndAllImports {\n-            assert!(module_.glob_count == 0);\n+            assert_eq!(module_.glob_count, 0);\n         }\n \n         // Check the list of resolved imports."}, {"sha": "25e97b0c8a82c4cf369c776a38d713e70597915f", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -169,7 +169,7 @@ fn represent_type_uncached(cx: @CrateContext, t: ty::t) -> Repr {\n \n             if cases.len() == 1 {\n                 // Equivalent to a struct/tuple/newtype.\n-                assert!(cases[0].discr == 0);\n+                assert_eq!(cases[0].discr, 0);\n                 return Univariant(mk_struct(cx, cases[0].tys, false), false)\n             }\n \n@@ -377,12 +377,12 @@ pub fn trans_start_init(bcx: block, r: &Repr, val: ValueRef, discr: int) {\n             Store(bcx, C_int(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n         }\n         Univariant(ref st, true) => {\n-            assert!(discr == 0);\n+            assert_eq!(discr, 0);\n             Store(bcx, C_bool(true),\n                   GEPi(bcx, val, [0, st.fields.len() - 1]))\n         }\n         Univariant(*) => {\n-            assert!(discr == 0);\n+            assert_eq!(discr, 0);\n         }\n         General(*) => {\n             Store(bcx, C_int(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n@@ -405,7 +405,7 @@ pub fn num_args(r: &Repr, discr: int) -> uint {\n     match *r {\n         CEnum(*) => 0,\n         Univariant(ref st, dtor) => {\n-            assert!(discr == 0);\n+            assert_eq!(discr, 0);\n             st.fields.len() - (if dtor { 1 } else { 0 })\n         }\n         General(ref cases) => cases[discr as uint].fields.len() - 1,\n@@ -426,7 +426,7 @@ pub fn trans_field_ptr(bcx: block, r: &Repr, val: ValueRef, discr: int,\n             bcx.ccx().sess.bug(~\"element access in C-like enum\")\n         }\n         Univariant(ref st, _dtor) => {\n-            assert!(discr == 0);\n+            assert_eq!(discr, 0);\n             struct_field_ptr(bcx, st, val, ix, false)\n         }\n         General(ref cases) => {\n@@ -439,7 +439,7 @@ pub fn trans_field_ptr(bcx: block, r: &Repr, val: ValueRef, discr: int,\n                 // The unit-like case might have a nonzero number of unit-like fields.\n                 // (e.g., Result or Either with () as one side.)\n                 let llty = type_of::type_of(bcx.ccx(), nullfields[ix]);\n-                assert!(machine::llsize_of_alloc(bcx.ccx(), llty) == 0);\n+                assert_eq!(machine::llsize_of_alloc(bcx.ccx(), llty), 0);\n                 // The contents of memory at this pointer can't matter, but use\n                 // the value that's \"reasonable\" in case of pointer comparison.\n                 PointerCast(bcx, val, T_ptr(llty))\n@@ -498,12 +498,12 @@ pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n                    vals: &[ValueRef]) -> ValueRef {\n     match *r {\n         CEnum(min, max) => {\n-            assert!(vals.len() == 0);\n+            assert_eq!(vals.len(), 0);\n             assert!(min <= discr && discr <= max);\n             C_int(ccx, discr)\n         }\n         Univariant(ref st, _dro) => {\n-            assert!(discr == 0);\n+            assert_eq!(discr, 0);\n             C_struct(build_const_struct(ccx, st, vals))\n         }\n         General(ref cases) => {\n@@ -517,7 +517,7 @@ pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n             if discr == nndiscr {\n                 C_struct(build_const_struct(ccx, nonnull, vals))\n             } else {\n-                assert!(vals.len() == 0);\n+                assert_eq!(vals.len(), 0);\n                 let vals = do nonnull.fields.mapi |i, &ty| {\n                     let llty = type_of::sizing_type_of(ccx, ty);\n                     if i == ptrfield { C_null(llty) } else { C_undef(llty) }\n@@ -540,7 +540,7 @@ pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n  */\n fn build_const_struct(ccx: @CrateContext, st: &Struct, vals: &[ValueRef])\n     -> ~[ValueRef] {\n-    assert!(vals.len() == st.fields.len());\n+    assert_eq!(vals.len(), st.fields.len());\n \n     let mut offset = 0;\n     let mut cfields = ~[];"}, {"sha": "66cca74214a41aa313aab0145c4643a21581768c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -496,7 +496,7 @@ pub fn get_res_dtor(ccx: @CrateContext,\n         } else {\n             did\n         };\n-        assert!(did.crate == ast::local_crate);\n+        assert_eq!(did.crate, ast::local_crate);\n         let (val, _) = monomorphize::monomorphic_fn(ccx,\n                                                     did,\n                                                     substs,"}, {"sha": "362bcd483b41fa35bc9b20f9e36d78befb7edba0", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -837,7 +837,7 @@ pub fn Phi(cx: block, Ty: TypeRef, vals: &[ValueRef], bbs: &[BasicBlockRef])\n     -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n-        assert!(vals.len() == bbs.len());\n+        assert_eq!(vals.len(), bbs.len());\n         let phi = EmptyPhi(cx, Ty);\n         count_insn(cx, \"addincoming\");\n         llvm::LLVMAddIncoming(phi, vec::raw::to_ptr(vals),"}, {"sha": "382e80148ec0152d18e6a2c86988d14daad4c06a", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -272,7 +272,7 @@ pub fn trans_fn_ref_with_vtables(\n     // Create a monomorphic verison of generic functions\n     if must_monomorphise {\n         // Should be either intra-crate or inlined.\n-        assert!(def_id.crate == ast::local_crate);\n+        assert_eq!(def_id.crate, ast::local_crate);\n \n         let mut (val, must_cast) =\n             monomorphize::monomorphic_fn(ccx, def_id, type_params,"}, {"sha": "d9cf1a3b4bc5417667600e495b3e6bc0215062da", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -263,7 +263,7 @@ pub fn build_closure(bcx0: block,\n         let datum = expr::trans_local_var(bcx, cap_var.def);\n         match cap_var.mode {\n             moves::CapRef => {\n-                assert!(sigil == ast::BorrowedSigil);\n+                assert_eq!(sigil, ast::BorrowedSigil);\n                 env_vals.push(EnvValue {action: EnvRef,\n                                         datum: datum});\n             }"}, {"sha": "e08cc536a701f6bd99543001d7c32dd01d3bc184", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -113,7 +113,7 @@ fn const_deref_ptr(cx: @CrateContext, v: ValueRef) -> ValueRef {\n         None => v\n     };\n     unsafe {\n-        assert!(llvm::LLVMIsGlobalConstant(v) == True);\n+        assert_eq!(llvm::LLVMIsGlobalConstant(v), True);\n         llvm::LLVMGetInitializer(v)\n     }\n }\n@@ -209,8 +209,8 @@ pub fn const_expr(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                             assert!(m != ast::m_mutbl);\n                             let size = machine::llsize_of(cx,\n                                                           val_ty(llconst));\n-                            assert!(abi::slice_elt_base == 0);\n-                            assert!(abi::slice_elt_len == 1);\n+                            assert_eq!(abi::slice_elt_base, 0);\n+                            assert_eq!(abi::slice_elt_len, 1);\n                             llconst = C_struct(~[llptr, size]);\n                         }\n                         _ => {\n@@ -486,7 +486,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n             }\n           }\n           ast::expr_path(pth) => {\n-            assert!(pth.types.len() == 0);\n+            assert_eq!(pth.types.len(), 0);\n             match cx.tcx.def_map.find(&e.id) {\n                 Some(&ast::def_fn(def_id, _purity)) => {\n                     if !ast_util::is_local(def_id) {"}, {"sha": "13b072c6f632b45e56acaba888cfcab067721782", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -375,7 +375,7 @@ pub impl Datum {\n          * Schedules this datum for cleanup in `bcx`.  The datum\n          * must be an rvalue. */\n \n-        assert!(self.source == RevokeClean);\n+        assert_eq!(self.source, RevokeClean);\n         match self.mode {\n             ByValue => {\n                 add_clean_temp_immediate(bcx, self.val, self.ty);"}, {"sha": "51f17fcf47c4fbc4b4dc34480aee3aa845fd9d3b", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -287,7 +287,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n         debug!(\"add_env(closure_ty=%s)\", closure_ty.repr(tcx));\n         let scratch = scratch_datum(bcx, closure_ty, false);\n         let llfn = GEPi(bcx, scratch.val, [0u, abi::fn_field_code]);\n-        assert!(datum.appropriate_mode() == ByValue);\n+        assert_eq!(datum.appropriate_mode(), ByValue);\n         Store(bcx, datum.to_appropriate_llval(bcx), llfn);\n         let llenv = GEPi(bcx, scratch.val, [0u, abi::fn_field_box]);\n         Store(bcx, base::null_env_ptr(bcx), llenv);"}, {"sha": "f77e2e0d52aa2350142bdea4014fa37b20a73779", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -483,7 +483,7 @@ pub fn trans_struct_drop(bcx: block,\n         // Class dtors have no explicit args, so the params should\n         // just consist of the output pointer and the environment\n         // (self)\n-        assert!((params.len() == 2));\n+        assert_eq!(params.len(), 2);\n \n         // Take a reference to the class (because it's using the Drop trait),\n         // do so now."}, {"sha": "9ea3259e9699c3133b828a29d7e039fe320879a2", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -2194,7 +2194,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 // If this assertion failures, it is likely because of a\n                 // failure in the cross-crate inlining code to translate a\n                 // def-id.\n-                assert!(p.def_id.crate == ast::local_crate);\n+                assert_eq!(p.def_id.crate, ast::local_crate);\n \n                 type_param_def_to_contents(\n                     cx, cx.ty_param_defs.get(&p.def_id.node))"}, {"sha": "aeb360dc3f2fc145252e0356021538af6b46a71c", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -863,7 +863,7 @@ pub impl CoherenceChecker {\n     }\n \n     fn span_of_impl(&self, implementation: @Impl) -> span {\n-        assert!(implementation.did.crate == local_crate);\n+        assert_eq!(implementation.did.crate, local_crate);\n         match self.crate_context.tcx.items.find(&implementation.did.node) {\n             Some(&node_item(item, _)) => {\n                 return item.span;"}, {"sha": "1437494e5f86e8ea8d5582da9bf1e26f9d877430", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -680,7 +680,7 @@ pub impl RegionVarBindings {\n             match undo_item {\n               Snapshot => {}\n               AddVar(vid) => {\n-                assert!(self.var_spans.len() == vid.to_uint() + 1);\n+                assert_eq!(self.var_spans.len(), vid.to_uint() + 1);\n                 self.var_spans.pop();\n               }\n               AddConstraint(ref constraint) => {\n@@ -1440,7 +1440,7 @@ pub impl RegionVarBindings {\n \n         return match a_node.value {\n             NoValue => {\n-                assert!(a_node.classification == Contracting);\n+                assert_eq!(a_node.classification, Contracting);\n                 a_node.value = Value(b_region);\n                 true // changed\n             }"}, {"sha": "d6e652592d835b56114e5403dcbf85752d3face8", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -129,7 +129,7 @@ pub impl InferCtxt {\n         } else {\n             // If equal, redirect one to the other and increment the\n             // other's rank.\n-            assert!(node_a.rank == node_b.rank);\n+            assert_eq!(node_a.rank, node_b.rank);\n             self.set(node_b.root, Redirect(node_a.root));\n             (node_a.root, node_a.rank + 1)\n         }"}, {"sha": "47c99a8d9b773027bd144f39d54bdbe4b6505d54", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -162,6 +162,6 @@ fn srv_should_return_request_result() {\n     let source = ~\"fn a() { }\";\n     do from_str(source) |srv| {\n         let result = exec(srv, |_ctxt| 1000 );\n-        assert!(result == 1000);\n+        assert_eq!(result, 1000);\n     }\n }"}, {"sha": "c25764ab0601b6dea91d9b3fff6d4fba92f9fd29", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -197,7 +197,7 @@ mod test {\n     #[test]\n     fn should_promote_desc() {\n         let doc = mk_doc(~\"#[doc = \\\"desc\\\"] mod m { }\");\n-        assert!(doc.cratemod().mods()[0].brief() == Some(~\"desc\"));\n+        assert_eq!(doc.cratemod().mods()[0].brief(), Some(~\"desc\"));\n     }\n \n     #[test]\n@@ -217,20 +217,20 @@ mod test {\n     #[test]\n     fn test_paragraphs_1() {\n         let paras = paragraphs(~\"1\\n\\n2\");\n-        assert!(paras == ~[~\"1\", ~\"2\"]);\n+        assert_eq!(paras, ~[~\"1\", ~\"2\"]);\n     }\n \n     #[test]\n     fn test_paragraphs_2() {\n         let paras = paragraphs(~\"\\n\\n1\\n1\\n\\n2\\n\\n\");\n-        assert!(paras == ~[~\"1\\n1\", ~\"2\"]);\n+        assert_eq!(paras, ~[~\"1\\n1\", ~\"2\"]);\n     }\n \n     #[test]\n     fn should_promote_short_descs() {\n         let desc = Some(~\"desc\");\n         let brief = extract(copy desc);\n-        assert!(brief == desc);\n+        assert_eq!(brief, desc);\n     }\n \n     #[test]\n@@ -244,7 +244,7 @@ Scotland in the mid 12th century, although it may have been built by\n King Henry II of England when he took control of England'snorthern\n counties.\");\n         let brief = extract(desc);\n-        assert!(brief == None);\n+        assert_eq!(brief, None);\n     }\n \n     #[test]"}, {"sha": "11e9b71afdfff243600bc90958eaf1c775f5fa88", "filename": "src/librustdoc/escape_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fescape_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fescape_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fescape_pass.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -27,5 +27,5 @@ fn escape(s: &str) -> ~str {\n fn should_escape_backslashes() {\n     let s = ~\"\\\\n\";\n     let r = escape(s);\n-    assert!(r == ~\"\\\\\\\\n\");\n+    assert_eq!(r, ~\"\\\\\\\\n\");\n }"}, {"sha": "4c120aed9116138560ce42bb331b1c0114fe87ff", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -369,7 +369,7 @@ fn default_fold_should_produce_same_doc() {\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_seq_fold(());\n     let folded = (fld.fold_doc)(&fld, copy doc);\n-    assert!(doc == folded);\n+    assert_eq!(doc, folded);\n }\n \n #[test]\n@@ -379,7 +379,7 @@ fn default_fold_should_produce_same_consts() {\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_seq_fold(());\n     let folded = (fld.fold_doc)(&fld, copy doc);\n-    assert!(doc == folded);\n+    assert_eq!(doc, folded);\n }\n \n #[test]\n@@ -389,7 +389,7 @@ fn default_fold_should_produce_same_enums() {\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_seq_fold(());\n     let folded = (fld.fold_doc)(&fld, copy doc);\n-    assert!(doc == folded);\n+    assert_eq!(doc, folded);\n }\n \n #[test]\n@@ -399,5 +399,5 @@ fn default_parallel_fold_should_produce_same_doc() {\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_par_fold(());\n     let folded = (fld.fold_doc)(&fld, copy doc);\n-    assert!(doc == folded);\n+    assert_eq!(doc, folded);\n }"}, {"sha": "2c34f3543b73440882481c694f5f91d27f5d46eb", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -209,7 +209,7 @@ mod test {\n \n     #[test]\n     fn should_trim_whitespace_after_removing_punctuation() {\n-        assert!(pandoc_header_id(\"impl foo for ()\") == ~\"impl-foo-for\");\n+        assert_eq!(pandoc_header_id(\"impl foo for ()\"), ~\"impl-foo-for\");\n     }\n \n     #[test]"}, {"sha": "94372127a22ede8e00dceaefa868554788f216d0", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -285,7 +285,7 @@ mod test {\n         let doc = mk_doc(~\"test\", ~\"\");\n         let page = doc::CratePage(doc.CrateDoc());\n         let filename = make_local_filename(config, page);\n-        assert!(filename.to_str() == ~\"output/dir/test.md\");\n+        assert_eq!(filename.to_str(), ~\"output/dir/test.md\");\n     }\n \n     #[test]\n@@ -299,7 +299,7 @@ mod test {\n         let doc = mk_doc(~\"\", ~\"\");\n         let page = doc::CratePage(doc.CrateDoc());\n         let filename = make_local_filename(config, page);\n-        assert!(filename.to_str() == ~\"output/dir/index.html\");\n+        assert_eq!(filename.to_str(), ~\"output/dir/index.html\");\n     }\n \n     #[test]\n@@ -314,6 +314,6 @@ mod test {\n         let modb = copy doc.cratemod().mods()[0].mods()[0];\n         let page = doc::ItemPage(doc::ModTag(modb));\n         let filename = make_local_filename(config, page);\n-        assert!(filename == Path(\"output/dir/a_b.html\"));\n+        assert_eq!(filename, Path(\"output/dir/a_b.html\"));\n     }\n }"}, {"sha": "02716ff73b6b33208980c6bf0dffa47cd8032f55", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -176,13 +176,13 @@ mod test {\n             config::DocPerCrate,\n             ~\"mod a { } mod b { mod c { } }\"\n         );\n-        assert!(doc.pages.len() == 1u);\n+        assert_eq!(doc.pages.len(), 1u);\n     }\n \n     #[test]\n     fn should_make_a_page_for_every_mod() {\n         let doc = mk_doc(~\"mod a { }\");\n-        assert!(doc.pages.mods()[0].name() == ~\"a\");\n+        assert_eq!(doc.pages.mods()[0].name(), ~\"a\");\n     }\n \n     #[test]"}, {"sha": "6527481d514c7ff44eb2c899907d8556ece67d97", "filename": "src/librustdoc/pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpass.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -89,6 +89,6 @@ fn test_run_passes() {\n         ];\n         let doc = extract::from_srv(srv.clone(), ~\"one\");\n         let doc = run_passes(srv, doc, passes);\n-        assert!(doc.cratemod().name() == ~\"onetwothree\");\n+        assert_eq!(doc.cratemod().name(), ~\"onetwothree\");\n     }\n }"}, {"sha": "a31a8ac5933de38b6b99400c0481625228cf14c9", "filename": "src/librustdoc/path_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpath_pass.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -109,6 +109,6 @@ fn should_record_fn_paths() {\n     do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = run(srv.clone(), doc);\n-        assert!(doc.cratemod().mods()[0].fns()[0].path() == ~[~\"a\"]);\n+        assert_eq!(doc.cratemod().mods()[0].fns()[0].path(), ~[~\"a\"]);\n     }\n }"}, {"sha": "9dfcc7c4ec692821296fa3e6e04ac1f498ab5e21", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -194,7 +194,7 @@ mod test {\n               pub fn bar() { }\\\n               fn baz() { }\\\n               }\");\n-        assert!(doc.cratemod().impls()[0].methods.len() == 1);\n+        assert_eq!(doc.cratemod().impls()[0].methods.len(), 1);\n     }\n \n     #[test]\n@@ -204,7 +204,7 @@ mod test {\n               pub fn bar() { }\\\n               priv fn baz() { }\\\n               }\");\n-        assert!(doc.cratemod().impls()[0].methods.len() == 1);\n+        assert_eq!(doc.cratemod().impls()[0].methods.len(), 1);\n     }\n \n     #[test]\n@@ -214,7 +214,7 @@ mod test {\n               fn bar() { }\\\n               priv fn baz() { }\\\n               }\");\n-        assert!(doc.cratemod().impls()[0].methods.len() == 1);\n+        assert_eq!(doc.cratemod().impls()[0].methods.len(), 1);\n     }\n \n     #[test]\n@@ -224,7 +224,7 @@ mod test {\n               pub fn bar() { }\\\n               fn baz() { }\\\n               }\");\n-        assert!(doc.cratemod().impls()[0].methods.len() == 1);\n+        assert_eq!(doc.cratemod().impls()[0].methods.len(), 1);\n     }\n \n     #[test]\n@@ -234,7 +234,7 @@ mod test {\n               pub fn bar() { }\\\n               priv fn baz() { }\\\n               }\");\n-        assert!(doc.cratemod().impls()[0].methods.len() == 1);\n+        assert_eq!(doc.cratemod().impls()[0].methods.len(), 1);\n     }\n \n     #[test]"}, {"sha": "8c3704d55c7d9c6d73ed6a537be7b5daca45d618", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -236,7 +236,7 @@ mod test {\n               Body\\\"]\\\n               mod a {\n }\");\n-        assert!(doc.cratemod().mods()[0].desc() == None);\n+        assert_eq!(doc.cratemod().mods()[0].desc(), None);\n     }\n \n     #[test]\n@@ -247,7 +247,7 @@ mod test {\n               # Header\\n\\\n               Body\\\"]\\\n               fn a(); }\");\n-        assert!(doc.cratemod().traits()[0].methods[0].sections.len() == 1u);\n+        assert_eq!(doc.cratemod().traits()[0].methods[0].sections.len(), 1u);\n     }\n \n     #[test]\n@@ -258,6 +258,6 @@ mod test {\n               # Header\\n\\\n               Body\\\"]\\\n               fn a() { } }\");\n-        assert!(doc.cratemod().impls()[0].methods[0].sections.len() == 1u);\n+        assert_eq!(doc.cratemod().impls()[0].methods[0].sections.len(), 1u);\n     }\n }"}, {"sha": "572cb7db926e30736eb9a0dee1b7e337fac5e92b", "filename": "src/librustdoc/sort_item_name_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fsort_item_name_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fsort_item_name_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_item_name_pass.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -31,7 +31,7 @@ fn test() {\n     do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = (mk_pass().f)(srv.clone(), doc);\n-        assert!(doc.cratemod().items[0].name() == ~\"y\");\n-        assert!(doc.cratemod().items[1].name() == ~\"z\");\n+        assert_eq!(doc.cratemod().items[0].name(), ~\"y\");\n+        assert_eq!(doc.cratemod().items[1].name(), ~\"z\");\n     }\n }"}, {"sha": "cdb1a49c36dd7153e1ae1a28fd7a61ef4e12323a", "filename": "src/librustdoc/sort_item_type_pass.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_item_type_pass.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -53,13 +53,13 @@ fn test() {\n     do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = (mk_pass().f)(srv.clone(), doc);\n-        assert!(doc.cratemod().items[0].name() == ~\"iconst\");\n-        assert!(doc.cratemod().items[1].name() == ~\"itype\");\n-        assert!(doc.cratemod().items[2].name() == ~\"ienum\");\n-        assert!(doc.cratemod().items[3].name() == ~\"istruct\");\n-        assert!(doc.cratemod().items[4].name() == ~\"itrait\");\n-        assert!(doc.cratemod().items[5].name() == ~\"__extensions__\");\n-        assert!(doc.cratemod().items[6].name() == ~\"ifn\");\n-        assert!(doc.cratemod().items[7].name() == ~\"imod\");\n+        assert_eq!(doc.cratemod().items[0].name(), ~\"iconst\");\n+        assert_eq!(doc.cratemod().items[1].name(), ~\"itype\");\n+        assert_eq!(doc.cratemod().items[2].name(), ~\"ienum\");\n+        assert_eq!(doc.cratemod().items[3].name(), ~\"istruct\");\n+        assert_eq!(doc.cratemod().items[4].name(), ~\"itrait\");\n+        assert_eq!(doc.cratemod().items[5].name(), ~\"__extensions__\");\n+        assert_eq!(doc.cratemod().items[6].name(), ~\"ifn\");\n+        assert_eq!(doc.cratemod().items[7].name(), ~\"imod\");\n     }\n }"}, {"sha": "72abbd2bdbd05423c2e1579b43f8129850e33698", "filename": "src/librustdoc/sort_pass.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_pass.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -67,10 +67,10 @@ fn test() {\n     do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = (mk_pass(~\"\", name_lteq).f)(srv.clone(), doc);\n-        assert!(doc.cratemod().mods()[0].name() == ~\"w\");\n-        assert!(doc.cratemod().mods()[1].items[0].name() == ~\"x\");\n-        assert!(doc.cratemod().mods()[1].items[1].name() == ~\"y\");\n-        assert!(doc.cratemod().mods()[1].name() == ~\"z\");\n+        assert_eq!(doc.cratemod().mods()[0].name(), ~\"w\");\n+        assert_eq!(doc.cratemod().mods()[1].items[0].name(), ~\"x\");\n+        assert_eq!(doc.cratemod().mods()[1].items[1].name(), ~\"y\");\n+        assert_eq!(doc.cratemod().mods()[1].name(), ~\"z\");\n     }\n }\n \n@@ -84,10 +84,10 @@ fn should_be_stable() {\n     do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = (mk_pass(~\"\", always_eq).f)(srv.clone(), doc);\n-        assert!(doc.cratemod().mods()[0].items[0].name() == ~\"b\");\n-        assert!(doc.cratemod().mods()[1].items[0].name() == ~\"d\");\n+        assert_eq!(doc.cratemod().mods()[0].items[0].name(), ~\"b\");\n+        assert_eq!(doc.cratemod().mods()[1].items[0].name(), ~\"d\");\n         let doc = (mk_pass(~\"\", always_eq).f)(srv.clone(), doc);\n-        assert!(doc.cratemod().mods()[0].items[0].name() == ~\"b\");\n-        assert!(doc.cratemod().mods()[1].items[0].name() == ~\"d\");\n+        assert_eq!(doc.cratemod().mods()[0].items[0].name(), ~\"b\");\n+        assert_eq!(doc.cratemod().mods()[1].items[0].name(), ~\"d\");\n     }\n }"}, {"sha": "3b1a2059622b61c19c04dc1f0d1cfcabc0bad5c0", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -158,13 +158,13 @@ mod test {\n     #[test]\n     fn should_execute_op_on_enum_brief() {\n         let doc = mk_doc(~\"#[doc = \\\" a \\\"] enum a { b }\");\n-        assert!(doc.cratemod().enums()[0].brief() == Some(~\"a\"));\n+        assert_eq!(doc.cratemod().enums()[0].brief(), Some(~\"a\"));\n     }\n \n     #[test]\n     fn should_execute_op_on_enum_desc() {\n         let doc = mk_doc(~\"#[doc = \\\" a \\\"] enum a { b }\");\n-        assert!(doc.cratemod().enums()[0].desc() == Some(~\"a\"));\n+        assert_eq!(doc.cratemod().enums()[0].desc(), Some(~\"a\"));\n     }\n \n     #[test]\n@@ -177,14 +177,14 @@ mod test {\n     fn should_execute_op_on_trait_brief() {\n         let doc = mk_doc(\n             ~\"#[doc = \\\" a \\\"] trait i { fn a(); }\");\n-        assert!(doc.cratemod().traits()[0].brief() == Some(~\"a\"));\n+        assert_eq!(doc.cratemod().traits()[0].brief(), Some(~\"a\"));\n     }\n \n     #[test]\n     fn should_execute_op_on_trait_desc() {\n         let doc = mk_doc(\n             ~\"#[doc = \\\" a \\\"] trait i { fn a(); }\");\n-        assert!(doc.cratemod().traits()[0].desc() == Some(~\"a\"));\n+        assert_eq!(doc.cratemod().traits()[0].desc(), Some(~\"a\"));\n     }\n \n     #[test]\n@@ -205,14 +205,14 @@ mod test {\n     fn should_execute_op_on_impl_brief() {\n         let doc = mk_doc(\n             ~\"#[doc = \\\" a \\\"] impl int { fn a() { } }\");\n-        assert!(doc.cratemod().impls()[0].brief() == Some(~\"a\"));\n+        assert_eq!(doc.cratemod().impls()[0].brief(), Some(~\"a\"));\n     }\n \n     #[test]\n     fn should_execute_op_on_impl_desc() {\n         let doc = mk_doc(\n             ~\"#[doc = \\\" a \\\"] impl int { fn a() { } }\");\n-        assert!(doc.cratemod().impls()[0].desc() == Some(~\"a\"));\n+        assert_eq!(doc.cratemod().impls()[0].desc(), Some(~\"a\"));\n     }\n \n     #[test]\n@@ -233,14 +233,14 @@ mod test {\n     fn should_execute_op_on_type_brief() {\n         let doc = mk_doc(\n             ~\"#[doc = \\\" a \\\"] type t = int;\");\n-        assert!(doc.cratemod().types()[0].brief() == Some(~\"a\"));\n+        assert_eq!(doc.cratemod().types()[0].brief(), Some(~\"a\"));\n     }\n \n     #[test]\n     fn should_execute_op_on_type_desc() {\n         let doc = mk_doc(\n             ~\"#[doc = \\\" a \\\"] type t = int;\");\n-        assert!(doc.cratemod().types()[0].desc() == Some(~\"a\"));\n+        assert_eq!(doc.cratemod().types()[0].desc(), Some(~\"a\"));\n     }\n \n     #[test]"}, {"sha": "8bfa12ca0b5c4970fd6699ae9c76a2795b224a86", "filename": "src/librustdoc/trim_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftrim_pass.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -45,6 +45,6 @@ mod test {\n         let doc = mk_doc(~\"#[doc = \\\" desc \\\"] \\\n                                  mod m {\n }\");\n-        assert!(doc.cratemod().mods()[0].desc() == Some(~\"desc\"));\n+        assert_eq!(doc.cratemod().mods()[0].desc(), Some(~\"desc\"));\n     }\n }"}, {"sha": "826012a2447248a277407f46267bb5981949095a", "filename": "src/librustdoc/unindent_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -92,14 +92,14 @@ fn unindent(s: &str) -> ~str {\n fn should_unindent() {\n     let s = ~\"    line1\\n    line2\";\n     let r = unindent(s);\n-    assert!(r == ~\"line1\\nline2\");\n+    assert_eq!(r, ~\"line1\\nline2\");\n }\n \n #[test]\n fn should_unindent_multiple_paragraphs() {\n     let s = ~\"    line1\\n\\n    line2\";\n     let r = unindent(s);\n-    assert!(r == ~\"line1\\n\\nline2\");\n+    assert_eq!(r, ~\"line1\\n\\nline2\");\n }\n \n #[test]\n@@ -108,7 +108,7 @@ fn should_leave_multiple_indent_levels() {\n     // base indentation and should be preserved\n     let s = ~\"    line1\\n\\n        line2\";\n     let r = unindent(s);\n-    assert!(r == ~\"line1\\n\\n    line2\");\n+    assert_eq!(r, ~\"line1\\n\\n    line2\");\n }\n \n #[test]\n@@ -120,12 +120,12 @@ fn should_ignore_first_line_indent() {\n     //          and continue here\"]\n     let s = ~\"line1\\n    line2\";\n     let r = unindent(s);\n-    assert!(r == ~\"line1\\nline2\");\n+    assert_eq!(r, ~\"line1\\nline2\");\n }\n \n #[test]\n fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n     let s = ~\"line1\\n\\n    line2\";\n     let r = unindent(s);\n-    assert!(r == ~\"line1\\n\\n    line2\");\n+    assert_eq!(r, ~\"line1\\n\\n    line2\");\n }"}, {"sha": "2574ba4e762286a4f139e4171303910499ebeb43", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -212,7 +212,7 @@ fn test_package_ids_must_be_relative_path_like() {\n \n     let whatever = PkgId::new(\"foo\");\n \n-    assert!(addversion(\"foo\") == whatever.to_str());\n+    assert_eq!(addversion(\"foo\"), whatever.to_str());\n     assert!(addversion(\"github.com/mozilla/rust\") ==\n             PkgId::new(\"github.com/mozilla/rust\").to_str());\n \n@@ -222,16 +222,16 @@ fn test_package_ids_must_be_relative_path_like() {\n         copy whatever\n     }).in {\n         let x = PkgId::new(\"\");\n-        assert!(addversion(\"foo\") == x.to_str());\n+        assert_eq!(addversion(\"foo\"), x.to_str());\n     }\n \n     do cond.trap(|(p, e)| {\n-        assert!(p.to_str() == os::make_absolute(&Path(\"foo/bar/quux\")).to_str());\n+        assert_eq!(p.to_str(), os::make_absolute(&Path(\"foo/bar/quux\")).to_str());\n         assert!(\"absolute pkgid\" == e);\n         copy whatever\n     }).in {\n         let z = PkgId::new(os::make_absolute(&Path(\"foo/bar/quux\")).to_str());\n-        assert!(addversion(\"foo\") == z.to_str());\n+        assert_eq!(addversion(\"foo\"), z.to_str());\n     }\n \n }"}, {"sha": "011a1540e1bca90dd2a8ad0a8e21fce0874e747e", "filename": "src/librustpkg/testsuite/pass/src/install-paths/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Ftest.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -10,5 +10,5 @@\n \n #[test]\n fn test_two_plus_two() {\n-    assert!(2 + 2 == 4);\n+    assert_eq!(2 + 2, 4);\n }"}, {"sha": "108a404eb7c02021cd4fb892c4cd3975af1b6d42", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -417,7 +417,7 @@ pub fn compile_crate_from_input(input: &driver::input,\n     match crate_opt {\n         Some(c) => {\n             debug!(\"Calling compile_rest, outputs = %?\", outputs);\n-            assert!(what == driver::cu_everything);\n+            assert_eq!(what, driver::cu_everything);\n             driver::compile_rest(sess, cfg, driver::cu_everything, Some(outputs), Some(c));\n             c\n         }"}, {"sha": "f0158acfa79face232f4269fa08b50dc5a1d03f6", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -501,13 +501,13 @@ mod tests {\n             let arc_v = p.recv();\n \n             let v = copy *arc::get::<~[int]>(&arc_v);\n-            assert!(v[3] == 4);\n+            assert_eq!(v[3], 4);\n         };\n \n         let c = p.recv();\n         c.send(arc::clone(&arc_v));\n \n-        assert!((*arc::get(&arc_v))[2] == 3);\n+        assert_eq!((*arc::get(&arc_v))[2], 3);\n \n         info!(arc_v);\n     }\n@@ -545,7 +545,7 @@ mod tests {\n             do arc2.access_cond |one, cond| {\n                 cond.signal();\n                 // Parent should fail when it wakes up.\n-                assert!(*one == 0);\n+                assert_eq!(*one, 0);\n             }\n         }\n \n@@ -562,11 +562,11 @@ mod tests {\n         let arc2 = ~arc.clone();\n         do task::try || {\n             do arc2.access |one| {\n-                assert!(*one == 2);\n+                assert_eq!(*one, 2);\n             }\n         };\n         do arc.access |one| {\n-            assert!(*one == 1);\n+            assert_eq!(*one, 1);\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -575,11 +575,11 @@ mod tests {\n         let arc2 = (*arc).clone();\n         do task::try || {\n             do arc2.write |one| {\n-                assert!(*one == 2);\n+                assert_eq!(*one, 2);\n             }\n         };\n         do arc.read |one| {\n-            assert!(*one == 1);\n+            assert_eq!(*one, 1);\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -588,11 +588,11 @@ mod tests {\n         let arc2 = (*arc).clone();\n         do task::try || {\n             do arc2.write |one| {\n-                assert!(*one == 2);\n+                assert_eq!(*one, 2);\n             }\n         };\n         do arc.write |one| {\n-            assert!(*one == 1);\n+            assert_eq!(*one, 1);\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -602,12 +602,12 @@ mod tests {\n         do task::try || {\n             do arc2.write_downgrade |mut write_mode| {\n                 do write_mode.write |one| {\n-                    assert!(*one == 2);\n+                    assert_eq!(*one, 2);\n                 }\n             }\n         };\n         do arc.write |one| {\n-            assert!(*one == 1);\n+            assert_eq!(*one, 1);\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n@@ -616,11 +616,11 @@ mod tests {\n         let arc2 = (*arc).clone();\n         do task::try || {\n             do arc2.read |one| {\n-                assert!(*one == 2);\n+                assert_eq!(*one, 2);\n             }\n         };\n         do arc.read |one| {\n-            assert!(*one == 1);\n+            assert_eq!(*one, 1);\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n@@ -629,11 +629,11 @@ mod tests {\n         let arc2 = (*arc).clone();\n         do task::try || {\n             do arc2.read |one| {\n-                assert!(*one == 2);\n+                assert_eq!(*one, 2);\n             }\n         };\n         do arc.write |one| {\n-            assert!(*one == 1);\n+            assert_eq!(*one, 1);\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n@@ -644,12 +644,12 @@ mod tests {\n             do arc2.write_downgrade |write_mode| {\n                 let read_mode = arc2.downgrade(write_mode);\n                 do (&read_mode).read |one| {\n-                    assert!(*one == 2);\n+                    assert_eq!(*one, 2);\n                 }\n             }\n         };\n         do arc.write |one| {\n-            assert!(*one == 1);\n+            assert_eq!(*one, 1);\n         }\n     }\n     #[test]\n@@ -691,7 +691,7 @@ mod tests {\n         // Wait for writer to finish\n         p.recv();\n         do arc.read |num| {\n-            assert!(*num == 10);\n+            assert_eq!(*num, 10);\n         }\n     }\n     #[test]\n@@ -713,7 +713,7 @@ mod tests {\n             do task::spawn || {\n                 rp1.recv(); // wait for downgrader to give go-ahead\n                 do arcn.read |state| {\n-                    assert!(*state == 31337);\n+                    assert_eq!(*state, 31337);\n                     rc2.send(());\n                 }\n             }\n@@ -725,15 +725,15 @@ mod tests {\n         do task::spawn || {\n             wp1.recv();\n             do arc2.write_cond |state, cond| {\n-                assert!(*state == 0);\n+                assert_eq!(*state, 0);\n                 *state = 42;\n                 cond.signal();\n             }\n             wp1.recv();\n             do arc2.write |state| {\n                 // This shouldn't happen until after the downgrade read\n                 // section, and all other readers, finish.\n-                assert!(*state == 31337);\n+                assert_eq!(*state, 31337);\n                 *state = 42;\n             }\n             wc2.send(());\n@@ -746,7 +746,7 @@ mod tests {\n                 while *state == 0 {\n                     cond.wait();\n                 }\n-                assert!(*state == 42);\n+                assert_eq!(*state, 42);\n                 *state = 31337;\n                 // send to other readers\n                 for reader_convos.each |x| {\n@@ -764,7 +764,7 @@ mod tests {\n                     }\n                 }\n                 wc1.send(()); // tell writer to try again\n-                assert!(*state == 31337);\n+                assert_eq!(*state, 31337);\n             }\n         }\n "}, {"sha": "76df10817379fc299de471497ed1dd187fbc944d", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -229,23 +229,23 @@ mod tests {\n \n     #[test]\n     fn test_to_base64() {\n-        assert!((~\"\").to_base64()       == ~\"\");\n+        assert_eq!((~\"\").to_base64(), ~\"\");\n         assert!((~\"f\").to_base64()      == ~\"Zg==\");\n-        assert!((~\"fo\").to_base64()     == ~\"Zm8=\");\n-        assert!((~\"foo\").to_base64()    == ~\"Zm9v\");\n+        assert_eq!((~\"fo\").to_base64(), ~\"Zm8=\");\n+        assert_eq!((~\"foo\").to_base64(), ~\"Zm9v\");\n         assert!((~\"foob\").to_base64()   == ~\"Zm9vYg==\");\n-        assert!((~\"fooba\").to_base64()  == ~\"Zm9vYmE=\");\n-        assert!((~\"foobar\").to_base64() == ~\"Zm9vYmFy\");\n+        assert_eq!((~\"fooba\").to_base64(), ~\"Zm9vYmE=\");\n+        assert_eq!((~\"foobar\").to_base64(), ~\"Zm9vYmFy\");\n     }\n \n     #[test]\n     fn test_from_base64() {\n-        assert!((~\"\").from_base64() == str::to_bytes(~\"\"));\n+        assert_eq!((~\"\").from_base64(), str::to_bytes(~\"\"));\n         assert!((~\"Zg==\").from_base64() == str::to_bytes(~\"f\"));\n-        assert!((~\"Zm8=\").from_base64() == str::to_bytes(~\"fo\"));\n-        assert!((~\"Zm9v\").from_base64() == str::to_bytes(~\"foo\"));\n+        assert_eq!((~\"Zm8=\").from_base64(), str::to_bytes(~\"fo\"));\n+        assert_eq!((~\"Zm9v\").from_base64(), str::to_bytes(~\"foo\"));\n         assert!((~\"Zm9vYg==\").from_base64() == str::to_bytes(~\"foob\"));\n-        assert!((~\"Zm9vYmE=\").from_base64() == str::to_bytes(~\"fooba\"));\n-        assert!((~\"Zm9vYmFy\").from_base64() == str::to_bytes(~\"foobar\"));\n+        assert_eq!((~\"Zm9vYmE=\").from_base64(), str::to_bytes(~\"fooba\"))\n+        assert_eq!((~\"Zm9vYmFy\").from_base64(), str::to_bytes(~\"foobar\"));\n     }\n }"}, {"sha": "f0632e550fa682bb00a218fb7a2effbb2565526d", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -127,7 +127,7 @@ pub impl BigBitv {\n     fn process(&mut self, b: &BigBitv, nbits: uint,\n                op: &fn(uint, uint) -> uint) -> bool {\n         let len = b.storage.len();\n-        assert!((self.storage.len() == len));\n+        assert_eq!(self.storage.len(), len);\n         let mut changed = false;\n         for uint::range(0, len) |i| {\n             let mask = big_mask(nbits, i);\n@@ -508,7 +508,7 @@ pub impl Bitv {\n      * the bitvector and vector must have the same length\n      */\n     fn eq_vec(&self, v: ~[uint]) -> bool {\n-        assert!(self.nbits == v.len());\n+        assert_eq!(self.nbits, v.len());\n         let mut i = 0;\n         while i < self.nbits {\n             let w0 = self.get(i);\n@@ -909,10 +909,10 @@ mod tests {\n     #[test]\n     fn test_to_str() {\n         let zerolen = Bitv::new(0u, false);\n-        assert!(zerolen.to_str() == ~\"\");\n+        assert_eq!(zerolen.to_str(), ~\"\");\n \n         let eightbits = Bitv::new(8u, false);\n-        assert!(eightbits.to_str() == ~\"00000000\");\n+        assert_eq!(eightbits.to_str(), ~\"00000000\");\n     }\n \n     #[test]\n@@ -938,7 +938,7 @@ mod tests {\n         let mut b = bitv::Bitv::new(2, false);\n         b.set(0, true);\n         b.set(1, false);\n-        assert!(b.to_str() == ~\"10\");\n+        assert_eq!(b.to_str(), ~\"10\");\n     }\n \n     #[test]\n@@ -1248,19 +1248,19 @@ mod tests {\n     fn test_from_bytes() {\n         let bitv = from_bytes([0b10110110, 0b00000000, 0b11111111]);\n         let str = ~\"10110110\" + ~\"00000000\" + ~\"11111111\";\n-        assert!(bitv.to_str() == str);\n+        assert_eq!(bitv.to_str(), str);\n     }\n \n     #[test]\n     fn test_to_bytes() {\n         let mut bv = Bitv::new(3, true);\n         bv.set(1, false);\n-        assert!(bv.to_bytes() == ~[0b10100000]);\n+        assert_eq!(bv.to_bytes(), ~[0b10100000]);\n \n         let mut bv = Bitv::new(9, false);\n         bv.set(2, true);\n         bv.set(8, true);\n-        assert!(bv.to_bytes() == ~[0b00100000, 0b10000000]);\n+        assert_eq!(bv.to_bytes(), ~[0b00100000, 0b10000000]);\n     }\n \n     #[test]\n@@ -1272,7 +1272,7 @@ mod tests {\n     #[test]\n     fn test_to_bools() {\n         let bools = ~[false, false, true, false, false, true, true, false];\n-        assert!(from_bytes([0b00100110]).to_bools() == bools);\n+        assert_eq!(from_bytes([0b00100110]).to_bools(), bools);\n     }\n \n     #[test]\n@@ -1330,7 +1330,7 @@ mod tests {\n         assert!(b.insert(400));\n         assert!(!b.insert(400));\n         assert!(b.contains(&400));\n-        assert!(b.len() == 2);\n+        assert_eq!(b.len(), 2);\n     }\n \n     #[test]\n@@ -1354,10 +1354,10 @@ mod tests {\n         let mut i = 0;\n         let expected = [3, 5, 11, 77];\n         for a.intersection(&b) |x| {\n-            assert!(*x == expected[i]);\n+            assert_eq!(*x, expected[i]);\n             i += 1\n         }\n-        assert!(i == expected.len());\n+        assert_eq!(i, expected.len());\n     }\n \n     #[test]\n@@ -1377,10 +1377,10 @@ mod tests {\n         let mut i = 0;\n         let expected = [1, 5, 500];\n         for a.difference(&b) |x| {\n-            assert!(*x == expected[i]);\n+            assert_eq!(*x, expected[i]);\n             i += 1\n         }\n-        assert!(i == expected.len());\n+        assert_eq!(i, expected.len());\n     }\n \n     #[test]\n@@ -1402,10 +1402,10 @@ mod tests {\n         let mut i = 0;\n         let expected = [1, 5, 11, 14, 220];\n         for a.symmetric_difference(&b) |x| {\n-            assert!(*x == expected[i]);\n+            assert_eq!(*x, expected[i]);\n             i += 1\n         }\n-        assert!(i == expected.len());\n+        assert_eq!(i, expected.len());\n     }\n \n     #[test]\n@@ -1430,10 +1430,10 @@ mod tests {\n         let mut i = 0;\n         let expected = [1, 3, 5, 9, 11, 13, 19, 24, 160];\n         for a.union(&b) |x| {\n-            assert!(*x == expected[i]);\n+            assert_eq!(*x, expected[i]);\n             i += 1\n         }\n-        assert!(i == expected.len());\n+        assert_eq!(i, expected.len());\n     }\n \n     #[test]\n@@ -1448,7 +1448,7 @@ mod tests {\n \n         assert!(a.insert(1000));\n         assert!(a.remove(&1000));\n-        assert!(a.capacity() == uint::bits);\n+        assert_eq!(a.capacity(), uint::bits);\n     }\n \n     fn rng() -> rand::IsaacRng {"}, {"sha": "e463e5971881c9bc00f11a487eb895452f1bfae4", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -165,9 +165,9 @@ mod tests {\n \n         set(cv, 3u, 8u8);\n         set(cv, 4u, 9u8);\n-        assert!(get(cv, 3u) == 8u8);\n-        assert!(get(cv, 4u) == 9u8);\n-        assert!(len(cv) == 16u);\n+        assert_eq!(get(cv, 3u), 8u8);\n+        assert_eq!(get(cv, 4u), 9u8);\n+        assert_eq!(len(cv), 16u);\n     }\n \n     #[test]\n@@ -195,7 +195,7 @@ mod tests {\n \n         set(cv, 0u, 32u8);\n         set(cv, 1u, 33u8);\n-        assert!(unsafe { *p } == 32u8);\n+        assert_eq!(unsafe { *p }, 32u8);\n         set(cv, 2u, 34u8); /* safety */\n     }\n "}, {"sha": "28d3d329b26154600e2ca6526fca7fa6509fc43d", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -104,7 +104,7 @@ mod test {\n         left.send(~\"abc\");\n         right.send(123);\n \n-        assert!(left.recv() == 123);\n-        assert!(right.recv() == ~\"abc\");\n+        assert_eq!(left.recv(), 123);\n+        assert_eq!(right.recv(), ~\"abc\");\n     }\n }"}, {"sha": "eac765de00636e230e6a457ffb402724831bdf1f", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -140,7 +140,7 @@ pub impl<T> Deque<T> {\n /// Grow is only called on full elts, so nelts is also len(elts), unlike\n /// elsewhere.\n fn grow<T>(nelts: uint, lo: uint, elts: &mut [Option<T>]) -> ~[Option<T>] {\n-    assert!(nelts == elts.len());\n+    assert_eq!(nelts, elts.len());\n     let mut rv = ~[];\n \n     do rv.grow_fn(nelts + 1) |i| {\n@@ -163,46 +163,46 @@ mod tests {\n     #[test]\n     fn test_simple() {\n         let mut d = Deque::new();\n-        assert!(d.len() == 0u);\n+        assert_eq!(d.len(), 0u);\n         d.add_front(17);\n         d.add_front(42);\n         d.add_back(137);\n-        assert!(d.len() == 3u);\n+        assert_eq!(d.len(), 3u);\n         d.add_back(137);\n-        assert!(d.len() == 4u);\n+        assert_eq!(d.len(), 4u);\n         debug!(d.peek_front());\n-        assert!(*d.peek_front() == 42);\n+        assert_eq!(*d.peek_front(), 42);\n         debug!(d.peek_back());\n-        assert!(*d.peek_back() == 137);\n+        assert_eq!(*d.peek_back(), 137);\n         let mut i: int = d.pop_front();\n         debug!(i);\n-        assert!(i == 42);\n+        assert_eq!(i, 42);\n         i = d.pop_back();\n         debug!(i);\n-        assert!(i == 137);\n+        assert_eq!(i, 137);\n         i = d.pop_back();\n         debug!(i);\n-        assert!(i == 137);\n+        assert_eq!(i, 137);\n         i = d.pop_back();\n         debug!(i);\n-        assert!(i == 17);\n-        assert!(d.len() == 0u);\n+        assert_eq!(i, 17);\n+        assert_eq!(d.len(), 0u);\n         d.add_back(3);\n-        assert!(d.len() == 1u);\n+        assert_eq!(d.len(), 1u);\n         d.add_front(2);\n-        assert!(d.len() == 2u);\n+        assert_eq!(d.len(), 2u);\n         d.add_back(4);\n-        assert!(d.len() == 3u);\n+        assert_eq!(d.len(), 3u);\n         d.add_front(1);\n-        assert!(d.len() == 4u);\n+        assert_eq!(d.len(), 4u);\n         debug!(d.get(0));\n         debug!(d.get(1));\n         debug!(d.get(2));\n         debug!(d.get(3));\n-        assert!(*d.get(0) == 1);\n-        assert!(*d.get(1) == 2);\n-        assert!(*d.get(2) == 3);\n-        assert!(*d.get(3) == 4);\n+        assert_eq!(*d.get(0), 1);\n+        assert_eq!(*d.get(1), 2);\n+        assert_eq!(*d.get(2), 3);\n+        assert_eq!(*d.get(3), 4);\n     }\n \n     #[test]\n@@ -213,63 +213,63 @@ mod tests {\n         let d: @int = @175;\n \n         let mut deq = Deque::new();\n-        assert!(deq.len() == 0);\n+        assert_eq!(deq.len(), 0);\n         deq.add_front(a);\n         deq.add_front(b);\n         deq.add_back(c);\n-        assert!(deq.len() == 3);\n+        assert_eq!(deq.len(), 3);\n         deq.add_back(d);\n-        assert!(deq.len() == 4);\n-        assert!(*deq.peek_front() == b);\n-        assert!(*deq.peek_back() == d);\n-        assert!(deq.pop_front() == b);\n-        assert!(deq.pop_back() == d);\n-        assert!(deq.pop_back() == c);\n-        assert!(deq.pop_back() == a);\n-        assert!(deq.len() == 0);\n+        assert_eq!(deq.len(), 4);\n+        assert_eq!(*deq.peek_front(), b);\n+        assert_eq!(*deq.peek_back(), d);\n+        assert_eq!(deq.pop_front(), b);\n+        assert_eq!(deq.pop_back(), d);\n+        assert_eq!(deq.pop_back(), c);\n+        assert_eq!(deq.pop_back(), a);\n+        assert_eq!(deq.len(), 0);\n         deq.add_back(c);\n-        assert!(deq.len() == 1);\n+        assert_eq!(deq.len(), 1);\n         deq.add_front(b);\n-        assert!(deq.len() == 2);\n+        assert_eq!(deq.len(), 2);\n         deq.add_back(d);\n-        assert!(deq.len() == 3);\n+        assert_eq!(deq.len(), 3);\n         deq.add_front(a);\n-        assert!(deq.len() == 4);\n-        assert!(*deq.get(0) == a);\n-        assert!(*deq.get(1) == b);\n-        assert!(*deq.get(2) == c);\n-        assert!(*deq.get(3) == d);\n+        assert_eq!(deq.len(), 4);\n+        assert_eq!(*deq.get(0), a);\n+        assert_eq!(*deq.get(1), b);\n+        assert_eq!(*deq.get(2), c);\n+        assert_eq!(*deq.get(3), d);\n     }\n \n     #[cfg(test)]\n     fn test_parameterized<T:Copy + Eq>(a: T, b: T, c: T, d: T) {\n         let mut deq = Deque::new();\n-        assert!(deq.len() == 0);\n+        assert_eq!(deq.len(), 0);\n         deq.add_front(a);\n         deq.add_front(b);\n         deq.add_back(c);\n-        assert!(deq.len() == 3);\n+        assert_eq!(deq.len(), 3);\n         deq.add_back(d);\n-        assert!(deq.len() == 4);\n-        assert!(*deq.peek_front() == b);\n-        assert!(*deq.peek_back() == d);\n-        assert!(deq.pop_front() == b);\n-        assert!(deq.pop_back() == d);\n-        assert!(deq.pop_back() == c);\n-        assert!(deq.pop_back() == a);\n-        assert!(deq.len() == 0);\n+        assert_eq!(deq.len(), 4);\n+        assert_eq!(*deq.peek_front(), b);\n+        assert_eq!(*deq.peek_back(), d);\n+        assert_eq!(deq.pop_front(), b);\n+        assert_eq!(deq.pop_back(), d);\n+        assert_eq!(deq.pop_back(), c);\n+        assert_eq!(deq.pop_back(), a);\n+        assert_eq!(deq.len(), 0);\n         deq.add_back(c);\n-        assert!(deq.len() == 1);\n+        assert_eq!(deq.len(), 1);\n         deq.add_front(b);\n-        assert!(deq.len() == 2);\n+        assert_eq!(deq.len(), 2);\n         deq.add_back(d);\n-        assert!(deq.len() == 3);\n+        assert_eq!(deq.len(), 3);\n         deq.add_front(a);\n-        assert!(deq.len() == 4);\n-        assert!(*deq.get(0) == a);\n-        assert!(*deq.get(1) == b);\n-        assert!(*deq.get(2) == c);\n-        assert!(*deq.get(3) == d);\n+        assert_eq!(deq.len(), 4);\n+        assert_eq!(*deq.get(0), a);\n+        assert_eq!(*deq.get(1), b);\n+        assert_eq!(*deq.get(2), c);\n+        assert_eq!(*deq.get(3), d);\n     }\n \n     #[deriving(Eq)]"}, {"sha": "e0b4d746d5317978740282b1943e0935a54199d0", "filename": "src/libstd/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdlist.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -438,7 +438,7 @@ pub impl<T> DList<T> {\n             link = nobe.next_link();\n             count += 1;\n         }\n-        assert!(count == self.len());\n+        assert_eq!(count, self.len());\n         // iterate backwards - some of this is probably redundant.\n         link = self.peek_tail_n();\n         rabbit = link;\n@@ -459,7 +459,7 @@ pub impl<T> DList<T> {\n             link = nobe.prev_link();\n             count -= 1;\n         }\n-        assert!(count == 0);\n+        assert_eq!(count, 0);\n     }\n }\n "}, {"sha": "8d550081d1e7a644d87f339d7f7882809e010866", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -273,22 +273,22 @@ pub mod reader {\n     pub fn doc_as_str(d: Doc) -> ~str { str::from_bytes(doc_data(d)) }\n \n     pub fn doc_as_u8(d: Doc) -> u8 {\n-        assert!(d.end == d.start + 1u);\n+        assert_eq!(d.end, d.start + 1u);\n         (*d.data)[d.start]\n     }\n \n     pub fn doc_as_u16(d: Doc) -> u16 {\n-        assert!(d.end == d.start + 2u);\n+        assert_eq!(d.end, d.start + 2u);\n         io::u64_from_be_bytes(*d.data, d.start, 2u) as u16\n     }\n \n     pub fn doc_as_u32(d: Doc) -> u32 {\n-        assert!(d.end == d.start + 4u);\n+        assert_eq!(d.end, d.start + 4u);\n         io::u64_from_be_bytes(*d.data, d.start, 4u) as u32\n     }\n \n     pub fn doc_as_u64(d: Doc) -> u64 {\n-        assert!(d.end == d.start + 8u);\n+        assert_eq!(d.end, d.start + 8u);\n         io::u64_from_be_bytes(*d.data, d.start, 8u)\n     }\n \n@@ -988,7 +988,7 @@ mod tests {\n             let mut deser = reader::Decoder(ebml_doc);\n             let v1 = serialize::Decodable::decode(&mut deser);\n             debug!(\"v1 == %?\", v1);\n-            assert!(v == v1);\n+            assert_eq!(v, v1);\n         }\n \n         test_v(Some(22));"}, {"sha": "b0d219bc945e936793b6cbbe50621283807b3abf", "filename": "src/libstd/flate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflate.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -102,6 +102,6 @@ fn test_flate_round_trip() {\n         debug!(\"%u bytes deflated to %u (%.1f%% size)\",\n                in.len(), cmp.len(),\n                100.0 * ((cmp.len() as float) / (in.len() as float)));\n-        assert!((in == out));\n+        assert_eq!(in, out);\n     }\n }"}, {"sha": "a634f88dcf5774ed00f7e37d8d26a9c7a1f0b1d0", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -356,7 +356,7 @@ pub mod flatteners {\n     impl<T:Copy + Owned> Unflattener<T> for PodUnflattener<T> {\n         fn unflatten(&self, buf: ~[u8]) -> T {\n             assert!(size_of::<T>() != 0);\n-            assert!(size_of::<T>() == buf.len());\n+            assert_eq!(size_of::<T>(), buf.len());\n             let addr_of_init: &u8 = unsafe { &*vec::raw::to_ptr(buf) };\n             let addr_of_value: &T = unsafe { cast::transmute(addr_of_init) };\n             copy *addr_of_value\n@@ -652,7 +652,7 @@ mod test {\n         let port = serial::reader_port(reader);\n \n         let res: int = port.recv();\n-        assert!(res == 10i);\n+        assert_eq!(res, 10i);\n     }\n \n     #[test]\n@@ -700,7 +700,7 @@ mod test {\n         let port = pod::reader_port(reader);\n \n         let res: int = port.recv();\n-        assert!(res == 10);\n+        assert_eq!(res, 10);\n     }\n \n     #[test]\n@@ -843,7 +843,7 @@ mod test {\n             for int::range(0, 10) |i| {\n                 let j = port.recv();\n                 debug!(\"received %?\", j);\n-                assert!(i == j);\n+                assert_eq!(i, j);\n             }\n \n             // The test is over!"}, {"sha": "02828b8eaee9e8ebc23ec597cca187a0cbf61222", "filename": "src/libstd/future.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -154,39 +154,39 @@ mod test {\n     #[test]\n     fn test_from_value() {\n         let mut f = from_value(~\"snail\");\n-        assert!(f.get() == ~\"snail\");\n+        assert_eq!(f.get(), ~\"snail\");\n     }\n \n     #[test]\n     fn test_from_port() {\n         let (po, ch) = oneshot();\n         send_one(ch, ~\"whale\");\n         let mut f = from_port(po);\n-        assert!(f.get() == ~\"whale\");\n+        assert_eq!(f.get(), ~\"whale\");\n     }\n \n     #[test]\n     fn test_from_fn() {\n         let mut f = from_fn(|| ~\"brail\");\n-        assert!(f.get() == ~\"brail\");\n+        assert_eq!(f.get(), ~\"brail\");\n     }\n \n     #[test]\n     fn test_interface_get() {\n         let mut f = from_value(~\"fail\");\n-        assert!(f.get() == ~\"fail\");\n+        assert_eq!(f.get(), ~\"fail\");\n     }\n \n     #[test]\n     fn test_get_ref_method() {\n         let mut f = from_value(22);\n-        assert!(*f.get_ref() == 22);\n+        assert_eq!(*f.get_ref(), 22);\n     }\n \n     #[test]\n     fn test_spawn() {\n         let mut f = spawn(|| ~\"bale\");\n-        assert!(f.get() == ~\"bale\");\n+        assert_eq!(f.get(), ~\"bale\");\n     }\n \n     #[test]\n@@ -204,7 +204,7 @@ mod test {\n         do task::spawn {\n             let mut f = f.take();\n             let actual = f.get();\n-            assert!(actual == expected);\n+            assert_eq!(actual, expected);\n         }\n     }\n }"}, {"sha": "d0b298deb898400a4ce4959b40a1d634f360adfc", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -684,7 +684,7 @@ mod tests {\n         match rs {\n           Ok(ref m) => {\n             assert!((opt_present(m, ~\"test\")));\n-            assert!((opt_str(m, ~\"test\") == ~\"20\"));\n+            assert_eq!(opt_str(m, ~\"test\"), ~\"20\");\n           }\n           _ => { fail!(\"test_reqopt_long failed\"); }\n         }\n@@ -731,7 +731,7 @@ mod tests {\n         match rs {\n           Ok(ref m) => {\n             assert!((opt_present(m, ~\"t\")));\n-            assert!((opt_str(m, ~\"t\") == ~\"20\"));\n+            assert_eq!(opt_str(m, ~\"t\"), ~\"20\");\n           }\n           _ => fail!()\n         }\n@@ -780,7 +780,7 @@ mod tests {\n         match rs {\n           Ok(ref m) => {\n             assert!((opt_present(m, ~\"test\")));\n-            assert!((opt_str(m, ~\"test\") == ~\"20\"));\n+            assert_eq!(opt_str(m, ~\"test\"), ~\"20\");\n           }\n           _ => fail!()\n         }\n@@ -827,7 +827,7 @@ mod tests {\n         match rs {\n           Ok(ref m) => {\n             assert!((opt_present(m, ~\"t\")));\n-            assert!((opt_str(m, ~\"t\") == ~\"20\"));\n+            assert_eq!(opt_str(m, ~\"t\"), ~\"20\");\n           }\n           _ => fail!()\n         }\n@@ -946,7 +946,7 @@ mod tests {\n           Ok(ref m) => {\n             // The next variable after the flag is just a free argument\n \n-            assert!((m.free[0] == ~\"20\"));\n+            assert!(m.free[0] == ~\"20\");\n           }\n           _ => fail!()\n         }\n@@ -971,7 +971,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_count(m, ~\"v\") == 1));\n+            assert_eq!(opt_count(m, ~\"v\"), 1);\n           }\n           _ => fail!()\n         }\n@@ -984,7 +984,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_count(m, ~\"v\") == 2));\n+            assert_eq!(opt_count(m, ~\"v\"), 2);\n           }\n           _ => fail!()\n         }\n@@ -997,7 +997,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_count(m, ~\"v\") == 2));\n+            assert_eq!(opt_count(m, ~\"v\"), 2);\n           }\n           _ => fail!()\n         }\n@@ -1010,7 +1010,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_count(m, ~\"verbose\") == 1));\n+            assert_eq!(opt_count(m, ~\"verbose\"), 1);\n           }\n           _ => fail!()\n         }\n@@ -1023,7 +1023,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_count(m, ~\"verbose\") == 2));\n+            assert_eq!(opt_count(m, ~\"verbose\"), 2);\n           }\n           _ => fail!()\n         }\n@@ -1038,7 +1038,7 @@ mod tests {\n         match rs {\n           Ok(ref m) => {\n             assert!((opt_present(m, ~\"test\")));\n-            assert!((opt_str(m, ~\"test\") == ~\"20\"));\n+            assert_eq!(opt_str(m, ~\"test\"), ~\"20\");\n           }\n           _ => fail!()\n         }\n@@ -1073,11 +1073,11 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-              assert!((opt_present(m, ~\"test\")));\n-              assert!((opt_str(m, ~\"test\") == ~\"20\"));\n+              assert!(opt_present(m, ~\"test\"));\n+              assert_eq!(opt_str(m, ~\"test\"), ~\"20\");\n               let pair = opt_strs(m, ~\"test\");\n-              assert!((pair[0] == ~\"20\"));\n-              assert!((pair[1] == ~\"30\"));\n+              assert!(pair[0] == ~\"20\");\n+              assert!(pair[1] == ~\"30\");\n           }\n           _ => fail!()\n         }\n@@ -1091,7 +1091,7 @@ mod tests {\n         match rs {\n           Ok(ref m) => {\n             assert!((opt_present(m, ~\"t\")));\n-            assert!((opt_str(m, ~\"t\") == ~\"20\"));\n+            assert_eq!(opt_str(m, ~\"t\"), ~\"20\");\n           }\n           _ => fail!()\n         }\n@@ -1127,10 +1127,10 @@ mod tests {\n         match rs {\n           Ok(ref m) => {\n             assert!((opt_present(m, ~\"t\")));\n-            assert!((opt_str(m, ~\"t\") == ~\"20\"));\n+            assert_eq!(opt_str(m, ~\"t\"), ~\"20\");\n             let pair = opt_strs(m, ~\"t\");\n-            assert!((pair[0] == ~\"20\"));\n-            assert!((pair[1] == ~\"30\"));\n+            assert!(pair[0] == ~\"20\");\n+            assert!(pair[1] == ~\"30\");\n           }\n           _ => fail!()\n         }\n@@ -1171,19 +1171,19 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((m.free[0] == ~\"prog\"));\n-            assert!((m.free[1] == ~\"free1\"));\n-            assert!((opt_str(m, ~\"s\") == ~\"20\"));\n-            assert!((m.free[2] == ~\"free2\"));\n+            assert!(m.free[0] == ~\"prog\");\n+            assert!(m.free[1] == ~\"free1\");\n+            assert_eq!(opt_str(m, ~\"s\"), ~\"20\");\n+            assert!(m.free[2] == ~\"free2\");\n             assert!((opt_present(m, ~\"flag\")));\n-            assert!((opt_str(m, ~\"long\") == ~\"30\"));\n+            assert_eq!(opt_str(m, ~\"long\"), ~\"30\");\n             assert!((opt_present(m, ~\"f\")));\n             let pair = opt_strs(m, ~\"m\");\n-            assert!((pair[0] == ~\"40\"));\n-            assert!((pair[1] == ~\"50\"));\n+            assert!(pair[0] == ~\"40\");\n+            assert!(pair[1] == ~\"50\");\n             let pair = opt_strs(m, ~\"n\");\n-            assert!((pair[0] == ~\"-A B\"));\n-            assert!((pair[1] == ~\"-60 70\"));\n+            assert!(pair[0] == ~\"-A B\");\n+            assert!(pair[1] == ~\"-60 70\");\n             assert!((!opt_present(m, ~\"notpresent\")));\n           }\n           _ => fail!()\n@@ -1206,10 +1206,10 @@ mod tests {\n         assert!(!opts_present(matches, ~[~\"thing\"]));\n         assert!(!opts_present(matches, ~[]));\n \n-        assert!(opts_str(matches, ~[~\"e\"]) == ~\"foo\");\n-        assert!(opts_str(matches, ~[~\"encrypt\"]) == ~\"foo\");\n-        assert!(opts_str(matches, ~[~\"e\", ~\"encrypt\"]) == ~\"foo\");\n-        assert!(opts_str(matches, ~[~\"encrypt\", ~\"e\"]) == ~\"foo\");\n+        assert_eq!(opts_str(matches, ~[~\"e\"]), ~\"foo\");\n+        assert_eq!(opts_str(matches, ~[~\"encrypt\"]), ~\"foo\");\n+        assert_eq!(opts_str(matches, ~[~\"e\", ~\"encrypt\"]), ~\"foo\");\n+        assert_eq!(opts_str(matches, ~[~\"encrypt\", ~\"e\"]), ~\"foo\");\n     }\n \n     #[test]\n@@ -1221,9 +1221,9 @@ mod tests {\n           result::Err(_) => fail!()\n         };\n         assert!(opts_present(matches, ~[~\"L\"]));\n-        assert!(opts_str(matches, ~[~\"L\"]) == ~\"foo\");\n+        assert_eq!(opts_str(matches, ~[~\"L\"]), ~\"foo\");\n         assert!(opts_present(matches, ~[~\"M\"]));\n-        assert!(opts_str(matches, ~[~\"M\"]) == ~\".\");\n+        assert_eq!(opts_str(matches, ~[~\"M\"]), ~\".\");\n \n     }\n \n@@ -1290,7 +1290,7 @@ mod tests {\n         let verbose = groups::reqopt(~\"b\", ~\"banana\",\n                                        ~\"some bananas\", ~\"VAL\");\n \n-        assert!(groups::long_to_short(&verbose) == short);\n+        assert_eq!(groups::long_to_short(&verbose), short);\n     }\n \n     #[test]\n@@ -1347,7 +1347,7 @@ Options:\n \n         debug!(\"expected: <<%s>>\", expected);\n         debug!(\"generated: <<%s>>\", generated_usage);\n-        assert!(generated_usage == expected);\n+        assert_eq!(generated_usage, expected);\n     }\n \n     #[test]"}, {"sha": "ae3251b961c18a91364ba0220e9d6150dca7179c", "filename": "src/libstd/list.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -228,28 +228,28 @@ mod tests {\n     fn test_from_vec() {\n         let l = from_vec(~[0, 1, 2]);\n \n-        assert!((head(l) == 0));\n+        assert_eq!(head(l), 0);\n \n         let tail_l = tail(l);\n-        assert!((head(tail_l) == 1));\n+        assert_eq!(head(tail_l), 1);\n \n         let tail_tail_l = tail(tail_l);\n-        assert!((head(tail_tail_l) == 2));\n+        assert_eq!(head(tail_tail_l), 2);\n     }\n \n     #[test]\n     fn test_from_vec_empty() {\n         let empty : @list::List<int> = from_vec(~[]);\n-        assert!((empty == @list::Nil::<int>));\n+        assert_eq!(empty, @list::Nil::<int>);\n     }\n \n     #[test]\n     fn test_foldl() {\n         fn add(a: &uint, b: &int) -> uint { return *a + (*b as uint); }\n         let l = from_vec(~[0, 1, 2, 3, 4]);\n         let empty = @list::Nil::<int>;\n-        assert!((list::foldl(0u, l, add) == 10u));\n-        assert!((list::foldl(0u, empty, add) == 0u));\n+        assert_eq!(list::foldl(0u, l, add), 10u);\n+        assert_eq!(list::foldl(0u, empty, add), 0u);\n     }\n \n     #[test]\n@@ -258,23 +258,23 @@ mod tests {\n             *a - *b\n         }\n         let l = from_vec(~[1, 2, 3, 4]);\n-        assert!((list::foldl(0, l, sub) == -10));\n+        assert_eq!(list::foldl(0, l, sub), -10);\n     }\n \n     #[test]\n     fn test_find_success() {\n         fn match_(i: &int) -> bool { return *i == 2; }\n         let l = from_vec(~[0, 1, 2]);\n-        assert!((list::find(l, match_) == option::Some(2)));\n+        assert_eq!(list::find(l, match_), option::Some(2));\n     }\n \n     #[test]\n     fn test_find_fail() {\n         fn match_(_i: &int) -> bool { return false; }\n         let l = from_vec(~[0, 1, 2]);\n         let empty = @list::Nil::<int>;\n-        assert!((list::find(l, match_) == option::None::<int>));\n-        assert!((list::find(empty, match_) == option::None::<int>));\n+        assert_eq!(list::find(l, match_), option::None::<int>);\n+        assert_eq!(list::find(empty, match_), option::None::<int>);\n     }\n \n     #[test]\n@@ -291,8 +291,8 @@ mod tests {\n     fn test_len() {\n         let l = from_vec(~[0, 1, 2]);\n         let empty = @list::Nil::<int>;\n-        assert!((list::len(l) == 3u));\n-        assert!((list::len(empty) == 0u));\n+        assert_eq!(list::len(l), 3u);\n+        assert_eq!(list::len(empty), 0u);\n     }\n \n     #[test]"}, {"sha": "19cd418915e748cabb21ff673d99a3c1c7cd47fb", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -125,9 +125,9 @@ pub fn md4_text(msg: &str) -> ~str { md4_str(str::to_bytes(msg)) }\n \n #[test]\n fn test_md4() {\n-    assert!(md4_text(~\"\") == ~\"31d6cfe0d16ae931b73c59d7e0c089c0\");\n-    assert!(md4_text(~\"a\") == ~\"bde52cb31de33e46245e05fbdbd6fb24\");\n-    assert!(md4_text(~\"abc\") == ~\"a448017aaf21d8525fc10ae87aa6729d\");\n+    assert_eq!(md4_text(~\"\"), ~\"31d6cfe0d16ae931b73c59d7e0c089c0\");\n+    assert_eq!(md4_text(~\"a\"), ~\"bde52cb31de33e46245e05fbdbd6fb24\");\n+    assert_eq!(md4_text(~\"abc\"), ~\"a448017aaf21d8525fc10ae87aa6729d\");\n     assert!(md4_text(~\"message digest\") ==\n         ~\"d9130a8164549fe818874806e1c7014b\");\n     assert!(md4_text(~\"abcdefghijklmnopqrstuvwxyz\") =="}, {"sha": "4f67f1c5f135142e2c136f03473b6e8ee00268b6", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -383,7 +383,7 @@ mod test {\n         let format_result = format_addr(&v6::parse_addr(localhost_str));\n         debug!(\"results: expected: '%s' actual: '%s'\",\n             localhost_str, format_result);\n-        assert!(format_result == localhost_str);\n+        assert_eq!(format_result, localhost_str);\n     }\n     #[test]\n     fn test_ip_ipv4_bad_parse() {"}, {"sha": "db61679890b27096f76a2e90185ec72e1f7dacee", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -1623,7 +1623,7 @@ mod test {\n         // This is what we are actually testing!\n         assert!(net::ip::format_addr(&sock.get_peer_addr()) ==\n             ~\"127.0.0.1\");\n-        assert!(net::ip::get_port(&sock.get_peer_addr()) == 8887);\n+        assert_eq!(net::ip::get_port(&sock.get_peer_addr()), 8887);\n \n         // Fulfill the protocol the test server expects\n         let resp_bytes = str::to_bytes(~\"ping\");"}, {"sha": "ef503817b55af2d6f8251065a51d80e3df374396", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 136, "deletions": 136, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -722,53 +722,53 @@ impl IterBytes for Url {\n #[test]\n fn test_split_char_first() {\n     let (u,v) = split_char_first(~\"hello, sweet world\", ',');\n-    assert!(u == ~\"hello\");\n-    assert!(v == ~\" sweet world\");\n+    assert_eq!(u, ~\"hello\");\n+    assert_eq!(v, ~\" sweet world\");\n \n     let (u,v) = split_char_first(~\"hello sweet world\", ',');\n-    assert!(u == ~\"hello sweet world\");\n-    assert!(v == ~\"\");\n+    assert_eq!(u, ~\"hello sweet world\");\n+    assert_eq!(v, ~\"\");\n }\n \n #[test]\n fn test_get_authority() {\n     let (u, h, p, r) = get_authority(\n         \"//user:pass@rust-lang.org/something\").unwrap();\n-    assert!(u == Some(UserInfo::new(~\"user\", Some(~\"pass\"))));\n-    assert!(h == ~\"rust-lang.org\");\n+    assert_eq!(u, Some(UserInfo::new(~\"user\", Some(~\"pass\"))));\n+    assert_eq!(h, ~\"rust-lang.org\");\n     assert!(p.is_none());\n-    assert!(r == ~\"/something\");\n+    assert_eq!(r, ~\"/something\");\n \n     let (u, h, p, r) = get_authority(\n         \"//rust-lang.org:8000?something\").unwrap();\n     assert!(u.is_none());\n-    assert!(h == ~\"rust-lang.org\");\n-    assert!(p == Some(~\"8000\"));\n-    assert!(r == ~\"?something\");\n+    assert_eq!(h, ~\"rust-lang.org\");\n+    assert_eq!(p, Some(~\"8000\"));\n+    assert_eq!(r, ~\"?something\");\n \n     let (u, h, p, r) = get_authority(\n         \"//rust-lang.org#blah\").unwrap();\n     assert!(u.is_none());\n-    assert!(h == ~\"rust-lang.org\");\n+    assert_eq!(h, ~\"rust-lang.org\");\n     assert!(p.is_none());\n-    assert!(r == ~\"#blah\");\n+    assert_eq!(r, ~\"#blah\");\n \n     // ipv6 tests\n     let (_, h, _, _) = get_authority(\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334#blah\").unwrap();\n-    assert!(h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n+    assert_eq!(h, ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n \n     let (_, h, p, _) = get_authority(\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\").unwrap();\n-    assert!(h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n-    assert!(p == Some(~\"8000\"));\n+    assert_eq!(h, ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n+    assert_eq!(p, Some(~\"8000\"));\n \n     let (u, h, p, _) = get_authority(\n         \"//us:p@2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\"\n     ).unwrap();\n-    assert!(u == Some(UserInfo::new(~\"us\", Some(~\"p\"))));\n-    assert!(h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n-    assert!(p == Some(~\"8000\"));\n+    assert_eq!(u, Some(UserInfo::new(~\"us\", Some(~\"p\"))));\n+    assert_eq!(h, ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n+    assert_eq!(p, Some(~\"8000\"));\n \n     // invalid authorities;\n     assert!(get_authority(\"//user:pass@rust-lang:something\").is_err());\n@@ -780,22 +780,22 @@ fn test_get_authority() {\n \n     // these parse as empty, because they don't start with '//'\n     let (_, h, _, _) = get_authority(~\"user:pass@rust-lang\").unwrap();\n-    assert!(h == ~\"\");\n+    assert_eq!(h, ~\"\");\n     let (_, h, _, _) = get_authority(~\"rust-lang.org\").unwrap();\n-    assert!(h == ~\"\");\n+    assert_eq!(h, ~\"\");\n }\n \n #[test]\n fn test_get_path() {\n     let (p, r) = get_path(\"/something+%20orother\", true).unwrap();\n-    assert!(p == ~\"/something+ orother\");\n-    assert!(r == ~\"\");\n+    assert_eq!(p, ~\"/something+ orother\");\n+    assert_eq!(r, ~\"\");\n     let (p, r) = get_path(\"test@email.com#fragment\", false).unwrap();\n-    assert!(p == ~\"test@email.com\");\n-    assert!(r == ~\"#fragment\");\n+    assert_eq!(p, ~\"test@email.com\");\n+    assert_eq!(r, ~\"#fragment\");\n     let (p, r) = get_path(~\"/gen/:addr=?q=v\", false).unwrap();\n-    assert!(p == ~\"/gen/:addr=\");\n-    assert!(r == ~\"?q=v\");\n+    assert_eq!(p, ~\"/gen/:addr=\");\n+    assert_eq!(r, ~\"?q=v\");\n \n     //failure cases\n     assert!(get_path(~\"something?q\", true).is_err());\n@@ -860,56 +860,56 @@ mod tests {\n     #[test]\n     fn test_full_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?s=v#something\";\n-        assert!(from_str(url).unwrap().to_str() == url);\n+        assert_eq!(from_str(url).unwrap().to_str(), url);\n     }\n \n     #[test]\n     fn test_userless_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org/doc?s=v#something\";\n-        assert!(from_str(url).unwrap().to_str() == url);\n+        assert_eq!(from_str(url).unwrap().to_str(), url);\n     }\n \n     #[test]\n     fn test_queryless_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc#something\";\n-        assert!(from_str(url).unwrap().to_str() == url);\n+        assert_eq!(from_str(url).unwrap().to_str(), url);\n     }\n \n     #[test]\n     fn test_empty_query_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?#something\";\n         let should_be = ~\"http://user:pass@rust-lang.org/doc#something\";\n-        assert!(from_str(url).unwrap().to_str() == should_be);\n+        assert_eq!(from_str(url).unwrap().to_str(), should_be);\n     }\n \n     #[test]\n     fn test_fragmentless_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?q=v\";\n-        assert!(from_str(url).unwrap().to_str() == url);\n+        assert_eq!(from_str(url).unwrap().to_str(), url);\n     }\n \n     #[test]\n     fn test_minimal_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org/doc\";\n-        assert!(from_str(url).unwrap().to_str() == url);\n+        assert_eq!(from_str(url).unwrap().to_str(), url);\n     }\n \n     #[test]\n     fn test_scheme_host_only_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org\";\n-        assert!(from_str(url).unwrap().to_str() == url);\n+        assert_eq!(from_str(url).unwrap().to_str(), url);\n     }\n \n     #[test]\n     fn test_pathless_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org?q=v#something\";\n-        assert!(from_str(url).unwrap().to_str() == url);\n+        assert_eq!(from_str(url).unwrap().to_str(), url);\n     }\n \n     #[test]\n     fn test_scheme_host_fragment_only_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org#something\";\n-        assert!(from_str(url).unwrap().to_str() == url);\n+        assert_eq!(from_str(url).unwrap().to_str(), url);\n     }\n \n     #[test]\n@@ -923,134 +923,134 @@ mod tests {\n     #[test]\n     fn test_url_without_authority() {\n         let url = ~\"mailto:test@email.com\";\n-        assert!(from_str(url).unwrap().to_str() == url);\n+        assert_eq!(from_str(url).unwrap().to_str(), url);\n     }\n \n     #[test]\n     fn test_encode() {\n-        assert!(encode(\"\") == ~\"\");\n-        assert!(encode(\"http://example.com\") == ~\"http://example.com\");\n-        assert!(encode(\"foo bar% baz\") == ~\"foo%20bar%25%20baz\");\n-        assert!(encode(\" \") == ~\"%20\");\n-        assert!(encode(\"!\") == ~\"!\");\n-        assert!(encode(\"\\\"\") == ~\"\\\"\");\n-        assert!(encode(\"#\") == ~\"#\");\n-        assert!(encode(\"$\") == ~\"$\");\n-        assert!(encode(\"%\") == ~\"%25\");\n-        assert!(encode(\"&\") == ~\"&\");\n-        assert!(encode(\"'\") == ~\"%27\");\n-        assert!(encode(\"(\") == ~\"(\");\n-        assert!(encode(\")\") == ~\")\");\n-        assert!(encode(\"*\") == ~\"*\");\n-        assert!(encode(\"+\") == ~\"+\");\n-        assert!(encode(\",\") == ~\",\");\n-        assert!(encode(\"/\") == ~\"/\");\n-        assert!(encode(\":\") == ~\":\");\n-        assert!(encode(\";\") == ~\";\");\n-        assert!(encode(\"=\") == ~\"=\");\n-        assert!(encode(\"?\") == ~\"?\");\n-        assert!(encode(\"@\") == ~\"@\");\n-        assert!(encode(\"[\") == ~\"[\");\n-        assert!(encode(\"]\") == ~\"]\");\n+        assert_eq!(encode(\"\"), ~\"\");\n+        assert_eq!(encode(\"http://example.com\"), ~\"http://example.com\");\n+        assert_eq!(encode(\"foo bar% baz\"), ~\"foo%20bar%25%20baz\");\n+        assert_eq!(encode(\" \"), ~\"%20\");\n+        assert_eq!(encode(\"!\"), ~\"!\");\n+        assert_eq!(encode(\"\\\"\"), ~\"\\\"\");\n+        assert_eq!(encode(\"#\"), ~\"#\");\n+        assert_eq!(encode(\"$\"), ~\"$\");\n+        assert_eq!(encode(\"%\"), ~\"%25\");\n+        assert_eq!(encode(\"&\"), ~\"&\");\n+        assert_eq!(encode(\"'\"), ~\"%27\");\n+        assert_eq!(encode(\"(\"), ~\"(\");\n+        assert_eq!(encode(\")\"), ~\")\");\n+        assert_eq!(encode(\"*\"), ~\"*\");\n+        assert_eq!(encode(\"+\"), ~\"+\");\n+        assert_eq!(encode(\",\"), ~\",\");\n+        assert_eq!(encode(\"/\"), ~\"/\");\n+        assert_eq!(encode(\":\"), ~\":\");\n+        assert_eq!(encode(\";\"), ~\";\");\n+        assert_eq!(encode(\"=\"), ~\"=\");\n+        assert_eq!(encode(\"?\"), ~\"?\");\n+        assert_eq!(encode(\"@\"), ~\"@\");\n+        assert_eq!(encode(\"[\"), ~\"[\");\n+        assert_eq!(encode(\"]\"), ~\"]\");\n     }\n \n     #[test]\n     fn test_encode_component() {\n-        assert!(encode_component(\"\") == ~\"\");\n+        assert_eq!(encode_component(\"\"), ~\"\");\n         assert!(encode_component(\"http://example.com\") ==\n             ~\"http%3A%2F%2Fexample.com\");\n         assert!(encode_component(\"foo bar% baz\") ==\n             ~\"foo%20bar%25%20baz\");\n-        assert!(encode_component(\" \") == ~\"%20\");\n-        assert!(encode_component(\"!\") == ~\"%21\");\n-        assert!(encode_component(\"#\") == ~\"%23\");\n-        assert!(encode_component(\"$\") == ~\"%24\");\n-        assert!(encode_component(\"%\") == ~\"%25\");\n-        assert!(encode_component(\"&\") == ~\"%26\");\n-        assert!(encode_component(\"'\") == ~\"%27\");\n-        assert!(encode_component(\"(\") == ~\"%28\");\n-        assert!(encode_component(\")\") == ~\"%29\");\n-        assert!(encode_component(\"*\") == ~\"%2A\");\n-        assert!(encode_component(\"+\") == ~\"%2B\");\n-        assert!(encode_component(\",\") == ~\"%2C\");\n-        assert!(encode_component(\"/\") == ~\"%2F\");\n-        assert!(encode_component(\":\") == ~\"%3A\");\n-        assert!(encode_component(\";\") == ~\"%3B\");\n-        assert!(encode_component(\"=\") == ~\"%3D\");\n-        assert!(encode_component(\"?\") == ~\"%3F\");\n-        assert!(encode_component(\"@\") == ~\"%40\");\n-        assert!(encode_component(\"[\") == ~\"%5B\");\n-        assert!(encode_component(\"]\") == ~\"%5D\");\n+        assert_eq!(encode_component(\" \"), ~\"%20\");\n+        assert_eq!(encode_component(\"!\"), ~\"%21\");\n+        assert_eq!(encode_component(\"#\"), ~\"%23\");\n+        assert_eq!(encode_component(\"$\"), ~\"%24\");\n+        assert_eq!(encode_component(\"%\"), ~\"%25\");\n+        assert_eq!(encode_component(\"&\"), ~\"%26\");\n+        assert_eq!(encode_component(\"'\"), ~\"%27\");\n+        assert_eq!(encode_component(\"(\"), ~\"%28\");\n+        assert_eq!(encode_component(\")\"), ~\"%29\");\n+        assert_eq!(encode_component(\"*\"), ~\"%2A\");\n+        assert_eq!(encode_component(\"+\"), ~\"%2B\");\n+        assert_eq!(encode_component(\",\"), ~\"%2C\");\n+        assert_eq!(encode_component(\"/\"), ~\"%2F\");\n+        assert_eq!(encode_component(\":\"), ~\"%3A\");\n+        assert_eq!(encode_component(\";\"), ~\"%3B\");\n+        assert_eq!(encode_component(\"=\"), ~\"%3D\");\n+        assert_eq!(encode_component(\"?\"), ~\"%3F\");\n+        assert_eq!(encode_component(\"@\"), ~\"%40\");\n+        assert_eq!(encode_component(\"[\"), ~\"%5B\");\n+        assert_eq!(encode_component(\"]\"), ~\"%5D\");\n     }\n \n     #[test]\n     fn test_decode() {\n-        assert!(decode(\"\") == ~\"\");\n-        assert!(decode(\"abc/def 123\") == ~\"abc/def 123\");\n-        assert!(decode(\"abc%2Fdef%20123\") == ~\"abc%2Fdef 123\");\n-        assert!(decode(\"%20\") == ~\" \");\n-        assert!(decode(\"%21\") == ~\"%21\");\n-        assert!(decode(\"%22\") == ~\"%22\");\n-        assert!(decode(\"%23\") == ~\"%23\");\n-        assert!(decode(\"%24\") == ~\"%24\");\n-        assert!(decode(\"%25\") == ~\"%\");\n-        assert!(decode(\"%26\") == ~\"%26\");\n-        assert!(decode(\"%27\") == ~\"'\");\n-        assert!(decode(\"%28\") == ~\"%28\");\n-        assert!(decode(\"%29\") == ~\"%29\");\n-        assert!(decode(\"%2A\") == ~\"%2A\");\n-        assert!(decode(\"%2B\") == ~\"%2B\");\n-        assert!(decode(\"%2C\") == ~\"%2C\");\n-        assert!(decode(\"%2F\") == ~\"%2F\");\n-        assert!(decode(\"%3A\") == ~\"%3A\");\n-        assert!(decode(\"%3B\") == ~\"%3B\");\n-        assert!(decode(\"%3D\") == ~\"%3D\");\n-        assert!(decode(\"%3F\") == ~\"%3F\");\n-        assert!(decode(\"%40\") == ~\"%40\");\n-        assert!(decode(\"%5B\") == ~\"%5B\");\n-        assert!(decode(\"%5D\") == ~\"%5D\");\n+        assert_eq!(decode(\"\"), ~\"\");\n+        assert_eq!(decode(\"abc/def 123\"), ~\"abc/def 123\");\n+        assert_eq!(decode(\"abc%2Fdef%20123\"), ~\"abc%2Fdef 123\");\n+        assert_eq!(decode(\"%20\"), ~\" \");\n+        assert_eq!(decode(\"%21\"), ~\"%21\");\n+        assert_eq!(decode(\"%22\"), ~\"%22\");\n+        assert_eq!(decode(\"%23\"), ~\"%23\");\n+        assert_eq!(decode(\"%24\"), ~\"%24\");\n+        assert_eq!(decode(\"%25\"), ~\"%\");\n+        assert_eq!(decode(\"%26\"), ~\"%26\");\n+        assert_eq!(decode(\"%27\"), ~\"'\");\n+        assert_eq!(decode(\"%28\"), ~\"%28\");\n+        assert_eq!(decode(\"%29\"), ~\"%29\");\n+        assert_eq!(decode(\"%2A\"), ~\"%2A\");\n+        assert_eq!(decode(\"%2B\"), ~\"%2B\");\n+        assert_eq!(decode(\"%2C\"), ~\"%2C\");\n+        assert_eq!(decode(\"%2F\"), ~\"%2F\");\n+        assert_eq!(decode(\"%3A\"), ~\"%3A\");\n+        assert_eq!(decode(\"%3B\"), ~\"%3B\");\n+        assert_eq!(decode(\"%3D\"), ~\"%3D\");\n+        assert_eq!(decode(\"%3F\"), ~\"%3F\");\n+        assert_eq!(decode(\"%40\"), ~\"%40\");\n+        assert_eq!(decode(\"%5B\"), ~\"%5B\");\n+        assert_eq!(decode(\"%5D\"), ~\"%5D\");\n     }\n \n     #[test]\n     fn test_decode_component() {\n-        assert!(decode_component(\"\") == ~\"\");\n-        assert!(decode_component(\"abc/def 123\") == ~\"abc/def 123\");\n-        assert!(decode_component(\"abc%2Fdef%20123\") == ~\"abc/def 123\");\n-        assert!(decode_component(\"%20\") == ~\" \");\n-        assert!(decode_component(\"%21\") == ~\"!\");\n-        assert!(decode_component(\"%22\") == ~\"\\\"\");\n-        assert!(decode_component(\"%23\") == ~\"#\");\n-        assert!(decode_component(\"%24\") == ~\"$\");\n-        assert!(decode_component(\"%25\") == ~\"%\");\n-        assert!(decode_component(\"%26\") == ~\"&\");\n-        assert!(decode_component(\"%27\") == ~\"'\");\n-        assert!(decode_component(\"%28\") == ~\"(\");\n-        assert!(decode_component(\"%29\") == ~\")\");\n-        assert!(decode_component(\"%2A\") == ~\"*\");\n-        assert!(decode_component(\"%2B\") == ~\"+\");\n-        assert!(decode_component(\"%2C\") == ~\",\");\n-        assert!(decode_component(\"%2F\") == ~\"/\");\n-        assert!(decode_component(\"%3A\") == ~\":\");\n-        assert!(decode_component(\"%3B\") == ~\";\");\n-        assert!(decode_component(\"%3D\") == ~\"=\");\n-        assert!(decode_component(\"%3F\") == ~\"?\");\n-        assert!(decode_component(\"%40\") == ~\"@\");\n-        assert!(decode_component(\"%5B\") == ~\"[\");\n-        assert!(decode_component(\"%5D\") == ~\"]\");\n+        assert_eq!(decode_component(\"\"), ~\"\");\n+        assert_eq!(decode_component(\"abc/def 123\"), ~\"abc/def 123\");\n+        assert_eq!(decode_component(\"abc%2Fdef%20123\"), ~\"abc/def 123\");\n+        assert_eq!(decode_component(\"%20\"), ~\" \");\n+        assert_eq!(decode_component(\"%21\"), ~\"!\");\n+        assert_eq!(decode_component(\"%22\"), ~\"\\\"\");\n+        assert_eq!(decode_component(\"%23\"), ~\"#\");\n+        assert_eq!(decode_component(\"%24\"), ~\"$\");\n+        assert_eq!(decode_component(\"%25\"), ~\"%\");\n+        assert_eq!(decode_component(\"%26\"), ~\"&\");\n+        assert_eq!(decode_component(\"%27\"), ~\"'\");\n+        assert_eq!(decode_component(\"%28\"), ~\"(\");\n+        assert_eq!(decode_component(\"%29\"), ~\")\");\n+        assert_eq!(decode_component(\"%2A\"), ~\"*\");\n+        assert_eq!(decode_component(\"%2B\"), ~\"+\");\n+        assert_eq!(decode_component(\"%2C\"), ~\",\");\n+        assert_eq!(decode_component(\"%2F\"), ~\"/\");\n+        assert_eq!(decode_component(\"%3A\"), ~\":\");\n+        assert_eq!(decode_component(\"%3B\"), ~\";\");\n+        assert_eq!(decode_component(\"%3D\"), ~\"=\");\n+        assert_eq!(decode_component(\"%3F\"), ~\"?\");\n+        assert_eq!(decode_component(\"%40\"), ~\"@\");\n+        assert_eq!(decode_component(\"%5B\"), ~\"[\");\n+        assert_eq!(decode_component(\"%5D\"), ~\"]\");\n     }\n \n     #[test]\n     fn test_encode_form_urlencoded() {\n         let mut m = HashMap::new();\n-        assert!(encode_form_urlencoded(&m) == ~\"\");\n+        assert_eq!(encode_form_urlencoded(&m), ~\"\");\n \n         m.insert(~\"\", ~[]);\n         m.insert(~\"foo\", ~[]);\n-        assert!(encode_form_urlencoded(&m) == ~\"\");\n+        assert_eq!(encode_form_urlencoded(&m), ~\"\");\n \n         let mut m = HashMap::new();\n         m.insert(~\"foo\", ~[~\"bar\", ~\"123\"]);\n-        assert!(encode_form_urlencoded(&m) == ~\"foo=bar&foo=123\");\n+        assert_eq!(encode_form_urlencoded(&m), ~\"foo=bar&foo=123\");\n \n         let mut m = HashMap::new();\n         m.insert(~\"foo bar\", ~[~\"abc\", ~\"12 = 34\"]);\n@@ -1063,13 +1063,13 @@ mod tests {\n         // FIXME #4449: Commented out because this causes an ICE, but only\n         // on FreeBSD\n         /*\n-        assert!(decode_form_urlencoded(~[]).len() == 0);\n+        assert_eq!(decode_form_urlencoded(~[]).len(), 0);\n \n         let s = str::to_bytes(\"a=1&foo+bar=abc&foo+bar=12+%3D+34\");\n         let form = decode_form_urlencoded(s);\n-        assert!(form.len() == 2);\n-        assert!(form.get_ref(&~\"a\") == &~[~\"1\"]);\n-        assert!(form.get_ref(&~\"foo bar\") == &~[~\"abc\", ~\"12 = 34\"]);\n+        assert_eq!(form.len(), 2);\n+        assert_eq!(form.get_ref(&~\"a\"), &~[~\"1\"]);\n+        assert_eq!(form.get_ref(&~\"foo bar\"), &~[~\"abc\", ~\"12 = 34\"]);\n         */\n     }\n }"}, {"sha": "21685b03c077d659f144e213aa89d214d63d1e78", "filename": "src/libstd/num/bigint.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fbigint.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -238,7 +238,7 @@ impl Sub<BigUint, BigUint> for BigUint {\n             lo\n         };\n \n-        assert!(borrow == 0);     // <=> assert!((self >= other));\n+        assert_eq!(borrow, 0);     // <=> assert!((self >= other));\n         return BigUint::new(diff);\n     }\n }\n@@ -1170,7 +1170,7 @@ mod biguint_tests {\n                 if i == j {\n                     assert_eq!(ni.cmp(nj), Equal);\n                     assert_eq!(nj.cmp(ni), Equal);\n-                    assert!(ni == nj);\n+                    assert_eq!(ni, nj);\n                     assert!(!(ni != nj));\n                     assert!(ni <= nj);\n                     assert!(ni >= nj);\n@@ -1200,7 +1200,7 @@ mod biguint_tests {\n     #[test]\n     fn test_shl() {\n         fn check(v: ~[BigDigit], shift: uint, ans: ~[BigDigit]) {\n-            assert!(BigUint::new(v) << shift == BigUint::new(ans));\n+            assert_eq!(BigUint::new(v) << shift, BigUint::new(ans));\n         }\n \n         check(~[], 3, ~[]);\n@@ -1245,7 +1245,7 @@ mod biguint_tests {\n     #[ignore(cfg(target_arch = \"mips\"))]\n     fn test_shr() {\n         fn check(v: ~[BigDigit], shift: uint, ans: ~[BigDigit]) {\n-            assert!(BigUint::new(v) >> shift == BigUint::new(ans));\n+            assert_eq!(BigUint::new(v) >> shift, BigUint::new(ans));\n         }\n \n         check(~[], 3, ~[]);\n@@ -1298,9 +1298,9 @@ mod biguint_tests {\n         check(~[ 0,  1], ((uint::max_value >> BigDigit::bits) + 1) as int);\n         check(~[-1, -1 >> 1], int::max_value);\n \n-        assert!(BigUint::new(~[0, -1]).to_int() == int::max_value);\n-        assert!(BigUint::new(~[0, 0, 1]).to_int() == int::max_value);\n-        assert!(BigUint::new(~[0, 0, -1]).to_int() == int::max_value);\n+        assert_eq!(BigUint::new(~[0, -1]).to_int(), int::max_value);\n+        assert_eq!(BigUint::new(~[0, 0, 1]).to_int(), int::max_value);\n+        assert_eq!(BigUint::new(~[0, 0, -1]).to_int(), int::max_value);\n     }\n \n     #[test]\n@@ -1318,8 +1318,8 @@ mod biguint_tests {\n         check(~[ 0, -1], uint::max_value << BigDigit::bits);\n         check(~[-1, -1], uint::max_value);\n \n-        assert!(BigUint::new(~[0, 0, 1]).to_uint()  == uint::max_value);\n-        assert!(BigUint::new(~[0, 0, -1]).to_uint() == uint::max_value);\n+        assert_eq!(BigUint::new(~[0, 0, 1]).to_uint(), uint::max_value);\n+        assert_eq!(BigUint::new(~[0, 0, -1]).to_uint(), uint::max_value);\n     }\n \n     static sum_triples: &'static [(&'static [BigDigit],\n@@ -1433,10 +1433,10 @@ mod biguint_tests {\n             let c = BigUint::from_slice(cVec);\n \n             if !a.is_zero() {\n-                assert!(c.div_rem(&a) == (b.clone(), Zero::zero()));\n+                assert_eq!(c.div_rem(&a), (b.clone(), Zero::zero()));\n             }\n             if !b.is_zero() {\n-                assert!(c.div_rem(&b) == (a.clone(), Zero::zero()));\n+                assert_eq!(c.div_rem(&b), (a.clone(), Zero::zero()));\n             }\n         }\n \n@@ -1560,7 +1560,7 @@ mod biguint_tests {\n             let &(n, rs) = num_pair;\n             for rs.each |str_pair| {\n                 let &(radix, str) = str_pair;\n-                assert!(n.to_str_radix(radix) == str);\n+                assert_eq!(n.to_str_radix(radix), str);\n             }\n         }\n     }\n@@ -1597,7 +1597,7 @@ mod biguint_tests {\n             let ans = match FromStrRadix::from_str_radix(s, 10) {\n                 Some(x) => x, None => fail!()\n             };\n-            assert!(n == ans);\n+            assert_eq!(n, ans);\n         }\n \n         check(3, \"6\");\n@@ -1618,7 +1618,7 @@ mod bigint_tests {\n         fn check(inp_s: Sign, inp_n: uint, ans_s: Sign, ans_n: uint) {\n             let inp = BigInt::from_biguint(inp_s, BigUint::from_uint(inp_n));\n             let ans = BigInt { sign: ans_s, data: BigUint::from_uint(ans_n)};\n-            assert!(inp == ans);\n+            assert_eq!(inp, ans);\n         }\n         check(Plus, 1, Plus, 1);\n         check(Plus, 0, Zero, 0);\n@@ -1640,7 +1640,7 @@ mod bigint_tests {\n                 if i == j {\n                     assert_eq!(ni.cmp(nj), Equal);\n                     assert_eq!(nj.cmp(ni), Equal);\n-                    assert!(ni == nj);\n+                    assert_eq!(ni, nj);\n                     assert!(!(ni != nj));\n                     assert!(ni <= nj);\n                     assert!(ni >= nj);\n@@ -1751,7 +1751,7 @@ mod bigint_tests {\n             assert!(c + (-b) == a);\n             assert!(a + (-c) == (-b));\n             assert!(b + (-c) == (-a));\n-            assert!((-a) + (-b) == (-c));\n+            assert!((-a) + (-b) == (-c))\n             assert!(a + (-a) == Zero::zero());\n         }\n     }\n@@ -1766,8 +1766,8 @@ mod bigint_tests {\n \n             assert!(c - a == b);\n             assert!(c - b == a);\n-            assert!((-b) - a == (-c));\n-            assert!((-a) - b == (-c));\n+            assert!((-b) - a == (-c))\n+            assert!((-a) - b == (-c))\n             assert!(b - (-a) == c);\n             assert!(a - (-b) == c);\n             assert!((-c) - (-a) == (-b));\n@@ -1845,7 +1845,7 @@ mod bigint_tests {\n         fn check_sub(a: &BigInt, b: &BigInt, ans_d: &BigInt, ans_m: &BigInt) {\n             let (d, m) = a.div_mod_floor(b);\n             if !m.is_zero() {\n-                assert!(m.sign == b.sign);\n+                assert_eq!(m.sign, b.sign);\n             }\n             assert!(m.abs() <= b.abs());\n             assert!(*a == b * d + m);\n@@ -1896,7 +1896,7 @@ mod bigint_tests {\n         fn check_sub(a: &BigInt, b: &BigInt, ans_q: &BigInt, ans_r: &BigInt) {\n             let (q, r) = a.div_rem(b);\n             if !r.is_zero() {\n-                assert!(r.sign == a.sign);\n+                assert_eq!(r.sign, a.sign);\n             }\n             assert!(r.abs() <= b.abs());\n             assert!(*a == b * q + r);\n@@ -1999,7 +1999,7 @@ mod bigint_tests {\n     fn test_from_str_radix() {\n         fn check(s: &str, ans: Option<int>) {\n             let ans = ans.map(|&n| IntConvertible::from_int::<BigInt>(n));\n-            assert!(FromStrRadix::from_str_radix(s, 10) == ans);\n+            assert_eq!(FromStrRadix::from_str_radix(s, 10), ans);\n         }\n         check(\"10\", Some(10));\n         check(\"1\", Some(1));\n@@ -2016,6 +2016,6 @@ mod bigint_tests {\n             BigInt::new(Minus, ~[1, 1, 1]));\n         assert!(-BigInt::new(Minus, ~[1, 1, 1]) ==\n             BigInt::new(Plus,  ~[1, 1, 1]));\n-        assert!(-Zero::zero::<BigInt>() == Zero::zero::<BigInt>());\n+        assert_eq!(-Zero::zero::<BigInt>(), Zero::zero::<BigInt>());\n     }\n }"}, {"sha": "e766d2d3bf0907bb0401ba5ec0da38bee016f641", "filename": "src/libstd/par.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -59,7 +59,7 @@ fn map_slices<A:Copy + Owned,B:Copy + Owned>(\n                         let slice : &[A] =\n                             cast::transmute(slice);\n                         info!(\"slice: %?\", (base, slice.len(), end - base));\n-                        assert!(slice.len() == end - base);\n+                        assert_eq!(slice.len(), end - base);\n                         f(base, slice)\n                     }\n                 };\n@@ -70,7 +70,7 @@ fn map_slices<A:Copy + Owned,B:Copy + Owned>(\n         info!(\"tasks spawned\");\n \n         info!(\"num_tasks: %?\", (num_tasks, futures.len()));\n-        assert!((num_tasks == futures.len()));\n+        assert_eq!(num_tasks, futures.len());\n \n         let r = do vec::map_consume(futures) |ys| {\n             let mut ys = ys;\n@@ -106,7 +106,7 @@ pub fn mapi<A:Copy + Owned,B:Copy + Owned>(\n     });\n     let r = vec::concat(slices);\n     info!(\"%?\", (r.len(), xs.len()));\n-    assert!((r.len() == xs.len()));\n+    assert_eq!(r.len(), xs.len());\n     r\n }\n "}, {"sha": "b54fc81aac11c7fdd2e0377f305e74a9fb5e304e", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -196,87 +196,87 @@ mod tests {\n         let mut sorted = merge_sort(data, le);\n         let mut heap = from_vec(data);\n         while !heap.is_empty() {\n-            assert!(heap.top() == sorted.last());\n-            assert!(heap.pop() == sorted.pop());\n+            assert_eq!(heap.top(), sorted.last());\n+            assert_eq!(heap.pop(), sorted.pop());\n         }\n     }\n \n     #[test]\n     fn test_push() {\n         let mut heap = from_vec(~[2, 4, 9]);\n-        assert!(heap.len() == 3);\n+        assert_eq!(heap.len(), 3);\n         assert!(*heap.top() == 9);\n         heap.push(11);\n-        assert!(heap.len() == 4);\n+        assert_eq!(heap.len(), 4);\n         assert!(*heap.top() == 11);\n         heap.push(5);\n-        assert!(heap.len() == 5);\n+        assert_eq!(heap.len(), 5);\n         assert!(*heap.top() == 11);\n         heap.push(27);\n-        assert!(heap.len() == 6);\n+        assert_eq!(heap.len(), 6);\n         assert!(*heap.top() == 27);\n         heap.push(3);\n-        assert!(heap.len() == 7);\n+        assert_eq!(heap.len(), 7);\n         assert!(*heap.top() == 27);\n         heap.push(103);\n-        assert!(heap.len() == 8);\n+        assert_eq!(heap.len(), 8);\n         assert!(*heap.top() == 103);\n     }\n \n     #[test]\n     fn test_push_unique() {\n         let mut heap = from_vec(~[~2, ~4, ~9]);\n-        assert!(heap.len() == 3);\n+        assert_eq!(heap.len(), 3);\n         assert!(*heap.top() == ~9);\n         heap.push(~11);\n-        assert!(heap.len() == 4);\n+        assert_eq!(heap.len(), 4);\n         assert!(*heap.top() == ~11);\n         heap.push(~5);\n-        assert!(heap.len() == 5);\n+        assert_eq!(heap.len(), 5);\n         assert!(*heap.top() == ~11);\n         heap.push(~27);\n-        assert!(heap.len() == 6);\n+        assert_eq!(heap.len(), 6);\n         assert!(*heap.top() == ~27);\n         heap.push(~3);\n-        assert!(heap.len() == 7);\n+        assert_eq!(heap.len(), 7);\n         assert!(*heap.top() == ~27);\n         heap.push(~103);\n-        assert!(heap.len() == 8);\n+        assert_eq!(heap.len(), 8);\n         assert!(*heap.top() == ~103);\n     }\n \n     #[test]\n     fn test_push_pop() {\n         let mut heap = from_vec(~[5, 5, 2, 1, 3]);\n-        assert!(heap.len() == 5);\n-        assert!(heap.push_pop(6) == 6);\n-        assert!(heap.len() == 5);\n-        assert!(heap.push_pop(0) == 5);\n-        assert!(heap.len() == 5);\n-        assert!(heap.push_pop(4) == 5);\n-        assert!(heap.len() == 5);\n-        assert!(heap.push_pop(1) == 4);\n-        assert!(heap.len() == 5);\n+        assert_eq!(heap.len(), 5);\n+        assert_eq!(heap.push_pop(6), 6);\n+        assert_eq!(heap.len(), 5);\n+        assert_eq!(heap.push_pop(0), 5);\n+        assert_eq!(heap.len(), 5);\n+        assert_eq!(heap.push_pop(4), 5);\n+        assert_eq!(heap.len(), 5);\n+        assert_eq!(heap.push_pop(1), 4);\n+        assert_eq!(heap.len(), 5);\n     }\n \n     #[test]\n     fn test_replace() {\n         let mut heap = from_vec(~[5, 5, 2, 1, 3]);\n-        assert!(heap.len() == 5);\n-        assert!(heap.replace(6) == 5);\n-        assert!(heap.len() == 5);\n-        assert!(heap.replace(0) == 6);\n-        assert!(heap.len() == 5);\n-        assert!(heap.replace(4) == 5);\n-        assert!(heap.len() == 5);\n-        assert!(heap.replace(1) == 4);\n-        assert!(heap.len() == 5);\n+        assert_eq!(heap.len(), 5);\n+        assert_eq!(heap.replace(6), 5);\n+        assert_eq!(heap.len(), 5);\n+        assert_eq!(heap.replace(0), 6);\n+        assert_eq!(heap.len(), 5);\n+        assert_eq!(heap.replace(4), 5);\n+        assert_eq!(heap.len(), 5);\n+        assert_eq!(heap.replace(1), 4);\n+        assert_eq!(heap.len(), 5);\n     }\n \n     fn check_to_vec(data: ~[int]) {\n         let heap = from_vec(copy data);\n-        assert!(merge_sort((copy heap).to_vec(), le) == merge_sort(data, le));\n-        assert!(heap.to_sorted_vec() == merge_sort(data, le));\n+        assert_eq!(merge_sort((copy heap).to_vec(), le), merge_sort(data, le));\n+        assert_eq!(heap.to_sorted_vec(), merge_sort(data, le));\n     }\n \n     #[test]"}, {"sha": "cc1492ba4489e40ef82d8f15a225e51f11815a2e", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -218,7 +218,7 @@ pub impl<T> RcMut<T> {\n     #[inline]\n     fn with_mut_borrow<U>(&self, f: &fn(&mut T) -> U) -> U {\n         unsafe {\n-            assert!((*self.ptr).borrow == Nothing);\n+            assert_eq!((*self.ptr).borrow, Nothing);\n             (*self.ptr).borrow = Mutable;\n             let res = f(&mut (*self.ptr).value);\n             (*self.ptr).borrow = Nothing;"}, {"sha": "925f79b66c9b2a3c222bd015a734c222915e7a6d", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -1281,16 +1281,16 @@ mod tests {\n \n     #[test]\n     fn trivial() {\n-        assert!(char_len(empty()) == 0u);\n-        assert!(byte_len(empty()) == 0u);\n+        assert_eq!(char_len(empty()), 0u);\n+        assert_eq!(byte_len(empty()), 0u);\n     }\n \n     #[test]\n     fn of_string1() {\n         let sample = @~\"0123456789ABCDE\";\n         let r      = of_str(sample);\n \n-        assert!(char_len(r) == str::char_len(*sample));\n+        assert_eq!(char_len(r), str::char_len(*sample));\n         assert!(rope_to_string(r) == *sample);\n     }\n \n@@ -1352,7 +1352,7 @@ mod tests {\n             }\n         }\n \n-        assert!(len == str::char_len(*sample));\n+        assert_eq!(len, str::char_len(*sample));\n     }\n \n     #[test]\n@@ -1375,7 +1375,7 @@ mod tests {\n \n         assert!(eq(r1, r2));\n         let r3 = bal(r2);\n-        assert!(char_len(r1) == char_len(r3));\n+        assert_eq!(char_len(r1), char_len(r3));\n \n         assert!(eq(r1, r3));\n     }"}, {"sha": "09855c9334e58808ca124984af507da869381c07", "filename": "src/libstd/semver.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsemver.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -239,16 +239,16 @@ pub fn parse(s: &str) -> Option<Version> {\n \n #[test]\n fn test_parse() {\n-    assert!(parse(\"\") == None);\n-    assert!(parse(\"  \") == None);\n-    assert!(parse(\"1\") == None);\n-    assert!(parse(\"1.2\") == None);\n-    assert!(parse(\"1.2\") == None);\n-    assert!(parse(\"1\") == None);\n-    assert!(parse(\"1.2\") == None);\n-    assert!(parse(\"1.2.3-\") == None);\n-    assert!(parse(\"a.b.c\") == None);\n-    assert!(parse(\"1.2.3 abc\") == None);\n+    assert_eq!(parse(\"\"), None);\n+    assert_eq!(parse(\"  \"), None);\n+    assert_eq!(parse(\"1\"), None);\n+    assert_eq!(parse(\"1.2\"), None);\n+    assert_eq!(parse(\"1.2\"), None);\n+    assert_eq!(parse(\"1\"), None);\n+    assert_eq!(parse(\"1.2\"), None);\n+    assert_eq!(parse(\"1.2.3-\"), None);\n+    assert_eq!(parse(\"a.b.c\"), None);\n+    assert_eq!(parse(\"1.2.3 abc\"), None);\n \n     assert!(parse(\"1.2.3\") == Some(Version {\n         major: 1u,\n@@ -320,8 +320,8 @@ fn test_parse() {\n \n #[test]\n fn test_eq() {\n-    assert!(parse(\"1.2.3\")        == parse(\"1.2.3\"));\n-    assert!(parse(\"1.2.3-alpha1\") == parse(\"1.2.3-alpha1\"));\n+    assert_eq!(parse(\"1.2.3\"), parse(\"1.2.3\"));\n+    assert_eq!(parse(\"1.2.3-alpha1\"), parse(\"1.2.3-alpha1\"));\n }\n \n #[test]"}, {"sha": "c270f46751fcd94b7897a1a663294117242e96c6", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -500,7 +500,7 @@ impl<S:Encoder,T0:Encodable<S>,T1:Encodable<S>> Encodable<S> for (T0, T1) {\n impl<D:Decoder,T0:Decodable<D>,T1:Decodable<D>> Decodable<D> for (T0, T1) {\n     fn decode(d: &mut D) -> (T0, T1) {\n         do d.read_seq |d, len| {\n-            assert!(len == 2);\n+            assert_eq!(len, 2);\n             (\n                 d.read_seq_elt(0, |d| Decodable::decode(d)),\n                 d.read_seq_elt(1, |d| Decodable::decode(d))\n@@ -536,7 +536,7 @@ impl<\n > Decodable<D> for (T0, T1, T2) {\n     fn decode(d: &mut D) -> (T0, T1, T2) {\n         do d.read_seq |d, len| {\n-            assert!(len == 3);\n+            assert_eq!(len, 3);\n             (\n                 d.read_seq_elt(0, |d| Decodable::decode(d)),\n                 d.read_seq_elt(1, |d| Decodable::decode(d)),\n@@ -576,7 +576,7 @@ impl<\n > Decodable<D> for (T0, T1, T2, T3) {\n     fn decode(d: &mut D) -> (T0, T1, T2, T3) {\n         do d.read_seq |d, len| {\n-            assert!(len == 4);\n+            assert_eq!(len, 4);\n             (\n                 d.read_seq_elt(0, |d| Decodable::decode(d)),\n                 d.read_seq_elt(1, |d| Decodable::decode(d)),\n@@ -620,7 +620,7 @@ impl<\n > Decodable<D> for (T0, T1, T2, T3, T4) {\n     fn decode(d: &mut D) -> (T0, T1, T2, T3, T4) {\n         do d.read_seq |d, len| {\n-            assert!(len == 5);\n+            assert_eq!(len, 5);\n             (\n                 d.read_seq_elt(0, |d| Decodable::decode(d)),\n                 d.read_seq_elt(1, |d| Decodable::decode(d)),"}, {"sha": "bb3be8a55ea3b9aa164605d337cc23ecfed9b648", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -90,8 +90,8 @@ pub fn sha1() -> @Sha1 {\n         }\n     }\n     fn process_msg_block(st: &mut Sha1State) {\n-        assert!(st.h.len() == digest_buf_len);\n-        assert!(vec::uniq_len(st.work_buf) == work_buf_len);\n+        assert_eq!(st.h.len(), digest_buf_len);\n+        assert_eq!(vec::uniq_len(st.work_buf), work_buf_len);\n         let mut t: int; // Loop counter\n         let w = st.work_buf;\n \n@@ -192,7 +192,7 @@ pub fn sha1() -> @Sha1 {\n      * can be assumed that the message digest has been computed.\n      */\n     fn pad_msg(st: &mut Sha1State) {\n-        assert!((vec::len((*st).msg_block) == msg_block_len));\n+        assert_eq!(vec::len((*st).msg_block), msg_block_len);\n \n         /*\n          * Check to see if the current message block is too small to hold\n@@ -230,7 +230,7 @@ pub fn sha1() -> @Sha1 {\n \n     impl Sha1 for Sha1State {\n         fn reset(&mut self) {\n-            assert!(self.h.len() == digest_buf_len);\n+            assert_eq!(self.h.len(), digest_buf_len);\n             self.len_low = 0u32;\n             self.len_high = 0u32;\n             self.msg_block_idx = 0u;\n@@ -365,13 +365,13 @@ mod tests {\n         ];\n         let tests = fips_180_1_tests + wikipedia_tests;\n         fn check_vec_eq(v0: ~[u8], v1: ~[u8]) {\n-            assert!((vec::len::<u8>(v0) == vec::len::<u8>(v1)));\n+            assert_eq!(vec::len::<u8>(v0), vec::len::<u8>(v1));\n             let len = vec::len::<u8>(v0);\n             let mut i = 0u;\n             while i < len {\n                 let a = v0[i];\n                 let b = v1[i];\n-                assert!((a == b));\n+                assert_eq!(a, b);\n                 i += 1u;\n             }\n         }\n@@ -384,8 +384,8 @@ mod tests {\n             check_vec_eq(copy t.output, out);\n \n             let out_str = sh.result_str();\n-            assert!((out_str.len() == 40));\n-            assert!((out_str == t.output_str));\n+            assert_eq!(out_str.len(), 40);\n+            assert!(out_str == t.output_str);\n \n             sh.reset();\n         }\n@@ -405,8 +405,8 @@ mod tests {\n             check_vec_eq(copy t.output, out);\n \n             let out_str = sh.result_str();\n-            assert!((out_str.len() == 40));\n-            assert!((out_str == t.output_str));\n+            assert_eq!(out_str.len(), 40);\n+            assert!(out_str == t.output_str);\n \n             sh.reset();\n         }"}, {"sha": "a336bd54a61aab8e48cfff9bb07e9b86bd893079", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -249,16 +249,16 @@ mod tests {\n     #[test]\n     fn test_len() {\n         let mut map = SmallIntMap::new();\n-        assert!(map.len() == 0);\n+        assert_eq!(map.len(), 0);\n         assert!(map.is_empty());\n         assert!(map.insert(5, 20));\n-        assert!(map.len() == 1);\n+        assert_eq!(map.len(), 1);\n         assert!(!map.is_empty());\n         assert!(map.insert(11, 12));\n-        assert!(map.len() == 2);\n+        assert_eq!(map.len(), 2);\n         assert!(!map.is_empty());\n         assert!(map.insert(14, 22));\n-        assert!(map.len() == 3);\n+        assert_eq!(map.len(), 3);\n         assert!(!map.is_empty());\n     }\n \n@@ -297,9 +297,9 @@ mod tests {\n         map.update_with_key(3, 2, addMoreToCount);\n \n         // check the total counts\n-        assert!(map.find(&3).get() == &10);\n-        assert!(map.find(&5).get() == &3);\n-        assert!(map.find(&9).get() == &1);\n+        assert_eq!(map.find(&3).get(), &10);\n+        assert_eq!(map.find(&5).get(), &3);\n+        assert_eq!(map.find(&9).get(), &1);\n \n         // sadly, no sevens were counted\n         assert!(map.find(&7).is_none());\n@@ -308,16 +308,16 @@ mod tests {\n     #[test]\n     fn test_swap() {\n         let mut m = SmallIntMap::new();\n-        assert!(m.swap(1, 2) == None);\n-        assert!(m.swap(1, 3) == Some(2));\n-        assert!(m.swap(1, 4) == Some(3));\n+        assert_eq!(m.swap(1, 2), None);\n+        assert_eq!(m.swap(1, 3), Some(2));\n+        assert_eq!(m.swap(1, 4), Some(3));\n     }\n \n     #[test]\n     fn test_pop() {\n         let mut m = SmallIntMap::new();\n         m.insert(1, 2);\n-        assert!(m.pop(&1) == Some(2));\n-        assert!(m.pop(&1) == None);\n+        assert_eq!(m.pop(&1), Some(2));\n+        assert_eq!(m.pop(&1), None);\n     }\n }"}, {"sha": "ca752a482981a92d9b867731dfdface70ca70a20", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -261,7 +261,7 @@ fn binarysort<T:Copy + Ord>(array: &mut [T], start: uint) {\n                 left = mid+1;\n             }\n         }\n-        assert!(left == right);\n+        assert_eq!(left, right);\n         let n = start-left;\n \n         shift_vec(array, left+1, left, n);\n@@ -357,7 +357,7 @@ fn gallop_left<T:Copy + Ord>(key: &T,\n             ofs = m;\n         }\n     }\n-    assert!(last_ofs == ofs);\n+    assert_eq!(last_ofs, ofs);\n     return ofs;\n }\n \n@@ -410,7 +410,7 @@ fn gallop_right<T:Copy + Ord>(key: &T,\n             ofs = m;\n         }\n     }\n-    assert!(last_ofs == ofs);\n+    assert_eq!(last_ofs, ofs);\n     return ofs;\n }\n \n@@ -449,7 +449,7 @@ impl<T:Copy + Ord> MergeState<T> {\n         let l2 = self.runs[n+1].len;\n \n         assert!(l1 > 0 && l2 > 0);\n-        assert!(b1 + l1 == b2);\n+        assert_eq!(b1 + l1, b2);\n \n         self.runs[n].len = l1 + l2;\n         if n == size-3 {\n@@ -583,7 +583,7 @@ impl<T:Copy + Ord> MergeState<T> {\n         } else if len1 == 0 {\n             fail!(\"Comparison violates its contract!\");\n         } else {\n-            assert!(len2 == 0);\n+            assert_eq!(len2, 0);\n             assert!(len1 > 1);\n             copy_vec(array, dest, tmp.slice(c1, c1+len1));\n         }\n@@ -705,7 +705,7 @@ impl<T:Copy + Ord> MergeState<T> {\n         } else if len2 == 0 {\n             fail!(\"Comparison violates its contract!\");\n         } else {\n-            assert!(len1 == 0);\n+            assert_eq!(len1, 0);\n             assert!(len2 != 0);\n             copy_vec(array, dest-(len2-1), tmp.slice(0, len2));\n         }\n@@ -818,7 +818,7 @@ mod test_qsort {\n         let mut i = 0u;\n         while i < len {\n             // debug!(v2[i]);\n-            assert!((v2[i] == v1[i]));\n+            assert_eq!(v2[i], v1[i]);\n             i += 1;\n         }\n     }\n@@ -863,7 +863,7 @@ mod test_qsort {\n         for pairs.each |p| {\n             let (a, b) = *p;\n             debug!(\"%d %d\", a, b);\n-            assert!((a == b));\n+            assert_eq!(a, b);\n         }\n     }\n }\n@@ -883,7 +883,7 @@ mod tests {\n         let mut i = 0u;\n         while i < len {\n             debug!(v3[i]);\n-            assert!((v3[i] == v2[i]));\n+            assert_eq!(v3[i], v2[i]);\n             i += 1;\n         }\n     }\n@@ -910,7 +910,7 @@ mod tests {\n         pub fn le(a: &int, b: &int) -> bool { *a <= *b }\n         let mut v1 = ~[3, 2, 1];\n         let v2 = merge_sort(v1, le);\n-        assert!(v2 == ~[1, 2, 3]);\n+        assert_eq!(v2, ~[1, 2, 3]);\n     }\n \n     #[test]\n@@ -932,7 +932,7 @@ mod tests {\n         let names2 = ~[\"Alex Andy\", \"Jack Brown\", \"joe bob\", \"Joe Bob\",\n                        \"JOE Bob\", \"JOE BOB\", \"Sally Mae\"];\n         let names3 = merge_sort(names1, ile);\n-        assert!(names3 == names2);\n+        assert_eq!(names3, names2);\n     }\n }\n \n@@ -964,7 +964,7 @@ mod test_tim_sort {\n         let mut i = 0u;\n         while i < len {\n             // debug!(v2[i]);\n-            assert!((v2[i] == v1[i]));\n+            assert_eq!(v2[i], v1[i]);\n             i += 1u;\n         }\n     }"}, {"sha": "cdef8e220ceed4fcab87732ab9fa7e573a3d0bbf", "filename": "src/libstd/sort_stage0.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fsort_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fsort_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort_stage0.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -261,7 +261,7 @@ fn binarysort<T:Copy + Ord>(array: &mut [T], start: uint) {\n                 left = mid+1;\n             }\n         }\n-        assert!(left == right);\n+        assert_eq!(left, right);\n         let n = start-left;\n \n         copy_vec(array, left+1, array, left, n);\n@@ -357,7 +357,7 @@ fn gallop_left<T:Copy + Ord>(key: &const T,\n             ofs = m;\n         }\n     }\n-    assert!(last_ofs == ofs);\n+    assert_eq!(last_ofs, ofs);\n     return ofs;\n }\n \n@@ -410,7 +410,7 @@ fn gallop_right<T:Copy + Ord>(key: &const T,\n             ofs = m;\n         }\n     }\n-    assert!(last_ofs == ofs);\n+    assert_eq!(last_ofs, ofs);\n     return ofs;\n }\n \n@@ -449,7 +449,7 @@ impl<T:Copy + Ord> MergeState<T> {\n         let l2 = self.runs[n+1].len;\n \n         assert!(l1 > 0 && l2 > 0);\n-        assert!(b1 + l1 == b2);\n+        assert_eq!(b1 + l1, b2);\n \n         self.runs[n].len = l1 + l2;\n         if n == size-3 {\n@@ -579,15 +579,15 @@ impl<T:Copy + Ord> MergeState<T> {\n         } else if len1 == 0 {\n             fail!(\"Comparison violates its contract!\");\n         } else {\n-            assert!(len2 == 0);\n+            assert_eq!(len2, 0);\n             assert!(len1 > 1);\n             copy_vec(array, dest, tmp, c1, len1);\n         }\n     }\n \n     fn merge_hi(&mut self, array: &mut [T], base1: uint, len1: uint,\n                 base2: uint, len2: uint) {\n-        assert!(len1 != 1 && len2 != 0 && base1 + len1 == base2);\n+        assert!(len1 != 1 && len2 != 0 && base1+len1 == base2);\n \n         let mut tmp = ~[];\n         for uint::range(base2, base2+len2) |i| {\n@@ -701,7 +701,7 @@ impl<T:Copy + Ord> MergeState<T> {\n         } else if len2 == 0 {\n             fail!(\"Comparison violates its contract!\");\n         } else {\n-            assert!(len1 == 0);\n+            assert_eq!(len1, 0);\n             assert!(len2 != 0);\n             copy_vec(array, dest-(len2-1), tmp, 0, len2);\n         }\n@@ -766,7 +766,7 @@ mod test_qsort3 {\n         let mut i = 0;\n         while i < len {\n             // debug!(v2[i]);\n-            assert!((v2[i] == v1[i]));\n+            assert_eq!(v2[i], v1[i]);\n             i += 1;\n         }\n     }\n@@ -811,7 +811,7 @@ mod test_qsort {\n         let mut i = 0u;\n         while i < len {\n             // debug!(v2[i]);\n-            assert!((v2[i] == v1[i]));\n+            assert_eq!(v2[i], v1[i]);\n             i += 1;\n         }\n     }\n@@ -856,7 +856,7 @@ mod test_qsort {\n         for pairs.each |p| {\n             let (a, b) = *p;\n             debug!(\"%d %d\", a, b);\n-            assert!((a == b));\n+            assert_eq!(a, b);\n         }\n     }\n }\n@@ -876,7 +876,7 @@ mod tests {\n         let mut i = 0u;\n         while i < len {\n             debug!(v3[i]);\n-            assert!((v3[i] == v2[i]));\n+            assert_eq!(v3[i], v2[i]);\n             i += 1;\n         }\n     }\n@@ -903,7 +903,7 @@ mod tests {\n         pub fn le(a: &int, b: &int) -> bool { *a <= *b }\n         let mut v1 = ~[3, 2, 1];\n         let v2 = merge_sort(v1, le);\n-        assert!(v2 == ~[1, 2, 3]);\n+        assert_eq!(v2, ~[1, 2, 3]);\n     }\n \n     #[test]\n@@ -925,7 +925,7 @@ mod tests {\n         let names2 = ~[\"Alex Andy\", \"Jack Brown\", \"joe bob\", \"Joe Bob\",\n                        \"JOE Bob\", \"JOE BOB\", \"Sally Mae\"];\n         let names3 = merge_sort(names1, ile);\n-        assert!(names3 == names2);\n+        assert_eq!(names3, names2);\n     }\n }\n \n@@ -955,7 +955,7 @@ mod test_tim_sort {\n         let mut i = 0u;\n         while i < len {\n             // debug!(v2[i]);\n-            assert!((v2[i] == v1[i]));\n+            assert_eq!(v2[i], v1[i]);\n             i += 1u;\n         }\n     }"}, {"sha": "002c6b2eca3ee02fb04819f81e202b9a4649ac4f", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -839,7 +839,7 @@ mod tests {\n             access_shared(sharedstate, m, 10);\n             let _ = p.recv();\n \n-            assert!(*sharedstate == 20);\n+            assert_eq!(*sharedstate, 20);\n         }\n \n         fn access_shared(sharedstate: &mut int, m: &Mutex, n: uint) {\n@@ -906,7 +906,7 @@ mod tests {\n         for ports.each |port| { let _ = port.recv(); }\n         do m.lock_cond |cond| {\n             let num_woken = cond.broadcast();\n-            assert!(num_woken == num_waiters);\n+            assert_eq!(num_woken, num_waiters);\n         }\n         // wait until all children wake up\n         for ports.each |port| { let _ = port.recv(); }\n@@ -1006,7 +1006,7 @@ mod tests {\n         for vec::each(p.recv()) |p| { p.recv(); } // wait on all its siblings\n         do m.lock_cond |cond| {\n             let woken = cond.broadcast();\n-            assert!(woken == 0);\n+            assert_eq!(woken, 0);\n         }\n         struct SendOnFailure {\n             c: comm::Chan<()>,\n@@ -1120,7 +1120,7 @@ mod tests {\n             access_shared(sharedstate, x, mode2, 10);\n             let _ = p.recv();\n \n-            assert!(*sharedstate == 20);\n+            assert_eq!(*sharedstate, 20);\n         }\n \n         fn access_shared(sharedstate: &mut int, x: &RWlock, mode: RWlockMode,\n@@ -1273,7 +1273,7 @@ mod tests {\n         for ports.each |port| { let _ = port.recv(); }\n         do lock_cond(x, dg2) |cond| {\n             let num_woken = cond.broadcast();\n-            assert!(num_woken == num_waiters);\n+            assert_eq!(num_woken, num_waiters);\n         }\n         // wait until all children wake up\n         for ports.each |port| { let _ = port.recv(); }"}, {"sha": "e9fd4e9a2b837d5f0927e945b85b31624ccce81a", "filename": "src/libstd/test.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -804,7 +804,7 @@ mod tests {\n         let ch = SharedChan::new(ch);\n         run_test(false, desc, ch);\n         let (_, res) = p.recv();\n-        assert!(res == TrIgnored);\n+        assert_eq!(res, TrIgnored);\n     }\n \n     #[test]\n@@ -823,7 +823,7 @@ mod tests {\n         let ch = SharedChan::new(ch);\n         run_test(false, desc, ch);\n         let (_, res) = p.recv();\n-        assert!(res == TrOk);\n+        assert_eq!(res, TrOk);\n     }\n \n     #[test]\n@@ -841,7 +841,7 @@ mod tests {\n         let ch = SharedChan::new(ch);\n         run_test(false, desc, ch);\n         let (_, res) = p.recv();\n-        assert!(res == TrFailed);\n+        assert_eq!(res, TrFailed);\n     }\n \n     #[test]\n@@ -901,9 +901,9 @@ mod tests {\n         ];\n         let filtered = filter_tests(&opts, tests);\n \n-        assert!(filtered.len() == 1);\n-        assert!((filtered[0].desc.name.to_str() == ~\"1\"));\n-        assert!((filtered[0].desc.ignore == false));\n+        assert_eq!(filtered.len(), 1);\n+        assert_eq!(filtered[0].desc.name.to_str(), ~\"1\");\n+        assert!(filtered[0].desc.ignore == false);\n     }\n \n     #[test]\n@@ -958,7 +958,7 @@ mod tests {\n         for pairs.each |p| {\n             match *p {\n                 (ref a, ref b) => {\n-                    assert!((*a == b.desc.name.to_str()));\n+                    assert!(*a == b.desc.name.to_str());\n                 }\n             }\n         }"}, {"sha": "9e6a45137a4a53eecf941c3502a5baefaa4e75d1", "filename": "src/libstd/time.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -952,8 +952,8 @@ mod tests {\n         let time = ::time::Timespec::new(1234567890, 54321);\n         let utc = at_utc(time);\n \n-        assert!(utc.to_timespec() == time);\n-        assert!(utc.to_local().to_timespec() == time);\n+        assert_eq!(utc.to_timespec(), time);\n+        assert_eq!(utc.to_local().to_timespec(), time);\n     }\n \n     fn test_conversions() {\n@@ -985,7 +985,7 @@ mod tests {\n             assert!(tm.tm_mon == 0_i32);\n             assert!(tm.tm_year == 0_i32);\n             assert!(tm.tm_wday == 0_i32);\n-            assert!(tm.tm_isdst== 0_i32);\n+            assert!(tm.tm_isdst == 0_i32);\n             assert!(tm.tm_gmtoff == 0_i32);\n             assert!(tm.tm_zone == ~\"\");\n             assert!(tm.tm_nsec == 0_i32);\n@@ -994,7 +994,7 @@ mod tests {\n         }\n \n         let format = ~\"%a %b %e %T %Y\";\n-        assert!(strptime(~\"\", format) == Err(~\"Invalid time\"));\n+        assert_eq!(strptime(~\"\", format), Err(~\"Invalid time\"));\n         assert!(strptime(~\"Fri Feb 13 15:31:30\", format)\n             == Err(~\"Invalid time\"));\n \n@@ -1140,8 +1140,8 @@ mod tests {\n \n         error!(\"test_ctime: %? %?\", utc.ctime(), local.ctime());\n \n-        assert!(utc.ctime()   == ~\"Fri Feb 13 23:31:30 2009\");\n-        assert!(local.ctime() == ~\"Fri Feb 13 15:31:30 2009\");\n+        assert_eq!(utc.ctime(), ~\"Fri Feb 13 23:31:30 2009\");\n+        assert_eq!(local.ctime(), ~\"Fri Feb 13 15:31:30 2009\");\n     }\n \n     fn test_strftime() {\n@@ -1152,53 +1152,53 @@ mod tests {\n         let utc = at_utc(time);\n         let local = at(time);\n \n-        assert!(local.strftime(~\"\") == ~\"\");\n-        assert!(local.strftime(~\"%A\") == ~\"Friday\");\n-        assert!(local.strftime(~\"%a\") == ~\"Fri\");\n-        assert!(local.strftime(~\"%B\") == ~\"February\");\n-        assert!(local.strftime(~\"%b\") == ~\"Feb\");\n-        assert!(local.strftime(~\"%C\") == ~\"20\");\n-        assert!(local.strftime(~\"%c\") == ~\"Fri Feb 13 15:31:30 2009\");\n-        assert!(local.strftime(~\"%D\") == ~\"02/13/09\");\n-        assert!(local.strftime(~\"%d\") == ~\"13\");\n-        assert!(local.strftime(~\"%e\") == ~\"13\");\n-        assert!(local.strftime(~\"%F\") == ~\"2009-02-13\");\n+        assert_eq!(local.strftime(~\"\"), ~\"\");\n+        assert_eq!(local.strftime(~\"%A\"), ~\"Friday\");\n+        assert_eq!(local.strftime(~\"%a\"), ~\"Fri\");\n+        assert_eq!(local.strftime(~\"%B\"), ~\"February\");\n+        assert_eq!(local.strftime(~\"%b\"), ~\"Feb\");\n+        assert_eq!(local.strftime(~\"%C\"), ~\"20\");\n+        assert_eq!(local.strftime(~\"%c\"), ~\"Fri Feb 13 15:31:30 2009\");\n+        assert_eq!(local.strftime(~\"%D\"), ~\"02/13/09\");\n+        assert_eq!(local.strftime(~\"%d\"), ~\"13\");\n+        assert_eq!(local.strftime(~\"%e\"), ~\"13\");\n+        assert_eq!(local.strftime(~\"%F\"), ~\"2009-02-13\");\n         // assert!(local.strftime(\"%G\") == \"2009\");\n         // assert!(local.strftime(\"%g\") == \"09\");\n-        assert!(local.strftime(~\"%H\") == ~\"15\");\n-        assert!(local.strftime(~\"%I\") == ~\"03\");\n-        assert!(local.strftime(~\"%j\") == ~\"044\");\n-        assert!(local.strftime(~\"%k\") == ~\"15\");\n-        assert!(local.strftime(~\"%l\") == ~\" 3\");\n-        assert!(local.strftime(~\"%M\") == ~\"31\");\n-        assert!(local.strftime(~\"%m\") == ~\"02\");\n-        assert!(local.strftime(~\"%n\") == ~\"\\n\");\n-        assert!(local.strftime(~\"%P\") == ~\"pm\");\n-        assert!(local.strftime(~\"%p\") == ~\"PM\");\n-        assert!(local.strftime(~\"%R\") == ~\"15:31\");\n-        assert!(local.strftime(~\"%r\") == ~\"03:31:30 PM\");\n-        assert!(local.strftime(~\"%S\") == ~\"30\");\n-        assert!(local.strftime(~\"%s\") == ~\"1234567890\");\n-        assert!(local.strftime(~\"%T\") == ~\"15:31:30\");\n-        assert!(local.strftime(~\"%t\") == ~\"\\t\");\n+        assert_eq!(local.strftime(~\"%H\"), ~\"15\");\n+        assert_eq!(local.strftime(~\"%I\"), ~\"03\");\n+        assert_eq!(local.strftime(~\"%j\"), ~\"044\");\n+        assert_eq!(local.strftime(~\"%k\"), ~\"15\");\n+        assert_eq!(local.strftime(~\"%l\"), ~\" 3\");\n+        assert_eq!(local.strftime(~\"%M\"), ~\"31\");\n+        assert_eq!(local.strftime(~\"%m\"), ~\"02\");\n+        assert_eq!(local.strftime(~\"%n\"), ~\"\\n\");\n+        assert_eq!(local.strftime(~\"%P\"), ~\"pm\");\n+        assert_eq!(local.strftime(~\"%p\"), ~\"PM\");\n+        assert_eq!(local.strftime(~\"%R\"), ~\"15:31\");\n+        assert_eq!(local.strftime(~\"%r\"), ~\"03:31:30 PM\");\n+        assert_eq!(local.strftime(~\"%S\"), ~\"30\");\n+        assert_eq!(local.strftime(~\"%s\"), ~\"1234567890\");\n+        assert_eq!(local.strftime(~\"%T\"), ~\"15:31:30\");\n+        assert_eq!(local.strftime(~\"%t\"), ~\"\\t\");\n         // assert!(local.strftime(\"%U\") == \"06\");\n-        assert!(local.strftime(~\"%u\") == ~\"5\");\n+        assert_eq!(local.strftime(~\"%u\"), ~\"5\");\n         // assert!(local.strftime(\"%V\") == \"07\");\n-        assert!(local.strftime(~\"%v\") == ~\"13-Feb-2009\");\n+        assert_eq!(local.strftime(~\"%v\"), ~\"13-Feb-2009\");\n         // assert!(local.strftime(\"%W\") == \"06\");\n-        assert!(local.strftime(~\"%w\") == ~\"5\");\n+        assert_eq!(local.strftime(~\"%w\"), ~\"5\");\n         // handle \"%X\"\n         // handle \"%x\"\n-        assert!(local.strftime(~\"%Y\") == ~\"2009\");\n-        assert!(local.strftime(~\"%y\") == ~\"09\");\n+        assert_eq!(local.strftime(~\"%Y\"), ~\"2009\");\n+        assert_eq!(local.strftime(~\"%y\"), ~\"09\");\n \n         // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n         let zone = local.strftime(~\"%Z\");\n         assert!(zone == ~\"PST\" || zone == ~\"Pacific Standard Time\");\n \n-        assert!(local.strftime(~\"%z\") == ~\"-0800\");\n-        assert!(local.strftime(~\"%%\") == ~\"%\");\n+        assert_eq!(local.strftime(~\"%z\"), ~\"-0800\");\n+        assert_eq!(local.strftime(~\"%%\"), ~\"%\");\n \n         // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n@@ -1207,14 +1207,14 @@ mod tests {\n         assert!(rfc822 == prefix + ~\"PST\" ||\n                      rfc822 == prefix + ~\"Pacific Standard Time\");\n \n-        assert!(local.ctime() == ~\"Fri Feb 13 15:31:30 2009\");\n-        assert!(local.rfc822z() == ~\"Fri, 13 Feb 2009 15:31:30 -0800\");\n-        assert!(local.rfc3339() == ~\"2009-02-13T15:31:30-08:00\");\n+        assert_eq!(local.ctime(), ~\"Fri Feb 13 15:31:30 2009\");\n+        assert_eq!(local.rfc822z(), ~\"Fri, 13 Feb 2009 15:31:30 -0800\");\n+        assert_eq!(local.rfc3339(), ~\"2009-02-13T15:31:30-08:00\");\n \n-        assert!(utc.ctime() == ~\"Fri Feb 13 23:31:30 2009\");\n-        assert!(utc.rfc822() == ~\"Fri, 13 Feb 2009 23:31:30 GMT\");\n-        assert!(utc.rfc822z() == ~\"Fri, 13 Feb 2009 23:31:30 -0000\");\n-        assert!(utc.rfc3339() == ~\"2009-02-13T23:31:30Z\");\n+        assert_eq!(utc.ctime(), ~\"Fri Feb 13 23:31:30 2009\");\n+        assert_eq!(utc.rfc822(), ~\"Fri, 13 Feb 2009 23:31:30 GMT\");\n+        assert_eq!(utc.rfc822z(), ~\"Fri, 13 Feb 2009 23:31:30 -0000\");\n+        assert_eq!(utc.rfc3339(), ~\"2009-02-13T23:31:30Z\");\n     }\n \n     fn test_timespec_eq_ord() {"}, {"sha": "7fea94a39a77e830e9367084959734daa6df08a8", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -256,7 +256,7 @@ mod test {\n \n             match recv_timeout(hl_loop, 10u, &test_po) {\n               Some(val) => {\n-                assert!(val == expected);\n+                assert_eq!(val, expected);\n                 successes += 1;\n               }\n               _ => failures += 1"}, {"sha": "e4026d7306ffe9caefc2943b315fac4c162827ed", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -920,7 +920,7 @@ mod test_treemap {\n         assert!(m.insert(1, 2));\n         assert!(m.insert(5, 3));\n         assert!(m.insert(9, 3));\n-        assert!(m.find(&2) == None);\n+        assert_eq!(m.find(&2), None);\n     }\n \n     #[test]\n@@ -942,7 +942,7 @@ mod test_treemap {\n         assert!(m.insert(5, 2));\n         assert!(m.insert(2, 9));\n         assert!(!m.insert(2, 11));\n-        assert!(m.find(&2).unwrap() == &11);\n+        assert_eq!(m.find(&2).unwrap(), &11);\n     }\n \n     #[test]\n@@ -971,13 +971,13 @@ mod test_treemap {\n         m.insert(copy k1, copy v1);\n         m.insert(copy k2, copy v2);\n \n-        assert!(m.find(&k2) == Some(&v2));\n-        assert!(m.find(&k1) == Some(&v1));\n+        assert_eq!(m.find(&k2), Some(&v2));\n+        assert_eq!(m.find(&k1), Some(&v1));\n     }\n \n     fn check_equal<K: Eq + TotalOrd, V: Eq>(ctrl: &[(K, V)],\n                                             map: &TreeMap<K, V>) {\n-        assert!(ctrl.is_empty() == map.is_empty());\n+        assert_eq!(ctrl.is_empty(), map.is_empty());\n         for ctrl.each |x| {\n             let &(k, v) = x;\n             assert!(map.find(&k).unwrap() == &v)\n@@ -1000,7 +1000,7 @@ mod test_treemap {\n                                   parent: &~TreeNode<K, V>) {\n         match *node {\n           Some(ref r) => {\n-            assert!(r.key.cmp(&parent.key) == Less);\n+            assert_eq!(r.key.cmp(&parent.key), Less);\n             assert!(r.level == parent.level - 1); // left is black\n             check_left(&r.left, r);\n             check_right(&r.right, r, false);\n@@ -1014,7 +1014,7 @@ mod test_treemap {\n                                    parent_red: bool) {\n         match *node {\n           Some(ref r) => {\n-            assert!(r.key.cmp(&parent.key) == Greater);\n+            assert_eq!(r.key.cmp(&parent.key), Greater);\n             let red = r.level == parent.level;\n             if parent_red { assert!(!red) } // no dual horizontal links\n             // Right red or black\n@@ -1072,19 +1072,19 @@ mod test_treemap {\n     fn test_len() {\n         let mut m = TreeMap::new();\n         assert!(m.insert(3, 6));\n-        assert!(m.len() == 1);\n+        assert_eq!(m.len(), 1);\n         assert!(m.insert(0, 0));\n-        assert!(m.len() == 2);\n+        assert_eq!(m.len(), 2);\n         assert!(m.insert(4, 8));\n-        assert!(m.len() == 3);\n+        assert_eq!(m.len(), 3);\n         assert!(m.remove(&3));\n-        assert!(m.len() == 2);\n+        assert_eq!(m.len(), 2);\n         assert!(!m.remove(&5));\n-        assert!(m.len() == 2);\n+        assert_eq!(m.len(), 2);\n         assert!(m.insert(2, 4));\n-        assert!(m.len() == 3);\n+        assert_eq!(m.len(), 3);\n         assert!(m.insert(1, 2));\n-        assert!(m.len() == 4);\n+        assert_eq!(m.len(), 4);\n     }\n \n     #[test]\n@@ -1099,8 +1099,8 @@ mod test_treemap {\n \n         let mut n = 0;\n         for m.each |k, v| {\n-            assert!(*k == n);\n-            assert!(*v == n * 2);\n+            assert_eq!(*k, n);\n+            assert_eq!(*v, n * 2);\n             n += 1;\n         }\n     }\n@@ -1117,8 +1117,8 @@ mod test_treemap {\n \n         let mut n = 4;\n         for m.each_reverse |k, v| {\n-            assert!(*k == n);\n-            assert!(*v == n * 2);\n+            assert_eq!(*k, n);\n+            assert_eq!(*v, n * 2);\n             n -= 1;\n         }\n     }\n@@ -1191,11 +1191,11 @@ mod test_treemap {\n         let m = m;\n         let mut a = m.iter();\n \n-        assert!(a.next().unwrap() == (&x1, &y1));\n-        assert!(a.next().unwrap() == (&x2, &y2));\n-        assert!(a.next().unwrap() == (&x3, &y3));\n-        assert!(a.next().unwrap() == (&x4, &y4));\n-        assert!(a.next().unwrap() == (&x5, &y5));\n+        assert_eq!(a.next().unwrap(), (&x1, &y1));\n+        assert_eq!(a.next().unwrap(), (&x2, &y2));\n+        assert_eq!(a.next().unwrap(), (&x3, &y3));\n+        assert_eq!(a.next().unwrap(), (&x4, &y4));\n+        assert_eq!(a.next().unwrap(), (&x5, &y5));\n \n         assert!(a.next().is_none());\n \n@@ -1206,7 +1206,7 @@ mod test_treemap {\n         let mut i = 0;\n \n         for b.advance |x| {\n-            assert!(expected[i] == x);\n+            assert_eq!(expected[i], x);\n             i += 1;\n \n             if i == 2 {\n@@ -1215,7 +1215,7 @@ mod test_treemap {\n         }\n \n         for b.advance |x| {\n-            assert!(expected[i] == x);\n+            assert_eq!(expected[i], x);\n             i += 1;\n         }\n     }\n@@ -1303,7 +1303,7 @@ mod test_set {\n \n         let mut n = 0;\n         for m.each |x| {\n-            assert!(*x == n);\n+            assert_eq!(*x, n);\n             n += 1\n         }\n     }\n@@ -1320,7 +1320,7 @@ mod test_set {\n \n         let mut n = 4;\n         for m.each_reverse |x| {\n-            assert!(*x == n);\n+            assert_eq!(*x, n);\n             n -= 1\n         }\n     }\n@@ -1335,10 +1335,10 @@ mod test_set {\n \n         let mut i = 0;\n         for f(&set_a, &set_b) |x| {\n-            assert!(*x == expected[i]);\n+            assert_eq!(*x, expected[i]);\n             i += 1;\n         }\n-        assert!(i == expected.len());\n+        assert_eq!(i, expected.len());\n     }\n \n     #[test]\n@@ -1421,10 +1421,10 @@ mod test_set {\n \n         // FIXME: #5801: this needs a type hint to compile...\n         let result: Option<(&uint, & &'static str)> = z.next();\n-        assert!(result.unwrap() == (&5u, & &\"bar\"));\n+        assert_eq!(result.unwrap(), (&5u, & &\"bar\"));\n \n         let result: Option<(&uint, & &'static str)> = z.next();\n-        assert!(result.unwrap() == (&11u, & &\"foo\"));\n+        assert_eq!(result.unwrap(), (&11u, & &\"foo\"));\n \n         let result: Option<(&uint, & &'static str)> = z.next();\n         assert!(result.is_none());\n@@ -1433,16 +1433,16 @@ mod test_set {\n     #[test]\n     fn test_swap() {\n         let mut m = TreeMap::new();\n-        assert!(m.swap(1, 2) == None);\n-        assert!(m.swap(1, 3) == Some(2));\n-        assert!(m.swap(1, 4) == Some(3));\n+        assert_eq!(m.swap(1, 2), None);\n+        assert_eq!(m.swap(1, 3), Some(2));\n+        assert_eq!(m.swap(1, 4), Some(3));\n     }\n \n     #[test]\n     fn test_pop() {\n         let mut m = TreeMap::new();\n         m.insert(1, 2);\n-        assert!(m.pop(&1) == Some(2));\n-        assert!(m.pop(&1) == None);\n+        assert_eq!(m.pop(&1), Some(2));\n+        assert_eq!(m.pop(&1), None);\n     }\n }"}, {"sha": "d1a95c5b9f764be7c94549c9eb69399d51b6b5aa", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -183,7 +183,7 @@ extern fn tear_down_walk_cb(handle: *libc::c_void, arg: *libc::c_void) {\n     // pretty much, if we still have an active handle and it is *not*\n     // the async handle that facilities global loop communication, we\n     // want to barf out and fail\n-    assert!(handle == arg);\n+    assert_eq!(handle, arg);\n }\n \n extern fn tear_down_close_cb(handle: *ll::uv_async_t) {"}, {"sha": "61921fbf090f233af7b0d98552525336e567b06b", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -319,7 +319,7 @@ pub impl FileMap {\n     fn next_line(&self, pos: BytePos) {\n         // the new charpos must be > the last one (or it's the first one).\n         let lines = &mut *self.lines;\n-        assert!((lines.len() == 0) || (lines[lines.len() - 1] < pos));\n+        assert!((lines.len() == 0) || (lines[lines.len() - 1] < pos))\n         lines.push(pos);\n     }\n \n@@ -458,7 +458,7 @@ pub impl CodeMap {\n     pub fn span_to_snippet(&self, sp: span) -> ~str {\n         let begin = self.lookup_byte_offset(sp.lo);\n         let end = self.lookup_byte_offset(sp.hi);\n-        assert!(begin.fm.start_pos == end.fm.start_pos);\n+        assert_eq!(begin.fm.start_pos, end.fm.start_pos);\n         return str::slice(*begin.fm.src,\n                           begin.pos.to_uint(), end.pos.to_uint()).to_owned();\n     }"}, {"sha": "fa52f3dde3d5456d7d66b9cc9d731960dfade22b", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -381,7 +381,7 @@ mod test {\n         i.intern(\"c\");\n         i.intern(\"d\");\n         i.intern(\"return\");\n-        assert!(i.get(ast::ident{repr:101,ctxt:0}) == @~\"b\");\n+        assert_eq!(i.get(ast::ident{repr:101,ctxt:0}), @~\"b\");\n         i\n     }\n "}, {"sha": "52495522613dd7772061670d27c9122df2e97696", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -111,7 +111,7 @@ pub fn tok_str(t: token) -> ~str {\n pub fn buf_str(toks: ~[token], szs: ~[int], left: uint, right: uint,\n                lim: uint) -> ~str {\n     let n = toks.len();\n-    assert!(n == szs.len());\n+    assert_eq!(n, szs.len());\n     let mut i = left;\n     let mut L = lim;\n     let mut s = ~\"[\";\n@@ -400,7 +400,7 @@ pub impl Printer {\n             match x {\n               BREAK(b) => self.left_total += b.blank_space,\n               STRING(_, len) => {\n-                assert!((len == L)); self.left_total += len;\n+                assert_eq!(len, L); self.left_total += len;\n               }\n               _ => ()\n             }\n@@ -526,7 +526,7 @@ pub impl Printer {\n           }\n           STRING(s, len) => {\n             debug!(\"print STRING(%s)\", *s);\n-            assert!((L == len));\n+            assert_eq!(L, len);\n             // assert!(L <= space);\n             self.space -= len;\n             self.print_str(*s);"}, {"sha": "b2db752af1179f288beb8722d893e0f35e801c86", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -2067,7 +2067,7 @@ pub fn maybe_print_comment(s: @ps, pos: BytePos) {\n pub fn print_comment(s: @ps, cmnt: &comments::cmnt) {\n     match cmnt.style {\n       comments::mixed => {\n-        assert!(cmnt.lines.len() == 1u);\n+        assert_eq!(cmnt.lines.len(), 1u);\n         zerobreak(s.s);\n         word(s.s, cmnt.lines[0]);\n         zerobreak(s.s);"}, {"sha": "0d951771d701444f58052003683481c56043b35d", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -35,7 +35,7 @@ fn ascending<M: Map<uint, uint>>(map: &mut M, n_keys: uint) {\n \n     do timed(\"search\") {\n         for uint::range(0, n_keys) |i| {\n-            assert!(map.find(&i).unwrap() == &(i + 1));\n+            assert_eq!(map.find(&i).unwrap(), &(i + 1));\n         }\n     }\n \n@@ -57,7 +57,7 @@ fn descending<M: Map<uint, uint>>(map: &mut M, n_keys: uint) {\n \n     do timed(\"search\") {\n         for uint::range_rev(n_keys, 0) |i| {\n-            assert!(map.find(&i).unwrap() == &(i + 1));\n+            assert_eq!(map.find(&i).unwrap(), &(i + 1));\n         }\n     }\n \n@@ -78,7 +78,7 @@ fn vector<M: Map<uint, uint>>(map: &mut M, n_keys: uint, dist: &[uint]) {\n \n     do timed(\"search\") {\n         for uint::range(0, n_keys) |i| {\n-            assert!(map.find(&dist[i]).unwrap() == &(i + 1));\n+            assert_eq!(map.find(&dist[i]).unwrap(), &(i + 1));\n         }\n     }\n "}, {"sha": "4be2cca0b48556c5eabec6e200c555b5950c734b", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -296,7 +296,7 @@ fn pbfs(graph: &arc::ARC<graph>, key: node_id) -> bfs_result {\n             };\n             result\n         };\n-        assert!((colors.len() == old_len));\n+        assert_eq!(colors.len(), old_len);\n     }\n \n     // Convert the results."}, {"sha": "d1be03e944ae1b4f50375519aec8a164d3141c0a", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -93,7 +93,7 @@ fn run(args: &[~str]) {\n     io::stdout().write_str(fmt!(\"Test took %? seconds\\n\", elapsed));\n     let thruput = ((size / workers * workers) as float) / (elapsed as float);\n     io::stdout().write_str(fmt!(\"Throughput=%f per sec\\n\", thruput));\n-    assert!(result == num_bytes * size);\n+    assert_eq!(result, num_bytes * size);\n }\n \n fn main() {"}, {"sha": "b72a38d4054bdc24e8734c99a8081dc36977cf50", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -90,7 +90,7 @@ fn run(args: &[~str]) {\n     io::stdout().write_str(fmt!(\"Test took %? seconds\\n\", elapsed));\n     let thruput = ((size / workers * workers) as float) / (elapsed as float);\n     io::stdout().write_str(fmt!(\"Throughput=%f per sec\\n\", thruput));\n-    assert!(result == num_bytes * size);\n+    assert_eq!(result, num_bytes * size);\n }\n \n fn main() {"}, {"sha": "31945310eb32b785f5404fc2809b4d7eec06e8ff", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -70,7 +70,7 @@ fn stress_task(id: int) {\n     let mut i = 0;\n     loop {\n         let n = 15;\n-        assert!((fib(n) == fib(n)));\n+        assert_eq!(fib(n), fib(n));\n         i += 1;\n         error!(\"%d: Completed %d iterations\", id, i);\n     }"}, {"sha": "7b8aca2694e80821088c66bef4fe628f3dca2edf", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -22,7 +22,7 @@ fn append_sequential(min: uint, max: uint, map: &mut SmallIntMap<uint>) {\n \n fn check_sequential(min: uint, max: uint, map: &SmallIntMap<uint>) {\n     for uint::range(min, max) |i| {\n-        assert!(*map.get(&i) == i + 22u);\n+        assert_eq!(*map.get(&i), i + 22u);\n     }\n }\n "}, {"sha": "4d8614b5eddb6c447ae92393773ac8d1d4856bcf", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -212,30 +212,30 @@ static default_solution: [[u8, ..9], ..9] = [\n \n #[test]\n fn colors_new_works() {\n-    assert!(*Colors::new(1) == 1022u16);\n-    assert!(*Colors::new(2) == 1020u16);\n-    assert!(*Colors::new(3) == 1016u16);\n-    assert!(*Colors::new(4) == 1008u16);\n-    assert!(*Colors::new(5) == 992u16);\n-    assert!(*Colors::new(6) == 960u16);\n-    assert!(*Colors::new(7) == 896u16);\n-    assert!(*Colors::new(8) == 768u16);\n-    assert!(*Colors::new(9) == 512u16);\n+    assert_eq!(*Colors::new(1), 1022u16);\n+    assert_eq!(*Colors::new(2), 1020u16);\n+    assert_eq!(*Colors::new(3), 1016u16);\n+    assert_eq!(*Colors::new(4), 1008u16);\n+    assert_eq!(*Colors::new(5), 992u16);\n+    assert_eq!(*Colors::new(6), 960u16);\n+    assert_eq!(*Colors::new(7), 896u16);\n+    assert_eq!(*Colors::new(8), 768u16);\n+    assert_eq!(*Colors::new(9), 512u16);\n }\n \n #[test]\n fn colors_next_works() {\n-    assert!(Colors(0).next() == 0u8);\n-    assert!(Colors(2).next() == 1u8);\n-    assert!(Colors(4).next() == 2u8);\n-    assert!(Colors(8).next() == 3u8);\n-    assert!(Colors(16).next() == 4u8);\n-    assert!(Colors(32).next() == 5u8);\n-    assert!(Colors(64).next() == 6u8);\n-    assert!(Colors(128).next() == 7u8);\n-    assert!(Colors(256).next() == 8u8);\n-    assert!(Colors(512).next() == 9u8);\n-    assert!(Colors(1024).next() == 0u8);\n+    assert_eq!(Colors(0).next(), 0u8);\n+    assert_eq!(Colors(2).next(), 1u8);\n+    assert_eq!(Colors(4).next(), 2u8);\n+    assert_eq!(Colors(8).next(), 3u8);\n+    assert_eq!(Colors(16).next(), 4u8);\n+    assert_eq!(Colors(32).next(), 5u8);\n+    assert_eq!(Colors(64).next(), 6u8);\n+    assert_eq!(Colors(128).next(), 7u8);\n+    assert_eq!(Colors(256).next(), 8u8);\n+    assert_eq!(Colors(512).next(), 9u8);\n+    assert_eq!(Colors(1024).next(), 0u8);\n }\n \n #[test]\n@@ -247,7 +247,7 @@ fn colors_remove_works() {\n     colors.remove(1);\n \n     // THEN\n-    assert!(colors.next() == 2u8);\n+    assert_eq!(colors.next(), 2u8);\n }\n \n #[test]"}, {"sha": "aacdf678bbfe5e0420cad4e9116152617442343a", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -54,7 +54,7 @@ fn spawn_supervised_blocking(myname: &str, f: ~fn()) {\n     builder.spawn(f);\n     error!(\"%s group waiting\", myname);\n     let x = res.unwrap().recv();\n-    assert!(x == task::Success);\n+    assert_eq!(x, task::Success);\n }\n \n fn main() {"}, {"sha": "e38c22004ed139ad568ed01f797f86966048157f", "filename": "src/test/compile-fail/autoderef-full-lval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -22,10 +22,10 @@ fn main() {\n     let b: clam = clam{x: @10, y: @20};\n     let z: int = a.x + b.y; //~ ERROR binary operation + cannot be applied to type `@int`\n     debug!(z);\n-    assert!((z == 21));\n+    assert_eq!(z, 21);\n     let forty: fish = fish{a: @40};\n     let two: fish = fish{a: @2};\n     let answer: int = forty.a + two.a;  //~ ERROR binary operation + cannot be applied to type `@int`\n     debug!(answer);\n-    assert!((answer == 42));\n+    assert_eq!(answer, 42);\n }"}, {"sha": "73a53d6cc988c9da33fa45db8ff4c4a6d1af734f", "filename": "src/test/compile-fail/block-arg-as-stmt-with-value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -19,5 +19,5 @@ fn compute1() -> float {\n fn main() {\n     let x = compute1();\n     debug!(x);\n-    assert!((x == -4f));\n+    assert_eq!(x, -4f);\n }"}, {"sha": "ae8779eafcc70627466671443b58e3ddb253c154", "filename": "src/test/compile-fail/borrowck-loan-blocks-mut-uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -16,8 +16,8 @@ fn box_imm() {\n     let mut v = ~3;\n     do borrow(v) |w| {\n         v = ~4; //~ ERROR cannot assign to `v` because it is borrowed\n-        assert!(*v == 3);\n-        assert!(*w == 4);\n+        assert_eq!(*v, 3);\n+        assert_eq!(*w, 4);\n     }\n }\n "}, {"sha": "4a34b85c3edfa059a5edc8dde906fc233d852ae5", "filename": "src/test/compile-fail/borrowck-ref-mut-of-imm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-mut-of-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-mut-of-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-mut-of-imm.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -16,5 +16,5 @@ fn destructure(x: Option<int>) -> int {\n }\n \n fn main() {\n-    assert!(destructure(Some(22)) == 22);\n+    assert_eq!(destructure(Some(22)), 22);\n }"}, {"sha": "4750f68d59b34454e9a438bd062246e562974ae4", "filename": "src/test/compile-fail/issue-1896-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -22,5 +22,5 @@ fn main () {\n \n     let myInt: uint = (aFn.theFn)();\n \n-    assert!(myInt == 10);\n+    assert_eq!(myInt, 10);\n }"}, {"sha": "3149db8a03f27f7f502f8a331c1293e82d7d1774", "filename": "src/test/compile-fail/issue-2467.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fissue-2467.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fissue-2467.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2467.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -12,5 +12,5 @@ enum test { thing = 3u } //~ ERROR mismatched types\n //~^ ERROR expected signed integer constant\n fn main() {\n     error!(thing as int);\n-    assert!((thing as int == 3));\n+    assert_eq!(thing as int, 3);\n }"}, {"sha": "fdaf1f562c8df3fe55b746665f0dfd0c2d1dd0af", "filename": "src/test/compile-fail/issue-2548.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -38,8 +38,8 @@ fn main() {\n \n         let mut v = ~[];\n         v = ~[(res)] + v; //~ instantiating a type parameter with an incompatible type `foo`, which does not fulfill `Copy`\n-        assert!((v.len() == 2));\n+        assert_eq!(v.len(), 2);\n     }\n \n-    assert!(*x == 1);\n+    assert_eq!(*x, 1);\n }"}, {"sha": "a9c26fc415ead5b7ff77030a9f1fa8c5cc85db5b", "filename": "src/test/compile-fail/issue-2969.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fissue-2969.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fissue-2969.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2969.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -15,5 +15,5 @@ fn main()\n    let mut x = [1, 2, 4];\n    let v : &int = &x[2];\n    x[2] = 6;\n-   assert!(*v == 6);\n+   assert_eq!(*v, 6);\n }"}, {"sha": "dc3717085ca57b1509263883f1b3ad374a2ca840", "filename": "src/test/compile-fail/kindck-owned-trait-scoped.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -30,7 +30,7 @@ fn to_foo<T:Copy>(t: T) {\n     let v = &3;\n     struct F<T> { f: T }\n     let x = @F {f:t} as @foo;\n-    assert!(x.foo(v) == 3);\n+    assert_eq!(x.foo(v), 3);\n }\n \n fn to_foo_2<T:Copy>(t: T) -> @foo {"}, {"sha": "9b16738e951f77da28d8161ce4d806efa47ab956", "filename": "src/test/compile-fail/mod_file_not_exist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fmod_file_not_exist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fmod_file_not_exist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmod_file_not_exist.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -11,5 +11,5 @@\n mod not_a_real_file; //~ ERROR not_a_real_file.rs\n \n fn main() {\n-    assert!(mod_file_aux::bar() == 10);\n+    assert_eq!(mod_file_aux::bar(), 10);\n }"}, {"sha": "ff330047c4e968d0f14f30c67c101e96892882a8", "filename": "src/test/compile-fail/mod_file_with_path_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fmod_file_with_path_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fmod_file_with_path_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmod_file_with_path_attr.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -12,5 +12,5 @@\n mod m; //~ ERROR not_a_real_file.rs\n \n fn main() {\n-    assert!(m::foo() == 10);\n+    assert_eq!(m::foo(), 10);\n }"}, {"sha": "4c206a949a2382587ca96d36148a1c71e1a1537f", "filename": "src/test/compile-fail/no-capture-arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -19,10 +19,10 @@ fn main() {\n \n     do task::spawn() {\n         let v = *arc::get(&arc_v);\n-        assert!(v[3] == 4);\n+        assert_eq!(v[3], 4);\n     };\n \n-    assert!((*arc::get(&arc_v))[2] == 3);\n+    assert_eq!((*arc::get(&arc_v))[2], 3);\n \n     info!(arc_v);\n }"}, {"sha": "46eaded4527a3c2d33bc95fa296c8d720a3b3b4f", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -17,7 +17,7 @@ fn main() {\n \n     do task::spawn() { //~ NOTE `arc_v` moved into closure environment here\n         let v = *arc::get(&arc_v);\n-        assert!(v[3] == 4);\n+        assert_eq!(v[3], 4);\n     };\n \n     assert!((*arc::get(&arc_v))[2] == 3); //~ ERROR use of moved value: `arc_v`"}, {"sha": "61300b92afd099de3c608e568ef2a59b63522b84", "filename": "src/test/compile-fail/regions-glb-free-free.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -37,5 +37,5 @@ mod argparse {\n fn main () {\n     let f : argparse::Flag = argparse::flag(~\"flag\", ~\"My flag\");\n     let updated_flag = f.set_desc(~\"My new flag\");\n-    assert!(updated_flag.desc == \"My new flag\");\n+    assert_eq!(updated_flag.desc, \"My new flag\");\n }"}, {"sha": "5710188ed9fe5e3c4a39dac7034dc925a22d0edb", "filename": "src/test/compile-fail/regions-infer-borrow-scope-too-big.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -19,7 +19,7 @@ fn x_coord<'r>(p: &'r point) -> &'r int {\n \n fn foo(p: @point) -> &int {\n     let xc = x_coord(p); //~ ERROR cannot root\n-    assert!(*xc == 3);\n+    assert_eq!(*xc, 3);\n     return xc;\n }\n "}, {"sha": "2ffd0796e30e7931ddc03d0a7eb65f3c12d082bc", "filename": "src/test/compile-fail/regions-infer-borrow-scope-within-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -19,7 +19,7 @@ fn foo(cond: &fn() -> bool, box: &fn() -> @int) {\n         // of this borrow is the fn body as a whole.\n         y = borrow(x); //~ ERROR cannot root\n \n-        assert!(*x == *y);\n+        assert_eq!(*x, *y);\n         if cond() { break; }\n     }\n     assert!(*y != 0);"}, {"sha": "ae697ad1181c344560ae25cffede7a2e94763641", "filename": "src/test/compile-fail/regions-trait-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -34,5 +34,5 @@ fn get_v(gc: @get_ctxt) -> uint {\n fn main() {\n     let ctxt = ctxt { v: 22u };\n     let hc = has_ctxt { c: &ctxt };\n-    assert!(get_v(@hc as @get_ctxt) == 22u);\n+    assert_eq!(get_v(@hc as @get_ctxt), 22u);\n }"}, {"sha": "8955a26de0b93c085014b1bea5ae070d1589fc9a", "filename": "src/test/compile-fail/regions-var-type-out-of-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fregions-var-type-out-of-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fregions-var-type-out-of-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-var-type-out-of-scope.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -15,7 +15,7 @@ fn foo(cond: bool) {\n \n     if cond {\n         x = &3; //~ ERROR borrowed value does not live long enough\n-        assert!((*x == 3));\n+        assert_eq!(*x, 3);\n     }\n }\n "}, {"sha": "5d0991024c4f6644aab80f8abba431ab97325d34", "filename": "src/test/compile-fail/vtable-res-trait-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -29,5 +29,5 @@ fn call_it<B:TraitB>(b: B)  -> int {\n \n fn main() {\n     let x = 3i;\n-    assert!(call_it(x) == 22);\n+    assert_eq!(call_it(x), 22);\n }"}, {"sha": "67059e07c899ded86bc80a925b41fcde2f5d137d", "filename": "src/test/pretty/record-trailing-comma.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fpretty%2Frecord-trailing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Fpretty%2Frecord-trailing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Frecord-trailing-comma.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -18,5 +18,5 @@ struct Thing {\n fn main() {\n     let sth = Thing{x: 0, y: 1,};\n     let sth2 = Thing{y: 9 , ..sth};\n-    assert!(sth.x + sth2.y == 9);\n+    assert_eq!(sth.x + sth2.y, 9);\n }"}, {"sha": "5ec2c093eebac8253d1f67954b6ef2c4dbce5b20", "filename": "src/test/run-fail/str-overrun.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fstr-overrun.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -15,5 +15,5 @@ fn main() {\n     let s: ~str = ~\"hello\";\n \n     // Bounds-check failure.\n-    assert!((s[5] == 0x0 as u8));\n+    assert_eq!(s[5], 0x0 as u8);\n }"}, {"sha": "a9761017c73f5e9b65f8cfb5650c8272fa965149", "filename": "src/test/run-fail/unwind-alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-fail%2Funwind-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-fail%2Funwind-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-alt.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -16,7 +16,7 @@ fn test_box() {\n fn test_str() {\n   let res = match false { true => { ~\"happy\" },\n      _ => fail!(\"non-exhaustive match failure\") };\n-  assert!(res == ~\"happy\");\n+  assert_eq!(res, ~\"happy\");\n }\n fn main() {\n     test_box();"}, {"sha": "411895a2ef0370514db4c68b017d796936c81eea", "filename": "src/test/run-fail/vec-overrun.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-overrun.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -14,8 +14,8 @@\n fn main() {\n     let v: ~[int] = ~[10];\n     let x: int = 0;\n-    assert!((v[x] == 10));\n+    assert_eq!(v[x], 10);\n     // Bounds-check failure.\n \n-    assert!((v[x + 2] == 20));\n+    assert_eq!(v[x + 2], 20);\n }"}, {"sha": "99ce79b3b6c0ca2c4278df1d2c704e9a2c17cf55", "filename": "src/test/run-fail/vec-underrun.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-fail%2Fvec-underrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-fail%2Fvec-underrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-underrun.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -14,8 +14,8 @@\n fn main() {\n     let v: ~[int] = ~[10, 20];\n     let x: int = 0;\n-    assert!((v[x] == 10));\n+    assert_eq!(v[x], 10);\n     // Bounds-check failure.\n \n-    assert!((v[x - 1] == 20));\n+    assert_eq!(v[x - 1], 20);\n }"}, {"sha": "53385e16759d14aecdeb43f28ceb8d441979e656", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -82,6 +82,6 @@ fn check_pp<T>(cx: fake_ext_ctxt,\n     stdout().write_line(s);\n     if expect != ~\"\" {\n         error!(\"expect: '%s', got: '%s'\", expect, s);\n-        assert!(s == expect);\n+        assert_eq!(s, expect);\n     }\n }"}, {"sha": "bf96d6cfab529b428385933727db35e2b51c49d5", "filename": "src/test/run-pass/alignment-gep-tup-like-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -20,6 +20,6 @@ fn f<A:Copy + 'static>(a: A, b: u16) -> @fn() -> (A, u16) {\n pub fn main() {\n     let (a, b) = f(22_u64, 44u16)();\n     debug!(\"a=%? b=%?\", a, b);\n-    assert!(a == 22u64);\n-    assert!(b == 44u16);\n+    assert_eq!(a, 22u64);\n+    assert_eq!(b, 44u16);\n }"}, {"sha": "6bf4e96bc053d9166f995caf00d5668b71f02b00", "filename": "src/test/run-pass/alignment-gep-tup-like-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -35,6 +35,6 @@ pub fn main() {\n     make_cycle(z);\n     let (a, b) = z();\n     debug!(\"a=%u b=%u\", *a as uint, b as uint);\n-    assert!(*a == x);\n-    assert!(b == y);\n+    assert_eq!(*a, x);\n+    assert_eq!(b, y);\n }"}, {"sha": "8d1e483bcd848cd3cc45d65a8b119e3c27b6aec1", "filename": "src/test/run-pass/alt-ref-binding-mut-option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Falt-ref-binding-mut-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Falt-ref-binding-mut-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-ref-binding-mut-option.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -14,5 +14,5 @@ pub fn main() {\n       None => {}\n       Some(ref mut p) => { *p += 1; }\n     }\n-    assert!(v == Some(23));\n+    assert_eq!(v, Some(23));\n }"}, {"sha": "266f7cdde11af0281836105808fcd27b6628c018", "filename": "src/test/run-pass/alt-ref-binding-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Falt-ref-binding-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Falt-ref-binding-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-ref-binding-mut.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -21,5 +21,5 @@ fn destructure(x: &mut Rec) {\n pub fn main() {\n     let mut v = Rec {f: 22};\n     destructure(&mut v);\n-    assert!(v.f == 23);\n+    assert_eq!(v.f, 23);\n }"}, {"sha": "0b613df18ee833668e2917cf859a94dee11b2dd0", "filename": "src/test/run-pass/alt-ref-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Falt-ref-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Falt-ref-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-ref-binding.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -16,5 +16,5 @@ fn destructure(x: Option<int>) -> int {\n }\n \n pub fn main() {\n-    assert!(destructure(Some(22)) == 22);\n+    assert_eq!(destructure(Some(22)), 22);\n }"}, {"sha": "8bbcc507f184fce31215cb47b2fb516c7f2dce60", "filename": "src/test/run-pass/alt-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Falt-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Falt-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-str.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -24,7 +24,7 @@ pub fn main() {\n     }\n \n     let x = match ~\"a\" { ~\"a\" => 1, ~\"b\" => 2, _ => fail!() };\n-    assert!((x == 1));\n+    assert_eq!(x, 1);\n \n     match ~\"a\" { ~\"a\" => { } ~\"b\" => { }, _ => fail!() }\n "}, {"sha": "9eeb12d9c45f2363f8475097bda1aff748cb50d2", "filename": "src/test/run-pass/alt-tag.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Falt-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Falt-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-tag.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -32,7 +32,7 @@ pub fn main() {\n     let gray: color = rgb(127, 127, 127);\n     let clear: color = rgba(50, 150, 250, 0);\n     let red: color = hsl(0, 255, 255);\n-    assert!((process(gray) == 127));\n-    assert!((process(clear) == 0));\n-    assert!((process(red) == 255));\n+    assert_eq!(process(gray), 127);\n+    assert_eq!(process(clear), 0);\n+    assert_eq!(process(red), 255);\n }"}, {"sha": "997cc1ee9ff9d8708281c297ff0cfd982c86ad3c", "filename": "src/test/run-pass/alt-unique-bind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Falt-unique-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Falt-unique-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-unique-bind.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -12,7 +12,7 @@ pub fn main() {\n     match ~100 {\n       ~x => {\n         debug!(\"%?\", x);\n-        assert!(x == 100);\n+        assert_eq!(x, 100);\n       }\n     }\n }"}, {"sha": "f46521f1d55171d36fa3e750973fd715653c5454", "filename": "src/test/run-pass/alt-with-ret-arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Falt-with-ret-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Falt-with-ret-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-with-ret-arm.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -16,6 +16,6 @@ pub fn main() {\n         None => return (),\n         Some(num) => num as u32\n     };\n-    assert!(f == 1234u32);\n+    assert_eq!(f, 1234u32);\n     error!(f)\n }"}, {"sha": "7e56edbedf629d34a69a6b044c4cf55a8a894bde", "filename": "src/test/run-pass/argument-passing.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fargument-passing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fargument-passing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fargument-passing.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -25,9 +25,9 @@ fn f2(a: int, f: &fn(int)) -> int { f(1); return a; }\n \n pub fn main() {\n     let mut a = X {x: 1}, b = 2, c = 3;\n-    assert!((f1(&mut a, &mut b, c) == 6));\n-    assert!((a.x == 0));\n-    assert!((b == 10));\n-    assert!((f2(a.x, |x| a.x = 50) == 0));\n-    assert!((a.x == 50));\n+    assert_eq!(f1(&mut a, &mut b, c), 6);\n+    assert_eq!(a.x, 0);\n+    assert_eq!(b, 10);\n+    assert_eq!(f2(a.x, |x| a.x = 50), 0);\n+    assert_eq!(a.x, 50);\n }"}, {"sha": "308a5c2721c3d3b874c50dfd0f72aed4a6e5b9a8", "filename": "src/test/run-pass/arith-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Farith-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Farith-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farith-0.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -13,5 +13,5 @@\n pub fn main() {\n     let a: int = 10;\n     debug!(a);\n-    assert!((a * (a - 1) == 90));\n+    assert_eq!(a * (a - 1), 90);\n }"}, {"sha": "a6321439db94304cf662a042f3904eff183138c3", "filename": "src/test/run-pass/arith-1.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Farith-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Farith-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farith-1.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -12,22 +12,22 @@\n \n pub fn main() {\n     let i32_a: int = 10;\n-    assert!((i32_a == 10));\n-    assert!((i32_a - 10 == 0));\n-    assert!((i32_a / 10 == 1));\n-    assert!((i32_a - 20 == -10));\n-    assert!((i32_a << 10 == 10240));\n-    assert!((i32_a << 16 == 655360));\n-    assert!((i32_a * 16 == 160));\n-    assert!((i32_a * i32_a * i32_a == 1000));\n-    assert!((i32_a * i32_a * i32_a * i32_a == 10000));\n-    assert!((i32_a * i32_a / i32_a * i32_a == 100));\n-    assert!((i32_a * (i32_a - 1) << 2 + i32_a == 368640));\n+    assert_eq!(i32_a, 10);\n+    assert_eq!(i32_a - 10, 0);\n+    assert_eq!(i32_a / 10, 1);\n+    assert_eq!(i32_a - 20, -10);\n+    assert_eq!(i32_a << 10, 10240);\n+    assert_eq!(i32_a << 16, 655360);\n+    assert_eq!(i32_a * 16, 160);\n+    assert_eq!(i32_a * i32_a * i32_a, 1000);\n+    assert_eq!(i32_a * i32_a * i32_a * i32_a, 10000);\n+    assert_eq!(i32_a * i32_a / i32_a * i32_a, 100);\n+    assert_eq!(i32_a * (i32_a - 1) << 2 + i32_a, 368640);\n     let i32_b: int = 0x10101010;\n-    assert!((i32_b + 1 - 1 == i32_b));\n-    assert!((i32_b << 1 == i32_b << 1));\n-    assert!((i32_b >> 1 == i32_b >> 1));\n-    assert!((i32_b & i32_b << 1 == 0));\n+    assert_eq!(i32_b + 1 - 1, i32_b);\n+    assert_eq!(i32_b << 1, i32_b << 1);\n+    assert_eq!(i32_b >> 1, i32_b >> 1);\n+    assert_eq!(i32_b & i32_b << 1, 0);\n     debug!(i32_b | i32_b << 1);\n-    assert!((i32_b | i32_b << 1 == 0x30303030));\n+    assert_eq!(i32_b | i32_b << 1, 0x30303030);\n }"}, {"sha": "0eb4e7ad92e784c6d147c4ada91061f9e691e750", "filename": "src/test/run-pass/arith-unsigned.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Farith-unsigned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Farith-unsigned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farith-unsigned.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -17,20 +17,20 @@ pub fn main() {\n     assert!((0u8 <= 255u8));\n     assert!((255u8 > 0u8));\n     assert!((255u8 >= 0u8));\n-    assert!((250u8 / 10u8 == 25u8));\n-    assert!((255u8 % 10u8 == 5u8));\n+    assert_eq!(250u8 / 10u8, 25u8);\n+    assert_eq!(255u8 % 10u8, 5u8);\n     assert!((0u16 < 60000u16));\n     assert!((0u16 <= 60000u16));\n     assert!((60000u16 > 0u16));\n     assert!((60000u16 >= 0u16));\n-    assert!((60000u16 / 10u16 == 6000u16));\n-    assert!((60005u16 % 10u16 == 5u16));\n+    assert_eq!(60000u16 / 10u16, 6000u16);\n+    assert_eq!(60005u16 % 10u16, 5u16);\n     assert!((0u32 < 4000000000u32));\n     assert!((0u32 <= 4000000000u32));\n     assert!((4000000000u32 > 0u32));\n     assert!((4000000000u32 >= 0u32));\n-    assert!((4000000000u32 / 10u32 == 400000000u32));\n-    assert!((4000000005u32 % 10u32 == 5u32));\n+    assert_eq!(4000000000u32 / 10u32, 400000000u32);\n+    assert_eq!(4000000005u32 % 10u32, 5u32);\n     // 64-bit numbers have some flakiness yet. Not tested\n \n }"}, {"sha": "5fe2aa6cc7c0eb7b3da129eac759356db5cc38b6", "filename": "src/test/run-pass/assign-assign.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fassign-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fassign-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassign-assign.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -12,21 +12,21 @@\n fn test_assign() {\n     let mut x: int;\n     let mut y: () = x = 10;\n-    assert!((x == 10));\n+    assert_eq!(x, 10);\n     let mut z = x = 11;\n-    assert!((x == 11));\n+    assert_eq!(x, 11);\n     z = x = 12;\n-    assert!((x == 12));\n+    assert_eq!(x, 12);\n }\n \n fn test_assign_op() {\n     let mut x: int = 0;\n     let mut y: () = x += 10;\n-    assert!((x == 10));\n+    assert_eq!(x, 10);\n     let mut z = x += 11;\n-    assert!((x == 21));\n+    assert_eq!(x, 21);\n     z = x += 12;\n-    assert!((x == 33));\n+    assert_eq!(x, 33);\n }\n \n pub fn main() { test_assign(); test_assign_op(); }"}, {"sha": "64e1e20e4ba2960e4c234bd394f2397d53c6e2f1", "filename": "src/test/run-pass/assignability-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-trait.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -39,15 +39,15 @@ pub fn main() {\n     // Call a method\n     for x.iterate() |y| { assert!(x[*y] == *y); }\n     // Call a parameterized function\n-    assert!(length(x.clone()) == x.len());\n+    assert_eq!(length(x.clone()), x.len());\n     // Call a parameterized function, with type arguments that require\n     // a borrow\n-    assert!(length::<int, &[int]>(x) == x.len());\n+    assert_eq!(length::<int, &[int]>(x), x.len());\n \n     // Now try it with a type that *needs* to be borrowed\n     let z = [0,1,2,3];\n     // Call a method\n     for z.iterate() |y| { assert!(z[*y] == *y); }\n     // Call a parameterized function\n-    assert!(length::<int, &[int]>(z) == z.len());\n+    assert_eq!(length::<int, &[int]>(z), z.len());\n }"}, {"sha": "dbcbb77efa39e91399451c9a32d980eae38a3d6d", "filename": "src/test/run-pass/auto-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-loop.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -13,5 +13,5 @@ pub fn main() {\n     for vec::each(~[1, 2, 3, 4, 5]) |x| {\n         sum += *x;\n     }\n-    assert!((sum == 15));\n+    assert_eq!(sum, 15);\n }"}, {"sha": "26ef339daf5627c3881b63151aa71c08f02a64d6", "filename": "src/test/run-pass/auto-ref-newtype.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fauto-ref-newtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fauto-ref-newtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-newtype.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -19,5 +19,5 @@ pub impl Foo {\n \n pub fn main() {\n     let m = Foo(3);\n-    assert!(m.len() == 3);\n+    assert_eq!(m.len(), 3);\n }"}, {"sha": "8e2b3b56736e2a1da329d3455583756c9c6025b7", "filename": "src/test/run-pass/auto-ref-sliceable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -22,5 +22,5 @@ pub fn main() {\n     let mut v = ~[1];\n     v.push_val(2);\n     v.push_val(3);\n-    assert!(v == ~[1, 2, 3]);\n+    assert_eq!(v, ~[1, 2, 3]);\n }"}, {"sha": "0788c74d07850df2e32bf51e123ff04cb0889372", "filename": "src/test/run-pass/autobind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fautobind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fautobind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautobind.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -13,7 +13,7 @@ fn f<T:Copy>(x: ~[T]) -> T { return x[0]; }\n fn g(act: &fn(~[int]) -> int) -> int { return act(~[1, 2, 3]); }\n \n pub fn main() {\n-    assert!((g(f) == 1));\n+    assert_eq!(g(f), 1);\n     let f1: &fn(~[~str]) -> ~str = f;\n-    assert!((f1(~[~\"x\", ~\"y\", ~\"z\"]) == ~\"x\"));\n+    assert_eq!(f1(~[~\"x\", ~\"y\", ~\"z\"]), ~\"x\");\n }"}, {"sha": "e3a19b23e91bf34ed25fcc646464ed12c1cf18bc", "filename": "src/test/run-pass/autoderef-method-newtype.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fautoderef-method-newtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fautoderef-method-newtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-newtype.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -20,5 +20,5 @@ struct foo(uint);\n \n pub fn main() {\n     let x = foo(3u);\n-    assert!(x.double() == 6u);\n+    assert_eq!(x.double(), 6u);\n }"}, {"sha": "9bc71517c1fb876463752e9b850141ab46a57fa3", "filename": "src/test/run-pass/autoderef-method-on-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -18,5 +18,5 @@ impl double for uint {\n \n pub fn main() {\n     let x = @(@3u as @double);\n-    assert!(x.double() == 6u);\n+    assert_eq!(x.double(), 6u);\n }"}, {"sha": "9cfdac0a330b0fe26c366c07b5d04d066202aef1", "filename": "src/test/run-pass/autoderef-method-priority.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fautoderef-method-priority.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fautoderef-method-priority.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-priority.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -25,5 +25,5 @@ impl double for @uint {\n \n pub fn main() {\n     let x = @3u;\n-    assert!(x.double() == 6u);\n+    assert_eq!(x.double(), 6u);\n }"}, {"sha": "299760289c2b3468a0c62a70863c725f1a47aba1", "filename": "src/test/run-pass/autoderef-method-twice-but-not-thrice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fautoderef-method-twice-but-not-thrice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fautoderef-method-twice-but-not-thrice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-twice-but-not-thrice.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -18,5 +18,5 @@ impl double for @uint {\n \n pub fn main() {\n     let x = @@@@@3u;\n-    assert!(x.double() == 6u);\n+    assert_eq!(x.double(), 6u);\n }"}, {"sha": "f93f0605269a443c70ea1df8613a75fc2104b16b", "filename": "src/test/run-pass/autoderef-method-twice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fautoderef-method-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fautoderef-method-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-twice.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -18,5 +18,5 @@ impl double for uint {\n \n pub fn main() {\n     let x = @@3u;\n-    assert!(x.double() == 6u);\n+    assert_eq!(x.double(), 6u);\n }"}, {"sha": "eb173e3d5f8ec2afa9928f3ec140b30b25bdadcc", "filename": "src/test/run-pass/autoderef-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fautoderef-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fautoderef-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -18,5 +18,5 @@ impl double for uint {\n \n pub fn main() {\n     let x = @3u;\n-    assert!(x.double() == 6u);\n+    assert_eq!(x.double(), 6u);\n }"}, {"sha": "cae3bff8043ea3958a32e71390bfae4e65705129", "filename": "src/test/run-pass/autoref-intermediate-types-issue-3585.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fautoref-intermediate-types-issue-3585.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fautoref-intermediate-types-issue-3585.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoref-intermediate-types-issue-3585.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -26,5 +26,5 @@ impl Foo for uint {\n \n pub fn main() {\n     let x = @3u;\n-    assert!(x.foo() == ~\"@3\");\n+    assert_eq!(x.foo(), ~\"@3\");\n }"}, {"sha": "96615b740b72bf1dc9d4237da25b07d6ab4e559d", "filename": "src/test/run-pass/big-literals.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fbig-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fbig-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbig-literals.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -11,11 +11,11 @@\n // except according to those terms.\n \n pub fn main() {\n-    assert!(0xffffffffu32 == (-1 as u32));\n-    assert!(4294967295u32 == (-1 as u32));\n-    assert!(0xffffffffffffffffu64 == (-1 as u64));\n-    assert!(18446744073709551615u64 == (-1 as u64));\n+    assert_eq!(0xffffffffu32, (-1 as u32));\n+    assert_eq!(4294967295u32, (-1 as u32));\n+    assert_eq!(0xffffffffffffffffu64, (-1 as u64));\n+    assert_eq!(18446744073709551615u64, (-1 as u64));\n \n-    assert!(-2147483648i32 - 1i32 == 2147483647i32);\n-    assert!(-9223372036854775808i64 - 1i64 == 9223372036854775807i64);\n+    assert_eq!(-2147483648i32 - 1i32, 2147483647i32);\n+    assert_eq!(-9223372036854775808i64 - 1i64, 9223372036854775807i64);\n }"}, {"sha": "78edf3e112e987622a4b82b08f2ff97d8c02cf09", "filename": "src/test/run-pass/binary-minus-without-space.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fbinary-minus-without-space.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fbinary-minus-without-space.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinary-minus-without-space.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -12,5 +12,5 @@\n \n pub fn main() {\n     match -1 { -1 => {}, _ => fail!(\"wat\") }\n-    assert!(1-1 == 0);\n+    assert_eq!(1-1, 0);\n }"}, {"sha": "9039730f11963f7eeb320c0a17f4eab3cbc3eb6b", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -11,7 +11,7 @@\n // Binop corner cases\n \n fn test_nil() {\n-    assert!((() == ()));\n+    assert_eq!((), ());\n     assert!((!(() != ())));\n     assert!((!(() < ())));\n     assert!((() <= ()));\n@@ -31,35 +31,35 @@ fn test_bool() {\n     assert!((!(false >= true)));\n \n     // Bools support bitwise binops\n-    assert!((false & false == false));\n-    assert!((true & false == false));\n-    assert!((true & true == true));\n-    assert!((false | false == false));\n-    assert!((true | false == true));\n-    assert!((true | true == true));\n-    assert!((false ^ false == false));\n-    assert!((true ^ false == true));\n-    assert!((true ^ true == false));\n+    assert_eq!(false & false, false);\n+    assert_eq!(true & false, false);\n+    assert_eq!(true & true, true);\n+    assert_eq!(false | false, false);\n+    assert_eq!(true | false, true);\n+    assert_eq!(true | true, true);\n+    assert_eq!(false ^ false, false);\n+    assert_eq!(true ^ false, true);\n+    assert_eq!(true ^ true, false);\n }\n \n fn test_char() {\n     let ch10 = 10 as char;\n     let ch4 = 4 as char;\n     let ch2 = 2 as char;\n-    assert!((ch10 + ch4 == 14 as char));\n-    assert!((ch10 - ch4 == 6 as char));\n-    assert!((ch10 * ch4 == 40 as char));\n-    assert!((ch10 / ch4 == ch2));\n-    assert!((ch10 % ch4 == ch2));\n-    assert!((ch10 >> ch2 == ch2));\n-    assert!((ch10 << ch4 == 160 as char));\n-    assert!((ch10 | ch4 == 14 as char));\n-    assert!((ch10 & ch2 == ch2));\n-    assert!((ch10 ^ ch2 == 8 as char));\n+    assert_eq!(ch10 + ch4, 14 as char);\n+    assert_eq!(ch10 - ch4, 6 as char);\n+    assert_eq!(ch10 * ch4, 40 as char);\n+    assert_eq!(ch10 / ch4, ch2);\n+    assert_eq!(ch10 % ch4, ch2);\n+    assert_eq!(ch10 >> ch2, ch2);\n+    assert_eq!(ch10 << ch4, 160 as char);\n+    assert_eq!(ch10 | ch4, 14 as char);\n+    assert_eq!(ch10 & ch2, ch2);\n+    assert_eq!(ch10 ^ ch2, 8 as char);\n }\n \n fn test_box() {\n-    assert!((@10 == @10));\n+    assert_eq!(@10, @10);\n }\n \n fn test_ptr() {\n@@ -68,7 +68,7 @@ fn test_ptr() {\n         let p2: *u8 = ::core::cast::transmute(0);\n         let p3: *u8 = ::core::cast::transmute(1);\n \n-        assert!(p1 == p2);\n+        assert_eq!(p1, p2);\n         assert!(p1 != p3);\n         assert!(p1 < p3);\n         assert!(p1 <= p3);\n@@ -110,10 +110,10 @@ fn test_class() {\n          (::core::cast::transmute::<*p, uint>(&q)),\n          (::core::cast::transmute::<*p, uint>(&r)));\n   }\n-  assert!((q == r));\n+  assert_eq!(q, r);\n   r.y = 17;\n   assert!((r.y != q.y));\n-  assert!((r.y == 17));\n+  assert_eq!(r.y, 17);\n   assert!((q != r));\n }\n "}, {"sha": "d3d1a1d12b269c878222763fbe10f661707e95dd", "filename": "src/test/run-pass/bitwise.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fbitwise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fbitwise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbitwise.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -13,12 +13,12 @@\n #[cfg(target_arch = \"x86\")]\n #[cfg(target_arch = \"arm\")]\n fn target() {\n-    assert!((-1000 as uint >> 3u == 536870787u));\n+    assert_eq!(-1000 as uint >> 3u, 536870787u);\n }\n \n #[cfg(target_arch = \"x86_64\")]\n fn target() {\n-    assert!((-1000 as uint >> 3u == 2305843009213693827u));\n+    assert_eq!(-1000 as uint >> 3u, 2305843009213693827u);\n }\n \n fn general() {\n@@ -29,14 +29,14 @@ fn general() {\n     a = a ^ b;\n     debug!(a);\n     debug!(b);\n-    assert!((b == 1));\n-    assert!((a == 2));\n-    assert!((!0xf0 & 0xff == 0xf));\n-    assert!((0xf0 | 0xf == 0xff));\n-    assert!((0xf << 4 == 0xf0));\n-    assert!((0xf0 >> 4 == 0xf));\n-    assert!((-16 >> 2 == -4));\n-    assert!((0b1010_1010 | 0b0101_0101 == 0xff));\n+    assert_eq!(b, 1);\n+    assert_eq!(a, 2);\n+    assert_eq!(!0xf0 & 0xff, 0xf);\n+    assert_eq!(0xf0 | 0xf, 0xff);\n+    assert_eq!(0xf << 4, 0xf0);\n+    assert_eq!(0xf0 >> 4, 0xf);\n+    assert_eq!(-16 >> 2, -4);\n+    assert_eq!(0b1010_1010 | 0b0101_0101, 0xff);\n }\n \n pub fn main() {"}, {"sha": "e27458327696ee1c232890e7d74138fc6b186bcc", "filename": "src/test/run-pass/block-arg-call-as.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-arg-call-as.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-arg-call-as.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-call-as.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -24,9 +24,9 @@ fn asBlock( f : &fn()->uint ) -> uint {\n \n pub fn main() {\n    let x = asSendfn(|| 22u);\n-   assert!((x == 22u));\n+   assert_eq!(x, 22u);\n    let x = asLambda(|| 22u);\n-   assert!((x == 22u));\n+   assert_eq!(x, 22u);\n    let x = asBlock(|| 22u);\n-   assert!((x == 22u));\n+   assert_eq!(x, 22u);\n }"}, {"sha": "d10bcaa216a67ff8aa047e8882178e20da07c62b", "filename": "src/test/run-pass/block-arg-can-be-followed-by-binop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -14,5 +14,5 @@ pub fn main() {\n     // Trailing expressions don't require parentheses:\n     let y = do vec::foldl(0f, v) |x, y| { x + *y } + 10f;\n \n-    assert!(y == 15f);\n+    assert_eq!(y, 15f);\n }"}, {"sha": "194fa297361f98789c54fafd5ede89a716d60644", "filename": "src/test/run-pass/block-arg-can-be-followed-by-block-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -12,5 +12,5 @@ pub fn main() {\n     fn f(i: &fn() -> uint) -> uint { i() }\n     let v = ~[-1f, 0f, 1f, 2f, 3f];\n     let z = do do vec::foldl(f, v) |x, _y| { x } { 22u };\n-    assert!(z == 22u);\n+    assert_eq!(z, 22u);\n }"}, {"sha": "5243eae30ca6384cafb61ac834468df6630e4fda", "filename": "src/test/run-pass/block-arg-can-be-followed-by-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -12,5 +12,5 @@ pub fn main() {\n     fn f(i: uint) -> uint { i }\n     let v = ~[-1f, 0f, 1f, 2f, 3f];\n     let z = do vec::foldl(f, v) |x, _y| { x } (22u);\n-    assert!(z == 22u);\n+    assert_eq!(z, 22u);\n }"}, {"sha": "ea189de562a8bed50e5b67cf27835eb8559bc892", "filename": "src/test/run-pass/block-arg-in-parentheses.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -28,8 +28,8 @@ fn w_ret(v: ~[int]) -> int {\n }\n \n pub fn main() {\n-    assert!(w_semi(~[0, 1, 2, 3]) == -10);\n-    assert!(w_paren1(~[0, 1, 2, 3]) == -4);\n-    assert!(w_paren2(~[0, 1, 2, 3]) == -4);\n-    assert!(w_ret(~[0, 1, 2, 3]) == -4);\n+    assert_eq!(w_semi(~[0, 1, 2, 3]), -10);\n+    assert_eq!(w_paren1(~[0, 1, 2, 3]), -4);\n+    assert_eq!(w_paren2(~[0, 1, 2, 3]), -4);\n+    assert_eq!(w_ret(~[0, 1, 2, 3]), -4);\n }"}, {"sha": "7ee9d9e5b5489f174559f6d16facf1abb8e6e16b", "filename": "src/test/run-pass/block-arg-used-as-any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-any.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -14,5 +14,5 @@ fn call_any(f: &fn() -> uint) -> uint {\n \n pub fn main() {\n     let x_r = do call_any { 22u };\n-    assert!(x_r == 22u);\n+    assert_eq!(x_r, 22u);\n }"}, {"sha": "34fa7e36d973f4ad6453b11766f27b44f212f40c", "filename": "src/test/run-pass/block-arg-used-as-lambda.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-lambda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-lambda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-lambda.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -19,6 +19,6 @@ pub fn main() {\n     let x_r = x(22u);\n     let y_r = y(x_r);\n \n-    assert!(x_r == 44u);\n-    assert!(y_r == 88u);\n+    assert_eq!(x_r, 44u);\n+    assert_eq!(y_r, 88u);\n }"}, {"sha": "de29ec99167f95d6d6bf29e758b6bf5c279bd758", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -51,8 +51,8 @@ pub fn main() {\n     let w = do vec::foldl(0f, v) |x, y| { x + *y } + 10f;\n     let y = do vec::foldl(0f, v) |x, y| { x + *y } + 10f;\n     let z = 10f + do vec::foldl(0f, v) |x, y| { x + *y };\n-    assert!(w == y);\n-    assert!(y == z);\n+    assert_eq!(w, y);\n+    assert_eq!(y, z);\n \n     // In the tail of a block\n     let w ="}, {"sha": "ace372dd2d3d9346d8db8a084044689c2ad44199", "filename": "src/test/run-pass/block-expr-precedence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-expr-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-expr-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-expr-precedence.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -58,8 +58,8 @@ pub fn main() {\n \n   let num = 12;\n \n-  assert!(if (true) { 12 } else { 12 } - num == 0);\n-  assert!(12 - if (true) { 12 } else { 12 } == 0);\n+  assert_eq!(if (true) { 12 } else { 12 } - num, 0);\n+  assert_eq!(12 - if (true) { 12 } else { 12 }, 0);\n   if (true) { 12; } {-num};\n   if (true) { 12; }; {-num};\n   if (true) { 12; };;; -num;"}, {"sha": "19e1fd4099b74408a851ac143be2ccdb84c2ca04", "filename": "src/test/run-pass/block-fn-coerce.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-fn-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-fn-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-fn-coerce.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -11,7 +11,7 @@\n fn force(f: &fn() -> int) -> int { return f(); }\n pub fn main() {\n     fn f() -> int { return 7; }\n-    assert!((force(f) == 7));\n+    assert_eq!(force(f), 7);\n     let g = {||force(f)};\n-    assert!((g() == 7));\n+    assert_eq!(g(), 7);\n }"}, {"sha": "34b77b4a844a8a9d24d305185ac6e05f2dd674cc", "filename": "src/test/run-pass/block-iter-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -21,5 +21,5 @@ pub fn main() {\n         }\n     });\n     error!(odds);\n-    assert!((odds == 4));\n+    assert_eq!(odds, 4);\n }"}, {"sha": "dc4ff5a054fbb983ace546b355c733f6f076f12f", "filename": "src/test/run-pass/block-iter-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -21,5 +21,5 @@ pub fn main() {\n         });\n     });\n     error!(sum);\n-    assert!((sum == 225));\n+    assert_eq!(sum, 225);\n }"}, {"sha": "b859dc91fba0c0cbb7711aa83ba9ef560a77fef2", "filename": "src/test/run-pass/block-vec-map_zip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-vec-map_zip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fblock-vec-map_zip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-vec-map_zip.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -16,5 +16,5 @@ pub fn main() {\n                   ~[true, false, false, true, true],\n                   |i, b| if *b { -(*i) } else { *i } );\n     error!(v.clone());\n-    assert!((v == ~[-1, 2, 3, -4, -5]));\n+    assert_eq!(v, ~[-1, 2, 3, -4, -5]);\n }"}, {"sha": "fb91e9a787e360cf2f3a79a472634c690e59683e", "filename": "src/test/run-pass/borrowck-borrow-from-at-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-at-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-at-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-at-vec.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -16,5 +16,5 @@ fn sum_slice(x: &[int]) -> int {\n \n pub fn main() {\n     let x = @[1, 2, 3];\n-    assert!(sum_slice(x) == 6);\n+    assert_eq!(sum_slice(x), 6);\n }"}, {"sha": "5149c87c4908e978a8c5f279e1ba1d9ab6d216cf", "filename": "src/test/run-pass/borrowck-borrow-from-expr-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -16,7 +16,7 @@ fn test1(x: @~int) {\n     do borrow(&*(*x).clone()) |p| {\n         let x_a = ptr::to_unsafe_ptr(&**x);\n         assert!((x_a as uint) != ptr::to_uint(p));\n-        assert!(unsafe{*x_a} == *p);\n+        assert_eq!(unsafe{*x_a}, *p);\n     }\n }\n "}, {"sha": "ee561fdb0be522857bcdc0cb86c92a46ede28fd6", "filename": "src/test/run-pass/borrowck-fixed-length-vecs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowck-fixed-length-vecs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowck-fixed-length-vecs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-fixed-length-vecs.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -11,5 +11,5 @@\n pub fn main() {\n     let x = [22];\n     let y = &x[0];\n-    assert!(*y == 22);\n+    assert_eq!(*y, 22);\n }"}, {"sha": "4b5d73f597e3fd2c7e2db618933a58a5c11a8f73", "filename": "src/test/run-pass/borrowck-mut-vec-as-imm-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -19,5 +19,5 @@ fn has_mut_vec(v: ~[int]) -> int {\n }\n \n pub fn main() {\n-    assert!(has_mut_vec(~[1, 2, 3]) == 6);\n+    assert_eq!(has_mut_vec(~[1, 2, 3]), 6);\n }"}, {"sha": "5a94e2f5cd03efa522ff11d94083dc97db4cc917", "filename": "src/test/run-pass/borrowck-preserve-box-in-discr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -16,14 +16,14 @@ pub fn main() {\n     let mut x = @F {f: ~3};\n     match x {\n       @F {f: ref b_x} => {\n-        assert!(**b_x == 3);\n-        assert!(ptr::to_unsafe_ptr(&(*x.f)) == ptr::to_unsafe_ptr(&(**b_x)));\n+        assert_eq!(**b_x, 3);\n+        assert_eq!(ptr::to_unsafe_ptr(&(*x.f)), ptr::to_unsafe_ptr(&(**b_x)));\n \n         x = @F {f: ~4};\n \n         debug!(\"ptr::to_unsafe_ptr(*b_x) = %x\",\n                ptr::to_unsafe_ptr(&(**b_x)) as uint);\n-        assert!(**b_x == 3);\n+        assert_eq!(**b_x, 3);\n         assert!(ptr::to_unsafe_ptr(&(*x.f)) != ptr::to_unsafe_ptr(&(**b_x)));\n       }\n     }"}, {"sha": "f86471fd20904f3617c50c36588c72a6c4e3c759", "filename": "src/test/run-pass/borrowck-preserve-box-in-field.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -14,21 +14,21 @@ fn borrow(x: &int, f: &fn(x: &int)) {\n     let before = *x;\n     f(x);\n     let after = *x;\n-    assert!(before == after);\n+    assert_eq!(before, after);\n }\n \n struct F { f: ~int }\n \n pub fn main() {\n     let mut x = @F {f: ~3};\n     do borrow(x.f) |b_x| {\n-        assert!(*b_x == 3);\n-        assert!(ptr::to_unsafe_ptr(&(*x.f)) == ptr::to_unsafe_ptr(&(*b_x)));\n+        assert_eq!(*b_x, 3);\n+        assert_eq!(ptr::to_unsafe_ptr(&(*x.f)), ptr::to_unsafe_ptr(&(*b_x)));\n         x = @F {f: ~4};\n \n         debug!(\"ptr::to_unsafe_ptr(*b_x) = %x\",\n                ptr::to_unsafe_ptr(&(*b_x)) as uint);\n-        assert!(*b_x == 3);\n+        assert_eq!(*b_x, 3);\n         assert!(ptr::to_unsafe_ptr(&(*x.f)) != ptr::to_unsafe_ptr(&(*b_x)));\n     }\n }"}, {"sha": "17f9dcb627d69fa88a6c9a8c77f3d86e3a185220", "filename": "src/test/run-pass/borrowck-preserve-box-in-pat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -16,14 +16,14 @@ pub fn main() {\n     let mut x = @mut @F {f: ~3};\n     match x {\n       @@F{f: ref b_x} => {\n-        assert!(**b_x == 3);\n-        assert!(ptr::to_unsafe_ptr(&(x.f)) == ptr::to_unsafe_ptr(b_x));\n+        assert_eq!(**b_x, 3);\n+        assert_eq!(ptr::to_unsafe_ptr(&(x.f)), ptr::to_unsafe_ptr(b_x));\n \n         *x = @F {f: ~4};\n \n         debug!(\"ptr::to_unsafe_ptr(*b_x) = %x\",\n                ptr::to_unsafe_ptr(&(**b_x)) as uint);\n-        assert!(**b_x == 3);\n+        assert_eq!(**b_x, 3);\n         assert!(ptr::to_unsafe_ptr(&(*x.f)) != ptr::to_unsafe_ptr(&(**b_x)));\n       }\n     }"}, {"sha": "25bc5c0c982d9a52bc6d3ef7497ba1b9e58cec64", "filename": "src/test/run-pass/borrowck-preserve-box-in-uniq.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -14,21 +14,21 @@ fn borrow(x: &int, f: &fn(x: &int)) {\n     let before = *x;\n     f(x);\n     let after = *x;\n-    assert!(before == after);\n+    assert_eq!(before, after);\n }\n \n struct F { f: ~int }\n \n pub fn main() {\n     let mut x = ~@F{f: ~3};\n     do borrow(x.f) |b_x| {\n-        assert!(*b_x == 3);\n-        assert!(ptr::to_unsafe_ptr(&(*x.f)) == ptr::to_unsafe_ptr(&(*b_x)));\n+        assert_eq!(*b_x, 3);\n+        assert_eq!(ptr::to_unsafe_ptr(&(*x.f)), ptr::to_unsafe_ptr(&(*b_x)));\n         *x = @F{f: ~4};\n \n         debug!(\"ptr::to_unsafe_ptr(*b_x) = %x\",\n                ptr::to_unsafe_ptr(&(*b_x)) as uint);\n-        assert!(*b_x == 3);\n+        assert_eq!(*b_x, 3);\n         assert!(ptr::to_unsafe_ptr(&(*x.f)) != ptr::to_unsafe_ptr(&(*b_x)));\n     }\n }"}, {"sha": "5f4d907e96289f8d6e8f83fc95ee285c0a936d98", "filename": "src/test/run-pass/borrowck-preserve-box.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -14,19 +14,19 @@ fn borrow(x: &int, f: &fn(x: &int)) {\n     let before = *x;\n     f(x);\n     let after = *x;\n-    assert!(before == after);\n+    assert_eq!(before, after);\n }\n \n pub fn main() {\n     let mut x = @3;\n     do borrow(x) |b_x| {\n-        assert!(*b_x == 3);\n-        assert!(ptr::to_unsafe_ptr(&(*x)) == ptr::to_unsafe_ptr(&(*b_x)));\n+        assert_eq!(*b_x, 3);\n+        assert_eq!(ptr::to_unsafe_ptr(&(*x)), ptr::to_unsafe_ptr(&(*b_x)));\n         x = @22;\n \n         debug!(\"ptr::to_unsafe_ptr(*b_x) = %x\",\n                ptr::to_unsafe_ptr(&(*b_x)) as uint);\n-        assert!(*b_x == 3);\n+        assert_eq!(*b_x, 3);\n         assert!(ptr::to_unsafe_ptr(&(*x)) != ptr::to_unsafe_ptr(&(*b_x)));\n     }\n }"}, {"sha": "d9adcbb06f17ed3d6e3598b74d1f7b12d1afda2b", "filename": "src/test/run-pass/borrowck-preserve-cond-box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowck-preserve-cond-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowck-preserve-cond-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-cond-box.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -25,13 +25,13 @@ fn testfn(cond: bool) {\n     }\n \n     debug!(\"*r = %d, exp = %d\", *r, exp);\n-    assert!(*r == exp);\n+    assert_eq!(*r, exp);\n \n     x = @5;\n     y = @6;\n \n     debug!(\"*r = %d, exp = %d\", *r, exp);\n-    assert!(*r == exp);\n+    assert_eq!(*r, exp);\n }\n \n pub fn main() {"}, {"sha": "ac1463caddf9fe8c0f9291e75dbc2923609136f7", "filename": "src/test/run-pass/borrowck-preserve-expl-deref.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -14,21 +14,21 @@ fn borrow(x: &int, f: &fn(x: &int)) {\n     let before = *x;\n     f(x);\n     let after = *x;\n-    assert!(before == after);\n+    assert_eq!(before, after);\n }\n \n struct F { f: ~int }\n \n pub fn main() {\n     let mut x = @F {f: ~3};\n     do borrow((*x).f) |b_x| {\n-        assert!(*b_x == 3);\n-        assert!(ptr::to_unsafe_ptr(&(*x.f)) == ptr::to_unsafe_ptr(&(*b_x)));\n+        assert_eq!(*b_x, 3);\n+        assert_eq!(ptr::to_unsafe_ptr(&(*x.f)), ptr::to_unsafe_ptr(&(*b_x)));\n         x = @F {f: ~4};\n \n         debug!(\"ptr::to_unsafe_ptr(*b_x) = %x\",\n                ptr::to_unsafe_ptr(&(*b_x)) as uint);\n-        assert!(*b_x == 3);\n+        assert_eq!(*b_x, 3);\n         assert!(ptr::to_unsafe_ptr(&(*x.f)) != ptr::to_unsafe_ptr(&(*b_x)));\n     }\n }"}, {"sha": "bb8710aad489bf67e6f0d4a61218e908d9c8619d", "filename": "src/test/run-pass/borrowck-univariant-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowck-univariant-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowck-univariant-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-univariant-enum.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -25,5 +25,5 @@ pub fn main() {\n         *x * b\n       }\n     };\n-    assert!(z == 18);\n+    assert_eq!(z, 18);\n }"}, {"sha": "4e9ba6d3158e00c37c03d4d5522989d5f77700a0", "filename": "src/test/run-pass/borrowed-ptr-pattern-infallible.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-infallible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-infallible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-infallible.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -10,7 +10,7 @@\n \n pub fn main() {\n     let (&x, &y, &z) = (&3, &'a', &@\"No pets!\");\n-    assert!(x == 3);\n-    assert!(y == 'a');\n-    assert!(z == @\"No pets!\");\n+    assert_eq!(x, 3);\n+    assert_eq!(y, 'a');\n+    assert_eq!(z, @\"No pets!\");\n }"}, {"sha": "4775e5fe0a80ee47988b8c4f951add5ebf2eb75f", "filename": "src/test/run-pass/borrowed-ptr-pattern-option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-option.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -19,5 +19,5 @@ fn select<'r>(x: &'r Option<int>, y: &'r Option<int>) -> &'r Option<int> {\n pub fn main() {\n     let x = None;\n     let y = Some(3);\n-    assert!(select(&x, &y).get() == 3);\n+    assert_eq!(select(&x, &y).get(), 3);\n }"}, {"sha": "e0af2e80508c3d5e5cdd41f44beefa26bbf48ff9", "filename": "src/test/run-pass/borrowed-ptr-pattern.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -15,7 +15,7 @@ fn foo<T:Copy>(x: &T) -> T{\n }\n \n pub fn main() {\n-    assert!(foo(&3) == 3);\n-    assert!(foo(&'a') == 'a');\n-    assert!(foo(&@\"Dogs rule, cats drool\") == @\"Dogs rule, cats drool\");\n+    assert_eq!(foo(&3), 3);\n+    assert_eq!(foo(&'a'), 'a');\n+    assert_eq!(foo(&@\"Dogs rule, cats drool\"), @\"Dogs rule, cats drool\");\n }"}, {"sha": "e7dc436567982d71d451e6b1d4d1feb3a74ef6ab", "filename": "src/test/run-pass/box-unbox.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-unbox.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -18,5 +18,5 @@ pub fn main() {\n     let foo: int = 17;\n     let bfoo: Box<int> = Box {c: @foo};\n     debug!(\"see what's in our box\");\n-    assert!((unbox::<int>(bfoo) == foo));\n+    assert_eq!(unbox::<int>(bfoo), foo);\n }"}, {"sha": "da362c8194d7c9ef190144e57e3e3fc6167d1d44", "filename": "src/test/run-pass/break.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fbreak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fbreak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbreak.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -11,9 +11,9 @@\n pub fn main() {\n     let mut i = 0;\n     while i < 20 { i += 1; if i == 10 { break; } }\n-    assert!((i == 10));\n+    assert_eq!(i, 10);\n     loop { i += 1; if i == 20 { break; } }\n-    assert!((i == 20));\n+    assert_eq!(i, 20);\n     for vec::each(~[1, 2, 3, 4, 5, 6]) |x| {\n         if *x == 3 { break; } assert!((*x <= 3));\n     }"}, {"sha": "ec204e7a4c23f778e5962d329f305efcd0f03076", "filename": "src/test/run-pass/c-stack-returning-int64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -29,7 +29,7 @@ fn atoll(s: ~str) -> i64 {\n \n pub fn main() {\n     unsafe {\n-        assert!(atol(~\"1024\") * 10 == atol(~\"10240\"));\n+        assert_eq!(atol(~\"1024\") * 10, atol(~\"10240\"));\n         assert!((atoll(~\"11111111111111111\") * 10i64)\n             == atoll(~\"111111111111111110\"));\n     }"}, {"sha": "cc8d8e96195561e4c27fab0956b6d38f4e3e58b7", "filename": "src/test/run-pass/call-closure-from-overloaded-op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcall-closure-from-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcall-closure-from-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcall-closure-from-overloaded-op.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -13,5 +13,5 @@ fn foo() -> int { 22 }\n pub fn main() {\n     let mut x: ~[@fn() -> int] = ~[];\n     x.push(foo);\n-    assert!((x[0])() == 22);\n+    assert_eq!((x[0])(), 22);\n }"}, {"sha": "19939650633556291a2d5ec9f97f9134e2ad30fc", "filename": "src/test/run-pass/cap-clause-move.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -12,20 +12,20 @@ pub fn main() {\n     let x = ~1;\n     let y = ptr::to_unsafe_ptr(&(*x)) as uint;\n     let lam_move: @fn() -> uint = || ptr::to_unsafe_ptr(&(*x)) as uint;\n-    assert!(lam_move() == y);\n+    assert_eq!(lam_move(), y);\n \n     let x = ~2;\n     let y = ptr::to_unsafe_ptr(&(*x)) as uint;\n     let lam_move: @fn() -> uint = || ptr::to_unsafe_ptr(&(*x)) as uint;\n-    assert!(lam_move() == y);\n+    assert_eq!(lam_move(), y);\n \n     let x = ~3;\n     let y = ptr::to_unsafe_ptr(&(*x)) as uint;\n     let snd_move: ~fn() -> uint = || ptr::to_unsafe_ptr(&(*x)) as uint;\n-    assert!(snd_move() == y);\n+    assert_eq!(snd_move(), y);\n \n     let x = ~4;\n     let y = ptr::to_unsafe_ptr(&(*x)) as uint;\n     let lam_move: ~fn() -> uint = || ptr::to_unsafe_ptr(&(*x)) as uint;\n-    assert!(lam_move() == y);\n+    assert_eq!(lam_move(), y);\n }"}, {"sha": "10407420a4332d8267a173f253cdc6e6e8af157e", "filename": "src/test/run-pass/cast.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcast.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -14,13 +14,13 @@\n // -*- rust -*-\n pub fn main() {\n     let i: int = 'Q' as int;\n-    assert!((i == 0x51));\n+    assert_eq!(i, 0x51);\n     let u: u32 = i as u32;\n-    assert!((u == 0x51 as u32));\n-    assert!((u == 'Q' as u32));\n-    assert!((i as u8 == 'Q' as u8));\n-    assert!((i as u8 as i8 == 'Q' as u8 as i8));\n-    assert!((0x51 as char == 'Q'));\n-    assert!((true == 1 as bool));\n-    assert!((0 as u32 == false as u32));\n+    assert_eq!(u, 0x51 as u32);\n+    assert_eq!(u, 'Q' as u32);\n+    assert_eq!(i as u8, 'Q' as u8);\n+    assert_eq!(i as u8 as i8, 'Q' as u8 as i8);\n+    assert_eq!(0x51 as char, 'Q');\n+    assert_eq!(true, 1 as bool);\n+    assert_eq!(0 as u32, false as u32);\n }"}, {"sha": "460d6136cafe014cafa0cdf17275685b3df18250", "filename": "src/test/run-pass/cci_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcci_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcci_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_borrow.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -18,5 +18,5 @@ pub fn main() {\n     let p = @22u;\n     let r = foo(p);\n     debug!(\"r=%u\", r);\n-    assert!(r == 22u);\n+    assert_eq!(r, 22u);\n }"}, {"sha": "231cd37db5d356be689f1692f1fe846e1d2a121b", "filename": "src/test/run-pass/cci_nested_exe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcci_nested_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcci_nested_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_nested_exe.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -18,12 +18,12 @@ pub fn main() {\n     let lst = new_int_alist();\n     alist_add(&lst, 22, ~\"hi\");\n     alist_add(&lst, 44, ~\"ho\");\n-    assert!(alist_get(&lst, 22) == ~\"hi\");\n-    assert!(alist_get(&lst, 44) == ~\"ho\");\n+    assert_eq!(alist_get(&lst, 22), ~\"hi\");\n+    assert_eq!(alist_get(&lst, 44), ~\"ho\");\n \n     let lst = new_int_alist_2();\n     alist_add(&lst, 22, ~\"hi\");\n     alist_add(&lst, 44, ~\"ho\");\n-    assert!(alist_get(&lst, 22) == ~\"hi\");\n-    assert!(alist_get(&lst, 44) == ~\"ho\");\n+    assert_eq!(alist_get(&lst, 22), ~\"hi\");\n+    assert_eq!(alist_get(&lst, 44), ~\"ho\");\n }"}, {"sha": "237fa3f7ea9c90b83b852b9d1fd2788f146b71ab", "filename": "src/test/run-pass/cfgs-on-items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcfgs-on-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcfgs-on-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcfgs-on-items.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -26,6 +26,6 @@ fn foo2() -> int { 3 }\n \n \n fn main() {\n-    assert!(1 == foo1());\n-    assert!(3 == foo2());\n+    assert_eq!(1, foo1());\n+    assert_eq!(3, foo2());\n }"}, {"sha": "f982d3723b4c2091cbeeec84762026a01a118c14", "filename": "src/test/run-pass/char.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchar.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -13,11 +13,11 @@\n pub fn main() {\n     let c: char = 'x';\n     let d: char = 'x';\n-    assert!((c == 'x'));\n-    assert!(('x' == c));\n-    assert!((c == c));\n-    assert!((c == d));\n-    assert!((d == c));\n-    assert!((d == 'x'));\n-    assert!(('x' == d));\n+    assert_eq!(c, 'x');\n+    assert_eq!('x', c);\n+    assert_eq!(c, c);\n+    assert_eq!(c, d);\n+    assert_eq!(d, c);\n+    assert_eq!(d, 'x');\n+    assert_eq!('x', d);\n }"}, {"sha": "8bedfef89d00d56cabe23a3886c6c4b1d492c4b5", "filename": "src/test/run-pass/class-cast-to-trait-cross-crate-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -17,7 +17,7 @@ use cci_class_cast::kitty::*;\n fn print_out(thing: @ToStr, expected: ~str) {\n   let actual = thing.to_str();\n   debug!(\"%s\", actual);\n-  assert!((actual == expected));\n+  assert_eq!(actual, expected);\n }\n \n pub fn main() {"}, {"sha": "6674147e147696d8d6cc42021f6881bdcd048f4c", "filename": "src/test/run-pass/class-cast-to-trait-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -51,7 +51,7 @@ class cat : to_str {\n fn print_out<T:to_str>(thing: T, expected: str) {\n   let actual = thing.to_str();\n   debug!(\"%s\", actual);\n-  assert!((actual == expected));\n+  assert_eq!(actual, expected);\n }\n \n pub fn main() {"}, {"sha": "051c09fac537e755a8dba748805118de92e85aea", "filename": "src/test/run-pass/class-cast-to-trait-multiple-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -88,6 +88,6 @@ pub fn main() {\n   let whitefang : dog = dog();\n   annoy_neighbors(@(copy nyan) as @noisy);\n   annoy_neighbors(@(copy whitefang) as @noisy);\n-  assert!((nyan.meow_count() == 10u));\n-  assert!((*whitefang.volume == 1));\n+  assert_eq!(nyan.meow_count(), 10u);\n+  assert_eq!(*whitefang.volume, 1);\n }"}, {"sha": "eb2c26478b6934988a6978a49b4b1c7874749e81", "filename": "src/test/run-pass/class-exports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-exports.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -34,5 +34,5 @@ mod kitty {\n }\n \n pub fn main() {\n-  assert!((cat(~\"Spreckles\").get_name() == ~\"Spreckles\"));\n+  assert_eq!(cat(~\"Spreckles\").get_name(), ~\"Spreckles\");\n }"}, {"sha": "ae3d088c539c7138ec40bfa2e2beea649565fb07", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -136,11 +136,11 @@ priv impl<T> cat<T> {\n pub fn main() {\n     let mut nyan: cat<~str> = cat::new(0, 2, ~\"nyan\");\n     for uint::range(1, 5) |_| { nyan.speak(); }\n-    assert!((*nyan.find(&1).unwrap() == ~\"nyan\"));\n-    assert!((nyan.find(&10) == None));\n+    assert!(*nyan.find(&1).unwrap() == ~\"nyan\");\n+    assert_eq!(nyan.find(&10), None);\n     let mut spotty: cat<cat_type> = cat::new(2, 57, tuxedo);\n     for uint::range(0, 6) |_| { spotty.speak(); }\n-    assert!((spotty.len() == 8));\n+    assert_eq!(spotty.len(), 8);\n     assert!((spotty.contains_key(&2)));\n-    assert!((spotty.get(&3) == &tuxedo));\n+    assert_eq!(spotty.get(&3), &tuxedo);\n }"}, {"sha": "9545f5340df76358f1e9986e807f61bff400f2c8", "filename": "src/test/run-pass/class-implements-multiple-traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-traits.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -123,7 +123,7 @@ fn scratched_something<T:scratchy>(critter: T) -> bool {\n pub fn main() {\n   let nyan : cat  = cat(0u, 2, \"nyan\");\n   annoy_neighbors(nyan as noisy);\n-  assert!((nyan.meow_count() == 10u));\n+  assert_eq!(nyan.meow_count(), 10u);\n   assert!((bite_everything(nyan as bitey)));\n   assert!((scratched_something(nyan as scratchy)));\n }"}, {"sha": "d2c78c7f1add831b526cad3629f7fa838458e87b", "filename": "src/test/run-pass/class-method-cross-crate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-method-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-method-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-method-cross-crate.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -16,7 +16,7 @@ use cci_class_2::kitties::*;\n pub fn main() {\n   let nyan : cat = cat(52u, 99);\n   let kitty = cat(1000u, 2);\n-  assert!((nyan.how_hungry == 99));\n-  assert!((kitty.how_hungry == 2));\n+  assert_eq!(nyan.how_hungry, 99);\n+  assert_eq!(kitty.how_hungry, 2);\n   nyan.speak();\n }"}, {"sha": "c5e37cab2b84a6975ded634cc06f21ccc75187ff", "filename": "src/test/run-pass/class-methods-cross-crate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-methods-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-methods-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-methods-cross-crate.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -16,8 +16,8 @@ use cci_class_3::kitties::*;\n pub fn main() {\n     let mut nyan : cat = cat(52u, 99);\n     let mut kitty = cat(1000u, 2);\n-    assert!((nyan.how_hungry == 99));\n-    assert!((kitty.how_hungry == 2));\n+    assert_eq!(nyan.how_hungry, 99);\n+    assert_eq!(kitty.how_hungry, 2);\n     nyan.speak();\n-    assert!((nyan.meow_count() == 53u));\n+    assert_eq!(nyan.meow_count(), 53u);\n }"}, {"sha": "fa358f4b132aaf52a69df77ca6da434bb39e6fe6", "filename": "src/test/run-pass/class-methods.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-methods.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -29,8 +29,8 @@ fn cat(in_x: uint, in_y: int) -> cat {\n pub fn main() {\n   let mut nyan: cat = cat(52u, 99);\n   let mut kitty = cat(1000u, 2);\n-  assert!((nyan.how_hungry == 99));\n-  assert!((kitty.how_hungry == 2));\n+  assert_eq!(nyan.how_hungry, 99);\n+  assert_eq!(kitty.how_hungry, 2);\n   nyan.speak();\n-  assert!((nyan.meow_count() == 53u));\n+  assert_eq!(nyan.meow_count(), 53u);\n }"}, {"sha": "62ff54388952fd03fbed6ab9b90f9c300d98db21", "filename": "src/test/run-pass/class-poly-methods-cross-crate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-poly-methods-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-poly-methods-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-poly-methods-cross-crate.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -16,10 +16,10 @@ use cci_class_6::kitties::*;\n pub fn main() {\n   let mut nyan : cat<char> = cat::<char>(52u, 99, ~['p']);\n   let mut kitty = cat(1000u, 2, ~[~\"tabby\"]);\n-  assert!((nyan.how_hungry == 99));\n-  assert!((kitty.how_hungry == 2));\n+  assert_eq!(nyan.how_hungry, 99);\n+  assert_eq!(kitty.how_hungry, 2);\n   nyan.speak(~[1u,2u,3u]);\n-  assert!((nyan.meow_count() == 55u));\n+  assert_eq!(nyan.meow_count(), 55u);\n   kitty.speak(~[~\"meow\", ~\"mew\", ~\"purr\", ~\"chirp\"]);\n-  assert!((kitty.meow_count() == 1004u));\n+  assert_eq!(kitty.meow_count(), 1004u);\n }"}, {"sha": "f538eb054a67fa16ae0c55e39807d31842551554", "filename": "src/test/run-pass/class-poly-methods.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -33,10 +33,10 @@ fn cat<U>(in_x : uint, in_y : int, in_info: ~[U]) -> cat<U> {\n pub fn main() {\n   let mut nyan : cat<int> = cat::<int>(52u, 99, ~[9]);\n   let mut kitty = cat(1000u, 2, ~[~\"tabby\"]);\n-  assert!((nyan.how_hungry == 99));\n-  assert!((kitty.how_hungry == 2));\n+  assert_eq!(nyan.how_hungry, 99);\n+  assert_eq!(kitty.how_hungry, 2);\n   nyan.speak(~[1,2,3]);\n-  assert!((nyan.meow_count() == 55u));\n+  assert_eq!(nyan.meow_count(), 55u);\n   kitty.speak(~[~\"meow\", ~\"mew\", ~\"purr\", ~\"chirp\"]);\n-  assert!((kitty.meow_count() == 1004u));\n+  assert_eq!(kitty.meow_count(), 1004u);\n }"}, {"sha": "1952520d018bc52292d517b2c32ea16b7b5971de", "filename": "src/test/run-pass/class-separate-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -62,7 +62,7 @@ impl ToStr for cat {\n fn print_out(thing: @ToStr, expected: ~str) {\n   let actual = thing.to_str();\n   debug!(\"%s\", actual);\n-  assert!((actual == expected));\n+  assert_eq!(actual, expected);\n }\n \n pub fn main() {"}, {"sha": "0246946102bdcf5586ff39702eaa9a170ef99804", "filename": "src/test/run-pass/class-trait-bounded-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-trait-bounded-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclass-trait-bounded-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-trait-bounded-param.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -31,5 +31,5 @@ pub fn main() {\n     let m = int_hash();\n     m.insert(1, 2);\n     m.insert(3, 4);\n-    assert!(old_iter::to_vec(keys(m)) == ~[1, 3]);\n+    assert_eq!(old_iter::to_vec(keys(m)), ~[1, 3]);\n }"}, {"sha": "0df04c40fb7c965a485d2443aaefc1a34ef466e5", "filename": "src/test/run-pass/classes-simple-cross-crate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclasses-simple-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclasses-simple-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses-simple-cross-crate.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -16,6 +16,6 @@ use cci_class::kitties::*;\n pub fn main() {\n   let nyan : cat = cat(52u, 99);\n   let kitty = cat(1000u, 2);\n-  assert!((nyan.how_hungry == 99));\n-  assert!((kitty.how_hungry == 2));\n+  assert_eq!(nyan.how_hungry, 99);\n+  assert_eq!(kitty.how_hungry, 2);\n }"}, {"sha": "9de1066ec5701008c7fd6d24435d5cf7357d69f9", "filename": "src/test/run-pass/classes-simple-method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclasses-simple-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclasses-simple-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses-simple-method.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -28,7 +28,7 @@ fn cat(in_x : uint, in_y : int) -> cat {\n pub fn main() {\n   let mut nyan : cat = cat(52u, 99);\n   let mut kitty = cat(1000u, 2);\n-  assert!((nyan.how_hungry == 99));\n-  assert!((kitty.how_hungry == 2));\n+  assert_eq!(nyan.how_hungry, 99);\n+  assert_eq!(kitty.how_hungry, 2);\n   nyan.speak();\n }"}, {"sha": "3d2b08d7a851dc1934faefe2890508c42f4a575d", "filename": "src/test/run-pass/classes-simple.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclasses-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclasses-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses-simple.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -24,6 +24,6 @@ fn cat(in_x : uint, in_y : int) -> cat {\n pub fn main() {\n   let mut nyan : cat = cat(52u, 99);\n   let mut kitty = cat(1000u, 2);\n-  assert!((nyan.how_hungry == 99));\n-  assert!((kitty.how_hungry == 2));\n+  assert_eq!(nyan.how_hungry, 99);\n+  assert_eq!(kitty.how_hungry, 2);\n }"}, {"sha": "091f955aca01b3265c35a869c6d491a566c9de9e", "filename": "src/test/run-pass/clone-with-exterior.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -20,8 +20,8 @@ pub fn main() {\n     let z = ~Pair { a : 10, b : 12};\n \n     let f: ~fn() = || {\n-        assert!((z.a == 10));\n-        assert!((z.b == 12));\n+        assert_eq!(z.a, 10);\n+        assert_eq!(z.b, 12);\n     };\n \n     spawn(f);"}, {"sha": "736c0f91941758d23fb8ea0a6d6cddefc74bbba5", "filename": "src/test/run-pass/close-over-big-then-small-data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -24,6 +24,6 @@ fn f<A:Copy + 'static>(a: A, b: u16) -> @fn() -> (A, u16) {\n pub fn main() {\n     let (a, b) = f(22_u64, 44u16)();\n     debug!(\"a=%? b=%?\", a, b);\n-    assert!(a == 22u64);\n-    assert!(b == 44u16);\n+    assert_eq!(a, 22u64);\n+    assert_eq!(b, 44u16);\n }"}, {"sha": "167fbdf3fc0524c9801664e5e4dee1ecc59e59c8", "filename": "src/test/run-pass/closure-inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclosure-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclosure-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-inference.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -16,5 +16,5 @@ fn apply<A>(f: &fn(A) -> A, v: A) -> A { f(v) }\n \n pub fn main() {\n     let f = {|i| foo(i)};\n-    assert!(apply(f, 2) == 3);\n+    assert_eq!(apply(f, 2), 3);\n }"}, {"sha": "fa16ea001452c79a52e825264ed202193dd55ace", "filename": "src/test/run-pass/closure-inference2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclosure-inference2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fclosure-inference2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-inference2.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -12,6 +12,6 @@\n \n pub fn main() {\n     let f = {|i| i};\n-    assert!(f(2) == 2);\n-    assert!(f(5) == 5);\n+    assert_eq!(f(2), 2);\n+    assert_eq!(f(5), 5);\n }"}, {"sha": "6c78cd250ddd8168c89c94df8d6f0beffdc9f5d9", "filename": "src/test/run-pass/coerce-reborrow-imm-ptr-rcvr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-rcvr.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -12,5 +12,5 @@ fn foo(speaker: &const SpeechMaker) -> uint {\n \n pub fn main() {\n     let mut lincoln = SpeechMaker {speeches: 22};\n-    assert!(foo(&const lincoln) == 55);\n+    assert_eq!(foo(&const lincoln), 55);\n }"}, {"sha": "7ab80920849b35f328053aa8a05df81f5be70ed3", "filename": "src/test/run-pass/coerce-reborrow-imm-vec-rcvr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -14,7 +14,7 @@ fn bip(v: &[uint]) -> ~[uint] {\n \n pub fn main() {\n     let mut the_vec = ~[1, 2, 3, 100];\n-    assert!(the_vec == foo(the_vec));\n-    assert!(the_vec == bar(the_vec));\n-    assert!(the_vec == bip(the_vec));\n+    assert_eq!(the_vec, foo(the_vec));\n+    assert_eq!(the_vec, bar(the_vec));\n+    assert_eq!(the_vec, bip(the_vec));\n }"}, {"sha": "18a28722c7017416988e294a95f4770357f77852", "filename": "src/test/run-pass/coerce-reborrow-mut-vec-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -11,5 +11,5 @@ fn bar(v: &mut [uint]) {\n pub fn main() {\n     let mut the_vec = ~[1, 2, 3, 100];\n     bar(the_vec);\n-    assert!(the_vec == ~[100, 3, 2, 1]);\n+    assert_eq!(the_vec, ~[100, 3, 2, 1]);\n }"}, {"sha": "aa787328c412b7357118c7842e21ac3d3890ee71", "filename": "src/test/run-pass/coerce-reborrow-mut-vec-rcvr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -17,5 +17,5 @@ fn bar(v: &mut [uint]) {\n pub fn main() {\n     let mut the_vec = ~[1, 2, 3, 100];\n     bar(the_vec);\n-    assert!(the_vec == ~[100, 3, 2, 1]);\n+    assert_eq!(the_vec, ~[100, 3, 2, 1]);\n }"}, {"sha": "510976c56463df53b6de791328bc42f5c80897bb", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -17,7 +17,7 @@ pub fn main() {\n     let y = p.recv();\n     error!(\"received\");\n     error!(y);\n-    assert!((y == 10));\n+    assert_eq!(y, 10);\n }\n \n fn child(c: &Chan<int>) {"}, {"sha": "3fe33eae84d49b877e610b6dd87d127d26144d8e", "filename": "src/test/run-pass/conditional-compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconditional-compile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconditional-compile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconditional-compile.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -104,7 +104,7 @@ fn test_in_fn_ctxt() {\n     #[cfg(bogus)]\n     static i: int = 0;\n     static i: int = 1;\n-    assert!((i == 1));\n+    assert_eq!(i, 1);\n }\n \n mod test_foreign_items {"}, {"sha": "19dea653a4a278b6a320bf48cac5654a6eced66b", "filename": "src/test/run-pass/const-autoderef-newtype.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-autoderef-newtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-autoderef-newtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-autoderef-newtype.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -13,5 +13,5 @@ static C0: S = S([3]);\n static C1: int = C0[0];\n \n pub fn main() {\n-    assert!(C1 == 3);\n+    assert_eq!(C1, 3);\n }"}, {"sha": "e80ed7c984b4a4da33b5f607fcec9ace7513aa1d", "filename": "src/test/run-pass/const-autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-autoderef.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -14,6 +14,6 @@ static C: &'static &'static &'static &'static [u8, ..1] = & & & &A;\n static D: u8 = (&C)[0];\n \n pub fn main() {\n-    assert!(B == A[0]);\n-    assert!(D == A[0]);\n+    assert_eq!(B, A[0]);\n+    assert_eq!(D, A[0]);\n }"}, {"sha": "ac2e879ceacc931b266366e665372f9f94c31ead", "filename": "src/test/run-pass/const-big-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-big-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-big-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-big-enum.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -27,8 +27,8 @@ pub fn main() {\n     }\n     match Z {\n         Quux(d,h) => {\n-            assert!((d == 0x123456789abcdef0));\n-            assert!((h == 0x1234));\n+            assert_eq!(d, 0x123456789abcdef0);\n+            assert_eq!(h, 0x1234);\n         }\n         _ => fail!()\n     }"}, {"sha": "3dc94936304794e2e5f36cf84bbfc93daea8bd6f", "filename": "src/test/run-pass/const-cast-ptr-int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-cast-ptr-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-cast-ptr-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-cast-ptr-int.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -11,5 +11,5 @@\n static a: *u8 = 0 as *u8;\n \n pub fn main() {\n-    assert!(a == ptr::null());\n+    assert_eq!(a, ptr::null());\n }"}, {"sha": "1c8e92b91cd1bbf3378a34205a9f00384c457db7", "filename": "src/test/run-pass/const-cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-cast.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -16,6 +16,6 @@ static a: &'static int = &10;\n static b: *int = a as *int;\n \n pub fn main() {\n-    assert!(x as *libc::c_void == y);\n-    assert!(a as *int == b);\n+    assert_eq!(x as *libc::c_void, y);\n+    assert_eq!(a as *int, b);\n }"}, {"sha": "bdb2b3d2110435ac6af63c1647e2505e1f8e5062", "filename": "src/test/run-pass/const-const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-const.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -12,5 +12,5 @@ static a: int = 1;\n static b: int = a + 2;\n \n pub fn main() {\n-    assert!(b == 3);\n+    assert_eq!(b, 3);\n }"}, {"sha": "5b31c9a44de51b433c8400a317df3114e67ca0fb", "filename": "src/test/run-pass/const-contents.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-contents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-contents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-contents.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -18,10 +18,10 @@ static notb : bool = !true;\n static neg : int = -(1);\n \n pub fn main() {\n-    assert!((lsl == 4));\n-    assert!((add == 3));\n-    assert!((addf == 3.0f));\n-    assert!((not == -1));\n-    assert!((notb == false));\n-    assert!((neg == -1));\n+    assert_eq!(lsl, 4);\n+    assert_eq!(add, 3);\n+    assert_eq!(addf, 3.0f);\n+    assert_eq!(not, -1);\n+    assert_eq!(notb, false);\n+    assert_eq!(neg, -1);\n }"}, {"sha": "607d0c72b8954e3385ded525868bd467f70ac807", "filename": "src/test/run-pass/const-cross-crate-const.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-cross-crate-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-cross-crate-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-cross-crate-const.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -17,9 +17,9 @@ static a: uint = cci_const::uint_val;\n static b: uint = cci_const::uint_expr + 5;\n \n fn main() {\n-    assert!(a == 12);\n+    assert_eq!(a, 12);\n     let foo2 = a;\n-    assert!(foo2 == cci_const::uint_val);\n-    assert!(b == cci_const::uint_expr + 5);\n-    assert!(foo == cci_const::foopy);\n+    assert_eq!(foo2, cci_const::uint_val);\n+    assert_eq!(b, cci_const::uint_expr + 5);\n+    assert_eq!(foo, cci_const::foopy);\n }"}, {"sha": "5281c217626895dd0255226bafc784f34b7d17ad", "filename": "src/test/run-pass/const-cross-crate-extern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-cross-crate-extern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-cross-crate-extern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-cross-crate-extern.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -16,5 +16,5 @@ use cci_const::bar;\n static foo: *u8 = bar;\n \n pub fn main() {\n-    assert!(foo == cci_const::bar);\n+    assert_eq!(foo, cci_const::bar);\n }"}, {"sha": "b1797857d0410d04985fba6601b47991e35ee790", "filename": "src/test/run-pass/const-deref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-deref.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -15,6 +15,6 @@ static E: &'static S = &S(C);\n static F: int = ***E;\n \n pub fn main() {\n-    assert!(D == 1000);\n-    assert!(F == 1000);\n+    assert_eq!(D, 1000);\n+    assert_eq!(F, 1000);\n }"}, {"sha": "616c7567adf470cc3fa3729bf2eb5780a4be7886", "filename": "src/test/run-pass/const-enum-cast.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-enum-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-enum-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-cast.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -20,12 +20,12 @@ pub fn main () {\n     let a2 = B2 as int;\n     let a3 = A2 as float;\n     let a4 = B2 as float;\n-    assert!(c1 == 1);\n-    assert!(c2 == 2);\n-    assert!(c3 == 1.0);\n-    assert!(c4 == 2.0);\n-    assert!(a1 == 1);\n-    assert!(a2 == 2);\n-    assert!(a3 == 1.0);\n-    assert!(a4 == 2.0);\n+    assert_eq!(c1, 1);\n+    assert_eq!(c2, 2);\n+    assert_eq!(c3, 1.0);\n+    assert_eq!(c4, 2.0);\n+    assert_eq!(a1, 1);\n+    assert_eq!(a2, 2);\n+    assert_eq!(a3, 1.0);\n+    assert_eq!(a4, 2.0);\n }"}, {"sha": "3229293fd7a46c4203dc4d250b7f4cfb36cd4f79", "filename": "src/test/run-pass/const-enum-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-enum-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-enum-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-struct.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -15,5 +15,5 @@ static C: S = S { a: V16(0xDEAD), b: 0x600D, c: 0xBAD };\n pub fn main() {\n     let n = C.b;\n     assert!(n != 0xBAD);\n-    assert!(n == 0x600D);\n+    assert_eq!(n, 0x600D);\n }"}, {"sha": "4530a65002772d19cec41d2adda866050279ad9b", "filename": "src/test/run-pass/const-enum-struct2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-enum-struct2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-enum-struct2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-struct2.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -15,5 +15,5 @@ static C: S = S { a: V0, b: 0x600D, c: 0xBAD };\n pub fn main() {\n     let n = C.b;\n     assert!(n != 0xBAD);\n-    assert!(n == 0x600D);\n+    assert_eq!(n, 0x600D);\n }"}, {"sha": "17d8341457d357de0bf42e1d79ce0f3346dfebdb", "filename": "src/test/run-pass/const-enum-tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-enum-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-enum-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-tuple.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -14,5 +14,5 @@ static C: (E, u16, u16) = (V16(0xDEAD), 0x600D, 0xBAD);\n pub fn main() {\n     let (_, n, _) = C;\n     assert!(n != 0xBAD);\n-    assert!(n == 0x600D);\n+    assert_eq!(n, 0x600D);\n }"}, {"sha": "5d7a161720c183814395a4a350f32698b6826add", "filename": "src/test/run-pass/const-enum-tuple2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-enum-tuple2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-enum-tuple2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-tuple2.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -14,5 +14,5 @@ static C: (E, u16, u16) = (V0, 0x600D, 0xBAD);\n pub fn main() {\n     let (_, n, _) = C;\n     assert!(n != 0xBAD);\n-    assert!(n == 0x600D);\n+    assert_eq!(n, 0x600D);\n }"}, {"sha": "40137afa2eee233f1da69b406182be2bbd0de31b", "filename": "src/test/run-pass/const-enum-tuplestruct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-enum-tuplestruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-enum-tuplestruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-tuplestruct.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -15,5 +15,5 @@ static C: S = S(V16(0xDEAD), 0x600D, 0xBAD);\n pub fn main() {\n     let S(_, n, _) = C;\n     assert!(n != 0xBAD);\n-    assert!(n == 0x600D);\n+    assert_eq!(n, 0x600D);\n }"}, {"sha": "f6345efcb4348f958cfedbbeda3c7d69f8ac619a", "filename": "src/test/run-pass/const-enum-tuplestruct2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-enum-tuplestruct2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-enum-tuplestruct2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-tuplestruct2.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -15,5 +15,5 @@ static C: S = S(V0, 0x600D, 0xBAD);\n pub fn main() {\n     let S(_, n, _) = C;\n     assert!(n != 0xBAD);\n-    assert!(n == 0x600D);\n+    assert_eq!(n, 0x600D);\n }"}, {"sha": "9a8104cb14f719a3d2281dc3f424e21c7c9be4c1", "filename": "src/test/run-pass/const-extern-function.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-extern-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-extern-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-extern-function.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -18,6 +18,6 @@ struct S {\n }\n \n pub fn main() {\n-    assert!(foopy == f);\n-    assert!(f == s.f);\n+    assert_eq!(foopy, f);\n+    assert_eq!(f, s.f);\n }"}, {"sha": "ccc7b486d1ea220e75759692edc6704263d31bc3", "filename": "src/test/run-pass/const-fields-and-indexing.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-fields-and-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-fields-and-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-fields-and-indexing.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -28,7 +28,7 @@ pub fn main() {\n     io::println(fmt!(\"%?\", p));\n     io::println(fmt!(\"%?\", q));\n     io::println(fmt!(\"%?\", t));\n-    assert!(p == 3);\n-    assert!(q == 3);\n-    assert!(t == 20);\n+    assert_eq!(p, 3);\n+    assert_eq!(q, 3);\n+    assert_eq!(t, 20);\n }"}, {"sha": "dfcfb30f77ffbbb772325ed00881a825222f80de", "filename": "src/test/run-pass/const-fn-val.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-fn-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-fn-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-fn-val.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -17,5 +17,5 @@ struct Bar<'self> { f: &'self fn() -> int }\n static b : Bar<'static> = Bar { f: foo };\n \n pub fn main() {\n-    assert!((b.f)() == 0xca7f000d);\n+    assert_eq!((b.f)(), 0xca7f000d);\n }"}, {"sha": "4e2be013c11e4c3088cabdb358b8a10a078dd845", "filename": "src/test/run-pass/const-negative.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-negative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-negative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-negative.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -13,5 +13,5 @@\n static toplevel_mod: int = -1;\n \n pub fn main() {\n-    assert!(toplevel_mod == -1);\n+    assert_eq!(toplevel_mod, -1);\n }"}, {"sha": "30fbe38aed033f71af342dfce3a3c1f840ffb39e", "filename": "src/test/run-pass/const-nullary-univariant-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-nullary-univariant-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-nullary-univariant-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-nullary-univariant-enum.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -15,8 +15,8 @@ enum Foo {\n static X: Foo = Bar;\n \n pub fn main() {\n-    assert!(((X as uint) == 0xDEADBEE));\n-    assert!(((Y as uint) == 0xDEADBEE));\n+    assert_eq!((X as uint), 0xDEADBEE);\n+    assert_eq!((Y as uint), 0xDEADBEE);\n }\n \n static Y: Foo = Bar;"}, {"sha": "acb7fa2f0f4751576961a00d7a6da2cb016a1a68", "filename": "src/test/run-pass/const-rec-and-tup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-rec-and-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-rec-and-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-rec-and-tup.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -20,6 +20,6 @@ static y : AnotherPair = AnotherPair{ x: (0xf0f0f0f0_f0f0f0f0,\n \n pub fn main() {\n     let (p, _) = y.x;\n-    assert!(p == - 1085102592571150096);\n+    assert_eq!(p, - 1085102592571150096);\n     io::println(fmt!(\"0x%x\", p as uint));\n }"}, {"sha": "14397569ad97f45367ecac98024560708f18d3b4", "filename": "src/test/run-pass/const-region-ptrs-noncopy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -14,5 +14,5 @@ static x: &'static Big = &([13, 14, 10, 13, 11, 14, 14, 15]);\n static y: &'static Pair<'static> = &Pair {a: 15, b: x};\n \n pub fn main() {\n-    assert!(ptr::to_unsafe_ptr(x) == ptr::to_unsafe_ptr(y.b));\n+    assert_eq!(ptr::to_unsafe_ptr(x), ptr::to_unsafe_ptr(y.b));\n }"}, {"sha": "12712844c8a69900a036316b4ff79e4aac3578b4", "filename": "src/test/run-pass/const-region-ptrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-region-ptrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-region-ptrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-region-ptrs.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -18,6 +18,6 @@ static y: &'static Pair<'static> = &Pair {a: 15, b: x};\n pub fn main() {\n     io::println(fmt!(\"x = %?\", *x));\n     io::println(fmt!(\"y = {a: %?, b: %?}\", y.a, *(y.b)));\n-    assert!(*x == 10);\n-    assert!(*(y.b) == 10);\n+    assert_eq!(*x, 10);\n+    assert_eq!(*(y.b), 10);\n }"}, {"sha": "48eb4d6ce59b932e868fe9c02a1447e484570666", "filename": "src/test/run-pass/const-str-ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -14,9 +14,9 @@ static b: *u8 = c as *u8;\n \n pub fn main() {\n     let foo = &a as *u8;\n-    assert!(unsafe { str::raw::from_bytes(a) } == ~\"hi\\x00\");\n-    assert!(unsafe { str::raw::from_buf(foo) } == ~\"hi\");\n-    assert!(unsafe { str::raw::from_buf(b) } == ~\"hi\");\n+    assert_eq!(unsafe { str::raw::from_bytes(a) }, ~\"hi\\x00\");\n+    assert_eq!(unsafe { str::raw::from_buf(foo) }, ~\"hi\");\n+    assert_eq!(unsafe { str::raw::from_buf(b) }, ~\"hi\");\n     assert!(unsafe { *b == a[0] });\n     assert!(unsafe { *(&c[0] as *u8) == a[0] });\n }"}, {"sha": "24542f549228958088ebbb18bb46d1e31b2ebb09", "filename": "src/test/run-pass/const-struct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-struct.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -25,9 +25,9 @@ static y : foo = foo { b:2, c:3, a: 1 };\n static z : &'static foo = &foo { a: 10, b: 22, c: 12 };\n \n pub fn main() {\n-    assert!(x.b == 2);\n-    assert!(x == y);\n-    assert!(z.b == 22);\n+    assert_eq!(x.b, 2);\n+    assert_eq!(x, y);\n+    assert_eq!(z.b, 22);\n     io::println(fmt!(\"0x%x\", x.b as uint));\n     io::println(fmt!(\"0x%x\", z.c as uint));\n }"}, {"sha": "54116dd4082ed96221fbd9cfbbcacddc03305715", "filename": "src/test/run-pass/const-tuple-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-tuple-struct.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -15,8 +15,8 @@ static X: Bar = Bar(1, 2);\n pub fn main() {\n     match X {\n         Bar(x, y) => {\n-            assert!(x == 1);\n-            assert!(y == 2);\n+            assert_eq!(x, 1);\n+            assert_eq!(y, 2);\n         }\n     }\n }"}, {"sha": "134ee58042571b7aaa352b5d6152ddbe9e6fa310", "filename": "src/test/run-pass/const-vecs-and-slices.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-vecs-and-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconst-vecs-and-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-vecs-and-slices.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -14,7 +14,7 @@ static y : &'static [int] = &[1,2,3,4];\n pub fn main() {\n     io::println(fmt!(\"%?\", x[1]));\n     io::println(fmt!(\"%?\", y[1]));\n-    assert!(x[1] == 2);\n-    assert!(x[3] == 4);\n-    assert!(x[3] == y[3]);\n+    assert_eq!(x[1], 2);\n+    assert_eq!(x[3], 4);\n+    assert_eq!(x[3], y[3]);\n }"}, {"sha": "788c30562c182ad73b3aeb7642a99b2610b5abfc", "filename": "src/test/run-pass/consts-in-patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconsts-in-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fconsts-in-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts-in-patterns.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -18,5 +18,5 @@ pub fn main() {\n         BAR => 2,\n         _ => 3\n     };\n-    assert!(y == 2);\n+    assert_eq!(y, 2);\n }"}, {"sha": "737a60470ad3e310fec04a95576a0059c24988c7", "filename": "src/test/run-pass/crateresolve1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcrateresolve1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcrateresolve1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrateresolve1.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -16,5 +16,5 @@\n extern mod crateresolve1(vers = \"0.2\");\n \n pub fn main() {\n-    assert!(crateresolve1::f() == 20);\n+    assert_eq!(crateresolve1::f(), 20);\n }"}, {"sha": "883f48656bcf6344d0994f1da403baf2ed82012f", "filename": "src/test/run-pass/crateresolve6.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcrateresolve6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcrateresolve6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrateresolve6.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -18,6 +18,6 @@ extern mod cr6_1 (name = \"crateresolve_calories\", vers = \"0.1\", calories=\"100\");\n extern mod cr6_2 (name = \"crateresolve_calories\", vers = \"0.1\", calories=\"200\");\n \n pub fn main() {\n-    assert!(cr6_1::f() == 100);\n-    assert!(cr6_2::f() == 200);\n+    assert_eq!(cr6_1::f(), 100);\n+    assert_eq!(cr6_2::f(), 200);\n }"}, {"sha": "86fc72aa489c65b0e9da476d29c8cbfeda24619c", "filename": "src/test/run-pass/crateresolve7.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcrateresolve7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fcrateresolve7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrateresolve7.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -16,6 +16,6 @@\n extern mod crateresolve7x;\n \n pub fn main() {\n-    assert!(crateresolve7x::a::f() == 100);\n-    assert!(crateresolve7x::b::f() == 200);\n+    assert_eq!(crateresolve7x::a::f(), 100);\n+    assert_eq!(crateresolve7x::b::f(), 200);\n }"}, {"sha": "3c4fb6c8c81b1b033d275dbab6b3a6cba1bab5e4", "filename": "src/test/run-pass/deriving-via-extension-c-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fderiving-via-extension-c-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fderiving-via-extension-c-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-c-enum.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -18,7 +18,7 @@ enum Foo {\n pub fn main() {\n     let a = Bar;\n     let b = Bar;\n-    assert!(a == b);\n+    assert_eq!(a, b);\n     assert!(!(a != b));\n     assert!(a.eq(&b));\n     assert!(!a.ne(&b));"}, {"sha": "4044c58dc5711398e2ca521fc788a0688889c7fb", "filename": "src/test/run-pass/deriving-via-extension-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fderiving-via-extension-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fderiving-via-extension-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-enum.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -17,7 +17,7 @@ enum Foo {\n pub fn main() {\n     let a = Bar(1, 2);\n     let b = Bar(1, 2);\n-    assert!(a == b);\n+    assert_eq!(a, b);\n     assert!(!(a != b));\n     assert!(a.eq(&b));\n     assert!(!a.ne(&b));"}, {"sha": "8f6a319798626334dfbd514871202fd727bb9a9a", "filename": "src/test/run-pass/deriving-via-extension-struct-empty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-empty.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -12,6 +12,6 @@\n struct Foo;\n \n pub fn main() {\n-  assert!(Foo == Foo);\n+  assert_eq!(Foo, Foo);\n   assert!(!(Foo != Foo));\n }\n\\ No newline at end of file"}, {"sha": "5189136c4863fd2552804b2f3bba754ca0afc2c8", "filename": "src/test/run-pass/deriving-via-extension-struct-like-enum-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-like-enum-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-like-enum-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-like-enum-variant.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -6,6 +6,6 @@ enum S {\n \n pub fn main() {\n     let x = X { x: 1, y: 2 };\n-    assert!(x == x);\n+    assert_eq!(x, x);\n     assert!(!(x != x));\n }"}, {"sha": "cc76751e27f4b72b9357a671a69a94c5280c5224", "filename": "src/test/run-pass/deriving-via-extension-struct-tuple.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-tuple.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -17,10 +17,10 @@ pub fn main() {\n   let b = Foo(5, 7, ~\"def\");\n \n   assert!(a1 == a1);\n-  assert!(a1 == a2);\n+  assert!(a2 == a1);\n   assert!(!(a1 == b));\n \n   assert!(a1 != b);\n   assert!(!(a1 != a1));\n-  assert!(!(a1 != a2));\n+  assert!(!(a2 != a1));\n }"}, {"sha": "44aca59aa9c073775ab9563cde731a8557c0be9c", "filename": "src/test/run-pass/deriving-via-extension-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -18,7 +18,7 @@ struct Foo {\n pub fn main() {\n     let a = Foo { x: 1, y: 2, z: 3 };\n     let b = Foo { x: 1, y: 2, z: 3 };\n-    assert!(a == b);\n+    assert_eq!(a, b);\n     assert!(!(a != b));\n     assert!(a.eq(&b));\n     assert!(!a.ne(&b));"}, {"sha": "ecc30555162ac615ff295a0388bd06c27cbbf662", "filename": "src/test/run-pass/deriving-via-extension-type-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fderiving-via-extension-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fderiving-via-extension-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-type-params.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -21,7 +21,7 @@ struct Foo<T> {\n pub fn main() {\n     let a = Foo { x: 1, y: 2.0, z: 3 };\n     let b = Foo { x: 1, y: 2.0, z: 3 };\n-    assert!(a == b);\n+    assert_eq!(a, b);\n     assert!(!(a != b));\n     assert!(a.eq(&b));\n     assert!(!a.ne(&b));"}, {"sha": "3aeaef01e189b444af0b99f604f1320f6acde53a", "filename": "src/test/run-pass/div-mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fdiv-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fdiv-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdiv-mod.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -15,14 +15,14 @@\n pub fn main() {\n     let x: int = 15;\n     let y: int = 5;\n-    assert!((x / 5 == 3));\n-    assert!((x / 4 == 3));\n-    assert!((x / 3 == 5));\n-    assert!((x / y == 3));\n-    assert!((15 / y == 3));\n-    assert!((x % 5 == 0));\n-    assert!((x % 4 == 3));\n-    assert!((x % 3 == 0));\n-    assert!((x % y == 0));\n-    assert!((15 % y == 0));\n+    assert_eq!(x / 5, 3);\n+    assert_eq!(x / 4, 3);\n+    assert_eq!(x / 3, 5);\n+    assert_eq!(x / y, 3);\n+    assert_eq!(15 / y, 3);\n+    assert_eq!(x % 5, 0);\n+    assert_eq!(x % 4, 3);\n+    assert_eq!(x % 3, 0);\n+    assert_eq!(x % y, 0);\n+    assert_eq!(15 % y, 0);\n }"}, {"sha": "684a2c108eb81f6d9c75a19f9f52f89fb960569a", "filename": "src/test/run-pass/do2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fdo2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fdo2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdo2.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -11,5 +11,5 @@\n fn f(f: @fn(int) -> int) -> int { f(10) }\n \n pub fn main() {\n-    assert!(do f() |i| { i } == 10);\n+    assert_eq!(do f() |i| { i }, 10);\n }"}, {"sha": "b0d49fd2bdd924e006ba573253a81c1c5154c6a9", "filename": "src/test/run-pass/do3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fdo3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fdo3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdo3.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -11,5 +11,5 @@\n fn f(f: @fn(int) -> int) -> int { f(10) }\n \n pub fn main() {\n-    assert!(do f |i| { i } == 10);\n+    assert_eq!(do f |i| { i }, 10);\n }"}, {"sha": "a8822e9a3fcfd1c791807642d191162806706aa7", "filename": "src/test/run-pass/empty-tag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fempty-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fempty-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-tag.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -18,7 +18,7 @@ impl cmp::Eq for chan {\n }\n \n fn wrapper3(i: chan) {\n-    assert!(i == chan_t);\n+    assert_eq!(i, chan_t);\n }\n \n pub fn main() {"}, {"sha": "a851141322f00327c3119b0606fc498a34f90dc3", "filename": "src/test/run-pass/estr-slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Festr-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Festr-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Festr-slice.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -17,11 +17,11 @@ pub fn main() {\n     debug!(x);\n     debug!(y);\n \n-    assert!(x[0] == 'h' as u8);\n-    assert!(x[4] == 'o' as u8);\n+    assert_eq!(x[0], 'h' as u8);\n+    assert_eq!(x[4], 'o' as u8);\n \n     let z : &str = &\"thing\";\n-    assert!(v == x);\n+    assert_eq!(v, x);\n     assert!(x != z);\n \n     let a = &\"aaaa\";"}, {"sha": "a096a8456739e490fe1845ef146f9997b799d07f", "filename": "src/test/run-pass/estr-uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Festr-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Festr-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Festr-uniq.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -13,6 +13,6 @@ pub fn main() {\n     let _y : ~str = ~\"there\";\n     let mut z = ~\"thing\";\n     z = x;\n-    assert!(z[0] == ('h' as u8));\n-    assert!(z[4] == ('o' as u8));\n+    assert_eq!(z[0], ('h' as u8));\n+    assert_eq!(z[4], ('o' as u8));\n }"}, {"sha": "64c8a4caf80aee78197358ed1f63ed533046d3a9", "filename": "src/test/run-pass/evec-internal-boxes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fevec-internal-boxes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc57ca012a1f49875e19b1b089c91928dc339979/src%2Ftest%2Frun-pass%2Fevec-internal-boxes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fevec-internal-boxes.rs?ref=cc57ca012a1f49875e19b1b089c91928dc339979", "patch": "@@ -13,6 +13,6 @@ pub fn main() {\n     let _y : [@int, ..5] = [@1,@2,@3,@4,@5];\n     let mut z = [@1,@2,@3,@4,@5];\n     z = x;\n-    assert!(*z[0] == 1);\n-    assert!(*z[4] == 5);\n+    assert_eq!(*z[0], 1);\n+    assert_eq!(*z[4], 5);\n }"}]}