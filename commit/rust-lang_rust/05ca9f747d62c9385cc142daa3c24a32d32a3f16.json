{"sha": "05ca9f747d62c9385cc142daa3c24a32d32a3f16", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1Y2E5Zjc0N2Q2MmM5Mzg1Y2MxNDJkYWEzYzI0YTMyZDMyYTNmMTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-24T22:06:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-24T22:06:48Z"}, "message": "auto merge of #15024 : kmcallister/rust/lint, r=alexcrichton\n\nThis is a rebase of #14804 with two new commits on top to implement and test lint plugins.\r\n\r\nr? @alexcrichton @huonw: Can you take a look at the new commits, and also weigh in about any issues from the old PR that you feel are still unresolved? I'm leaving the old branch alone to preserve discussion history.", "tree": {"sha": "21cc221be93fe29694d665edfad1b0efbb05ff17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21cc221be93fe29694d665edfad1b0efbb05ff17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05ca9f747d62c9385cc142daa3c24a32d32a3f16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05ca9f747d62c9385cc142daa3c24a32d32a3f16", "html_url": "https://github.com/rust-lang/rust/commit/05ca9f747d62c9385cc142daa3c24a32d32a3f16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05ca9f747d62c9385cc142daa3c24a32d32a3f16/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87f3741fdf6356d57d22f8154cf6069a83dec8d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/87f3741fdf6356d57d22f8154cf6069a83dec8d7", "html_url": "https://github.com/rust-lang/rust/commit/87f3741fdf6356d57d22f8154cf6069a83dec8d7"}, {"sha": "7e694e71153ebc8d3f2be9c20783bb283e38a59e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e694e71153ebc8d3f2be9c20783bb283e38a59e", "html_url": "https://github.com/rust-lang/rust/commit/7e694e71153ebc8d3f2be9c20783bb283e38a59e"}], "stats": {"total": 5030, "additions": 2892, "deletions": 2138}, "files": [{"sha": "d815e3d8a86e66379b0b742a871ccab6aeae8dfa", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -19,7 +19,7 @@ use back;\n use back::link;\n use back::target_strs;\n use back::{arm, x86, x86_64, mips, mipsel};\n-use middle::lint;\n+use lint;\n \n use syntax::abi;\n use syntax::ast;\n@@ -70,7 +70,8 @@ pub struct Options {\n     pub gc: bool,\n     pub optimize: OptLevel,\n     pub debuginfo: DebugInfoLevel,\n-    pub lint_opts: Vec<(lint::Lint, lint::Level)> ,\n+    pub lint_opts: Vec<(String, lint::Level)>,\n+    pub describe_lints: bool,\n     pub output_types: Vec<back::link::OutputType> ,\n     // This was mutable for rustpkg, which updates search paths based on the\n     // parsed code. It remains mutable in case its replacements wants to use\n@@ -104,6 +105,7 @@ pub fn basic_options() -> Options {\n         optimize: No,\n         debuginfo: NoDebugInfo,\n         lint_opts: Vec::new(),\n+        describe_lints: false,\n         output_types: Vec::new(),\n         addl_lib_search_paths: RefCell::new(HashSet::new()),\n         maybe_sysroot: None,\n@@ -585,30 +587,15 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let no_trans = matches.opt_present(\"no-trans\");\n     let no_analysis = matches.opt_present(\"no-analysis\");\n \n-    let lint_levels = [lint::Allow, lint::Warn,\n-                       lint::Deny, lint::Forbid];\n-    let mut lint_opts = Vec::new();\n-    let lint_dict = lint::get_lint_dict();\n-    for level in lint_levels.iter() {\n-        let level_name = lint::level_to_str(*level);\n-\n-        let level_short = level_name.slice_chars(0, 1);\n-        let level_short = level_short.to_ascii().to_upper().into_str();\n-        let flags = matches.opt_strs(level_short.as_slice())\n-                           .move_iter()\n-                           .collect::<Vec<_>>()\n-                           .append(matches.opt_strs(level_name).as_slice());\n-        for lint_name in flags.iter() {\n-            let lint_name = lint_name.replace(\"-\", \"_\").into_string();\n-            match lint_dict.find_equiv(&lint_name) {\n-              None => {\n-                early_error(format!(\"unknown {} flag: {}\",\n-                                    level_name,\n-                                    lint_name).as_slice());\n-              }\n-              Some(lint) => {\n-                lint_opts.push((lint.lint, *level));\n-              }\n+    let mut lint_opts = vec!();\n+    let mut describe_lints = false;\n+\n+    for &level in [lint::Allow, lint::Warn, lint::Deny, lint::Forbid].iter() {\n+        for lint_name in matches.opt_strs(level.as_str()).move_iter() {\n+            if lint_name.as_slice() == \"help\" {\n+                describe_lints = true;\n+            } else {\n+                lint_opts.push((lint_name.replace(\"-\", \"_\").into_string(), level));\n             }\n         }\n     }\n@@ -752,6 +739,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         optimize: opt_level,\n         debuginfo: debuginfo,\n         lint_opts: lint_opts,\n+        describe_lints: describe_lints,\n         output_types: output_types,\n         addl_lib_search_paths: RefCell::new(addl_lib_search_paths),\n         maybe_sysroot: sysroot_opt,"}, {"sha": "9a7be85bdd7479f53eed78aa442b148f7a13885c", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -20,12 +20,13 @@ use metadata::common::LinkMeta;\n use metadata::creader;\n use middle::cfg;\n use middle::cfg::graphviz::LabelledCFG;\n-use middle::{trans, freevars, stability, kind, ty, typeck, lint, reachable};\n+use middle::{trans, freevars, stability, kind, ty, typeck, reachable};\n use middle::dependency_format;\n use middle;\n use plugin::load::Plugins;\n use plugin::registry::Registry;\n use plugin;\n+use lint;\n use util::common::time;\n use util::ppaux;\n use util::nodemap::{NodeSet};\n@@ -78,8 +79,12 @@ pub fn compile_input(sess: Session,\n                                                  &sess);\n             let id = link::find_crate_id(krate.attrs.as_slice(),\n                                          outputs.out_filestem.as_slice());\n-            let (expanded_crate, ast_map) =\n-                phase_2_configure_and_expand(&sess, krate, &id);\n+            let (expanded_crate, ast_map)\n+                = match phase_2_configure_and_expand(&sess, krate, &id) {\n+                    None => return,\n+                    Some(p) => p,\n+                };\n+\n             (outputs, expanded_crate, ast_map)\n         };\n         write_out_deps(&sess, input, &outputs, &expanded_crate);\n@@ -172,10 +177,12 @@ pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n /// syntax expansion, secondary `cfg` expansion, synthesis of a test\n /// harness if one is to be provided and injection of a dependency on the\n /// standard library and prelude.\n+///\n+/// Returns `None` if we're aborting after handling -W help.\n pub fn phase_2_configure_and_expand(sess: &Session,\n                                     mut krate: ast::Crate,\n                                     crate_id: &CrateId)\n-                                    -> (ast::Crate, syntax::ast_map::Map) {\n+                                    -> Option<(ast::Crate, syntax::ast_map::Map)> {\n     let time_passes = sess.time_passes();\n \n     *sess.crate_types.borrow_mut() = collect_crate_types(sess, krate.attrs.as_slice());\n@@ -209,7 +216,24 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         }\n     });\n \n-    let Registry { syntax_exts, .. } = registry;\n+    let Registry { syntax_exts, lint_passes, .. } = registry;\n+\n+    {\n+        let mut ls = sess.lint_store.borrow_mut();\n+        for pass in lint_passes.move_iter() {\n+            ls.register_pass(Some(sess), true, pass);\n+        }\n+    }\n+\n+    // Lint plugins are registered; now we can process command line flags.\n+    if sess.opts.describe_lints {\n+        super::describe_lints(&*sess.lint_store.borrow(), true);\n+        return None;\n+    }\n+    sess.lint_store.borrow_mut().process_command_line(sess);\n+\n+    // Abort if there are errors from lint processing or a plugin registrar.\n+    sess.abort_if_errors();\n \n     krate = time(time_passes, \"expansion\", (krate, macros, syntax_exts),\n         |(krate, macros, syntax_exts)| {\n@@ -253,7 +277,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         krate.encode(&mut json).unwrap();\n     }\n \n-    (krate, map)\n+    Some((krate, map))\n }\n \n pub struct CrateAnalysis {\n@@ -366,7 +390,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n     });\n \n     time(time_passes, \"lint checking\", (), |_|\n-         lint::check_crate(&ty_cx, &exported_items, krate));\n+         lint::check_crate(&ty_cx, krate, &exported_items));\n \n     CrateAnalysis {\n         exp_map2: exp_map2,\n@@ -630,9 +654,11 @@ pub fn pretty_print_input(sess: Session,\n \n     let (krate, ast_map, is_expanded) = match ppm {\n         PpmExpanded | PpmExpandedIdentified | PpmTyped | PpmFlowGraph(_) => {\n-            let (krate, ast_map) = phase_2_configure_and_expand(&sess,\n-                                                                krate,\n-                                                                &id);\n+            let (krate, ast_map)\n+                = match phase_2_configure_and_expand(&sess, krate, &id) {\n+                    None => return,\n+                    Some(p) => p,\n+                };\n             (krate, Some(ast_map), true)\n         }\n         _ => (krate, None, false)\n@@ -766,15 +792,15 @@ pub fn collect_crate_types(session: &Session,\n                 }\n                 Some(ref n) if n.equiv(&(\"bin\")) => Some(config::CrateTypeExecutable),\n                 Some(_) => {\n-                    session.add_lint(lint::UnknownCrateType,\n+                    session.add_lint(lint::builtin::UNKNOWN_CRATE_TYPE,\n                                      ast::CRATE_NODE_ID,\n                                      a.span,\n                                      \"invalid `crate_type` \\\n                                       value\".to_string());\n                     None\n                 }\n                 _ => {\n-                    session.add_lint(lint::UnknownCrateType,\n+                    session.add_lint(lint::builtin::UNKNOWN_CRATE_TYPE,\n                                      ast::CRATE_NODE_ID,\n                                      a.span,\n                                      \"`crate_type` requires a \\"}, {"sha": "cfde4ad52afa6c9556a44959c5fa13525bbedc62", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 65, "deletions": 35, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -13,11 +13,11 @@ pub use syntax::diagnostic;\n use back::link;\n use driver::driver::{Input, FileInput, StrInput};\n use driver::session::{Session, build_session};\n-use middle::lint;\n+use lint::Lint;\n+use lint;\n use metadata;\n \n use std::any::AnyRefExt;\n-use std::cmp;\n use std::io;\n use std::os;\n use std::str;\n@@ -49,9 +49,18 @@ fn run_compiler(args: &[String]) {\n         Some(matches) => matches,\n         None => return\n     };\n+    let sopts = config::build_session_options(&matches);\n \n     let (input, input_file_path) = match matches.free.len() {\n-        0u => early_error(\"no input filename given\"),\n+        0u => {\n+            if sopts.describe_lints {\n+                let mut ls = lint::LintStore::new();\n+                ls.register_builtin(None);\n+                describe_lints(&ls, false);\n+                return;\n+            }\n+            early_error(\"no input filename given\");\n+        }\n         1u => {\n             let ifile = matches.free.get(0).as_slice();\n             if ifile == \"-\" {\n@@ -66,7 +75,6 @@ fn run_compiler(args: &[String]) {\n         _ => early_error(\"multiple input filenames provided\")\n     };\n \n-    let sopts = config::build_session_options(&matches);\n     let sess = build_session(sopts, input_file_path);\n     let cfg = config::build_configuration(&sess);\n     let odir = matches.opt_str(\"out-dir\").map(|o| Path::new(o));\n@@ -124,41 +132,68 @@ Additional help:\n                              config::optgroups().as_slice()));\n }\n \n-fn describe_warnings() {\n+fn describe_lints(lint_store: &lint::LintStore, loaded_plugins: bool) {\n     println!(\"\n Available lint options:\n     -W <foo>           Warn about <foo>\n     -A <foo>           Allow <foo>\n     -D <foo>           Deny <foo>\n     -F <foo>           Forbid <foo> (deny, and deny all overrides)\n-\");\n \n-    let lint_dict = lint::get_lint_dict();\n-    let mut lint_dict = lint_dict.move_iter()\n-                                 .map(|(k, v)| (v, k))\n-                                 .collect::<Vec<(lint::LintSpec, &'static str)> >();\n-    lint_dict.as_mut_slice().sort();\n+\");\n \n-    let mut max_key = 0;\n-    for &(_, name) in lint_dict.iter() {\n-        max_key = cmp::max(name.len(), max_key);\n-    }\n-    fn padded(max: uint, s: &str) -> String {\n-        format!(\"{}{}\", \" \".repeat(max - s.len()), s)\n+    fn sort_lints(lints: Vec<(&'static Lint, bool)>) -> Vec<&'static Lint> {\n+        let mut lints: Vec<_> = lints.move_iter().map(|(x, _)| x).collect();\n+        lints.sort_by(|x: &&Lint, y: &&Lint| {\n+            match x.default_level.cmp(&y.default_level) {\n+                // The sort doesn't case-fold but it's doubtful we care.\n+                Equal => x.name.cmp(&y.name),\n+                r => r,\n+            }\n+        });\n+        lints\n     }\n-    println!(\"\\nAvailable lint checks:\\n\");\n-    println!(\"    {}  {:7.7s}  {}\",\n-             padded(max_key, \"name\"), \"default\", \"meaning\");\n-    println!(\"    {}  {:7.7s}  {}\\n\",\n-             padded(max_key, \"----\"), \"-------\", \"-------\");\n-    for (spec, name) in lint_dict.move_iter() {\n-        let name = name.replace(\"_\", \"-\");\n-        println!(\"    {}  {:7.7s}  {}\",\n-                 padded(max_key, name.as_slice()),\n-                 lint::level_to_str(spec.default),\n-                 spec.desc);\n+\n+    let (plugin, builtin) = lint_store.get_lints().partitioned(|&(_, p)| p);\n+    let plugin = sort_lints(plugin);\n+    let builtin = sort_lints(builtin);\n+\n+    // FIXME (#7043): We should use the width in character cells rather than\n+    // the number of codepoints.\n+    let max_name_len = plugin.iter().chain(builtin.iter())\n+        .map(|&s| s.name.char_len())\n+        .max().unwrap_or(0);\n+    let padded = |x: &str| {\n+        \" \".repeat(max_name_len - x.char_len()).append(x)\n+    };\n+\n+    println!(\"Lint checks provided by rustc:\\n\");\n+    println!(\"    {}  {:7.7s}  {}\", padded(\"name\"), \"default\", \"meaning\");\n+    println!(\"    {}  {:7.7s}  {}\", padded(\"----\"), \"-------\", \"-------\");\n+\n+    let print_lints = |lints: Vec<&Lint>| {\n+        for lint in lints.move_iter() {\n+            let name = lint.name_lower().replace(\"_\", \"-\");\n+            println!(\"    {}  {:7.7s}  {}\",\n+                     padded(name.as_slice()), lint.default_level.as_str(), lint.desc);\n+        }\n+        println!(\"\\n\");\n+    };\n+\n+    print_lints(builtin);\n+\n+    match (loaded_plugins, plugin.len()) {\n+        (false, 0) => {\n+            println!(\"Compiler plugins can provide additional lints. To see a listing of these, \\\n+                      re-run `rustc -W help` with a crate filename.\");\n+        }\n+        (false, _) => fail!(\"didn't load lint plugins but got them anyway!\"),\n+        (true, 0) => println!(\"This crate does not load any lint plugins.\"),\n+        (true, _) => {\n+            println!(\"Lint checks provided by plugins loaded by this crate:\\n\");\n+            print_lints(plugin);\n+        }\n     }\n-    println!(\"\");\n }\n \n fn describe_debug_flags() {\n@@ -214,12 +249,7 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n         return None;\n     }\n \n-    let lint_flags = matches.opt_strs(\"W\").move_iter().collect::<Vec<_>>().append(\n-                                    matches.opt_strs(\"warn\").as_slice());\n-    if lint_flags.iter().any(|x| x.as_slice() == \"help\") {\n-        describe_warnings();\n-        return None;\n-    }\n+    // Don't handle -W help here, because we might first load plugins.\n \n     let r = matches.opt_strs(\"Z\");\n     if r.iter().any(|x| x.as_slice() == \"help\") {"}, {"sha": "07366f34c4e03d7018c1821d408645025f59ccee", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -14,7 +14,7 @@ use driver::driver;\n use front;\n use metadata::cstore::CStore;\n use metadata::filesearch;\n-use middle::lint;\n+use lint;\n use util::nodemap::NodeMap;\n \n use syntax::ast::NodeId;\n@@ -43,7 +43,8 @@ pub struct Session {\n     // expected to be absolute. `None` means that there is no source file.\n     pub local_crate_source_file: Option<Path>,\n     pub working_dir: Path,\n-    pub lints: RefCell<NodeMap<Vec<(lint::Lint, codemap::Span, String)>>>,\n+    pub lint_store: RefCell<lint::LintStore>,\n+    pub lints: RefCell<NodeMap<Vec<(lint::LintId, codemap::Span, String)>>>,\n     pub node_id: Cell<ast::NodeId>,\n     pub crate_types: RefCell<Vec<config::CrateType>>,\n     pub features: front::feature_gate::Features,\n@@ -106,16 +107,17 @@ impl Session {\n         self.diagnostic().handler().unimpl(msg)\n     }\n     pub fn add_lint(&self,\n-                    lint: lint::Lint,\n+                    lint: &'static lint::Lint,\n                     id: ast::NodeId,\n                     sp: Span,\n                     msg: String) {\n+        let lint_id = lint::LintId::of(lint);\n         let mut lints = self.lints.borrow_mut();\n         match lints.find_mut(&id) {\n-            Some(arr) => { arr.push((lint, sp, msg)); return; }\n+            Some(arr) => { arr.push((lint_id, sp, msg)); return; }\n             None => {}\n         }\n-        lints.insert(id, vec!((lint, sp, msg)));\n+        lints.insert(id, vec!((lint_id, sp, msg)));\n     }\n     pub fn next_node_id(&self) -> ast::NodeId {\n         self.reserve_node_ids(1)\n@@ -225,7 +227,7 @@ pub fn build_session_(sopts: config::Options,\n         }\n     );\n \n-    Session {\n+    let sess = Session {\n         targ_cfg: target_cfg,\n         opts: sopts,\n         cstore: CStore::new(token::get_ident_interner()),\n@@ -237,12 +239,16 @@ pub fn build_session_(sopts: config::Options,\n         default_sysroot: default_sysroot,\n         local_crate_source_file: local_crate_source_file,\n         working_dir: os::getcwd(),\n+        lint_store: RefCell::new(lint::LintStore::new()),\n         lints: RefCell::new(NodeMap::new()),\n         node_id: Cell::new(1),\n         crate_types: RefCell::new(Vec::new()),\n         features: front::feature_gate::Features::new(),\n         recursion_limit: Cell::new(64),\n-    }\n+    };\n+\n+    sess.lint_store.borrow_mut().register_builtin(Some(&sess));\n+    sess\n }\n \n // Seems out of place, but it uses session, so I'm putting it here"}, {"sha": "89697dc1674fa625968ade04f59597b23dae7a35", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -18,7 +18,7 @@\n //! Features are enabled in programs via the crate-level attributes of\n //! `#![feature(...)]` with a comma-separated list of features.\n \n-use middle::lint;\n+use lint;\n \n use syntax::abi::RustIntrinsic;\n use syntax::ast::NodeId;\n@@ -409,7 +409,7 @@ pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n                                                      directive not necessary\");\n                         }\n                         None => {\n-                            sess.add_lint(lint::UnknownFeatures,\n+                            sess.add_lint(lint::builtin::UNKNOWN_FEATURES,\n                                           ast::CRATE_NODE_ID,\n                                           mi.span,\n                                           \"unknown feature\".to_string());"}, {"sha": "0703b1fab603e2d0ddbd4245c98c2257fafad084", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -56,7 +56,6 @@ pub mod middle {\n     pub mod check_match;\n     pub mod check_const;\n     pub mod check_static;\n-    pub mod lint;\n     pub mod borrowck;\n     pub mod dataflow;\n     pub mod mem_categorization;\n@@ -113,6 +112,8 @@ pub mod driver;\n \n pub mod plugin;\n \n+pub mod lint;\n+\n pub mod util {\n     pub mod common;\n     pub mod ppaux;\n@@ -126,6 +127,15 @@ pub mod lib {\n     pub mod llvmdeps;\n }\n \n+// A private module so that macro-expanded idents like\n+// `::rustc::lint::Lint` will also work in `rustc` itself.\n+//\n+// `libstd` uses the same trick.\n+#[doc(hidden)]\n+mod rustc {\n+    pub use lint;\n+}\n+\n pub fn main() {\n     let args = std::os::args().iter()\n                               .map(|x| x.to_string())"}, {"sha": "5078ae80d75c1157f7d3da871d8535fa64ff4e7f", "filename": "src/librustc/lint/builtin.rs", "status": "added", "additions": 1501, "deletions": 0, "changes": 1501, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -0,0 +1,1501 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Lints built in to rustc.\n+//!\n+//! This is a sibling of `lint::context` in order to ensure that\n+//! lints implemented here use the same public API as lint plugins.\n+//!\n+//! To add a new lint to rustc, declare it here using `declare_lint!()`.\n+//! Then add code to emit the new lint in the appropriate circumstances.\n+//! You can do that in an existing `LintPass` if it makes sense, or in\n+//! a new `LintPass`, or using `Session::add_lint` elsewhere in the\n+//! compiler. Only do the latter if the check can't be written cleanly\n+//! as a `LintPass`.\n+//!\n+//! If you define a new `LintPass`, you will also need to add it to the\n+//! `add_builtin!` or `add_builtin_with_new!` invocation in `context.rs`.\n+//! Use the former for unit-like structs and the latter for structs with\n+//! a `pub fn new()`.\n+\n+use metadata::csearch;\n+use middle::def::*;\n+use middle::trans::adt; // for `adt::is_ffi_safe`\n+use middle::typeck::astconv::ast_ty_to_ty;\n+use middle::typeck::infer;\n+use middle::{typeck, ty, def, pat_util};\n+use util::ppaux::{ty_to_str};\n+use util::nodemap::NodeSet;\n+use lint::{Context, LintPass, LintArray};\n+\n+use std::cmp;\n+use std::collections::HashMap;\n+use std::i16;\n+use std::i32;\n+use std::i64;\n+use std::i8;\n+use std::u16;\n+use std::u32;\n+use std::u64;\n+use std::u8;\n+use std::gc::Gc;\n+use syntax::abi;\n+use syntax::ast_map;\n+use syntax::attr::AttrMetaMethods;\n+use syntax::attr;\n+use syntax::codemap::Span;\n+use syntax::parse::token;\n+use syntax::{ast, ast_util, visit};\n+\n+declare_lint!(WHILE_TRUE, Warn,\n+              \"suggest using `loop { }` instead of `while true { }`\")\n+\n+pub struct WhileTrue;\n+\n+impl LintPass for WhileTrue {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(WHILE_TRUE)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        match e.node {\n+            ast::ExprWhile(cond, _) => {\n+                match cond.node {\n+                    ast::ExprLit(lit) => {\n+                        match lit.node {\n+                            ast::LitBool(true) => {\n+                                cx.span_lint(WHILE_TRUE, e.span,\n+                                             \"denote infinite loops with loop \\\n+                                              { ... }\");\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+                    _ => ()\n+                }\n+            }\n+            _ => ()\n+        }\n+    }\n+}\n+\n+declare_lint!(UNNECESSARY_TYPECAST, Allow,\n+              \"detects unnecessary type casts, that can be removed\")\n+\n+pub struct UnusedCasts;\n+\n+impl LintPass for UnusedCasts {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNNECESSARY_TYPECAST)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        match e.node {\n+            ast::ExprCast(expr, ty) => {\n+                let t_t = ast_ty_to_ty(cx, &infer::new_infer_ctxt(cx.tcx), &*ty);\n+                if ty::get(ty::expr_ty(cx.tcx, &*expr)).sty == ty::get(t_t).sty {\n+                    cx.span_lint(UNNECESSARY_TYPECAST, ty.span, \"unnecessary type cast\");\n+                }\n+            }\n+            _ => ()\n+        }\n+    }\n+}\n+\n+declare_lint!(UNSIGNED_NEGATE, Warn,\n+              \"using an unary minus operator on unsigned type\")\n+\n+declare_lint!(TYPE_LIMITS, Warn,\n+              \"comparisons made useless by limits of the types involved\")\n+\n+declare_lint!(TYPE_OVERFLOW, Warn,\n+              \"literal out of range for its type\")\n+\n+pub struct TypeLimits {\n+    /// Id of the last visited negated expression\n+    negated_expr_id: ast::NodeId,\n+}\n+\n+impl TypeLimits {\n+    pub fn new() -> TypeLimits {\n+        TypeLimits {\n+            negated_expr_id: -1,\n+        }\n+    }\n+}\n+\n+impl LintPass for TypeLimits {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNSIGNED_NEGATE, TYPE_LIMITS, TYPE_OVERFLOW)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        match e.node {\n+            ast::ExprUnary(ast::UnNeg, expr) => {\n+                match expr.node  {\n+                    ast::ExprLit(lit) => {\n+                        match lit.node {\n+                            ast::LitUint(..) => {\n+                                cx.span_lint(UNSIGNED_NEGATE, e.span,\n+                                             \"negation of unsigned int literal may \\\n+                                             be unintentional\");\n+                            },\n+                            _ => ()\n+                        }\n+                    },\n+                    _ => {\n+                        let t = ty::expr_ty(cx.tcx, &*expr);\n+                        match ty::get(t).sty {\n+                            ty::ty_uint(_) => {\n+                                cx.span_lint(UNSIGNED_NEGATE, e.span,\n+                                             \"negation of unsigned int variable may \\\n+                                             be unintentional\");\n+                            },\n+                            _ => ()\n+                        }\n+                    }\n+                };\n+                // propagate negation, if the negation itself isn't negated\n+                if self.negated_expr_id != e.id {\n+                    self.negated_expr_id = expr.id;\n+                }\n+            },\n+            ast::ExprParen(expr) if self.negated_expr_id == e.id => {\n+                self.negated_expr_id = expr.id;\n+            },\n+            ast::ExprBinary(binop, l, r) => {\n+                if is_comparison(binop) && !check_limits(cx.tcx, binop, &*l, &*r) {\n+                    cx.span_lint(TYPE_LIMITS, e.span,\n+                                 \"comparison is useless due to type limits\");\n+                }\n+            },\n+            ast::ExprLit(lit) => {\n+                match ty::get(ty::expr_ty(cx.tcx, e)).sty {\n+                    ty::ty_int(t) => {\n+                        let int_type = if t == ast::TyI {\n+                            cx.sess().targ_cfg.int_type\n+                        } else { t };\n+                        let (min, max) = int_ty_range(int_type);\n+                        let mut lit_val: i64 = match lit.node {\n+                            ast::LitInt(v, _) => v,\n+                            ast::LitUint(v, _) => v as i64,\n+                            ast::LitIntUnsuffixed(v) => v,\n+                            _ => fail!()\n+                        };\n+                        if self.negated_expr_id == e.id {\n+                            lit_val *= -1;\n+                        }\n+                        if  lit_val < min || lit_val > max {\n+                            cx.span_lint(TYPE_OVERFLOW, e.span,\n+                                         \"literal out of range for its type\");\n+                        }\n+                    },\n+                    ty::ty_uint(t) => {\n+                        let uint_type = if t == ast::TyU {\n+                            cx.sess().targ_cfg.uint_type\n+                        } else { t };\n+                        let (min, max) = uint_ty_range(uint_type);\n+                        let lit_val: u64 = match lit.node {\n+                            ast::LitByte(_v) => return,  // _v is u8, within range by definition\n+                            ast::LitInt(v, _) => v as u64,\n+                            ast::LitUint(v, _) => v,\n+                            ast::LitIntUnsuffixed(v) => v as u64,\n+                            _ => fail!()\n+                        };\n+                        if  lit_val < min || lit_val > max {\n+                            cx.span_lint(TYPE_OVERFLOW, e.span,\n+                                         \"literal out of range for its type\");\n+                        }\n+                    },\n+\n+                    _ => ()\n+                };\n+            },\n+            _ => ()\n+        };\n+\n+        fn is_valid<T:cmp::PartialOrd>(binop: ast::BinOp, v: T,\n+                                min: T, max: T) -> bool {\n+            match binop {\n+                ast::BiLt => v >  min && v <= max,\n+                ast::BiLe => v >= min && v <  max,\n+                ast::BiGt => v >= min && v <  max,\n+                ast::BiGe => v >  min && v <= max,\n+                ast::BiEq | ast::BiNe => v >= min && v <= max,\n+                _ => fail!()\n+            }\n+        }\n+\n+        fn rev_binop(binop: ast::BinOp) -> ast::BinOp {\n+            match binop {\n+                ast::BiLt => ast::BiGt,\n+                ast::BiLe => ast::BiGe,\n+                ast::BiGt => ast::BiLt,\n+                ast::BiGe => ast::BiLe,\n+                _ => binop\n+            }\n+        }\n+\n+        // for int & uint, be conservative with the warnings, so that the\n+        // warnings are consistent between 32- and 64-bit platforms\n+        fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n+            match int_ty {\n+                ast::TyI =>    (i64::MIN,        i64::MAX),\n+                ast::TyI8 =>   (i8::MIN  as i64, i8::MAX  as i64),\n+                ast::TyI16 =>  (i16::MIN as i64, i16::MAX as i64),\n+                ast::TyI32 =>  (i32::MIN as i64, i32::MAX as i64),\n+                ast::TyI64 =>  (i64::MIN,        i64::MAX)\n+            }\n+        }\n+\n+        fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n+            match uint_ty {\n+                ast::TyU =>   (u64::MIN,         u64::MAX),\n+                ast::TyU8 =>  (u8::MIN   as u64, u8::MAX   as u64),\n+                ast::TyU16 => (u16::MIN  as u64, u16::MAX  as u64),\n+                ast::TyU32 => (u32::MIN  as u64, u32::MAX  as u64),\n+                ast::TyU64 => (u64::MIN,         u64::MAX)\n+            }\n+        }\n+\n+        fn check_limits(tcx: &ty::ctxt, binop: ast::BinOp,\n+                        l: &ast::Expr, r: &ast::Expr) -> bool {\n+            let (lit, expr, swap) = match (&l.node, &r.node) {\n+                (&ast::ExprLit(_), _) => (l, r, true),\n+                (_, &ast::ExprLit(_)) => (r, l, false),\n+                _ => return true\n+            };\n+            // Normalize the binop so that the literal is always on the RHS in\n+            // the comparison\n+            let norm_binop = if swap { rev_binop(binop) } else { binop };\n+            match ty::get(ty::expr_ty(tcx, expr)).sty {\n+                ty::ty_int(int_ty) => {\n+                    let (min, max) = int_ty_range(int_ty);\n+                    let lit_val: i64 = match lit.node {\n+                        ast::ExprLit(li) => match li.node {\n+                            ast::LitInt(v, _) => v,\n+                            ast::LitUint(v, _) => v as i64,\n+                            ast::LitIntUnsuffixed(v) => v,\n+                            _ => return true\n+                        },\n+                        _ => fail!()\n+                    };\n+                    is_valid(norm_binop, lit_val, min, max)\n+                }\n+                ty::ty_uint(uint_ty) => {\n+                    let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n+                    let lit_val: u64 = match lit.node {\n+                        ast::ExprLit(li) => match li.node {\n+                            ast::LitInt(v, _) => v as u64,\n+                            ast::LitUint(v, _) => v,\n+                            ast::LitIntUnsuffixed(v) => v as u64,\n+                            _ => return true\n+                        },\n+                        _ => fail!()\n+                    };\n+                    is_valid(norm_binop, lit_val, min, max)\n+                }\n+                _ => true\n+            }\n+        }\n+\n+        fn is_comparison(binop: ast::BinOp) -> bool {\n+            match binop {\n+                ast::BiEq | ast::BiLt | ast::BiLe |\n+                ast::BiNe | ast::BiGe | ast::BiGt => true,\n+                _ => false\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint!(CTYPES, Warn,\n+              \"proper use of libc types in foreign modules\")\n+\n+pub struct CTypes;\n+\n+impl LintPass for CTypes {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(CTYPES)\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        fn check_ty(cx: &Context, ty: &ast::Ty) {\n+            match ty.node {\n+                ast::TyPath(_, _, id) => {\n+                    match cx.tcx.def_map.borrow().get_copy(&id) {\n+                        def::DefPrimTy(ast::TyInt(ast::TyI)) => {\n+                            cx.span_lint(CTYPES, ty.span,\n+                                         \"found rust type `int` in foreign module, while \\\n+                                          libc::c_int or libc::c_long should be used\");\n+                        }\n+                        def::DefPrimTy(ast::TyUint(ast::TyU)) => {\n+                            cx.span_lint(CTYPES, ty.span,\n+                                         \"found rust type `uint` in foreign module, while \\\n+                                          libc::c_uint or libc::c_ulong should be used\");\n+                        }\n+                        def::DefTy(def_id) => {\n+                            if !adt::is_ffi_safe(cx.tcx, def_id) {\n+                                cx.span_lint(CTYPES, ty.span,\n+                                             \"found enum type without foreign-function-safe \\\n+                                              representation annotation in foreign module\");\n+                                // hmm... this message could be more helpful\n+                            }\n+                        }\n+                        _ => ()\n+                    }\n+                }\n+                ast::TyPtr(ref mt) => { check_ty(cx, &*mt.ty) }\n+                _ => {}\n+            }\n+        }\n+\n+        fn check_foreign_fn(cx: &Context, decl: &ast::FnDecl) {\n+            for input in decl.inputs.iter() {\n+                check_ty(cx, &*input.ty);\n+            }\n+            check_ty(cx, &*decl.output)\n+        }\n+\n+        match it.node {\n+          ast::ItemForeignMod(ref nmod) if nmod.abi != abi::RustIntrinsic => {\n+            for ni in nmod.items.iter() {\n+                match ni.node {\n+                    ast::ForeignItemFn(decl, _) => check_foreign_fn(cx, &*decl),\n+                    ast::ForeignItemStatic(t, _) => check_ty(cx, &*t)\n+                }\n+            }\n+          }\n+          _ => {/* nothing to do */ }\n+        }\n+    }\n+}\n+\n+declare_lint!(MANAGED_HEAP_MEMORY, Allow,\n+              \"use of managed (@ type) heap memory\")\n+\n+declare_lint!(OWNED_HEAP_MEMORY, Allow,\n+              \"use of owned (Box type) heap memory\")\n+\n+declare_lint!(HEAP_MEMORY, Allow,\n+              \"use of any (Box type or @ type) heap memory\")\n+\n+pub struct HeapMemory;\n+\n+impl HeapMemory {\n+    fn check_heap_type(&self, cx: &Context, span: Span, ty: ty::t) {\n+        let mut n_box = 0;\n+        let mut n_uniq = 0;\n+        ty::fold_ty(cx.tcx, ty, |t| {\n+            match ty::get(t).sty {\n+                ty::ty_box(_) => {\n+                    n_box += 1;\n+                }\n+                ty::ty_uniq(_) |\n+                ty::ty_closure(box ty::ClosureTy {\n+                    store: ty::UniqTraitStore,\n+                    ..\n+                }) => {\n+                    n_uniq += 1;\n+                }\n+\n+                _ => ()\n+            };\n+            t\n+        });\n+\n+        if n_uniq > 0 {\n+            let s = ty_to_str(cx.tcx, ty);\n+            let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n+            cx.span_lint(OWNED_HEAP_MEMORY, span, m.as_slice());\n+            cx.span_lint(HEAP_MEMORY, span, m.as_slice());\n+        }\n+\n+        if n_box > 0 {\n+            let s = ty_to_str(cx.tcx, ty);\n+            let m = format!(\"type uses managed (@ type) pointers: {}\", s);\n+            cx.span_lint(MANAGED_HEAP_MEMORY, span, m.as_slice());\n+            cx.span_lint(HEAP_MEMORY, span, m.as_slice());\n+        }\n+    }\n+}\n+\n+impl LintPass for HeapMemory {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(MANAGED_HEAP_MEMORY, OWNED_HEAP_MEMORY, HEAP_MEMORY)\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        match it.node {\n+            ast::ItemFn(..) |\n+            ast::ItemTy(..) |\n+            ast::ItemEnum(..) |\n+            ast::ItemStruct(..) =>\n+                self.check_heap_type(cx, it.span,\n+                                     ty::node_id_to_type(cx.tcx, it.id)),\n+            _ => ()\n+        }\n+\n+        // If it's a struct, we also have to check the fields' types\n+        match it.node {\n+            ast::ItemStruct(struct_def, _) => {\n+                for struct_field in struct_def.fields.iter() {\n+                    self.check_heap_type(cx, struct_field.span,\n+                                         ty::node_id_to_type(cx.tcx, struct_field.node.id));\n+                }\n+            }\n+            _ => ()\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        let ty = ty::expr_ty(cx.tcx, e);\n+        self.check_heap_type(cx, e.span, ty);\n+    }\n+}\n+\n+declare_lint!(RAW_POINTER_DERIVING, Warn,\n+              \"uses of #[deriving] with raw pointers are rarely correct\")\n+\n+struct RawPtrDerivingVisitor<'a> {\n+    cx: &'a Context<'a>\n+}\n+\n+impl<'a> visit::Visitor<()> for RawPtrDerivingVisitor<'a> {\n+    fn visit_ty(&mut self, ty: &ast::Ty, _: ()) {\n+        static MSG: &'static str = \"use of `#[deriving]` with a raw pointer\";\n+        match ty.node {\n+            ast::TyPtr(..) => self.cx.span_lint(RAW_POINTER_DERIVING, ty.span, MSG),\n+            _ => {}\n+        }\n+        visit::walk_ty(self, ty, ());\n+    }\n+    // explicit override to a no-op to reduce code bloat\n+    fn visit_expr(&mut self, _: &ast::Expr, _: ()) {}\n+    fn visit_block(&mut self, _: &ast::Block, _: ()) {}\n+}\n+\n+pub struct RawPointerDeriving {\n+    checked_raw_pointers: NodeSet,\n+}\n+\n+impl RawPointerDeriving {\n+    pub fn new() -> RawPointerDeriving {\n+        RawPointerDeriving {\n+            checked_raw_pointers: NodeSet::new(),\n+        }\n+    }\n+}\n+\n+impl LintPass for RawPointerDeriving {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(RAW_POINTER_DERIVING)\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n+        if !attr::contains_name(item.attrs.as_slice(), \"automatically_derived\") {\n+            return\n+        }\n+        let did = match item.node {\n+            ast::ItemImpl(..) => {\n+                match ty::get(ty::node_id_to_type(cx.tcx, item.id)).sty {\n+                    ty::ty_enum(did, _) => did,\n+                    ty::ty_struct(did, _) => did,\n+                    _ => return,\n+                }\n+            }\n+            _ => return,\n+        };\n+        if !ast_util::is_local(did) { return }\n+        let item = match cx.tcx.map.find(did.node) {\n+            Some(ast_map::NodeItem(item)) => item,\n+            _ => return,\n+        };\n+        if !self.checked_raw_pointers.insert(item.id) { return }\n+        match item.node {\n+            ast::ItemStruct(..) | ast::ItemEnum(..) => {\n+                let mut visitor = RawPtrDerivingVisitor { cx: cx };\n+                visit::walk_item(&mut visitor, &*item, ());\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n+declare_lint!(UNUSED_ATTRIBUTE, Warn,\n+              \"detects attributes that were not used by the compiler\")\n+\n+pub struct UnusedAttribute;\n+\n+impl LintPass for UnusedAttribute {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_ATTRIBUTE)\n+    }\n+\n+    fn check_attribute(&mut self, cx: &Context, attr: &ast::Attribute) {\n+        static ATTRIBUTE_WHITELIST: &'static [&'static str] = &'static [\n+            // FIXME: #14408 whitelist docs since rustdoc looks at them\n+            \"doc\",\n+\n+            // FIXME: #14406 these are processed in trans, which happens after the\n+            // lint pass\n+            \"cold\",\n+            \"inline\",\n+            \"link\",\n+            \"link_name\",\n+            \"link_section\",\n+            \"no_builtins\",\n+            \"no_mangle\",\n+            \"no_split_stack\",\n+            \"packed\",\n+            \"static_assert\",\n+            \"thread_local\",\n+\n+            // not used anywhere (!?) but apparently we want to keep them around\n+            \"comment\",\n+            \"desc\",\n+            \"license\",\n+\n+            // FIXME: #14407 these are only looked at on-demand so we can't\n+            // guarantee they'll have already been checked\n+            \"deprecated\",\n+            \"experimental\",\n+            \"frozen\",\n+            \"locked\",\n+            \"must_use\",\n+            \"stable\",\n+            \"unstable\",\n+        ];\n+\n+        static CRATE_ATTRS: &'static [&'static str] = &'static [\n+            \"crate_type\",\n+            \"feature\",\n+            \"no_start\",\n+            \"no_main\",\n+            \"no_std\",\n+            \"crate_id\",\n+            \"desc\",\n+            \"comment\",\n+            \"license\",\n+            \"copyright\",\n+            \"no_builtins\",\n+        ];\n+\n+        for &name in ATTRIBUTE_WHITELIST.iter() {\n+            if attr.check_name(name) {\n+                break;\n+            }\n+        }\n+\n+        if !attr::is_used(attr) {\n+            cx.span_lint(UNUSED_ATTRIBUTE, attr.span, \"unused attribute\");\n+            if CRATE_ATTRS.contains(&attr.name().get()) {\n+                let msg = match attr.node.style {\n+                    ast::AttrOuter => \"crate-level attribute should be an inner \\\n+                                       attribute: add an exclamation mark: #![foo]\",\n+                    ast::AttrInner => \"crate-level attribute should be in the \\\n+                                       root module\",\n+                };\n+                cx.span_lint(UNUSED_ATTRIBUTE, attr.span, msg);\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint!(PATH_STATEMENT, Warn,\n+              \"path statements with no effect\")\n+\n+pub struct PathStatement;\n+\n+impl LintPass for PathStatement {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(PATH_STATEMENT)\n+    }\n+\n+    fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n+        match s.node {\n+            ast::StmtSemi(expr, _) => {\n+                match expr.node {\n+                    ast::ExprPath(_) => cx.span_lint(PATH_STATEMENT, s.span,\n+                                                     \"path statement with no effect\"),\n+                    _ => ()\n+                }\n+            }\n+            _ => ()\n+        }\n+    }\n+}\n+\n+declare_lint!(UNUSED_MUST_USE, Warn,\n+              \"unused result of a type flagged as #[must_use]\")\n+\n+declare_lint!(UNUSED_RESULT, Allow,\n+              \"unused result of an expression in a statement\")\n+\n+pub struct UnusedResult;\n+\n+impl LintPass for UnusedResult {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_MUST_USE, UNUSED_RESULT)\n+    }\n+\n+    fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n+        let expr = match s.node {\n+            ast::StmtSemi(expr, _) => expr,\n+            _ => return\n+        };\n+        let t = ty::expr_ty(cx.tcx, &*expr);\n+        match ty::get(t).sty {\n+            ty::ty_nil | ty::ty_bot | ty::ty_bool => return,\n+            _ => {}\n+        }\n+        match expr.node {\n+            ast::ExprRet(..) => return,\n+            _ => {}\n+        }\n+\n+        let t = ty::expr_ty(cx.tcx, &*expr);\n+        let mut warned = false;\n+        match ty::get(t).sty {\n+            ty::ty_struct(did, _) |\n+            ty::ty_enum(did, _) => {\n+                if ast_util::is_local(did) {\n+                    match cx.tcx.map.get(did.node) {\n+                        ast_map::NodeItem(it) => {\n+                            if attr::contains_name(it.attrs.as_slice(),\n+                                                   \"must_use\") {\n+                                cx.span_lint(UNUSED_MUST_USE, s.span,\n+                                             \"unused result which must be used\");\n+                                warned = true;\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                } else {\n+                    csearch::get_item_attrs(&cx.sess().cstore, did, |attrs| {\n+                        if attr::contains_name(attrs.as_slice(), \"must_use\") {\n+                            cx.span_lint(UNUSED_MUST_USE, s.span,\n+                                         \"unused result which must be used\");\n+                            warned = true;\n+                        }\n+                    });\n+                }\n+            }\n+            _ => {}\n+        }\n+        if !warned {\n+            cx.span_lint(UNUSED_RESULT, s.span, \"unused result\");\n+        }\n+    }\n+}\n+\n+declare_lint!(NON_CAMEL_CASE_TYPES, Warn,\n+              \"types, variants and traits should have camel case names\")\n+\n+pub struct NonCamelCaseTypes;\n+\n+impl LintPass for NonCamelCaseTypes {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(NON_CAMEL_CASE_TYPES)\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        fn is_camel_case(ident: ast::Ident) -> bool {\n+            let ident = token::get_ident(ident);\n+            assert!(!ident.get().is_empty());\n+            let ident = ident.get().trim_chars('_');\n+\n+            // start with a non-lowercase letter rather than non-uppercase\n+            // ones (some scripts don't have a concept of upper/lowercase)\n+            !ident.char_at(0).is_lowercase() && !ident.contains_char('_')\n+        }\n+\n+        fn to_camel_case(s: &str) -> String {\n+            s.split('_').flat_map(|word| word.chars().enumerate().map(|(i, c)|\n+                if i == 0 { c.to_uppercase() }\n+                else { c }\n+            )).collect()\n+        }\n+\n+        fn check_case(cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n+            let s = token::get_ident(ident);\n+\n+            if !is_camel_case(ident) {\n+                cx.span_lint(NON_CAMEL_CASE_TYPES, span,\n+                    format!(\"{} `{}` should have a camel case name such as `{}`\",\n+                            sort, s, to_camel_case(s.get())).as_slice());\n+            }\n+        }\n+\n+        match it.node {\n+            ast::ItemTy(..) | ast::ItemStruct(..) => {\n+                check_case(cx, \"type\", it.ident, it.span)\n+            }\n+            ast::ItemTrait(..) => {\n+                check_case(cx, \"trait\", it.ident, it.span)\n+            }\n+            ast::ItemEnum(ref enum_definition, _) => {\n+                check_case(cx, \"type\", it.ident, it.span);\n+                for variant in enum_definition.variants.iter() {\n+                    check_case(cx, \"variant\", variant.node.name, variant.span);\n+                }\n+            }\n+            _ => ()\n+        }\n+    }\n+}\n+\n+#[deriving(PartialEq)]\n+enum MethodContext {\n+    TraitDefaultImpl,\n+    TraitImpl,\n+    PlainImpl\n+}\n+\n+fn method_context(cx: &Context, m: &ast::Method) -> MethodContext {\n+    let did = ast::DefId {\n+        krate: ast::LOCAL_CRATE,\n+        node: m.id\n+    };\n+\n+    match cx.tcx.methods.borrow().find_copy(&did) {\n+        None => cx.sess().span_bug(m.span, \"missing method descriptor?!\"),\n+        Some(md) => {\n+            match md.container {\n+                ty::TraitContainer(..) => TraitDefaultImpl,\n+                ty::ImplContainer(cid) => {\n+                    match ty::impl_trait_ref(cx.tcx, cid) {\n+                        Some(..) => TraitImpl,\n+                        None => PlainImpl\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint!(NON_SNAKE_CASE_FUNCTIONS, Warn,\n+              \"methods and functions should have snake case names\")\n+\n+pub struct NonSnakeCaseFunctions;\n+\n+impl NonSnakeCaseFunctions {\n+    fn check_snake_case(&self, cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n+        fn is_snake_case(ident: ast::Ident) -> bool {\n+            let ident = token::get_ident(ident);\n+            assert!(!ident.get().is_empty());\n+            let ident = ident.get().trim_chars('_');\n+\n+            let mut allow_underscore = true;\n+            ident.chars().all(|c| {\n+                allow_underscore = match c {\n+                    c if c.is_lowercase() || c.is_digit() => true,\n+                    '_' if allow_underscore => false,\n+                    _ => return false,\n+                };\n+                true\n+            })\n+        }\n+\n+        fn to_snake_case(str: &str) -> String {\n+            let mut words = vec![];\n+            for s in str.split('_') {\n+                let mut buf = String::new();\n+                if s.is_empty() { continue; }\n+                for ch in s.chars() {\n+                    if !buf.is_empty() && ch.is_uppercase() {\n+                        words.push(buf);\n+                        buf = String::new();\n+                    }\n+                    buf.push_char(ch.to_lowercase());\n+                }\n+                words.push(buf);\n+            }\n+            words.connect(\"_\")\n+        }\n+\n+        let s = token::get_ident(ident);\n+\n+        if !is_snake_case(ident) {\n+            cx.span_lint(NON_SNAKE_CASE_FUNCTIONS, span,\n+                format!(\"{} `{}` should have a snake case name such as `{}`\",\n+                        sort, s, to_snake_case(s.get())).as_slice());\n+        }\n+    }\n+}\n+\n+impl LintPass for NonSnakeCaseFunctions {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(NON_SNAKE_CASE_FUNCTIONS)\n+    }\n+\n+    fn check_fn(&mut self, cx: &Context,\n+                fk: &visit::FnKind, _: &ast::FnDecl,\n+                _: &ast::Block, span: Span, _: ast::NodeId) {\n+        match *fk {\n+            visit::FkMethod(ident, _, m) => match method_context(cx, m) {\n+                PlainImpl\n+                    => self.check_snake_case(cx, \"method\", ident, span),\n+                TraitDefaultImpl\n+                    => self.check_snake_case(cx, \"trait method\", ident, span),\n+                _ => (),\n+            },\n+            visit::FkItemFn(ident, _, _, _)\n+                => self.check_snake_case(cx, \"function\", ident, span),\n+            _ => (),\n+        }\n+    }\n+\n+    fn check_ty_method(&mut self, cx: &Context, t: &ast::TypeMethod) {\n+        self.check_snake_case(cx, \"trait method\", t.ident, t.span);\n+    }\n+}\n+\n+declare_lint!(NON_UPPERCASE_STATICS, Allow,\n+              \"static constants should have uppercase identifiers\")\n+\n+pub struct NonUppercaseStatics;\n+\n+impl LintPass for NonUppercaseStatics {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(NON_UPPERCASE_STATICS)\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        match it.node {\n+            // only check static constants\n+            ast::ItemStatic(_, ast::MutImmutable, _) => {\n+                let s = token::get_ident(it.ident);\n+                // check for lowercase letters rather than non-uppercase\n+                // ones (some scripts don't have a concept of\n+                // upper/lowercase)\n+                if s.get().chars().any(|c| c.is_lowercase()) {\n+                    cx.span_lint(NON_UPPERCASE_STATICS, it.span,\n+                        format!(\"static constant `{}` should have an uppercase name \\\n+                                 such as `{}`\",\n+                                s.get(), s.get().chars().map(|c| c.to_uppercase())\n+                                .collect::<String>().as_slice()).as_slice());\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n+declare_lint!(NON_UPPERCASE_PATTERN_STATICS, Warn,\n+              \"static constants in match patterns should be all caps\")\n+\n+pub struct NonUppercasePatternStatics;\n+\n+impl LintPass for NonUppercasePatternStatics {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(NON_UPPERCASE_PATTERN_STATICS)\n+    }\n+\n+    fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n+        // Lint for constants that look like binding identifiers (#7526)\n+        match (&p.node, cx.tcx.def_map.borrow().find(&p.id)) {\n+            (&ast::PatIdent(_, ref path, _), Some(&def::DefStatic(_, false))) => {\n+                // last identifier alone is right choice for this lint.\n+                let ident = path.segments.last().unwrap().identifier;\n+                let s = token::get_ident(ident);\n+                if s.get().chars().any(|c| c.is_lowercase()) {\n+                    cx.span_lint(NON_UPPERCASE_PATTERN_STATICS, path.span,\n+                        format!(\"static constant in pattern `{}` should have an uppercase \\\n+                                 name such as `{}`\",\n+                                s.get(), s.get().chars().map(|c| c.to_uppercase())\n+                                    .collect::<String>().as_slice()).as_slice());\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n+declare_lint!(UPPERCASE_VARIABLES, Warn,\n+              \"variable and structure field names should start with a lowercase character\")\n+\n+pub struct UppercaseVariables;\n+\n+impl LintPass for UppercaseVariables {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UPPERCASE_VARIABLES)\n+    }\n+\n+    fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n+        match &p.node {\n+            &ast::PatIdent(_, ref path, _) => {\n+                match cx.tcx.def_map.borrow().find(&p.id) {\n+                    Some(&def::DefLocal(_, _)) | Some(&def::DefBinding(_, _)) |\n+                            Some(&def::DefArg(_, _)) => {\n+                        // last identifier alone is right choice for this lint.\n+                        let ident = path.segments.last().unwrap().identifier;\n+                        let s = token::get_ident(ident);\n+                        if s.get().len() > 0 && s.get().char_at(0).is_uppercase() {\n+                            cx.span_lint(UPPERCASE_VARIABLES, path.span,\n+                                         \"variable names should start with \\\n+                                          a lowercase character\");\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_struct_def(&mut self, cx: &Context, s: &ast::StructDef,\n+            _: ast::Ident, _: &ast::Generics, _: ast::NodeId) {\n+        for sf in s.fields.iter() {\n+            match sf.node {\n+                ast::StructField_ { kind: ast::NamedField(ident, _), .. } => {\n+                    let s = token::get_ident(ident);\n+                    if s.get().char_at(0).is_uppercase() {\n+                        cx.span_lint(UPPERCASE_VARIABLES, sf.span,\n+                                     \"structure field names should start with \\\n+                                      a lowercase character\");\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint!(UNNECESSARY_PARENS, Warn,\n+              \"`if`, `match`, `while` and `return` do not need parentheses\")\n+\n+pub struct UnnecessaryParens;\n+\n+impl UnnecessaryParens {\n+    fn check_unnecessary_parens_core(&self, cx: &Context, value: &ast::Expr, msg: &str) {\n+        match value.node {\n+            ast::ExprParen(_) => {\n+                cx.span_lint(UNNECESSARY_PARENS, value.span,\n+                    format!(\"unnecessary parentheses around {}\", msg).as_slice())\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n+impl LintPass for UnnecessaryParens {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNNECESSARY_PARENS)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        let (value, msg) = match e.node {\n+            ast::ExprIf(cond, _, _) => (cond, \"`if` condition\"),\n+            ast::ExprWhile(cond, _) => (cond, \"`while` condition\"),\n+            ast::ExprMatch(head, _) => (head, \"`match` head expression\"),\n+            ast::ExprRet(Some(value)) => (value, \"`return` value\"),\n+            ast::ExprAssign(_, value) => (value, \"assigned value\"),\n+            ast::ExprAssignOp(_, _, value) => (value, \"assigned value\"),\n+            _ => return\n+        };\n+        self.check_unnecessary_parens_core(cx, &*value, msg);\n+    }\n+\n+    fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n+        let (value, msg) = match s.node {\n+            ast::StmtDecl(decl, _) => match decl.node {\n+                ast::DeclLocal(local) => match local.init {\n+                    Some(value) => (value, \"assigned value\"),\n+                    None => return\n+                },\n+                _ => return\n+            },\n+            _ => return\n+        };\n+        self.check_unnecessary_parens_core(cx, &*value, msg);\n+    }\n+}\n+\n+declare_lint!(UNUSED_UNSAFE, Warn,\n+              \"unnecessary use of an `unsafe` block\")\n+\n+pub struct UnusedUnsafe;\n+\n+impl LintPass for UnusedUnsafe {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_UNSAFE)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        match e.node {\n+            // Don't warn about generated blocks, that'll just pollute the output.\n+            ast::ExprBlock(ref blk) => {\n+                if blk.rules == ast::UnsafeBlock(ast::UserProvided) &&\n+                    !cx.tcx.used_unsafe.borrow().contains(&blk.id) {\n+                    cx.span_lint(UNUSED_UNSAFE, blk.span, \"unnecessary `unsafe` block\");\n+                }\n+            }\n+            _ => ()\n+        }\n+    }\n+}\n+\n+declare_lint!(UNSAFE_BLOCK, Allow,\n+              \"usage of an `unsafe` block\")\n+\n+pub struct UnsafeBlock;\n+\n+impl LintPass for UnsafeBlock {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNSAFE_BLOCK)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        match e.node {\n+            // Don't warn about generated blocks, that'll just pollute the output.\n+            ast::ExprBlock(ref blk) if blk.rules == ast::UnsafeBlock(ast::UserProvided) => {\n+                cx.span_lint(UNSAFE_BLOCK, blk.span, \"usage of an `unsafe` block\");\n+            }\n+            _ => ()\n+        }\n+    }\n+}\n+\n+declare_lint!(UNUSED_MUT, Warn,\n+              \"detect mut variables which don't need to be mutable\")\n+\n+pub struct UnusedMut;\n+\n+impl UnusedMut {\n+    fn check_unused_mut_pat(&self, cx: &Context, pats: &[Gc<ast::Pat>]) {\n+        // collect all mutable pattern and group their NodeIDs by their Identifier to\n+        // avoid false warnings in match arms with multiple patterns\n+        let mut mutables = HashMap::new();\n+        for &p in pats.iter() {\n+            pat_util::pat_bindings(&cx.tcx.def_map, &*p, |mode, id, _, path| {\n+                match mode {\n+                    ast::BindByValue(ast::MutMutable) => {\n+                        if path.segments.len() != 1 {\n+                            cx.sess().span_bug(p.span,\n+                                               \"mutable binding that doesn't consist \\\n+                                                of exactly one segment\");\n+                        }\n+                        let ident = path.segments.get(0).identifier;\n+                        if !token::get_ident(ident).get().starts_with(\"_\") {\n+                            mutables.insert_or_update_with(ident.name as uint,\n+                                vec!(id), |_, old| { old.push(id); });\n+                        }\n+                    }\n+                    _ => {\n+                    }\n+                }\n+            });\n+        }\n+\n+        let used_mutables = cx.tcx.used_mut_nodes.borrow();\n+        for (_, v) in mutables.iter() {\n+            if !v.iter().any(|e| used_mutables.contains(e)) {\n+                cx.span_lint(UNUSED_MUT, cx.tcx.map.span(*v.get(0)),\n+                             \"variable does not need to be mutable\");\n+            }\n+        }\n+    }\n+}\n+\n+impl LintPass for UnusedMut {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_MUT)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        match e.node {\n+            ast::ExprMatch(_, ref arms) => {\n+                for a in arms.iter() {\n+                    self.check_unused_mut_pat(cx, a.pats.as_slice())\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n+        match s.node {\n+            ast::StmtDecl(d, _) => {\n+                match d.node {\n+                    ast::DeclLocal(l) => {\n+                        self.check_unused_mut_pat(cx, &[l.pat]);\n+                    },\n+                    _ => {}\n+                }\n+            },\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_fn(&mut self, cx: &Context,\n+                _: &visit::FnKind, decl: &ast::FnDecl,\n+                _: &ast::Block, _: Span, _: ast::NodeId) {\n+        for a in decl.inputs.iter() {\n+            self.check_unused_mut_pat(cx, &[a.pat]);\n+        }\n+    }\n+}\n+\n+enum Allocation {\n+    VectorAllocation,\n+    BoxAllocation\n+}\n+\n+declare_lint!(UNNECESSARY_ALLOCATION, Warn,\n+              \"detects unnecessary allocations that can be eliminated\")\n+\n+pub struct UnnecessaryAllocation;\n+\n+impl LintPass for UnnecessaryAllocation {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNNECESSARY_ALLOCATION)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        // Warn if string and vector literals with sigils, or boxing expressions,\n+        // are immediately borrowed.\n+        let allocation = match e.node {\n+            ast::ExprVstore(e2, ast::ExprVstoreUniq) => {\n+                match e2.node {\n+                    ast::ExprLit(lit) if ast_util::lit_is_str(lit) => {\n+                        VectorAllocation\n+                    }\n+                    ast::ExprVec(..) => VectorAllocation,\n+                    _ => return\n+                }\n+            }\n+            ast::ExprUnary(ast::UnUniq, _) |\n+            ast::ExprUnary(ast::UnBox, _) => BoxAllocation,\n+\n+            _ => return\n+        };\n+\n+        match cx.tcx.adjustments.borrow().find(&e.id) {\n+            Some(adjustment) => {\n+                match *adjustment {\n+                    ty::AutoDerefRef(ty::AutoDerefRef { autoref, .. }) => {\n+                        match (allocation, autoref) {\n+                            (VectorAllocation, Some(ty::AutoBorrowVec(..))) => {\n+                                cx.span_lint(UNNECESSARY_ALLOCATION, e.span,\n+                                             \"unnecessary allocation, the sigil can be removed\");\n+                            }\n+                            (BoxAllocation,\n+                             Some(ty::AutoPtr(_, ast::MutImmutable))) => {\n+                                cx.span_lint(UNNECESSARY_ALLOCATION, e.span,\n+                                             \"unnecessary allocation, use & instead\");\n+                            }\n+                            (BoxAllocation,\n+                             Some(ty::AutoPtr(_, ast::MutMutable))) => {\n+                                cx.span_lint(UNNECESSARY_ALLOCATION, e.span,\n+                                             \"unnecessary allocation, use &mut instead\");\n+                            }\n+                            _ => ()\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => ()\n+        }\n+    }\n+}\n+\n+declare_lint!(MISSING_DOC, Allow,\n+              \"detects missing documentation for public members\")\n+\n+pub struct MissingDoc {\n+    /// Stack of IDs of struct definitions.\n+    struct_def_stack: Vec<ast::NodeId>,\n+\n+    /// Stack of whether #[doc(hidden)] is set\n+    /// at each level which has lint attributes.\n+    doc_hidden_stack: Vec<bool>,\n+}\n+\n+impl MissingDoc {\n+    pub fn new() -> MissingDoc {\n+        MissingDoc {\n+            struct_def_stack: vec!(),\n+            doc_hidden_stack: vec!(false),\n+        }\n+    }\n+\n+    fn doc_hidden(&self) -> bool {\n+        *self.doc_hidden_stack.last().expect(\"empty doc_hidden_stack\")\n+    }\n+\n+    fn check_missing_doc_attrs(&self,\n+                               cx: &Context,\n+                               id: Option<ast::NodeId>,\n+                               attrs: &[ast::Attribute],\n+                               sp: Span,\n+                               desc: &'static str) {\n+        // If we're building a test harness, then warning about\n+        // documentation is probably not really relevant right now.\n+        if cx.sess().opts.test { return }\n+\n+        // `#[doc(hidden)]` disables missing_doc check.\n+        if self.doc_hidden() { return }\n+\n+        // Only check publicly-visible items, using the result from the privacy pass.\n+        // It's an option so the crate root can also use this function (it doesn't\n+        // have a NodeId).\n+        match id {\n+            Some(ref id) if !cx.exported_items.contains(id) => return,\n+            _ => ()\n+        }\n+\n+        let has_doc = attrs.iter().any(|a| {\n+            match a.node.value.node {\n+                ast::MetaNameValue(ref name, _) if name.equiv(&(\"doc\")) => true,\n+                _ => false\n+            }\n+        });\n+        if !has_doc {\n+            cx.span_lint(MISSING_DOC, sp,\n+                format!(\"missing documentation for {}\", desc).as_slice());\n+        }\n+    }\n+}\n+\n+impl LintPass for MissingDoc {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(MISSING_DOC)\n+    }\n+\n+    fn enter_lint_attrs(&mut self, _: &Context, attrs: &[ast::Attribute]) {\n+        let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n+            attr.check_name(\"doc\") && match attr.meta_item_list() {\n+                None => false,\n+                Some(l) => attr::contains_name(l.as_slice(), \"hidden\"),\n+            }\n+        });\n+        self.doc_hidden_stack.push(doc_hidden);\n+    }\n+\n+    fn exit_lint_attrs(&mut self, _: &Context, _: &[ast::Attribute]) {\n+        self.doc_hidden_stack.pop().expect(\"empty doc_hidden_stack\");\n+    }\n+\n+    fn check_struct_def(&mut self, _: &Context,\n+        _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, id: ast::NodeId) {\n+        self.struct_def_stack.push(id);\n+    }\n+\n+    fn check_struct_def_post(&mut self, _: &Context,\n+        _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, id: ast::NodeId) {\n+        let popped = self.struct_def_stack.pop().expect(\"empty struct_def_stack\");\n+        assert!(popped == id);\n+    }\n+\n+    fn check_crate(&mut self, cx: &Context, krate: &ast::Crate) {\n+        self.check_missing_doc_attrs(cx, None, krate.attrs.as_slice(),\n+                                     krate.span, \"crate\");\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        let desc = match it.node {\n+            ast::ItemFn(..) => \"a function\",\n+            ast::ItemMod(..) => \"a module\",\n+            ast::ItemEnum(..) => \"an enum\",\n+            ast::ItemStruct(..) => \"a struct\",\n+            ast::ItemTrait(..) => \"a trait\",\n+            _ => return\n+        };\n+        self.check_missing_doc_attrs(cx, Some(it.id), it.attrs.as_slice(),\n+                                     it.span, desc);\n+    }\n+\n+    fn check_fn(&mut self, cx: &Context,\n+            fk: &visit::FnKind, _: &ast::FnDecl,\n+            _: &ast::Block, _: Span, _: ast::NodeId) {\n+        match *fk {\n+            visit::FkMethod(_, _, m) => {\n+                // If the method is an impl for a trait, don't doc.\n+                if method_context(cx, m) == TraitImpl { return; }\n+\n+                // Otherwise, doc according to privacy. This will also check\n+                // doc for default methods defined on traits.\n+                self.check_missing_doc_attrs(cx, Some(m.id), m.attrs.as_slice(),\n+                                             m.span, \"a method\");\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_ty_method(&mut self, cx: &Context, tm: &ast::TypeMethod) {\n+        self.check_missing_doc_attrs(cx, Some(tm.id), tm.attrs.as_slice(),\n+                                     tm.span, \"a type method\");\n+    }\n+\n+    fn check_struct_field(&mut self, cx: &Context, sf: &ast::StructField) {\n+        match sf.node.kind {\n+            ast::NamedField(_, vis) if vis == ast::Public => {\n+                let cur_struct_def = *self.struct_def_stack.last()\n+                    .expect(\"empty struct_def_stack\");\n+                self.check_missing_doc_attrs(cx, Some(cur_struct_def),\n+                                             sf.node.attrs.as_slice(), sf.span,\n+                                             \"a struct field\")\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_variant(&mut self, cx: &Context, v: &ast::Variant, _: &ast::Generics) {\n+        self.check_missing_doc_attrs(cx, Some(v.node.id), v.node.attrs.as_slice(),\n+                                     v.span, \"a variant\");\n+    }\n+}\n+\n+declare_lint!(DEPRECATED, Warn,\n+              \"detects use of #[deprecated] items\")\n+\n+// FIXME #6875: Change to Warn after std library stabilization is complete\n+declare_lint!(EXPERIMENTAL, Allow,\n+              \"detects use of #[experimental] items\")\n+\n+declare_lint!(UNSTABLE, Allow,\n+              \"detects use of #[unstable] items (incl. items with no stability attribute)\")\n+\n+/// Checks for use of items with `#[deprecated]`, `#[experimental]` and\n+/// `#[unstable]` attributes, or no stability attribute.\n+pub struct Stability;\n+\n+impl LintPass for Stability {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(DEPRECATED, EXPERIMENTAL, UNSTABLE)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        let id = match e.node {\n+            ast::ExprPath(..) | ast::ExprStruct(..) => {\n+                match cx.tcx.def_map.borrow().find(&e.id) {\n+                    Some(&def) => def.def_id(),\n+                    None => return\n+                }\n+            }\n+            ast::ExprMethodCall(..) => {\n+                let method_call = typeck::MethodCall::expr(e.id);\n+                match cx.tcx.method_map.borrow().find(&method_call) {\n+                    Some(method) => {\n+                        match method.origin {\n+                            typeck::MethodStatic(def_id) => {\n+                                // If this implements a trait method, get def_id\n+                                // of the method inside trait definition.\n+                                // Otherwise, use the current def_id (which refers\n+                                // to the method inside impl).\n+                                ty::trait_method_of_method(cx.tcx, def_id).unwrap_or(def_id)\n+                            }\n+                            typeck::MethodParam(typeck::MethodParam {\n+                                trait_id: trait_id,\n+                                method_num: index,\n+                                ..\n+                            })\n+                            | typeck::MethodObject(typeck::MethodObject {\n+                                trait_id: trait_id,\n+                                method_num: index,\n+                                ..\n+                            }) => ty::trait_method(cx.tcx, trait_id, index).def_id\n+                        }\n+                    }\n+                    None => return\n+                }\n+            }\n+            _ => return\n+        };\n+\n+        // stability attributes are promises made across crates; do not\n+        // check anything for crate-local usage.\n+        if ast_util::is_local(id) { return }\n+\n+        let stability = cx.tcx.stability.borrow_mut().lookup(&cx.tcx.sess.cstore, id);\n+\n+        let (lint, label) = match stability {\n+            // no stability attributes == Unstable\n+            None => (UNSTABLE, \"unmarked\"),\n+            Some(attr::Stability { level: attr::Unstable, .. }) =>\n+                    (UNSTABLE, \"unstable\"),\n+            Some(attr::Stability { level: attr::Experimental, .. }) =>\n+                    (EXPERIMENTAL, \"experimental\"),\n+            Some(attr::Stability { level: attr::Deprecated, .. }) =>\n+                    (DEPRECATED, \"deprecated\"),\n+            _ => return\n+        };\n+\n+        let msg = match stability {\n+            Some(attr::Stability { text: Some(ref s), .. }) => {\n+                format!(\"use of {} item: {}\", label, *s)\n+            }\n+            _ => format!(\"use of {} item\", label)\n+        };\n+\n+        cx.span_lint(lint, e.span, msg.as_slice());\n+    }\n+}\n+\n+declare_lint!(pub UNUSED_IMPORTS, Warn,\n+              \"imports that are never used\")\n+\n+declare_lint!(pub UNNECESSARY_QUALIFICATION, Allow,\n+              \"detects unnecessarily qualified names\")\n+\n+declare_lint!(pub UNRECOGNIZED_LINT, Warn,\n+              \"unrecognized lint attribute\")\n+\n+declare_lint!(pub UNUSED_VARIABLE, Warn,\n+              \"detect variables which are not used in any way\")\n+\n+declare_lint!(pub DEAD_ASSIGNMENT, Warn,\n+              \"detect assignments that will never be read\")\n+\n+declare_lint!(pub DEAD_CODE, Warn,\n+              \"detect piece of code that will never be used\")\n+\n+declare_lint!(pub VISIBLE_PRIVATE_TYPES, Warn,\n+              \"detect use of private types in exported type signatures\")\n+\n+declare_lint!(pub UNREACHABLE_CODE, Warn,\n+              \"detects unreachable code\")\n+\n+declare_lint!(pub WARNINGS, Warn,\n+              \"mass-change the level for lints which produce warnings\")\n+\n+declare_lint!(pub UNKNOWN_FEATURES, Deny,\n+              \"unknown features found in crate-level #[feature] directives\")\n+\n+declare_lint!(pub UNKNOWN_CRATE_TYPE, Deny,\n+              \"unknown crate type found in #[crate_type] directive\")\n+\n+declare_lint!(pub VARIANT_SIZE_DIFFERENCE, Allow,\n+              \"detects enums with widely varying variant sizes\")\n+\n+/// Does nothing as a lint pass, but registers some `Lint`s\n+/// which are used by other parts of the compiler.\n+pub struct HardwiredLints;\n+\n+impl LintPass for HardwiredLints {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(\n+            UNUSED_IMPORTS,\n+            UNNECESSARY_QUALIFICATION,\n+            UNRECOGNIZED_LINT,\n+            UNUSED_VARIABLE,\n+            DEAD_ASSIGNMENT,\n+            DEAD_CODE,\n+            VISIBLE_PRIVATE_TYPES,\n+            UNREACHABLE_CODE,\n+            WARNINGS,\n+            UNKNOWN_FEATURES,\n+            UNKNOWN_CRATE_TYPE,\n+            VARIANT_SIZE_DIFFERENCE\n+        )\n+    }\n+}"}, {"sha": "79fbd73c23d3cbdbcffeef0ed299fcc604440657", "filename": "src/librustc/lint/context.rs", "status": "added", "additions": 675, "deletions": 0, "changes": 675, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -0,0 +1,675 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of lint checking.\n+//!\n+//! The lint checking is mostly consolidated into one pass which runs just\n+//! before translation to LLVM bytecode. Throughout compilation, lint warnings\n+//! can be added via the `add_lint` method on the Session structure. This\n+//! requires a span and an id of the node that the lint is being added to. The\n+//! lint isn't actually emitted at that time because it is unknown what the\n+//! actual lint level at that location is.\n+//!\n+//! To actually emit lint warnings/errors, a separate pass is used just before\n+//! translation. A context keeps track of the current state of all lint levels.\n+//! Upon entering a node of the ast which can modify the lint settings, the\n+//! previous lint state is pushed onto a stack and the ast is then recursed\n+//! upon.  As the ast is traversed, this keeps track of the current lint level\n+//! for all lint attributes.\n+\n+use middle::privacy::ExportedItems;\n+use middle::ty;\n+use middle::typeck::astconv::AstConv;\n+use middle::typeck::infer;\n+use driver::session::Session;\n+use driver::early_error;\n+use lint::{Level, LevelSource, Lint, LintId, LintArray, LintPass, LintPassObject};\n+use lint::{Default, CommandLine, Node, Allow, Warn, Deny, Forbid};\n+use lint::builtin;\n+\n+use std::collections::HashMap;\n+use std::rc::Rc;\n+use std::cell::RefCell;\n+use std::tuple::Tuple2;\n+use std::mem;\n+use syntax::ast_util::IdVisitingOperation;\n+use syntax::attr::AttrMetaMethods;\n+use syntax::attr;\n+use syntax::codemap::Span;\n+use syntax::visit::{Visitor, FnKind};\n+use syntax::parse::token::InternedString;\n+use syntax::{ast, ast_util, visit};\n+\n+/// Information about the registered lints.\n+///\n+/// This is basically the subset of `Context` that we can\n+/// build early in the compile pipeline.\n+pub struct LintStore {\n+    /// Registered lints. The bool is true if the lint was\n+    /// added by a plugin.\n+    lints: Vec<(&'static Lint, bool)>,\n+\n+    /// Trait objects for each lint pass.\n+    /// This is only `None` while iterating over the objects. See the definition\n+    /// of run_lints.\n+    passes: Option<Vec<LintPassObject>>,\n+\n+    /// Lints indexed by name.\n+    by_name: HashMap<String, LintId>,\n+\n+    /// Current levels of each lint, and where they were set.\n+    levels: HashMap<LintId, LevelSource>,\n+}\n+\n+impl LintStore {\n+    fn get_level_source(&self, lint: LintId) -> LevelSource {\n+        match self.levels.find(&lint) {\n+            Some(&s) => s,\n+            None => (Allow, Default),\n+        }\n+    }\n+\n+    fn set_level(&mut self, lint: LintId, lvlsrc: LevelSource) {\n+        if lvlsrc.val0() == Allow {\n+            self.levels.remove(&lint);\n+        } else {\n+            self.levels.insert(lint, lvlsrc);\n+        }\n+    }\n+\n+    pub fn new() -> LintStore {\n+        LintStore {\n+            lints: vec!(),\n+            passes: Some(vec!()),\n+            by_name: HashMap::new(),\n+            levels: HashMap::new(),\n+        }\n+    }\n+\n+    pub fn get_lints<'t>(&'t self) -> &'t [(&'static Lint, bool)] {\n+        self.lints.as_slice()\n+    }\n+\n+    pub fn register_pass(&mut self, sess: Option<&Session>,\n+                         from_plugin: bool, pass: LintPassObject) {\n+        for &lint in pass.get_lints().iter() {\n+            self.lints.push((lint, from_plugin));\n+\n+            let id = LintId::of(lint);\n+            if !self.by_name.insert(lint.name_lower(), id) {\n+                let msg = format!(\"duplicate specification of lint {}\", lint.name_lower());\n+                match (sess, from_plugin) {\n+                    // We load builtin lints first, so a duplicate is a compiler bug.\n+                    // Use early_error when handling -W help with no crate.\n+                    (None, _) => early_error(msg.as_slice()),\n+                    (Some(sess), false) => sess.bug(msg.as_slice()),\n+\n+                    // A duplicate name from a plugin is a user error.\n+                    (Some(sess), true)  => sess.err(msg.as_slice()),\n+                }\n+            }\n+\n+            if lint.default_level != Allow {\n+                self.levels.insert(id, (lint.default_level, Default));\n+            }\n+        }\n+        self.passes.get_mut_ref().push(pass);\n+    }\n+\n+    pub fn register_builtin(&mut self, sess: Option<&Session>) {\n+        macro_rules! add_builtin ( ( $sess:ident, $($name:ident),*, ) => (\n+            {$(\n+                self.register_pass($sess, false, box builtin::$name as LintPassObject);\n+            )*}\n+        ))\n+\n+        macro_rules! add_builtin_with_new ( ( $sess:ident, $($name:ident),*, ) => (\n+            {$(\n+                self.register_pass($sess, false, box builtin::$name::new() as LintPassObject);\n+            )*}\n+        ))\n+\n+        add_builtin!(sess,\n+                     HardwiredLints,\n+                     WhileTrue,\n+                     UnusedCasts,\n+                     CTypes,\n+                     HeapMemory,\n+                     UnusedAttribute,\n+                     PathStatement,\n+                     UnusedResult,\n+                     NonCamelCaseTypes,\n+                     NonSnakeCaseFunctions,\n+                     NonUppercaseStatics,\n+                     NonUppercasePatternStatics,\n+                     UppercaseVariables,\n+                     UnnecessaryParens,\n+                     UnusedUnsafe,\n+                     UnsafeBlock,\n+                     UnusedMut,\n+                     UnnecessaryAllocation,\n+                     Stability,\n+        )\n+\n+        add_builtin_with_new!(sess,\n+                              TypeLimits,\n+                              RawPointerDeriving,\n+                              MissingDoc,\n+        )\n+\n+        // We have one lint pass defined in this module.\n+        self.register_pass(sess, false, box GatherNodeLevels as LintPassObject);\n+    }\n+\n+    pub fn process_command_line(&mut self, sess: &Session) {\n+        for &(ref lint_name, level) in sess.opts.lint_opts.iter() {\n+            match self.by_name.find_equiv(&lint_name.as_slice()) {\n+                Some(&lint_id) => self.set_level(lint_id, (level, CommandLine)),\n+                None => sess.err(format!(\"unknown {} flag: {}\",\n+                                         level.as_str(), lint_name).as_slice()),\n+            }\n+        }\n+    }\n+}\n+\n+/// Context for lint checking.\n+pub struct Context<'a> {\n+    /// Type context we're checking in.\n+    pub tcx: &'a ty::ctxt,\n+\n+    /// The crate being checked.\n+    pub krate: &'a ast::Crate,\n+\n+    /// Items exported from the crate being checked.\n+    pub exported_items: &'a ExportedItems,\n+\n+    /// The store of registered lints.\n+    lints: LintStore,\n+\n+    /// When recursing into an attributed node of the ast which modifies lint\n+    /// levels, this stack keeps track of the previous lint levels of whatever\n+    /// was modified.\n+    level_stack: Vec<(LintId, LevelSource)>,\n+\n+    /// Level of lints for certain NodeIds, stored here because the body of\n+    /// the lint needs to run in trans.\n+    node_levels: RefCell<HashMap<(ast::NodeId, LintId), LevelSource>>,\n+}\n+\n+/// Convenience macro for calling a `LintPass` method on every pass in the context.\n+macro_rules! run_lints ( ($cx:expr, $f:ident, $($args:expr),*) => ({\n+    // Move the vector of passes out of `$cx` so that we can\n+    // iterate over it mutably while passing `$cx` to the methods.\n+    let mut passes = $cx.lints.passes.take_unwrap();\n+    for obj in passes.mut_iter() {\n+        obj.$f($cx, $($args),*);\n+    }\n+    $cx.lints.passes = Some(passes);\n+}))\n+\n+/// Parse the lint attributes into a vector, with `Err`s for malformed lint\n+/// attributes. Writing this as an iterator is an enormous mess.\n+pub fn gather_attrs(attrs: &[ast::Attribute])\n+                    -> Vec<Result<(InternedString, Level, Span), Span>> {\n+    let mut out = vec!();\n+    for attr in attrs.iter() {\n+        let level = match Level::from_str(attr.name().get()) {\n+            None => continue,\n+            Some(lvl) => lvl,\n+        };\n+\n+        attr::mark_used(attr);\n+\n+        let meta = attr.node.value;\n+        let metas = match meta.node {\n+            ast::MetaList(_, ref metas) => metas,\n+            _ => {\n+                out.push(Err(meta.span));\n+                continue;\n+            }\n+        };\n+\n+        for meta in metas.iter() {\n+            out.push(match meta.node {\n+                ast::MetaWord(ref lint_name) => Ok((lint_name.clone(), level, meta.span)),\n+                _ => Err(meta.span),\n+            });\n+        }\n+    }\n+    out\n+}\n+\n+/// Emit a lint as a warning or an error (or not at all)\n+/// according to `level`.\n+///\n+/// This lives outside of `Context` so it can be used by checks\n+/// in trans that run after the main lint pass is finished. Most\n+/// lints elsewhere in the compiler should call\n+/// `Session::add_lint()` instead.\n+pub fn raw_emit_lint(sess: &Session, lint: &'static Lint,\n+                     lvlsrc: LevelSource, span: Option<Span>, msg: &str) {\n+    let (mut level, source) = lvlsrc;\n+    if level == Allow { return }\n+\n+    let name = lint.name_lower();\n+    let mut note = None;\n+    let msg = match source {\n+        Default => {\n+            format!(\"{}, #[{}({})] on by default\", msg,\n+                    level.as_str(), name)\n+        },\n+        CommandLine => {\n+            format!(\"{} [-{} {}]\", msg,\n+                    match level {\n+                        Warn => 'W', Deny => 'D', Forbid => 'F',\n+                        Allow => fail!()\n+                    }, name.replace(\"_\", \"-\"))\n+        },\n+        Node(src) => {\n+            note = Some(src);\n+            msg.to_string()\n+        }\n+    };\n+\n+    // For purposes of printing, we can treat forbid as deny.\n+    if level == Forbid { level = Deny; }\n+\n+    match (level, span) {\n+        (Warn, Some(sp)) => sess.span_warn(sp, msg.as_slice()),\n+        (Warn, None)     => sess.warn(msg.as_slice()),\n+        (Deny, Some(sp)) => sess.span_err(sp, msg.as_slice()),\n+        (Deny, None)     => sess.err(msg.as_slice()),\n+        _ => sess.bug(\"impossible level in raw_emit_lint\"),\n+    }\n+\n+    for span in note.move_iter() {\n+        sess.span_note(span, \"lint level defined here\");\n+    }\n+}\n+\n+impl<'a> Context<'a> {\n+    fn new(tcx: &'a ty::ctxt,\n+           krate: &'a ast::Crate,\n+           exported_items: &'a ExportedItems) -> Context<'a> {\n+        // We want to own the lint store, so move it out of the session.\n+        let lint_store = mem::replace(&mut *tcx.sess.lint_store.borrow_mut(),\n+                                      LintStore::new());\n+\n+        Context {\n+            tcx: tcx,\n+            krate: krate,\n+            exported_items: exported_items,\n+            lints: lint_store,\n+            level_stack: vec!(),\n+            node_levels: RefCell::new(HashMap::new()),\n+        }\n+    }\n+\n+    /// Get the overall compiler `Session` object.\n+    pub fn sess(&'a self) -> &'a Session {\n+        &self.tcx.sess\n+    }\n+\n+    fn lookup_and_emit(&self, lint: &'static Lint, span: Option<Span>, msg: &str) {\n+        let (level, src) = match self.lints.levels.find(&LintId::of(lint)) {\n+            None => return,\n+            Some(&(Warn, src)) => {\n+                let lint_id = LintId::of(builtin::WARNINGS);\n+                (self.lints.get_level_source(lint_id).val0(), src)\n+            }\n+            Some(&pair) => pair,\n+        };\n+\n+        raw_emit_lint(&self.tcx.sess, lint, (level, src), span, msg);\n+    }\n+\n+    /// Emit a lint at the appropriate level, with no associated span.\n+    pub fn lint(&self, lint: &'static Lint, msg: &str) {\n+        self.lookup_and_emit(lint, None, msg);\n+    }\n+\n+    /// Emit a lint at the appropriate level, for a particular span.\n+    pub fn span_lint(&self, lint: &'static Lint, span: Span, msg: &str) {\n+        self.lookup_and_emit(lint, Some(span), msg);\n+    }\n+\n+    /**\n+     * Merge the lints specified by any lint attributes into the\n+     * current lint context, call the provided function, then reset the\n+     * lints in effect to their previous state.\n+     */\n+    fn with_lint_attrs(&mut self,\n+                       attrs: &[ast::Attribute],\n+                       f: |&mut Context|) {\n+        // Parse all of the lint attributes, and then add them all to the\n+        // current dictionary of lint information. Along the way, keep a history\n+        // of what we changed so we can roll everything back after invoking the\n+        // specified closure\n+        let mut pushed = 0u;\n+\n+        for result in gather_attrs(attrs).move_iter() {\n+            let (lint_id, level, span) = match result {\n+                Err(span) => {\n+                    self.tcx.sess.span_err(span, \"malformed lint attribute\");\n+                    continue;\n+                }\n+                Ok((lint_name, level, span)) => {\n+                    match self.lints.by_name.find_equiv(&lint_name.get()) {\n+                        Some(&lint_id) => (lint_id, level, span),\n+                        None => {\n+                            self.span_lint(builtin::UNRECOGNIZED_LINT, span,\n+                                           format!(\"unknown `{}` attribute: `{}`\",\n+                                                   level.as_str(), lint_name).as_slice());\n+                            continue;\n+                        }\n+                    }\n+                }\n+            };\n+\n+            let now = self.lints.get_level_source(lint_id).val0();\n+            if now == Forbid && level != Forbid {\n+                let lint_name = lint_id.as_str();\n+                self.tcx.sess.span_err(span,\n+                                       format!(\"{}({}) overruled by outer forbid({})\",\n+                                               level.as_str(), lint_name, lint_name).as_slice());\n+            } else if now != level {\n+                let src = self.lints.get_level_source(lint_id).val1();\n+                self.level_stack.push((lint_id, (now, src)));\n+                pushed += 1;\n+                self.lints.set_level(lint_id, (level, Node(span)));\n+            }\n+        }\n+\n+        run_lints!(self, enter_lint_attrs, attrs);\n+        f(self);\n+        run_lints!(self, exit_lint_attrs, attrs);\n+\n+        // rollback\n+        for _ in range(0, pushed) {\n+            let (lint, lvlsrc) = self.level_stack.pop().unwrap();\n+            self.lints.set_level(lint, lvlsrc);\n+        }\n+    }\n+\n+    fn visit_ids(&self, f: |&mut ast_util::IdVisitor<Context>|) {\n+        let mut v = ast_util::IdVisitor {\n+            operation: self,\n+            pass_through_items: false,\n+            visited_outermost: false,\n+        };\n+        f(&mut v);\n+    }\n+}\n+\n+impl<'a> AstConv for Context<'a>{\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n+\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n+        ty::lookup_item_type(self.tcx, id)\n+    }\n+\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n+        ty::lookup_trait_def(self.tcx, id)\n+    }\n+\n+    fn ty_infer(&self, _span: Span) -> ty::t {\n+        infer::new_infer_ctxt(self.tcx).next_ty_var()\n+    }\n+}\n+\n+impl<'a> Visitor<()> for Context<'a> {\n+    fn visit_item(&mut self, it: &ast::Item, _: ()) {\n+        self.with_lint_attrs(it.attrs.as_slice(), |cx| {\n+            run_lints!(cx, check_item, it);\n+            cx.visit_ids(|v| v.visit_item(it, ()));\n+            visit::walk_item(cx, it, ());\n+        })\n+    }\n+\n+    fn visit_foreign_item(&mut self, it: &ast::ForeignItem, _: ()) {\n+        self.with_lint_attrs(it.attrs.as_slice(), |cx| {\n+            run_lints!(cx, check_foreign_item, it);\n+            visit::walk_foreign_item(cx, it, ());\n+        })\n+    }\n+\n+    fn visit_view_item(&mut self, i: &ast::ViewItem, _: ()) {\n+        self.with_lint_attrs(i.attrs.as_slice(), |cx| {\n+            run_lints!(cx, check_view_item, i);\n+            cx.visit_ids(|v| v.visit_view_item(i, ()));\n+            visit::walk_view_item(cx, i, ());\n+        })\n+    }\n+\n+    fn visit_pat(&mut self, p: &ast::Pat, _: ()) {\n+        run_lints!(self, check_pat, p);\n+        visit::walk_pat(self, p, ());\n+    }\n+\n+    fn visit_expr(&mut self, e: &ast::Expr, _: ()) {\n+        run_lints!(self, check_expr, e);\n+        visit::walk_expr(self, e, ());\n+    }\n+\n+    fn visit_stmt(&mut self, s: &ast::Stmt, _: ()) {\n+        run_lints!(self, check_stmt, s);\n+        visit::walk_stmt(self, s, ());\n+    }\n+\n+    fn visit_fn(&mut self, fk: &FnKind, decl: &ast::FnDecl,\n+                body: &ast::Block, span: Span, id: ast::NodeId, _: ()) {\n+        match *fk {\n+            visit::FkMethod(_, _, m) => {\n+                self.with_lint_attrs(m.attrs.as_slice(), |cx| {\n+                    run_lints!(cx, check_fn, fk, decl, body, span, id);\n+                    cx.visit_ids(|v| {\n+                        v.visit_fn(fk, decl, body, span, id, ());\n+                    });\n+                    visit::walk_fn(cx, fk, decl, body, span, ());\n+                })\n+            },\n+            _ => {\n+                run_lints!(self, check_fn, fk, decl, body, span, id);\n+                visit::walk_fn(self, fk, decl, body, span, ());\n+            }\n+        }\n+    }\n+\n+    fn visit_ty_method(&mut self, t: &ast::TypeMethod, _: ()) {\n+        self.with_lint_attrs(t.attrs.as_slice(), |cx| {\n+            run_lints!(cx, check_ty_method, t);\n+            visit::walk_ty_method(cx, t, ());\n+        })\n+    }\n+\n+    fn visit_struct_def(&mut self,\n+                        s: &ast::StructDef,\n+                        ident: ast::Ident,\n+                        g: &ast::Generics,\n+                        id: ast::NodeId,\n+                        _: ()) {\n+        run_lints!(self, check_struct_def, s, ident, g, id);\n+        visit::walk_struct_def(self, s, ());\n+        run_lints!(self, check_struct_def_post, s, ident, g, id);\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &ast::StructField, _: ()) {\n+        self.with_lint_attrs(s.node.attrs.as_slice(), |cx| {\n+            run_lints!(cx, check_struct_field, s);\n+            visit::walk_struct_field(cx, s, ());\n+        })\n+    }\n+\n+    fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics, _: ()) {\n+        self.with_lint_attrs(v.node.attrs.as_slice(), |cx| {\n+            run_lints!(cx, check_variant, v, g);\n+            visit::walk_variant(cx, v, g, ());\n+        })\n+    }\n+\n+    // FIXME(#10894) should continue recursing\n+    fn visit_ty(&mut self, t: &ast::Ty, _: ()) {\n+        run_lints!(self, check_ty, t);\n+    }\n+\n+    fn visit_ident(&mut self, sp: Span, id: ast::Ident, _: ()) {\n+        run_lints!(self, check_ident, sp, id);\n+    }\n+\n+    fn visit_mod(&mut self, m: &ast::Mod, s: Span, n: ast::NodeId, _: ()) {\n+        run_lints!(self, check_mod, m, s, n);\n+        visit::walk_mod(self, m, ());\n+    }\n+\n+    fn visit_local(&mut self, l: &ast::Local, _: ()) {\n+        run_lints!(self, check_local, l);\n+        visit::walk_local(self, l, ());\n+    }\n+\n+    fn visit_block(&mut self, b: &ast::Block, _: ()) {\n+        run_lints!(self, check_block, b);\n+        visit::walk_block(self, b, ());\n+    }\n+\n+    fn visit_arm(&mut self, a: &ast::Arm, _: ()) {\n+        run_lints!(self, check_arm, a);\n+        visit::walk_arm(self, a, ());\n+    }\n+\n+    fn visit_decl(&mut self, d: &ast::Decl, _: ()) {\n+        run_lints!(self, check_decl, d);\n+        visit::walk_decl(self, d, ());\n+    }\n+\n+    fn visit_expr_post(&mut self, e: &ast::Expr, _: ()) {\n+        run_lints!(self, check_expr_post, e);\n+    }\n+\n+    fn visit_generics(&mut self, g: &ast::Generics, _: ()) {\n+        run_lints!(self, check_generics, g);\n+        visit::walk_generics(self, g, ());\n+    }\n+\n+    fn visit_trait_method(&mut self, m: &ast::TraitMethod, _: ()) {\n+        run_lints!(self, check_trait_method, m);\n+        visit::walk_trait_method(self, m, ());\n+    }\n+\n+    fn visit_opt_lifetime_ref(&mut self, sp: Span, lt: &Option<ast::Lifetime>, _: ()) {\n+        run_lints!(self, check_opt_lifetime_ref, sp, lt);\n+    }\n+\n+    fn visit_lifetime_ref(&mut self, lt: &ast::Lifetime, _: ()) {\n+        run_lints!(self, check_lifetime_ref, lt);\n+    }\n+\n+    fn visit_lifetime_decl(&mut self, lt: &ast::Lifetime, _: ()) {\n+        run_lints!(self, check_lifetime_decl, lt);\n+    }\n+\n+    fn visit_explicit_self(&mut self, es: &ast::ExplicitSelf, _: ()) {\n+        run_lints!(self, check_explicit_self, es);\n+        visit::walk_explicit_self(self, es, ());\n+    }\n+\n+    fn visit_mac(&mut self, mac: &ast::Mac, _: ()) {\n+        run_lints!(self, check_mac, mac);\n+        visit::walk_mac(self, mac, ());\n+    }\n+\n+    fn visit_path(&mut self, p: &ast::Path, id: ast::NodeId, _: ()) {\n+        run_lints!(self, check_path, p, id);\n+        visit::walk_path(self, p, ());\n+    }\n+\n+    fn visit_attribute(&mut self, attr: &ast::Attribute, _: ()) {\n+        run_lints!(self, check_attribute, attr);\n+    }\n+}\n+\n+// Output any lints that were previously added to the session.\n+impl<'a> IdVisitingOperation for Context<'a> {\n+    fn visit_id(&self, id: ast::NodeId) {\n+        match self.tcx.sess.lints.borrow_mut().pop(&id) {\n+            None => {}\n+            Some(lints) => {\n+                for (lint_id, span, msg) in lints.move_iter() {\n+                    self.span_lint(lint_id.lint, span, msg.as_slice())\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// This lint pass is defined here because it touches parts of the `Context`\n+// that we don't want to expose. It records the lint level at certain AST\n+// nodes, so that the variant size difference check in trans can call\n+// `raw_emit_lint`.\n+\n+struct GatherNodeLevels;\n+\n+impl LintPass for GatherNodeLevels {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!()\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        match it.node {\n+            ast::ItemEnum(..) => {\n+                let lint_id = LintId::of(builtin::VARIANT_SIZE_DIFFERENCE);\n+                match cx.lints.get_level_source(lint_id) {\n+                    lvlsrc @ (lvl, _) if lvl != Allow => {\n+                        cx.node_levels.borrow_mut()\n+                            .insert((it.id, lint_id), lvlsrc);\n+                    },\n+                    _ => { }\n+                }\n+            },\n+            _ => { }\n+        }\n+    }\n+}\n+\n+/// Perform lint checking on a crate.\n+///\n+/// Consumes the `lint_store` field of the `Session`.\n+pub fn check_crate(tcx: &ty::ctxt,\n+                   krate: &ast::Crate,\n+                   exported_items: &ExportedItems) {\n+    let mut cx = Context::new(tcx, krate, exported_items);\n+\n+    // Visit the whole crate.\n+    cx.with_lint_attrs(krate.attrs.as_slice(), |cx| {\n+        cx.visit_id(ast::CRATE_NODE_ID);\n+        cx.visit_ids(|v| {\n+            v.visited_outermost = true;\n+            visit::walk_crate(v, krate, ());\n+        });\n+\n+        // since the root module isn't visited as an item (because it isn't an\n+        // item), warn for it here.\n+        run_lints!(cx, check_crate, krate);\n+\n+        visit::walk_crate(cx, krate, ());\n+    });\n+\n+    // If we missed any lints added to the session, then there's a bug somewhere\n+    // in the iteration code.\n+    for (id, v) in tcx.sess.lints.borrow().iter() {\n+        for &(lint, span, ref msg) in v.iter() {\n+            tcx.sess.span_bug(span,\n+                              format!(\"unprocessed lint {} at {}: {}\",\n+                                      lint.as_str(), tcx.map.node_to_str(*id), *msg).as_slice())\n+        }\n+    }\n+\n+    tcx.sess.abort_if_errors();\n+    *tcx.node_lint_levels.borrow_mut() = cx.node_levels.unwrap();\n+}"}, {"sha": "5aa10b5ab8e8ac9c91db7890ca68d13d3cc317bb", "filename": "src/librustc/lint/mod.rs", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -0,0 +1,253 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Lints, aka compiler warnings.\n+//!\n+//! A 'lint' check is a kind of miscellaneous constraint that a user _might_\n+//! want to enforce, but might reasonably want to permit as well, on a\n+//! module-by-module basis. They contrast with static constraints enforced by\n+//! other phases of the compiler, which are generally required to hold in order\n+//! to compile the program at all.\n+//!\n+//! Most lints can be written as `LintPass` instances. These run just before\n+//! translation to LLVM bytecode. The `LintPass`es built into rustc are defined\n+//! within `builtin.rs`, which has further comments on how to add such a lint.\n+//! rustc can also load user-defined lint plugins via the plugin mechanism.\n+//!\n+//! Some of rustc's lints are defined elsewhere in the compiler and work by\n+//! calling `add_lint()` on the overall `Session` object. This works when\n+//! it happens before the main lint pass, which emits the lints stored by\n+//! `add_lint()`. To emit lints after the main lint pass (from trans, for\n+//! example) requires more effort. See `emit_lint` and `GatherNodeLevels`\n+//! in `context.rs`.\n+\n+#![macro_escape]\n+\n+use std::hash;\n+use std::ascii::StrAsciiExt;\n+use syntax::codemap::Span;\n+use syntax::visit::FnKind;\n+use syntax::ast;\n+\n+pub use lint::context::{Context, LintStore, raw_emit_lint, check_crate, gather_attrs};\n+\n+/// Specification of a single lint.\n+pub struct Lint {\n+    /// A string identifier for the lint.\n+    ///\n+    /// This identifies the lint in attributes and in command-line arguments.\n+    /// In those contexts it is always lowercase, but this field is compared\n+    /// in a way which is case-insensitive for ASCII characters. This allows\n+    /// `declare_lint!()` invocations to follow the convention of upper-case\n+    /// statics without repeating the name.\n+    ///\n+    /// The name is written with underscores, e.g. \"unused_imports\".\n+    /// On the command line, underscores become dashes.\n+    pub name: &'static str,\n+\n+    /// Default level for the lint.\n+    pub default_level: Level,\n+\n+    /// Description of the lint or the issue it detects.\n+    ///\n+    /// e.g. \"imports that are never used\"\n+    pub desc: &'static str,\n+}\n+\n+impl Lint {\n+    /// Get the lint's name, with ASCII letters converted to lowercase.\n+    pub fn name_lower(&self) -> String {\n+        self.name.to_ascii_lower()\n+    }\n+}\n+\n+/// Build a `Lint` initializer.\n+#[macro_export]\n+macro_rules! lint_initializer (\n+    ($name:ident, $level:ident, $desc:expr) => (\n+        ::rustc::lint::Lint {\n+            name: stringify!($name),\n+            default_level: ::rustc::lint::$level,\n+            desc: $desc,\n+        }\n+    )\n+)\n+\n+/// Declare a static item of type `&'static Lint`.\n+#[macro_export]\n+macro_rules! declare_lint (\n+    // FIXME(#14660): deduplicate\n+    (pub $name:ident, $level:ident, $desc:expr) => (\n+        pub static $name: &'static ::rustc::lint::Lint\n+            = &lint_initializer!($name, $level, $desc);\n+    );\n+    ($name:ident, $level:ident, $desc:expr) => (\n+        static $name: &'static ::rustc::lint::Lint\n+            = &lint_initializer!($name, $level, $desc);\n+    );\n+)\n+\n+/// Declare a static `LintArray` and return it as an expression.\n+#[macro_export]\n+macro_rules! lint_array ( ($( $lint:expr ),*) => (\n+    {\n+        static array: LintArray = &[ $( $lint ),* ];\n+        array\n+    }\n+))\n+\n+pub type LintArray = &'static [&'static Lint];\n+\n+/// Trait for types providing lint checks.\n+///\n+/// Each `check` method checks a single syntax node, and should not\n+/// invoke methods recursively (unlike `Visitor`). By default they\n+/// do nothing.\n+//\n+// FIXME: eliminate the duplication with `Visitor`. But this also\n+// contains a few lint-specific methods with no equivalent in `Visitor`.\n+pub trait LintPass {\n+    /// Get descriptions of the lints this `LintPass` object can emit.\n+    ///\n+    /// NB: there is no enforcement that the object only emits lints it registered.\n+    /// And some `rustc` internal `LintPass`es register lints to be emitted by other\n+    /// parts of the compiler. If you want enforced access restrictions for your\n+    /// `Lint`, make it a private `static` item in its own module.\n+    fn get_lints(&self) -> LintArray;\n+\n+    fn check_crate(&mut self, _: &Context, _: &ast::Crate) { }\n+    fn check_ident(&mut self, _: &Context, _: Span, _: ast::Ident) { }\n+    fn check_mod(&mut self, _: &Context, _: &ast::Mod, _: Span, _: ast::NodeId) { }\n+    fn check_view_item(&mut self, _: &Context, _: &ast::ViewItem) { }\n+    fn check_foreign_item(&mut self, _: &Context, _: &ast::ForeignItem) { }\n+    fn check_item(&mut self, _: &Context, _: &ast::Item) { }\n+    fn check_local(&mut self, _: &Context, _: &ast::Local) { }\n+    fn check_block(&mut self, _: &Context, _: &ast::Block) { }\n+    fn check_stmt(&mut self, _: &Context, _: &ast::Stmt) { }\n+    fn check_arm(&mut self, _: &Context, _: &ast::Arm) { }\n+    fn check_pat(&mut self, _: &Context, _: &ast::Pat) { }\n+    fn check_decl(&mut self, _: &Context, _: &ast::Decl) { }\n+    fn check_expr(&mut self, _: &Context, _: &ast::Expr) { }\n+    fn check_expr_post(&mut self, _: &Context, _: &ast::Expr) { }\n+    fn check_ty(&mut self, _: &Context, _: &ast::Ty) { }\n+    fn check_generics(&mut self, _: &Context, _: &ast::Generics) { }\n+    fn check_fn(&mut self, _: &Context,\n+        _: &FnKind, _: &ast::FnDecl, _: &ast::Block, _: Span, _: ast::NodeId) { }\n+    fn check_ty_method(&mut self, _: &Context, _: &ast::TypeMethod) { }\n+    fn check_trait_method(&mut self, _: &Context, _: &ast::TraitMethod) { }\n+    fn check_struct_def(&mut self, _: &Context,\n+        _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, _: ast::NodeId) { }\n+    fn check_struct_def_post(&mut self, _: &Context,\n+        _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, _: ast::NodeId) { }\n+    fn check_struct_field(&mut self, _: &Context, _: &ast::StructField) { }\n+    fn check_variant(&mut self, _: &Context, _: &ast::Variant, _: &ast::Generics) { }\n+    fn check_opt_lifetime_ref(&mut self, _: &Context, _: Span, _: &Option<ast::Lifetime>) { }\n+    fn check_lifetime_ref(&mut self, _: &Context, _: &ast::Lifetime) { }\n+    fn check_lifetime_decl(&mut self, _: &Context, _: &ast::Lifetime) { }\n+    fn check_explicit_self(&mut self, _: &Context, _: &ast::ExplicitSelf) { }\n+    fn check_mac(&mut self, _: &Context, _: &ast::Mac) { }\n+    fn check_path(&mut self, _: &Context, _: &ast::Path, _: ast::NodeId) { }\n+    fn check_attribute(&mut self, _: &Context, _: &ast::Attribute) { }\n+\n+    /// Called when entering a syntax node that can have lint attributes such\n+    /// as `#[allow(...)]`. Called with *all* the attributes of that node.\n+    fn enter_lint_attrs(&mut self, _: &Context, _: &[ast::Attribute]) { }\n+\n+    /// Counterpart to `enter_lint_attrs`.\n+    fn exit_lint_attrs(&mut self, _: &Context, _: &[ast::Attribute]) { }\n+}\n+\n+/// A lint pass boxed up as a trait object.\n+pub type LintPassObject = Box<LintPass + 'static>;\n+\n+/// Identifies a lint known to the compiler.\n+#[deriving(Clone)]\n+pub struct LintId {\n+    // Identity is based on pointer equality of this field.\n+    lint: &'static Lint,\n+}\n+\n+impl PartialEq for LintId {\n+    fn eq(&self, other: &LintId) -> bool {\n+        (self.lint as *Lint) == (other.lint as *Lint)\n+    }\n+}\n+\n+impl Eq for LintId { }\n+\n+impl<S: hash::Writer> hash::Hash<S> for LintId {\n+    fn hash(&self, state: &mut S) {\n+        let ptr = self.lint as *Lint;\n+        ptr.hash(state);\n+    }\n+}\n+\n+impl LintId {\n+    /// Get the `LintId` for a `Lint`.\n+    pub fn of(lint: &'static Lint) -> LintId {\n+        LintId {\n+            lint: lint,\n+        }\n+    }\n+\n+    /// Get the name of the lint.\n+    pub fn as_str(&self) -> String {\n+        self.lint.name_lower()\n+    }\n+}\n+\n+/// Setting for how to handle a lint.\n+#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord)]\n+pub enum Level {\n+    Allow, Warn, Deny, Forbid\n+}\n+\n+impl Level {\n+    /// Convert a level to a lower-case string.\n+    pub fn as_str(self) -> &'static str {\n+        match self {\n+            Allow => \"allow\",\n+            Warn => \"warn\",\n+            Deny => \"deny\",\n+            Forbid => \"forbid\",\n+        }\n+    }\n+\n+    /// Convert a lower-case string to a level.\n+    pub fn from_str(x: &str) -> Option<Level> {\n+        match x {\n+            \"allow\" => Some(Allow),\n+            \"warn\" => Some(Warn),\n+            \"deny\" => Some(Deny),\n+            \"forbid\" => Some(Forbid),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+/// How a lint level was set.\n+#[deriving(Clone, PartialEq, Eq)]\n+pub enum LintSource {\n+    /// Lint is at the default level as declared\n+    /// in rustc or a plugin.\n+    Default,\n+\n+    /// Lint level was set by an attribute.\n+    Node(Span),\n+\n+    /// Lint level was set by a command-line flag.\n+    CommandLine,\n+}\n+\n+pub type LevelSource = (Level, LintSource);\n+\n+pub mod builtin;\n+\n+mod context;"}, {"sha": "156b8840067720b29fe8b29112d19e304fb24098", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -13,7 +13,7 @@\n // from live codes are live, and everything else is dead.\n \n use middle::def;\n-use middle::lint::{Allow, contains_lint, DeadCode};\n+use lint;\n use middle::privacy;\n use middle::ty;\n use middle::typeck;\n@@ -23,14 +23,13 @@ use std::collections::HashSet;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::{local_def, is_local};\n+use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n use syntax::codemap;\n use syntax::parse::token;\n use syntax::visit::Visitor;\n use syntax::visit;\n \n-pub static DEAD_CODE_LINT_STR: &'static str = \"dead_code\";\n-\n // Any local node that may call something in its body block should be\n // explored. For example, if it's a live NodeItem that is a\n // function, then we should explore its block to check for codes that\n@@ -266,8 +265,19 @@ impl<'a> Visitor<MarkSymbolVisitorContext> for MarkSymbolVisitor<'a> {\n }\n \n fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n-    contains_lint(attrs, Allow, DEAD_CODE_LINT_STR)\n-    || attr::contains_name(attrs.as_slice(), \"lang\")\n+    if attr::contains_name(attrs.as_slice(), \"lang\") {\n+        return true;\n+    }\n+\n+    let dead_code = lint::builtin::DEAD_CODE.name_lower();\n+    for attr in lint::gather_attrs(attrs).move_iter() {\n+        match attr {\n+            Ok((ref name, lint::Allow, _))\n+                if name.get() == dead_code.as_slice() => return true,\n+            _ => (),\n+        }\n+    }\n+    false\n }\n \n // This visitor seeds items that\n@@ -446,7 +456,7 @@ impl<'a> DeadVisitor<'a> {\n                       ident: ast::Ident) {\n         self.tcx\n             .sess\n-            .add_lint(DeadCode,\n+            .add_lint(lint::builtin::DEAD_CODE,\n                       id,\n                       span,\n                       format!(\"code is never used: `{}`\","}, {"sha": "c2fad75d6b89b490ffd488b365fc2f6680827467", "filename": "src/librustc/middle/lint.rs", "status": "removed", "additions": 0, "deletions": 1988, "changes": 1988, "blob_url": "https://github.com/rust-lang/rust/blob/87f3741fdf6356d57d22f8154cf6069a83dec8d7/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87f3741fdf6356d57d22f8154cf6069a83dec8d7/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=87f3741fdf6356d57d22f8154cf6069a83dec8d7", "patch": "@@ -1,1988 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A 'lint' check is a kind of miscellaneous constraint that a user _might_\n-//! want to enforce, but might reasonably want to permit as well, on a\n-//! module-by-module basis. They contrast with static constraints enforced by\n-//! other phases of the compiler, which are generally required to hold in order\n-//! to compile the program at all.\n-//!\n-//! The lint checking is all consolidated into one pass which runs just before\n-//! translation to LLVM bytecode. Throughout compilation, lint warnings can be\n-//! added via the `add_lint` method on the Session structure. This requires a\n-//! span and an id of the node that the lint is being added to. The lint isn't\n-//! actually emitted at that time because it is unknown what the actual lint\n-//! level at that location is.\n-//!\n-//! To actually emit lint warnings/errors, a separate pass is used just before\n-//! translation. A context keeps track of the current state of all lint levels.\n-//! Upon entering a node of the ast which can modify the lint settings, the\n-//! previous lint state is pushed onto a stack and the ast is then recursed\n-//! upon.  As the ast is traversed, this keeps track of the current lint level\n-//! for all lint attributes.\n-//!\n-//! To add a new lint warning, all you need to do is to either invoke `add_lint`\n-//! on the session at the appropriate time, or write a few linting functions and\n-//! modify the Context visitor appropriately. If you're adding lints from the\n-//! Context itself, span_lint should be used instead of add_lint.\n-\n-#![allow(non_camel_case_types)]\n-\n-use driver::session;\n-use metadata::csearch;\n-use middle::dead::DEAD_CODE_LINT_STR;\n-use middle::def;\n-use middle::def::*;\n-use middle::pat_util;\n-use middle::privacy;\n-use middle::trans::adt; // for `adt::is_ffi_safe`\n-use middle::ty;\n-use middle::typeck::astconv::{ast_ty_to_ty, AstConv};\n-use middle::typeck::infer;\n-use middle::typeck;\n-use util::ppaux::{ty_to_str};\n-use util::nodemap::NodeSet;\n-\n-use std::cmp;\n-use std::collections::HashMap;\n-use std::i16;\n-use std::i32;\n-use std::i64;\n-use std::i8;\n-use std::rc::Rc;\n-use std::gc::Gc;\n-use std::to_str::ToStr;\n-use std::u16;\n-use std::u32;\n-use std::u64;\n-use std::u8;\n-use std::collections::SmallIntMap;\n-use syntax::abi;\n-use syntax::ast_map;\n-use syntax::ast_util::IdVisitingOperation;\n-use syntax::attr::AttrMetaMethods;\n-use syntax::attr;\n-use syntax::codemap::Span;\n-use syntax::parse::token::InternedString;\n-use syntax::parse::token;\n-use syntax::visit::Visitor;\n-use syntax::{ast, ast_util, visit};\n-\n-#[deriving(Clone, Show, PartialEq, PartialOrd, Eq, Ord, Hash)]\n-pub enum Lint {\n-    CTypes,\n-    UnusedImports,\n-    UnnecessaryQualification,\n-    WhileTrue,\n-    PathStatement,\n-    UnrecognizedLint,\n-    NonCamelCaseTypes,\n-    NonUppercaseStatics,\n-    NonUppercasePatternStatics,\n-    NonSnakeCaseFunctions,\n-    UppercaseVariables,\n-    UnnecessaryParens,\n-    TypeLimits,\n-    TypeOverflow,\n-    UnusedUnsafe,\n-    UnsafeBlock,\n-    UnusedAttribute,\n-    UnknownFeatures,\n-    UnknownCrateType,\n-    UnsignedNegate,\n-    VariantSizeDifference,\n-\n-    ManagedHeapMemory,\n-    OwnedHeapMemory,\n-    HeapMemory,\n-\n-    UnusedVariable,\n-    DeadAssignment,\n-    UnusedMut,\n-    UnnecessaryAllocation,\n-    DeadCode,\n-    VisiblePrivateTypes,\n-    UnnecessaryTypecast,\n-\n-    MissingDoc,\n-    UnreachableCode,\n-\n-    Deprecated,\n-    Experimental,\n-    Unstable,\n-\n-    UnusedMustUse,\n-    UnusedResult,\n-\n-    Warnings,\n-\n-    RawPointerDeriving,\n-}\n-\n-pub fn level_to_str(lv: Level) -> &'static str {\n-    match lv {\n-      Allow => \"allow\",\n-      Warn => \"warn\",\n-      Deny => \"deny\",\n-      Forbid => \"forbid\"\n-    }\n-}\n-\n-#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord)]\n-pub enum Level {\n-    Allow, Warn, Deny, Forbid\n-}\n-\n-#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord)]\n-pub struct LintSpec {\n-    pub default: Level,\n-    pub lint: Lint,\n-    pub desc: &'static str,\n-}\n-\n-pub type LintDict = HashMap<&'static str, LintSpec>;\n-\n-// this is public for the lints that run in trans\n-#[deriving(PartialEq)]\n-pub enum LintSource {\n-    Node(Span),\n-    Default,\n-    CommandLine\n-}\n-\n-static lint_table: &'static [(&'static str, LintSpec)] = &[\n-    (\"ctypes\",\n-     LintSpec {\n-        lint: CTypes,\n-        desc: \"proper use of libc types in foreign modules\",\n-        default: Warn\n-     }),\n-\n-    (\"unused_imports\",\n-     LintSpec {\n-        lint: UnusedImports,\n-        desc: \"imports that are never used\",\n-        default: Warn\n-     }),\n-\n-    (\"unnecessary_qualification\",\n-     LintSpec {\n-        lint: UnnecessaryQualification,\n-        desc: \"detects unnecessarily qualified names\",\n-        default: Allow\n-     }),\n-\n-    (\"while_true\",\n-     LintSpec {\n-        lint: WhileTrue,\n-        desc: \"suggest using `loop { }` instead of `while true { }`\",\n-        default: Warn\n-     }),\n-\n-    (\"path_statement\",\n-     LintSpec {\n-        lint: PathStatement,\n-        desc: \"path statements with no effect\",\n-        default: Warn\n-     }),\n-\n-    (\"unrecognized_lint\",\n-     LintSpec {\n-        lint: UnrecognizedLint,\n-        desc: \"unrecognized lint attribute\",\n-        default: Warn\n-     }),\n-\n-    (\"non_camel_case_types\",\n-     LintSpec {\n-        lint: NonCamelCaseTypes,\n-        desc: \"types, variants and traits should have camel case names\",\n-        default: Warn\n-     }),\n-\n-    (\"non_uppercase_statics\",\n-     LintSpec {\n-         lint: NonUppercaseStatics,\n-         desc: \"static constants should have uppercase identifiers\",\n-         default: Allow\n-     }),\n-\n-    (\"non_uppercase_pattern_statics\",\n-     LintSpec {\n-         lint: NonUppercasePatternStatics,\n-         desc: \"static constants in match patterns should be all caps\",\n-         default: Warn\n-     }),\n-\n-    (\"non_snake_case_functions\",\n-     LintSpec {\n-         lint: NonSnakeCaseFunctions,\n-         desc: \"methods and functions should have snake case names\",\n-         default: Warn\n-     }),\n-\n-    (\"uppercase_variables\",\n-     LintSpec {\n-         lint: UppercaseVariables,\n-         desc: \"variable and structure field names should start with a lowercase character\",\n-         default: Warn\n-     }),\n-\n-     (\"unnecessary_parens\",\n-     LintSpec {\n-        lint: UnnecessaryParens,\n-        desc: \"`if`, `match`, `while` and `return` do not need parentheses\",\n-        default: Warn\n-     }),\n-\n-    (\"managed_heap_memory\",\n-     LintSpec {\n-        lint: ManagedHeapMemory,\n-        desc: \"use of managed (@ type) heap memory\",\n-        default: Allow\n-     }),\n-\n-    (\"owned_heap_memory\",\n-     LintSpec {\n-        lint: OwnedHeapMemory,\n-        desc: \"use of owned (Box type) heap memory\",\n-        default: Allow\n-     }),\n-\n-    (\"heap_memory\",\n-     LintSpec {\n-        lint: HeapMemory,\n-        desc: \"use of any (Box type or @ type) heap memory\",\n-        default: Allow\n-     }),\n-\n-    (\"type_limits\",\n-     LintSpec {\n-        lint: TypeLimits,\n-        desc: \"comparisons made useless by limits of the types involved\",\n-        default: Warn\n-     }),\n-\n-    (\"type_overflow\",\n-     LintSpec {\n-        lint: TypeOverflow,\n-        desc: \"literal out of range for its type\",\n-        default: Warn\n-     }),\n-\n-\n-    (\"unused_unsafe\",\n-     LintSpec {\n-        lint: UnusedUnsafe,\n-        desc: \"unnecessary use of an `unsafe` block\",\n-        default: Warn\n-    }),\n-\n-    (\"unsafe_block\",\n-     LintSpec {\n-        lint: UnsafeBlock,\n-        desc: \"usage of an `unsafe` block\",\n-        default: Allow\n-    }),\n-\n-    (\"unused_attribute\",\n-     LintSpec {\n-         lint: UnusedAttribute,\n-         desc: \"detects attributes that were not used by the compiler\",\n-         default: Warn\n-    }),\n-\n-    (\"unused_variable\",\n-     LintSpec {\n-        lint: UnusedVariable,\n-        desc: \"detect variables which are not used in any way\",\n-        default: Warn\n-    }),\n-\n-    (\"dead_assignment\",\n-     LintSpec {\n-        lint: DeadAssignment,\n-        desc: \"detect assignments that will never be read\",\n-        default: Warn\n-    }),\n-\n-    (\"unnecessary_typecast\",\n-     LintSpec {\n-        lint: UnnecessaryTypecast,\n-        desc: \"detects unnecessary type casts, that can be removed\",\n-        default: Allow,\n-    }),\n-\n-    (\"unused_mut\",\n-     LintSpec {\n-        lint: UnusedMut,\n-        desc: \"detect mut variables which don't need to be mutable\",\n-        default: Warn\n-    }),\n-\n-    (\"unnecessary_allocation\",\n-     LintSpec {\n-        lint: UnnecessaryAllocation,\n-        desc: \"detects unnecessary allocations that can be eliminated\",\n-        default: Warn\n-    }),\n-\n-    (DEAD_CODE_LINT_STR,\n-     LintSpec {\n-        lint: DeadCode,\n-        desc: \"detect piece of code that will never be used\",\n-        default: Warn\n-    }),\n-    (\"visible_private_types\",\n-     LintSpec {\n-        lint: VisiblePrivateTypes,\n-        desc: \"detect use of private types in exported type signatures\",\n-        default: Warn\n-    }),\n-\n-    (\"missing_doc\",\n-     LintSpec {\n-        lint: MissingDoc,\n-        desc: \"detects missing documentation for public members\",\n-        default: Allow\n-    }),\n-\n-    (\"unreachable_code\",\n-     LintSpec {\n-        lint: UnreachableCode,\n-        desc: \"detects unreachable code\",\n-        default: Warn\n-    }),\n-\n-    (\"deprecated\",\n-     LintSpec {\n-        lint: Deprecated,\n-        desc: \"detects use of #[deprecated] items\",\n-        default: Warn\n-    }),\n-\n-    (\"experimental\",\n-     LintSpec {\n-        lint: Experimental,\n-        desc: \"detects use of #[experimental] items\",\n-        // FIXME #6875: Change to Warn after std library stabilization is complete\n-        default: Allow\n-    }),\n-\n-    (\"unstable\",\n-     LintSpec {\n-        lint: Unstable,\n-        desc: \"detects use of #[unstable] items (incl. items with no stability attribute)\",\n-        default: Allow\n-    }),\n-\n-    (\"warnings\",\n-     LintSpec {\n-        lint: Warnings,\n-        desc: \"mass-change the level for lints which produce warnings\",\n-        default: Warn\n-    }),\n-\n-    (\"unknown_features\",\n-     LintSpec {\n-        lint: UnknownFeatures,\n-        desc: \"unknown features found in crate-level #[feature] directives\",\n-        default: Deny,\n-    }),\n-\n-    (\"unknown_crate_type\",\n-    LintSpec {\n-        lint: UnknownCrateType,\n-        desc: \"unknown crate type found in #[crate_type] directive\",\n-        default: Deny,\n-    }),\n-\n-    (\"unsigned_negate\",\n-    LintSpec {\n-        lint: UnsignedNegate,\n-        desc: \"using an unary minus operator on unsigned type\",\n-        default: Warn\n-    }),\n-\n-    (\"variant_size_difference\",\n-    LintSpec {\n-        lint: VariantSizeDifference,\n-        desc: \"detects enums with widely varying variant sizes\",\n-        default: Allow,\n-    }),\n-\n-    (\"unused_must_use\",\n-    LintSpec {\n-        lint: UnusedMustUse,\n-        desc: \"unused result of a type flagged as #[must_use]\",\n-        default: Warn,\n-    }),\n-\n-    (\"unused_result\",\n-    LintSpec {\n-        lint: UnusedResult,\n-        desc: \"unused result of an expression in a statement\",\n-        default: Allow,\n-    }),\n-\n-    (\"raw_pointer_deriving\",\n-     LintSpec {\n-        lint: RawPointerDeriving,\n-        desc: \"uses of #[deriving] with raw pointers are rarely correct\",\n-        default: Warn,\n-    }),\n-];\n-\n-/*\n-  Pass names should not contain a '-', as the compiler normalizes\n-  '-' to '_' in command-line flags\n- */\n-pub fn get_lint_dict() -> LintDict {\n-    lint_table.iter().map(|&(k, v)| (k, v)).collect()\n-}\n-\n-struct Context<'a> {\n-    /// All known lint modes (string versions)\n-    dict: LintDict,\n-    /// Current levels of each lint warning\n-    cur: SmallIntMap<(Level, LintSource)>,\n-    /// Context we're checking in (used to access fields like sess)\n-    tcx: &'a ty::ctxt,\n-    /// Items exported by the crate; used by the missing_doc lint.\n-    exported_items: &'a privacy::ExportedItems,\n-    /// The id of the current `ast::StructDef` being walked.\n-    cur_struct_def_id: ast::NodeId,\n-    /// Whether some ancestor of the current node was marked\n-    /// #[doc(hidden)].\n-    is_doc_hidden: bool,\n-\n-    /// When recursing into an attributed node of the ast which modifies lint\n-    /// levels, this stack keeps track of the previous lint levels of whatever\n-    /// was modified.\n-    lint_stack: Vec<(Lint, Level, LintSource)>,\n-\n-    /// Id of the last visited negated expression\n-    negated_expr_id: ast::NodeId,\n-\n-    /// Ids of structs/enums which have been checked for raw_pointer_deriving\n-    checked_raw_pointers: NodeSet,\n-\n-    /// Level of lints for certain NodeIds, stored here because the body of\n-    /// the lint needs to run in trans.\n-    node_levels: HashMap<(ast::NodeId, Lint), (Level, LintSource)>,\n-}\n-\n-pub fn emit_lint(level: Level, src: LintSource, msg: &str, span: Span,\n-                 lint_str: &str, tcx: &ty::ctxt) {\n-    if level == Allow { return }\n-\n-    let mut note = None;\n-    let msg = match src {\n-        Default => {\n-            format!(\"{}, #[{}({})] on by default\", msg,\n-                level_to_str(level), lint_str)\n-        },\n-        CommandLine => {\n-            format!(\"{} [-{} {}]\", msg,\n-                match level {\n-                    Warn => 'W', Deny => 'D', Forbid => 'F',\n-                    Allow => fail!()\n-                }, lint_str.replace(\"_\", \"-\"))\n-        },\n-        Node(src) => {\n-            note = Some(src);\n-            msg.to_str()\n-        }\n-    };\n-\n-    match level {\n-        Warn =>          { tcx.sess.span_warn(span, msg.as_slice()); }\n-        Deny | Forbid => { tcx.sess.span_err(span, msg.as_slice());  }\n-        Allow => fail!(),\n-    }\n-\n-    for &span in note.iter() {\n-        tcx.sess.span_note(span, \"lint level defined here\");\n-    }\n-}\n-\n-pub fn lint_to_str(lint: Lint) -> &'static str {\n-    for &(name, lspec) in lint_table.iter() {\n-        if lspec.lint == lint {\n-            return name;\n-        }\n-    }\n-\n-    fail!(\"unrecognized lint: {}\", lint);\n-}\n-\n-impl<'a> Context<'a> {\n-    fn get_level(&self, lint: Lint) -> Level {\n-        match self.cur.find(&(lint as uint)) {\n-          Some(&(lvl, _)) => lvl,\n-          None => Allow\n-        }\n-    }\n-\n-    fn get_source(&self, lint: Lint) -> LintSource {\n-        match self.cur.find(&(lint as uint)) {\n-          Some(&(_, src)) => src,\n-          None => Default\n-        }\n-    }\n-\n-    fn set_level(&mut self, lint: Lint, level: Level, src: LintSource) {\n-        if level == Allow {\n-            self.cur.remove(&(lint as uint));\n-        } else {\n-            self.cur.insert(lint as uint, (level, src));\n-        }\n-    }\n-\n-    fn lint_to_str(&self, lint: Lint) -> &'static str {\n-        for (k, v) in self.dict.iter() {\n-            if v.lint == lint {\n-                return *k;\n-            }\n-        }\n-        fail!(\"unregistered lint {}\", lint);\n-    }\n-\n-    fn span_lint(&self, lint: Lint, span: Span, msg: &str) {\n-        let (level, src) = match self.cur.find(&(lint as uint)) {\n-            None => { return }\n-            Some(&(Warn, src)) => (self.get_level(Warnings), src),\n-            Some(&pair) => pair,\n-        };\n-\n-        emit_lint(level, src, msg, span, self.lint_to_str(lint), self.tcx);\n-    }\n-\n-    /**\n-     * Merge the lints specified by any lint attributes into the\n-     * current lint context, call the provided function, then reset the\n-     * lints in effect to their previous state.\n-     */\n-    fn with_lint_attrs(&mut self,\n-                       attrs: &[ast::Attribute],\n-                       f: |&mut Context|) {\n-        // Parse all of the lint attributes, and then add them all to the\n-        // current dictionary of lint information. Along the way, keep a history\n-        // of what we changed so we can roll everything back after invoking the\n-        // specified closure\n-        let mut pushed = 0u;\n-        each_lint(&self.tcx.sess, attrs, |meta, level, lintname| {\n-            match self.dict.find_equiv(&lintname) {\n-                None => {\n-                    self.span_lint(\n-                        UnrecognizedLint,\n-                        meta.span,\n-                        format!(\"unknown `{}` attribute: `{}`\",\n-                                level_to_str(level), lintname).as_slice());\n-                }\n-                Some(lint) => {\n-                    let lint = lint.lint;\n-                    let now = self.get_level(lint);\n-                    if now == Forbid && level != Forbid {\n-                        self.tcx.sess.span_err(meta.span,\n-                        format!(\"{}({}) overruled by outer forbid({})\",\n-                                level_to_str(level),\n-                                lintname,\n-                                lintname).as_slice());\n-                    } else if now != level {\n-                        let src = self.get_source(lint);\n-                        self.lint_stack.push((lint, now, src));\n-                        pushed += 1;\n-                        self.set_level(lint, level, Node(meta.span));\n-                    }\n-                }\n-            }\n-            true\n-        });\n-\n-        let old_is_doc_hidden = self.is_doc_hidden;\n-        self.is_doc_hidden =\n-            self.is_doc_hidden ||\n-            attrs.iter()\n-                 .any(|attr| {\n-                     attr.name().equiv(&(\"doc\")) &&\n-                     match attr.meta_item_list() {\n-                         None => false,\n-                         Some(l) => {\n-                             attr::contains_name(l.as_slice(), \"hidden\")\n-                         }\n-                     }\n-                 });\n-\n-        f(self);\n-\n-        // rollback\n-        self.is_doc_hidden = old_is_doc_hidden;\n-        for _ in range(0, pushed) {\n-            let (lint, lvl, src) = self.lint_stack.pop().unwrap();\n-            self.set_level(lint, lvl, src);\n-        }\n-    }\n-\n-    fn visit_ids(&self, f: |&mut ast_util::IdVisitor<Context>|) {\n-        let mut v = ast_util::IdVisitor {\n-            operation: self,\n-            pass_through_items: false,\n-            visited_outermost: false,\n-        };\n-        f(&mut v);\n-    }\n-}\n-\n-/// Check that every lint from the list of attributes satisfies `f`.\n-/// Return true if that's the case. Otherwise return false.\n-pub fn each_lint(sess: &session::Session,\n-                 attrs: &[ast::Attribute],\n-                 f: |Gc<ast::MetaItem>, Level, InternedString| -> bool)\n-                 -> bool {\n-    let xs = [Allow, Warn, Deny, Forbid];\n-    for &level in xs.iter() {\n-        let level_name = level_to_str(level);\n-        for attr in attrs.iter().filter(|m| m.check_name(level_name)) {\n-            let meta = attr.node.value;\n-            let metas = match meta.node {\n-                ast::MetaList(_, ref metas) => metas,\n-                _ => {\n-                    sess.span_err(meta.span, \"malformed lint attribute\");\n-                    continue;\n-                }\n-            };\n-            for meta in metas.iter() {\n-                match meta.node {\n-                    ast::MetaWord(ref lintname) => {\n-                        if !f(*meta, level, (*lintname).clone()) {\n-                            return false;\n-                        }\n-                    }\n-                    _ => {\n-                        sess.span_err(meta.span, \"malformed lint attribute\");\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    true\n-}\n-\n-/// Check from a list of attributes if it contains the appropriate\n-/// `#[level(lintname)]` attribute (e.g. `#[allow(dead_code)]).\n-pub fn contains_lint(attrs: &[ast::Attribute],\n-                     level: Level,\n-                     lintname: &'static str)\n-                     -> bool {\n-    let level_name = level_to_str(level);\n-    for attr in attrs.iter().filter(|m| m.name().equiv(&level_name)) {\n-        if attr.meta_item_list().is_none() {\n-            continue\n-        }\n-        let list = attr.meta_item_list().unwrap();\n-        for meta_item in list.iter() {\n-            if meta_item.name().equiv(&lintname) {\n-                return true;\n-            }\n-        }\n-    }\n-    false\n-}\n-\n-fn check_while_true_expr(cx: &Context, e: &ast::Expr) {\n-    match e.node {\n-        ast::ExprWhile(cond, _) => {\n-            match cond.node {\n-                ast::ExprLit(lit) => {\n-                    match lit.node {\n-                        ast::LitBool(true) => {\n-                            cx.span_lint(WhileTrue,\n-                                         e.span,\n-                                         \"denote infinite loops with loop \\\n-                                          { ... }\");\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-                _ => ()\n-            }\n-        }\n-        _ => ()\n-    }\n-}\n-impl<'a> AstConv for Context<'a>{\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n-\n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n-        ty::lookup_item_type(self.tcx, id)\n-    }\n-\n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n-        ty::lookup_trait_def(self.tcx, id)\n-    }\n-\n-    fn ty_infer(&self, _span: Span) -> ty::t {\n-        infer::new_infer_ctxt(self.tcx).next_ty_var()\n-    }\n-}\n-\n-\n-fn check_unused_casts(cx: &Context, e: &ast::Expr) {\n-    return match e.node {\n-        ast::ExprCast(expr, ty) => {\n-            let t_t = ast_ty_to_ty(cx, &infer::new_infer_ctxt(cx.tcx), &*ty);\n-            if  ty::get(ty::expr_ty(cx.tcx, &*expr)).sty == ty::get(t_t).sty {\n-                cx.span_lint(UnnecessaryTypecast, ty.span,\n-                             \"unnecessary type cast\");\n-            }\n-        }\n-        _ => ()\n-    };\n-}\n-\n-fn check_type_limits(cx: &Context, e: &ast::Expr) {\n-    return match e.node {\n-        ast::ExprUnary(ast::UnNeg, ex) => {\n-            match ex.node  {\n-                ast::ExprLit(lit) => {\n-                    match lit.node {\n-                        ast::LitUint(..) => {\n-                            cx.span_lint(UnsignedNegate, e.span,\n-                                         \"negation of unsigned int literal may be unintentional\");\n-                        },\n-                        _ => ()\n-                    }\n-                },\n-                _ => {\n-                    let t = ty::expr_ty(cx.tcx, &*ex);\n-                    match ty::get(t).sty {\n-                        ty::ty_uint(_) => {\n-                            cx.span_lint(UnsignedNegate, e.span,\n-                                         \"negation of unsigned int variable may be unintentional\");\n-                        },\n-                        _ => ()\n-                    }\n-                }\n-            }\n-        },\n-        ast::ExprBinary(binop, l, r) => {\n-            if is_comparison(binop) && !check_limits(cx.tcx, binop, &*l, &*r) {\n-                cx.span_lint(TypeLimits, e.span,\n-                             \"comparison is useless due to type limits\");\n-            }\n-        },\n-        ast::ExprLit(lit) => {\n-            match ty::get(ty::expr_ty(cx.tcx, e)).sty {\n-                ty::ty_int(t) => {\n-                    let int_type = if t == ast::TyI {\n-                        cx.tcx.sess.targ_cfg.int_type\n-                    } else { t };\n-                    let (min, max) = int_ty_range(int_type);\n-                    let mut lit_val: i64 = match lit.node {\n-                        ast::LitInt(v, _) => v,\n-                        ast::LitUint(v, _) => v as i64,\n-                        ast::LitIntUnsuffixed(v) => v,\n-                        _ => fail!()\n-                    };\n-                    if cx.negated_expr_id == e.id {\n-                        lit_val *= -1;\n-                    }\n-                    if  lit_val < min || lit_val > max {\n-                        cx.span_lint(TypeOverflow, e.span,\n-                                     \"literal out of range for its type\");\n-                    }\n-                },\n-                ty::ty_uint(t) => {\n-                    let uint_type = if t == ast::TyU {\n-                        cx.tcx.sess.targ_cfg.uint_type\n-                    } else { t };\n-                    let (min, max) = uint_ty_range(uint_type);\n-                    let lit_val: u64 = match lit.node {\n-                        ast::LitByte(_v) => return,  // _v is u8, within range by definition\n-                        ast::LitInt(v, _) => v as u64,\n-                        ast::LitUint(v, _) => v,\n-                        ast::LitIntUnsuffixed(v) => v as u64,\n-                        _ => fail!()\n-                    };\n-                    if  lit_val < min || lit_val > max {\n-                        cx.span_lint(TypeOverflow, e.span,\n-                                     \"literal out of range for its type\");\n-                    }\n-                },\n-\n-                _ => ()\n-            };\n-        },\n-        _ => ()\n-    };\n-\n-    fn is_valid<T:cmp::PartialOrd>(binop: ast::BinOp, v: T,\n-                            min: T, max: T) -> bool {\n-        match binop {\n-            ast::BiLt => v >  min && v <= max,\n-            ast::BiLe => v >= min && v <  max,\n-            ast::BiGt => v >= min && v <  max,\n-            ast::BiGe => v >  min && v <= max,\n-            ast::BiEq | ast::BiNe => v >= min && v <= max,\n-            _ => fail!()\n-        }\n-    }\n-\n-    fn rev_binop(binop: ast::BinOp) -> ast::BinOp {\n-        match binop {\n-            ast::BiLt => ast::BiGt,\n-            ast::BiLe => ast::BiGe,\n-            ast::BiGt => ast::BiLt,\n-            ast::BiGe => ast::BiLe,\n-            _ => binop\n-        }\n-    }\n-\n-    // for int & uint, be conservative with the warnings, so that the\n-    // warnings are consistent between 32- and 64-bit platforms\n-    fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n-        match int_ty {\n-            ast::TyI =>    (i64::MIN,        i64::MAX),\n-            ast::TyI8 =>   (i8::MIN  as i64, i8::MAX  as i64),\n-            ast::TyI16 =>  (i16::MIN as i64, i16::MAX as i64),\n-            ast::TyI32 =>  (i32::MIN as i64, i32::MAX as i64),\n-            ast::TyI64 =>  (i64::MIN,        i64::MAX)\n-        }\n-    }\n-\n-    fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n-        match uint_ty {\n-            ast::TyU =>   (u64::MIN,         u64::MAX),\n-            ast::TyU8 =>  (u8::MIN   as u64, u8::MAX   as u64),\n-            ast::TyU16 => (u16::MIN  as u64, u16::MAX  as u64),\n-            ast::TyU32 => (u32::MIN  as u64, u32::MAX  as u64),\n-            ast::TyU64 => (u64::MIN,         u64::MAX)\n-        }\n-    }\n-\n-    fn check_limits(tcx: &ty::ctxt, binop: ast::BinOp,\n-                    l: &ast::Expr, r: &ast::Expr) -> bool {\n-        let (lit, expr, swap) = match (&l.node, &r.node) {\n-            (&ast::ExprLit(_), _) => (l, r, true),\n-            (_, &ast::ExprLit(_)) => (r, l, false),\n-            _ => return true\n-        };\n-        // Normalize the binop so that the literal is always on the RHS in\n-        // the comparison\n-        let norm_binop = if swap { rev_binop(binop) } else { binop };\n-        match ty::get(ty::expr_ty(tcx, expr)).sty {\n-            ty::ty_int(int_ty) => {\n-                let (min, max) = int_ty_range(int_ty);\n-                let lit_val: i64 = match lit.node {\n-                    ast::ExprLit(li) => match li.node {\n-                        ast::LitInt(v, _) => v,\n-                        ast::LitUint(v, _) => v as i64,\n-                        ast::LitIntUnsuffixed(v) => v,\n-                        _ => return true\n-                    },\n-                    _ => fail!()\n-                };\n-                is_valid(norm_binop, lit_val, min, max)\n-            }\n-            ty::ty_uint(uint_ty) => {\n-                let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n-                let lit_val: u64 = match lit.node {\n-                    ast::ExprLit(li) => match li.node {\n-                        ast::LitInt(v, _) => v as u64,\n-                        ast::LitUint(v, _) => v,\n-                        ast::LitIntUnsuffixed(v) => v as u64,\n-                        _ => return true\n-                    },\n-                    _ => fail!()\n-                };\n-                is_valid(norm_binop, lit_val, min, max)\n-            }\n-            _ => true\n-        }\n-    }\n-\n-    fn is_comparison(binop: ast::BinOp) -> bool {\n-        match binop {\n-            ast::BiEq | ast::BiLt | ast::BiLe |\n-            ast::BiNe | ast::BiGe | ast::BiGt => true,\n-            _ => false\n-        }\n-    }\n-}\n-\n-fn check_item_ctypes(cx: &Context, it: &ast::Item) {\n-    fn check_ty(cx: &Context, ty: &ast::Ty) {\n-        match ty.node {\n-            ast::TyPath(_, _, id) => {\n-                match cx.tcx.def_map.borrow().get_copy(&id) {\n-                    def::DefPrimTy(ast::TyInt(ast::TyI)) => {\n-                        cx.span_lint(CTypes, ty.span,\n-                                \"found rust type `int` in foreign module, while \\\n-                                libc::c_int or libc::c_long should be used\");\n-                    }\n-                    def::DefPrimTy(ast::TyUint(ast::TyU)) => {\n-                        cx.span_lint(CTypes, ty.span,\n-                                \"found rust type `uint` in foreign module, while \\\n-                                libc::c_uint or libc::c_ulong should be used\");\n-                    }\n-                    def::DefTy(def_id) => {\n-                        if !adt::is_ffi_safe(cx.tcx, def_id) {\n-                            cx.span_lint(CTypes, ty.span,\n-                                         \"found enum type without foreign-function-safe \\\n-                                          representation annotation in foreign module\");\n-                            // hmm... this message could be more helpful\n-                        }\n-                    }\n-                    _ => ()\n-                }\n-            }\n-            ast::TyPtr(ref mt) => { check_ty(cx, &*mt.ty) }\n-            _ => {}\n-        }\n-    }\n-\n-    fn check_foreign_fn(cx: &Context, decl: &ast::FnDecl) {\n-        for input in decl.inputs.iter() {\n-            check_ty(cx, &*input.ty);\n-        }\n-        check_ty(cx, &*decl.output)\n-    }\n-\n-    match it.node {\n-      ast::ItemForeignMod(ref nmod) if nmod.abi != abi::RustIntrinsic => {\n-        for ni in nmod.items.iter() {\n-            match ni.node {\n-                ast::ForeignItemFn(decl, _) => check_foreign_fn(cx, &*decl),\n-                ast::ForeignItemStatic(t, _) => check_ty(cx, &*t)\n-            }\n-        }\n-      }\n-      _ => {/* nothing to do */ }\n-    }\n-}\n-\n-fn check_heap_type(cx: &Context, span: Span, ty: ty::t) {\n-    let xs = [ManagedHeapMemory, OwnedHeapMemory, HeapMemory];\n-    for &lint in xs.iter() {\n-        if cx.get_level(lint) == Allow { continue }\n-\n-        let mut n_box = 0;\n-        let mut n_uniq = 0;\n-        ty::fold_ty(cx.tcx, ty, |t| {\n-            match ty::get(t).sty {\n-                ty::ty_box(_) => {\n-                    n_box += 1;\n-                }\n-                ty::ty_uniq(_) |\n-                ty::ty_closure(box ty::ClosureTy {\n-                    store: ty::UniqTraitStore,\n-                    ..\n-                }) => {\n-                    n_uniq += 1;\n-                }\n-\n-                _ => ()\n-            };\n-            t\n-        });\n-\n-        if n_uniq > 0 && lint != ManagedHeapMemory {\n-            let s = ty_to_str(cx.tcx, ty);\n-            let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n-            cx.span_lint(lint, span, m.as_slice());\n-        }\n-\n-        if n_box > 0 && lint != OwnedHeapMemory {\n-            let s = ty_to_str(cx.tcx, ty);\n-            let m = format!(\"type uses managed (@ type) pointers: {}\", s);\n-            cx.span_lint(lint, span, m.as_slice());\n-        }\n-    }\n-}\n-\n-fn check_heap_item(cx: &Context, it: &ast::Item) {\n-    match it.node {\n-        ast::ItemFn(..) |\n-        ast::ItemTy(..) |\n-        ast::ItemEnum(..) |\n-        ast::ItemStruct(..) => check_heap_type(cx, it.span,\n-                                               ty::node_id_to_type(cx.tcx,\n-                                                                   it.id)),\n-        _ => ()\n-    }\n-\n-    // If it's a struct, we also have to check the fields' types\n-    match it.node {\n-        ast::ItemStruct(struct_def, _) => {\n-            for struct_field in struct_def.fields.iter() {\n-                check_heap_type(cx, struct_field.span,\n-                                ty::node_id_to_type(cx.tcx,\n-                                                    struct_field.node.id));\n-            }\n-        }\n-        _ => ()\n-    }\n-}\n-\n-struct RawPtrDerivingVisitor<'a> {\n-    cx: &'a Context<'a>\n-}\n-\n-impl<'a> Visitor<()> for RawPtrDerivingVisitor<'a> {\n-    fn visit_ty(&mut self, ty: &ast::Ty, _: ()) {\n-        static MSG: &'static str = \"use of `#[deriving]` with a raw pointer\";\n-        match ty.node {\n-            ast::TyPtr(..) => self.cx.span_lint(RawPointerDeriving, ty.span, MSG),\n-            _ => {}\n-        }\n-        visit::walk_ty(self, ty, ());\n-    }\n-    // explicit override to a no-op to reduce code bloat\n-    fn visit_expr(&mut self, _: &ast::Expr, _: ()) {}\n-    fn visit_block(&mut self, _: &ast::Block, _: ()) {}\n-}\n-\n-fn check_raw_ptr_deriving(cx: &mut Context, item: &ast::Item) {\n-    if !attr::contains_name(item.attrs.as_slice(), \"automatically_derived\") {\n-        return\n-    }\n-    let did = match item.node {\n-        ast::ItemImpl(..) => {\n-            match ty::get(ty::node_id_to_type(cx.tcx, item.id)).sty {\n-                ty::ty_enum(did, _) => did,\n-                ty::ty_struct(did, _) => did,\n-                _ => return,\n-            }\n-        }\n-        _ => return,\n-    };\n-    if !ast_util::is_local(did) { return }\n-    let item = match cx.tcx.map.find(did.node) {\n-        Some(ast_map::NodeItem(item)) => item,\n-        _ => return,\n-    };\n-    if !cx.checked_raw_pointers.insert(item.id) { return }\n-    match item.node {\n-        ast::ItemStruct(..) | ast::ItemEnum(..) => {\n-            let mut visitor = RawPtrDerivingVisitor { cx: cx };\n-            visit::walk_item(&mut visitor, &*item, ());\n-        }\n-        _ => {}\n-    }\n-}\n-\n-fn check_unused_attribute(cx: &Context, attr: &ast::Attribute) {\n-    static ATTRIBUTE_WHITELIST: &'static [&'static str] = &'static [\n-        // FIXME: #14408 whitelist docs since rustdoc looks at them\n-        \"doc\",\n-\n-        // FIXME: #14406 these are processed in trans, which happens after the\n-        // lint pass\n-        \"cold\",\n-        \"inline\",\n-        \"link\",\n-        \"link_name\",\n-        \"link_section\",\n-        \"no_builtins\",\n-        \"no_mangle\",\n-        \"no_split_stack\",\n-        \"packed\",\n-        \"static_assert\",\n-        \"thread_local\",\n-\n-        // not used anywhere (!?) but apparently we want to keep them around\n-        \"comment\",\n-        \"desc\",\n-        \"license\",\n-\n-        // FIXME: #14407 these are only looked at on-demand so we can't\n-        // guarantee they'll have already been checked\n-        \"deprecated\",\n-        \"experimental\",\n-        \"frozen\",\n-        \"locked\",\n-        \"must_use\",\n-        \"stable\",\n-        \"unstable\",\n-    ];\n-\n-    static CRATE_ATTRS: &'static [&'static str] = &'static [\n-        \"crate_type\",\n-        \"feature\",\n-        \"no_start\",\n-        \"no_main\",\n-        \"no_std\",\n-        \"crate_id\",\n-        \"desc\",\n-        \"comment\",\n-        \"license\",\n-        \"copyright\",\n-        \"no_builtins\",\n-    ];\n-\n-    for &name in ATTRIBUTE_WHITELIST.iter() {\n-        if attr.check_name(name) {\n-            break;\n-        }\n-    }\n-\n-    if !attr::is_used(attr) {\n-        cx.span_lint(UnusedAttribute, attr.span, \"unused attribute\");\n-        if CRATE_ATTRS.contains(&attr.name().get()) {\n-            let msg = match attr.node.style {\n-                ast::AttrOuter => \"crate-level attribute should be an inner \\\n-                                  attribute: add an exclamation mark: #![foo]\",\n-                ast::AttrInner => \"crate-level attribute should be in the \\\n-                                   root module\",\n-            };\n-            cx.span_lint(UnusedAttribute, attr.span, msg);\n-        }\n-    }\n-}\n-\n-fn check_heap_expr(cx: &Context, e: &ast::Expr) {\n-    let ty = ty::expr_ty(cx.tcx, e);\n-    check_heap_type(cx, e.span, ty);\n-}\n-\n-fn check_path_statement(cx: &Context, s: &ast::Stmt) {\n-    match s.node {\n-        ast::StmtSemi(expr, _) => {\n-            match expr.node {\n-                ast::ExprPath(_) => {\n-                    cx.span_lint(PathStatement,\n-                                 s.span,\n-                                 \"path statement with no effect\");\n-                }\n-                _ => {}\n-            }\n-        }\n-        _ => ()\n-    }\n-}\n-\n-fn check_unused_result(cx: &Context, s: &ast::Stmt) {\n-    let expr = match s.node {\n-        ast::StmtSemi(expr, _) => expr,\n-        _ => return\n-    };\n-    let t = ty::expr_ty(cx.tcx, &*expr);\n-    match ty::get(t).sty {\n-        ty::ty_nil | ty::ty_bot | ty::ty_bool => return,\n-        _ => {}\n-    }\n-    match expr.node {\n-        ast::ExprRet(..) => return,\n-        _ => {}\n-    }\n-\n-    let t = ty::expr_ty(cx.tcx, &*expr);\n-    let mut warned = false;\n-    match ty::get(t).sty {\n-        ty::ty_struct(did, _) |\n-        ty::ty_enum(did, _) => {\n-            if ast_util::is_local(did) {\n-                match cx.tcx.map.get(did.node) {\n-                    ast_map::NodeItem(it) => {\n-                        if attr::contains_name(it.attrs.as_slice(),\n-                                               \"must_use\") {\n-                            cx.span_lint(UnusedMustUse, s.span,\n-                                         \"unused result which must be used\");\n-                            warned = true;\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            } else {\n-                csearch::get_item_attrs(&cx.tcx.sess.cstore, did, |attrs| {\n-                    if attr::contains_name(attrs.as_slice(), \"must_use\") {\n-                        cx.span_lint(UnusedMustUse, s.span,\n-                                     \"unused result which must be used\");\n-                        warned = true;\n-                    }\n-                });\n-            }\n-        }\n-        _ => {}\n-    }\n-    if !warned {\n-        cx.span_lint(UnusedResult, s.span, \"unused result\");\n-    }\n-}\n-\n-fn check_item_non_camel_case_types(cx: &Context, it: &ast::Item) {\n-    fn is_camel_case(ident: ast::Ident) -> bool {\n-        let ident = token::get_ident(ident);\n-        assert!(!ident.get().is_empty());\n-        let ident = ident.get().trim_chars('_');\n-\n-        // start with a non-lowercase letter rather than non-uppercase\n-        // ones (some scripts don't have a concept of upper/lowercase)\n-        !ident.char_at(0).is_lowercase() && !ident.contains_char('_')\n-    }\n-\n-    fn to_camel_case(s: &str) -> String {\n-        s.split('_').flat_map(|word| word.chars().enumerate().map(|(i, c)|\n-            if i == 0 { c.to_uppercase() }\n-            else { c }\n-        )).collect()\n-    }\n-\n-    fn check_case(cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n-        let s = token::get_ident(ident);\n-\n-        if !is_camel_case(ident) {\n-            cx.span_lint(\n-                NonCamelCaseTypes, span,\n-                format!(\"{} `{}` should have a camel case name such as `{}`\",\n-                    sort, s, to_camel_case(s.get())).as_slice());\n-        }\n-    }\n-\n-    match it.node {\n-        ast::ItemTy(..) | ast::ItemStruct(..) => {\n-            check_case(cx, \"type\", it.ident, it.span)\n-        }\n-        ast::ItemTrait(..) => {\n-            check_case(cx, \"trait\", it.ident, it.span)\n-        }\n-        ast::ItemEnum(ref enum_definition, _) => {\n-            check_case(cx, \"type\", it.ident, it.span);\n-            for variant in enum_definition.variants.iter() {\n-                check_case(cx, \"variant\", variant.node.name, variant.span);\n-            }\n-        }\n-        _ => ()\n-    }\n-}\n-\n-fn check_snake_case(cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n-    fn is_snake_case(ident: ast::Ident) -> bool {\n-        let ident = token::get_ident(ident);\n-        assert!(!ident.get().is_empty());\n-        let ident = ident.get().trim_chars('_');\n-\n-        let mut allow_underscore = true;\n-        ident.chars().all(|c| {\n-            allow_underscore = match c {\n-                c if c.is_lowercase() || c.is_digit() => true,\n-                '_' if allow_underscore => false,\n-                _ => return false,\n-            };\n-            true\n-        })\n-    }\n-\n-    fn to_snake_case(str: &str) -> String {\n-        let mut words = vec![];\n-        for s in str.split('_') {\n-            let mut buf = String::new();\n-            if s.is_empty() { continue; }\n-            for ch in s.chars() {\n-                if !buf.is_empty() && ch.is_uppercase() {\n-                    words.push(buf);\n-                    buf = String::new();\n-                }\n-                buf.push_char(ch.to_lowercase());\n-            }\n-            words.push(buf);\n-        }\n-        words.connect(\"_\")\n-    }\n-\n-    let s = token::get_ident(ident);\n-\n-    if !is_snake_case(ident) {\n-        cx.span_lint(NonSnakeCaseFunctions, span,\n-                    format!(\"{} `{}` should have a snake case name such as `{}`\",\n-                            sort, s, to_snake_case(s.get())).as_slice());\n-    }\n-}\n-\n-fn check_item_non_uppercase_statics(cx: &Context, it: &ast::Item) {\n-    match it.node {\n-        // only check static constants\n-        ast::ItemStatic(_, ast::MutImmutable, _) => {\n-            let s = token::get_ident(it.ident);\n-            // check for lowercase letters rather than non-uppercase\n-            // ones (some scripts don't have a concept of\n-            // upper/lowercase)\n-            if s.get().chars().any(|c| c.is_lowercase()) {\n-                cx.span_lint(NonUppercaseStatics, it.span,\n-                            format!(\"static constant `{}` should have an uppercase name \\\n-                                such as `{}`\", s.get(),\n-                                s.get().chars().map(|c| c.to_uppercase())\n-                                    .collect::<String>().as_slice()).as_slice());\n-            }\n-        }\n-        _ => {}\n-    }\n-}\n-\n-fn check_pat_non_uppercase_statics(cx: &Context, p: &ast::Pat) {\n-    // Lint for constants that look like binding identifiers (#7526)\n-    match (&p.node, cx.tcx.def_map.borrow().find(&p.id)) {\n-        (&ast::PatIdent(_, ref path, _), Some(&def::DefStatic(_, false))) => {\n-            // last identifier alone is right choice for this lint.\n-            let ident = path.segments.last().unwrap().identifier;\n-            let s = token::get_ident(ident);\n-            if s.get().chars().any(|c| c.is_lowercase()) {\n-                cx.span_lint(NonUppercasePatternStatics, path.span,\n-                            format!(\"static constant in pattern `{}` should have an uppercase \\\n-                                name such as `{}`\", s.get(),\n-                                s.get().chars().map(|c| c.to_uppercase())\n-                                    .collect::<String>().as_slice()).as_slice());\n-            }\n-        }\n-        _ => {}\n-    }\n-}\n-\n-fn check_pat_uppercase_variable(cx: &Context, p: &ast::Pat) {\n-    match &p.node {\n-        &ast::PatIdent(_, ref path, _) => {\n-            match cx.tcx.def_map.borrow().find(&p.id) {\n-                Some(&def::DefLocal(_, _)) | Some(&def::DefBinding(_, _)) |\n-                        Some(&def::DefArg(_, _)) => {\n-                    // last identifier alone is right choice for this lint.\n-                    let ident = path.segments.last().unwrap().identifier;\n-                    let s = token::get_ident(ident);\n-                    if s.get().len() > 0 && s.get().char_at(0).is_uppercase() {\n-                        cx.span_lint(\n-                            UppercaseVariables,\n-                            path.span,\n-                            \"variable names should start with a lowercase character\");\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-        _ => {}\n-    }\n-}\n-\n-fn check_struct_uppercase_variable(cx: &Context, s: &ast::StructDef) {\n-    for sf in s.fields.iter() {\n-        match sf.node {\n-            ast::StructField_ { kind: ast::NamedField(ident, _), .. } => {\n-                let s = token::get_ident(ident);\n-                if s.get().char_at(0).is_uppercase() {\n-                    cx.span_lint(\n-                        UppercaseVariables,\n-                        sf.span,\n-                        \"structure field names should start with a lowercase character\");\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-}\n-\n-fn check_unnecessary_parens_core(cx: &Context, value: &ast::Expr, msg: &str) {\n-    match value.node {\n-        ast::ExprParen(_) => {\n-            cx.span_lint(UnnecessaryParens, value.span,\n-                         format!(\"unnecessary parentheses around {}\",\n-                                 msg).as_slice())\n-        }\n-        _ => {}\n-    }\n-}\n-\n-fn check_unnecessary_parens_expr(cx: &Context, e: &ast::Expr) {\n-    let (value, msg) = match e.node {\n-        ast::ExprIf(cond, _, _) => (cond, \"`if` condition\"),\n-        ast::ExprWhile(cond, _) => (cond, \"`while` condition\"),\n-        ast::ExprMatch(head, _) => (head, \"`match` head expression\"),\n-        ast::ExprRet(Some(value)) => (value, \"`return` value\"),\n-        ast::ExprAssign(_, value) => (value, \"assigned value\"),\n-        ast::ExprAssignOp(_, _, value) => (value, \"assigned value\"),\n-        _ => return\n-    };\n-    check_unnecessary_parens_core(cx, &*value, msg);\n-}\n-\n-fn check_unnecessary_parens_stmt(cx: &Context, s: &ast::Stmt) {\n-    let (value, msg) = match s.node {\n-        ast::StmtDecl(decl, _) => match decl.node {\n-            ast::DeclLocal(local) => match local.init {\n-                Some(value) => (value, \"assigned value\"),\n-                None => return\n-            },\n-            _ => return\n-        },\n-        _ => return\n-    };\n-    check_unnecessary_parens_core(cx, &*value, msg);\n-}\n-\n-fn check_unused_unsafe(cx: &Context, e: &ast::Expr) {\n-    match e.node {\n-        // Don't warn about generated blocks, that'll just pollute the output.\n-        ast::ExprBlock(ref blk) => {\n-            if blk.rules == ast::UnsafeBlock(ast::UserProvided) &&\n-                !cx.tcx.used_unsafe.borrow().contains(&blk.id) {\n-                cx.span_lint(UnusedUnsafe, blk.span,\n-                             \"unnecessary `unsafe` block\");\n-            }\n-        }\n-        _ => ()\n-    }\n-}\n-\n-fn check_unsafe_block(cx: &Context, e: &ast::Expr) {\n-    match e.node {\n-        // Don't warn about generated blocks, that'll just pollute the output.\n-        ast::ExprBlock(ref blk) if blk.rules == ast::UnsafeBlock(ast::UserProvided) => {\n-            cx.span_lint(UnsafeBlock, blk.span, \"usage of an `unsafe` block\");\n-        }\n-        _ => ()\n-    }\n-}\n-\n-fn check_unused_mut_pat(cx: &Context, pats: &[Gc<ast::Pat>]) {\n-    // collect all mutable pattern and group their NodeIDs by their Identifier to\n-    // avoid false warnings in match arms with multiple patterns\n-    let mut mutables = HashMap::new();\n-    for &p in pats.iter() {\n-        pat_util::pat_bindings(&cx.tcx.def_map, &*p, |mode, id, _, path| {\n-            match mode {\n-                ast::BindByValue(ast::MutMutable) => {\n-                    if path.segments.len() != 1 {\n-                        cx.tcx.sess.span_bug(p.span,\n-                                             \"mutable binding that doesn't consist \\\n-                                              of exactly one segment\");\n-                    }\n-                    let ident = path.segments.get(0).identifier;\n-                    if !token::get_ident(ident).get().starts_with(\"_\") {\n-                        mutables.insert_or_update_with(ident.name as uint, vec!(id), |_, old| {\n-                            old.push(id);\n-                        });\n-                    }\n-                }\n-                _ => {\n-                }\n-            }\n-        });\n-    }\n-\n-    let used_mutables = cx.tcx.used_mut_nodes.borrow();\n-    for (_, v) in mutables.iter() {\n-        if !v.iter().any(|e| used_mutables.contains(e)) {\n-            cx.span_lint(UnusedMut, cx.tcx.map.span(*v.get(0)),\n-                         \"variable does not need to be mutable\");\n-        }\n-    }\n-}\n-\n-enum Allocation {\n-    VectorAllocation,\n-    BoxAllocation\n-}\n-\n-fn check_unnecessary_allocation(cx: &Context, e: &ast::Expr) {\n-    // Warn if string and vector literals with sigils, or boxing expressions,\n-    // are immediately borrowed.\n-    let allocation = match e.node {\n-        ast::ExprVstore(e2, ast::ExprVstoreUniq) => {\n-            match e2.node {\n-                ast::ExprLit(lit) if ast_util::lit_is_str(lit) => {\n-                    VectorAllocation\n-                }\n-                ast::ExprVec(..) => VectorAllocation,\n-                _ => return\n-            }\n-        }\n-        ast::ExprUnary(ast::UnUniq, _) |\n-        ast::ExprUnary(ast::UnBox, _) => BoxAllocation,\n-\n-        _ => return\n-    };\n-\n-    let report = |msg| {\n-        cx.span_lint(UnnecessaryAllocation, e.span, msg);\n-    };\n-\n-    match cx.tcx.adjustments.borrow().find(&e.id) {\n-        Some(adjustment) => {\n-            match *adjustment {\n-                ty::AutoDerefRef(ty::AutoDerefRef { autoref, .. }) => {\n-                    match (allocation, autoref) {\n-                        (VectorAllocation, Some(ty::AutoBorrowVec(..))) => {\n-                            report(\"unnecessary allocation, the sigil can be \\\n-                                    removed\");\n-                        }\n-                        (BoxAllocation,\n-                         Some(ty::AutoPtr(_, ast::MutImmutable))) => {\n-                            report(\"unnecessary allocation, use & instead\");\n-                        }\n-                        (BoxAllocation,\n-                         Some(ty::AutoPtr(_, ast::MutMutable))) => {\n-                            report(\"unnecessary allocation, use &mut \\\n-                                    instead\");\n-                        }\n-                        _ => ()\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-\n-        _ => ()\n-    }\n-}\n-\n-fn check_missing_doc_attrs(cx: &Context,\n-                           id: Option<ast::NodeId>,\n-                           attrs: &[ast::Attribute],\n-                           sp: Span,\n-                           desc: &'static str) {\n-    // If we're building a test harness, then warning about\n-    // documentation is probably not really relevant right now.\n-    if cx.tcx.sess.opts.test { return }\n-\n-    // `#[doc(hidden)]` disables missing_doc check.\n-    if cx.is_doc_hidden { return }\n-\n-    // Only check publicly-visible items, using the result from the privacy pass. It's an option so\n-    // the crate root can also use this function (it doesn't have a NodeId).\n-    match id {\n-        Some(ref id) if !cx.exported_items.contains(id) => return,\n-        _ => ()\n-    }\n-\n-    let has_doc = attrs.iter().any(|a| {\n-        match a.node.value.node {\n-            ast::MetaNameValue(ref name, _) if name.equiv(&(\"doc\")) => true,\n-            _ => false\n-        }\n-    });\n-    if !has_doc {\n-        cx.span_lint(MissingDoc,\n-                     sp,\n-                     format!(\"missing documentation for {}\",\n-                             desc).as_slice());\n-    }\n-}\n-\n-fn check_missing_doc_item(cx: &Context, it: &ast::Item) {\n-    let desc = match it.node {\n-        ast::ItemFn(..) => \"a function\",\n-        ast::ItemMod(..) => \"a module\",\n-        ast::ItemEnum(..) => \"an enum\",\n-        ast::ItemStruct(..) => \"a struct\",\n-        ast::ItemTrait(..) => \"a trait\",\n-        _ => return\n-    };\n-    check_missing_doc_attrs(cx,\n-                            Some(it.id),\n-                            it.attrs.as_slice(),\n-                            it.span,\n-                            desc);\n-}\n-\n-#[deriving(PartialEq)]\n-enum MethodContext {\n-    TraitDefaultImpl,\n-    TraitImpl,\n-    PlainImpl\n-}\n-\n-fn check_missing_doc_method(cx: &Context, m: &ast::Method) {\n-    // If the method is an impl for a trait, don't doc.\n-    if method_context(cx, m) == TraitImpl { return; }\n-\n-    // Otherwise, doc according to privacy. This will also check\n-    // doc for default methods defined on traits.\n-    check_missing_doc_attrs(cx,\n-                            Some(m.id),\n-                            m.attrs.as_slice(),\n-                            m.span,\n-                            \"a method\");\n-}\n-\n-fn method_context(cx: &Context, m: &ast::Method) -> MethodContext {\n-    let did = ast::DefId {\n-        krate: ast::LOCAL_CRATE,\n-        node: m.id\n-    };\n-\n-    match cx.tcx.methods.borrow().find_copy(&did) {\n-        None => cx.tcx.sess.span_bug(m.span, \"missing method descriptor?!\"),\n-        Some(md) => {\n-            match md.container {\n-                ty::TraitContainer(..) => TraitDefaultImpl,\n-                ty::ImplContainer(cid) => {\n-                    match ty::impl_trait_ref(cx.tcx, cid) {\n-                        Some(..) => TraitImpl,\n-                        None => PlainImpl\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn check_missing_doc_ty_method(cx: &Context, tm: &ast::TypeMethod) {\n-    check_missing_doc_attrs(cx,\n-                            Some(tm.id),\n-                            tm.attrs.as_slice(),\n-                            tm.span,\n-                            \"a type method\");\n-}\n-\n-fn check_missing_doc_struct_field(cx: &Context, sf: &ast::StructField) {\n-    match sf.node.kind {\n-        ast::NamedField(_, vis) if vis == ast::Public =>\n-            check_missing_doc_attrs(cx,\n-                                    Some(cx.cur_struct_def_id),\n-                                    sf.node.attrs.as_slice(),\n-                                    sf.span,\n-                                    \"a struct field\"),\n-        _ => {}\n-    }\n-}\n-\n-fn check_missing_doc_variant(cx: &Context, v: &ast::Variant) {\n-    check_missing_doc_attrs(cx,\n-                            Some(v.node.id),\n-                            v.node.attrs.as_slice(),\n-                            v.span,\n-                            \"a variant\");\n-}\n-\n-/// Checks for use of items with #[deprecated], #[experimental] and\n-/// #[unstable] (or none of them) attributes.\n-fn check_stability(cx: &Context, e: &ast::Expr) {\n-    let tcx = cx.tcx;\n-\n-    let id = match e.node {\n-        ast::ExprPath(..) | ast::ExprStruct(..) => {\n-            match cx.tcx.def_map.borrow().find(&e.id) {\n-                Some(&def) => def.def_id(),\n-                None => return\n-            }\n-        }\n-        ast::ExprMethodCall(..) => {\n-            let method_call = typeck::MethodCall::expr(e.id);\n-            match tcx.method_map.borrow().find(&method_call) {\n-                Some(method) => {\n-                    match method.origin {\n-                        typeck::MethodStatic(def_id) => {\n-                            // If this implements a trait method, get def_id\n-                            // of the method inside trait definition.\n-                            // Otherwise, use the current def_id (which refers\n-                            // to the method inside impl).\n-                            ty::trait_method_of_method(cx.tcx, def_id)\n-                               .unwrap_or(def_id)\n-                        }\n-                        typeck::MethodParam(typeck::MethodParam {\n-                            trait_id: trait_id,\n-                            method_num: index,\n-                            ..\n-                        })\n-                        | typeck::MethodObject(typeck::MethodObject {\n-                            trait_id: trait_id,\n-                            method_num: index,\n-                            ..\n-                        }) => ty::trait_method(cx.tcx, trait_id, index).def_id\n-                    }\n-                }\n-                None => return\n-            }\n-        }\n-        _ => return\n-    };\n-\n-    // stability attributes are promises made across crates; do not\n-    // check anything for crate-local usage.\n-    if ast_util::is_local(id) { return }\n-\n-    let stability = tcx.stability.borrow_mut().lookup(&tcx.sess.cstore, id);\n-\n-    let (lint, label) = match stability {\n-        // no stability attributes == Unstable\n-        None => (Unstable, \"unmarked\"),\n-        Some(attr::Stability { level: attr::Unstable, .. }) =>\n-                (Unstable, \"unstable\"),\n-        Some(attr::Stability { level: attr::Experimental, .. }) =>\n-                (Experimental, \"experimental\"),\n-        Some(attr::Stability { level: attr::Deprecated, .. }) =>\n-                (Deprecated, \"deprecated\"),\n-        _ => return\n-    };\n-\n-    let msg = match stability {\n-        Some(attr::Stability { text: Some(ref s), .. }) => {\n-            format!(\"use of {} item: {}\", label, *s)\n-        }\n-        _ => format!(\"use of {} item\", label)\n-    };\n-\n-    cx.span_lint(lint, e.span, msg.as_slice());\n-}\n-\n-fn check_enum_variant_sizes(cx: &mut Context, it: &ast::Item) {\n-    match it.node {\n-        ast::ItemEnum(..) => {\n-            match cx.cur.find(&(VariantSizeDifference as uint)) {\n-                Some(&(lvl, src)) if lvl != Allow => {\n-                    cx.node_levels.insert((it.id, VariantSizeDifference), (lvl, src));\n-                },\n-                _ => { }\n-            }\n-        },\n-        _ => { }\n-    }\n-}\n-\n-impl<'a> Visitor<()> for Context<'a> {\n-    fn visit_item(&mut self, it: &ast::Item, _: ()) {\n-        self.with_lint_attrs(it.attrs.as_slice(), |cx| {\n-            check_enum_variant_sizes(cx, it);\n-            check_item_ctypes(cx, it);\n-            check_item_non_camel_case_types(cx, it);\n-            check_item_non_uppercase_statics(cx, it);\n-            check_heap_item(cx, it);\n-            check_missing_doc_item(cx, it);\n-            check_raw_ptr_deriving(cx, it);\n-\n-            cx.visit_ids(|v| v.visit_item(it, ()));\n-\n-            visit::walk_item(cx, it, ());\n-        })\n-    }\n-\n-    fn visit_foreign_item(&mut self, it: &ast::ForeignItem, _: ()) {\n-        self.with_lint_attrs(it.attrs.as_slice(), |cx| {\n-            visit::walk_foreign_item(cx, it, ());\n-        })\n-    }\n-\n-    fn visit_view_item(&mut self, i: &ast::ViewItem, _: ()) {\n-        self.with_lint_attrs(i.attrs.as_slice(), |cx| {\n-            cx.visit_ids(|v| v.visit_view_item(i, ()));\n-\n-            visit::walk_view_item(cx, i, ());\n-        })\n-    }\n-\n-    fn visit_pat(&mut self, p: &ast::Pat, _: ()) {\n-        check_pat_non_uppercase_statics(self, p);\n-        check_pat_uppercase_variable(self, p);\n-\n-        visit::walk_pat(self, p, ());\n-    }\n-\n-    fn visit_expr(&mut self, e: &ast::Expr, _: ()) {\n-        match e.node {\n-            ast::ExprUnary(ast::UnNeg, expr) => {\n-                // propagate negation, if the negation itself isn't negated\n-                if self.negated_expr_id != e.id {\n-                    self.negated_expr_id = expr.id;\n-                }\n-            },\n-            ast::ExprParen(expr) => if self.negated_expr_id == e.id {\n-                self.negated_expr_id = expr.id\n-            },\n-            ast::ExprMatch(_, ref arms) => {\n-                for a in arms.iter() {\n-                    check_unused_mut_pat(self, a.pats.as_slice());\n-                }\n-            },\n-            _ => ()\n-        };\n-\n-        check_while_true_expr(self, e);\n-        check_stability(self, e);\n-        check_unnecessary_parens_expr(self, e);\n-        check_unused_unsafe(self, e);\n-        check_unsafe_block(self, e);\n-        check_unnecessary_allocation(self, e);\n-        check_heap_expr(self, e);\n-\n-        check_type_limits(self, e);\n-        check_unused_casts(self, e);\n-\n-        visit::walk_expr(self, e, ());\n-    }\n-\n-    fn visit_stmt(&mut self, s: &ast::Stmt, _: ()) {\n-        check_path_statement(self, s);\n-        check_unused_result(self, s);\n-        check_unnecessary_parens_stmt(self, s);\n-\n-        match s.node {\n-            ast::StmtDecl(d, _) => {\n-                match d.node {\n-                    ast::DeclLocal(l) => {\n-                        check_unused_mut_pat(self, &[l.pat]);\n-                    },\n-                    _ => {}\n-                }\n-            },\n-            _ => {}\n-        }\n-\n-        visit::walk_stmt(self, s, ());\n-    }\n-\n-    fn visit_fn(&mut self, fk: &visit::FnKind, decl: &ast::FnDecl,\n-                body: &ast::Block, span: Span, id: ast::NodeId, _: ()) {\n-        let recurse = |this: &mut Context| {\n-            visit::walk_fn(this, fk, decl, body, span, ());\n-        };\n-\n-        for a in decl.inputs.iter(){\n-            check_unused_mut_pat(self, &[a.pat]);\n-        }\n-\n-        match *fk {\n-            visit::FkMethod(ident, _, m) => {\n-                self.with_lint_attrs(m.attrs.as_slice(), |cx| {\n-                    check_missing_doc_method(cx, m);\n-\n-                    match method_context(cx, m) {\n-                        PlainImpl => check_snake_case(cx, \"method\", ident, span),\n-                        TraitDefaultImpl => check_snake_case(cx, \"trait method\", ident, span),\n-                        _ => (),\n-                    }\n-\n-                    cx.visit_ids(|v| {\n-                        v.visit_fn(fk, decl, body, span, id, ());\n-                    });\n-                    recurse(cx);\n-                })\n-            },\n-            visit::FkItemFn(ident, _, _, _) => {\n-                check_snake_case(self, \"function\", ident, span);\n-                recurse(self);\n-            }\n-            _ => recurse(self),\n-        }\n-    }\n-\n-    fn visit_ty_method(&mut self, t: &ast::TypeMethod, _: ()) {\n-        self.with_lint_attrs(t.attrs.as_slice(), |cx| {\n-            check_missing_doc_ty_method(cx, t);\n-            check_snake_case(cx, \"trait method\", t.ident, t.span);\n-\n-            visit::walk_ty_method(cx, t, ());\n-        })\n-    }\n-\n-    fn visit_struct_def(&mut self,\n-                        s: &ast::StructDef,\n-                        _: ast::Ident,\n-                        _: &ast::Generics,\n-                        id: ast::NodeId,\n-                        _: ()) {\n-        check_struct_uppercase_variable(self, s);\n-\n-        let old_id = self.cur_struct_def_id;\n-        self.cur_struct_def_id = id;\n-        visit::walk_struct_def(self, s, ());\n-        self.cur_struct_def_id = old_id;\n-    }\n-\n-    fn visit_struct_field(&mut self, s: &ast::StructField, _: ()) {\n-        self.with_lint_attrs(s.node.attrs.as_slice(), |cx| {\n-            check_missing_doc_struct_field(cx, s);\n-\n-            visit::walk_struct_field(cx, s, ());\n-        })\n-    }\n-\n-    fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics, _: ()) {\n-        self.with_lint_attrs(v.node.attrs.as_slice(), |cx| {\n-            check_missing_doc_variant(cx, v);\n-\n-            visit::walk_variant(cx, v, g, ());\n-        })\n-    }\n-\n-    // FIXME(#10894) should continue recursing\n-    fn visit_ty(&mut self, _t: &ast::Ty, _: ()) {}\n-\n-    fn visit_attribute(&mut self, attr: &ast::Attribute, _: ()) {\n-        check_unused_attribute(self, attr);\n-    }\n-}\n-\n-impl<'a> IdVisitingOperation for Context<'a> {\n-    fn visit_id(&self, id: ast::NodeId) {\n-        match self.tcx.sess.lints.borrow_mut().pop(&id) {\n-            None => {}\n-            Some(l) => {\n-                for (lint, span, msg) in l.move_iter() {\n-                    self.span_lint(lint, span, msg.as_slice())\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub fn check_crate(tcx: &ty::ctxt,\n-                   exported_items: &privacy::ExportedItems,\n-                   krate: &ast::Crate) {\n-    let mut cx = Context {\n-        dict: get_lint_dict(),\n-        cur: SmallIntMap::new(),\n-        tcx: tcx,\n-        exported_items: exported_items,\n-        cur_struct_def_id: -1,\n-        is_doc_hidden: false,\n-        lint_stack: Vec::new(),\n-        negated_expr_id: -1,\n-        checked_raw_pointers: NodeSet::new(),\n-        node_levels: HashMap::new(),\n-    };\n-\n-    // Install default lint levels, followed by the command line levels, and\n-    // then actually visit the whole crate.\n-    for (_, spec) in cx.dict.iter() {\n-        if spec.default != Allow {\n-            cx.cur.insert(spec.lint as uint, (spec.default, Default));\n-        }\n-    }\n-    for &(lint, level) in tcx.sess.opts.lint_opts.iter() {\n-        cx.set_level(lint, level, CommandLine);\n-    }\n-    cx.with_lint_attrs(krate.attrs.as_slice(), |cx| {\n-        cx.visit_id(ast::CRATE_NODE_ID);\n-        cx.visit_ids(|v| {\n-            v.visited_outermost = true;\n-            visit::walk_crate(v, krate, ());\n-        });\n-\n-        // since the root module isn't visited as an item (because it isn't an item), warn for it\n-        // here.\n-        check_missing_doc_attrs(cx,\n-                                None,\n-                                krate.attrs.as_slice(),\n-                                krate.span,\n-                                \"crate\");\n-\n-        visit::walk_crate(cx, krate, ());\n-    });\n-\n-    // If we missed any lints added to the session, then there's a bug somewhere\n-    // in the iteration code.\n-    for (id, v) in tcx.sess.lints.borrow().iter() {\n-        for &(lint, span, ref msg) in v.iter() {\n-            tcx.sess.span_bug(span, format!(\"unprocessed lint {} at {}: {}\",\n-                                            lint, tcx.map.node_to_str(*id), *msg).as_slice())\n-        }\n-    }\n-\n-    tcx.sess.abort_if_errors();\n-    *tcx.node_lint_levels.borrow_mut() = cx.node_levels;\n-}"}, {"sha": "f09af6ea4416e415157168443bdaeb2fa6289763", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -104,10 +104,10 @@\n \n use middle::def::*;\n use middle::freevars;\n-use middle::lint::{UnusedVariable, DeadAssignment};\n use middle::mem_categorization::Typer;\n use middle::pat_util;\n use middle::ty;\n+use lint;\n use util::nodemap::NodeMap;\n \n use std::fmt;\n@@ -1560,11 +1560,11 @@ impl<'a> Liveness<'a> {\n                 };\n \n                 if is_assigned {\n-                    self.ir.tcx.sess.add_lint(UnusedVariable, id, sp,\n+                    self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_VARIABLE, id, sp,\n                         format!(\"variable `{}` is assigned to, but never used\",\n                                 *name));\n                 } else {\n-                    self.ir.tcx.sess.add_lint(UnusedVariable, id, sp,\n+                    self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_VARIABLE, id, sp,\n                         format!(\"unused variable: `{}`\", *name));\n                 }\n             }\n@@ -1582,7 +1582,7 @@ impl<'a> Liveness<'a> {\n         if self.live_on_exit(ln, var).is_none() {\n             let r = self.should_warn(var);\n             for name in r.iter() {\n-                self.ir.tcx.sess.add_lint(DeadAssignment, id, sp,\n+                self.ir.tcx.sess.add_lint(lint::builtin::DEAD_ASSIGNMENT, id, sp,\n                     format!(\"value assigned to `{}` is never read\", *name));\n             }\n         }"}, {"sha": "414aac47cdcc0882719525d04160e9e6bf1fabc3", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -17,7 +17,7 @@ use std::mem::replace;\n \n use metadata::csearch;\n use middle::def;\n-use middle::lint;\n+use lint;\n use middle::resolve;\n use middle::ty;\n use middle::typeck::{MethodCall, MethodMap, MethodOrigin, MethodParam};\n@@ -1394,7 +1394,7 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n             ast::TyPath(ref p, _, path_id) => {\n                 if self.path_is_private_type(path_id) {\n                     self.tcx.sess.add_lint(\n-                        lint::VisiblePrivateTypes,\n+                        lint::builtin::VISIBLE_PRIVATE_TYPES,\n                         path_id, p.span,\n                         \"private type in exported type \\\n                          signature\".to_string());"}, {"sha": "2329d5d685d66a8172742f0cba821ba29e9b62d7", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -15,9 +15,9 @@ use metadata::csearch;\n use metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n use middle::def::*;\n use middle::lang_items::LanguageItems;\n-use middle::lint::{UnnecessaryQualification, UnusedImports};\n use middle::pat_util::pat_bindings;\n use middle::subst::{ParamSpace, FnSpace, TypeSpace};\n+use lint;\n use util::nodemap::{NodeMap, DefIdSet, FnvHashMap};\n \n use syntax::ast::*;\n@@ -4632,7 +4632,7 @@ impl<'a> Resolver<'a> {\n             match (def, unqualified_def) {\n                 (Some((d, _)), Some((ud, _))) if d == ud => {\n                     self.session\n-                        .add_lint(UnnecessaryQualification,\n+                        .add_lint(lint::builtin::UNNECESSARY_QUALIFICATION,\n                                   id,\n                                   path.span,\n                                   \"unnecessary qualification\".to_string());\n@@ -5487,7 +5487,7 @@ impl<'a> Resolver<'a> {\n                         if !self.used_imports.contains(&(id, TypeNS)) &&\n                            !self.used_imports.contains(&(id, ValueNS)) {\n                             self.session\n-                                .add_lint(UnusedImports,\n+                                .add_lint(lint::builtin::UNUSED_IMPORTS,\n                                           id,\n                                           p.span,\n                                           \"unused import\".to_string());\n@@ -5511,7 +5511,7 @@ impl<'a> Resolver<'a> {\n \n         if !self.used_imports.contains(&(id, TypeNS)) &&\n            !self.used_imports.contains(&(id, ValueNS)) {\n-            self.session.add_lint(UnusedImports,\n+            self.session.add_lint(lint::builtin::UNUSED_IMPORTS,\n                                   id,\n                                   span,\n                                   \"unused import\".to_string());"}, {"sha": "210de1946c9e6f9ec8deef4faf185821439b460c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 42, "deletions": 39, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -36,7 +36,7 @@ use lib::llvm::{ModuleRef, ValueRef, BasicBlockRef};\n use lib::llvm::{llvm, Vector};\n use lib;\n use metadata::{csearch, encoder, loader};\n-use middle::lint;\n+use lint;\n use middle::astencode;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::weak_lang_items;\n@@ -1552,49 +1552,52 @@ fn trans_enum_def(ccx: &CrateContext, enum_definition: &ast::EnumDef,\n fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span, id: ast::NodeId) {\n     let mut sizes = Vec::new(); // does no allocation if no pushes, thankfully\n \n-    let (lvl, src) = ccx.tcx.node_lint_levels.borrow()\n-                        .find(&(id, lint::VariantSizeDifference))\n-                        .map_or((lint::Allow, lint::Default), |&(lvl,src)| (lvl, src));\n-\n-    if lvl != lint::Allow {\n-        let avar = adt::represent_type(ccx, ty::node_id_to_type(ccx.tcx(), id));\n-        match *avar {\n-            adt::General(_, ref variants) => {\n-                for var in variants.iter() {\n-                    let mut size = 0;\n-                    for field in var.fields.iter().skip(1) {\n-                        // skip the discriminant\n-                        size += llsize_of_real(ccx, sizing_type_of(ccx, *field));\n-                    }\n-                    sizes.push(size);\n-                }\n-            },\n-            _ => { /* its size is either constant or unimportant */ }\n-        }\n+    let levels = ccx.tcx.node_lint_levels.borrow();\n+    let lint_id = lint::LintId::of(lint::builtin::VARIANT_SIZE_DIFFERENCE);\n+    let lvlsrc = match levels.find(&(id, lint_id)) {\n+        None | Some(&(lint::Allow, _)) => return,\n+        Some(&lvlsrc) => lvlsrc,\n+    };\n \n-        let (largest, slargest, largest_index) = sizes.iter().enumerate().fold((0, 0, 0),\n-            |(l, s, li), (idx, &size)|\n-                if size > l {\n-                    (size, l, idx)\n-                } else if size > s {\n-                    (l, size, li)\n-                } else {\n-                    (l, s, li)\n+    let avar = adt::represent_type(ccx, ty::node_id_to_type(ccx.tcx(), id));\n+    match *avar {\n+        adt::General(_, ref variants) => {\n+            for var in variants.iter() {\n+                let mut size = 0;\n+                for field in var.fields.iter().skip(1) {\n+                    // skip the discriminant\n+                    size += llsize_of_real(ccx, sizing_type_of(ccx, *field));\n                 }\n-        );\n+                sizes.push(size);\n+            }\n+        },\n+        _ => { /* its size is either constant or unimportant */ }\n+    }\n \n-        // we only warn if the largest variant is at least thrice as large as\n-        // the second-largest.\n-        if largest > slargest * 3 && slargest > 0 {\n-            lint::emit_lint(lvl, src,\n+    let (largest, slargest, largest_index) = sizes.iter().enumerate().fold((0, 0, 0),\n+        |(l, s, li), (idx, &size)|\n+            if size > l {\n+                (size, l, idx)\n+            } else if size > s {\n+                (l, size, li)\n+            } else {\n+                (l, s, li)\n+            }\n+    );\n+\n+    // we only warn if the largest variant is at least thrice as large as\n+    // the second-largest.\n+    if largest > slargest * 3 && slargest > 0 {\n+        // Use lint::raw_emit_lint rather than sess.add_lint because the lint-printing\n+        // pass for the latter already ran.\n+        lint::raw_emit_lint(&ccx.tcx().sess, lint::builtin::VARIANT_SIZE_DIFFERENCE,\n+                            lvlsrc, Some(sp),\n                             format!(\"enum variant is more than three times larger \\\n-                                    ({} bytes) than the next largest (ignoring padding)\",\n-                                    largest).as_slice(),\n-                            sp, lint::lint_to_str(lint::VariantSizeDifference), ccx.tcx());\n+                                     ({} bytes) than the next largest (ignoring padding)\",\n+                                    largest).as_slice());\n \n-            ccx.sess().span_note(enum_def.variants.get(largest_index).span,\n-                                 \"this variant is the largest\");\n-        }\n+        ccx.sess().span_note(enum_def.variants.get(largest_index).span,\n+                             \"this variant is the largest\");\n     }\n }\n "}, {"sha": "b0e838a442b8d910e84c694de28c96a86c66c6d1", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -14,7 +14,7 @@ use back::svh::Svh;\n use driver::session::Session;\n use metadata::csearch;\n use mc = middle::mem_categorization;\n-use middle::lint;\n+use lint;\n use middle::const_eval;\n use middle::def;\n use middle::dependency_format;\n@@ -367,8 +367,8 @@ pub struct ctxt {\n \n     pub dependency_formats: RefCell<dependency_format::Dependencies>,\n \n-    pub node_lint_levels: RefCell<HashMap<(ast::NodeId, lint::Lint),\n-                                          (lint::Level, lint::LintSource)>>,\n+    pub node_lint_levels: RefCell<HashMap<(ast::NodeId, lint::LintId),\n+                                          lint::LevelSource>>,\n \n     /// The types that must be asserted to be the same size for `transmute`\n     /// to be valid. We gather up these restrictions in the intrinsicck pass"}, {"sha": "9d155ef31f98438790959f3565e5285f7c702001", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -79,7 +79,6 @@ type parameter).\n \n use middle::const_eval;\n use middle::def;\n-use middle::lint::UnreachableCode;\n use middle::pat_util::pat_id_map;\n use middle::pat_util;\n use middle::subst;\n@@ -111,6 +110,7 @@ use middle::typeck::{require_same_types, vtable_map};\n use middle::typeck::{MethodCall, MethodMap};\n use middle::typeck::{TypeAndSubsts};\n use middle::lang_items::TypeIdLangItem;\n+use lint;\n use util::common::{block_query, indenter, loop_query};\n use util::ppaux;\n use util::ppaux::{UserString, Repr};\n@@ -3416,7 +3416,7 @@ pub fn check_block_with_expected(fcx: &FnCtxt,\n                 fcx.ccx\n                    .tcx\n                    .sess\n-                   .add_lint(UnreachableCode,\n+                   .add_lint(lint::builtin::UNREACHABLE_CODE,\n                              s_id,\n                              s.span,\n                              \"unreachable statement\".to_string());\n@@ -3443,7 +3443,7 @@ pub fn check_block_with_expected(fcx: &FnCtxt,\n                 fcx.ccx\n                    .tcx\n                    .sess\n-                   .add_lint(UnreachableCode,\n+                   .add_lint(lint::builtin::UNREACHABLE_CODE,\n                              e.id,\n                              e.span,\n                              \"unreachable expression\".to_string());"}, {"sha": "5ae469c41f2dfa39ed0f37b06b50454db956cf3c", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -120,7 +120,8 @@ fn test_env(_test_name: &str,\n                              name: \"test\".to_owned(),\n                              version: None };\n     let (krate, ast_map) =\n-        driver::phase_2_configure_and_expand(&sess, krate, &krate_id);\n+        driver::phase_2_configure_and_expand(&sess, krate, &krate_id)\n+            .expect(\"phase 2 aborted\");\n \n     // run just enough stuff to build a tcx:\n     let lang_items = lang_items::collect_language_items(&krate, &sess);"}, {"sha": "587bedd502e15015d7920fc7110126c152f02512", "filename": "src/librustc/plugin/registry.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fplugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustc%2Fplugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fregistry.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -10,6 +10,8 @@\n \n //! Used by plugin crates to tell `rustc` about the plugins they provide.\n \n+use lint::LintPassObject;\n+\n use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT};\n use syntax::ext::base::{IdentTT, ItemDecorator, ItemModifier, BasicMacroExpander};\n use syntax::ext::base::{MacroExpanderFn};\n@@ -31,6 +33,9 @@ pub struct Registry {\n \n     #[doc(hidden)]\n     pub syntax_exts: Vec<NamedSyntaxExtension>,\n+\n+    #[doc(hidden)]\n+    pub lint_passes: Vec<LintPassObject>,\n }\n \n impl Registry {\n@@ -39,6 +44,7 @@ impl Registry {\n         Registry {\n             krate_span: krate.span,\n             syntax_exts: vec!(),\n+            lint_passes: vec!(),\n         }\n     }\n \n@@ -67,4 +73,9 @@ impl Registry {\n                 span: None,\n             }, None));\n     }\n+\n+    /// Register a compiler lint pass.\n+    pub fn register_lint_pass(&mut self, lint_pass: LintPassObject) {\n+        self.lint_passes.push(lint_pass);\n+    }\n }"}, {"sha": "ba0161da7e664054f9affe3d72cfc5c6c932c030", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -11,7 +11,7 @@\n use rustc;\n use rustc::{driver, middle};\n use rustc::middle::privacy;\n-use rustc::middle::lint;\n+use rustc::lint;\n \n use syntax::ast;\n use syntax::parse::token;\n@@ -75,11 +75,13 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>)\n \n     let input = FileInput(cpath.clone());\n \n+    let warning_lint = lint::builtin::WARNINGS.name_lower();\n+\n     let sessopts = driver::config::Options {\n         maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: RefCell::new(libs),\n         crate_types: vec!(driver::config::CrateTypeRlib),\n-        lint_opts: vec!((lint::Warnings, lint::Allow)),\n+        lint_opts: vec!((warning_lint, lint::Allow)),\n         ..rustc::driver::config::basic_options().clone()\n     };\n \n@@ -100,8 +102,10 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>)\n     }\n \n     let krate = phase_1_parse_input(&sess, cfg, &input);\n-    let (krate, ast_map) = phase_2_configure_and_expand(&sess, krate,\n-                                                        &from_str(\"rustdoc\").unwrap());\n+    let (krate, ast_map)\n+        = phase_2_configure_and_expand(&sess, krate, &from_str(\"rustdoc\").unwrap())\n+            .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n+\n     let driver::driver::CrateAnalysis {\n         exported_items, public_items, ty_cx, ..\n     } = phase_3_run_analysis_passes(sess, &krate, ast_map);"}, {"sha": "e7fc3cedf5ec9cd40cc834997b1ccb9d387b3397", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -69,7 +69,8 @@ pub fn run(input: &str,\n     }));\n     let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n     let (krate, _) = driver::phase_2_configure_and_expand(&sess, krate,\n-                                                          &from_str(\"rustdoc-test\").unwrap());\n+            &from_str(\"rustdoc-test\").unwrap())\n+        .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n \n     let ctx = box(GC) core::DocContext {\n         krate: krate,"}, {"sha": "e18cef6d1362452e9f51da1915a40b681d938bdd", "filename": "src/test/auxiliary/lint_plugin_test.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+\n+#![feature(phase, plugin_registrar)]\n+\n+extern crate syntax;\n+\n+// Load rustc as a plugin to get macros\n+#[phase(plugin, link)]\n+extern crate rustc;\n+\n+use syntax::ast;\n+use syntax::parse::token;\n+use rustc::lint::{Context, LintPass, LintPassObject, LintArray};\n+use rustc::plugin::Registry;\n+\n+declare_lint!(TEST_LINT, Warn,\n+              \"Warn about items named 'lintme'\")\n+\n+struct Pass;\n+\n+impl LintPass for Pass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(TEST_LINT)\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        let name = token::get_ident(it.ident);\n+        if name.get() == \"lintme\" {\n+            cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n+        }\n+    }\n+}\n+\n+#[plugin_registrar]\n+pub fn plugin_registrar(reg: &mut Registry) {\n+    reg.register_lint_pass(box Pass as LintPassObject);\n+}"}, {"sha": "9eb39a9178c027ffbaaf88499553ccd5e97a7b82", "filename": "src/test/compile-fail-fulldeps/lint-plugin-deny-attr.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-plugin-deny-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-plugin-deny-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-plugin-deny-attr.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:lint_plugin_test.rs\n+// ignore-stage1\n+\n+#![feature(phase)]\n+#![deny(test_lint)]\n+\n+#[phase(plugin)]\n+extern crate lint_plugin_test;\n+\n+fn lintme() { } //~ ERROR item is named 'lintme'\n+\n+pub fn main() {\n+    lintme();\n+}"}, {"sha": "46aa4b6b5b74154b6990eef8a9114be14d35dbfb", "filename": "src/test/compile-fail-fulldeps/lint-plugin-deny-cmdline.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-plugin-deny-cmdline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-plugin-deny-cmdline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-plugin-deny-cmdline.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:lint_plugin_test.rs\n+// ignore-stage1\n+// compile-flags: -D test-lint\n+\n+#![feature(phase)]\n+\n+#[phase(plugin)]\n+extern crate lint_plugin_test;\n+\n+fn lintme() { } //~ ERROR item is named 'lintme'\n+\n+pub fn main() {\n+    lintme();\n+}"}, {"sha": "329d3e86c052e0059ba28e07985c78012099e1ea", "filename": "src/test/compile-fail-fulldeps/lint-plugin-forbid-attrs.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-plugin-forbid-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-plugin-forbid-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-plugin-forbid-attrs.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:lint_plugin_test.rs\n+// ignore-stage1\n+\n+#![feature(phase)]\n+#![forbid(test_lint)]\n+\n+#[phase(plugin)]\n+extern crate lint_plugin_test;\n+\n+fn lintme() { } //~ ERROR item is named 'lintme'\n+\n+#[allow(test_lint)] //~ ERROR allow(test_lint) overruled by outer forbid(test_lint)\n+pub fn main() {\n+    lintme();\n+}"}, {"sha": "601faa22d77a0a51945f0979e76cea0eb4069615", "filename": "src/test/compile-fail-fulldeps/lint-plugin-forbid-cmdline.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-plugin-forbid-cmdline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-plugin-forbid-cmdline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-plugin-forbid-cmdline.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:lint_plugin_test.rs\n+// ignore-stage1\n+// compile-flags: -F test-lint\n+\n+#![feature(phase)]\n+\n+#[phase(plugin)]\n+extern crate lint_plugin_test;\n+\n+fn lintme() { } //~ ERROR item is named 'lintme'\n+\n+#[allow(test_lint)] //~ ERROR allow(test_lint) overruled by outer forbid(test_lint)\n+pub fn main() {\n+    lintme();\n+}"}, {"sha": "92fabd6050bc1ec95958c16c4fd98a614104cacb", "filename": "src/test/compile-fail/lint-forbid-attr.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Ftest%2Fcompile-fail%2Flint-forbid-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Ftest%2Fcompile-fail%2Flint-forbid-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-forbid-attr.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![forbid(experimental)]\n+\n+#[allow(experimental)] //~ ERROR allow(experimental) overruled by outer forbid(experimental)\n+fn main() {\n+}"}, {"sha": "4de84825ada9e26f95803a8d344087b39b2d29d1", "filename": "src/test/compile-fail/lint-forbid-cmdline.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Ftest%2Fcompile-fail%2Flint-forbid-cmdline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Ftest%2Fcompile-fail%2Flint-forbid-cmdline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-forbid-cmdline.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -F experimental\n+\n+#[allow(experimental)] //~ ERROR allow(experimental) overruled by outer forbid(experimental)\n+fn main() {\n+}"}, {"sha": "d3d1f1ea565a38580a8f7cb8082050f7870d1d59", "filename": "src/test/run-pass-fulldeps/lint-plugin-cmdline.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Ftest%2Frun-pass-fulldeps%2Flint-plugin-cmdline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Ftest%2Frun-pass-fulldeps%2Flint-plugin-cmdline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Flint-plugin-cmdline.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:lint_plugin_test.rs\n+// ignore-stage1\n+// compile-flags: -A test-lint\n+\n+#![feature(phase)]\n+\n+#[phase(plugin)]\n+extern crate lint_plugin_test;\n+\n+fn lintme() { }\n+\n+pub fn main() {\n+}"}, {"sha": "8c5269e2274108e66f6e39146858b152e2d10ea8", "filename": "src/test/run-pass-fulldeps/lint-plugin.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Ftest%2Frun-pass-fulldeps%2Flint-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ca9f747d62c9385cc142daa3c24a32d32a3f16/src%2Ftest%2Frun-pass-fulldeps%2Flint-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Flint-plugin.rs?ref=05ca9f747d62c9385cc142daa3c24a32d32a3f16", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:lint_plugin_test.rs\n+// ignore-stage1\n+// ignore-pretty\n+\n+#![feature(phase)]\n+\n+#[phase(plugin)]\n+extern crate lint_plugin_test;\n+\n+fn lintme() { } //~ WARNING item is named 'lintme'\n+\n+#[allow(test_lint)]\n+pub fn main() {\n+    fn lintme() { }\n+}"}]}