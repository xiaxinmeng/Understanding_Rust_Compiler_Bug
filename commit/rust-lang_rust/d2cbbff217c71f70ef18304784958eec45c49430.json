{"sha": "d2cbbff217c71f70ef18304784958eec45c49430", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyY2JiZmYyMTdjNzFmNzBlZjE4MzA0Nzg0OTU4ZWVjNDVjNDk0MzA=", "commit": {"author": {"name": "Roland Kuhn", "email": "rk@rkuhn.info", "date": "2020-04-07T13:39:07Z"}, "committer": {"name": "Roland Kuhn", "email": "rk@rkuhn.info", "date": "2020-04-17T11:54:05Z"}, "message": "add lint futures_not_send", "tree": {"sha": "ce88b5085488d9ed3ef722d0e277544efdf7c7dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce88b5085488d9ed3ef722d0e277544efdf7c7dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2cbbff217c71f70ef18304784958eec45c49430", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2cbbff217c71f70ef18304784958eec45c49430", "html_url": "https://github.com/rust-lang/rust/commit/d2cbbff217c71f70ef18304784958eec45c49430", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2cbbff217c71f70ef18304784958eec45c49430/comments", "author": {"login": "rkuhn", "id": 470469, "node_id": "MDQ6VXNlcjQ3MDQ2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/470469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rkuhn", "html_url": "https://github.com/rkuhn", "followers_url": "https://api.github.com/users/rkuhn/followers", "following_url": "https://api.github.com/users/rkuhn/following{/other_user}", "gists_url": "https://api.github.com/users/rkuhn/gists{/gist_id}", "starred_url": "https://api.github.com/users/rkuhn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rkuhn/subscriptions", "organizations_url": "https://api.github.com/users/rkuhn/orgs", "repos_url": "https://api.github.com/users/rkuhn/repos", "events_url": "https://api.github.com/users/rkuhn/events{/privacy}", "received_events_url": "https://api.github.com/users/rkuhn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rkuhn", "id": 470469, "node_id": "MDQ6VXNlcjQ3MDQ2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/470469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rkuhn", "html_url": "https://github.com/rkuhn", "followers_url": "https://api.github.com/users/rkuhn/followers", "following_url": "https://api.github.com/users/rkuhn/following{/other_user}", "gists_url": "https://api.github.com/users/rkuhn/gists{/gist_id}", "starred_url": "https://api.github.com/users/rkuhn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rkuhn/subscriptions", "organizations_url": "https://api.github.com/users/rkuhn/orgs", "repos_url": "https://api.github.com/users/rkuhn/repos", "events_url": "https://api.github.com/users/rkuhn/events{/privacy}", "received_events_url": "https://api.github.com/users/rkuhn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ea8e5e85659db1af8a1d76d39f88639c0724f99", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ea8e5e85659db1af8a1d76d39f88639c0724f99", "html_url": "https://github.com/rust-lang/rust/commit/3ea8e5e85659db1af8a1d76d39f88639c0724f99"}], "stats": {"total": 329, "additions": 329, "deletions": 0}, "files": [{"sha": "60ad855d7f87e79895d8f3f81d391c4779cd5ade", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2cbbff217c71f70ef18304784958eec45c49430/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/d2cbbff217c71f70ef18304784958eec45c49430/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=d2cbbff217c71f70ef18304784958eec45c49430", "patch": "@@ -1281,6 +1281,7 @@ Released 2018-09-13\n [`for_loop_over_result`]: https://rust-lang.github.io/rust-clippy/master/index.html#for_loop_over_result\n [`forget_copy`]: https://rust-lang.github.io/rust-clippy/master/index.html#forget_copy\n [`forget_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#forget_ref\n+[`future_not_send`]: https://rust-lang.github.io/rust-clippy/master/index.html#future_not_send\n [`get_last_with_len`]: https://rust-lang.github.io/rust-clippy/master/index.html#get_last_with_len\n [`get_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#get_unwrap\n [`identity_conversion`]: https://rust-lang.github.io/rust-clippy/master/index.html#identity_conversion"}, {"sha": "57f47bc9bc932f50deb27b13a1ffc07ae73a0279", "filename": "clippy_lints/src/future_not_send.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/d2cbbff217c71f70ef18304784958eec45c49430/clippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2cbbff217c71f70ef18304784958eec45c49430/clippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=d2cbbff217c71f70ef18304784958eec45c49430", "patch": "@@ -0,0 +1,113 @@\n+use crate::utils;\n+use rustc_hir::intravisit::FnKind;\n+use rustc_hir::{Body, FnDecl, HirId};\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{Opaque, Predicate::Trait, ToPolyTraitRef};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{sym, Span};\n+use rustc_trait_selection::traits::error_reporting::suggestions::InferCtxtExt;\n+use rustc_trait_selection::traits::{self, FulfillmentError, TraitEngine};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** This lint requires Future implementations returned from\n+    /// functions and methods to implement the `Send` marker trait. It is mostly\n+    /// used by library authors (public and internal) that target an audience where\n+    /// multithreaded executors are likely to be used for running these Futures.\n+    ///\n+    /// **Why is this bad?** A Future implementation captures some state that it\n+    /// needs to eventually produce its final value. When targeting a multithreaded\n+    /// executor (which is the norm on non-embedded devices) this means that this\n+    /// state may need to be transported to other threads, in other words the\n+    /// whole Future needs to implement the `Send` marker trait. If it does not,\n+    /// then the resulting Future cannot be submitted to a thread pool in the\n+    /// end user\u2019s code.\n+    ///\n+    /// Especially for generic functions it can be confusing to leave the\n+    /// discovery of this problem to the end user: the reported error location\n+    /// will be far from its cause and can in many cases not even be fixed without\n+    /// modifying the library where the offending Future implementation is\n+    /// produced.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// async fn not_send(bytes: std::rc::Rc<[u8]>) {}\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// async fn is_send(bytes: std::sync::Arc<[u8]>) {}\n+    /// ```\n+    pub FUTURE_NOT_SEND,\n+    nursery,\n+    \"public Futures must be Send\"\n+}\n+\n+declare_lint_pass!(FutureNotSend => [FUTURE_NOT_SEND]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FutureNotSend {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        kind: FnKind<'tcx>,\n+        decl: &'tcx FnDecl<'tcx>,\n+        _: &'tcx Body<'tcx>,\n+        _: Span,\n+        hir_id: HirId,\n+    ) {\n+        if let FnKind::Closure(_) = kind {\n+            return;\n+        }\n+        let def_id = cx.tcx.hir().local_def_id(hir_id);\n+        let fn_sig = cx.tcx.fn_sig(def_id);\n+        let fn_sig = cx.tcx.erase_late_bound_regions(&fn_sig);\n+        let ret_ty = fn_sig.output();\n+        if let Opaque(id, subst) = ret_ty.kind {\n+            let preds = cx.tcx.predicates_of(id).instantiate(cx.tcx, subst);\n+            let mut is_future = false;\n+            for p in preds.predicates {\n+                if let Some(trait_ref) = p.to_opt_poly_trait_ref() {\n+                    if Some(trait_ref.def_id()) == cx.tcx.lang_items().future_trait() {\n+                        is_future = true;\n+                        break;\n+                    }\n+                }\n+            }\n+            if is_future {\n+                let send_trait = cx.tcx.get_diagnostic_item(sym::send_trait).unwrap();\n+                let span = decl.output.span();\n+                let send_result = cx.tcx.infer_ctxt().enter(|infcx| {\n+                    let cause = traits::ObligationCause::misc(span, hir_id);\n+                    let mut fulfillment_cx = traits::FulfillmentContext::new();\n+                    fulfillment_cx.register_bound(&infcx, cx.param_env, ret_ty, send_trait, cause);\n+                    fulfillment_cx.select_all_or_error(&infcx)\n+                });\n+                if let Err(send_errors) = send_result {\n+                    utils::span_lint_and_then(\n+                        cx,\n+                        FUTURE_NOT_SEND,\n+                        span,\n+                        \"future cannot be sent between threads safely\",\n+                        |db| {\n+                            cx.tcx.infer_ctxt().enter(|infcx| {\n+                                for FulfillmentError { obligation, .. } in send_errors {\n+                                    infcx.maybe_note_obligation_cause_for_async_await(db, &obligation);\n+                                    if let Trait(trait_pred, _) = obligation.predicate {\n+                                        let trait_ref = trait_pred.to_poly_trait_ref();\n+                                        db.note(&*format!(\n+                                            \"`{}` doesn't implement `{}`\",\n+                                            trait_ref.self_ty(),\n+                                            trait_ref.print_only_trait_path(),\n+                                        ));\n+                                    }\n+                                }\n+                            })\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "a5b55d2ab704b2080cfe2cce9ed7150d9ddac2ad", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2cbbff217c71f70ef18304784958eec45c49430/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2cbbff217c71f70ef18304784958eec45c49430/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=d2cbbff217c71f70ef18304784958eec45c49430", "patch": "@@ -218,6 +218,7 @@ mod floating_point_arithmetic;\n mod format;\n mod formatting;\n mod functions;\n+mod future_not_send;\n mod get_last_with_len;\n mod identity_conversion;\n mod identity_op;\n@@ -566,6 +567,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &functions::NOT_UNSAFE_PTR_ARG_DEREF,\n         &functions::TOO_MANY_ARGUMENTS,\n         &functions::TOO_MANY_LINES,\n+        &future_not_send::FUTURE_NOT_SEND,\n         &get_last_with_len::GET_LAST_WITH_LEN,\n         &identity_conversion::IDENTITY_CONVERSION,\n         &identity_op::IDENTITY_OP,\n@@ -1045,6 +1047,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box redundant_pub_crate::RedundantPubCrate::default());\n     store.register_late_pass(|| box unnamed_address::UnnamedAddress);\n     store.register_late_pass(|| box dereference::Dereferencing);\n+    store.register_late_pass(|| box future_not_send::FutureNotSend);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1689,6 +1692,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&fallible_impl_from::FALLIBLE_IMPL_FROM),\n         LintId::of(&floating_point_arithmetic::IMPRECISE_FLOPS),\n         LintId::of(&floating_point_arithmetic::SUBOPTIMAL_FLOPS),\n+        LintId::of(&future_not_send::FUTURE_NOT_SEND),\n         LintId::of(&missing_const_for_fn::MISSING_CONST_FOR_FN),\n         LintId::of(&mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL),\n         LintId::of(&mutex_atomic::MUTEX_INTEGER),"}, {"sha": "cf2537e6d66973e61c85d2432f49eac028faab38", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d2cbbff217c71f70ef18304784958eec45c49430/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2cbbff217c71f70ef18304784958eec45c49430/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=d2cbbff217c71f70ef18304784958eec45c49430", "patch": "@@ -696,6 +696,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"drop_forget_ref\",\n     },\n+    Lint {\n+        name: \"future_not_send\",\n+        group: \"nursery\",\n+        desc: \"public Futures must be Send\",\n+        deprecation: None,\n+        module: \"future_not_send\",\n+    },\n     Lint {\n         name: \"get_last_with_len\",\n         group: \"complexity\","}, {"sha": "6d09d71a630a28b6e85b089b6b74cf94a9558f45", "filename": "tests/ui/future_not_send.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/d2cbbff217c71f70ef18304784958eec45c49430/tests%2Fui%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2cbbff217c71f70ef18304784958eec45c49430/tests%2Fui%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffuture_not_send.rs?ref=d2cbbff217c71f70ef18304784958eec45c49430", "patch": "@@ -0,0 +1,79 @@\n+// edition:2018\n+#![warn(clippy::future_not_send)]\n+\n+use std::cell::Cell;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+async fn private_future(rc: Rc<[u8]>, cell: &Cell<usize>) -> bool {\n+    async { true }.await\n+}\n+\n+pub async fn public_future(rc: Rc<[u8]>) {\n+    async { true }.await;\n+}\n+\n+pub async fn public_send(arc: Arc<[u8]>) -> bool {\n+    async { false }.await\n+}\n+\n+async fn private_future2(rc: Rc<[u8]>, cell: &Cell<usize>) -> bool {\n+    true\n+}\n+\n+pub async fn public_future2(rc: Rc<[u8]>) {}\n+\n+pub async fn public_send2(arc: Arc<[u8]>) -> bool {\n+    false\n+}\n+\n+struct Dummy {\n+    rc: Rc<[u8]>,\n+}\n+\n+impl Dummy {\n+    async fn private_future(&self) -> usize {\n+        async { true }.await;\n+        self.rc.len()\n+    }\n+\n+    pub async fn public_future(&self) {\n+        self.private_future().await;\n+    }\n+\n+    pub fn public_send(&self) -> impl std::future::Future<Output = bool> {\n+        async { false }\n+    }\n+}\n+\n+async fn generic_future<T>(t: T) -> T\n+where\n+    T: Send,\n+{\n+    let rt = &t;\n+    async { true }.await;\n+    t\n+}\n+\n+async fn generic_future_send<T>(t: T)\n+where\n+    T: Send,\n+{\n+    async { true }.await;\n+}\n+\n+async fn unclear_future<T>(t: T) {}\n+\n+fn main() {\n+    let rc = Rc::new([1, 2, 3]);\n+    private_future(rc.clone(), &Cell::new(42));\n+    public_future(rc.clone());\n+    let arc = Arc::new([4, 5, 6]);\n+    public_send(arc);\n+    generic_future(42);\n+    generic_future_send(42);\n+\n+    let dummy = Dummy { rc };\n+    dummy.public_future();\n+    dummy.public_send();\n+}"}, {"sha": "3b4968ef0a63c528c8060966465c349c55dc6b94", "filename": "tests/ui/future_not_send.stderr", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/d2cbbff217c71f70ef18304784958eec45c49430/tests%2Fui%2Ffuture_not_send.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d2cbbff217c71f70ef18304784958eec45c49430/tests%2Fui%2Ffuture_not_send.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffuture_not_send.stderr?ref=d2cbbff217c71f70ef18304784958eec45c49430", "patch": "@@ -0,0 +1,125 @@\n+error: future cannot be sent between threads safely\n+  --> $DIR/future_not_send.rs:8:62\n+   |\n+LL | async fn private_future(rc: Rc<[u8]>, cell: &Cell<usize>) -> bool {\n+   |                                                              ^^^^ future returned by `private_future` is not `Send`\n+   |\n+   = note: `-D clippy::future-not-send` implied by `-D warnings`\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/future_not_send.rs:9:5\n+   |\n+LL | async fn private_future(rc: Rc<[u8]>, cell: &Cell<usize>) -> bool {\n+   |                         -- has type `std::rc::Rc<[u8]>` which is not `Send`\n+LL |     async { true }.await\n+   |     ^^^^^^^^^^^^^^^^^^^^ await occurs here, with `rc` maybe used later\n+LL | }\n+   | - `rc` is later dropped here\n+   = note: `std::rc::Rc<[u8]>` doesn't implement `std::marker::Send`\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/future_not_send.rs:9:5\n+   |\n+LL | async fn private_future(rc: Rc<[u8]>, cell: &Cell<usize>) -> bool {\n+   |                                       ---- has type `&std::cell::Cell<usize>` which is not `Send`\n+LL |     async { true }.await\n+   |     ^^^^^^^^^^^^^^^^^^^^ await occurs here, with `cell` maybe used later\n+LL | }\n+   | - `cell` is later dropped here\n+   = note: `std::cell::Cell<usize>` doesn't implement `std::marker::Sync`\n+\n+error: future cannot be sent between threads safely\n+  --> $DIR/future_not_send.rs:12:42\n+   |\n+LL | pub async fn public_future(rc: Rc<[u8]>) {\n+   |                                          ^ future returned by `public_future` is not `Send`\n+   |\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/future_not_send.rs:13:5\n+   |\n+LL | pub async fn public_future(rc: Rc<[u8]>) {\n+   |                            -- has type `std::rc::Rc<[u8]>` which is not `Send`\n+LL |     async { true }.await;\n+   |     ^^^^^^^^^^^^^^^^^^^^ await occurs here, with `rc` maybe used later\n+LL | }\n+   | - `rc` is later dropped here\n+   = note: `std::rc::Rc<[u8]>` doesn't implement `std::marker::Send`\n+\n+error: future cannot be sent between threads safely\n+  --> $DIR/future_not_send.rs:20:63\n+   |\n+LL | async fn private_future2(rc: Rc<[u8]>, cell: &Cell<usize>) -> bool {\n+   |                                                               ^^^^\n+   |\n+   = note: `std::rc::Rc<[u8]>` doesn't implement `std::marker::Send`\n+   = note: `std::cell::Cell<usize>` doesn't implement `std::marker::Sync`\n+\n+error: future cannot be sent between threads safely\n+  --> $DIR/future_not_send.rs:24:43\n+   |\n+LL | pub async fn public_future2(rc: Rc<[u8]>) {}\n+   |                                           ^\n+   |\n+   = note: `std::rc::Rc<[u8]>` doesn't implement `std::marker::Send`\n+\n+error: future cannot be sent between threads safely\n+  --> $DIR/future_not_send.rs:35:39\n+   |\n+LL |     async fn private_future(&self) -> usize {\n+   |                                       ^^^^^ future returned by `private_future` is not `Send`\n+   |\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/future_not_send.rs:36:9\n+   |\n+LL |     async fn private_future(&self) -> usize {\n+   |                             ----- has type `&Dummy` which is not `Send`\n+LL |         async { true }.await;\n+   |         ^^^^^^^^^^^^^^^^^^^^ await occurs here, with `&self` maybe used later\n+LL |         self.rc.len()\n+LL |     }\n+   |     - `&self` is later dropped here\n+   = note: `std::rc::Rc<[u8]>` doesn't implement `std::marker::Sync`\n+\n+error: future cannot be sent between threads safely\n+  --> $DIR/future_not_send.rs:40:39\n+   |\n+LL |     pub async fn public_future(&self) {\n+   |                                       ^ future returned by `public_future` is not `Send`\n+   |\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/future_not_send.rs:41:9\n+   |\n+LL |     pub async fn public_future(&self) {\n+   |                                ----- has type `&Dummy` which is not `Send`\n+LL |         self.private_future().await;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ await occurs here, with `&self` maybe used later\n+LL |     }\n+   |     - `&self` is later dropped here\n+   = note: `std::rc::Rc<[u8]>` doesn't implement `std::marker::Sync`\n+\n+error: future cannot be sent between threads safely\n+  --> $DIR/future_not_send.rs:49:37\n+   |\n+LL | async fn generic_future<T>(t: T) -> T\n+   |                                     ^ future returned by `generic_future` is not `Send`\n+   |\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/future_not_send.rs:54:5\n+   |\n+LL |     let rt = &t;\n+   |         -- has type `&T` which is not `Send`\n+LL |     async { true }.await;\n+   |     ^^^^^^^^^^^^^^^^^^^^ await occurs here, with `rt` maybe used later\n+LL |     t\n+LL | }\n+   | - `rt` is later dropped here\n+   = note: `T` doesn't implement `std::marker::Sync`\n+\n+error: future cannot be sent between threads safely\n+  --> $DIR/future_not_send.rs:65:34\n+   |\n+LL | async fn unclear_future<T>(t: T) {}\n+   |                                  ^\n+   |\n+   = note: `T` doesn't implement `std::marker::Send`\n+\n+error: aborting due to 8 previous errors\n+"}]}