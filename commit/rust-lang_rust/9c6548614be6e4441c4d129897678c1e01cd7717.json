{"sha": "9c6548614be6e4441c4d129897678c1e01cd7717", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljNjU0ODYxNGJlNmU0NDQxYzRkMTI5ODk3Njc4YzFlMDFjZDc3MTc=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-01T14:42:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-01T14:42:44Z"}, "message": "Rollup merge of #73705 - lcnr:skip_binder, r=nikomatsakis\n\nstop taking references in Relate\n\nAdds a `Copy` bound to `Relate` and changes the type signatures to `T` from `&T`. While the `Copy` bound is not strictly necessary (i.e. the `Clone` bound of `TypeRelation` would be good enough), we don't need non `Copy` types and it simplifies the implementation.\n\nRemoves the afaict unused impls for `Vec<ty::PolyExistentialProjection<'tcx>>`, `Rc<T>` and `Box<T>`. If they end up being relevant again the bound of `Relate` can be reduced to `T: Clone`.\n\nThis also changes signature of `Binder::skip_binder` to `fn skip_binder(self) -> T`.\n\n`TypeError::ProjectionBoundsLength` was never used and is also removed in this PR.\n\nr? @nikomatsakis maybe :thinking: feel free to reassign", "tree": {"sha": "476e95f9247f25ec832d467a0e3c7e35f2b4090f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/476e95f9247f25ec832d467a0e3c7e35f2b4090f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c6548614be6e4441c4d129897678c1e01cd7717", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe/KDkCRBK7hj4Ov3rIwAAdHIIAJLBgLhMobpswyW2VGWzYRH9\nK8nJjLL6ZREAWwPPH4Zd6lS7czH7tMAHQMJm5OSouN6Qjoayr/mb0Bk/mQclo0CG\nBqYcX0/onKpvJmKX09iWKodt0s7SaZ29v2aCHP8sWhPam1/YLdMyEY7Wn948bC1A\nAuvdLmjl29gh/I/g6vjspjsxLyo4aNzAhp/p2EPvDEethOS8R5ZRDzU93BHe8ctR\nxgWfcGF9uD1aYKPNGHQzthRr1Yef5UH9uw4uddFObJjRD63M1zf6u6ZW4FndhR31\nQ4r/F+PCgmmZhwKCwWFaf4x9c8hecvy8bskrejY7OlVHWq0jmHOT2acl/qTBvAk=\n=yqK3\n-----END PGP SIGNATURE-----\n", "payload": "tree 476e95f9247f25ec832d467a0e3c7e35f2b4090f\nparent 6556f269918124b43db67367867c6930cb3189c9\nparent 69e49908f9a3fa2ebee94f67825bce15118c10ba\nauthor Manish Goregaokar <manishsmail@gmail.com> 1593614564 -0700\ncommitter GitHub <noreply@github.com> 1593614564 -0700\n\nRollup merge of #73705 - lcnr:skip_binder, r=nikomatsakis\n\nstop taking references in Relate\n\nAdds a `Copy` bound to `Relate` and changes the type signatures to `T` from `&T`. While the `Copy` bound is not strictly necessary (i.e. the `Clone` bound of `TypeRelation` would be good enough), we don't need non `Copy` types and it simplifies the implementation.\n\nRemoves the afaict unused impls for `Vec<ty::PolyExistentialProjection<'tcx>>`, `Rc<T>` and `Box<T>`. If they end up being relevant again the bound of `Relate` can be reduced to `T: Clone`.\n\nThis also changes signature of `Binder::skip_binder` to `fn skip_binder(self) -> T`.\n\n`TypeError::ProjectionBoundsLength` was never used and is also removed in this PR.\n\nr? @nikomatsakis maybe :thinking: feel free to reassign\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c6548614be6e4441c4d129897678c1e01cd7717", "html_url": "https://github.com/rust-lang/rust/commit/9c6548614be6e4441c4d129897678c1e01cd7717", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c6548614be6e4441c4d129897678c1e01cd7717/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6556f269918124b43db67367867c6930cb3189c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6556f269918124b43db67367867c6930cb3189c9", "html_url": "https://github.com/rust-lang/rust/commit/6556f269918124b43db67367867c6930cb3189c9"}, {"sha": "69e49908f9a3fa2ebee94f67825bce15118c10ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/69e49908f9a3fa2ebee94f67825bce15118c10ba", "html_url": "https://github.com/rust-lang/rust/commit/69e49908f9a3fa2ebee94f67825bce15118c10ba"}], "stats": {"total": 545, "additions": 242, "deletions": 303}, "files": [{"sha": "a7749d33b7c1389edcd874c10151ac8403d17da7", "filename": "src/librustc_infer/infer/at.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_infer%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_infer%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fat.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -82,7 +82,7 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace_exp(a_is_expected, a, b).sub(&a, &b)\n+        self.trace_exp(a_is_expected, a, b).sub(a, b)\n     }\n \n     /// Makes `actual <: expected`. For example, if type-checking a\n@@ -109,15 +109,15 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace_exp(a_is_expected, a, b).eq(&a, &b)\n+        self.trace_exp(a_is_expected, a, b).eq(a, b)\n     }\n \n     /// Makes `expected <: actual`.\n     pub fn eq<T>(self, expected: T, actual: T) -> InferResult<'tcx, ()>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace(expected, actual).eq(&expected, &actual)\n+        self.trace(expected, actual).eq(expected, actual)\n     }\n \n     pub fn relate<T>(self, expected: T, variance: ty::Variance, actual: T) -> InferResult<'tcx, ()>\n@@ -147,7 +147,7 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace(expected, actual).lub(&expected, &actual)\n+        self.trace(expected, actual).lub(expected, actual)\n     }\n \n     /// Computes the greatest-lower-bound, or mutual subtype, of two\n@@ -157,7 +157,7 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace(expected, actual).glb(&expected, &actual)\n+        self.trace(expected, actual).glb(expected, actual)\n     }\n \n     /// Sets the \"trace\" values that will be used for\n@@ -186,7 +186,7 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n impl<'a, 'tcx> Trace<'a, 'tcx> {\n     /// Makes `a <: b` where `a` may or may not be expected (if\n     /// `a_is_expected` is true, then `a` is expected).\n-    pub fn sub<T>(self, a: &T, b: &T) -> InferResult<'tcx, ()>\n+    pub fn sub<T>(self, a: T, b: T) -> InferResult<'tcx, ()>\n     where\n         T: Relate<'tcx>,\n     {\n@@ -203,7 +203,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n \n     /// Makes `a == b`; the expectation is set by the call to\n     /// `trace()`.\n-    pub fn eq<T>(self, a: &T, b: &T) -> InferResult<'tcx, ()>\n+    pub fn eq<T>(self, a: T, b: T) -> InferResult<'tcx, ()>\n     where\n         T: Relate<'tcx>,\n     {\n@@ -218,7 +218,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n         })\n     }\n \n-    pub fn lub<T>(self, a: &T, b: &T) -> InferResult<'tcx, T>\n+    pub fn lub<T>(self, a: T, b: T) -> InferResult<'tcx, T>\n     where\n         T: Relate<'tcx>,\n     {\n@@ -233,7 +233,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n         })\n     }\n \n-    pub fn glb<T>(self, a: &T, b: &T) -> InferResult<'tcx, T>\n+    pub fn glb<T>(self, a: T, b: T) -> InferResult<'tcx, T>\n     where\n         T: Relate<'tcx>,\n     {"}, {"sha": "5cba581b9dffb4c2bdc10c07d111e1d532436334", "filename": "src/librustc_infer/infer/canonical/query_response.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -271,7 +271,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                         },\n                         ty::Variance::Invariant,\n                     )\n-                    .relate(&v1, &v2)?;\n+                    .relate(v1, v2)?;\n                 }\n \n                 (GenericArgKind::Const(v1), GenericArgKind::Const(v2)) => {\n@@ -285,7 +285,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                         },\n                         ty::Variance::Invariant,\n                     )\n-                    .relate(&v1, &v2)?;\n+                    .relate(v1, v2)?;\n                 }\n \n                 _ => {\n@@ -302,7 +302,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 // Screen out `'a: 'a` cases -- we skip the binder here but\n                 // only compare the inner values to one another, so they are still at\n                 // consistent binding levels.\n-                let &ty::OutlivesPredicate(k1, r2) = r_c.skip_binder();\n+                let ty::OutlivesPredicate(k1, r2) = r_c.skip_binder();\n                 if k1 != r2.into() { Some(r_c) } else { None }\n             }),\n         );\n@@ -526,7 +526,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a + Captures<'tcx> {\n         unsubstituted_region_constraints.iter().map(move |constraint| {\n             let constraint = substitute_value(self.tcx, result_subst, constraint);\n-            let &ty::OutlivesPredicate(k1, r2) = constraint.skip_binder(); // restored below\n+            let ty::OutlivesPredicate(k1, r2) = constraint.skip_binder(); // restored below\n \n             Obligation::new(\n                 cause.clone(),"}, {"sha": "c8d4e9f0e14b9e66c916b3cb84b8927ae24c2a72", "filename": "src/librustc_infer/infer/combine.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -318,10 +318,10 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         // to associate causes/spans with each of the relations in\n         // the stack to get this right.\n         match dir {\n-            EqTo => self.equate(a_is_expected).relate(&a_ty, &b_ty),\n-            SubtypeOf => self.sub(a_is_expected).relate(&a_ty, &b_ty),\n+            EqTo => self.equate(a_is_expected).relate(a_ty, b_ty),\n+            SubtypeOf => self.sub(a_is_expected).relate(a_ty, b_ty),\n             SupertypeOf => {\n-                self.sub(a_is_expected).relate_with_variance(ty::Contravariant, &a_ty, &b_ty)\n+                self.sub(a_is_expected).relate_with_variance(ty::Contravariant, a_ty, b_ty)\n             }\n         }?;\n \n@@ -379,7 +379,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             param_env: self.param_env,\n         };\n \n-        let ty = match generalize.relate(&ty, &ty) {\n+        let ty = match generalize.relate(ty, ty) {\n             Ok(ty) => ty,\n             Err(e) => {\n                 debug!(\"generalize: failure {:?}\", e);\n@@ -490,8 +490,8 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,\n@@ -519,8 +519,8 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         let old_ambient_variance = self.ambient_variance;\n         self.ambient_variance = self.ambient_variance.xform(variance);\n@@ -552,7 +552,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                     match probe {\n                         TypeVariableValue::Known { value: u } => {\n                             debug!(\"generalize: known value {:?}\", u);\n-                            self.relate(&u, &u)\n+                            self.relate(u, u)\n                         }\n                         TypeVariableValue::Unknown { universe } => {\n                             match self.ambient_variance {\n@@ -655,7 +655,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                 let variable_table = &mut inner.const_unification_table();\n                 let var_value = variable_table.probe_value(vid);\n                 match var_value.val {\n-                    ConstVariableValue::Known { value: u } => self.relate(&u, &u),\n+                    ConstVariableValue::Known { value: u } => self.relate(u, u),\n                     ConstVariableValue::Unknown { universe } => {\n                         if self.for_universe.can_name(universe) {\n                             Ok(c)"}, {"sha": "7de752d1de0dbe3be10fc0175965ed5b69897fac", "filename": "src/librustc_infer/infer/equate.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_infer%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_infer%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fequate.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -59,8 +59,8 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         self.relate(a, b)\n     }\n@@ -124,8 +124,8 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,\n@@ -136,7 +136,7 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n         } else {\n             // Fast path for the common case.\n             self.relate(a.skip_binder(), b.skip_binder())?;\n-            Ok(a.clone())\n+            Ok(a)\n         }\n     }\n }"}, {"sha": "8a0ab52f383065cd72205619ec3232cf0a6ce8a2", "filename": "src/librustc_infer/infer/glb.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_infer%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_infer%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fglb.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -43,8 +43,8 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         match variance {\n             ty::Invariant => self.fields.equate(self.a_is_expected).relate(a, b),\n@@ -85,8 +85,8 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,\n@@ -112,8 +112,8 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Glb<'combine, 'infcx,\n \n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n         let mut sub = self.fields.sub(self.a_is_expected);\n-        sub.relate(&v, &a)?;\n-        sub.relate(&v, &b)?;\n+        sub.relate(v, a)?;\n+        sub.relate(v, b)?;\n         Ok(())\n     }\n }"}, {"sha": "ea19dff7db125098ba4b1ad85f765af989cf64aa", "filename": "src/librustc_infer/infer/higher_ranked/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -11,8 +11,8 @@ use rustc_middle::ty::{self, Binder, TypeFoldable};\n impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n     pub fn higher_ranked_sub<T>(\n         &mut self,\n-        a: &Binder<T>,\n-        b: &Binder<T>,\n+        a: Binder<T>,\n+        b: Binder<T>,\n         a_is_expected: bool,\n     ) -> RelateResult<'tcx, Binder<T>>\n     where\n@@ -33,20 +33,20 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n         self.infcx.commit_if_ok(|_| {\n             // First, we instantiate each bound region in the supertype with a\n             // fresh placeholder region.\n-            let (b_prime, _) = self.infcx.replace_bound_vars_with_placeholders(b);\n+            let (b_prime, _) = self.infcx.replace_bound_vars_with_placeholders(&b);\n \n             // Next, we instantiate each bound region in the subtype\n             // with a fresh region variable. These region variables --\n             // but no other pre-existing region variables -- can name\n             // the placeholders.\n             let (a_prime, _) =\n-                self.infcx.replace_bound_vars_with_fresh_vars(span, HigherRankedType, a);\n+                self.infcx.replace_bound_vars_with_fresh_vars(span, HigherRankedType, &a);\n \n             debug!(\"a_prime={:?}\", a_prime);\n             debug!(\"b_prime={:?}\", b_prime);\n \n             // Compare types now that bound regions have been replaced.\n-            let result = self.sub(a_is_expected).relate(&a_prime, &b_prime)?;\n+            let result = self.sub(a_is_expected).relate(a_prime, b_prime)?;\n \n             debug!(\"higher_ranked_sub: OK result={:?}\", result);\n "}, {"sha": "3e2ea3d0f8fbf19856222dcaefbed6e22acfa477", "filename": "src/librustc_infer/infer/lub.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_infer%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_infer%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flub.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -43,8 +43,8 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         match variance {\n             ty::Invariant => self.fields.equate(self.a_is_expected).relate(a, b),\n@@ -85,8 +85,8 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,\n@@ -97,7 +97,7 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n         // very challenging, switch to invariance. This is obviously\n         // overly conservative but works ok in practice.\n         self.relate_with_variance(ty::Variance::Invariant, a, b)?;\n-        Ok(a.clone())\n+        Ok(a)\n     }\n }\n \n@@ -118,8 +118,8 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Lub<'combine, 'infcx,\n \n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n         let mut sub = self.fields.sub(self.a_is_expected);\n-        sub.relate(&a, &v)?;\n-        sub.relate(&b, &v)?;\n+        sub.relate(a, v)?;\n+        sub.relate(b, v)?;\n         Ok(())\n     }\n }"}, {"sha": "cb1f1c08d88f88cce50efd51249bd7482c324e28", "filename": "src/librustc_infer/infer/nll_relate/mod.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -161,7 +161,7 @@ where\n \n     fn create_scope(\n         &mut self,\n-        value: &ty::Binder<impl TypeFoldable<'tcx>>,\n+        value: ty::Binder<impl Relate<'tcx>>,\n         universally_quantified: UniversallyQuantified,\n     ) -> BoundRegionScope<'tcx> {\n         let mut scope = BoundRegionScope::default();\n@@ -369,7 +369,7 @@ where\n             universe,\n         };\n \n-        generalizer.relate(&value, &value)\n+        generalizer.relate(value, value)\n     }\n }\n \n@@ -495,8 +495,8 @@ where\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         debug!(\"relate_with_variance(variance={:?}, a={:?}, b={:?})\", variance, a, b);\n \n@@ -613,8 +613,8 @@ where\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,\n@@ -640,11 +640,10 @@ where\n \n         debug!(\"binders({:?}: {:?}, ambient_variance={:?})\", a, b, self.ambient_variance);\n \n-        if !a.skip_binder().has_escaping_bound_vars() && !b.skip_binder().has_escaping_bound_vars()\n-        {\n+        if let (Some(a), Some(b)) = (a.no_bound_vars(), b.no_bound_vars()) {\n             // Fast path for the common case.\n-            self.relate(a.skip_binder(), b.skip_binder())?;\n-            return Ok(a.clone());\n+            self.relate(a, b)?;\n+            return Ok(ty::Binder::bind(a));\n         }\n \n         if self.ambient_covariance() {\n@@ -839,8 +838,8 @@ where\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         debug!(\n             \"TypeGeneralizer::relate_with_variance(variance={:?}, a={:?}, b={:?})\",\n@@ -890,7 +889,7 @@ where\n                     match variables.probe(vid) {\n                         TypeVariableValue::Known { value: u } => {\n                             drop(variables);\n-                            self.relate(&u, &u)\n+                            self.relate(u, u)\n                         }\n                         TypeVariableValue::Unknown { universe: _universe } => {\n                             if self.ambient_variance == ty::Bivariant {\n@@ -984,7 +983,7 @@ where\n                 let variable_table = &mut inner.const_unification_table();\n                 let var_value = variable_table.probe_value(vid);\n                 match var_value.val.known() {\n-                    Some(u) => self.relate(&u, &u),\n+                    Some(u) => self.relate(u, u),\n                     None => {\n                         let new_var_id = variable_table.new_key(ConstVarValue {\n                             origin: var_value.origin,\n@@ -1001,8 +1000,8 @@ where\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        _: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        _: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,"}, {"sha": "d190f7e434298996252818144e695e96fcc61d75", "filename": "src/librustc_infer/infer/sub.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fsub.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -62,8 +62,8 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         match variance {\n             ty::Invariant => self.fields.equate(self.a_is_expected).relate(a, b),\n@@ -162,8 +162,8 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,"}, {"sha": "d55cbbe19c279d9699672b8842762e24bb64b261", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -911,7 +911,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n                 }\n                 let sig = cx.tables().node_type(expr.hir_id).fn_sig(cx.tcx);\n                 let from = sig.inputs().skip_binder()[0];\n-                let to = *sig.output().skip_binder();\n+                let to = sig.output().skip_binder();\n                 return Some((from, to));\n             }\n             None"}, {"sha": "8f15c99f951fe234000288f1a36bc70cbd4b8494", "filename": "src/librustc_middle/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -123,7 +123,7 @@ where\n     T: HashStable<StableHashingContext<'a>>,\n {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        self.skip_binder().hash_stable(hcx, hasher);\n+        self.as_ref().skip_binder().hash_stable(hcx, hasher);\n     }\n }\n "}, {"sha": "4693a2f66fb4ccfef2522681a9e436c82a38b916", "filename": "src/librustc_middle/ty/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_middle%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_middle%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2F_match.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -46,8 +46,8 @@ impl TypeRelation<'tcx> for Match<'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         self.relate(a, b)\n     }\n@@ -112,8 +112,8 @@ impl TypeRelation<'tcx> for Match<'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,"}, {"sha": "30ff5a2d9ebdfcd660dbd4c48eee1971204471d5", "filename": "src/librustc_middle/ty/error.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_middle%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_middle%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ferror.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -57,7 +57,6 @@ pub enum TypeError<'tcx> {\n     /// type).\n     CyclicTy(Ty<'tcx>),\n     ProjectionMismatched(ExpectedFound<DefId>),\n-    ProjectionBoundsLength(ExpectedFound<usize>),\n     ExistentialMismatch(ExpectedFound<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>),\n     ObjectUnsafeCoercion(DefId),\n     ConstMismatch(ExpectedFound<&'tcx ty::Const<'tcx>>),\n@@ -174,13 +173,6 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                     tcx.def_path_str(values.found)\n                 )\n             }),\n-            ProjectionBoundsLength(ref values) => write!(\n-                f,\n-                \"expected {} associated type binding{}, found {}\",\n-                values.expected,\n-                pluralize!(values.expected),\n-                values.found\n-            ),\n             ExistentialMismatch(ref values) => report_maybe_different(\n                 f,\n                 &format!(\"trait `{}`\", values.expected),\n@@ -216,7 +208,6 @@ impl<'tcx> TypeError<'tcx> {\n             | RegionsPlaceholderMismatch\n             | Traits(_)\n             | ProjectionMismatched(_)\n-            | ProjectionBoundsLength(_)\n             | ExistentialMismatch(_)\n             | ConstMismatch(_)\n             | IntrinsicCast"}, {"sha": "0e86fcf53b247e0d460ab171e3ab18d45e5f73d5", "filename": "src/librustc_middle/ty/flags.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_middle%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_middle%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fflags.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -88,13 +88,13 @@ impl FlagComputation {\n                 self.add_substs(substs);\n             }\n \n-            &ty::GeneratorWitness(ref ts) => {\n+            &ty::GeneratorWitness(ts) => {\n                 let mut computation = FlagComputation::new();\n-                computation.add_tys(&ts.skip_binder()[..]);\n+                computation.add_tys(ts.skip_binder());\n                 self.add_bound_computation(computation);\n             }\n \n-            &ty::Closure(_, ref substs) => {\n+            &ty::Closure(_, substs) => {\n                 self.add_substs(substs);\n             }\n \n@@ -122,7 +122,7 @@ impl FlagComputation {\n                 self.add_substs(substs);\n             }\n \n-            &ty::Projection(ref data) => {\n+            &ty::Projection(data) => {\n                 self.add_flags(TypeFlags::HAS_TY_PROJECTION);\n                 self.add_projection_ty(data);\n             }\n@@ -211,7 +211,7 @@ impl FlagComputation {\n \n                 self.add_bound_computation(computation);\n             }\n-            ty::PredicateKind::Projection(projection) => {\n+            &ty::PredicateKind::Projection(projection) => {\n                 let mut computation = FlagComputation::new();\n                 let ty::ProjectionPredicate { projection_ty, ty } = projection.skip_binder();\n                 computation.add_projection_ty(projection_ty);\n@@ -298,7 +298,7 @@ impl FlagComputation {\n         self.add_ty(projection.ty);\n     }\n \n-    fn add_projection_ty(&mut self, projection_ty: &ty::ProjectionTy<'_>) {\n+    fn add_projection_ty(&mut self, projection_ty: ty::ProjectionTy<'_>) {\n         self.add_substs(projection_ty.substs);\n     }\n "}, {"sha": "492f8ce9ef1a9d1afd832535d5a91b7a7edf1b35", "filename": "src/librustc_middle/ty/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_middle%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_middle%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ffold.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -336,7 +336,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         {\n             fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> bool {\n                 self.outer_index.shift_in(1);\n-                let result = t.skip_binder().visit_with(self);\n+                let result = t.as_ref().skip_binder().visit_with(self);\n                 self.outer_index.shift_out(1);\n                 result\n             }\n@@ -558,7 +558,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let fld_c = |bound_ct, ty| {\n             self.mk_const(ty::Const { val: ty::ConstKind::Bound(ty::INNERMOST, bound_ct), ty })\n         };\n-        self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t, fld_c)\n+        self.replace_escaping_bound_vars(value.as_ref().skip_binder(), fld_r, fld_t, fld_c)\n     }\n \n     /// Replaces all escaping bound vars. The `fld_r` closure replaces escaping\n@@ -617,7 +617,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         H: FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx>,\n         T: TypeFoldable<'tcx>,\n     {\n-        self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t, fld_c)\n+        self.replace_escaping_bound_vars(value.as_ref().skip_binder(), fld_r, fld_t, fld_c)\n     }\n \n     /// Replaces any late-bound regions bound in `value` with\n@@ -673,7 +673,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         T: TypeFoldable<'tcx>,\n     {\n         let mut collector = LateBoundRegionsCollector::new(just_constraint);\n-        let result = value.skip_binder().visit_with(&mut collector);\n+        let result = value.as_ref().skip_binder().visit_with(&mut collector);\n         assert!(!result); // should never have stopped early\n         collector.regions\n     }"}, {"sha": "39b8566e7a873a0d9f50d27c02084880babe2428", "filename": "src/librustc_middle/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_middle%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_middle%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flayout.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -2303,7 +2303,7 @@ impl<'tcx> ty::Instance<'tcx> {\n \n                 let env_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n                 sig.map_bound(|sig| tcx.mk_fn_sig(\n-                    iter::once(*env_ty.skip_binder()).chain(sig.inputs().iter().cloned()),\n+                    iter::once(env_ty.skip_binder()).chain(sig.inputs().iter().cloned()),\n                     sig.output(),\n                     sig.c_variadic,\n                     sig.unsafety,"}, {"sha": "9fa1260f64d7407e8db9de792e944b409dd56f09", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -189,7 +189,7 @@ pub trait PrettyPrinter<'tcx>:\n     where\n         T: Print<'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>,\n     {\n-        value.skip_binder().print(self)\n+        value.as_ref().skip_binder().print(self)\n     }\n \n     /// Prints comma-separated elements."}, {"sha": "cee04ce8c6a831f62212f0b73c461acacad8af27", "filename": "src/librustc_middle/ty/relate.rs", "status": "modified", "additions": 90, "deletions": 136, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_middle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_middle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Frelate.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -13,7 +13,6 @@ use rustc_hir::def_id::DefId;\n use rustc_span::DUMMY_SP;\n use rustc_target::spec::abi;\n use std::iter;\n-use std::rc::Rc;\n \n pub type RelateResult<'tcx, T> = Result<T, TypeError<'tcx>>;\n \n@@ -42,7 +41,7 @@ pub trait TypeRelation<'tcx>: Sized {\n     }\n \n     /// Generic relation routine suitable for most anything.\n-    fn relate<T: Relate<'tcx>>(&mut self, a: &T, b: &T) -> RelateResult<'tcx, T> {\n+    fn relate<T: Relate<'tcx>>(&mut self, a: T, b: T) -> RelateResult<'tcx, T> {\n         Relate::relate(self, a, b)\n     }\n \n@@ -68,8 +67,8 @@ pub trait TypeRelation<'tcx>: Sized {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T>;\n \n     // Overridable relations. You shouldn't typically call these\n@@ -94,18 +93,18 @@ pub trait TypeRelation<'tcx>: Sized {\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>;\n }\n \n-pub trait Relate<'tcx>: TypeFoldable<'tcx> {\n+pub trait Relate<'tcx>: TypeFoldable<'tcx> + Copy {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &Self,\n-        b: &Self,\n+        a: Self,\n+        b: Self,\n     ) -> RelateResult<'tcx, Self>;\n }\n \n@@ -115,8 +114,8 @@ pub trait Relate<'tcx>: TypeFoldable<'tcx> {\n impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::TypeAndMut<'tcx>,\n-        b: &ty::TypeAndMut<'tcx>,\n+        a: ty::TypeAndMut<'tcx>,\n+        b: ty::TypeAndMut<'tcx>,\n     ) -> RelateResult<'tcx, ty::TypeAndMut<'tcx>> {\n         debug!(\"{}.mts({:?}, {:?})\", relation.tag(), a, b);\n         if a.mutbl != b.mutbl {\n@@ -127,7 +126,7 @@ impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n                 ast::Mutability::Not => ty::Covariant,\n                 ast::Mutability::Mut => ty::Invariant,\n             };\n-            let ty = relation.relate_with_variance(variance, &a.ty, &b.ty)?;\n+            let ty = relation.relate_with_variance(variance, a.ty, b.ty)?;\n             Ok(ty::TypeAndMut { ty, mutbl })\n         }\n     }\n@@ -143,7 +142,7 @@ pub fn relate_substs<R: TypeRelation<'tcx>>(\n \n     let params = a_subst.iter().zip(b_subst).enumerate().map(|(i, (a, b))| {\n         let variance = variances.map_or(ty::Invariant, |v| v[i]);\n-        relation.relate_with_variance(variance, &a, &b)\n+        relation.relate_with_variance(variance, a, b)\n     });\n \n     Ok(tcx.mk_substs(params)?)\n@@ -152,8 +151,8 @@ pub fn relate_substs<R: TypeRelation<'tcx>>(\n impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::FnSig<'tcx>,\n-        b: &ty::FnSig<'tcx>,\n+        a: ty::FnSig<'tcx>,\n+        b: ty::FnSig<'tcx>,\n     ) -> RelateResult<'tcx, ty::FnSig<'tcx>> {\n         let tcx = relation.tcx();\n \n@@ -164,8 +163,8 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n                 &b.c_variadic,\n             )));\n         }\n-        let unsafety = relation.relate(&a.unsafety, &b.unsafety)?;\n-        let abi = relation.relate(&a.abi, &b.abi)?;\n+        let unsafety = relation.relate(a.unsafety, b.unsafety)?;\n+        let abi = relation.relate(a.abi, b.abi)?;\n \n         if a.inputs().len() != b.inputs().len() {\n             return Err(TypeError::ArgCount);\n@@ -180,9 +179,9 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n             .chain(iter::once(((a.output(), b.output()), true)))\n             .map(|((a, b), is_output)| {\n                 if is_output {\n-                    relation.relate(&a, &b)\n+                    relation.relate(a, b)\n                 } else {\n-                    relation.relate_with_variance(ty::Contravariant, &a, &b)\n+                    relation.relate_with_variance(ty::Contravariant, a, b)\n                 }\n             });\n         Ok(ty::FnSig {\n@@ -197,32 +196,32 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n impl<'tcx> Relate<'tcx> for ast::Unsafety {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ast::Unsafety,\n-        b: &ast::Unsafety,\n+        a: ast::Unsafety,\n+        b: ast::Unsafety,\n     ) -> RelateResult<'tcx, ast::Unsafety> {\n         if a != b {\n-            Err(TypeError::UnsafetyMismatch(expected_found(relation, a, b)))\n+            Err(TypeError::UnsafetyMismatch(expected_found(relation, &a, &b)))\n         } else {\n-            Ok(*a)\n+            Ok(a)\n         }\n     }\n }\n \n impl<'tcx> Relate<'tcx> for abi::Abi {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &abi::Abi,\n-        b: &abi::Abi,\n+        a: abi::Abi,\n+        b: abi::Abi,\n     ) -> RelateResult<'tcx, abi::Abi> {\n-        if a == b { Ok(*a) } else { Err(TypeError::AbiMismatch(expected_found(relation, a, b))) }\n+        if a == b { Ok(a) } else { Err(TypeError::AbiMismatch(expected_found(relation, &a, &b))) }\n     }\n }\n \n impl<'tcx> Relate<'tcx> for ty::ProjectionTy<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::ProjectionTy<'tcx>,\n-        b: &ty::ProjectionTy<'tcx>,\n+        a: ty::ProjectionTy<'tcx>,\n+        b: ty::ProjectionTy<'tcx>,\n     ) -> RelateResult<'tcx, ty::ProjectionTy<'tcx>> {\n         if a.item_def_id != b.item_def_id {\n             Err(TypeError::ProjectionMismatched(expected_found(\n@@ -231,7 +230,7 @@ impl<'tcx> Relate<'tcx> for ty::ProjectionTy<'tcx> {\n                 &b.item_def_id,\n             )))\n         } else {\n-            let substs = relation.relate(&a.substs, &b.substs)?;\n+            let substs = relation.relate(a.substs, b.substs)?;\n             Ok(ty::ProjectionTy { item_def_id: a.item_def_id, substs: &substs })\n         }\n     }\n@@ -240,8 +239,8 @@ impl<'tcx> Relate<'tcx> for ty::ProjectionTy<'tcx> {\n impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::ExistentialProjection<'tcx>,\n-        b: &ty::ExistentialProjection<'tcx>,\n+        a: ty::ExistentialProjection<'tcx>,\n+        b: ty::ExistentialProjection<'tcx>,\n     ) -> RelateResult<'tcx, ty::ExistentialProjection<'tcx>> {\n         if a.item_def_id != b.item_def_id {\n             Err(TypeError::ProjectionMismatched(expected_found(\n@@ -250,37 +249,18 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n                 &b.item_def_id,\n             )))\n         } else {\n-            let ty = relation.relate_with_variance(ty::Invariant, &a.ty, &b.ty)?;\n-            let substs = relation.relate_with_variance(ty::Invariant, &a.substs, &b.substs)?;\n+            let ty = relation.relate_with_variance(ty::Invariant, a.ty, b.ty)?;\n+            let substs = relation.relate_with_variance(ty::Invariant, a.substs, b.substs)?;\n             Ok(ty::ExistentialProjection { item_def_id: a.item_def_id, substs, ty })\n         }\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for Vec<ty::PolyExistentialProjection<'tcx>> {\n-    fn relate<R: TypeRelation<'tcx>>(\n-        relation: &mut R,\n-        a: &Vec<ty::PolyExistentialProjection<'tcx>>,\n-        b: &Vec<ty::PolyExistentialProjection<'tcx>>,\n-    ) -> RelateResult<'tcx, Vec<ty::PolyExistentialProjection<'tcx>>> {\n-        // To be compatible, `a` and `b` must be for precisely the\n-        // same set of traits and item names. We always require that\n-        // projection bounds lists are sorted by trait-def-id and item-name,\n-        // so we can just iterate through the lists pairwise, so long as they are the\n-        // same length.\n-        if a.len() != b.len() {\n-            Err(TypeError::ProjectionBoundsLength(expected_found(relation, &a.len(), &b.len())))\n-        } else {\n-            a.iter().zip(b).map(|(a, b)| relation.relate(a, b)).collect()\n-        }\n-    }\n-}\n-\n impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::TraitRef<'tcx>,\n-        b: &ty::TraitRef<'tcx>,\n+        a: ty::TraitRef<'tcx>,\n+        b: ty::TraitRef<'tcx>,\n     ) -> RelateResult<'tcx, ty::TraitRef<'tcx>> {\n         // Different traits cannot be related.\n         if a.def_id != b.def_id {\n@@ -295,8 +275,8 @@ impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::ExistentialTraitRef<'tcx>,\n-        b: &ty::ExistentialTraitRef<'tcx>,\n+        a: ty::ExistentialTraitRef<'tcx>,\n+        b: ty::ExistentialTraitRef<'tcx>,\n     ) -> RelateResult<'tcx, ty::ExistentialTraitRef<'tcx>> {\n         // Different traits cannot be related.\n         if a.def_id != b.def_id {\n@@ -308,27 +288,27 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n     }\n }\n \n-#[derive(Debug, Clone, TypeFoldable)]\n+#[derive(Copy, Debug, Clone, TypeFoldable)]\n struct GeneratorWitness<'tcx>(&'tcx ty::List<Ty<'tcx>>);\n \n impl<'tcx> Relate<'tcx> for GeneratorWitness<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &GeneratorWitness<'tcx>,\n-        b: &GeneratorWitness<'tcx>,\n+        a: GeneratorWitness<'tcx>,\n+        b: GeneratorWitness<'tcx>,\n     ) -> RelateResult<'tcx, GeneratorWitness<'tcx>> {\n         assert_eq!(a.0.len(), b.0.len());\n         let tcx = relation.tcx();\n-        let types = tcx.mk_type_list(a.0.iter().zip(b.0).map(|(a, b)| relation.relate(&a, &b)))?;\n+        let types = tcx.mk_type_list(a.0.iter().zip(b.0).map(|(a, b)| relation.relate(a, b)))?;\n         Ok(GeneratorWitness(types))\n     }\n }\n \n impl<'tcx> Relate<'tcx> for Ty<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &Ty<'tcx>,\n-        b: &Ty<'tcx>,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n     ) -> RelateResult<'tcx, Ty<'tcx>> {\n         relation.tys(a, b)\n     }\n@@ -379,7 +359,7 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n \n         (&ty::Foreign(a_id), &ty::Foreign(b_id)) if a_id == b_id => Ok(tcx.mk_foreign(a_id)),\n \n-        (&ty::Dynamic(ref a_obj, ref a_region), &ty::Dynamic(ref b_obj, ref b_region)) => {\n+        (&ty::Dynamic(a_obj, a_region), &ty::Dynamic(b_obj, b_region)) => {\n             let region_bound = relation.with_cause(Cause::ExistentialRegionBound, |relation| {\n                 relation.relate_with_variance(ty::Contravariant, a_region, b_region)\n             })?;\n@@ -392,7 +372,7 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n             // All Generator types with the same id represent\n             // the (anonymous) type of the same generator expression. So\n             // all of their regions should be equated.\n-            let substs = relation.relate(&a_substs, &b_substs)?;\n+            let substs = relation.relate(a_substs, b_substs)?;\n             Ok(tcx.mk_generator(a_id, substs, movability))\n         }\n \n@@ -402,34 +382,34 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n             let a_types = a_types.map_bound(GeneratorWitness);\n             let b_types = b_types.map_bound(GeneratorWitness);\n             // Then remove the GeneratorWitness for the result\n-            let types = relation.relate(&a_types, &b_types)?.map_bound(|witness| witness.0);\n+            let types = relation.relate(a_types, b_types)?.map_bound(|witness| witness.0);\n             Ok(tcx.mk_generator_witness(types))\n         }\n \n         (&ty::Closure(a_id, a_substs), &ty::Closure(b_id, b_substs)) if a_id == b_id => {\n             // All Closure types with the same id represent\n             // the (anonymous) type of the same closure expression. So\n             // all of their regions should be equated.\n-            let substs = relation.relate(&a_substs, &b_substs)?;\n+            let substs = relation.relate(a_substs, b_substs)?;\n             Ok(tcx.mk_closure(a_id, &substs))\n         }\n \n-        (&ty::RawPtr(ref a_mt), &ty::RawPtr(ref b_mt)) => {\n+        (&ty::RawPtr(a_mt), &ty::RawPtr(b_mt)) => {\n             let mt = relation.relate(a_mt, b_mt)?;\n             Ok(tcx.mk_ptr(mt))\n         }\n \n         (&ty::Ref(a_r, a_ty, a_mutbl), &ty::Ref(b_r, b_ty, b_mutbl)) => {\n-            let r = relation.relate_with_variance(ty::Contravariant, &a_r, &b_r)?;\n+            let r = relation.relate_with_variance(ty::Contravariant, a_r, b_r)?;\n             let a_mt = ty::TypeAndMut { ty: a_ty, mutbl: a_mutbl };\n             let b_mt = ty::TypeAndMut { ty: b_ty, mutbl: b_mutbl };\n-            let mt = relation.relate(&a_mt, &b_mt)?;\n+            let mt = relation.relate(a_mt, b_mt)?;\n             Ok(tcx.mk_ref(r, mt))\n         }\n \n         (&ty::Array(a_t, sz_a), &ty::Array(b_t, sz_b)) => {\n-            let t = relation.relate(&a_t, &b_t)?;\n-            match relation.relate(&sz_a, &sz_b) {\n+            let t = relation.relate(a_t, b_t)?;\n+            match relation.relate(sz_a, sz_b) {\n                 Ok(sz) => Ok(tcx.mk_ty(ty::Array(t, sz))),\n                 // FIXME(#72219) Implement improved diagnostics for mismatched array\n                 // length?\n@@ -450,16 +430,14 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n         }\n \n         (&ty::Slice(a_t), &ty::Slice(b_t)) => {\n-            let t = relation.relate(&a_t, &b_t)?;\n+            let t = relation.relate(a_t, b_t)?;\n             Ok(tcx.mk_slice(t))\n         }\n \n         (&ty::Tuple(as_), &ty::Tuple(bs)) => {\n             if as_.len() == bs.len() {\n                 Ok(tcx.mk_tup(\n-                    as_.iter()\n-                        .zip(bs)\n-                        .map(|(a, b)| relation.relate(&a.expect_ty(), &b.expect_ty())),\n+                    as_.iter().zip(bs).map(|(a, b)| relation.relate(a.expect_ty(), b.expect_ty())),\n                 )?)\n             } else if !(as_.is_empty() || bs.is_empty()) {\n                 Err(TypeError::TupleSize(expected_found(relation, &as_.len(), &bs.len())))\n@@ -476,12 +454,12 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n         }\n \n         (&ty::FnPtr(a_fty), &ty::FnPtr(b_fty)) => {\n-            let fty = relation.relate(&a_fty, &b_fty)?;\n+            let fty = relation.relate(a_fty, b_fty)?;\n             Ok(tcx.mk_fn_ptr(fty))\n         }\n \n         // these two are already handled downstream in case of lazy normalization\n-        (ty::Projection(a_data), ty::Projection(b_data)) => {\n+        (&ty::Projection(a_data), &ty::Projection(b_data)) => {\n             let projection_ty = relation.relate(a_data, b_data)?;\n             Ok(tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs))\n         }\n@@ -603,8 +581,8 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n             ty::ConstKind::Unevaluated(b_def_id, b_substs, b_promoted),\n         ) if a_def_id == b_def_id && a_promoted == b_promoted => {\n             let substs =\n-                relation.relate_with_variance(ty::Variance::Invariant, &a_substs, &b_substs)?;\n-            Ok(ty::ConstKind::Unevaluated(a_def_id, &substs, a_promoted))\n+                relation.relate_with_variance(ty::Variance::Invariant, a_substs, b_substs)?;\n+            Ok(ty::ConstKind::Unevaluated(a_def_id, substs, a_promoted))\n         }\n         _ => Err(TypeError::ConstMismatch(expected_found(relation, &a, &b))),\n     };\n@@ -614,8 +592,8 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &Self,\n-        b: &Self,\n+        a: Self,\n+        b: Self,\n     ) -> RelateResult<'tcx, Self> {\n         let tcx = relation.tcx();\n \n@@ -629,16 +607,16 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n         b_v.sort_by(|a, b| a.stable_cmp(tcx, b));\n         b_v.dedup();\n         if a_v.len() != b_v.len() {\n-            return Err(TypeError::ExistentialMismatch(expected_found(relation, a, b)));\n+            return Err(TypeError::ExistentialMismatch(expected_found(relation, &a, &b)));\n         }\n \n         let v = a_v.into_iter().zip(b_v.into_iter()).map(|(ep_a, ep_b)| {\n             use crate::ty::ExistentialPredicate::*;\n             match (ep_a, ep_b) {\n-                (Trait(ref a), Trait(ref b)) => Ok(Trait(relation.relate(a, b)?)),\n-                (Projection(ref a), Projection(ref b)) => Ok(Projection(relation.relate(a, b)?)),\n-                (AutoTrait(ref a), AutoTrait(ref b)) if a == b => Ok(AutoTrait(*a)),\n-                _ => Err(TypeError::ExistentialMismatch(expected_found(relation, a, b))),\n+                (Trait(a), Trait(b)) => Ok(Trait(relation.relate(a, b)?)),\n+                (Projection(a), Projection(b)) => Ok(Projection(relation.relate(a, b)?)),\n+                (AutoTrait(a), AutoTrait(b)) if a == b => Ok(AutoTrait(a)),\n+                _ => Err(TypeError::ExistentialMismatch(expected_found(relation, &a, &b))),\n             }\n         });\n         Ok(tcx.mk_existential_predicates(v)?)\n@@ -648,8 +626,8 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n impl<'tcx> Relate<'tcx> for ty::ClosureSubsts<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::ClosureSubsts<'tcx>,\n-        b: &ty::ClosureSubsts<'tcx>,\n+        a: ty::ClosureSubsts<'tcx>,\n+        b: ty::ClosureSubsts<'tcx>,\n     ) -> RelateResult<'tcx, ty::ClosureSubsts<'tcx>> {\n         let substs = relate_substs(relation, None, a.substs, b.substs)?;\n         Ok(ty::ClosureSubsts { substs })\n@@ -659,8 +637,8 @@ impl<'tcx> Relate<'tcx> for ty::ClosureSubsts<'tcx> {\n impl<'tcx> Relate<'tcx> for ty::GeneratorSubsts<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::GeneratorSubsts<'tcx>,\n-        b: &ty::GeneratorSubsts<'tcx>,\n+        a: ty::GeneratorSubsts<'tcx>,\n+        b: ty::GeneratorSubsts<'tcx>,\n     ) -> RelateResult<'tcx, ty::GeneratorSubsts<'tcx>> {\n         let substs = relate_substs(relation, None, a.substs, b.substs)?;\n         Ok(ty::GeneratorSubsts { substs })\n@@ -670,8 +648,8 @@ impl<'tcx> Relate<'tcx> for ty::GeneratorSubsts<'tcx> {\n impl<'tcx> Relate<'tcx> for SubstsRef<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &SubstsRef<'tcx>,\n-        b: &SubstsRef<'tcx>,\n+        a: SubstsRef<'tcx>,\n+        b: SubstsRef<'tcx>,\n     ) -> RelateResult<'tcx, SubstsRef<'tcx>> {\n         relate_substs(relation, None, a, b)\n     }\n@@ -680,72 +658,48 @@ impl<'tcx> Relate<'tcx> for SubstsRef<'tcx> {\n impl<'tcx> Relate<'tcx> for ty::Region<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::Region<'tcx>,\n-        b: &ty::Region<'tcx>,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        relation.regions(*a, *b)\n+        relation.regions(a, b)\n     }\n }\n \n impl<'tcx> Relate<'tcx> for &'tcx ty::Const<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &&'tcx ty::Const<'tcx>,\n-        b: &&'tcx ty::Const<'tcx>,\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-        relation.consts(*a, *b)\n+        relation.consts(a, b)\n     }\n }\n \n impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for ty::Binder<T> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>> {\n         relation.binders(a, b)\n     }\n }\n \n-impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for Rc<T> {\n-    fn relate<R: TypeRelation<'tcx>>(\n-        relation: &mut R,\n-        a: &Rc<T>,\n-        b: &Rc<T>,\n-    ) -> RelateResult<'tcx, Rc<T>> {\n-        let a: &T = a;\n-        let b: &T = b;\n-        Ok(Rc::new(relation.relate(a, b)?))\n-    }\n-}\n-\n-impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for Box<T> {\n-    fn relate<R: TypeRelation<'tcx>>(\n-        relation: &mut R,\n-        a: &Box<T>,\n-        b: &Box<T>,\n-    ) -> RelateResult<'tcx, Box<T>> {\n-        let a: &T = a;\n-        let b: &T = b;\n-        Ok(Box::new(relation.relate(a, b)?))\n-    }\n-}\n-\n impl<'tcx> Relate<'tcx> for GenericArg<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &GenericArg<'tcx>,\n-        b: &GenericArg<'tcx>,\n+        a: GenericArg<'tcx>,\n+        b: GenericArg<'tcx>,\n     ) -> RelateResult<'tcx, GenericArg<'tcx>> {\n         match (a.unpack(), b.unpack()) {\n             (GenericArgKind::Lifetime(a_lt), GenericArgKind::Lifetime(b_lt)) => {\n-                Ok(relation.relate(&a_lt, &b_lt)?.into())\n+                Ok(relation.relate(a_lt, b_lt)?.into())\n             }\n             (GenericArgKind::Type(a_ty), GenericArgKind::Type(b_ty)) => {\n-                Ok(relation.relate(&a_ty, &b_ty)?.into())\n+                Ok(relation.relate(a_ty, b_ty)?.into())\n             }\n             (GenericArgKind::Const(a_ct), GenericArgKind::Const(b_ct)) => {\n-                Ok(relation.relate(&a_ct, &b_ct)?.into())\n+                Ok(relation.relate(a_ct, b_ct)?.into())\n             }\n             (GenericArgKind::Lifetime(unpacked), x) => {\n                 bug!(\"impossible case reached: can't relate: {:?} with {:?}\", unpacked, x)\n@@ -763,22 +717,22 @@ impl<'tcx> Relate<'tcx> for GenericArg<'tcx> {\n impl<'tcx> Relate<'tcx> for ty::TraitPredicate<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::TraitPredicate<'tcx>,\n-        b: &ty::TraitPredicate<'tcx>,\n+        a: ty::TraitPredicate<'tcx>,\n+        b: ty::TraitPredicate<'tcx>,\n     ) -> RelateResult<'tcx, ty::TraitPredicate<'tcx>> {\n-        Ok(ty::TraitPredicate { trait_ref: relation.relate(&a.trait_ref, &b.trait_ref)? })\n+        Ok(ty::TraitPredicate { trait_ref: relation.relate(a.trait_ref, b.trait_ref)? })\n     }\n }\n \n impl<'tcx> Relate<'tcx> for ty::ProjectionPredicate<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::ProjectionPredicate<'tcx>,\n-        b: &ty::ProjectionPredicate<'tcx>,\n+        a: ty::ProjectionPredicate<'tcx>,\n+        b: ty::ProjectionPredicate<'tcx>,\n     ) -> RelateResult<'tcx, ty::ProjectionPredicate<'tcx>> {\n         Ok(ty::ProjectionPredicate {\n-            projection_ty: relation.relate(&a.projection_ty, &b.projection_ty)?,\n-            ty: relation.relate(&a.ty, &b.ty)?,\n+            projection_ty: relation.relate(a.projection_ty, b.projection_ty)?,\n+            ty: relation.relate(a.ty, b.ty)?,\n         })\n     }\n }"}, {"sha": "1d3607fe32ffce570cba672a64bcf87ff6b28910", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -514,7 +514,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n     type Lifted = ty::Binder<T::Lifted>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.skip_binder()).map(ty::Binder::bind)\n+        tcx.lift(self.as_ref().skip_binder()).map(ty::Binder::bind)\n     }\n }\n \n@@ -655,7 +655,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             VariadicMismatch(x) => VariadicMismatch(x),\n             CyclicTy(t) => return tcx.lift(&t).map(|t| CyclicTy(t)),\n             ProjectionMismatched(x) => ProjectionMismatched(x),\n-            ProjectionBoundsLength(x) => ProjectionBoundsLength(x),\n             Sorts(ref x) => return tcx.lift(x).map(Sorts),\n             ExistentialMismatch(ref x) => return tcx.lift(x).map(ExistentialMismatch),\n             ConstMismatch(ref x) => return tcx.lift(x).map(ConstMismatch),\n@@ -798,7 +797,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.skip_binder().visit_with(visitor)\n+        self.as_ref().skip_binder().visit_with(visitor)\n     }\n \n     fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {"}, {"sha": "c7683cefd82f6a6541c65bb6a5b6b0eedb00910f", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -615,7 +615,7 @@ impl<'tcx> ExistentialPredicate<'tcx> {\n impl<'tcx> Binder<ExistentialPredicate<'tcx>> {\n     pub fn with_self_ty(&self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> ty::Predicate<'tcx> {\n         use crate::ty::ToPredicate;\n-        match *self.skip_binder() {\n+        match self.skip_binder() {\n             ExistentialPredicate::Trait(tr) => {\n                 Binder(tr).with_self_ty(tcx, self_ty).without_const().to_predicate(tcx)\n             }\n@@ -776,7 +776,7 @@ impl<'tcx> PolyTraitRef<'tcx> {\n \n     pub fn to_poly_trait_predicate(&self) -> ty::PolyTraitPredicate<'tcx> {\n         // Note that we preserve binding levels\n-        Binder(ty::TraitPredicate { trait_ref: *self.skip_binder() })\n+        Binder(ty::TraitPredicate { trait_ref: self.skip_binder() })\n     }\n }\n \n@@ -880,8 +880,8 @@ impl<T> Binder<T> {\n     /// - extracting the `DefId` from a PolyTraitRef;\n     /// - comparing the self type of a PolyTraitRef to see if it is equal to\n     ///   a type parameter `X`, since the type `X` does not reference any regions\n-    pub fn skip_binder(&self) -> &T {\n-        &self.0\n+    pub fn skip_binder(self) -> T {\n+        self.0\n     }\n \n     pub fn as_ref(&self) -> Binder<&T> {\n@@ -916,11 +916,7 @@ impl<T> Binder<T> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        if self.skip_binder().has_escaping_bound_vars() {\n-            None\n-        } else {\n-            Some(self.skip_binder().clone())\n-        }\n+        if self.0.has_escaping_bound_vars() { None } else { Some(self.skip_binder()) }\n     }\n \n     /// Given two things that have the same binder level,\n@@ -997,7 +993,7 @@ impl<'tcx> ProjectionTy<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, TypeFoldable)]\n+#[derive(Copy, Clone, Debug, TypeFoldable)]\n pub struct GenSig<'tcx> {\n     pub resume_ty: Ty<'tcx>,\n     pub yield_ty: Ty<'tcx>,"}, {"sha": "82c649b8f543b88c22794ac1ac0e5909c54ca606", "filename": "src/librustc_middle/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_middle%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_middle%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fwalk.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -133,7 +133,7 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n             ty::Dynamic(obj, lt) => {\n                 stack.push(lt.into());\n                 stack.extend(obj.iter().rev().flat_map(|predicate| {\n-                    let (substs, opt_ty) = match *predicate.skip_binder() {\n+                    let (substs, opt_ty) = match predicate.skip_binder() {\n                         ty::ExistentialPredicate::Trait(tr) => (tr.substs, None),\n                         ty::ExistentialPredicate::Projection(p) => (p.substs, Some(p.ty)),\n                         ty::ExistentialPredicate::AutoTrait(_) =>"}, {"sha": "17846055f6c9615290796c931375e39317239e59", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -1923,7 +1923,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n                 // We use a mix of the HIR and the Ty types to get information\n                 // as the HIR doesn't have full types for closure arguments.\n-                let return_ty = *sig.output().skip_binder();\n+                let return_ty = sig.output().skip_binder();\n                 let mut return_span = fn_decl.output.span();\n                 if let hir::FnRetTy::Return(ty) = &fn_decl.output {\n                     if let hir::TyKind::Rptr(lifetime, _) = ty.kind {\n@@ -1965,7 +1965,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let argument_ty = sig.inputs().skip_binder().first()?;\n \n                 let return_span = fn_decl.output.span();\n-                let return_ty = *sig.output().skip_binder();\n+                let return_ty = sig.output().skip_binder();\n \n                 // We expect the first argument to be a reference.\n                 match argument_ty.kind {"}, {"sha": "91b1a1fbd97059492a75221f2ed13ebe3d9f46d2", "filename": "src/librustc_mir/borrow_check/type_check/relate_tys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Frelate_tys.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -31,7 +31,7 @@ pub(super) fn relate_types<'tcx>(\n         NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n         v,\n     )\n-    .relate(&a, &b)?;\n+    .relate(a, b)?;\n     Ok(())\n }\n "}, {"sha": "e794a6949d2f0eb5af50522f5103c460e51f8846", "filename": "src/librustc_mir/transform/validate.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -74,8 +74,8 @@ pub fn equal_up_to_regions(\n         fn relate_with_variance<T: Relate<'tcx>>(\n             &mut self,\n             _: ty::Variance,\n-            a: &T,\n-            b: &T,\n+            a: T,\n+            b: T,\n         ) -> RelateResult<'tcx, T> {\n             // Ignore variance, require types to be exactly the same.\n             self.relate(a, b)\n@@ -108,8 +108,8 @@ pub fn equal_up_to_regions(\n \n         fn binders<T>(\n             &mut self,\n-            a: &ty::Binder<T>,\n-            b: &ty::Binder<T>,\n+            a: ty::Binder<T>,\n+            b: ty::Binder<T>,\n         ) -> RelateResult<'tcx, ty::Binder<T>>\n         where\n             T: Relate<'tcx>,\n@@ -121,7 +121,7 @@ pub fn equal_up_to_regions(\n \n     // Instantiate and run relation.\n     let mut relator: LifetimeIgnoreRelation<'tcx> = LifetimeIgnoreRelation { tcx: tcx, param_env };\n-    relator.relate(&src, &dest).is_ok()\n+    relator.relate(src, dest).is_ok()\n }\n \n struct TypeChecker<'a, 'tcx> {"}, {"sha": "e4f4885690fd92045d423a777b701c73bffcaba4", "filename": "src/librustc_passes/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_passes%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_passes%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fintrinsicck.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -422,7 +422,7 @@ impl Visitor<'tcx> for ExprVisitor<'tcx> {\n                         let typ = self.tables.node_type(expr.hir_id);\n                         let sig = typ.fn_sig(self.tcx);\n                         let from = sig.inputs().skip_binder()[0];\n-                        let to = *sig.output().skip_binder();\n+                        let to = sig.output().skip_binder();\n                         self.check_transmute(expr.span, from, to);\n                     }\n                 }"}, {"sha": "20f09ef52f00bd741abeeb182ee0f75cc9c2119f", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -92,14 +92,14 @@ where\n         for (predicate, _span) in predicates {\n             match predicate.kind() {\n                 ty::PredicateKind::Trait(poly_predicate, _) => {\n-                    let ty::TraitPredicate { trait_ref } = *poly_predicate.skip_binder();\n+                    let ty::TraitPredicate { trait_ref } = poly_predicate.skip_binder();\n                     if self.visit_trait(trait_ref) {\n                         return true;\n                     }\n                 }\n                 ty::PredicateKind::Projection(poly_predicate) => {\n                     let ty::ProjectionPredicate { projection_ty, ty } =\n-                        *poly_predicate.skip_binder();\n+                        poly_predicate.skip_binder();\n                     if ty.visit_with(self) {\n                         return true;\n                     }\n@@ -108,7 +108,7 @@ where\n                     }\n                 }\n                 ty::PredicateKind::TypeOutlives(poly_predicate) => {\n-                    let ty::OutlivesPredicate(ty, _region) = *poly_predicate.skip_binder();\n+                    let ty::OutlivesPredicate(ty, _region) = poly_predicate.skip_binder();\n                     if ty.visit_with(self) {\n                         return true;\n                     }\n@@ -175,7 +175,7 @@ where\n             ty::Dynamic(predicates, ..) => {\n                 // All traits in the list are considered the \"primary\" part of the type\n                 // and are visited by shallow visitors.\n-                for predicate in *predicates.skip_binder() {\n+                for predicate in predicates.skip_binder() {\n                     let trait_ref = match predicate {\n                         ty::ExistentialPredicate::Trait(trait_ref) => trait_ref,\n                         ty::ExistentialPredicate::Projection(proj) => proj.trait_ref(tcx),\n@@ -1270,7 +1270,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             );\n \n             for (trait_predicate, _, _) in bounds.trait_bounds {\n-                if self.visit_trait(*trait_predicate.skip_binder()) {\n+                if self.visit_trait(trait_predicate.skip_binder()) {\n                     return;\n                 }\n             }"}, {"sha": "ecf27fbf54220a00d1205a3382e73394713b594a", "filename": "src/librustc_symbol_mangling/v0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_symbol_mangling%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_symbol_mangling%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_symbol_mangling%2Fv0.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -219,7 +219,7 @@ impl SymbolMangler<'tcx> {\n         lifetime_depths.end += lifetimes;\n \n         self.binders.push(BinderLevel { lifetime_depths });\n-        self = print_value(self, value.skip_binder())?;\n+        self = print_value(self, value.as_ref().skip_binder())?;\n         self.binders.pop();\n \n         Ok(self)"}, {"sha": "ce478de7c755c64e071ceff53ef6998307d83311", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -691,7 +691,7 @@ where\n     OP: FnMut(ty::Region<'tcx>),\n {\n     fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n-        t.skip_binder().visit_with(self);\n+        t.as_ref().skip_binder().visit_with(self);\n         false // keep visiting\n     }\n "}, {"sha": "49e43873df759d652118a863a2370d36d7286300", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -1569,7 +1569,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     // no need to overload user in such cases\n                     return;\n                 }\n-                let &SubtypePredicate { a_is_expected: _, a, b } = data.skip_binder();\n+                let SubtypePredicate { a_is_expected: _, a, b } = data.skip_binder();\n                 // both must be type variables, or the other would've been instantiated\n                 assert!(a.is_ty_var() && b.is_ty_var());\n                 self.need_type_info_err(body_id, span, a, ErrorCode::E0282)"}, {"sha": "ec51dddc2c8102265469b2fb08cc6b842eafbbf3", "filename": "src/librustc_trait_selection/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -122,7 +122,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     ) -> OnUnimplementedNote {\n         let def_id =\n             self.impl_similar_to(trait_ref, obligation).unwrap_or_else(|| trait_ref.def_id());\n-        let trait_ref = *trait_ref.skip_binder();\n+        let trait_ref = trait_ref.skip_binder();\n \n         let mut flags = vec![];\n         flags.push((\n@@ -219,7 +219,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         }\n         if let ty::Dynamic(traits, _) = self_ty.kind {\n-            for t in *traits.skip_binder() {\n+            for t in traits.skip_binder() {\n                 if let ty::ExistentialPredicate::Trait(trait_ref) = t {\n                     flags.push((sym::_Self, Some(self.tcx.def_path_str(trait_ref.def_id))))\n                 }"}, {"sha": "1fafa9ec035cebb544c3f7e41ec2b3d8ad938724", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -1179,7 +1179,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     ) -> DiagnosticBuilder<'tcx> {\n         crate fn build_fn_sig_string<'tcx>(\n             tcx: TyCtxt<'tcx>,\n-            trait_ref: &ty::TraitRef<'tcx>,\n+            trait_ref: ty::TraitRef<'tcx>,\n         ) -> String {\n             let inputs = trait_ref.substs.type_at(1);\n             let sig = if let ty::Tuple(inputs) = inputs.kind {\n@@ -1360,7 +1360,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         }\n                         ty::GeneratorWitness(..) => {}\n                         _ if generator.is_none() => {\n-                            trait_ref = Some(*derived_obligation.parent_trait_ref.skip_binder());\n+                            trait_ref = Some(derived_obligation.parent_trait_ref.skip_binder());\n                             target_ty = Some(ty);\n                         }\n                         _ => {}"}, {"sha": "91c162872b21572226891f30a46c2ba5d8e9c5e4", "filename": "src/librustc_trait_selection/traits/select/candidate_assembly.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -220,7 +220,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Okay to skip binder because the substs on generator types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters.\n-        let self_ty = *obligation.self_ty().skip_binder();\n+        let self_ty = obligation.self_ty().skip_binder();\n         match self_ty.kind {\n             ty::Generator(..) => {\n                 debug!(\n@@ -299,7 +299,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         // Okay to skip binder because what we are inspecting doesn't involve bound regions.\n-        let self_ty = *obligation.self_ty().skip_binder();\n+        let self_ty = obligation.self_ty().skip_binder();\n         match self_ty.kind {\n             ty::Infer(ty::TyVar(_)) => {\n                 debug!(\"assemble_fn_pointer_candidates: ambiguous self-type\");\n@@ -362,7 +362,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) -> Result<(), SelectionError<'tcx>> {\n         // Okay to skip binder here because the tests we do below do not involve bound regions.\n-        let self_ty = *obligation.self_ty().skip_binder();\n+        let self_ty = obligation.self_ty().skip_binder();\n         debug!(\"assemble_candidates_from_auto_impls(self_ty={:?})\", self_ty);\n \n         let def_id = obligation.predicate.def_id();\n@@ -583,7 +583,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) -> Result<(), SelectionError<'tcx>> {\n         // Okay to skip binder here because the tests we do below do not involve bound regions.\n-        let self_ty = *obligation.self_ty().skip_binder();\n+        let self_ty = obligation.self_ty().skip_binder();\n         debug!(\"assemble_candidates_for_trait_alias(self_ty={:?})\", self_ty);\n \n         let def_id = obligation.predicate.def_id();"}, {"sha": "fa970589bbbf60399b801884cd6ccb94db9572da", "filename": "src/librustc_trait_selection/traits/select/confirmation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -326,7 +326,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // probably flatten the binder from the obligation and the binder\n         // from the object. Have to try to make a broken test case that\n         // results.\n-        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n         let poly_trait_ref = match self_ty.kind {\n             ty::Dynamic(ref data, ..) => data\n                 .principal()\n@@ -379,7 +379,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"confirm_fn_pointer_candidate({:?})\", obligation);\n \n         // Okay to skip binder; it is reintroduced below.\n-        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n         let sig = self_ty.fn_sig(self.tcx());\n         let trait_ref = closure_trait_ref_and_return_type(\n             self.tcx(),\n@@ -448,7 +448,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Okay to skip binder because the substs on generator types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters.\n-        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n         let (generator_def_id, substs) = match self_ty.kind {\n             ty::Generator(id, substs, _) => (id, substs),\n             _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n@@ -497,7 +497,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Okay to skip binder because the substs on closure types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters.\n-        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n         let (closure_def_id, substs) = match self_ty.kind {\n             ty::Closure(id, substs) => (id, substs),\n             _ => bug!(\"closure candidate for non-closure {:?}\", obligation),"}, {"sha": "c41a27c6f431f4e840f8953ef912f5415bb315b8", "filename": "src/librustc_trait_selection/traits/select/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -748,8 +748,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             && stack.iter().skip(1).any(|prev| {\n                 stack.obligation.param_env == prev.obligation.param_env\n                     && self.match_fresh_trait_refs(\n-                        &stack.fresh_trait_ref,\n-                        &prev.fresh_trait_ref,\n+                        stack.fresh_trait_ref,\n+                        prev.fresh_trait_ref,\n                         prev.obligation.param_env,\n                     )\n             })\n@@ -1944,8 +1944,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn match_fresh_trait_refs(\n         &self,\n-        previous: &ty::PolyTraitRef<'tcx>,\n-        current: &ty::PolyTraitRef<'tcx>,\n+        previous: ty::PolyTraitRef<'tcx>,\n+        current: ty::PolyTraitRef<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> bool {\n         let mut matcher = ty::_match::Match::new(self.tcx(), param_env);"}, {"sha": "ebff2dd9b23c1e3e46780d2933bce28348e97524", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -695,7 +695,7 @@ pub fn object_region_bounds<'tcx>(\n     let open_ty = tcx.mk_ty_infer(ty::FreshTy(0));\n \n     let predicates = existential_predicates.iter().filter_map(|predicate| {\n-        if let ty::ExistentialPredicate::Projection(_) = *predicate.skip_binder() {\n+        if let ty::ExistentialPredicate::Projection(_) = predicate.skip_binder() {\n             None\n         } else {\n             Some(predicate.with_self_ty(tcx, open_ty))"}, {"sha": "ed021e5b9de1b8431e4698ce26177e53a6b65e84", "filename": "src/librustc_traits/chalk/lowering.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Flowering.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -615,7 +615,7 @@ crate fn collect_bound_vars<'a, 'tcx, T: TypeFoldable<'tcx>>(\n     ty: &'a Binder<T>,\n ) -> (T, chalk_ir::VariableKinds<RustInterner<'tcx>>, BTreeMap<DefId, u32>) {\n     let mut bound_vars_collector = BoundVarsCollector::new();\n-    ty.skip_binder().visit_with(&mut bound_vars_collector);\n+    ty.as_ref().skip_binder().visit_with(&mut bound_vars_collector);\n     let mut parameters = bound_vars_collector.parameters;\n     let named_parameters: BTreeMap<DefId, u32> = bound_vars_collector\n         .named_parameters\n@@ -625,7 +625,7 @@ crate fn collect_bound_vars<'a, 'tcx, T: TypeFoldable<'tcx>>(\n         .collect();\n \n     let mut bound_var_substitutor = NamedBoundVarSubstitutor::new(tcx, &named_parameters);\n-    let new_ty = ty.skip_binder().fold_with(&mut bound_var_substitutor);\n+    let new_ty = ty.as_ref().skip_binder().fold_with(&mut bound_var_substitutor);\n \n     for var in named_parameters.values() {\n         parameters.insert(*var, chalk_ir::VariableKind::Lifetime);"}, {"sha": "5d1949626dd84e82a24bb0dc482b19993bacf35e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -1802,15 +1802,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         // Calling `skip_binder` is okay because the predicates are re-bound.\n         let regular_trait_predicates = existential_trait_refs\n-            .map(|trait_ref| ty::ExistentialPredicate::Trait(*trait_ref.skip_binder()));\n+            .map(|trait_ref| ty::ExistentialPredicate::Trait(trait_ref.skip_binder()));\n         let auto_trait_predicates = auto_traits\n             .into_iter()\n             .map(|trait_ref| ty::ExistentialPredicate::AutoTrait(trait_ref.trait_ref().def_id()));\n         let mut v = regular_trait_predicates\n             .chain(auto_trait_predicates)\n             .chain(\n                 existential_projections\n-                    .map(|x| ty::ExistentialPredicate::Projection(*x.skip_binder())),\n+                    .map(|x| ty::ExistentialPredicate::Projection(x.skip_binder())),\n             )\n             .collect::<SmallVec<[_; 8]>>();\n         v.sort_by(|a, b| a.stable_cmp(tcx, b));"}, {"sha": "fce2b18b782fb3a0794695f215d2d1d69ae18b45", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -188,7 +188,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             ty::Infer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),\n             ty::FnPtr(sig) => {\n-                let expected_sig = ExpectedSig { cause_span: None, sig: *sig.skip_binder() };\n+                let expected_sig = ExpectedSig { cause_span: None, sig: sig.skip_binder() };\n                 (Some(expected_sig), Some(ty::ClosureKind::Fn))\n             }\n             _ => (None, None),\n@@ -501,7 +501,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             for ((hir_ty, &supplied_ty), expected_ty) in decl\n                 .inputs\n                 .iter()\n-                .zip(*supplied_sig.inputs().skip_binder()) // binder moved to (*) below\n+                .zip(supplied_sig.inputs().skip_binder()) // binder moved to (*) below\n                 .zip(expected_sigs.liberated_sig.inputs())\n             // `liberated_sig` is E'.\n             {"}, {"sha": "e6b3224050e9bc755fd70a299060f86fe99fb834", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -964,7 +964,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let sig = self\n                 .at(cause, self.param_env)\n                 .trace(prev_ty, new_ty)\n-                .lub(&a_sig, &b_sig)\n+                .lub(a_sig, b_sig)\n                 .map(|ok| self.register_infer_ok_obligations(ok))?;\n \n             // Reify both sides and return the reified fn pointer type."}, {"sha": "e6217e0cc1b6eceb45f10a1d9dc44e1f7f4ad115", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -502,7 +502,7 @@ fn compare_self_type<'tcx>(\n             ty::ImplContainer(_) => impl_trait_ref.self_ty(),\n             ty::TraitContainer(_) => tcx.types.self_param,\n         };\n-        let self_arg_ty = *tcx.fn_sig(method.def_id).input(0).skip_binder();\n+        let self_arg_ty = tcx.fn_sig(method.def_id).input(0).skip_binder();\n         let param_env = ty::ParamEnv::reveal_all();\n \n         tcx.infer_ctxt().enter(|infcx| {"}, {"sha": "f6991120f347989da516a95e7cd58c979805d0d6", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -227,10 +227,10 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         let predicate_matches_closure = |p: Predicate<'tcx>| {\n             let mut relator: SimpleEqRelation<'tcx> = SimpleEqRelation::new(tcx, self_param_env);\n             match (predicate.kind(), p.kind()) {\n-                (ty::PredicateKind::Trait(a, _), ty::PredicateKind::Trait(b, _)) => {\n+                (&ty::PredicateKind::Trait(a, _), &ty::PredicateKind::Trait(b, _)) => {\n                     relator.relate(a, b).is_ok()\n                 }\n-                (ty::PredicateKind::Projection(a), ty::PredicateKind::Projection(b)) => {\n+                (&ty::PredicateKind::Projection(a), &ty::PredicateKind::Projection(b)) => {\n                     relator.relate(a, b).is_ok()\n                 }\n                 _ => predicate == p,\n@@ -310,8 +310,8 @@ impl TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         // Here we ignore variance because we require drop impl's types\n         // to be *exactly* the same as to the ones in the struct definition.\n@@ -354,8 +354,8 @@ impl TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,\n@@ -364,8 +364,8 @@ impl TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n \n         // Anonymizing the LBRs is necessary to solve (Issue #59497).\n         // After we do so, it should be totally fine to skip the binders.\n-        let anon_a = self.tcx.anonymize_late_bound_regions(a);\n-        let anon_b = self.tcx.anonymize_late_bound_regions(b);\n+        let anon_a = self.tcx.anonymize_late_bound_regions(&a);\n+        let anon_b = self.tcx.anonymize_late_bound_regions(&b);\n         self.relate(anon_a.skip_binder(), anon_b.skip_binder())?;\n \n         Ok(a.clone())"}, {"sha": "b75dac52b93e51eca8a9278758f5c870bee05fc2", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -608,7 +608,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             ty::Adt(def, _) => bound_spans.push((def_span(def.did), msg)),\n                             // Point at the trait object that couldn't satisfy the bound.\n                             ty::Dynamic(preds, _) => {\n-                                for pred in *preds.skip_binder() {\n+                                for pred in preds.skip_binder() {\n                                     match pred {\n                                         ty::ExistentialPredicate::Trait(tr) => {\n                                             bound_spans.push((def_span(tr.def_id), msg.clone()))"}, {"sha": "b617937d6bd542d43324e485e1a843f546de6112", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -2446,7 +2446,7 @@ fn bounds_from_generic_predicates(\n /// Return placeholder code for the given function.\n fn fn_sig_suggestion(\n     tcx: TyCtxt<'_>,\n-    sig: &ty::FnSig<'_>,\n+    sig: ty::FnSig<'_>,\n     ident: Ident,\n     predicates: ty::GenericPredicates<'_>,\n     assoc: &ty::AssocItem,"}, {"sha": "a1e060b97ad2815a6b527ba48b3541910f3f70d9", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -500,7 +500,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return false;\n             }\n             // We're emitting a suggestion, so we can just ignore regions\n-            let fn_sig = *self.tcx.fn_sig(def_id).skip_binder();\n+            let fn_sig = self.tcx.fn_sig(def_id).skip_binder();\n \n             let other_ty = if let FnDef(def_id, _) = other_ty.kind {\n                 if !self.tcx.has_typeck_tables(def_id) {"}, {"sha": "3b203dd222afbbd15e2a737e9071c801449ece6e", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -216,7 +216,7 @@ fn check_object_overlap<'tcx>(\n         let component_def_ids = data.iter().flat_map(|predicate| {\n             match predicate.skip_binder() {\n                 ty::ExistentialPredicate::Trait(tr) => Some(tr.def_id),\n-                ty::ExistentialPredicate::AutoTrait(def_id) => Some(*def_id),\n+                ty::ExistentialPredicate::AutoTrait(def_id) => Some(def_id),\n                 // An associated type projection necessarily comes with\n                 // an additional `Trait` requirement.\n                 ty::ExistentialPredicate::Projection(..) => None,"}, {"sha": "8920203e6af400a46e133816d8ffb3d2f53fcc81", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -2102,11 +2102,11 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n                     .emit();\n             }\n         };\n-        for (input, ty) in decl.inputs.iter().zip(*fty.inputs().skip_binder()) {\n+        for (input, ty) in decl.inputs.iter().zip(fty.inputs().skip_binder()) {\n             check(&input, ty)\n         }\n         if let hir::FnRetTy::Return(ref ty) = decl.output {\n-            check(&ty, *fty.output().skip_binder())\n+            check(&ty, fty.output().skip_binder())\n         }\n     }\n "}, {"sha": "bfe8464347d2986b7982e7f7cd3ac7482ddbac72", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6548614be6e4441c4d129897678c1e01cd7717/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9c6548614be6e4441c4d129897678c1e01cd7717", "patch": "@@ -347,7 +347,7 @@ impl Clean<GenericBound> for (ty::PolyTraitRef<'_>, &[TypeBinding]) {\n \n         GenericBound::TraitBound(\n             PolyTrait {\n-                trait_: (*poly_trait_ref.skip_binder(), bounds).clean(cx),\n+                trait_: (poly_trait_ref.skip_binder(), bounds).clean(cx),\n                 generic_params: late_bound_regions,\n             },\n             hir::TraitBoundModifier::None,\n@@ -549,7 +549,7 @@ impl<'tcx> Clean<Option<WherePredicate>> for ty::PolyOutlivesPredicate<Ty<'tcx>,\n \n impl<'tcx> Clean<WherePredicate> for ty::PolyProjectionPredicate<'tcx> {\n     fn clean(&self, cx: &DocContext<'_>) -> WherePredicate {\n-        let ty::ProjectionPredicate { projection_ty, ty } = *self.skip_binder();\n+        let ty::ProjectionPredicate { projection_ty, ty } = self.skip_binder();\n         WherePredicate::EqPredicate { lhs: projection_ty.clean(cx), rhs: ty.clean(cx) }\n     }\n }\n@@ -1177,7 +1177,7 @@ impl Clean<Item> for ty::AssocItem {\n                         ty::ImplContainer(def_id) => cx.tcx.type_of(def_id),\n                         ty::TraitContainer(_) => cx.tcx.types.self_param,\n                     };\n-                    let self_arg_ty = *sig.input(0).skip_binder();\n+                    let self_arg_ty = sig.input(0).skip_binder();\n                     if self_arg_ty == self_ty {\n                         decl.inputs.values[0].type_ = Generic(String::from(\"Self\"));\n                     } else if let ty::Ref(_, ty, _) = self_arg_ty.kind {\n@@ -1679,7 +1679,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                                 if let ty::PredicateKind::Projection(proj) = pred.kind() {\n                                     let proj = proj.skip_binder();\n                                     if proj.projection_ty.trait_ref(cx.tcx)\n-                                        == *trait_ref.skip_binder()\n+                                        == trait_ref.skip_binder()\n                                     {\n                                         Some(TypeBinding {\n                                             name: cx"}]}