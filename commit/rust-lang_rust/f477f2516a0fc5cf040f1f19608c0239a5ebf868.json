{"sha": "f477f2516a0fc5cf040f1f19608c0239a5ebf868", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0NzdmMjUxNmEwZmM1Y2YwNDBmMWYxOTYwOGMwMjM5YTVlYmY4Njg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-06T11:30:24Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-06T11:30:24Z"}, "message": "minor", "tree": {"sha": "1a689bbe05e4bb6af2e1f0ef1eecd2afc5ca9ee0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a689bbe05e4bb6af2e1f0ef1eecd2afc5ca9ee0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f477f2516a0fc5cf040f1f19608c0239a5ebf868", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f477f2516a0fc5cf040f1f19608c0239a5ebf868", "html_url": "https://github.com/rust-lang/rust/commit/f477f2516a0fc5cf040f1f19608c0239a5ebf868", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f477f2516a0fc5cf040f1f19608c0239a5ebf868/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bdb456d17660f3460bbf2c38315568b2f76aaa5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bdb456d17660f3460bbf2c38315568b2f76aaa5", "html_url": "https://github.com/rust-lang/rust/commit/3bdb456d17660f3460bbf2c38315568b2f76aaa5"}], "stats": {"total": 100, "additions": 51, "deletions": 49}, "files": [{"sha": "fe90879b62215f02f7b7596bb516e681cb1a051a", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f477f2516a0fc5cf040f1f19608c0239a5ebf868/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f477f2516a0fc5cf040f1f19608c0239a5ebf868/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=f477f2516a0fc5cf040f1f19608c0239a5ebf868", "patch": "@@ -1,51 +1,51 @@\n-/// This module implements import-resolution/macro expansion algorithm.\n-///\n-/// The result of this module is `CrateDefMap`: a data structure which contains:\n-///\n-///   * a tree of modules for the crate\n-///   * for each module, a set of items visible in the module (directly declared\n-///     or imported)\n-///\n-/// Note that `CrateDefMap` contains fully macro expanded code.\n-///\n-/// Computing `CrateDefMap` can be partitioned into several logically\n-/// independent \"phases\". The phases are mutually recursive though, there's no\n-/// strict ordering.\n-///\n-/// ## Collecting RawItems\n-///\n-///  This happens in the `raw` module, which parses a single source file into a\n-///  set of top-level items. Nested imports are desugared to flat imports in\n-///  this phase. Macro calls are represented as a triple of (Path, Option<Name>,\n-///  TokenTree).\n-///\n-/// ## Collecting Modules\n-///\n-/// This happens in the `collector` module. In this phase, we recursively walk\n-/// tree of modules, collect raw items from submodules, populate module scopes\n-/// with defined items (so, we assign item ids in this phase) and record the set\n-/// of unresolved imports and macros.\n-///\n-/// While we walk tree of modules, we also record macro_rules definitions and\n-/// expand calls to macro_rules defined macros.\n-///\n-/// ## Resolving Imports\n-///\n-/// We maintain a list of currently unresolved imports. On every iteration, we\n-/// try to resolve some imports from this list. If the import is resolved, we\n-/// record it, by adding an item to current module scope and, if necessary, by\n-/// recursively populating glob imports.\n-///\n-/// ## Resolving Macros\n-///\n-/// macro_rules from the same crate use a global mutable namespace. We expand\n-/// them immediately, when we collect modules.\n-///\n-/// Macros from other crates (including proc-macros) can be used with\n-/// `foo::bar!` syntax. We handle them similarly to imports. There's a list of\n-/// unexpanded macros. On every iteration, we try to resolve each macro call\n-/// path and, upon success, we run macro expansion and \"collect module\" phase\n-/// on the result\n+//! This module implements import-resolution/macro expansion algorithm.\n+//!\n+//! The result of this module is `CrateDefMap`: a data structure which contains:\n+//!\n+//!   * a tree of modules for the crate\n+//!   * for each module, a set of items visible in the module (directly declared\n+//!     or imported)\n+//!\n+//! Note that `CrateDefMap` contains fully macro expanded code.\n+//!\n+//! Computing `CrateDefMap` can be partitioned into several logically\n+//! independent \"phases\". The phases are mutually recursive though, there's no\n+//! strict ordering.\n+//!\n+//! ## Collecting RawItems\n+//!\n+//!  This happens in the `raw` module, which parses a single source file into a\n+//!  set of top-level items. Nested imports are desugared to flat imports in\n+//!  this phase. Macro calls are represented as a triple of (Path, Option<Name>,\n+//!  TokenTree).\n+//!\n+//! ## Collecting Modules\n+//!\n+//! This happens in the `collector` module. In this phase, we recursively walk\n+//! tree of modules, collect raw items from submodules, populate module scopes\n+//! with defined items (so, we assign item ids in this phase) and record the set\n+//! of unresolved imports and macros.\n+//!\n+//! While we walk tree of modules, we also record macro_rules definitions and\n+//! expand calls to macro_rules defined macros.\n+//!\n+//! ## Resolving Imports\n+//!\n+//! We maintain a list of currently unresolved imports. On every iteration, we\n+//! try to resolve some imports from this list. If the import is resolved, we\n+//! record it, by adding an item to current module scope and, if necessary, by\n+//! recursively populating glob imports.\n+//!\n+//! ## Resolving Macros\n+//!\n+//! macro_rules from the same crate use a global mutable namespace. We expand\n+//! them immediately, when we collect modules.\n+//!\n+//! Macros from other crates (including proc-macros) can be used with\n+//! `foo::bar!` syntax. We handle them similarly to imports. There's a list of\n+//! unexpanded macros. On every iteration, we try to resolve each macro call\n+//! path and, upon success, we run macro expansion and \"collect module\" phase\n+//! on the result\n \n mod per_ns;\n mod raw;"}, {"sha": "c6be93dcd0c355b06f57c5e656f4c3354f787e56", "filename": "crates/ra_hir/src/nameres/mod_resolution.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f477f2516a0fc5cf040f1f19608c0239a5ebf868/crates%2Fra_hir%2Fsrc%2Fnameres%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f477f2516a0fc5cf040f1f19608c0239a5ebf868/crates%2Fra_hir%2Fsrc%2Fnameres%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fmod_resolution.rs?ref=f477f2516a0fc5cf040f1f19608c0239a5ebf868", "patch": "@@ -1,3 +1,5 @@\n+//! This module resolves `mod foo;` declaration to file.\n+\n use std::{borrow::Cow, sync::Arc};\n \n use ra_db::{FileId, SourceRoot};\n@@ -77,7 +79,7 @@ pub(super) fn resolve_submodule(\n             let path = dir_path.join(file_path.as_ref()).normalize();\n             ResolutionMode::OutOfLine(OutOfLineMode::WithAttributePath(path))\n         }\n-        _ => {\n+        (None, None) => {\n             let is_dir_owner = is_root || mod_name == \"mod\";\n             if is_dir_owner {\n                 let file_mod = dir_path.join(format!(\"{}.rs\", name));"}]}