{"sha": "529fed0c340d4dfdc3ba3ccb0e426fe82c058d99", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyOWZlZDBjMzQwZDRkZmRjM2JhM2NjYjBlNDI2ZmU4MmMwNThkOTk=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2018-02-23T13:30:05Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2018-02-23T13:30:05Z"}, "message": "Add attr module", "tree": {"sha": "d287dccdfd068b2e3dbf54184c1c1042330d0f32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d287dccdfd068b2e3dbf54184c1c1042330d0f32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/529fed0c340d4dfdc3ba3ccb0e426fe82c058d99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/529fed0c340d4dfdc3ba3ccb0e426fe82c058d99", "html_url": "https://github.com/rust-lang/rust/commit/529fed0c340d4dfdc3ba3ccb0e426fe82c058d99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/529fed0c340d4dfdc3ba3ccb0e426fe82c058d99/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc2c7433e249005c0fb70744f999b4d7f2ad17fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc2c7433e249005c0fb70744f999b4d7f2ad17fe", "html_url": "https://github.com/rust-lang/rust/commit/cc2c7433e249005c0fb70744f999b4d7f2ad17fe"}], "stats": {"total": 595, "additions": 307, "deletions": 288}, "files": [{"sha": "75d98a729c6b14b71400079326ab5ce4f500bbb1", "filename": "rustfmt-core/src/attr.rs", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/529fed0c340d4dfdc3ba3ccb0e426fe82c058d99/rustfmt-core%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529fed0c340d4dfdc3ba3ccb0e426fe82c058d99/rustfmt-core%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fattr.rs?ref=529fed0c340d4dfdc3ba3ccb0e426fe82c058d99", "patch": "@@ -0,0 +1,304 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Format attributes and meta items.\n+\n+use config::lists::*;\n+use syntax::ast;\n+\n+use comment::{combine_strs_with_missing_comments, contains_comment, rewrite_doc_comment};\n+use expr::rewrite_literal;\n+use lists::{itemize_list, write_list, ListFormatting};\n+use rewrite::{Rewrite, RewriteContext};\n+use shape::Shape;\n+use utils::{count_newlines, mk_sp};\n+\n+use std::cmp;\n+\n+/// Returns attributes on the given statement.\n+pub fn get_attrs_from_stmt(stmt: &ast::Stmt) -> &[ast::Attribute] {\n+    match stmt.node {\n+        ast::StmtKind::Local(ref local) => &local.attrs,\n+        ast::StmtKind::Item(ref item) => &item.attrs,\n+        ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => &expr.attrs,\n+        ast::StmtKind::Mac(ref mac) => &mac.2,\n+    }\n+}\n+\n+fn is_derive(attr: &ast::Attribute) -> bool {\n+    attr.check_name(\"derive\")\n+}\n+\n+/// Returns the arguments of `#[derive(...)]`.\n+fn get_derive_args<'a>(context: &'a RewriteContext, attr: &ast::Attribute) -> Option<Vec<&'a str>> {\n+    attr.meta_item_list().map(|meta_item_list| {\n+        meta_item_list\n+            .iter()\n+            .map(|nested_meta_item| context.snippet(nested_meta_item.span))\n+            .collect()\n+    })\n+}\n+\n+// Format `#[derive(..)]`, using visual indent & mixed style when we need to go multiline.\n+fn format_derive(context: &RewriteContext, derive_args: &[&str], shape: Shape) -> Option<String> {\n+    let mut result = String::with_capacity(128);\n+    result.push_str(\"#[derive(\");\n+    // 11 = `#[derive()]`\n+    let initial_budget = shape.width.checked_sub(11)?;\n+    let mut budget = initial_budget;\n+    let num = derive_args.len();\n+    for (i, a) in derive_args.iter().enumerate() {\n+        // 2 = `, ` or `)]`\n+        let width = a.len() + 2;\n+        if width > budget {\n+            if i > 0 {\n+                // Remove trailing whitespace.\n+                result.pop();\n+            }\n+            result.push('\\n');\n+            // 9 = `#[derive(`\n+            result.push_str(&(shape.indent + 9).to_string(context.config));\n+            budget = initial_budget;\n+        } else {\n+            budget = budget.checked_sub(width).unwrap_or(0);\n+        }\n+        result.push_str(a);\n+        if i != num - 1 {\n+            result.push_str(\", \")\n+        }\n+    }\n+    result.push_str(\")]\");\n+    Some(result)\n+}\n+\n+/// Returns the first group of attributes that fills the given predicate.\n+/// We consider two doc comments are in different group if they are separated by normal comments.\n+fn take_while_with_pred<'a, P>(\n+    context: &RewriteContext,\n+    attrs: &'a [ast::Attribute],\n+    pred: P,\n+) -> &'a [ast::Attribute]\n+where\n+    P: Fn(&ast::Attribute) -> bool,\n+{\n+    let mut last_index = 0;\n+    let mut iter = attrs.iter().enumerate().peekable();\n+    while let Some((i, attr)) = iter.next() {\n+        if !pred(attr) {\n+            break;\n+        }\n+        if let Some(&(_, next_attr)) = iter.peek() {\n+            // Extract comments between two attributes.\n+            let span_between_attr = mk_sp(attr.span.hi(), next_attr.span.lo());\n+            let snippet = context.snippet(span_between_attr);\n+            if count_newlines(snippet) >= 2 || snippet.contains('/') {\n+                break;\n+            }\n+        }\n+        last_index = i;\n+    }\n+    if last_index == 0 {\n+        &[]\n+    } else {\n+        &attrs[..last_index + 1]\n+    }\n+}\n+\n+fn rewrite_first_group_attrs(\n+    context: &RewriteContext,\n+    attrs: &[ast::Attribute],\n+    shape: Shape,\n+) -> Option<(usize, String)> {\n+    if attrs.is_empty() {\n+        return Some((0, String::new()));\n+    }\n+    // Rewrite doc comments\n+    let sugared_docs = take_while_with_pred(context, attrs, |a| a.is_sugared_doc);\n+    if !sugared_docs.is_empty() {\n+        let snippet = sugared_docs\n+            .iter()\n+            .map(|a| context.snippet(a.span))\n+            .collect::<Vec<_>>()\n+            .join(\"\\n\");\n+        return Some((\n+            sugared_docs.len(),\n+            rewrite_doc_comment(&snippet, shape, context.config)?,\n+        ));\n+    }\n+    // Rewrite `#[derive(..)]`s.\n+    if context.config.merge_derives() {\n+        let derives = take_while_with_pred(context, attrs, is_derive);\n+        if !derives.is_empty() {\n+            let mut derive_args = vec![];\n+            for derive in derives {\n+                derive_args.append(&mut get_derive_args(context, derive)?);\n+            }\n+            return Some((derives.len(), format_derive(context, &derive_args, shape)?));\n+        }\n+    }\n+    // Rewrite the first attribute.\n+    Some((1, attrs[0].rewrite(context, shape)?))\n+}\n+\n+impl Rewrite for ast::NestedMetaItem {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        match self.node {\n+            ast::NestedMetaItemKind::MetaItem(ref meta_item) => meta_item.rewrite(context, shape),\n+            ast::NestedMetaItemKind::Literal(ref l) => rewrite_literal(context, l, shape),\n+        }\n+    }\n+}\n+\n+fn has_newlines_before_after_comment(comment: &str) -> (&str, &str) {\n+    // Look at before and after comment and see if there are any empty lines.\n+    let comment_begin = comment.chars().position(|c| c == '/');\n+    let len = comment_begin.unwrap_or_else(|| comment.len());\n+    let mlb = count_newlines(&comment[..len]) > 1;\n+    let mla = if comment_begin.is_none() {\n+        mlb\n+    } else {\n+        let comment_end = comment.chars().rev().position(|c| !c.is_whitespace());\n+        let len = comment_end.unwrap();\n+        comment\n+            .chars()\n+            .rev()\n+            .take(len)\n+            .filter(|c| *c == '\\n')\n+            .count() > 1\n+    };\n+    (if mlb { \"\\n\" } else { \"\" }, if mla { \"\\n\" } else { \"\" })\n+}\n+\n+impl Rewrite for ast::MetaItem {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        Some(match self.node {\n+            ast::MetaItemKind::Word => String::from(&*self.name.as_str()),\n+            ast::MetaItemKind::List(ref list) => {\n+                let name = self.name.as_str();\n+                // 1 = `(`, 2 = `]` and `)`\n+                let item_shape = shape\n+                    .visual_indent(0)\n+                    .shrink_left(name.len() + 1)\n+                    .and_then(|s| s.sub_width(2))?;\n+                let items = itemize_list(\n+                    context.snippet_provider,\n+                    list.iter(),\n+                    \")\",\n+                    \",\",\n+                    |nested_meta_item| nested_meta_item.span.lo(),\n+                    |nested_meta_item| nested_meta_item.span.hi(),\n+                    |nested_meta_item| nested_meta_item.rewrite(context, item_shape),\n+                    self.span.lo(),\n+                    self.span.hi(),\n+                    false,\n+                );\n+                let item_vec = items.collect::<Vec<_>>();\n+                let fmt = ListFormatting {\n+                    tactic: DefinitiveListTactic::Mixed,\n+                    separator: \",\",\n+                    trailing_separator: SeparatorTactic::Never,\n+                    separator_place: SeparatorPlace::Back,\n+                    shape: item_shape,\n+                    ends_with_newline: false,\n+                    preserve_newline: false,\n+                    config: context.config,\n+                };\n+                format!(\"{}({})\", name, write_list(&item_vec, &fmt)?)\n+            }\n+            ast::MetaItemKind::NameValue(ref literal) => {\n+                let name = self.name.as_str();\n+                // 3 = ` = `\n+                let lit_shape = shape.shrink_left(name.len() + 3)?;\n+                let value = rewrite_literal(context, literal, lit_shape)?;\n+                format!(\"{} = {}\", name, value)\n+            }\n+        })\n+    }\n+}\n+\n+impl Rewrite for ast::Attribute {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        let prefix = match self.style {\n+            ast::AttrStyle::Inner => \"#!\",\n+            ast::AttrStyle::Outer => \"#\",\n+        };\n+        let snippet = context.snippet(self.span);\n+        if self.is_sugared_doc {\n+            let doc_shape = Shape {\n+                width: cmp::min(shape.width, context.config.comment_width())\n+                    .checked_sub(shape.indent.width())\n+                    .unwrap_or(0),\n+                ..shape\n+            };\n+            rewrite_doc_comment(snippet, doc_shape, context.config)\n+        } else {\n+            if contains_comment(snippet) {\n+                return Some(snippet.to_owned());\n+            }\n+            // 1 = `[`\n+            let shape = shape.offset_left(prefix.len() + 1)?;\n+            Some(\n+                self.meta()\n+                    .and_then(|meta| meta.rewrite(context, shape))\n+                    .map_or_else(|| snippet.to_owned(), |rw| format!(\"{}[{}]\", prefix, rw)),\n+            )\n+        }\n+    }\n+}\n+\n+impl<'a> Rewrite for [ast::Attribute] {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        if self.is_empty() {\n+            return Some(String::new());\n+        }\n+        let (first_group_len, first_group_str) = rewrite_first_group_attrs(context, self, shape)?;\n+        if self.len() == 1 || first_group_len == self.len() {\n+            Some(first_group_str)\n+        } else {\n+            let rest_str = self[first_group_len..].rewrite(context, shape)?;\n+            let missing_span = mk_sp(\n+                self[first_group_len - 1].span.hi(),\n+                self[first_group_len].span.lo(),\n+            );\n+            // Preserve an empty line before/after doc comments.\n+            if self[0].is_sugared_doc || self[first_group_len].is_sugared_doc {\n+                let snippet = context.snippet(missing_span);\n+                let (mla, mlb) = has_newlines_before_after_comment(snippet);\n+                let comment = ::comment::recover_missing_comment_in_span(\n+                    missing_span,\n+                    shape.with_max_width(context.config),\n+                    context,\n+                    0,\n+                )?;\n+                let comment = if comment.is_empty() {\n+                    format!(\"\\n{}\", mlb)\n+                } else {\n+                    format!(\"{}{}\\n{}\", mla, comment, mlb)\n+                };\n+                Some(format!(\n+                    \"{}{}{}{}\",\n+                    first_group_str,\n+                    comment,\n+                    shape.indent.to_string(context.config),\n+                    rest_str\n+                ))\n+            } else {\n+                combine_strs_with_missing_comments(\n+                    context,\n+                    &first_group_str,\n+                    &rest_str,\n+                    missing_span,\n+                    shape,\n+                    false,\n+                )\n+            }\n+        }\n+    }\n+}"}, {"sha": "6e9554f68554a008a4263b4a8916f72122348027", "filename": "rustfmt-core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/529fed0c340d4dfdc3ba3ccb0e426fe82c058d99/rustfmt-core%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529fed0c340d4dfdc3ba3ccb0e426fe82c058d99/rustfmt-core%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Flib.rs?ref=529fed0c340d4dfdc3ba3ccb0e426fe82c058d99", "patch": "@@ -53,6 +53,7 @@ pub use config::summary::Summary;\n #[macro_use]\n mod utils;\n \n+mod attr;\n mod chains;\n mod checkstyle;\n mod closures;"}, {"sha": "8a6fb3f169c65ed58040a3fd6098ce113cee6a95", "filename": "rustfmt-core/src/visitor.rs", "status": "modified", "additions": 2, "deletions": 288, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/529fed0c340d4dfdc3ba3ccb0e426fe82c058d99/rustfmt-core%2Fsrc%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/529fed0c340d4dfdc3ba3ccb0e426fe82c058d99/rustfmt-core%2Fsrc%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fvisitor.rs?ref=529fed0c340d4dfdc3ba3ccb0e426fe82c058d99", "patch": "@@ -8,23 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cmp;\n-\n-use config::lists::*;\n use syntax::{ast, visit};\n use syntax::attr::HasAttrs;\n use syntax::codemap::{self, BytePos, CodeMap, Pos, Span};\n use syntax::parse::ParseSess;\n \n+use attr::*;\n use codemap::{LineRangeUtils, SpanUtils};\n-use comment::{combine_strs_with_missing_comments, contains_comment, CodeCharKind,\n-              CommentCodeSlices, FindUncommented};\n-use comment::rewrite_doc_comment;\n+use comment::{contains_comment, CodeCharKind, CommentCodeSlices, FindUncommented};\n use config::{BraceStyle, Config};\n-use expr::rewrite_literal;\n use items::{format_impl, format_trait, format_trait_alias, rewrite_associated_impl_type,\n             rewrite_associated_type, rewrite_type_alias, FnSig, StaticParts, StructParts};\n-use lists::{itemize_list, write_list, ListFormatting};\n use macros::{rewrite_macro, rewrite_macro_def, MacroPosition};\n use regex::Regex;\n use rewrite::{Rewrite, RewriteContext};\n@@ -736,277 +730,6 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n     }\n }\n \n-impl Rewrite for ast::NestedMetaItem {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        match self.node {\n-            ast::NestedMetaItemKind::MetaItem(ref meta_item) => meta_item.rewrite(context, shape),\n-            ast::NestedMetaItemKind::Literal(ref l) => rewrite_literal(context, l, shape),\n-        }\n-    }\n-}\n-\n-impl Rewrite for ast::MetaItem {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        Some(match self.node {\n-            ast::MetaItemKind::Word => String::from(&*self.name.as_str()),\n-            ast::MetaItemKind::List(ref list) => {\n-                let name = self.name.as_str();\n-                // 1 = `(`, 2 = `]` and `)`\n-                let item_shape = shape\n-                    .visual_indent(0)\n-                    .shrink_left(name.len() + 1)\n-                    .and_then(|s| s.sub_width(2))?;\n-                let items = itemize_list(\n-                    context.snippet_provider,\n-                    list.iter(),\n-                    \")\",\n-                    \",\",\n-                    |nested_meta_item| nested_meta_item.span.lo(),\n-                    |nested_meta_item| nested_meta_item.span.hi(),\n-                    |nested_meta_item| nested_meta_item.rewrite(context, item_shape),\n-                    self.span.lo(),\n-                    self.span.hi(),\n-                    false,\n-                );\n-                let item_vec = items.collect::<Vec<_>>();\n-                let fmt = ListFormatting {\n-                    tactic: DefinitiveListTactic::Mixed,\n-                    separator: \",\",\n-                    trailing_separator: SeparatorTactic::Never,\n-                    separator_place: SeparatorPlace::Back,\n-                    shape: item_shape,\n-                    ends_with_newline: false,\n-                    preserve_newline: false,\n-                    config: context.config,\n-                };\n-                format!(\"{}({})\", name, write_list(&item_vec, &fmt)?)\n-            }\n-            ast::MetaItemKind::NameValue(ref literal) => {\n-                let name = self.name.as_str();\n-                // 3 = ` = `\n-                let lit_shape = shape.shrink_left(name.len() + 3)?;\n-                let value = rewrite_literal(context, literal, lit_shape)?;\n-                format!(\"{} = {}\", name, value)\n-            }\n-        })\n-    }\n-}\n-\n-impl Rewrite for ast::Attribute {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        let prefix = match self.style {\n-            ast::AttrStyle::Inner => \"#!\",\n-            ast::AttrStyle::Outer => \"#\",\n-        };\n-        let snippet = context.snippet(self.span);\n-        if self.is_sugared_doc {\n-            let doc_shape = Shape {\n-                width: cmp::min(shape.width, context.config.comment_width())\n-                    .checked_sub(shape.indent.width())\n-                    .unwrap_or(0),\n-                ..shape\n-            };\n-            rewrite_doc_comment(snippet, doc_shape, context.config)\n-        } else {\n-            if contains_comment(snippet) {\n-                return Some(snippet.to_owned());\n-            }\n-            // 1 = `[`\n-            let shape = shape.offset_left(prefix.len() + 1)?;\n-            Some(\n-                self.meta()\n-                    .and_then(|meta| meta.rewrite(context, shape))\n-                    .map_or_else(|| snippet.to_owned(), |rw| format!(\"{}[{}]\", prefix, rw)),\n-            )\n-        }\n-    }\n-}\n-\n-/// Returns the first group of attributes that fills the given predicate.\n-/// We consider two doc comments are in different group if they are separated by normal comments.\n-fn take_while_with_pred<'a, P>(\n-    context: &RewriteContext,\n-    attrs: &'a [ast::Attribute],\n-    pred: P,\n-) -> &'a [ast::Attribute]\n-where\n-    P: Fn(&ast::Attribute) -> bool,\n-{\n-    let mut last_index = 0;\n-    let mut iter = attrs.iter().enumerate().peekable();\n-    while let Some((i, attr)) = iter.next() {\n-        if !pred(attr) {\n-            break;\n-        }\n-        if let Some(&(_, next_attr)) = iter.peek() {\n-            // Extract comments between two attributes.\n-            let span_between_attr = mk_sp(attr.span.hi(), next_attr.span.lo());\n-            let snippet = context.snippet(span_between_attr);\n-            if count_newlines(snippet) >= 2 || snippet.contains('/') {\n-                break;\n-            }\n-        }\n-        last_index = i;\n-    }\n-    if last_index == 0 {\n-        &[]\n-    } else {\n-        &attrs[..last_index + 1]\n-    }\n-}\n-\n-fn rewrite_first_group_attrs(\n-    context: &RewriteContext,\n-    attrs: &[ast::Attribute],\n-    shape: Shape,\n-) -> Option<(usize, String)> {\n-    if attrs.is_empty() {\n-        return Some((0, String::new()));\n-    }\n-    // Rewrite doc comments\n-    let sugared_docs = take_while_with_pred(context, attrs, |a| a.is_sugared_doc);\n-    if !sugared_docs.is_empty() {\n-        let snippet = sugared_docs\n-            .iter()\n-            .map(|a| context.snippet(a.span))\n-            .collect::<Vec<_>>()\n-            .join(\"\\n\");\n-        return Some((\n-            sugared_docs.len(),\n-            rewrite_doc_comment(&snippet, shape, context.config)?,\n-        ));\n-    }\n-    // Rewrite `#[derive(..)]`s.\n-    if context.config.merge_derives() {\n-        let derives = take_while_with_pred(context, attrs, is_derive);\n-        if !derives.is_empty() {\n-            let mut derive_args = vec![];\n-            for derive in derives {\n-                derive_args.append(&mut get_derive_args(context, derive)?);\n-            }\n-            return Some((derives.len(), format_derive(context, &derive_args, shape)?));\n-        }\n-    }\n-    // Rewrite the first attribute.\n-    Some((1, attrs[0].rewrite(context, shape)?))\n-}\n-\n-fn has_newlines_before_after_comment(comment: &str) -> (&str, &str) {\n-    // Look at before and after comment and see if there are any empty lines.\n-    let comment_begin = comment.chars().position(|c| c == '/');\n-    let len = comment_begin.unwrap_or_else(|| comment.len());\n-    let mlb = count_newlines(&comment[..len]) > 1;\n-    let mla = if comment_begin.is_none() {\n-        mlb\n-    } else {\n-        let comment_end = comment.chars().rev().position(|c| !c.is_whitespace());\n-        let len = comment_end.unwrap();\n-        comment\n-            .chars()\n-            .rev()\n-            .take(len)\n-            .filter(|c| *c == '\\n')\n-            .count() > 1\n-    };\n-    (if mlb { \"\\n\" } else { \"\" }, if mla { \"\\n\" } else { \"\" })\n-}\n-\n-impl<'a> Rewrite for [ast::Attribute] {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        if self.is_empty() {\n-            return Some(String::new());\n-        }\n-        let (first_group_len, first_group_str) = rewrite_first_group_attrs(context, self, shape)?;\n-        if self.len() == 1 || first_group_len == self.len() {\n-            Some(first_group_str)\n-        } else {\n-            let rest_str = self[first_group_len..].rewrite(context, shape)?;\n-            let missing_span = mk_sp(\n-                self[first_group_len - 1].span.hi(),\n-                self[first_group_len].span.lo(),\n-            );\n-            // Preserve an empty line before/after doc comments.\n-            if self[0].is_sugared_doc || self[first_group_len].is_sugared_doc {\n-                let snippet = context.snippet(missing_span);\n-                let (mla, mlb) = has_newlines_before_after_comment(snippet);\n-                let comment = ::comment::recover_missing_comment_in_span(\n-                    missing_span,\n-                    shape.with_max_width(context.config),\n-                    context,\n-                    0,\n-                )?;\n-                let comment = if comment.is_empty() {\n-                    format!(\"\\n{}\", mlb)\n-                } else {\n-                    format!(\"{}{}\\n{}\", mla, comment, mlb)\n-                };\n-                Some(format!(\n-                    \"{}{}{}{}\",\n-                    first_group_str,\n-                    comment,\n-                    shape.indent.to_string(context.config),\n-                    rest_str\n-                ))\n-            } else {\n-                combine_strs_with_missing_comments(\n-                    context,\n-                    &first_group_str,\n-                    &rest_str,\n-                    missing_span,\n-                    shape,\n-                    false,\n-                )\n-            }\n-        }\n-    }\n-}\n-\n-// Format `#[derive(..)]`, using visual indent & mixed style when we need to go multiline.\n-fn format_derive(context: &RewriteContext, derive_args: &[&str], shape: Shape) -> Option<String> {\n-    let mut result = String::with_capacity(128);\n-    result.push_str(\"#[derive(\");\n-    // 11 = `#[derive()]`\n-    let initial_budget = shape.width.checked_sub(11)?;\n-    let mut budget = initial_budget;\n-    let num = derive_args.len();\n-    for (i, a) in derive_args.iter().enumerate() {\n-        // 2 = `, ` or `)]`\n-        let width = a.len() + 2;\n-        if width > budget {\n-            if i > 0 {\n-                // Remove trailing whitespace.\n-                result.pop();\n-            }\n-            result.push('\\n');\n-            // 9 = `#[derive(`\n-            result.push_str(&(shape.indent + 9).to_string(context.config));\n-            budget = initial_budget;\n-        } else {\n-            budget = budget.checked_sub(width).unwrap_or(0);\n-        }\n-        result.push_str(a);\n-        if i != num - 1 {\n-            result.push_str(\", \")\n-        }\n-    }\n-    result.push_str(\")]\");\n-    Some(result)\n-}\n-\n-fn is_derive(attr: &ast::Attribute) -> bool {\n-    attr.check_name(\"derive\")\n-}\n-\n-/// Returns the arguments of `#[derive(...)]`.\n-fn get_derive_args<'a>(context: &'a RewriteContext, attr: &ast::Attribute) -> Option<Vec<&'a str>> {\n-    attr.meta_item_list().map(|meta_item_list| {\n-        meta_item_list\n-            .iter()\n-            .map(|nested_meta_item| context.snippet(nested_meta_item.span))\n-            .collect()\n-    })\n-}\n-\n // Rewrite `extern crate foo;` WITHOUT attributes.\n pub fn rewrite_extern_crate(context: &RewriteContext, item: &ast::Item) -> Option<String> {\n     assert!(is_extern_crate(item));\n@@ -1018,12 +741,3 @@ pub fn rewrite_extern_crate(context: &RewriteContext, item: &ast::Item) -> Optio\n         String::from(&*Regex::new(r\"\\s;\").unwrap().replace(no_whitespace, \";\"))\n     })\n }\n-\n-fn get_attrs_from_stmt(stmt: &ast::Stmt) -> &[ast::Attribute] {\n-    match stmt.node {\n-        ast::StmtKind::Local(ref local) => &local.attrs,\n-        ast::StmtKind::Item(ref item) => &item.attrs,\n-        ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => &expr.attrs,\n-        ast::StmtKind::Mac(ref mac) => &mac.2,\n-    }\n-}"}]}