{"sha": "6b5d90972ae2f288ae7cf57e209c0d5d8c7a1fd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiNWQ5MDk3MmFlMmYyODhhZTdjZjU3ZTIwOWMwZDVkOGM3YTFmZDI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-17T16:46:55Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-17T16:46:55Z"}, "message": "move roots to a module", "tree": {"sha": "c66df5d10770cf111be8a61094c2f70e5fe8b768", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c66df5d10770cf111be8a61094c2f70e5fe8b768"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b5d90972ae2f288ae7cf57e209c0d5d8c7a1fd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b5d90972ae2f288ae7cf57e209c0d5d8c7a1fd2", "html_url": "https://github.com/rust-lang/rust/commit/6b5d90972ae2f288ae7cf57e209c0d5d8c7a1fd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b5d90972ae2f288ae7cf57e209c0d5d8c7a1fd2/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f937d11ad892036fa93b25a2c19d10dcebe4ab24", "url": "https://api.github.com/repos/rust-lang/rust/commits/f937d11ad892036fa93b25a2c19d10dcebe4ab24", "html_url": "https://github.com/rust-lang/rust/commit/f937d11ad892036fa93b25a2c19d10dcebe4ab24"}], "stats": {"total": 210, "additions": 112, "deletions": 98}, "files": [{"sha": "a740e82efe596166f5d745959d833c2636e8f0c8", "filename": "crates/ra_vfs/src/lib.rs", "status": "modified", "additions": 10, "deletions": 98, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/6b5d90972ae2f288ae7cf57e209c0d5d8c7a1fd2/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b5d90972ae2f288ae7cf57e209c0d5d8c7a1fd2/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=6b5d90972ae2f288ae7cf57e209c0d5d8c7a1fd2", "patch": "@@ -15,117 +15,29 @@\n //! VFS is based on a concept of roots: a set of directories on the file system\n //! which are watched for changes. Typically, there will be a root for each\n //! Cargo package.\n+mod roots;\n mod io;\n \n use std::{\n-    cmp::Reverse,\n     fmt, fs, mem,\n     path::{Path, PathBuf},\n     sync::Arc,\n };\n \n use crossbeam_channel::Receiver;\n use ra_arena::{impl_arena_id, Arena, RawId, map::ArenaMap};\n-use relative_path::{Component, RelativePath, RelativePathBuf};\n+use relative_path::{RelativePath, RelativePathBuf};\n use rustc_hash::{FxHashMap, FxHashSet};\n \n-pub use crate::io::TaskResult as VfsTask;\n-use io::{TaskResult, Worker};\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct VfsRoot(pub RawId);\n-impl_arena_id!(VfsRoot);\n-\n-/// Describes the contents of a single source root.\n-///\n-/// `RootConfig` can be thought of as a glob pattern like `src/**.rs` which\n-/// specifies the source root or as a function which takes a `PathBuf` and\n-/// returns `true` iff path belongs to the source root\n-pub(crate) struct RootConfig {\n-    root: PathBuf,\n-    // result of `root.canonicalize()` if that differs from `root`; `None` otherwise.\n-    canonical_root: Option<PathBuf>,\n-    excluded_dirs: Vec<PathBuf>,\n-}\n-\n-pub(crate) struct Roots {\n-    roots: Arena<VfsRoot, Arc<RootConfig>>,\n-}\n-\n-impl std::ops::Deref for Roots {\n-    type Target = Arena<VfsRoot, Arc<RootConfig>>;\n-    fn deref(&self) -> &Self::Target {\n-        &self.roots\n-    }\n-}\n-\n-impl RootConfig {\n-    fn new(root: PathBuf, excluded_dirs: Vec<PathBuf>) -> RootConfig {\n-        let mut canonical_root = root.canonicalize().ok();\n-        if Some(&root) == canonical_root.as_ref() {\n-            canonical_root = None;\n-        }\n-        RootConfig { root, canonical_root, excluded_dirs }\n-    }\n-    /// Checks if root contains a path and returns a root-relative path.\n-    pub(crate) fn contains(&self, path: &Path) -> Option<RelativePathBuf> {\n-        // First, check excluded dirs\n-        if self.excluded_dirs.iter().any(|it| path.starts_with(it)) {\n-            return None;\n-        }\n-        let rel_path = path\n-            .strip_prefix(&self.root)\n-            .or_else(|err_payload| {\n-                self.canonical_root\n-                    .as_ref()\n-                    .map_or(Err(err_payload), |canonical_root| path.strip_prefix(canonical_root))\n-            })\n-            .ok()?;\n-        let rel_path = RelativePathBuf::from_path(rel_path).ok()?;\n-\n-        // Ignore some common directories.\n-        //\n-        // FIXME: don't hard-code, specify at source-root creation time using\n-        // gitignore\n-        for (i, c) in rel_path.components().enumerate() {\n-            if let Component::Normal(c) = c {\n-                if (i == 0 && c == \"target\") || c == \".git\" || c == \"node_modules\" {\n-                    return None;\n-                }\n-            }\n-        }\n-\n-        if path.is_file() && rel_path.extension() != Some(\"rs\") {\n-            return None;\n-        }\n-\n-        Some(rel_path)\n-    }\n-}\n+use crate::{\n+    io::{TaskResult, Worker},\n+    roots::{RootConfig, Roots},\n+};\n \n-impl Roots {\n-    pub(crate) fn new(mut paths: Vec<PathBuf>) -> Roots {\n-        let mut roots = Arena::default();\n-        // A hack to make nesting work.\n-        paths.sort_by_key(|it| Reverse(it.as_os_str().len()));\n-        paths.dedup();\n-        for (i, path) in paths.iter().enumerate() {\n-            let nested_roots = paths[..i]\n-                .iter()\n-                .filter(|it| it.starts_with(path))\n-                .map(|it| it.clone())\n-                .collect::<Vec<_>>();\n-\n-            let config = Arc::new(RootConfig::new(path.clone(), nested_roots));\n-\n-            roots.alloc(config.clone());\n-        }\n-        Roots { roots }\n-    }\n-    pub(crate) fn find(&self, path: &Path) -> Option<(VfsRoot, RelativePathBuf)> {\n-        self.roots.iter().find_map(|(root, data)| data.contains(path).map(|it| (root, it)))\n-    }\n-}\n+pub use crate::{\n+    io::TaskResult as VfsTask,\n+    roots::VfsRoot,\n+};\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct VfsFile(pub RawId);"}, {"sha": "564e12239c368a8c19952fbf0053c20f14034d2e", "filename": "crates/ra_vfs/src/roots.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/6b5d90972ae2f288ae7cf57e209c0d5d8c7a1fd2/crates%2Fra_vfs%2Fsrc%2Froots.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b5d90972ae2f288ae7cf57e209c0d5d8c7a1fd2/crates%2Fra_vfs%2Fsrc%2Froots.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Froots.rs?ref=6b5d90972ae2f288ae7cf57e209c0d5d8c7a1fd2", "patch": "@@ -0,0 +1,102 @@\n+use std::{\n+    sync::Arc,\n+    path::{Path, PathBuf},\n+};\n+\n+use relative_path::RelativePathBuf;\n+use ra_arena::{impl_arena_id, Arena, RawId};\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct VfsRoot(pub RawId);\n+impl_arena_id!(VfsRoot);\n+\n+/// Describes the contents of a single source root.\n+///\n+/// `RootConfig` can be thought of as a glob pattern like `src/**.rs` which\n+/// specifies the source root or as a function which takes a `PathBuf` and\n+/// returns `true` iff path belongs to the source root\n+pub(crate) struct RootConfig {\n+    pub(crate) root: PathBuf,\n+    // result of `root.canonicalize()` if that differs from `root`; `None` otherwise.\n+    canonical_root: Option<PathBuf>,\n+    excluded_dirs: Vec<PathBuf>,\n+}\n+\n+pub(crate) struct Roots {\n+    roots: Arena<VfsRoot, Arc<RootConfig>>,\n+}\n+\n+impl std::ops::Deref for Roots {\n+    type Target = Arena<VfsRoot, Arc<RootConfig>>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.roots\n+    }\n+}\n+\n+impl RootConfig {\n+    fn new(root: PathBuf, excluded_dirs: Vec<PathBuf>) -> RootConfig {\n+        let mut canonical_root = root.canonicalize().ok();\n+        if Some(&root) == canonical_root.as_ref() {\n+            canonical_root = None;\n+        }\n+        RootConfig { root, canonical_root, excluded_dirs }\n+    }\n+    /// Checks if root contains a path and returns a root-relative path.\n+    pub(crate) fn contains(&self, path: &Path) -> Option<RelativePathBuf> {\n+        // First, check excluded dirs\n+        if self.excluded_dirs.iter().any(|it| path.starts_with(it)) {\n+            return None;\n+        }\n+        let rel_path = path\n+            .strip_prefix(&self.root)\n+            .or_else(|err_payload| {\n+                self.canonical_root\n+                    .as_ref()\n+                    .map_or(Err(err_payload), |canonical_root| path.strip_prefix(canonical_root))\n+            })\n+            .ok()?;\n+        let rel_path = RelativePathBuf::from_path(rel_path).ok()?;\n+\n+        // Ignore some common directories.\n+        //\n+        // FIXME: don't hard-code, specify at source-root creation time using\n+        // gitignore\n+        for (i, c) in rel_path.components().enumerate() {\n+            if let relative_path::Component::Normal(c) = c {\n+                if (i == 0 && c == \"target\") || c == \".git\" || c == \"node_modules\" {\n+                    return None;\n+                }\n+            }\n+        }\n+\n+        if path.is_file() && rel_path.extension() != Some(\"rs\") {\n+            return None;\n+        }\n+\n+        Some(rel_path)\n+    }\n+}\n+\n+impl Roots {\n+    pub(crate) fn new(mut paths: Vec<PathBuf>) -> Roots {\n+        let mut roots = Arena::default();\n+        // A hack to make nesting work.\n+        paths.sort_by_key(|it| std::cmp::Reverse(it.as_os_str().len()));\n+        paths.dedup();\n+        for (i, path) in paths.iter().enumerate() {\n+            let nested_roots = paths[..i]\n+                .iter()\n+                .filter(|it| it.starts_with(path))\n+                .map(|it| it.clone())\n+                .collect::<Vec<_>>();\n+\n+            let config = Arc::new(RootConfig::new(path.clone(), nested_roots));\n+\n+            roots.alloc(config.clone());\n+        }\n+        Roots { roots }\n+    }\n+    pub(crate) fn find(&self, path: &Path) -> Option<(VfsRoot, RelativePathBuf)> {\n+        self.roots.iter().find_map(|(root, data)| data.contains(path).map(|it| (root, it)))\n+    }\n+}"}]}