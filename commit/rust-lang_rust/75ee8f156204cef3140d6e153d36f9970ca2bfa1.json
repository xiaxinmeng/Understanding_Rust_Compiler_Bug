{"sha": "75ee8f156204cef3140d6e153d36f9970ca2bfa1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ZWU4ZjE1NjIwNGNlZjMxNDBkNmUxNTNkMzZmOTk3MGNhMmJmYTE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-08-07T14:28:51Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-08-12T21:58:22Z"}, "message": "Introduce a \"origin/cause\" for new requirements (or bugfixes...) introduced by RFC 1214,\nand issue a warning (and explanatory note) when we encounter such a\nthing.", "tree": {"sha": "6bd154df8cee3efa70a947b8230ef68c52eec19d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bd154df8cee3efa70a947b8230ef68c52eec19d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75ee8f156204cef3140d6e153d36f9970ca2bfa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75ee8f156204cef3140d6e153d36f9970ca2bfa1", "html_url": "https://github.com/rust-lang/rust/commit/75ee8f156204cef3140d6e153d36f9970ca2bfa1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75ee8f156204cef3140d6e153d36f9970ca2bfa1/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39d164d0421a7560ea1e35a2347fda223cd43f6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/39d164d0421a7560ea1e35a2347fda223cd43f6e", "html_url": "https://github.com/rust-lang/rust/commit/39d164d0421a7560ea1e35a2347fda223cd43f6e"}], "stats": {"total": 471, "additions": 339, "deletions": 132}, "files": [{"sha": "44eceb1f213af848ff5106d74230ab7367e7f188", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 59, "deletions": 11, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/75ee8f156204cef3140d6e153d36f9970ca2bfa1/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ee8f156204cef3140d6e153d36f9970ca2bfa1/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=75ee8f156204cef3140d6e153d36f9970ca2bfa1", "patch": "@@ -239,8 +239,7 @@ pub trait ErrorReporting<'tcx> {\n     fn report_generic_bound_failure(&self,\n                                     origin: SubregionOrigin<'tcx>,\n                                     kind: GenericKind<'tcx>,\n-                                    sub: Region,\n-                                    sups: Vec<Region>);\n+                                    sub: Region);\n \n     fn report_sub_sup_conflict(&self,\n                                var_origin: RegionVariableOrigin,\n@@ -292,8 +291,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     self.report_concrete_failure(origin, sub, sup);\n                 }\n \n-                GenericBoundFailure(kind, param_ty, sub, sups) => {\n-                    self.report_generic_bound_failure(kind, param_ty, sub, sups);\n+                GenericBoundFailure(kind, param_ty, sub) => {\n+                    self.report_generic_bound_failure(kind, param_ty, sub);\n                 }\n \n                 SubSupConflict(var_origin,\n@@ -527,14 +526,18 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n     fn report_generic_bound_failure(&self,\n                                     origin: SubregionOrigin<'tcx>,\n                                     bound_kind: GenericKind<'tcx>,\n-                                    sub: Region,\n-                                    _sups: Vec<Region>)\n+                                    sub: Region)\n     {\n         // FIXME: it would be better to report the first error message\n         // with the span of the parameter itself, rather than the span\n         // where the error was detected. But that span is not readily\n         // accessible.\n \n+        let is_warning = match origin {\n+            infer::RFC1214Subregion(_) => true,\n+            _ => false,\n+        };\n+\n         let labeled_user_string = match bound_kind {\n             GenericKind::Param(ref p) =>\n                 format!(\"the parameter type `{}`\", p),\n@@ -545,7 +548,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         match sub {\n             ty::ReFree(ty::FreeRegion {bound_region: ty::BrNamed(..), ..}) => {\n                 // Does the required lifetime have a nice name we can print?\n-                span_err!(self.tcx.sess, origin.span(), E0309,\n+                span_err_or_warn!(\n+                    is_warning, self.tcx.sess, origin.span(), E0309,\n                     \"{} may not live long enough\", labeled_user_string);\n                 self.tcx.sess.fileline_help(\n                     origin.span(),\n@@ -557,7 +561,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n             ty::ReStatic => {\n                 // Does the required lifetime have a nice name we can print?\n-                span_err!(self.tcx.sess, origin.span(), E0310,\n+                span_err_or_warn!(\n+                    is_warning, self.tcx.sess, origin.span(), E0310,\n                     \"{} may not live long enough\", labeled_user_string);\n                 self.tcx.sess.fileline_help(\n                     origin.span(),\n@@ -568,9 +573,10 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n             _ => {\n                 // If not, be less specific.\n-                span_err!(self.tcx.sess, origin.span(), E0311,\n-                        \"{} may not live long enough\",\n-                        labeled_user_string);\n+                span_err_or_warn!(\n+                    is_warning, self.tcx.sess, origin.span(), E0311,\n+                    \"{} may not live long enough\",\n+                    labeled_user_string);\n                 self.tcx.sess.fileline_help(\n                     origin.span(),\n                     &format!(\n@@ -583,6 +589,10 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         }\n \n+        if is_warning {\n+            self.tcx.sess.note_rfc_1214(origin.span());\n+        }\n+\n         self.note_region_origin(&origin);\n     }\n \n@@ -591,6 +601,13 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                sub: Region,\n                                sup: Region) {\n         match origin {\n+            infer::RFC1214Subregion(ref suborigin) => {\n+                // Ideally, this would be a warning, but it doesn't\n+                // seem to come up in practice, since the changes from\n+                // RFC1214 mostly trigger errors in type definitions\n+                // that don't wind up coming down this path.\n+                self.report_concrete_failure((**suborigin).clone(), sub, sup);\n+            }\n             infer::Subtype(trace) => {\n                 let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n                 self.report_and_explain_type_error(trace, &terr);\n@@ -819,6 +836,23 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     sup,\n                     \"\");\n             }\n+            infer::ParameterInScope(_, span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    &format!(\"type/lifetime parameter not in scope here\"));\n+                self.tcx.note_and_explain_region(\n+                    \"the parameter is only valid for \",\n+                    sub,\n+                    \"\");\n+            }\n+            infer::DataBorrowed(ty, span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    &format!(\"a value of type `{}` is borrowed for too long\",\n+                             self.ty_to_string(ty)));\n+                self.tcx.note_and_explain_region(\"the type is valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(\"but the borrow lasts for \", sup, \"\");\n+            }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n                 self.tcx.sess.span_err(\n                     span,\n@@ -1567,6 +1601,9 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn note_region_origin(&self, origin: &SubregionOrigin<'tcx>) {\n         match *origin {\n+            infer::RFC1214Subregion(ref suborigin) => {\n+                self.note_region_origin(suborigin);\n+            }\n             infer::Subtype(ref trace) => {\n                 let desc = match trace.origin {\n                     infer::Misc(_) => {\n@@ -1714,6 +1751,17 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"...so that variable is valid at time of its declaration\");\n             }\n+            infer::ParameterInScope(_, span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    &format!(\"...so that a type/lifetime parameter is in scope here\"));\n+            }\n+            infer::DataBorrowed(ty, span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    &format!(\"...so that the type `{}` is not borrowed for too long\",\n+                             self.ty_to_string(ty)));\n+            }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n                 self.tcx.sess.span_note(\n                     span,"}, {"sha": "da3749979b6010a342fe572e68e0365ab5301fce", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/75ee8f156204cef3140d6e153d36f9970ca2bfa1/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ee8f156204cef3140d6e153d36f9970ca2bfa1/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=75ee8f156204cef3140d6e153d36f9970ca2bfa1", "patch": "@@ -35,6 +35,7 @@ use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n use rustc_data_structures::unify::{self, UnificationTable};\n use std::cell::{RefCell, Ref};\n use std::fmt;\n+use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::{Span, DUMMY_SP};\n@@ -188,6 +189,8 @@ pub struct TypeTrace<'tcx> {\n /// See `error_reporting.rs` for more details\n #[derive(Clone, Debug)]\n pub enum SubregionOrigin<'tcx> {\n+    RFC1214Subregion(Rc<SubregionOrigin<'tcx>>),\n+\n     // Arose from a subtyping relation\n     Subtype(TypeTrace<'tcx>),\n \n@@ -229,9 +232,15 @@ pub enum SubregionOrigin<'tcx> {\n     // Creating a pointer `b` to contents of an upvar\n     ReborrowUpvar(Span, ty::UpvarId),\n \n+    // Data with type `Ty<'tcx>` was borrowed\n+    DataBorrowed(Ty<'tcx>, Span),\n+\n     // (&'a &'b T) where a >= b\n     ReferenceOutlivesReferent(Ty<'tcx>, Span),\n \n+    // Type or region parameters must be in scope.\n+    ParameterInScope(ParameterOrigin, Span),\n+\n     // The type T of an expression E must outlive the lifetime for E.\n     ExprTypeIsNotInScope(Ty<'tcx>, Span),\n \n@@ -260,6 +269,15 @@ pub enum SubregionOrigin<'tcx> {\n     SafeDestructor(Span),\n }\n \n+/// Places that type/region parameters can appear.\n+#[derive(Clone, Copy, Debug)]\n+pub enum ParameterOrigin {\n+    Path, // foo::bar\n+    MethodCall, // foo.bar() <-- parameters on impl providing bar()\n+    OverloadedOperator, // a + b when overloaded\n+    OverloadedDeref, // *a when overloaded\n+}\n+\n /// Times when we replace late-bound regions with variables:\n #[derive(Clone, Copy, Debug)]\n pub enum LateBoundRegionConversionTime {\n@@ -1565,6 +1583,7 @@ impl TypeOrigin {\n impl<'tcx> SubregionOrigin<'tcx> {\n     pub fn span(&self) -> Span {\n         match *self {\n+            RFC1214Subregion(ref a) => a.span(),\n             Subtype(ref a) => a.span(),\n             InfStackClosure(a) => a,\n             InvokeClosure(a) => a,\n@@ -1577,7 +1596,9 @@ impl<'tcx> SubregionOrigin<'tcx> {\n             RelateDefaultParamBound(a, _) => a,\n             Reborrow(a) => a,\n             ReborrowUpvar(a, _) => a,\n+            DataBorrowed(_, a) => a,\n             ReferenceOutlivesReferent(_, a) => a,\n+            ParameterInScope(_, a) => a,\n             ExprTypeIsNotInScope(_, a) => a,\n             BindingTypeIsNotValidAtDecl(a) => a,\n             CallRcvr(a) => a,"}, {"sha": "fb2db5089c9784645002c7b3bd14e964ea2b9f9a", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 192, "deletions": 111, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/75ee8f156204cef3140d6e153d36f9970ca2bfa1/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ee8f156204cef3140d6e153d36f9970ca2bfa1/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=75ee8f156204cef3140d6e153d36f9970ca2bfa1", "patch": "@@ -25,11 +25,12 @@ use super::{\n \n use fmt_macros::{Parser, Piece, Position};\n use middle::infer::InferCtxt;\n-use middle::ty::{self, ToPredicate, HasTypeFlags, ToPolyTraitRef, TraitRef};\n+use middle::ty::{self, ToPredicate, HasTypeFlags, ToPolyTraitRef, TraitRef, Ty};\n use middle::ty_fold::TypeFoldable;\n use std::collections::HashMap;\n use std::fmt;\n use syntax::codemap::Span;\n+use syntax::ast;\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n \n pub fn report_fulfillment_errors<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n@@ -54,22 +55,28 @@ fn report_fulfillment_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     }\n }\n \n+fn is_warning<T>(obligation: &Obligation<T>) -> bool {\n+    obligation.cause.code.is_rfc1214()\n+}\n+\n pub fn report_projection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                          obligation: &PredicateObligation<'tcx>,\n                                          error: &MismatchedProjectionTypes<'tcx>)\n {\n     let predicate =\n         infcx.resolve_type_vars_if_possible(&obligation.predicate);\n+\n     // The TyError created by normalize_to_error can end up being unified\n     // into all obligations: for example, if our obligation is something\n     // like `$X = <() as Foo<$X>>::Out` and () does not implement Foo<_>,\n     // then $X will be unified with TyError, but the error still needs to be\n     // reported.\n     if !infcx.tcx.sess.has_errors() || !predicate.references_error() {\n-        span_err!(infcx.tcx.sess, obligation.cause.span, E0271,\n-                \"type mismatch resolving `{}`: {}\",\n-                predicate,\n-                error.err);\n+        span_err_or_warn!(\n+            is_warning(obligation), infcx.tcx.sess, obligation.cause.span, E0271,\n+            \"type mismatch resolving `{}`: {}\",\n+            predicate,\n+            error.err);\n         note_obligation_cause(infcx, obligation);\n     }\n }\n@@ -173,66 +180,93 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                         obligation: &PredicateObligation<'tcx>,\n                                         error: &SelectionError<'tcx>)\n {\n+    let is_warning = is_warning(obligation);\n     match *error {\n         SelectionError::Unimplemented => {\n-            match &obligation.cause.code {\n-                &ObligationCauseCode::CompareImplMethodObligation => {\n-                    span_err!(infcx.tcx.sess, obligation.cause.span, E0276,\n-                            \"the requirement `{}` appears on the impl \\\n-                            method but not on the corresponding trait method\",\n-                            obligation.predicate);;\n-                }\n-                _ => {\n-                    match obligation.predicate {\n-                        ty::Predicate::Trait(ref trait_predicate) => {\n-                            let trait_predicate =\n-                                infcx.resolve_type_vars_if_possible(trait_predicate);\n-\n-                            if !infcx.tcx.sess.has_errors() ||\n-                               !trait_predicate.references_error() {\n-                                let trait_ref = trait_predicate.to_poly_trait_ref();\n-                                span_err!(infcx.tcx.sess, obligation.cause.span, E0277,\n-                                        \"the trait `{}` is not implemented for the type `{}`\",\n-                                        trait_ref,\n-                                        trait_ref.self_ty());\n-                                // Check if it has a custom \"#[rustc_on_unimplemented]\"\n-                                // error message, report with that message if it does\n-                                let custom_note = report_on_unimplemented(infcx, &trait_ref.0,\n-                                                                          obligation.cause.span);\n-                                if let Some(s) = custom_note {\n-                                    infcx.tcx.sess.span_note(obligation.cause.span,\n-                                                             &s);\n-                                }\n+            if let ObligationCauseCode::CompareImplMethodObligation = obligation.cause.code {\n+                span_err_or_warn!(\n+                    is_warning, infcx.tcx.sess, obligation.cause.span, E0276,\n+                    \"the requirement `{}` appears on the impl \\\n+                     method but not on the corresponding trait method\",\n+                    obligation.predicate);;\n+            } else {\n+                match obligation.predicate {\n+                    ty::Predicate::Trait(ref trait_predicate) => {\n+                        let trait_predicate =\n+                            infcx.resolve_type_vars_if_possible(trait_predicate);\n+\n+                        if !infcx.tcx.sess.has_errors() || !trait_predicate.references_error() {\n+                            let trait_ref = trait_predicate.to_poly_trait_ref();\n+                            span_err_or_warn!(\n+                                is_warning, infcx.tcx.sess, obligation.cause.span, E0277,\n+                                \"the trait `{}` is not implemented for the type `{}`\",\n+                                trait_ref, trait_ref.self_ty());\n+\n+                            // Check if it has a custom \"#[rustc_on_unimplemented]\"\n+                            // error message, report with that message if it does\n+                            let custom_note = report_on_unimplemented(infcx, &trait_ref.0,\n+                                                                      obligation.cause.span);\n+                            if is_warning {\n+                                note_obligation_cause(infcx, obligation);\n+                            } else if let Some(s) = custom_note {\n+                                infcx.tcx.sess.span_note(obligation.cause.span, &s);\n+                            } else {\n+                                note_obligation_cause(infcx, obligation);\n                             }\n                         }\n+                    }\n \n-                        ty::Predicate::Equate(ref predicate) => {\n-                            let predicate = infcx.resolve_type_vars_if_possible(predicate);\n-                            let err = infcx.equality_predicate(obligation.cause.span,\n-                                                               &predicate).err().unwrap();\n-                            span_err!(infcx.tcx.sess, obligation.cause.span, E0278,\n-                                    \"the requirement `{}` is not satisfied (`{}`)\",\n-                                    predicate,\n-                                    err);\n-                        }\n+                    ty::Predicate::Equate(ref predicate) => {\n+                        let predicate = infcx.resolve_type_vars_if_possible(predicate);\n+                        let err = infcx.equality_predicate(obligation.cause.span,\n+                                                           &predicate).err().unwrap();\n+                        span_err_or_warn!(\n+                            is_warning, infcx.tcx.sess, obligation.cause.span, E0278,\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate,\n+                            err);\n+                        note_obligation_cause(infcx, obligation);\n+                    }\n \n-                        ty::Predicate::RegionOutlives(ref predicate) => {\n-                            let predicate = infcx.resolve_type_vars_if_possible(predicate);\n-                            let err = infcx.region_outlives_predicate(obligation.cause.span,\n-                                                                      &predicate).err().unwrap();\n-                            span_err!(infcx.tcx.sess, obligation.cause.span, E0279,\n-                                    \"the requirement `{}` is not satisfied (`{}`)\",\n-                                    predicate,\n-                                    err);\n-                        }\n+                    ty::Predicate::RegionOutlives(ref predicate) => {\n+                        let predicate = infcx.resolve_type_vars_if_possible(predicate);\n+                        let err = infcx.region_outlives_predicate(obligation.cause.span,\n+                                                                  &predicate).err().unwrap();\n+                        span_err_or_warn!(\n+                            is_warning, infcx.tcx.sess, obligation.cause.span, E0279,\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate,\n+                            err);\n+                        note_obligation_cause(infcx, obligation);\n+                    }\n \n-                        ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n-                                let predicate =\n-                                    infcx.resolve_type_vars_if_possible(&obligation.predicate);\n-                                span_err!(infcx.tcx.sess, obligation.cause.span, E0280,\n-                                        \"the requirement `{}` is not satisfied\",\n-                                        predicate);\n-                        }\n+                    ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n+                        let predicate =\n+                            infcx.resolve_type_vars_if_possible(&obligation.predicate);\n+                        span_err_or_warn!(\n+                            is_warning, infcx.tcx.sess, obligation.cause.span, E0280,\n+                            \"the requirement `{}` is not satisfied\",\n+                            predicate);\n+                        note_obligation_cause(infcx, obligation);\n+                    }\n+\n+                    ty::Predicate::ObjectSafe(trait_def_id) => {\n+                        report_object_safety_error(infcx.tcx,\n+                                                   obligation.cause.span,\n+                                                   trait_def_id,\n+                                                   is_warning);\n+                        note_obligation_cause(infcx, obligation);\n+                    }\n+\n+                    ty::Predicate::WellFormed(ty) => {\n+                        // WF predicates cannot themselves make\n+                        // errors. They can only block due to\n+                        // ambiguity; otherwise, they always\n+                        // degenerate into other obligations\n+                        // (which may fail).\n+                        infcx.tcx.sess.span_bug(\n+                            obligation.cause.span,\n+                            &format!(\"WF predicate not satisfied for {:?}\", ty));\n                     }\n                 }\n             }\n@@ -242,62 +276,73 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             let expected_trait_ref = infcx.resolve_type_vars_if_possible(&*expected_trait_ref);\n             let actual_trait_ref = infcx.resolve_type_vars_if_possible(&*actual_trait_ref);\n             if !actual_trait_ref.self_ty().references_error() {\n-                span_err!(infcx.tcx.sess, obligation.cause.span, E0281,\n-                        \"type mismatch: the type `{}` implements the trait `{}`, \\\n-                        but the trait `{}` is required ({})\",\n-                        expected_trait_ref.self_ty(),\n-                        expected_trait_ref,\n-                        actual_trait_ref,\n-                        e);\n-                    note_obligation_cause(infcx, obligation);\n+                span_err_or_warn!(\n+                    is_warning, infcx.tcx.sess, obligation.cause.span, E0281,\n+                    \"type mismatch: the type `{}` implements the trait `{}`, \\\n+                     but the trait `{}` is required ({})\",\n+                    expected_trait_ref.self_ty(),\n+                    expected_trait_ref,\n+                    actual_trait_ref,\n+                    e);\n+                note_obligation_cause(infcx, obligation);\n             }\n         }\n \n         TraitNotObjectSafe(did) => {\n-            span_err!(infcx.tcx.sess, obligation.cause.span, E0038,\n-                \"cannot convert to a trait object because trait `{}` is not object-safe\",\n-                infcx.tcx.item_path_str(did));\n-\n-            for violation in object_safety_violations(infcx.tcx, did) {\n-                match violation {\n-                    ObjectSafetyViolation::SizedSelf => {\n-                        infcx.tcx.sess.span_note(\n-                            obligation.cause.span,\n-                            \"the trait cannot require that `Self : Sized`\");\n-                    }\n+            report_object_safety_error(infcx.tcx, obligation.cause.span, did, is_warning);\n+            note_obligation_cause(infcx, obligation);\n+        }\n+    }\n+}\n \n-                    ObjectSafetyViolation::SupertraitSelf => {\n-                        infcx.tcx.sess.span_note(\n-                            obligation.cause.span,\n-                            \"the trait cannot use `Self` as a type parameter \\\n-                            in the supertrait listing\");\n-                    }\n+pub fn report_object_safety_error<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                        span: Span,\n+                                        trait_def_id: ast::DefId,\n+                                        is_warning: bool)\n+{\n+    span_err_or_warn!(\n+        is_warning, tcx.sess, span, E0038,\n+        \"the trait `{}` cannot be made into an object\",\n+        tcx.item_path_str(trait_def_id));\n \n-                    ObjectSafetyViolation::Method(method,\n-                            MethodViolationCode::StaticMethod) => {\n-                        infcx.tcx.sess.span_note(\n-                            obligation.cause.span,\n-                            &format!(\"method `{}` has no receiver\",\n-                                    method.name));\n-                    }\n+    for violation in object_safety_violations(tcx, trait_def_id) {\n+        match violation {\n+            ObjectSafetyViolation::SizedSelf => {\n+                tcx.sess.span_note(\n+                    span,\n+                    \"the trait cannot require that `Self : Sized`\");\n+            }\n \n-                    ObjectSafetyViolation::Method(method,\n-                            MethodViolationCode::ReferencesSelf) => {\n-                        infcx.tcx.sess.span_note(\n-                            obligation.cause.span,\n-                            &format!(\"method `{}` references the `Self` type \\\n-                                    in its arguments or return type\",\n-                                    method.name));\n-                    }\n+            ObjectSafetyViolation::SupertraitSelf => {\n+                tcx.sess.span_note(\n+                    span,\n+                    \"the trait cannot use `Self` as a type parameter \\\n+                     in the supertrait listing\");\n+            }\n \n-                    ObjectSafetyViolation::Method(method,\n-                            MethodViolationCode::Generic) => {\n-                        infcx.tcx.sess.span_note(\n-                            obligation.cause.span,\n-                            &format!(\"method `{}` has generic type parameters\",\n-                                    method.name));\n-                    }\n-                }\n+            ObjectSafetyViolation::Method(method,\n+                                          MethodViolationCode::StaticMethod) => {\n+                tcx.sess.span_note(\n+                    span,\n+                    &format!(\"method `{}` has no receiver\",\n+                             method.name));\n+            }\n+\n+            ObjectSafetyViolation::Method(method,\n+                                          MethodViolationCode::ReferencesSelf) => {\n+                tcx.sess.span_note(\n+                    span,\n+                    &format!(\"method `{}` references the `Self` type \\\n+                              in its arguments or return type\",\n+                             method.name));\n+            }\n+\n+            ObjectSafetyViolation::Method(method,\n+                                          MethodViolationCode::Generic) => {\n+                tcx.sess.span_note(\n+                    span,\n+                    &format!(\"method `{}` has generic type parameters\",\n+                             method.name));\n             }\n         }\n     }\n@@ -342,14 +387,11 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         infcx.tcx.lang_items.sized_trait()\n                         .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n                     {\n-                        span_err!(infcx.tcx.sess, obligation.cause.span, E0282,\n-                                \"unable to infer enough type information about `{}`; \\\n-                                 type annotations or generic parameter binding required\",\n-                                self_ty);\n+                        need_type_info(infcx, obligation.cause.span, self_ty);\n                     } else {\n                         span_err!(infcx.tcx.sess, obligation.cause.span, E0283,\n                                 \"type annotations required: cannot resolve `{}`\",\n-                                predicate);;\n+                                predicate);\n                         note_obligation_cause(infcx, obligation);\n                     }\n                 }\n@@ -366,6 +408,14 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             }\n         }\n \n+        ty::Predicate::WellFormed(ty) => {\n+            // Same hacky approach as above to avoid deluging user\n+            // with error messages.\n+            if !ty.references_error() && !infcx.tcx.sess.has_errors() {\n+                need_type_info(infcx, obligation.cause.span, ty);\n+            }\n+        }\n+\n         _ => {\n             if !infcx.tcx.sess.has_errors() {\n                 span_err!(infcx.tcx.sess, obligation.cause.span, E0284,\n@@ -377,6 +427,16 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     }\n }\n \n+fn need_type_info<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                            span: Span,\n+                            ty: Ty<'tcx>)\n+{\n+    span_err!(infcx.tcx.sess, span, E0282,\n+              \"unable to infer enough type information about `{}`; \\\n+               type annotations or generic parameter binding required\",\n+              ty);\n+}\n+\n fn note_obligation_cause<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n                                       obligation: &Obligation<'tcx, T>)\n     where T: fmt::Display\n@@ -396,6 +456,27 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n     let tcx = infcx.tcx;\n     match *cause_code {\n         ObligationCauseCode::MiscObligation => { }\n+        ObligationCauseCode::RFC1214(ref subcode) => {\n+            tcx.sess.note_rfc_1214(cause_span);\n+            note_obligation_cause_code(infcx, predicate, cause_span, subcode);\n+        }\n+        ObligationCauseCode::SliceOrArrayElem => {\n+            tcx.sess.span_note(\n+                cause_span,\n+                &format!(\"slice and array elements must have `Sized` type\"));\n+        }\n+        ObligationCauseCode::ProjectionWf(data) => {\n+            tcx.sess.span_note(\n+                cause_span,\n+                &format!(\"required so that the projection `{}` is well-formed\",\n+                         data));\n+        }\n+        ObligationCauseCode::ReferenceOutlivesReferent(ref_ty) => {\n+            tcx.sess.span_note(\n+                cause_span,\n+                &format!(\"required so that reference `{}` does not outlive its referent\",\n+                         ref_ty));\n+        }\n         ObligationCauseCode::ItemObligation(item_def_id) => {\n             let item_name = tcx.item_path_str(item_def_id);\n             tcx.sess.span_note("}, {"sha": "14ab6c505d05cb95bff978333b4eefbf8e26c2c4", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/75ee8f156204cef3140d6e153d36f9970ca2bfa1/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ee8f156204cef3140d6e153d36f9970ca2bfa1/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=75ee8f156204cef3140d6e153d36f9970ca2bfa1", "patch": "@@ -27,6 +27,7 @@ use syntax::codemap::{Span, DUMMY_SP};\n pub use self::error_reporting::report_fulfillment_errors;\n pub use self::error_reporting::report_overflow_error;\n pub use self::error_reporting::report_selection_error;\n+pub use self::error_reporting::report_object_safety_error;\n pub use self::error_reporting::suggest_new_overflow_limit;\n pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n@@ -80,7 +81,7 @@ pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n \n /// Why did we incur this obligation? Used for error reporting.\n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub struct ObligationCause<'tcx> {\n     pub span: Span,\n \n@@ -95,15 +96,27 @@ pub struct ObligationCause<'tcx> {\n     pub code: ObligationCauseCode<'tcx>\n }\n \n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub enum ObligationCauseCode<'tcx> {\n     /// Not well classified or should be obvious from span.\n     MiscObligation,\n \n+    /// Obligation that triggers warning until RFC 1214 is fully in place.\n+    RFC1214(Rc<ObligationCauseCode<'tcx>>),\n+\n+    /// This is the trait reference from the given projection\n+    SliceOrArrayElem,\n+\n+    /// This is the trait reference from the given projection\n+    ProjectionWf(ty::ProjectionTy<'tcx>),\n+\n     /// In an impl of trait X for type Y, type Y must\n     /// also implement all supertraits of X.\n     ItemObligation(ast::DefId),\n \n+    /// A type like `&'a T` is WF only if `T: 'a`.\n+    ReferenceOutlivesReferent(Ty<'tcx>),\n+\n     /// Obligation incurred due to an object cast.\n     ObjectCastObligation(/* Object type */ Ty<'tcx>),\n \n@@ -124,15 +137,14 @@ pub enum ObligationCauseCode<'tcx> {\n     // static items must have `Sync` type\n     SharedStatic,\n \n-\n     BuiltinDerivedObligation(DerivedObligationCause<'tcx>),\n \n     ImplDerivedObligation(DerivedObligationCause<'tcx>),\n \n     CompareImplMethodObligation,\n }\n \n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub struct DerivedObligationCause<'tcx> {\n     /// The trait reference of the parent obligation that led to the\n     /// current obligation. Note that only trait obligations lead to\n@@ -516,6 +528,15 @@ impl<'tcx> ObligationCause<'tcx> {\n     }\n }\n \n+impl<'tcx> ObligationCauseCode<'tcx> {\n+    pub fn is_rfc1214(&self) -> bool {\n+        match *self {\n+            ObligationCauseCode::RFC1214(..) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n impl<'tcx, N> Vtable<'tcx, N> {\n     pub fn nested_obligations(self) -> Vec<N> {\n         match self {"}, {"sha": "713b7394b59a12dca02743339620ffe60b1137c8", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/75ee8f156204cef3140d6e153d36f9970ca2bfa1/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ee8f156204cef3140d6e153d36f9970ca2bfa1/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=75ee8f156204cef3140d6e153d36f9970ca2bfa1", "patch": "@@ -2920,13 +2920,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // chain. Ideally, we should have a way to configure this either\n         // by using -Z verbose or just a CLI argument.\n         if obligation.recursion_depth >= 0 {\n-            let derived_cause = DerivedObligationCause {\n-                parent_trait_ref: obligation.predicate.to_poly_trait_ref(),\n-                parent_code: Rc::new(obligation.cause.code.clone()),\n+            let derived_code = match obligation.cause.code {\n+                ObligationCauseCode::RFC1214(ref base_code) => {\n+                    let derived_cause = DerivedObligationCause {\n+                        parent_trait_ref: obligation.predicate.to_poly_trait_ref(),\n+                        parent_code: base_code.clone(),\n+                    };\n+                    ObligationCauseCode::RFC1214(Rc::new(variant(derived_cause)))\n+                }\n+                _ => {\n+                    let derived_cause = DerivedObligationCause {\n+                        parent_trait_ref: obligation.predicate.to_poly_trait_ref(),\n+                        parent_code: Rc::new(obligation.cause.code.clone())\n+                    };\n+                    variant(derived_cause)\n+                }\n             };\n-            ObligationCause::new(obligation.cause.span,\n-                                 obligation.cause.body_id,\n-                                 variant(derived_cause))\n+            ObligationCause::new(obligation.cause.span, obligation.cause.body_id, derived_code)\n         } else {\n             obligation.cause.clone()\n         }"}, {"sha": "ffb3a8ccb36ba94bf6473ecea1c93a7d883d1378", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/75ee8f156204cef3140d6e153d36f9970ca2bfa1/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ee8f156204cef3140d6e153d36f9970ca2bfa1/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=75ee8f156204cef3140d6e153d36f9970ca2bfa1", "patch": "@@ -90,6 +90,13 @@ impl Session {\n         }\n         self.diagnostic().handler().fatal(msg)\n     }\n+    pub fn span_err_or_warn(&self, is_warning: bool, sp: Span, msg: &str) {\n+        if is_warning {\n+            self.span_warn(sp, msg);\n+        } else {\n+            self.span_err(sp, msg);\n+        }\n+    }\n     pub fn span_err(&self, sp: Span, msg: &str) {\n         if self.opts.treat_err_as_bug {\n             self.span_bug(sp, msg);\n@@ -99,6 +106,13 @@ impl Session {\n             None => self.diagnostic().span_err(sp, msg)\n         }\n     }\n+    pub fn note_rfc_1214(&self, span: Span) {\n+        self.span_note(\n+            span,\n+            &format!(\"this warning results from recent bug fixes and clarifications; \\\n+                      it will become a HARD ERROR in the next release. \\\n+                      See RFC 1214 for details.\"));\n+    }\n     pub fn span_err_with_code(&self, sp: Span, msg: &str, code: &str) {\n         if self.opts.treat_err_as_bug {\n             self.span_bug(sp, msg);"}, {"sha": "3c8347f8a8e0e165b3852e1c52cf95df903188e5", "filename": "src/libsyntax/diagnostics/macros.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/75ee8f156204cef3140d6e153d36f9970ca2bfa1/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ee8f156204cef3140d6e153d36f9970ca2bfa1/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs?ref=75ee8f156204cef3140d6e153d36f9970ca2bfa1", "patch": "@@ -30,6 +30,18 @@ macro_rules! span_err {\n     })\n }\n \n+#[macro_export]\n+macro_rules! span_err_or_warn {\n+    ($is_warning:expr, $session:expr, $span:expr, $code:ident, $($message:tt)*) => ({\n+        __diagnostic_used!($code);\n+        if $is_warning {\n+            $session.span_warn_with_code($span, &format!($($message)*), stringify!($code))\n+        } else {\n+            $session.span_err_with_code($span, &format!($($message)*), stringify!($code))\n+        }\n+    })\n+}\n+\n #[macro_export]\n macro_rules! span_warn {\n     ($session:expr, $span:expr, $code:ident, $($message:tt)*) => ({"}]}