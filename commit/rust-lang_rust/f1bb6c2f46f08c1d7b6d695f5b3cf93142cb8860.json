{"sha": "f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxYmI2YzJmNDZmMDhjMWQ3YjZkNjk1ZjViM2NmOTMxNDJjYjg4NjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-17T05:57:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-17T05:57:55Z"}, "message": "Auto merge of #22397 - Manishearth:rollup, r=huonw\n\nNone", "tree": {"sha": "98ca2711a34754a09d5eedaa32770aed248a7dce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98ca2711a34754a09d5eedaa32770aed248a7dce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "html_url": "https://github.com/rust-lang/rust/commit/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22224ca4499247e99e18fba8a18a4259f0e4d08b", "url": "https://api.github.com/repos/rust-lang/rust/commits/22224ca4499247e99e18fba8a18a4259f0e4d08b", "html_url": "https://github.com/rust-lang/rust/commit/22224ca4499247e99e18fba8a18a4259f0e4d08b"}, {"sha": "35ee89599cb50be74270e6475f4bbe182e769892", "url": "https://api.github.com/repos/rust-lang/rust/commits/35ee89599cb50be74270e6475f4bbe182e769892", "html_url": "https://github.com/rust-lang/rust/commit/35ee89599cb50be74270e6475f4bbe182e769892"}], "stats": {"total": 1615, "additions": 1189, "deletions": 426}, "files": [{"sha": "799871e2bd596601a960782deed9b66efdbc63c5", "filename": "mk/docs.mk", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -129,21 +129,21 @@ doc/:\n HTML_DEPS += doc/rust.css\n doc/rust.css: $(D)/rust.css | doc/\n \t@$(call E, cp: $@)\n-\t$(Q)cp -a $< $@ 2> /dev/null\n+\t$(Q)cp -PRp $< $@ 2> /dev/null\n \n HTML_DEPS += doc/favicon.inc\n doc/favicon.inc: $(D)/favicon.inc | doc/\n \t@$(call E, cp: $@)\n-\t$(Q)cp -a $< $@ 2> /dev/null\n+\t$(Q)cp -PRp $< $@ 2> /dev/null\n \n doc/full-toc.inc: $(D)/full-toc.inc | doc/\n \t@$(call E, cp: $@)\n-\t$(Q)cp -a $< $@ 2> /dev/null\n+\t$(Q)cp -PRp $< $@ 2> /dev/null\n \n HTML_DEPS += doc/footer.inc\n doc/footer.inc: $(D)/footer.inc | doc/\n \t@$(call E, cp: $@)\n-\t$(Q)cp -a $< $@ 2> /dev/null\n+\t$(Q)cp -PRp $< $@ 2> /dev/null\n \n # The (english) documentation for each doc item.\n "}, {"sha": "c5bb6ef81f6dae59dbdd73e62c07fd02791b14b5", "filename": "mk/tests.mk", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -38,23 +38,23 @@ ifdef CHECK_IGNORED\n   TESTARGS += --ignored\n endif\n \n-\n # Arguments to the cfail/rfail/rpass/bench tests\n ifdef CFG_VALGRIND\n   CTEST_RUNTOOL = --runtool \"$(CFG_VALGRIND)\"\n endif\n \n-ifdef PLEASE_BENCH\n-  TESTARGS += --bench\n-endif\n-\n # Arguments to the perf tests\n ifdef CFG_PERF_TOOL\n   CTEST_PERF_RUNTOOL = --runtool \"$(CFG_PERF_TOOL)\"\n endif\n \n CTEST_TESTARGS := $(TESTARGS)\n \n+# --bench is only relevant for crate tests, not for the compile tests\n+ifdef PLEASE_BENCH\n+  TESTARGS += --bench\n+endif\n+\n ifdef VERBOSE\n   CTEST_TESTARGS += --verbose\n endif"}, {"sha": "11b2afc1c8822141f5418c43b3bded8df0756b94", "filename": "src/doc/reference.md", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -648,7 +648,7 @@ All of the above extensions are expressions with values.\n \n Users of `rustc` can define new syntax extensions in two ways:\n \n-* [Compiler plugins](book/syntax-extensions.html) can include arbitrary\n+* [Compiler plugins][plugin] can include arbitrary\n   Rust code that manipulates syntax trees at compile time.\n \n * [Macros](book/macros.html) define new syntax in a higher-level,\n@@ -818,9 +818,8 @@ item : extern_crate_decl | use_decl | mod_item | fn_item | type_item\n      | extern_block ;\n ```\n \n-An _item_ is a component of a crate; some module items can be defined in crate\n-files, but most are defined in source files. Items are organized within a crate\n-by a nested set of [modules](#modules). Every crate has a single \"outermost\"\n+An _item_ is a component of a crate. Items are organized within a crate by a\n+nested set of [modules](#modules). Every crate has a single \"outermost\"\n anonymous module; all further items within the crate have [paths](#paths)\n within the module tree of the crate.\n "}, {"sha": "9e16414d225a98e5f9ad636503e726457624c47d", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -37,3 +37,4 @@\n     * [Macros](macros.md)\n     * [Compiler Plugins](plugins.md)\n * [Conclusion](conclusion.md)\n+* [Glossary](glossary.md)"}, {"sha": "db3202b30345f5f80b647a19ddea091ff06074df", "filename": "src/doc/trpl/compound-data-types.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -47,7 +47,8 @@ This pattern is very powerful, and we'll see it repeated more later.\n \n There are also a few things you can do with a tuple as a whole, without\n destructuring. You can assign one tuple into another, if they have the same\n-arity and contained types.\n+contained types and arity. Tuples have the same arity when they have the same\n+length.\n \n ```rust\n let mut x = (1, 2); // x: (i32, i32)"}, {"sha": "156f33748673b34a5c91b7ffed743143efe108e4", "filename": "src/doc/trpl/glossary.md", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Fdoc%2Ftrpl%2Fglossary.md", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Fdoc%2Ftrpl%2Fglossary.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fglossary.md?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -0,0 +1,16 @@\n+% Glossary\n+\n+Not every Rustacean has a background in systems programming, nor in computer\n+science, so we've added explanations of terms that might be unfamiliar.\n+\n+### Arity\n+\n+Arity refers to the number of arguments a function or operation takes.\n+\n+```rust\n+let x = (2, 3);\n+let y = (4, 6);\n+let z = (8, 2, 6);\n+```\n+\n+In the example above `x` and `y` have arity 2. `z` has arity 3."}, {"sha": "a3b5d655fa78bb5ee41ff5bd4e44709690cfdbe5", "filename": "src/doc/trpl/hello-world.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Fdoc%2Ftrpl%2Fhello-world.md", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Fdoc%2Ftrpl%2Fhello-world.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fhello-world.md?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -89,7 +89,7 @@ This line does all of the work in our little program. There are a number of\n details that are important here. The first is that it's indented with four\n spaces, not tabs. Please configure your editor of choice to insert four spaces\n with the tab key. We provide some [sample configurations for various\n-editors](https://github.com/rust-lang/rust/tree/master/src/etc).\n+editors](https://github.com/rust-lang/rust/tree/master/src/etc/CONFIGS.md).\n \n The second point is the `println!()` part. This is calling a Rust *macro*,\n which is how metaprogramming is done in Rust. If it were a function instead, it"}, {"sha": "79502f3cd17f755768cabac2c00c36c2f594f03a", "filename": "src/doc/trpl/plugins.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Fdoc%2Ftrpl%2Fplugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Fdoc%2Ftrpl%2Fplugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fplugins.md?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -39,6 +39,16 @@ If present, arguments passed as `#![plugin(foo(... args ...))]` are not\n interpreted by rustc itself.  They are provided to the plugin through the\n `Registry`'s [`args` method](../rustc/plugin/registry/struct.Registry.html#method.args).\n \n+In the vast majority of cases, a plugin should *only* be used through\n+`#![plugin]` and not through an `extern crate` item.  Linking a plugin would\n+pull in all of libsyntax and librustc as dependencies of your crate.  This is\n+generally unwanted unless you are building another plugin.  The\n+`plugin_as_library` lint checks these guidelines.\n+\n+The usual practice is to put compiler plugins in their own crate, separate from\n+any `macro_rules!` macros or ordinary Rust code meant to be used by consumers\n+of a library.\n+\n # Syntax extensions\n \n Plugins can extend Rust's syntax in various ways. One kind of syntax extension"}, {"sha": "88babd8659c2bb44a24e73f7825d292f1ba57b40", "filename": "src/doc/trpl/variable-bindings.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -40,6 +40,11 @@ let x: i32 = 5;\n If I asked you to read this out loud to the rest of the class, you'd say \"`x`\n is a binding with the type `i32` and the value `five`.\"\n \n+In this case we chose to represent `x` as a 32-bit signed integer. Rust has\n+many different primitive integer types. They begin with `i` for signed integers\n+and `u` for unsigned integers. The possible integer sizes are 8, 16, 32, and 64\n+bits.\n+\n In future examples, we may annotate the type in a comment. The examples will\n look like this:\n "}, {"sha": "036a2f7d4365b11fe090d629d699d42992c28a02", "filename": "src/etc/CONFIGS.md", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Fetc%2FCONFIGS.md", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Fetc%2FCONFIGS.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2FCONFIGS.md?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -0,0 +1,10 @@\n+# Configs\n+\n+Here are some links to repos with configs which ease the use of rust:\n+\n+* [rust.vim](https://github.com/rust-lang/rust.vim)\n+* [emacs rust-mode](https://github.com/rust-lang/rust-mode)\n+* [gedit-config](https://github.com/rust-lang/gedit-config)\n+* [kate-config](https://github.com/rust-lang/kate-config)\n+* [nano-config](https://github.com/rust-lang/nano-config)\n+* [zsh-config](https://github.com/rust-lang/zsh-config)"}, {"sha": "d4f1071c724b6a0cd17020514890601005ac1925", "filename": "src/etc/rustup.sh", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Fetc%2Frustup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Fetc%2Frustup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frustup.sh?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -241,6 +241,9 @@ create_tmp_dir() {\n     echo $TMP_DIR\n }\n \n+# Make `tr` locale independent\n+LC_CTYPE=C\n+\n probe_need CFG_CURL  curl\n probe_need CFG_TAR   tar\n probe_need CFG_FILE  file"}, {"sha": "1d994839d99410677ea349342c3d6b1b7a5d9675", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -655,6 +655,8 @@ impl<T: Ord> FromIterator<T> for BinaryHeap<T> {\n     }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T: Ord> IntoIterator for BinaryHeap<T> {\n     type IntoIter = IntoIter<T>;\n \n@@ -663,6 +665,18 @@ impl<T: Ord> IntoIterator for BinaryHeap<T> {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<T: Ord> IntoIterator for BinaryHeap<T> {\n+    type Item = T;\n+    type IntoIter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.into_iter()\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<'a, T> IntoIterator for &'a BinaryHeap<T> where T: Ord {\n     type IntoIter = Iter<'a, T>;\n \n@@ -671,6 +685,16 @@ impl<'a, T> IntoIterator for &'a BinaryHeap<T> where T: Ord {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<'a, T> IntoIterator for &'a BinaryHeap<T> where T: Ord {\n+    type Item = &'a T;\n+    type IntoIter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BinaryHeap<T> {\n     fn extend<Iter: Iterator<Item=T>>(&mut self, iter: Iter) {"}, {"sha": "ca598a8d4d29255145f51abefe7056be6fb50109", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -1070,6 +1070,8 @@ impl<'a> RandomAccessIterator for Iter<'a> {\n     }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<'a> IntoIterator for &'a Bitv {\n     type IntoIter = Iter<'a>;\n \n@@ -1078,6 +1080,16 @@ impl<'a> IntoIterator for &'a Bitv {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<'a> IntoIterator for &'a Bitv {\n+    type Item = bool;\n+    type IntoIter = Iter<'a>;\n+\n+    fn into_iter(self) -> Iter<'a> {\n+        self.iter()\n+    }\n+}\n+\n /// An implementation of a set using a bit vector as an underlying\n /// representation for holding unsigned numerical elements.\n ///\n@@ -1882,6 +1894,8 @@ impl<'a> Iterator for SymmetricDifference<'a> {\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<'a> IntoIterator for &'a BitvSet {\n     type IntoIter = SetIter<'a>;\n \n@@ -1890,6 +1904,16 @@ impl<'a> IntoIterator for &'a BitvSet {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<'a> IntoIterator for &'a BitvSet {\n+    type Item = usize;\n+    type IntoIter = SetIter<'a>;\n+\n+    fn into_iter(self) -> SetIter<'a> {\n+        self.iter()\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use prelude::*;"}, {"sha": "84f9825e989b365af71a4cae1a2d1a6dad90ee10", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -462,6 +462,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<K, V> IntoIterator for BTreeMap<K, V> {\n     type IntoIter = IntoIter<K, V>;\n \n@@ -470,6 +472,18 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<K, V> IntoIterator for BTreeMap<K, V> {\n+    type Item = (K, V);\n+    type IntoIter = IntoIter<K, V>;\n+\n+    fn into_iter(self) -> IntoIter<K, V> {\n+        self.into_iter()\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<'a, K, V> IntoIterator for &'a BTreeMap<K, V> {\n     type IntoIter = Iter<'a, K, V>;\n \n@@ -478,6 +492,18 @@ impl<'a, K, V> IntoIterator for &'a BTreeMap<K, V> {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<'a, K, V> IntoIterator for &'a BTreeMap<K, V> {\n+    type Item = (&'a K, &'a V);\n+    type IntoIter = Iter<'a, K, V>;\n+\n+    fn into_iter(self) -> Iter<'a, K, V> {\n+        self.iter()\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<'a, K, V> IntoIterator for &'a mut BTreeMap<K, V> {\n     type IntoIter = IterMut<'a, K, V>;\n \n@@ -486,6 +512,16 @@ impl<'a, K, V> IntoIterator for &'a mut BTreeMap<K, V> {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<'a, K, V> IntoIterator for &'a mut BTreeMap<K, V> {\n+    type Item = (&'a K, &'a mut V);\n+    type IntoIter = IterMut<'a, K, V>;\n+\n+    fn into_iter(mut self) -> IterMut<'a, K, V> {\n+        self.iter_mut()\n+    }\n+}\n+\n /// A helper enum useful for deciding whether to continue a loop since we can't\n /// return from a closure\n enum Continuation<A, B> {"}, {"sha": "aecf59403119244a66e29c44ae1e3120eb523ca8", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -480,6 +480,8 @@ impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n     }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T> IntoIterator for BTreeSet<T> {\n     type IntoIter = IntoIter<T>;\n \n@@ -488,6 +490,18 @@ impl<T> IntoIterator for BTreeSet<T> {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<T> IntoIterator for BTreeSet<T> {\n+    type Item = T;\n+    type IntoIter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.into_iter()\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<'a, T> IntoIterator for &'a BTreeSet<T> {\n     type IntoIter = Iter<'a, T>;\n \n@@ -496,6 +510,16 @@ impl<'a, T> IntoIterator for &'a BTreeSet<T> {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<'a, T> IntoIterator for &'a BTreeSet<T> {\n+    type Item = &'a T;\n+    type IntoIter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BTreeSet<T> {\n     #[inline]"}, {"sha": "27b282ee9a9c1a04ee344d21ef2450180623d7b2", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -837,6 +837,8 @@ impl<A> FromIterator<A> for DList<A> {\n     }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T> IntoIterator for DList<T> {\n     type IntoIter = IntoIter<T>;\n \n@@ -845,15 +847,49 @@ impl<T> IntoIterator for DList<T> {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<T> IntoIterator for DList<T> {\n+    type Item = T;\n+    type IntoIter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.into_iter()\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n+impl<'a, T> IntoIterator for &'a DList<T> {\n+    type IntoIter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n impl<'a, T> IntoIterator for &'a DList<T> {\n+    type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n \n     fn into_iter(self) -> Iter<'a, T> {\n         self.iter()\n     }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n+impl<'a, T> IntoIterator for &'a mut DList<T> {\n+    type IntoIter = IterMut<'a, T>;\n+\n+    fn into_iter(mut self) -> IterMut<'a, T> {\n+        self.iter_mut()\n+    }\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n impl<'a, T> IntoIterator for &'a mut DList<T> {\n+    type Item = &'a mut T;\n     type IntoIter = IterMut<'a, T>;\n \n     fn into_iter(mut self) -> IterMut<'a, T> {"}, {"sha": "5c37be188fea4c972859790ba405362e53663a98", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -257,6 +257,8 @@ impl<E:CLike> FromIterator<E> for EnumSet<E> {\n     }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<'a, E> IntoIterator for &'a EnumSet<E> where E: CLike {\n     type IntoIter = Iter<E>;\n \n@@ -265,6 +267,16 @@ impl<'a, E> IntoIterator for &'a EnumSet<E> where E: CLike {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<'a, E> IntoIterator for &'a EnumSet<E> where E: CLike {\n+    type Item = E;\n+    type IntoIter = Iter<E>;\n+\n+    fn into_iter(self) -> Iter<E> {\n+        self.iter()\n+    }\n+}\n+\n impl<E:CLike> Extend<E> for EnumSet<E> {\n     fn extend<I: Iterator<Item=E>>(&mut self, iterator: I) {\n         for element in iterator {"}, {"sha": "0a4ccde923667ef01764443f05c58293ca495895", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -1699,6 +1699,8 @@ impl<A> FromIterator<A> for RingBuf<A> {\n     }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T> IntoIterator for RingBuf<T> {\n     type IntoIter = IntoIter<T>;\n \n@@ -1707,6 +1709,18 @@ impl<T> IntoIterator for RingBuf<T> {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<T> IntoIterator for RingBuf<T> {\n+    type Item = T;\n+    type IntoIter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.into_iter()\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<'a, T> IntoIterator for &'a RingBuf<T> {\n     type IntoIter = Iter<'a, T>;\n \n@@ -1715,6 +1729,18 @@ impl<'a, T> IntoIterator for &'a RingBuf<T> {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<'a, T> IntoIterator for &'a RingBuf<T> {\n+    type Item = &'a T;\n+    type IntoIter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<'a, T> IntoIterator for &'a mut RingBuf<T> {\n     type IntoIter = IterMut<'a, T>;\n \n@@ -1723,6 +1749,16 @@ impl<'a, T> IntoIterator for &'a mut RingBuf<T> {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<'a, T> IntoIterator for &'a mut RingBuf<T> {\n+    type Item = &'a mut T;\n+    type IntoIter = IterMut<'a, T>;\n+\n+    fn into_iter(mut self) -> IterMut<'a, T> {\n+        self.iter_mut()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Extend<A> for RingBuf<A> {\n     fn extend<T: Iterator<Item=A>>(&mut self, iterator: T) {"}, {"sha": "2d4dc2bcf30d35bfbd53d8b88abd2924cbf5cf55", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -1285,7 +1285,8 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// let v: Vec<&str> = some_words.words().collect();\n     /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[unstable(feature = \"str_words\",\n+               reason = \"the precise algorithm to use is unclear\")]\n     fn words(&self) -> Words {\n         UnicodeStr::words(&self[])\n     }"}, {"sha": "f294dd3c3e0f62c88321284cd564373430a2c435", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -1387,6 +1387,17 @@ impl<T> FromIterator<T> for Vec<T> {\n         let (lower, _) = iterator.size_hint();\n         let mut vector = Vec::with_capacity(lower);\n \n+        // This function should be the moral equivalent of:\n+        //\n+        //      for item in iterator {\n+        //          vector.push(item);\n+        //      }\n+        //\n+        // This equivalent crucially runs the iterator precisely once. The\n+        // optimization below (eliding bound/growth checks) means that we\n+        // actually run the iterator twice. To ensure the \"moral equivalent\" we\n+        // do a `fuse()` operation to ensure that the iterator continues to\n+        // return `None` after seeing the first `None`.\n         let mut i = iterator.fuse();\n         for element in i.by_ref().take(vector.capacity()) {\n             let len = vector.len();\n@@ -1403,6 +1414,8 @@ impl<T> FromIterator<T> for Vec<T> {\n     }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T> IntoIterator for Vec<T> {\n     type IntoIter = IntoIter<T>;\n \n@@ -1411,6 +1424,18 @@ impl<T> IntoIterator for Vec<T> {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<T> IntoIterator for Vec<T> {\n+    type Item = T;\n+    type IntoIter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.into_iter()\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<'a, T> IntoIterator for &'a Vec<T> {\n     type IntoIter = slice::Iter<'a, T>;\n \n@@ -1419,7 +1444,29 @@ impl<'a, T> IntoIterator for &'a Vec<T> {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<'a, T> IntoIterator for &'a Vec<T> {\n+    type Item = &'a T;\n+    type IntoIter = slice::Iter<'a, T>;\n+\n+    fn into_iter(self) -> slice::Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n+impl<'a, T> IntoIterator for &'a mut Vec<T> {\n+    type IntoIter = slice::IterMut<'a, T>;\n+\n+    fn into_iter(mut self) -> slice::IterMut<'a, T> {\n+        self.iter_mut()\n+    }\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n impl<'a, T> IntoIterator for &'a mut Vec<T> {\n+    type Item = &'a mut T;\n     type IntoIter = slice::IterMut<'a, T>;\n \n     fn into_iter(mut self) -> slice::IterMut<'a, T> {"}, {"sha": "7f9484c58a18575994e941a7ce4e1ce2f8400bb1", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -668,6 +668,8 @@ impl<V> FromIterator<(usize, V)> for VecMap<V> {\n     }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T> IntoIterator for VecMap<T> {\n     type IntoIter = IntoIter<T>;\n \n@@ -676,15 +678,49 @@ impl<T> IntoIterator for VecMap<T> {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<T> IntoIterator for VecMap<T> {\n+    type Item = (usize, T);\n+    type IntoIter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.into_iter()\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n+impl<'a, T> IntoIterator for &'a VecMap<T> {\n+    type IntoIter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n impl<'a, T> IntoIterator for &'a VecMap<T> {\n+    type Item = (usize, &'a T);\n     type IntoIter = Iter<'a, T>;\n \n     fn into_iter(self) -> Iter<'a, T> {\n         self.iter()\n     }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n+impl<'a, T> IntoIterator for &'a mut VecMap<T> {\n+    type IntoIter = IterMut<'a, T>;\n+\n+    fn into_iter(mut self) -> IterMut<'a, T> {\n+        self.iter_mut()\n+    }\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n impl<'a, T> IntoIterator for &'a mut VecMap<T> {\n+    type Item = (usize, &'a mut T);\n     type IntoIter = IterMut<'a, T>;\n \n     fn into_iter(mut self) -> IterMut<'a, T> {"}, {"sha": "abaa7594d04780678661e93ecb0087070baa9170", "filename": "src/libcore/array.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -48,6 +48,8 @@ macro_rules! array_impls {\n                 }\n             }\n \n+            // NOTE(stage0): remove impl after a snapshot\n+            #[cfg(stage0)]\n             impl<'a, T> IntoIterator for &'a [T; $N] {\n                 type IntoIter = Iter<'a, T>;\n \n@@ -56,7 +58,29 @@ macro_rules! array_impls {\n                 }\n             }\n \n+            #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+            impl<'a, T> IntoIterator for &'a [T; $N] {\n+                type Item = &'a T;\n+                type IntoIter = Iter<'a, T>;\n+\n+                fn into_iter(self) -> Iter<'a, T> {\n+                    self.iter()\n+                }\n+            }\n+\n+            // NOTE(stage0): remove impl after a snapshot\n+            #[cfg(stage0)]\n+            impl<'a, T> IntoIterator for &'a mut [T; $N] {\n+                type IntoIter = IterMut<'a, T>;\n+\n+                fn into_iter(self) -> IterMut<'a, T> {\n+                    self.iter_mut()\n+                }\n+            }\n+\n+            #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n             impl<'a, T> IntoIterator for &'a mut [T; $N] {\n+                type Item = &'a mut T;\n                 type IntoIter = IterMut<'a, T>;\n \n                 fn into_iter(self) -> IterMut<'a, T> {"}, {"sha": "562a597cccf1d1947e48363a3031cb26e0a8d52b", "filename": "src/libcore/finally.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcore%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcore%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffinally.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -72,7 +72,7 @@ impl<T, F> Finally<T> for F where F: FnMut() -> T {\n /// ```\n /// use std::finally::try_finally;\n ///\n-/// struct State<'a> { buffer: &'a mut [u8], len: uint }\n+/// struct State<'a> { buffer: &'a mut [u8], len: usize }\n /// # let mut buf = [];\n /// let mut state = State { buffer: &mut buf, len: 0 };\n /// try_finally("}, {"sha": "03c473ed9674117b0a29bd58280a11f7edbbb0e3", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -118,6 +118,8 @@ pub trait FromIterator<A> {\n     fn from_iter<T: Iterator<Item=A>>(iterator: T) -> Self;\n }\n \n+// NOTE(stage0): remove trait after a snapshot\n+#[cfg(stage0)]\n /// Conversion into an `Iterator`\n pub trait IntoIterator {\n     type IntoIter: Iterator;\n@@ -127,6 +129,19 @@ pub trait IntoIterator {\n     fn into_iter(self) -> Self::IntoIter;\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+/// Conversion into an `Iterator`\n+pub trait IntoIterator {\n+    type Item;\n+    type IntoIter: Iterator<Item=Self::Item>;\n+\n+    /// Consumes `Self` and returns an iterator over it\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn into_iter(self) -> Self::IntoIter;\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<I> IntoIterator for I where I: Iterator {\n     type IntoIter = I;\n \n@@ -135,6 +150,16 @@ impl<I> IntoIterator for I where I: Iterator {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<I: Iterator> IntoIterator for I {\n+    type Item = I::Item;\n+    type IntoIter = I;\n+\n+    fn into_iter(self) -> I {\n+        self\n+    }\n+}\n+\n /// A type growable from an `Iterator` implementation\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Extend<A> {\n@@ -1055,6 +1080,7 @@ pub trait RandomAccessIterator: Iterator {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait ExactSizeIterator: Iterator {\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Return the exact length of the iterator.\n     fn len(&self) -> usize {\n         let (lower, upper) = self.size_hint();"}, {"sha": "fbd7f840da6e15748e2972899771deaa7b5307d5", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -37,8 +37,8 @@\n //!\n //! #[derive(Debug)]\n //! struct Point {\n-//!     x: int,\n-//!     y: int\n+//!     x: i32,\n+//!     y: i32\n //! }\n //!\n //! impl Add for Point {\n@@ -206,7 +206,7 @@ macro_rules! add_impl {\n     )*)\n }\n \n-add_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n+add_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n \n /// The `Sub` trait is used to specify the functionality of `-`.\n ///\n@@ -259,7 +259,7 @@ macro_rules! sub_impl {\n     )*)\n }\n \n-sub_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n+sub_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n \n /// The `Mul` trait is used to specify the functionality of `*`.\n ///\n@@ -312,7 +312,7 @@ macro_rules! mul_impl {\n     )*)\n }\n \n-mul_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n+mul_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n \n /// The `Div` trait is used to specify the functionality of `/`.\n ///\n@@ -365,7 +365,7 @@ macro_rules! div_impl {\n     )*)\n }\n \n-div_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n+div_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n \n /// The `Rem` trait is used to specify the functionality of `%`.\n ///\n@@ -435,7 +435,7 @@ macro_rules! rem_float_impl {\n     }\n }\n \n-rem_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n+rem_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n rem_float_impl! { f32, fmodf }\n rem_float_impl! { f64, fmod }\n \n@@ -506,9 +506,9 @@ macro_rules! neg_uint_impl {\n     }\n }\n \n-neg_impl! { int i8 i16 i32 i64 f32 f64 }\n+neg_impl! { isize i8 i16 i32 i64 f32 f64 }\n \n-neg_uint_impl! { uint, int }\n+neg_uint_impl! { usize, isize }\n neg_uint_impl! { u8, i8 }\n neg_uint_impl! { u16, i16 }\n neg_uint_impl! { u32, i32 }\n@@ -566,7 +566,7 @@ macro_rules! not_impl {\n     )*)\n }\n \n-not_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n+not_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n \n /// The `BitAnd` trait is used to specify the functionality of `&`.\n ///\n@@ -619,7 +619,7 @@ macro_rules! bitand_impl {\n     )*)\n }\n \n-bitand_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n+bitand_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n \n /// The `BitOr` trait is used to specify the functionality of `|`.\n ///\n@@ -672,7 +672,7 @@ macro_rules! bitor_impl {\n     )*)\n }\n \n-bitor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n+bitor_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n \n /// The `BitXor` trait is used to specify the functionality of `^`.\n ///\n@@ -725,7 +725,7 @@ macro_rules! bitxor_impl {\n     )*)\n }\n \n-bitxor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n+bitxor_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n \n /// The `Shl` trait is used to specify the functionality of `<<`.\n ///"}, {"sha": "3dc94ba555f3589bff0aec08c7cfde3f2232bead", "filename": "src/libcore/option.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -60,19 +60,19 @@\n //! the optional owned box, `Option<Box<T>>`.\n //!\n //! The following example uses `Option` to create an optional box of\n-//! `int`. Notice that in order to use the inner `int` value first the\n+//! `i32`. Notice that in order to use the inner `i32` value first the\n //! `check_optional` function needs to use pattern matching to\n //! determine whether the box has a value (i.e. it is `Some(...)`) or\n //! not (`None`).\n //!\n //! ```\n-//! let optional: Option<Box<int>> = None;\n+//! let optional: Option<Box<i32>> = None;\n //! check_optional(&optional);\n //!\n-//! let optional: Option<Box<int>> = Some(Box::new(9000));\n+//! let optional: Option<Box<i32>> = Some(Box::new(9000));\n //! check_optional(&optional);\n //!\n-//! fn check_optional(optional: &Option<Box<int>>) {\n+//! fn check_optional(optional: &Option<Box<i32>>) {\n //!     match *optional {\n //!         Some(ref p) => println!(\"have value {}\", p),\n //!         None => println!(\"have no value\")\n@@ -108,7 +108,7 @@\n //! Initialize a result to `None` before a loop:\n //!\n //! ```\n-//! enum Kingdom { Plant(uint, &'static str), Animal(uint, &'static str) }\n+//! enum Kingdom { Plant(u32, &'static str), Animal(u32, &'static str) }\n //!\n //! // A list of data to search through.\n //! let all_the_big_things = [\n@@ -188,10 +188,10 @@ impl<T> Option<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// let x: Option<uint> = Some(2);\n+    /// let x: Option<u32> = Some(2);\n     /// assert_eq!(x.is_some(), true);\n     ///\n-    /// let x: Option<uint> = None;\n+    /// let x: Option<u32> = None;\n     /// assert_eq!(x.is_some(), false);\n     /// ```\n     #[inline]\n@@ -208,10 +208,10 @@ impl<T> Option<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// let x: Option<uint> = Some(2);\n+    /// let x: Option<u32> = Some(2);\n     /// assert_eq!(x.is_none(), false);\n     ///\n-    /// let x: Option<uint> = None;\n+    /// let x: Option<u32> = None;\n     /// assert_eq!(x.is_none(), true);\n     /// ```\n     #[inline]\n@@ -228,7 +228,7 @@ impl<T> Option<T> {\n     ///\n     /// # Example\n     ///\n-    /// Convert an `Option<String>` into an `Option<int>`, preserving the original.\n+    /// Convert an `Option<String>` into an `Option<usize>`, preserving the original.\n     /// The `map` method takes the `self` argument by value, consuming the original,\n     /// so this technique uses `as_ref` to first take an `Option` to a reference\n     /// to the value inside the original.\n@@ -237,7 +237,7 @@ impl<T> Option<T> {\n     /// let num_as_str: Option<String> = Some(\"10\".to_string());\n     /// // First, cast `Option<String>` to `Option<&String>` with `as_ref`,\n     /// // then consume *that* with `map`, leaving `num_as_str` on the stack.\n-    /// let num_as_int: Option<uint> = num_as_str.as_ref().map(|n| n.len());\n+    /// let num_as_int: Option<usize> = num_as_str.as_ref().map(|n| n.len());\n     /// println!(\"still can print num_as_str: {:?}\", num_as_str);\n     /// ```\n     #[inline]\n@@ -406,12 +406,12 @@ impl<T> Option<T> {\n     ///\n     /// # Example\n     ///\n-    /// Convert an `Option<String>` into an `Option<uint>`, consuming the original:\n+    /// Convert an `Option<String>` into an `Option<usize>`, consuming the original:\n     ///\n     /// ```\n     /// let num_as_str: Option<String> = Some(\"10\".to_string());\n     /// // `Option::map` takes self *by value*, consuming `num_as_str`\n-    /// let num_as_int: Option<uint> = num_as_str.map(|n| n.len());\n+    /// let num_as_int: Option<usize> = num_as_str.map(|n| n.len());\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -518,7 +518,7 @@ impl<T> Option<T> {\n     /// let x = Some(4);\n     /// assert_eq!(x.iter().next(), Some(&4));\n     ///\n-    /// let x: Option<uint> = None;\n+    /// let x: Option<u32> = None;\n     /// assert_eq!(x.iter().next(), None);\n     /// ```\n     #[inline]\n@@ -539,7 +539,7 @@ impl<T> Option<T> {\n     /// }\n     /// assert_eq!(x, Some(42));\n     ///\n-    /// let mut x: Option<uint> = None;\n+    /// let mut x: Option<u32> = None;\n     /// assert_eq!(x.iter_mut().next(), None);\n     /// ```\n     #[inline]\n@@ -581,15 +581,15 @@ impl<T> Option<T> {\n     /// let y: Option<&str> = None;\n     /// assert_eq!(x.and(y), None);\n     ///\n-    /// let x: Option<uint> = None;\n+    /// let x: Option<u32> = None;\n     /// let y = Some(\"foo\");\n     /// assert_eq!(x.and(y), None);\n     ///\n     /// let x = Some(2);\n     /// let y = Some(\"foo\");\n     /// assert_eq!(x.and(y), Some(\"foo\"));\n     ///\n-    /// let x: Option<uint> = None;\n+    /// let x: Option<u32> = None;\n     /// let y: Option<&str> = None;\n     /// assert_eq!(x.and(y), None);\n     /// ```\n@@ -608,8 +608,8 @@ impl<T> Option<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// fn sq(x: uint) -> Option<uint> { Some(x * x) }\n-    /// fn nope(_: uint) -> Option<uint> { None }\n+    /// fn sq(x: u32) -> Option<u32> { Some(x * x) }\n+    /// fn nope(_: u32) -> Option<u32> { None }\n     ///\n     /// assert_eq!(Some(2).and_then(sq).and_then(sq), Some(16));\n     /// assert_eq!(Some(2).and_then(sq).and_then(nope), None);\n@@ -642,7 +642,7 @@ impl<T> Option<T> {\n     /// let y = Some(100);\n     /// assert_eq!(x.or(y), Some(2));\n     ///\n-    /// let x: Option<uint> = None;\n+    /// let x: Option<u32> = None;\n     /// let y = None;\n     /// assert_eq!(x.or(y), None);\n     /// ```\n@@ -690,7 +690,7 @@ impl<T> Option<T> {\n     /// x.take();\n     /// assert_eq!(x, None);\n     ///\n-    /// let mut x: Option<uint> = None;\n+    /// let mut x: Option<u32> = None;\n     /// x.take();\n     /// assert_eq!(x, None);\n     /// ```\n@@ -789,7 +789,7 @@ impl<A> Iterator for Item<A> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         match self.opt {\n             Some(_) => (1, Some(1)),\n             None => (0, Some(0)),\n@@ -817,7 +817,7 @@ impl<'a, A> Iterator for Iter<'a, A> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a A> { self.inner.next() }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -847,7 +847,7 @@ impl<'a, A> Iterator for IterMut<'a, A> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut A> { self.inner.next() }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -870,7 +870,7 @@ impl<A> Iterator for IntoIter<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.inner.next() }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -896,11 +896,11 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// checking for overflow:\n     ///\n     /// ```rust\n-    /// use std::uint;\n+    /// use std::u16;\n     ///\n     /// let v = vec!(1, 2);\n-    /// let res: Option<Vec<uint>> = v.iter().map(|&x: &uint|\n-    ///     if x == uint::MAX { None }\n+    /// let res: Option<Vec<u16>> = v.iter().map(|&x: &u16|\n+    ///     if x == u16::MAX { None }\n     ///     else { Some(x + 1) }\n     /// ).collect();\n     /// assert!(res == Some(vec!(2, 3)));"}, {"sha": "072c60c7036cffceb2c5c88beb2e14841ebb7a17", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -27,10 +27,10 @@\n //! ## 1. Coerce a reference (`&T`) or mutable reference (`&mut T`).\n //!\n //! ```\n-//! let my_num: int = 10;\n-//! let my_num_ptr: *const int = &my_num;\n-//! let mut my_speed: int = 88;\n-//! let my_speed_ptr: *mut int = &mut my_speed;\n+//! let my_num: i32 = 10;\n+//! let my_num_ptr: *const i32 = &my_num;\n+//! let mut my_speed: i32 = 88;\n+//! let my_speed_ptr: *mut i32 = &mut my_speed;\n //! ```\n //!\n //! This does not take ownership of the original allocation\n@@ -49,15 +49,15 @@\n //! use std::mem;\n //!\n //! unsafe {\n-//!     let my_num: Box<int> = Box::new(10);\n-//!     let my_num: *const int = mem::transmute(my_num);\n-//!     let my_speed: Box<int> = Box::new(88);\n-//!     let my_speed: *mut int = mem::transmute(my_speed);\n+//!     let my_num: Box<i32> = Box::new(10);\n+//!     let my_num: *const i32 = mem::transmute(my_num);\n+//!     let my_speed: Box<i32> = Box::new(88);\n+//!     let my_speed: *mut i32 = mem::transmute(my_speed);\n //!\n //!     // By taking ownership of the original `Box<T>` though\n //!     // we are obligated to transmute it back later to be destroyed.\n-//!     drop(mem::transmute::<_, Box<int>>(my_speed));\n-//!     drop(mem::transmute::<_, Box<int>>(my_num));\n+//!     drop(mem::transmute::<_, Box<i32>>(my_speed));\n+//!     drop(mem::transmute::<_, Box<i32>>(my_num));\n //! }\n //! ```\n //!\n@@ -73,7 +73,7 @@\n //!\n //! fn main() {\n //!     unsafe {\n-//!         let my_num: *mut int = libc::malloc(mem::size_of::<int>() as libc::size_t) as *mut int;\n+//!         let my_num: *mut i32 = libc::malloc(mem::size_of::<i32>() as libc::size_t) as *mut i32;\n //!         if my_num.is_null() {\n //!             panic!(\"failed to allocate memory\");\n //!         }\n@@ -117,7 +117,7 @@ pub use intrinsics::set_memory;\n /// ```\n /// use std::ptr;\n ///\n-/// let p: *const int = ptr::null();\n+/// let p: *const i32 = ptr::null();\n /// assert!(p.is_null());\n /// ```\n #[inline]\n@@ -131,7 +131,7 @@ pub fn null<T>() -> *const T { 0 as *const T }\n /// ```\n /// use std::ptr;\n ///\n-/// let p: *mut int = ptr::null_mut();\n+/// let p: *mut i32 = ptr::null_mut();\n /// assert!(p.is_null());\n /// ```\n #[inline]\n@@ -148,7 +148,7 @@ pub fn null_mut<T>() -> *mut T { 0 as *mut T }\n #[inline]\n #[unstable(feature = \"core\",\n            reason = \"may play a larger role in std::ptr future extensions\")]\n-pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) {\n+pub unsafe fn zero_memory<T>(dst: *mut T, count: usize) {\n     set_memory(dst, 0, count);\n }\n \n@@ -276,7 +276,7 @@ pub trait PtrExt: Sized {\n     /// Otherwise `offset` invokes Undefined Behaviour, regardless of whether\n     /// the pointer is used.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe fn offset(self, count: int) -> Self;\n+    unsafe fn offset(self, count: isize) -> Self;\n }\n \n /// Methods on mutable raw pointers\n@@ -303,11 +303,11 @@ impl<T> PtrExt for *const T {\n \n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_null(self) -> bool { self as uint == 0 }\n+    fn is_null(self) -> bool { self as usize == 0 }\n \n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe fn offset(self, count: int) -> *const T {\n+    unsafe fn offset(self, count: isize) -> *const T {\n         intrinsics::offset(self, count)\n     }\n \n@@ -330,11 +330,11 @@ impl<T> PtrExt for *mut T {\n \n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_null(self) -> bool { self as uint == 0 }\n+    fn is_null(self) -> bool { self as usize == 0 }\n \n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe fn offset(self, count: int) -> *mut T {\n+    unsafe fn offset(self, count: isize) -> *mut T {\n         intrinsics::offset(self, count) as *mut T\n     }\n \n@@ -553,7 +553,7 @@ impl<T> Unique<T> {\n     /// Return an (unsafe) pointer into the memory owned by `self`.\n     #[unstable(feature = \"core\",\n                reason = \"recently added to this module\")]\n-    pub unsafe fn offset(self, offset: int) -> *mut T {\n+    pub unsafe fn offset(self, offset: isize) -> *mut T {\n         self.ptr.offset(offset)\n     }\n }"}, {"sha": "1a874ee178ba0fd8c477c69e2232b01a1d50edd5", "filename": "src/libcore/result.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -311,10 +311,10 @@ impl<T, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// let x: Result<uint, &str> = Ok(2);\n+    /// let x: Result<u32, &str> = Ok(2);\n     /// assert_eq!(x.ok(), Some(2));\n     ///\n-    /// let x: Result<uint, &str> = Err(\"Nothing here\");\n+    /// let x: Result<u32, &str> = Err(\"Nothing here\");\n     /// assert_eq!(x.ok(), None);\n     /// ```\n     #[inline]\n@@ -334,10 +334,10 @@ impl<T, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// let x: Result<uint, &str> = Ok(2);\n+    /// let x: Result<u32, &str> = Ok(2);\n     /// assert_eq!(x.err(), None);\n     ///\n-    /// let x: Result<uint, &str> = Err(\"Nothing here\");\n+    /// let x: Result<u32, &str> = Err(\"Nothing here\");\n     /// assert_eq!(x.err(), Some(\"Nothing here\"));\n     /// ```\n     #[inline]\n@@ -359,10 +359,10 @@ impl<T, E> Result<T, E> {\n     /// into the original, leaving the original in place.\n     ///\n     /// ```\n-    /// let x: Result<uint, &str> = Ok(2);\n+    /// let x: Result<u32, &str> = Ok(2);\n     /// assert_eq!(x.as_ref(), Ok(&2));\n     ///\n-    /// let x: Result<uint, &str> = Err(\"Error\");\n+    /// let x: Result<u32, &str> = Err(\"Error\");\n     /// assert_eq!(x.as_ref(), Err(&\"Error\"));\n     /// ```\n     #[inline]\n@@ -404,7 +404,7 @@ impl<T, E> Result<T, E> {\n     /// Convert from `Result<T, E>` to `&mut [T]` (without copying)\n     ///\n     /// ```\n-    /// let mut x: Result<&str, uint> = Ok(\"Gold\");\n+    /// let mut x: Result<&str, u32> = Ok(\"Gold\");\n     /// {\n     ///     let v = x.as_mut_slice();\n     ///     assert!(v == [\"Gold\"]);\n@@ -413,7 +413,7 @@ impl<T, E> Result<T, E> {\n     /// }\n     /// assert_eq!(x, Ok(\"Silver\"));\n     ///\n-    /// let mut x: Result<&str, uint> = Err(45);\n+    /// let mut x: Result<&str, u32> = Err(45);\n     /// assert!(x.as_mut_slice().is_empty());\n     /// ```\n     #[inline]\n@@ -481,12 +481,12 @@ impl<T, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// fn stringify(x: uint) -> String { format!(\"error code: {}\", x) }\n+    /// fn stringify(x: u32) -> String { format!(\"error code: {}\", x) }\n     ///\n-    /// let x: Result<uint, uint> = Ok(2);\n+    /// let x: Result<u32, u32> = Ok(2);\n     /// assert_eq!(x.map_err(stringify), Ok(2));\n     ///\n-    /// let x: Result<uint, uint> = Err(13);\n+    /// let x: Result<u32, u32> = Err(13);\n     /// assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n     /// ```\n     #[inline]\n@@ -507,10 +507,10 @@ impl<T, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// let x: Result<uint, &str> = Ok(7);\n+    /// let x: Result<u32, &str> = Ok(7);\n     /// assert_eq!(x.iter().next(), Some(&7));\n     ///\n-    /// let x: Result<uint, &str> = Err(\"nothing!\");\n+    /// let x: Result<u32, &str> = Err(\"nothing!\");\n     /// assert_eq!(x.iter().next(), None);\n     /// ```\n     #[inline]\n@@ -524,14 +524,14 @@ impl<T, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// let mut x: Result<uint, &str> = Ok(7);\n+    /// let mut x: Result<u32, &str> = Ok(7);\n     /// match x.iter_mut().next() {\n     ///     Some(&mut ref mut x) => *x = 40,\n     ///     None => {},\n     /// }\n     /// assert_eq!(x, Ok(40));\n     ///\n-    /// let mut x: Result<uint, &str> = Err(\"nothing!\");\n+    /// let mut x: Result<u32, &str> = Err(\"nothing!\");\n     /// assert_eq!(x.iter_mut().next(), None);\n     /// ```\n     #[inline]\n@@ -545,12 +545,12 @@ impl<T, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// let x: Result<uint, &str> = Ok(5);\n-    /// let v: Vec<uint> = x.into_iter().collect();\n+    /// let x: Result<u32, &str> = Ok(5);\n+    /// let v: Vec<u32> = x.into_iter().collect();\n     /// assert_eq!(v, vec![5]);\n     ///\n-    /// let x: Result<uint, &str> = Err(\"nothing!\");\n-    /// let v: Vec<uint> = x.into_iter().collect();\n+    /// let x: Result<u32, &str> = Err(\"nothing!\");\n+    /// let v: Vec<u32> = x.into_iter().collect();\n     /// assert_eq!(v, vec![]);\n     /// ```\n     #[inline]\n@@ -568,19 +568,19 @@ impl<T, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// let x: Result<uint, &str> = Ok(2);\n+    /// let x: Result<u32, &str> = Ok(2);\n     /// let y: Result<&str, &str> = Err(\"late error\");\n     /// assert_eq!(x.and(y), Err(\"late error\"));\n     ///\n-    /// let x: Result<uint, &str> = Err(\"early error\");\n+    /// let x: Result<u32, &str> = Err(\"early error\");\n     /// let y: Result<&str, &str> = Ok(\"foo\");\n     /// assert_eq!(x.and(y), Err(\"early error\"));\n     ///\n-    /// let x: Result<uint, &str> = Err(\"not a 2\");\n+    /// let x: Result<u32, &str> = Err(\"not a 2\");\n     /// let y: Result<&str, &str> = Err(\"late error\");\n     /// assert_eq!(x.and(y), Err(\"not a 2\"));\n     ///\n-    /// let x: Result<uint, &str> = Ok(2);\n+    /// let x: Result<u32, &str> = Ok(2);\n     /// let y: Result<&str, &str> = Ok(\"different result type\");\n     /// assert_eq!(x.and(y), Ok(\"different result type\"));\n     /// ```\n@@ -600,8 +600,8 @@ impl<T, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// fn sq(x: uint) -> Result<uint, uint> { Ok(x * x) }\n-    /// fn err(x: uint) -> Result<uint, uint> { Err(x) }\n+    /// fn sq(x: u32) -> Result<u32, u32> { Ok(x * x) }\n+    /// fn err(x: u32) -> Result<u32, u32> { Err(x) }\n     ///\n     /// assert_eq!(Ok(2).and_then(sq).and_then(sq), Ok(16));\n     /// assert_eq!(Ok(2).and_then(sq).and_then(err), Err(4));\n@@ -622,20 +622,20 @@ impl<T, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// let x: Result<uint, &str> = Ok(2);\n-    /// let y: Result<uint, &str> = Err(\"late error\");\n+    /// let x: Result<u32, &str> = Ok(2);\n+    /// let y: Result<u32, &str> = Err(\"late error\");\n     /// assert_eq!(x.or(y), Ok(2));\n     ///\n-    /// let x: Result<uint, &str> = Err(\"early error\");\n-    /// let y: Result<uint, &str> = Ok(2);\n+    /// let x: Result<u32, &str> = Err(\"early error\");\n+    /// let y: Result<u32, &str> = Ok(2);\n     /// assert_eq!(x.or(y), Ok(2));\n     ///\n-    /// let x: Result<uint, &str> = Err(\"not a 2\");\n-    /// let y: Result<uint, &str> = Err(\"late error\");\n+    /// let x: Result<u32, &str> = Err(\"not a 2\");\n+    /// let y: Result<u32, &str> = Err(\"late error\");\n     /// assert_eq!(x.or(y), Err(\"late error\"));\n     ///\n-    /// let x: Result<uint, &str> = Ok(2);\n-    /// let y: Result<uint, &str> = Ok(100);\n+    /// let x: Result<u32, &str> = Ok(2);\n+    /// let y: Result<u32, &str> = Ok(100);\n     /// assert_eq!(x.or(y), Ok(2));\n     /// ```\n     #[inline]\n@@ -654,8 +654,8 @@ impl<T, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// fn sq(x: uint) -> Result<uint, uint> { Ok(x * x) }\n-    /// fn err(x: uint) -> Result<uint, uint> { Err(x) }\n+    /// fn sq(x: u32) -> Result<u32, u32> { Ok(x * x) }\n+    /// fn err(x: u32) -> Result<u32, u32> { Err(x) }\n     ///\n     /// assert_eq!(Ok(2).or_else(sq).or_else(sq), Ok(2));\n     /// assert_eq!(Ok(2).or_else(err).or_else(sq), Ok(2));\n@@ -678,10 +678,10 @@ impl<T, E> Result<T, E> {\n     ///\n     /// ```\n     /// let optb = 2;\n-    /// let x: Result<uint, &str> = Ok(9);\n+    /// let x: Result<u32, &str> = Ok(9);\n     /// assert_eq!(x.unwrap_or(optb), 9);\n     ///\n-    /// let x: Result<uint, &str> = Err(\"error\");\n+    /// let x: Result<u32, &str> = Err(\"error\");\n     /// assert_eq!(x.unwrap_or(optb), optb);\n     /// ```\n     #[inline]\n@@ -699,7 +699,7 @@ impl<T, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// fn count(x: &str) -> uint { x.len() }\n+    /// fn count(x: &str) -> usize { x.len() }\n     ///\n     /// assert_eq!(Ok(2).unwrap_or_else(count), 2);\n     /// assert_eq!(Err(\"foo\").unwrap_or_else(count), 3);\n@@ -726,12 +726,12 @@ impl<T, E: fmt::Debug> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// let x: Result<uint, &str> = Ok(2);\n+    /// let x: Result<u32, &str> = Ok(2);\n     /// assert_eq!(x.unwrap(), 2);\n     /// ```\n     ///\n     /// ```{.should_fail}\n-    /// let x: Result<uint, &str> = Err(\"emergency failure\");\n+    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n     /// x.unwrap(); // panics with `emergency failure`\n     /// ```\n     #[inline]\n@@ -757,12 +757,12 @@ impl<T: fmt::Debug, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```{.should_fail}\n-    /// let x: Result<uint, &str> = Ok(2);\n+    /// let x: Result<u32, &str> = Ok(2);\n     /// x.unwrap_err(); // panics with `2`\n     /// ```\n     ///\n     /// ```\n-    /// let x: Result<uint, &str> = Err(\"emergency failure\");\n+    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n     /// assert_eq!(x.unwrap_err(), \"emergency failure\");\n     /// ```\n     #[inline]\n@@ -811,7 +811,7 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> { self.inner.take() }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let n = if self.inner.is_some() {1} else {0};\n         (n, Some(n))\n     }\n@@ -841,7 +841,7 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut T> { self.inner.take() }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let n = if self.inner.is_some() {1} else {0};\n         (n, Some(n))\n     }\n@@ -867,7 +867,7 @@ impl<T> Iterator for IntoIter<T> {\n     #[inline]\n     fn next(&mut self) -> Option<T> { self.inner.take() }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let n = if self.inner.is_some() {1} else {0};\n         (n, Some(n))\n     }\n@@ -896,11 +896,11 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// checking for overflow:\n     ///\n     /// ```rust\n-    /// use std::uint;\n+    /// use std::u32;\n     ///\n     /// let v = vec!(1, 2);\n-    /// let res: Result<Vec<uint>, &'static str> = v.iter().map(|&x: &uint|\n-    ///     if x == uint::MAX { Err(\"Overflow!\") }\n+    /// let res: Result<Vec<u32>, &'static str> = v.iter().map(|&x: &u32|\n+    ///     if x == u32::MAX { Err(\"Overflow!\") }\n     ///     else { Ok(x + 1) }\n     /// ).collect();\n     /// assert!(res == Ok(vec!(2, 3)));"}, {"sha": "cd91843f359ea9abae945c6599f8e9c67386ddb4", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -626,6 +626,8 @@ impl<'a, T> Default for &'a [T] {\n // Iterators\n //\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<'a, T> IntoIterator for &'a [T] {\n     type IntoIter = Iter<'a, T>;\n \n@@ -634,7 +636,29 @@ impl<'a, T> IntoIterator for &'a [T] {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<'a, T> IntoIterator for &'a [T] {\n+    type Item = &'a T;\n+    type IntoIter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n+impl<'a, T> IntoIterator for &'a mut [T] {\n+    type IntoIter = IterMut<'a, T>;\n+\n+    fn into_iter(self) -> IterMut<'a, T> {\n+        self.iter_mut()\n+    }\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n impl<'a, T> IntoIterator for &'a mut [T] {\n+    type Item = &'a mut T;\n     type IntoIter = IterMut<'a, T>;\n \n     fn into_iter(self) -> IterMut<'a, T> {"}, {"sha": "4535e0b1691952821ee50cc9f3d19e60a5ef6a72", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -2005,7 +2005,7 @@ pub mod types {\n                 use types::common::c95::{c_void};\n                 use types::os::arch::c95::{c_char, c_int, c_uint};\n \n-                pub type socklen_t = c_int;\n+                pub type socklen_t = u32;\n                 pub type sa_family_t = u8;\n                 pub type in_port_t = u16;\n                 pub type in_addr_t = u32;\n@@ -2114,8 +2114,8 @@ pub mod types {\n                 pub type c_double = f64;\n                 pub type size_t = u32;\n                 pub type ptrdiff_t = i32;\n-                pub type clock_t = u32;\n-                pub type time_t = i32;\n+                pub type clock_t = c_ulong;\n+                pub type time_t = c_long;\n                 pub type suseconds_t = i32;\n                 pub type wchar_t = i32;\n             }\n@@ -2128,6 +2128,8 @@ pub mod types {\n                 pub type uintmax_t = u64;\n             }\n             pub mod posix88 {\n+                use types::os::arch::c95::c_long;\n+\n                 pub type off_t = i64;\n                 pub type dev_t = i32;\n                 pub type ino_t = u64;\n@@ -2136,7 +2138,7 @@ pub mod types {\n                 pub type gid_t = u32;\n                 pub type useconds_t = u32;\n                 pub type mode_t = u16;\n-                pub type ssize_t = i32;\n+                pub type ssize_t = c_long;\n             }\n             pub mod posix01 {\n                 use types::common::c99::{int32_t, int64_t, uint32_t};\n@@ -2145,8 +2147,8 @@ pub mod types {\n                                                      mode_t, off_t, uid_t};\n \n                 pub type nlink_t = u16;\n-                pub type blksize_t = i64;\n-                pub type blkcnt_t = i32;\n+                pub type blksize_t = i32;\n+                pub type blkcnt_t = i64;\n \n                 #[repr(C)]\n                 #[derive(Copy)] pub struct stat {\n@@ -2217,8 +2219,8 @@ pub mod types {\n                 pub type c_double = f64;\n                 pub type size_t = u64;\n                 pub type ptrdiff_t = i64;\n-                pub type clock_t = u64;\n-                pub type time_t = i64;\n+                pub type clock_t = c_ulong;\n+                pub type time_t = c_long;\n                 pub type suseconds_t = i32;\n                 pub type wchar_t = i32;\n             }\n@@ -2231,6 +2233,8 @@ pub mod types {\n                 pub type uintmax_t = u64;\n             }\n             pub mod posix88 {\n+                use types::os::arch::c95::c_long;\n+\n                 pub type off_t = i64;\n                 pub type dev_t = i32;\n                 pub type ino_t = u64;\n@@ -2239,7 +2243,7 @@ pub mod types {\n                 pub type gid_t = u32;\n                 pub type useconds_t = u32;\n                 pub type mode_t = u16;\n-                pub type ssize_t = i64;\n+                pub type ssize_t = c_long;\n             }\n             pub mod posix01 {\n                 use types::common::c99::{int32_t, int64_t};\n@@ -2249,8 +2253,8 @@ pub mod types {\n                 use types::os::arch::posix88::{mode_t, off_t, uid_t};\n \n                 pub type nlink_t = u16;\n-                pub type blksize_t = i64;\n-                pub type blkcnt_t = i32;\n+                pub type blksize_t = i32;\n+                pub type blkcnt_t = i64;\n \n                 #[repr(C)]\n                 #[derive(Copy)] pub struct stat {"}, {"sha": "d09e4bd975924f3392c3b417b1fcc542f641f9a4", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -26,7 +26,7 @@\n //! a `pub fn new()`.\n use self::MethodContext::*;\n \n-use metadata::csearch;\n+use metadata::{csearch, decoder};\n use middle::def::*;\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n@@ -1964,6 +1964,48 @@ impl LintPass for UnconditionalRecursion {\n     }\n }\n \n+declare_lint! {\n+    PLUGIN_AS_LIBRARY,\n+    Warn,\n+    \"compiler plugin used as ordinary library in non-plugin crate\"\n+}\n+\n+#[derive(Copy)]\n+pub struct PluginAsLibrary;\n+\n+impl LintPass for PluginAsLibrary {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array![PLUGIN_AS_LIBRARY]\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        if cx.sess().plugin_registrar_fn.get().is_some() {\n+            // We're compiling a plugin; it's fine to link other plugins.\n+            return;\n+        }\n+\n+        match it.node {\n+            ast::ItemExternCrate(..) => (),\n+            _ => return,\n+        };\n+\n+        let md = match cx.sess().cstore.find_extern_mod_stmt_cnum(it.id) {\n+            Some(cnum) => cx.sess().cstore.get_crate_data(cnum),\n+            None => {\n+                // Probably means we aren't linking the crate for some reason.\n+                //\n+                // Not sure if / when this could happen.\n+                return;\n+            }\n+        };\n+\n+        if decoder::get_plugin_registrar_fn(md.data()).is_some() {\n+            cx.span_lint(PLUGIN_AS_LIBRARY, it.span,\n+                \"compiler plugin used as an ordinary library\");\n+        }\n+    }\n+}\n+\n declare_lint! {\n     pub UNUSED_IMPORTS,\n     Warn,"}, {"sha": "42a6861f452a66f95d6f0f0c301979165a92264a", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -214,6 +214,7 @@ impl LintStore {\n                      Stability,\n                      UnconditionalRecursion,\n                      InvalidNoMangleItems,\n+                     PluginAsLibrary,\n         );\n \n         add_builtin_with_new!(sess,"}, {"sha": "0871c36d892c6cb30ed6135e9fb763e760db58fb", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 29, "deletions": 47, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -121,12 +121,10 @@ fn register_native_lib(sess: &Session,\n     sess.cstore.add_used_library(name, kind);\n }\n \n-pub struct PluginMetadata<'a> {\n-    sess: &'a Session,\n+// Extra info about a crate loaded for plugins or exported macros.\n+struct ExtensionCrate {\n     metadata: PMDSource,\n     dylib: Option<Path>,\n-    info: CrateInfo,\n-    vi_span: Span,\n     target_only: bool,\n }\n \n@@ -451,21 +449,7 @@ impl<'a> CrateReader<'a> {\n         }).collect()\n     }\n \n-    pub fn read_plugin_metadata<'b>(&'b mut self,\n-                                    krate: CrateOrString<'b>) -> PluginMetadata<'b> {\n-        let (info, span) = match krate {\n-            CrateOrString::Krate(c) => {\n-                (self.extract_crate_info(c).unwrap(), c.span)\n-            }\n-            CrateOrString::Str(sp, s) => {\n-                (CrateInfo {\n-                     name: s.to_string(),\n-                     ident: s.to_string(),\n-                     id: ast::DUMMY_NODE_ID,\n-                     should_link: false,\n-                 }, sp)\n-            }\n-        };\n+    fn read_extension_crate(&mut self, span: Span, info: &CrateInfo) -> ExtensionCrate {\n         let target_triple = &self.sess.opts.target_triple[];\n         let is_cross = target_triple != config::host_triple();\n         let mut should_link = info.should_link && !is_cross;\n@@ -517,30 +501,21 @@ impl<'a> CrateReader<'a> {\n             PMDSource::Owned(library.metadata)\n         };\n \n-        PluginMetadata {\n-            sess: self.sess,\n+        ExtensionCrate {\n             metadata: metadata,\n             dylib: dylib.map(|p| p.0),\n-            info: info,\n-            vi_span: span,\n             target_only: target_only,\n         }\n     }\n-}\n \n-#[derive(Copy)]\n-pub enum CrateOrString<'a> {\n-    Krate(&'a ast::Item),\n-    Str(Span, &'a str)\n-}\n+    /// Read exported macros.\n+    pub fn read_exported_macros(&mut self, krate: &ast::Item) -> Vec<ast::MacroDef> {\n+        let ci = self.extract_crate_info(krate).unwrap();\n+        let ekrate = self.read_extension_crate(krate.span, &ci);\n \n-impl<'a> PluginMetadata<'a> {\n-    /// Read exported macros\n-    pub fn exported_macros(&self) -> Vec<ast::MacroDef> {\n-        let imported_from = Some(token::intern(&self.info.ident[]).ident());\n-        let source_name = format!(\"<{} macros>\", &self.info.ident[]);\n+        let source_name = format!(\"<{} macros>\", krate.ident);\n         let mut macros = vec![];\n-        decoder::each_exported_macro(self.metadata.as_slice(),\n+        decoder::each_exported_macro(ekrate.metadata.as_slice(),\n                                      &*self.sess.cstore.intr,\n             |name, attrs, body| {\n                 // NB: Don't use parse::parse_tts_from_source_str because it parses with\n@@ -558,7 +533,7 @@ impl<'a> PluginMetadata<'a> {\n                     attrs: attrs,\n                     id: ast::DUMMY_NODE_ID,\n                     span: span,\n-                    imported_from: imported_from,\n+                    imported_from: Some(krate.ident),\n                     // overridden in plugin/load.rs\n                     export: false,\n                     use_locally: false,\n@@ -572,28 +547,35 @@ impl<'a> PluginMetadata<'a> {\n     }\n \n     /// Look for a plugin registrar. Returns library path and symbol name.\n-    pub fn plugin_registrar(&self) -> Option<(Path, String)> {\n-        if self.target_only {\n+    pub fn find_plugin_registrar(&mut self, span: Span, name: &str) -> Option<(Path, String)> {\n+        let ekrate = self.read_extension_crate(span, &CrateInfo {\n+             name: name.to_string(),\n+             ident: name.to_string(),\n+             id: ast::DUMMY_NODE_ID,\n+             should_link: false,\n+        });\n+\n+        if ekrate.target_only {\n             // Need to abort before syntax expansion.\n-            let message = format!(\"plugin crate `{}` is not available for triple `{}` \\\n+            let message = format!(\"plugin `{}` is not available for triple `{}` \\\n                                    (only found {})\",\n-                                  self.info.ident,\n+                                  name,\n                                   config::host_triple(),\n                                   self.sess.opts.target_triple);\n-            self.sess.span_err(self.vi_span, &message[]);\n+            self.sess.span_err(span, &message[]);\n             self.sess.abort_if_errors();\n         }\n \n-        let registrar = decoder::get_plugin_registrar_fn(self.metadata.as_slice())\n-            .map(|id| decoder::get_symbol(self.metadata.as_slice(), id));\n+        let registrar = decoder::get_plugin_registrar_fn(ekrate.metadata.as_slice())\n+            .map(|id| decoder::get_symbol(ekrate.metadata.as_slice(), id));\n \n-        match (self.dylib.as_ref(), registrar) {\n+        match (ekrate.dylib.as_ref(), registrar) {\n             (Some(dylib), Some(reg)) => Some((dylib.clone(), reg)),\n             (None, Some(_)) => {\n-                let message = format!(\"plugin crate `{}` only found in rlib format, \\\n+                let message = format!(\"plugin `{}` only found in rlib format, \\\n                                        but must be available in dylib format\",\n-                                       self.info.ident);\n-                self.sess.span_err(self.vi_span, &message[]);\n+                                       name);\n+                self.sess.span_err(span, &message[]);\n                 // No need to abort because the loading code will just ignore this\n                 // empty dylib.\n                 None"}, {"sha": "28c98d455f046dc2e04601c1ce421275b52492af", "filename": "src/librustc/metadata/macro_import.rs", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -0,0 +1,186 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Used by `rustc` when loading a crate with exported macros.\n+\n+use session::Session;\n+use metadata::creader::CrateReader;\n+\n+use std::collections::{HashSet, HashMap};\n+use syntax::ast;\n+use syntax::attr;\n+use syntax::codemap::Span;\n+use syntax::parse::token;\n+use syntax::visit;\n+use syntax::visit::Visitor;\n+use syntax::attr::AttrMetaMethods;\n+\n+struct MacroLoader<'a> {\n+    sess: &'a Session,\n+    span_whitelist: HashSet<Span>,\n+    reader: CrateReader<'a>,\n+    macros: Vec<ast::MacroDef>,\n+}\n+\n+impl<'a> MacroLoader<'a> {\n+    fn new(sess: &'a Session) -> MacroLoader<'a> {\n+        MacroLoader {\n+            sess: sess,\n+            span_whitelist: HashSet::new(),\n+            reader: CrateReader::new(sess),\n+            macros: vec![],\n+        }\n+    }\n+}\n+\n+/// Read exported macros.\n+pub fn read_macro_defs(sess: &Session, krate: &ast::Crate) -> Vec<ast::MacroDef> {\n+    let mut loader = MacroLoader::new(sess);\n+\n+    // We need to error on `#[macro_use] extern crate` when it isn't at the\n+    // crate root, because `$crate` won't work properly. Identify these by\n+    // spans, because the crate map isn't set up yet.\n+    for item in &krate.module.items {\n+        if let ast::ItemExternCrate(_) = item.node {\n+            loader.span_whitelist.insert(item.span);\n+        }\n+    }\n+\n+    visit::walk_crate(&mut loader, krate);\n+\n+    loader.macros\n+}\n+\n+pub type MacroSelection = HashMap<token::InternedString, Span>;\n+\n+// note that macros aren't expanded yet, and therefore macros can't add macro imports.\n+impl<'a, 'v> Visitor<'v> for MacroLoader<'a> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        // We're only interested in `extern crate`.\n+        match item.node {\n+            ast::ItemExternCrate(_) => {}\n+            _ => {\n+                visit::walk_item(self, item);\n+                return;\n+            }\n+        }\n+\n+        // Parse the attributes relating to macros.\n+        let mut import = Some(HashMap::new());  // None => load all\n+        let mut reexport = HashMap::new();\n+\n+        for attr in &item.attrs {\n+            let mut used = true;\n+            match &attr.name()[] {\n+                \"phase\" => {\n+                    self.sess.span_err(attr.span, \"#[phase] is deprecated\");\n+                }\n+                \"plugin\" => {\n+                    self.sess.span_err(attr.span, \"#[plugin] on `extern crate` is deprecated\");\n+                    self.sess.span_help(attr.span, &format!(\"use a crate attribute instead, \\\n+                                                            i.e. #![plugin({})]\",\n+                                                            item.ident.as_str())[]);\n+                }\n+                \"macro_use\" => {\n+                    let names = attr.meta_item_list();\n+                    if names.is_none() {\n+                        // no names => load all\n+                        import = None;\n+                    }\n+                    if let (Some(sel), Some(names)) = (import.as_mut(), names) {\n+                        for attr in names {\n+                            if let ast::MetaWord(ref name) = attr.node {\n+                                sel.insert(name.clone(), attr.span);\n+                            } else {\n+                                self.sess.span_err(attr.span, \"bad macro import\");\n+                            }\n+                        }\n+                    }\n+                }\n+                \"macro_reexport\" => {\n+                    let names = match attr.meta_item_list() {\n+                        Some(names) => names,\n+                        None => {\n+                            self.sess.span_err(attr.span, \"bad macro reexport\");\n+                            continue;\n+                        }\n+                    };\n+\n+                    for attr in names {\n+                        if let ast::MetaWord(ref name) = attr.node {\n+                            reexport.insert(name.clone(), attr.span);\n+                        } else {\n+                            self.sess.span_err(attr.span, \"bad macro reexport\");\n+                        }\n+                    }\n+                }\n+                _ => used = false,\n+            }\n+            if used {\n+                attr::mark_used(attr);\n+            }\n+        }\n+\n+        self.load_macros(item, import, reexport)\n+    }\n+\n+    fn visit_mac(&mut self, _: &ast::Mac) {\n+        // bummer... can't see macro imports inside macros.\n+        // do nothing.\n+    }\n+}\n+\n+impl<'a> MacroLoader<'a> {\n+    fn load_macros<'b>(&mut self,\n+                       vi: &ast::Item,\n+                       import: Option<MacroSelection>,\n+                       reexport: MacroSelection) {\n+        if let Some(sel) = import.as_ref() {\n+            if sel.is_empty() && reexport.is_empty() {\n+                return;\n+            }\n+        }\n+\n+        if !self.span_whitelist.contains(&vi.span) {\n+            self.sess.span_err(vi.span, \"an `extern crate` loading macros must be at \\\n+                                         the crate root\");\n+            return;\n+        }\n+\n+        let macros = self.reader.read_exported_macros(vi);\n+        let mut seen = HashSet::new();\n+\n+        for mut def in macros {\n+            let name = token::get_ident(def.ident);\n+            seen.insert(name.clone());\n+\n+            def.use_locally = match import.as_ref() {\n+                None => true,\n+                Some(sel) => sel.contains_key(&name),\n+            };\n+            def.export = reexport.contains_key(&name);\n+            self.macros.push(def);\n+        }\n+\n+        if let Some(sel) = import.as_ref() {\n+            for (name, span) in sel.iter() {\n+                if !seen.contains(name) {\n+                    self.sess.span_err(*span, \"imported macro not found\");\n+                }\n+            }\n+        }\n+\n+        for (name, span) in reexport.iter() {\n+            if !seen.contains(name) {\n+                self.sess.span_err(*span, \"reexported macro not found\");\n+            }\n+        }\n+    }\n+}"}, {"sha": "0bf1e6d198fa2ad1fab28f8f611c6d4ae06a7c24", "filename": "src/librustc/metadata/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustc%2Fmetadata%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustc%2Fmetadata%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmod.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -18,3 +18,4 @@ pub mod cstore;\n pub mod csearch;\n pub mod loader;\n pub mod filesearch;\n+pub mod macro_import;"}, {"sha": "e27e7a80246858058081618883503e7c0b5daa74", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -530,6 +530,8 @@ impl<'a,T> Iterator for EnumeratedItems<'a,T> {\n     }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T> IntoIterator for VecPerParamSpace<T> {\n     type IntoIter = IntoIter<T>;\n \n@@ -538,7 +540,29 @@ impl<T> IntoIterator for VecPerParamSpace<T> {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<T> IntoIterator for VecPerParamSpace<T> {\n+    type Item = T;\n+    type IntoIter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.into_vec().into_iter()\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n+impl<'a,T> IntoIterator for &'a VecPerParamSpace<T> {\n+    type IntoIter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.as_slice().into_iter()\n+    }\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n impl<'a,T> IntoIterator for &'a VecPerParamSpace<T> {\n+    type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n \n     fn into_iter(self) -> Iter<'a, T> {"}, {"sha": "1895cbcb5421e341f051dd3b4c6109b8dc6f811e", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 21, "deletions": 190, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -8,24 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Used by `rustc` when loading a plugin, or a crate with exported macros.\n+//! Used by `rustc` when loading a plugin.\n \n use session::Session;\n-use metadata::creader::{CrateOrString, CrateReader};\n+use metadata::creader::CrateReader;\n use plugin::registry::Registry;\n \n use std::mem;\n use std::env;\n use std::dynamic_lib::DynamicLibrary;\n-use std::collections::{HashSet, HashMap};\n use std::borrow::ToOwned;\n use syntax::ast;\n-use syntax::attr;\n use syntax::codemap::{Span, COMMAND_LINE_SP};\n-use syntax::parse::token;\n use syntax::ptr::P;\n-use syntax::visit;\n-use syntax::visit::Visitor;\n use syntax::attr::AttrMetaMethods;\n \n /// Pointer to a registrar function.\n@@ -37,51 +32,17 @@ pub struct PluginRegistrar {\n     pub args: Vec<P<ast::MetaItem>>,\n }\n \n-/// Information about loaded plugins.\n-pub struct Plugins {\n-    /// Imported macros.\n-    pub macros: Vec<ast::MacroDef>,\n-    /// Registrars, as function pointers.\n-    pub registrars: Vec<PluginRegistrar>,\n-}\n-\n-pub struct PluginLoader<'a> {\n+struct PluginLoader<'a> {\n     sess: &'a Session,\n-    span_whitelist: HashSet<Span>,\n     reader: CrateReader<'a>,\n-    pub plugins: Plugins,\n-}\n-\n-impl<'a> PluginLoader<'a> {\n-    fn new(sess: &'a Session) -> PluginLoader<'a> {\n-        PluginLoader {\n-            sess: sess,\n-            reader: CrateReader::new(sess),\n-            span_whitelist: HashSet::new(),\n-            plugins: Plugins {\n-                macros: vec!(),\n-                registrars: vec!(),\n-            },\n-        }\n-    }\n+    plugins: Vec<PluginRegistrar>,\n }\n \n /// Read plugin metadata and dynamically load registrar functions.\n pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n-                    addl_plugins: Option<Vec<String>>) -> Plugins {\n+                    addl_plugins: Option<Vec<String>>) -> Vec<PluginRegistrar> {\n     let mut loader = PluginLoader::new(sess);\n \n-    // We need to error on `#[macro_use] extern crate` when it isn't at the\n-    // crate root, because `$crate` won't work properly. Identify these by\n-    // spans, because the crate map isn't set up yet.\n-    for item in &krate.module.items {\n-        if let ast::ItemExternCrate(_) = item.node {\n-            loader.span_whitelist.insert(item.span);\n-        }\n-    }\n-\n-    visit::walk_crate(&mut loader, krate);\n-\n     for attr in &krate.attrs {\n         if !attr.check_name(\"plugin\") {\n             continue;\n@@ -102,165 +63,43 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n             }\n \n             let args = plugin.meta_item_list().map(ToOwned::to_owned).unwrap_or_default();\n-            loader.load_plugin(CrateOrString::Str(plugin.span, &*plugin.name()),\n-                               args);\n+            loader.load_plugin(plugin.span, &*plugin.name(), args);\n         }\n     }\n \n     if let Some(plugins) = addl_plugins {\n         for plugin in plugins {\n-            loader.load_plugin(CrateOrString::Str(COMMAND_LINE_SP, &plugin), vec![]);\n-        }\n-    }\n-\n-    return loader.plugins;\n-}\n-\n-pub type MacroSelection = HashMap<token::InternedString, Span>;\n-\n-// note that macros aren't expanded yet, and therefore macros can't add plugins.\n-impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n-        // We're only interested in `extern crate`.\n-        match item.node {\n-            ast::ItemExternCrate(_) => {}\n-            _ => {\n-                visit::walk_item(self, item);\n-                return;\n-            }\n-        }\n-\n-        // Parse the attributes relating to macro loading.\n-        let mut import = Some(HashMap::new());  // None => load all\n-        let mut reexport = HashMap::new();\n-        for attr in &item.attrs {\n-            let mut used = true;\n-            match &attr.name()[] {\n-                \"phase\" => {\n-                    self.sess.span_err(attr.span, \"#[phase] is deprecated\");\n-                }\n-                \"plugin\" => {\n-                    self.sess.span_err(attr.span, \"#[plugin] on `extern crate` is deprecated\");\n-                    self.sess.span_help(attr.span, &format!(\"use a crate attribute instead, \\\n-                                                            i.e. #![plugin({})]\",\n-                                                            item.ident.as_str())[]);\n-                }\n-                \"macro_use\" => {\n-                    let names = attr.meta_item_list();\n-                    if names.is_none() {\n-                        // no names => load all\n-                        import = None;\n-                    }\n-                    if let (Some(sel), Some(names)) = (import.as_mut(), names) {\n-                        for attr in names {\n-                            if let ast::MetaWord(ref name) = attr.node {\n-                                sel.insert(name.clone(), attr.span);\n-                            } else {\n-                                self.sess.span_err(attr.span, \"bad macro import\");\n-                            }\n-                        }\n-                    }\n-                }\n-                \"macro_reexport\" => {\n-                    let names = match attr.meta_item_list() {\n-                        Some(names) => names,\n-                        None => {\n-                            self.sess.span_err(attr.span, \"bad macro reexport\");\n-                            continue;\n-                        }\n-                    };\n-\n-                    for attr in names {\n-                        if let ast::MetaWord(ref name) = attr.node {\n-                            reexport.insert(name.clone(), attr.span);\n-                        } else {\n-                            self.sess.span_err(attr.span, \"bad macro reexport\");\n-                        }\n-                    }\n-                }\n-                _ => used = false,\n-            }\n-            if used {\n-                attr::mark_used(attr);\n-            }\n+            loader.load_plugin(COMMAND_LINE_SP, &plugin, vec![]);\n         }\n-\n-        self.load_macros(item, import, reexport)\n     }\n \n-    fn visit_mac(&mut self, _: &ast::Mac) {\n-        // bummer... can't see plugins inside macros.\n-        // do nothing.\n-    }\n+    loader.plugins\n }\n \n impl<'a> PluginLoader<'a> {\n-    pub fn load_macros<'b>(&mut self,\n-                           vi: &ast::Item,\n-                           import: Option<MacroSelection>,\n-                           reexport: MacroSelection) {\n-        if let Some(sel) = import.as_ref() {\n-            if sel.is_empty() && reexport.is_empty() {\n-                return;\n-            }\n-        }\n-\n-        if !self.span_whitelist.contains(&vi.span) {\n-            self.sess.span_err(vi.span, \"an `extern crate` loading macros must be at \\\n-                                         the crate root\");\n-            return;\n-        }\n-\n-        let pmd = self.reader.read_plugin_metadata(CrateOrString::Krate(vi));\n-\n-        let mut seen = HashSet::new();\n-        for mut def in pmd.exported_macros() {\n-            let name = token::get_ident(def.ident);\n-            seen.insert(name.clone());\n-\n-            def.use_locally = match import.as_ref() {\n-                None => true,\n-                Some(sel) => sel.contains_key(&name),\n-            };\n-            def.export = reexport.contains_key(&name);\n-            self.plugins.macros.push(def);\n-        }\n-\n-        if let Some(sel) = import.as_ref() {\n-            for (name, span) in sel.iter() {\n-                if !seen.contains(name) {\n-                    self.sess.span_err(*span, \"imported macro not found\");\n-                }\n-            }\n-        }\n-\n-        for (name, span) in reexport.iter() {\n-            if !seen.contains(name) {\n-                self.sess.span_err(*span, \"reexported macro not found\");\n-            }\n+    fn new(sess: &'a Session) -> PluginLoader<'a> {\n+        PluginLoader {\n+            sess: sess,\n+            reader: CrateReader::new(sess),\n+            plugins: vec![],\n         }\n     }\n \n-    pub fn load_plugin<'b>(&mut self,\n-                           c: CrateOrString<'b>,\n-                           args: Vec<P<ast::MetaItem>>) {\n-        let registrar = {\n-            let pmd = self.reader.read_plugin_metadata(c);\n-            pmd.plugin_registrar()\n-        };\n+    fn load_plugin(&mut self, span: Span, name: &str, args: Vec<P<ast::MetaItem>>) {\n+        let registrar = self.reader.find_plugin_registrar(span, name);\n \n         if let Some((lib, symbol)) = registrar {\n-            let fun = self.dylink_registrar(c, lib, symbol);\n-            self.plugins.registrars.push(PluginRegistrar {\n+            let fun = self.dylink_registrar(span, lib, symbol);\n+            self.plugins.push(PluginRegistrar {\n                 fun: fun,\n                 args: args,\n             });\n         }\n     }\n \n     // Dynamically link a registrar function into the compiler process.\n-    fn dylink_registrar<'b>(&mut self,\n-                        c: CrateOrString<'b>,\n+    fn dylink_registrar(&mut self,\n+                        span: Span,\n                         path: Path,\n                         symbol: String) -> PluginRegistrarFun {\n         // Make sure the path contains a / or the linker will search for it.\n@@ -272,11 +111,7 @@ impl<'a> PluginLoader<'a> {\n             // inside this crate, so continue would spew \"macro undefined\"\n             // errors\n             Err(err) => {\n-                if let CrateOrString::Krate(cr) = c {\n-                    self.sess.span_fatal(cr.span, &err[])\n-                } else {\n-                    self.sess.fatal(&err[])\n-                }\n+                self.sess.span_fatal(span, &err[])\n             }\n         };\n \n@@ -288,11 +123,7 @@ impl<'a> PluginLoader<'a> {\n                     }\n                     // again fatal if we can't register macros\n                     Err(err) => {\n-                        if let CrateOrString::Krate(cr) = c {\n-                            self.sess.span_fatal(cr.span, &err[])\n-                        } else {\n-                            self.sess.fatal(&err[])\n-                        }\n+                        self.sess.span_fatal(span, &err[])\n                     }\n                 };\n "}, {"sha": "eb1dba7159cf8a537b1633b463703c5c4e9b72b3", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -12,11 +12,11 @@ use rustc::session::Session;\n use rustc::session::config::{self, Input, OutputFilenames};\n use rustc::session::search_paths::PathKind;\n use rustc::lint;\n+use rustc::metadata;\n use rustc::metadata::creader::CrateReader;\n use rustc::middle::{stability, ty, reachable};\n use rustc::middle::dependency_format;\n use rustc::middle;\n-use rustc::plugin::load::Plugins;\n use rustc::plugin::registry::Registry;\n use rustc::plugin;\n use rustc::util::common::time;\n@@ -409,10 +409,12 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n                  syntax::std_inject::maybe_inject_crates_ref(krate,\n                                                              sess.opts.alt_std_name.clone()));\n \n+    let macros = time(time_passes, \"macro loading\", (), |_|\n+        metadata::macro_import::read_macro_defs(sess, &krate));\n+\n     let mut addl_plugins = Some(addl_plugins);\n-    let Plugins { macros, registrars }\n-        = time(time_passes, \"plugin loading\", (), |_|\n-               plugin::load::load_plugins(sess, &krate, addl_plugins.take().unwrap()));\n+    let registrars = time(time_passes, \"plugin loading\", (), |_|\n+        plugin::load::load_plugins(sess, &krate, addl_plugins.take().unwrap()));\n \n     let mut registry = Registry::new(sess, &krate);\n "}, {"sha": "213e356536246bb60631baafed5a218c5dbc61b1", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -436,50 +436,73 @@ pub enum DiagnosticKind {\n }\n \n // Opaque pointer types\n+#[allow(missing_copy_implementations)]\n pub enum Module_opaque {}\n pub type ModuleRef = *mut Module_opaque;\n+#[allow(missing_copy_implementations)]\n pub enum Context_opaque {}\n pub type ContextRef = *mut Context_opaque;\n+#[allow(missing_copy_implementations)]\n pub enum Type_opaque {}\n pub type TypeRef = *mut Type_opaque;\n+#[allow(missing_copy_implementations)]\n pub enum Value_opaque {}\n pub type ValueRef = *mut Value_opaque;\n+#[allow(missing_copy_implementations)]\n pub enum Metadata_opaque {}\n pub type MetadataRef = *mut Metadata_opaque;\n+#[allow(missing_copy_implementations)]\n pub enum BasicBlock_opaque {}\n pub type BasicBlockRef = *mut BasicBlock_opaque;\n+#[allow(missing_copy_implementations)]\n pub enum Builder_opaque {}\n pub type BuilderRef = *mut Builder_opaque;\n+#[allow(missing_copy_implementations)]\n pub enum ExecutionEngine_opaque {}\n pub type ExecutionEngineRef = *mut ExecutionEngine_opaque;\n+#[allow(missing_copy_implementations)]\n pub enum RustJITMemoryManager_opaque {}\n pub type RustJITMemoryManagerRef = *mut RustJITMemoryManager_opaque;\n+#[allow(missing_copy_implementations)]\n pub enum MemoryBuffer_opaque {}\n pub type MemoryBufferRef = *mut MemoryBuffer_opaque;\n+#[allow(missing_copy_implementations)]\n pub enum PassManager_opaque {}\n pub type PassManagerRef = *mut PassManager_opaque;\n+#[allow(missing_copy_implementations)]\n pub enum PassManagerBuilder_opaque {}\n pub type PassManagerBuilderRef = *mut PassManagerBuilder_opaque;\n+#[allow(missing_copy_implementations)]\n pub enum Use_opaque {}\n pub type UseRef = *mut Use_opaque;\n+#[allow(missing_copy_implementations)]\n pub enum TargetData_opaque {}\n pub type TargetDataRef = *mut TargetData_opaque;\n+#[allow(missing_copy_implementations)]\n pub enum ObjectFile_opaque {}\n pub type ObjectFileRef = *mut ObjectFile_opaque;\n+#[allow(missing_copy_implementations)]\n pub enum SectionIterator_opaque {}\n pub type SectionIteratorRef = *mut SectionIterator_opaque;\n+#[allow(missing_copy_implementations)]\n pub enum Pass_opaque {}\n pub type PassRef = *mut Pass_opaque;\n+#[allow(missing_copy_implementations)]\n pub enum TargetMachine_opaque {}\n pub type TargetMachineRef = *mut TargetMachine_opaque;\n+#[allow(missing_copy_implementations)]\n pub enum Archive_opaque {}\n pub type ArchiveRef = *mut Archive_opaque;\n+#[allow(missing_copy_implementations)]\n pub enum Twine_opaque {}\n pub type TwineRef = *mut Twine_opaque;\n+#[allow(missing_copy_implementations)]\n pub enum DiagnosticInfo_opaque {}\n pub type DiagnosticInfoRef = *mut DiagnosticInfo_opaque;\n+#[allow(missing_copy_implementations)]\n pub enum DebugLoc_opaque {}\n pub type DebugLocRef = *mut DebugLoc_opaque;\n+#[allow(missing_copy_implementations)]\n pub enum SMDiagnostic_opaque {}\n pub type SMDiagnosticRef = *mut SMDiagnostic_opaque;\n \n@@ -490,6 +513,7 @@ pub mod debuginfo {\n     pub use self::DIDescriptorFlags::*;\n     use super::{MetadataRef};\n \n+    #[allow(missing_copy_implementations)]\n     pub enum DIBuilder_opaque {}\n     pub type DIBuilderRef = *mut DIBuilder_opaque;\n \n@@ -2192,6 +2216,7 @@ pub fn get_param(llfn: ValueRef, index: c_uint) -> ValueRef {\n     }\n }\n \n+#[allow(missing_copy_implementations)]\n pub enum RustString_opaque {}\n pub type RustStringRef = *mut RustString_opaque;\n type RustStringRepr = *mut RefCell<Vec<u8>>;"}, {"sha": "e6cd44676cefb6a11dca91a98c3277d369739163", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -339,7 +339,7 @@ pub fn trans_ret<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = bcx;\n     let dest = match (fcx.llretslotptr.get(), retval_expr) {\n         (Some(_), Some(retval_expr)) => {\n-            let ret_ty = expr_ty(bcx, &*retval_expr);\n+            let ret_ty = expr_ty_adjusted(bcx, &*retval_expr);\n             expr::SaveIn(fcx.get_ret_slot(bcx, ty::FnConverging(ret_ty), \"ret_slot\"))\n         }\n         _ => expr::Ignore,"}, {"sha": "f43469363cd81f435c03b018bac9cf8d606fd8a7", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -88,15 +88,10 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n                     Err(traits::OrphanCheckErr::UncoveredTy(param_ty)) => {\n                         if !ty::has_attr(self.tcx, trait_def_id, \"old_orphan_check\") {\n                             span_err!(self.tcx.sess, item.span, E0210,\n-                                    \"type parameter `{}` is not constrained by any local type; \\\n-                                     only traits defined in the current crate can be implemented \\\n-                                     for a type parameter\",\n+                                    \"type parameter `{}` must be used as the type parameter for \\\n+                                     some local type (e.g. `MyStruct<T>`); only traits defined in \\\n+                                     the current crate can be implemented for a type parameter\",\n                                     param_ty.user_string(self.tcx));\n-                            self.tcx.sess.span_note(\n-                                item.span,\n-                                &format!(\"for a limited time, you can add \\\n-                                          `#![feature(old_orphan_check)]` to your crate \\\n-                                          to disable this rule\"));\n                         }\n                     }\n                 }"}, {"sha": "44e850a0738001e71c081dd2d6a66b29010a12a1", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -2022,10 +2022,6 @@ fn enforce_impl_ty_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     \"the type parameter `{}` is not constrained by the \\\n                              impl trait, self type, or predicates\",\n                             param_ty.user_string(tcx));\n-                tcx.sess.span_help(\n-                    ty_param.span,\n-                    &format!(\"you can temporarily opt out of this rule by placing \\\n-                              the `#[old_impl_check]` attribute on the impl\"));\n             }\n         }\n     }"}, {"sha": "7ef48378af183415d595255c30b3541896a698b3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -2490,6 +2490,7 @@ pub struct Stability {\n     pub level: attr::StabilityLevel,\n     pub feature: String,\n     pub since: String,\n+    pub deprecated_since: String,\n     pub reason: String\n }\n \n@@ -2500,6 +2501,8 @@ impl Clean<Stability> for attr::Stability {\n             feature: self.feature.to_string(),\n             since: self.since.as_ref().map_or(\"\".to_string(),\n                                               |interned| interned.to_string()),\n+            deprecated_since: self.deprecated_since.as_ref().map_or(\"\".to_string(),\n+                                                                    |istr| istr.to_string()),\n             reason: self.reason.as_ref().map_or(\"\".to_string(),\n                                                 |interned| interned.to_string()),\n         }"}, {"sha": "ed7f051408c45894303ab703902b7d49a155d1a6", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -711,7 +711,11 @@ impl<'a> fmt::Display for Stability<'a> {\n         match *stab {\n             Some(ref stability) => {\n                 write!(f, \"<a class='stability {lvl}' title='{reason}'>{lvl}</a>\",\n-                       lvl = stability.level,\n+                       lvl = if stability.deprecated_since.is_empty() {\n+                           format!(\"{}\", stability.level)\n+                       } else {\n+                           \"Deprecated\".to_string()\n+                       },\n                        reason = stability.reason)\n             }\n             None => Ok(())\n@@ -725,7 +729,11 @@ impl<'a> fmt::Display for ConciseStability<'a> {\n         match *stab {\n             Some(ref stability) => {\n                 write!(f, \"<a class='stability {lvl}' title='{lvl}{colon}{reason}'></a>\",\n-                       lvl = stability.level,\n+                       lvl = if stability.deprecated_since.is_empty() {\n+                           format!(\"{}\", stability.level)\n+                       } else {\n+                           \"Deprecated\".to_string()\n+                       },\n                        colon = if stability.reason.len() > 0 { \": \" } else { \"\" },\n                        reason = stability.reason)\n             }\n@@ -763,6 +771,9 @@ impl fmt::Display for ModuleSummary {\n             try!(write!(f, \"<span class='summary Unstable' \\\n                             style='width: {:.4}%; display: inline-block'>&nbsp</span>\",\n                         (100 * cnt.unstable) as f64/tot as f64));\n+            try!(write!(f, \"<span class='summary Deprecated' \\\n+                            style='width: {:.4}%; display: inline-block'>&nbsp</span>\",\n+                        (100 * cnt.deprecated) as f64/tot as f64));\n             try!(write!(f, \"<span class='summary Unmarked' \\\n                             style='width: {:.4}%; display: inline-block'>&nbsp</span>\",\n                         (100 * cnt.unmarked) as f64/tot as f64));\n@@ -778,11 +789,12 @@ impl fmt::Display for ModuleSummary {\n         let mut context = Vec::new();\n \n         let tot = self.counts.total();\n-        let (stable, unstable, unmarked) = if tot == 0 {\n-            (0, 0, 0)\n+        let (stable, unstable, deprecated, unmarked) = if tot == 0 {\n+            (0, 0, 0, 0)\n         } else {\n             ((100 * self.counts.stable)/tot,\n              (100 * self.counts.unstable)/tot,\n+             (100 * self.counts.deprecated)/tot,\n              (100 * self.counts.unmarked)/tot)\n         };\n \n@@ -794,11 +806,12 @@ its children (percentages total for {name}):\n <blockquote>\n <a class='stability Stable'></a> stable ({}%),<br/>\n <a class='stability Unstable'></a> unstable ({}%),<br/>\n+<a class='stability Deprecated'></a> deprecated ({}%),<br/>\n <a class='stability Unmarked'></a> unmarked ({}%)\n </blockquote>\n The counts do not include methods or trait\n implementations that are visible only through a re-exported type.\",\n-stable, unstable, unmarked,\n+stable, unstable, deprecated, unmarked,\n name=self.name));\n         try!(write!(f, \"<table>\"));\n         try!(fmt_inner(f, &mut context, self));"}, {"sha": "a4263badb013660ab6e28f95a92f1d353e09bf96", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -292,6 +292,27 @@ nav.sub {\n .content td p:first-child { margin-top: 0; }\n .content td h1, .content td h2 { margin-left: 0; font-size: 1.1em; }\n \n+.docblock table {\n+    border: 1px solid #ddd;\n+    margin: .5em 0;\n+    border-collapse: collapse;\n+    width: 100%;\n+}\n+\n+.docblock table td {\n+    padding: .5em;\n+    border-top: 1px dashed #ddd;\n+    border-bottom: 1px dashed #ddd;\n+\n+}\n+\n+.docblock table th {\n+    padding: .5em;\n+    text-align: left;\n+    border-top: 1px solid #ddd;\n+    border-bottom: 1px solid #ddd;\n+}\n+\n .content .item-list {\n     list-style-type: none;\n     padding: 0;"}, {"sha": "47918ba78a270f060a4c684dd6d4adb91d275936", "filename": "src/librustdoc/stability_summary.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -29,18 +29,20 @@ use html::render::cache;\n /// The counts for each stability level.\n #[derive(Copy)]\n pub struct Counts {\n-    pub unstable: uint,\n-    pub stable: uint,\n+    pub deprecated: u64,\n+    pub unstable: u64,\n+    pub stable: u64,\n \n     /// No stability level, inherited or otherwise.\n-    pub unmarked: uint,\n+    pub unmarked: u64,\n }\n \n impl Add for Counts {\n     type Output = Counts;\n \n     fn add(self, other: Counts) -> Counts {\n         Counts {\n+            deprecated:   self.deprecated   + other.deprecated,\n             unstable:     self.unstable     + other.unstable,\n             stable:       self.stable       + other.stable,\n             unmarked:     self.unmarked     + other.unmarked,\n@@ -51,14 +53,15 @@ impl Add for Counts {\n impl Counts {\n     fn zero() -> Counts {\n         Counts {\n+            deprecated:   0,\n             unstable:     0,\n             stable:       0,\n             unmarked:     0,\n         }\n     }\n \n-    pub fn total(&self) -> uint {\n-        self.unstable + self.stable + self.unmarked\n+    pub fn total(&self) -> u64 {\n+        self.deprecated + self.unstable + self.stable + self.unmarked\n     }\n }\n \n@@ -94,9 +97,14 @@ fn visible(item: &Item) -> bool {\n fn count_stability(stab: Option<&Stability>) -> Counts {\n     match stab {\n         None            => Counts { unmarked: 1,     .. Counts::zero() },\n-        Some(ref stab) => match stab.level {\n-            Unstable    => Counts { unstable: 1,     .. Counts::zero() },\n-            Stable      => Counts { stable: 1,       .. Counts::zero() },\n+        Some(ref stab) => {\n+            if !stab.deprecated_since.is_empty() {\n+                return Counts { deprecated: 1, .. Counts::zero() };\n+            }\n+            match stab.level {\n+                Unstable    => Counts { unstable: 1,     .. Counts::zero() },\n+                Stable      => Counts { stable: 1,       .. Counts::zero() },\n+            }\n         }\n     }\n }"}, {"sha": "241e409910f366b859af95528b99f87ac85afb43", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -1372,6 +1372,8 @@ enum VacantEntryState<K, V, M> {\n     NoElem(EmptyBucket<K, V, M>),\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<'a, K, V, S, H> IntoIterator for &'a HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -1384,6 +1386,22 @@ impl<'a, K, V, S, H> IntoIterator for &'a HashMap<K, V, S>\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<'a, K, V, S, H> IntoIterator for &'a HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Item = (&'a K, &'a V);\n+    type IntoIter = Iter<'a, K, V>;\n+\n+    fn into_iter(self) -> Iter<'a, K, V> {\n+        self.iter()\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<'a, K, V, S, H> IntoIterator for &'a mut HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -1396,6 +1414,22 @@ impl<'a, K, V, S, H> IntoIterator for &'a mut HashMap<K, V, S>\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<'a, K, V, S, H> IntoIterator for &'a mut HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Item = (&'a K, &'a mut V);\n+    type IntoIter = IterMut<'a, K, V>;\n+\n+    fn into_iter(mut self) -> IterMut<'a, K, V> {\n+        self.iter_mut()\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<K, V, S, H> IntoIterator for HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -1408,6 +1442,20 @@ impl<K, V, S, H> IntoIterator for HashMap<K, V, S>\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<K, V, S, H> IntoIterator for HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Item = (K, V);\n+    type IntoIter = IntoIter<K, V>;\n+\n+    fn into_iter(self) -> IntoIter<K, V> {\n+        self.into_iter()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     type Item = (&'a K, &'a V);"}, {"sha": "300e208931765087bea28a51755e4399914cf66a", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -835,6 +835,8 @@ pub struct Union<'a, T: 'a, S: 'a> {\n     iter: Chain<Iter<'a, T>, Difference<'a, T, S>>\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<'a, T, S, H> IntoIterator for &'a HashSet<T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -847,11 +849,41 @@ impl<'a, T, S, H> IntoIterator for &'a HashSet<T, S>\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<'a, T, S, H> IntoIterator for &'a HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Item = &'a T;\n+    type IntoIter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n+impl<T, S, H> IntoIterator for HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type IntoIter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.into_iter()\n+    }\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n impl<T, S, H> IntoIterator for HashSet<T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n           H: hash::Hasher<Output=u64>\n {\n+    type Item = T;\n     type IntoIter = IntoIter<T>;\n \n     fn into_iter(self) -> IntoIter<T> {"}, {"sha": "5f91d173ed2acfaead56b000d3e675805fa34fef", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -112,10 +112,10 @@ impl File {\n         OpenOptions::new().read(true).open(path)\n     }\n \n-    /// Creates a open a file in write-only mode.\n+    /// Open a file in write-only mode.\n     ///\n-    /// This method will attempt to open a new file, truncating it if it already\n-    /// exists.\n+    /// This function will create a file it it does not exist,\n+    /// and will truncate it if it does.\n     ///\n     /// See the `OpenOptions::open` function for more details.\n     pub fn create<P: AsPath + ?Sized>(path: &P) -> io::Result<File> {"}, {"sha": "740a45feb3d1c96761c147f94e4f94973525eb89", "filename": "src/libstd/os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -132,7 +132,7 @@ pub fn env() -> Vec<(String,String)> {\n \n /// Returns a vector of (variable, value) byte-vector pairs for all the\n /// environment variables of the current process.\n-#[deprecated(since = \"1.0.0\", reason = \"use env::vars instead\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use env::vars_os instead\")]\n #[unstable(feature = \"os\")]\n pub fn env_as_bytes() -> Vec<(Vec<u8>, Vec<u8>)> {\n     env::vars_os().map(|(k, v)| (byteify(k), byteify(v))).collect()\n@@ -159,7 +159,7 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>, Vec<u8>)> {\n ///     None => println!(\"{} is not defined in the environment.\", key)\n /// }\n /// ```\n-#[deprecated(since = \"1.0.0\", reason = \"use env::var or env::var_os instead\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use env::var instead\")]\n #[unstable(feature = \"os\")]\n pub fn getenv(n: &str) -> Option<String> {\n     env::var(n).ok()\n@@ -171,7 +171,7 @@ pub fn getenv(n: &str) -> Option<String> {\n /// # Panics\n ///\n /// Panics if `n` has any interior NULs.\n-#[deprecated(since = \"1.0.0\", reason = \"use env::var instead\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use env::var_os instead\")]\n #[unstable(feature = \"os\")]\n pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n     env::var_os(n).map(byteify)\n@@ -732,7 +732,7 @@ pub fn args() -> Vec<String> {\n \n /// Returns the arguments which this program was started with (normally passed\n /// via the command line) as byte vectors.\n-#[deprecated(since = \"1.0.0\", reason = \"use env::args_raw instead\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use env::args_os instead\")]\n #[unstable(feature = \"os\")]\n pub fn args_as_bytes() -> Vec<Vec<u8>> {\n     real_args_as_bytes()"}, {"sha": "b45878584e02d0a957de8a86ea7d5957d57ae051", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -292,7 +292,6 @@ pub mod eabi {\n \n     #[lang=\"eh_personality\"]\n     #[no_mangle] // referenced from rust_try.ll\n-    #[allow(private_no_mangle_fns)]\n     pub extern \"C\" fn rust_eh_personality(\n         version: c_int,\n         actions: uw::_Unwind_Action,"}, {"sha": "0ee2b5b68090ede1123950edbb95c94059d8ed8a", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -364,7 +364,10 @@ mod tests {\n     use os;\n     use prelude::v1::*;\n \n-    #[cfg_attr(target_os = \"freebsd\", ignore)] // hmm, maybe pipes have a tiny buffer\n+    #[cfg_attr(any(target_os = \"freebsd\",\n+                   target_os = \"openbsd\"),\n+               ignore)]\n+    // under some system, pipe(2) will return a bidrectionnal pipe\n     #[test]\n     fn test_file_desc() {\n         // Run this test with some pipes so we don't have to mess around with"}, {"sha": "a8466465f871bdce7c2c0cc15e208a0aa4460ac2", "filename": "src/rustbook/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fmain.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -50,7 +50,7 @@ fn main() {\n     let mut term = Term::new();\n     let cmd = os::args();\n \n-    if cmd.len() < 1 {\n+    if cmd.len() <= 1 {\n         help::usage()\n     } else {\n         match subcommand::parse_name(&cmd[1][]) {"}, {"sha": "7647f159401a74412b0590625e37d5102536f7d0", "filename": "src/test/auxiliary/orphan_check_diagnostics.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fauxiliary%2Forphan_check_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fauxiliary%2Forphan_check_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Forphan_check_diagnostics.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait RemoteTrait {}"}, {"sha": "cfc8c015324d9384edfcbb88cb5f8b47717b39df", "filename": "src/test/auxiliary/plugin_with_plugin_lib.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fauxiliary%2Fplugin_with_plugin_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fauxiliary%2Fplugin_with_plugin_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fplugin_with_plugin_lib.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+\n+#![feature(plugin_registrar)]\n+#![deny(plugin_as_library)] // should have no effect in a plugin crate\n+\n+extern crate macro_crate_test;\n+extern crate rustc;\n+\n+use rustc::plugin::Registry;\n+\n+#[plugin_registrar]\n+pub fn plugin_registrar(_: &mut Registry) { }"}, {"sha": "7a362994b8db6fe6948a3cd8bfef77b0e324118b", "filename": "src/test/compile-fail-fulldeps/macro-crate-rlib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-rlib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-rlib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-rlib.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -16,6 +16,6 @@\n \n #![feature(plugin)]\n #![plugin(rlib_crate_test)]\n-//~^ ERROR: plugin crate `rlib_crate_test` only found in rlib format, but must be available in dylib format\n+//~^ ERROR: plugin `rlib_crate_test` only found in rlib format, but must be available in dylib format\n \n fn main() {}"}, {"sha": "c5169b61a2bf9df2dbe58a3d3f041aec3734c9d9", "filename": "src/test/compile-fail-fulldeps/plugin-as-extern-crate.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fcompile-fail-fulldeps%2Fplugin-as-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fcompile-fail-fulldeps%2Fplugin-as-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fplugin-as-extern-crate.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_crate_test.rs\n+// ignore-stage1\n+// ignore-cross-compile\n+//\n+// macro_crate_test will not compile on a cross-compiled target because\n+// libsyntax is not compiled for it.\n+\n+#![deny(plugin_as_library)]\n+\n+extern crate macro_crate_test; //~ ERROR compiler plugin used as an ordinary library\n+\n+fn main() { }"}, {"sha": "3dfd8838ebec40ca172830f79e3106a4a77690ae", "filename": "src/test/compile-fail-fulldeps/plugin-plus-extern-crate.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fcompile-fail-fulldeps%2Fplugin-plus-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fcompile-fail-fulldeps%2Fplugin-plus-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fplugin-plus-extern-crate.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_crate_test.rs\n+// ignore-stage1\n+// ignore-cross-compile\n+//\n+// macro_crate_test will not compile on a cross-compiled target because\n+// libsyntax is not compiled for it.\n+\n+#![deny(plugin_as_library)]\n+#![feature(plugin)]\n+#![plugin(macro_crate_test)]\n+\n+extern crate macro_crate_test; //~ ERROR compiler plugin used as an ordinary library\n+\n+fn main() {\n+    assert_eq!(1, make_a_1!());\n+    macro_crate_test::foo();\n+}"}, {"sha": "b7ca499be736623db82a570eccbda76c7718a28e", "filename": "src/test/compile-fail/coherence-bigint-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fcompile-fail%2Fcoherence-bigint-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fcompile-fail%2Fcoherence-bigint-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-bigint-param.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -16,6 +16,6 @@ use lib::Remote1;\n pub struct BigInt;\n \n impl<T> Remote1<BigInt> for T { }\n-//~^ ERROR type parameter `T` is not constrained\n+//~^ ERROR type parameter `T` must be used as the type parameter for some local type\n \n fn main() { }"}, {"sha": "1bec97de53386a4020f4ef071327b69a8a51f28a", "filename": "src/test/compile-fail/coherence-cow-no-cover.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fcompile-fail%2Fcoherence-cow-no-cover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fcompile-fail%2Fcoherence-cow-no-cover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-cow-no-cover.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -18,6 +18,6 @@ use lib::{Remote,Pair};\n pub struct Cover<T>(T);\n \n impl<T,U> Remote for Pair<Cover<T>,U> { }\n-//~^ ERROR type parameter `U` is not constrained by any local type\n+//~^ ERROR type parameter `U` must be used as the type parameter for some local type\n \n fn main() { }"}, {"sha": "a020b518d8273a9ad0e1d6b1812f07cd7c9900ce", "filename": "src/test/compile-fail/coherence-cross-crate-conflict.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fcompile-fail%2Fcoherence-cross-crate-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fcompile-fail%2Fcoherence-cross-crate-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-cross-crate-conflict.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -16,7 +16,7 @@ extern crate trait_impl_conflict;\n use trait_impl_conflict::Foo;\n \n impl<A> Foo for A {\n-    //~^ ERROR type parameter `A` is not constrained\n+    //~^ ERROR type parameter `A` must be used as the type parameter for some local type\n     //~^^ ERROR E0119\n }\n "}, {"sha": "9f7481f12f2f7d3201c3b0bcf629b8f34615194d", "filename": "src/test/compile-fail/coherence-lone-type-parameter.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fcompile-fail%2Fcoherence-lone-type-parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fcompile-fail%2Fcoherence-lone-type-parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-lone-type-parameter.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -13,6 +13,7 @@\n extern crate \"coherence-lib\" as lib;\n use lib::Remote;\n \n-impl<T> Remote for T { } //~ ERROR type parameter `T` is not constrained\n+impl<T> Remote for T { }\n+//~^ ERROR type parameter `T` must be used as the type parameter for some local type\n \n fn main() { }"}, {"sha": "9878bdec2c36ffc56100fbffe72ad6c1716389f7", "filename": "src/test/compile-fail/coherence-overlapping-pairs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fcompile-fail%2Fcoherence-overlapping-pairs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fcompile-fail%2Fcoherence-overlapping-pairs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-overlapping-pairs.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -16,6 +16,6 @@ use lib::Remote;\n struct Foo;\n \n impl<T> Remote for lib::Pair<T,Foo> { }\n-//~^ ERROR type parameter `T` is not constrained\n+//~^ ERROR type parameter `T` must be used as the type parameter for some local type\n \n fn main() { }"}, {"sha": "2bdcc346f70d3055193c616afa1324ece4c7f08e", "filename": "src/test/compile-fail/coherence-pair-covered-uncovered-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fcompile-fail%2Fcoherence-pair-covered-uncovered-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fcompile-fail%2Fcoherence-pair-covered-uncovered-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-pair-covered-uncovered-1.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -18,7 +18,7 @@ use lib::{Remote1, Pair};\n \n pub struct Local<T>(T);\n \n-impl<T,U> Remote1<Pair<T,Local<U>>> for i32 { }\n-//~^ ERROR type parameter `T` is not constrained\n+impl<T, U> Remote1<Pair<T, Local<U>>> for i32 { }\n+//~^ ERROR type parameter `T` must be used as the type parameter for some local type\n \n fn main() { }"}, {"sha": "881494f009f1576784b3f10d345ffa88e94d83bb", "filename": "src/test/compile-fail/coherence-pair-covered-uncovered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fcompile-fail%2Fcoherence-pair-covered-uncovered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fcompile-fail%2Fcoherence-pair-covered-uncovered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-pair-covered-uncovered.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -16,6 +16,6 @@ use lib::{Remote, Pair};\n struct Local<T>(T);\n \n impl<T,U> Remote for Pair<T,Local<U>> { }\n-//~^ ERROR type parameter `T` is not constrained\n+//~^ ERROR type parameter `T` must be used as the type parameter for some local type\n \n fn main() { }"}, {"sha": "ff5c101b9178f60a5998d9e0fffb0142017fb1a9", "filename": "src/test/compile-fail/orphan-check-diagnostics.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fcompile-fail%2Forphan-check-diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fcompile-fail%2Forphan-check-diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Forphan-check-diagnostics.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:orphan_check_diagnostics.rs\n+// see #22388\n+\n+extern crate orphan_check_diagnostics;\n+\n+use orphan_check_diagnostics::RemoteTrait;\n+\n+trait LocalTrait {}\n+\n+impl<T> RemoteTrait for T where T: LocalTrait {}\n+//~^ ERROR type parameter `T` must be used as the type parameter for some local type\n+\n+fn main() {}"}, {"sha": "aa902a9b2d4ade48db06cde5dbc70a7372a5373d", "filename": "src/test/debuginfo/gdb-pretty-struct-and-enums-pre-gdb-7-7.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums-pre-gdb-7-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums-pre-gdb-7-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums-pre-gdb-7-7.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -13,6 +13,7 @@\n // gdb-pretty-struct-and-enums.rs\n \n // ignore-windows failing on win32 bot\n+// ignore-freebsd: gdb package too new\n // ignore-tidy-linelength\n // ignore-lldb\n // ignore-android: FIXME(#10381)"}, {"sha": "d9a7e7406eb735144324301876cebc12ac6e58c4", "filename": "src/test/debuginfo/gdb-pretty-struct-and-enums.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // ignore-windows failing on win32 bot\n+// ignore-freebsd: output doesn't match\n // ignore-tidy-linelength\n // ignore-lldb\n // ignore-android: FIXME(#10381)"}, {"sha": "f8abc5019b4fd87f98de63a10fa8d19d8a7e503f", "filename": "src/test/run-make/use-extern-for-plugins/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Frun-make%2Fuse-extern-for-plugins%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Frun-make%2Fuse-extern-for-plugins%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fuse-extern-for-plugins%2FMakefile?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -1,6 +1,6 @@\n -include ../tools.mk\n \n-ifneq ($(UNAME),OpenBSD)\n+ifneq ($(findstring BSD,$(UNAME)),BSD)\n HOST := $(shell $(RUSTC) -vV | grep 'host:' | sed 's/host: //')\n ifeq ($(findstring i686,$(HOST)),i686)\n TARGET := $(subst i686,x86_64,$(HOST))\n@@ -13,6 +13,6 @@ all:\n \t$(RUSTC) bar.rs -C extra-filename=-targ --target $(TARGET)\n \t$(RUSTC) baz.rs --extern a=$(TMPDIR)/liba-targ.rlib --target $(TARGET)\n else\n-# OpenBSD support only x86_64 architecture for now\n+# FreeBSD & OpenBSD support only x86_64 architecture for now\n all:\n endif"}, {"sha": "c612ee75651bab413affb5a0cb4cb1a3ee869347", "filename": "src/test/run-pass-fulldeps/plugin-lib-ok-in-plugin.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-lib-ok-in-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-lib-ok-in-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-lib-ok-in-plugin.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_crate_test.rs\n+// aux-build:plugin_with_plugin_lib.rs\n+// ignore-stage1\n+// ignore-cross-compile\n+//\n+// macro_crate_test will not compile on a cross-compiled target because\n+// libsyntax is not compiled for it.\n+\n+#![deny(plugin_as_library)]\n+#![feature(plugin)]\n+#![plugin(macro_crate_test)]\n+#![plugin(plugin_with_plugin_lib)]\n+\n+fn main() {\n+    assert_eq!(1, make_a_1!());\n+}"}, {"sha": "d1ce83f26778847cbb484ea8abc392d9cf9425c4", "filename": "src/test/run-pass-fulldeps/plugin-plus-extern-crate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-plus-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-plus-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-plus-extern-crate.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -15,6 +15,7 @@\n // macro_crate_test will not compile on a cross-compiled target because\n // libsyntax is not compiled for it.\n \n+#![allow(plugin_as_library)]\n #![feature(plugin)]\n #![plugin(macro_crate_test)]\n "}, {"sha": "3193e5c5fc2477f9005f9ba79580d93c41de4444", "filename": "src/test/run-pass/issue22346.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Frun-pass%2Fissue22346.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860/src%2Ftest%2Frun-pass%2Fissue22346.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue22346.rs?ref=f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This used to cause an ICE because the retslot for the \"return\" had the wrong type\n+fn testcase<'a>() -> Box<Iterator<Item=usize> + 'a> {\n+    return Box::new(range(0, 3).map(|i| { return i; }));\n+}\n+\n+fn main() {\n+}"}]}