{"sha": "ddec6b5f472088e26ec81cc829c0b377fef477ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkZWM2YjVmNDcyMDg4ZTI2ZWM4MWNjODI5YzBiMzc3ZmVmNDc3YWM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-21T01:36:35Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-08T02:33:18Z"}, "message": "rustc: Use a set-based approach to unification; remove ty_bound_param and ty_local.\n\nSorry, big perf regression; will fix soon.", "tree": {"sha": "910db1d314fd5d682c24946216c0089e3ad1a94e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/910db1d314fd5d682c24946216c0089e3ad1a94e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddec6b5f472088e26ec81cc829c0b377fef477ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddec6b5f472088e26ec81cc829c0b377fef477ac", "html_url": "https://github.com/rust-lang/rust/commit/ddec6b5f472088e26ec81cc829c0b377fef477ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddec6b5f472088e26ec81cc829c0b377fef477ac/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "721c5bbee870a08e16d5303837fae4184a5ad377", "url": "https://api.github.com/repos/rust-lang/rust/commits/721c5bbee870a08e16d5303837fae4184a5ad377", "html_url": "https://github.com/rust-lang/rust/commit/721c5bbee870a08e16d5303837fae4184a5ad377"}], "stats": {"total": 2291, "additions": 1106, "deletions": 1185}, "files": [{"sha": "a33416c8638b4791a736f62aa499ea18cbcfd3b0", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddec6b5f472088e26ec81cc829c0b377fef477ac/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddec6b5f472088e26ec81cc829c0b377fef477ac/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=ddec6b5f472088e26ec81cc829c0b377fef477ac", "patch": "@@ -125,7 +125,7 @@ fn pretty_print_input(session::session sess, eval::env env, str input,\n                       pp_mode ppm) {\n     auto def = tup(ast::local_crate, 0);\n     auto p = front::parser::new_parser(sess, env, def, input, 0u, 0u);\n-    auto crate = front::parser::parse_crate_from_source_file(p);\n+    auto crate = parse_input(sess, p, input);\n \n     auto mode;\n     alt (ppm) {"}, {"sha": "59f3cf56387c529841f0bd9982b2c10ccb2bc2e1", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ddec6b5f472088e26ec81cc829c0b377fef477ac/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddec6b5f472088e26ec81cc829c0b377fef477ac/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=ddec6b5f472088e26ec81cc829c0b377fef477ac", "patch": "@@ -230,17 +230,6 @@ mod Encode {\n             }\n             case (ty::ty_type) {w.write_char('Y');}\n             case (ty::ty_task) {w.write_char('a');}\n-\n-            // These two don't appear in crate metadata, but are here because\n-            // `hash_ty()` uses this function.\n-            case (ty::ty_bound_param(?id)) {\n-                w.write_char('o');\n-                w.write_str(common::uistr(id));\n-            }\n-            case (ty::ty_local(?def)) {\n-                w.write_char('L');\n-                w.write_str(cx.ds(def));\n-            }\n         }\n     }\n "}, {"sha": "01192deb8da7f7edbda91a1b91084d3ea66bc050", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ddec6b5f472088e26ec81cc829c0b377fef477ac/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddec6b5f472088e26ec81cc829c0b377fef477ac/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=ddec6b5f472088e26ec81cc829c0b377fef477ac", "patch": "@@ -904,10 +904,6 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n         case (ty::ty_param(_)) {\n             llty = T_i8();\n         }\n-        case (ty::ty_bound_param(_)) {\n-            cx.tcx.sess.span_err(sp, \n-                                 \"trans::type_of called on ty_bound_param\");\n-        }\n         case (ty::ty_type) { llty = T_ptr(T_tydesc(cx.tn)); }\n     }\n \n@@ -1299,7 +1295,6 @@ fn static_size_of_tag(&@crate_ctxt cx, &span sp, &ty::t t) -> uint {\n         auto tup_ty = simplify_type(cx, ty::mk_imm_tup(cx.tcx, variant.args));\n \n         // Perform any type parameter substitutions.\n-        tup_ty = ty::bind_params_in_type(cx.tcx, tup_ty);\n         tup_ty = ty::substitute_type_params(cx.tcx, subtys, tup_ty);\n \n         // Here we possibly do a recursive call.\n@@ -1373,10 +1368,8 @@ fn dynamic_size_of(&@block_ctxt cx, ty::t t) -> result {\n                 let vec[ty::t] raw_tys = variant.args;\n                 let vec[ty::t] tys = [];\n                 for (ty::t raw_ty in raw_tys) {\n-                    auto t = ty::bind_params_in_type(cx.fcx.lcx.ccx.tcx,\n-                                                    raw_ty);\n-                    t = ty::substitute_type_params(cx.fcx.lcx.ccx.tcx, tps,\n-                                                   t);\n+                    auto t = ty::substitute_type_params(cx.fcx.lcx.ccx.tcx,\n+                                                        tps, raw_ty);\n                     tys += [t];\n                 }\n \n@@ -1553,9 +1546,8 @@ fn GEP_tag(@block_ctxt cx,\n     auto i = 0;\n     let vec[ty::t] true_arg_tys = [];\n     for (ty::t aty in arg_tys) {\n-        auto arg_ty = ty::bind_params_in_type(cx.fcx.lcx.ccx.tcx, aty);\n-        arg_ty = ty::substitute_type_params(cx.fcx.lcx.ccx.tcx, ty_substs,\n-                                           arg_ty);\n+        auto arg_ty = ty::substitute_type_params(cx.fcx.lcx.ccx.tcx,\n+                                                 ty_substs, aty);\n         true_arg_tys += [arg_ty];\n         if (i == ix) {\n             elem_ty = arg_ty;\n@@ -2745,10 +2737,8 @@ fn iter_structural_ty_full(&@block_ctxt cx,\n                                 auto llfldp_b = rslt.val;\n                                 variant_cx = rslt.bcx;\n \n-                                auto ty_subst = ty::bind_params_in_type(\n-                                    cx.fcx.lcx.ccx.tcx, a.ty);\n-                                ty_subst = ty::substitute_type_params(\n-                                    cx.fcx.lcx.ccx.tcx, tps, ty_subst);\n+                                auto ty_subst = ty::substitute_type_params(\n+                                    cx.fcx.lcx.ccx.tcx, tps, a.ty);\n \n                                 auto llfld_a =\n                                     load_if_immediate(variant_cx,\n@@ -5308,6 +5298,7 @@ fn trans_call(&@block_ctxt cx, &@ast::expr f,\n     }\n \n     auto ret_ty = ty::ann_to_type(cx.fcx.lcx.ccx.tcx, ann);\n+\n     auto args_res = trans_args(f_res.res.bcx,\n                                llenv, f_res.llobj,\n                                f_res.generic,\n@@ -7552,6 +7543,7 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx,\n \n     // Declare the wrapper.\n     auto t = node_ann_type(ccx, ann);\n+\n     auto wrapper_type = native_fn_wrapper_type(ccx, sp, num_ty_param, t);\n     let str s = mangle_internal_name_by_path(ccx, path);\n     let ValueRef wrapper_fn = decl_internal_fastcall_fn(ccx.llmod, s,"}, {"sha": "53b3c8fce077be70e9dd66cb4410b8ef4dc7bdcb", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 273, "deletions": 398, "changes": 671, "blob_url": "https://github.com/rust-lang/rust/blob/ddec6b5f472088e26ec81cc829c0b377fef477ac/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddec6b5f472088e26ec81cc829c0b377fef477ac/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=ddec6b5f472088e26ec81cc829c0b377fef477ac", "patch": "@@ -9,6 +9,7 @@ import std::map::hashmap;\n import std::option;\n import std::option::none;\n import std::option::some;\n+import std::smallintmap;\n \n import driver::session;\n import front::ast;\n@@ -88,9 +89,7 @@ type raw_t = rec(sty struct,\n                  option::t[str] cname,\n                  uint hash,\n                  bool has_params,\n-                 bool has_bound_params,\n-                 bool has_vars,\n-                 bool has_locals);\n+                 bool has_vars);\n \n type t = uint;\n \n@@ -118,23 +117,15 @@ tag sty {\n     ty_fn(ast::proto, vec[arg], t, controlflow);\n     ty_native_fn(ast::native_abi, vec[arg], t);\n     ty_obj(vec[method]);\n-    ty_var(int);                                    // ephemeral type var\n-    ty_local(ast::def_id);                           // type of a local var\n+    ty_var(int);                                    // type variable\n     ty_param(uint);                                 // fn/tag type param\n-    ty_bound_param(uint);                           // bound param, only paths\n     ty_type;\n     ty_native;\n     // TODO: ty_fn_arg(t), for a possibly-aliased function argument\n }\n \n // Data structures used in type unification\n \n-type unify_handler = obj {\n-    fn resolve_local(ast::def_id id) -> option::t[t];\n-    fn record_local(ast::def_id id, t ty);  // TODO: -> unify::result\n-    fn record_param(uint index, t binding) -> unify::result;\n-};\n-\n tag type_err {\n     terr_mismatch;\n     terr_controlflow_mismatch;\n@@ -259,132 +250,101 @@ fn mk_raw_ty(&ctxt cx, &sty st, &option::t[str] cname) -> raw_t {\n     auto h = hash_type_info(st, cname);\n \n     let bool has_params = false;\n-    let bool has_bound_params = false;\n     let bool has_vars = false;\n-    let bool has_locals = false;\n \n     fn derive_flags_t(&ctxt cx,\n                       &mutable bool has_params,\n-                      &mutable bool has_bound_params,\n                       &mutable bool has_vars,\n-                      &mutable bool has_locals,\n                       &t tt) {\n         auto rt = interner::get[raw_t](*cx.ts, tt);\n         has_params = has_params || rt.has_params;\n-        has_bound_params = has_bound_params || rt.has_bound_params;\n         has_vars = has_vars || rt.has_vars;\n-        has_locals = has_locals || rt.has_locals;\n     }\n \n     fn derive_flags_mt(&ctxt cx,\n                        &mutable bool has_params,\n-                       &mutable bool has_bound_params,\n                        &mutable bool has_vars,\n-                       &mutable bool has_locals,\n                        &mt m) {\n-        derive_flags_t(cx, has_params, has_bound_params,\n-                       has_vars, has_locals, m.ty);\n+        derive_flags_t(cx, has_params, has_vars, m.ty);\n     }\n \n \n     fn derive_flags_arg(&ctxt cx,\n                         &mutable bool has_params,\n-                        &mutable bool has_bound_params,\n                         &mutable bool has_vars,\n-                        &mutable bool has_locals,\n                         &arg a) {\n-        derive_flags_t(cx, has_params, has_bound_params,\n-                       has_vars, has_locals, a.ty);\n+        derive_flags_t(cx, has_params, has_vars, a.ty);\n     }\n \n     fn derive_flags_sig(&ctxt cx,\n                         &mutable bool has_params,\n-                        &mutable bool has_bound_params,\n                         &mutable bool has_vars,\n-                        &mutable bool has_locals,\n                         &vec[arg] args,\n                         &t tt) {\n         for (arg a in args) {\n-            derive_flags_arg(cx, has_params, has_bound_params,\n-                             has_vars, has_locals, a);\n+            derive_flags_arg(cx, has_params, has_vars, a);\n         }\n-        derive_flags_t(cx, has_params, has_bound_params,\n-                       has_vars, has_locals, tt);\n+        derive_flags_t(cx, has_params, has_vars, tt);\n     }\n \n     alt (st) {\n         case (ty_param(_)) {\n             has_params = true;\n         }\n-        case (ty_bound_param(_)) {\n-            has_bound_params = true;\n-        }\n         case (ty_var(_)) { has_vars = true; }\n-        case (ty_local(_)) { has_locals = true; }\n         case (ty_tag(_, ?tys)) {\n             for (t tt in tys) {\n-                derive_flags_t(cx, has_params, has_bound_params,\n-                               has_vars, has_locals, tt);\n+                derive_flags_t(cx, has_params, has_vars, tt);\n             }\n         }\n         case (ty_box(?m)) {\n-            derive_flags_mt(cx, has_params, has_bound_params,\n-                            has_vars, has_locals, m);\n+            derive_flags_mt(cx, has_params, has_vars, m);\n         }\n \n         case (ty_vec(?m)) {\n-            derive_flags_mt(cx, has_params, has_bound_params,\n-                            has_vars, has_locals, m);\n+            derive_flags_mt(cx, has_params, has_vars, m);\n         }\n \n         case (ty_port(?tt)) {\n-            derive_flags_t(cx, has_params, has_bound_params,\n-                           has_vars, has_locals, tt);\n+            derive_flags_t(cx, has_params, has_vars, tt);\n         }\n \n         case (ty_chan(?tt)) {\n-            derive_flags_t(cx, has_params, has_bound_params,\n-                           has_vars, has_locals, tt);\n+            derive_flags_t(cx, has_params, has_vars, tt);\n         }\n \n         case (ty_tup(?mts)) {\n             for (mt m in mts) {\n-                derive_flags_mt(cx, has_params, has_bound_params,\n-                                has_vars, has_locals, m);\n+                derive_flags_mt(cx, has_params, has_vars, m);\n             }\n         }\n \n         case (ty_rec(?flds)) {\n             for (field f in flds) {\n-                derive_flags_mt(cx, has_params, has_bound_params,\n-                                has_vars, has_locals, f.mt);\n+                derive_flags_mt(cx, has_params, has_vars, f.mt);\n             }\n         }\n \n         case (ty_fn(_, ?args, ?tt, _)) {\n-            derive_flags_sig(cx, has_params, has_bound_params,\n-                             has_vars, has_locals, args, tt);\n+            derive_flags_sig(cx, has_params, has_vars, args, tt);\n         }\n \n         case (ty_native_fn(_, ?args, ?tt)) {\n-            derive_flags_sig(cx, has_params, has_bound_params,\n-                             has_vars, has_locals, args, tt);\n+            derive_flags_sig(cx, has_params, has_vars, args, tt);\n         }\n \n         case (ty_obj(?meths)) {\n             for (method m in meths) {\n-                derive_flags_sig(cx, has_params, has_bound_params,\n-                                 has_vars, has_locals, m.inputs, m.output);\n+                derive_flags_sig(cx, has_params, has_vars, m.inputs,\n+                                 m.output);\n             }\n         }\n         case (_) { }\n     }\n \n     ret rec(struct=st, cname=cname, hash=h,\n-            has_params = has_params,\n-            has_bound_params = has_bound_params,\n-            has_vars = has_vars,\n-            has_locals = has_locals);\n+            has_params=has_params,\n+            has_vars=has_vars);\n }\n \n fn intern(&ctxt cx, &sty st, &option::t[str] cname) {\n@@ -485,18 +445,10 @@ fn mk_var(&ctxt cx, int v) -> t {\n     ret gen_ty(cx, ty_var(v));\n }\n \n-fn mk_local(&ctxt cx, ast::def_id did) -> t {\n-    ret gen_ty(cx, ty_local(did));\n-}\n-\n fn mk_param(&ctxt cx, uint n) -> t {\n     ret gen_ty(cx, ty_param(n));\n }\n \n-fn mk_bound_param(&ctxt cx, uint n) -> t {\n-    ret gen_ty(cx, ty_bound_param(n));\n-}\n-\n fn mk_type(&ctxt cx) -> t    { ret idx_type; }\n fn mk_native(&ctxt cx) -> t  { ret idx_native; }\n \n@@ -594,12 +546,12 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n         ret mstr + ty_to_str(cx, m.ty);\n     }\n \n-    alt (cname(cx, typ)) {\n+    /*alt (cname(cx, typ)) {\n         case (some(?cs)) {\n             ret cs;\n         }\n         case (_) { }\n-    }\n+    }*/\n \n     auto s = \"\";\n \n@@ -664,20 +616,10 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n             s += \"<T\" + util::common::istr(v) + \">\";\n         }\n \n-        case (ty_local(?id)) {\n-            s += \"<L\" + util::common::istr(id._0) + \":\" +\n-                util::common::istr(id._1) + \">\";\n-        }\n-\n         case (ty_param(?id)) {\n             s += \"'\" + str::unsafe_from_bytes([('a' as u8) + (id as u8)]);\n         }\n \n-        case (ty_bound_param(?id)) {\n-            s += \"''\" + str::unsafe_from_bytes([('a' as u8) +\n-                                                    (id as u8)]);\n-        }\n-\n         case (_) {\n             s += ty_to_short_str(cx, typ);\n         }\n@@ -753,9 +695,7 @@ fn walk_ty(&ctxt cx, ty_walk walker, t ty) {\n             }\n         }\n         case (ty_var(_))         { /* no-op */ }\n-        case (ty_local(_))       { /* no-op */ }\n         case (ty_param(_))       { /* no-op */ }\n-        case (ty_bound_param(_)) { /* no-op */ }\n     }\n \n     walker(ty);\n@@ -853,9 +793,7 @@ fn fold_ty(&ctxt cx, ty_fold fld, t ty_0) -> t {\n             ty = copy_cname(cx, mk_obj(cx, new_methods), ty);\n         }\n         case (ty_var(_))         { /* no-op */ }\n-        case (ty_local(_))       { /* no-op */ }\n         case (ty_param(_))       { /* no-op */ }\n-        case (ty_bound_param(_)) { /* no-op */ }\n     }\n \n     ret fld(ty);\n@@ -1018,7 +956,6 @@ fn type_has_pointers(&ctxt cx, &t ty) -> bool {\n             for (variant_info variant in variants) {\n                 auto tup_ty = mk_imm_tup(cx, variant.args);\n                 // Perform any type parameter substitutions.\n-                tup_ty = bind_params_in_type(cx, tup_ty);\n                 tup_ty = substitute_type_params(cx, tps, tup_ty);\n                 if (type_has_pointers(cx, tup_ty)) { ret true; }\n             }\n@@ -1228,13 +1165,11 @@ fn hash_type_structure(&sty st) -> uint {\n             ret h;\n         }\n         case (ty_var(?v)) { ret hash_uint(28u, v as uint); }\n-        case (ty_local(?did)) { ret hash_def(29u, did); }\n-        case (ty_param(?pid)) { ret hash_uint(30u, pid); }\n-        case (ty_bound_param(?pid)) { ret hash_uint(31u, pid); }\n-        case (ty_type) { ret 32u; }\n-        case (ty_native) { ret 33u; }\n-        case (ty_bot) { ret 34u; }\n-        case (ty_ptr(?mt)) { ret hash_subty(35u, mt.ty); }\n+        case (ty_param(?pid)) { ret hash_uint(29u, pid); }\n+        case (ty_type) { ret 30u; }\n+        case (ty_native) { ret 31u; }\n+        case (ty_bot) { ret 32u; }\n+        case (ty_ptr(?mt)) { ret hash_subty(33u, mt.ty); }\n     }\n }\n \n@@ -1470,24 +1405,12 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n                 case (_) { ret false; }\n             }\n         }\n-        case (ty_local(?did_a)) {\n-            alt (b) {\n-                case (ty_local(?did_b)) { ret equal_def(did_a, did_b); }\n-                case (_) { ret false; }\n-            }\n-        }\n         case (ty_param(?pid_a)) {\n             alt (b) {\n                 case (ty_param(?pid_b)) { ret pid_a == pid_b; }\n                 case (_) { ret false; }\n             }\n         }\n-        case (ty_bound_param(?pid_a)) {\n-            alt (b) {\n-                case (ty_bound_param(?pid_b)) { ret pid_a == pid_b; }\n-                case (_) { ret false; }\n-            }\n-        }\n         case (ty_type) {\n             alt (b) {\n                 case (ty_type) { ret true; }\n@@ -1575,16 +1498,21 @@ fn ann_has_type_params(&ctxt cx, &ast::ann ann) -> bool {\n }\n \n \n+// Returns a type with type parameter substitutions performed if applicable.\n+fn ty_param_substs_opt_and_ty_to_monotype(&ctxt cx,\n+                                          &ty_param_substs_opt_and_ty tpot)\n+        -> t {\n+    alt (tpot._0) {\n+        case (none) { ret tpot._1; }\n+        case (some(?tps)) { ret substitute_type_params(cx, tps, tpot._1); }\n+    }\n+}\n+\n // Returns the type of an annotation, with type parameter substitutions\n // performed if applicable.\n fn ann_to_monotype(&ctxt cx, ast::ann a) -> t {\n     auto tpot = ann_to_ty_param_substs_opt_and_ty(cx, a);\n-    alt (tpot._0) {\n-        case (none) { ret tpot._1; }\n-        case (some(?tps)) {\n-            ret substitute_type_params(cx, tps, tpot._1);\n-        }\n-    }\n+    ret ty_param_substs_opt_and_ty_to_monotype(cx, tpot);\n }\n \n \n@@ -1618,18 +1546,10 @@ fn type_contains_vars(&ctxt cx, &t typ) -> bool {\n     ret interner::get[raw_t](*cx.ts, typ).has_vars;\n }\n \n-fn type_contains_locals(&ctxt cx, &t typ) -> bool {\n-    ret interner::get[raw_t](*cx.ts, typ).has_locals;\n-}\n-\n fn type_contains_params(&ctxt cx, &t typ) -> bool {\n     ret interner::get[raw_t](*cx.ts, typ).has_params;\n }\n \n-fn type_contains_bound_params(&ctxt cx, &t typ) -> bool {\n-    ret interner::get[raw_t](*cx.ts, typ).has_bound_params;\n-}\n-\n // Type accessors for substructures of types\n \n fn ty_fn_args(&ctxt cx, &t fty) -> vec[arg] {\n@@ -1670,6 +1590,13 @@ fn is_fn_ty(&ctxt cx, &t fty) -> bool {\n     }\n }\n \n+fn ty_var_id(&ctxt cx, t typ) -> int {\n+    alt (struct(cx, typ)) {\n+        case (ty::ty_var(?vid)) { ret vid; }\n+        case (_) { log_err \"ty_var_id called on non-var ty\"; fail; }\n+    }\n+}\n+\n \n // Type accessors for AST nodes\n \n@@ -1882,55 +1809,88 @@ fn is_lval(&@ast::expr expr) -> bool {\n mod unify {\n     tag result {\n         ures_ok(t);\n-        ures_err(type_err, t, t);\n+        ures_err(type_err);\n+    }\n+\n+    tag union_result {\n+        unres_ok;\n+        unres_err(type_err);\n     }\n \n-    tag set_result {\n-        usr_ok(vec[t]);\n-        usr_err(type_err, t, t);\n+    tag fixup_result {\n+        fix_ok(t);      // fixup succeeded\n+        fix_err(int);   // fixup failed because a type variable was unresolved\n     }\n \n-    type bindings[T] = rec(ufind::ufind sets,\n-                           hashmap[T,uint] ids,\n-                           mutable vec[mutable option::t[t]] types);\n+    type var_bindings = rec(ufind::ufind sets,\n+                            smallintmap::smallintmap[t] types);\n+\n+    type ctxt = rec(@var_bindings vb, ty_ctxt tcx);\n \n-    fn mk_bindings[T](map::hashfn[T] hasher, map::eqfn[T] eqer)\n-            -> @bindings[T] {\n-        let vec[mutable option::t[t]] types = [mutable];\n-        ret @rec(sets=ufind::make(),\n-                 ids=map::mk_hashmap[T,uint](hasher, eqer),\n-                 mutable types=types);\n+    fn mk_var_bindings() -> @var_bindings {\n+        ret @rec(sets=ufind::make(), types=smallintmap::mk[t]());\n     }\n \n-    fn record_binding[T](&@ctxt cx, &@bindings[T] bindings, &T key, t typ)\n-            -> result {\n-        auto n = get_or_create_set[T](bindings, key);\n+    // Unifies two sets.\n+    fn union(&@ctxt cx, uint set_a, uint set_b) -> union_result {\n+        ufind::grow(cx.vb.sets, uint::max(set_a, set_b) + 1u);\n \n-        auto result_type = typ;\n-        if (n < vec::len[option::t[t]](bindings.types)) {\n-            alt (bindings.types.(n)) {\n-                case (some(?old_type)) {\n-                    alt (unify_step(cx, old_type, typ)) {\n-                        case (ures_ok(?unified_type)) {\n-                            result_type = unified_type;\n+        auto root_a = ufind::find(cx.vb.sets, set_a);\n+        auto root_b = ufind::find(cx.vb.sets, set_b);\n+        ufind::union(cx.vb.sets, set_a, set_b);\n+        auto root_c = ufind::find(cx.vb.sets, set_a);\n+\n+        alt (smallintmap::find[t](cx.vb.types, root_a)) {\n+            case (none[t]) {\n+                alt (smallintmap::find[t](cx.vb.types, root_b)) {\n+                    case (none[t]) { ret unres_ok; }\n+                    case (some[t](?t_b)) {\n+                        smallintmap::insert[t](cx.vb.types, root_c, t_b);\n+                        ret unres_ok;\n+                    }\n+                }\n+            }\n+            case (some[t](?t_a)) {\n+                alt (smallintmap::find[t](cx.vb.types, root_b)) {\n+                    case (none[t]) {\n+                        smallintmap::insert[t](cx.vb.types, root_c, t_a);\n+                        ret unres_ok;\n+                    }\n+                    case (some[t](?t_b)) {\n+                        alt (unify_step(cx, t_a, t_b)) {\n+                            case (ures_ok(?t_c)) {\n+                                smallintmap::insert[t](cx.vb.types, root_c,\n+                                                       t_c);\n+                                ret unres_ok;\n+                            }\n+                            case (ures_err(?terr)) { ret unres_err(terr); }\n                         }\n-                        case (?res) { ret res; }\n                     }\n                 }\n-                case (none) { /* fall through */ }\n             }\n         }\n+    }\n+\n+    fn record_var_binding(&@ctxt cx, int key, t typ) -> result {\n+        ufind::grow(cx.vb.sets, (key as uint) + 1u);\n \n-        vec::grow_set[option::t[t]](bindings.types, n, none[t],\n-                                    some[t](result_type));\n+        auto result_type = typ;\n+        alt (smallintmap::find[t](cx.vb.types, key as uint)) {\n+            case (some(?old_type)) {\n+                alt (unify_step(cx, old_type, typ)) {\n+                    case (ures_ok(?unified_type)) {\n+                        result_type = unified_type;\n+                    }\n+                    case (?res) { ret res; }\n+                }\n+            }\n+            case (none) { /* fall through */ }\n+        }\n \n+        smallintmap::insert[t](cx.vb.types, key as uint, result_type);\n         ret ures_ok(typ);\n     }\n \n-    type ctxt = rec(@bindings[int] bindings,\n-                    unify_handler handler,\n-                    ty_ctxt tcx);\n-\n     // Wraps the given type in an appropriate cname.\n     //\n     // TODO: This doesn't do anything yet. We should carry the cname up from\n@@ -1944,7 +1904,7 @@ mod unify {\n             ret ures_ok(expected);\n         }\n \n-        ret ures_err(terr_mismatch, expected, actual);\n+        ret ures_err(terr_mismatch);\n     }\n \n     // Unifies two mutability flags.\n@@ -1976,8 +1936,7 @@ mod unify {\n         auto expected_len = vec::len[arg](expected_inputs);\n         auto actual_len = vec::len[arg](actual_inputs);\n         if (expected_len != actual_len) {\n-            ret fn_common_res_err(ures_err(terr_arg_count,\n-                                           expected, actual));\n+            ret fn_common_res_err(ures_err(terr_arg_count));\n         }\n \n         // TODO: as above, we should have an iter2 iterator.\n@@ -1995,8 +1954,7 @@ mod unify {\n                 result_mode = expected_input.mode;\n             } else if (expected_input.mode != actual_input.mode) {\n                 // FIXME this is the wrong error\n-                ret fn_common_res_err(ures_err(terr_arg_count,\n-                                               expected, actual));\n+                ret fn_common_res_err(ures_err(terr_arg_count));\n             } else {\n                 result_mode = expected_input.mode;\n             }\n@@ -2040,7 +1998,7 @@ mod unify {\n         -> result {\n \n         if (e_proto != a_proto) {\n-            ret ures_err(terr_mismatch, expected, actual);\n+            ret ures_err(terr_mismatch);\n         }\n         alt (expected_cf) {\n             case (ast::return) { } // ok\n@@ -2055,8 +2013,7 @@ mod unify {\n                            this check is necessary to ensure that the\n                            annotation in an object method matches the\n                            declared object type */\n-                        ret ures_err(terr_controlflow_mismatch,\n-                                     expected, actual);\n+                        ret ures_err(terr_controlflow_mismatch);\n                     }\n                 }\n             }\n@@ -2084,9 +2041,7 @@ mod unify {\n                        &vec[arg] expected_inputs, &t expected_output,\n                        &vec[arg] actual_inputs, &t actual_output)\n         -> result {\n-        if (e_abi != a_abi) {\n-            ret ures_err(terr_mismatch, expected, actual);\n-        }\n+        if (e_abi != a_abi) { ret ures_err(terr_mismatch); }\n \n         auto t = unify_fn_common(cx, expected, actual,\n                                  expected_inputs, expected_output,\n@@ -2113,16 +2068,13 @@ mod unify {\n       let uint expected_len = vec::len[method](expected_meths);\n       let uint actual_len = vec::len[method](actual_meths);\n \n-      if (expected_len != actual_len) {\n-        ret ures_err(terr_meth_count, expected, actual);\n-      }\n+      if (expected_len != actual_len) { ret ures_err(terr_meth_count); }\n \n       while (i < expected_len) {\n         auto e_meth = expected_meths.(i);\n         auto a_meth = actual_meths.(i);\n         if (! str::eq(e_meth.ident, a_meth.ident)) {\n-          ret ures_err(terr_obj_meths(e_meth.ident, a_meth.ident),\n-                       expected, actual);\n+          ret ures_err(terr_obj_meths(e_meth.ident, a_meth.ident));\n         }\n         auto r = unify_fn(cx,\n                           e_meth.proto, a_meth.proto,\n@@ -2151,16 +2103,42 @@ mod unify {\n       ret ures_ok(t);\n     }\n \n-    fn get_or_create_set[T](&@bindings[T] bindings, &T key) -> uint {\n-        auto set_num;\n-        alt (bindings.ids.find(key)) {\n-            case (none) {\n-                set_num = ufind::make_set(bindings.sets);\n-                bindings.ids.insert(key, set_num);\n+    // FIXME: This function should not be necessary, but it is for now until\n+    // we eliminate pushdown. The typechecker should never rely on early\n+    // resolution of type variables.\n+    fn resolve_all_vars(&ty_ctxt tcx, &@var_bindings vb, t typ) -> t {\n+        fn folder(ty_ctxt tcx, @var_bindings vb, @bool success, t typ) -> t {\n+            alt (struct(tcx, typ)) {\n+                case (ty_var(?vid)) {\n+                    // It's possible that we haven't even created the var set.\n+                    // Handle this case gracefully.\n+                    if ((vid as uint) >= ufind::set_count(vb.sets)) {\n+                        *success = false; ret typ;\n+                    }\n+\n+                    auto root_id = ufind::find(vb.sets, vid as uint);\n+                    alt (smallintmap::find[t](vb.types, root_id)) {\n+                        case (some[t](?typ2)) {\n+                            ret fold_ty(tcx, bind folder(tcx, vb, success, _),\n+                                        typ2);\n+                        }\n+                        case (none[t]) { *success = false; ret typ; }\n+                    }\n+                    log \"\"; // fixes ambiguity\n+                    *success = false; ret typ;\n+                }\n+\n+                case (_) { ret typ; }\n             }\n-            case (some(?n)) { set_num = n; }\n         }\n-        ret set_num;\n+\n+        auto success = @true;\n+        auto rty = fold_ty(tcx, bind folder(tcx, vb, success, _), typ);\n+        /*if (*success) { ret rty; }\n+        log_err \"*** failed! type \" + ty::ty_to_str(tcx, typ) + \" => \" +\n+            ty::ty_to_str(tcx, rty);\n+        ret typ;*/\n+        ret rty;\n     }\n \n     fn unify_step(&@ctxt cx, &t expected, &t actual) -> result {\n@@ -2173,72 +2151,57 @@ mod unify {\n         // Fast path.\n         if (eq_ty(expected, actual)) { ret ures_ok(expected); }\n \n-        alt (struct(cx.tcx, actual)) {\n+        // Stage 1: Handle the cases in which one side or another is a type\n+        // variable.\n \n-            // a _|_ type can be used anywhere\n-            case (ty::ty_bot) {\n-                ret ures_ok(expected);\n-            }\n-       \n+        alt (struct(cx.tcx, actual)) {\n             // If the RHS is a variable type, then just do the appropriate\n             // binding.\n             case (ty::ty_var(?actual_id)) {\n-                auto actual_n = get_or_create_set[int](cx.bindings,\n-                                                       actual_id);\n+                auto actual_n = actual_id as uint;\n                 alt (struct(cx.tcx, expected)) {\n                     case (ty::ty_var(?expected_id)) {\n-                        auto expected_n = get_or_create_set[int](cx.bindings,\n-                                                                 expected_id);\n-                        ufind::union(cx.bindings.sets, expected_n, actual_n);\n+                        auto expected_n = expected_id as uint;\n+                        union(cx, expected_n, actual_n);\n                     }\n-\n                     case (_) {\n                         // Just bind the type variable to the expected type.\n-                        alt (record_binding[int](cx, cx.bindings, actual_id,\n-                                                 expected)) {\n+                        alt (record_var_binding(cx, actual_id, expected)) {\n                             case (ures_ok(_)) { /* fall through */ }\n                             case (?res) { ret res; }\n                         }\n                     }\n                 }\n-                ret ures_ok(actual);\n-            }\n-            case (ty::ty_local(?actual_id)) {\n-                auto result_ty;\n-                alt (cx.handler.resolve_local(actual_id)) {\n-                    case (none) { result_ty = expected; }\n-                    case (some(?actual_ty)) {\n-                        auto result = unify_step(cx, expected, actual_ty);\n-                        alt (result) {\n-                            case (ures_ok(?rty)) { result_ty = rty; }\n-                            case (_) { ret result; }\n-                        }\n-                    }\n-                }\n-\n-                cx.handler.record_local(actual_id, result_ty);\n-                ret ures_ok(result_ty);\n+                ret ures_ok(mk_var(cx.tcx, actual_id));\n             }\n-            case (ty::ty_bound_param(?actual_id)) {\n-                alt (struct(cx.tcx, expected)) {\n-                    case (ty::ty_local(_)) {\n-                        // TODO: bound param unifying with local\n-                        cx.tcx.sess.unimpl(\"TODO: bound param unifying with \"\n-                                           + \"local\");\n-                    }\n \n-                    case (_) {\n-                        ret cx.handler.record_param(actual_id, expected);\n-                    }\n+            case (_) { /* empty */ }\n+        }\n+\n+        alt (struct(cx.tcx, expected)) {\n+            case (ty::ty_var(?expected_id)) {\n+                // Add a binding. (`actual` can't actually be a var here.)\n+                alt (record_var_binding(cx, expected_id, actual)) {\n+                    case (ures_ok(_)) { /* fall through */ }\n+                    case (?res) { ret res; }\n                 }\n+                ret ures_ok(mk_var(cx.tcx, expected_id));\n             }\n-            case (_) { /* empty */ }\n+\n+            case (_) { /* fall through */ }\n+        }\n+\n+        // Stage 2: Handle all other cases.\n+\n+        alt (struct(cx.tcx, actual)) {\n+            case (ty::ty_bot)        { ret ures_ok(expected);                }\n+            case (_)                 { /* fall through */                    }\n         }\n \n         alt (struct(cx.tcx, expected)) {\n             case (ty::ty_nil)        { ret struct_cmp(cx, expected, actual); }\n             // _|_ unifies with anything\n-            case (ty::ty_bot)        { ret ures_ok(expected);                }\n+            case (ty::ty_bot)        { ret ures_ok(actual);                  }\n             case (ty::ty_bool)       { ret struct_cmp(cx, expected, actual); }\n             case (ty::ty_int)        { ret struct_cmp(cx, expected, actual); }\n             case (ty::ty_uint)       { ret struct_cmp(cx, expected, actual); }\n@@ -2255,7 +2218,7 @@ mod unify {\n                     case (ty::ty_tag(?actual_id, ?actual_tps)) {\n                         if (expected_id._0 != actual_id._0 ||\n                                 expected_id._1 != actual_id._1) {\n-                            ret ures_err(terr_mismatch, expected, actual);\n+                            ret ures_err(terr_mismatch);\n                         }\n \n                         // TODO: factor this cruft out, see the TODO in the\n@@ -2288,18 +2251,15 @@ mod unify {\n                     case (_) { /* fall through */ }\n                 }\n \n-                ret ures_err(terr_mismatch, expected, actual);\n+                ret ures_err(terr_mismatch);\n             }\n \n             case (ty::ty_box(?expected_mt)) {\n                 alt (struct(cx.tcx, actual)) {\n                     case (ty::ty_box(?actual_mt)) {\n                         auto mut;\n                         alt (unify_mut(expected_mt.mut, actual_mt.mut)) {\n-                            case (none) {\n-                                ret ures_err(terr_box_mutability, expected,\n-                                             actual);\n-                            }\n+                            case (none) { ret ures_err(terr_box_mutability); }\n                             case (some(?m)) { mut = m; }\n                         }\n \n@@ -2317,9 +2277,7 @@ mod unify {\n                         }\n                     }\n \n-                    case (_) {\n-                        ret ures_err(terr_mismatch, expected, actual);\n-                    }\n+                    case (_) { ret ures_err(terr_mismatch); }\n                 }\n             }\n \n@@ -2328,10 +2286,7 @@ mod unify {\n                     case (ty::ty_vec(?actual_mt)) {\n                         auto mut;\n                         alt (unify_mut(expected_mt.mut, actual_mt.mut)) {\n-                            case (none) {\n-                                ret ures_err(terr_vec_mutability, expected,\n-                                             actual);\n-                            }\n+                            case (none) { ret ures_err(terr_vec_mutability); }\n                             case (some(?m)) { mut = m; }\n                         }\n \n@@ -2349,9 +2304,7 @@ mod unify {\n                         }\n                     }\n \n-                    case (_) {\n-                        ret ures_err(terr_mismatch, expected, actual);\n-                   }\n+                    case (_) { ret ures_err(terr_mismatch); }\n                 }\n             }\n \n@@ -2371,9 +2324,7 @@ mod unify {\n                         }\n                     }\n \n-                    case (_) {\n-                        ret ures_err(terr_mismatch, expected, actual);\n-                    }\n+                    case (_) { ret ures_err(terr_mismatch); }\n                 }\n             }\n \n@@ -2393,9 +2344,7 @@ mod unify {\n                         }\n                     }\n \n-                    case (_) {\n-                        ret ures_err(terr_mismatch, expected, actual);\n-                    }\n+                    case (_) { ret ures_err(terr_mismatch); }\n                 }\n             }\n \n@@ -2407,7 +2356,7 @@ mod unify {\n                         if (expected_len != actual_len) {\n                             auto err = terr_tuple_size(expected_len,\n                                                        actual_len);\n-                            ret ures_err(err, expected, actual);\n+                            ret ures_err(err);\n                         }\n \n                         // TODO: implement an iterator that can iterate over\n@@ -2423,7 +2372,7 @@ mod unify {\n                                            actual_elem.mut)) {\n                                 case (none) {\n                                     auto err = terr_tuple_mutability;\n-                                    ret ures_err(err, expected, actual);\n+                                    ret ures_err(err);\n                                 }\n                                 case (some(?m)) { mut = m; }\n                             }\n@@ -2447,9 +2396,7 @@ mod unify {\n                         ret ures_ok(mk_tup(cx.tcx, result_elems));\n                     }\n \n-                    case (_) {\n-                        ret ures_err(terr_mismatch, expected, actual);\n-                    }\n+                    case (_) { ret ures_err(terr_mismatch); }\n                 }\n             }\n \n@@ -2461,7 +2408,7 @@ mod unify {\n                         if (expected_len != actual_len) {\n                             auto err = terr_record_size(expected_len,\n                                                         actual_len);\n-                            ret ures_err(err, expected, actual);\n+                            ret ures_err(err);\n                         }\n \n                         // TODO: implement an iterator that can iterate over\n@@ -2476,8 +2423,7 @@ mod unify {\n                             alt (unify_mut(expected_field.mt.mut,\n                                            actual_field.mt.mut)) {\n                                 case (none) {\n-                                    ret ures_err(terr_record_mutability,\n-                                                 expected, actual);\n+                                    ret ures_err(terr_record_mutability);\n                                 }\n                                 case (some(?m)) { mut = m; }\n                             }\n@@ -2487,7 +2433,7 @@ mod unify {\n                                 auto err =\n                                     terr_record_fields(expected_field.ident,\n                                                        actual_field.ident);\n-                                ret ures_err(err, expected, actual);\n+                                ret ures_err(err);\n                             }\n \n                             auto result = unify_step(cx,\n@@ -2511,9 +2457,7 @@ mod unify {\n                         ret ures_ok(mk_rec(cx.tcx, result_fields));\n                     }\n \n-                    case (_) {\n-                        ret ures_err(terr_mismatch, expected, actual);\n-                    }\n+                    case (_) { ret ures_err(terr_mismatch); }\n                 }\n             }\n \n@@ -2529,9 +2473,7 @@ mod unify {\n                                      expected_cf, actual_cf);\n                     }\n \n-                    case (_) {\n-                        ret ures_err(terr_mismatch, expected, actual);\n-                    }\n+                    case (_) { ret ures_err(terr_mismatch); }\n                 }\n             }\n \n@@ -2545,9 +2487,7 @@ mod unify {\n                                             expected_inputs, expected_output,\n                                             actual_inputs, actual_output);\n                     }\n-                    case (_) {\n-                        ret ures_err(terr_mismatch, expected, actual);\n-                    }\n+                    case (_) { ret ures_err(terr_mismatch); }\n                 }\n             }\n \n@@ -2557,147 +2497,82 @@ mod unify {\n                         ret unify_obj(cx, expected, actual,\n                                       expected_meths, actual_meths);\n                     }\n-                    case (_) {\n-                        ret ures_err(terr_mismatch, expected, actual);\n-                    }\n+                    case (_) { ret ures_err(terr_mismatch); }\n                 }\n             }\n+        }\n+    }\n \n-            case (ty::ty_var(?expected_id)) {\n-                // Add a binding. (`actual` can't actually be a var here.)\n-                alt (record_binding[int](cx, cx.bindings, expected_id,\n-                                         actual)) {\n-                    case (ures_ok(_)) { /* fall through */ }\n-                    case (?res) { ret res; }\n-                }\n-                ret ures_ok(expected);\n-            }\n+    fn unify(&t expected,\n+             &t actual,\n+             &@var_bindings vb,\n+             &ty_ctxt tcx) -> result {\n+        auto cx = @rec(vb=vb, tcx=tcx);\n+        ret unify_step(cx, expected, actual);\n+    }\n \n-            case (ty::ty_local(?expected_id)) {\n-                auto result_ty;\n-                alt (cx.handler.resolve_local(expected_id)) {\n-                    case (none) { result_ty = actual; }\n-                    case (some(?expected_ty)) {\n-                        auto result = unify_step(cx, expected_ty, actual);\n-                        alt (result) {\n-                            case (ures_ok(?rty)) { result_ty = rty; }\n-                            case (_) { ret result; }\n-                        }\n-                    }\n+    fn dump_var_bindings(ty_ctxt tcx, @var_bindings vb) {\n+        auto i = 0u;\n+        while (i < vec::len[ufind::node](vb.sets.nodes)) {\n+            auto sets = \"\";\n+            auto j = 0u;\n+            while (j < vec::len[option::t[uint]](vb.sets.nodes)) {\n+                if (ufind::find(vb.sets, j) == i) { sets += #fmt(\" %u\", j); }\n+                j += 1u;\n+            }\n+\n+            auto typespec;\n+            alt (smallintmap::find[t](vb.types, i)) {\n+                case (none[t]) { typespec = \"\"; }\n+                case (some[t](?typ)) {\n+                    typespec = \" =\" + ty_to_str(tcx, typ);\n                 }\n-\n-                cx.handler.record_local(expected_id, result_ty);\n-                ret ures_ok(result_ty);\n             }\n \n-            case (ty::ty_bound_param(?expected_id)) {\n-                ret cx.handler.record_param(expected_id, actual);\n-            }\n+            log_err #fmt(\"set %u:%s%s\", i, typespec, sets);\n+            i += 1u;\n         }\n     }\n \n-    // Performs type binding substitution.\n-    fn substitute(&ty_ctxt tcx,\n-                  &@bindings[int] bindings,\n-                  &vec[t] set_types,\n-                  &t typ) -> t {\n-        if (!type_contains_vars(tcx, typ)) {\n-            ret typ;\n-        }\n+    // Fixups and substitutions\n \n-        fn substituter(ty_ctxt tcx,\n-                       @bindings[int] bindings,\n-                       vec[t] types,\n-                       t typ) -> t {\n+    fn fixup_vars(ty_ctxt tcx, @var_bindings vb, t typ) -> fixup_result {\n+        fn subst_vars(ty_ctxt tcx, @var_bindings vb, t typ) -> t {\n             alt (struct(tcx, typ)) {\n-                case (ty_var(?id)) {\n-                    alt (bindings.ids.find(id)) {\n-                        case (some(?n)) {\n-                            auto root = ufind::find(bindings.sets, n);\n-                            ret types.(root);\n+                case (ty::ty_var(?vid)) {\n+                    auto root_id = ufind::find(vb.sets, vid as uint);\n+                    alt (smallintmap::find[t](vb.types, root_id)) {\n+                        case (none[t]) {\n+                            log_err \"unresolved type variable\";\n+                            fail;\n+                        }\n+                        case (some[t](?rt)) {\n+                            ret fold_ty(tcx, bind subst_vars(tcx, vb, _), rt);\n                         }\n-                        case (none) { ret typ; }\n                     }\n                 }\n                 case (_) { ret typ; }\n             }\n         }\n \n-        auto f = bind substituter(tcx, bindings, set_types, _);\n-        ret fold_ty(tcx, f, typ);\n+        // FIXME: Report errors better.\n+        ret fix_ok(fold_ty(tcx, bind subst_vars(tcx, vb, _), typ));\n     }\n \n-    fn unify_sets[T](&ty_ctxt tcx, &@bindings[T] bindings) -> set_result {\n-        obj handler(ty_ctxt tcx) {\n-            fn resolve_local(ast::def_id id) -> option::t[t] {\n-                tcx.sess.bug(\"resolve_local in unify_sets\");\n-            }\n-            fn record_local(ast::def_id id, t ty) {\n-                tcx.sess.bug(\"record_local in unify_sets\");\n-            }\n-            fn record_param(uint index, t binding) -> unify::result {\n-                tcx.sess.bug(\"record_param in unify_sets\");\n-            }\n-        }\n-\n-        auto node_count = vec::len[option::t[t]](bindings.types);\n-\n-        let vec[option::t[t]] results =\n-            vec::init_elt[option::t[t]](none[t], node_count);\n-\n-        auto i = 0u;\n-        while (i < node_count) {\n-            auto root = ufind::find(bindings.sets, i);\n-            alt (bindings.types.(i)) {\n-                case (none) { /* nothing to do */ }\n-                case (some(?actual)) {\n-                    alt (results.(root)) {\n-                        case (none) { results.(root) = some[t](actual); }\n-                        case (some(?expected)) {\n-                            // FIXME: Is this right?\n-                            auto bindings = mk_bindings[int](int::hash,\n-                                                             int::eq_alias);\n-                            alt (unify(expected, actual, handler(tcx), \n-                                       bindings, tcx)) {\n-                                case (ures_ok(?result_ty)) {\n-                                    results.(i) = some[t](result_ty);\n-                                }\n-                                case (ures_err(?e, ?t_a, ?t_b)) {\n-                                    ret usr_err(e, t_a, t_b);\n-                                }\n-                            }\n-                        }\n+    fn resolve_type_var(&ty_ctxt tcx, &@var_bindings vb, int vid) -> t {\n+        auto root_id = ufind::find(vb.sets, vid as uint);\n+        alt (smallintmap::find[t](vb.types, root_id)) {\n+            case (none[t]) { ret mk_var(tcx, vid); }\n+            case (some[t](?rt)) {\n+                alt (fixup_vars(tcx, vb, rt)) {\n+                    case (fix_ok(?rty)) { ret rty; }\n+                    case (fix_err(_)) {\n+                        // TODO: antisocial\n+                        log_err \"failed to resolve type var\";\n+                        fail;\n                     }\n                 }\n             }\n-            i += 1u;\n-        }\n-\n-        // FIXME: This is equivalent to map(option::get, results) but it\n-        // causes an assertion in typeck at the moment.\n-        let vec[t] real_results = [];\n-        for (option::t[t] typ in results) {\n-            real_results += [option::get[t](typ)];\n-        }\n-\n-        ret usr_ok(real_results);\n-    }\n-\n-    fn unify(&t expected,\n-             &t actual,\n-             &unify_handler handler,\n-             &@bindings[int] bindings,\n-             &ty_ctxt tcx) -> result {\n-        auto cx = @rec(bindings=bindings, handler=handler, tcx=tcx);\n-        ret unify_step(cx, expected, actual);\n-    }\n-\n-    fn fixup(&ty_ctxt tcx, &@bindings[int] bindings, t typ) -> result {\n-        alt (unify_sets[int](tcx, bindings)) {\n-            case (usr_ok(?set_types)) {\n-                ret ures_ok(substitute(tcx, bindings, set_types, typ));\n-            }\n-            case (usr_err(?terr, ?t0, ?t1)) { ret ures_err(terr, t0, t1); }\n         }\n     }\n }\n@@ -2752,46 +2627,46 @@ fn type_err_to_str(&ty::type_err err) -> str {\n     }\n }\n \n-// Performs bound type parameter replacement using the supplied mapping from\n-// parameter IDs to types.\n-fn substitute_type_params(&ctxt cx, &vec[t] bindings, &t typ) -> t {\n-    if (!type_contains_bound_params(cx, typ)) {\n-        ret typ;\n+// Converts type parameters in a type to type variables and returns the\n+// resulting type along with a list of type variable IDs.\n+fn bind_params_in_type(&ctxt cx, fn()->int next_ty_var, t typ,\n+                       uint ty_param_count)\n+        -> tup(vec[int], t) {\n+    let vec[int] param_var_ids = [];\n+    auto i = 0u;\n+    while (i < ty_param_count) {\n+        param_var_ids += [next_ty_var()];\n+        i += 1u;\n     }\n-    fn replacer(&ctxt cx, vec[t] bindings, t typ) -> t {\n+\n+    fn binder(ctxt cx, vec[int] param_var_ids, fn()->int next_ty_var, t typ)\n+            -> t {\n         alt (struct(cx, typ)) {\n-            case (ty_bound_param(?param_index)) {\n-                ret bindings.(param_index);\n-            }\n+            case (ty_param(?index)) { ret mk_var(cx, param_var_ids.(index)); }\n             case (_) { ret typ; }\n         }\n     }\n \n-    auto f = bind replacer(cx, bindings, _);\n-    ret fold_ty(cx, f, typ);\n+    auto f = bind binder(cx, param_var_ids, next_ty_var, _);\n+    auto new_typ = fold_ty(cx, f, typ);\n+    ret tup(param_var_ids, new_typ);\n }\n \n-// Converts type parameters in a type to bound type parameters.\n-fn bind_params_in_type(&ctxt cx, &t typ) -> t {\n-    if (!type_contains_params(cx, typ)) {\n-        ret typ;\n-    }\n-    fn binder(&ctxt cx, t typ) -> t {\n+// Replaces type parameters in the given type using the given list of\n+// substitions.\n+fn substitute_type_params(&ctxt cx, vec[ty::t] substs, t typ) -> t {\n+    if (!type_contains_params(cx, typ)) { ret typ; }\n+\n+    fn substituter(ctxt cx, vec[ty::t] substs, t typ) -> t {\n         alt (struct(cx, typ)) {\n-            case (ty_bound_param(?index)) {\n-                cx.sess.bug(\"bind_params_in_type() called on type that \"\n-                            + \"already has bound params in it\");\n-            }\n-            case (ty_param(?index)) { ret mk_bound_param(cx, index); }\n+            case (ty_param(?idx)) { ret substs.(idx); }\n             case (_) { ret typ; }\n         }\n     }\n \n-    auto f = bind binder(cx, _);\n-    ret fold_ty(cx, f, typ);\n+    ret fold_ty(cx, bind substituter(cx, substs, _), typ);\n }\n \n-\n fn def_has_ty_params(&ast::def def) -> bool {\n     alt (def) {\n         case (ast::def_fn(_))            { ret true;  }"}, {"sha": "d604ad9a3906272f496a2ac8912323e7ee88606c", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 793, "deletions": 753, "changes": 1546, "blob_url": "https://github.com/rust-lang/rust/blob/ddec6b5f472088e26ec81cc829c0b377fef477ac/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddec6b5f472088e26ec81cc829c0b377fef477ac/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=ddec6b5f472088e26ec81cc829c0b377fef477ac"}, {"sha": "49e9efa20f4c537d53c9c7e3d18773034851d654", "filename": "src/lib/smallintmap.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddec6b5f472088e26ec81cc829c0b377fef477ac/src%2Flib%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddec6b5f472088e26ec81cc829c0b377fef477ac/src%2Flib%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsmallintmap.rs?ref=ddec6b5f472088e26ec81cc829c0b377fef477ac", "patch": "@@ -38,3 +38,7 @@ fn truncate[T](&smallintmap[T] m, uint len) {\n     m.v = vec::slice_mut[option::t[T]](m.v, 0u, len);\n }\n \n+fn max_key[T](&smallintmap[T] m) -> uint {\n+    ret vec::len[option::t[T]](m.v);\n+}\n+"}, {"sha": "275efd813e487f50fc6e727551def9e1247487b7", "filename": "src/lib/ufind.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ddec6b5f472088e26ec81cc829c0b377fef477ac/src%2Flib%2Fufind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddec6b5f472088e26ec81cc829c0b377fef477ac/src%2Flib%2Fufind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fufind.rs?ref=ddec6b5f472088e26ec81cc829c0b377fef477ac", "patch": "@@ -20,6 +20,12 @@ fn make_set(&ufind ufnd) -> uint {\n     ret idx;\n }\n \n+/// Creates sets as necessary to ensure that least `n` sets are present in the\n+/// data structure.\n+fn grow(&ufind ufnd, uint n) {\n+    while (set_count(ufnd) < n) { make_set(ufnd); }\n+}\n+\n fn find(&ufind ufnd, uint n) -> uint {\n     alt (ufnd.nodes.(n)) {\n         case (none) { ret n; }\n@@ -37,12 +43,17 @@ fn union(&ufind ufnd, uint m, uint n) {\n     }\n }\n \n+fn set_count(&ufind ufnd) -> uint {\n+    ret vec::len[node](ufnd.nodes);\n+}\n+\n // Removes all sets with IDs greater than or equal to the given value.\n fn prune(&ufind ufnd, uint n) {\n     // TODO: Use \"slice\" once we get rid of \"mutable?\"\n-    while (n != 0u) {\n+    auto len = vec::len[node](ufnd.nodes);\n+    while (len != n) {\n         vec::pop[node](ufnd.nodes);\n-        n -= 1u;\n+        len -= 1u;\n     }\n }\n "}, {"sha": "c5aeb49d80b720dbbcbbc4eec61243aedcd78e1b", "filename": "src/lib/uint.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ddec6b5f472088e26ec81cc829c0b377fef477ac/src%2Flib%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddec6b5f472088e26ec81cc829c0b377fef477ac/src%2Flib%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fuint.rs?ref=ddec6b5f472088e26ec81cc829c0b377fef477ac", "patch": "@@ -12,6 +12,11 @@ fn ne(uint x, uint y) -> bool { ret x != y; }\n fn ge(uint x, uint y) -> bool { ret x >= y; }\n fn gt(uint x, uint y) -> bool { ret x > y; }\n \n+fn max(uint x, uint y) -> uint {\n+    if (x > y) { ret x; }\n+    ret y;\n+}\n+\n iter range(uint lo, uint hi) -> uint {\n     auto lo_ = lo;\n     while (lo_ < hi) {"}, {"sha": "2f82f330446ebab846260f5338f32963df9896e5", "filename": "src/lib/vec.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ddec6b5f472088e26ec81cc829c0b377fef477ac/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddec6b5f472088e26ec81cc829c0b377fef477ac/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=ddec6b5f472088e26ec81cc829c0b377fef477ac", "patch": "@@ -210,15 +210,15 @@ fn unshift[T](&mutable array[T] v, &T t) {\n     v = res;\n }\n \n-fn grow[T](&array[T] v, uint n, &T initval) {\n+fn grow[T](&mutable array[T] v, uint n, &T initval) {\n     let uint i = n;\n     while (i > 0u) {\n         i -= 1u;\n         v += [initval];\n     }\n }\n \n-fn grow_set[T](&vec[mutable T] v, uint index, &T initval, &T val) {\n+fn grow_set[T](&mutable vec[mutable T] v, uint index, &T initval, &T val) {\n     auto length = vec::len(v);\n     if (index >= length) {\n         grow(v, index - length + 1u, initval);\n@@ -393,6 +393,12 @@ fn reversed[T](vec[T] v) -> vec[T] {\n     ret res;\n }\n \n+/// Truncates the vector to length `new_len`.\n+/// FIXME: This relies on a typechecker bug (covariance vs. invariance).\n+fn truncate[T](&mutable vec[mutable? T] v, uint new_len) {\n+    v = slice[T](v, 0u, new_len);\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "9a7591ab7cebdd7830320b4f9f30ca643e030d85", "filename": "src/test/compile-fail/ext-nonexistent.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddec6b5f472088e26ec81cc829c0b377fef477ac/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddec6b5f472088e26ec81cc829c0b377fef477ac/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs?ref=ddec6b5f472088e26ec81cc829c0b377fef477ac", "patch": "@@ -1,5 +1,4 @@\n-\n // error-pattern:unknown syntax expander\n fn main() {\n   #iamnotanextensionthatexists(\"\");\n-}\n\\ No newline at end of file\n+}"}]}