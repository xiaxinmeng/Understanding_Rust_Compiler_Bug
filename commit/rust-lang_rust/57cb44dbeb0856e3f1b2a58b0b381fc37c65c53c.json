{"sha": "57cb44dbeb0856e3f1b2a58b0b381fc37c65c53c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3Y2I0NGRiZWIwODU2ZTNmMWIyYTU4YjBiMzgxZmMzN2M2NWM1M2M=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-06-11T02:13:56Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-06-13T18:45:14Z"}, "message": "Change sync::RWlock implementation to use atomic uint instead of exclusive, for performance. Close #7066.", "tree": {"sha": "59edca01f4c0494bddc15651bf6717ddd4ae1a47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59edca01f4c0494bddc15651bf6717ddd4ae1a47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57cb44dbeb0856e3f1b2a58b0b381fc37c65c53c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57cb44dbeb0856e3f1b2a58b0b381fc37c65c53c", "html_url": "https://github.com/rust-lang/rust/commit/57cb44dbeb0856e3f1b2a58b0b381fc37c65c53c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57cb44dbeb0856e3f1b2a58b0b381fc37c65c53c/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68e8fe9b6e8cd1abf88822c12738a8cd8fc950a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/68e8fe9b6e8cd1abf88822c12738a8cd8fc950a5", "html_url": "https://github.com/rust-lang/rust/commit/68e8fe9b6e8cd1abf88822c12738a8cd8fc950a5"}], "stats": {"total": 137, "additions": 80, "deletions": 57}, "files": [{"sha": "86cc014f714b27b89917d93b8edc706bbd211636", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 80, "deletions": 57, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/57cb44dbeb0856e3f1b2a58b0b381fc37c65c53c/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57cb44dbeb0856e3f1b2a58b0b381fc37c65c53c/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=57cb44dbeb0856e3f1b2a58b0b381fc37c65c53c", "patch": "@@ -20,7 +20,8 @@ use core::prelude::*;\n use core::borrow;\n use core::comm;\n use core::task;\n-use core::unstable::sync::{Exclusive, exclusive};\n+use core::unstable::sync::{Exclusive, exclusive, UnsafeAtomicRcBox};\n+use core::unstable::atomics;\n use core::util;\n \n /****************************************************************************\n@@ -37,6 +38,7 @@ type SignalEnd = comm::ChanOne<()>;\n struct Waitqueue { head: comm::Port<SignalEnd>,\n                    tail: comm::Chan<SignalEnd> }\n \n+#[doc(hidden)]\n fn new_waitqueue() -> Waitqueue {\n     let (block_head, block_tail) = comm::stream();\n     Waitqueue { head: block_head, tail: block_tail }\n@@ -166,22 +168,27 @@ impl Sem<~[Waitqueue]> {\n // FIXME(#3588) should go inside of access()\n #[doc(hidden)]\n type SemRelease<'self> = SemReleaseGeneric<'self, ()>;\n+#[doc(hidden)]\n type SemAndSignalRelease<'self> = SemReleaseGeneric<'self, ~[Waitqueue]>;\n+#[doc(hidden)]\n struct SemReleaseGeneric<'self, Q> { sem: &'self Sem<Q> }\n \n+#[doc(hidden)]\n #[unsafe_destructor]\n impl<'self, Q:Owned> Drop for SemReleaseGeneric<'self, Q> {\n     fn finalize(&self) {\n         self.sem.release();\n     }\n }\n \n+#[doc(hidden)]\n fn SemRelease<'r>(sem: &'r Sem<()>) -> SemRelease<'r> {\n     SemReleaseGeneric {\n         sem: sem\n     }\n }\n \n+#[doc(hidden)]\n fn SemAndSignalRelease<'r>(sem: &'r Sem<~[Waitqueue]>)\n                         -> SemAndSignalRelease<'r> {\n     SemReleaseGeneric {\n@@ -465,8 +472,23 @@ impl Mutex {\n \n #[doc(hidden)]\n struct RWlockInner {\n+    // You might ask, \"Why don't you need to use an atomic for the mode flag?\"\n+    // This flag affects the behaviour of readers (for plain readers, they\n+    // assert on it; for downgraders, they use it to decide which mode to\n+    // unlock for). Consider that the flag is only unset when the very last\n+    // reader exits; therefore, it can never be unset during a reader/reader\n+    // (or reader/downgrader) race.\n+    // By the way, if we didn't care about the assert in the read unlock path,\n+    // we could instead store the mode flag in write_downgrade's stack frame,\n+    // and have the downgrade tokens store a borrowed pointer to it.\n     read_mode:  bool,\n-    read_count: uint\n+    // The only way the count flag is ever accessed is with xadd. Since it is\n+    // a read-modify-write operation, multiple xadds on different cores will\n+    // always be consistent with respect to each other, so a monotonic/relaxed\n+    // consistency ordering suffices (i.e., no extra barriers are needed).\n+    // FIXME(#6598): The atomics module has no relaxed ordering flag, so I use\n+    // acquire/release orderings superfluously. Change these someday.\n+    read_count: atomics::AtomicUint,\n }\n \n /**\n@@ -479,7 +501,7 @@ struct RWlockInner {\n pub struct RWlock {\n     priv order_lock:  Semaphore,\n     priv access_lock: Sem<~[Waitqueue]>,\n-    priv state:       Exclusive<RWlockInner>\n+    priv state:       UnsafeAtomicRcBox<RWlockInner>,\n }\n \n /// Create a new rwlock, with one associated condvar.\n@@ -490,10 +512,13 @@ pub fn RWlock() -> RWlock { rwlock_with_condvars(1) }\n  * Similar to mutex_with_condvars.\n  */\n pub fn rwlock_with_condvars(num_condvars: uint) -> RWlock {\n-    RWlock { order_lock: semaphore(1),\n+    let state = UnsafeAtomicRcBox::new(RWlockInner {\n+        read_mode:  false,\n+        read_count: atomics::AtomicUint::new(0),\n+    });\n+    RWlock { order_lock:  semaphore(1),\n              access_lock: new_sem_and_signal(1, num_condvars),\n-             state: exclusive(RWlockInner { read_mode:  false,\n-                                             read_count: 0 }) }\n+             state:       state, }\n }\n \n impl RWlock {\n@@ -513,20 +538,11 @@ impl RWlock {\n         unsafe {\n             do task::unkillable {\n                 do (&self.order_lock).access {\n-                    let mut first_reader = false;\n-                    do self.state.with |state| {\n-                        first_reader = (state.read_count == 0);\n-                        state.read_count += 1;\n-                    }\n-                    if first_reader {\n+                    let state = &mut *self.state.get();\n+                    let old_count = state.read_count.fetch_add(1, atomics::Acquire);\n+                    if old_count == 0 {\n                         (&self.access_lock).acquire();\n-                        do self.state.with |state| {\n-                            // Must happen *after* getting access_lock. If\n-                            // this is set while readers are waiting, but\n-                            // while a writer holds the lock, the writer will\n-                            // be confused if they downgrade-then-unlock.\n-                            state.read_mode = true;\n-                        }\n+                        state.read_mode = true;\n                     }\n                 }\n                 release = Some(RWlockReleaseRead(self));\n@@ -606,12 +622,12 @@ impl RWlock {\n      * # Example\n      *\n      * ~~~ {.rust}\n-     * do lock.write_downgrade |write_mode| {\n-     *     do (&write_mode).write_cond |condvar| {\n+     * do lock.write_downgrade |write_token| {\n+     *     do (&write_token).write_cond |condvar| {\n      *         ... exclusive access ...\n      *     }\n-     *     let read_mode = lock.downgrade(write_mode);\n-     *     do (&read_mode).read {\n+     *     let read_token = lock.downgrade(write_token);\n+     *     do (&read_token).read {\n      *         ... shared access ...\n      *     }\n      * }\n@@ -640,14 +656,15 @@ impl RWlock {\n         }\n         unsafe {\n             do task::unkillable {\n-                let mut first_reader = false;\n-                do self.state.with |state| {\n-                    assert!(!state.read_mode);\n-                    state.read_mode = true;\n-                    first_reader = (state.read_count == 0);\n-                    state.read_count += 1;\n-                }\n-                if !first_reader {\n+                let state = &mut *self.state.get();\n+                assert!(!state.read_mode);\n+                state.read_mode = true;\n+                // If a reader attempts to enter at this point, both the\n+                // downgrader and reader will set the mode flag. This is fine.\n+                let old_count = state.read_count.fetch_add(1, atomics::Release);\n+                // If another reader was already blocking, we need to hand-off\n+                // the \"reader cloud\" access lock to them.\n+                if old_count != 0 {\n                     // Guaranteed not to let another writer in, because\n                     // another reader was holding the order_lock. Hence they\n                     // must be the one to get the access_lock (because all\n@@ -667,29 +684,30 @@ struct RWlockReleaseRead<'self> {\n     lock: &'self RWlock,\n }\n \n+#[doc(hidden)]\n #[unsafe_destructor]\n impl<'self> Drop for RWlockReleaseRead<'self> {\n     fn finalize(&self) {\n         unsafe {\n             do task::unkillable {\n-                let mut last_reader = false;\n-                do self.lock.state.with |state| {\n-                    assert!(state.read_mode);\n-                    assert!(state.read_count > 0);\n-                    state.read_count -= 1;\n-                    if state.read_count == 0 {\n-                        last_reader = true;\n-                        state.read_mode = false;\n-                    }\n-                }\n-                if last_reader {\n+                let state = &mut *self.lock.state.get();\n+                assert!(state.read_mode);\n+                let old_count = state.read_count.fetch_sub(1, atomics::Release);\n+                assert!(old_count > 0);\n+                if old_count == 1 {\n+                    state.read_mode = false;\n+                    // Note: this release used to be outside of a locked access\n+                    // to exclusive-protected state. If this code is ever\n+                    // converted back to such (instead of using atomic ops),\n+                    // this access MUST NOT go inside the exclusive access.\n                     (&self.lock.access_lock).release();\n                 }\n             }\n         }\n     }\n }\n \n+#[doc(hidden)]\n fn RWlockReleaseRead<'r>(lock: &'r RWlock) -> RWlockReleaseRead<'r> {\n     RWlockReleaseRead {\n         lock: lock\n@@ -703,37 +721,42 @@ struct RWlockReleaseDowngrade<'self> {\n     lock: &'self RWlock,\n }\n \n+#[doc(hidden)]\n #[unsafe_destructor]\n impl<'self> Drop for RWlockReleaseDowngrade<'self> {\n     fn finalize(&self) {\n         unsafe {\n             do task::unkillable {\n-                let mut writer_or_last_reader = false;\n-                do self.lock.state.with |state| {\n-                    if state.read_mode {\n-                        assert!(state.read_count > 0);\n-                        state.read_count -= 1;\n-                        if state.read_count == 0 {\n-                            // Case 1: Writer downgraded & was the last reader\n-                            writer_or_last_reader = true;\n-                            state.read_mode = false;\n-                        } else {\n-                            // Case 2: Writer downgraded & was not the last\n-                            // reader\n-                        }\n-                    } else {\n-                        // Case 3: Writer did not downgrade\n+                let writer_or_last_reader;\n+                // Check if we're releasing from read mode or from write mode.\n+                let state = &mut *self.lock.state.get();\n+                if state.read_mode {\n+                    // Releasing from read mode.\n+                    let old_count = state.read_count.fetch_sub(1, atomics::Release);\n+                    assert!(old_count > 0);\n+                    // Check if other readers remain.\n+                    if old_count == 1 {\n+                        // Case 1: Writer downgraded & was the last reader\n                         writer_or_last_reader = true;\n+                        state.read_mode = false;\n+                    } else {\n+                        // Case 2: Writer downgraded & was not the last reader\n+                        writer_or_last_reader = false;\n                     }\n+                } else {\n+                    // Case 3: Writer did not downgrade\n+                    writer_or_last_reader = true;\n                 }\n                 if writer_or_last_reader {\n+                    // Nobody left inside; release the \"reader cloud\" lock.\n                     (&self.lock.access_lock).release();\n                 }\n             }\n         }\n     }\n }\n \n+#[doc(hidden)]\n fn RWlockReleaseDowngrade<'r>(lock: &'r RWlock)\n                            -> RWlockReleaseDowngrade<'r> {\n     RWlockReleaseDowngrade {"}]}