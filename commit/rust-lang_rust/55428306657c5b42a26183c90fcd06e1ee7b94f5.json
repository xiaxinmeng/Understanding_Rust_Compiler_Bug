{"sha": "55428306657c5b42a26183c90fcd06e1ee7b94f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1NDI4MzA2NjU3YzViNDJhMjYxODNjOTBmY2QwNmUxZWU3Yjk0ZjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-22T16:58:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-22T16:58:56Z"}, "message": "Auto merge of #27219 - steveklabnik:rollup, r=steveklabnik\n\n- Successful merges: #27084, #27127, #27131, #27140, #27146, #27147, #27151, #27154, #27155, #27156, #27157, #27158, #27163, #27164, #27166, #27167, #27170, #27175, #27183, #27201, #27202\n- Failed merges: #26778", "tree": {"sha": "73fa8e52bdc282916ff8836ec93d7f65229042c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73fa8e52bdc282916ff8836ec93d7f65229042c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55428306657c5b42a26183c90fcd06e1ee7b94f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55428306657c5b42a26183c90fcd06e1ee7b94f5", "html_url": "https://github.com/rust-lang/rust/commit/55428306657c5b42a26183c90fcd06e1ee7b94f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55428306657c5b42a26183c90fcd06e1ee7b94f5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d", "html_url": "https://github.com/rust-lang/rust/commit/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d"}, {"sha": "5f04b1b384204bfad1e1e582b36ef99c78c5cc19", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f04b1b384204bfad1e1e582b36ef99c78c5cc19", "html_url": "https://github.com/rust-lang/rust/commit/5f04b1b384204bfad1e1e582b36ef99c78c5cc19"}], "stats": {"total": 950, "additions": 893, "deletions": 57}, "files": [{"sha": "753a5a32e8a1bfff0249e479e05ffd7292f0b998", "filename": "src/doc/trpl/ffi.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Fdoc%2Ftrpl%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Fdoc%2Ftrpl%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fffi.md?ref=55428306657c5b42a26183c90fcd06e1ee7b94f5", "patch": "@@ -340,7 +340,7 @@ libraries:\n Note that frameworks are only available on OSX targets.\n \n The different `kind` values are meant to differentiate how the native library\n-participates in linkage. From a linkage perspective, the rust compiler creates\n+participates in linkage. From a linkage perspective, the Rust compiler creates\n two flavors of artifacts: partial (rlib/staticlib) and final (dylib/binary).\n Native dynamic library and framework dependencies are propagated to the final\n artifact boundary, while static library dependencies are not propagated at\n@@ -350,9 +350,9 @@ artifact.\n A few examples of how this model can be used are:\n \n * A native build dependency. Sometimes some C/C++ glue is needed when writing\n-  some rust code, but distribution of the C/C++ code in a library format is just\n+  some Rust code, but distribution of the C/C++ code in a library format is just\n   a burden. In this case, the code will be archived into `libfoo.a` and then the\n-  rust crate would declare a dependency via `#[link(name = \"foo\", kind =\n+  Rust crate would declare a dependency via `#[link(name = \"foo\", kind =\n   \"static\")]`.\n \n   Regardless of the flavor of output for the crate, the native static library\n@@ -361,7 +361,7 @@ A few examples of how this model can be used are:\n \n * A normal dynamic dependency. Common system libraries (like `readline`) are\n   available on a large number of systems, and often a static copy of these\n-  libraries cannot be found. When this dependency is included in a rust crate,\n+  libraries cannot be found. When this dependency is included in a Rust crate,\n   partial targets (like rlibs) will not link to the library, but when the rlib\n   is included in a final target (like a binary), the native library will be\n   linked in."}, {"sha": "83750ec3b01adff931f9dfc68d22bd13e526b55d", "filename": "src/doc/trpl/installing-rust.md", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Fdoc%2Ftrpl%2Finstalling-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Fdoc%2Ftrpl%2Finstalling-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Finstalling-rust.md?ref=55428306657c5b42a26183c90fcd06e1ee7b94f5", "patch": "@@ -2,7 +2,7 @@\n \n The first step to using Rust is to install it! There are a number of ways to\n install Rust, but the easiest is to use the `rustup` script. If you're on Linux\n-or a Mac, all you need to do is this: \n+or a Mac, all you need to do is this:\n \n > Note: you don't need to type in the `$`s, they just indicate the start of\n > each command. You\u2019ll see many tutorials and examples around the web that\n@@ -25,6 +25,12 @@ $ sh rustup.sh\n [insecurity]: http://curlpipesh.tumblr.com\n \n If you're on Windows, please download the appropriate [installer][install-page].\n+**NOTE:** By default, the Windows installer will not add Rust to the %PATH%\n+system variable. If this is the only version of Rust you are installing and you\n+want to be able to run it from the command line, click on \"Advanced\" on the\n+install dialog and on the \"Product Features\" page ensure \"Add to PATH\" is\n+installed on the local hard drive.\n+\n \n [install-page]: http://www.rust-lang.org/install.html\n \n@@ -87,6 +93,11 @@ rustc 1.0.0 (a59de37e9 2015-05-13)\n \n If you did, Rust has been installed successfully! Congrats!\n \n+If you didn't and you're on Windows, check that Rust is in your %PATH% system\n+variable. If it isn't, run the installer again, select \"Change\" on the \"Change,\n+repair, or remove installation\" page and ensure \"Add to PATH\" is installed on\n+the local hard drive.\n+\n This installer also installs a copy of the documentation locally, so you can\n read it offline. On UNIX systems, `/usr/local/share/doc/rust` is the location.\n On Windows, it's in a `share/doc` directory, inside wherever you installed Rust\n@@ -101,5 +112,5 @@ resources include [the user\u2019s forum][users], and\n \n [irc]: irc://irc.mozilla.org/#rust\n [mibbit]: http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust\n-[users]: http://users.rust-lang.org/ \n+[users]: http://users.rust-lang.org/\n [stackoverflow]: http://stackoverflow.com/questions/tagged/rust"}, {"sha": "1e203c6553ee107f11cf205bab3da4062133225c", "filename": "src/doc/trpl/release-channels.md", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Fdoc%2Ftrpl%2Frelease-channels.md", "raw_url": "https://github.com/rust-lang/rust/raw/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Fdoc%2Ftrpl%2Frelease-channels.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Frelease-channels.md?ref=55428306657c5b42a26183c90fcd06e1ee7b94f5", "patch": "@@ -43,3 +43,26 @@ This will help alert the team in case there\u2019s an accidental regression.\n Additionally, testing against nightly can catch regressions even sooner, and so\n if you don\u2019t mind a third build, we\u2019d appreciate testing against all channels.\n \n+As an example, many Rust programmers use [Travis](https://travis-ci.org/) to\n+test their crates, which is free for open source projects. Travis [supports\n+Rust directly][travis], and you can use a `.travis.yml` file like this to\n+test on all channels:\n+\n+```yaml\n+language: rust\n+rust:\n+  - nightly\n+  - beta\n+  - stable\n+\n+matrix:\n+  allow_failures:\n+    - rust: nightly\n+```\n+\n+[travis]: http://docs.travis-ci.com/user/languages/rust/\n+\n+With this configuration, Travis will test all three channels, but if something\n+breaks on nightly, it won\u2019t fail your build. A similar configuration is\n+recommended for any CI system, check the documentation of the one you\u2019re\n+using for more details."}, {"sha": "1b223365bd63ac72a15c072fc79da5a5ec3967d9", "filename": "src/doc/trpl/unsafe.md", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Fdoc%2Ftrpl%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Fdoc%2Ftrpl%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe.md?ref=55428306657c5b42a26183c90fcd06e1ee7b94f5", "patch": "@@ -100,10 +100,14 @@ that you normally can not do. Just three. Here they are:\n \n That\u2019s it. It\u2019s important that `unsafe` does not, for example, \u2018turn off the\n borrow checker\u2019. Adding `unsafe` to some random Rust code doesn\u2019t change its\n-semantics, it won\u2019t just start accepting anything.\n+semantics, it won\u2019t just start accepting anything. But it will let you write\n+things that _do_ break some of the rules.\n \n-But it will let you write things that _do_ break some of the rules. Let\u2019s go\n-over these three abilities in order.\n+You will also encounter the `unsafe` keyword when writing bindings to foreign\n+(non-Rust) interfaces. You're encouraged to write a safe, native Rust interface\n+around the methods provided by the library.\n+\n+Let\u2019s go over the basic three abilities listed, in order.\n \n ## Access or update a `static mut`\n "}, {"sha": "415326a8a616e950c6464b383bc2be0796eff173", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=55428306657c5b42a26183c90fcd06e1ee7b94f5", "patch": "@@ -2555,7 +2555,7 @@ impl<I: RandomAccessIterator, F> RandomAccessIterator for Inspect<I, F>\n #[unstable(feature = \"iter_unfold\")]\n #[derive(Clone)]\n #[deprecated(since = \"1.2.0\",\n-             reason = \"has gained enough traction to retain its position \\\n+             reason = \"has not gained enough traction to retain its position \\\n                        in the standard library\")]\n #[allow(deprecated)]\n pub struct Unfold<St, F> {\n@@ -2567,7 +2567,7 @@ pub struct Unfold<St, F> {\n \n #[unstable(feature = \"iter_unfold\")]\n #[deprecated(since = \"1.2.0\",\n-             reason = \"has gained enough traction to retain its position \\\n+             reason = \"has not gained enough traction to retain its position \\\n                        in the standard library\")]\n #[allow(deprecated)]\n impl<A, St, F> Unfold<St, F> where F: FnMut(&mut St) -> Option<A> {\n@@ -3018,7 +3018,7 @@ type IterateState<T, F> = (F, Option<T>, bool);\n /// from a given seed value.\n #[unstable(feature = \"iter_iterate\")]\n #[deprecated(since = \"1.2.0\",\n-             reason = \"has gained enough traction to retain its position \\\n+             reason = \"has not gained enough traction to retain its position \\\n                        in the standard library\")]\n #[allow(deprecated)]\n pub type Iterate<T, F> = Unfold<IterateState<T, F>, fn(&mut IterateState<T, F>) -> Option<T>>;\n@@ -3027,7 +3027,7 @@ pub type Iterate<T, F> = Unfold<IterateState<T, F>, fn(&mut IterateState<T, F>)\n /// repeated applications of the given function `f`.\n #[unstable(feature = \"iter_iterate\")]\n #[deprecated(since = \"1.2.0\",\n-             reason = \"has gained enough traction to retain its position \\\n+             reason = \"has not gained enough traction to retain its position \\\n                        in the standard library\")]\n #[allow(deprecated)]\n pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where"}, {"sha": "a10e0b8dfc29e4b8ddd360f372d9be1cb279dbf3", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=55428306657c5b42a26183c90fcd06e1ee7b94f5", "patch": "@@ -165,7 +165,7 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n         if from_tc.interior_param() || to_tc.interior_param() {\n             span_err!(self.tcx.sess, span, E0139,\n                       \"cannot transmute to or from a type that contains \\\n-                       type parameters in its interior\");\n+                       unsubstituted type parameters\");\n             return;\n         }\n "}, {"sha": "5a941c757fc6d939543c65511daba3efff7559f5", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 155, "deletions": 9, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=55428306657c5b42a26183c90fcd06e1ee7b94f5", "patch": "@@ -106,8 +106,7 @@ mod foo {\n use foo::MyTrait::do_something;\n ```\n \n-In general, it's not legal to directly import methods belonging to a\n-trait or concrete type.\n+It's illegal to directly import methods belonging to a trait or concrete type.\n \"##,\n \n E0255: r##\"\n@@ -272,7 +271,160 @@ See the 'Use Declarations' section of the reference for more information\n on this topic:\n \n http://doc.rust-lang.org/reference.html#use-declarations\n-\"##\n+\"##,\n+\n+E0403: r##\"\n+Some type parameters have the same name. Example of erroneous code:\n+\n+```\n+fn foo<T, T>(s: T, u: T) {} // error: the name `T` is already used for a type\n+                            //        parameter in this type parameter list\n+```\n+\n+Please verify that none of the type parameterss are misspelled, and rename any\n+clashing parameters. Example:\n+\n+```\n+fn foo<T, Y>(s: T, u: Y) {} // ok!\n+```\n+\"##,\n+\n+E0404: r##\"\n+You tried to implement something which was not a trait on an object. Example of\n+erroneous code:\n+\n+```\n+struct Foo;\n+struct Bar;\n+\n+impl Foo for Bar {} // error: `Foo` is not a trait\n+```\n+\n+Please verify that you didn't misspell the trait's name or otherwise use the\n+wrong identifier. Example:\n+\n+```\n+trait Foo {\n+    // some functions\n+}\n+struct Bar;\n+\n+impl Foo for Bar { // ok!\n+    // functions implementation\n+}\n+```\n+\"##,\n+\n+E0405: r##\"\n+An unknown trait was implemented. Example of erroneous code:\n+\n+```\n+struct Foo;\n+\n+impl SomeTrait for Foo {} // error: use of undeclared trait name `SomeTrait`\n+```\n+\n+Please verify that the name of the trait wasn't misspelled and ensure that it\n+was imported. Example:\n+\n+```\n+// solution 1:\n+use some_file::SomeTrait;\n+\n+// solution 2:\n+trait SomeTrait {\n+    // some functions\n+}\n+\n+struct Foo;\n+\n+impl SomeTrait for Foo { // ok!\n+    // implements functions\n+}\n+```\n+\"##,\n+\n+E0407: r##\"\n+A definition of a method not in the implemented trait was given in a trait\n+implementation. Example of erroneous code:\n+\n+```\n+trait Foo {\n+    fn a();\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    fn a() {}\n+    fn b() {} // error: method `b` is not a member of trait `Foo`\n+}\n+```\n+\n+Please verify you didn't misspell the method name and you used the correct\n+trait. First example:\n+\n+```\n+trait Foo {\n+    fn a();\n+    fn b();\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    fn a() {}\n+    fn b() {} // ok!\n+}\n+```\n+\n+Second example:\n+\n+```\n+trait Foo {\n+    fn a();\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    fn a() {}\n+}\n+\n+impl Bar {\n+    fn b() {}\n+}\n+```\n+\"##,\n+\n+E0428: r##\"\n+A type or module has been defined more than once. Example of erroneous\n+code:\n+\n+```\n+struct Bar;\n+struct Bar; // error: duplicate definition of value `Bar`\n+```\n+\n+Please verify you didn't misspell the type/module's name or remove/rename the\n+duplicated one. Example:\n+\n+```\n+struct Bar;\n+struct Bar2; // ok!\n+```\n+\"##,\n+\n+E0433: r##\"\n+Invalid import. Example of erroneous code:\n+\n+```\n+use something_which_doesnt_exist;\n+// error: unresolved import `something_which_doesnt_exist`\n+```\n+\n+Please verify you didn't misspell the import's name.\n+\"##,\n \n }\n \n@@ -284,11 +436,7 @@ register_diagnostics! {\n     E0258,\n     E0401, // can't use type parameters from outer function\n     E0402, // cannot use an outer type parameter in this context\n-    E0403, // the name `{}` is already used\n-    E0404, // is not a trait\n-    E0405, // use of undeclared trait name\n     E0406, // undeclared associated type\n-    E0407, // method is not a member of trait\n     E0408, // variable from pattern #1 is not bound in pattern #\n     E0409, // variable is bound with different mode in pattern # than in\n            // pattern #1\n@@ -313,13 +461,11 @@ register_diagnostics! {\n     E0425, // unresolved name\n     E0426, // use of undeclared label\n     E0427, // cannot use `ref` binding mode with ...\n-    E0428, // duplicate definition of ...\n     E0429, // `self` imports are only allowed within a { } list\n     E0430, // `self` import can only appear once in the list\n     E0431, // `self` import can only appear in an import list with a non-empty\n            // prefix\n     E0432, // unresolved import\n-    E0433, // failed to resolve\n     E0434, // can't capture dynamic environment in a fn item\n     E0435, // attempt to use a non-constant value in a constant\n     E0437, // type is not a member of trait"}, {"sha": "f865de522b28aa0611eee697e87d930d9c487d73", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=55428306657c5b42a26183c90fcd06e1ee7b94f5", "patch": "@@ -1458,6 +1458,33 @@ return, for example with a `loop` that never breaks or a call to another\n diverging function (such as `panic!()`).\n \"##,\n \n+E0172: r##\"\n+This error means that an attempt was made to specify the type of a variable with\n+a combination of a concrete type and a trait. Consider the following example:\n+\n+```\n+fn foo(bar: i32+std::fmt::Display) {}\n+```\n+\n+The code is trying to specify that we want to receive a signed 32-bit integer\n+which also implements `Display`. This doesn't make sense: when we pass `i32`, a\n+concrete type, it implicitly includes all of the traits that it implements.\n+This includes `Display`, `Debug`, `Clone`, and a host of others.\n+\n+If `i32` implements the trait we desire, there's no need to specify the trait\n+separately. If it does not, then we need to `impl` the trait for `i32` before\n+passing it into `foo`. Either way, a fixed definition for `foo` will look like\n+the following:\n+\n+```\n+fn foo(bar: i32) {}\n+```\n+\n+To learn more about traits, take a look at the Book:\n+\n+https://doc.rust-lang.org/book/traits.html\n+\"##,\n+\n E0178: r##\"\n In types, the `+` type operator has low precedence, so it is often necessary\n to use parentheses.\n@@ -2178,7 +2205,6 @@ register_diagnostics! {\n     E0164,\n     E0167,\n     E0168,\n-    E0172,\n     E0173, // manual implementations of unboxed closure traits are experimental\n     E0174, // explicit use of unboxed closure methods are experimental\n     E0182,"}, {"sha": "c25aa35ffbe3b339d9045ea47a6c15a6bd904f4d", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 290, "deletions": 9, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=55428306657c5b42a26183c90fcd06e1ee7b94f5", "patch": "@@ -252,14 +252,49 @@ impl<R: Seek> Seek for BufReader<R> {\n     }\n }\n \n-/// Wraps a Writer and buffers output to it.\n+/// Wraps a writer and buffers its output.\n ///\n-/// It can be excessively inefficient to work directly with a `Write`. For\n-/// example, every call to `write` on `TcpStream` results in a system call. A\n-/// `BufWriter` keeps an in memory buffer of data and writes it to the\n-/// underlying `Write` in large, infrequent batches.\n+/// It can be excessively inefficient to work directly with something that\n+/// implements `Write`. For example, every call to `write` on `TcpStream`\n+/// results in a system call. A `BufWriter` keeps an in-memory buffer of data\n+/// and writes it to an underlying writer in large, infrequent batches.\n ///\n /// The buffer will be written out when the writer is dropped.\n+///\n+/// # Examples\n+///\n+/// Let's write the numbers one through ten to a `TcpStream`:\n+///\n+/// ```no_run\n+/// use std::io::prelude::*;\n+/// use std::net::TcpStream;\n+///\n+/// let mut stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n+///\n+/// for i in 1..10 {\n+///     stream.write(&[i]).unwrap();\n+/// }\n+/// ```\n+///\n+/// Because we're not buffering, we write each one in turn, incurring the\n+/// overhead of a system call per byte written. We can fix this with a\n+/// `BufWriter`:\n+///\n+/// ```no_run\n+/// use std::io::prelude::*;\n+/// use std::io::BufWriter;\n+/// use std::net::TcpStream;\n+///\n+/// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+///\n+/// for i in 1..10 {\n+///     stream.write(&[i]).unwrap();\n+/// }\n+/// ```\n+///\n+/// By wrapping the stream with a `BufWriter`, these ten writes are all grouped\n+/// together by the buffer, and will all be written out in one system call when\n+/// the `stream` is dropped.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BufWriter<W: Write> {\n     inner: Option<W>,\n@@ -269,18 +304,60 @@ pub struct BufWriter<W: Write> {\n /// An error returned by `into_inner` which combines an error that\n /// happened while writing out the buffer, and the buffered writer object\n /// which may be used to recover from the condition.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::io::BufWriter;\n+/// use std::net::TcpStream;\n+///\n+/// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+///\n+/// // do stuff with the stream\n+///\n+/// // we want to get our `TcpStream` back, so let's try:\n+///\n+/// let stream = match stream.into_inner() {\n+///     Ok(s) => s,\n+///     Err(e) => {\n+///         // Here, e is an IntoInnerError\n+///         panic!(\"An error occurred\");\n+///     }\n+/// };\n+/// ```\n #[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoInnerError<W>(W, Error);\n \n impl<W: Write> BufWriter<W> {\n     /// Creates a new `BufWriter` with a default buffer capacity.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(inner: W) -> BufWriter<W> {\n         BufWriter::with_capacity(DEFAULT_BUF_SIZE, inner)\n     }\n \n     /// Creates a new `BufWriter` with the specified buffer capacity.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Creating a buffer with a buffer of a hundred bytes.\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n+    /// let mut buffer = BufWriter::with_capacity(100, stream);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(cap: usize, inner: W) -> BufWriter<W> {\n         BufWriter {\n@@ -313,6 +390,18 @@ impl<W: Write> BufWriter<W> {\n     }\n \n     /// Gets a reference to the underlying writer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    ///\n+    /// // we can use reference just like buffer\n+    /// let reference = buffer.get_ref();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_ref(&self) -> &W { self.inner.as_ref().unwrap() }\n \n@@ -321,12 +410,36 @@ impl<W: Write> BufWriter<W> {\n     /// # Warning\n     ///\n     /// It is inadvisable to directly write to the underlying writer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    ///\n+    /// // we can use reference just like buffer\n+    /// let reference = buffer.get_mut();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut W { self.inner.as_mut().unwrap() }\n \n     /// Unwraps this `BufWriter`, returning the underlying writer.\n     ///\n     /// The buffer is written out before returning the writer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    ///\n+    /// // unwrap the TcpStream and flush the buffer\n+    /// let stream = buffer.into_inner().unwrap();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> {\n         match self.flush_buf() {\n@@ -384,16 +497,67 @@ impl<W: Write> Drop for BufWriter<W> {\n }\n \n impl<W> IntoInnerError<W> {\n-    /// Returns the error which caused the call to `into_inner` to fail.\n+    /// Returns the error which caused the call to `into_inner()` to fail.\n     ///\n     /// This error was returned when attempting to write the internal buffer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    ///\n+    /// // do stuff with the stream\n+    ///\n+    /// // we want to get our `TcpStream` back, so let's try:\n+    ///\n+    /// let stream = match stream.into_inner() {\n+    ///     Ok(s) => s,\n+    ///     Err(e) => {\n+    ///         // Here, e is an IntoInnerError, let's log the inner error.\n+    ///         //\n+    ///         // We'll just 'log' to stdout for this example.\n+    ///         println!(\"{}\", e.error());\n+    ///\n+    ///         panic!(\"An unexpected error occurred.\");\n+    ///     }\n+    /// };\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn error(&self) -> &Error { &self.1 }\n \n     /// Returns the buffered writer instance which generated the error.\n     ///\n     /// The returned object can be used for error recovery, such as\n     /// re-inspecting the buffer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    ///\n+    /// // do stuff with the stream\n+    ///\n+    /// // we want to get our `TcpStream` back, so let's try:\n+    ///\n+    /// let stream = match stream.into_inner() {\n+    ///     Ok(s) => s,\n+    ///     Err(e) => {\n+    ///         // Here, e is a IntoInnerError, let's re-examine the buffer:\n+    ///         let buffer = e.into_inner();\n+    ///\n+    ///         // do stuff to try to recover\n+    ///\n+    ///         // afterwards, let's just return the stream\n+    ///         buffer.into_inner().unwrap()\n+    ///     }\n+    /// };\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> W { self.0 }\n }\n@@ -417,17 +581,74 @@ impl<W> fmt::Display for IntoInnerError<W> {\n     }\n }\n \n-/// Wraps a Writer and buffers output to it, flushing whenever a newline\n+/// Wraps a writer and buffers output to it, flushing whenever a newline\n /// (`0x0a`, `'\\n'`) is detected.\n ///\n-/// The buffer will be written out when the writer is dropped.\n+/// The [`BufWriter`][bufwriter] struct wraps a writer and buffers its output.\n+/// But it only does this batched write when it goes out of scope, or when the\n+/// internal buffer is full. Sometimes, you'd prefer to write each line as it's\n+/// completed, rather than the entire buffer at once. Enter `LineWriter`. It\n+/// does exactly that.\n+///\n+/// [bufwriter]: struct.BufWriter.html\n+///\n+/// If there's still a partial line in the buffer when the `LineWriter` is\n+/// dropped, it will flush those contents.\n+///\n+/// # Examples\n+///\n+/// We can use `LineWriter` to write one line at a time, significantly\n+/// reducing the number of actual writes to the file.\n+///\n+/// ```\n+/// use std::fs::File;\n+/// use std::io::prelude::*;\n+/// use std::io::LineWriter;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// let road_not_taken = b\"I shall be telling this with a sigh\n+/// Somewhere ages and ages hence:\n+/// Two roads diverged in a wood, and I -\n+/// I took the one less traveled by,\n+/// And that has made all the difference.\";\n+///\n+/// let file = try!(File::create(\"poem.txt\"));\n+/// let mut file = LineWriter::new(file);\n+///\n+/// for &byte in road_not_taken.iter() {\n+///    file.write(&[byte]).unwrap();\n+/// }\n+///\n+/// // let's check we did the right thing.\n+/// let mut file = try!(File::open(\"poem.txt\"));\n+/// let mut contents = String::new();\n+///\n+/// try!(file.read_to_string(&mut contents));\n+///\n+/// assert_eq!(contents.as_bytes(), &road_not_taken[..]);\n+/// # Ok(())\n+/// # }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct LineWriter<W: Write> {\n     inner: BufWriter<W>,\n }\n \n impl<W: Write> LineWriter<W> {\n-    /// Creates a new `LineWriter`\n+    /// Creates a new `LineWriter`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs::File;\n+    /// use std::io::LineWriter;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let file = try!(File::create(\"poem.txt\"));\n+    /// let file = LineWriter::new(file);\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(inner: W) -> LineWriter<W> {\n         // Lines typically aren't that long, don't use a giant buffer\n@@ -436,25 +657,85 @@ impl<W: Write> LineWriter<W> {\n \n     /// Creates a new `LineWriter` with a specified capacity for the internal\n     /// buffer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs::File;\n+    /// use std::io::LineWriter;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let file = try!(File::create(\"poem.txt\"));\n+    /// let file = LineWriter::with_capacity(100, file);\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(cap: usize, inner: W) -> LineWriter<W> {\n         LineWriter { inner: BufWriter::with_capacity(cap, inner) }\n     }\n \n     /// Gets a reference to the underlying writer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs::File;\n+    /// use std::io::LineWriter;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let file = try!(File::create(\"poem.txt\"));\n+    /// let file = LineWriter::new(file);\n+    ///\n+    /// let reference = file.get_ref();\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_ref(&self) -> &W { self.inner.get_ref() }\n \n     /// Gets a mutable reference to the underlying writer.\n     ///\n     /// Caution must be taken when calling methods on the mutable reference\n     /// returned as extra writes could corrupt the output stream.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs::File;\n+    /// use std::io::LineWriter;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let file = try!(File::create(\"poem.txt\"));\n+    /// let mut file = LineWriter::new(file);\n+    ///\n+    /// // we can use reference just like file\n+    /// let reference = file.get_mut();\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut W { self.inner.get_mut() }\n \n     /// Unwraps this `LineWriter`, returning the underlying writer.\n     ///\n     /// The internal buffer is written out before returning the writer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs::File;\n+    /// use std::io::LineWriter;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let file = try!(File::create(\"poem.txt\"));\n+    ///\n+    /// let writer: LineWriter<File> = LineWriter::new(file);\n+    ///\n+    /// let file: File = try!(writer.into_inner());\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> Result<W, IntoInnerError<LineWriter<W>>> {\n         self.inner.into_inner().map_err(|IntoInnerError(buf, e)| {"}, {"sha": "4bb7d2ebd1963ef7fe1dad775895d3c9523c4a1b", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 140, "deletions": 9, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=55428306657c5b42a26183c90fcd06e1ee7b94f5", "patch": "@@ -15,16 +15,67 @@ use cmp;\n use io::{self, SeekFrom, Error, ErrorKind};\n use slice;\n \n-/// A `Cursor` is a type which wraps a non-I/O object to provide a `Seek`\n+/// A `Cursor` wraps another type and provides it with a [`Seek`][seek]\n /// implementation.\n ///\n-/// Cursors are typically used with memory buffer objects in order to allow\n-/// `Seek`, `Read`, and `Write` implementations. For example, common cursor types\n-/// include `Cursor<Vec<u8>>` and `Cursor<&[u8]>`.\n+/// [seek]: trait.Seek.html\n ///\n-/// Implementations of the I/O traits for `Cursor<T>` are currently not generic\n-/// over `T` itself. Instead, specific implementations are provided for various\n-/// in-memory buffer types like `Vec<u8>` and `&[u8]`.\n+/// Cursors are typically used with in-memory buffers to allow them to\n+/// implement `Read` and/or `Write`, allowing these buffers to be used\n+/// anywhere you might use a reader or writer that does actual I/O.\n+///\n+/// The standard library implements some I/O traits on various types which\n+/// are commonly used as a buffer, like `Cursor<Vec<u8>>` and `Cursor<&[u8]>`.\n+///\n+/// # Examples\n+///\n+/// We may want to write bytes to a [`File`][file] in our production\n+/// code, but use an in-memory buffer in our tests. We can do this with\n+/// `Cursor`:\n+///\n+/// [file]: ../fs/struct.File.html\n+///\n+/// ```no_run\n+/// use std::io::prelude::*;\n+/// use std::io::{self, SeekFrom};\n+/// use std::fs::File;\n+///\n+/// // a library function we've written\n+/// fn write_ten_bytes_at_end<W: Write + Seek>(writer: &mut W) -> io::Result<()> {\n+///     try!(writer.seek(SeekFrom::End(-10)));\n+///\n+///     for i in 0..10 {\n+///         try!(writer.write(&[i]));\n+///     }\n+///\n+///     // all went well\n+///     Ok(())\n+/// }\n+///\n+/// # fn foo() -> io::Result<()> {\n+/// // Here's some code that uses this library function.\n+/// //\n+/// // We might want to use a BufReader here for efficiency, but let's\n+/// // keep this example focused.\n+/// let mut file = try!(File::create(\"foo.txt\"));\n+///\n+/// try!(write_ten_bytes_at_end(&mut file));\n+/// # Ok(())\n+/// # }\n+///\n+/// // now let's write a test\n+/// #[test]\n+/// fn test_writes_bytes() {\n+///     // setting up a real File is much more slow than an in-memory buffer,\n+///     // let's use a cursor instead\n+///     use std::io::Cursor;\n+///     let mut buff = Cursor::new(vec![0; 15]);\n+///\n+///     write_ten_bytes(&mut buff).unwrap();\n+///\n+///     assert_eq!(&buff.get_ref()[5..15], &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n+/// }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone, Debug)]\n pub struct Cursor<T> {\n@@ -34,31 +85,111 @@ pub struct Cursor<T> {\n \n impl<T> Cursor<T> {\n     /// Creates a new cursor wrapping the provided underlying I/O object.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::Cursor;\n+    ///\n+    /// let buff = Cursor::new(Vec::new());\n+    /// # fn force_inference(_: &Cursor<Vec<u8>>) {}\n+    /// # force_inference(&buff);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(inner: T) -> Cursor<T> {\n         Cursor { pos: 0, inner: inner }\n     }\n \n     /// Consumes this cursor, returning the underlying value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::Cursor;\n+    ///\n+    /// let buff = Cursor::new(Vec::new());\n+    /// # fn force_inference(_: &Cursor<Vec<u8>>) {}\n+    /// # force_inference(&buff);\n+    ///\n+    /// let vec = buff.into_inner();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> T { self.inner }\n \n     /// Gets a reference to the underlying value in this cursor.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::Cursor;\n+    ///\n+    /// let buff = Cursor::new(Vec::new());\n+    /// # fn force_inference(_: &Cursor<Vec<u8>>) {}\n+    /// # force_inference(&buff);\n+    ///\n+    /// let reference = buff.get_ref();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_ref(&self) -> &T { &self.inner }\n \n     /// Gets a mutable reference to the underlying value in this cursor.\n     ///\n     /// Care should be taken to avoid modifying the internal I/O state of the\n     /// underlying value as it may corrupt this cursor's position.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::Cursor;\n+    ///\n+    /// let mut buff = Cursor::new(Vec::new());\n+    /// # fn force_inference(_: &Cursor<Vec<u8>>) {}\n+    /// # force_inference(&buff);\n+    ///\n+    /// let reference = buff.get_mut();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut T { &mut self.inner }\n \n-    /// Returns the current value of this cursor\n+    /// Returns the current position of this cursor.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::Cursor;\n+    /// use std::io::prelude::*;\n+    /// use std::io::SeekFrom;\n+    ///\n+    /// let mut buff = Cursor::new(vec![1, 2, 3, 4, 5]);\n+    ///\n+    /// assert_eq!(buff.position(), 0);\n+    ///\n+    /// buff.seek(SeekFrom::Current(2)).unwrap();\n+    /// assert_eq!(buff.position(), 2);\n+    ///\n+    /// buff.seek(SeekFrom::Current(-1)).unwrap();\n+    /// assert_eq!(buff.position(), 1);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn position(&self) -> u64 { self.pos }\n \n-    /// Sets the value of this cursor\n+    /// Sets the position of this cursor.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::Cursor;\n+    ///\n+    /// let mut buff = Cursor::new(vec![1, 2, 3, 4, 5]);\n+    ///\n+    /// assert_eq!(buff.position(), 0);\n+    ///\n+    /// buff.set_position(2);\n+    /// assert_eq!(buff.position(), 2);\n+    ///\n+    /// buff.set_position(4);\n+    /// assert_eq!(buff.position(), 4);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn set_position(&mut self, pos: u64) { self.pos = pos; }\n }"}, {"sha": "fbdfdeaaef4f286bbe9aeef2ef5ca8535991778e", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=55428306657c5b42a26183c90fcd06e1ee7b94f5", "patch": "@@ -1396,7 +1396,10 @@ pub trait BufRead: Read {\n \n /// A `Write` adaptor which will write data to multiple locations.\n ///\n-/// For more information, see `Write::broadcast`.\n+/// This struct is generally created by calling [`broadcast()`][broadcast] on a\n+/// writer. Please see the documentation of `broadcast()` for more details.\n+///\n+/// [broadcast]: trait.Write.html#method.broadcast\n #[unstable(feature = \"io\", reason = \"awaiting stability of Write::broadcast\")]\n pub struct Broadcast<T, U> {\n     first: T,\n@@ -1417,9 +1420,12 @@ impl<T: Write, U: Write> Write for Broadcast<T, U> {\n     }\n }\n \n-/// Adaptor to chain together two instances of `Read`.\n+/// Adaptor to chain together two readers.\n+///\n+/// This struct is generally created by calling [`chain()`][chain] on a reader.\n+/// Please see the documentation of `chain()` for more details.\n ///\n-/// For more information, see `Read::chain`.\n+/// [chain]: trait.Read.html#method.chain\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chain<T, U> {\n     first: T,\n@@ -1442,7 +1448,10 @@ impl<T: Read, U: Read> Read for Chain<T, U> {\n \n /// Reader adaptor which limits the bytes read from an underlying reader.\n ///\n-/// For more information, see `Read::take`.\n+/// This struct is generally created by calling [`take()`][take] on a reader.\n+/// Please see the documentation of `take()` for more details.\n+///\n+/// [take]: trait.Read.html#method.take\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Take<T> {\n     inner: T,\n@@ -1495,7 +1504,10 @@ impl<T: BufRead> BufRead for Take<T> {\n \n /// An adaptor which will emit all read data to a specified writer as well.\n ///\n-/// For more information see `Read::tee`\n+/// This struct is generally created by calling [`tee()`][tee] on a reader.\n+/// Please see the documentation of `tee()` for more details.\n+///\n+/// [tee]: trait.Read.html#method.tee\n #[unstable(feature = \"io\", reason = \"awaiting stability of Read::tee\")]\n pub struct Tee<R, W> {\n     reader: R,\n@@ -1512,9 +1524,12 @@ impl<R: Read, W: Write> Read for Tee<R, W> {\n     }\n }\n \n-/// A bridge from implementations of `Read` to an `Iterator` of `u8`.\n+/// An iterator over `u8` values of a reader.\n ///\n-/// See `Read::bytes` for more information.\n+/// This struct is generally created by calling [`bytes()`][bytes] on a reader.\n+/// Please see the documentation of `bytes()` for more details.\n+///\n+/// [bytes]: trait.Read.html#method.bytes\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Bytes<R> {\n     inner: R,\n@@ -1534,9 +1549,12 @@ impl<R: Read> Iterator for Bytes<R> {\n     }\n }\n \n-/// A bridge from implementations of `Read` to an `Iterator` of `char`.\n+/// An iterator over the `char`s of a reader.\n+///\n+/// This struct is generally created by calling [`chars()`][chars] on a reader.\n+/// Please see the documentation of `chars()` for more details.\n ///\n-/// See `Read::chars` for more information.\n+/// [chars]: trait.Read.html#method.chars\n #[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\")]\n pub struct Chars<R> {\n     inner: R,\n@@ -1618,7 +1636,10 @@ impl fmt::Display for CharsError {\n /// An iterator over the contents of an instance of `BufRead` split on a\n /// particular byte.\n ///\n-/// See `BufRead::split` for more information.\n+/// This struct is generally created by calling [`split()`][split] on a\n+/// `BufRead`. Please see the documentation of `split()` for more details.\n+///\n+/// [split]: trait.BufRead.html#method.split\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Split<B> {\n     buf: B,\n@@ -1644,10 +1665,12 @@ impl<B: BufRead> Iterator for Split<B> {\n     }\n }\n \n-/// An iterator over the lines of an instance of `BufRead` split on a newline\n-/// byte.\n+/// An iterator over the lines of an instance of `BufRead`.\n+///\n+/// This struct is generally created by calling [`lines()`][lines] on a\n+/// `BufRead`. Please see the documentation of `lines()` for more details.\n ///\n-/// See `BufRead::lines` for more information.\n+/// [lines]: trait.BufRead.html#method.lines\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Lines<B> {\n     buf: B,"}, {"sha": "dc29811ed5ba11c1cdbf9b0c794bee3943ac98b7", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=55428306657c5b42a26183c90fcd06e1ee7b94f5", "patch": "@@ -61,6 +61,11 @@ pub fn copy<R: Read, W: Write>(reader: &mut R, writer: &mut W) -> io::Result<u64\n }\n \n /// A reader which is always at EOF.\n+///\n+/// This struct is generally created by calling [`empty()`][empty]. Please see\n+/// the documentation of `empty()` for more details.\n+///\n+/// [empty]: fn.empty.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Empty { _priv: () }\n \n@@ -95,7 +100,12 @@ impl BufRead for Empty {\n     fn consume(&mut self, _n: usize) {}\n }\n \n-/// A reader which infinitely yields one byte.\n+/// A reader which yields one byte over and over and over and over and over and...\n+///\n+/// This struct is generally created by calling [`repeat()`][repeat]. Please\n+/// see the documentation of `repeat()` for more details.\n+///\n+/// [empty]: fn.repeat.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Repeat { byte: u8 }\n \n@@ -117,6 +127,11 @@ impl Read for Repeat {\n }\n \n /// A writer which will move data into the void.\n+///\n+/// This struct is generally created by calling [`sink()`][sink]. Please\n+/// see the documentation of `sink()` for more details.\n+///\n+/// [empty]: fn.sink.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Sink { _priv: () }\n "}, {"sha": "d3a87689ac5e11793d29eef8798d18bda0ca8e48", "filename": "src/test/compile-fail/issue-20162.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Ftest%2Fcompile-fail%2Fissue-20162.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Ftest%2Fcompile-fail%2Fissue-20162.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20162.rs?ref=55428306657c5b42a26183c90fcd06e1ee7b94f5", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct X { x: i32 }\n+\n+fn main() {\n+    let mut b: Vec<X> = vec![];\n+    b.sort();\n+    //~^ ERROR the trait `core::cmp::Ord` is not implemented for the type `X`\n+}"}, {"sha": "30fd2eb4d2f9aeb6cfa527f04d3e5c2150b41adc", "filename": "src/test/compile-fail/issue-21174.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Ftest%2Fcompile-fail%2Fissue-21174.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Ftest%2Fcompile-fail%2Fissue-21174.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21174.rs?ref=55428306657c5b42a26183c90fcd06e1ee7b94f5", "patch": "@@ -15,7 +15,7 @@ trait Trait<'a> {\n \n fn foo<'a, T: Trait<'a>>(value: T::A) {\n     let new: T::B = unsafe { std::mem::transmute(value) };\n-//~^ ERROR: cannot transmute to or from a type that contains type parameters in its interior [E0139]\n+//~^ ERROR: cannot transmute to or from a type that contains unsubstituted type parameters [E0139]\n }\n \n fn main() { }"}, {"sha": "81a955b0f22e4ce04577339e7605ae15c80cca86", "filename": "src/test/run-pass/issue-10436.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Ftest%2Frun-pass%2Fissue-10436.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Ftest%2Frun-pass%2Fissue-10436.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10436.rs?ref=55428306657c5b42a26183c90fcd06e1ee7b94f5", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn works<T>(x: T) -> Vec<T> { vec![x] }\n+\n+fn also_works<T: Clone>(x: T) -> Vec<T> { vec![x] }\n+\n+fn main() {\n+    let _: Vec<usize> = works(0);\n+    let _: Vec<usize> = also_works(0);\n+    let _ = works(0);\n+    let _ = also_works(0);\n+}"}, {"sha": "ee2bbe63750c34644b215867a0658ada7cb11354", "filename": "src/test/run-pass/issue-14229.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Ftest%2Frun-pass%2Fissue-14229.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Ftest%2Frun-pass%2Fissue-14229.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14229.rs?ref=55428306657c5b42a26183c90fcd06e1ee7b94f5", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo: Sized {\n+    fn foo(self) {}\n+}\n+\n+trait Bar: Sized {\n+    fn bar(self) {}\n+}\n+\n+struct S;\n+\n+impl<'l> Foo for &'l S {}\n+\n+impl<T: Foo> Bar for T {}\n+\n+fn main() {\n+    let s = S;\n+    s.foo();\n+    (&s).bar();\n+    s.bar();\n+}"}, {"sha": "cdb44f6a60675e3a1d05be978ca1d8cc56070942", "filename": "src/test/run-pass/issue-14382.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Ftest%2Frun-pass%2Fissue-14382.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Ftest%2Frun-pass%2Fissue-14382.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14382.rs?ref=55428306657c5b42a26183c90fcd06e1ee7b94f5", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[derive(Debug)]\n+struct Matrix4<S>(S);\n+trait POrd<S> {}\n+\n+fn translate<S: POrd<S>>(s: S) -> Matrix4<S> { Matrix4(s) }\n+\n+impl POrd<f32> for f32 {}\n+impl POrd<f64> for f64 {}\n+\n+fn main() {\n+    let x = 1.0;\n+    let m : Matrix4<f32> = translate(x);\n+    println!(\"m: {:?}\", m);\n+}"}, {"sha": "0eea6ba22cae8d5594f7b56a317b9b4cddc97a5c", "filename": "src/test/run-pass/issue-19404.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Ftest%2Frun-pass%2Fissue-19404.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Ftest%2Frun-pass%2Fissue-19404.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19404.rs?ref=55428306657c5b42a26183c90fcd06e1ee7b94f5", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(reflect_marker)]\n+\n+use std::any::TypeId;\n+use std::marker::Reflect;\n+use std::rc::Rc;\n+\n+type Fp<T> = Rc<T>;\n+\n+struct Engine;\n+\n+trait Component: 'static + Reflect {}\n+impl Component for Engine {}\n+\n+trait Env {\n+    fn get_component_type_id(&self, type_id: TypeId) -> Option<Fp<Component>>;\n+}\n+\n+impl<'a> Env+'a {\n+    fn get_component<T: Component>(&self) -> Option<Fp<T>> {\n+        let x = self.get_component_type_id(TypeId::of::<T>());\n+        None\n+    }\n+}\n+\n+trait Figment {\n+    fn init(&mut self, env: &Env);\n+}\n+\n+struct MyFigment;\n+\n+impl Figment for MyFigment {\n+    fn init(&mut self, env: &Env) {\n+        let engine = env.get_component::<Engine>();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "9fb8675e84e9d36c8e1c1f1e9e675a3410ffc967", "filename": "src/test/run-pass/issue-26468.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Ftest%2Frun-pass%2Fissue-26468.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55428306657c5b42a26183c90fcd06e1ee7b94f5/src%2Ftest%2Frun-pass%2Fissue-26468.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-26468.rs?ref=55428306657c5b42a26183c90fcd06e1ee7b94f5", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+enum FooMode {\n+    Check = 0x1001,\n+}\n+\n+enum BarMode {\n+    Check = 0x2001,\n+}\n+\n+enum Mode {\n+    Foo(FooMode),\n+    Bar(BarMode),\n+}\n+\n+#[inline(never)]\n+fn broken(mode: &Mode) -> u32 {\n+    for _ in 0..1 {\n+        if let Mode::Foo(FooMode::Check) = *mode { return 17 }\n+        if let Mode::Bar(BarMode::Check) = *mode { return 19 }\n+    }\n+    return 42;\n+}\n+\n+fn main() {\n+    let mode = Mode::Bar(BarMode::Check);\n+    assert_eq!(broken(&mode), 19);\n+}"}]}