{"sha": "11f31ae4c3a38831609e4591e751ce10c4e38daf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExZjMxYWU0YzNhMzg4MzE2MDllNDU5MWU3NTFjZTEwYzRlMzhkYWY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-28T21:43:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-28T21:43:18Z"}, "message": "Merge #5114\n\n5114: Cleanup cargo process handling in flycheck r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "75cc520452cfae4ad77c1ad88a37fd43efe38b81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75cc520452cfae4ad77c1ad88a37fd43efe38b81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11f31ae4c3a38831609e4591e751ce10c4e38daf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe+Q72CRBK7hj4Ov3rIwAAdHIIABSQO4AmACxGxgC+L0h6G1rW\njJQjnwRhEQWd14MH0rUkikD79I8/dHAM49ONDw/iSHIEkIrDLACd1Lf8gL7TVKtg\nn1fOt0RJvUjRyK9XMhQpaQP6m3yNLewfMtjGg/nF0WoG7rubkrgxXQVzw9K1f36/\nbcZpzxXNs81UwaE5P80pMmwJNqg97N+NSftjCyjkVLrQEBzy2hVOnxQGbefMGo3o\nXKy0mD9Lb5n2sQdnAWmiHoFEmw0+xwICZkAkSNRsj62NSur/RoRz6hDr2dW6Taav\nfKB7OV//5NE0gYk79jjKZ6kcAr+vCEmYB0W7vUi5X9gjA0yWbb9efZ19UYs2Ds8=\n=J24Z\n-----END PGP SIGNATURE-----\n", "payload": "tree 75cc520452cfae4ad77c1ad88a37fd43efe38b81\nparent f3cd82cabf6ab6ab2d41abfedc77504fbf6f1361\nparent 5cdd8d442ef5a573f4af07e68dce7720ca603aba\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593380598 +0000\ncommitter GitHub <noreply@github.com> 1593380598 +0000\n\nMerge #5114\n\n5114: Cleanup cargo process handling in flycheck r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11f31ae4c3a38831609e4591e751ce10c4e38daf", "html_url": "https://github.com/rust-lang/rust/commit/11f31ae4c3a38831609e4591e751ce10c4e38daf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11f31ae4c3a38831609e4591e751ce10c4e38daf/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3cd82cabf6ab6ab2d41abfedc77504fbf6f1361", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3cd82cabf6ab6ab2d41abfedc77504fbf6f1361", "html_url": "https://github.com/rust-lang/rust/commit/f3cd82cabf6ab6ab2d41abfedc77504fbf6f1361"}, {"sha": "5cdd8d442ef5a573f4af07e68dce7720ca603aba", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cdd8d442ef5a573f4af07e68dce7720ca603aba", "html_url": "https://github.com/rust-lang/rust/commit/5cdd8d442ef5a573f4af07e68dce7720ca603aba"}], "stats": {"total": 222, "additions": 128, "deletions": 94}, "files": [{"sha": "1023d3040f99d626ff430c9a51290f88175af586", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 119, "deletions": 89, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/11f31ae4c3a38831609e4591e751ce10c4e38daf/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f31ae4c3a38831609e4591e751ce10c4e38daf/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=11f31ae4c3a38831609e4591e751ce10c4e38daf", "patch": "@@ -5,8 +5,9 @@\n use std::{\n     fmt,\n     io::{self, BufReader},\n+    ops,\n     path::PathBuf,\n-    process::{Command, Stdio},\n+    process::{self, Command, Stdio},\n     time::Duration,\n };\n \n@@ -49,8 +50,8 @@ impl fmt::Display for FlycheckConfig {\n #[derive(Debug)]\n pub struct FlycheckHandle {\n     // XXX: drop order is significant\n-    cmd_send: Sender<Restart>,\n-    handle: jod_thread::JoinHandle,\n+    sender: Sender<Restart>,\n+    thread: jod_thread::JoinHandle,\n }\n \n impl FlycheckHandle {\n@@ -59,16 +60,15 @@ impl FlycheckHandle {\n         config: FlycheckConfig,\n         workspace_root: PathBuf,\n     ) -> FlycheckHandle {\n-        let (cmd_send, cmd_recv) = unbounded::<Restart>();\n-        let handle = jod_thread::spawn(move || {\n-            FlycheckActor::new(sender, config, workspace_root).run(cmd_recv);\n-        });\n-        FlycheckHandle { cmd_send, handle }\n+        let actor = FlycheckActor::new(sender, config, workspace_root);\n+        let (sender, receiver) = unbounded::<Restart>();\n+        let thread = jod_thread::spawn(move || actor.run(receiver));\n+        FlycheckHandle { sender, thread }\n     }\n \n     /// Schedule a re-start of the cargo check worker.\n     pub fn update(&self) {\n-        self.cmd_send.send(Restart).unwrap();\n+        self.sender.send(Restart).unwrap();\n     }\n }\n \n@@ -85,7 +85,7 @@ pub enum Message {\n pub enum Progress {\n     DidStart,\n     DidCheckCrate(String),\n-    DidFinish,\n+    DidFinish(io::Result<()>),\n     DidCancel,\n }\n \n@@ -100,8 +100,7 @@ struct FlycheckActor {\n     /// doesn't provide a way to read sub-process output without blocking, so we\n     /// have to wrap sub-processes output handling in a thread and pass messages\n     /// back over a channel.\n-    // XXX: drop order is significant\n-    check_process: Option<(Receiver<cargo_metadata::Message>, jod_thread::JoinHandle)>,\n+    cargo_handle: Option<CargoHandle>,\n }\n \n enum Event {\n@@ -115,29 +114,36 @@ impl FlycheckActor {\n         config: FlycheckConfig,\n         workspace_root: PathBuf,\n     ) -> FlycheckActor {\n-        FlycheckActor { sender, config, workspace_root, check_process: None }\n+        FlycheckActor { sender, config, workspace_root, cargo_handle: None }\n     }\n     fn next_event(&self, inbox: &Receiver<Restart>) -> Option<Event> {\n-        let check_chan = self.check_process.as_ref().map(|(chan, _thread)| chan);\n+        let check_chan = self.cargo_handle.as_ref().map(|cargo| &cargo.receiver);\n         select! {\n             recv(inbox) -> msg => msg.ok().map(Event::Restart),\n             recv(check_chan.unwrap_or(&never())) -> msg => Some(Event::CheckEvent(msg.ok())),\n         }\n     }\n-    fn run(&mut self, inbox: Receiver<Restart>) {\n+    fn run(mut self, inbox: Receiver<Restart>) {\n         while let Some(event) = self.next_event(&inbox) {\n             match event {\n                 Event::Restart(Restart) => {\n                     while let Ok(Restart) = inbox.recv_timeout(Duration::from_millis(50)) {}\n+\n                     self.cancel_check_process();\n-                    self.check_process = Some(self.start_check_process());\n-                    self.send(Message::Progress(Progress::DidStart));\n+\n+                    let mut command = self.check_command();\n+                    command.stdout(Stdio::piped()).stderr(Stdio::null()).stdin(Stdio::null());\n+                    if let Ok(child) = command.spawn().map(JodChild) {\n+                        self.cargo_handle = Some(CargoHandle::spawn(child));\n+                        self.send(Message::Progress(Progress::DidStart));\n+                    }\n                 }\n                 Event::CheckEvent(None) => {\n                     // Watcher finished, replace it with a never channel to\n                     // avoid busy-waiting.\n-                    assert!(self.check_process.take().is_some());\n-                    self.send(Message::Progress(Progress::DidFinish));\n+                    let cargo_handle = self.cargo_handle.take().unwrap();\n+                    let res = cargo_handle.join();\n+                    self.send(Message::Progress(Progress::DidFinish(res)));\n                 }\n                 Event::CheckEvent(Some(message)) => match message {\n                     cargo_metadata::Message::CompilerArtifact(msg) => {\n@@ -162,11 +168,11 @@ impl FlycheckActor {\n         self.cancel_check_process();\n     }\n     fn cancel_check_process(&mut self) {\n-        if self.check_process.take().is_some() {\n+        if self.cargo_handle.take().is_some() {\n             self.send(Message::Progress(Progress::DidCancel));\n         }\n     }\n-    fn start_check_process(&self) -> (Receiver<cargo_metadata::Message>, jod_thread::JoinHandle) {\n+    fn check_command(&self) -> Command {\n         let mut cmd = match &self.config {\n             FlycheckConfig::CargoCommand {\n                 command,\n@@ -198,88 +204,112 @@ impl FlycheckActor {\n             }\n         };\n         cmd.current_dir(&self.workspace_root);\n-\n-        let (message_send, message_recv) = unbounded();\n-        let thread = jod_thread::spawn(move || {\n-            // If we trigger an error here, we will do so in the loop instead,\n-            // which will break out of the loop, and continue the shutdown\n-            let res = run_cargo(cmd, &mut |message| {\n-                // Skip certain kinds of messages to only spend time on what's useful\n-                match &message {\n-                    cargo_metadata::Message::CompilerArtifact(artifact) if artifact.fresh => {\n-                        return true\n-                    }\n-                    cargo_metadata::Message::BuildScriptExecuted(_)\n-                    | cargo_metadata::Message::Unknown => return true,\n-                    _ => {}\n-                }\n-\n-                // if the send channel was closed, we want to shutdown\n-                message_send.send(message).is_ok()\n-            });\n-\n-            if let Err(err) = res {\n-                // FIXME: make the `message_send` to be `Sender<Result<CheckEvent, CargoError>>`\n-                // to display user-caused misconfiguration errors instead of just logging them here\n-                log::error!(\"Cargo watcher failed {:?}\", err);\n-            }\n-        });\n-        (message_recv, thread)\n+        cmd\n     }\n \n     fn send(&self, check_task: Message) {\n         (self.sender)(check_task)\n     }\n }\n \n-fn run_cargo(\n-    mut command: Command,\n-    on_message: &mut dyn FnMut(cargo_metadata::Message) -> bool,\n-) -> io::Result<()> {\n-    let mut child =\n-        command.stdout(Stdio::piped()).stderr(Stdio::null()).stdin(Stdio::null()).spawn()?;\n+struct CargoHandle {\n+    child: JodChild,\n+    #[allow(unused)]\n+    thread: jod_thread::JoinHandle<io::Result<bool>>,\n+    receiver: Receiver<cargo_metadata::Message>,\n+}\n \n-    // We manually read a line at a time, instead of using serde's\n-    // stream deserializers, because the deserializer cannot recover\n-    // from an error, resulting in it getting stuck, because we try to\n-    // be resillient against failures.\n-    //\n-    // Because cargo only outputs one JSON object per line, we can\n-    // simply skip a line if it doesn't parse, which just ignores any\n-    // erroneus output.\n-    let stdout = BufReader::new(child.stdout.take().unwrap());\n-    let mut read_at_least_one_message = false;\n-    for message in cargo_metadata::Message::parse_stream(stdout) {\n-        let message = match message {\n-            Ok(message) => message,\n-            Err(err) => {\n-                log::error!(\"Invalid json from cargo check, ignoring ({})\", err);\n-                continue;\n-            }\n-        };\n+impl CargoHandle {\n+    fn spawn(mut child: JodChild) -> CargoHandle {\n+        let child_stdout = child.stdout.take().unwrap();\n+        let (sender, receiver) = unbounded();\n+        let actor = CargoActor::new(child_stdout, sender);\n+        let thread = jod_thread::spawn(move || actor.run());\n+        CargoHandle { child, thread, receiver }\n+    }\n+    fn join(mut self) -> io::Result<()> {\n+        // It is okay to ignore the result, as it only errors if the process is already dead\n+        let _ = self.child.kill();\n+        let exit_status = self.child.wait()?;\n+        let read_at_least_one_message = self.thread.join()?;\n+        if !exit_status.success() && !read_at_least_one_message {\n+            // FIXME: Read the stderr to display the reason, see `read2()` reference in PR comment:\n+            // https://github.com/rust-analyzer/rust-analyzer/pull/3632#discussion_r395605298\n+            return Err(io::Error::new(\n+                io::ErrorKind::Other,\n+                format!(\n+                    \"Cargo watcher failed,the command produced no valid metadata (exit code: {:?})\",\n+                    exit_status\n+                ),\n+            ));\n+        }\n+        Ok(())\n+    }\n+}\n+\n+struct CargoActor {\n+    child_stdout: process::ChildStdout,\n+    sender: Sender<cargo_metadata::Message>,\n+}\n+\n+impl CargoActor {\n+    fn new(\n+        child_stdout: process::ChildStdout,\n+        sender: Sender<cargo_metadata::Message>,\n+    ) -> CargoActor {\n+        CargoActor { child_stdout, sender }\n+    }\n+    fn run(self) -> io::Result<bool> {\n+        // We manually read a line at a time, instead of using serde's\n+        // stream deserializers, because the deserializer cannot recover\n+        // from an error, resulting in it getting stuck, because we try to\n+        // be resilient against failures.\n+        //\n+        // Because cargo only outputs one JSON object per line, we can\n+        // simply skip a line if it doesn't parse, which just ignores any\n+        // erroneus output.\n+        let stdout = BufReader::new(self.child_stdout);\n+        let mut read_at_least_one_message = false;\n+        for message in cargo_metadata::Message::parse_stream(stdout) {\n+            let message = match message {\n+                Ok(message) => message,\n+                Err(err) => {\n+                    log::error!(\"Invalid json from cargo check, ignoring ({})\", err);\n+                    continue;\n+                }\n+            };\n \n-        read_at_least_one_message = true;\n+            read_at_least_one_message = true;\n \n-        if !on_message(message) {\n-            break;\n+            // Skip certain kinds of messages to only spend time on what's useful\n+            match &message {\n+                cargo_metadata::Message::CompilerArtifact(artifact) if artifact.fresh => (),\n+                cargo_metadata::Message::BuildScriptExecuted(_)\n+                | cargo_metadata::Message::Unknown => (),\n+                _ => self.sender.send(message).unwrap(),\n+            }\n         }\n+        Ok(read_at_least_one_message)\n     }\n+}\n \n-    // It is okay to ignore the result, as it only errors if the process is already dead\n-    let _ = child.kill();\n+struct JodChild(process::Child);\n \n-    let exit_status = child.wait()?;\n-    if !exit_status.success() && !read_at_least_one_message {\n-        // FIXME: Read the stderr to display the reason, see `read2()` reference in PR comment:\n-        // https://github.com/rust-analyzer/rust-analyzer/pull/3632#discussion_r395605298\n-        return Err(io::Error::new(\n-            io::ErrorKind::Other,\n-            format!(\n-                \"the command produced no valid metadata (exit code: {:?}): {:?}\",\n-                exit_status, command\n-            ),\n-        ));\n+impl ops::Deref for JodChild {\n+    type Target = process::Child;\n+    fn deref(&self) -> &process::Child {\n+        &self.0\n     }\n+}\n \n-    Ok(())\n+impl ops::DerefMut for JodChild {\n+    fn deref_mut(&mut self) -> &mut process::Child {\n+        &mut self.0\n+    }\n+}\n+\n+impl Drop for JodChild {\n+    fn drop(&mut self) {\n+        let _ = self.0.kill();\n+    }\n }"}, {"sha": "9fd16ef3b4a3cd619e3c073aafed32cd50faf2fa", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11f31ae4c3a38831609e4591e751ce10c4e38daf/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f31ae4c3a38831609e4591e751ce10c4e38daf/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=11f31ae4c3a38831609e4591e751ce10c4e38daf", "patch": "@@ -216,7 +216,11 @@ impl GlobalState {\n                         flycheck::Progress::DidCheckCrate(target) => {\n                             (Progress::Report, Some(target))\n                         }\n-                        flycheck::Progress::DidFinish | flycheck::Progress::DidCancel => {\n+                        flycheck::Progress::DidCancel => (Progress::End, None),\n+                        flycheck::Progress::DidFinish(result) => {\n+                            if let Err(err) = result {\n+                                log::error!(\"cargo check failed: {}\", err)\n+                            }\n                             (Progress::End, None)\n                         }\n                     };"}, {"sha": "b1ea298ae5f6c891ecedec00215736411864dd5f", "filename": "crates/vfs-notify/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/11f31ae4c3a38831609e4591e751ce10c4e38daf/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f31ae4c3a38831609e4591e751ce10c4e38daf/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs-notify%2Fsrc%2Flib.rs?ref=11f31ae4c3a38831609e4591e751ce10c4e38daf", "patch": "@@ -10,7 +10,7 @@ mod include;\n \n use std::convert::{TryFrom, TryInto};\n \n-use crossbeam_channel::{select, unbounded, Receiver};\n+use crossbeam_channel::{select, unbounded, Receiver, Sender};\n use notify::{RecommendedWatcher, RecursiveMode, Watcher};\n use paths::{AbsPath, AbsPathBuf};\n use rustc_hash::FxHashSet;\n@@ -22,8 +22,8 @@ use crate::include::Include;\n #[derive(Debug)]\n pub struct NotifyHandle {\n     // Relative order of fields below is significant.\n-    sender: crossbeam_channel::Sender<Message>,\n-    _thread: jod_thread::JoinHandle,\n+    sender: Sender<Message>,\n+    thread: jod_thread::JoinHandle,\n }\n \n #[derive(Debug)]\n@@ -37,7 +37,7 @@ impl loader::Handle for NotifyHandle {\n         let actor = NotifyActor::new(sender);\n         let (sender, receiver) = unbounded::<Message>();\n         let thread = jod_thread::spawn(move || actor.run(receiver));\n-        NotifyHandle { sender, _thread: thread }\n+        NotifyHandle { sender, thread }\n     }\n     fn set_config(&mut self, config: loader::Config) {\n         self.sender.send(Message::Config(config)).unwrap()"}]}