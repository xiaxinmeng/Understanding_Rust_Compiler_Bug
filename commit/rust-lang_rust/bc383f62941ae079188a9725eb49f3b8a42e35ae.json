{"sha": "bc383f62941ae079188a9725eb49f3b8a42e35ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjMzgzZjYyOTQxYWUwNzkxODhhOTcyNWViNDlmM2I4YTQyZTM1YWU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-06-14T01:50:23Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-06-18T22:18:42Z"}, "message": "rustc: enforce stack discipline on ty::ctxt.", "tree": {"sha": "e27b379c1846874c850d4addb539f3fb9540302f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e27b379c1846874c850d4addb539f3fb9540302f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc383f62941ae079188a9725eb49f3b8a42e35ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc383f62941ae079188a9725eb49f3b8a42e35ae", "html_url": "https://github.com/rust-lang/rust/commit/bc383f62941ae079188a9725eb49f3b8a42e35ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc383f62941ae079188a9725eb49f3b8a42e35ae/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84b49b2d355e49c429703eade10f93680cc3bd47", "url": "https://api.github.com/repos/rust-lang/rust/commits/84b49b2d355e49c429703eade10f93680cc3bd47", "html_url": "https://github.com/rust-lang/rust/commit/84b49b2d355e49c429703eade10f93680cc3bd47"}], "stats": {"total": 477, "additions": 255, "deletions": 222}, "files": [{"sha": "6cbfe7616147c174f10ed7e13a9104b58dc60c0c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bc383f62941ae079188a9725eb49f3b8a42e35ae/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc383f62941ae079188a9725eb49f3b8a42e35ae/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=bc383f62941ae079188a9725eb49f3b8a42e35ae", "patch": "@@ -2810,20 +2810,22 @@ impl<'tcx> CommonTypes<'tcx> {\n     }\n }\n \n-pub fn mk_ctxt<'tcx>(s: Session,\n-                     arenas: &'tcx CtxtArenas<'tcx>,\n-                     def_map: DefMap,\n-                     named_region_map: resolve_lifetime::NamedRegionMap,\n-                     map: ast_map::Map<'tcx>,\n-                     freevars: RefCell<FreevarMap>,\n-                     region_maps: RegionMaps,\n-                     lang_items: middle::lang_items::LanguageItems,\n-                     stability: stability::Index<'tcx>) -> ctxt<'tcx>\n+pub fn with_ctxt<'tcx, F, R>(s: Session,\n+                             arenas: &'tcx CtxtArenas<'tcx>,\n+                             def_map: DefMap,\n+                             named_region_map: resolve_lifetime::NamedRegionMap,\n+                             map: ast_map::Map<'tcx>,\n+                             freevars: RefCell<FreevarMap>,\n+                             region_maps: RegionMaps,\n+                             lang_items: middle::lang_items::LanguageItems,\n+                             stability: stability::Index<'tcx>,\n+                             f: F) -> (Session, R)\n+                             where F: FnOnce(&ctxt<'tcx>) -> R\n {\n     let mut interner = FnvHashMap();\n     let common_types = CommonTypes::new(&arenas.type_, &mut interner);\n \n-    ctxt {\n+    let tcx = ctxt {\n         arenas: arenas,\n         interner: RefCell::new(interner),\n         substs_interner: RefCell::new(FnvHashMap()),\n@@ -2885,7 +2887,9 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         const_qualif_map: RefCell::new(NodeMap()),\n         custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n         cast_kinds: RefCell::new(NodeMap()),\n-   }\n+   };\n+   let result = f(&tcx);\n+   (tcx.sess, result)\n }\n \n // Type constructors"}, {"sha": "a834ed4cb5f67e1bdc4ca5e0b4abb37fbfade1a8", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 135, "deletions": 114, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/bc383f62941ae079188a9725eb49f3b8a42e35ae/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc383f62941ae079188a9725eb49f3b8a42e35ae/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=bc383f62941ae079188a9725eb49f3b8a42e35ae", "patch": "@@ -65,7 +65,7 @@ pub fn compile_input(sess: Session,\n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n-    let (outputs, trans, sess) = {\n+    let (sess, result) = {\n         let (outputs, expanded_crate, id) = {\n             let krate = phase_1_parse_input(&sess, cfg, input);\n \n@@ -119,37 +119,52 @@ pub fn compile_input(sess: Session,\n                                                                      &ast_map.krate(),\n                                                                      &id[..]));\n \n-        let (tcx, analysis) = phase_3_run_analysis_passes(sess,\n-                                                          ast_map,\n-                                                          &arenas,\n-                                                          id,\n-                                                          control.make_glob_map);\n-\n-        controller_entry_point!(after_analysis,\n-                                tcx.sess,\n-                                CompileState::state_after_analysis(input,\n-                                                                   &tcx.sess,\n-                                                                   outdir,\n-                                                                   tcx.map.krate(),\n-                                                                   &analysis,\n-                                                                   &tcx));\n-\n-        if log_enabled!(::log::INFO) {\n-            println!(\"Pre-trans\");\n-            tcx.print_debug_stats();\n-        }\n-        let trans = phase_4_translate_to_llvm(&tcx, analysis);\n+        phase_3_run_analysis_passes(sess,\n+                                    ast_map,\n+                                    &arenas,\n+                                    id,\n+                                    control.make_glob_map,\n+                                    |tcx, analysis| {\n+\n+            {\n+                let state = CompileState::state_after_analysis(input,\n+                                                               &tcx.sess,\n+                                                               outdir,\n+                                                               tcx.map.krate(),\n+                                                               &analysis,\n+                                                               tcx);\n+                (control.after_analysis.callback)(state);\n+\n+                tcx.sess.abort_if_errors();\n+                if control.after_analysis.stop == Compilation::Stop {\n+                    return Err(());\n+                }\n+            }\n \n-        if log_enabled!(::log::INFO) {\n-            println!(\"Post-trans\");\n-            tcx.print_debug_stats();\n-        }\n+            if log_enabled!(::log::INFO) {\n+                println!(\"Pre-trans\");\n+                tcx.print_debug_stats();\n+            }\n+            let trans = phase_4_translate_to_llvm(tcx, analysis);\n+\n+            if log_enabled!(::log::INFO) {\n+                println!(\"Post-trans\");\n+                tcx.print_debug_stats();\n+            }\n \n-        // Discard interned strings as they are no longer required.\n-        token::get_ident_interner().clear();\n+            // Discard interned strings as they are no longer required.\n+            token::get_ident_interner().clear();\n \n-        (outputs, trans, tcx.sess)\n+            Ok((outputs, trans))\n+        })\n     };\n+\n+    let (outputs, trans) = if let Ok(out) = result {\n+        out\n+    } else {\n+        return;\n+    };\n+\n     phase_5_run_llvm_passes(&sess, &trans, &outputs);\n \n     controller_entry_point!(after_llvm,\n@@ -578,12 +593,16 @@ pub fn assign_node_ids_and_map<'ast>(sess: &Session,\n /// Run the resolution, typechecking, region checking and other\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis.\n-pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n-                                         ast_map: ast_map::Map<'tcx>,\n-                                         arenas: &'tcx ty::CtxtArenas<'tcx>,\n-                                         name: String,\n-                                         make_glob_map: resolve::MakeGlobMap)\n-                                         -> (ty::ctxt<'tcx>, ty::CrateAnalysis) {\n+pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n+                                               ast_map: ast_map::Map<'tcx>,\n+                                               arenas: &'tcx ty::CtxtArenas<'tcx>,\n+                                               name: String,\n+                                               make_glob_map: resolve::MakeGlobMap,\n+                                               f: F)\n+                                               -> (Session, R)\n+                                               where F: FnOnce(&ty::ctxt<'tcx>,\n+                                                               ty::CrateAnalysis) -> R\n+{\n     let time_passes = sess.time_passes();\n     let krate = ast_map.krate();\n \n@@ -627,86 +646,88 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     time(time_passes, \"static item recursion checking\", (), |_|\n          middle::check_static_recursion::check_crate(&sess, krate, &def_map, &ast_map));\n \n-    let ty_cx = ty::mk_ctxt(sess,\n-                            arenas,\n-                            def_map,\n-                            named_region_map,\n-                            ast_map,\n-                            freevars,\n-                            region_map,\n-                            lang_items,\n-                            stability::Index::new(krate));\n-\n-    // passes are timed inside typeck\n-    typeck::check_crate(&ty_cx, trait_map);\n-\n-    time(time_passes, \"const checking\", (), |_|\n-         middle::check_const::check_crate(&ty_cx));\n-\n-    let (exported_items, public_items) =\n-            time(time_passes, \"privacy checking\", (), |_|\n-                 rustc_privacy::check_crate(&ty_cx, &export_map, external_exports));\n-\n-    // Do not move this check past lint\n-    time(time_passes, \"stability index\", (), |_|\n-         ty_cx.stability.borrow_mut().build(&ty_cx, krate, &public_items));\n-\n-    time(time_passes, \"intrinsic checking\", (), |_|\n-         middle::intrinsicck::check_crate(&ty_cx));\n-\n-    time(time_passes, \"effect checking\", (), |_|\n-         middle::effect::check_crate(&ty_cx));\n-\n-    time(time_passes, \"match checking\", (), |_|\n-         middle::check_match::check_crate(&ty_cx));\n-\n-    time(time_passes, \"liveness checking\", (), |_|\n-         middle::liveness::check_crate(&ty_cx));\n-\n-    time(time_passes, \"borrow checking\", (), |_|\n-         borrowck::check_crate(&ty_cx));\n-\n-    time(time_passes, \"rvalue checking\", (), |_|\n-         middle::check_rvalues::check_crate(&ty_cx, krate));\n-\n-    // Avoid overwhelming user with errors if type checking failed.\n-    // I'm not sure how helpful this is, to be honest, but it avoids a\n-    // lot of annoying errors in the compile-fail tests (basically,\n-    // lint warnings and so on -- kindck used to do this abort, but\n-    // kindck is gone now). -nmatsakis\n-    ty_cx.sess.abort_if_errors();\n-\n-    let reachable_map =\n-        time(time_passes, \"reachability checking\", (), |_|\n-             reachable::find_reachable(&ty_cx, &exported_items));\n-\n-    time(time_passes, \"death checking\", (), |_| {\n-        middle::dead::check_crate(&ty_cx,\n-                                  &exported_items,\n-                                  &reachable_map)\n-    });\n-\n-    let ref lib_features_used =\n-        time(time_passes, \"stability checking\", (), |_|\n-             stability::check_unstable_api_usage(&ty_cx));\n-\n-    time(time_passes, \"unused lib feature checking\", (), |_|\n-         stability::check_unused_or_stable_features(\n-             &ty_cx.sess, lib_features_used));\n-\n-    time(time_passes, \"lint checking\", (), |_|\n-         lint::check_crate(&ty_cx, &exported_items));\n-\n-    // The above three passes generate errors w/o aborting\n-    ty_cx.sess.abort_if_errors();\n-\n-    (ty_cx, ty::CrateAnalysis {\n-        export_map: export_map,\n-        exported_items: exported_items,\n-        public_items: public_items,\n-        reachable: reachable_map,\n-        name: name,\n-        glob_map: glob_map,\n+    ty::with_ctxt(sess,\n+                  arenas,\n+                  def_map,\n+                  named_region_map,\n+                  ast_map,\n+                  freevars,\n+                  region_map,\n+                  lang_items,\n+                  stability::Index::new(krate),\n+                  |tcx| {\n+\n+        // passes are timed inside typeck\n+        typeck::check_crate(tcx, trait_map);\n+\n+        time(time_passes, \"const checking\", (), |_|\n+            middle::check_const::check_crate(tcx));\n+\n+        let (exported_items, public_items) =\n+                time(time_passes, \"privacy checking\", (), |_|\n+                    rustc_privacy::check_crate(tcx, &export_map, external_exports));\n+\n+        // Do not move this check past lint\n+        time(time_passes, \"stability index\", (), |_|\n+            tcx.stability.borrow_mut().build(tcx, krate, &public_items));\n+\n+        time(time_passes, \"intrinsic checking\", (), |_|\n+            middle::intrinsicck::check_crate(tcx));\n+\n+        time(time_passes, \"effect checking\", (), |_|\n+            middle::effect::check_crate(tcx));\n+\n+        time(time_passes, \"match checking\", (), |_|\n+            middle::check_match::check_crate(tcx));\n+\n+        time(time_passes, \"liveness checking\", (), |_|\n+            middle::liveness::check_crate(tcx));\n+\n+        time(time_passes, \"borrow checking\", (), |_|\n+            borrowck::check_crate(tcx));\n+\n+        time(time_passes, \"rvalue checking\", (), |_|\n+            middle::check_rvalues::check_crate(tcx, krate));\n+\n+        // Avoid overwhelming user with errors if type checking failed.\n+        // I'm not sure how helpful this is, to be honest, but it avoids a\n+        // lot of annoying errors in the compile-fail tests (basically,\n+        // lint warnings and so on -- kindck used to do this abort, but\n+        // kindck is gone now). -nmatsakis\n+        tcx.sess.abort_if_errors();\n+\n+        let reachable_map =\n+            time(time_passes, \"reachability checking\", (), |_|\n+                reachable::find_reachable(tcx, &exported_items));\n+\n+        time(time_passes, \"death checking\", (), |_| {\n+            middle::dead::check_crate(tcx,\n+                                      &exported_items,\n+                                      &reachable_map)\n+        });\n+\n+        let ref lib_features_used =\n+            time(time_passes, \"stability checking\", (), |_|\n+                stability::check_unstable_api_usage(tcx));\n+\n+        time(time_passes, \"unused lib feature checking\", (), |_|\n+            stability::check_unused_or_stable_features(\n+                &tcx.sess, lib_features_used));\n+\n+        time(time_passes, \"lint checking\", (), |_|\n+            lint::check_crate(tcx, &exported_items));\n+\n+        // The above three passes generate errors w/o aborting\n+        tcx.sess.abort_if_errors();\n+\n+        f(tcx, ty::CrateAnalysis {\n+            export_map: export_map,\n+            exported_items: exported_items,\n+            public_items: public_items,\n+            reachable: reachable_map,\n+            name: name,\n+            glob_map: glob_map,\n+        })\n     })\n }\n "}, {"sha": "b5ae498bedf4ec9e1dc87bf379198a52d71a93af", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bc383f62941ae079188a9725eb49f3b8a42e35ae/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc383f62941ae079188a9725eb49f3b8a42e35ae/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=bc383f62941ae079188a9725eb49f3b8a42e35ae", "patch": "@@ -148,13 +148,15 @@ impl PpSourceMode {\n             }\n             PpmTyped => {\n                 let ast_map = ast_map.expect(\"--pretty=typed missing ast_map\");\n-                let (tcx, _) = driver::phase_3_run_analysis_passes(sess,\n-                                                                   ast_map,\n-                                                                   arenas,\n-                                                                   id,\n-                                                                   resolve::MakeGlobMap::No);\n-                let annotation = TypedAnnotation { tcx: tcx };\n-                f(&annotation, payload)\n+                driver::phase_3_run_analysis_passes(sess,\n+                                                    ast_map,\n+                                                    arenas,\n+                                                    id,\n+                                                    resolve::MakeGlobMap::No,\n+                                                    |tcx, _| {\n+                    let annotation = TypedAnnotation { tcx: tcx };\n+                    f(&annotation, payload)\n+                }).1\n             }\n         }\n     }\n@@ -284,11 +286,11 @@ impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n }\n \n \n-struct TypedAnnotation<'tcx> {\n-    tcx: ty::ctxt<'tcx>,\n+struct TypedAnnotation<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n }\n \n-impl<'tcx> PrinterSupport<'tcx> for TypedAnnotation<'tcx> {\n+impl<'b, 'tcx> PrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n     fn sess<'a>(&'a self) -> &'a Session { &self.tcx.sess }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'tcx>> {\n@@ -298,7 +300,7 @@ impl<'tcx> PrinterSupport<'tcx> for TypedAnnotation<'tcx> {\n     fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n }\n \n-impl<'tcx> pprust::PpAnn for TypedAnnotation<'tcx> {\n+impl<'a, 'tcx> pprust::PpAnn for TypedAnnotation<'a, 'tcx> {\n     fn pre(&self,\n            s: &mut pprust::State,\n            node: pprust::AnnNode) -> io::Result<()> {\n@@ -645,12 +647,14 @@ pub fn pretty_print_input(sess: Session,\n             match code {\n                 Some(code) => {\n                     let variants = gather_flowgraph_variants(&sess);\n-                    let (tcx, _) = driver::phase_3_run_analysis_passes(sess,\n-                                                                       ast_map,\n-                                                                       &arenas,\n-                                                                       id,\n-                                                                       resolve::MakeGlobMap::No);\n-                    print_flowgraph(variants, &tcx, code, mode, out)\n+                    driver::phase_3_run_analysis_passes(sess,\n+                                                        ast_map,\n+                                                        &arenas,\n+                                                        id,\n+                                                        resolve::MakeGlobMap::No,\n+                                                        |tcx, _| {\n+                        print_flowgraph(variants, tcx, code, mode, out)\n+                    }).1\n                 }\n                 None => {\n                     let message = format!(\"--pretty=flowgraph needs \\"}, {"sha": "4668b3d1c25ecd2a746f0db57f4f306f094489ca", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bc383f62941ae079188a9725eb49f3b8a42e35ae/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc383f62941ae079188a9725eb49f3b8a42e35ae/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=bc383f62941ae079188a9725eb49f3b8a42e35ae", "patch": "@@ -129,20 +129,22 @@ fn test_env<F>(source_string: &str,\n         resolve::resolve_crate(&sess, &ast_map, resolve::MakeGlobMap::No);\n     let named_region_map = resolve_lifetime::krate(&sess, krate, &def_map);\n     let region_map = region::resolve_crate(&sess, krate);\n-    let tcx = ty::mk_ctxt(sess,\n-                          &arenas,\n-                          def_map,\n-                          named_region_map,\n-                          ast_map,\n-                          freevars,\n-                          region_map,\n-                          lang_items,\n-                          stability::Index::new(krate));\n-    let infcx = infer::new_infer_ctxt(&tcx);\n-    body(Env { infcx: &infcx });\n-    let free_regions = FreeRegionMap::new();\n-    infcx.resolve_regions_and_report_errors(&free_regions, ast::CRATE_NODE_ID);\n-    assert_eq!(tcx.sess.err_count(), expected_err_count);\n+    ty::with_ctxt(sess,\n+                  &arenas,\n+                  def_map,\n+                  named_region_map,\n+                  ast_map,\n+                  freevars,\n+                  region_map,\n+                  lang_items,\n+                  stability::Index::new(krate),\n+                  |tcx| {\n+        let infcx = infer::new_infer_ctxt(tcx);\n+        body(Env { infcx: &infcx });\n+        let free_regions = FreeRegionMap::new();\n+        infcx.resolve_regions_and_report_errors(&free_regions, ast::CRATE_NODE_ID);\n+        assert_eq!(tcx.sess.err_count(), expected_err_count);\n+    });\n }\n \n impl<'a, 'tcx> Env<'a, 'tcx> {"}, {"sha": "13022fd43efb82446efc229ceb5f504d62227621", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 52, "deletions": 51, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/bc383f62941ae079188a9725eb49f3b8a42e35ae/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc383f62941ae079188a9725eb49f3b8a42e35ae/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=bc383f62941ae079188a9725eb49f3b8a42e35ae", "patch": "@@ -32,17 +32,17 @@ pub use rustc::session::config::Input;\n pub use rustc::session::search_paths::SearchPaths;\n \n /// Are we generating documentation (`Typed`) or tests (`NotTyped`)?\n-pub enum MaybeTyped<'tcx> {\n-    Typed(ty::ctxt<'tcx>),\n+pub enum MaybeTyped<'a, 'tcx: 'a> {\n+    Typed(&'a ty::ctxt<'tcx>),\n     NotTyped(session::Session)\n }\n \n pub type ExternalPaths = RefCell<Option<HashMap<ast::DefId,\n                                                 (Vec<String>, clean::TypeKind)>>>;\n \n-pub struct DocContext<'tcx> {\n+pub struct DocContext<'a, 'tcx: 'a> {\n     pub krate: &'tcx ast::Crate,\n-    pub maybe_typed: MaybeTyped<'tcx>,\n+    pub maybe_typed: MaybeTyped<'a, 'tcx>,\n     pub input: Input,\n     pub external_paths: ExternalPaths,\n     pub external_traits: RefCell<Option<HashMap<ast::DefId, clean::Trait>>>,\n@@ -52,17 +52,17 @@ pub struct DocContext<'tcx> {\n     pub deref_trait_did: Cell<Option<ast::DefId>>,\n }\n \n-impl<'tcx> DocContext<'tcx> {\n+impl<'b, 'tcx> DocContext<'b, 'tcx> {\n     pub fn sess<'a>(&'a self) -> &'a session::Session {\n         match self.maybe_typed {\n-            Typed(ref tcx) => &tcx.sess,\n+            Typed(tcx) => &tcx.sess,\n             NotTyped(ref sess) => sess\n         }\n     }\n \n     pub fn tcx_opt<'a>(&'a self) -> Option<&'a ty::ctxt<'tcx>> {\n         match self.maybe_typed {\n-            Typed(ref tcx) => Some(tcx),\n+            Typed(tcx) => Some(tcx),\n             NotTyped(_) => None\n         }\n     }\n@@ -133,48 +133,49 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n     let arenas = ty::CtxtArenas::new();\n     let ast_map = driver::assign_node_ids_and_map(&sess, &mut forest);\n \n-    let (tcx, ty::CrateAnalysis {\n-        exported_items, public_items, ..\n-    }) = driver::phase_3_run_analysis_passes(sess,\n-                                             ast_map,\n-                                             &arenas,\n-                                             name,\n-                                             resolve::MakeGlobMap::No);\n-\n-    let ctxt = DocContext {\n-        krate: tcx.map.krate(),\n-        maybe_typed: Typed(tcx),\n-        input: input,\n-        external_traits: RefCell::new(Some(HashMap::new())),\n-        external_typarams: RefCell::new(Some(HashMap::new())),\n-        external_paths: RefCell::new(Some(HashMap::new())),\n-        inlined: RefCell::new(Some(HashSet::new())),\n-        populated_crate_impls: RefCell::new(HashSet::new()),\n-        deref_trait_did: Cell::new(None),\n-    };\n-    debug!(\"crate: {:?}\", ctxt.krate);\n-\n-    let mut analysis = CrateAnalysis {\n-        exported_items: exported_items,\n-        public_items: public_items,\n-        external_paths: RefCell::new(None),\n-        external_typarams: RefCell::new(None),\n-        inlined: RefCell::new(None),\n-        deref_trait_did: None,\n-    };\n-\n-    let krate = {\n-        let mut v = RustdocVisitor::new(&ctxt, Some(&analysis));\n-        v.visit(ctxt.krate);\n-        v.clean(&ctxt)\n-    };\n-\n-    let external_paths = ctxt.external_paths.borrow_mut().take();\n-    *analysis.external_paths.borrow_mut() = external_paths;\n-    let map = ctxt.external_typarams.borrow_mut().take();\n-    *analysis.external_typarams.borrow_mut() = map;\n-    let map = ctxt.inlined.borrow_mut().take();\n-    *analysis.inlined.borrow_mut() = map;\n-    analysis.deref_trait_did = ctxt.deref_trait_did.get();\n-    (krate, analysis)\n+    driver::phase_3_run_analysis_passes(sess,\n+                                        ast_map,\n+                                        &arenas,\n+                                        name,\n+                                        resolve::MakeGlobMap::No,\n+                                        |tcx, analysis| {\n+        let ty::CrateAnalysis { exported_items, public_items, .. } = analysis;\n+\n+        let ctxt = DocContext {\n+            krate: tcx.map.krate(),\n+            maybe_typed: Typed(tcx),\n+            input: input,\n+            external_traits: RefCell::new(Some(HashMap::new())),\n+            external_typarams: RefCell::new(Some(HashMap::new())),\n+            external_paths: RefCell::new(Some(HashMap::new())),\n+            inlined: RefCell::new(Some(HashSet::new())),\n+            populated_crate_impls: RefCell::new(HashSet::new()),\n+            deref_trait_did: Cell::new(None),\n+        };\n+        debug!(\"crate: {:?}\", ctxt.krate);\n+\n+        let mut analysis = CrateAnalysis {\n+            exported_items: exported_items,\n+            public_items: public_items,\n+            external_paths: RefCell::new(None),\n+            external_typarams: RefCell::new(None),\n+            inlined: RefCell::new(None),\n+            deref_trait_did: None,\n+        };\n+\n+        let krate = {\n+            let mut v = RustdocVisitor::new(&ctxt, Some(&analysis));\n+            v.visit(ctxt.krate);\n+            v.clean(&ctxt)\n+        };\n+\n+        let external_paths = ctxt.external_paths.borrow_mut().take();\n+        *analysis.external_paths.borrow_mut() = external_paths;\n+        let map = ctxt.external_typarams.borrow_mut().take();\n+        *analysis.external_typarams.borrow_mut() = map;\n+        let map = ctxt.inlined.borrow_mut().take();\n+        *analysis.inlined.borrow_mut() = map;\n+        analysis.deref_trait_did = ctxt.deref_trait_did.get();\n+        (krate, analysis)\n+    }).1\n }"}, {"sha": "305747d12824a7fd567b4393d13bf960b17f50c2", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc383f62941ae079188a9725eb49f3b8a42e35ae/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc383f62941ae079188a9725eb49f3b8a42e35ae/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=bc383f62941ae079188a9725eb49f3b8a42e35ae", "patch": "@@ -38,14 +38,14 @@ use doctree::*;\n pub struct RustdocVisitor<'a, 'tcx: 'a> {\n     pub module: Module,\n     pub attrs: Vec<ast::Attribute>,\n-    pub cx: &'a core::DocContext<'tcx>,\n+    pub cx: &'a core::DocContext<'a, 'tcx>,\n     pub analysis: Option<&'a core::CrateAnalysis>,\n     view_item_stack: HashSet<ast::NodeId>,\n     inlining_from_glob: bool,\n }\n \n impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n-    pub fn new(cx: &'a core::DocContext<'tcx>,\n+    pub fn new(cx: &'a core::DocContext<'a, 'tcx>,\n                analysis: Option<&'a core::CrateAnalysis>) -> RustdocVisitor<'a, 'tcx> {\n         // If the root is reexported, terminate all recursion.\n         let mut stack = HashSet::new();"}, {"sha": "8af3844e62eefdee3de563b9c759018b42101a84", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bc383f62941ae079188a9725eb49f3b8a42e35ae/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc383f62941ae079188a9725eb49f3b8a42e35ae/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=bc383f62941ae079188a9725eb49f3b8a42e35ae", "patch": "@@ -221,25 +221,26 @@ fn compile_program(input: &str, sysroot: PathBuf)\n         let arenas = ty::CtxtArenas::new();\n         let ast_map = driver::assign_node_ids_and_map(&sess, &mut forest);\n \n-        let (tcx, analysis) = driver::phase_3_run_analysis_passes(\n-            sess, ast_map, &arenas, id, MakeGlobMap::No);\n+        driver::phase_3_run_analysis_passes(\n+            sess, ast_map, &arenas, id, MakeGlobMap::No, |tcx, analysis| {\n \n-        let trans = driver::phase_4_translate_to_llvm(&tcx, analysis);\n+            let trans = driver::phase_4_translate_to_llvm(tcx, analysis);\n \n-        let crates = tcx.sess.cstore.get_used_crates(RequireDynamic);\n+            let crates = tcx.sess.cstore.get_used_crates(RequireDynamic);\n \n-        // Collect crates used in the session.\n-        // Reverse order finds dependencies first.\n-        let deps = crates.into_iter().rev()\n-            .filter_map(|(_, p)| p).collect();\n+            // Collect crates used in the session.\n+            // Reverse order finds dependencies first.\n+            let deps = crates.into_iter().rev()\n+                .filter_map(|(_, p)| p).collect();\n \n-        assert_eq!(trans.modules.len(), 1);\n-        let llmod = trans.modules[0].llmod;\n+            assert_eq!(trans.modules.len(), 1);\n+            let llmod = trans.modules[0].llmod;\n \n-        // Workaround because raw pointers do not impl Send\n-        let modp = llmod as usize;\n+            // Workaround because raw pointers do not impl Send\n+            let modp = llmod as usize;\n \n-        (modp, deps)\n+            (modp, deps)\n+        }).1\n     }).unwrap();\n \n     match handle.join() {"}]}