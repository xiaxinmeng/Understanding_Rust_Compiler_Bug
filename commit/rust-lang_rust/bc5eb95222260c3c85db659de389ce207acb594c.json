{"sha": "bc5eb95222260c3c85db659de389ce207acb594c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjNWViOTUyMjIyNjBjM2M4NWRiNjU5ZGUzODljZTIwN2FjYjU5NGM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-21T22:55:17Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-21T23:07:53Z"}, "message": "implement a map testing benchmark\n\nThis involved some other changes:\n- add a managed<T> wrapper that makes send_map usable from @-data\n- implement map<K,V> for managed<send_map>\n\nUnit tests are coming.", "tree": {"sha": "708ca1c43de068fb83a31e1e350e6093b50d1491", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/708ca1c43de068fb83a31e1e350e6093b50d1491"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc5eb95222260c3c85db659de389ce207acb594c", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc5eb95222260c3c85db659de389ce207acb594c", "html_url": "https://github.com/rust-lang/rust/commit/bc5eb95222260c3c85db659de389ce207acb594c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc5eb95222260c3c85db659de389ce207acb594c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "182814ef8191e2b153806380f8d3d46069c69a8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/182814ef8191e2b153806380f8d3d46069c69a8d", "html_url": "https://github.com/rust-lang/rust/commit/182814ef8191e2b153806380f8d3d46069c69a8d"}], "stats": {"total": 377, "additions": 367, "deletions": 10}, "files": [{"sha": "4b1ace5651b15df00bcdc65f0c2b8318d667bade", "filename": "src/libcore/core.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc5eb95222260c3c85db659de389ce207acb594c/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/bc5eb95222260c3c85db659de389ce207acb594c/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=bc5eb95222260c3c85db659de389ce207acb594c", "patch": "@@ -55,6 +55,7 @@ export hash;\n export cmp;\n export num;\n export path;\n+export managed;\n \n // NDM seems to be necessary for resolve to work\n export option_iter;\n@@ -261,6 +262,7 @@ mod sys;\n #[warn(non_camel_case_types)]\n mod unsafe;\n \n+mod managed;\n \n // Modules supporting compiler-generated code\n // Exported but not part of the public interface"}, {"sha": "06fcd87282b0f231b210515f9c7b1fe3f2e465d9", "filename": "src/libcore/managed.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/bc5eb95222260c3c85db659de389ce207acb594c/src%2Flibcore%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc5eb95222260c3c85db659de389ce207acb594c/src%2Flibcore%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmanaged.rs?ref=bc5eb95222260c3c85db659de389ce207acb594c", "patch": "@@ -0,0 +1,62 @@\n+/*!\n+\n+Module for wrapping freezable data structures in managed boxes.\n+Normally freezable data structures require an unaliased reference,\n+such as `T` or `~T`, so that the compiler can track when they are\n+being mutated.  The `rw<T>` type converts these static checks into\n+dynamic checks: your program will fail if you attempt to perform\n+mutation when the data structure should be immutable.\n+\n+*/\n+\n+#[forbid(non_camel_case_types)];\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n+import util::with;\n+import unsafe::transmute_immut;\n+\n+export Managed;\n+\n+enum Mode { ReadOnly, Mutable, Immutable }\n+\n+struct Data<T> {\n+    mut value: T;\n+    mut mode: Mode;\n+}\n+\n+type Managed<T> = @Data<T>;\n+\n+fn Managed<T>(+t: T) -> Managed<T> {\n+    @Data {value: t, mode: ReadOnly}\n+}\n+\n+impl<T> Data<T> {\n+    fn borrow_mut<R>(op: &fn(t: &mut T) -> R) -> R {\n+        match self.mode {\n+          Immutable => fail fmt!(\"%? currently immutable\",\n+                                 self.value),\n+          ReadOnly | Mutable => {}\n+        }\n+\n+        do with(&mut self.mode, Mutable) {\n+            op(&mut self.value)\n+        }\n+    }\n+\n+    fn borrow_const<R>(op: &fn(t: &const T) -> R) -> R {\n+        op(&const self.value)\n+    }\n+\n+    fn borrow_imm<R>(op: &fn(t: &T) -> R) -> R {\n+        match self.mode {\n+          Mutable => fail fmt!(\"%? currently mutable\",\n+                               self.value),\n+          ReadOnly | Immutable => {}\n+        }\n+\n+        do with(&mut self.mode, Immutable) {\n+            op(unsafe{transmute_immut(&mut self.value)})\n+        }\n+    }\n+}"}, {"sha": "9b5b6e0d4f3b14e29c77f822356a77c32e6a7cfe", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bc5eb95222260c3c85db659de389ce207acb594c/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc5eb95222260c3c85db659de389ce207acb594c/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=bc5eb95222260c3c85db659de389ce207acb594c", "patch": "@@ -221,6 +221,13 @@ mod linear {\n             self.size -= 1;\n             return true;\n         }\n+\n+        fn clear() {\n+            for uint::range(0, self.buckets.len()) |idx| {\n+                self.buckets[idx] = none;\n+            }\n+            self.size = 0;\n+        }\n     }\n \n     priv impl<K,V> &LinearMap<K,V> {"}, {"sha": "8487e4ff930e09a97d04aa4f3dda35b81fd2ef03", "filename": "src/libcore/util.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc5eb95222260c3c85db659de389ce207acb594c/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc5eb95222260c3c85db659de389ce207acb594c/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=bc5eb95222260c3c85db659de389ce207acb594c", "patch": "@@ -12,6 +12,24 @@ pure fn id<T>(+x: T) -> T { x }\n /// Ignores a value.\n pure fn ignore<T>(+_x: T) { }\n \n+/// Sets `*ptr` to `new_value`, invokes `op()`, and then restores the\n+/// original value of `*ptr`.\n+#[inline(always)]\n+fn with<T: copy, R>(\n+    ptr: &mut T,\n+    +new_value: T,\n+    op: &fn() -> R) -> R\n+{\n+    // NDM: if swap operator were defined somewhat differently,\n+    // we wouldn't need to copy...\n+\n+    let old_value = *ptr;\n+    *ptr = move new_value;\n+    let result = op();\n+    *ptr = move old_value;\n+    return move result;\n+}\n+\n /**\n  * Swap the values at two mutable locations of the same type, without\n  * deinitialising or copying either one."}, {"sha": "538a6446001f01d30e5297da876a528a4d9849b1", "filename": "src/libstd/map.rs", "status": "modified", "additions": 97, "deletions": 7, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/bc5eb95222260c3c85db659de389ce207acb594c/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc5eb95222260c3c85db659de389ce207acb594c/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=bc5eb95222260c3c85db659de389ce207acb594c", "patch": "@@ -4,6 +4,9 @@\n \n import io::WriterUtil;\n import to_str::ToStr;\n+import managed::Managed;\n+import send_map::linear::LinearMap;\n+\n export hashmap, hashfn, eqfn, set, map, chained, hashmap, str_hash;\n export box_str_hash;\n export bytes_hash, int_hash, uint_hash, set_add;\n@@ -59,10 +62,10 @@ trait map<K: copy, V: copy> {\n     fn find(+key: K) -> option<V>;\n \n     /**\n-     * Remove and return a value from the map. If the key does not exist\n-     * in the map then returns none.\n+     * Remove and return a value from the map. Returns true if the\n+     * key was present in the map, otherwise false.\n      */\n-    fn remove(+key: K) -> option<V>;\n+    fn remove(+key: K) -> bool;\n \n     /// Clear the map, removing all key/value pairs.\n     fn clear();\n@@ -279,18 +282,18 @@ mod chained {\n             option::unwrap(opt_v)\n         }\n \n-        fn remove(+k: K) -> option<V> {\n+        fn remove(+k: K) -> bool {\n             match self.search_tbl(&k, self.hasher(&k)) {\n-              not_found => none,\n+              not_found => false,\n               found_first(idx, entry) => {\n                 self.count -= 1u;\n                 self.chains[idx] = entry.next;\n-                some(entry.value)\n+                true\n               }\n               found_after(eprev, entry) => {\n                 self.count -= 1u;\n                 eprev.next = entry.next;\n-                some(entry.value)\n+                true\n               }\n             }\n         }\n@@ -468,6 +471,93 @@ fn hash_from_uints<V: copy>(items: &[(uint, V)]) -> hashmap<uint, V> {\n     hash_from_vec(uint::hash, uint::eq, items)\n }\n \n+// XXX Transitionary\n+impl<K: copy, V: copy> Managed<LinearMap<K, V>>: map<K, V> {\n+    fn size() -> uint {\n+        do self.borrow_const |p| {\n+            p.len()\n+        }\n+    }\n+\n+    fn insert(+key: K, +value: V) -> bool {\n+        do self.borrow_mut |p| {\n+            p.insert(key, value)\n+        }\n+    }\n+\n+    fn contains_key(+key: K) -> bool {\n+        do self.borrow_const |p| {\n+            p.contains_key(&key)\n+        }\n+    }\n+\n+    fn contains_key_ref(key: &K) -> bool {\n+        do self.borrow_const |p| {\n+            p.contains_key(key)\n+        }\n+    }\n+\n+    fn get(+key: K) -> V {\n+        do self.borrow_const |p| {\n+            p.get(&key)\n+        }\n+    }\n+\n+    fn find(+key: K) -> option<V> {\n+        do self.borrow_const |p| {\n+            p.find(&key)\n+        }\n+    }\n+\n+    fn remove(+key: K) -> bool {\n+        do self.borrow_mut |p| {\n+            p.remove(&key)\n+        }\n+    }\n+\n+    fn clear() {\n+        do self.borrow_mut |p| {\n+            p.clear()\n+        }\n+    }\n+\n+    fn each(op: fn(+key: K, +value: V) -> bool) {\n+        do self.borrow_imm |p| {\n+            p.each(op)\n+        }\n+    }\n+\n+    fn each_key(op: fn(+key: K) -> bool) {\n+        do self.borrow_imm |p| {\n+            p.each_key(op)\n+        }\n+    }\n+\n+    fn each_value(op: fn(+value: V) -> bool) {\n+        do self.borrow_imm |p| {\n+            p.each_value(op)\n+        }\n+    }\n+\n+    fn each_ref(op: fn(key: &K, value: &V) -> bool) {\n+        do self.borrow_imm |p| {\n+            p.each_ref(op)\n+        }\n+    }\n+\n+    fn each_key_ref(op: fn(key: &K) -> bool) {\n+        do self.borrow_imm |p| {\n+            p.each_key_ref(op)\n+        }\n+    }\n+\n+    fn each_value_ref(op: fn(value: &V) -> bool) {\n+        do self.borrow_imm |p| {\n+            p.each_value_ref(op)\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n "}, {"sha": "04b04f505a452baa8ce4084e5e312e4db72545b8", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc5eb95222260c3c85db659de389ce207acb594c/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc5eb95222260c3c85db659de389ce207acb594c/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=bc5eb95222260c3c85db659de389ce207acb594c", "patch": "@@ -80,13 +80,13 @@ impl<V: copy> smallintmap<V>: map::map<uint, V> {\n         insert(self, key, value);\n         return !exists;\n     }\n-    fn remove(+key: uint) -> option<V> {\n+    fn remove(+key: uint) -> bool {\n         if key >= self.v.len() {\n-            return none;\n+            return false;\n         }\n         let old = self.v.get_elt(key);\n         self.v.set_elt(key, none);\n-        old\n+        old.is_some()\n     }\n     fn clear() {\n         self.v.set(~[mut]);"}, {"sha": "9a267a5a25daccc35924c7238510e189e05d8fc1", "filename": "src/test/bench/core-map.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/bc5eb95222260c3c85db659de389ce207acb594c/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc5eb95222260c3c85db659de389ce207acb594c/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=bc5eb95222260c3c85db659de389ce207acb594c", "patch": "@@ -0,0 +1,178 @@\n+/*\n+\n+\n+\n+*/\n+\n+use std;\n+import rand;\n+import std::map;\n+import managed::Managed;\n+import send_map::linear::*;\n+import io::WriterUtil;\n+\n+struct Results {\n+    sequential_ints: float;\n+    random_ints: float;\n+    delete_ints: float;\n+\n+    sequential_strings: float;\n+    random_strings: float;\n+    delete_strings: float;\n+}\n+\n+fn timed(result: &mut float,\n+         op: fn()) {\n+    let start = std::time::precise_time_s();\n+    op();\n+    let end = std::time::precise_time_s();\n+    *result = (end - start);\n+}\n+\n+fn int_benchmarks<M: map::map<uint, uint>>(make_map: fn() -> M,\n+                                           rng: @rand::Rng,\n+                                           num_keys: uint,\n+                                           results: &mut Results) {\n+\n+    {\n+        let map = make_map();\n+        do timed(&mut results.sequential_ints) {\n+            for uint::range(0, num_keys) |i| {\n+                map.insert(i, i+1);\n+            }\n+\n+            for uint::range(0, num_keys) |i| {\n+                assert map.get(i) == i+1;\n+            }\n+        }\n+    }\n+\n+    {\n+        let map = make_map();\n+        do timed(&mut results.random_ints) {\n+            for uint::range(0, num_keys) |i| {\n+                map.insert(rng.next() as uint, i);\n+            }\n+        }\n+    }\n+\n+    {\n+        let map = make_map();\n+        for uint::range(0, num_keys) |i| {\n+            map.insert(i, i);;\n+        }\n+\n+        do timed(&mut results.delete_ints) {\n+            for uint::range(0, num_keys) |i| {\n+                assert map.remove(i);\n+            }\n+        }\n+    }\n+}\n+\n+fn str_benchmarks<M: map::map<~str, uint>>(make_map: fn() -> M,\n+                                           rng: @rand::Rng,\n+                                           num_keys: uint,\n+                                           results: &mut Results) {\n+    {\n+        let map = make_map();\n+        do timed(&mut results.sequential_strings) {\n+            for uint::range(0, num_keys) |i| {\n+                let s = uint::to_str(i, 10);\n+                map.insert(s, i);\n+            }\n+\n+            for uint::range(0, num_keys) |i| {\n+                let s = uint::to_str(i, 10);\n+                assert map.get(s) == i;\n+            }\n+        }\n+    }\n+\n+    {\n+        let map = make_map();\n+        do timed(&mut results.random_strings) {\n+            for uint::range(0, num_keys) |i| {\n+                let s = uint::to_str(rng.next() as uint, 10);\n+                map.insert(s, i);\n+            }\n+        }\n+    }\n+\n+    {\n+        let map = make_map();\n+        for uint::range(0, num_keys) |i| {\n+            map.insert(uint::to_str(i, 10), i);\n+        }\n+        do timed(&mut results.delete_strings) {\n+            for uint::range(0, num_keys) |i| {\n+                assert map.remove(uint::to_str(i, 10));\n+            }\n+        }\n+    }\n+}\n+\n+fn write_header(header: &str) {\n+    io::stdout().write_str(header);\n+    io::stdout().write_str(\"\\n\");\n+}\n+\n+fn write_row(label: &str, value: float) {\n+    io::stdout().write_str(fmt!(\"%30s %f s\\n\", label, value));\n+}\n+\n+fn write_results(label: &str, results: &Results) {\n+    write_header(label);\n+    write_row(\"sequential_ints\", results.sequential_ints);\n+    write_row(\"random_ints\", results.random_ints);\n+    write_row(\"delete_ints\", results.delete_ints);\n+    write_row(\"sequential_strings\", results.sequential_strings);\n+    write_row(\"random_strings\", results.random_strings);\n+    write_row(\"delete_strings\", results.delete_strings);\n+}\n+\n+fn empty_results() -> Results {\n+    Results {\n+        sequential_ints: 0f,\n+        random_ints: 0f,\n+        delete_ints: 0f,\n+\n+        sequential_strings: 0f,\n+        random_strings: 0f,\n+        delete_strings: 0f,\n+    }\n+}\n+\n+fn main(args: ~[~str]) {\n+    let num_keys = {\n+        if args.len() == 2 {\n+            uint::from_str(args[1]).get()\n+        } else {\n+            100 // woefully inadequate for any real measurement\n+        }\n+    };\n+\n+    let seed = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+\n+    {\n+        let rng = rand::seeded_rng(copy seed);\n+        let mut results = empty_results();\n+        int_benchmarks::<map::hashmap<uint, uint>>(\n+            map::uint_hash, rng, num_keys, &mut results);\n+        str_benchmarks::<map::hashmap<~str, uint>>(\n+            map::str_hash, rng, num_keys, &mut results);\n+        write_results(\"libstd::map::hashmap\", &results);\n+    }\n+\n+    {\n+        let rng = rand::seeded_rng(copy seed);\n+        let mut results = empty_results();\n+        int_benchmarks::<Managed<LinearMap<uint, uint>>>(\n+            || Managed(linear_map(uint::hash, uint::eq)),\n+            rng, num_keys, &mut results);\n+        str_benchmarks::<Managed<LinearMap<~str, uint>>>(\n+            || Managed(linear_map(str::hash, str::eq)),\n+            rng, num_keys, &mut results);\n+        write_results(\"libstd::map::hashmap\", &results);\n+    }\n+}\n\\ No newline at end of file"}]}