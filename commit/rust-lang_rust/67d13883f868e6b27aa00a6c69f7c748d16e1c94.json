{"sha": "67d13883f868e6b27aa00a6c69f7c748d16e1c94", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3ZDEzODgzZjg2OGU2YjI3YWEwMGE2YzY5ZjdjNzQ4ZDE2ZTFjOTQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-31T02:51:51Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-31T02:51:51Z"}, "message": "rollup merge of #20061: aturon/stab-2-vec-slice\n\nConflicts:\n\tsrc/libcollections/slice.rs\n\tsrc/libcollections/vec.rs\n\tsrc/libstd/sys/windows/os.rs", "tree": {"sha": "195395a9e6d556c7c60a1507376a75e9e0c348bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/195395a9e6d556c7c60a1507376a75e9e0c348bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67d13883f868e6b27aa00a6c69f7c748d16e1c94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67d13883f868e6b27aa00a6c69f7c748d16e1c94", "html_url": "https://github.com/rust-lang/rust/commit/67d13883f868e6b27aa00a6c69f7c748d16e1c94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67d13883f868e6b27aa00a6c69f7c748d16e1c94/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd0f29ad0f3ddc48f36340cd0abff4712e882a3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd0f29ad0f3ddc48f36340cd0abff4712e882a3e", "html_url": "https://github.com/rust-lang/rust/commit/dd0f29ad0f3ddc48f36340cd0abff4712e882a3e"}, {"sha": "6abfac083feafc73e5d736177755cce3bfb7153f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6abfac083feafc73e5d736177755cce3bfb7153f", "html_url": "https://github.com/rust-lang/rust/commit/6abfac083feafc73e5d736177755cce3bfb7153f"}], "stats": {"total": 5253, "additions": 2627, "deletions": 2626}, "files": [{"sha": "c513aec0b843a9ac793fc7276b46718ceb4b0dab", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -32,6 +32,7 @@ use std::io::process;\n use std::io::timer;\n use std::io;\n use std::os;\n+use std::iter::repeat;\n use std::str;\n use std::string::String;\n use std::thread::Thread;\n@@ -947,8 +948,7 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n                          proc_res: &ProcRes) {\n \n     // true if we found the error in question\n-    let mut found_flags = Vec::from_elem(\n-        expected_errors.len(), false);\n+    let mut found_flags: Vec<_> = repeat(false).take(expected_errors.len()).collect();\n \n     if proc_res.status.success() {\n         fatal(\"process did not return an error status\");\n@@ -1308,7 +1308,7 @@ fn make_run_args(config: &Config, props: &TestProps, testfile: &Path) ->\n     // Add the arguments in the run_flags directive\n     args.extend(split_maybe_args(&props.run_flags).into_iter());\n \n-    let prog = args.remove(0).unwrap();\n+    let prog = args.remove(0);\n     return ProcArgs {\n         prog: prog,\n         args: args,"}, {"sha": "03634657a71b7da8a37dd15d86743d815d2bf0cc", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -96,7 +96,7 @@ use heap::deallocate;\n /// use std::thread::Thread;\n ///\n /// fn main() {\n-///     let numbers = Vec::from_fn(100, |i| i as f32);\n+///     let numbers: Vec<_> = range(0, 100u32).map(|i| i as f32).collect();\n ///     let shared_numbers = Arc::new(numbers);\n ///\n ///     for _ in range(0u, 10) {"}, {"sha": "2427422f743208bbceb77fcc037ce299def3e0b1", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -66,7 +66,7 @@\n //! // for a simpler implementation.\n //! fn shortest_path(adj_list: &Vec<Vec<Edge>>, start: uint, goal: uint) -> uint {\n //!     // dist[node] = current shortest distance from `start` to `node`\n-//!     let mut dist = Vec::from_elem(adj_list.len(), uint::MAX);\n+//!     let mut dist: Vec<_> = range(0, adj_list.len()).map(|_| uint::MAX).collect();\n //!\n //!     let mut heap = BinaryHeap::new();\n //!"}, {"sha": "e29f19bbed3696ec7193e9b8e681a60a98124453", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -85,7 +85,7 @@ use core::prelude::*;\n use core::cmp;\n use core::default::Default;\n use core::fmt;\n-use core::iter::{Cloned, Chain, Enumerate, Repeat, Skip, Take};\n+use core::iter::{Cloned, Chain, Enumerate, Repeat, Skip, Take, repeat};\n use core::iter;\n use core::num::Int;\n use core::slice::{Iter, IterMut};\n@@ -267,7 +267,7 @@ impl Bitv {\n     pub fn from_elem(nbits: uint, bit: bool) -> Bitv {\n         let nblocks = blocks_for_bits(nbits);\n         let mut bitv = Bitv {\n-            storage: Vec::from_elem(nblocks, if bit { !0u32 } else { 0u32 }),\n+            storage: repeat(if bit { !0u32 } else { 0u32 }).take(nblocks).collect(),\n             nbits: nbits\n         };\n         bitv.fix_last_block();\n@@ -651,7 +651,7 @@ impl Bitv {\n \n         let len = self.nbits/8 +\n                   if self.nbits % 8 == 0 { 0 } else { 1 };\n-        Vec::from_fn(len, |i|\n+        range(0, len).map(|i|\n             bit(self, i, 0) |\n             bit(self, i, 1) |\n             bit(self, i, 2) |\n@@ -660,7 +660,7 @@ impl Bitv {\n             bit(self, i, 5) |\n             bit(self, i, 6) |\n             bit(self, i, 7)\n-        )\n+        ).collect()\n     }\n \n     /// Deprecated: Use `iter().collect()`.\n@@ -834,7 +834,7 @@ impl Bitv {\n         // Allocate new words, if needed\n         if new_nblocks > self.storage.len() {\n             let to_add = new_nblocks - self.storage.len();\n-            self.storage.grow(to_add, full_value);\n+            self.storage.extend(repeat(full_value).take(to_add));\n         }\n \n         // Adjust internal bit count"}, {"sha": "8f51b551700761f7454d8eedef15cf233b85409f", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -555,10 +555,10 @@ impl <K, V> Node<K, V> {\n         let node = mem::replace(left_and_out, unsafe { Node::new_internal(capacity_from_b(b)) });\n         left_and_out._len = 1;\n         unsafe {\n-            ptr::write(left_and_out.keys_mut().unsafe_mut(0), key);\n-            ptr::write(left_and_out.vals_mut().unsafe_mut(0), value);\n-            ptr::write(left_and_out.edges_mut().unsafe_mut(0), node);\n-            ptr::write(left_and_out.edges_mut().unsafe_mut(1), right);\n+            ptr::write(left_and_out.keys_mut().get_unchecked_mut(0), key);\n+            ptr::write(left_and_out.vals_mut().get_unchecked_mut(0), value);\n+            ptr::write(left_and_out.edges_mut().get_unchecked_mut(0), node);\n+            ptr::write(left_and_out.edges_mut().get_unchecked_mut(1), right);\n         }\n     }\n \n@@ -637,7 +637,7 @@ impl<'a, K: 'a, V: 'a> Handle<&'a Node<K, V>, handle::Edge, handle::Internal> {\n     /// making it more suitable for moving down a chain of nodes.\n     pub fn into_edge(self) -> &'a Node<K, V> {\n         unsafe {\n-            self.node.edges().unsafe_get(self.index)\n+            self.node.edges().get_unchecked(self.index)\n         }\n     }\n }\n@@ -648,7 +648,7 @@ impl<'a, K: 'a, V: 'a> Handle<&'a mut Node<K, V>, handle::Edge, handle::Internal\n     /// `edge_mut`, making it more suitable for moving down a chain of nodes.\n     pub fn into_edge_mut(self) -> &'a mut Node<K, V> {\n         unsafe {\n-            self.node.edges_mut().unsafe_mut(self.index)\n+            self.node.edges_mut().get_unchecked_mut(self.index)\n         }\n     }\n }\n@@ -722,7 +722,7 @@ impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::Edge, handle::\n     /// confused with `node`, which references the parent node of what is returned here.\n     pub fn edge_mut(&mut self) -> &mut Node<K, V> {\n         unsafe {\n-            self.node.edges_mut().unsafe_mut(self.index)\n+            self.node.edges_mut().get_unchecked_mut(self.index)\n         }\n     }\n \n@@ -830,8 +830,8 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a Node<K, V>, handle::KV, NodeType> {\n         let (keys, vals) = self.node.as_slices();\n         unsafe {\n             (\n-                keys.unsafe_get(self.index),\n-                vals.unsafe_get(self.index)\n+                keys.get_unchecked(self.index),\n+                vals.get_unchecked(self.index)\n             )\n         }\n     }\n@@ -845,8 +845,8 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a mut Node<K, V>, handle::KV, NodeType\n         let (keys, vals) = self.node.as_slices_mut();\n         unsafe {\n             (\n-                keys.unsafe_mut(self.index),\n-                vals.unsafe_mut(self.index)\n+                keys.get_unchecked_mut(self.index),\n+                vals.get_unchecked_mut(self.index)\n             )\n         }\n     }\n@@ -870,14 +870,14 @@ impl<'a, K: 'a, V: 'a, NodeRef: Deref<Node<K, V>> + 'a, NodeType> Handle<NodeRef\n     // /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n     // /// handle.\n     // pub fn key(&'a self) -> &'a K {\n-    //     unsafe { self.node.keys().unsafe_get(self.index) }\n+    //     unsafe { self.node.keys().get_unchecked(self.index) }\n     // }\n     //\n     // /// Returns a reference to the value pointed-to by this handle. This doesn't return a\n     // /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n     // /// handle.\n     // pub fn val(&'a self) -> &'a V {\n-    //     unsafe { self.node.vals().unsafe_get(self.index) }\n+    //     unsafe { self.node.vals().get_unchecked(self.index) }\n     // }\n }\n \n@@ -887,14 +887,14 @@ impl<'a, K: 'a, V: 'a, NodeRef: DerefMut<Node<K, V>> + 'a, NodeType> Handle<Node\n     /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n     /// handle.\n     pub fn key_mut(&'a mut self) -> &'a mut K {\n-        unsafe { self.node.keys_mut().unsafe_mut(self.index) }\n+        unsafe { self.node.keys_mut().get_unchecked_mut(self.index) }\n     }\n \n     /// Returns a mutable reference to the value pointed-to by this handle. This doesn't return a\n     /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n     /// handle.\n     pub fn val_mut(&'a mut self) -> &'a mut V {\n-        unsafe { self.node.vals_mut().unsafe_mut(self.index) }\n+        unsafe { self.node.vals_mut().get_unchecked_mut(self.index) }\n     }\n }\n \n@@ -1078,7 +1078,7 @@ impl<K, V> Node<K, V> {\n         debug_assert!(!self.is_leaf());\n \n         unsafe {\n-            let ret = ptr::read(self.edges().unsafe_get(0));\n+            let ret = ptr::read(self.edges().get_unchecked(0));\n             self.destroy();\n             ptr::write(self, ret);\n         }\n@@ -1092,8 +1092,8 @@ impl<K, V> Node<K, V> {\n     unsafe fn push_kv(&mut self, key: K, val: V) {\n         let len = self.len();\n \n-        ptr::write(self.keys_mut().unsafe_mut(len), key);\n-        ptr::write(self.vals_mut().unsafe_mut(len), val);\n+        ptr::write(self.keys_mut().get_unchecked_mut(len), key);\n+        ptr::write(self.vals_mut().get_unchecked_mut(len), val);\n \n         self._len += 1;\n     }\n@@ -1103,7 +1103,7 @@ impl<K, V> Node<K, V> {\n     unsafe fn push_edge(&mut self, edge: Node<K, V>) {\n         let len = self.len();\n \n-        ptr::write(self.edges_mut().unsafe_mut(len), edge);\n+        ptr::write(self.edges_mut().get_unchecked_mut(len), edge);\n     }\n \n     // This must be followed by insert_edge on an internal node.\n@@ -1120,12 +1120,12 @@ impl<K, V> Node<K, V> {\n             self.len() - index\n         );\n \n-        ptr::write(self.keys_mut().unsafe_mut(index), key);\n-        ptr::write(self.vals_mut().unsafe_mut(index), val);\n+        ptr::write(self.keys_mut().get_unchecked_mut(index), key);\n+        ptr::write(self.vals_mut().get_unchecked_mut(index), val);\n \n         self._len += 1;\n \n-        self.vals_mut().unsafe_mut(index)\n+        self.vals_mut().get_unchecked_mut(index)\n     }\n \n     // This can only be called immediately after a call to insert_kv.\n@@ -1136,14 +1136,14 @@ impl<K, V> Node<K, V> {\n             self.edges().as_ptr().offset(index as int),\n             self.len() - index\n         );\n-        ptr::write(self.edges_mut().unsafe_mut(index), edge);\n+        ptr::write(self.edges_mut().get_unchecked_mut(index), edge);\n     }\n \n     // This must be followed by pop_edge on an internal node.\n     #[inline]\n     unsafe fn pop_kv(&mut self) -> (K, V) {\n-        let key = ptr::read(self.keys().unsafe_get(self.len() - 1));\n-        let val = ptr::read(self.vals().unsafe_get(self.len() - 1));\n+        let key = ptr::read(self.keys().get_unchecked(self.len() - 1));\n+        let val = ptr::read(self.vals().get_unchecked(self.len() - 1));\n \n         self._len -= 1;\n \n@@ -1153,16 +1153,16 @@ impl<K, V> Node<K, V> {\n     // This can only be called immediately after a call to pop_kv.\n     #[inline]\n     unsafe fn pop_edge(&mut self) -> Node<K, V> {\n-        let edge = ptr::read(self.edges().unsafe_get(self.len() + 1));\n+        let edge = ptr::read(self.edges().get_unchecked(self.len() + 1));\n \n         edge\n     }\n \n     // This must be followed by remove_edge on an internal node.\n     #[inline]\n     unsafe fn remove_kv(&mut self, index: uint) -> (K, V) {\n-        let key = ptr::read(self.keys().unsafe_get(index));\n-        let val = ptr::read(self.vals().unsafe_get(index));\n+        let key = ptr::read(self.keys().get_unchecked(index));\n+        let val = ptr::read(self.vals().get_unchecked(index));\n \n         ptr::copy_memory(\n             self.keys_mut().as_mut_ptr().offset(index as int),\n@@ -1183,7 +1183,7 @@ impl<K, V> Node<K, V> {\n     // This can only be called immediately after a call to remove_kv.\n     #[inline]\n     unsafe fn remove_edge(&mut self, index: uint) -> Node<K, V> {\n-        let edge = ptr::read(self.edges().unsafe_get(index));\n+        let edge = ptr::read(self.edges().get_unchecked(index));\n \n         ptr::copy_memory(\n             self.edges_mut().as_mut_ptr().offset(index as int),\n@@ -1230,8 +1230,8 @@ impl<K, V> Node<K, V> {\n                 );\n             }\n \n-            let key = ptr::read(self.keys().unsafe_get(right_offset - 1));\n-            let val = ptr::read(self.vals().unsafe_get(right_offset - 1));\n+            let key = ptr::read(self.keys().get_unchecked(right_offset - 1));\n+            let val = ptr::read(self.vals().get_unchecked(right_offset - 1));\n \n             self._len = right_offset - 1;\n \n@@ -1250,8 +1250,8 @@ impl<K, V> Node<K, V> {\n             let old_len = self.len();\n             self._len += right.len() + 1;\n \n-            ptr::write(self.keys_mut().unsafe_mut(old_len), key);\n-            ptr::write(self.vals_mut().unsafe_mut(old_len), val);\n+            ptr::write(self.keys_mut().get_unchecked_mut(old_len), key);\n+            ptr::write(self.vals_mut().get_unchecked_mut(old_len), val);\n \n             ptr::copy_nonoverlapping_memory(\n                 self.keys_mut().as_mut_ptr().offset(old_len as int + 1),"}, {"sha": "82dabedd871a4c9648f9fd07b0f4ee08a9b99b45", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -1294,8 +1294,10 @@ mod tests {\n                     v.pop();\n                 }\n                 1 => {\n-                    m.pop_front();\n-                    v.remove(0);\n+                    if !v.is_empty() {\n+                        m.pop_front();\n+                        v.remove(0);\n+                    }\n                 }\n                 2 | 4 =>  {\n                     m.push_front(-i);"}, {"sha": "688214140c1be1ec999bd24dc1b9ca3d6a0e8e50", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -128,8 +128,8 @@ mod prelude {\n     pub use unicode::char::UnicodeChar;\n \n     // from collections.\n-    pub use slice::{CloneSliceExt, VectorVector};\n-    pub use str::{IntoMaybeOwned, StrVector};\n+    pub use slice::{CloneSliceExt, SliceConcatExt};\n+    pub use str::IntoMaybeOwned;\n     pub use string::{String, ToString};\n     pub use vec::Vec;\n }"}, {"sha": "aeda7309064f723c99d19e70a263b1063ccd9888", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -1154,7 +1154,7 @@ impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n         }\n         let tail = self.tail;\n         self.tail = wrap_index(self.tail + 1, self.ring.len());\n-        unsafe { Some(self.ring.unsafe_get(tail)) }\n+        unsafe { Some(self.ring.get_unchecked(tail)) }\n     }\n \n     #[inline]\n@@ -1171,7 +1171,7 @@ impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n             return None;\n         }\n         self.head = wrap_index(self.head - 1, self.ring.len());\n-        unsafe { Some(self.ring.unsafe_get(self.head)) }\n+        unsafe { Some(self.ring.get_unchecked(self.head)) }\n     }\n }\n \n@@ -1190,7 +1190,7 @@ impl<'a, T> RandomAccessIterator<&'a T> for Iter<'a, T> {\n             None\n         } else {\n             let idx = wrap_index(self.tail + j, self.ring.len());\n-            unsafe { Some(self.ring.unsafe_get(idx)) }\n+            unsafe { Some(self.ring.get_unchecked(idx)) }\n         }\n     }\n }"}, {"sha": "bbe6ecc8ea6b56f47e1350b33b969088f3b85636", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1145, "deletions": 1066, "changes": 2211, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -96,1247 +96,1318 @@ use core::mem::size_of;\n use core::mem;\n use core::ops::{FnMut,SliceMut};\n use core::prelude::{Clone, Greater, Iterator, IteratorExt, Less, None, Option};\n-use core::prelude::{Ord, Ordering, PtrExt, Some, range};\n+use core::prelude::{Ord, Ordering, PtrExt, Some, range, IteratorCloneExt, Result};\n use core::ptr;\n use core::slice as core_slice;\n use self::Direction::*;\n \n use vec::Vec;\n \n-pub use core::slice::{Chunks, AsSlice, SplitsN, Windows};\n+pub use core::slice::{Chunks, AsSlice, Windows};\n pub use core::slice::{Iter, IterMut, PartialEqSliceExt};\n-pub use core::slice::{ImmutableIntSlice, MutableIntSlice};\n-pub use core::slice::{MutSplits, MutChunks, Splits};\n+pub use core::slice::{IntSliceExt, SplitMut, ChunksMut, Split};\n+pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n pub use core::slice::{bytes, mut_ref_slice, ref_slice};\n-pub use core::slice::{from_raw_buf, from_raw_mut_buf, BinarySearchResult};\n+pub use core::slice::{from_raw_buf, from_raw_mut_buf};\n \n-// Functional utilities\n+#[deprecated = \"use Iter instead\"]\n+pub type Items<'a, T:'a> = Iter<'a, T>;\n \n-#[allow(missing_docs)]\n-pub trait VectorVector<T> for Sized? {\n-    // FIXME #5898: calling these .concat and .connect conflicts with\n-    // StrVector::con{cat,nect}, since they have generic contents.\n-    /// Flattens a vector of vectors of `T` into a single `Vec<T>`.\n-    fn concat_vec(&self) -> Vec<T>;\n+#[deprecated = \"use IterMut instead\"]\n+pub type MutItems<'a, T:'a> = IterMut<'a, T>;\n \n-    /// Concatenate a vector of vectors, placing a given separator between each.\n-    fn connect_vec(&self, sep: &T) -> Vec<T>;\n-}\n+////////////////////////////////////////////////////////////////////////////////\n+// Basic slice extension methods\n+////////////////////////////////////////////////////////////////////////////////\n \n-impl<'a, T: Clone, V: AsSlice<T>> VectorVector<T> for [V] {\n-    fn concat_vec(&self) -> Vec<T> {\n-        let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n-        let mut result = Vec::with_capacity(size);\n-        for v in self.iter() {\n-            result.push_all(v.as_slice())\n-        }\n-        result\n-    }\n+/// Allocating extension methods for slices.\n+#[unstable = \"needs associated types, may merge with other traits\"]\n+pub trait SliceExt<T> for Sized? {\n+    /// Sorts the slice, in place, using `compare` to compare\n+    /// elements.\n+    ///\n+    /// This sort is `O(n log n)` worst-case and stable, but allocates\n+    /// approximately `2 * n`, where `n` is the length of `self`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// let mut v = [5i, 4, 1, 3, 2];\n+    /// v.sort_by(|a, b| a.cmp(b));\n+    /// assert!(v == [1, 2, 3, 4, 5]);\n+    ///\n+    /// // reverse sorting\n+    /// v.sort_by(|a, b| b.cmp(a));\n+    /// assert!(v == [5, 4, 3, 2, 1]);\n+    /// ```\n+    #[stable]\n+    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering;\n \n-    fn connect_vec(&self, sep: &T) -> Vec<T> {\n-        let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n-        let mut result = Vec::with_capacity(size + self.len());\n-        let mut first = true;\n-        for v in self.iter() {\n-            if first { first = false } else { result.push(sep.clone()) }\n-            result.push_all(v.as_slice())\n-        }\n-        result\n-    }\n-}\n+    /// Consumes `src` and moves as many elements as it can into `self`\n+    /// from the range [start,end).\n+    ///\n+    /// Returns the number of elements copied (the shorter of `self.len()`\n+    /// and `end - start`).\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * src - A mutable vector of `T`\n+    /// * start - The index into `src` to start copying from\n+    /// * end - The index into `src` to stop copying from\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// let mut a = [1i, 2, 3, 4, 5];\n+    /// let b = vec![6i, 7, 8];\n+    /// let num_moved = a.move_from(b, 0, 3);\n+    /// assert_eq!(num_moved, 3);\n+    /// assert!(a == [6i, 7, 8, 4, 5]);\n+    /// ```\n+    #[experimental = \"uncertain about this API approach\"]\n+    fn move_from(&mut self, src: Vec<T>, start: uint, end: uint) -> uint;\n \n-/// An iterator that yields the element swaps needed to produce\n-/// a sequence of all possible permutations for an indexed sequence of\n-/// elements. Each permutation is only a single swap apart.\n-///\n-/// The Steinhaus-Johnson-Trotter algorithm is used.\n-///\n-/// Generates even and odd permutations alternately.\n-///\n-/// The last generated swap is always (0, 1), and it returns the\n-/// sequence to its initial order.\n-#[deriving(Clone)]\n-pub struct ElementSwaps {\n-    sdir: Vec<SizeDirection>,\n-    /// If `true`, emit the last swap that returns the sequence to initial\n-    /// state.\n-    emit_reset: bool,\n-    swaps_made : uint,\n-}\n+    /// Returns a subslice spanning the interval [`start`, `end`).\n+    ///\n+    /// Panics when the end of the new slice lies beyond the end of the\n+    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n+    ///\n+    /// Slicing with `start` equal to `end` yields an empty slice.\n+    #[experimental = \"will be replaced by slice syntax\"]\n+    fn slice(&self, start: uint, end: uint) -> &[T];\n \n-impl ElementSwaps {\n-    /// Creates an `ElementSwaps` iterator for a sequence of `length` elements.\n-    pub fn new(length: uint) -> ElementSwaps {\n-        // Initialize `sdir` with a direction that position should move in\n-        // (all negative at the beginning) and the `size` of the\n-        // element (equal to the original index).\n-        ElementSwaps{\n-            emit_reset: true,\n-            sdir: range(0, length).map(|i| SizeDirection{ size: i, dir: Neg }).collect(),\n-            swaps_made: 0\n-        }\n-    }\n-}\n+    /// Returns a subslice from `start` to the end of the slice.\n+    ///\n+    /// Panics when `start` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing from `self.len()` yields an empty slice.\n+    #[experimental = \"will be replaced by slice syntax\"]\n+    fn slice_from(&self, start: uint) -> &[T];\n \n-#[deriving(Copy, Clone)]\n-enum Direction { Pos, Neg }\n+    /// Returns a subslice from the start of the slice to `end`.\n+    ///\n+    /// Panics when `end` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing to `0` yields an empty slice.\n+    #[experimental = \"will be replaced by slice syntax\"]\n+    fn slice_to(&self, end: uint) -> &[T];\n \n-/// An `Index` and `Direction` together.\n-#[deriving(Copy, Clone)]\n-struct SizeDirection {\n-    size: uint,\n-    dir: Direction,\n-}\n+    /// Divides one slice into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// Panics if `mid > len`.\n+    #[stable]\n+    fn split_at(&self, mid: uint) -> (&[T], &[T]);\n \n-impl Iterator<(uint, uint)> for ElementSwaps {\n-    #[inline]\n-    fn next(&mut self) -> Option<(uint, uint)> {\n-        fn new_pos(i: uint, s: Direction) -> uint {\n-            i + match s { Pos => 1, Neg => -1 }\n-        }\n+    /// Returns an iterator over the slice\n+    #[stable]\n+    fn iter(&self) -> Iter<T>;\n \n-        // Find the index of the largest mobile element:\n-        // The direction should point into the vector, and the\n-        // swap should be with a smaller `size` element.\n-        let max = self.sdir.iter().map(|&x| x).enumerate()\n-                           .filter(|&(i, sd)|\n-                                new_pos(i, sd.dir) < self.sdir.len() &&\n-                                self.sdir[new_pos(i, sd.dir)].size < sd.size)\n-                           .max_by(|&(_, sd)| sd.size);\n-        match max {\n-            Some((i, sd)) => {\n-                let j = new_pos(i, sd.dir);\n-                self.sdir.swap(i, j);\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`.  The matched element is not contained in the subslices.\n+    #[stable]\n+    fn split<F>(&self, pred: F) -> Split<T, F>\n+                where F: FnMut(&T) -> bool;\n \n-                // Swap the direction of each larger SizeDirection\n-                for x in self.sdir.iter_mut() {\n-                    if x.size > sd.size {\n-                        x.dir = match x.dir { Pos => Neg, Neg => Pos };\n-                    }\n-                }\n-                self.swaps_made += 1;\n-                Some((i, j))\n-            },\n-            None => if self.emit_reset {\n-                self.emit_reset = false;\n-                if self.sdir.len() > 1 {\n-                    // The last swap\n-                    self.swaps_made += 1;\n-                    Some((0, 1))\n-                } else {\n-                    // Vector is of the form [] or [x], and the only permutation is itself\n-                    self.swaps_made += 1;\n-                    Some((0,0))\n-                }\n-            } else { None }\n-        }\n-    }\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`, limited to splitting at most `n` times.  The matched element is\n+    /// not contained in the subslices.\n+    #[stable]\n+    fn splitn<F>(&self, n: uint, pred: F) -> SplitN<T, F>\n+                 where F: FnMut(&T) -> bool;\n \n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        // For a vector of size n, there are exactly n! permutations.\n-        let n = range(2, self.sdir.len() + 1).product();\n-        (n - self.swaps_made, Some(n - self.swaps_made))\n-    }\n-}\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred` limited to splitting at most `n` times. This starts at the end of\n+    /// the slice and works backwards.  The matched element is not contained in\n+    /// the subslices.\n+    #[stable]\n+    fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<T, F>\n+                  where F: FnMut(&T) -> bool;\n \n-/// An iterator that uses `ElementSwaps` to iterate through\n-/// all possible permutations of a vector.\n-///\n-/// The first iteration yields a clone of the vector as it is,\n-/// then each successive element is the vector with one\n-/// swap applied.\n-///\n-/// Generates even and odd permutations alternately.\n-#[deriving(Clone)]\n-pub struct Permutations<T> {\n-    swaps: ElementSwaps,\n-    v: Vec<T>,\n-}\n+    /// Returns an iterator over all contiguous windows of length\n+    /// `size`. The windows overlap. If the slice is shorter than\n+    /// `size`, the iterator returns no values.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `size` is 0.\n+    ///\n+    /// # Example\n+    ///\n+    /// Print the adjacent pairs of a slice (i.e. `[1,2]`, `[2,3]`,\n+    /// `[3,4]`):\n+    ///\n+    /// ```rust\n+    /// let v = &[1i, 2, 3, 4];\n+    /// for win in v.windows(2) {\n+    ///     println!(\"{}\", win);\n+    /// }\n+    /// ```\n+    #[stable]\n+    fn windows(&self, size: uint) -> Windows<T>;\n \n-impl<T: Clone> Iterator<Vec<T>> for Permutations<T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<Vec<T>> {\n-        match self.swaps.next() {\n-            None => None,\n-            Some((0,0)) => Some(self.v.clone()),\n-            Some((a, b)) => {\n-                let elt = self.v.clone();\n-                self.v.swap(a, b);\n-                Some(elt)\n-            }\n-        }\n-    }\n+    /// Returns an iterator over `size` elements of the slice at a\n+    /// time. The chunks do not overlap. If `size` does not divide the\n+    /// length of the slice, then the last chunk will not have length\n+    /// `size`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `size` is 0.\n+    ///\n+    /// # Example\n+    ///\n+    /// Print the slice two elements at a time (i.e. `[1,2]`,\n+    /// `[3,4]`, `[5]`):\n+    ///\n+    /// ```rust\n+    /// let v = &[1i, 2, 3, 4, 5];\n+    /// for win in v.chunks(2) {\n+    ///     println!(\"{}\", win);\n+    /// }\n+    /// ```\n+    #[stable]\n+    fn chunks(&self, size: uint) -> Chunks<T>;\n \n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        self.swaps.size_hint()\n-    }\n-}\n+    /// Returns the element of a slice at the given index, or `None` if the\n+    /// index is out of bounds.\n+    #[stable]\n+    fn get(&self, index: uint) -> Option<&T>;\n \n-/// Extension methods for boxed slices.\n-pub trait BoxedSliceExt<T> {\n-    /// Convert `self` into a vector without clones or allocation.\n-    fn into_vec(self) -> Vec<T>;\n-}\n+    /// Returns the first element of a slice, or `None` if it is empty.\n+    #[stable]\n+    fn first(&self) -> Option<&T>;\n \n-impl<T> BoxedSliceExt<T> for Box<[T]> {\n-    #[experimental]\n-    fn into_vec(mut self) -> Vec<T> {\n-        unsafe {\n-            let xs = Vec::from_raw_parts(self.as_mut_ptr(), self.len(), self.len());\n-            mem::forget(self);\n-            xs\n-        }\n-    }\n-}\n+    /// Deprecated: renamed to `first`.\n+    #[deprecated = \"renamed to `first`\"]\n+    fn head(&self) -> Option<&T> { self.first() }\n+\n+    /// Returns all but the first element of a slice.\n+    #[experimental = \"likely to be renamed\"]\n+    fn tail(&self) -> &[T];\n+\n+    /// Returns all but the last element of a slice.\n+    #[experimental = \"likely to be renamed\"]\n+    fn init(&self) -> &[T];\n \n-/// Allocating extension methods for slices containing `Clone` elements.\n-pub trait CloneSliceExt<T> for Sized? {\n-    /// Copies `self` into a new `Vec`.\n-    fn to_vec(&self) -> Vec<T>;\n+    /// Returns the last element of a slice, or `None` if it is empty.\n+    #[stable]\n+    fn last(&self) -> Option<&T>;\n \n-    /// Partitions the vector into two vectors `(a, b)`, where all\n-    /// elements of `a` satisfy `f` and all elements of `b` do not.\n-    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool;\n+    /// Returns a pointer to the element at the given index, without doing\n+    /// bounds checking.\n+    #[stable]\n+    unsafe fn get_unchecked(&self, index: uint) -> &T;\n \n-    /// Creates an iterator that yields every possible permutation of the\n-    /// vector in succession.\n+    /// Deprecated: renamed to `get_unchecked`.\n+    #[deprecated = \"renamed to get_unchecked\"]\n+    unsafe fn unsafe_get(&self, index: uint) -> &T {\n+        self.get_unchecked(index)\n+    }\n+\n+    /// Returns an unsafe pointer to the slice's buffer\n     ///\n-    /// # Examples\n+    /// The caller must ensure that the slice outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n     ///\n-    /// ```rust\n-    /// let v = [1i, 2, 3];\n-    /// let mut perms = v.permutations();\n+    /// Modifying the slice may cause its buffer to be reallocated, which\n+    /// would also make any pointers to it invalid.\n+    #[stable]\n+    fn as_ptr(&self) -> *const T;\n+\n+    /// Binary search a sorted slice with a comparator function.\n     ///\n-    /// for p in perms {\n-    ///   println!(\"{}\", p);\n-    /// }\n-    /// ```\n+    /// The comparator function should implement an order consistent\n+    /// with the sort order of the underlying slice, returning an\n+    /// order code that indicates whether its argument is `Less`,\n+    /// `Equal` or `Greater` the desired target.\n     ///\n-    /// Iterating through permutations one by one.\n+    /// If a matching value is found then returns `Ok`, containing\n+    /// the index for the matched element; if no match is found then\n+    /// `Err` is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Example\n+    ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1,4]`.\n     ///\n     /// ```rust\n-    /// let v = [1i, 2, 3];\n-    /// let mut perms = v.permutations();\n+    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    /// let s = s.as_slice();\n     ///\n-    /// assert_eq!(Some(vec![1i, 2, 3]), perms.next());\n-    /// assert_eq!(Some(vec![1i, 3, 2]), perms.next());\n-    /// assert_eq!(Some(vec![3i, 1, 2]), perms.next());\n+    /// let seek = 13;\n+    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9));\n+    /// let seek = 4;\n+    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(7));\n+    /// let seek = 100;\n+    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(13));\n+    /// let seek = 1;\n+    /// let r = s.binary_search_by(|probe| probe.cmp(&seek));\n+    /// assert!(match r { Ok(1...4) => true, _ => false, });\n     /// ```\n-    fn permutations(&self) -> Permutations<T>;\n+    #[stable]\n+    fn binary_search_by<F>(&self, f: F) -> Result<uint, uint> where\n+        F: FnMut(&T) -> Ordering;\n \n-    /// Copies as many elements from `src` as it can into `self` (the\n-    /// shorter of `self.len()` and `src.len()`). Returns the number\n-    /// of elements copied.\n+    /// Return the number of elements in the slice\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n-    /// let mut dst = [0i, 0, 0];\n-    /// let src = [1i, 2];\n+    /// ```\n+    /// let a = [1i, 2, 3];\n+    /// assert_eq!(a.len(), 3);\n+    /// ```\n+    #[stable]\n+    fn len(&self) -> uint;\n+\n+    /// Returns true if the slice has a length of 0\n     ///\n-    /// assert!(dst.clone_from_slice(&src) == 2);\n-    /// assert!(dst == [1, 2, 0]);\n+    /// # Example\n     ///\n-    /// let src2 = [3i, 4, 5, 6];\n-    /// assert!(dst.clone_from_slice(&src2) == 3);\n-    /// assert!(dst == [3i, 4, 5]);\n     /// ```\n-    fn clone_from_slice(&mut self, &[T]) -> uint;\n-}\n-\n-impl<T: Clone> CloneSliceExt<T> for [T] {\n-    /// Returns a copy of `v`.\n+    /// let a = [1i, 2, 3];\n+    /// assert!(!a.is_empty());\n+    /// ```\n     #[inline]\n-    fn to_vec(&self) -> Vec<T> {\n-        let mut vector = Vec::with_capacity(self.len());\n-        vector.push_all(self);\n-        vector\n-    }\n+    #[stable]\n+    fn is_empty(&self) -> bool { self.len() == 0 }\n+    /// Returns a mutable reference to the element at the given index,\n+    /// or `None` if the index is out of bounds\n+    #[stable]\n+    fn get_mut(&mut self, index: uint) -> Option<&mut T>;\n \n+    /// Work with `self` as a mut slice.\n+    /// Primarily intended for getting a &mut [T] from a [T, ..N].\n+    #[stable]\n+    fn as_mut_slice(&mut self) -> &mut [T];\n \n-    #[inline]\n-    fn partitioned<F>(&self, mut f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n-        let mut lefts  = Vec::new();\n-        let mut rights = Vec::new();\n-\n-        for elt in self.iter() {\n-            if f(elt) {\n-                lefts.push((*elt).clone());\n-            } else {\n-                rights.push((*elt).clone());\n-            }\n-        }\n+    /// Returns a mutable subslice spanning the interval [`start`, `end`).\n+    ///\n+    /// Panics when the end of the new slice lies beyond the end of the\n+    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n+    ///\n+    /// Slicing with `start` equal to `end` yields an empty slice.\n+    #[experimental = \"will be replaced by slice syntax\"]\n+    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [T];\n \n-        (lefts, rights)\n-    }\n+    /// Returns a mutable subslice from `start` to the end of the slice.\n+    ///\n+    /// Panics when `start` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing from `self.len()` yields an empty slice.\n+    #[experimental = \"will be replaced by slice syntax\"]\n+    fn slice_from_mut(&mut self, start: uint) -> &mut [T];\n \n-    /// Returns an iterator over all permutations of a vector.\n-    fn permutations(&self) -> Permutations<T> {\n-        Permutations{\n-            swaps: ElementSwaps::new(self.len()),\n-            v: self.to_vec(),\n-        }\n-    }\n+    /// Returns a mutable subslice from the start of the slice to `end`.\n+    ///\n+    /// Panics when `end` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing to `0` yields an empty slice.\n+    #[experimental = \"will be replaced by slice syntax\"]\n+    fn slice_to_mut(&mut self, end: uint) -> &mut [T];\n \n-    fn clone_from_slice(&mut self, src: &[T]) -> uint {\n-        core_slice::CloneSliceExt::clone_from_slice(self, src)\n+    /// Returns an iterator that allows modifying each value\n+    #[stable]\n+    fn iter_mut(&mut self) -> IterMut<T>;\n+\n+    /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n+    #[stable]\n+    fn first_mut(&mut self) -> Option<&mut T>;\n+\n+    /// Depreated: renamed to `first_mut`.\n+    #[deprecated = \"renamed to first_mut\"]\n+    fn head_mut(&mut self) -> Option<&mut T> {\n+        self.first_mut()\n     }\n-}\n \n-fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n-    let len = v.len() as int;\n-    let buf_v = v.as_mut_ptr();\n+    /// Returns all but the first element of a mutable slice\n+    #[experimental = \"likely to be renamed or removed\"]\n+    fn tail_mut(&mut self) -> &mut [T];\n \n-    // 1 <= i < len;\n-    for i in range(1, len) {\n-        // j satisfies: 0 <= j <= i;\n-        let mut j = i;\n-        unsafe {\n-            // `i` is in bounds.\n-            let read_ptr = buf_v.offset(i) as *const T;\n+    /// Returns all but the last element of a mutable slice\n+    #[experimental = \"likely to be renamed or removed\"]\n+    fn init_mut(&mut self) -> &mut [T];\n \n-            // find where to insert, we need to do strict <,\n-            // rather than <=, to maintain stability.\n+    /// Returns a mutable pointer to the last item in the slice.\n+    #[stable]\n+    fn last_mut(&mut self) -> Option<&mut T>;\n \n-            // 0 <= j - 1 < len, so .offset(j - 1) is in bounds.\n-            while j > 0 &&\n-                    compare(&*read_ptr, &*buf_v.offset(j - 1)) == Less {\n-                j -= 1;\n-            }\n+    /// Returns an iterator over mutable subslices separated by elements that\n+    /// match `pred`.  The matched element is not contained in the subslices.\n+    #[stable]\n+    fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F>\n+                    where F: FnMut(&T) -> bool;\n \n-            // shift everything to the right, to make space to\n-            // insert this value.\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`, limited to splitting at most `n` times.  The matched element is\n+    /// not contained in the subslices.\n+    #[stable]\n+    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitNMut<T, F>\n+                     where F: FnMut(&T) -> bool;\n \n-            // j + 1 could be `len` (for the last `i`), but in\n-            // that case, `i == j` so we don't copy. The\n-            // `.offset(j)` is always in bounds.\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred` limited to splitting at most `n` times. This starts at the end of\n+    /// the slice and works backwards.  The matched element is not contained in\n+    /// the subslices.\n+    #[stable]\n+    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> RSplitNMut<T, F>\n+                      where F: FnMut(&T) -> bool;\n \n-            if i != j {\n-                let tmp = ptr::read(read_ptr);\n-                ptr::copy_memory(buf_v.offset(j + 1),\n-                                 &*buf_v.offset(j),\n-                                 (i - j) as uint);\n-                ptr::copy_nonoverlapping_memory(buf_v.offset(j),\n-                                                &tmp as *const T,\n-                                                1);\n-                mem::forget(tmp);\n-            }\n-        }\n-    }\n-}\n+    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n+    /// The chunks are mutable and do not overlap. If `chunk_size` does\n+    /// not divide the length of the slice, then the last chunk will not\n+    /// have length `chunk_size`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n+    #[stable]\n+    fn chunks_mut(&mut self, chunk_size: uint) -> ChunksMut<T>;\n \n-fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n-    // warning: this wildly uses unsafe.\n-    static BASE_INSERTION: uint = 32;\n-    static LARGE_INSERTION: uint = 16;\n+    /// Swaps two elements in a slice.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * a - The index of the first element\n+    /// * b - The index of the second element\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `a` or `b` are out of bounds.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n+    /// v.swap(1, 3);\n+    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n+    /// ```\n+    #[stable]\n+    fn swap(&mut self, a: uint, b: uint);\n \n-    // FIXME #12092: smaller insertion runs seems to make sorting\n-    // vectors of large elements a little faster on some platforms,\n-    // but hasn't been tested/tuned extensively\n-    let insertion = if size_of::<T>() <= 16 {\n-        BASE_INSERTION\n-    } else {\n-        LARGE_INSERTION\n-    };\n+    /// Divides one `&mut` into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `mid > len`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [1i, 2, 3, 4, 5, 6];\n+    ///\n+    /// // scoped to restrict the lifetime of the borrows\n+    /// {\n+    ///    let (left, right) = v.split_at_mut(0);\n+    ///    assert!(left == []);\n+    ///    assert!(right == [1i, 2, 3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.split_at_mut(2);\n+    ///     assert!(left == [1i, 2]);\n+    ///     assert!(right == [3i, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.split_at_mut(6);\n+    ///     assert!(left == [1i, 2, 3, 4, 5, 6]);\n+    ///     assert!(right == []);\n+    /// }\n+    /// ```\n+    #[stable]\n+    fn split_at_mut(&mut self, mid: uint) -> (&mut [T], &mut [T]);\n \n-    let len = v.len();\n+    /// Reverse the order of elements in a slice, in place.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [1i, 2, 3];\n+    /// v.reverse();\n+    /// assert!(v == [3i, 2, 1]);\n+    /// ```\n+    #[stable]\n+    fn reverse(&mut self);\n \n-    // short vectors get sorted in-place via insertion sort to avoid allocations\n-    if len <= insertion {\n-        insertion_sort(v, compare);\n-        return;\n-    }\n+    /// Returns an unsafe mutable pointer to the element in index\n+    #[stable]\n+    unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut T;\n \n-    // allocate some memory to use as scratch memory, we keep the\n-    // length 0 so we can keep shallow copies of the contents of `v`\n-    // without risking the dtors running on an object twice if\n-    // `compare` panics.\n-    let mut working_space = Vec::with_capacity(2 * len);\n-    // these both are buffers of length `len`.\n-    let mut buf_dat = working_space.as_mut_ptr();\n-    let mut buf_tmp = unsafe {buf_dat.offset(len as int)};\n+    /// Deprecated: renamed to `get_unchecked_mut`.\n+    #[deprecated = \"renamed to get_unchecked_mut\"]\n+    unsafe fn unchecked_mut(&mut self, index: uint) -> &mut T {\n+        self.get_unchecked_mut(index)\n+    }\n \n-    // length `len`.\n-    let buf_v = v.as_ptr();\n+    /// Return an unsafe mutable pointer to the slice's buffer.\n+    ///\n+    /// The caller must ensure that the slice outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    ///\n+    /// Modifying the slice may cause its buffer to be reallocated, which\n+    /// would also make any pointers to it invalid.\n+    #[inline]\n+    #[stable]\n+    fn as_mut_ptr(&mut self) -> *mut T;\n+}\n \n-    // step 1. sort short runs with insertion sort. This takes the\n-    // values from `v` and sorts them into `buf_dat`, leaving that\n-    // with sorted runs of length INSERTION.\n+#[unstable = \"trait is unstable\"]\n+impl<T> SliceExt<T> for [T] {\n+    #[inline]\n+    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering {\n+        merge_sort(self, compare)\n+    }\n \n-    // We could hardcode the sorting comparisons here, and we could\n-    // manipulate/step the pointers themselves, rather than repeatedly\n-    // .offset-ing.\n-    for start in range_step(0, len, insertion) {\n-        // start <= i < len;\n-        for i in range(start, cmp::min(start + insertion, len)) {\n-            // j satisfies: start <= j <= i;\n-            let mut j = i as int;\n-            unsafe {\n-                // `i` is in bounds.\n-                let read_ptr = buf_v.offset(i as int);\n+    #[inline]\n+    fn move_from(&mut self, mut src: Vec<T>, start: uint, end: uint) -> uint {\n+        for (a, b) in self.iter_mut().zip(src.slice_mut(start, end).iter_mut()) {\n+            mem::swap(a, b);\n+        }\n+        cmp::min(self.len(), end-start)\n+    }\n \n-                // find where to insert, we need to do strict <,\n-                // rather than <=, to maintain stability.\n+    #[inline]\n+    fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {\n+        core_slice::SliceExt::slice(self, start, end)\n+    }\n \n-                // start <= j - 1 < len, so .offset(j - 1) is in\n-                // bounds.\n-                while j > start as int &&\n-                        compare(&*read_ptr, &*buf_dat.offset(j - 1)) == Less {\n-                    j -= 1;\n-                }\n+    #[inline]\n+    fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n+        core_slice::SliceExt::slice_from(self, start)\n+    }\n \n-                // shift everything to the right, to make space to\n-                // insert this value.\n+    #[inline]\n+    fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n+        core_slice::SliceExt::slice_to(self, end)\n+    }\n \n-                // j + 1 could be `len` (for the last `i`), but in\n-                // that case, `i == j` so we don't copy. The\n-                // `.offset(j)` is always in bounds.\n-                ptr::copy_memory(buf_dat.offset(j + 1),\n-                                 &*buf_dat.offset(j),\n-                                 i - j as uint);\n-                ptr::copy_nonoverlapping_memory(buf_dat.offset(j), read_ptr, 1);\n-            }\n-        }\n+    #[inline]\n+    fn split_at<'a>(&'a self, mid: uint) -> (&'a [T], &'a [T]) {\n+        core_slice::SliceExt::split_at(self, mid)\n     }\n \n-    // step 2. merge the sorted runs.\n-    let mut width = insertion;\n-    while width < len {\n-        // merge the sorted runs of length `width` in `buf_dat` two at\n-        // a time, placing the result in `buf_tmp`.\n+    #[inline]\n+    fn iter<'a>(&'a self) -> Iter<'a, T> {\n+        core_slice::SliceExt::iter(self)\n+    }\n \n-        // 0 <= start <= len.\n-        for start in range_step(0, len, 2 * width) {\n-            // manipulate pointers directly for speed (rather than\n-            // using a `for` loop with `range` and `.offset` inside\n-            // that loop).\n-            unsafe {\n-                // the end of the first run & start of the\n-                // second. Offset of `len` is defined, since this is\n-                // precisely one byte past the end of the object.\n-                let right_start = buf_dat.offset(cmp::min(start + width, len) as int);\n-                // end of the second. Similar reasoning to the above re safety.\n-                let right_end_idx = cmp::min(start + 2 * width, len);\n-                let right_end = buf_dat.offset(right_end_idx as int);\n+    #[inline]\n+    fn split<F>(&self, pred: F) -> Split<T, F>\n+                where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::split(self, pred)\n+    }\n \n-                // the pointers to the elements under consideration\n-                // from the two runs.\n+    #[inline]\n+    fn splitn<F>(&self, n: uint, pred: F) -> SplitN<T, F>\n+                 where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::splitn(self, n, pred)\n+    }\n \n-                // both of these are in bounds.\n-                let mut left = buf_dat.offset(start as int);\n-                let mut right = right_start;\n+    #[inline]\n+    fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<T, F>\n+                  where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::rsplitn(self, n, pred)\n+    }\n \n-                // where we're putting the results, it is a run of\n-                // length `2*width`, so we step it once for each step\n-                // of either `left` or `right`.  `buf_tmp` has length\n-                // `len`, so these are in bounds.\n-                let mut out = buf_tmp.offset(start as int);\n-                let out_end = buf_tmp.offset(right_end_idx as int);\n+    #[inline]\n+    fn windows<'a>(&'a self, size: uint) -> Windows<'a, T> {\n+        core_slice::SliceExt::windows(self, size)\n+    }\n \n-                while out < out_end {\n-                    // Either the left or the right run are exhausted,\n-                    // so just copy the remainder from the other run\n-                    // and move on; this gives a huge speed-up (order\n-                    // of 25%) for mostly sorted vectors (the best\n-                    // case).\n-                    if left == right_start {\n-                        // the number remaining in this run.\n-                        let elems = (right_end as uint - right as uint) / mem::size_of::<T>();\n-                        ptr::copy_nonoverlapping_memory(out, &*right, elems);\n-                        break;\n-                    } else if right == right_end {\n-                        let elems = (right_start as uint - left as uint) / mem::size_of::<T>();\n-                        ptr::copy_nonoverlapping_memory(out, &*left, elems);\n-                        break;\n-                    }\n+    #[inline]\n+    fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, T> {\n+        core_slice::SliceExt::chunks(self, size)\n+    }\n \n-                    // check which side is smaller, and that's the\n-                    // next element for the new run.\n+    #[inline]\n+    fn get<'a>(&'a self, index: uint) -> Option<&'a T> {\n+        core_slice::SliceExt::get(self, index)\n+    }\n \n-                    // `left < right_start` and `right < right_end`,\n-                    // so these are valid.\n-                    let to_copy = if compare(&*left, &*right) == Greater {\n-                        step(&mut right)\n-                    } else {\n-                        step(&mut left)\n-                    };\n-                    ptr::copy_nonoverlapping_memory(out, &*to_copy, 1);\n-                    step(&mut out);\n-                }\n-            }\n-        }\n+    #[inline]\n+    fn first<'a>(&'a self) -> Option<&'a T> {\n+        core_slice::SliceExt::first(self)\n+    }\n \n-        mem::swap(&mut buf_dat, &mut buf_tmp);\n+    #[inline]\n+    fn tail<'a>(&'a self) -> &'a [T] {\n+        core_slice::SliceExt::tail(self)\n+    }\n \n-        width *= 2;\n+    #[inline]\n+    fn init<'a>(&'a self) -> &'a [T] {\n+        core_slice::SliceExt::init(self)\n     }\n \n-    // write the result to `v` in one go, so that there are never two copies\n-    // of the same object in `v`.\n-    unsafe {\n-        ptr::copy_nonoverlapping_memory(v.as_mut_ptr(), &*buf_dat, len);\n+    #[inline]\n+    fn last<'a>(&'a self) -> Option<&'a T> {\n+        core_slice::SliceExt::last(self)\n     }\n \n-    // increment the pointer, returning the old pointer.\n-    #[inline(always)]\n-    unsafe fn step<T>(ptr: &mut *mut T) -> *mut T {\n-        let old = *ptr;\n-        *ptr = ptr.offset(1);\n-        old\n+    #[inline]\n+    unsafe fn get_unchecked<'a>(&'a self, index: uint) -> &'a T {\n+        core_slice::SliceExt::get_unchecked(self, index)\n     }\n-}\n \n-/// Allocating extension methods for slices on Ord values.\n-#[experimental = \"likely to merge with other traits\"]\n-pub trait OrdSliceExt<T> for Sized? {\n-    /// Sorts the slice, in place.\n-    ///\n-    /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let mut v = [-5i, 4, 1, -3, 2];\n-    ///\n-    /// v.sort();\n-    /// assert!(v == [-5i, -3, 1, 2, 4]);\n-    /// ```\n-    #[experimental]\n-    fn sort(&mut self);\n+    #[inline]\n+    fn as_ptr(&self) -> *const T {\n+        core_slice::SliceExt::as_ptr(self)\n+    }\n \n-    /// Binary search a sorted slice for a given element.\n-    ///\n-    /// If the value is found then `Found` is returned, containing the\n-    /// index of the matching element; if the value is not found then\n-    /// `NotFound` is returned, containing the index where a matching\n-    /// element could be inserted while maintaining sorted order.\n-    ///\n-    /// # Example\n-    ///\n-    /// Looks up a series of four elements. The first is found, with a\n-    /// uniquely determined position; the second and third are not\n-    /// found; the fourth could match any position in `[1,4]`.\n-    ///\n-    /// ```rust\n-    /// use std::slice::BinarySearchResult::{Found, NotFound};\n-    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n-    /// let s = s.as_slice();\n-    ///\n-    /// assert_eq!(s.binary_search_elem(&13),  Found(9));\n-    /// assert_eq!(s.binary_search_elem(&4),   NotFound(7));\n-    /// assert_eq!(s.binary_search_elem(&100), NotFound(13));\n-    /// let r = s.binary_search_elem(&1);\n-    /// assert!(match r { Found(1...4) => true, _ => false, });\n-    /// ```\n-    #[unstable = \"name likely to change\"]\n-    fn binary_search_elem(&self, x: &T) -> BinarySearchResult;\n+    #[inline]\n+    fn binary_search_by<F>(&self, f: F) -> Result<uint, uint>\n+                        where F: FnMut(&T) -> Ordering {\n+        core_slice::SliceExt::binary_search_by(self, f)\n+    }\n \n-    /// Mutates the slice to the next lexicographic permutation.\n-    ///\n-    /// Returns `true` if successful and `false` if the slice is at the\n-    /// last-ordered permutation.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: &mut [_] = &mut [0i, 1, 2];\n-    /// v.next_permutation();\n-    /// let b: &mut [_] = &mut [0i, 2, 1];\n-    /// assert!(v == b);\n-    /// v.next_permutation();\n-    /// let b: &mut [_] = &mut [1i, 0, 2];\n-    /// assert!(v == b);\n-    /// ```\n-    #[experimental]\n-    fn next_permutation(&mut self) -> bool;\n+    #[inline]\n+    fn len(&self) -> uint {\n+        core_slice::SliceExt::len(self)\n+    }\n \n-    /// Mutates the slice to the previous lexicographic permutation.\n-    ///\n-    /// Returns `true` if successful and `false` if the slice is at the\n-    /// first-ordered permutation.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: &mut [_] = &mut [1i, 0, 2];\n-    /// v.prev_permutation();\n-    /// let b: &mut [_] = &mut [0i, 2, 1];\n-    /// assert!(v == b);\n-    /// v.prev_permutation();\n-    /// let b: &mut [_] = &mut [0i, 1, 2];\n-    /// assert!(v == b);\n-    /// ```\n-    #[experimental]\n-    fn prev_permutation(&mut self) -> bool;\n-}\n+    #[inline]\n+    fn is_empty(&self) -> bool {\n+        core_slice::SliceExt::is_empty(self)\n+    }\n \n-impl<T: Ord> OrdSliceExt<T> for [T] {\n     #[inline]\n-    fn sort(&mut self) {\n-        self.sort_by(|a, b| a.cmp(b))\n+    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T> {\n+        core_slice::SliceExt::get_mut(self, index)\n     }\n \n-    fn binary_search_elem(&self, x: &T) -> BinarySearchResult {\n-        core_slice::OrdSliceExt::binary_search_elem(self, x)\n+    #[inline]\n+    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n+        core_slice::SliceExt::as_mut_slice(self)\n     }\n \n-    fn next_permutation(&mut self) -> bool {\n-        core_slice::OrdSliceExt::next_permutation(self)\n+    #[inline]\n+    fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [T] {\n+        core_slice::SliceExt::slice_mut(self, start, end)\n     }\n \n-    fn prev_permutation(&mut self) -> bool {\n-        core_slice::OrdSliceExt::prev_permutation(self)\n+    #[inline]\n+    fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n+        core_slice::SliceExt::slice_from_mut(self, start)\n     }\n-}\n \n-/// Allocating extension methods for slices.\n-#[experimental = \"likely to merge with other traits\"]\n-pub trait SliceExt<T> for Sized? {\n-    /// Sorts the slice, in place, using `compare` to compare\n-    /// elements.\n-    ///\n-    /// This sort is `O(n log n)` worst-case and stable, but allocates\n-    /// approximately `2 * n`, where `n` is the length of `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let mut v = [5i, 4, 1, 3, 2];\n-    /// v.sort_by(|a, b| a.cmp(b));\n-    /// assert!(v == [1, 2, 3, 4, 5]);\n-    ///\n-    /// // reverse sorting\n-    /// v.sort_by(|a, b| b.cmp(a));\n-    /// assert!(v == [5, 4, 3, 2, 1]);\n-    /// ```\n-    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering;\n+    #[inline]\n+    fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n+        core_slice::SliceExt::slice_to_mut(self, end)\n+    }\n \n-    /// Consumes `src` and moves as many elements as it can into `self`\n-    /// from the range [start,end).\n-    ///\n-    /// Returns the number of elements copied (the shorter of `self.len()`\n-    /// and `end - start`).\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * src - A mutable vector of `T`\n-    /// * start - The index into `src` to start copying from\n-    /// * end - The index into `src` to stop copying from\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let mut a = [1i, 2, 3, 4, 5];\n-    /// let b = vec![6i, 7, 8];\n-    /// let num_moved = a.move_from(b, 0, 3);\n-    /// assert_eq!(num_moved, 3);\n-    /// assert!(a == [6i, 7, 8, 4, 5]);\n-    /// ```\n-    fn move_from(&mut self, src: Vec<T>, start: uint, end: uint) -> uint;\n+    #[inline]\n+    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n+        core_slice::SliceExt::iter_mut(self)\n+    }\n \n-    /// Returns a subslice spanning the interval [`start`, `end`).\n-    ///\n-    /// Panics when the end of the new slice lies beyond the end of the\n-    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n-    ///\n-    /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions/slicing syntax\"]\n-    fn slice(&self, start: uint, end: uint) -> &[T];\n+    #[inline]\n+    fn first_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+        core_slice::SliceExt::first_mut(self)\n+    }\n \n-    /// Returns a subslice from `start` to the end of the slice.\n-    ///\n-    /// Panics when `start` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing from `self.len()` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions/slicing syntax\"]\n-    fn slice_from(&self, start: uint) -> &[T];\n+    #[inline]\n+    fn tail_mut<'a>(&'a mut self) -> &'a mut [T] {\n+        core_slice::SliceExt::tail_mut(self)\n+    }\n \n-    /// Returns a subslice from the start of the slice to `end`.\n-    ///\n-    /// Panics when `end` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing to `0` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions/slicing syntax\"]\n-    fn slice_to(&self, end: uint) -> &[T];\n+    #[inline]\n+    fn init_mut<'a>(&'a mut self) -> &'a mut [T] {\n+        core_slice::SliceExt::init_mut(self)\n+    }\n \n-    /// Divides one slice into two at an index.\n-    ///\n-    /// The first will contain all indices from `[0, mid)` (excluding\n-    /// the index `mid` itself) and the second will contain all\n-    /// indices from `[mid, len)` (excluding the index `len` itself).\n-    ///\n-    /// Panics if `mid > len`.\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn split_at(&self, mid: uint) -> (&[T], &[T]);\n+    #[inline]\n+    fn last_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+        core_slice::SliceExt::last_mut(self)\n+    }\n \n-    /// Returns an iterator over the slice\n-    #[unstable = \"iterator type may change\"]\n-    fn iter(&self) -> Iter<T>;\n+    #[inline]\n+    fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F>\n+                    where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::split_mut(self, pred)\n+    }\n \n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`.  The matched element is not contained in the subslices.\n-    #[unstable = \"iterator type may change, waiting on unboxed closures\"]\n-    fn split<F>(&self, pred: F) -> Splits<T, F>\n-                where F: FnMut(&T) -> bool;\n+    #[inline]\n+    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitNMut<T, F>\n+                     where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::splitn_mut(self, n, pred)\n+    }\n \n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, limited to splitting at most `n` times.  The matched element is\n-    /// not contained in the subslices.\n-    #[unstable = \"iterator type may change\"]\n-    fn splitn<F>(&self, n: uint, pred: F) -> SplitsN<Splits<T, F>>\n-                 where F: FnMut(&T) -> bool;\n+    #[inline]\n+    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> RSplitNMut<T, F>\n+                      where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::rsplitn_mut(self, n, pred)\n+    }\n \n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred` limited to splitting at most `n` times. This starts at the end of\n-    /// the slice and works backwards.  The matched element is not contained in\n-    /// the subslices.\n-    #[unstable = \"iterator type may change\"]\n-    fn rsplitn<F>(&self, n: uint, pred: F) -> SplitsN<Splits<T, F>>\n-                  where F: FnMut(&T) -> bool;\n+    #[inline]\n+    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> ChunksMut<'a, T> {\n+        core_slice::SliceExt::chunks_mut(self, chunk_size)\n+    }\n \n-    /// Returns an iterator over all contiguous windows of length\n-    /// `size`. The windows overlap. If the slice is shorter than\n-    /// `size`, the iterator returns no values.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `size` is 0.\n-    ///\n-    /// # Example\n-    ///\n-    /// Print the adjacent pairs of a slice (i.e. `[1,2]`, `[2,3]`,\n-    /// `[3,4]`):\n-    ///\n-    /// ```rust\n-    /// let v = &[1i, 2, 3, 4];\n-    /// for win in v.windows(2) {\n-    ///     println!(\"{}\", win);\n-    /// }\n-    /// ```\n-    #[unstable = \"iterator type may change\"]\n-    fn windows(&self, size: uint) -> Windows<T>;\n+    #[inline]\n+    fn swap(&mut self, a: uint, b: uint) {\n+        core_slice::SliceExt::swap(self, a, b)\n+    }\n \n-    /// Returns an iterator over `size` elements of the slice at a\n-    /// time. The chunks do not overlap. If `size` does not divide the\n-    /// length of the slice, then the last chunk will not have length\n-    /// `size`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `size` is 0.\n-    ///\n-    /// # Example\n-    ///\n-    /// Print the slice two elements at a time (i.e. `[1,2]`,\n-    /// `[3,4]`, `[5]`):\n-    ///\n-    /// ```rust\n-    /// let v = &[1i, 2, 3, 4, 5];\n-    /// for win in v.chunks(2) {\n-    ///     println!(\"{}\", win);\n-    /// }\n-    /// ```\n-    #[unstable = \"iterator type may change\"]\n-    fn chunks(&self, size: uint) -> Chunks<T>;\n+    #[inline]\n+    fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n+        core_slice::SliceExt::split_at_mut(self, mid)\n+    }\n \n-    /// Returns the element of a slice at the given index, or `None` if the\n-    /// index is out of bounds.\n-    #[unstable = \"waiting on final collection conventions\"]\n-    fn get(&self, index: uint) -> Option<&T>;\n+    #[inline]\n+    fn reverse(&mut self) {\n+        core_slice::SliceExt::reverse(self)\n+    }\n \n-    /// Returns the first element of a slice, or `None` if it is empty.\n-    #[unstable = \"name may change\"]\n-    fn head(&self) -> Option<&T>;\n+    #[inline]\n+    unsafe fn get_unchecked_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n+        core_slice::SliceExt::get_unchecked_mut(self, index)\n+    }\n \n-    /// Returns all but the first element of a slice.\n-    #[unstable = \"name may change\"]\n-    fn tail(&self) -> &[T];\n+    #[inline]\n+    fn as_mut_ptr(&mut self) -> *mut T {\n+        core_slice::SliceExt::as_mut_ptr(self)\n+    }\n+}\n \n-    /// Returns all but the last element of a slice.\n-    #[unstable = \"name may change\"]\n-    fn init(&self) -> &[T];\n+////////////////////////////////////////////////////////////////////////////////\n+// Extension traits for slices over specifc kinds of data\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// Extension methods for boxed slices.\n+#[experimental = \"likely to merge into SliceExt if it survives\"]\n+pub trait BoxedSliceExt<T> {\n+    /// Convert `self` into a vector without clones or allocation.\n+    #[experimental]\n+    fn into_vec(self) -> Vec<T>;\n+}\n \n-    /// Returns the last element of a slice, or `None` if it is empty.\n-    #[unstable = \"name may change\"]\n-    fn last(&self) -> Option<&T>;\n+#[experimental = \"trait is experimental\"]\n+impl<T> BoxedSliceExt<T> for Box<[T]> {\n+    fn into_vec(mut self) -> Vec<T> {\n+        unsafe {\n+            let xs = Vec::from_raw_parts(self.as_mut_ptr(), self.len(), self.len());\n+            mem::forget(self);\n+            xs\n+        }\n+    }\n+}\n \n-    /// Returns a pointer to the element at the given index, without doing\n-    /// bounds checking.\n-    #[unstable]\n-    unsafe fn unsafe_get(&self, index: uint) -> &T;\n+/// Allocating extension methods for slices containing `Clone` elements.\n+#[unstable = \"likely to be merged into SliceExt\"]\n+pub trait CloneSliceExt<T> for Sized? {\n+    /// Copies `self` into a new `Vec`.\n+    #[stable]\n+    fn to_vec(&self) -> Vec<T>;\n \n-    /// Returns an unsafe pointer to the slice's buffer\n-    ///\n-    /// The caller must ensure that the slice outlives the pointer this\n-    /// function returns, or else it will end up pointing to garbage.\n-    ///\n-    /// Modifying the slice may cause its buffer to be reallocated, which\n-    /// would also make any pointers to it invalid.\n-    #[unstable]\n-    fn as_ptr(&self) -> *const T;\n+    /// Deprecated: use `iter().cloned().partition(f)` instead.\n+    #[deprecated = \"use iter().cloned().partition(f) instead\"]\n+    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool;\n \n-    /// Binary search a sorted slice with a comparator function.\n+    /// Creates an iterator that yields every possible permutation of the\n+    /// vector in succession.\n     ///\n-    /// The comparator function should implement an order consistent\n-    /// with the sort order of the underlying slice, returning an\n-    /// order code that indicates whether its argument is `Less`,\n-    /// `Equal` or `Greater` the desired target.\n+    /// # Examples\n     ///\n-    /// If a matching value is found then returns `Found`, containing\n-    /// the index for the matched element; if no match is found then\n-    /// `NotFound` is returned, containing the index where a matching\n-    /// element could be inserted while maintaining sorted order.\n+    /// ```rust\n+    /// let v = [1i, 2, 3];\n+    /// let mut perms = v.permutations();\n     ///\n-    /// # Example\n+    /// for p in perms {\n+    ///   println!(\"{}\", p);\n+    /// }\n+    /// ```\n     ///\n-    /// Looks up a series of four elements. The first is found, with a\n-    /// uniquely determined position; the second and third are not\n-    /// found; the fourth could match any position in `[1,4]`.\n+    /// Iterating through permutations one by one.\n     ///\n     /// ```rust\n-    /// use std::slice::BinarySearchResult::{Found, NotFound};\n-    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n-    /// let s = s.as_slice();\n+    /// let v = [1i, 2, 3];\n+    /// let mut perms = v.permutations();\n     ///\n-    /// let seek = 13;\n-    /// assert_eq!(s.binary_search(|probe| probe.cmp(&seek)), Found(9));\n-    /// let seek = 4;\n-    /// assert_eq!(s.binary_search(|probe| probe.cmp(&seek)), NotFound(7));\n-    /// let seek = 100;\n-    /// assert_eq!(s.binary_search(|probe| probe.cmp(&seek)), NotFound(13));\n-    /// let seek = 1;\n-    /// let r = s.binary_search(|probe| probe.cmp(&seek));\n-    /// assert!(match r { Found(1...4) => true, _ => false, });\n+    /// assert_eq!(Some(vec![1i, 2, 3]), perms.next());\n+    /// assert_eq!(Some(vec![1i, 3, 2]), perms.next());\n+    /// assert_eq!(Some(vec![3i, 1, 2]), perms.next());\n     /// ```\n-    #[unstable = \"waiting on unboxed closures\"]\n-    fn binary_search<F>(&self, f: F) -> BinarySearchResult\n-                        where F: FnMut(&T) -> Ordering;\n+    #[unstable]\n+    fn permutations(&self) -> Permutations<T>;\n \n-    /// Return the number of elements in the slice\n+    /// Copies as many elements from `src` as it can into `self` (the\n+    /// shorter of `self.len()` and `src.len()`). Returns the number\n+    /// of elements copied.\n     ///\n     /// # Example\n     ///\n-    /// ```\n-    /// let a = [1i, 2, 3];\n-    /// assert_eq!(a.len(), 3);\n-    /// ```\n-    #[experimental = \"not triaged yet\"]\n-    fn len(&self) -> uint;\n-\n-    /// Returns true if the slice has a length of 0\n+    /// ```rust\n+    /// let mut dst = [0i, 0, 0];\n+    /// let src = [1i, 2];\n     ///\n-    /// # Example\n+    /// assert!(dst.clone_from_slice(&src) == 2);\n+    /// assert!(dst == [1, 2, 0]);\n     ///\n+    /// let src2 = [3i, 4, 5, 6];\n+    /// assert!(dst.clone_from_slice(&src2) == 3);\n+    /// assert!(dst == [3i, 4, 5]);\n     /// ```\n-    /// let a = [1i, 2, 3];\n-    /// assert!(!a.is_empty());\n-    /// ```\n-    #[inline]\n-    #[experimental = \"not triaged yet\"]\n-    fn is_empty(&self) -> bool { self.len() == 0 }\n-    /// Returns a mutable reference to the element at the given index,\n-    /// or `None` if the index is out of bounds\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn get_mut(&mut self, index: uint) -> Option<&mut T>;\n-\n-    /// Work with `self` as a mut slice.\n-    /// Primarily intended for getting a &mut [T] from a [T, ..N].\n-    fn as_mut_slice(&mut self) -> &mut [T];\n-\n-    /// Returns a mutable subslice spanning the interval [`start`, `end`).\n-    ///\n-    /// Panics when the end of the new slice lies beyond the end of the\n-    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n-    ///\n-    /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [T];\n-\n-    /// Returns a mutable subslice from `start` to the end of the slice.\n-    ///\n-    /// Panics when `start` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing from `self.len()` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn slice_from_mut(&mut self, start: uint) -> &mut [T];\n-\n-    /// Returns a mutable subslice from the start of the slice to `end`.\n-    ///\n-    /// Panics when `end` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing to `0` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn slice_to_mut(&mut self, end: uint) -> &mut [T];\n-\n-    /// Returns an iterator that allows modifying each value\n-    #[unstable = \"waiting on iterator type name conventions\"]\n-    fn iter_mut(&mut self) -> IterMut<T>;\n-\n-    /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n-    #[unstable = \"name may change\"]\n-    fn head_mut(&mut self) -> Option<&mut T>;\n-\n-    /// Returns all but the first element of a mutable slice\n-    #[unstable = \"name may change\"]\n-    fn tail_mut(&mut self) -> &mut [T];\n-\n-    /// Returns all but the last element of a mutable slice\n-    #[unstable = \"name may change\"]\n-    fn init_mut(&mut self) -> &mut [T];\n+    #[experimental]\n+    fn clone_from_slice(&mut self, &[T]) -> uint;\n+}\n \n-    /// Returns a mutable pointer to the last item in the slice.\n-    #[unstable = \"name may change\"]\n-    fn last_mut(&mut self) -> Option<&mut T>;\n+#[unstable = \"trait is unstable\"]\n+impl<T: Clone> CloneSliceExt<T> for [T] {\n+    /// Returns a copy of `v`.\n+    #[inline]\n+    fn to_vec(&self) -> Vec<T> {\n+        let mut vector = Vec::with_capacity(self.len());\n+        vector.push_all(self);\n+        vector\n+    }\n \n-    /// Returns an iterator over mutable subslices separated by elements that\n-    /// match `pred`.  The matched element is not contained in the subslices.\n-    #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n-    fn split_mut<F>(&mut self, pred: F) -> MutSplits<T, F>\n-                    where F: FnMut(&T) -> bool;\n \n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, limited to splitting at most `n` times.  The matched element is\n-    /// not contained in the subslices.\n-    #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n-    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitsN<MutSplits<T, F>>\n-                     where F: FnMut(&T) -> bool;\n+    #[inline]\n+    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n+        self.iter().cloned().partition(f)\n+    }\n \n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred` limited to splitting at most `n` times. This starts at the end of\n-    /// the slice and works backwards.  The matched element is not contained in\n-    /// the subslices.\n-    #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n-    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> SplitsN<MutSplits<T, F>>\n-                      where F: FnMut(&T) -> bool;\n+    /// Returns an iterator over all permutations of a vector.\n+    fn permutations(&self) -> Permutations<T> {\n+        Permutations{\n+            swaps: ElementSwaps::new(self.len()),\n+            v: self.to_vec(),\n+        }\n+    }\n \n-    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n-    /// The chunks are mutable and do not overlap. If `chunk_size` does\n-    /// not divide the length of the slice, then the last chunk will not\n-    /// have length `chunk_size`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `chunk_size` is 0.\n-    #[unstable = \"waiting on iterator type name conventions\"]\n-    fn chunks_mut(&mut self, chunk_size: uint) -> MutChunks<T>;\n+    fn clone_from_slice(&mut self, src: &[T]) -> uint {\n+        core_slice::CloneSliceExt::clone_from_slice(self, src)\n+    }\n+}\n \n-    /// Swaps two elements in a slice.\n-    ///\n-    /// Panics if `a` or `b` are out of bounds.\n-    ///\n-    /// # Arguments\n+/// Allocating extension methods for slices on Ord values.\n+#[unstable = \"likely to merge with SliceExt\"]\n+pub trait OrdSliceExt<T> for Sized? {\n+    /// Sorts the slice, in place.\n     ///\n-    /// * a - The index of the first element\n-    /// * b - The index of the second element\n+    /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n-    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n-    /// v.swap(1, 3);\n-    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n+    /// let mut v = [-5i, 4, 1, -3, 2];\n+    ///\n+    /// v.sort();\n+    /// assert!(v == [-5i, -3, 1, 2, 4]);\n     /// ```\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn swap(&mut self, a: uint, b: uint);\n+    #[stable]\n+    fn sort(&mut self);\n \n-    /// Divides one `&mut` into two at an index.\n-    ///\n-    /// The first will contain all indices from `[0, mid)` (excluding\n-    /// the index `mid` itself) and the second will contain all\n-    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    /// Binary search a sorted slice for a given element.\n     ///\n-    /// Panics if `mid > len`.\n+    /// If the value is found then `Ok` is returned, containing the\n+    /// index of the matching element; if the value is not found then\n+    /// `Err` is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n-    /// let mut v = [1i, 2, 3, 4, 5, 6];\n-    ///\n-    /// // scoped to restrict the lifetime of the borrows\n-    /// {\n-    ///    let (left, right) = v.split_at_mut(0);\n-    ///    assert!(left == []);\n-    ///    assert!(right == [1i, 2, 3, 4, 5, 6]);\n-    /// }\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1,4]`.\n     ///\n-    /// {\n-    ///     let (left, right) = v.split_at_mut(2);\n-    ///     assert!(left == [1i, 2]);\n-    ///     assert!(right == [3i, 4, 5, 6]);\n-    /// }\n+    /// ```rust\n+    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    /// let s = s.as_slice();\n     ///\n-    /// {\n-    ///     let (left, right) = v.split_at_mut(6);\n-    ///     assert!(left == [1i, 2, 3, 4, 5, 6]);\n-    ///     assert!(right == []);\n-    /// }\n+    /// assert_eq!(s.binary_search(&13),  Ok(9));\n+    /// assert_eq!(s.binary_search(&4),   Err(7));\n+    /// assert_eq!(s.binary_search(&100), Err(13));\n+    /// let r = s.binary_search(&1);\n+    /// assert!(match r { Ok(1...4) => true, _ => false, });\n     /// ```\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn split_at_mut(&mut self, mid: uint) -> (&mut [T], &mut [T]);\n+    #[stable]\n+    fn binary_search(&self, x: &T) -> Result<uint, uint>;\n \n-    /// Reverse the order of elements in a slice, in place.\n+    /// Deprecated: use `binary_search` instead.\n+    #[deprecated = \"use binary_search instead\"]\n+    fn binary_search_elem(&self, x: &T) -> Result<uint, uint> {\n+        self.binary_search(x)\n+    }\n+\n+    /// Mutates the slice to the next lexicographic permutation.\n+    ///\n+    /// Returns `true` if successful and `false` if the slice is at the\n+    /// last-ordered permutation.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut v = [1i, 2, 3];\n-    /// v.reverse();\n-    /// assert!(v == [3i, 2, 1]);\n+    /// let v: &mut [_] = &mut [0i, 1, 2];\n+    /// v.next_permutation();\n+    /// let b: &mut [_] = &mut [0i, 2, 1];\n+    /// assert!(v == b);\n+    /// v.next_permutation();\n+    /// let b: &mut [_] = &mut [1i, 0, 2];\n+    /// assert!(v == b);\n     /// ```\n-    #[experimental = \"may be moved to iterators instead\"]\n-    fn reverse(&mut self);\n-\n-    /// Returns an unsafe mutable pointer to the element in index\n-    #[experimental = \"waiting on unsafe conventions\"]\n-    unsafe fn unsafe_mut(&mut self, index: uint) -> &mut T;\n+    #[unstable = \"uncertain if this merits inclusion in std\"]\n+    fn next_permutation(&mut self) -> bool;\n \n-    /// Return an unsafe mutable pointer to the slice's buffer.\n+    /// Mutates the slice to the previous lexicographic permutation.\n     ///\n-    /// The caller must ensure that the slice outlives the pointer this\n-    /// function returns, or else it will end up pointing to garbage.\n+    /// Returns `true` if successful and `false` if the slice is at the\n+    /// first-ordered permutation.\n     ///\n-    /// Modifying the slice may cause its buffer to be reallocated, which\n-    /// would also make any pointers to it invalid.\n-    #[inline]\n-    #[unstable]\n-    fn as_mut_ptr(&mut self) -> *mut T;\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: &mut [_] = &mut [1i, 0, 2];\n+    /// v.prev_permutation();\n+    /// let b: &mut [_] = &mut [0i, 2, 1];\n+    /// assert!(v == b);\n+    /// v.prev_permutation();\n+    /// let b: &mut [_] = &mut [0i, 1, 2];\n+    /// assert!(v == b);\n+    /// ```\n+    #[unstable = \"uncertain if this merits inclusion in std\"]\n+    fn prev_permutation(&mut self) -> bool;\n }\n \n-impl<T> SliceExt<T> for [T] {\n+#[unstable = \"trait is unstable\"]\n+impl<T: Ord> OrdSliceExt<T> for [T] {\n     #[inline]\n-    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering {\n-        merge_sort(self, compare)\n+    fn sort(&mut self) {\n+        self.sort_by(|a, b| a.cmp(b))\n     }\n \n-    #[inline]\n-    fn move_from(&mut self, mut src: Vec<T>, start: uint, end: uint) -> uint {\n-        for (a, b) in self.iter_mut().zip(src.slice_mut(start, end).iter_mut()) {\n-            mem::swap(a, b);\n-        }\n-        cmp::min(self.len(), end-start)\n+    fn binary_search(&self, x: &T) -> Result<uint, uint> {\n+        core_slice::OrdSliceExt::binary_search(self, x)\n     }\n \n-    #[inline]\n-    fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {\n-        core_slice::SliceExt::slice(self, start, end)\n+    fn next_permutation(&mut self) -> bool {\n+        core_slice::OrdSliceExt::next_permutation(self)\n     }\n \n-    #[inline]\n-    fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n-        core_slice::SliceExt::slice_from(self, start)\n+    fn prev_permutation(&mut self) -> bool {\n+        core_slice::OrdSliceExt::prev_permutation(self)\n     }\n+}\n \n-    #[inline]\n-    fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n-        core_slice::SliceExt::slice_to(self, end)\n-    }\n+#[unstable = \"U should be an associated type\"]\n+/// An extension trait for concatenating slices\n+pub trait SliceConcatExt<Sized? T, U> for Sized? {\n+    /// Flattens a slice of `T` into a single value `U`.\n+    #[stable]\n+    fn concat(&self) -> U;\n \n-    #[inline]\n-    fn split_at<'a>(&'a self, mid: uint) -> (&'a [T], &'a [T]) {\n-        core_slice::SliceExt::split_at(self, mid)\n+    #[deprecated = \"renamed to concat\"]\n+    fn concat_vec(&self) -> U {\n+        self.concat()\n     }\n \n-    #[inline]\n-    fn iter<'a>(&'a self) -> Iter<'a, T> {\n-        core_slice::SliceExt::iter(self)\n-    }\n+    /// Flattens a slice of `T` into a single value `U`, placing a\n+    /// given seperator between each.\n+    #[stable]\n+    fn connect(&self, sep: &T) -> U;\n \n-    #[inline]\n-    fn split<F>(&self, pred: F) -> Splits<T, F>\n-                where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::split(self, pred)\n+    #[deprecated = \"renamed to connect\"]\n+    fn connect_vec(&self, sep: &T) -> U {\n+        self.connect(sep)\n     }\n+}\n \n-    #[inline]\n-    fn splitn<F>(&self, n: uint, pred: F) -> SplitsN<Splits<T, F>>\n-                 where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::splitn(self, n, pred)\n+impl<T: Clone, V: AsSlice<T>> SliceConcatExt<T, Vec<T>> for [V] {\n+    fn concat(&self) -> Vec<T> {\n+        let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n+        let mut result = Vec::with_capacity(size);\n+        for v in self.iter() {\n+            result.push_all(v.as_slice())\n+        }\n+        result\n     }\n \n-    #[inline]\n-    fn rsplitn<F>(&self, n: uint, pred: F) -> SplitsN<Splits<T, F>>\n-                  where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::rsplitn(self, n, pred)\n+    fn connect(&self, sep: &T) -> Vec<T> {\n+        let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n+        let mut result = Vec::with_capacity(size + self.len());\n+        let mut first = true;\n+        for v in self.iter() {\n+            if first { first = false } else { result.push(sep.clone()) }\n+            result.push_all(v.as_slice())\n+        }\n+        result\n     }\n+}\n \n-    #[inline]\n-    fn windows<'a>(&'a self, size: uint) -> Windows<'a, T> {\n-        core_slice::SliceExt::windows(self, size)\n-    }\n+/// An iterator that yields the element swaps needed to produce\n+/// a sequence of all possible permutations for an indexed sequence of\n+/// elements. Each permutation is only a single swap apart.\n+///\n+/// The Steinhaus-Johnson-Trotter algorithm is used.\n+///\n+/// Generates even and odd permutations alternately.\n+///\n+/// The last generated swap is always (0, 1), and it returns the\n+/// sequence to its initial order.\n+#[experimental]\n+#[deriving(Clone)]\n+pub struct ElementSwaps {\n+    sdir: Vec<SizeDirection>,\n+    /// If `true`, emit the last swap that returns the sequence to initial\n+    /// state.\n+    emit_reset: bool,\n+    swaps_made : uint,\n+}\n \n-    #[inline]\n-    fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, T> {\n-        core_slice::SliceExt::chunks(self, size)\n+impl ElementSwaps {\n+    /// Creates an `ElementSwaps` iterator for a sequence of `length` elements.\n+    #[experimental]\n+    pub fn new(length: uint) -> ElementSwaps {\n+        // Initialize `sdir` with a direction that position should move in\n+        // (all negative at the beginning) and the `size` of the\n+        // element (equal to the original index).\n+        ElementSwaps{\n+            emit_reset: true,\n+            sdir: range(0, length).map(|i| SizeDirection{ size: i, dir: Neg }).collect(),\n+            swaps_made: 0\n+        }\n     }\n+}\n \n-    #[inline]\n-    fn get<'a>(&'a self, index: uint) -> Option<&'a T> {\n-        core_slice::SliceExt::get(self, index)\n-    }\n+////////////////////////////////////////////////////////////////////////////////\n+// Standard trait implementations for slices\n+////////////////////////////////////////////////////////////////////////////////\n+\n+#[unstable = \"trait is unstable\"]\n+impl<T> BorrowFrom<Vec<T>> for [T] {\n+    fn borrow_from(owned: &Vec<T>) -> &[T] { owned[] }\n+}\n+\n+#[unstable = \"trait is unstable\"]\n+impl<T> BorrowFromMut<Vec<T>> for [T] {\n+    fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { owned.as_mut_slice_() }\n+}\n+\n+#[unstable = \"trait is unstable\"]\n+impl<T: Clone> ToOwned<Vec<T>> for [T] {\n+    fn to_owned(&self) -> Vec<T> { self.to_vec() }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Iterators\n+////////////////////////////////////////////////////////////////////////////////\n+\n+#[deriving(Copy)]\n+enum Direction { Pos, Neg }\n+\n+/// An `Index` and `Direction` together.\n+#[deriving(Copy)]\n+struct SizeDirection {\n+    size: uint,\n+    dir: Direction,\n+}\n \n+impl Iterator<(uint, uint)> for ElementSwaps {\n     #[inline]\n-    fn head<'a>(&'a self) -> Option<&'a T> {\n-        core_slice::SliceExt::head(self)\n+    fn next(&mut self) -> Option<(uint, uint)> {\n+        fn new_pos(i: uint, s: Direction) -> uint {\n+            i + match s { Pos => 1, Neg => -1 }\n+        }\n+\n+        // Find the index of the largest mobile element:\n+        // The direction should point into the vector, and the\n+        // swap should be with a smaller `size` element.\n+        let max = self.sdir.iter().map(|&x| x).enumerate()\n+                           .filter(|&(i, sd)|\n+                                new_pos(i, sd.dir) < self.sdir.len() &&\n+                                self.sdir[new_pos(i, sd.dir)].size < sd.size)\n+                           .max_by(|&(_, sd)| sd.size);\n+        match max {\n+            Some((i, sd)) => {\n+                let j = new_pos(i, sd.dir);\n+                self.sdir.swap(i, j);\n+\n+                // Swap the direction of each larger SizeDirection\n+                for x in self.sdir.iter_mut() {\n+                    if x.size > sd.size {\n+                        x.dir = match x.dir { Pos => Neg, Neg => Pos };\n+                    }\n+                }\n+                self.swaps_made += 1;\n+                Some((i, j))\n+            },\n+            None => if self.emit_reset {\n+                self.emit_reset = false;\n+                if self.sdir.len() > 1 {\n+                    // The last swap\n+                    self.swaps_made += 1;\n+                    Some((0, 1))\n+                } else {\n+                    // Vector is of the form [] or [x], and the only permutation is itself\n+                    self.swaps_made += 1;\n+                    Some((0,0))\n+                }\n+            } else { None }\n+        }\n     }\n \n     #[inline]\n-    fn tail<'a>(&'a self) -> &'a [T] {\n-        core_slice::SliceExt::tail(self)\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        // For a vector of size n, there are exactly n! permutations.\n+        let n = range(2, self.sdir.len() + 1).product();\n+        (n - self.swaps_made, Some(n - self.swaps_made))\n     }\n+}\n+\n+/// An iterator that uses `ElementSwaps` to iterate through\n+/// all possible permutations of a vector.\n+///\n+/// The first iteration yields a clone of the vector as it is,\n+/// then each successive element is the vector with one\n+/// swap applied.\n+///\n+/// Generates even and odd permutations alternately.\n+#[unstable]\n+pub struct Permutations<T> {\n+    swaps: ElementSwaps,\n+    v: Vec<T>,\n+}\n \n+#[unstable = \"trait is unstable\"]\n+impl<T: Clone> Iterator<Vec<T>> for Permutations<T> {\n     #[inline]\n-    fn init<'a>(&'a self) -> &'a [T] {\n-        core_slice::SliceExt::init(self)\n+    fn next(&mut self) -> Option<Vec<T>> {\n+        match self.swaps.next() {\n+            None => None,\n+            Some((0,0)) => Some(self.v.clone()),\n+            Some((a, b)) => {\n+                let elt = self.v.clone();\n+                self.v.swap(a, b);\n+                Some(elt)\n+            }\n+        }\n     }\n \n     #[inline]\n-    fn last<'a>(&'a self) -> Option<&'a T> {\n-        core_slice::SliceExt::last(self)\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        self.swaps.size_hint()\n     }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Sorting\n+////////////////////////////////////////////////////////////////////////////////\n+\n+fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n+    let len = v.len() as int;\n+    let buf_v = v.as_mut_ptr();\n+\n+    // 1 <= i < len;\n+    for i in range(1, len) {\n+        // j satisfies: 0 <= j <= i;\n+        let mut j = i;\n+        unsafe {\n+            // `i` is in bounds.\n+            let read_ptr = buf_v.offset(i) as *const T;\n+\n+            // find where to insert, we need to do strict <,\n+            // rather than <=, to maintain stability.\n+\n+            // 0 <= j - 1 < len, so .offset(j - 1) is in bounds.\n+            while j > 0 &&\n+                    compare(&*read_ptr, &*buf_v.offset(j - 1)) == Less {\n+                j -= 1;\n+            }\n+\n+            // shift everything to the right, to make space to\n+            // insert this value.\n+\n+            // j + 1 could be `len` (for the last `i`), but in\n+            // that case, `i == j` so we don't copy. The\n+            // `.offset(j)` is always in bounds.\n \n-    #[inline]\n-    unsafe fn unsafe_get<'a>(&'a self, index: uint) -> &'a T {\n-        core_slice::SliceExt::unsafe_get(self, index)\n+            if i != j {\n+                let tmp = ptr::read(read_ptr);\n+                ptr::copy_memory(buf_v.offset(j + 1),\n+                                 &*buf_v.offset(j),\n+                                 (i - j) as uint);\n+                ptr::copy_nonoverlapping_memory(buf_v.offset(j),\n+                                                &tmp as *const T,\n+                                                1);\n+                mem::forget(tmp);\n+            }\n+        }\n     }\n+}\n \n-    #[inline]\n-    fn as_ptr(&self) -> *const T {\n-        core_slice::SliceExt::as_ptr(self)\n-    }\n+fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n+    // warning: this wildly uses unsafe.\n+    static BASE_INSERTION: uint = 32;\n+    static LARGE_INSERTION: uint = 16;\n \n-    #[inline]\n-    fn binary_search<F>(&self, f: F) -> BinarySearchResult\n-                        where F: FnMut(&T) -> Ordering {\n-        core_slice::SliceExt::binary_search(self, f)\n-    }\n+    // FIXME #12092: smaller insertion runs seems to make sorting\n+    // vectors of large elements a little faster on some platforms,\n+    // but hasn't been tested/tuned extensively\n+    let insertion = if size_of::<T>() <= 16 {\n+        BASE_INSERTION\n+    } else {\n+        LARGE_INSERTION\n+    };\n \n-    #[inline]\n-    fn len(&self) -> uint {\n-        core_slice::SliceExt::len(self)\n-    }\n+    let len = v.len();\n \n-    #[inline]\n-    fn is_empty(&self) -> bool {\n-        core_slice::SliceExt::is_empty(self)\n+    // short vectors get sorted in-place via insertion sort to avoid allocations\n+    if len <= insertion {\n+        insertion_sort(v, compare);\n+        return;\n     }\n \n-    #[inline]\n-    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T> {\n-        core_slice::SliceExt::get_mut(self, index)\n-    }\n+    // allocate some memory to use as scratch memory, we keep the\n+    // length 0 so we can keep shallow copies of the contents of `v`\n+    // without risking the dtors running on an object twice if\n+    // `compare` panics.\n+    let mut working_space = Vec::with_capacity(2 * len);\n+    // these both are buffers of length `len`.\n+    let mut buf_dat = working_space.as_mut_ptr();\n+    let mut buf_tmp = unsafe {buf_dat.offset(len as int)};\n \n-    #[inline]\n-    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n-        core_slice::SliceExt::as_mut_slice(self)\n-    }\n+    // length `len`.\n+    let buf_v = v.as_ptr();\n \n-    #[inline]\n-    fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [T] {\n-        core_slice::SliceExt::slice_mut(self, start, end)\n-    }\n+    // step 1. sort short runs with insertion sort. This takes the\n+    // values from `v` and sorts them into `buf_dat`, leaving that\n+    // with sorted runs of length INSERTION.\n \n-    #[inline]\n-    fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n-        core_slice::SliceExt::slice_from_mut(self, start)\n-    }\n+    // We could hardcode the sorting comparisons here, and we could\n+    // manipulate/step the pointers themselves, rather than repeatedly\n+    // .offset-ing.\n+    for start in range_step(0, len, insertion) {\n+        // start <= i < len;\n+        for i in range(start, cmp::min(start + insertion, len)) {\n+            // j satisfies: start <= j <= i;\n+            let mut j = i as int;\n+            unsafe {\n+                // `i` is in bounds.\n+                let read_ptr = buf_v.offset(i as int);\n \n-    #[inline]\n-    fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n-        core_slice::SliceExt::slice_to_mut(self, end)\n-    }\n+                // find where to insert, we need to do strict <,\n+                // rather than <=, to maintain stability.\n \n-    #[inline]\n-    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n-        core_slice::SliceExt::iter_mut(self)\n-    }\n+                // start <= j - 1 < len, so .offset(j - 1) is in\n+                // bounds.\n+                while j > start as int &&\n+                        compare(&*read_ptr, &*buf_dat.offset(j - 1)) == Less {\n+                    j -= 1;\n+                }\n \n-    #[inline]\n-    fn head_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n-        core_slice::SliceExt::head_mut(self)\n-    }\n+                // shift everything to the right, to make space to\n+                // insert this value.\n \n-    #[inline]\n-    fn tail_mut<'a>(&'a mut self) -> &'a mut [T] {\n-        core_slice::SliceExt::tail_mut(self)\n+                // j + 1 could be `len` (for the last `i`), but in\n+                // that case, `i == j` so we don't copy. The\n+                // `.offset(j)` is always in bounds.\n+                ptr::copy_memory(buf_dat.offset(j + 1),\n+                                 &*buf_dat.offset(j),\n+                                 i - j as uint);\n+                ptr::copy_nonoverlapping_memory(buf_dat.offset(j), read_ptr, 1);\n+            }\n+        }\n     }\n \n-    #[inline]\n-    fn init_mut<'a>(&'a mut self) -> &'a mut [T] {\n-        core_slice::SliceExt::init_mut(self)\n-    }\n+    // step 2. merge the sorted runs.\n+    let mut width = insertion;\n+    while width < len {\n+        // merge the sorted runs of length `width` in `buf_dat` two at\n+        // a time, placing the result in `buf_tmp`.\n \n-    #[inline]\n-    fn last_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n-        core_slice::SliceExt::last_mut(self)\n-    }\n+        // 0 <= start <= len.\n+        for start in range_step(0, len, 2 * width) {\n+            // manipulate pointers directly for speed (rather than\n+            // using a `for` loop with `range` and `.offset` inside\n+            // that loop).\n+            unsafe {\n+                // the end of the first run & start of the\n+                // second. Offset of `len` is defined, since this is\n+                // precisely one byte past the end of the object.\n+                let right_start = buf_dat.offset(cmp::min(start + width, len) as int);\n+                // end of the second. Similar reasoning to the above re safety.\n+                let right_end_idx = cmp::min(start + 2 * width, len);\n+                let right_end = buf_dat.offset(right_end_idx as int);\n \n-    #[inline]\n-    fn split_mut<F>(&mut self, pred: F) -> MutSplits<T, F>\n-                    where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::split_mut(self, pred)\n-    }\n+                // the pointers to the elements under consideration\n+                // from the two runs.\n \n-    #[inline]\n-    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitsN<MutSplits<T, F>>\n-                     where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::splitn_mut(self, n, pred)\n-    }\n+                // both of these are in bounds.\n+                let mut left = buf_dat.offset(start as int);\n+                let mut right = right_start;\n \n-    #[inline]\n-    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> SplitsN<MutSplits<T, F>>\n-                      where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::rsplitn_mut(self, n, pred)\n-    }\n+                // where we're putting the results, it is a run of\n+                // length `2*width`, so we step it once for each step\n+                // of either `left` or `right`.  `buf_tmp` has length\n+                // `len`, so these are in bounds.\n+                let mut out = buf_tmp.offset(start as int);\n+                let out_end = buf_tmp.offset(right_end_idx as int);\n \n-    #[inline]\n-    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> MutChunks<'a, T> {\n-        core_slice::SliceExt::chunks_mut(self, chunk_size)\n-    }\n+                while out < out_end {\n+                    // Either the left or the right run are exhausted,\n+                    // so just copy the remainder from the other run\n+                    // and move on; this gives a huge speed-up (order\n+                    // of 25%) for mostly sorted vectors (the best\n+                    // case).\n+                    if left == right_start {\n+                        // the number remaining in this run.\n+                        let elems = (right_end as uint - right as uint) / mem::size_of::<T>();\n+                        ptr::copy_nonoverlapping_memory(out, &*right, elems);\n+                        break;\n+                    } else if right == right_end {\n+                        let elems = (right_start as uint - left as uint) / mem::size_of::<T>();\n+                        ptr::copy_nonoverlapping_memory(out, &*left, elems);\n+                        break;\n+                    }\n \n-    #[inline]\n-    fn swap(&mut self, a: uint, b: uint) {\n-        core_slice::SliceExt::swap(self, a, b)\n-    }\n+                    // check which side is smaller, and that's the\n+                    // next element for the new run.\n \n-    #[inline]\n-    fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n-        core_slice::SliceExt::split_at_mut(self, mid)\n-    }\n+                    // `left < right_start` and `right < right_end`,\n+                    // so these are valid.\n+                    let to_copy = if compare(&*left, &*right) == Greater {\n+                        step(&mut right)\n+                    } else {\n+                        step(&mut left)\n+                    };\n+                    ptr::copy_nonoverlapping_memory(out, &*to_copy, 1);\n+                    step(&mut out);\n+                }\n+            }\n+        }\n \n-    #[inline]\n-    fn reverse(&mut self) {\n-        core_slice::SliceExt::reverse(self)\n-    }\n+        mem::swap(&mut buf_dat, &mut buf_tmp);\n \n-    #[inline]\n-    unsafe fn unsafe_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n-        core_slice::SliceExt::unsafe_mut(self, index)\n+        width *= 2;\n     }\n \n-    #[inline]\n-    fn as_mut_ptr(&mut self) -> *mut T {\n-        core_slice::SliceExt::as_mut_ptr(self)\n+    // write the result to `v` in one go, so that there are never two copies\n+    // of the same object in `v`.\n+    unsafe {\n+        ptr::copy_nonoverlapping_memory(v.as_mut_ptr(), &*buf_dat, len);\n     }\n-}\n-\n-#[unstable = \"trait is unstable\"]\n-impl<T> BorrowFrom<Vec<T>> for [T] {\n-    fn borrow_from(owned: &Vec<T>) -> &[T] { owned[] }\n-}\n-\n-#[unstable = \"trait is unstable\"]\n-impl<T> BorrowFromMut<Vec<T>> for [T] {\n-    fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { owned.as_mut_slice_() }\n-}\n \n-#[unstable = \"trait is unstable\"]\n-impl<T: Clone> ToOwned<Vec<T>> for [T] {\n-    fn to_owned(&self) -> Vec<T> { self.to_vec() }\n+    // increment the pointer, returning the old pointer.\n+    #[inline(always)]\n+    unsafe fn step<T>(ptr: &mut *mut T) -> *mut T {\n+        let old = *ptr;\n+        *ptr = ptr.offset(1);\n+        old\n+    }\n }\n \n-/// Unsafe operations\n+/// Deprecated, unsafe operations\n+#[deprecated]\n pub mod raw {\n     pub use core::slice::raw::{buf_as_slice, mut_buf_as_slice};\n     pub use core::slice::raw::{shift_ptr, pop_ptr};\n@@ -1348,7 +1419,7 @@ mod tests {\n     use prelude::{Some, None, range, Vec, ToString, Clone, Greater, Less, Equal};\n     use prelude::{SliceExt, Iterator, IteratorExt, DoubleEndedIteratorExt};\n     use prelude::{OrdSliceExt, CloneSliceExt, PartialEqSliceExt, AsSlice};\n-    use prelude::{RandomAccessIterator, Ord, VectorVector};\n+    use prelude::{RandomAccessIterator, Ord, SliceConcatExt};\n     use core::cell::Cell;\n     use core::default::Default;\n     use core::mem;\n@@ -1614,15 +1685,19 @@ mod tests {\n     fn test_swap_remove() {\n         let mut v = vec![1i, 2, 3, 4, 5];\n         let mut e = v.swap_remove(0);\n-        assert_eq!(e, Some(1));\n+        assert_eq!(e, 1);\n         assert_eq!(v, vec![5i, 2, 3, 4]);\n         e = v.swap_remove(3);\n-        assert_eq!(e, Some(4));\n+        assert_eq!(e, 4);\n         assert_eq!(v, vec![5i, 2, 3]);\n+    }\n \n-        e = v.swap_remove(3);\n-        assert_eq!(e, None);\n-        assert_eq!(v, vec![5i, 2, 3]);\n+    #[test]\n+    #[should_fail]\n+    fn test_swap_remove_fail() {\n+        let mut v = vec![1i];\n+        let _ = v.swap_remove(0);\n+        let _ = v.swap_remove(0);\n     }\n \n     #[test]\n@@ -1906,48 +1981,48 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_binary_search_elem() {\n-        assert_eq!([1i,2,3,4,5].binary_search_elem(&5).found(), Some(4));\n-        assert_eq!([1i,2,3,4,5].binary_search_elem(&4).found(), Some(3));\n-        assert_eq!([1i,2,3,4,5].binary_search_elem(&3).found(), Some(2));\n-        assert_eq!([1i,2,3,4,5].binary_search_elem(&2).found(), Some(1));\n-        assert_eq!([1i,2,3,4,5].binary_search_elem(&1).found(), Some(0));\n+    fn test_binary_search() {\n+        assert_eq!([1i,2,3,4,5].binary_search(&5).ok(), Some(4));\n+        assert_eq!([1i,2,3,4,5].binary_search(&4).ok(), Some(3));\n+        assert_eq!([1i,2,3,4,5].binary_search(&3).ok(), Some(2));\n+        assert_eq!([1i,2,3,4,5].binary_search(&2).ok(), Some(1));\n+        assert_eq!([1i,2,3,4,5].binary_search(&1).ok(), Some(0));\n \n-        assert_eq!([2i,4,6,8,10].binary_search_elem(&1).found(), None);\n-        assert_eq!([2i,4,6,8,10].binary_search_elem(&5).found(), None);\n-        assert_eq!([2i,4,6,8,10].binary_search_elem(&4).found(), Some(1));\n-        assert_eq!([2i,4,6,8,10].binary_search_elem(&10).found(), Some(4));\n+        assert_eq!([2i,4,6,8,10].binary_search(&1).ok(), None);\n+        assert_eq!([2i,4,6,8,10].binary_search(&5).ok(), None);\n+        assert_eq!([2i,4,6,8,10].binary_search(&4).ok(), Some(1));\n+        assert_eq!([2i,4,6,8,10].binary_search(&10).ok(), Some(4));\n \n-        assert_eq!([2i,4,6,8].binary_search_elem(&1).found(), None);\n-        assert_eq!([2i,4,6,8].binary_search_elem(&5).found(), None);\n-        assert_eq!([2i,4,6,8].binary_search_elem(&4).found(), Some(1));\n-        assert_eq!([2i,4,6,8].binary_search_elem(&8).found(), Some(3));\n+        assert_eq!([2i,4,6,8].binary_search(&1).ok(), None);\n+        assert_eq!([2i,4,6,8].binary_search(&5).ok(), None);\n+        assert_eq!([2i,4,6,8].binary_search(&4).ok(), Some(1));\n+        assert_eq!([2i,4,6,8].binary_search(&8).ok(), Some(3));\n \n-        assert_eq!([2i,4,6].binary_search_elem(&1).found(), None);\n-        assert_eq!([2i,4,6].binary_search_elem(&5).found(), None);\n-        assert_eq!([2i,4,6].binary_search_elem(&4).found(), Some(1));\n-        assert_eq!([2i,4,6].binary_search_elem(&6).found(), Some(2));\n+        assert_eq!([2i,4,6].binary_search(&1).ok(), None);\n+        assert_eq!([2i,4,6].binary_search(&5).ok(), None);\n+        assert_eq!([2i,4,6].binary_search(&4).ok(), Some(1));\n+        assert_eq!([2i,4,6].binary_search(&6).ok(), Some(2));\n \n-        assert_eq!([2i,4].binary_search_elem(&1).found(), None);\n-        assert_eq!([2i,4].binary_search_elem(&5).found(), None);\n-        assert_eq!([2i,4].binary_search_elem(&2).found(), Some(0));\n-        assert_eq!([2i,4].binary_search_elem(&4).found(), Some(1));\n+        assert_eq!([2i,4].binary_search(&1).ok(), None);\n+        assert_eq!([2i,4].binary_search(&5).ok(), None);\n+        assert_eq!([2i,4].binary_search(&2).ok(), Some(0));\n+        assert_eq!([2i,4].binary_search(&4).ok(), Some(1));\n \n-        assert_eq!([2i].binary_search_elem(&1).found(), None);\n-        assert_eq!([2i].binary_search_elem(&5).found(), None);\n-        assert_eq!([2i].binary_search_elem(&2).found(), Some(0));\n+        assert_eq!([2i].binary_search(&1).ok(), None);\n+        assert_eq!([2i].binary_search(&5).ok(), None);\n+        assert_eq!([2i].binary_search(&2).ok(), Some(0));\n \n-        assert_eq!([].binary_search_elem(&1i).found(), None);\n-        assert_eq!([].binary_search_elem(&5i).found(), None);\n+        assert_eq!([].binary_search(&1i).ok(), None);\n+        assert_eq!([].binary_search(&5i).ok(), None);\n \n-        assert!([1i,1,1,1,1].binary_search_elem(&1).found() != None);\n-        assert!([1i,1,1,1,2].binary_search_elem(&1).found() != None);\n-        assert!([1i,1,1,2,2].binary_search_elem(&1).found() != None);\n-        assert!([1i,1,2,2,2].binary_search_elem(&1).found() != None);\n-        assert_eq!([1i,2,2,2,2].binary_search_elem(&1).found(), Some(0));\n+        assert!([1i,1,1,1,1].binary_search(&1).ok() != None);\n+        assert!([1i,1,1,1,2].binary_search(&1).ok() != None);\n+        assert!([1i,1,1,2,2].binary_search(&1).ok() != None);\n+        assert!([1i,1,2,2,2].binary_search(&1).ok() != None);\n+        assert_eq!([1i,2,2,2,2].binary_search(&1).ok(), Some(0));\n \n-        assert_eq!([1i,2,3,4,5].binary_search_elem(&6).found(), None);\n-        assert_eq!([1i,2,3,4,5].binary_search_elem(&0).found(), None);\n+        assert_eq!([1i,2,3,4,5].binary_search(&6).ok(), None);\n+        assert_eq!([1i,2,3,4,5].binary_search(&0).ok(), None);\n     }\n \n     #[test]\n@@ -2042,13 +2117,15 @@ mod tests {\n     #[test]\n     fn test_concat() {\n         let v: [Vec<int>, ..0] = [];\n-        assert_eq!(v.concat_vec(), vec![]);\n-        assert_eq!([vec![1i], vec![2i,3i]].concat_vec(), vec![1, 2, 3]);\n+        let c: Vec<int> = v.concat();\n+        assert_eq!(c, []);\n+        let d: Vec<int> = [vec![1i], vec![2i,3i]].concat();\n+        assert_eq!(d, vec![1i, 2, 3]);\n \n         let v: [&[int], ..2] = [&[1], &[2, 3]];\n-        assert_eq!(v.connect_vec(&0), vec![1, 0, 2, 3]);\n-        let v: [&[int], ..3] = [&[1], &[2], &[3]];\n-        assert_eq!(v.connect_vec(&0), vec![1, 0, 2, 0, 3]);\n+        assert_eq!(v.connect(&0), vec![1i, 0, 2, 3]);\n+        let v: [&[int], ..3] = [&[1i], &[2], &[3]];\n+        assert_eq!(v.connect(&0), vec![1i, 0, 2, 0, 3]);\n     }\n \n     #[test]\n@@ -2094,23 +2171,25 @@ mod tests {\n     fn test_remove() {\n         let mut a = vec![1i,2,3,4];\n \n-        assert_eq!(a.remove(2), Some(3));\n+        assert_eq!(a.remove(2), 3);\n         assert_eq!(a, vec![1i,2,4]);\n \n-        assert_eq!(a.remove(2), Some(4));\n-        assert_eq!(a, vec![1i,2]);\n-\n-        assert_eq!(a.remove(2), None);\n+        assert_eq!(a.remove(2), 4);\n         assert_eq!(a, vec![1i,2]);\n \n-        assert_eq!(a.remove(0), Some(1));\n+        assert_eq!(a.remove(0), 1);\n         assert_eq!(a, vec![2i]);\n \n-        assert_eq!(a.remove(0), Some(2));\n+        assert_eq!(a.remove(0), 2);\n         assert_eq!(a, vec![]);\n+    }\n \n-        assert_eq!(a.remove(0), None);\n-        assert_eq!(a.remove(10), None);\n+    #[test]\n+    #[should_fail]\n+    fn test_remove_fail() {\n+        let mut a = vec![1i];\n+        let _ = a.remove(0);\n+        let _ = a.remove(0);\n     }\n \n     #[test]\n@@ -2806,7 +2885,7 @@ mod bench {\n         let xss: Vec<Vec<uint>> =\n             Vec::from_fn(100, |i| range(0u, i).collect());\n         b.iter(|| {\n-            xss.as_slice().concat_vec()\n+            xss.as_slice().concat();\n         });\n     }\n "}, {"sha": "8d5d76f9598f4a400b0a482399222cf78539b8e2", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 30, "deletions": 97, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -77,6 +77,7 @@ use slice::SliceExt;\n use string::String;\n use unicode;\n use vec::Vec;\n+use slice::SliceConcatExt;\n \n pub use core::str::{from_utf8, CharEq, Chars, CharIndices};\n pub use core::str::{Bytes, CharSplits, is_utf8};\n@@ -93,71 +94,45 @@ pub use core::str::{SplitN, RSplitN};\n Section: Creating a string\n */\n \n-/// Methods for vectors of strings.\n-#[unstable = \"functionality may be replaced with iterators\"]\n-pub trait StrVector for Sized? {\n-    /// Concatenates a vector of strings.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let first = \"Restaurant at the End of the\".to_string();\n-    /// let second = \" Universe\".to_string();\n-    /// let string_vec = vec![first, second];\n-    /// assert_eq!(string_vec.concat(), \"Restaurant at the End of the Universe\".to_string());\n-    /// ```\n-    fn concat(&self) -> String;\n-\n-    /// Concatenates a vector of strings, placing a given separator between each.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let first = \"Roast\".to_string();\n-    /// let second = \"Sirloin Steak\".to_string();\n-    /// let string_vec = vec![first, second];\n-    /// assert_eq!(string_vec.connect(\", \"), \"Roast, Sirloin Steak\".to_string());\n-    /// ```\n-    fn connect(&self, sep: &str) -> String;\n-}\n-\n-#[allow(deprecated)]\n-impl<S: Str> StrVector for [S] {\n+impl<S: Str> SliceConcatExt<str, String> for [S] {\n     fn concat(&self) -> String {\n-        if self.is_empty() {\n+        let s = self.as_slice();\n+\n+        if s.is_empty() {\n             return String::new();\n         }\n \n         // `len` calculation may overflow but push_str will check boundaries\n-        let len = self.iter().map(|s| s.as_slice().len()).sum();\n-\n+        let len = s.iter().map(|s| s.as_slice().len()).sum();\n         let mut result = String::with_capacity(len);\n \n-        for s in self.iter() {\n-            result.push_str(s.as_slice());\n+        for s in s.iter() {\n+            result.push_str(s.as_slice())\n         }\n \n         result\n     }\n \n     fn connect(&self, sep: &str) -> String {\n-        if self.is_empty() {\n+        let s = self.as_slice();\n+\n+        if s.is_empty() {\n             return String::new();\n         }\n \n         // concat is faster\n         if sep.is_empty() {\n-            return self.concat();\n+            return s.concat();\n         }\n \n         // this is wrong without the guarantee that `self` is non-empty\n         // `len` calculation may overflow but push_str but will check boundaries\n-        let len = sep.len() * (self.len() - 1)\n-            + self.iter().map(|s| s.as_slice().len()).sum();\n+        let len = sep.len() * (s.len() - 1)\n+            + s.iter().map(|s| s.as_slice().len()).sum();\n         let mut result = String::with_capacity(len);\n         let mut first = true;\n \n-        for s in self.iter() {\n+        for s in s.iter() {\n             if first {\n                 first = false;\n             } else {\n@@ -169,18 +144,6 @@ impl<S: Str> StrVector for [S] {\n     }\n }\n \n-impl<S: Str, T: AsSlice<S>> StrVector for T {\n-    #[inline]\n-    fn concat(&self) -> String {\n-        self.as_slice().concat()\n-    }\n-\n-    #[inline]\n-    fn connect(&self, sep: &str) -> String {\n-        self.as_slice().connect(sep)\n-    }\n-}\n-\n /*\n Section: Iterators\n */\n@@ -221,7 +184,7 @@ pub struct Decompositions<'a> {\n impl<'a> Iterator<char> for Decompositions<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n-        match self.buffer.head() {\n+        match self.buffer.first() {\n             Some(&(c, 0)) => {\n                 self.sorted = false;\n                 self.buffer.remove(0);\n@@ -268,13 +231,16 @@ impl<'a> Iterator<char> for Decompositions<'a> {\n             self.sorted = true;\n         }\n \n-        match self.buffer.remove(0) {\n-            Some((c, 0)) => {\n-                self.sorted = false;\n-                Some(c)\n+        if self.buffer.is_empty() {\n+            None\n+        } else {\n+            match self.buffer.remove(0) {\n+                (c, 0) => {\n+                    self.sorted = false;\n+                    Some(c)\n+                }\n+                (c, _) => Some(c),\n             }\n-            Some((c, _)) => Some(c),\n-            None => None\n         }\n     }\n \n@@ -747,7 +713,7 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n         if me.is_empty() { return t.chars().count(); }\n         if t.is_empty() { return me.chars().count(); }\n \n-        let mut dcol = Vec::from_fn(t.len() + 1, |x| x);\n+        let mut dcol: Vec<_> = range(0, t.len() + 1).collect();\n         let mut t_last = 0;\n \n         for (i, sc) in me.chars().enumerate() {\n@@ -1892,45 +1858,23 @@ mod tests {\n         assert_eq!(\"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\", \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".slice_chars(2, 8));\n     }\n \n-    struct S {\n-        x: [String, .. 2]\n-    }\n-\n-    impl AsSlice<String> for S {\n-        fn as_slice<'a> (&'a self) -> &'a [String] {\n-            &self.x\n-        }\n-    }\n-\n     fn s(x: &str) -> String { x.into_string() }\n \n     macro_rules! test_concat {\n         ($expected: expr, $string: expr) => {\n             {\n-                let s = $string.concat();\n+                let s: String = $string.concat();\n                 assert_eq!($expected, s);\n             }\n         }\n     }\n \n     #[test]\n     fn test_concat_for_different_types() {\n-        test_concat!(\"ab\", [\"a\", \"b\"]);\n-        test_concat!(\"ab\", [s(\"a\"), s(\"b\")]);\n+        test_concat!(\"ab\", vec![s(\"a\"), s(\"b\")]);\n         test_concat!(\"ab\", vec![\"a\", \"b\"]);\n         test_concat!(\"ab\", vec![\"a\", \"b\"].as_slice());\n         test_concat!(\"ab\", vec![s(\"a\"), s(\"b\")]);\n-\n-        let mut v0 = [\"a\", \"b\"];\n-        let mut v1 = [s(\"a\"), s(\"b\")];\n-        unsafe {\n-            use std::c_vec::CVec;\n-\n-            test_concat!(\"ab\", CVec::new(v0.as_mut_ptr(), v0.len()));\n-            test_concat!(\"ab\", CVec::new(v1.as_mut_ptr(), v1.len()));\n-        }\n-\n-        test_concat!(\"ab\", S { x: [s(\"a\"), s(\"b\")] });\n     }\n \n     #[test]\n@@ -1959,17 +1903,6 @@ mod tests {\n         test_connect!(\"a-b\", vec![\"a\", \"b\"], hyphen.as_slice());\n         test_connect!(\"a-b\", vec![\"a\", \"b\"].as_slice(), \"-\");\n         test_connect!(\"a-b\", vec![s(\"a\"), s(\"b\")], \"-\");\n-\n-        let mut v0 = [\"a\", \"b\"];\n-        let mut v1 = [s(\"a\"), s(\"b\")];\n-        unsafe {\n-            use std::c_vec::CVec;\n-\n-            test_connect!(\"a-b\", CVec::new(v0.as_mut_ptr(), v0.len()), \"-\");\n-            test_connect!(\"a-b\", CVec::new(v1.as_mut_ptr(), v1.len()), hyphen.as_slice());\n-        }\n-\n-        test_connect!(\"a-b\", S { x: [s(\"a\"), s(\"b\")] }, \"-\");\n     }\n \n     #[test]\n@@ -3339,7 +3272,7 @@ mod tests {\n #[cfg(test)]\n mod bench {\n     use super::*;\n-    use prelude::{SliceExt, IteratorExt, DoubleEndedIteratorExt};\n+    use prelude::{SliceExt, IteratorExt, DoubleEndedIteratorExt, SliceConcatExt};\n     use test::Bencher;\n     use test::black_box;\n \n@@ -3502,7 +3435,7 @@ mod bench {\n     fn bench_connect(b: &mut Bencher) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n         let sep = \"\u2192\";\n-        let v = [s, s, s, s, s, s, s, s, s, s];\n+        let v = vec![s, s, s, s, s, s, s, s, s, s];\n         b.iter(|| {\n             assert_eq!(v.connect(sep).len(), s.len() * 10 + sep.len() * 9);\n         })"}, {"sha": "f703ff99660c6ae4691119ad4d830d8b530f0300", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -151,7 +151,7 @@ impl String {\n         let mut i = 0;\n         let total = v.len();\n         fn unsafe_get(xs: &[u8], i: uint) -> u8 {\n-            unsafe { *xs.unsafe_get(i) }\n+            unsafe { *xs.get_unchecked(i) }\n         }\n         fn safe_get(xs: &[u8], i: uint, total: uint) -> u8 {\n             if i >= total {"}, {"sha": "a1952352badfaa28115cfad197b07a9840bd463a", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 917, "deletions": 1009, "changes": 1926, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -142,26 +142,9 @@ pub struct Vec<T> {\n unsafe impl<T: Send> Send for Vec<T> { }\n unsafe impl<T: Sync> Sync for Vec<T> { }\n \n-/// A clone-on-write vector\n-pub type CowVec<'a, T> = Cow<'a, Vec<T>, [T]>;\n-\n-impl<'a, T> FromIterator<T> for CowVec<'a, T> where T: Clone {\n-    fn from_iter<I: Iterator<T>>(it: I) -> CowVec<'a, T> {\n-        Cow::Owned(FromIterator::from_iter(it))\n-    }\n-}\n-\n-impl<'a, T: 'a> IntoCow<'a, Vec<T>, [T]> for Vec<T> where T: Clone {\n-    fn into_cow(self) -> CowVec<'a, T> {\n-        Cow::Owned(self)\n-    }\n-}\n-\n-impl<'a, T> IntoCow<'a, Vec<T>, [T]> for &'a [T] where T: Clone {\n-    fn into_cow(self) -> CowVec<'a, T> {\n-        Cow::Borrowed(self)\n-    }\n-}\n+////////////////////////////////////////////////////////////////////////////////\n+// Inherent methods\n+////////////////////////////////////////////////////////////////////////////////\n \n impl<T> Vec<T> {\n     /// Constructs a new, empty `Vec<T>`.\n@@ -190,8 +173,7 @@ impl<T> Vec<T> {\n     ///\n     /// It is important to note that this function does not specify the *length* of the returned\n     /// vector, but only the *capacity*. (For an explanation of the difference between length and\n-    /// capacity, see the main `Vec<T>` docs above, 'Capacity and reallocation'.) To create a\n-    /// vector of a given length, use `Vec::from_elem` or `Vec::from_fn`.\n+    /// capacity, see the main `Vec<T>` docs above, 'Capacity and reallocation'.)\n     ///\n     /// # Examples\n     ///\n@@ -225,30 +207,11 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Creates and initializes a `Vec<T>`.\n-    ///\n-    /// Creates a `Vec<T>` of size `length` and initializes the elements to the value returned by\n-    /// the closure `op`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let vec = Vec::from_fn(3, |idx| idx * 2);\n-    /// assert_eq!(vec, vec![0, 2, 4]);\n-    /// ```\n+    /// Deprecated: use `iter::range(0, length).map(op).collect()` instead\n     #[inline]\n-    #[unstable = \"the naming is uncertain as well as this migrating to unboxed \\\n-                  closures in the future\"]\n-    pub fn from_fn<F>(length: uint, mut op: F) -> Vec<T> where F: FnMut(uint) -> T {\n-        unsafe {\n-            let mut xs = Vec::with_capacity(length);\n-            while xs.len < length {\n-                let len = xs.len;\n-                ptr::write(xs.unsafe_mut(len), op(len));\n-                xs.len += 1;\n-            }\n-            xs\n-        }\n+    #[deprecated = \"use iter::range(0, length).map(op).collect() instead\"]\n+    pub fn from_fn<F>(length: uint, op: F) -> Vec<T> where F: FnMut(uint) -> T {\n+        range(0, length).map(op).collect()\n     }\n \n     /// Creates a `Vec<T>` directly from the raw components of another vector.\n@@ -285,7 +248,7 @@ impl<T> Vec<T> {\n     ///     }\n     /// }\n     /// ```\n-    #[unstable = \"needs finalization\"]\n+    #[stable]\n     pub unsafe fn from_raw_parts(ptr: *mut T, length: uint,\n                                  capacity: uint) -> Vec<T> {\n         Vec { ptr: NonZero::new(ptr), len: length, cap: capacity }\n@@ -297,960 +260,802 @@ impl<T> Vec<T> {\n     /// owned by the returned `Vec<T>`. The elements of the buffer are copied into the vector\n     /// without cloning, as if `ptr::read()` were called on them.\n     #[inline]\n-    #[unstable = \"just renamed from raw::from_buf\"]\n+    #[unstable = \"may be better expressed via composition\"]\n     pub unsafe fn from_raw_buf(ptr: *const T, elts: uint) -> Vec<T> {\n         let mut dst = Vec::with_capacity(elts);\n         dst.set_len(elts);\n         ptr::copy_nonoverlapping_memory(dst.as_mut_ptr(), ptr, elts);\n         dst\n     }\n \n-    /// Consumes the `Vec<T>`, partitioning it based on a predicate.\n-    ///\n-    /// Partitions the `Vec<T>` into two `Vec<T>`s `(A,B)`, where all elements of `A` satisfy `f`\n-    /// and all elements of `B` do not. The order of elements is preserved.\n+    /// Deprecated: use `into_iter().partition(f)` instead.\n+    #[inline]\n+    #[deprecated = \"use into_iter().partition(f) instead\"]\n+    pub fn partition<F>(self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n+        self.into_iter().partition(f)\n+    }\n+\n+    /// Returns the number of elements the vector can hold without\n+    /// reallocating.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let vec = vec![1i, 2i, 3i, 4i];\n-    /// let (even, odd) = vec.partition(|&n| n % 2 == 0);\n-    /// assert_eq!(even, vec![2, 4]);\n-    /// assert_eq!(odd, vec![1, 3]);\n+    /// let vec: Vec<int> = Vec::with_capacity(10);\n+    /// assert_eq!(vec.capacity(), 10);\n     /// ```\n     #[inline]\n-    #[experimental]\n-    pub fn partition<F>(self, mut f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n-        let mut lefts  = Vec::new();\n-        let mut rights = Vec::new();\n-\n-        for elt in self.into_iter() {\n-            if f(&elt) {\n-                lefts.push(elt);\n-            } else {\n-                rights.push(elt);\n-            }\n-        }\n+    #[stable]\n+    pub fn capacity(&self) -> uint {\n+        self.cap\n+    }\n \n-        (lefts, rights)\n+    /// Deprecated: Renamed to `reserve`.\n+    #[deprecated = \"Renamed to `reserve`\"]\n+    pub fn reserve_additional(&mut self, extra: uint) {\n+        self.reserve(extra)\n     }\n-}\n \n-impl<T: Clone> Vec<T> {\n-    /// Constructs a `Vec<T>` with copies of a value.\n+    /// Reserves capacity for at least `additional` more elements to be inserted in the given\n+    /// `Vec<T>`. The collection may reserve more space to avoid frequent reallocations.\n+    ///\n+    /// # Panics\n     ///\n-    /// Creates a `Vec<T>` with `length` copies of `value`.\n+    /// Panics if the new capacity overflows `uint`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let vec = Vec::from_elem(3, \"hi\");\n-    /// println!(\"{}\", vec); // prints [hi, hi, hi]\n+    /// let mut vec: Vec<int> = vec![1];\n+    /// vec.reserve(10);\n+    /// assert!(vec.capacity() >= 11);\n     /// ```\n-    #[inline]\n-    #[unstable = \"this functionality may become more generic over all collections\"]\n-    pub fn from_elem(length: uint, value: T) -> Vec<T> {\n-        unsafe {\n-            let mut xs = Vec::with_capacity(length);\n-            while xs.len < length {\n-                let len = xs.len;\n-                ptr::write(xs.unsafe_mut(len),\n-                           value.clone());\n-                xs.len += 1;\n-            }\n-            xs\n+    #[stable]\n+    pub fn reserve(&mut self, additional: uint) {\n+        if self.cap - self.len < additional {\n+            let err_msg = \"Vec::reserve: `uint` overflow\";\n+            let new_cap = self.len.checked_add(additional).expect(err_msg)\n+                .checked_next_power_of_two().expect(err_msg);\n+            self.grow_capacity(new_cap);\n         }\n     }\n \n-    /// Appends all elements in a slice to the `Vec<T>`.\n+    /// Reserves the minimum capacity for exactly `additional` more elements to\n+    /// be inserted in the given `Vec<T>`. Does nothing if the capacity is already\n+    /// sufficient.\n     ///\n-    /// Iterates over the slice `other`, clones each element, and then appends\n-    /// it to this `Vec<T>`. The `other` vector is traversed in-order.\n+    /// Note that the allocator may give the collection more space than it\n+    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// minimal. Prefer `reserve` if future insertions are expected.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec = vec![1i];\n-    /// vec.push_all(&[2i, 3, 4]);\n-    /// assert_eq!(vec, vec![1, 2, 3, 4]);\n+    /// let mut vec: Vec<int> = vec![1];\n+    /// vec.reserve_exact(10);\n+    /// assert!(vec.capacity() >= 11);\n     /// ```\n-    #[inline]\n-    #[experimental]\n-    pub fn push_all(&mut self, other: &[T]) {\n-        self.reserve(other.len());\n-\n-        for i in range(0, other.len()) {\n-            let len = self.len();\n-\n-            // Unsafe code so this can be optimised to a memcpy (or something similarly\n-            // fast) when T is Copy. LLVM is easily confused, so any extra operations\n-            // during the loop can prevent this optimisation.\n-            unsafe {\n-                ptr::write(\n-                    self.unsafe_mut(len),\n-                    other.unsafe_get(i).clone());\n-                self.set_len(len + 1);\n+    #[stable]\n+    pub fn reserve_exact(&mut self, additional: uint) {\n+        if self.cap - self.len < additional {\n+            match self.len.checked_add(additional) {\n+                None => panic!(\"Vec::reserve: `uint` overflow\"),\n+                Some(new_cap) => self.grow_capacity(new_cap)\n             }\n         }\n     }\n \n-    /// Grows the `Vec<T>` in-place.\n+    /// Shrinks the capacity of the vector as much as possible.\n     ///\n-    /// Adds `n` copies of `value` to the `Vec<T>`.\n+    /// It will drop down as close as possible to the length but the allocator\n+    /// may still inform the vector that there is space for a few more elements.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec = vec![\"hello\"];\n-    /// vec.grow(2, \"world\");\n-    /// assert_eq!(vec, vec![\"hello\", \"world\", \"world\"]);\n+    /// let mut vec: Vec<int> = Vec::with_capacity(10);\n+    /// vec.push_all(&[1, 2, 3]);\n+    /// assert_eq!(vec.capacity(), 10);\n+    /// vec.shrink_to_fit();\n+    /// assert!(vec.capacity() >= 3);\n     /// ```\n     #[stable]\n-    pub fn grow(&mut self, n: uint, value: T) {\n-        self.reserve(n);\n-        let mut i: uint = 0u;\n+    pub fn shrink_to_fit(&mut self) {\n+        if mem::size_of::<T>() == 0 { return }\n+\n+        if self.len == 0 {\n+            if self.cap != 0 {\n+                unsafe {\n+                    dealloc(*self.ptr, self.cap)\n+                }\n+                self.cap = 0;\n+            }\n+        } else {\n+            unsafe {\n+                // Overflow check is unnecessary as the vector is already at\n+                // least this large.\n+                let ptr = reallocate(*self.ptr as *mut u8,\n+                                     self.cap * mem::size_of::<T>(),\n+                                     self.len * mem::size_of::<T>(),\n+                                     mem::min_align_of::<T>()) as *mut T;\n+                if ptr.is_null() { ::alloc::oom() }\n+                self.ptr = NonZero::new(ptr);\n+            }\n+            self.cap = self.len;\n+        }\n+    }\n \n-        while i < n {\n-            self.push(value.clone());\n-            i += 1u;\n+    /// Convert the vector into Box<[T]>.\n+    ///\n+    /// Note that this will drop any excess capacity. Calling this and\n+    /// converting back to a vector with `into_vec()` is equivalent to calling\n+    /// `shrink_to_fit()`.\n+    #[experimental]\n+    pub fn into_boxed_slice(mut self) -> Box<[T]> {\n+        self.shrink_to_fit();\n+        unsafe {\n+            let xs: Box<[T]> = mem::transmute(self.as_mut_slice());\n+            mem::forget(self);\n+            xs\n         }\n     }\n \n-    /// Resizes the `Vec` in-place so that `len()` is equal to `new_len`.\n+    /// Shorten a vector, dropping excess elements.\n     ///\n-    /// Calls either `extend()` or `truncate()` depending on whether `new_len`\n-    /// is larger than the current value of `len()` or not.\n+    /// If `len` is greater than the vector's current length, this has no\n+    /// effect.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec = vec![\"hello\"];\n-    /// vec.resize(3, \"world\");\n-    /// assert_eq!(vec, vec![\"hello\", \"world\", \"world\"]);\n-    ///\n     /// let mut vec = vec![1i, 2, 3, 4];\n-    /// vec.resize(2, 0);\n+    /// vec.truncate(2);\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n-    #[unstable = \"matches collection reform specification; waiting for dust to settle\"]\n-    pub fn resize(&mut self, new_len: uint, value: T) {\n-        let len = self.len();\n-\n-        if new_len > len {\n-            self.extend(repeat(value).take(new_len - len));\n-        } else {\n-            self.truncate(new_len);\n+    #[stable]\n+    pub fn truncate(&mut self, len: uint) {\n+        unsafe {\n+            // drop any extra elements\n+            while len < self.len {\n+                // decrement len before the read(), so a panic on Drop doesn't\n+                // re-drop the just-failed value.\n+                self.len -= 1;\n+                ptr::read(self.get_unchecked(self.len));\n+            }\n         }\n     }\n \n-    /// Partitions a vector based on a predicate.\n-    ///\n-    /// Clones the elements of the vector, partitioning them into two `Vec<T>`s\n-    /// `(a, b)`, where all elements of `a` satisfy `f` and all elements of `b`\n-    /// do not. The order of elements is preserved.\n+    /// Returns a mutable slice of the elements of `self`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let vec = vec![1i, 2, 3, 4];\n-    /// let (even, odd) = vec.partitioned(|&n| n % 2 == 0);\n-    /// assert_eq!(even, vec![2i, 4]);\n-    /// assert_eq!(odd, vec![1i, 3]);\n+    /// fn foo(slice: &mut [int]) {}\n+    ///\n+    /// let mut vec = vec![1i, 2];\n+    /// foo(vec.as_mut_slice());\n     /// ```\n-    #[experimental]\n-    pub fn partitioned<F>(&self, mut f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n-        let mut lefts = Vec::new();\n-        let mut rights = Vec::new();\n-\n-        for elt in self.iter() {\n-            if f(elt) {\n-                lefts.push(elt.clone());\n-            } else {\n-                rights.push(elt.clone());\n-            }\n+    #[inline]\n+    #[stable]\n+    pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n+        unsafe {\n+            mem::transmute(RawSlice {\n+                data: *self.ptr as *const T,\n+                len: self.len,\n+            })\n         }\n-\n-        (lefts, rights)\n     }\n-}\n-\n-#[stable]\n-impl<T:Clone> Clone for Vec<T> {\n-    fn clone(&self) -> Vec<T> { self.as_slice().to_vec() }\n-\n-    fn clone_from(&mut self, other: &Vec<T>) {\n-        // drop anything in self that will not be overwritten\n-        if self.len() > other.len() {\n-            self.truncate(other.len())\n-        }\n \n-        // reuse the contained values' allocations/resources.\n-        for (place, thing) in self.iter_mut().zip(other.iter()) {\n-            place.clone_from(thing)\n+    /// Creates a consuming iterator, that is, one that moves each value out of\n+    /// the vector (from start to end). The vector cannot be used after calling\n+    /// this.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = vec![\"a\".to_string(), \"b\".to_string()];\n+    /// for s in v.into_iter() {\n+    ///     // s has type String, not &String\n+    ///     println!(\"{}\", s);\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[stable]\n+    pub fn into_iter(self) -> IntoIter<T> {\n+        unsafe {\n+            let ptr = *self.ptr;\n+            let cap = self.cap;\n+            let begin = ptr as *const T;\n+            let end = if mem::size_of::<T>() == 0 {\n+                (ptr as uint + self.len()) as *const T\n+            } else {\n+                ptr.offset(self.len() as int) as *const T\n+            };\n+            mem::forget(self);\n+            IntoIter { allocation: ptr, cap: cap, ptr: begin, end: end }\n         }\n-\n-        // self.len <= other.len due to the truncate above, so the\n-        // slice here is always in-bounds.\n-        let slice = other[self.len()..];\n-        self.push_all(slice);\n     }\n-}\n \n-#[experimental = \"waiting on Index stability\"]\n-impl<T> Index<uint,T> for Vec<T> {\n+    /// Sets the length of a vector.\n+    ///\n+    /// This will explicitly set the size of the vector, without actually\n+    /// modifying its buffers, so it is up to the caller to ensure that the\n+    /// vector is actually the specified size.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = vec![1u, 2, 3, 4];\n+    /// unsafe {\n+    ///     v.set_len(1);\n+    /// }\n+    /// ```\n     #[inline]\n-    fn index<'a>(&'a self, index: &uint) -> &'a T {\n-        &self.as_slice()[*index]\n+    #[stable]\n+    pub unsafe fn set_len(&mut self, len: uint) {\n+        self.len = len;\n     }\n-}\n \n-impl<T> IndexMut<uint,T> for Vec<T> {\n-    #[inline]\n-    fn index_mut<'a>(&'a mut self, index: &uint) -> &'a mut T {\n-        &mut self.as_mut_slice()[*index]\n-    }\n-}\n-\n-impl<T> ops::Slice<uint, [T]> for Vec<T> {\n-    #[inline]\n-    fn as_slice_<'a>(&'a self) -> &'a [T] {\n-        self.as_slice()\n-    }\n-\n-    #[inline]\n-    fn slice_from_or_fail<'a>(&'a self, start: &uint) -> &'a [T] {\n-        self.as_slice().slice_from_or_fail(start)\n-    }\n-\n-    #[inline]\n-    fn slice_to_or_fail<'a>(&'a self, end: &uint) -> &'a [T] {\n-        self.as_slice().slice_to_or_fail(end)\n-    }\n-    #[inline]\n-    fn slice_or_fail<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n-        self.as_slice().slice_or_fail(start, end)\n-    }\n-}\n-\n-impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n-    #[inline]\n-    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n-        self.as_mut_slice()\n-    }\n-\n-    #[inline]\n-    fn slice_from_or_fail_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_from_or_fail_mut(start)\n-    }\n-\n-    #[inline]\n-    fn slice_to_or_fail_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_to_or_fail_mut(end)\n-    }\n-    #[inline]\n-    fn slice_or_fail_mut<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_or_fail_mut(start, end)\n-    }\n-}\n-\n-#[experimental = \"waiting on Deref stability\"]\n-impl<T> ops::Deref<[T]> for Vec<T> {\n-    fn deref<'a>(&'a self) -> &'a [T] { self.as_slice() }\n-}\n-\n-#[experimental = \"waiting on DerefMut stability\"]\n-impl<T> ops::DerefMut<[T]> for Vec<T> {\n-    fn deref_mut<'a>(&'a mut self) -> &'a mut [T] { self.as_mut_slice() }\n-}\n-\n-#[experimental = \"waiting on FromIterator stability\"]\n-impl<T> FromIterator<T> for Vec<T> {\n-    #[inline]\n-    fn from_iter<I:Iterator<T>>(mut iterator: I) -> Vec<T> {\n-        let (lower, _) = iterator.size_hint();\n-        let mut vector = Vec::with_capacity(lower);\n-        for element in iterator {\n-            vector.push(element)\n-        }\n-        vector\n-    }\n-}\n-\n-#[experimental = \"waiting on Extend stability\"]\n-impl<T> Extend<T> for Vec<T> {\n-    #[inline]\n-    fn extend<I: Iterator<T>>(&mut self, mut iterator: I) {\n-        let (lower, _) = iterator.size_hint();\n-        self.reserve(lower);\n-        for element in iterator {\n-            self.push(element)\n-        }\n-    }\n-}\n-\n-#[stable]\n-impl<A, B> PartialEq<Vec<B>> for Vec<A> where A: PartialEq<B> {\n-    #[inline]\n-    fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }\n-    #[inline]\n-    fn ne(&self, other: &Vec<B>) -> bool { PartialEq::ne(&**self, &**other) }\n-}\n-\n-macro_rules! impl_eq {\n-    ($lhs:ty, $rhs:ty) => {\n-        #[stable]\n-        impl<'b, A, B> PartialEq<$rhs> for $lhs where A: PartialEq<B> {\n-            #[inline]\n-            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n-            #[inline]\n-            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n-        }\n-\n-        #[stable]\n-        impl<'b, A, B> PartialEq<$lhs> for $rhs where B: PartialEq<A> {\n-            #[inline]\n-            fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&**self, &**other) }\n-            #[inline]\n-            fn ne(&self, other: &$lhs) -> bool { PartialEq::ne(&**self, &**other) }\n-        }\n-    }\n-}\n-\n-impl_eq! { Vec<A>, &'b [B] }\n-impl_eq! { Vec<A>, &'b mut [B] }\n-\n-#[stable]\n-impl<'a, A, B> PartialEq<Vec<B>> for CowVec<'a, A> where A: PartialEq<B> + Clone {\n-    #[inline]\n-    fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }\n-    #[inline]\n-    fn ne(&self, other: &Vec<B>) -> bool { PartialEq::ne(&**self, &**other) }\n-}\n-\n-#[stable]\n-impl<'a, A, B> PartialEq<CowVec<'a, A>> for Vec<B> where A: Clone, B: PartialEq<A> {\n-    #[inline]\n-    fn eq(&self, other: &CowVec<'a, A>) -> bool { PartialEq::eq(&**self, &**other) }\n-    #[inline]\n-    fn ne(&self, other: &CowVec<'a, A>) -> bool { PartialEq::ne(&**self, &**other) }\n-}\n-\n-macro_rules! impl_eq_for_cowvec {\n-    ($rhs:ty) => {\n-        #[stable]\n-        impl<'a, 'b, A, B> PartialEq<$rhs> for CowVec<'a, A> where A: PartialEq<B> + Clone {\n-            #[inline]\n-            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n-            #[inline]\n-            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n-        }\n-\n-        #[stable]\n-        impl<'a, 'b, A, B> PartialEq<CowVec<'a, A>> for $rhs where A: Clone, B: PartialEq<A> {\n-            #[inline]\n-            fn eq(&self, other: &CowVec<'a, A>) -> bool { PartialEq::eq(&**self, &**other) }\n-            #[inline]\n-            fn ne(&self, other: &CowVec<'a, A>) -> bool { PartialEq::ne(&**self, &**other) }\n-        }\n-    }\n-}\n-\n-impl_eq_for_cowvec! { &'b [B] }\n-impl_eq_for_cowvec! { &'b mut [B] }\n-\n-#[stable]\n-impl<T: PartialOrd> PartialOrd for Vec<T> {\n-    #[inline]\n-    fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n-        self.as_slice().partial_cmp(other.as_slice())\n-    }\n-}\n-\n-#[stable]\n-impl<T: Eq> Eq for Vec<T> {}\n-\n-#[allow(deprecated)]\n-#[deprecated = \"Use overloaded `core::cmp::PartialEq`\"]\n-impl<T: PartialEq, Sized? V: AsSlice<T>> Equiv<V> for Vec<T> {\n-    #[inline]\n-    fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n-}\n-\n-#[stable]\n-impl<T: Ord> Ord for Vec<T> {\n-    #[inline]\n-    fn cmp(&self, other: &Vec<T>) -> Ordering {\n-        self.as_slice().cmp(other.as_slice())\n-    }\n-}\n-\n-impl<S: hash::Writer, T: Hash<S>> Hash<S> for Vec<T> {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.as_slice().hash(state);\n-    }\n-}\n-\n-// FIXME: #13996: need a way to mark the return value as `noalias`\n-#[inline(never)]\n-unsafe fn alloc_or_realloc<T>(ptr: *mut T, old_size: uint, size: uint) -> *mut T {\n-    if old_size == 0 {\n-        allocate(size, mem::min_align_of::<T>()) as *mut T\n-    } else {\n-        reallocate(ptr as *mut u8, old_size, size, mem::min_align_of::<T>()) as *mut T\n-    }\n-}\n-\n-#[inline]\n-unsafe fn dealloc<T>(ptr: *mut T, len: uint) {\n-    if mem::size_of::<T>() != 0 {\n-        deallocate(ptr as *mut u8,\n-                   len * mem::size_of::<T>(),\n-                   mem::min_align_of::<T>())\n-    }\n-}\n-\n-impl<T> Vec<T> {\n-    /// Returns the number of elements the vector can hold without reallocating.\n+    /// Removes an element from anywhere in the vector and return it, replacing\n+    /// it with the last element.\n+    ///\n+    /// This does not preserve ordering, but is O(1).\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is out of bounds.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let vec: Vec<int> = Vec::with_capacity(10);\n-    /// assert_eq!(vec.capacity(), 10);\n+    /// let mut v = vec![\"foo\", \"bar\", \"baz\", \"qux\"];\n+    ///\n+    /// assert_eq!(v.swap_remove(1), \"bar\");\n+    /// assert_eq!(v, vec![\"foo\", \"qux\", \"baz\"]);\n+    ///\n+    /// assert_eq!(v.swap_remove(0), \"foo\");\n+    /// assert_eq!(v, vec![\"baz\", \"qux\"]);\n     /// ```\n     #[inline]\n     #[stable]\n-    pub fn capacity(&self) -> uint {\n-        self.cap\n-    }\n-\n-    /// Deprecated: Renamed to `reserve`.\n-    #[deprecated = \"Renamed to `reserve`\"]\n-    pub fn reserve_additional(&mut self, extra: uint) {\n-        self.reserve(extra)\n+    pub fn swap_remove(&mut self, index: uint) -> T {\n+        let length = self.len();\n+        self.swap(index, length - 1);\n+        self.pop().unwrap()\n     }\n \n-    /// Reserves capacity for at least `additional` more elements to be inserted in the given\n-    /// `Vec<T>`. The collection may reserve more space to avoid frequent reallocations.\n+    /// Inserts an element at position `index` within the vector, shifting all\n+    /// elements after position `i` one position to the right.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if `index` is not between `0` and the vector's length (both\n+    /// bounds inclusive).\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec: Vec<int> = vec![1];\n-    /// vec.reserve(10);\n-    /// assert!(vec.capacity() >= 11);\n+    /// let mut vec = vec![1i, 2, 3];\n+    /// vec.insert(1, 4);\n+    /// assert_eq!(vec, vec![1, 4, 2, 3]);\n+    /// vec.insert(4, 5);\n+    /// assert_eq!(vec, vec![1, 4, 2, 3, 5]);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn reserve(&mut self, additional: uint) {\n-        if self.cap - self.len < additional {\n-            let err_msg = \"Vec::reserve: `uint` overflow\";\n-            let new_cap = self.len.checked_add(additional).expect(err_msg)\n-                                  .checked_next_power_of_two().expect(err_msg);\n-            self.grow_capacity(new_cap);\n+    #[stable]\n+    pub fn insert(&mut self, index: uint, element: T) {\n+        let len = self.len();\n+        assert!(index <= len);\n+        // space for the new element\n+        self.reserve(1);\n+\n+        unsafe { // infallible\n+            // The spot to put the new value\n+            {\n+                let p = self.as_mut_ptr().offset(index as int);\n+                // Shift everything over to make space. (Duplicating the\n+                // `index`th element into two consecutive places.)\n+                ptr::copy_memory(p.offset(1), &*p, len - index);\n+                // Write it in, overwriting the first copy of the `index`th\n+                // element.\n+                ptr::write(&mut *p, element);\n+            }\n+            self.set_len(len + 1);\n         }\n     }\n \n-    /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n-    /// given `Vec<T>`. Does nothing if the capacity is already sufficient.\n-    ///\n-    /// Note that the allocator may give the collection more space than it requests. Therefore\n-    /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n-    /// insertions are expected.\n+    /// Removes and returns the element at position `index` within the vector,\n+    /// shifting all elements after position `index` one position to the left.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if `i` is out of bounds.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec: Vec<int> = vec![1];\n-    /// vec.reserve_exact(10);\n-    /// assert!(vec.capacity() >= 11);\n+    /// let mut v = vec![1i, 2, 3];\n+    /// assert_eq!(v.remove(1), 2);\n+    /// assert_eq!(v, vec![1, 3]);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn reserve_exact(&mut self, additional: uint) {\n-        if self.cap - self.len < additional {\n-            match self.len.checked_add(additional) {\n-                None => panic!(\"Vec::reserve: `uint` overflow\"),\n-                Some(new_cap) => self.grow_capacity(new_cap)\n+    #[stable]\n+    pub fn remove(&mut self, index: uint) -> T {\n+        let len = self.len();\n+        assert!(index < len);\n+        unsafe { // infallible\n+            let ret;\n+            {\n+                // the place we are taking from.\n+                let ptr = self.as_mut_ptr().offset(index as int);\n+                // copy it out, unsafely having a copy of the value on\n+                // the stack and in the vector at the same time.\n+                ret = ptr::read(ptr as *const T);\n+\n+                // Shift everything down to fill in that spot.\n+                ptr::copy_memory(ptr, &*ptr.offset(1), len - index - 1);\n             }\n+            self.set_len(len - 1);\n+            ret\n         }\n     }\n \n-    /// Shrinks the capacity of the vector as much as possible.\n+    /// Retains only the elements specified by the predicate.\n     ///\n-    /// It will drop down as close as possible to the length but the allocator may still inform the\n-    /// vector that there is space for a few more elements.\n+    /// In other words, remove all elements `e` such that `f(&e)` returns false.\n+    /// This method operates in place and preserves the order of the retained\n+    /// elements.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec: Vec<int> = Vec::with_capacity(10);\n-    ///\n-    /// vec.push_all(&[1, 2, 3]);\n-    /// assert_eq!(vec.capacity(), 10);\n-    ///\n-    /// vec.shrink_to_fit();\n-    /// assert!(vec.capacity() >= 3);\n+    /// let mut vec = vec![1i, 2, 3, 4];\n+    /// vec.retain(|&x| x%2 == 0);\n+    /// assert_eq!(vec, vec![2, 4]);\n     /// ```\n     #[stable]\n-    pub fn shrink_to_fit(&mut self) {\n-        if mem::size_of::<T>() == 0 { return }\n+    pub fn retain<F>(&mut self, mut f: F) where F: FnMut(&T) -> bool {\n+        let len = self.len();\n+        let mut del = 0u;\n+        {\n+            let v = self.as_mut_slice();\n \n-        if self.len == 0 {\n-            if self.cap != 0 {\n-                unsafe {\n-                    dealloc(*self.ptr, self.cap)\n+            for i in range(0u, len) {\n+                if !f(&v[i]) {\n+                    del += 1;\n+                } else if del > 0 {\n+                    v.swap(i-del, i);\n                 }\n-                self.cap = 0;\n             }\n-        } else {\n-            unsafe {\n-                // Overflow check is unnecessary as the vector is already at\n-                // least this large.\n-                let ptr = reallocate(*self.ptr as *mut u8,\n-                                     self.cap * mem::size_of::<T>(),\n-                                     self.len * mem::size_of::<T>(),\n-                                     mem::min_align_of::<T>()) as *mut T;\n-                if ptr.is_null() { ::alloc::oom() }\n-                self.ptr = NonZero::new(ptr);\n-            }\n-            self.cap = self.len;\n+        }\n+        if del > 0 {\n+            self.truncate(len - del);\n         }\n     }\n \n-    /// Convert the vector into Box<[T]>.\n-    ///\n-    /// Note that this will drop any excess capacity. Calling this and converting back to a vector\n-    /// with `into_vec()` is equivalent to calling `shrink_to_fit()`.\n-    #[experimental]\n-    pub fn into_boxed_slice(mut self) -> Box<[T]> {\n-        self.shrink_to_fit();\n-        unsafe {\n-            let xs: Box<[T]> = mem::transmute(self.as_mut_slice());\n-            mem::forget(self);\n-            xs\n-        }\n+    /// Deprecated: use `extend(range(0, n).map(f))` instead.\n+    #[deprecated = \"use extend(range(0, n).map(f)) instead\"]\n+    pub fn grow_fn<F>(&mut self, n: uint, f: F) where F: FnMut(uint) -> T {\n+        self.extend(range(0, n).map(f));\n     }\n \n-    /// Shorten a vector, dropping excess elements.\n+    /// Appends an element to the back of a collection.\n     ///\n-    /// If `len` is greater than the vector's current length, this has no\n-    /// effect.\n+    /// # Panics\n+    ///\n+    /// Panics if the number of elements in the vector overflows a `uint`.\n     ///\n     /// # Examples\n     ///\n+    /// ```rust\n+    /// let mut vec = vec!(1i, 2);\n+    /// vec.push(3);\n+    /// assert_eq!(vec, vec!(1, 2, 3));\n     /// ```\n-    /// let mut vec = vec![1i, 2, 3, 4];\n-    /// vec.truncate(2);\n-    /// assert_eq!(vec, vec![1, 2]);\n-    /// ```\n-    #[unstable = \"matches collection reform specification; waiting on panic semantics\"]\n-    pub fn truncate(&mut self, len: uint) {\n-        unsafe {\n-            // drop any extra elements\n-            while len < self.len {\n-                // decrement len before the read(), so a panic on Drop doesn't\n-                // re-drop the just-failed value.\n-                self.len -= 1;\n-                ptr::read(self.unsafe_get(self.len));\n+    #[inline]\n+    #[stable]\n+    pub fn push(&mut self, value: T) {\n+        if mem::size_of::<T>() == 0 {\n+            // zero-size types consume no memory, so we can't rely on the\n+            // address space running out\n+            self.len = self.len.checked_add(1).expect(\"length overflow\");\n+            unsafe { mem::forget(value); }\n+            return\n+        }\n+        if self.len == self.cap {\n+            let old_size = self.cap * mem::size_of::<T>();\n+            let size = max(old_size, 2 * mem::size_of::<T>()) * 2;\n+            if old_size > size { panic!(\"capacity overflow\") }\n+            unsafe {\n+                let ptr = alloc_or_realloc(*self.ptr, old_size, size);\n+                if ptr.is_null() { ::alloc::oom() }\n+                self.ptr = NonZero::new(ptr);\n             }\n+            self.cap = max(self.cap, 2) * 2;\n+        }\n+\n+        unsafe {\n+            let end = (*self.ptr).offset(self.len as int);\n+            ptr::write(&mut *end, value);\n+            self.len += 1;\n         }\n     }\n \n-    /// Returns a mutable slice of the elements of `self`.\n+    /// Removes the last element from a vector and returns it, or `None` if it is empty.\n     ///\n     /// # Examples\n     ///\n-    /// ```\n-    /// fn foo(slice: &mut [int]) {}\n-    ///\n-    /// let mut vec = vec![1i, 2];\n-    /// foo(vec.as_mut_slice());\n+    /// ```rust\n+    /// let mut vec = vec![1i, 2, 3];\n+    /// assert_eq!(vec.pop(), Some(3));\n+    /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n     #[inline]\n     #[stable]\n-    pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n-        unsafe {\n-            mem::transmute(RawSlice {\n-                data: *self.ptr as *const T,\n-                len: self.len,\n-            })\n+    pub fn pop(&mut self) -> Option<T> {\n+        if self.len == 0 {\n+            None\n+        } else {\n+            unsafe {\n+                self.len -= 1;\n+                Some(ptr::read(self.get_unchecked(self.len())))\n+            }\n         }\n     }\n \n-    /// Creates a consuming iterator, that is, one that moves each value out of the vector (from\n-    /// start to end). The vector cannot be used after calling this.\n+    /// Creates a draining iterator that clears the `Vec` and iterates over\n+    /// the removed items from start to end.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let v = vec![\"a\".to_string(), \"b\".to_string()];\n-    ///\n-    /// for s in v.into_iter() {\n+    /// let mut v = vec![\"a\".to_string(), \"b\".to_string()];\n+    /// for s in v.drain() {\n     ///     // s has type String, not &String\n     ///     println!(\"{}\", s);\n     /// }\n+    /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> IntoIter<T> {\n+    pub fn drain<'a>(&'a mut self) -> Drain<'a, T> {\n         unsafe {\n-            let ptr = *self.ptr;\n-            let cap = self.cap;\n-            let begin = ptr as *const T;\n+            let begin = *self.ptr as *const T;\n             let end = if mem::size_of::<T>() == 0 {\n-                (ptr as uint + self.len()) as *const T\n+                (*self.ptr as uint + self.len()) as *const T\n             } else {\n-                ptr.offset(self.len() as int) as *const T\n+                (*self.ptr).offset(self.len() as int) as *const T\n             };\n-            mem::forget(self);\n-            IntoIter { allocation: ptr, cap: cap, ptr: begin, end: end }\n+            self.set_len(0);\n+            Drain {\n+                ptr: begin,\n+                end: end,\n+                marker: ContravariantLifetime,\n+            }\n         }\n     }\n \n-    /// Sets the length of a vector.\n-    ///\n-    /// This will explicitly set the size of the vector, without actually modifying its buffers, so\n-    /// it is up to the caller to ensure that the vector is actually the specified size.\n+    /// Clears the vector, removing all values.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut v = vec![1u, 2, 3, 4];\n-    /// unsafe {\n-    ///     v.set_len(1);\n-    /// }\n+    /// let mut v = vec![1i, 2, 3];\n+    ///\n+    /// v.clear();\n+    ///\n+    /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n     #[stable]\n-    pub unsafe fn set_len(&mut self, len: uint) {\n-        self.len = len;\n+    pub fn clear(&mut self) {\n+        self.truncate(0)\n     }\n \n-    /// Removes an element from anywhere in the vector and return it, replacing it with the last\n-    /// element.\n-    ///\n-    /// This does not preserve ordering, but is O(1).\n-    ///\n-    /// Returns `None` if `index` is out of bounds.\n+    /// Returns the number of elements in the vector.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut v = vec![\"foo\", \"bar\", \"baz\", \"qux\"];\n-    ///\n-    /// assert_eq!(v.swap_remove(1), Some(\"bar\"));\n-    /// assert_eq!(v, vec![\"foo\", \"qux\", \"baz\"]);\n-    ///\n-    /// assert_eq!(v.swap_remove(0), Some(\"foo\"));\n-    /// assert_eq!(v, vec![\"baz\", \"qux\"]);\n-    ///\n-    /// assert_eq!(v.swap_remove(2), None);\n+    /// let a = vec![1i, 2, 3];\n+    /// assert_eq!(a.len(), 3);\n     /// ```\n     #[inline]\n-    #[unstable = \"the naming of this function may be altered\"]\n-    pub fn swap_remove(&mut self, index: uint) -> Option<T> {\n-        let length = self.len();\n-        if length > 0 && index < length - 1 {\n-            self.swap(index, length - 1);\n-        } else if index >= length {\n-            return None\n-        }\n-        self.pop()\n-    }\n+    #[stable]\n+    pub fn len(&self) -> uint { self.len }\n \n-    /// Inserts an element at position `index` within the vector, shifting all elements after\n-    /// position `i` one position to the right.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `index` is not between `0` and the vector's length (both bounds inclusive).\n+    /// Returns `true` if the vector contains no elements.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec = vec![1i, 2, 3];\n-    /// vec.insert(1, 4);\n-    /// assert_eq!(vec, vec![1, 4, 2, 3]);\n-    /// vec.insert(4, 5);\n-    /// assert_eq!(vec, vec![1, 4, 2, 3, 5]);\n+    /// let mut v = Vec::new();\n+    /// assert!(v.is_empty());\n+    ///\n+    /// v.push(1i);\n+    /// assert!(!v.is_empty());\n     /// ```\n-    #[unstable = \"panic semantics need settling\"]\n-    pub fn insert(&mut self, index: uint, element: T) {\n-        let len = self.len();\n-        assert!(index <= len);\n-        // space for the new element\n-        self.reserve(1);\n-\n-        unsafe { // infallible\n-            // The spot to put the new value\n-            {\n-                let p = self.as_mut_ptr().offset(index as int);\n-                // Shift everything over to make space. (Duplicating the\n-                // `index`th element into two consecutive places.)\n-                ptr::copy_memory(p.offset(1), &*p, len - index);\n-                // Write it in, overwriting the first copy of the `index`th\n-                // element.\n-                ptr::write(&mut *p, element);\n-            }\n-            self.set_len(len + 1);\n-        }\n-    }\n+    #[stable]\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n-    /// Removes and returns the element at position `index` within the vector, shifting all\n-    /// elements after position `index` one position to the left. Returns `None` if `i` is out of\n-    /// bounds.\n+    /// Converts a `Vec<T>` to a `Vec<U>` where `T` and `U` have the same\n+    /// size and in case they are not zero-sized the same minimal alignment.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `T` and `U` have differing sizes or are not zero-sized and\n+    /// have differing minimal alignments.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut v = vec![1i, 2, 3];\n-    /// assert_eq!(v.remove(1), Some(2));\n-    /// assert_eq!(v, vec![1, 3]);\n+    /// let v = vec![0u, 1, 2];\n+    /// let w = v.map_in_place(|i| i + 3);\n+    /// assert_eq!(w.as_slice(), [3, 4, 5].as_slice());\n     ///\n-    /// assert_eq!(v.remove(4), None);\n-    /// // v is unchanged:\n-    /// assert_eq!(v, vec![1, 3]);\n+    /// #[deriving(PartialEq, Show)]\n+    /// struct Newtype(u8);\n+    /// let bytes = vec![0x11, 0x22];\n+    /// let newtyped_bytes = bytes.map_in_place(|x| Newtype(x));\n+    /// assert_eq!(newtyped_bytes.as_slice(), [Newtype(0x11), Newtype(0x22)].as_slice());\n     /// ```\n-    #[unstable = \"panic semantics need settling\"]\n-    pub fn remove(&mut self, index: uint) -> Option<T> {\n-        let len = self.len();\n-        if index < len {\n-            unsafe { // infallible\n-                let ret;\n-                {\n-                    // the place we are taking from.\n-                    let ptr = self.as_mut_ptr().offset(index as int);\n-                    // copy it out, unsafely having a copy of the value on\n-                    // the stack and in the vector at the same time.\n-                    ret = Some(ptr::read(ptr as *const T));\n-\n-                    // Shift everything down to fill in that spot.\n-                    ptr::copy_memory(ptr, &*ptr.offset(1), len - index - 1);\n+    #[experimental = \"API may change to provide stronger guarantees\"]\n+    pub fn map_in_place<U, F>(self, mut f: F) -> Vec<U> where F: FnMut(T) -> U {\n+        // FIXME: Assert statically that the types `T` and `U` have the same\n+        // size.\n+        assert!(mem::size_of::<T>() == mem::size_of::<U>());\n+\n+        let mut vec = self;\n+\n+        if mem::size_of::<T>() != 0 {\n+            // FIXME: Assert statically that the types `T` and `U` have the\n+            // same minimal alignment in case they are not zero-sized.\n+\n+            // These asserts are necessary because the `min_align_of` of the\n+            // types are passed to the allocator by `Vec`.\n+            assert!(mem::min_align_of::<T>() == mem::min_align_of::<U>());\n+\n+            // This `as int` cast is safe, because the size of the elements of the\n+            // vector is not 0, and:\n+            //\n+            // 1) If the size of the elements in the vector is 1, the `int` may\n+            //    overflow, but it has the correct bit pattern so that the\n+            //    `.offset()` function will work.\n+            //\n+            //    Example:\n+            //        Address space 0x0-0xF.\n+            //        `u8` array at: 0x1.\n+            //        Size of `u8` array: 0x8.\n+            //        Calculated `offset`: -0x8.\n+            //        After `array.offset(offset)`: 0x9.\n+            //        (0x1 + 0x8 = 0x1 - 0x8)\n+            //\n+            // 2) If the size of the elements in the vector is >1, the `uint` ->\n+            //    `int` conversion can't overflow.\n+            let offset = vec.len() as int;\n+            let start = vec.as_mut_ptr();\n+\n+            let mut pv = PartialVecNonZeroSized {\n+                vec: vec,\n+\n+                start_t: start,\n+                // This points inside the vector, as the vector has length\n+                // `offset`.\n+                end_t: unsafe { start.offset(offset) },\n+                start_u: start as *mut U,\n+                end_u: start as *mut U,\n+            };\n+            //  start_t\n+            //  start_u\n+            //  |\n+            // +-+-+-+-+-+-+\n+            // |T|T|T|...|T|\n+            // +-+-+-+-+-+-+\n+            //  |           |\n+            //  end_u       end_t\n+\n+            while pv.end_u as *mut T != pv.end_t {\n+                unsafe {\n+                    //  start_u start_t\n+                    //  |       |\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    // |U|...|U|T|T|...|T|\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    //          |         |\n+                    //          end_u     end_t\n+\n+                    let t = ptr::read(pv.start_t as *const T);\n+                    //  start_u start_t\n+                    //  |       |\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    // |U|...|U|X|T|...|T|\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    //          |         |\n+                    //          end_u     end_t\n+                    // We must not panic here, one cell is marked as `T`\n+                    // although it is not `T`.\n+\n+                    pv.start_t = pv.start_t.offset(1);\n+                    //  start_u   start_t\n+                    //  |         |\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    // |U|...|U|X|T|...|T|\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    //          |         |\n+                    //          end_u     end_t\n+                    // We may panic again.\n+\n+                    // The function given by the user might panic.\n+                    let u = f(t);\n+\n+                    ptr::write(pv.end_u, u);\n+                    //  start_u   start_t\n+                    //  |         |\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    // |U|...|U|U|T|...|T|\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    //          |         |\n+                    //          end_u     end_t\n+                    // We should not panic here, because that would leak the `U`\n+                    // pointed to by `end_u`.\n+\n+                    pv.end_u = pv.end_u.offset(1);\n+                    //  start_u   start_t\n+                    //  |         |\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    // |U|...|U|U|T|...|T|\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    //            |       |\n+                    //            end_u   end_t\n+                    // We may panic again.\n                 }\n-                self.set_len(len - 1);\n-                ret\n+            }\n+\n+            //  start_u     start_t\n+            //  |           |\n+            // +-+-+-+-+-+-+\n+            // |U|...|U|U|U|\n+            // +-+-+-+-+-+-+\n+            //              |\n+            //              end_t\n+            //              end_u\n+            // Extract `vec` and prevent the destructor of\n+            // `PartialVecNonZeroSized` from running. Note that none of the\n+            // function calls can panic, thus no resources can be leaked (as the\n+            // `vec` member of `PartialVec` is the only one which holds\n+            // allocations -- and it is returned from this function. None of\n+            // this can panic.\n+            unsafe {\n+                let vec_len = pv.vec.len();\n+                let vec_cap = pv.vec.capacity();\n+                let vec_ptr = pv.vec.as_mut_ptr() as *mut U;\n+                mem::forget(pv);\n+                Vec::from_raw_parts(vec_ptr, vec_len, vec_cap)\n             }\n         } else {\n-            None\n-        }\n-    }\n+            // Put the `Vec` into the `PartialVecZeroSized` structure and\n+            // prevent the destructor of the `Vec` from running. Since the\n+            // `Vec` contained zero-sized objects, it did not allocate, so we\n+            // are not leaking memory here.\n+            let mut pv = PartialVecZeroSized::<T,U> {\n+                num_t: vec.len(),\n+                num_u: 0,\n+                marker_t: InvariantType,\n+                marker_u: InvariantType,\n+            };\n+            unsafe { mem::forget(vec); }\n \n-    /// Retains only the elements specified by the predicate.\n-    ///\n-    /// In other words, remove all elements `e` such that `f(&e)` returns false. This method\n-    /// operates in place and preserves the order of the retained elements.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut vec = vec![1i, 2, 3, 4];\n-    /// vec.retain(|&x| x%2 == 0);\n-    /// assert_eq!(vec, vec![2, 4]);\n-    /// ```\n-    #[unstable = \"the closure argument may become an unboxed closure\"]\n-    pub fn retain<F>(&mut self, mut f: F) where F: FnMut(&T) -> bool {\n-        let len = self.len();\n-        let mut del = 0u;\n-        {\n-            let v = self.as_mut_slice();\n+            while pv.num_t != 0 {\n+                unsafe {\n+                    // Create a `T` out of thin air and decrement `num_t`. This\n+                    // must not panic between these steps, as otherwise a\n+                    // destructor of `T` which doesn't exist runs.\n+                    let t = mem::uninitialized();\n+                    pv.num_t -= 1;\n \n-            for i in range(0u, len) {\n-                if !f(&v[i]) {\n-                    del += 1;\n-                } else if del > 0 {\n-                    v.swap(i-del, i);\n+                    // The function given by the user might panic.\n+                    let u = f(t);\n+\n+                    // Forget the `U` and increment `num_u`. This increment\n+                    // cannot overflow the `uint` as we only do this for a\n+                    // number of times that fits into a `uint` (and start with\n+                    // `0`). Again, we should not panic between these steps.\n+                    mem::forget(u);\n+                    pv.num_u += 1;\n                 }\n             }\n-        }\n-        if del > 0 {\n-            self.truncate(len - del);\n+            // Create a `Vec` from our `PartialVecZeroSized` and make sure the\n+            // destructor of the latter will not run. None of this can panic.\n+            let mut result = Vec::new();\n+            unsafe {\n+                result.set_len(pv.num_u);\n+                mem::forget(pv);\n+            }\n+            result\n         }\n     }\n+}\n \n-    /// Expands a vector in place, initializing the new elements to the result of a function.\n-    ///\n-    /// The vector is grown by `n` elements. The i-th new element are initialized to the value\n-    /// returned by `f(i)` where `i` is in the range [0, n).\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut vec = vec![0u, 1];\n-    /// vec.grow_fn(3, |i| i);\n-    /// assert_eq!(vec, vec![0, 1, 0, 1, 2]);\n-    /// ```\n-    #[unstable = \"this function may be renamed or change to unboxed closures\"]\n-    pub fn grow_fn<F>(&mut self, n: uint, mut f: F) where F: FnMut(uint) -> T {\n-        self.reserve(n);\n-        for i in range(0u, n) {\n-            self.push(f(i));\n-        }\n+impl<T: Clone> Vec<T> {\n+    /// Deprecated: use `repeat(value).take(length).collect()` instead.\n+    #[inline]\n+    #[deprecated = \"use repeat(value).take(length).collect() instead\"]\n+    pub fn from_elem(length: uint, value: T) -> Vec<T> {\n+        repeat(value).take(length).collect()\n     }\n \n-    /// Appends an element to the back of a collection.\n-    ///\n-    /// # Panics\n+    /// Resizes the `Vec` in-place so that `len()` is equal to `new_len`.\n     ///\n-    /// Panics if the number of elements in the vector overflows a `uint`.\n+    /// Calls either `extend()` or `truncate()` depending on whether `new_len`\n+    /// is larger than the current value of `len()` or not.\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n-    /// let mut vec = vec!(1i, 2);\n-    /// vec.push(3);\n-    /// assert_eq!(vec, vec!(1, 2, 3));\n     /// ```\n-    #[inline]\n-    #[stable]\n-    pub fn push(&mut self, value: T) {\n-        if mem::size_of::<T>() == 0 {\n-            // zero-size types consume no memory, so we can't rely on the address space running out\n-            self.len = self.len.checked_add(1).expect(\"length overflow\");\n-            unsafe { mem::forget(value); }\n-            return\n-        }\n-        if self.len == self.cap {\n-            let old_size = self.cap * mem::size_of::<T>();\n-            let size = max(old_size, 2 * mem::size_of::<T>()) * 2;\n-            if old_size > size { panic!(\"capacity overflow\") }\n-            unsafe {\n-                let ptr = alloc_or_realloc(*self.ptr, old_size, size);\n-                if ptr.is_null() { ::alloc::oom() }\n-                self.ptr = NonZero::new(ptr);\n-            }\n-            self.cap = max(self.cap, 2) * 2;\n-        }\n-\n-        unsafe {\n-            let end = (*self.ptr).offset(self.len as int);\n-            ptr::write(&mut *end, value);\n-            self.len += 1;\n-        }\n-    }\n-\n-    /// Removes the last element from a vector and returns it, or `None` if it is empty.\n-    ///\n-    /// # Examples\n+    /// let mut vec = vec![\"hello\"];\n+    /// vec.resize(3, \"world\");\n+    /// assert_eq!(vec, vec![\"hello\", \"world\", \"world\"]);\n     ///\n-    /// ```rust\n-    /// let mut vec = vec![1i, 2, 3];\n-    /// assert_eq!(vec.pop(), Some(3));\n+    /// let mut vec = vec![1i, 2, 3, 4];\n+    /// vec.resize(2, 0);\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n-    #[inline]\n-    #[stable]\n-    pub fn pop(&mut self) -> Option<T> {\n-        if self.len == 0 {\n-            None\n-        } else {\n-            unsafe {\n-                self.len -= 1;\n-                Some(ptr::read(self.unsafe_get(self.len())))\n-            }\n-        }\n-    }\n+    #[unstable = \"matches collection reform specification; waiting for dust to settle\"]\n+    pub fn resize(&mut self, new_len: uint, value: T) {\n+        let len = self.len();\n \n-    /// Creates a draining iterator that clears the `Vec` and iterates over\n-    /// the removed items from start to end.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = vec![\"a\".to_string(), \"b\".to_string()];\n-    /// for s in v.drain() {\n-    ///     // s has type String, not &String\n-    ///     println!(\"{}\", s);\n-    /// }\n-    /// assert!(v.is_empty());\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn drain<'a>(&'a mut self) -> Drain<'a, T> {\n-        unsafe {\n-            let begin = *self.ptr as *const T;\n-            let end = if mem::size_of::<T>() == 0 {\n-                (*self.ptr as uint + self.len()) as *const T\n-            } else {\n-                (*self.ptr).offset(self.len() as int) as *const T\n-            };\n-            self.set_len(0);\n-            Drain {\n-                ptr: begin,\n-                end: end,\n-                marker: ContravariantLifetime,\n-            }\n+        if new_len > len {\n+            self.extend(repeat(value).take(new_len - len));\n+        } else {\n+            self.truncate(new_len);\n         }\n     }\n \n-    /// Clears the vector, removing all values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = vec![1i, 2, 3];\n+    /// Appends all elements in a slice to the `Vec`.\n     ///\n-    /// v.clear();\n-    ///\n-    /// assert!(v.is_empty());\n-    /// ```\n-    #[inline]\n-    #[stable]\n-    pub fn clear(&mut self) {\n-        self.truncate(0)\n-    }\n-\n-    /// Returns the number of elements in the vector.\n+    /// Iterates over the slice `other`, clones each element, and then appends\n+    /// it to this `Vec`. The `other` vector is traversed in-order.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let a = vec![1i, 2, 3];\n-    /// assert_eq!(a.len(), 3);\n+    /// let mut vec = vec![1i];\n+    /// vec.push_all(&[2i, 3, 4]);\n+    /// assert_eq!(vec, vec![1, 2, 3, 4]);\n     /// ```\n     #[inline]\n-    #[stable]\n-    pub fn len(&self) -> uint { self.len }\n-\n-    /// Returns `true` if the vector contains no elements.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = Vec::new();\n-    /// assert!(v.is_empty());\n-    ///\n-    /// v.push(1i);\n-    /// assert!(!v.is_empty());\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+    #[experimental = \"likely to be replaced by a more optimized extend\"]\n+    pub fn push_all(&mut self, other: &[T]) {\n+        self.reserve(other.len());\n \n-    /// Reserves capacity for exactly `capacity` elements in the given vector.\n-    ///\n-    /// If the capacity for `self` is already equal to or greater than the\n-    /// requested capacity, then no action is taken.\n-    fn grow_capacity(&mut self, capacity: uint) {\n-        if mem::size_of::<T>() == 0 { return }\n+        for i in range(0, other.len()) {\n+            let len = self.len();\n \n-        if capacity > self.cap {\n-            let size = capacity.checked_mul(mem::size_of::<T>())\n-                               .expect(\"capacity overflow\");\n-            unsafe {\n-                let ptr = alloc_or_realloc(*self.ptr, self.cap * mem::size_of::<T>(), size);\n-                if ptr.is_null() { ::alloc::oom() }\n-                self.ptr = NonZero::new(ptr);\n+            // Unsafe code so this can be optimised to a memcpy (or something similarly\n+            // fast) when T is Copy. LLVM is easily confused, so any extra operations\n+            // during the loop can prevent this optimisation.\n+            unsafe {\n+                ptr::write(\n+                    self.get_unchecked_mut(len),\n+                    other.get_unchecked(i).clone());\n+                self.set_len(len + 1);\n             }\n-            self.cap = capacity;\n         }\n     }\n+\n+    /// Deprecated: use `extend(repeat(value).take(n))` instead\n+    #[deprecated = \"use extend(repeat(value).take(n)) instead\"]\n+    pub fn grow(&mut self, n: uint, value: T) {\n+        self.extend(repeat(value).take(n))\n+    }\n+\n+    /// Deprecated: use `iter().cloned().partition(f)` instead.\n+    #[deprecated = \"use iter().cloned().partition(f) instead\"]\n+    pub fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n+        self.iter().cloned().partition(f)\n+    }\n }\n \n impl<T: PartialEq> Vec<T> {\n@@ -1267,7 +1072,7 @@ impl<T: PartialEq> Vec<T> {\n     ///\n     /// assert_eq!(vec, vec![1i, 2, 3, 2]);\n     /// ```\n-    #[unstable = \"this function may be renamed\"]\n+    #[stable]\n     pub fn dedup(&mut self) {\n         unsafe {\n             // Although we have a mutable reference to `self`, we cannot make\n@@ -1348,8 +1153,276 @@ impl<T: PartialEq> Vec<T> {\n                 r += 1;\n             }\n \n-            self.truncate(w);\n-        }\n+            self.truncate(w);\n+        }\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Public free fns\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// Deprecated: use `unzip` directly on the iterator instead.\n+#[deprecated = \"use unzip directly on the iterator instead\"]\n+pub fn unzip<T, U, V: Iterator<(T, U)>>(iter: V) -> (Vec<T>, Vec<U>) {\n+    iter.unzip()\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Internal methods and functions\n+////////////////////////////////////////////////////////////////////////////////\n+\n+impl<T> Vec<T> {\n+    /// Reserves capacity for exactly `capacity` elements in the given vector.\n+    ///\n+    /// If the capacity for `self` is already equal to or greater than the\n+    /// requested capacity, then no action is taken.\n+    fn grow_capacity(&mut self, capacity: uint) {\n+        if mem::size_of::<T>() == 0 { return }\n+\n+        if capacity > self.cap {\n+            let size = capacity.checked_mul(mem::size_of::<T>())\n+                               .expect(\"capacity overflow\");\n+            unsafe {\n+                let ptr = alloc_or_realloc(*self.ptr, self.cap * mem::size_of::<T>(), size);\n+                if ptr.is_null() { ::alloc::oom() }\n+                self.ptr = NonZero::new(ptr);\n+            }\n+            self.cap = capacity;\n+        }\n+    }\n+}\n+\n+// FIXME: #13996: need a way to mark the return value as `noalias`\n+#[inline(never)]\n+unsafe fn alloc_or_realloc<T>(ptr: *mut T, old_size: uint, size: uint) -> *mut T {\n+    if old_size == 0 {\n+        allocate(size, mem::min_align_of::<T>()) as *mut T\n+    } else {\n+        reallocate(ptr as *mut u8, old_size, size, mem::min_align_of::<T>()) as *mut T\n+    }\n+}\n+\n+#[inline]\n+unsafe fn dealloc<T>(ptr: *mut T, len: uint) {\n+    if mem::size_of::<T>() != 0 {\n+        deallocate(ptr as *mut u8,\n+                   len * mem::size_of::<T>(),\n+                   mem::min_align_of::<T>())\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Common trait implementations for Vec\n+////////////////////////////////////////////////////////////////////////////////\n+\n+#[unstable]\n+impl<T:Clone> Clone for Vec<T> {\n+    fn clone(&self) -> Vec<T> { self.as_slice().to_vec() }\n+\n+    fn clone_from(&mut self, other: &Vec<T>) {\n+        // drop anything in self that will not be overwritten\n+        if self.len() > other.len() {\n+            self.truncate(other.len())\n+        }\n+\n+        // reuse the contained values' allocations/resources.\n+        for (place, thing) in self.iter_mut().zip(other.iter()) {\n+            place.clone_from(thing)\n+        }\n+\n+        // self.len <= other.len due to the truncate above, so the\n+        // slice here is always in-bounds.\n+        let slice = other[self.len()..];\n+        self.push_all(slice);\n+    }\n+}\n+\n+impl<S: hash::Writer, T: Hash<S>> Hash<S> for Vec<T> {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        self.as_slice().hash(state);\n+    }\n+}\n+\n+#[experimental = \"waiting on Index stability\"]\n+impl<T> Index<uint,T> for Vec<T> {\n+    #[inline]\n+    fn index<'a>(&'a self, index: &uint) -> &'a T {\n+        &self.as_slice()[*index]\n+    }\n+}\n+\n+impl<T> IndexMut<uint,T> for Vec<T> {\n+    #[inline]\n+    fn index_mut<'a>(&'a mut self, index: &uint) -> &'a mut T {\n+        &mut self.as_mut_slice()[*index]\n+    }\n+}\n+\n+impl<T> ops::Slice<uint, [T]> for Vec<T> {\n+    #[inline]\n+    fn as_slice_<'a>(&'a self) -> &'a [T] {\n+        self.as_slice()\n+    }\n+\n+    #[inline]\n+    fn slice_from_or_fail<'a>(&'a self, start: &uint) -> &'a [T] {\n+        self.as_slice().slice_from_or_fail(start)\n+    }\n+\n+    #[inline]\n+    fn slice_to_or_fail<'a>(&'a self, end: &uint) -> &'a [T] {\n+        self.as_slice().slice_to_or_fail(end)\n+    }\n+    #[inline]\n+    fn slice_or_fail<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n+        self.as_slice().slice_or_fail(start, end)\n+    }\n+}\n+\n+impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n+    #[inline]\n+    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n+        self.as_mut_slice()\n+    }\n+\n+    #[inline]\n+    fn slice_from_or_fail_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n+        self.as_mut_slice().slice_from_or_fail_mut(start)\n+    }\n+\n+    #[inline]\n+    fn slice_to_or_fail_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n+        self.as_mut_slice().slice_to_or_fail_mut(end)\n+    }\n+    #[inline]\n+    fn slice_or_fail_mut<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n+        self.as_mut_slice().slice_or_fail_mut(start, end)\n+    }\n+}\n+\n+#[experimental = \"waiting on Deref stability\"]\n+impl<T> ops::Deref<[T]> for Vec<T> {\n+    fn deref<'a>(&'a self) -> &'a [T] { self.as_slice() }\n+}\n+\n+#[experimental = \"waiting on DerefMut stability\"]\n+impl<T> ops::DerefMut<[T]> for Vec<T> {\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut [T] { self.as_mut_slice() }\n+}\n+\n+#[experimental = \"waiting on FromIterator stability\"]\n+impl<T> FromIterator<T> for Vec<T> {\n+    #[inline]\n+    fn from_iter<I:Iterator<T>>(mut iterator: I) -> Vec<T> {\n+        let (lower, _) = iterator.size_hint();\n+        let mut vector = Vec::with_capacity(lower);\n+        for element in iterator {\n+            vector.push(element)\n+        }\n+        vector\n+    }\n+}\n+\n+#[experimental = \"waiting on Extend stability\"]\n+impl<T> Extend<T> for Vec<T> {\n+    #[inline]\n+    fn extend<I: Iterator<T>>(&mut self, mut iterator: I) {\n+        let (lower, _) = iterator.size_hint();\n+        self.reserve(lower);\n+        for element in iterator {\n+            self.push(element)\n+        }\n+    }\n+}\n+\n+impl<A, B> PartialEq<Vec<B>> for Vec<A> where A: PartialEq<B> {\n+    #[inline]\n+    fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &Vec<B>) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+\n+macro_rules! impl_eq {\n+    ($lhs:ty, $rhs:ty) => {\n+        impl<'b, A, B> PartialEq<$rhs> for $lhs where A: PartialEq<B> {\n+            #[inline]\n+            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n+\n+        impl<'b, A, B> PartialEq<$lhs> for $rhs where B: PartialEq<A> {\n+            #[inline]\n+            fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &$lhs) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n+    }\n+}\n+\n+impl_eq! { Vec<A>, &'b [B] }\n+impl_eq! { Vec<A>, &'b mut [B] }\n+\n+impl<'a, A, B> PartialEq<Vec<B>> for CowVec<'a, A> where A: PartialEq<B> + Clone {\n+    #[inline]\n+    fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &Vec<B>) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+\n+impl<'a, A, B> PartialEq<CowVec<'a, A>> for Vec<B> where A: Clone, B: PartialEq<A> {\n+    #[inline]\n+    fn eq(&self, other: &CowVec<'a, A>) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &CowVec<'a, A>) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+\n+macro_rules! impl_eq_for_cowvec {\n+    ($rhs:ty) => {\n+        impl<'a, 'b, A, B> PartialEq<$rhs> for CowVec<'a, A> where A: PartialEq<B> + Clone {\n+            #[inline]\n+            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n+\n+        impl<'a, 'b, A, B> PartialEq<CowVec<'a, A>> for $rhs where A: Clone, B: PartialEq<A> {\n+            #[inline]\n+            fn eq(&self, other: &CowVec<'a, A>) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &CowVec<'a, A>) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n+    }\n+}\n+\n+impl_eq_for_cowvec! { &'b [B] }\n+impl_eq_for_cowvec! { &'b mut [B] }\n+\n+#[unstable = \"waiting on PartialOrd stability\"]\n+impl<T: PartialOrd> PartialOrd for Vec<T> {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n+        self.as_slice().partial_cmp(other.as_slice())\n+    }\n+}\n+\n+#[unstable = \"waiting on Eq stability\"]\n+impl<T: Eq> Eq for Vec<T> {}\n+\n+#[allow(deprecated)]\n+#[deprecated = \"Use overloaded `core::cmp::PartialEq`\"]\n+impl<T: PartialEq, Sized? V: AsSlice<T>> Equiv<V> for Vec<T> {\n+    #[inline]\n+    fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n+}\n+\n+#[unstable = \"waiting on Ord stability\"]\n+impl<T: Ord> Ord for Vec<T> {\n+    #[inline]\n+    fn cmp(&self, other: &Vec<T>) -> Ordering {\n+        self.as_slice().cmp(other.as_slice())\n     }\n }\n \n@@ -1415,17 +1488,58 @@ impl<T:fmt::Show> fmt::Show for Vec<T> {\n     }\n }\n \n+impl<'a> fmt::FormatWriter for Vec<u8> {\n+    fn write(&mut self, buf: &[u8]) -> fmt::Result {\n+        self.push_all(buf);\n+        Ok(())\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Clone-on-write\n+////////////////////////////////////////////////////////////////////////////////\n+\n+#[experimental = \"unclear how valuable this alias is\"]\n+/// A clone-on-write vector\n+pub type CowVec<'a, T> = Cow<'a, Vec<T>, [T]>;\n+\n+impl<'a, T> FromIterator<T> for CowVec<'a, T> where T: Clone {\n+    fn from_iter<I: Iterator<T>>(it: I) -> CowVec<'a, T> {\n+        Cow::Owned(FromIterator::from_iter(it))\n+    }\n+}\n+\n+impl<'a, T: 'a> IntoCow<'a, Vec<T>, [T]> for Vec<T> where T: Clone {\n+    fn into_cow(self) -> CowVec<'a, T> {\n+        Cow::Owned(self)\n+    }\n+}\n+\n+impl<'a, T> IntoCow<'a, Vec<T>, [T]> for &'a [T] where T: Clone {\n+    fn into_cow(self) -> CowVec<'a, T> {\n+        Cow::Borrowed(self)\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Iterators\n+////////////////////////////////////////////////////////////////////////////////\n+\n /// An iterator that moves out of a vector.\n+#[stable]\n pub struct IntoIter<T> {\n     allocation: *mut T, // the block of memory allocated for the vector\n     cap: uint, // the capacity of the vector\n     ptr: *const T,\n     end: *const T\n }\n \n+#[deprecated = \"use IntoIter instead\"]\n+pub type MoveItems<T> = IntoIter<T>;\n+\n impl<T> IntoIter<T> {\n-    /// Drops all items that have not yet been moved and returns the empty vector.\n     #[inline]\n+    /// Drops all items that have not yet been moved and returns the empty vector.\n     #[unstable]\n     pub fn into_inner(mut self) -> Vec<T> {\n         unsafe {\n@@ -1515,6 +1629,7 @@ impl<T> Drop for IntoIter<T> {\n \n /// An iterator that drains a vector.\n #[unsafe_no_drop_flag]\n+#[unstable = \"recently added as part of collections reform 2\"]\n pub struct Drain<'a, T> {\n     ptr: *const T,\n     end: *const T,\n@@ -1591,22 +1706,9 @@ impl<'a, T> Drop for Drain<'a, T> {\n     }\n }\n \n-/// Converts an iterator of pairs into a pair of vectors.\n-///\n-/// Returns a tuple containing two vectors where the i-th element of the first vector contains the\n-/// first element of the i-th tuple of the input iterator, and the i-th element of the second\n-/// vector contains the second element of the i-th tuple of the input iterator.\n-#[unstable = \"this functionality may become more generic over time\"]\n-pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (Vec<T>, Vec<U>) {\n-    let (lo, _) = iter.size_hint();\n-    let mut ts = Vec::with_capacity(lo);\n-    let mut us = Vec::with_capacity(lo);\n-    for (t, u) in iter {\n-        ts.push(t);\n-        us.push(u);\n-    }\n-    (ts, us)\n-}\n+////////////////////////////////////////////////////////////////////////////////\n+// Conversion from &[T] to &Vec<T>\n+////////////////////////////////////////////////////////////////////////////////\n \n /// Wrapper type providing a `&Vec<T>` reference via `Deref`.\n #[experimental]\n@@ -1615,6 +1717,7 @@ pub struct DerefVec<'a, T> {\n     l: ContravariantLifetime<'a>\n }\n \n+#[experimental]\n impl<'a, T> Deref<Vec<T>> for DerefVec<'a, T> {\n     fn deref<'b>(&'b self) -> &'b Vec<T> {\n         &self.x\n@@ -1623,6 +1726,7 @@ impl<'a, T> Deref<Vec<T>> for DerefVec<'a, T> {\n \n // Prevent the inner `Vec<T>` from attempting to deallocate memory.\n #[unsafe_destructor]\n+#[experimental]\n impl<'a, T> Drop for DerefVec<'a, T> {\n     fn drop(&mut self) {\n         self.x.len = 0;\n@@ -1641,6 +1745,10 @@ pub fn as_vec<'a, T>(x: &'a [T]) -> DerefVec<'a, T> {\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Raw module (deprecated)\n+////////////////////////////////////////////////////////////////////////////////\n+\n /// Unsafe vector operations.\n #[deprecated]\n pub mod raw {\n@@ -1657,6 +1765,10 @@ pub mod raw {\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Partial vec, used for map_in_place\n+////////////////////////////////////////////////////////////////////////////////\n+\n /// An owned, partially type-converted vector of elements with non-zero size.\n ///\n /// `T` and `U` must have the same, non-zero size. They must also have the same\n@@ -1728,211 +1840,6 @@ impl<T,U> Drop for PartialVecZeroSized<T,U> {\n     }\n }\n \n-impl<T> Vec<T> {\n-    /// Converts a `Vec<T>` to a `Vec<U>` where `T` and `U` have the same\n-    /// size and in case they are not zero-sized the same minimal alignment.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `T` and `U` have differing sizes or are not zero-sized and\n-    /// have differing minimal alignments.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = vec![0u, 1, 2];\n-    /// let w = v.map_in_place(|i| i + 3);\n-    /// assert_eq!(w.as_slice(), [3, 4, 5].as_slice());\n-    ///\n-    /// #[deriving(PartialEq, Show)]\n-    /// struct Newtype(u8);\n-    /// let bytes = vec![0x11, 0x22];\n-    /// let newtyped_bytes = bytes.map_in_place(|x| Newtype(x));\n-    /// assert_eq!(newtyped_bytes.as_slice(), [Newtype(0x11), Newtype(0x22)].as_slice());\n-    /// ```\n-    pub fn map_in_place<U, F>(self, mut f: F) -> Vec<U> where F: FnMut(T) -> U {\n-        // FIXME: Assert statically that the types `T` and `U` have the same\n-        // size.\n-        assert!(mem::size_of::<T>() == mem::size_of::<U>());\n-\n-        let mut vec = self;\n-\n-        if mem::size_of::<T>() != 0 {\n-            // FIXME: Assert statically that the types `T` and `U` have the\n-            // same minimal alignment in case they are not zero-sized.\n-\n-            // These asserts are necessary because the `min_align_of` of the\n-            // types are passed to the allocator by `Vec`.\n-            assert!(mem::min_align_of::<T>() == mem::min_align_of::<U>());\n-\n-            // This `as int` cast is safe, because the size of the elements of the\n-            // vector is not 0, and:\n-            //\n-            // 1) If the size of the elements in the vector is 1, the `int` may\n-            //    overflow, but it has the correct bit pattern so that the\n-            //    `.offset()` function will work.\n-            //\n-            //    Example:\n-            //        Address space 0x0-0xF.\n-            //        `u8` array at: 0x1.\n-            //        Size of `u8` array: 0x8.\n-            //        Calculated `offset`: -0x8.\n-            //        After `array.offset(offset)`: 0x9.\n-            //        (0x1 + 0x8 = 0x1 - 0x8)\n-            //\n-            // 2) If the size of the elements in the vector is >1, the `uint` ->\n-            //    `int` conversion can't overflow.\n-            let offset = vec.len() as int;\n-            let start = vec.as_mut_ptr();\n-\n-            let mut pv = PartialVecNonZeroSized {\n-                vec: vec,\n-\n-                start_t: start,\n-                // This points inside the vector, as the vector has length\n-                // `offset`.\n-                end_t: unsafe { start.offset(offset) },\n-                start_u: start as *mut U,\n-                end_u: start as *mut U,\n-            };\n-            //  start_t\n-            //  start_u\n-            //  |\n-            // +-+-+-+-+-+-+\n-            // |T|T|T|...|T|\n-            // +-+-+-+-+-+-+\n-            //  |           |\n-            //  end_u       end_t\n-\n-            while pv.end_u as *mut T != pv.end_t {\n-                unsafe {\n-                    //  start_u start_t\n-                    //  |       |\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    // |U|...|U|T|T|...|T|\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    //          |         |\n-                    //          end_u     end_t\n-\n-                    let t = ptr::read(pv.start_t as *const T);\n-                    //  start_u start_t\n-                    //  |       |\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    // |U|...|U|X|T|...|T|\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    //          |         |\n-                    //          end_u     end_t\n-                    // We must not panic here, one cell is marked as `T`\n-                    // although it is not `T`.\n-\n-                    pv.start_t = pv.start_t.offset(1);\n-                    //  start_u   start_t\n-                    //  |         |\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    // |U|...|U|X|T|...|T|\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    //          |         |\n-                    //          end_u     end_t\n-                    // We may panic again.\n-\n-                    // The function given by the user might panic.\n-                    let u = f(t);\n-\n-                    ptr::write(pv.end_u, u);\n-                    //  start_u   start_t\n-                    //  |         |\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    // |U|...|U|U|T|...|T|\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    //          |         |\n-                    //          end_u     end_t\n-                    // We should not panic here, because that would leak the `U`\n-                    // pointed to by `end_u`.\n-\n-                    pv.end_u = pv.end_u.offset(1);\n-                    //  start_u   start_t\n-                    //  |         |\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    // |U|...|U|U|T|...|T|\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    //            |       |\n-                    //            end_u   end_t\n-                    // We may panic again.\n-                }\n-            }\n-\n-            //  start_u     start_t\n-            //  |           |\n-            // +-+-+-+-+-+-+\n-            // |U|...|U|U|U|\n-            // +-+-+-+-+-+-+\n-            //              |\n-            //              end_t\n-            //              end_u\n-            // Extract `vec` and prevent the destructor of\n-            // `PartialVecNonZeroSized` from running. Note that none of the\n-            // function calls can panic, thus no resources can be leaked (as the\n-            // `vec` member of `PartialVec` is the only one which holds\n-            // allocations -- and it is returned from this function. None of\n-            // this can panic.\n-            unsafe {\n-                let vec_len = pv.vec.len();\n-                let vec_cap = pv.vec.capacity();\n-                let vec_ptr = pv.vec.as_mut_ptr() as *mut U;\n-                mem::forget(pv);\n-                Vec::from_raw_parts(vec_ptr, vec_len, vec_cap)\n-            }\n-        } else {\n-            // Put the `Vec` into the `PartialVecZeroSized` structure and\n-            // prevent the destructor of the `Vec` from running. Since the\n-            // `Vec` contained zero-sized objects, it did not allocate, so we\n-            // are not leaking memory here.\n-            let mut pv = PartialVecZeroSized::<T,U> {\n-                num_t: vec.len(),\n-                num_u: 0,\n-                marker_t: InvariantType,\n-                marker_u: InvariantType,\n-            };\n-            unsafe { mem::forget(vec); }\n-\n-            while pv.num_t != 0 {\n-                unsafe {\n-                    // Create a `T` out of thin air and decrement `num_t`. This\n-                    // must not panic between these steps, as otherwise a\n-                    // destructor of `T` which doesn't exist runs.\n-                    let t = mem::uninitialized();\n-                    pv.num_t -= 1;\n-\n-                    // The function given by the user might panic.\n-                    let u = f(t);\n-\n-                    // Forget the `U` and increment `num_u`. This increment\n-                    // cannot overflow the `uint` as we only do this for a\n-                    // number of times that fits into a `uint` (and start with\n-                    // `0`). Again, we should not panic between these steps.\n-                    mem::forget(u);\n-                    pv.num_u += 1;\n-                }\n-            }\n-            // Create a `Vec` from our `PartialVecZeroSized` and make sure the\n-            // destructor of the latter will not run. None of this can panic.\n-            let mut result = Vec::new();\n-            unsafe {\n-                result.set_len(pv.num_u);\n-                mem::forget(pv);\n-            }\n-            result\n-        }\n-    }\n-}\n-\n-impl<'a> fmt::FormatWriter for Vec<u8> {\n-    fn write(&mut self, buf: &[u8]) -> fmt::Result {\n-        self.push_all(buf);\n-        Ok(())\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n@@ -2300,9 +2207,10 @@ mod tests {\n     }\n \n     #[test]\n+    #[should_fail]\n     fn test_swap_remove_empty() {\n         let mut vec: Vec<uint> = vec!();\n-        assert_eq!(vec.swap_remove(0), None);\n+        vec.swap_remove(0);\n     }\n \n     #[test]"}, {"sha": "3a7168094fff43db9ce5bb71642e72c397aeb2e3", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -448,7 +448,7 @@ impl<V> VecMap<V> {\n     pub fn insert(&mut self, key: uint, value: V) -> Option<V> {\n         let len = self.v.len();\n         if len <= key {\n-            self.v.grow_fn(key - len + 1, |_| None);\n+            self.v.extend(range(0, key - len + 1).map(|_| None));\n         }\n         replace(&mut self.v[key], Some(value))\n     }"}, {"sha": "b0fd52896fe5726b078dba2e63b0162e454fa348", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 80, "deletions": 15, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -59,6 +59,7 @@ pub use self::MinMaxResult::*;\n use clone::Clone;\n use cmp;\n use cmp::Ord;\n+use default::Default;\n use mem;\n use num::{ToPrimitive, Int};\n use ops::{Add, Deref, FnMut};\n@@ -68,20 +69,6 @@ use uint;\n \n #[deprecated = \"renamed to Extend\"] pub use self::Extend as Extendable;\n \n-/// Conversion from an `Iterator`\n-#[unstable = \"may be replaced by a more general conversion trait\"]\n-pub trait FromIterator<A> {\n-    /// Build a container with elements from an external iterator.\n-    fn from_iter<T: Iterator<A>>(iterator: T) -> Self;\n-}\n-\n-/// A type growable from an `Iterator` implementation\n-#[unstable = \"just renamed as part of collections reform\"]\n-pub trait Extend<A> {\n-    /// Extend a container with the elements yielded by an arbitrary iterator\n-    fn extend<T: Iterator<A>>(&mut self, iterator: T);\n-}\n-\n /// An interface for dealing with \"external iterators\". These types of iterators\n /// can be resumed at any time as all state is stored internally as opposed to\n /// being located on the call stack.\n@@ -106,6 +93,20 @@ pub trait Iterator<A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { (0, None) }\n }\n \n+/// Conversion from an `Iterator`\n+#[unstable = \"may be replaced by a more general conversion trait\"]\n+pub trait FromIterator<A> {\n+    /// Build a container with elements from an external iterator.\n+    fn from_iter<T: Iterator<A>>(iterator: T) -> Self;\n+}\n+\n+/// A type growable from an `Iterator` implementation\n+#[unstable = \"just renamed as part of collections reform\"]\n+pub trait Extend<A> {\n+    /// Extend a container with the elements yielded by an arbitrary iterator\n+    fn extend<T: Iterator<A>>(&mut self, iterator: T);\n+}\n+\n #[unstable = \"new convention for extension traits\"]\n /// An extension trait providing numerous methods applicable to all iterators.\n pub trait IteratorExt<A>: Iterator<A> {\n@@ -223,7 +224,6 @@ pub trait IteratorExt<A>: Iterator<A> {\n         Enumerate{iter: self, count: 0}\n     }\n \n-\n     /// Creates an iterator that has a `.peek()` method\n     /// that returns an optional reference to the next element.\n     ///\n@@ -471,6 +471,35 @@ pub trait IteratorExt<A>: Iterator<A> {\n         FromIterator::from_iter(self)\n     }\n \n+    /// Loops through the entire iterator, collecting all of the elements into\n+    /// one of two containers, depending on a predicate. The elements of the\n+    /// first container satisfy the predicate, while the elements of the second\n+    /// do not.\n+    ///\n+    /// ```\n+    /// let vec = vec![1i, 2i, 3i, 4i];\n+    /// let (even, odd): (Vec<int>, Vec<int>) = vec.into_iter().partition(|&n| n % 2 == 0);\n+    /// assert_eq!(even, vec![2, 4]);\n+    /// assert_eq!(odd, vec![1, 3]);\n+    /// ```\n+    #[unstable = \"recently added as part of collections reform\"]\n+    fn partition<B, F>(mut self, mut f: F) -> (B, B) where\n+        B: Default + Extend<A>, F: FnMut(&A) -> bool\n+    {\n+        let mut left: B = Default::default();\n+        let mut right: B = Default::default();\n+\n+        for x in self {\n+            if f(&x) {\n+                left.extend(Some(x).into_iter())\n+            } else {\n+                right.extend(Some(x).into_iter())\n+            }\n+        }\n+\n+        (left, right)\n+    }\n+\n     /// Loops through `n` iterations, returning the `n`th element of the\n     /// iterator.\n     ///\n@@ -661,6 +690,42 @@ pub trait IteratorExt<A>: Iterator<A> {\n #[unstable = \"trait is unstable\"]\n impl<A, I> IteratorExt<A> for I where I: Iterator<A> {}\n \n+/// Extention trait for iterators of pairs.\n+#[unstable = \"newly added trait, likely to be merged with IteratorExt\"]\n+pub trait IteratorPairExt<A, B>: Iterator<(A, B)> {\n+    /// Converts an iterator of pairs into a pair of containers.\n+    ///\n+    /// Loops through the entire iterator, collecting the first component of\n+    /// each item into one new container, and the second component into another.\n+    fn unzip<FromA, FromB>(mut self) -> (FromA, FromB) where\n+        FromA: Default + Extend<A>, FromB: Default + Extend<B>\n+    {\n+        struct SizeHint<A>(uint, Option<uint>);\n+        impl<A> Iterator<A> for SizeHint<A> {\n+            fn next(&mut self) -> Option<A> { None }\n+            fn size_hint(&self) -> (uint, Option<uint>) {\n+                (self.0, self.1)\n+            }\n+        }\n+\n+        let (lo, hi) = self.size_hint();\n+        let mut ts: FromA = Default::default();\n+        let mut us: FromB = Default::default();\n+\n+        ts.extend(SizeHint(lo, hi));\n+        us.extend(SizeHint(lo, hi));\n+\n+        for (t, u) in self {\n+            ts.extend(Some(t).into_iter());\n+            us.extend(Some(u).into_iter());\n+        }\n+\n+        (ts, us)\n+    }\n+}\n+\n+impl<A, B, I> IteratorPairExt<A, B> for I where I: Iterator<(A, B)> {}\n+\n /// A range iterator able to yield elements from both ends\n ///\n /// A `DoubleEndedIterator` can be thought of as a deque in that `next()` and `next_back()` exhaust"}, {"sha": "cecb49381538035f4c309205994f5e193e082129", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -52,7 +52,7 @@ pub use cmp::{Ordering, Equiv};\n pub use cmp::Ordering::{Less, Equal, Greater};\n pub use iter::{FromIterator, Extend, IteratorExt};\n pub use iter::{Iterator, DoubleEndedIterator, DoubleEndedIteratorExt, RandomAccessIterator};\n-pub use iter::{IteratorCloneExt, CloneIteratorExt};\n+pub use iter::{IteratorCloneExt, CloneIteratorExt, IteratorPairExt};\n pub use iter::{IteratorOrdExt, MutableDoubleEndedIterator, ExactSizeIterator};\n pub use num::{ToPrimitive, FromPrimitive};\n pub use option::Option;"}, {"sha": "7d894ac697be280f339a7e1454967a460280d66d", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 171, "deletions": 159, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -46,6 +46,8 @@ use num::Int;\n use ops::{FnMut, mod};\n use option::Option;\n use option::Option::{None, Some};\n+use result::Result;\n+use result::Result::{Ok, Err};\n use ptr;\n use ptr::PtrExt;\n use mem;\n@@ -68,23 +70,23 @@ pub trait SliceExt<T> for Sized? {\n     fn slice_to<'a>(&'a self, end: uint) -> &'a [T];\n     fn split_at<'a>(&'a self, mid: uint) -> (&'a [T], &'a [T]);\n     fn iter<'a>(&'a self) -> Iter<'a, T>;\n-    fn split<'a, P>(&'a self, pred: P) -> Splits<'a, T, P>\n+    fn split<'a, P>(&'a self, pred: P) -> Split<'a, T, P>\n                     where P: FnMut(&T) -> bool;\n-    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitsN<Splits<'a, T, P>>\n+    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitN<'a, T, P>\n                      where P: FnMut(&T) -> bool;\n-    fn rsplitn<'a, P>(&'a self,  n: uint, pred: P) -> SplitsN<Splits<'a, T, P>>\n+    fn rsplitn<'a, P>(&'a self,  n: uint, pred: P) -> RSplitN<'a, T, P>\n                       where P: FnMut(&T) -> bool;\n     fn windows<'a>(&'a self, size: uint) -> Windows<'a, T>;\n     fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, T>;\n     fn get<'a>(&'a self, index: uint) -> Option<&'a T>;\n-    fn head<'a>(&'a self) -> Option<&'a T>;\n+    fn first<'a>(&'a self) -> Option<&'a T>;\n     fn tail<'a>(&'a self) -> &'a [T];\n     fn init<'a>(&'a self) -> &'a [T];\n     fn last<'a>(&'a self) -> Option<&'a T>;\n-    unsafe fn unsafe_get<'a>(&'a self, index: uint) -> &'a T;\n+    unsafe fn get_unchecked<'a>(&'a self, index: uint) -> &'a T;\n     fn as_ptr(&self) -> *const T;\n-    fn binary_search<F>(&self, f: F) -> BinarySearchResult\n-                        where F: FnMut(&T) -> Ordering;\n+    fn binary_search_by<F>(&self, f: F) -> Result<uint, uint> where\n+        F: FnMut(&T) -> Ordering;\n     fn len(&self) -> uint;\n     fn is_empty(&self) -> bool { self.len() == 0 }\n     fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T>;\n@@ -93,21 +95,21 @@ pub trait SliceExt<T> for Sized? {\n     fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T];\n     fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T];\n     fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T>;\n-    fn head_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n+    fn first_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n     fn tail_mut<'a>(&'a mut self) -> &'a mut [T];\n     fn init_mut<'a>(&'a mut self) -> &'a mut [T];\n     fn last_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n-    fn split_mut<'a, P>(&'a mut self, pred: P) -> MutSplits<'a, T, P>\n+    fn split_mut<'a, P>(&'a mut self, pred: P) -> SplitMut<'a, T, P>\n                         where P: FnMut(&T) -> bool;\n-    fn splitn_mut<P>(&mut self, n: uint, pred: P) -> SplitsN<MutSplits<T, P>>\n+    fn splitn_mut<P>(&mut self, n: uint, pred: P) -> SplitNMut<T, P>\n                      where P: FnMut(&T) -> bool;\n-    fn rsplitn_mut<P>(&mut self,  n: uint, pred: P) -> SplitsN<MutSplits<T, P>>\n+    fn rsplitn_mut<P>(&mut self,  n: uint, pred: P) -> RSplitNMut<T, P>\n                       where P: FnMut(&T) -> bool;\n-    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> MutChunks<'a, T>;\n+    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> ChunksMut<'a, T>;\n     fn swap(&mut self, a: uint, b: uint);\n     fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]);\n     fn reverse(&mut self);\n-    unsafe fn unsafe_mut<'a>(&'a mut self, index: uint) -> &'a mut T;\n+    unsafe fn get_unchecked_mut<'a>(&'a mut self, index: uint) -> &'a mut T;\n     fn as_mut_ptr(&mut self) -> *mut T;\n }\n \n@@ -145,45 +147,49 @@ impl<T> SliceExt<T> for [T] {\n         unsafe {\n             let p = self.as_ptr();\n             if mem::size_of::<T>() == 0 {\n-                Iter{ptr: p,\n+                Iter {ptr: p,\n                       end: (p as uint + self.len()) as *const T,\n                       marker: marker::ContravariantLifetime::<'a>}\n             } else {\n-                Iter{ptr: p,\n+                Iter {ptr: p,\n                       end: p.offset(self.len() as int),\n                       marker: marker::ContravariantLifetime::<'a>}\n             }\n         }\n     }\n \n     #[inline]\n-    fn split<'a, P>(&'a self, pred: P) -> Splits<'a, T, P> where P: FnMut(&T) -> bool {\n-        Splits {\n+    fn split<'a, P>(&'a self, pred: P) -> Split<'a, T, P> where P: FnMut(&T) -> bool {\n+        Split {\n             v: self,\n             pred: pred,\n             finished: false\n         }\n     }\n \n     #[inline]\n-    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitsN<Splits<'a, T, P>> where\n+    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitN<'a, T, P> where\n         P: FnMut(&T) -> bool,\n     {\n-        SplitsN {\n-            iter: self.split(pred),\n-            count: n,\n-            invert: false\n+        SplitN {\n+            inner: GenericSplitN {\n+                iter: self.split(pred),\n+                count: n,\n+                invert: false\n+            }\n         }\n     }\n \n     #[inline]\n-    fn rsplitn<'a, P>(&'a self, n: uint, pred: P) -> SplitsN<Splits<'a, T, P>> where\n+    fn rsplitn<'a, P>(&'a self, n: uint, pred: P) -> RSplitN<'a, T, P> where\n         P: FnMut(&T) -> bool,\n     {\n-        SplitsN {\n-            iter: self.split(pred),\n-            count: n,\n-            invert: true\n+        RSplitN {\n+            inner: GenericSplitN {\n+                iter: self.split(pred),\n+                count: n,\n+                invert: true\n+            }\n         }\n     }\n \n@@ -205,7 +211,7 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[inline]\n-    fn head(&self) -> Option<&T> {\n+    fn first(&self) -> Option<&T> {\n         if self.len() == 0 { None } else { Some(&self[0]) }\n     }\n \n@@ -223,7 +229,7 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[inline]\n-    unsafe fn unsafe_get(&self, index: uint) -> &T {\n+    unsafe fn get_unchecked(&self, index: uint) -> &T {\n         transmute(self.repr().data.offset(index as int))\n     }\n \n@@ -233,14 +239,16 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[unstable]\n-    fn binary_search<F>(&self, mut f: F) -> BinarySearchResult where F: FnMut(&T) -> Ordering {\n+    fn binary_search_by<F>(&self, mut f: F) -> Result<uint, uint> where\n+        F: FnMut(&T) -> Ordering\n+    {\n         let mut base : uint = 0;\n         let mut lim : uint = self.len();\n \n         while lim != 0 {\n             let ix = base + (lim >> 1);\n             match f(&self[ix]) {\n-                Equal => return BinarySearchResult::Found(ix),\n+                Equal => return Ok(ix),\n                 Less => {\n                     base = ix + 1;\n                     lim -= 1;\n@@ -249,7 +257,7 @@ impl<T> SliceExt<T> for [T] {\n             }\n             lim >>= 1;\n         }\n-        return BinarySearchResult::NotFound(base);\n+        Err(base)\n     }\n \n     #[inline]\n@@ -292,11 +300,11 @@ impl<T> SliceExt<T> for [T] {\n         unsafe {\n             let p = self.as_mut_ptr();\n             if mem::size_of::<T>() == 0 {\n-                IterMut{ptr: p,\n+                IterMut {ptr: p,\n                          end: (p as uint + self.len()) as *mut T,\n                          marker: marker::ContravariantLifetime::<'a>}\n             } else {\n-                IterMut{ptr: p,\n+                IterMut {ptr: p,\n                          end: p.offset(self.len() as int),\n                          marker: marker::ContravariantLifetime::<'a>}\n             }\n@@ -311,7 +319,7 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[inline]\n-    fn head_mut(&mut self) -> Option<&mut T> {\n+    fn first_mut(&mut self) -> Option<&mut T> {\n         if self.len() == 0 { None } else { Some(&mut self[0]) }\n     }\n \n@@ -327,36 +335,40 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[inline]\n-    fn split_mut<'a, P>(&'a mut self, pred: P) -> MutSplits<'a, T, P> where P: FnMut(&T) -> bool {\n-        MutSplits { v: self, pred: pred, finished: false }\n+    fn split_mut<'a, P>(&'a mut self, pred: P) -> SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n+        SplitMut { v: self, pred: pred, finished: false }\n     }\n \n     #[inline]\n-    fn splitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> SplitsN<MutSplits<'a, T, P>> where\n+    fn splitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> SplitNMut<'a, T, P> where\n         P: FnMut(&T) -> bool\n     {\n-        SplitsN {\n-            iter: self.split_mut(pred),\n-            count: n,\n-            invert: false\n+        SplitNMut {\n+            inner: GenericSplitN {\n+                iter: self.split_mut(pred),\n+                count: n,\n+                invert: false\n+            }\n         }\n     }\n \n     #[inline]\n-    fn rsplitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> SplitsN<MutSplits<'a, T, P>> where\n+    fn rsplitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> RSplitNMut<'a, T, P> where\n         P: FnMut(&T) -> bool,\n     {\n-        SplitsN {\n-            iter: self.split_mut(pred),\n-            count: n,\n-            invert: true\n+        RSplitNMut {\n+            inner: GenericSplitN {\n+                iter: self.split_mut(pred),\n+                count: n,\n+                invert: true\n+            }\n         }\n    }\n \n     #[inline]\n-    fn chunks_mut(&mut self, chunk_size: uint) -> MutChunks<T> {\n+    fn chunks_mut(&mut self, chunk_size: uint) -> ChunksMut<T> {\n         assert!(chunk_size > 0);\n-        MutChunks { v: self, chunk_size: chunk_size }\n+        ChunksMut { v: self, chunk_size: chunk_size }\n     }\n \n     fn swap(&mut self, a: uint, b: uint) {\n@@ -375,16 +387,16 @@ impl<T> SliceExt<T> for [T] {\n         while i < ln / 2 {\n             // Unsafe swap to avoid the bounds check in safe swap.\n             unsafe {\n-                let pa: *mut T = self.unsafe_mut(i);\n-                let pb: *mut T = self.unsafe_mut(ln - i - 1);\n+                let pa: *mut T = self.get_unchecked_mut(i);\n+                let pb: *mut T = self.get_unchecked_mut(ln - i - 1);\n                 ptr::swap(pa, pb);\n             }\n             i += 1;\n         }\n     }\n \n     #[inline]\n-    unsafe fn unsafe_mut(&mut self, index: uint) -> &mut T {\n+    unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut T {\n         transmute((self.repr().data as *mut T).offset(index as int))\n     }\n \n@@ -468,21 +480,26 @@ impl<T> ops::SliceMut<uint, [T]> for [T] {\n }\n \n /// Extension methods for slices containing `PartialEq` elements.\n-#[unstable = \"may merge with other traits\"]\n+#[unstable = \"may merge with SliceExt\"]\n pub trait PartialEqSliceExt<T: PartialEq> for Sized? {\n     /// Find the first index containing a matching value.\n+    #[experimental]\n     fn position_elem(&self, t: &T) -> Option<uint>;\n \n     /// Find the last index containing a matching value.\n+    #[experimental]\n     fn rposition_elem(&self, t: &T) -> Option<uint>;\n \n     /// Return true if the slice contains an element with the given value.\n+    #[stable]\n     fn contains(&self, x: &T) -> bool;\n \n     /// Returns true if `needle` is a prefix of the slice.\n+    #[stable]\n     fn starts_with(&self, needle: &[T]) -> bool;\n \n     /// Returns true if `needle` is a suffix of the slice.\n+    #[stable]\n     fn ends_with(&self, needle: &[T]) -> bool;\n }\n \n@@ -520,19 +537,16 @@ impl<T: PartialEq> PartialEqSliceExt<T> for [T] {\n #[unstable = \"may merge with other traits\"]\n #[allow(missing_docs)] // docs in libcollections\n pub trait OrdSliceExt<T: Ord> for Sized? {\n-    #[unstable = \"name likely to change\"]\n-    fn binary_search_elem(&self, x: &T) -> BinarySearchResult;\n-    #[experimental]\n+    fn binary_search(&self, x: &T) -> Result<uint, uint>;\n     fn next_permutation(&mut self) -> bool;\n-    #[experimental]\n     fn prev_permutation(&mut self) -> bool;\n }\n \n #[unstable = \"trait is unstable\"]\n impl<T: Ord> OrdSliceExt<T> for [T] {\n     #[unstable]\n-    fn binary_search_elem(&self, x: &T) -> BinarySearchResult {\n-        self.binary_search(|p| p.cmp(x))\n+    fn binary_search(&self, x: &T) -> Result<uint, uint> {\n+        self.binary_search_by(|p| p.cmp(x))\n     }\n \n     #[experimental]\n@@ -619,28 +633,30 @@ impl<T: Clone> CloneSliceExt<T> for [T] {\n     }\n }\n \n-//\n+////////////////////////////////////////////////////////////////////////////////\n // Common traits\n-//\n+////////////////////////////////////////////////////////////////////////////////\n \n /// Data that is viewable as a slice.\n-#[unstable = \"may merge with other traits\"]\n+#[experimental = \"will be replaced by slice syntax\"]\n pub trait AsSlice<T> for Sized? {\n     /// Work with `self` as a slice.\n     fn as_slice<'a>(&'a self) -> &'a [T];\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[experimental = \"trait is experimental\"]\n impl<T> AsSlice<T> for [T] {\n     #[inline(always)]\n     fn as_slice<'a>(&'a self) -> &'a [T] { self }\n }\n \n+#[experimental = \"trait is experimental\"]\n impl<'a, T, Sized? U: AsSlice<T>> AsSlice<T> for &'a U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }\n \n+#[experimental = \"trait is experimental\"]\n impl<'a, T, Sized? U: AsSlice<T>> AsSlice<T> for &'a mut U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n@@ -656,7 +672,7 @@ impl<'a, T> Default for &'a [T] {\n // Iterators\n //\n \n-// The shared definition of the `Item` and `IterMut` iterators\n+// The shared definition of the `Iter` and `IterMut` iterators\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n         #[experimental = \"needs review\"]\n@@ -736,9 +752,8 @@ macro_rules! make_slice {\n     }}\n }\n \n-\n /// Immutable slice iterator\n-#[experimental = \"needs review\"]\n+#[stable]\n pub struct Iter<'a, T: 'a> {\n     ptr: *const T,\n     end: *const T,\n@@ -813,7 +828,7 @@ impl<'a, T> RandomAccessIterator<&'a T> for Iter<'a, T> {\n }\n \n /// Mutable slice iterator.\n-#[experimental = \"needs review\"]\n+#[stable]\n pub struct IterMut<'a, T: 'a> {\n     ptr: *mut T,\n     end: *mut T,\n@@ -876,28 +891,28 @@ iterator!{struct IterMut -> *mut T, &'a mut T}\n #[experimental = \"needs review\"]\n impl<'a, T> ExactSizeIterator<&'a mut T> for IterMut<'a, T> {}\n \n-/// An abstraction over the splitting iterators, so that splitn, splitn_mut etc\n-/// can be implemented once.\n-trait SplitsIter<E>: DoubleEndedIterator<E> {\n+/// An internal abstraction over the splitting iterators, so that\n+/// splitn, splitn_mut etc can be implemented once.\n+trait SplitIter<E>: DoubleEndedIterator<E> {\n     /// Mark the underlying iterator as complete, extracting the remaining\n     /// portion of the slice.\n     fn finish(&mut self) -> Option<E>;\n }\n \n /// An iterator over subslices separated by elements that match a predicate\n /// function.\n-#[experimental = \"needs review\"]\n-pub struct Splits<'a, T:'a, P> where P: FnMut(&T) -> bool {\n+#[stable]\n+pub struct Split<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     v: &'a [T],\n     pred: P,\n     finished: bool\n }\n \n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n #[stable]\n-impl<'a, T, P> Clone for Splits<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n-    fn clone(&self) -> Splits<'a, T, P> {\n-        Splits {\n+impl<'a, T, P> Clone for Split<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n+    fn clone(&self) -> Split<'a, T, P> {\n+        Split {\n             v: self.v,\n             pred: self.pred.clone(),\n             finished: self.finished,\n@@ -906,7 +921,7 @@ impl<'a, T, P> Clone for Splits<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T, P> Iterator<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> Iterator<&'a [T]> for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n         if self.finished { return None; }\n@@ -932,7 +947,7 @@ impl<'a, T, P> Iterator<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bool\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T, P> DoubleEndedIterator<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> DoubleEndedIterator<&'a [T]> for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n         if self.finished { return None; }\n@@ -948,7 +963,7 @@ impl<'a, T, P> DoubleEndedIterator<&'a [T]> for Splits<'a, T, P> where P: FnMut(\n     }\n }\n \n-impl<'a, T, P> SplitsIter<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> SplitIter<&'a [T]> for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn finish(&mut self) -> Option<&'a [T]> {\n         if self.finished { None } else { self.finished = true; Some(self.v) }\n@@ -957,14 +972,14 @@ impl<'a, T, P> SplitsIter<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bo\n \n /// An iterator over the subslices of the vector which are separated\n /// by elements that match `pred`.\n-#[experimental = \"needs review\"]\n-pub struct MutSplits<'a, T:'a, P> where P: FnMut(&T) -> bool {\n+#[stable]\n+pub struct SplitMut<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     v: &'a mut [T],\n     pred: P,\n     finished: bool\n }\n \n-impl<'a, T, P> SplitsIter<&'a mut [T]> for MutSplits<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> SplitIter<&'a mut [T]> for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn finish(&mut self) -> Option<&'a mut [T]> {\n         if self.finished {\n@@ -977,7 +992,7 @@ impl<'a, T, P> SplitsIter<&'a mut [T]> for MutSplits<'a, T, P> where P: FnMut(&T\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T, P> Iterator<&'a mut [T]> for MutSplits<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> Iterator<&'a mut [T]> for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut [T]> {\n         if self.finished { return None; }\n@@ -1010,7 +1025,7 @@ impl<'a, T, P> Iterator<&'a mut [T]> for MutSplits<'a, T, P> where P: FnMut(&T)\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T, P> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T, P> where\n+impl<'a, T, P> DoubleEndedIterator<&'a mut [T]> for SplitMut<'a, T, P> where\n     P: FnMut(&T) -> bool,\n {\n     #[inline]\n@@ -1033,17 +1048,17 @@ impl<'a, T, P> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T, P> where\n     }\n }\n \n-/// An iterator over subslices separated by elements that match a predicate\n-/// function, splitting at most a fixed number of times.\n-#[experimental = \"needs review\"]\n-pub struct SplitsN<I> {\n+/// An private iterator over subslices separated by elements that\n+/// match a predicate function, splitting at most a fixed number of\n+/// times.\n+struct GenericSplitN<I> {\n     iter: I,\n     count: uint,\n     invert: bool\n }\n \n #[experimental = \"needs review\"]\n-impl<E, I: SplitsIter<E>> Iterator<E> for SplitsN<I> {\n+impl<E, I: SplitIter<E>> Iterator<E> for GenericSplitN<I> {\n     #[inline]\n     fn next(&mut self) -> Option<E> {\n         if self.count == 0 {\n@@ -1061,6 +1076,55 @@ impl<E, I: SplitsIter<E>> Iterator<E> for SplitsN<I> {\n     }\n }\n \n+/// An iterator over subslices separated by elements that match a predicate\n+/// function, limited to a given number of splits.\n+pub struct SplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n+    inner: GenericSplitN<Split<'a, T, P>>\n+}\n+\n+/// An iterator over subslices separated by elements that match a\n+/// predicate function, limited to a given number of splits, starting\n+/// from the end of the slice.\n+pub struct RSplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n+    inner: GenericSplitN<Split<'a, T, P>>\n+}\n+\n+/// An iterator over subslices separated by elements that match a predicate\n+/// function, limited to a given number of splits.\n+pub struct SplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n+    inner: GenericSplitN<SplitMut<'a, T, P>>\n+}\n+\n+/// An iterator over subslices separated by elements that match a\n+/// predicate function, limited to a given number of splits, starting\n+/// from the end of the slice.\n+pub struct RSplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n+    inner: GenericSplitN<SplitMut<'a, T, P>>\n+}\n+\n+macro_rules! forward_iterator {\n+    ($name:ident: $elem:ident, $iter_of:ty) => {\n+        impl<'a, $elem, P> Iterator<$iter_of> for $name<'a, $elem, P> where\n+            P: FnMut(&T) -> bool\n+        {\n+            #[inline]\n+            fn next(&mut self) -> Option<$iter_of> {\n+                self.inner.next()\n+            }\n+\n+            #[inline]\n+            fn size_hint(&self) -> (uint, Option<uint>) {\n+                self.inner.size_hint()\n+            }\n+        }\n+    }\n+}\n+\n+forward_iterator! { SplitN: T, &'a [T] }\n+forward_iterator! { RSplitN: T, &'a [T] }\n+forward_iterator! { SplitNMut: T, &'a mut [T] }\n+forward_iterator! { RSplitNMut: T, &'a mut [T] }\n+\n /// An iterator over overlapping subslices of length `size`.\n #[deriving(Clone)]\n #[experimental = \"needs review\"]\n@@ -1172,13 +1236,13 @@ impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n /// elements at a time). When the slice len is not evenly divided by the chunk\n /// size, the last slice of the iteration will be the remainder.\n #[experimental = \"needs review\"]\n-pub struct MutChunks<'a, T:'a> {\n+pub struct ChunksMut<'a, T:'a> {\n     v: &'a mut [T],\n     chunk_size: uint\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> Iterator<&'a mut [T]> for MutChunks<'a, T> {\n+impl<'a, T> Iterator<&'a mut [T]> for ChunksMut<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut [T]> {\n         if self.v.len() == 0 {\n@@ -1206,7 +1270,7 @@ impl<'a, T> Iterator<&'a mut [T]> for MutChunks<'a, T> {\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunks<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a mut [T]> for ChunksMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n         if self.v.len() == 0 {\n@@ -1224,59 +1288,20 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunks<'a, T> {\n }\n \n \n-\n-/// The result of calling `binary_search`.\n-///\n-/// `Found` means the search succeeded, and the contained value is the\n-/// index of the matching element. `NotFound` means the search\n-/// succeeded, and the contained value is an index where a matching\n-/// value could be inserted while maintaining sort order.\n-#[deriving(Copy, PartialEq, Show)]\n-#[experimental = \"needs review\"]\n-pub enum BinarySearchResult {\n-    /// The index of the found value.\n-    Found(uint),\n-    /// The index where the value should have been found.\n-    NotFound(uint)\n-}\n-\n-#[experimental = \"needs review\"]\n-impl BinarySearchResult {\n-    /// Converts a `Found` to `Some`, `NotFound` to `None`.\n-    /// Similar to `Result::ok`.\n-    pub fn found(&self) -> Option<uint> {\n-        match *self {\n-            BinarySearchResult::Found(i) => Some(i),\n-            BinarySearchResult::NotFound(_) => None\n-        }\n-    }\n-\n-    /// Convert a `Found` to `None`, `NotFound` to `Some`.\n-    /// Similar to `Result::err`.\n-    pub fn not_found(&self) -> Option<uint> {\n-        match *self {\n-            BinarySearchResult::Found(_) => None,\n-            BinarySearchResult::NotFound(i) => Some(i)\n-        }\n-    }\n-}\n-\n-\n-\n //\n // Free functions\n //\n \n /// Converts a pointer to A into a slice of length 1 (without copying).\n-#[unstable = \"waiting for DST\"]\n+#[unstable]\n pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n     unsafe {\n         transmute(RawSlice { data: s, len: 1 })\n     }\n }\n \n /// Converts a pointer to A into a slice of length 1 (without copying).\n-#[unstable = \"waiting for DST\"]\n+#[unstable]\n pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n     unsafe {\n         let ptr: *const A = transmute(s);\n@@ -1310,7 +1335,7 @@ pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n /// }\n /// ```\n #[inline]\n-#[unstable = \"just renamed from `mod raw`\"]\n+#[unstable = \"should be renamed to from_raw_parts\"]\n pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: uint) -> &'a [T] {\n     transmute(RawSlice { data: *p, len: len })\n }\n@@ -1322,7 +1347,7 @@ pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: uint) -> &'a [T] {\n /// not being able to provide a non-aliasing guarantee of the returned mutable\n /// slice.\n #[inline]\n-#[unstable = \"just renamed from `mod raw`\"]\n+#[unstable = \"jshould be renamed to from_raw_parts_mut\"]\n pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: uint) -> &'a mut [T] {\n     transmute(RawSlice { data: *p as *const T, len: len })\n }\n@@ -1497,39 +1522,28 @@ impl<T: PartialOrd> PartialOrd for [T] {\n     }\n }\n \n-/// Extension methods for immutable slices containing integers.\n+/// Extension methods for slices containing integers.\n #[experimental]\n-pub trait ImmutableIntSlice<U, S> for Sized? {\n+pub trait IntSliceExt<U, S> for Sized? {\n     /// Converts the slice to an immutable slice of unsigned integers with the same width.\n     fn as_unsigned<'a>(&'a self) -> &'a [U];\n     /// Converts the slice to an immutable slice of signed integers with the same width.\n     fn as_signed<'a>(&'a self) -> &'a [S];\n-}\n \n-/// Extension methods for mutable slices containing integers.\n-#[experimental]\n-pub trait MutableIntSlice<U, S> for Sized?: ImmutableIntSlice<U, S> {\n     /// Converts the slice to a mutable slice of unsigned integers with the same width.\n     fn as_unsigned_mut<'a>(&'a mut self) -> &'a mut [U];\n     /// Converts the slice to a mutable slice of signed integers with the same width.\n     fn as_signed_mut<'a>(&'a mut self) -> &'a mut [S];\n }\n \n-macro_rules! impl_immut_int_slice {\n+macro_rules! impl_int_slice {\n     ($u:ty, $s:ty, $t:ty) => {\n         #[experimental]\n-        impl ImmutableIntSlice<$u, $s> for [$t] {\n+        impl IntSliceExt<$u, $s> for [$t] {\n             #[inline]\n             fn as_unsigned(&self) -> &[$u] { unsafe { transmute(self) } }\n             #[inline]\n             fn as_signed(&self) -> &[$s] { unsafe { transmute(self) } }\n-        }\n-    }\n-}\n-macro_rules! impl_mut_int_slice {\n-    ($u:ty, $s:ty, $t:ty) => {\n-        #[experimental]\n-        impl MutableIntSlice<$u, $s> for [$t] {\n             #[inline]\n             fn as_unsigned_mut(&mut self) -> &mut [$u] { unsafe { transmute(self) } }\n             #[inline]\n@@ -1538,17 +1552,15 @@ macro_rules! impl_mut_int_slice {\n     }\n }\n \n-macro_rules! impl_int_slice {\n+macro_rules! impl_int_slices {\n     ($u:ty, $s:ty) => {\n-        impl_immut_int_slice! { $u, $s, $u }\n-        impl_immut_int_slice! { $u, $s, $s }\n-        impl_mut_int_slice! { $u, $s, $u }\n-        impl_mut_int_slice! { $u, $s, $s }\n+        impl_int_slice! { $u, $s, $u }\n+        impl_int_slice! { $u, $s, $s }\n     }\n }\n \n-impl_int_slice! { u8,   i8 }\n-impl_int_slice! { u16,  i16 }\n-impl_int_slice! { u32,  i32 }\n-impl_int_slice! { u64,  i64 }\n-impl_int_slice! { uint, int }\n+impl_int_slices! { u8,   i8  }\n+impl_int_slices! { u16,  i16 }\n+impl_int_slices! { u32,  i32 }\n+impl_int_slices! { u64,  i64 }\n+impl_int_slices! { uint, int }"}, {"sha": "9ef7d6030593a008f24a6d22fb1477afcdcd5ead", "filename": "src/libcoretest/slice.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcoretest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibcoretest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fslice.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -8,30 +8,30 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::slice::BinarySearchResult::{Found, NotFound};\n+use core::result::Result::{Ok, Err};\n \n #[test]\n fn binary_search_not_found() {\n     let b = [1i, 2, 4, 6, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&6)) == Found(3));\n+    assert!(b.binary_search_by(|v| v.cmp(&6)) == Ok(3));\n     let b = [1i, 2, 4, 6, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&5)) == NotFound(3));\n+    assert!(b.binary_search_by(|v| v.cmp(&5)) == Err(3));\n     let b = [1i, 2, 4, 6, 7, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&6)) == Found(3));\n+    assert!(b.binary_search_by(|v| v.cmp(&6)) == Ok(3));\n     let b = [1i, 2, 4, 6, 7, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&5)) == NotFound(3));\n+    assert!(b.binary_search_by(|v| v.cmp(&5)) == Err(3));\n     let b = [1i, 2, 4, 6, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&8)) == Found(4));\n+    assert!(b.binary_search_by(|v| v.cmp(&8)) == Ok(4));\n     let b = [1i, 2, 4, 6, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&7)) == NotFound(4));\n+    assert!(b.binary_search_by(|v| v.cmp(&7)) == Err(4));\n     let b = [1i, 2, 4, 6, 7, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&8)) == Found(5));\n+    assert!(b.binary_search_by(|v| v.cmp(&8)) == Ok(5));\n     let b = [1i, 2, 4, 5, 6, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&7)) == NotFound(5));\n+    assert!(b.binary_search_by(|v| v.cmp(&7)) == Err(5));\n     let b = [1i, 2, 4, 5, 6, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&0)) == NotFound(0));\n+    assert!(b.binary_search_by(|v| v.cmp(&0)) == Err(0));\n     let b = [1i, 2, 4, 5, 6, 8];\n-    assert!(b.binary_search(|v| v.cmp(&9)) == NotFound(6));\n+    assert!(b.binary_search_by(|v| v.cmp(&9)) == Err(6));\n }\n \n #[test]"}, {"sha": "0184222b9e0b660fea87cf2d43eaae35818d03d0", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -578,7 +578,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n \n     fn f(_x: uint) -> Vec<Optval> { return Vec::new(); }\n \n-    let mut vals = Vec::from_fn(n_opts, f);\n+    let mut vals: Vec<_> = range(0, n_opts).map(f).collect();\n     let mut free: Vec<String> = Vec::new();\n     let l = args.len();\n     let mut i = 0;"}, {"sha": "a76e5ebd08a8493ae4ff217f9863193350515e16", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -361,7 +361,7 @@ impl Isaac64Rng {\n         const MP_VEC: [(uint, uint), .. 2] = [(0,MIDPOINT), (MIDPOINT, 0)];\n         macro_rules! ind (\n             ($x:expr) => {\n-                *self.mem.unsafe_get(($x as uint >> 3) & (RAND_SIZE_64 - 1))\n+                *self.mem.get_unchecked(($x as uint >> 3) & (RAND_SIZE_64 - 1))\n             }\n         );\n \n@@ -375,13 +375,13 @@ impl Isaac64Rng {\n                             let mix = if $j == 0 {!mix} else {mix};\n \n                             unsafe {\n-                                let x = *self.mem.unsafe_get(base + mr_offset);\n-                                a = mix + *self.mem.unsafe_get(base + m2_offset);\n+                                let x = *self.mem.get_unchecked(base + mr_offset);\n+                                a = mix + *self.mem.get_unchecked(base + m2_offset);\n                                 let y = ind!(x) + a + b;\n-                                *self.mem.unsafe_mut(base + mr_offset) = y;\n+                                *self.mem.get_unchecked_mut(base + mr_offset) = y;\n \n                                 b = ind!(y >> RAND_SIZE_64_LEN) + x;\n-                                *self.rsl.unsafe_mut(base + mr_offset) = b;\n+                                *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n                             }\n                         }}\n                     );\n@@ -392,13 +392,13 @@ impl Isaac64Rng {\n                             let mix = if $j == 0 {!mix} else {mix};\n \n                             unsafe {\n-                                let x = *self.mem.unsafe_get(base + mr_offset);\n-                                a = mix + *self.mem.unsafe_get(base + m2_offset);\n+                                let x = *self.mem.get_unchecked(base + mr_offset);\n+                                a = mix + *self.mem.get_unchecked(base + m2_offset);\n                                 let y = ind!(x) + a + b;\n-                                *self.mem.unsafe_mut(base + mr_offset) = y;\n+                                *self.mem.get_unchecked_mut(base + mr_offset) = y;\n \n                                 b = ind!(y >> RAND_SIZE_64_LEN) + x;\n-                                *self.rsl.unsafe_mut(base + mr_offset) = b;\n+                                *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n                             }\n                         }}\n                     );"}, {"sha": "fd0c54e8ed3a8fce98cb8b2a7d525463a005b167", "filename": "src/librbml/io.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -11,6 +11,7 @@\n use std::io::{IoError, IoResult, SeekStyle};\n use std::io;\n use std::slice;\n+use std::iter::repeat;\n \n static BUF_CAPACITY: uint = 128;\n \n@@ -87,7 +88,7 @@ impl Writer for SeekableMemWriter {\n             // currently are\n             let difference = self.pos as i64 - self.buf.len() as i64;\n             if difference > 0 {\n-                self.buf.grow(difference as uint, 0);\n+                self.buf.extend(repeat(0).take(difference as uint));\n             }\n \n             // Figure out what bytes will be used to overwrite what's currently"}, {"sha": "1476e6ab8a7068669c5e8b81edc13cb0e1bb2660", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -14,6 +14,7 @@\n pub use self::Inst::*;\n \n use std::cmp;\n+use std::iter::repeat;\n use parse;\n use parse::{\n     Flags, FLAG_EMPTY,\n@@ -157,7 +158,7 @@ impl<'r> Compiler<'r> {\n             Capture(cap, name, x) => {\n                 let len = self.names.len();\n                 if cap >= len {\n-                    self.names.grow(10 + cap - len, None)\n+                    self.names.extend(repeat(None).take(10 + cap - len))\n                 }\n                 self.names[cap] = name;\n "}, {"sha": "692a065299ca2b25a21d39c6f515a760c7fc87b9", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -18,7 +18,6 @@ use std::cmp;\n use std::fmt;\n use std::iter;\n use std::num;\n-use std::slice::BinarySearchResult;\n \n /// Static data containing Unicode ranges for general categories and scripts.\n use unicode::regex::{UNICODE_CLASSES, PERLD, PERLS, PERLW};\n@@ -1028,9 +1027,9 @@ fn is_valid_cap(c: char) -> bool {\n }\n \n fn find_class(classes: NamedClasses, name: &str) -> Option<Vec<(char, char)>> {\n-    match classes.binary_search(|&(s, _)| s.cmp(name)) {\n-        BinarySearchResult::Found(i) => Some(classes[i].1.to_vec()),\n-        BinarySearchResult::NotFound(_) => None,\n+    match classes.binary_search_by(|&(s, _)| s.cmp(name)) {\n+        Ok(i) => Some(classes[i].1.to_vec()),\n+        Err(_) => None,\n     }\n }\n "}, {"sha": "72e0e559c805bb7f0192088050576b7e29d648f2", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -38,6 +38,7 @@ pub use self::StepState::*;\n \n use std::cmp;\n use std::mem;\n+use std::iter::repeat;\n use std::slice::SliceExt;\n use compile::{\n     Program,\n@@ -121,7 +122,7 @@ impl<'r, 't> Nfa<'r, 't> {\n         let mut clist = &mut Threads::new(self.which, ninsts, ncaps);\n         let mut nlist = &mut Threads::new(self.which, ninsts, ncaps);\n \n-        let mut groups = Vec::from_elem(ncaps * 2, None);\n+        let mut groups: Vec<_> = repeat(None).take(ncaps * 2).collect();\n \n         // Determine if the expression starts with a '^' so we can avoid\n         // simulating .*?\n@@ -227,8 +228,7 @@ impl<'r, 't> Nfa<'r, 't> {\n                     let negate = flags & FLAG_NEGATED > 0;\n                     let casei = flags & FLAG_NOCASE > 0;\n                     let found = ranges.as_slice();\n-                    let found = found.binary_search(|&rc| class_cmp(casei, c, rc))\n-                        .found().is_some();\n+                    let found = found.binary_search_by(|&rc| class_cmp(casei, c, rc)).is_ok();\n                     if found ^ negate {\n                         self.add(nlist, pc+1, caps);\n                     }\n@@ -457,10 +457,10 @@ impl Threads {\n     fn new(which: MatchKind, num_insts: uint, ncaps: uint) -> Threads {\n         Threads {\n             which: which,\n-            queue: Vec::from_fn(num_insts, |_| {\n-                Thread { pc: 0, groups: Vec::from_elem(ncaps * 2, None) }\n-            }),\n-            sparse: Vec::from_elem(num_insts, 0u),\n+            queue: range(0, num_insts).map(|_| {\n+                Thread { pc: 0, groups: repeat(None).take(ncaps * 2).collect() }\n+            }).collect(),\n+            sparse: repeat(0u).take(num_insts).collect(),\n             size: 0,\n         }\n     }\n@@ -518,15 +518,15 @@ pub fn is_word(c: Option<char>) -> bool {\n     // Try the common ASCII case before invoking binary search.\n     match c {\n         '_' | '0' ... '9' | 'a' ... 'z' | 'A' ... 'Z' => true,\n-        _ => PERLW.binary_search(|&(start, end)| {\n+        _ => PERLW.binary_search_by(|&(start, end)| {\n             if c >= start && c <= end {\n                 Equal\n             } else if start > c {\n                 Greater\n             } else {\n                 Less\n             }\n-        }).found().is_some()\n+        }).is_ok()\n     }\n }\n "}, {"sha": "5d0532a621022eb6723685784600bb62014c8e37", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -1599,7 +1599,7 @@ fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn:\n     F: FnMut(&mut SeekableMemWriter, &T),\n     T: Hash,\n {\n-    let mut buckets: Vec<Vec<entry<T>>> = Vec::from_fn(256, |_| Vec::new());\n+    let mut buckets: Vec<Vec<entry<T>>> = range(0, 256u16).map(|_| Vec::new()).collect();\n     for elt in index.into_iter() {\n         let h = hash::hash(&elt.val) as uint;\n         buckets[h % 256].push(elt);"}, {"sha": "522e1d4d3b284a571ca9e952e408264dfcff1d43", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -611,9 +611,9 @@ fn is_useful(cx: &MatchCheckCtxt,\n                             let arity = constructor_arity(cx, &c, left_ty);\n                             let mut result = {\n                                 let pat_slice = pats[];\n-                                let subpats = Vec::from_fn(arity, |i| {\n+                                let subpats: Vec<_> = range(0, arity).map(|i| {\n                                     pat_slice.get(i).map_or(DUMMY_WILD_PAT, |p| &**p)\n-                                });\n+                                }).collect();\n                                 vec![construct_witness(cx, &c, subpats, left_ty)]\n                             };\n                             result.extend(pats.into_iter().skip(arity));\n@@ -635,7 +635,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n                 match is_useful(cx, &matrix, v.tail(), witness) {\n                     UsefulWithWitness(pats) => {\n                         let arity = constructor_arity(cx, &constructor, left_ty);\n-                        let wild_pats = Vec::from_elem(arity, DUMMY_WILD_PAT);\n+                        let wild_pats: Vec<_> = repeat(DUMMY_WILD_PAT).take(arity).collect();\n                         let enum_pat = construct_witness(cx, &constructor, wild_pats, left_ty);\n                         let mut new_pats = vec![enum_pat];\n                         new_pats.extend(pats.into_iter());\n@@ -788,7 +788,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n     } = raw_pat(r[col]);\n     let head: Option<Vec<&Pat>> = match *node {\n         ast::PatWild(_) =>\n-            Some(Vec::from_elem(arity, DUMMY_WILD_PAT)),\n+            Some(repeat(DUMMY_WILD_PAT).take(arity).collect()),\n \n         ast::PatIdent(_, _, _) => {\n             let opt_def = cx.tcx.def_map.borrow().get(&pat_id).cloned();\n@@ -801,7 +801,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 } else {\n                     None\n                 },\n-                _ => Some(Vec::from_elem(arity, DUMMY_WILD_PAT))\n+                _ => Some(repeat(DUMMY_WILD_PAT).take(arity).collect())\n             }\n         }\n \n@@ -815,7 +815,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 DefVariant(..) | DefStruct(..) => {\n                     Some(match args {\n                         &Some(ref args) => args.iter().map(|p| &**p).collect(),\n-                        &None => Vec::from_elem(arity, DUMMY_WILD_PAT)\n+                        &None => repeat(DUMMY_WILD_PAT).take(arity).collect(),\n                     })\n                 }\n                 _ => None\n@@ -894,13 +894,13 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 // Fixed-length vectors.\n                 Single => {\n                     let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n-                    pats.grow_fn(arity - before.len() - after.len(), |_| DUMMY_WILD_PAT);\n+                    pats.extend(repeat(DUMMY_WILD_PAT).take(arity - before.len() - after.len()));\n                     pats.extend(after.iter().map(|p| &**p));\n                     Some(pats)\n                 },\n                 Slice(length) if before.len() + after.len() <= length && slice.is_some() => {\n                     let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n-                    pats.grow_fn(arity - before.len() - after.len(), |_| DUMMY_WILD_PAT);\n+                    pats.extend(repeat(DUMMY_WILD_PAT).take(arity - before.len() - after.len()));\n                     pats.extend(after.iter().map(|p| &**p));\n                     Some(pats)\n                 },"}, {"sha": "6cf6065de19f0ee90e6942ac161cd4e88d5e91a4", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -21,6 +21,7 @@ use middle::cfg::CFGIndex;\n use middle::ty;\n use std::io;\n use std::uint;\n+use std::iter::repeat;\n use syntax::ast;\n use syntax::ast_util::IdRange;\n use syntax::visit;\n@@ -203,9 +204,9 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n         let entry = if oper.initial_value() { uint::MAX } else {0};\n \n-        let gens = Vec::from_elem(num_nodes * words_per_id, 0);\n-        let kills = Vec::from_elem(num_nodes * words_per_id, 0);\n-        let on_entry = Vec::from_elem(num_nodes * words_per_id, entry);\n+        let gens: Vec<_> = repeat(0).take(num_nodes * words_per_id).collect();\n+        let kills: Vec<_> = repeat(0).take(num_nodes * words_per_id).collect();\n+        let on_entry: Vec<_> = repeat(entry).take(num_nodes * words_per_id).collect();\n \n         let nodeid_to_index = build_nodeid_to_index(decl, cfg);\n \n@@ -446,7 +447,7 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n                 changed: true\n             };\n \n-            let mut temp = Vec::from_elem(words_per_id, 0u);\n+            let mut temp: Vec<_> = repeat(0u).take(words_per_id).collect();\n             while propcx.changed {\n                 propcx.changed = false;\n                 propcx.reset(temp.as_mut_slice());"}, {"sha": "6f1c7af5b8628671494ec222c0bd538d91769c36", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -1187,7 +1187,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n         let mut new_ty = P(ty.clone());\n         let mut ty_queue = vec!(ty);\n         while !ty_queue.is_empty() {\n-            let cur_ty = ty_queue.remove(0).unwrap();\n+            let cur_ty = ty_queue.remove(0);\n             match cur_ty.node {\n                 ast::TyRptr(lt_opt, ref mut_ty) => {\n                     let rebuild = match lt_opt {"}, {"sha": "91fbaca26d113fdc67f0a5e0b04c34d33a7f4ef8", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -799,7 +799,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn next_ty_vars(&self, n: uint) -> Vec<Ty<'tcx>> {\n-        Vec::from_fn(n, |_i| self.next_ty_var())\n+        range(0, n).map(|_i| self.next_ty_var()).collect()\n     }\n \n     pub fn next_int_var_id(&self) -> IntVid {"}, {"sha": "7372bb267b06c853de1e77c1fe5e327af1cfb67f", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -34,6 +34,7 @@ use util::ppaux::Repr;\n \n use std::cell::{Cell, RefCell};\n use std::u32;\n+use std::iter::repeat;\n use syntax::ast;\n \n mod doc;\n@@ -975,7 +976,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     fn construct_var_data(&self) -> Vec<VarData> {\n-        Vec::from_fn(self.num_vars() as uint, |_| {\n+        range(0, self.num_vars() as uint).map(|_| {\n             VarData {\n                 // All nodes are initially classified as contracting; during\n                 // the expansion phase, we will shift the classification for\n@@ -984,7 +985,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 classification: Contracting,\n                 value: NoValue,\n             }\n-        })\n+        }).collect()\n     }\n \n     fn dump_constraints(&self) {\n@@ -1247,7 +1248,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // idea is to report errors that derive from independent\n         // regions of the graph, but not those that derive from\n         // overlapping locations.\n-        let mut dup_vec = Vec::from_elem(self.num_vars() as uint, u32::MAX);\n+        let mut dup_vec: Vec<_> = repeat(u32::MAX).take(self.num_vars() as uint).collect();\n \n         let mut opt_graph = None;\n \n@@ -1308,7 +1309,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             }\n         }\n \n-        Vec::from_fn(self.num_vars() as uint, |idx| var_data[idx].value)\n+        range(0, self.num_vars() as uint).map(|idx| var_data[idx].value).collect()\n     }\n \n     fn construct_graph(&self) -> RegionGraph {"}, {"sha": "5be8d03e74359306afe6012ecda7e15ea5fb7abd", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -117,6 +117,7 @@ use util::nodemap::NodeMap;\n \n use std::{fmt, io, uint};\n use std::rc::Rc;\n+use std::iter::repeat;\n use syntax::ast::{mod, NodeId, Expr};\n use syntax::codemap::{BytePos, original_sp, Span};\n use syntax::parse::token::{mod, special_idents};\n@@ -575,8 +576,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         Liveness {\n             ir: ir,\n             s: specials,\n-            successors: Vec::from_elem(num_live_nodes, invalid_node()),\n-            users: Vec::from_elem(num_live_nodes * num_vars, invalid_users()),\n+            successors: repeat(invalid_node()).take(num_live_nodes).collect(),\n+            users: repeat(invalid_users()).take(num_live_nodes * num_vars).collect(),\n             loop_scope: Vec::new(),\n             break_ln: NodeMap::new(),\n             cont_ln: NodeMap::new(),\n@@ -1068,7 +1069,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 // the same bindings, and we also consider the first pattern to be\n                 // the \"authoritative\" set of ids\n                 let arm_succ =\n-                    self.define_bindings_in_arm_pats(arm.pats.head().map(|p| &**p),\n+                    self.define_bindings_in_arm_pats(arm.pats.first().map(|p| &**p),\n                                                      guard_succ);\n                 self.merge_from_succ(ln, arm_succ, first_merge);\n                 first_merge = false;\n@@ -1436,7 +1437,7 @@ fn check_arm(this: &mut Liveness, arm: &ast::Arm) {\n     // only consider the first pattern; any later patterns must have\n     // the same bindings, and we also consider the first pattern to be\n     // the \"authoritative\" set of ids\n-    this.arm_pats_bindings(arm.pats.head().map(|p| &**p), |this, ln, var, sp, id| {\n+    this.arm_pats_bindings(arm.pats.first().map(|p| &**p), |this, ln, var, sp, id| {\n         this.warn_about_unused(sp, id, ln, var);\n     });\n     visit::walk_arm(this, arm);\n@@ -1542,7 +1543,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 } else {\n                     let ends_with_stmt = match body.expr {\n                         None if body.stmts.len() > 0 =>\n-                            match body.stmts.last().unwrap().node {\n+                            match body.stmts.first().unwrap().node {\n                                 ast::StmtSemi(ref e, _) => {\n                                     ty::expr_ty(self.ir.tcx, &**e) == t_ret\n                                 },\n@@ -1553,7 +1554,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     self.ir.tcx.sess.span_err(\n                         sp, \"not all control paths return a value\");\n                     if ends_with_stmt {\n-                        let last_stmt = body.stmts.last().unwrap();\n+                        let last_stmt = body.stmts.first().unwrap();\n                         let original_span = original_sp(self.ir.tcx.sess.codemap(),\n                                                         last_stmt.span, sp);\n                         let span_semicolon = Span {"}, {"sha": "edba2839f37eabc9476b5c8a85df7aae6e9d74de", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -751,10 +751,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         let orig_def = self.tcx.def_map.borrow()[path_id].clone();\n         let ck = |tyname: &str| {\n             let ck_public = |def: ast::DefId| {\n-                let name = token::get_ident(path.segments\n-                                                .last()\n-                                                .unwrap()\n-                                                .identifier);\n+                let name = token::get_ident(path.segments.last().unwrap().identifier);\n                 let origdid = orig_def.def_id();\n                 self.ensure_public(span,\n                                    def,"}, {"sha": "e9504a92f7b460ef714c3d9f24faef02dc88e8da", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -296,7 +296,7 @@ impl<'a> LifetimeContext<'a> {\n         debug!(\"visit_early_late: referenced_idents={}\",\n                referenced_idents);\n \n-        let (early, late) = generics.lifetimes.clone().partition(\n+        let (early, late): (Vec<_>, _) = generics.lifetimes.iter().cloned().partition(\n             |l| referenced_idents.iter().any(|&i| i == l.lifetime.name));\n \n         self.with(EarlyScope(early_space, &early, self.scope), move |old_scope, this| {"}, {"sha": "07da9853e558525d280845190bd51a345730bac9", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -323,7 +323,11 @@ impl<T> VecPerParamSpace<T> {\n                 SelfSpace => { self.self_limit -= 1; }\n                 FnSpace => {}\n             }\n-            self.content.remove(limit - 1)\n+            if self.content.is_empty() {\n+                None\n+            } else {\n+                Some(self.content.remove(limit - 1))\n+            }\n         }\n     }\n "}, {"sha": "e7c77b12499274360e9f3ce7bacbe6a75b87c836", "filename": "src/librustc/util/lev_distance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Flev_distance.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -14,7 +14,7 @@ pub fn lev_distance(me: &str, t: &str) -> uint {\n     if me.is_empty() { return t.chars().count(); }\n     if t.is_empty() { return me.chars().count(); }\n \n-    let mut dcol = Vec::from_fn(t.len() + 1, |x| x);\n+    let mut dcol: Vec<_> = range(0, t.len() + 1).collect();\n     let mut t_last = 0;\n \n     for (i, sc) in me.chars().enumerate() {"}, {"sha": "a7d1d3a23bd1345c941e74a729001fc690f7f4f2", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -14,7 +14,7 @@\n \n #![allow(deprecated)] // to_be32\n \n-use std::iter::range_step;\n+use std::iter::{range_step, repeat};\n use std::num::Int;\n use std::slice::bytes::{MutableByteVector, copy_memory};\n use serialize::hex::ToHex;\n@@ -258,7 +258,7 @@ pub trait Digest {\n     /// Convenience function that retrieves the result of a digest as a\n     /// newly allocated vec of bytes.\n     fn result_bytes(&mut self) -> Vec<u8> {\n-        let mut buf = Vec::from_elem((self.output_bits()+7)/8, 0u8);\n+        let mut buf: Vec<u8> = repeat(0u8).take((self.output_bits()+7)/8).collect();\n         self.result(buf.as_mut_slice());\n         buf\n     }\n@@ -612,7 +612,7 @@ mod tests {\n     /// correct.\n     fn test_digest_1million_random<D: Digest>(digest: &mut D, blocksize: uint, expected: &str) {\n         let total_size = 1000000;\n-        let buffer = Vec::from_elem(blocksize * 2, 'a' as u8);\n+        let buffer: Vec<u8> = repeat('a' as u8).take(blocksize * 2).collect();\n         let mut rng = IsaacRng::new_unseeded();\n         let mut count = 0;\n "}, {"sha": "070ae1151aa6d4701e305057cd84bdb4471b9662", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -25,7 +25,6 @@ use rustc::middle::mem_categorization as mc;\n use rustc::util::ppaux::{Repr, UserString};\n use std::mem;\n use std::rc::Rc;\n-use std::slice;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::attr::AttrMetaMethods;\n@@ -268,9 +267,9 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n     return;\n \n     fn non_member(elem: MovePathIndex, set: &[MovePathIndex]) -> bool {\n-        match set.binary_search_elem(&elem) {\n-            slice::BinarySearchResult::Found(_) => false,\n-            slice::BinarySearchResult::NotFound(_) => true,\n+        match set.binary_search(&elem) {\n+            Ok(_) => false,\n+            Err(_) => true,\n         }\n     }\n }"}, {"sha": "664d470b11bd1c46ad6a228946272b712f8ad6f5", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -37,4 +37,3 @@ pub use borrowck::FnPartsWithCFG;\n mod borrowck;\n \n pub mod graphviz;\n-"}, {"sha": "0d98434d042ba91f672d6f6a172925ec1ead6f02", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -265,11 +265,13 @@ Available lint options:\n         lints\n     }\n \n-    let (plugin, builtin) = lint_store.get_lints().partitioned(|&(_, p)| p);\n+    let (plugin, builtin): (Vec<_>, _) = lint_store.get_lints()\n+        .iter().cloned().partition(|&(_, p)| p);\n     let plugin = sort_lints(plugin);\n     let builtin = sort_lints(builtin);\n \n-    let (plugin_groups, builtin_groups) = lint_store.get_lint_groups().partitioned(|&(_, _, p)| p);\n+    let (plugin_groups, builtin_groups): (Vec<_>, _) = lint_store.get_lint_groups()\n+        .iter().cloned().partition(|&(_, _, p)| p);\n     let plugin_groups = sort_lint_groups(plugin_groups);\n     let builtin_groups = sort_lint_groups(builtin_groups);\n \n@@ -377,7 +379,7 @@ fn describe_codegen_flags() {\n /// returns None.\n pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     // Throw away the first argument, the name of the binary\n-    let _binary = args.remove(0).unwrap();\n+    let _binary = args.remove(0);\n \n     if args.is_empty() {\n         // user did not write `-v` nor `-Z unstable-options`, so do not"}, {"sha": "e371046a9b21d34073d0dbfa6737ced88b9b707d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -3554,9 +3554,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             Some(def) => {\n                                 debug!(\"(resolving type) resolved `{}` to \\\n                                         type {}\",\n-                                       token::get_ident(path.segments\n-                                                            .last().unwrap()\n-                                                            .identifier),\n+                                       token::get_ident(path.segments.last().unwrap() .identifier),\n                                        def);\n                                 result_def = Some(def);\n                             }\n@@ -3747,19 +3745,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             self.resolve_error(path.span,\n                                 format!(\"`{}` is not an enum variant, struct or const\",\n                                     token::get_ident(\n-                                        path.segments\n-                                            .last()\n-                                            .unwrap()\n-                                            .identifier))[]);\n+                                        path.segments.last().unwrap().identifier))[]);\n                         }\n                         None => {\n                             self.resolve_error(path.span,\n                                 format!(\"unresolved enum variant, struct or const `{}`\",\n                                     token::get_ident(\n-                                        path.segments\n-                                            .last()\n-                                            .unwrap()\n-                                            .identifier))[]);\n+                                        path.segments.last().unwrap().identifier))[]);\n                         }\n                     }\n \n@@ -3913,9 +3905,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Try to find a path to an item in a module.\n         let unqualified_def =\n-                self.resolve_identifier(path.segments\n-                                            .last().unwrap()\n-                                            .identifier,\n+                self.resolve_identifier(path.segments.last().unwrap().identifier,\n                                         namespace,\n                                         check_ribs,\n                                         path.span);"}, {"sha": "c6e4ce9457b533ba764480a276163ee6bfbf5bb9", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -606,9 +606,9 @@ fn extract_variant_args<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     val: ValueRef)\n                                     -> ExtractedBlock<'blk, 'tcx> {\n     let _icx = push_ctxt(\"match::extract_variant_args\");\n-    let args = Vec::from_fn(adt::num_args(repr, disr_val), |i| {\n+    let args = range(0, adt::num_args(repr, disr_val)).map(|i| {\n         adt::trans_field_ptr(bcx, repr, val, disr_val, i)\n-    });\n+    }).collect();\n \n     ExtractedBlock { vals: args, bcx: bcx }\n }"}, {"sha": "fffdc9c97ab97e41fa73be0b562b865664efe755", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -23,6 +23,7 @@ use trans::context::CrateContext;\n use trans::type_::Type;\n \n use std::cmp;\n+use std::iter::repeat;\n \n #[deriving(Clone, Copy, PartialEq)]\n enum RegClass {\n@@ -286,7 +287,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n     }\n \n     let words = (ty_size(ty) + 7) / 8;\n-    let mut cls = Vec::from_elem(words, NoClass);\n+    let mut cls: Vec<_> = repeat(NoClass).take(words).collect();\n     if words > 4 {\n         all_mem(cls.as_mut_slice());\n         return cls;"}, {"sha": "1f01da8a124b3c7309e82460b2012c7964d19fdf", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -25,6 +25,7 @@ use middle::ty::{mod, Ty};\n use util::ppaux::{Repr, ty_to_string};\n \n use std::c_str::ToCStr;\n+use std::iter::repeat;\n use libc::c_uint;\n use syntax::{ast, ast_util};\n use syntax::ptr::P;\n@@ -608,7 +609,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                 const_eval::const_uint(i) => i as uint,\n                 _ => cx.sess().span_bug(count.span, \"count must be integral const expression.\")\n             };\n-            let vs = Vec::from_elem(n, const_expr(cx, &**elem).0);\n+            let vs: Vec<_> = repeat(const_expr(cx, &**elem).0).take(n).collect();\n             if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n                 C_struct(cx, vs[], false)\n             } else {"}, {"sha": "589250430cd71b778028d331f3b2a123745837cc", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -3405,10 +3405,7 @@ fn create_scope_map(cx: &CrateContext,\n                     if need_new_scope {\n                         // Create a new lexical scope and push it onto the stack\n                         let loc = cx.sess().codemap().lookup_char_pos(pat.span.lo);\n-                        let file_metadata = file_metadata(cx,\n-                                                          loc.file\n-                                                             .name\n-                                                             []);\n+                        let file_metadata = file_metadata(cx, loc.file.name[]);\n                         let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n                         let scope_metadata = unsafe {"}, {"sha": "7587adae5b7ef68b3a30908c8c9e9fc834ba6d9a", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -68,6 +68,7 @@ use syntax::print::pprust::{expr_to_string};\n use syntax::ptr::P;\n use syntax::parse::token;\n use std::rc::Rc;\n+use std::iter::repeat;\n \n // Destinations\n \n@@ -1413,7 +1414,7 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let tcx = bcx.tcx();\n     with_field_tys(tcx, ty, Some(expr_id), |discr, field_tys| {\n-        let mut need_base = Vec::from_elem(field_tys.len(), true);\n+        let mut need_base: Vec<_> = repeat(true).take(field_tys.len()).collect();\n \n         let numbered_fields = fields.iter().map(|field| {\n             let opt_pos ="}, {"sha": "2cc40a617950843affa2364d296169b9e6039195", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -22,6 +22,7 @@ use syntax::ast;\n use std::c_str::ToCStr;\n use std::mem;\n use std::cell::RefCell;\n+use std::iter::repeat;\n \n use libc::c_uint;\n \n@@ -282,7 +283,7 @@ impl Type {\n             if n_elts == 0 {\n                 return Vec::new();\n             }\n-            let mut elts = Vec::from_elem(n_elts, Type { rf: 0 as TypeRef });\n+            let mut elts: Vec<_> = repeat(Type { rf: 0 as TypeRef }).take(n_elts).collect();\n             llvm::LLVMGetStructElementTypes(self.to_ref(),\n                                             elts.as_mut_ptr() as *mut TypeRef);\n             elts\n@@ -296,7 +297,7 @@ impl Type {\n     pub fn func_params(&self) -> Vec<Type> {\n         unsafe {\n             let n_args = llvm::LLVMCountParamTypes(self.to_ref()) as uint;\n-            let mut args = Vec::from_elem(n_args, Type { rf: 0 as TypeRef });\n+            let mut args: Vec<_> = repeat(Type { rf: 0 as TypeRef }).take(n_args).collect();\n             llvm::LLVMGetParamTypes(self.to_ref(),\n                                     args.as_mut_ptr() as *mut TypeRef);\n             args"}, {"sha": "dee9aafd06d7bfc561420daf53b0eee36aa61c59", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -62,7 +62,7 @@ use util::nodemap::DefIdMap;\n use util::ppaux::{mod, Repr, UserString};\n \n use std::rc::Rc;\n-use std::iter::AdditiveIterator;\n+use std::iter::{repeat, AdditiveIterator};\n use syntax::{abi, ast, ast_util};\n use syntax::codemap::Span;\n use syntax::parse::token;\n@@ -317,8 +317,8 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n \n         match anon_regions {\n             Ok(v) => v.into_iter().collect(),\n-            Err(_) => Vec::from_fn(expected_num_region_params,\n-                                   |_| ty::ReStatic) // hokey\n+            Err(_) => range(0, expected_num_region_params)\n+                          .map(|_| ty::ReStatic).collect() // hokey\n         }\n     };\n \n@@ -500,7 +500,7 @@ fn convert_parenthesized_parameters<'tcx,AC>(this: &AC,\n                             .map(|a_t| ast_ty_to_ty(this, &binding_rscope, &**a_t))\n                             .collect::<Vec<Ty<'tcx>>>();\n \n-    let input_params = Vec::from_elem(inputs.len(), String::new());\n+    let input_params: Vec<_> = repeat(String::new()).take(inputs.len()).collect();\n     let (implied_output_region,\n          params_lifetimes) = find_implied_output_region(&*inputs, input_params);\n \n@@ -734,8 +734,8 @@ pub fn ast_path_to_ty_relaxed<'tcx,AC,RS>(\n         path.segments.iter().all(|s| s.parameters.is_empty());\n \n     let substs = if needs_defaults {\n-        let type_params = Vec::from_fn(generics.types.len(TypeSpace),\n-                                       |_| this.ty_infer(path.span));\n+        let type_params: Vec<_> = range(0, generics.types.len(TypeSpace))\n+                                      .map(|_| this.ty_infer(path.span)).collect();\n         let region_params =\n             rscope.anon_regions(path.span, generics.regions.len(TypeSpace))\n                   .unwrap();\n@@ -1528,21 +1528,18 @@ fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n     let mut partitioned_bounds = partition_bounds(this.tcx(), span, ast_bounds[]);\n \n     let mut projection_bounds = Vec::new();\n-    let main_trait_bound = match partitioned_bounds.trait_bounds.remove(0) {\n-        Some(trait_bound) => {\n-            let ptr = instantiate_poly_trait_ref(this,\n-                                                 rscope,\n-                                                 trait_bound,\n-                                                 None,\n-                                                 &mut projection_bounds);\n-            Some(ptr)\n-        }\n-        None => {\n-            this.tcx().sess.span_err(\n-                span,\n-                \"at least one non-builtin trait is required for an object type\");\n-            None\n-        }\n+    let main_trait_bound = if !partitioned_bounds.trait_bounds.is_empty() {\n+        let trait_bound = partitioned_bounds.trait_bounds.remove(0);\n+        Some(instantiate_poly_trait_ref(this,\n+                                        rscope,\n+                                        trait_bound,\n+                                        None,\n+                                        &mut projection_bounds))\n+    } else {\n+        this.tcx().sess.span_err(\n+            span,\n+            \"at least one non-builtin trait is required for an object type\");\n+        None\n     };\n \n     let bounds ="}, {"sha": "7c431b4fc0bd065279edc29078605de20e4a70c8", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -124,7 +124,8 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             check_pat_struct(pcx, pat, path, fields.as_slice(), etc, expected);\n         }\n         ast::PatTup(ref elements) => {\n-            let element_tys = Vec::from_fn(elements.len(), |_| fcx.infcx().next_ty_var());\n+            let element_tys: Vec<_> = range(0, elements.len()).map(|_| fcx.infcx()\n+                .next_ty_var()).collect();\n             let pat_ty = ty::mk_tup(tcx, element_tys.clone());\n             fcx.write_ty(pat.id, pat_ty);\n             demand::eqtype(fcx, pat.span, expected, pat_ty);"}, {"sha": "a751b65a0f8c58233cacd91266082958ded4b931", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -24,6 +24,7 @@ use syntax::ast;\n use syntax::codemap::Span;\n use std::rc::Rc;\n use std::mem;\n+use std::iter::repeat;\n use util::ppaux::Repr;\n \n struct ConfirmContext<'a, 'tcx:'a> {\n@@ -339,7 +340,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             } else if num_supplied_types != num_method_types {\n                 span_err!(self.tcx().sess, self.span, E0036,\n                     \"incorrect number of type parameters given for this method\");\n-                Vec::from_elem(num_method_types, self.tcx().types.err)\n+                repeat(self.tcx().types.err).take(num_method_types).collect()\n             } else {\n                 supplied_method_types\n             }"}, {"sha": "f3a4a8d177e233b1153f1423b4ed7ebcb2b5c55a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -110,6 +110,7 @@ use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n use std::cell::{Cell, Ref, RefCell};\n use std::mem::replace;\n use std::rc::Rc;\n+use std::iter::repeat;\n use syntax::{mod, abi, attr};\n use syntax::ast::{mod, ProvidedMethod, RequiredMethod, TypeTraitItem, DefId};\n use syntax::ast_util::{mod, local_def, PostExpansionMethod};\n@@ -2130,9 +2131,9 @@ impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> {\n \n     fn anon_regions(&self, span: Span, count: uint)\n                     -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>> {\n-        Ok(Vec::from_fn(count, |_| {\n+        Ok(range(0, count).map(|_| {\n             self.infcx().next_region_var(infer::MiscVariable(span))\n-        }))\n+        }).collect())\n     }\n }\n \n@@ -2810,7 +2811,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n // FIXME(#17596) Ty<'tcx> is incorrectly invariant w.r.t 'tcx.\n fn err_args<'tcx>(tcx: &ty::ctxt<'tcx>, len: uint) -> Vec<Ty<'tcx>> {\n-    Vec::from_fn(len, |_| tcx.types.err)\n+    range(0, len).map(|_| tcx.types.err).collect()\n }\n \n fn write_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -5166,7 +5167,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // The first step then is to categorize the segments appropriately.\n \n     assert!(path.segments.len() >= 1);\n-    let mut segment_spaces;\n+    let mut segment_spaces: Vec<_>;\n     match def {\n         // Case 1 and 1b. Reference to a *type* or *enum variant*.\n         def::DefSelfTy(..) |\n@@ -5181,15 +5182,15 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         def::DefTyParam(..) => {\n             // Everything but the final segment should have no\n             // parameters at all.\n-            segment_spaces = Vec::from_elem(path.segments.len() - 1, None);\n+            segment_spaces = repeat(None).take(path.segments.len() - 1).collect();\n             segment_spaces.push(Some(subst::TypeSpace));\n         }\n \n         // Case 2. Reference to a top-level value.\n         def::DefFn(..) |\n         def::DefConst(..) |\n         def::DefStatic(..) => {\n-            segment_spaces = Vec::from_elem(path.segments.len() - 1, None);\n+            segment_spaces = repeat(None).take(path.segments.len() - 1).collect();\n             segment_spaces.push(Some(subst::FnSpace));\n         }\n \n@@ -5205,7 +5206,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 def::FromImpl(_) => {}\n             }\n \n-            segment_spaces = Vec::from_elem(path.segments.len() - 2, None);\n+            segment_spaces = repeat(None).take(path.segments.len() - 2).collect();\n             segment_spaces.push(Some(subst::TypeSpace));\n             segment_spaces.push(Some(subst::FnSpace));\n         }\n@@ -5220,7 +5221,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         def::DefRegion(..) |\n         def::DefLabel(..) |\n         def::DefUpvar(..) => {\n-            segment_spaces = Vec::from_elem(path.segments.len(), None);\n+            segment_spaces = repeat(None).take(path.segments.len()).collect();\n         }\n     }\n     assert_eq!(segment_spaces.len(), path.segments.len());\n@@ -5489,8 +5490,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 \"too few type parameters provided: expected {}{} parameter(s) \\\n                 , found {} parameter(s)\",\n                 qualifier, required_len, provided_len);\n-            substs.types.replace(space,\n-                                 Vec::from_elem(desired.len(), fcx.tcx().types.err));\n+            substs.types.replace(space, repeat(fcx.tcx().types.err).take(desired.len()).collect());\n             return;\n         }\n \n@@ -5614,7 +5614,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     // make a vector of booleans initially false, set to true when used\n     if tps.len() == 0u { return; }\n-    let mut tps_used = Vec::from_elem(tps.len(), false);\n+    let mut tps_used: Vec<_> = repeat(false).take(tps.len()).collect();\n \n     ty::walk_ty(ty, |t| {\n             match t.sty {"}, {"sha": "42ffe2d5327bc4eb85a520c942dba6252b968d99", "filename": "src/librustc_typeck/check/regionmanip.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -409,4 +409,3 @@ impl<'tcx> Repr<'tcx> for WfConstraint<'tcx> {\n         }\n     }\n }\n-"}, {"sha": "c62218313f4e810142640a3d8a15feaa897dded5", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -13,6 +13,7 @@ use middle::ty;\n use middle::ty_fold;\n \n use std::cell::Cell;\n+use std::iter::repeat;\n use syntax::codemap::Span;\n \n /// Defines strategies for handling regions that are omitted.  For\n@@ -99,7 +100,7 @@ impl RegionScope for SpecificRscope {\n                     count: uint)\n                     -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>\n     {\n-        Ok(Vec::from_elem(count, self.default))\n+        Ok(repeat(self.default).take(count).collect())\n     }\n }\n \n@@ -134,7 +135,7 @@ impl RegionScope for BindingRscope {\n                     count: uint)\n                     -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>\n     {\n-        Ok(Vec::from_fn(count, |_| self.next_region()))\n+        Ok(range(0, count).map(|_| self.next_region()).collect())\n     }\n }\n "}, {"sha": "de0b0a7ad3548e75c444d457c0b7944e15711cb0", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -199,6 +199,7 @@ use middle::subst::{ParamSpace, FnSpace, TypeSpace, SelfSpace, VecPerParamSpace}\n use middle::ty::{mod, Ty};\n use std::fmt;\n use std::rc::Rc;\n+use std::iter::repeat;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n@@ -971,7 +972,7 @@ struct SolveContext<'a, 'tcx: 'a> {\n \n fn solve_constraints(constraints_cx: ConstraintContext) {\n     let ConstraintContext { terms_cx, constraints, .. } = constraints_cx;\n-    let solutions = Vec::from_elem(terms_cx.num_inferred(), ty::Bivariant);\n+    let solutions: Vec<_> = repeat(ty::Bivariant).take(terms_cx.num_inferred()).collect();\n     let mut solutions_cx = SolveContext {\n         terms_cx: terms_cx,\n         constraints: constraints,"}, {"sha": "3c09a10f3d98ed651dd4447540d0bf6c25b4df0c", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -398,7 +398,7 @@ fn primitive_link(f: &mut fmt::Formatter,\n                 Some(root) => {\n                     try!(write!(f, \"<a href='{}{}/primitive.{}.html'>\",\n                                 root,\n-                                path.0.head().unwrap(),\n+                                path.0.first().unwrap(),\n                                 prim.to_url_str()));\n                     needs_termination = true;\n                 }"}, {"sha": "f8a0b88b4088d99ac4ffcf7fbf56771f3d7d359a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -1799,7 +1799,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     try!(write!(w, r#\"<script type=\"text/javascript\" async\n                               src=\"{root_path}/implementors/{path}/{ty}.{name}.js\">\n                       </script>\"#,\n-                root_path = Vec::from_elem(cx.current.len(), \"..\").connect(\"/\"),\n+                root_path = repeat(\"..\").take(cx.current.len()).collect::<Vec<_>>().connect(\"/\"),\n                 path = if ast_util::is_local(it.def_id) {\n                     cx.current.connect(\"/\")\n                 } else {\n@@ -2055,7 +2055,8 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n     match cache().impls.get(&it.def_id) {\n         Some(v) => {\n-            let (non_trait, traits) = v.partitioned(|i| i.impl_.trait_.is_none());\n+            let (non_trait, traits): (Vec<_>, _) = v.iter().cloned()\n+                .partition(|i| i.impl_.trait_.is_none());\n             if non_trait.len() > 0 {\n                 try!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n                 for i in non_trait.iter() {\n@@ -2065,7 +2066,8 @@ fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n             if traits.len() > 0 {\n                 try!(write!(w, \"<h2 id='implementations'>Trait \\\n                                   Implementations</h2>\"));\n-                let (derived, manual) = traits.partition(|i| i.impl_.derived);\n+                let (derived, manual): (Vec<_>, _) = traits.into_iter()\n+                    .partition(|i| i.impl_.derived);\n                 for i in manual.iter() {\n                     try!(render_impl(w, i));\n                 }"}, {"sha": "4e22fc6008037cc41cd50ce77218e57954e06834", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -74,7 +74,7 @@ use fmt;\n use hash;\n use mem;\n use ptr;\n-use slice::{mod, ImmutableIntSlice};\n+use slice::{mod, IntSliceExt};\n use str;\n use string::String;\n use core::kinds::marker;"}, {"sha": "a8004155af06d7bde0a02a57ac9b1b3af2223d24", "filename": "src/libstd/comm/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibstd%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibstd%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fsync.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -148,7 +148,7 @@ impl<T: Send> Packet<T> {\n                     tail: 0 as *mut Node,\n                 },\n                 buf: Buffer {\n-                    buf: Vec::from_fn(cap + if cap == 0 {1} else {0}, |_| None),\n+                    buf: range(0, cap + if cap == 0 {1} else {0}).map(|_| None).collect(),\n                     start: 0,\n                     size: 0,\n                 },"}, {"sha": "0fba0f6704be4bac990c9f2dbd06c632f5904b33", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -439,9 +439,10 @@ mod test {\n \n     impl Reader for ShortReader {\n         fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> {\n-            match self.lengths.remove(0) {\n-                Some(i) => Ok(i),\n-                None => Err(io::standard_error(io::EndOfFile))\n+            if self.lengths.is_empty() {\n+                Err(io::standard_error(io::EndOfFile))\n+            } else {\n+                Ok(self.lengths.remove(0))\n             }\n         }\n     }"}, {"sha": "181c4c04c5129d36ad461215451fbcd86f6f3208", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -158,6 +158,7 @@ pub use alloc::rc;\n pub use core_collections::slice;\n pub use core_collections::str;\n pub use core_collections::string;\n+#[stable]\n pub use core_collections::vec;\n \n pub use unicode::char;"}, {"sha": "a9d9607395ce52997ca3549ad2354776cd093459", "filename": "src/libstd/os.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -620,10 +620,11 @@ pub fn get_exit_status() -> int {\n unsafe fn load_argc_and_argv(argc: int,\n                              argv: *const *const c_char) -> Vec<Vec<u8>> {\n     use c_str::CString;\n+    use iter::range;\n \n-    Vec::from_fn(argc as uint, |i| {\n+    range(0, argc as uint).map(|i| {\n         CString::new(*argv.offset(i as int), false).as_bytes_no_nul().to_vec()\n-    })\n+    }).collect()\n }\n \n /// Returns the command line arguments\n@@ -721,7 +722,7 @@ fn real_args() -> Vec<String> {\n     let lpCmdLine = unsafe { GetCommandLineW() };\n     let szArgList = unsafe { CommandLineToArgvW(lpCmdLine, lpArgCount) };\n \n-    let args = Vec::from_fn(nArgs as uint, |i| unsafe {\n+    let args: Vec<_> = range(0, nArgs as uint).map(|i| unsafe {\n         // Determine the length of this argument.\n         let ptr = *szArgList.offset(i as int);\n         let mut len = 0;\n@@ -732,7 +733,7 @@ fn real_args() -> Vec<String> {\n         let buf = slice::from_raw_buf(&ptr, len);\n         let opt_s = String::from_utf16(sys::os::truncate_utf16_at_nul(buf));\n         opt_s.ok().expect(\"CommandLineToArgvW returned invalid UTF-16\")\n-    });\n+    }).collect();\n \n     unsafe {\n         LocalFree(szArgList as *mut c_void);"}, {"sha": "bd4031e623085ee0c1263833ba9eef187918c109", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -22,14 +22,14 @@ use option::Option::{None, Some};\n use kinds::Sized;\n use str::{FromStr, Str};\n use str;\n-use slice::{CloneSliceExt, Splits, AsSlice, VectorVector,\n+use slice::{CloneSliceExt, Split, AsSlice, SliceConcatExt,\n             PartialEqSliceExt, SliceExt};\n use vec::Vec;\n \n use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n \n /// Iterator that yields successive components of a Path as &[u8]\n-pub type Components<'a> = Splits<'a, u8, fn(&u8) -> bool>;\n+pub type Components<'a> = Split<'a, u8, fn(&u8) -> bool>;\n \n /// Iterator that yields successive components of a Path as Option<&str>\n pub type StrComponents<'a> =\n@@ -306,7 +306,7 @@ impl GenericPath for Path {\n                     }\n                 }\n             }\n-            Some(Path::new(comps.connect_vec(&SEP_BYTE)))\n+            Some(Path::new(comps.as_slice().connect(&SEP_BYTE)))\n         }\n     }\n "}, {"sha": "751ed4b70fb38fa1646c49a1b5ae47217d45d0ea", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -25,8 +25,8 @@ use iter::{Iterator, IteratorExt, Map, repeat};\n use mem;\n use option::Option;\n use option::Option::{Some, None};\n-use slice::SliceExt;\n-use str::{SplitTerminator, FromStr, StrVector, StrExt};\n+use slice::{SliceExt, SliceConcatExt};\n+use str::{SplitTerminator, FromStr, StrExt};\n use string::{String, ToString};\n use unicode::char::UnicodeChar;\n use vec::Vec;"}, {"sha": "f016683e3d0a99991cf5f07db5befa71e6edb27e", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -66,7 +66,7 @@\n #[doc(no_inline)] pub use iter::{FromIterator, Extend, ExactSizeIterator};\n #[doc(no_inline)] pub use iter::{Iterator, IteratorExt, DoubleEndedIterator};\n #[doc(no_inline)] pub use iter::{DoubleEndedIteratorExt, CloneIteratorExt};\n-#[doc(no_inline)] pub use iter::{RandomAccessIterator, IteratorCloneExt};\n+#[doc(no_inline)] pub use iter::{RandomAccessIterator, IteratorCloneExt, IteratorPairExt};\n #[doc(no_inline)] pub use iter::{IteratorOrdExt, MutableDoubleEndedIterator};\n #[doc(no_inline)] pub use num::{ToPrimitive, FromPrimitive};\n #[doc(no_inline)] pub use boxed::Box;\n@@ -80,10 +80,9 @@\n #[doc(no_inline)] pub use core::prelude::{Tuple1, Tuple2, Tuple3, Tuple4};\n #[doc(no_inline)] pub use core::prelude::{Tuple5, Tuple6, Tuple7, Tuple8};\n #[doc(no_inline)] pub use core::prelude::{Tuple9, Tuple10, Tuple11, Tuple12};\n-#[doc(no_inline)] pub use str::{Str, StrVector};\n-#[doc(no_inline)] pub use str::StrExt;\n+#[doc(no_inline)] pub use str::{Str, StrExt};\n #[doc(no_inline)] pub use slice::AsSlice;\n-#[doc(no_inline)] pub use slice::{VectorVector, PartialEqSliceExt};\n+#[doc(no_inline)] pub use slice::{SliceConcatExt, PartialEqSliceExt};\n #[doc(no_inline)] pub use slice::{CloneSliceExt, OrdSliceExt, SliceExt};\n #[doc(no_inline)] pub use slice::{BoxedSliceExt};\n #[doc(no_inline)] pub use string::{IntoString, String, ToString};"}, {"sha": "98eff621ce0f3c95c3c28552ff007b2e5b29a7ae", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -95,14 +95,14 @@ mod imp {\n     }\n \n     unsafe fn load_argc_and_argv(argc: int, argv: *const *const u8) -> Vec<Vec<u8>> {\n-        Vec::from_fn(argc as uint, |i| {\n+        range(0, argc as uint).map(|i| {\n             let arg = *argv.offset(i as int);\n             let mut len = 0u;\n             while *arg.offset(len as int) != 0 {\n                 len += 1u;\n             }\n             slice::from_raw_buf(&arg, len).to_vec()\n-        })\n+        }).collect()\n     }\n \n     #[cfg(test)]"}, {"sha": "150ec6aad8aa98f3a2f642c7bc9b928a730b8981", "filename": "src/libstd/sys/unix/timer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -120,9 +120,9 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n     // signals the first requests in the queue, possible re-enqueueing it.\n     fn signal(active: &mut Vec<Box<Inner>>,\n               dead: &mut Vec<(uint, Box<Inner>)>) {\n-        let mut timer = match active.remove(0) {\n-            Some(timer) => timer, None => return\n-        };\n+        if active.is_empty() { return }\n+\n+        let mut timer = active.remove(0);\n         let mut cb = timer.cb.take().unwrap();\n         cb.call();\n         if timer.repeat {\n@@ -185,15 +185,15 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n                         Ok(RemoveTimer(id, ack)) => {\n                             match dead.iter().position(|&(i, _)| id == i) {\n                                 Some(i) => {\n-                                    let (_, i) = dead.remove(i).unwrap();\n+                                    let (_, i) = dead.remove(i);\n                                     ack.send(i);\n                                     continue\n                                 }\n                                 None => {}\n                             }\n                             let i = active.iter().position(|i| i.id == id);\n                             let i = i.expect(\"no timer found\");\n-                            let t = active.remove(i).unwrap();\n+                            let t = active.remove(i);\n                             ack.send(t);\n                         }\n                         Err(..) => break"}, {"sha": "235ebf211ac08e27879e662bfd41063cf40742d0", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -16,13 +16,14 @@\n use prelude::*;\n \n use io::{IoResult, IoError};\n+use iter::repeat;\n use libc::{c_int, c_void};\n use libc;\n use os;\n use path::BytesContainer;\n use ptr;\n-use sys::fs::FileDesc;\n use slice;\n+use sys::fs::FileDesc;\n \n use os::TMPBUF_SZ;\n use libc::types::os::arch::extra::DWORD;\n@@ -128,7 +129,7 @@ pub fn fill_utf16_buf_and_decode(f: |*mut u16, DWORD| -> DWORD) -> Option<String\n         let mut res = None;\n         let mut done = false;\n         while !done {\n-            let mut buf = Vec::from_elem(n as uint, 0u16);\n+            let mut buf: Vec<u16> = repeat(0u16).take(n).collect();\n             let k = f(buf.as_mut_ptr(), n);\n             if k == (0 as DWORD) {\n                 done = true;"}, {"sha": "415524733ff504ee9efe65b1f609198c74e1c703", "filename": "src/libstd/sys/windows/tty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -33,6 +33,7 @@ use libc::{c_int, HANDLE, LPDWORD, DWORD, LPVOID};\n use libc::{get_osfhandle, CloseHandle};\n use libc::types::os::arch::extra::LPCVOID;\n use io::{mod, IoError, IoResult, MemReader};\n+use iter::repeat;\n use prelude::*;\n use ptr;\n use str::from_utf8;\n@@ -90,7 +91,7 @@ impl TTY {\n     pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         // Read more if the buffer is empty\n         if self.utf8.eof() {\n-            let mut utf16 = Vec::from_elem(0x1000, 0u16);\n+            let mut utf16: Vec<u16> = repeat(0u16).take(0x1000).collect();\n             let mut num: DWORD = 0;\n             match unsafe { ReadConsoleW(self.handle,\n                                          utf16.as_mut_ptr() as LPVOID,"}, {"sha": "b5395d09ca7d4adb2b90a34fdae0bee7a1343615", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -26,7 +26,7 @@ use arena::TypedArena;\n use std::cell::RefCell;\n use std::fmt;\n use std::io::IoResult;\n-use std::iter;\n+use std::iter::{mod, repeat};\n use std::mem;\n use std::slice;\n \n@@ -726,7 +726,7 @@ impl<'ast> NodeCollector<'ast> {\n         debug!(\"ast_map: {} => {}\", id, entry);\n         let len = self.map.len();\n         if id as uint >= len {\n-            self.map.grow(id as uint - len + 1, NotPresent);\n+            self.map.extend(repeat(NotPresent).take(id as uint - len + 1));\n         }\n         self.map[id as uint] = entry;\n     }"}, {"sha": "9fcaf2210c194ea74d726ccc855adca5a2eade3d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -470,7 +470,7 @@ pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n fn expand_item_modifiers(mut it: P<ast::Item>, fld: &mut MacroExpander)\n                          -> P<ast::Item> {\n     // partition the attributes into ItemModifiers and others\n-    let (modifiers, other_attrs) = it.attrs.partitioned(|attr| {\n+    let (modifiers, other_attrs): (Vec<_>, _) = it.attrs.iter().cloned().partition(|attr| {\n         match fld.cx.syntax_env.find(&intern(attr.name().get())) {\n             Some(rc) => match *rc { Modifier(_) => true, _ => false },\n             _ => false"}, {"sha": "500070a14d2d9f6b7281811c2ca31b2638ac38af", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -22,6 +22,7 @@ use parse::token;\n use ptr::P;\n \n use std::collections::HashMap;\n+use std::iter::repeat;\n \n #[deriving(PartialEq)]\n enum ArgumentType {\n@@ -477,7 +478,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// to\n     fn into_expr(mut self) -> P<ast::Expr> {\n         let mut locals = Vec::new();\n-        let mut names = Vec::from_fn(self.name_positions.len(), |_| None);\n+        let mut names: Vec<_> = repeat(None).take(self.name_positions.len()).collect();\n         let mut pats = Vec::new();\n         let mut heads = Vec::new();\n \n@@ -664,7 +665,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n                                     name_ordering: Vec<String>,\n                                     names: HashMap<String, P<ast::Expr>>)\n                                     -> P<ast::Expr> {\n-    let arg_types = Vec::from_fn(args.len(), |_| None);\n+    let arg_types: Vec<_> = range(0, args.len()).map(|_| None).collect();\n     let mut cx = Context {\n         ecx: ecx,\n         args: args,\n@@ -707,13 +708,10 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n             None => break\n         }\n     }\n-    match parser.errors.remove(0) {\n-        Some(error) => {\n-            cx.ecx.span_err(cx.fmtsp,\n-                            format!(\"invalid format string: {}\", error)[]);\n-            return DummyResult::raw_expr(sp);\n-        }\n-        None => {}\n+    if !parser.errors.is_empty() {\n+        cx.ecx.span_err(cx.fmtsp, format!(\"invalid format string: {}\",\n+                                          parser.errors.remove(0))[]);\n+        return DummyResult::raw_expr(sp);\n     }\n     if !cx.literal.is_empty() {\n         let s = cx.trans_literal_string();"}, {"sha": "65ecf701e8dfcbd433041379ea3523138d8f4150", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -166,7 +166,7 @@ pub fn count_names(ms: &[TokenTree]) -> uint {\n pub fn initial_matcher_pos(ms: Rc<Vec<TokenTree>>, sep: Option<Token>, lo: BytePos)\n                            -> Box<MatcherPos> {\n     let match_idx_hi = count_names(ms[]);\n-    let matches = Vec::from_fn(match_idx_hi, |_i| Vec::new());\n+    let matches: Vec<_> = range(0, match_idx_hi).map(|_| Vec::new()).collect();\n     box MatcherPos {\n         stack: vec![],\n         top_elts: TtSeq(ms),\n@@ -392,7 +392,8 @@ pub fn parse(sess: &ParseSess,\n                             cur_eis.push(new_ei);\n                         }\n \n-                        let matches = Vec::from_elem(ei.matches.len(), Vec::new());\n+                        let matches: Vec<_> = range(0, ei.matches.len())\n+                            .map(|_| Vec::new()).collect();\n                         let ei_t = ei;\n                         cur_eis.push(box MatcherPos {\n                             stack: vec![],"}, {"sha": "a15f1ca354bffd8e870483e07dd7f288a18348f9", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -65,6 +65,7 @@ pub use self::Token::*;\n \n use std::io;\n use std::string;\n+use std::iter::repeat;\n \n #[deriving(Clone, Copy, PartialEq)]\n pub enum Breaks {\n@@ -166,9 +167,9 @@ pub fn mk_printer(out: Box<io::Writer+'static>, linewidth: uint) -> Printer {\n     // fall behind.\n     let n: uint = 3 * linewidth;\n     debug!(\"mk_printer {}\", linewidth);\n-    let token: Vec<Token> = Vec::from_elem(n, Eof);\n-    let size: Vec<int> = Vec::from_elem(n, 0i);\n-    let scan_stack: Vec<uint> = Vec::from_elem(n, 0u);\n+    let token: Vec<Token> = repeat(Eof).take(n).collect();\n+    let size: Vec<int> = repeat(0i).take(n).collect();\n+    let scan_stack: Vec<uint> = repeat(0u).take(n).collect();\n     Printer {\n         out: out,\n         buf_len: n,"}, {"sha": "c1823231e24f75133f609268d2092d90273048b6", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -163,7 +163,7 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n                 }),\n         };\n \n-        let (crates, uses) = view_items.partitioned(|x| {\n+        let (crates, uses): (Vec<_>, _) = view_items.iter().cloned().partition(|x| {\n             match x.node {\n                 ast::ViewItemExternCrate(..) => true,\n                 _ => false,"}, {"sha": "680ed55cd98438db54a196aec96a8f14311b8a4a", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -16,6 +16,7 @@ use self::FormatState::*;\n use self::FormatOp::*;\n use std::ascii::OwnedAsciiExt;\n use std::mem::replace;\n+use std::iter::repeat;\n \n #[deriving(Copy, PartialEq)]\n enum States {\n@@ -508,7 +509,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n             if flags.precision > s.len() {\n                 let mut s_ = Vec::with_capacity(flags.precision);\n                 let n = flags.precision - s.len();\n-                s_.grow(n, b'0');\n+                s_.extend(repeat(b'0').take(n));\n                 s_.extend(s.into_iter());\n                 s = s_;\n             }\n@@ -560,10 +561,10 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n     if flags.width > s.len() {\n         let n = flags.width - s.len();\n         if flags.left {\n-            s.grow(n, b' ');\n+            s.extend(repeat(b' ').take(n));\n         } else {\n             let mut s_ = Vec::with_capacity(flags.width);\n-            s_.grow(n, b' ');\n+            s_.extend(repeat(b' ').take(n));\n             s_.extend(s.into_iter());\n             s = s_;\n         }"}, {"sha": "c097e9337905093b510f1d1c6f0c30519c641fe9", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -990,8 +990,8 @@ fn run_tests<F>(opts: &TestOpts,\n \n     try!(callback(TeFiltered(filtered_descs)));\n \n-    let (filtered_tests, filtered_benchs_and_metrics) =\n-        filtered_tests.partition(|e| {\n+    let (filtered_tests, filtered_benchs_and_metrics): (Vec<_>, _) =\n+        filtered_tests.into_iter().partition(|e| {\n             match e.testfn {\n                 StaticTestFn(_) | DynTestFn(_) => true,\n                 _ => false"}, {"sha": "9e4aa0712470bc6c7ebe346d0fb62f119927b7f8", "filename": "src/libunicode/normalize.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibunicode%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibunicode%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fnormalize.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -13,21 +13,21 @@\n use core::cmp::Ordering::{Equal, Less, Greater};\n use core::option::Option;\n use core::option::Option::{Some, None};\n-use core::slice;\n use core::slice::SliceExt;\n+use core::result::Result::{Ok, Err};\n use tables::normalization::{canonical_table, compatibility_table, composition_table};\n \n fn bsearch_table<T>(c: char, r: &'static [(char, &'static [T])]) -> Option<&'static [T]> {\n-    match r.binary_search(|&(val, _)| {\n+    match r.binary_search_by(|&(val, _)| {\n         if c == val { Equal }\n         else if val < c { Less }\n         else { Greater }\n     }) {\n-        slice::BinarySearchResult::Found(idx) => {\n+        Ok(idx) => {\n             let (_, result) = r[idx];\n             Some(result)\n         }\n-        slice::BinarySearchResult::NotFound(_) => None\n+        Err(_) => None\n     }\n }\n \n@@ -81,16 +81,16 @@ pub fn compose(a: char, b: char) -> Option<char> {\n         match bsearch_table(a, composition_table) {\n             None => None,\n             Some(candidates) => {\n-                match candidates.binary_search(|&(val, _)| {\n+                match candidates.binary_search_by(|&(val, _)| {\n                     if b == val { Equal }\n                     else if val < b { Less }\n                     else { Greater }\n                 }) {\n-                    slice::BinarySearchResult::Found(idx) => {\n+                    Ok(idx) => {\n                         let (_, result) = candidates[idx];\n                         Some(result)\n                     }\n-                    slice::BinarySearchResult::NotFound(_) => None\n+                    Err(_) => None\n                 }\n             }\n         }"}, {"sha": "5a8f63f207e2721be96a15bfcadf8b83c453c5a3", "filename": "src/libunicode/tables.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibunicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Flibunicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Ftables.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -19,11 +19,11 @@ pub const UNICODE_VERSION: (uint, uint, uint) = (7, 0, 0);\n fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n     use core::cmp::Ordering::{Equal, Less, Greater};\n     use core::slice::SliceExt;\n-    r.binary_search(|&(lo,hi)| {\n+    r.binary_search_by(|&(lo,hi)| {\n         if lo <= c && c <= hi { Equal }\n         else if hi < c { Less }\n         else { Greater }\n-    }).found().is_some()\n+    }).is_ok()\n }\n \n pub mod general_category {\n@@ -6826,17 +6826,17 @@ pub mod normalization {\n     fn bsearch_range_value_table(c: char, r: &'static [(char, char, u8)]) -> u8 {\n         use core::cmp::Ordering::{Equal, Less, Greater};\n         use core::slice::SliceExt;\n-        use core::slice;\n-        match r.binary_search(|&(lo, hi, _)| {\n+        use core::result::Result::{Ok, Err};\n+        match r.binary_search_by(|&(lo, hi, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n         }) {\n-            slice::BinarySearchResult::Found(idx) => {\n+            Ok(idx) => {\n                 let (_, _, result) = r[idx];\n                 result\n             }\n-            slice::BinarySearchResult::NotFound(_) => 0\n+            Err(_) => 0\n         }\n     }\n \n@@ -6961,7 +6961,7 @@ pub mod conversions {\n     use core::slice::SliceExt;\n     use core::option::Option;\n     use core::option::Option::{Some, None};\n-    use core::slice;\n+    use core::result::Result::{Ok, Err};\n \n     pub fn to_lower(c: char) -> char {\n         match bsearch_case_table(c, LuLl_table) {\n@@ -6978,13 +6978,13 @@ pub mod conversions {\n     }\n \n     fn bsearch_case_table(c: char, table: &'static [(char, char)]) -> Option<uint> {\n-        match table.binary_search(|&(key, _)| {\n+        match table.binary_search_by(|&(key, _)| {\n             if c == key { Equal }\n             else if key < c { Less }\n             else { Greater }\n         }) {\n-            slice::BinarySearchResult::Found(i) => Some(i),\n-            slice::BinarySearchResult::NotFound(_) => None,\n+            Ok(i) => Some(i),\n+            Err(_) => None,\n         }\n     }\n \n@@ -7596,20 +7596,20 @@ pub mod charwidth {\n     use core::option::Option;\n     use core::option::Option::{Some, None};\n     use core::slice::SliceExt;\n-    use core::slice;\n+    use core::result::Result::{Ok, Err};\n \n     fn bsearch_range_value_table(c: char, is_cjk: bool, r: &'static [(char, char, u8, u8)]) -> u8 {\n         use core::cmp::Ordering::{Equal, Less, Greater};\n-        match r.binary_search(|&(lo, hi, _, _)| {\n+        match r.binary_search_by(|&(lo, hi, _, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n         }) {\n-            slice::BinarySearchResult::Found(idx) => {\n+            Ok(idx) => {\n                 let (_, _, r_ncjk, r_cjk) = r[idx];\n                 if is_cjk { r_cjk } else { r_ncjk }\n             }\n-            slice::BinarySearchResult::NotFound(_) => 1\n+            Err(_) => 1\n         }\n     }\n \n@@ -7804,7 +7804,7 @@ pub mod grapheme {\n     use core::kinds::Copy;\n     use core::slice::SliceExt;\n     pub use self::GraphemeCat::*;\n-    use core::slice;\n+    use core::result::Result::{Ok, Err};\n \n     #[allow(non_camel_case_types)]\n     #[deriving(Clone)]\n@@ -7825,16 +7825,16 @@ pub mod grapheme {\n \n     fn bsearch_range_value_table(c: char, r: &'static [(char, char, GraphemeCat)]) -> GraphemeCat {\n         use core::cmp::Ordering::{Equal, Less, Greater};\n-        match r.binary_search(|&(lo, hi, _)| {\n+        match r.binary_search_by(|&(lo, hi, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n         }) {\n-            slice::BinarySearchResult::Found(idx) => {\n+            Ok(idx) => {\n                 let (_, _, cat) = r[idx];\n                 cat\n             }\n-            slice::BinarySearchResult::NotFound(_) => GC_Any\n+            Err(_) => GC_Any\n         }\n     }\n "}, {"sha": "26d4ec25c643955f3641f0a38aaf4b81c60f62d7", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -65,7 +65,7 @@ fn shift_push() {\n     let mut v2 = Vec::new();\n \n     while v1.len() > 0 {\n-        v2.push(v1.remove(0).unwrap());\n+        v2.push(v1.remove(0));\n     }\n }\n "}, {"sha": "909f8afc34a9fe68f5dd1fa1c92a1f7bbc4aebca", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -181,7 +181,7 @@ fn reverse_complement(seq: &mut [u8], tables: &Tables) {\n         unsafe {\n             copy_memory(seq.as_mut_ptr().offset((i - off + 1) as int),\n                         seq.as_ptr().offset((i - off) as int), off);\n-            *seq.unsafe_mut(i - off) = b'\\n';\n+            *seq.get_unchecked_mut(i - off) = b'\\n';\n         }\n         i += LINE_LEN + 1;\n     }"}, {"sha": "5be3b960ec635711d09cdff1ecb2623836257376", "filename": "src/test/compile-fail/issue-15756.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Ftest%2Fcompile-fail%2Fissue-15756.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Ftest%2Fcompile-fail%2Fissue-15756.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15756.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n use std::slice::Chunks;\n-use std::slice::MutChunks;\n+use std::slice::ChunksMut;\n \n-fn dft_iter<'a, T>(arg1: Chunks<'a,T>, arg2: MutChunks<'a,T>)\n+fn dft_iter<'a, T>(arg1: Chunks<'a,T>, arg2: ChunksMut<'a,T>)\n {\n     for\n     &something"}, {"sha": "45b0314d2c01da88190a844571b87fecb337bb44", "filename": "src/test/compile-fail/resolve-conflict-type-vs-import.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-type-vs-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d13883f868e6b27aa00a6c69f7c748d16e1c94/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-type-vs-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-type-vs-import.rs?ref=67d13883f868e6b27aa00a6c69f7c748d16e1c94", "patch": "@@ -15,4 +15,3 @@ struct Iter;\n \n fn main() {\n }\n-"}]}