{"sha": "d69108d8f78a9b5a8669606b62fe6df6409d17e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2OTEwOGQ4Zjc4YTliNWE4NjY5NjA2YjYyZmU2ZGY2NDA5ZDE3ZTc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-03-24T05:11:42Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-03-26T23:21:05Z"}, "message": "std: Remove the oldmap module", "tree": {"sha": "65b4789c0d2ba30391c2cef2681c753bc4e40ff6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65b4789c0d2ba30391c2cef2681c753bc4e40ff6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d69108d8f78a9b5a8669606b62fe6df6409d17e7", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d69108d8f78a9b5a8669606b62fe6df6409d17e7", "html_url": "https://github.com/rust-lang/rust/commit/d69108d8f78a9b5a8669606b62fe6df6409d17e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d69108d8f78a9b5a8669606b62fe6df6409d17e7/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbe1354321e6d8aa5bfe09ac33d780a97d3f7788", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbe1354321e6d8aa5bfe09ac33d780a97d3f7788", "html_url": "https://github.com/rust-lang/rust/commit/dbe1354321e6d8aa5bfe09ac33d780a97d3f7788"}], "stats": {"total": 390, "additions": 0, "deletions": 390}, "files": [{"sha": "b40237cf5848f1ba6fec33ce1123c95a73deb633", "filename": "src/libstd/oldmap.rs", "status": "removed", "additions": 0, "deletions": 388, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/dbe1354321e6d8aa5bfe09ac33d780a97d3f7788/src%2Flibstd%2Foldmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbe1354321e6d8aa5bfe09ac33d780a97d3f7788/src%2Flibstd%2Foldmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldmap.rs?ref=dbe1354321e6d8aa5bfe09ac33d780a97d3f7788", "patch": "@@ -1,388 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A deprecated compatibility layer on top of `core::hashmap`\n-\n-use core::prelude::*;\n-use core::hash::Hash;\n-use core::prelude::*;\n-use core::to_bytes::IterBytes;\n-use core::vec;\n-\n-/// A convenience type to treat a hashmap as a set\n-pub type Set<K> = HashMap<K, ()>;\n-\n-pub type HashMap<K, V> = chained::T<K, V>;\n-\n-pub mod chained {\n-    use core::ops;\n-    use core::prelude::*;\n-    use core::hashmap::linear::LinearMap;\n-\n-    struct HashMap_<K, V> {\n-        priv map: LinearMap<K, V>\n-    }\n-\n-    pub type T<K, V> = @mut HashMap_<K, V>;\n-\n-    pub impl<K:Eq + IterBytes + Hash,V> HashMap_<K, V> {\n-        fn clear(&mut self) {\n-            self.map.clear()\n-        }\n-    }\n-\n-    impl<K:Eq + IterBytes + Hash,V> Container for HashMap_<K, V> {\n-        fn len(&const self) -> uint { self.map.len() }\n-        fn is_empty(&const self) -> bool { self.map.is_empty() }\n-    }\n-\n-    pub impl<K:Eq + IterBytes + Hash,V> HashMap_<K, V> {\n-        fn contains_key(&self, k: &K) -> bool {\n-            self.map.contains_key(k)\n-        }\n-\n-        fn insert(&mut self, k: K, v: V) -> bool {\n-            self.map.insert(k, v)\n-        }\n-\n-        fn remove(&mut self, k: &K) -> bool {\n-            self.map.remove(k)\n-        }\n-\n-        fn each(&self, blk: &fn(key: &K, value: &V) -> bool) {\n-            do self.map.each |&(k, v)| { blk(k, v) }\n-        }\n-\n-        fn each_key(&self, blk: &fn(key: &K) -> bool) {\n-            self.map.each_key(blk)\n-        }\n-\n-        fn each_value(&self, blk: &fn(value: &V) -> bool) {\n-            self.map.each_value(blk)\n-        }\n-    }\n-\n-    pub impl<K:Eq + IterBytes + Hash + Copy,V:Copy> HashMap_<K, V> {\n-        fn find(&self, k: &K) -> Option<V> {\n-            self.map.find(k).map(|&x| copy *x)\n-        }\n-\n-        fn update(&mut self, key: K, newval: V, ff: &fn(V, V) -> V) -> bool {\n-            match self.find(&key) {\n-                None => self.insert(key, newval),\n-                Some(orig) => self.insert(key, ff(orig, newval))\n-            }\n-        }\n-\n-        fn get(&self, k: &K) -> V {\n-            copy *self.map.get(k)\n-        }\n-    }\n-\n-    impl<K:Eq + IterBytes + Hash + Copy,V:Copy> ops::Index<K, V>\n-            for HashMap_<K, V> {\n-        fn index(&self, k: K) -> V {\n-            self.get(&k)\n-        }\n-    }\n-\n-    pub fn mk<K:Eq + IterBytes + Hash,V:Copy>() -> T<K,V> {\n-        @mut HashMap_{map: LinearMap::new()}\n-    }\n-}\n-\n-/*\n-Function: hashmap\n-\n-Construct a hashmap.\n-*/\n-pub fn HashMap<K:Eq + IterBytes + Hash + Const,V:Copy>()\n-        -> HashMap<K, V> {\n-    chained::mk()\n-}\n-\n-/// Convenience function for adding keys to a hashmap with nil type keys\n-pub fn set_add<K:Eq + IterBytes + Hash + Const + Copy>(set: Set<K>, key: K)\n-                                                    -> bool {\n-    set.insert(key, ())\n-}\n-\n-/// Convert a set into a vector.\n-pub fn vec_from_set<T:Eq + IterBytes + Hash + Copy>(s: Set<T>) -> ~[T] {\n-    do vec::build_sized(s.len()) |push| {\n-        for s.each_key() |&k| {\n-            push(k);\n-        }\n-    }\n-}\n-\n-/// Construct a hashmap from a vector\n-pub fn hash_from_vec<K:Eq + IterBytes + Hash + Const + Copy,V:Copy>(\n-    items: &[(K, V)]) -> HashMap<K, V> {\n-    let map = HashMap();\n-    for vec::each(items) |item| {\n-        match *item {\n-            (copy key, copy value) => {\n-                map.insert(key, value);\n-            }\n-        }\n-    }\n-    map\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use core::uint;\n-\n-    use super::*;\n-\n-    #[test]\n-    fn test_simple() {\n-        debug!(\"*** starting test_simple\");\n-        fn eq_uint(x: &uint, y: &uint) -> bool { *x == *y }\n-        fn uint_id(x: &uint) -> uint { *x }\n-        debug!(\"uint -> uint\");\n-        let hm_uu: HashMap<uint, uint> =\n-            HashMap::<uint, uint>();\n-        fail_unless!((hm_uu.insert(10u, 12u)));\n-        fail_unless!((hm_uu.insert(11u, 13u)));\n-        fail_unless!((hm_uu.insert(12u, 14u)));\n-        fail_unless!((hm_uu.get(&11) == 13u));\n-        fail_unless!((hm_uu.get(&12) == 14u));\n-        fail_unless!((hm_uu.get(&10) == 12u));\n-        fail_unless!((!hm_uu.insert(12u, 14u)));\n-        fail_unless!((hm_uu.get(&12) == 14u));\n-        fail_unless!((!hm_uu.insert(12u, 12u)));\n-        fail_unless!((hm_uu.get(&12) == 12u));\n-        let ten: ~str = ~\"ten\";\n-        let eleven: ~str = ~\"eleven\";\n-        let twelve: ~str = ~\"twelve\";\n-        debug!(\"str -> uint\");\n-        let hm_su: HashMap<~str, uint> =\n-            HashMap::<~str, uint>();\n-        fail_unless!((hm_su.insert(~\"ten\", 12u)));\n-        fail_unless!((hm_su.insert(eleven, 13u)));\n-        fail_unless!((hm_su.insert(~\"twelve\", 14u)));\n-        fail_unless!((hm_su.get(&eleven) == 13u));\n-        fail_unless!((hm_su.get(&~\"eleven\") == 13u));\n-        fail_unless!((hm_su.get(&~\"twelve\") == 14u));\n-        fail_unless!((hm_su.get(&~\"ten\") == 12u));\n-        fail_unless!((!hm_su.insert(~\"twelve\", 14u)));\n-        fail_unless!((hm_su.get(&~\"twelve\") == 14u));\n-        fail_unless!((!hm_su.insert(~\"twelve\", 12u)));\n-        fail_unless!((hm_su.get(&~\"twelve\") == 12u));\n-        debug!(\"uint -> str\");\n-        let hm_us: HashMap<uint, ~str> =\n-            HashMap::<uint, ~str>();\n-        fail_unless!((hm_us.insert(10u, ~\"twelve\")));\n-        fail_unless!((hm_us.insert(11u, ~\"thirteen\")));\n-        fail_unless!((hm_us.insert(12u, ~\"fourteen\")));\n-        fail_unless!(hm_us.get(&11) == ~\"thirteen\");\n-        fail_unless!(hm_us.get(&12) == ~\"fourteen\");\n-        fail_unless!(hm_us.get(&10) == ~\"twelve\");\n-        fail_unless!((!hm_us.insert(12u, ~\"fourteen\")));\n-        fail_unless!(hm_us.get(&12) == ~\"fourteen\");\n-        fail_unless!((!hm_us.insert(12u, ~\"twelve\")));\n-        fail_unless!(hm_us.get(&12) == ~\"twelve\");\n-        debug!(\"str -> str\");\n-        let hm_ss: HashMap<~str, ~str> =\n-            HashMap::<~str, ~str>();\n-        fail_unless!((hm_ss.insert(ten, ~\"twelve\")));\n-        fail_unless!((hm_ss.insert(eleven, ~\"thirteen\")));\n-        fail_unless!((hm_ss.insert(twelve, ~\"fourteen\")));\n-        fail_unless!(hm_ss.get(&~\"eleven\") == ~\"thirteen\");\n-        fail_unless!(hm_ss.get(&~\"twelve\") == ~\"fourteen\");\n-        fail_unless!(hm_ss.get(&~\"ten\") == ~\"twelve\");\n-        fail_unless!((!hm_ss.insert(~\"twelve\", ~\"fourteen\")));\n-        fail_unless!(hm_ss.get(&~\"twelve\") == ~\"fourteen\");\n-        fail_unless!((!hm_ss.insert(~\"twelve\", ~\"twelve\")));\n-        fail_unless!(hm_ss.get(&~\"twelve\") == ~\"twelve\");\n-        debug!(\"*** finished test_simple\");\n-    }\n-\n-\n-    /**\n-    * Force map growth\n-    */\n-    #[test]\n-    fn test_growth() {\n-        debug!(\"*** starting test_growth\");\n-        let num_to_insert: uint = 64u;\n-        fn eq_uint(x: &uint, y: &uint) -> bool { *x == *y }\n-        fn uint_id(x: &uint) -> uint { *x }\n-        debug!(\"uint -> uint\");\n-        let hm_uu: HashMap<uint, uint> =\n-            HashMap::<uint, uint>();\n-        let mut i: uint = 0u;\n-        while i < num_to_insert {\n-            fail_unless!((hm_uu.insert(i, i * i)));\n-            debug!(\"inserting %u -> %u\", i, i*i);\n-            i += 1u;\n-        }\n-        debug!(\"-----\");\n-        i = 0u;\n-        while i < num_to_insert {\n-            debug!(\"get(%u) = %u\", i, hm_uu.get(&i));\n-            fail_unless!((hm_uu.get(&i) == i * i));\n-            i += 1u;\n-        }\n-        fail_unless!((hm_uu.insert(num_to_insert, 17u)));\n-        fail_unless!((hm_uu.get(&num_to_insert) == 17u));\n-        debug!(\"-----\");\n-        i = 0u;\n-        while i < num_to_insert {\n-            debug!(\"get(%u) = %u\", i, hm_uu.get(&i));\n-            fail_unless!((hm_uu.get(&i) == i * i));\n-            i += 1u;\n-        }\n-        debug!(\"str -> str\");\n-        let hm_ss: HashMap<~str, ~str> =\n-            HashMap::<~str, ~str>();\n-        i = 0u;\n-        while i < num_to_insert {\n-            fail_unless!(hm_ss.insert(uint::to_str_radix(i, 2u),\n-                                uint::to_str_radix(i * i, 2u)));\n-            debug!(\"inserting \\\"%s\\\" -> \\\"%s\\\"\",\n-                   uint::to_str_radix(i, 2u),\n-                   uint::to_str_radix(i*i, 2u));\n-            i += 1u;\n-        }\n-        debug!(\"-----\");\n-        i = 0u;\n-        while i < num_to_insert {\n-            debug!(\"get(\\\"%s\\\") = \\\"%s\\\"\",\n-                   uint::to_str_radix(i, 2u),\n-                   hm_ss.get(&uint::to_str_radix(i, 2u)));\n-            fail_unless!(hm_ss.get(&uint::to_str_radix(i, 2u)) ==\n-                             uint::to_str_radix(i * i, 2u));\n-            i += 1u;\n-        }\n-        fail_unless!(hm_ss.insert(uint::to_str_radix(num_to_insert, 2u),\n-                             uint::to_str_radix(17u, 2u)));\n-        fail_unless!(hm_ss.get(&uint::to_str_radix(num_to_insert, 2u)) ==\n-            uint::to_str_radix(17u, 2u));\n-        debug!(\"-----\");\n-        i = 0u;\n-        while i < num_to_insert {\n-            debug!(\"get(\\\"%s\\\") = \\\"%s\\\"\",\n-                   uint::to_str_radix(i, 2u),\n-                   hm_ss.get(&uint::to_str_radix(i, 2u)));\n-            fail_unless!(hm_ss.get(&uint::to_str_radix(i, 2u)) ==\n-                             uint::to_str_radix(i * i, 2u));\n-            i += 1u;\n-        }\n-        debug!(\"*** finished test_growth\");\n-    }\n-\n-    #[test]\n-    fn test_removal() {\n-        debug!(\"*** starting test_removal\");\n-        let num_to_insert: uint = 64u;\n-        let hm: HashMap<uint, uint> =\n-            HashMap::<uint, uint>();\n-        let mut i: uint = 0u;\n-        while i < num_to_insert {\n-            fail_unless!((hm.insert(i, i * i)));\n-            debug!(\"inserting %u -> %u\", i, i*i);\n-            i += 1u;\n-        }\n-        fail_unless!((hm.len() == num_to_insert));\n-        debug!(\"-----\");\n-        debug!(\"removing evens\");\n-        i = 0u;\n-        while i < num_to_insert {\n-            let v = hm.remove(&i);\n-            fail_unless!(v);\n-            i += 2u;\n-        }\n-        fail_unless!((hm.len() == num_to_insert / 2u));\n-        debug!(\"-----\");\n-        i = 1u;\n-        while i < num_to_insert {\n-            debug!(\"get(%u) = %u\", i, hm.get(&i));\n-            fail_unless!((hm.get(&i) == i * i));\n-            i += 2u;\n-        }\n-        debug!(\"-----\");\n-        i = 1u;\n-        while i < num_to_insert {\n-            debug!(\"get(%u) = %u\", i, hm.get(&i));\n-            fail_unless!((hm.get(&i) == i * i));\n-            i += 2u;\n-        }\n-        debug!(\"-----\");\n-        i = 0u;\n-        while i < num_to_insert {\n-            fail_unless!((hm.insert(i, i * i)));\n-            debug!(\"inserting %u -> %u\", i, i*i);\n-            i += 2u;\n-        }\n-        fail_unless!((hm.len() == num_to_insert));\n-        debug!(\"-----\");\n-        i = 0u;\n-        while i < num_to_insert {\n-            debug!(\"get(%u) = %u\", i, hm.get(&i));\n-            fail_unless!((hm.get(&i) == i * i));\n-            i += 1u;\n-        }\n-        debug!(\"-----\");\n-        fail_unless!((hm.len() == num_to_insert));\n-        i = 0u;\n-        while i < num_to_insert {\n-            debug!(\"get(%u) = %u\", i, hm.get(&i));\n-            fail_unless!((hm.get(&i) == i * i));\n-            i += 1u;\n-        }\n-        debug!(\"*** finished test_removal\");\n-    }\n-\n-    #[test]\n-    fn test_contains_key() {\n-        let key = ~\"k\";\n-        let map = HashMap::<~str, ~str>();\n-        fail_unless!((!map.contains_key(&key)));\n-        map.insert(key, ~\"val\");\n-        fail_unless!((map.contains_key(&key)));\n-    }\n-\n-    #[test]\n-    fn test_find() {\n-        let key = ~\"k\";\n-        let map = HashMap::<~str, ~str>();\n-        fail_unless!(map.find(&key).is_none());\n-        map.insert(key, ~\"val\");\n-        fail_unless!(map.find(&key).get() == ~\"val\");\n-    }\n-\n-    #[test]\n-    fn test_clear() {\n-        let key = ~\"k\";\n-        let mut map = HashMap::<~str, ~str>();\n-        map.insert(key, ~\"val\");\n-        fail_unless!((map.len() == 1));\n-        fail_unless!((map.contains_key(&key)));\n-        map.clear();\n-        fail_unless!((map.len() == 0));\n-        fail_unless!((!map.contains_key(&key)));\n-    }\n-\n-    #[test]\n-    fn test_hash_from_vec() {\n-        let map = hash_from_vec(~[\n-            (~\"a\", 1),\n-            (~\"b\", 2),\n-            (~\"c\", 3)\n-        ]);\n-        fail_unless!(map.len() == 3u);\n-        fail_unless!(map.get(&~\"a\") == 1);\n-        fail_unless!(map.get(&~\"b\") == 2);\n-        fail_unless!(map.get(&~\"c\") == 3);\n-    }\n-}"}, {"sha": "7d46e73a697f818b708ba37cb5edbc56d0b511f3", "filename": "src/libstd/std.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d69108d8f78a9b5a8669606b62fe6df6409d17e7/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d69108d8f78a9b5a8669606b62fe6df6409d17e7/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=d69108d8f78a9b5a8669606b62fe6df6409d17e7", "patch": "@@ -71,7 +71,6 @@ pub mod bitv;\n pub mod deque;\n pub mod fun_treemap;\n pub mod list;\n-pub mod oldmap;\n pub mod priority_queue;\n pub mod rope;\n pub mod smallintmap;"}, {"sha": "0a68d29ac560ebb53c6018c03cdc64dae6fcb2c9", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d69108d8f78a9b5a8669606b62fe6df6409d17e7/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69108d8f78a9b5a8669606b62fe6df6409d17e7/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=d69108d8f78a9b5a8669606b62fe6df6409d17e7", "patch": "@@ -13,7 +13,6 @@\n extern mod std;\n \n use std::time::precise_time_s;\n-use std::oldmap;\n \n use core::io::{Reader, ReaderUtil};\n use core::rand::RngUtil;"}]}