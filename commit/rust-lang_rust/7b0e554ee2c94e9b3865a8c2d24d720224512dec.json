{"sha": "7b0e554ee2c94e9b3865a8c2d24d720224512dec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiMGU1NTRlZTJjOTRlOWIzODY1YThjMmQyNGQ3MjAyMjQ1MTJkZWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-25T16:22:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-25T16:22:57Z"}, "message": "Auto merge of #88329 - LeSeulArtichaut:rollup-blg8hc0, r=LeSeulArtichaut\n\nRollup of 16 pull requests\n\nSuccessful merges:\n\n - #87944 (add Cell::as_array_of_cells, similar to Cell::as_slice_of_cells)\n - #88156 (Adjust / fix documentation of `Arc::make_mut`)\n - #88157 (bootstrap.py: recognize riscv64 when auto-detect)\n - #88196 (Refactor `named_asm_labels` to a HIR lint)\n - #88218 (Remove `Session.trait_methods_not_found`)\n - #88223 (Remove the `TryV2` alias)\n - #88226 (Fix typo \u201ca Rc\u201d \u2192 \u201can Rc\u201d (and a few more))\n - #88267 (2229: Update signature for truncate function)\n - #88273 (Fix references to `ControlFlow` in docs)\n - #88277 (Update books)\n - #88291 (Add SAFETY comments to core::slice::sort::partition_in_blocks)\n - #88293 (Fix grammar in alloc test)\n - #88298 (Errorkind reorder)\n - #88299 (Stabilise BufWriter::into_parts)\n - #88314 (Add type of a let tait test)\n - #88325 (Add mutable-noalias to the release notes for 1.54)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "c593474b55894db3cd17a5a78200005ba265bd53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c593474b55894db3cd17a5a78200005ba265bd53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b0e554ee2c94e9b3865a8c2d24d720224512dec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b0e554ee2c94e9b3865a8c2d24d720224512dec", "html_url": "https://github.com/rust-lang/rust/commit/7b0e554ee2c94e9b3865a8c2d24d720224512dec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b0e554ee2c94e9b3865a8c2d24d720224512dec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a992a11913b39a258158646bb1e03528c5aa5060", "url": "https://api.github.com/repos/rust-lang/rust/commits/a992a11913b39a258158646bb1e03528c5aa5060", "html_url": "https://github.com/rust-lang/rust/commit/a992a11913b39a258158646bb1e03528c5aa5060"}, {"sha": "d9ed23a9130b0941fd1ed4a651cbbec8a6621dd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9ed23a9130b0941fd1ed4a651cbbec8a6621dd8", "html_url": "https://github.com/rust-lang/rust/commit/d9ed23a9130b0941fd1ed4a651cbbec8a6621dd8"}], "stats": {"total": 1001, "additions": 682, "deletions": 319}, "files": [{"sha": "dd299ca936ace88029c578d0977c09310c0df858", "filename": "RELEASES.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -175,6 +175,7 @@ Compiler\n - [Improved debugger output for enums on Windows MSVC platforms.][85292]\n - [Added tier 3\\* support for `bpfel-unknown-none`\n    and `bpfeb-unknown-none`.][79608]\n+- [`-Zmutable-noalias=yes`][82834] is enabled by default when using LLVM 12 or above.\n \n \\* Refer to Rust's [platform support page][platform-support-doc] for more\n    information on Rust's tiered platform support.\n@@ -244,6 +245,7 @@ Compatibility Notes\n [83366]: https://github.com/rust-lang/rust/pull/83366\n [83278]: https://github.com/rust-lang/rust/pull/83278\n [85292]: https://github.com/rust-lang/rust/pull/85292\n+[82834]: https://github.com/rust-lang/rust/pull/82834\n [cargo/9520]: https://github.com/rust-lang/cargo/pull/9520\n [cargo/9499]: https://github.com/rust-lang/cargo/pull/9499\n [cargo/9488]: https://github.com/rust-lang/cargo/pull/9488"}, {"sha": "2c2d30d872e2023d38f4a61b054d6bcd59231533", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -2028,6 +2028,7 @@ pub enum InlineAsmOperand {\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct InlineAsm {\n     pub template: Vec<InlineAsmTemplatePiece>,\n+    pub template_strs: Box<[(Symbol, Option<Symbol>, Span)]>,\n     pub operands: Vec<(InlineAsmOperand, Span)>,\n     pub clobber_abi: Option<(Symbol, Span)>,\n     pub options: InlineAsmOptions,"}, {"sha": "774d5cb2dda9d55660b6d451e55af3b456cde476", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -19,20 +19,20 @@ use crate::token;\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::Span;\n \n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub enum AssocCtxt {\n     Trait,\n     Impl,\n }\n \n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub enum FnCtxt {\n     Free,\n     Foreign,\n     Assoc(AssocCtxt),\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub enum FnKind<'a> {\n     /// E.g., `fn foo()`, `fn foo(&self)`, or `extern \"Abi\" fn foo()`.\n     Fn(FnCtxt, Ident, &'a FnSig, &'a Visibility, Option<&'a Block>),"}, {"sha": "b9b27855a0b88cc7331ab0d3471158b8603e0a0d", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -392,8 +392,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let operands = self.arena.alloc_from_iter(operands);\n         let template = self.arena.alloc_from_iter(asm.template.iter().cloned());\n+        let template_strs = self.arena.alloc_from_iter(asm.template_strs.iter().cloned());\n         let line_spans = self.arena.alloc_slice(&asm.line_spans[..]);\n-        let hir_asm = hir::InlineAsm { template, operands, options: asm.options, line_spans };\n+        let hir_asm =\n+            hir::InlineAsm { template, template_strs, operands, options: asm.options, line_spans };\n         self.arena.alloc(hir_asm)\n     }\n }"}, {"sha": "652165fb9b60b1f646c7827aaa07d17548a6e8a1", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 14, "deletions": 76, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -7,10 +7,10 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_expand::base::{self, *};\n use rustc_parse::parser::Parser;\n use rustc_parse_format as parse;\n-use rustc_session::lint::{self, BuiltinLintDiagnostics};\n+use rustc_session::lint;\n use rustc_span::symbol::Ident;\n use rustc_span::symbol::{kw, sym, Symbol};\n-use rustc_span::{InnerSpan, MultiSpan, Span};\n+use rustc_span::{InnerSpan, Span};\n use rustc_target::asm::InlineAsmArch;\n use smallvec::smallvec;\n \n@@ -484,11 +484,7 @@ fn parse_reg<'a>(\n     Ok(result)\n }\n \n-fn expand_preparsed_asm(\n-    ecx: &mut ExtCtxt<'_>,\n-    args: AsmArgs,\n-    is_local_asm: bool,\n-) -> Option<ast::InlineAsm> {\n+fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::InlineAsm> {\n     let mut template = vec![];\n     // Register operands are implicitly used since they are not allowed to be\n     // referenced in the template string.\n@@ -501,6 +497,8 @@ fn expand_preparsed_asm(\n     let mut line_spans = Vec::with_capacity(args.templates.len());\n     let mut curarg = 0;\n \n+    let mut template_strs = Vec::with_capacity(args.templates.len());\n+\n     for template_expr in args.templates.into_iter() {\n         if !template.is_empty() {\n             template.push(ast::InlineAsmTemplatePiece::String(\"\\n\".to_string()));\n@@ -524,8 +522,13 @@ fn expand_preparsed_asm(\n             ast::StrStyle::Raw(raw) => Some(raw as usize),\n         };\n \n-        let template_str = &template_str.as_str();\n         let template_snippet = ecx.source_map().span_to_snippet(template_sp).ok();\n+        template_strs.push((\n+            template_str,\n+            template_snippet.as_ref().map(|s| Symbol::intern(s)),\n+            template_sp,\n+        ));\n+        let template_str = &template_str.as_str();\n \n         if let Some(InlineAsmArch::X86 | InlineAsmArch::X86_64) = ecx.sess.asm_arch {\n             let find_span = |needle: &str| -> Span {\n@@ -560,72 +563,6 @@ fn expand_preparsed_asm(\n             }\n         }\n \n-        // Lint against the use of named labels in inline `asm!` but not `global_asm!`\n-        if is_local_asm {\n-            let find_label_span = |needle: &str| -> Option<Span> {\n-                if let Some(snippet) = &template_snippet {\n-                    if let Some(pos) = snippet.find(needle) {\n-                        let end = pos\n-                            + &snippet[pos..]\n-                                .find(|c| c == ':')\n-                                .unwrap_or(snippet[pos..].len() - 1);\n-                        let inner = InnerSpan::new(pos, end);\n-                        return Some(template_sp.from_inner(inner));\n-                    }\n-                }\n-\n-                None\n-            };\n-\n-            let mut found_labels = Vec::new();\n-\n-            // A semicolon might not actually be specified as a separator for all targets, but it seems like LLVM accepts it always\n-            let statements = template_str.split(|c| matches!(c, '\\n' | ';'));\n-            for statement in statements {\n-                // If there's a comment, trim it from the statement\n-                let statement = statement.find(\"//\").map_or(statement, |idx| &statement[..idx]);\n-                let mut start_idx = 0;\n-                for (idx, _) in statement.match_indices(':') {\n-                    let possible_label = statement[start_idx..idx].trim();\n-                    let mut chars = possible_label.chars();\n-                    if let Some(c) = chars.next() {\n-                        // A label starts with an alphabetic character or . or _ and continues with alphanumeric characters, _, or $\n-                        if (c.is_alphabetic() || matches!(c, '.' | '_'))\n-                            && chars.all(|c| c.is_alphanumeric() || matches!(c, '_' | '$'))\n-                        {\n-                            found_labels.push(possible_label);\n-                        } else {\n-                            // If we encounter a non-label, there cannot be any further labels, so stop checking\n-                            break;\n-                        }\n-                    } else {\n-                        // Empty string means a leading ':' in this section, which is not a label\n-                        break;\n-                    }\n-\n-                    start_idx = idx + 1;\n-                }\n-            }\n-\n-            if found_labels.len() > 0 {\n-                let spans =\n-                    found_labels.into_iter().filter_map(find_label_span).collect::<Vec<Span>>();\n-                // If there were labels but we couldn't find a span, combine the warnings and use the template span\n-                let target_spans: MultiSpan =\n-                    if spans.len() > 0 { spans.into() } else { template_sp.into() };\n-                ecx.parse_sess().buffer_lint_with_diagnostic(\n-                    lint::builtin::NAMED_ASM_LABELS,\n-                    target_spans,\n-                    ecx.current_expansion.lint_node_id,\n-                    \"avoid using named labels in inline assembly\",\n-                    BuiltinLintDiagnostics::NamedAsmLabel(\n-                        \"only local labels of the form `<number>:` should be used in inline asm\"\n-                            .to_string(),\n-                    ),\n-                );\n-            }\n-        }\n-\n         // Don't treat raw asm as a format string.\n         if args.options.contains(ast::InlineAsmOptions::RAW) {\n             template.push(ast::InlineAsmTemplatePiece::String(template_str.to_string()));\n@@ -819,6 +756,7 @@ fn expand_preparsed_asm(\n \n     Some(ast::InlineAsm {\n         template,\n+        template_strs: template_strs.into_boxed_slice(),\n         operands: args.operands,\n         clobber_abi: args.clobber_abi,\n         options: args.options,\n@@ -833,7 +771,7 @@ pub fn expand_asm<'cx>(\n ) -> Box<dyn base::MacResult + 'cx> {\n     match parse_args(ecx, sp, tts, false) {\n         Ok(args) => {\n-            let expr = if let Some(inline_asm) = expand_preparsed_asm(ecx, args, true) {\n+            let expr = if let Some(inline_asm) = expand_preparsed_asm(ecx, args) {\n                 P(ast::Expr {\n                     id: ast::DUMMY_NODE_ID,\n                     kind: ast::ExprKind::InlineAsm(P(inline_asm)),\n@@ -860,7 +798,7 @@ pub fn expand_global_asm<'cx>(\n ) -> Box<dyn base::MacResult + 'cx> {\n     match parse_args(ecx, sp, tts, true) {\n         Ok(args) => {\n-            if let Some(inline_asm) = expand_preparsed_asm(ecx, args, false) {\n+            if let Some(inline_asm) = expand_preparsed_asm(ecx, args) {\n                 MacEager::items(smallvec![P(ast::Item {\n                     ident: Ident::invalid(),\n                     attrs: Vec::new(),"}, {"sha": "e7397bf13bad43319c3ebcb0f4874dd74e3cf78e", "filename": "compiler/rustc_data_structures/src/owning_ref/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -5,7 +5,7 @@\n \n This crate provides the _owning reference_ types `OwningRef` and `OwningRefMut`\n that enables it to bundle a reference together with the owner of the data it points to.\n-This allows moving and dropping of a `OwningRef` without needing to recreate the reference.\n+This allows moving and dropping of an `OwningRef` without needing to recreate the reference.\n \n This can sometimes be useful because Rust borrowing rules normally prevent\n moving a type that has been moved from. For example, this kind of code gets rejected:\n@@ -1146,7 +1146,7 @@ pub type VecRef<T, U = T> = OwningRef<Vec<T>, U>;\n /// Typedef of an owning reference that uses a `String` as the owner.\n pub type StringRef = OwningRef<String, str>;\n \n-/// Typedef of an owning reference that uses a `Rc` as the owner.\n+/// Typedef of an owning reference that uses an `Rc` as the owner.\n pub type RcRef<T, U = T> = OwningRef<Rc<T>, U>;\n /// Typedef of an owning reference that uses an `Arc` as the owner.\n pub type ArcRef<T, U = T> = OwningRef<Arc<T>, U>;\n@@ -1157,9 +1157,9 @@ pub type RefRef<'a, T, U = T> = OwningRef<Ref<'a, T>, U>;\n pub type RefMutRef<'a, T, U = T> = OwningRef<RefMut<'a, T>, U>;\n /// Typedef of an owning reference that uses a `MutexGuard` as the owner.\n pub type MutexGuardRef<'a, T, U = T> = OwningRef<MutexGuard<'a, T>, U>;\n-/// Typedef of an owning reference that uses a `RwLockReadGuard` as the owner.\n+/// Typedef of an owning reference that uses an `RwLockReadGuard` as the owner.\n pub type RwLockReadGuardRef<'a, T, U = T> = OwningRef<RwLockReadGuard<'a, T>, U>;\n-/// Typedef of an owning reference that uses a `RwLockWriteGuard` as the owner.\n+/// Typedef of an owning reference that uses an `RwLockWriteGuard` as the owner.\n pub type RwLockWriteGuardRef<'a, T, U = T> = OwningRef<RwLockWriteGuard<'a, T>, U>;\n \n /// Typedef of a mutable owning reference that uses a `Box` as the owner.\n@@ -1173,7 +1173,7 @@ pub type StringRefMut = OwningRefMut<String, str>;\n pub type RefMutRefMut<'a, T, U = T> = OwningRefMut<RefMut<'a, T>, U>;\n /// Typedef of a mutable owning reference that uses a `MutexGuard` as the owner.\n pub type MutexGuardRefMut<'a, T, U = T> = OwningRefMut<MutexGuard<'a, T>, U>;\n-/// Typedef of a mutable owning reference that uses a `RwLockWriteGuard` as the owner.\n+/// Typedef of a mutable owning reference that uses an `RwLockWriteGuard` as the owner.\n pub type RwLockWriteGuardRefMut<'a, T, U = T> = OwningRef<RwLockWriteGuard<'a, T>, U>;\n \n unsafe impl<'a, T: 'a> IntoErased<'a> for Box<T> {"}, {"sha": "38deb8eaaae6b97a19685dbc5dc345726d5201f6", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -2386,6 +2386,7 @@ impl<'hir> InlineAsmOperand<'hir> {\n #[derive(Debug, HashStable_Generic)]\n pub struct InlineAsm<'hir> {\n     pub template: &'hir [InlineAsmTemplatePiece],\n+    pub template_strs: &'hir [(Symbol, Option<Symbol>, Span)],\n     pub operands: &'hir [(InlineAsmOperand<'hir>, Span)],\n     pub options: InlineAsmOptions,\n     pub line_spans: &'hir [Span],"}, {"sha": "d0bd508bc257f2dfd4fd63b71bdd0e65c669a7f2", "filename": "compiler/rustc_infer/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -104,11 +104,5 @@ pub fn report_object_safety_error(\n          to be resolvable dynamically; for more information visit \\\n          <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\",\n     );\n-\n-    if tcx.sess.trait_methods_not_found.borrow().iter().any(|full_span| full_span.contains(span)) {\n-        // Avoid emitting error caused by non-existing method (#58734)\n-        err.cancel();\n-    }\n-\n     err\n }"}, {"sha": "add0c0ff332f2574ba21cb2f374782f2884ef30b", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 122, "deletions": 2, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -45,11 +45,11 @@ use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::{GenericArgKind, Subst};\n use rustc_middle::ty::Instance;\n use rustc_middle::ty::{self, layout::LayoutError, Ty, TyCtxt};\n-use rustc_session::lint::FutureIncompatibilityReason;\n+use rustc_session::lint::{BuiltinLintDiagnostics, FutureIncompatibilityReason};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{BytePos, Span};\n+use rustc_span::{BytePos, InnerSpan, MultiSpan, Span};\n use rustc_target::abi::{LayoutOf, VariantIdx};\n use rustc_trait_selection::traits::misc::can_type_implement_copy;\n \n@@ -3140,3 +3140,123 @@ impl<'tcx> LateLintPass<'tcx> for DerefNullPtr {\n         }\n     }\n }\n+\n+declare_lint! {\n+    /// The `named_asm_labels` lint detects the use of named labels in the\n+    /// inline `asm!` macro.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![feature(asm)]\n+    /// fn main() {\n+    ///     unsafe {\n+    ///         asm!(\"foo: bar\");\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// LLVM is allowed to duplicate inline assembly blocks for any\n+    /// reason, for example when it is in a function that gets inlined. Because\n+    /// of this, GNU assembler [local labels] *must* be used instead of labels\n+    /// with a name. Using named labels might cause assembler or linker errors.\n+    ///\n+    /// See the [unstable book] for more details.\n+    ///\n+    /// [local labels]: https://sourceware.org/binutils/docs/as/Symbol-Names.html#Local-Labels\n+    /// [unstable book]: https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels\n+    pub NAMED_ASM_LABELS,\n+    Deny,\n+    \"named labels in inline assembly\",\n+}\n+\n+declare_lint_pass!(NamedAsmLabels => [NAMED_ASM_LABELS]);\n+\n+impl<'tcx> LateLintPass<'tcx> for NamedAsmLabels {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'tcx>) {\n+        if let hir::Expr {\n+            kind: hir::ExprKind::InlineAsm(hir::InlineAsm { template_strs, .. }),\n+            ..\n+        } = expr\n+        {\n+            for (template_sym, template_snippet, template_span) in template_strs.iter() {\n+                let template_str = &template_sym.as_str();\n+                let find_label_span = |needle: &str| -> Option<Span> {\n+                    if let Some(template_snippet) = template_snippet {\n+                        let snippet = template_snippet.as_str();\n+                        if let Some(pos) = snippet.find(needle) {\n+                            let end = pos\n+                                + &snippet[pos..]\n+                                    .find(|c| c == ':')\n+                                    .unwrap_or(snippet[pos..].len() - 1);\n+                            let inner = InnerSpan::new(pos, end);\n+                            return Some(template_span.from_inner(inner));\n+                        }\n+                    }\n+\n+                    None\n+                };\n+\n+                let mut found_labels = Vec::new();\n+\n+                // A semicolon might not actually be specified as a separator for all targets, but it seems like LLVM accepts it always\n+                let statements = template_str.split(|c| matches!(c, '\\n' | ';'));\n+                for statement in statements {\n+                    // If there's a comment, trim it from the statement\n+                    let statement = statement.find(\"//\").map_or(statement, |idx| &statement[..idx]);\n+                    let mut start_idx = 0;\n+                    for (idx, _) in statement.match_indices(':') {\n+                        let possible_label = statement[start_idx..idx].trim();\n+                        let mut chars = possible_label.chars();\n+                        if let Some(c) = chars.next() {\n+                            // A label starts with an alphabetic character or . or _ and continues with alphanumeric characters, _, or $\n+                            if (c.is_alphabetic() || matches!(c, '.' | '_'))\n+                                && chars.all(|c| c.is_alphanumeric() || matches!(c, '_' | '$'))\n+                            {\n+                                found_labels.push(possible_label);\n+                            } else {\n+                                // If we encounter a non-label, there cannot be any further labels, so stop checking\n+                                break;\n+                            }\n+                        } else {\n+                            // Empty string means a leading ':' in this section, which is not a label\n+                            break;\n+                        }\n+\n+                        start_idx = idx + 1;\n+                    }\n+                }\n+\n+                debug!(\"NamedAsmLabels::check_expr(): found_labels: {:#?}\", &found_labels);\n+\n+                if found_labels.len() > 0 {\n+                    let spans = found_labels\n+                        .into_iter()\n+                        .filter_map(|label| find_label_span(label))\n+                        .collect::<Vec<Span>>();\n+                    // If there were labels but we couldn't find a span, combine the warnings and use the template span\n+                    let target_spans: MultiSpan =\n+                        if spans.len() > 0 { spans.into() } else { (*template_span).into() };\n+\n+                    cx.lookup_with_diagnostics(\n+                            NAMED_ASM_LABELS,\n+                            Some(target_spans),\n+                            |diag| {\n+                                let mut err =\n+                                    diag.build(\"avoid using named labels in inline assembly\");\n+                                err.emit();\n+                            },\n+                            BuiltinLintDiagnostics::NamedAsmLabel(\n+                                \"only local labels of the form `<number>:` should be used in inline asm\"\n+                                    .to_string(),\n+                            ),\n+                        );\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "24ac723f2c9132c5677fd2e0bc0e9d2b822931bf", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -168,6 +168,7 @@ macro_rules! late_lint_passes {\n                 NonPanicFmt: NonPanicFmt,\n                 NoopMethodCall: NoopMethodCall,\n                 InvalidAtomicOrdering: InvalidAtomicOrdering,\n+                NamedAsmLabels: NamedAsmLabels,\n             ]\n         );\n     };"}, {"sha": "1d978b6c829239cace433aa057a8693bd5d063fb", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -2468,38 +2468,6 @@ declare_lint! {\n     \"incorrect use of inline assembly\",\n }\n \n-declare_lint! {\n-    /// The `named_asm_labels` lint detects the use of named labels in the\n-    /// inline `asm!` macro.\n-    ///\n-    /// ### Example\n-    ///\n-    /// ```rust,compile_fail\n-    /// fn main() {\n-    ///     unsafe {\n-    ///         asm!(\"foo: bar\");\n-    ///     }\n-    /// }\n-    /// ```\n-    ///\n-    /// {{produces}}\n-    ///\n-    /// ### Explanation\n-    ///\n-    /// LLVM is allowed to duplicate inline assembly blocks for any\n-    /// reason, for example when it is in a function that gets inlined. Because\n-    /// of this, GNU assembler [local labels] *must* be used instead of labels\n-    /// with a name. Using named labels might cause assembler or linker errors.\n-    ///\n-    /// See the [unstable book] for more details.\n-    ///\n-    /// [local labels]: https://sourceware.org/binutils/docs/as/Symbol-Names.html#Local-Labels\n-    /// [unstable book]: https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels\n-    pub NAMED_ASM_LABELS,\n-    Deny,\n-    \"named labels in inline assembly\",\n-}\n-\n declare_lint! {\n     /// The `unsafe_op_in_unsafe_fn` lint detects unsafe operations in unsafe\n     /// functions without an explicit unsafe block.\n@@ -3020,7 +2988,6 @@ declare_lint_pass! {\n         INLINE_NO_SANITIZE,\n         BAD_ASM_STYLE,\n         ASM_SUB_REGISTER,\n-        NAMED_ASM_LABELS,\n         UNSAFE_OP_IN_UNSAFE_FN,\n         INCOMPLETE_INCLUDE,\n         CENUM_IMPL_DROP_CAST,"}, {"sha": "20e94e32be61f396cd640cda0d8b80177e922922", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -189,9 +189,6 @@ pub struct Session {\n     /// Cap lint level specified by a driver specifically.\n     pub driver_lint_caps: FxHashMap<lint::LintId, lint::Level>,\n \n-    /// `Span`s of trait methods that weren't found to avoid emitting object safety errors\n-    pub trait_methods_not_found: Lock<FxHashSet<Span>>,\n-\n     /// Mapping from ident span to path span for paths that don't exist as written, but that\n     /// exist under `std`. For example, wrote `str::from_utf8` instead of `std::str::from_utf8`.\n     pub confused_type_with_std_module: Lock<FxHashMap<Span, Span>>,\n@@ -1326,7 +1323,6 @@ pub fn build_session(\n         print_fuel,\n         jobserver: jobserver::client(),\n         driver_lint_caps,\n-        trait_methods_not_found: Lock::new(Default::default()),\n         confused_type_with_std_module: Lock::new(Default::default()),\n         ctfe_backtrace,\n         miri_unleashed_features: Lock::new(Default::default()),"}, {"sha": "0cf30fecf73815415194abbe2da8d1976c34e8ac", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -858,13 +858,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     path.segments,\n                 );\n             }\n-            QPath::TypeRelative(ref qself, ref segment) => (self.to_ty(qself), qself, segment),\n+            QPath::TypeRelative(ref qself, ref segment) => {\n+                // Don't use `self.to_ty`, since this will register a WF obligation.\n+                // If we're trying to call a non-existent method on a trait\n+                // (e.g. `MyTrait::missing_method`), then resolution will\n+                // give us a `QPath::TypeRelative` with a trait object as\n+                // `qself`. In that case, we want to avoid registering a WF obligation\n+                // for `dyn MyTrait`, since we don't actually need the trait\n+                // to be object-safe.\n+                // We manually call `register_wf_obligation` in the success path\n+                // below.\n+                (<dyn AstConv<'_>>::ast_ty_to_ty(self, qself), qself, segment)\n+            }\n             QPath::LangItem(..) => {\n                 bug!(\"`resolve_ty_and_res_fully_qualified_call` called on `LangItem`\")\n             }\n         };\n         if let Some(&cached_result) = self.typeck_results.borrow().type_dependent_defs().get(hir_id)\n         {\n+            self.register_wf_obligation(ty.into(), qself.span, traits::WellFormed(None));\n             // Return directly on cache hit. This is useful to avoid doubly reporting\n             // errors with default match binding modes. See #44614.\n             let def = cached_result.map_or(Res::Err, |(kind, def_id)| Res::Def(kind, def_id));\n@@ -878,6 +890,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     method::MethodError::PrivateMatch(kind, def_id, _) => Ok((kind, def_id)),\n                     _ => Err(ErrorReported),\n                 };\n+\n+                // If we have a path like `MyTrait::missing_method`, then don't register\n+                // a WF obligation for `dyn MyTrait` when method lookup fails. Otherwise,\n+                // register a WF obligation so that we can detect any additional\n+                // errors in the self type.\n+                if !(matches!(error, method::MethodError::NoMatch(_)) && ty.is_trait()) {\n+                    self.register_wf_obligation(ty.into(), qself.span, traits::WellFormed(None));\n+                }\n                 if item_name.name != kw::Empty {\n                     if let Some(mut e) = self.report_method_error(\n                         span,\n@@ -895,6 +915,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if result.is_ok() {\n             self.maybe_lint_bare_trait(qpath, hir_id);\n+            self.register_wf_obligation(ty.into(), qself.span, traits::WellFormed(None));\n         }\n \n         // Write back the new resolution."}, {"sha": "afe274a2a796e11e8b2c39d911eac04dab0b2fba", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -70,15 +70,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn report_method_error(\n         &self,\n-        span: Span,\n+        mut span: Span,\n         rcvr_ty: Ty<'tcx>,\n         item_name: Ident,\n         source: SelfSource<'tcx>,\n         error: MethodError<'tcx>,\n         args: Option<&'tcx [hir::Expr<'tcx>]>,\n     ) -> Option<DiagnosticBuilder<'_>> {\n-        let orig_span = span;\n-        let mut span = span;\n         // Avoid suggestions when we don't know what's going on.\n         if rcvr_ty.references_error() {\n             return None;\n@@ -545,7 +543,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     } else {\n                         err.span_label(span, format!(\"{item_kind} cannot be called on `{ty_str}` due to unsatisfied trait bounds\"));\n                     }\n-                    self.tcx.sess.trait_methods_not_found.borrow_mut().insert(orig_span);\n                 };\n \n                 // If the method name is the name of a field with a function or closure type,"}, {"sha": "84dfdd4d4341b32fbe8e69d6d572f889752037d8", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 48, "deletions": 70, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -489,7 +489,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut root_var_min_capture_list =\n             typeck_results.closure_min_captures.remove(&closure_def_id).unwrap_or_default();\n \n-        for (place, capture_info) in capture_information.into_iter() {\n+        for (mut place, capture_info) in capture_information.into_iter() {\n             let var_hir_id = match place.base {\n                 PlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n                 base => bug!(\"Expected upvar, found={:?}\", base),\n@@ -530,14 +530,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                         // Truncate the descendant (already in min_captures) to be same as the ancestor to handle any\n                         // possible change in capture mode.\n-                        let (_, descendant_capture_kind) = truncate_place_to_len(\n-                            possible_descendant.place,\n-                            possible_descendant.info.capture_kind,\n+                        truncate_place_to_len_and_update_capture_kind(\n+                            &mut possible_descendant.place,\n+                            &mut possible_descendant.info.capture_kind,\n                             place.projections.len(),\n                         );\n \n-                        possible_descendant.info.capture_kind = descendant_capture_kind;\n-\n                         updated_capture_info =\n                             determine_capture_info(updated_capture_info, possible_descendant.info);\n \n@@ -561,14 +559,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                             // Truncate the descendant (current place) to be same as the ancestor to handle any\n                             // possible change in capture mode.\n-                            let (_, descendant_capture_kind) = truncate_place_to_len(\n-                                place.clone(),\n-                                updated_capture_info.capture_kind,\n+                            truncate_place_to_len_and_update_capture_kind(\n+                                &mut place,\n+                                &mut updated_capture_info.capture_kind,\n                                 possible_ancestor.place.projections.len(),\n                             );\n \n-                            updated_capture_info.capture_kind = descendant_capture_kind;\n-\n                             possible_ancestor.info = determine_capture_info(\n                                 possible_ancestor.info,\n                                 updated_capture_info,\n@@ -1476,7 +1472,7 @@ fn restrict_repr_packed_field_ref_capture<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     place: &Place<'tcx>,\n-    curr_borrow_kind: ty::UpvarCapture<'tcx>,\n+    mut curr_borrow_kind: ty::UpvarCapture<'tcx>,\n ) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n     let pos = place.projections.iter().enumerate().position(|(i, p)| {\n         let ty = place.ty_before_projection(i);\n@@ -1508,13 +1504,13 @@ fn restrict_repr_packed_field_ref_capture<'tcx>(\n         }\n     });\n \n-    let place = place.clone();\n+    let mut place = place.clone();\n \n     if let Some(pos) = pos {\n-        truncate_place_to_len(place, curr_borrow_kind, pos)\n-    } else {\n-        (place, curr_borrow_kind)\n+        truncate_place_to_len_and_update_capture_kind(&mut place, &mut curr_borrow_kind, pos);\n     }\n+\n+    (place, curr_borrow_kind)\n }\n \n /// Returns a Ty that applies the specified capture kind on the provided capture Ty\n@@ -1841,31 +1837,28 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n ///   them completely.\n /// - No projections are applied on top of Union ADTs, since these require unsafe blocks.\n fn restrict_precision_for_unsafe(\n-    place: Place<'tcx>,\n-    curr_mode: ty::UpvarCapture<'tcx>,\n+    mut place: Place<'tcx>,\n+    mut curr_mode: ty::UpvarCapture<'tcx>,\n ) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n-    if place.projections.is_empty() {\n-        // Nothing to do here\n-        return (place, curr_mode);\n-    }\n-\n     if place.base_ty.is_unsafe_ptr() {\n-        return truncate_place_to_len(place, curr_mode, 0);\n+        truncate_place_to_len_and_update_capture_kind(&mut place, &mut curr_mode, 0);\n     }\n \n     if place.base_ty.is_union() {\n-        return truncate_place_to_len(place, curr_mode, 0);\n+        truncate_place_to_len_and_update_capture_kind(&mut place, &mut curr_mode, 0);\n     }\n \n     for (i, proj) in place.projections.iter().enumerate() {\n         if proj.ty.is_unsafe_ptr() {\n             // Don't apply any projections on top of an unsafe ptr.\n-            return truncate_place_to_len(place, curr_mode, i + 1);\n+            truncate_place_to_len_and_update_capture_kind(&mut place, &mut curr_mode, i + 1);\n+            break;\n         }\n \n         if proj.ty.is_union() {\n             // Don't capture preicse fields of a union.\n-            return truncate_place_to_len(place, curr_mode, i + 1);\n+            truncate_place_to_len_and_update_capture_kind(&mut place, &mut curr_mode, i + 1);\n+            break;\n         }\n     }\n \n@@ -1880,7 +1873,7 @@ fn restrict_capture_precision<'tcx>(\n     place: Place<'tcx>,\n     curr_mode: ty::UpvarCapture<'tcx>,\n ) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n-    let (place, curr_mode) = restrict_precision_for_unsafe(place, curr_mode);\n+    let (mut place, mut curr_mode) = restrict_precision_for_unsafe(place, curr_mode);\n \n     if place.projections.is_empty() {\n         // Nothing to do here\n@@ -1891,7 +1884,8 @@ fn restrict_capture_precision<'tcx>(\n         match proj.kind {\n             ProjectionKind::Index => {\n                 // Arrays are completely captured, so we drop Index projections\n-                return truncate_place_to_len(place, curr_mode, i);\n+                truncate_place_to_len_and_update_capture_kind(&mut place, &mut curr_mode, i);\n+                return (place, curr_mode);\n             }\n             ProjectionKind::Deref => {}\n             ProjectionKind::Field(..) => {} // ignore\n@@ -1906,8 +1900,8 @@ fn restrict_capture_precision<'tcx>(\n /// (or if closure attempts to move data that it doesn\u2019t own).\n /// Note: When taking ownership, only capture data found on the stack.\n fn adjust_for_move_closure<'tcx>(\n-    place: Place<'tcx>,\n-    kind: ty::UpvarCapture<'tcx>,\n+    mut place: Place<'tcx>,\n+    mut kind: ty::UpvarCapture<'tcx>,\n ) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n     let contains_deref_of_ref = place.deref_tys().any(|ty| ty.is_ref());\n     let first_deref = place.projections.iter().position(|proj| proj.kind == ProjectionKind::Deref);\n@@ -1917,52 +1911,38 @@ fn adjust_for_move_closure<'tcx>(\n \n         // If there's any Deref and the data needs to be moved into the closure body,\n         // or it's a Deref of a Box, truncate the path to the first deref\n-        _ if first_deref.is_some() => {\n-            let place = match first_deref {\n-                Some(idx) => {\n-                    let (place, _) = truncate_place_to_len(place, kind, idx);\n-                    place\n-                }\n-                None => place,\n-            };\n+        _ => {\n+            if let Some(idx) = first_deref {\n+                truncate_place_to_len_and_update_capture_kind(&mut place, &mut kind, idx);\n+            }\n \n             // AMAN: I think we don't need the span inside the ByValue anymore\n             //       we have more detailed span in CaptureInfo\n             (place, ty::UpvarCapture::ByValue(None))\n         }\n-\n-        _ => (place, ty::UpvarCapture::ByValue(None)),\n     }\n }\n \n /// Adjust closure capture just that if taking ownership of data, only move data\n /// from enclosing stack frame.\n fn adjust_for_non_move_closure<'tcx>(\n-    place: Place<'tcx>,\n+    mut place: Place<'tcx>,\n     mut kind: ty::UpvarCapture<'tcx>,\n ) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n     let contains_deref =\n         place.projections.iter().position(|proj| proj.kind == ProjectionKind::Deref);\n \n     match kind {\n-        ty::UpvarCapture::ByValue(..) if contains_deref.is_some() => {\n-            let place = match contains_deref {\n-                Some(idx) => {\n-                    let (place, new_kind) = truncate_place_to_len(place, kind, idx);\n-\n-                    kind = new_kind;\n-                    place\n-                }\n-                // Because of the if guard on the match on `kind`, we should never get here.\n-                None => unreachable!(),\n-            };\n-\n-            (place, kind)\n+        ty::UpvarCapture::ByValue(..) => {\n+            if let Some(idx) = contains_deref {\n+                truncate_place_to_len_and_update_capture_kind(&mut place, &mut kind, idx);\n+            }\n         }\n \n-        ty::UpvarCapture::ByValue(..) => (place, kind),\n-        ty::UpvarCapture::ByRef(..) => (place, kind),\n+        ty::UpvarCapture::ByRef(..) => {}\n     }\n+\n+    (place, kind)\n }\n \n fn construct_place_string(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String {\n@@ -2157,15 +2137,13 @@ fn determine_capture_info(\n ///\n /// Note: Capture kind changes from `MutBorrow` to `UniqueImmBorrow` if the truncated part of the `place`\n /// contained `Deref` of `&mut`.\n-fn truncate_place_to_len(\n-    mut place: Place<'tcx>,\n-    curr_mode: ty::UpvarCapture<'tcx>,\n+fn truncate_place_to_len_and_update_capture_kind(\n+    place: &mut Place<'tcx>,\n+    curr_mode: &mut ty::UpvarCapture<'tcx>,\n     len: usize,\n-) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n+) {\n     let is_mut_ref = |ty: Ty<'_>| matches!(ty.kind(), ty::Ref(.., hir::Mutability::Mut));\n \n-    let mut capture_kind = curr_mode;\n-\n     // If the truncated part of the place contains `Deref` of a `&mut` then convert MutBorrow ->\n     // UniqueImmBorrow\n     // Note that if the place contained Deref of a raw pointer it would've not been MutBorrow, so\n@@ -2176,7 +2154,7 @@ fn truncate_place_to_len(\n                 if place.projections[i].kind == ProjectionKind::Deref\n                     && is_mut_ref(place.ty_before_projection(i))\n                 {\n-                    capture_kind = ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n+                    *curr_mode = ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n                         kind: ty::BorrowKind::UniqueImmBorrow,\n                         region,\n                     });\n@@ -2190,8 +2168,6 @@ fn truncate_place_to_len(\n     }\n \n     place.projections.truncate(len);\n-\n-    (place, capture_kind)\n }\n \n /// Determines the Ancestry relationship of Place A relative to Place B\n@@ -2256,8 +2232,8 @@ fn determine_place_ancestry_relation(\n /// }\n /// ```\n fn truncate_capture_for_optimization<'tcx>(\n-    place: Place<'tcx>,\n-    curr_mode: ty::UpvarCapture<'tcx>,\n+    mut place: Place<'tcx>,\n+    mut curr_mode: ty::UpvarCapture<'tcx>,\n ) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n     let is_shared_ref = |ty: Ty<'_>| matches!(ty.kind(), ty::Ref(.., hir::Mutability::Not));\n \n@@ -2269,10 +2245,12 @@ fn truncate_capture_for_optimization<'tcx>(\n     match idx {\n         // If that pointer is a shared reference, then we don't need those fields.\n         Some(idx) if is_shared_ref(place.ty_before_projection(idx)) => {\n-            truncate_place_to_len(place, curr_mode, idx + 1)\n+            truncate_place_to_len_and_update_capture_kind(&mut place, &mut curr_mode, idx + 1)\n         }\n-        None | Some(_) => (place, curr_mode),\n+        None | Some(_) => {}\n     }\n+\n+    (place, curr_mode)\n }\n \n /// Precise capture is enabled if the feature gate `capture_disjoint_fields` is enabled or if"}, {"sha": "0814652a5d47d595822ed1a7492d2ad81f97b60c", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -1011,7 +1011,7 @@ impl<T: ?Sized> Rc<T> {\n     /// mutate a shared value.\n     ///\n     /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n-    /// the inner value when there are other pointers.\n+    /// the inner value when there are other `Rc` pointers.\n     ///\n     /// [make_mut]: Rc::make_mut\n     /// [clone]: Clone::clone\n@@ -1100,10 +1100,12 @@ impl<T: Clone> Rc<T> {\n     /// [`clone`] the inner value to a new allocation to ensure unique ownership.  This is also\n     /// referred to as clone-on-write.\n     ///\n-    /// If there are no other `Rc` pointers to this allocation, then [`Weak`]\n-    /// pointers to this allocation will be disassociated.\n+    /// However, if there are no other `Rc` pointers to this allocation, but some [`Weak`]\n+    /// pointers, then the [`Weak`] pointers will be disassociated and the inner value will not\n+    /// be cloned.\n     ///\n-    /// See also [`get_mut`], which will fail rather than cloning.\n+    /// See also [`get_mut`], which will fail rather than cloning the inner value\n+    /// or diassociating [`Weak`] pointers.\n     ///\n     /// [`clone`]: Clone::clone\n     /// [`get_mut`]: Rc::get_mut\n@@ -1115,11 +1117,11 @@ impl<T: Clone> Rc<T> {\n     ///\n     /// let mut data = Rc::new(5);\n     ///\n-    /// *Rc::make_mut(&mut data) += 1;        // Won't clone anything\n-    /// let mut other_data = Rc::clone(&data);    // Won't clone inner data\n-    /// *Rc::make_mut(&mut data) += 1;        // Clones inner data\n-    /// *Rc::make_mut(&mut data) += 1;        // Won't clone anything\n-    /// *Rc::make_mut(&mut other_data) *= 2;  // Won't clone anything\n+    /// *Rc::make_mut(&mut data) += 1;         // Won't clone anything\n+    /// let mut other_data = Rc::clone(&data); // Won't clone inner data\n+    /// *Rc::make_mut(&mut data) += 1;         // Clones inner data\n+    /// *Rc::make_mut(&mut data) += 1;         // Won't clone anything\n+    /// *Rc::make_mut(&mut other_data) *= 2;   // Won't clone anything\n     ///\n     /// // Now `data` and `other_data` point to different allocations.\n     /// assert_eq!(*data, 8);\n@@ -1743,7 +1745,7 @@ impl<T: ?Sized> fmt::Pointer for Rc<T> {\n #[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"from_for_ptrs\", since = \"1.6.0\")]\n impl<T> From<T> for Rc<T> {\n-    /// Converts a generic type `T` into a `Rc<T>`\n+    /// Converts a generic type `T` into an `Rc<T>`\n     ///\n     /// The conversion allocates on the heap and moves `t`\n     /// from the stack into it."}, {"sha": "a066e0b49e25c4505381f7d83e037bd8e24e4d86", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -1346,18 +1346,19 @@ impl<T: ?Sized> Receiver for Arc<T> {}\n impl<T: Clone> Arc<T> {\n     /// Makes a mutable reference into the given `Arc`.\n     ///\n-    /// If there are other `Arc` or [`Weak`] pointers to the same allocation,\n-    /// then `make_mut` will create a new allocation and invoke [`clone`][clone] on the inner value\n-    /// to ensure unique ownership. This is also referred to as clone-on-write.\n+    /// If there are other `Arc` pointers to the same allocation, then `make_mut` will\n+    /// [`clone`] the inner value to a new allocation to ensure unique ownership.  This is also\n+    /// referred to as clone-on-write.\n     ///\n-    /// Note that this differs from the behavior of [`Rc::make_mut`] which disassociates\n-    /// any remaining `Weak` pointers.\n+    /// However, if there are no other `Arc` pointers to this allocation, but some [`Weak`]\n+    /// pointers, then the [`Weak`] pointers will be disassociated and the inner value will not\n+    /// be cloned.\n     ///\n-    /// See also [`get_mut`][get_mut], which will fail rather than cloning.\n+    /// See also [`get_mut`], which will fail rather than cloning the inner value\n+    /// or diassociating [`Weak`] pointers.\n     ///\n-    /// [clone]: Clone::clone\n-    /// [get_mut]: Arc::get_mut\n-    /// [`Rc::make_mut`]: super::rc::Rc::make_mut\n+    /// [`clone`]: Clone::clone\n+    /// [`get_mut`]: Arc::get_mut\n     ///\n     /// # Examples\n     ///\n@@ -1376,6 +1377,23 @@ impl<T: Clone> Arc<T> {\n     /// assert_eq!(*data, 8);\n     /// assert_eq!(*other_data, 12);\n     /// ```\n+    ///\n+    /// [`Weak`] pointers will be disassociated:\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut data = Arc::new(75);\n+    /// let weak = Arc::downgrade(&data);\n+    ///\n+    /// assert!(75 == *data);\n+    /// assert!(75 == *weak.upgrade().unwrap());\n+    ///\n+    /// *Arc::make_mut(&mut data) += 1;\n+    ///\n+    /// assert!(76 == *data);\n+    /// assert!(weak.upgrade().is_none());\n+    /// ```\n     #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     #[stable(feature = \"arc_unique\", since = \"1.4.0\")]\n@@ -1441,7 +1459,7 @@ impl<T: ?Sized> Arc<T> {\n     /// mutate a shared value.\n     ///\n     /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n-    /// the inner value when there are other pointers.\n+    /// the inner value when there are other `Arc` pointers.\n     ///\n     /// [make_mut]: Arc::make_mut\n     /// [clone]: Clone::clone"}, {"sha": "a38b5c471bf06cc63b546b28fa5e8c1a44836379", "filename": "library/alloc/tests/boxed.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Falloc%2Ftests%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Falloc%2Ftests%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fboxed.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -35,11 +35,11 @@ fn box_clone_and_clone_from_equivalence() {\n     }\n }\n \n-/// This test might give a false positive in case the box realocates, but the alocator keeps the\n-/// original pointer.\n+/// This test might give a false positive in case the box reallocates,\n+/// but the allocator keeps the original pointer.\n ///\n-/// On the other hand it won't give a false negative, if it fails than the memory was definitely not\n-/// reused\n+/// On the other hand, it won't give a false negative: If it fails, then the\n+/// memory was definitely not reused.\n #[test]\n fn box_clone_from_ptr_stability() {\n     for size in (0..8).map(|i| 2usize.pow(i)) {"}, {"sha": "85b43f48847608a4708b2464ce71ba5d4c3d66ac", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -576,6 +576,26 @@ impl<T> Cell<[T]> {\n     }\n }\n \n+impl<T, const N: usize> Cell<[T; N]> {\n+    /// Returns a `&[Cell<T>; N]` from a `&Cell<[T; N]>`\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(as_array_of_cells)]\n+    /// use std::cell::Cell;\n+    ///\n+    /// let mut array: [i32; 3] = [1, 2, 3];\n+    /// let cell_array: &Cell<[i32; 3]> = Cell::from_mut(&mut array);\n+    /// let array_cell: &[Cell<i32>; 3] = cell_array.as_array_of_cells();\n+    /// ```\n+    #[unstable(feature = \"as_array_of_cells\", issue = \"88248\")]\n+    pub fn as_array_of_cells(&self) -> &[Cell<T>; N] {\n+        // SAFETY: `Cell<T>` has the same memory layout as `T`.\n+        unsafe { &*(self as *const Cell<[T; N]> as *const [Cell<T>; N]) }\n+    }\n+}\n+\n /// A mutable memory location with dynamically checked borrow rules\n ///\n /// See the [module-level documentation](self) for more."}, {"sha": "850435b53cc7e3ebfb7502d54826700515babbeb", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -1957,8 +1957,8 @@ pub trait Iterator {\n     /// assert_eq!(it.next(), Some(&40));\n     /// ```\n     ///\n-    /// While you cannot `break` from a closure, the [`crate::ops::ControlFlow`]\n-    /// type allows a similar idea:\n+    /// While you cannot `break` from a closure, the [`ControlFlow`] type allows\n+    /// a similar idea:\n     ///\n     /// ```\n     /// use std::ops::ControlFlow;\n@@ -2024,8 +2024,8 @@ pub trait Iterator {\n     /// assert_eq!(it.next(), Some(\"stale_bread.json\"));\n     /// ```\n     ///\n-    /// The [`crate::ops::ControlFlow`] type can be used with this method for the\n-    /// situations in which you'd use `break` and `continue` in a normal loop:\n+    /// The [`ControlFlow`] type can be used with this method for the situations\n+    /// in which you'd use `break` and `continue` in a normal loop:\n     ///\n     /// ```\n     /// use std::ops::ControlFlow;\n@@ -2442,14 +2442,14 @@ pub trait Iterator {\n         R: Try<Output = bool>,\n         // FIXME: This bound is rather strange, but means minimal breakage on nightly.\n         // See #85115 for the issue tracking a holistic solution for this and try_map.\n-        R: crate::ops::TryV2<Residual = Result<crate::convert::Infallible, E>>,\n+        R: Try<Residual = Result<crate::convert::Infallible, E>>,\n     {\n         #[inline]\n         fn check<F, T, R, E>(mut f: F) -> impl FnMut((), T) -> ControlFlow<Result<T, E>>\n         where\n             F: FnMut(&T) -> R,\n             R: Try<Output = bool>,\n-            R: crate::ops::TryV2<Residual = Result<crate::convert::Infallible, E>>,\n+            R: Try<Residual = Result<crate::convert::Infallible, E>>,\n         {\n             move |(), x| match f(&x).branch() {\n                 ControlFlow::Continue(false) => ControlFlow::CONTINUE,"}, {"sha": "cd2d57699c92c95e797b647c68480d0c60905377", "filename": "library/core/src/ops/control_flow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -63,7 +63,7 @@ pub enum ControlFlow<B, C = ()> {\n }\n \n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n-impl<B, C> ops::TryV2 for ControlFlow<B, C> {\n+impl<B, C> ops::Try for ControlFlow<B, C> {\n     type Output = C;\n     type Residual = ControlFlow<B, convert::Infallible>;\n \n@@ -165,7 +165,7 @@ impl<B, C> ControlFlow<B, C> {\n /// These are used only as part of implementing the iterator adapters.\n /// They have mediocre names and non-obvious semantics, so aren't\n /// currently on a path to potential stabilization.\n-impl<R: ops::TryV2> ControlFlow<R, R::Output> {\n+impl<R: ops::Try> ControlFlow<R, R::Output> {\n     /// Create a `ControlFlow` from any type implementing `Try`.\n     #[inline]\n     pub(crate) fn from_try(r: R) -> Self {"}, {"sha": "bd7feb8b183ced5c29727a33299ae357ec72fa47", "filename": "library/core/src/ops/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fmod.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -182,13 +182,7 @@ pub use self::range::{Range, RangeFrom, RangeFull, RangeTo};\n pub use self::range::{Bound, RangeBounds, RangeInclusive, RangeToInclusive};\n \n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n-pub use self::try_trait::FromResidual;\n-\n-#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n-pub use self::try_trait::Try;\n-\n-#[unstable(feature = \"try_trait_transition\", reason = \"for bootstrap\", issue = \"none\")]\n-pub(crate) use self::try_trait::Try as TryV2;\n+pub use self::try_trait::{FromResidual, Try};\n \n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n pub use self::generator::{Generator, GeneratorState};"}, {"sha": "47865240f6a6fdaf601cc57ed7082acf9c37c50e", "filename": "library/core/src/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -2013,7 +2013,7 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n }\n \n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n-impl<T> ops::TryV2 for Option<T> {\n+impl<T> ops::Try for Option<T> {\n     type Output = T;\n     type Residual = Option<convert::Infallible>;\n "}, {"sha": "092e6544342b7f4e2105ce21fd9b81d25d29bede", "filename": "library/core/src/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -1889,7 +1889,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n }\n \n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n-impl<T, E> ops::TryV2 for Result<T, E> {\n+impl<T, E> ops::Try for Result<T, E> {\n     type Output = T;\n     type Residual = Result<convert::Infallible, E>;\n "}, {"sha": "8a31388fbdbbc6b68704022a2de0f4e09d50f5b6", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -369,6 +369,22 @@ where\n             // Instead of swapping one pair at the time, it is more efficient to perform a cyclic\n             // permutation. This is not strictly equivalent to swapping, but produces a similar\n             // result using fewer memory operations.\n+\n+            // SAFETY: The use of `ptr::read` is valid because there is at least one element in\n+            // both `offsets_l` and `offsets_r`, so `left!` is a valid pointer to read from.\n+            //\n+            // The uses of `left!` involve calls to `offset` on `l`, which points to the\n+            // beginning of `v`. All the offsets pointed-to by `start_l` are at most `block_l`, so\n+            // these `offset` calls are safe as all reads are within the block. The same argument\n+            // applies for the uses of `right!`.\n+            //\n+            // The calls to `start_l.offset` are valid because there are at most `count-1` of them,\n+            // plus the final one at the end of the unsafe block, where `count` is the minimum number\n+            // of collected offsets in `offsets_l` and `offsets_r`, so there is no risk of there not\n+            // being enough elements. The same reasoning applies to the calls to `start_r.offset`.\n+            //\n+            // The calls to `copy_nonoverlapping` are safe because `left!` and `right!` are guaranteed\n+            // not to overlap, and are valid because of the reasoning above.\n             unsafe {\n                 let tmp = ptr::read(left!());\n                 ptr::copy_nonoverlapping(right!(), left!(), 1);\n@@ -389,11 +405,21 @@ where\n \n         if start_l == end_l {\n             // All out-of-order elements in the left block were moved. Move to the next block.\n+\n+            // block-width-guarantee\n+            // SAFETY: if `!is_done` then the slice width is guaranteed to be at least `2*BLOCK` wide. There\n+            // are at most `BLOCK` elements in `offsets_l` because of its size, so the `offset` operation is\n+            // safe. Otherwise, the debug assertions in the `is_done` case guarantee that\n+            // `width(l, r) == block_l + block_r`, namely, that the block sizes have been adjusted to account\n+            // for the smaller number of remaining elements.\n             l = unsafe { l.offset(block_l as isize) };\n         }\n \n         if start_r == end_r {\n             // All out-of-order elements in the right block were moved. Move to the previous block.\n+\n+            // SAFETY: Same argument as [block-width-guarantee]. Either this is a full block `2*BLOCK`-wide,\n+            // or `block_r` has been adjusted for the last handful of elements.\n             r = unsafe { r.offset(-(block_r as isize)) };\n         }\n "}, {"sha": "250704609963217e62828be3ae43c2a1f7eaca10", "filename": "library/core/src/task/poll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -222,7 +222,7 @@ impl<T> From<T> for Poll<T> {\n }\n \n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n-impl<T, E> ops::TryV2 for Poll<Result<T, E>> {\n+impl<T, E> ops::Try for Poll<Result<T, E>> {\n     type Output = Poll<T>;\n     type Residual = Result<convert::Infallible, E>;\n \n@@ -252,7 +252,7 @@ impl<T, E, F: From<E>> ops::FromResidual<Result<convert::Infallible, E>> for Pol\n }\n \n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n-impl<T, E> ops::TryV2 for Poll<Option<Result<T, E>>> {\n+impl<T, E> ops::Try for Poll<Option<Result<T, E>>> {\n     type Output = Poll<Option<T>>;\n     type Residual = Result<convert::Infallible, E>;\n "}, {"sha": "de05c377852950120a0d70655d2ab94c87a53248", "filename": "library/std/src/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -958,7 +958,7 @@ impl From<&CStr> for Arc<CStr> {\n \n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<CString> for Rc<CStr> {\n-    /// Converts a [`CString`] into a [`Rc`]`<CStr>` without copying or allocating.\n+    /// Converts a [`CString`] into an [`Rc`]`<CStr>` without copying or allocating.\n     #[inline]\n     fn from(s: CString) -> Rc<CStr> {\n         let rc: Rc<[u8]> = Rc::from(s.into_inner());"}, {"sha": "21f354caf6ae9fba2d1ed486ff7411a5dec7e9ea", "filename": "library/std/src/ffi/os_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -916,7 +916,7 @@ impl From<&OsStr> for Arc<OsStr> {\n \n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<OsString> for Rc<OsStr> {\n-    /// Converts an [`OsString`] into a [`Rc`]`<OsStr>` without copying or allocating.\n+    /// Converts an [`OsString`] into an [`Rc`]`<OsStr>` without copying or allocating.\n     #[inline]\n     fn from(s: OsString) -> Rc<OsStr> {\n         let rc = s.inner.into_rc();"}, {"sha": "df60af7c36a3e236a73c6fb8abef22fd217fa989", "filename": "library/std/src/io/buffered/bufwriter.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -323,7 +323,6 @@ impl<W: Write> BufWriter<W> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(bufwriter_into_parts)]\n     /// use std::io::{BufWriter, Write};\n     ///\n     /// let mut buffer = [0u8; 10];\n@@ -334,7 +333,7 @@ impl<W: Write> BufWriter<W> {\n     /// assert_eq!(recovered_writer.len(), 0);\n     /// assert_eq!(&buffered_data.unwrap(), b\"ata\");\n     /// ```\n-    #[unstable(feature = \"bufwriter_into_parts\", issue = \"80690\")]\n+    #[stable(feature = \"bufwriter_into_parts\", since = \"1.56.0\")]\n     pub fn into_parts(mut self) -> (W, Result<Vec<u8>, WriterPanicked>) {\n         let buf = mem::take(&mut self.buf);\n         let buf = if !self.panicked { Ok(buf) } else { Err(WriterPanicked { buf }) };\n@@ -444,14 +443,13 @@ impl<W: Write> BufWriter<W> {\n     }\n }\n \n-#[unstable(feature = \"bufwriter_into_parts\", issue = \"80690\")]\n+#[stable(feature = \"bufwriter_into_parts\", since = \"1.56.0\")]\n /// Error returned for the buffered data from `BufWriter::into_parts`, when the underlying\n /// writer has previously panicked.  Contains the (possibly partly written) buffered data.\n ///\n /// # Example\n ///\n /// ```\n-/// #![feature(bufwriter_into_parts)]\n /// use std::io::{self, BufWriter, Write};\n /// use std::panic::{catch_unwind, AssertUnwindSafe};\n ///\n@@ -478,7 +476,7 @@ pub struct WriterPanicked {\n impl WriterPanicked {\n     /// Returns the perhaps-unwritten data.  Some of this data may have been written by the\n     /// panicking call(s) to the underlying writer, so simply writing it again is not a good idea.\n-    #[unstable(feature = \"bufwriter_into_parts\", issue = \"80690\")]\n+    #[stable(feature = \"bufwriter_into_parts\", since = \"1.56.0\")]\n     pub fn into_inner(self) -> Vec<u8> {\n         self.buf\n     }\n@@ -487,22 +485,22 @@ impl WriterPanicked {\n         \"BufWriter inner writer panicked, what data remains unwritten is not known\";\n }\n \n-#[unstable(feature = \"bufwriter_into_parts\", issue = \"80690\")]\n+#[stable(feature = \"bufwriter_into_parts\", since = \"1.56.0\")]\n impl error::Error for WriterPanicked {\n     #[allow(deprecated, deprecated_in_future)]\n     fn description(&self) -> &str {\n         Self::DESCRIPTION\n     }\n }\n \n-#[unstable(feature = \"bufwriter_into_parts\", issue = \"80690\")]\n+#[stable(feature = \"bufwriter_into_parts\", since = \"1.56.0\")]\n impl fmt::Display for WriterPanicked {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{}\", Self::DESCRIPTION)\n     }\n }\n \n-#[unstable(feature = \"bufwriter_into_parts\", issue = \"80690\")]\n+#[stable(feature = \"bufwriter_into_parts\", since = \"1.56.0\")]\n impl fmt::Debug for WriterPanicked {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"WriterPanicked\")"}, {"sha": "179bdf7fe553ace0281075792757ef91e7ddd7a8", "filename": "library/std/src/io/buffered/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fmod.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -14,7 +14,7 @@ use crate::io::Error;\n \n pub use bufreader::BufReader;\n pub use bufwriter::BufWriter;\n-#[unstable(feature = \"bufwriter_into_parts\", issue = \"80690\")]\n+#[stable(feature = \"bufwriter_into_parts\", since = \"1.56.0\")]\n pub use bufwriter::WriterPanicked;\n pub use linewriter::LineWriter;\n use linewritershim::LineWriterShim;"}, {"sha": "51666c0a3c7f1bf534c653b48916c51c7314bc6c", "filename": "library/std/src/io/error.rs", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -261,19 +261,15 @@ pub enum ErrorKind {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Interrupted,\n \n-    /// A custom error that does not fall under any other I/O error kind.\n-    ///\n-    /// This can be used to construct your own [`Error`]s that do not match any\n-    /// [`ErrorKind`].\n-    ///\n-    /// This [`ErrorKind`] is not used by the standard library.\n+    /// This operation is unsupported on this platform.\n     ///\n-    /// Errors from the standard library that do not fall under any of the I/O\n-    /// error kinds cannot be `match`ed on, and will only match a wildcard (`_`) pattern.\n-    /// New [`ErrorKind`]s might be added in the future for some of those.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Other,\n+    /// This means that the operation can never succeed.\n+    #[stable(feature = \"unsupported_error\", since = \"1.53.0\")]\n+    Unsupported,\n \n+    // ErrorKinds which are primarily categorisations for OS error\n+    // codes should be added above.\n+    //\n     /// An error returned when an operation could not be completed because an\n     /// \"end of file\" was reached prematurely.\n     ///\n@@ -283,17 +279,28 @@ pub enum ErrorKind {\n     #[stable(feature = \"read_exact\", since = \"1.6.0\")]\n     UnexpectedEof,\n \n-    /// This operation is unsupported on this platform.\n-    ///\n-    /// This means that the operation can never succeed.\n-    #[stable(feature = \"unsupported_error\", since = \"1.53.0\")]\n-    Unsupported,\n-\n     /// An operation could not be completed, because it failed\n     /// to allocate enough memory.\n     #[stable(feature = \"out_of_memory_error\", since = \"1.54.0\")]\n     OutOfMemory,\n \n+    // \"Unusual\" error kinds which do not correspond simply to (sets\n+    // of) OS error codes, should be added just above this comment.\n+    // `Other` and `Uncategorised` should remain at the end:\n+    //\n+    /// A custom error that does not fall under any other I/O error kind.\n+    ///\n+    /// This can be used to construct your own [`Error`]s that do not match any\n+    /// [`ErrorKind`].\n+    ///\n+    /// This [`ErrorKind`] is not used by the standard library.\n+    ///\n+    /// Errors from the standard library that do not fall under any of the I/O\n+    /// error kinds cannot be `match`ed on, and will only match a wildcard (`_`) pattern.\n+    /// New [`ErrorKind`]s might be added in the future for some of those.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Other,\n+\n     /// Any I/O error from the standard library that's not part of this list.\n     ///\n     /// Errors that are `Uncategorized` now may move to a different or a new\n@@ -307,23 +314,24 @@ pub enum ErrorKind {\n impl ErrorKind {\n     pub(crate) fn as_str(&self) -> &'static str {\n         use ErrorKind::*;\n+        // Strictly alphabetical, please.  (Sadly rustfmt cannot do this yet.)\n         match *self {\n             AddrInUse => \"address in use\",\n             AddrNotAvailable => \"address not available\",\n             AlreadyExists => \"entity already exists\",\n             ArgumentListTooLong => \"argument list too long\",\n             BrokenPipe => \"broken pipe\",\n-            ResourceBusy => \"resource busy\",\n             ConnectionAborted => \"connection aborted\",\n             ConnectionRefused => \"connection refused\",\n             ConnectionReset => \"connection reset\",\n             CrossesDevices => \"cross-device link or rename\",\n             Deadlock => \"deadlock\",\n             DirectoryNotEmpty => \"directory not empty\",\n             ExecutableFileBusy => \"executable file busy\",\n+            FileTooLarge => \"file too large\",\n             FilenameTooLong => \"filename too long\",\n+            FilesystemLoop => \"filesystem loop or indirection limit (e.g. symlink loop)\",\n             FilesystemQuotaExceeded => \"filesystem quota exceeded\",\n-            FileTooLarge => \"file too large\",\n             HostUnreachable => \"host unreachable\",\n             Interrupted => \"operation interrupted\",\n             InvalidData => \"invalid data\",\n@@ -332,16 +340,16 @@ impl ErrorKind {\n             NetworkDown => \"network down\",\n             NetworkUnreachable => \"network unreachable\",\n             NotADirectory => \"not a directory\",\n-            StorageFull => \"no storage space\",\n             NotConnected => \"not connected\",\n             NotFound => \"entity not found\",\n+            NotSeekable => \"seek on unseekable file\",\n             Other => \"other error\",\n             OutOfMemory => \"out of memory\",\n             PermissionDenied => \"permission denied\",\n             ReadOnlyFilesystem => \"read-only filesystem or storage medium\",\n+            ResourceBusy => \"resource busy\",\n             StaleNetworkFileHandle => \"stale network file handle\",\n-            FilesystemLoop => \"filesystem loop or indirection limit (e.g. symlink loop)\",\n-            NotSeekable => \"seek on unseekable file\",\n+            StorageFull => \"no storage space\",\n             TimedOut => \"timed out\",\n             TooManyLinks => \"too many links\",\n             Uncategorized => \"uncategorized error\","}, {"sha": "e8466fa06b899470cb213eb6ea295fdc1d6d86b6", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -264,7 +264,7 @@ use crate::sys_common::memchr;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::buffered::IntoInnerError;\n-#[unstable(feature = \"bufwriter_into_parts\", issue = \"80690\")]\n+#[stable(feature = \"bufwriter_into_parts\", since = \"1.56.0\")]\n pub use self::buffered::WriterPanicked;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::buffered::{BufReader, BufWriter, LineWriter};"}, {"sha": "e34768bc2c906ba9f3245cc87f7c3508f6e0f559", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -301,6 +301,7 @@ def default_build_triple(verbose):\n         'ppc': 'powerpc',\n         'ppc64': 'powerpc64',\n         'ppc64le': 'powerpc64le',\n+        'riscv64': 'riscv64gc',\n         's390x': 's390x',\n         'x64': 'x86_64',\n         'x86': 'i686',"}, {"sha": "687e21bde2ea10c261f79fa14797c5137425098d", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -1 +1 @@\n-Subproject commit 7e49659102f0977d9142190e1ba23345c0f00eb1\n+Subproject commit 687e21bde2ea10c261f79fa14797c5137425098d"}, {"sha": "da6ea9b03f74cae0a292f40315723d7a3a973637", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -1 +1 @@\n-Subproject commit 4884fe45c14f8b22121760fb117181bb4da8dfe0\n+Subproject commit da6ea9b03f74cae0a292f40315723d7a3a973637"}, {"sha": "04f489c889235fe3b6dfe678ae5410d07deda958", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -1 +1 @@\n-Subproject commit 0dc9cd4e89f00cb5230f120e1a083916386e422b\n+Subproject commit 04f489c889235fe3b6dfe678ae5410d07deda958"}, {"sha": "cf0e151b7925a40f13fbc6573c6f97d5f94c7c17", "filename": "src/doc/rustc-dev-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-dev-guide?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -1 +1 @@\n-Subproject commit c4644b427cbdaafc7a87be0ccdf5d8aaa07ac35f\n+Subproject commit cf0e151b7925a40f13fbc6573c6f97d5f94c7c17"}, {"sha": "9f487bd8061fc5994d3c7cfed36dcaf91f3dcce0", "filename": "src/test/ui/asm/named-asm-labels.rs", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/src%2Ftest%2Fui%2Fasm%2Fnamed-asm-labels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/src%2Ftest%2Fui%2Fasm%2Fnamed-asm-labels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fnamed-asm-labels.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -1,6 +1,14 @@\n // only-x86_64\n \n-#![feature(asm, global_asm)]\n+// Tests that the use of named labels in the `asm!` macro are linted against\n+// except for in `#[naked]` fns.\n+// Using a named label is incorrect as per the RFC because for most cases\n+// the compiler cannot ensure that inline asm is emitted exactly once per\n+// codegen unit (except for naked fns) and so the label could be duplicated\n+// which causes less readable LLVM errors and in the worst cases causes ICEs\n+// or segfaults based on system dependent behavior and codegen flags.\n+\n+#![feature(asm, global_asm, naked_functions)]\n \n #[no_mangle]\n pub static FOO: usize = 42;\n@@ -126,5 +134,61 @@ fn main() {\n     }\n }\n \n+// Trigger on naked fns too, even though they can't be inlined, reusing a\n+// label or LTO can cause labels to break\n+#[naked]\n+pub extern \"C\" fn foo() -> i32 {\n+    unsafe { asm!(\".Lfoo: mov rax, {}; ret;\", \"nop\", const 1, options(noreturn)) } //~ ERROR avoid using named labels\n+}\n+\n+// Make sure that non-naked attributes *do* still let the lint happen\n+#[no_mangle]\n+pub extern \"C\" fn bar() {\n+    unsafe { asm!(\".Lbar: mov rax, {}; ret;\", \"nop\", const 1, options(noreturn)) }\n+    //~^ ERROR avoid using named labels\n+}\n+\n+#[naked]\n+pub extern \"C\" fn aaa() {\n+    fn _local() {}\n+\n+    unsafe { asm!(\".Laaa: nop; ret;\", options(noreturn)) } //~ ERROR avoid using named labels\n+}\n+\n+pub fn normal() {\n+    fn _local1() {}\n+\n+    #[naked]\n+    pub extern \"C\" fn bbb() {\n+        fn _very_local() {}\n+\n+        unsafe { asm!(\".Lbbb: nop; ret;\", options(noreturn)) } //~ ERROR avoid using named labels\n+    }\n+\n+    fn _local2() {}\n+}\n+\n+// Make sure that the lint happens within closures\n+fn closures() {\n+    || unsafe {\n+        asm!(\"closure1: nop\"); //~ ERROR avoid using named labels\n+    };\n+\n+    move || unsafe {\n+        asm!(\"closure2: nop\"); //~ ERROR avoid using named labels\n+    };\n+\n+    || {\n+        #[naked]\n+        unsafe extern \"C\" fn _nested() {\n+            asm!(\"ret;\", options(noreturn));\n+        }\n+\n+        unsafe {\n+            asm!(\"closure3: nop\"); //~ ERROR avoid using named labels\n+        }\n+    };\n+}\n+\n // Don't trigger on global asm\n global_asm!(\"aaaaaaaa: nop\");"}, {"sha": "396f0a1942428800f0e711f817b4332f941da732", "filename": "src/test/ui/asm/named-asm-labels.stderr", "status": "modified", "additions": 94, "deletions": 31, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/src%2Ftest%2Fui%2Fasm%2Fnamed-asm-labels.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/src%2Ftest%2Fui%2Fasm%2Fnamed-asm-labels.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fnamed-asm-labels.stderr?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -1,5 +1,5 @@\n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:11:15\n+  --> $DIR/named-asm-labels.rs:19:15\n    |\n LL |         asm!(\"bar: nop\");\n    |               ^^^\n@@ -9,7 +9,7 @@ LL |         asm!(\"bar: nop\");\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:14:15\n+  --> $DIR/named-asm-labels.rs:22:15\n    |\n LL |         asm!(\"abcd:\");\n    |               ^^^^\n@@ -18,7 +18,7 @@ LL |         asm!(\"abcd:\");\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:17:15\n+  --> $DIR/named-asm-labels.rs:25:15\n    |\n LL |         asm!(\"foo: bar1: nop\");\n    |               ^^^  ^^^^\n@@ -27,7 +27,7 @@ LL |         asm!(\"foo: bar1: nop\");\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:21:15\n+  --> $DIR/named-asm-labels.rs:29:15\n    |\n LL |         asm!(\"foo1: nop\", \"nop\");\n    |               ^^^^\n@@ -36,7 +36,7 @@ LL |         asm!(\"foo1: nop\", \"nop\");\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:22:15\n+  --> $DIR/named-asm-labels.rs:30:15\n    |\n LL |         asm!(\"foo2: foo3: nop\", \"nop\");\n    |               ^^^^  ^^^^\n@@ -45,7 +45,7 @@ LL |         asm!(\"foo2: foo3: nop\", \"nop\");\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:24:22\n+  --> $DIR/named-asm-labels.rs:32:22\n    |\n LL |         asm!(\"nop\", \"foo4: nop\");\n    |                      ^^^^\n@@ -54,7 +54,7 @@ LL |         asm!(\"nop\", \"foo4: nop\");\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:25:15\n+  --> $DIR/named-asm-labels.rs:33:15\n    |\n LL |         asm!(\"foo5: nop\", \"foo6: nop\");\n    |               ^^^^\n@@ -63,7 +63,7 @@ LL |         asm!(\"foo5: nop\", \"foo6: nop\");\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:25:28\n+  --> $DIR/named-asm-labels.rs:33:28\n    |\n LL |         asm!(\"foo5: nop\", \"foo6: nop\");\n    |                            ^^^^\n@@ -72,7 +72,7 @@ LL |         asm!(\"foo5: nop\", \"foo6: nop\");\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:30:15\n+  --> $DIR/named-asm-labels.rs:38:15\n    |\n LL |         asm!(\"foo7: nop; foo8: nop\");\n    |               ^^^^       ^^^^\n@@ -81,7 +81,7 @@ LL |         asm!(\"foo7: nop; foo8: nop\");\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:32:15\n+  --> $DIR/named-asm-labels.rs:40:15\n    |\n LL |         asm!(\"foo9: nop; nop\");\n    |               ^^^^\n@@ -90,7 +90,7 @@ LL |         asm!(\"foo9: nop; nop\");\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:33:20\n+  --> $DIR/named-asm-labels.rs:41:20\n    |\n LL |         asm!(\"nop; foo10: nop\");\n    |                    ^^^^^\n@@ -99,7 +99,7 @@ LL |         asm!(\"nop; foo10: nop\");\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:36:15\n+  --> $DIR/named-asm-labels.rs:44:15\n    |\n LL |         asm!(\"bar2: nop\\n bar3: nop\");\n    |               ^^^^        ^^^^\n@@ -108,7 +108,7 @@ LL |         asm!(\"bar2: nop\\n bar3: nop\");\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:38:15\n+  --> $DIR/named-asm-labels.rs:46:15\n    |\n LL |         asm!(\"bar4: nop\\n nop\");\n    |               ^^^^\n@@ -117,7 +117,7 @@ LL |         asm!(\"bar4: nop\\n nop\");\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:39:21\n+  --> $DIR/named-asm-labels.rs:47:21\n    |\n LL |         asm!(\"nop\\n bar5: nop\");\n    |                     ^^^^\n@@ -126,7 +126,7 @@ LL |         asm!(\"nop\\n bar5: nop\");\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:40:21\n+  --> $DIR/named-asm-labels.rs:48:21\n    |\n LL |         asm!(\"nop\\n bar6: bar7: nop\");\n    |                     ^^^^  ^^^^\n@@ -135,7 +135,7 @@ LL |         asm!(\"nop\\n bar6: bar7: nop\");\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:46:13\n+  --> $DIR/named-asm-labels.rs:54:13\n    |\n LL |             blah2: nop\n    |             ^^^^^\n@@ -146,7 +146,7 @@ LL |             blah3: nop\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:55:19\n+  --> $DIR/named-asm-labels.rs:63:19\n    |\n LL |             nop ; blah4: nop\n    |                   ^^^^^\n@@ -155,7 +155,7 @@ LL |             nop ; blah4: nop\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:69:15\n+  --> $DIR/named-asm-labels.rs:77:15\n    |\n LL |         asm!(\"blah1: 2bar: nop\");\n    |               ^^^^^\n@@ -164,7 +164,7 @@ LL |         asm!(\"blah1: 2bar: nop\");\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:72:15\n+  --> $DIR/named-asm-labels.rs:80:15\n    |\n LL |         asm!(\"def: def: nop\");\n    |               ^^^\n@@ -173,7 +173,7 @@ LL |         asm!(\"def: def: nop\");\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:73:15\n+  --> $DIR/named-asm-labels.rs:81:15\n    |\n LL |         asm!(\"def: nop\\ndef: nop\");\n    |               ^^^\n@@ -182,7 +182,7 @@ LL |         asm!(\"def: nop\\ndef: nop\");\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:74:15\n+  --> $DIR/named-asm-labels.rs:82:15\n    |\n LL |         asm!(\"def: nop; def: nop\");\n    |               ^^^\n@@ -191,7 +191,7 @@ LL |         asm!(\"def: nop; def: nop\");\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:82:15\n+  --> $DIR/named-asm-labels.rs:90:15\n    |\n LL |         asm!(\"fooo\\u{003A} nop\");\n    |               ^^^^^^^^^^^^^^^^\n@@ -200,7 +200,7 @@ LL |         asm!(\"fooo\\u{003A} nop\");\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:83:15\n+  --> $DIR/named-asm-labels.rs:91:15\n    |\n LL |         asm!(\"foooo\\x3A nop\");\n    |               ^^^^^^^^^^^^^\n@@ -209,7 +209,7 @@ LL |         asm!(\"foooo\\x3A nop\");\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:86:15\n+  --> $DIR/named-asm-labels.rs:94:15\n    |\n LL |         asm!(\"fooooo:\\u{000A} nop\");\n    |               ^^^^^^\n@@ -218,7 +218,7 @@ LL |         asm!(\"fooooo:\\u{000A} nop\");\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:87:15\n+  --> $DIR/named-asm-labels.rs:95:15\n    |\n LL |         asm!(\"foooooo:\\x0A nop\");\n    |               ^^^^^^^\n@@ -227,7 +227,7 @@ LL |         asm!(\"foooooo:\\x0A nop\");\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:91:14\n+  --> $DIR/named-asm-labels.rs:99:14\n    |\n LL |         asm!(\"\\x41\\x42\\x43\\x3A\\x20\\x6E\\x6F\\x70\");\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -236,7 +236,7 @@ LL |         asm!(\"\\x41\\x42\\x43\\x3A\\x20\\x6E\\x6F\\x70\");\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:102:13\n+  --> $DIR/named-asm-labels.rs:110:13\n    |\n LL |             ab: nop // ab: does foo\n    |             ^^\n@@ -245,7 +245,7 @@ LL |             ab: nop // ab: does foo\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n error: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:114:14\n+  --> $DIR/named-asm-labels.rs:122:14\n    |\n LL |         asm!(include_str!(\"named-asm-labels.s\"));\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -254,18 +254,81 @@ LL |         asm!(include_str!(\"named-asm-labels.s\"));\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n warning: avoid using named labels in inline assembly\n-  --> $DIR/named-asm-labels.rs:124:19\n+  --> $DIR/named-asm-labels.rs:132:19\n    |\n LL |             asm!(\"warned: nop\");\n    |                   ^^^^^^\n    |\n note: the lint level is defined here\n-  --> $DIR/named-asm-labels.rs:122:16\n+  --> $DIR/named-asm-labels.rs:130:16\n    |\n LL |         #[warn(named_asm_labels)]\n    |                ^^^^^^^^^^^^^^^^\n    = help: only local labels of the form `<number>:` should be used in inline asm\n    = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n \n-error: aborting due to 28 previous errors; 1 warning emitted\n+error: avoid using named labels in inline assembly\n+  --> $DIR/named-asm-labels.rs:141:20\n+   |\n+LL |     unsafe { asm!(\".Lfoo: mov rax, {}; ret;\", \"nop\", const 1, options(noreturn)) }\n+   |                    ^^^^^\n+   |\n+   = help: only local labels of the form `<number>:` should be used in inline asm\n+   = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n+\n+error: avoid using named labels in inline assembly\n+  --> $DIR/named-asm-labels.rs:147:20\n+   |\n+LL |     unsafe { asm!(\".Lbar: mov rax, {}; ret;\", \"nop\", const 1, options(noreturn)) }\n+   |                    ^^^^^\n+   |\n+   = help: only local labels of the form `<number>:` should be used in inline asm\n+   = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n+\n+error: avoid using named labels in inline assembly\n+  --> $DIR/named-asm-labels.rs:155:20\n+   |\n+LL |     unsafe { asm!(\".Laaa: nop; ret;\", options(noreturn)) }\n+   |                    ^^^^^\n+   |\n+   = help: only local labels of the form `<number>:` should be used in inline asm\n+   = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n+\n+error: avoid using named labels in inline assembly\n+  --> $DIR/named-asm-labels.rs:165:24\n+   |\n+LL |         unsafe { asm!(\".Lbbb: nop; ret;\", options(noreturn)) }\n+   |                        ^^^^^\n+   |\n+   = help: only local labels of the form `<number>:` should be used in inline asm\n+   = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n+\n+error: avoid using named labels in inline assembly\n+  --> $DIR/named-asm-labels.rs:174:15\n+   |\n+LL |         asm!(\"closure1: nop\");\n+   |               ^^^^^^^^\n+   |\n+   = help: only local labels of the form `<number>:` should be used in inline asm\n+   = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n+\n+error: avoid using named labels in inline assembly\n+  --> $DIR/named-asm-labels.rs:178:15\n+   |\n+LL |         asm!(\"closure2: nop\");\n+   |               ^^^^^^^^\n+   |\n+   = help: only local labels of the form `<number>:` should be used in inline asm\n+   = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n+\n+error: avoid using named labels in inline assembly\n+  --> $DIR/named-asm-labels.rs:188:19\n+   |\n+LL |             asm!(\"closure3: nop\");\n+   |                   ^^^^^^^^\n+   |\n+   = help: only local labels of the form `<number>:` should be used in inline asm\n+   = note: see the asm section of the unstable book <https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#labels> for more information\n+\n+error: aborting due to 35 previous errors; 1 warning emitted\n "}, {"sha": "27a599315dc1c580095682525d05da3f03237c4e", "filename": "src/test/ui/drop/dropck_legal_cycles.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/src%2Ftest%2Fui%2Fdrop%2Fdropck_legal_cycles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/src%2Ftest%2Fui%2Fdrop%2Fdropck_legal_cycles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdropck_legal_cycles.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -368,7 +368,7 @@ pub fn main() {\n     // We can use refcells if we're single-threaded (as this test is).\n     // If one were to generalize these constructions to a\n     // multi-threaded context, then it might seem like we could choose\n-    // between either a RwLock or a Mutex to hold the owned arcs on\n+    // between either an RwLock or a Mutex to hold the owned arcs on\n     // each node.\n     //\n     // Part of the point of this test is to actually confirm that the"}, {"sha": "329fadb150fcd9586e5f39e60e5f34e881ced254", "filename": "src/test/ui/rfcs/rfc-1789-as-cell/from-mut.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/src%2Ftest%2Fui%2Frfcs%2Frfc-1789-as-cell%2Ffrom-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/src%2Ftest%2Fui%2Frfcs%2Frfc-1789-as-cell%2Ffrom-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-1789-as-cell%2Ffrom-mut.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -1,5 +1,7 @@\n // run-pass\n \n+#![feature(as_array_of_cells)]\n+\n use std::cell::Cell;\n \n fn main() {\n@@ -8,4 +10,11 @@ fn main() {\n     let slice_cell: &[Cell<i32>] = cell_slice.as_slice_of_cells();\n \n     assert_eq!(slice_cell.len(), 3);\n+\n+    let mut array: [i32; 3] = [1, 2, 3];\n+    let cell_array: &Cell<[i32; 3]> = Cell::from_mut(&mut array);\n+    let array_cell: &[Cell<i32>; 3] = cell_array.as_array_of_cells();\n+\n+    array_cell[0].set(99);\n+    assert_eq!(array, [99, 2, 3]);\n }"}, {"sha": "7f8e6127cca3b2faf3b078c5bb6f34823fe1e857", "filename": "src/test/ui/type-alias-impl-trait/type_of_a_let.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype_of_a_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype_of_a_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype_of_a_let.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -0,0 +1,29 @@\n+#![feature(type_alias_impl_trait)]\n+#![allow(dead_code)]\n+\n+// FIXME This should compile, but it currently doesn't\n+\n+use std::fmt::Debug;\n+\n+type Foo = impl Debug;\n+//~^ ERROR: could not find defining uses\n+\n+fn foo1() -> u32 {\n+    let x: Foo = 22_u32;\n+    //~^ ERROR: mismatched types [E0308]\n+    x\n+    //~^ ERROR: mismatched types [E0308]\n+}\n+\n+fn foo2() -> u32 {\n+    let x: Foo = 22_u32;\n+    //~^ ERROR: mismatched types [E0308]\n+    let y: Foo = x;\n+    same_type((x, y));\n+    y\n+    //~^ ERROR: mismatched types [E0308]\n+}\n+\n+fn same_type<T>(x: (T, T)) {}\n+\n+fn main() {}"}, {"sha": "cac8d6841afda098ec95f81178252b7c16d75123", "filename": "src/test/ui/type-alias-impl-trait/type_of_a_let.stderr", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype_of_a_let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype_of_a_let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype_of_a_let.stderr?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -0,0 +1,67 @@\n+error[E0308]: mismatched types\n+  --> $DIR/type_of_a_let.rs:12:18\n+   |\n+LL | type Foo = impl Debug;\n+   |            ---------- the expected opaque type\n+...\n+LL |     let x: Foo = 22_u32;\n+   |            ---   ^^^^^^ expected opaque type, found `u32`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected opaque type `impl Debug`\n+                     found type `u32`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type_of_a_let.rs:14:5\n+   |\n+LL | type Foo = impl Debug;\n+   |            ---------- the found opaque type\n+...\n+LL | fn foo1() -> u32 {\n+   |              --- expected `u32` because of return type\n+...\n+LL |     x\n+   |     ^ expected `u32`, found opaque type\n+   |\n+   = note:     expected type `u32`\n+           found opaque type `impl Debug`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type_of_a_let.rs:19:18\n+   |\n+LL | type Foo = impl Debug;\n+   |            ---------- the expected opaque type\n+...\n+LL |     let x: Foo = 22_u32;\n+   |            ---   ^^^^^^ expected opaque type, found `u32`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected opaque type `impl Debug`\n+                     found type `u32`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type_of_a_let.rs:23:5\n+   |\n+LL | type Foo = impl Debug;\n+   |            ---------- the found opaque type\n+...\n+LL | fn foo2() -> u32 {\n+   |              --- expected `u32` because of return type\n+...\n+LL |     y\n+   |     ^ expected `u32`, found opaque type\n+   |\n+   = note:     expected type `u32`\n+           found opaque type `impl Debug`\n+\n+error: could not find defining uses\n+  --> $DIR/type_of_a_let.rs:8:12\n+   |\n+LL | type Foo = impl Debug;\n+   |            ^^^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "33d3f164ce15eaec80f44835b7a4046b10303c14", "filename": "src/test/ui/type-alias-impl-trait/type_of_a_let2.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype_of_a_let2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype_of_a_let2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype_of_a_let2.rs?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -0,0 +1,25 @@\n+#![feature(type_alias_impl_trait)]\n+#![allow(dead_code)]\n+\n+// FIXME This should be under a feature flag\n+\n+use std::fmt::Debug;\n+\n+fn foo1() -> u32 {\n+    let x: impl Debug = 22_u32;\n+    //~^ ERROR: `impl Trait` not allowed outside of function and method return types [E0562]\n+    x // ERROR: we only know x: Debug, we don't know x = u32\n+}\n+\n+fn foo2() -> u32 {\n+    let x: impl Debug = 22_u32;\n+    //~^ ERROR: `impl Trait` not allowed outside of function and method return types [E0562]\n+    let y: impl Debug = x;\n+    //~^ ERROR: `impl Trait` not allowed outside of function and method return types [E0562]\n+    same_type((x, y)); // ERROR\n+    x\n+}\n+\n+fn same_type<T>(x: (T, T)) {}\n+\n+fn main() {}"}, {"sha": "7a1825a8e2d9a9a35afd57b4db9609a3a95d849e", "filename": "src/test/ui/type-alias-impl-trait/type_of_a_let2.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7b0e554ee2c94e9b3865a8c2d24d720224512dec/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype_of_a_let2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b0e554ee2c94e9b3865a8c2d24d720224512dec/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype_of_a_let2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype_of_a_let2.stderr?ref=7b0e554ee2c94e9b3865a8c2d24d720224512dec", "patch": "@@ -0,0 +1,21 @@\n+error[E0562]: `impl Trait` not allowed outside of function and method return types\n+  --> $DIR/type_of_a_let2.rs:9:12\n+   |\n+LL |     let x: impl Debug = 22_u32;\n+   |            ^^^^^^^^^^\n+\n+error[E0562]: `impl Trait` not allowed outside of function and method return types\n+  --> $DIR/type_of_a_let2.rs:15:12\n+   |\n+LL |     let x: impl Debug = 22_u32;\n+   |            ^^^^^^^^^^\n+\n+error[E0562]: `impl Trait` not allowed outside of function and method return types\n+  --> $DIR/type_of_a_let2.rs:17:12\n+   |\n+LL |     let y: impl Debug = x;\n+   |            ^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0562`."}]}