{"sha": "f68a0449ed4e49705e2ee70be6e5678aa426b206", "node_id": "C_kwDOAAsO6NoAKGY2OGEwNDQ5ZWQ0ZTQ5NzA1ZTJlZTcwYmU2ZTU2NzhhYTQyNmIyMDY", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-30T21:21:36Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-31T03:39:00Z"}, "message": "Remove `MatcherPos::stack`.\n\n`parse_tt` needs a way to get from within submatchers make to the\nenclosing submatchers. Currently it has two distinct mechanisms for\nthis:\n- `Delimited` submatchers use `MatcherPos::stack` to record stuff about\n  the parent (and further back ancestors).\n- `Sequence` submatchers use `MatcherPosSequence::parent` to point to\n  the parent matcher position.\n\nHaving two mechanisms is really confusing, and it took me a long time to\nunderstand all this.\n\nThis commit eliminates `MatcherPos::stack`, and changes `Delimited`\nsubmatchers to use the same mechanism as sequence submatchers. That\nmechanism is also changed a bit: instead of storing the entire parent\n`MatcherPos`, we now only store the necessary parts from the parent\n`MatcherPos`.\n\nOverall this is a small performance win, with the positives outweighing\nthe negatives, but it's mostly for clarity.", "tree": {"sha": "b978668d9df0404b7c8b51391d6920eb70d094cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b978668d9df0404b7c8b51391d6920eb70d094cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f68a0449ed4e49705e2ee70be6e5678aa426b206", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f68a0449ed4e49705e2ee70be6e5678aa426b206", "html_url": "https://github.com/rust-lang/rust/commit/f68a0449ed4e49705e2ee70be6e5678aa426b206", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f68a0449ed4e49705e2ee70be6e5678aa426b206/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "048bd67d513d23341431da208aa7ec075d6252b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/048bd67d513d23341431da208aa7ec075d6252b2", "html_url": "https://github.com/rust-lang/rust/commit/048bd67d513d23341431da208aa7ec075d6252b2"}], "stats": {"total": 136, "additions": 74, "deletions": 62}, "files": [{"sha": "f5a93905b82e4ef72024975a090a4be063257537", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f68a0449ed4e49705e2ee70be6e5678aa426b206/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f68a0449ed4e49705e2ee70be6e5678aa426b206/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=f68a0449ed4e49705e2ee70be6e5678aa426b206", "patch": "@@ -1,5 +1,6 @@\n #![feature(associated_type_bounds)]\n #![feature(associated_type_defaults)]\n+#![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]"}, {"sha": "0e05440493a635a31a25a210a7cba7832b2cdb77", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 73, "deletions": 62, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/f68a0449ed4e49705e2ee70be6e5678aa426b206/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f68a0449ed4e49705e2ee70be6e5678aa426b206/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=f68a0449ed4e49705e2ee70be6e5678aa426b206", "patch": "@@ -87,17 +87,6 @@ use rustc_data_structures::sync::Lrc;\n use rustc_span::symbol::Ident;\n use std::borrow::Cow;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n-use std::mem;\n-\n-/// This is used by `parse_tt_inner` to keep track of delimited submatchers that we have\n-/// descended into.\n-#[derive(Clone)]\n-struct MatcherPosFrame<'tt> {\n-    /// The \"parent\" matcher that we have descended from.\n-    tts: &'tt [TokenTree],\n-    /// The position of the \"dot\" in `tt` at the time we descended.\n-    idx: usize,\n-}\n \n // One element is enough to cover 95-99% of vectors for most benchmarks. Also,\n // vectors longer than one frequently have many elements, not just two or\n@@ -108,6 +97,33 @@ type NamedMatchVec = SmallVec<[NamedMatch; 1]>;\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(NamedMatchVec, 48);\n \n+#[derive(Clone)]\n+enum MatcherKind<'tt> {\n+    TopLevel,\n+    Delimited(Box<DelimitedSubmatcher<'tt>>),\n+    Sequence(Box<SequenceSubmatcher<'tt>>),\n+}\n+\n+#[derive(Clone)]\n+struct DelimitedSubmatcher<'tt> {\n+    parent: Parent<'tt>,\n+}\n+\n+#[derive(Clone)]\n+struct SequenceSubmatcher<'tt> {\n+    parent: Parent<'tt>,\n+    seq: &'tt SequenceRepetition,\n+}\n+\n+/// Data used to ascend from a submatcher back to its parent matcher. A subset of the fields from\n+/// `MathcherPos`.\n+#[derive(Clone)]\n+struct Parent<'tt> {\n+    tts: &'tt [TokenTree],\n+    idx: usize,\n+    kind: MatcherKind<'tt>,\n+}\n+\n /// A single matcher position, which could be within the top-level matcher, a submatcher, a\n /// subsubmatcher, etc. For example:\n /// ```text\n@@ -140,17 +156,14 @@ struct MatcherPos<'tt> {\n     /// stream. Should not be used if there are no metavars.\n     match_cur: usize,\n \n-    /// This field is only used if we are matching a sequence.\n-    sequence: Option<MatcherPosSequence<'tt>>,\n-\n-    /// When we are within a `Delimited` submatcher (or subsubmatcher), this tracks the parent\n-    /// matcher(s). The bottom of the stack is the top-level matcher.\n-    stack: SmallVec<[MatcherPosFrame<'tt>; 1]>,\n+    /// What kind of matcher we are in. For submatchers, this contains enough information to\n+    /// reconstitute a `MatcherPos` within the parent once we ascend out of the submatcher.\n+    kind: MatcherKind<'tt>,\n }\n \n // This type is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(MatcherPos<'_>, 96);\n+rustc_data_structures::static_assert_size!(MatcherPos<'_>, 64);\n \n impl<'tt> MatcherPos<'tt> {\n     fn top_level(matcher: &'tt [TokenTree], empty_matches: Lrc<NamedMatchVec>) -> Self {\n@@ -160,24 +173,26 @@ impl<'tt> MatcherPos<'tt> {\n             matches: empty_matches,\n             seq_depth: 0,\n             match_cur: 0,\n-            stack: smallvec![],\n-            sequence: None,\n+            kind: MatcherKind::TopLevel,\n         }\n     }\n \n     fn sequence(\n-        parent: Box<MatcherPos<'tt>>,\n+        parent_mp: Box<MatcherPos<'tt>>,\n         seq: &'tt SequenceRepetition,\n         empty_matches: Lrc<NamedMatchVec>,\n     ) -> Self {\n+        let seq_kind = box SequenceSubmatcher {\n+            parent: Parent { tts: parent_mp.tts, idx: parent_mp.idx, kind: parent_mp.kind },\n+            seq,\n+        };\n         let mut mp = MatcherPos {\n             tts: &seq.tts,\n             idx: 0,\n-            matches: parent.matches.clone(),\n-            seq_depth: parent.seq_depth,\n-            match_cur: parent.match_cur,\n-            sequence: Some(MatcherPosSequence { parent, seq }),\n-            stack: smallvec![],\n+            matches: parent_mp.matches,\n+            seq_depth: parent_mp.seq_depth,\n+            match_cur: parent_mp.match_cur,\n+            kind: MatcherKind::Sequence(seq_kind),\n         };\n         // Start with an empty vec for each metavar within the sequence. Note that `mp.seq_depth`\n         // must have the parent's depth at this point for these `push_match` calls to work.\n@@ -222,16 +237,6 @@ impl<'tt> MatcherPos<'tt> {\n     }\n }\n \n-#[derive(Clone)]\n-struct MatcherPosSequence<'tt> {\n-    /// The parent matcher position. Effectively gives a linked list of matches all the way to the\n-    /// top-level matcher.\n-    parent: Box<MatcherPos<'tt>>,\n-\n-    /// The sequence itself.\n-    seq: &'tt SequenceRepetition,\n-}\n-\n enum EofMatcherPositions<'tt> {\n     None,\n     One(Box<MatcherPos<'tt>>),\n@@ -499,15 +504,17 @@ impl<'tt> TtParser<'tt> {\n                     }\n \n                     TokenTree::Delimited(_, delimited) => {\n-                        // To descend into a delimited submatcher, we push the current matcher onto\n-                        // a stack and push a new mp containing the submatcher onto `cur_mps`. When\n-                        // we reach the closing delimiter, we will pop the stack to backtrack out\n-                        // of the descent. Note that we use `all_tts` to include the open and close\n-                        // delimiter tokens.\n-                        let tts = mem::replace(&mut mp.tts, &delimited.all_tts);\n-                        let idx = mp.idx;\n-                        mp.stack.push(MatcherPosFrame { tts, idx });\n+                        // To descend into a delimited submatcher, we update `mp` appropriately,\n+                        // including enough information to re-ascend afterwards, and push it onto\n+                        // `cur_mps`. Later, when we reach the closing delimiter, we will recover\n+                        // the parent matcher position to ascend. Note that we use `all_tts` to\n+                        // include the open and close delimiter tokens.\n+                        let kind = MatcherKind::Delimited(box DelimitedSubmatcher {\n+                            parent: Parent { tts: mp.tts, idx: mp.idx, kind: mp.kind },\n+                        });\n+                        mp.tts = &delimited.all_tts;\n                         mp.idx = 0;\n+                        mp.kind = kind;\n                         self.cur_mps.push(mp);\n                     }\n \n@@ -528,9 +535,14 @@ impl<'tt> TtParser<'tt> {\n                             if let TokenKind::CloseDelim(_) = token.kind {\n                                 // Ascend out of the delimited submatcher.\n                                 debug_assert_eq!(idx, len - 1);\n-                                let frame = mp.stack.pop().unwrap();\n-                                mp.tts = frame.tts;\n-                                mp.idx = frame.idx;\n+                                match mp.kind {\n+                                    MatcherKind::Delimited(submatcher) => {\n+                                        mp.tts = submatcher.parent.tts;\n+                                        mp.idx = submatcher.parent.idx;\n+                                        mp.kind = submatcher.parent.kind;\n+                                    }\n+                                    _ => unreachable!(),\n+                                }\n                             }\n                             mp.idx += 1;\n                             self.next_mps.push(mp);\n@@ -540,45 +552,44 @@ impl<'tt> TtParser<'tt> {\n                     // These cannot appear in a matcher.\n                     TokenTree::MetaVar(..) | TokenTree::MetaVarExpr(..) => unreachable!(),\n                 }\n-            } else if let Some(sequence) = &mp.sequence {\n+            } else if let MatcherKind::Sequence(box SequenceSubmatcher { parent, seq }) = &mp.kind {\n                 // We are past the end of a sequence.\n                 // - If it has no separator, we must be only one past the end.\n                 // - If it has a separator, we may be one past the end, in which case we must\n                 //   look for a separator. Or we may be two past the end, in which case we have\n                 //   already dealt with the separator.\n-                debug_assert!(idx == len || idx == len + 1 && sequence.seq.separator.is_some());\n+                debug_assert!(idx == len || idx == len + 1 && seq.separator.is_some());\n \n                 if idx == len {\n                     // Sequence matching may have finished: move the \"dot\" past the sequence in\n                     // `parent`. This applies whether a separator is used or not. If sequence\n                     // matching hasn't finished, this `new_mp` will fail quietly when it is\n                     // processed next time around the loop.\n-                    let mut new_mp = sequence.parent.clone();\n-                    new_mp.matches = mp.matches.clone();\n-                    new_mp.match_cur = mp.match_cur;\n-                    new_mp.idx += 1;\n+                    let new_mp = box MatcherPos {\n+                        tts: parent.tts,\n+                        idx: parent.idx + 1,\n+                        matches: mp.matches.clone(), // a cheap clone\n+                        seq_depth: mp.seq_depth - 1,\n+                        match_cur: mp.match_cur,\n+                        kind: parent.kind.clone(), // an expensive clone\n+                    };\n                     self.cur_mps.push(new_mp);\n                 }\n \n-                if sequence.seq.separator.is_some() && idx == len {\n+                if seq.separator.is_some() && idx == len {\n                     // Look for the separator.\n-                    if sequence\n-                        .seq\n-                        .separator\n-                        .as_ref()\n-                        .map_or(false, |sep| token_name_eq(token, sep))\n-                    {\n+                    if seq.separator.as_ref().map_or(false, |sep| token_name_eq(token, sep)) {\n                         // The matcher has a separator, and it matches the current token. We can\n                         // advance past the separator token.\n                         mp.idx += 1;\n                         self.next_mps.push(mp);\n                     }\n-                } else if sequence.seq.kleene.op != mbe::KleeneOp::ZeroOrOne {\n+                } else if seq.kleene.op != mbe::KleeneOp::ZeroOrOne {\n                     // We don't need to look for a separator: either this sequence doesn't have\n                     // one, or it does and we've already handled it. Also, we are allowed to have\n                     // more than one repetition. Move the \"dot\" back to the beginning of the\n                     // matcher and try to match again.\n-                    mp.match_cur -= sequence.seq.num_captures;\n+                    mp.match_cur -= seq.num_captures;\n                     mp.idx = 0;\n                     self.cur_mps.push(mp);\n                 }"}]}