{"sha": "08b510c351e990d835511f45a28f2f29c12ee545", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4YjUxMGMzNTFlOTkwZDgzNTUxMWY0NWEyOGYyZjI5YzEyZWU1NDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-01T20:01:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-01T20:01:28Z"}, "message": "auto merge of #9519 : thestinger/rust/float, r=catamorphism\n\nIt is simply defined as `f64` across every platform right now.\r\n\r\nA use case hasn't been presented for a `float` type defined as the\r\nhighest precision floating point type implemented in hardware on the\r\nplatform. Performance-wise, using the smallest precision correct for the\r\nuse case greatly saves on cache space and allows for fitting more\r\nnumbers into SSE/AVX registers.\r\n\r\nIf there was a use case, this could be implemented as simply a type\r\nalias or a struct thanks to `#[cfg(...)]`.\r\n\r\nCloses #6592\r\n\r\nThe mailing list thread, for reference:\r\n\r\nhttps://mail.mozilla.org/pipermail/rust-dev/2013-July/004632.html", "tree": {"sha": "41b6f0afad8fac043f3985c2a842dfde27e2b745", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41b6f0afad8fac043f3985c2a842dfde27e2b745"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08b510c351e990d835511f45a28f2f29c12ee545", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08b510c351e990d835511f45a28f2f29c12ee545", "html_url": "https://github.com/rust-lang/rust/commit/08b510c351e990d835511f45a28f2f29c12ee545", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08b510c351e990d835511f45a28f2f29c12ee545/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8cdabc32fc7c6a5c3b01ef24340bc2f4b1ae359", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8cdabc32fc7c6a5c3b01ef24340bc2f4b1ae359", "html_url": "https://github.com/rust-lang/rust/commit/c8cdabc32fc7c6a5c3b01ef24340bc2f4b1ae359"}, {"sha": "c9d4ad07c4c166d655f11862e03c10100dcb704b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9d4ad07c4c166d655f11862e03c10100dcb704b", "html_url": "https://github.com/rust-lang/rust/commit/c9d4ad07c4c166d655f11862e03c10100dcb704b"}], "stats": {"total": 2815, "additions": 606, "deletions": 2209}, "files": [{"sha": "2a1b30bd7fa964da6abbde0e75a587c485115935", "filename": "doc/rust.md", "status": "modified", "additions": 34, "deletions": 49, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -363,19 +363,17 @@ A _floating-point literal_ has one of two forms:\n   second decimal literal.\n * A single _decimal literal_ followed by an _exponent_.\n \n-By default, a floating-point literal is of type `float`. A\n-floating-point literal may be followed (immediately, without any\n-spaces) by a _floating-point suffix_, which changes the type of the\n-literal. There are three floating-point suffixes: `f` (for the base\n-`float` type), `f32`, and `f64` (the 32-bit and 64-bit floating point\n-types).\n+By default, a floating-point literal has a generic type, but will fall back to\n+`f64`. A floating-point literal may be followed (immediately, without any\n+spaces) by a _floating-point suffix_, which changes the type of the literal.\n+There are two floating-point suffixes: `f32`, and `f64` (the 32-bit and 64-bit\n+floating point types).\n \n Examples of floating-point literals of various forms:\n \n ~~~~\n-123.0;                             // type float\n-0.1;                               // type float\n-3f;                                // type float\n+123.0;                             // type f64\n+0.1;                               // type f64\n 0.1f32;                            // type f32\n 12E+99_f64;                        // type f64\n ~~~~\n@@ -1179,8 +1177,8 @@ a = Cat;\n Enumeration constructors can have either named or unnamed fields:\n ~~~~\n enum Animal {\n-    Dog (~str, float),\n-    Cat { name: ~str, weight: float }\n+    Dog (~str, f64),\n+    Cat { name: ~str, weight: f64 }\n }\n \n let mut a: Animal = Dog(~\"Cocoa\", 37.2);\n@@ -1344,17 +1342,17 @@ For example:\n trait Num {\n     fn from_int(n: int) -> Self;\n }\n-impl Num for float {\n-    fn from_int(n: int) -> float { n as float }\n+impl Num for f64 {\n+    fn from_int(n: int) -> f64 { n as f64 }\n }\n-let x: float = Num::from_int(42);\n+let x: f64 = Num::from_int(42);\n ~~~~\n \n Traits may inherit from other traits. For example, in\n \n ~~~~\n-trait Shape { fn area() -> float; }\n-trait Circle : Shape { fn radius() -> float; }\n+trait Shape { fn area() -> f64; }\n+trait Circle : Shape { fn radius() -> f64; }\n ~~~~\n \n the syntax `Circle : Shape` means that types that implement `Circle` must also have an implementation for `Shape`.\n@@ -1367,9 +1365,9 @@ methods of the supertrait may be called on values of subtrait-bound type paramet\n Referring to the previous example of `trait Circle : Shape`:\n \n ~~~\n-# trait Shape { fn area(&self) -> float; }\n-# trait Circle : Shape { fn radius(&self) -> float; }\n-fn radius_times_area<T: Circle>(c: T) -> float {\n+# trait Shape { fn area(&self) -> f64; }\n+# trait Circle : Shape { fn radius(&self) -> f64; }\n+fn radius_times_area<T: Circle>(c: T) -> f64 {\n     // `c` is both a Circle and a Shape\n     c.radius() * c.area()\n }\n@@ -1378,10 +1376,10 @@ fn radius_times_area<T: Circle>(c: T) -> float {\n Likewise, supertrait methods may also be called on trait objects.\n \n ~~~ {.xfail-test}\n-# trait Shape { fn area(&self) -> float; }\n-# trait Circle : Shape { fn radius(&self) -> float; }\n-# impl Shape for int { fn area(&self) -> float { 0.0 } }\n-# impl Circle for int { fn radius(&self) -> float { 0.0 } }\n+# trait Shape { fn area(&self) -> f64; }\n+# trait Circle : Shape { fn radius(&self) -> f64; }\n+# impl Shape for int { fn area(&self) -> f64 { 0.0 } }\n+# impl Circle for int { fn radius(&self) -> f64 { 0.0 } }\n # let mycircle = 0;\n \n let mycircle: Circle = @mycircle as @Circle;\n@@ -1395,14 +1393,14 @@ An _implementation_ is an item that implements a [trait](#traits) for a specific\n Implementations are defined with the keyword `impl`.\n \n ~~~~\n-# struct Point {x: float, y: float};\n+# struct Point {x: f64, y: f64};\n # type Surface = int;\n-# struct BoundingBox {x: float, y: float, width: float, height: float};\n+# struct BoundingBox {x: f64, y: f64, width: f64, height: f64};\n # trait Shape { fn draw(&self, Surface); fn bounding_box(&self) -> BoundingBox; }\n # fn do_draw_circle(s: Surface, c: Circle) { }\n \n struct Circle {\n-    radius: float,\n+    radius: f64,\n     center: Point,\n }\n \n@@ -1970,7 +1968,7 @@ values.\n \n ~~~~~~~~ {.tuple}\n (0,);\n-(0f, 4.5f);\n+(0.0, 4.5);\n (\"a\", 4u, true);\n ~~~~~~~~\n \n@@ -2002,12 +2000,12 @@ A _unit-like structure expression_ consists only of the [path](#paths) of a [str\n The following are examples of structure expressions:\n \n ~~~~\n-# struct Point { x: float, y: float }\n-# struct TuplePoint(float, float);\n+# struct Point { x: f64, y: f64 }\n+# struct TuplePoint(f64, f64);\n # mod game { pub struct User<'self> { name: &'self str, age: uint, score: uint } }\n # struct Cookie; fn some_fn<T>(t: T) {}\n-Point {x: 10f, y: 20f};\n-TuplePoint(10f, 20f);\n+Point {x: 10.0, y: 20.0};\n+TuplePoint(10.0, 20.0);\n let u = game::User {name: \"Joe\", age: 35, score: 100_000};\n some_fn::<Cookie>(Cookie);\n ~~~~\n@@ -2248,12 +2246,12 @@ Any other cast is unsupported and will fail to compile.\n An example of an `as` expression:\n \n ~~~~\n-# fn sum(v: &[float]) -> float { 0.0 }\n-# fn len(v: &[float]) -> int { 0 }\n+# fn sum(v: &[f64]) -> f64 { 0.0 }\n+# fn len(v: &[f64]) -> int { 0 }\n \n-fn avg(v: &[float]) -> float {\n-  let sum: float = sum(v);\n-  let sz: float = len(v) as float;\n+fn avg(v: &[f64]) -> f64 {\n+  let sum: f64 = sum(v);\n+  let sz: f64 = len(v) as f64;\n   return sum / sz;\n }\n ~~~~\n@@ -2767,19 +2765,6 @@ size, in bits, is equal to the size of the rust type `uint` on the same target\n machine.\n \n \n-#### Machine-dependent floating point type\n-\n-The Rust type `float` is a machine-specific type equal to one of the supported\n-Rust floating-point machine types (`f32` or `f64`). It is the largest\n-floating-point type that is directly supported by hardware on the target\n-machine, or if the target machine has no floating-point hardware support, the\n-largest floating-point type supported by the software floating-point library\n-used to support the other floating-point machine types.\n-\n-Note that due to the preference for hardware-supported floating-point, the\n-type `float` may not be equal to the largest *supported* floating-point type.\n-\n-\n ### Textual types\n \n The types `char` and `str` hold textual data."}, {"sha": "c5933eb40f7647e80a689eeee5a84183acde472e", "filename": "doc/tutorial-borrowed-ptr.md", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/doc%2Ftutorial-borrowed-ptr.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/doc%2Ftutorial-borrowed-ptr.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-borrowed-ptr.md?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -32,15 +32,15 @@ where you would like to use data for a short time.\n As an example, consider a simple struct type `Point`:\n \n ~~~\n-struct Point {x: float, y: float}\n+struct Point {x: f64, y: f64}\n ~~~\n \n We can use this simple definition to allocate points in many different ways. For\n example, in this code, each of these three local variables contains a\n point, but allocated in a different place:\n \n ~~~\n-# struct Point {x: float, y: float}\n+# struct Point {x: f64, y: f64}\n let on_the_stack :  Point =  Point {x: 3.0, y: 4.0};\n let managed_box  : @Point = @Point {x: 5.0, y: 1.0};\n let owned_box    : ~Point = ~Point {x: 7.0, y: 9.0};\n@@ -59,9 +59,9 @@ function that takes the points by pointer. We can use borrowed pointers to do\n this:\n \n ~~~\n-# struct Point {x: float, y: float}\n-# fn sqrt(f: float) -> float { 0f }\n-fn compute_distance(p1: &Point, p2: &Point) -> float {\n+# struct Point {x: f64, y: f64}\n+# fn sqrt(f: f64) -> f64 { 0.0 }\n+fn compute_distance(p1: &Point, p2: &Point) -> f64 {\n     let x_d = p1.x - p2.x;\n     let y_d = p1.y - p2.y;\n     sqrt(x_d * x_d + y_d * y_d)\n@@ -71,11 +71,11 @@ fn compute_distance(p1: &Point, p2: &Point) -> float {\n Now we can call `compute_distance()` in various ways:\n \n ~~~\n-# struct Point {x: float, y: float}\n+# struct Point {x: f64, y: f64}\n # let on_the_stack :  Point =  Point{x: 3.0, y: 4.0};\n # let managed_box  : @Point = @Point{x: 5.0, y: 1.0};\n # let owned_box    : ~Point = ~Point{x: 7.0, y: 9.0};\n-# fn compute_distance(p1: &Point, p2: &Point) -> float { 0f }\n+# fn compute_distance(p1: &Point, p2: &Point) -> f64 { 0.0 }\n compute_distance(&on_the_stack, managed_box);\n compute_distance(managed_box, owned_box);\n ~~~\n@@ -108,7 +108,7 @@ before you can make full use of it again.\n In the previous example, the value `on_the_stack` was defined like so:\n \n ~~~\n-# struct Point {x: float, y: float}\n+# struct Point {x: f64, y: f64}\n let on_the_stack: Point = Point {x: 3.0, y: 4.0};\n ~~~\n \n@@ -118,7 +118,7 @@ functions. As a consequence, we had to explicitly take the address of\n convenient to move the & operator into the definition of `on_the_stack`:\n \n ~~~\n-# struct Point {x: float, y: float}\n+# struct Point {x: f64, y: f64}\n let on_the_stack2: &Point = &Point {x: 3.0, y: 4.0};\n ~~~\n \n@@ -127,7 +127,7 @@ shorthand for creating a temporary and taking its address. A more verbose\n way to write the same code is:\n \n ~~~\n-# struct Point {x: float, y: float}\n+# struct Point {x: f64, y: f64}\n let tmp = Point {x: 3.0, y: 4.0};\n let on_the_stack2 : &Point = &tmp;\n ~~~\n@@ -140,36 +140,36 @@ individual array elements. For example, consider this type definition\n for `rectangle`:\n \n ~~~\n-struct Point {x: float, y: float} // as before\n-struct Size {w: float, h: float} // as before\n+struct Point {x: f64, y: f64} // as before\n+struct Size {w: f64, h: f64} // as before\n struct Rectangle {origin: Point, size: Size}\n ~~~\n \n Now, as before, we can define rectangles in a few different ways:\n \n ~~~\n-# struct Point {x: float, y: float}\n-# struct Size {w: float, h: float} // as before\n+# struct Point {x: f64, y: f64}\n+# struct Size {w: f64, h: f64} // as before\n # struct Rectangle {origin: Point, size: Size}\n-let rect_stack   = &Rectangle {origin: Point {x: 1f, y: 2f},\n-                               size: Size {w: 3f, h: 4f}};\n-let rect_managed = @Rectangle {origin: Point {x: 3f, y: 4f},\n-                               size: Size {w: 3f, h: 4f}};\n-let rect_owned   = ~Rectangle {origin: Point {x: 5f, y: 6f},\n-                               size: Size {w: 3f, h: 4f}};\n+let rect_stack   = &Rectangle {origin: Point {x: 1.0, y: 2.0},\n+                               size: Size {w: 3.0, h: 4.0}};\n+let rect_managed = @Rectangle {origin: Point {x: 3.0, y: 4.0},\n+                               size: Size {w: 3.0, h: 4.0}};\n+let rect_owned   = ~Rectangle {origin: Point {x: 5.0, y: 6.0},\n+                               size: Size {w: 3.0, h: 4.0}};\n ~~~\n \n In each case, we can extract out individual subcomponents with the `&`\n operator. For example, I could write:\n \n ~~~\n-# struct Point {x: float, y: float} // as before\n-# struct Size {w: float, h: float} // as before\n+# struct Point {x: f64, y: f64} // as before\n+# struct Size {w: f64, h: f64} // as before\n # struct Rectangle {origin: Point, size: Size}\n-# let rect_stack  = &Rectangle {origin: Point {x: 1f, y: 2f}, size: Size {w: 3f, h: 4f}};\n-# let rect_managed = @Rectangle {origin: Point {x: 3f, y: 4f}, size: Size {w: 3f, h: 4f}};\n-# let rect_owned = ~Rectangle {origin: Point {x: 5f, y: 6f}, size: Size {w: 3f, h: 4f}};\n-# fn compute_distance(p1: &Point, p2: &Point) -> float { 0f }\n+# let rect_stack  = &Rectangle {origin: Point {x: 1.0, y: 2.0}, size: Size {w: 3.0, h: 4.0}};\n+# let rect_managed = @Rectangle {origin: Point {x: 3.0, y: 4.0}, size: Size {w: 3.0, h: 4.0}};\n+# let rect_owned = ~Rectangle {origin: Point {x: 5.0, y: 6.0}, size: Size {w: 3.0, h: 4.0}};\n+# fn compute_distance(p1: &Point, p2: &Point) -> f64 { 0.0 }\n compute_distance(&rect_stack.origin, &rect_managed.origin);\n ~~~\n \n@@ -375,10 +375,10 @@ As an example, let\u2019s look at the following `shape` type that can\n represent both rectangles and circles:\n \n ~~~\n-struct Point {x: float, y: float}; // as before\n-struct Size {w: float, h: float}; // as before\n+struct Point {x: f64, y: f64}; // as before\n+struct Size {w: f64, h: f64}; // as before\n enum Shape {\n-    Circle(Point, float),   // origin, radius\n+    Circle(Point, f64),   // origin, radius\n     Rectangle(Point, Size)  // upper-left, dimensions\n }\n ~~~\n@@ -388,14 +388,14 @@ function takes a borrowed pointer to a shape, to avoid the need for\n copying.\n \n ~~~\n-# struct Point {x: float, y: float}; // as before\n-# struct Size {w: float, h: float}; // as before\n+# struct Point {x: f64, y: f64}; // as before\n+# struct Size {w: f64, h: f64}; // as before\n # enum Shape {\n-#     Circle(Point, float),   // origin, radius\n+#     Circle(Point, f64),   // origin, radius\n #     Rectangle(Point, Size)  // upper-left, dimensions\n # }\n-# static tau: float = 6.28f;\n-fn compute_area(shape: &Shape) -> float {\n+# static tau: f64 = 6.28;\n+fn compute_area(shape: &Shape) -> f64 {\n     match *shape {\n         Circle(_, radius) => 0.5 * tau * radius * radius,\n         Rectangle(_, ref size) => size.w * size.h\n@@ -424,10 +424,10 @@ Stack             Memory\n \n +-------+         +---------------+\n | shape | ------> | rectangle(    |\n-+-------+         |   {x: float,  |\n-| size  | -+      |    y: float}, |\n-+-------+  +----> |   {w: float,  |\n-                  |    h: float}) |\n++-------+         |   {x: f64,    |\n+| size  | -+      |    y: f64},   |\n++-------+  +----> |   {w: f64,    |\n+                  |    h: f64})   |\n                   +---------------+\n ~~~\n \n@@ -449,16 +449,16 @@ Stack             Memory\n \n +-------+         +---------------+\n | shape | ------> | circle(       |\n-+-------+         |   {x: float,  |\n-| size  | -+      |    y: float}, |\n-+-------+  +----> |   float)      |\n++-------+         |   {x: f64,    |\n+| size  | -+      |    y: f64},   |\n++-------+  +----> |   f64)        |\n                   |               |\n                   +---------------+\n ~~~\n \n-As you can see, the `size` pointer would be pointing at a `float`\n+As you can see, the `size` pointer would be pointing at a `f64`\n instead of a struct. This is not good: dereferencing the second field\n-of a `float` as if it were a struct with two fields would be a memory\n+of a `f64` as if it were a struct with two fields would be a memory\n safety violation.\n \n So, in fact, for every `ref` binding, the compiler will impose the\n@@ -484,13 +484,13 @@ as we'll see, doing so requires some explicit annotation.\n For example, we could write a subroutine like this:\n \n ~~~\n-struct Point {x: float, y: float}\n-fn get_x<'r>(p: &'r Point) -> &'r float { &p.x }\n+struct Point {x: f64, y: f64}\n+fn get_x<'r>(p: &'r Point) -> &'r f64 { &p.x }\n ~~~\n \n Here, the function `get_x()` returns a pointer into the structure it\n was given. The type of the parameter (`&'r Point`) and return type\n-(`&'r float`) both use a new syntactic form that we have not seen so\n+(`&'r f64`) both use a new syntactic form that we have not seen so\n far.  Here the identifier `r` names the lifetime of the pointer\n explicitly. So in effect, this function declares that it takes a\n pointer with lifetime `r` and returns a pointer with that same\n@@ -525,8 +525,8 @@ To emphasize this point, let\u2019s look at a variation on the example, this\n time one that does not compile:\n \n ~~~ {.xfail-test}\n-struct Point {x: float, y: float}\n-fn get_x_sh(p: @Point) -> &float {\n+struct Point {x: f64, y: f64}\n+fn get_x_sh(p: @Point) -> &f64 {\n     &p.x // Error reported here\n }\n ~~~\n@@ -564,14 +564,14 @@ for grouping of parameters by lifetime. For example, consider this\n function:\n \n ~~~\n-# struct Point {x: float, y: float}; // as before\n-# struct Size {w: float, h: float}; // as before\n+# struct Point {x: f64, y: f64}; // as before\n+# struct Size {w: f64, h: f64}; // as before\n # enum Shape {\n-#     Circle(Point, float),   // origin, radius\n+#     Circle(Point, f64),   // origin, radius\n #     Rectangle(Point, Size)  // upper-left, dimensions\n # }\n-# fn compute_area(shape: &Shape) -> float { 0f }\n-fn select<'r, T>(shape: &'r Shape, threshold: float,\n+# fn compute_area(shape: &Shape) -> f64 { 0.0 }\n+fn select<'r, T>(shape: &'r Shape, threshold: f64,\n                  a: &'r T, b: &'r T) -> &'r T {\n     if compute_area(shape) > threshold {a} else {b}\n }\n@@ -584,20 +584,20 @@ region parameters*. This may be overly conservative, as in this\n example:\n \n ~~~\n-# struct Point {x: float, y: float}; // as before\n-# struct Size {w: float, h: float}; // as before\n+# struct Point {x: f64, y: f64}; // as before\n+# struct Size {w: f64, h: f64}; // as before\n # enum Shape {\n-#     Circle(Point, float),   // origin, radius\n+#     Circle(Point, f64),   // origin, radius\n #     Rectangle(Point, Size)  // upper-left, dimensions\n # }\n-# fn compute_area(shape: &Shape) -> float { 0f }\n-# fn select<'r, T>(shape: &Shape, threshold: float,\n+# fn compute_area(shape: &Shape) -> f64 { 0.0 }\n+# fn select<'r, T>(shape: &Shape, threshold: f64,\n #                  a: &'r T, b: &'r T) -> &'r T {\n #     if compute_area(shape) > threshold {a} else {b}\n # }\n                                                      // -+ r\n fn select_based_on_unit_circle<'r, T>(               //  |-+ B\n-    threshold: float, a: &'r T, b: &'r T) -> &'r T { //  | |\n+    threshold: f64, a: &'r T, b: &'r T) -> &'r T { //  | |\n                                                      //  | |\n     let shape = Circle(Point {x: 0., y: 0.}, 1.);    //  | |\n     select(&shape, threshold, a, b)                  //  | |\n@@ -621,14 +621,14 @@ the latter two. After all, the first parameter is not being\n returned. Here is how the new `select()` might look:\n \n ~~~\n-# struct Point {x: float, y: float}; // as before\n-# struct Size {w: float, h: float}; // as before\n+# struct Point {x: f64, y: f64}; // as before\n+# struct Size {w: f64, h: f64}; // as before\n # enum Shape {\n-#     Circle(Point, float),   // origin, radius\n+#     Circle(Point, f64),   // origin, radius\n #     Rectangle(Point, Size)  // upper-left, dimensions\n # }\n-# fn compute_area(shape: &Shape) -> float { 0f }\n-fn select<'r, 'tmp, T>(shape: &'tmp Shape, threshold: float,\n+# fn compute_area(shape: &Shape) -> f64 { 0.0 }\n+fn select<'r, 'tmp, T>(shape: &'tmp Shape, threshold: f64,\n                        a: &'r T, b: &'r T) -> &'r T {\n     if compute_area(shape) > threshold {a} else {b}\n }\n@@ -640,14 +640,14 @@ However, since the lifetime `tmp` is not returned, it would be more\n concise to just omit the named lifetime for `shape` altogether:\n \n ~~~\n-# struct Point {x: float, y: float}; // as before\n-# struct Size {w: float, h: float}; // as before\n+# struct Point {x: f64, y: f64}; // as before\n+# struct Size {w: f64, h: f64}; // as before\n # enum Shape {\n-#     Circle(Point, float),   // origin, radius\n+#     Circle(Point, f64),   // origin, radius\n #     Rectangle(Point, Size)  // upper-left, dimensions\n # }\n-# fn compute_area(shape: &Shape) -> float { 0f }\n-fn select<'r, T>(shape: &Shape, threshold: float,\n+# fn compute_area(shape: &Shape) -> f64 { 0.0 }\n+fn select<'r, T>(shape: &Shape, threshold: f64,\n                  a: &'r T, b: &'r T) -> &'r T {\n     if compute_area(shape) > threshold {a} else {b}\n }"}, {"sha": "dedbc8ae5931cc456ad563145a66b7411221cd9b", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -331,12 +331,12 @@ a single large vector of floats. Each task needs the full vector to perform its\n # use std::rand;\n use extra::arc::Arc;\n \n-fn pnorm(nums: &~[float], p: uint) -> float {\n-    nums.iter().fold(0.0, |a,b| a+(*b).pow(&(p as float)) ).pow(&(1f / (p as float)))\n+fn pnorm(nums: &~[f64], p: uint) -> f64 {\n+    nums.iter().fold(0.0, |a,b| a+(*b).pow(&(p as f64)) ).pow(&(1.0 / (p as f64)))\n }\n \n fn main() {\n-    let numbers = vec::from_fn(1000000, |_| rand::random::<float>());\n+    let numbers = vec::from_fn(1000000, |_| rand::random::<f64>());\n     println!(\"Inf-norm = {}\",  *numbers.iter().max().unwrap());\n \n     let numbers_arc = Arc::new(numbers);\n@@ -346,7 +346,7 @@ fn main() {\n         chan.send(numbers_arc.clone());\n \n         do spawn {\n-            let local_arc : Arc<~[float]> = port.recv();\n+            let local_arc : Arc<~[f64]> = port.recv();\n             let task_numbers = local_arc.get();\n             println!(\"{}-norm = {}\", num, pnorm(task_numbers, num));\n         }\n@@ -361,15 +361,15 @@ created by the line\n # use extra::arc::Arc;\n # use std::vec;\n # use std::rand;\n-# let numbers = vec::from_fn(1000000, |_| rand::random::<float>());\n+# let numbers = vec::from_fn(1000000, |_| rand::random::<f64>());\n let numbers_arc=Arc::new(numbers);\n ~~~\n and a clone of it is sent to each task\n ~~~\n # use extra::arc::Arc;\n # use std::vec;\n # use std::rand;\n-# let numbers=vec::from_fn(1000000, |_| rand::random::<float>());\n+# let numbers=vec::from_fn(1000000, |_| rand::random::<f64>());\n # let numbers_arc = Arc::new(numbers);\n # let (port, chan)  = stream();\n chan.send(numbers_arc.clone());\n@@ -381,11 +381,11 @@ Each task recovers the underlying data by\n # use extra::arc::Arc;\n # use std::vec;\n # use std::rand;\n-# let numbers=vec::from_fn(1000000, |_| rand::random::<float>());\n+# let numbers=vec::from_fn(1000000, |_| rand::random::<f64>());\n # let numbers_arc=Arc::new(numbers);\n # let (port, chan)  = stream();\n # chan.send(numbers_arc.clone());\n-# let local_arc : Arc<~[float]> = port.recv();\n+# let local_arc : Arc<~[f64]> = port.recv();\n let task_numbers = local_arc.get();\n ~~~\n and can use it as if it were local."}, {"sha": "64230a27637ec78b52200473619823d39da051db", "filename": "doc/tutorial.md", "status": "modified", "additions": 104, "deletions": 104, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -235,13 +235,13 @@ can specify a variable's type by following it with a colon, then the type\n name. Static items, on the other hand, always require a type annotation.\n \n ~~~~\n-static MONSTER_FACTOR: float = 57.8;\n+static MONSTER_FACTOR: f64 = 57.8;\n let monster_size = MONSTER_FACTOR * 10.0;\n let monster_size: int = 50;\n ~~~~\n \n Local variables may shadow earlier declarations, as in the previous example:\n-`monster_size` was first declared as a `float`, and then a second\n+`monster_size` was first declared as a `f64`, and then a second\n `monster_size` was declared as an `int`. If you were to actually compile this\n example, though, the compiler would determine that the first `monster_size` is\n unused and issue a warning (because this situation is likely to indicate a\n@@ -341,10 +341,10 @@ let c = 100u;    // c is a uint\n let d = 1000i32; // d is an i32\n ~~~~\n \n-There are three floating-point types: `float`, `f32`, and `f64`.\n+There are two floating-point types: `f32`, and `f64`.\n Floating-point numbers are written `0.0`, `1e6`, or `2.1e-4`.\n Like integers, floating-point literals are inferred to the correct type.\n-Suffixes `f`, `f32`, and `f64` can be used to create literals of a specific type.\n+Suffixes ``f32`, and `f64` can be used to create literals of a specific type.\n \n The keywords `true` and `false` produce literals of type `bool`.\n \n@@ -377,7 +377,7 @@ if a meaningful conversion exists, convert the result of the\n expression to the given type.\n \n ~~~~\n-let x: float = 4.0;\n+let x: f64 = 4.0;\n let y: uint = x as uint;\n assert!(y == 4u);\n ~~~~\n@@ -496,25 +496,25 @@ A powerful application of pattern matching is *destructuring*:\n matching in order to bind names to the contents of data\n types.\n \n-> ***Note:*** The following code makes use of tuples (`(float, float)`) which\n+> ***Note:*** The following code makes use of tuples (`(f64, f64)`) which\n > are explained in section 5.3. For now you can think of tuples as a list of\n > items.\n \n ~~~~\n-use std::float;\n+use std::f64;\n use std::num::atan;\n-fn angle(vector: (float, float)) -> float {\n-    let pi = float::consts::pi;\n+fn angle(vector: (f64, f64)) -> f64 {\n+    let pi = f64::consts::pi;\n     match vector {\n-      (0f, y) if y < 0f => 1.5 * pi,\n-      (0f, y) => 0.5 * pi,\n+      (0.0, y) if y < 0.0 => 1.5 * pi,\n+      (0.0, y) => 0.5 * pi,\n       (x, y) => atan(y / x)\n     }\n }\n ~~~~\n \n A variable name in a pattern matches any value, *and* binds that name\n-to the value of the matched value inside of the arm's action. Thus, `(0f,\n+to the value of the matched value inside of the arm's action. Thus, `(0.0,\n y)` matches any tuple whose first element is zero, and binds `y` to\n the second element. `(x, y)` matches any two-element tuple, and binds both\n elements to variables.\n@@ -583,8 +583,8 @@ operator to access struct fields, as in `mypoint.x`.\n \n ~~~~\n struct Point {\n-    x: float,\n-    y: float\n+    x: f64,\n+    y: f64\n }\n ~~~~\n \n@@ -597,7 +597,7 @@ With a value (say, `mypoint`) of such a type in a mutable location, you can do\n struct without inherited mutability would result in a type error.\n \n ~~~~ {.xfail-test}\n-# struct Point { x: float, y: float }\n+# struct Point { x: f64, y: f64 }\n let mut mypoint = Point { x: 1.0, y: 1.0 };\n let origin = Point { x: 0.0, y: 0.0 };\n \n@@ -609,7 +609,7 @@ origin.y += 1.0; // ERROR: assigning to immutable field\n `Name { fieldname: pattern, ... }`:\n \n ~~~~\n-# struct Point { x: float, y: float }\n+# struct Point { x: f64, y: f64 }\n # let mypoint = Point { x: 0.0, y: 0.0 };\n match mypoint {\n     Point { x: 0.0, y: yy } => { println(yy.to_str());                     }\n@@ -625,7 +625,7 @@ Additionally, struct fields have a shorthand matching form that simply\n reuses the field name as the binding name.\n \n ~~~\n-# struct Point { x: float, y: float }\n+# struct Point { x: f64, y: f64 }\n # let mypoint = Point { x: 0.0, y: 0.0 };\n match mypoint {\n     Point { x, _ } => { println(x.to_str()) }\n@@ -638,23 +638,23 @@ Enums are datatypes that have several alternate representations. For\n example, consider the type shown earlier:\n \n ~~~~\n-# struct Point { x: float, y: float }\n+# struct Point { x: f64, y: f64 }\n enum Shape {\n-    Circle(Point, float),\n+    Circle(Point, f64),\n     Rectangle(Point, Point)\n }\n ~~~~\n \n A value of this type is either a `Circle`, in which case it contains a\n-`Point` struct and a float, or a `Rectangle`, in which case it contains\n+`Point` struct and a f64, or a `Rectangle`, in which case it contains\n two `Point` structs. The run-time representation of such a value\n includes an identifier of the actual form that it holds, much like the\n \"tagged union\" pattern in C, but with better static guarantees.\n \n The above declaration will define a type `Shape` that can refer to\n such shapes, and two functions, `Circle` and `Rectangle`, which can be\n used to construct values of the type (taking arguments of the\n-specified types). So `Circle(Point { x: 0f, y: 0f }, 10f)` is the way to\n+specified types). So `Circle(Point { x: 0.0, y: 0.0 }, 10.0)` is the way to\n create a new circle.\n \n Enum variants need not have parameters. This `enum` declaration,\n@@ -697,12 +697,12 @@ get at their contents. All variant constructors can be used as\n patterns, as in this definition of `area`:\n \n ~~~~\n-use std::float;\n-# struct Point {x: float, y: float}\n-# enum Shape { Circle(Point, float), Rectangle(Point, Point) }\n-fn area(sh: Shape) -> float {\n+use std::f64;\n+# struct Point {x: f64, y: f64}\n+# enum Shape { Circle(Point, f64), Rectangle(Point, Point) }\n+fn area(sh: Shape) -> f64 {\n     match sh {\n-        Circle(_, size) => float::consts::pi * size * size,\n+        Circle(_, size) => f64::consts::pi * size * size,\n         Rectangle(Point { x, y }, Point { x: x2, y: y2 }) => (x2 - x) * (y2 - y)\n     }\n }\n@@ -714,31 +714,31 @@ introduction form, nullary enum patterns are written without\n parentheses.\n \n ~~~~\n-# struct Point { x: float, y: float }\n+# struct Point { x: f64, y: f64 }\n # enum Direction { North, East, South, West }\n fn point_from_direction(dir: Direction) -> Point {\n     match dir {\n-        North => Point { x:  0f, y:  1f },\n-        East  => Point { x:  1f, y:  0f },\n-        South => Point { x:  0f, y: -1f },\n-        West  => Point { x: -1f, y:  0f }\n+        North => Point { x:  0.0, y:  1.0 },\n+        East  => Point { x:  1.0, y:  0.0 },\n+        South => Point { x:  0.0, y: -1.0 },\n+        West  => Point { x: -1.0, y:  0.0 }\n     }\n }\n ~~~~\n \n Enum variants may also be structs. For example:\n \n ~~~~\n-use std::float;\n-# struct Point { x: float, y: float }\n-# fn square(x: float) -> float { x * x }\n+use std::f64;\n+# struct Point { x: f64, y: f64 }\n+# fn square(x: f64) -> f64 { x * x }\n enum Shape {\n-    Circle { center: Point, radius: float },\n+    Circle { center: Point, radius: f64 },\n     Rectangle { top_left: Point, bottom_right: Point }\n }\n-fn area(sh: Shape) -> float {\n+fn area(sh: Shape) -> f64 {\n     match sh {\n-        Circle { radius: radius, _ } => float::consts::pi * square(radius),\n+        Circle { radius: radius, _ } => f64::consts::pi * square(radius),\n         Rectangle { top_left: top_left, bottom_right: bottom_right } => {\n             (bottom_right.x - top_left.x) * (top_left.y - bottom_right.y)\n         }\n@@ -754,7 +754,7 @@ Tuples can have any arity except for 0 (though you may consider\n unit, `()`, as the empty tuple if you like).\n \n ~~~~\n-let mytup: (int, int, float) = (10, 20, 30.0);\n+let mytup: (int, int, f64) = (10, 20, 30.0);\n match mytup {\n   (a, b, c) => info2!(\"{}\", a + b + (c as int))\n }\n@@ -769,7 +769,7 @@ names.\n \n For example:\n ~~~~\n-struct MyTup(int, int, float);\n+struct MyTup(int, int, f64);\n let mytup: MyTup = MyTup(10, 20, 30.0);\n match mytup {\n   MyTup(a, b, c) => info2!(\"{}\", a + b + (c as int))\n@@ -862,7 +862,7 @@ pattern destructuring. Like `let`, argument patterns must be irrefutable,\n as in this example that unpacks the first value from a tuple and returns it.\n \n ~~~\n-fn first((value, _): (int, float)) -> int { value }\n+fn first((value, _): (int, f64)) -> int { value }\n ~~~\n \n # Destructors\n@@ -1074,8 +1074,8 @@ As an example, consider a simple struct type, `Point`:\n \n ~~~\n struct Point {\n-    x: float,\n-    y: float\n+    x: f64,\n+    y: f64\n }\n ~~~~\n \n@@ -1084,7 +1084,7 @@ ways. For example, in this code, each of these three local variables\n contains a point, but allocated in a different location:\n \n ~~~\n-# struct Point { x: float, y: float }\n+# struct Point { x: f64, y: f64 }\n let on_the_stack : Point  =  Point { x: 3.0, y: 4.0 };\n let managed_box  : @Point = @Point { x: 5.0, y: 1.0 };\n let owned_box    : ~Point = ~Point { x: 7.0, y: 9.0 };\n@@ -1101,9 +1101,9 @@ bad, but often copies are expensive. So we\u2019d like to define a function\n that takes the points by pointer. We can use borrowed pointers to do this:\n \n ~~~\n-# struct Point { x: float, y: float }\n-# fn sqrt(f: float) -> float { 0f }\n-fn compute_distance(p1: &Point, p2: &Point) -> float {\n+# struct Point { x: f64, y: f64 }\n+# fn sqrt(f: f64) -> f64 { 0.0 }\n+fn compute_distance(p1: &Point, p2: &Point) -> f64 {\n     let x_d = p1.x - p2.x;\n     let y_d = p1.y - p2.y;\n     sqrt(x_d * x_d + y_d * y_d)\n@@ -1113,11 +1113,11 @@ fn compute_distance(p1: &Point, p2: &Point) -> float {\n Now we can call `compute_distance()` in various ways:\n \n ~~~\n-# struct Point{ x: float, y: float };\n+# struct Point{ x: f64, y: f64 };\n # let on_the_stack : Point  =  Point { x: 3.0, y: 4.0 };\n # let managed_box  : @Point = @Point { x: 5.0, y: 1.0 };\n # let owned_box    : ~Point = ~Point { x: 7.0, y: 9.0 };\n-# fn compute_distance(p1: &Point, p2: &Point) -> float { 0f }\n+# fn compute_distance(p1: &Point, p2: &Point) -> f64 { 0.0 }\n compute_distance(&on_the_stack, managed_box);\n compute_distance(managed_box, owned_box);\n ~~~\n@@ -1211,11 +1211,11 @@ dot operator used for field and method access. This precedence order\n can sometimes make code awkward and parenthesis-filled.\n \n ~~~\n-# struct Point { x: float, y: float }\n+# struct Point { x: f64, y: f64 }\n # enum Shape { Rectangle(Point, Point) }\n # impl Shape { fn area(&self) -> int { 0 } }\n-let start = @Point { x: 10f, y: 20f };\n-let end = ~Point { x: (*start).x + 100f, y: (*start).y + 100f };\n+let start = @Point { x: 10.0, y: 20.0 };\n+let end = ~Point { x: (*start).x + 100.0, y: (*start).y + 100.0 };\n let rect = &Rectangle(*start, *end);\n let area = (*rect).area();\n ~~~\n@@ -1225,11 +1225,11 @@ dereferencing_ to the receiver (the value on the left-hand side of the\n dot), so in most cases, explicitly dereferencing the receiver is not necessary.\n \n ~~~\n-# struct Point { x: float, y: float }\n+# struct Point { x: f64, y: f64 }\n # enum Shape { Rectangle(Point, Point) }\n # impl Shape { fn area(&self) -> int { 0 } }\n-let start = @Point { x: 10f, y: 20f };\n-let end = ~Point { x: start.x + 100f, y: start.y + 100f };\n+let start = @Point { x: 10.0, y: 20.0 };\n+let end = ~Point { x: start.x + 100.0, y: start.y + 100.0 };\n let rect = &Rectangle(*start, *end);\n let area = rect.area();\n ~~~\n@@ -1239,8 +1239,8 @@ automatically. For example, if you feel inclined, you could write\n something silly like\n \n ~~~\n-# struct Point { x: float, y: float }\n-let point = &@~Point { x: 10f, y: 20f };\n+# struct Point { x: f64, y: f64 }\n+let point = &@~Point { x: 10.0, y: 20.0 };\n println!(\"{:f}\", point.x);\n ~~~\n \n@@ -1601,15 +1601,15 @@ methods on most Rust types, including structs and enums.\n As an example, let's define a `draw` method on our `Shape` enum.\n \n ~~~\n-# fn draw_circle(p: Point, f: float) { }\n+# fn draw_circle(p: Point, f: f64) { }\n # fn draw_rectangle(p: Point, p: Point) { }\n struct Point {\n-    x: float,\n-    y: float\n+    x: f64,\n+    y: f64\n }\n \n enum Shape {\n-    Circle(Point, float),\n+    Circle(Point, f64),\n     Rectangle(Point, Point)\n }\n \n@@ -1622,7 +1622,7 @@ impl Shape {\n     }\n }\n \n-let s = Circle(Point { x: 1f, y: 2f }, 3f);\n+let s = Circle(Point { x: 1.0, y: 2.0 }, 3.0);\n s.draw();\n ~~~\n \n@@ -1636,11 +1636,11 @@ or a pointer thereof. As an argument it is written either `self`,\n A caller must in turn have a compatible pointer type to call the method.\n \n ~~~\n-# fn draw_circle(p: Point, f: float) { }\n+# fn draw_circle(p: Point, f: f64) { }\n # fn draw_rectangle(p: Point, p: Point) { }\n-# struct Point { x: float, y: float }\n+# struct Point { x: f64, y: f64 }\n # enum Shape {\n-#     Circle(Point, float),\n+#     Circle(Point, f64),\n #     Rectangle(Point, Point)\n # }\n impl Shape {\n@@ -1650,7 +1650,7 @@ impl Shape {\n     fn draw_value(self) { ... }\n }\n \n-let s = Circle(Point { x: 1f, y: 2f }, 3f);\n+let s = Circle(Point { x: 1.0, y: 2.0 }, 3.0);\n \n (@s).draw_managed();\n (~s).draw_owned();\n@@ -1663,11 +1663,11 @@ so the compiler will go to great lengths to convert a callee\n to a borrowed pointer.\n \n ~~~\n-# fn draw_circle(p: Point, f: float) { }\n+# fn draw_circle(p: Point, f: f64) { }\n # fn draw_rectangle(p: Point, p: Point) { }\n-# struct Point { x: float, y: float }\n+# struct Point { x: f64, y: f64 }\n # enum Shape {\n-#     Circle(Point, float),\n+#     Circle(Point, f64),\n #     Rectangle(Point, Point)\n # }\n # impl Shape {\n@@ -1676,7 +1676,7 @@ to a borrowed pointer.\n #    fn draw_owned(~self) { ... }\n #    fn draw_value(self) { ... }\n # }\n-# let s = Circle(Point { x: 1f, y: 2f }, 3f);\n+# let s = Circle(Point { x: 1.0, y: 2.0 }, 3.0);\n // As with typical function arguments, managed and owned pointers\n // are automatically converted to borrowed pointers\n \n@@ -1700,18 +1700,18 @@ These methods are the preferred way to define constructor functions.\n \n ~~~~ {.xfail-test}\n impl Circle {\n-    fn area(&self) -> float { ... }\n-    fn new(area: float) -> Circle { ... }\n+    fn area(&self) -> f64 { ... }\n+    fn new(area: f64) -> Circle { ... }\n }\n ~~~~\n \n To call such a method, just prefix it with the type name and a double colon:\n \n ~~~~\n-use std::float::consts::pi;\n-struct Circle { radius: float }\n+use std::f64::consts::pi;\n+struct Circle { radius: f64 }\n impl Circle {\n-    fn new(area: float) -> Circle { Circle { radius: (area / pi).sqrt() } }\n+    fn new(area: f64) -> Circle { Circle { radius: (area / pi).sqrt() } }\n }\n let c = Circle::new(42.5);\n ~~~~\n@@ -1777,9 +1777,9 @@ combination of arguments of the appropriate types. The usual way is to write\n a function that returns `Option<T>` instead of `T`.\n \n ~~~~\n-# struct Point { x: float, y: float }\n-# enum Shape { Circle(Point, float), Rectangle(Point, Point) }\n-fn radius(shape: Shape) -> Option<float> {\n+# struct Point { x: f64, y: f64 }\n+# enum Shape { Circle(Point, f64), Rectangle(Point, Point) }\n+fn radius(shape: Shape) -> Option<f64> {\n     match shape {\n         Circle(_, radius) => Some(radius),\n         Rectangle(*)      => None\n@@ -1986,16 +1986,16 @@ name and a double colon.  The compiler uses type inference to decide which\n implementation to use.\n \n ~~~~\n-use std::float::consts::pi;\n-trait Shape { fn new(area: float) -> Self; }\n-struct Circle { radius: float }\n-struct Square { length: float }\n+use std::f64::consts::pi;\n+trait Shape { fn new(area: f64) -> Self; }\n+struct Circle { radius: f64 }\n+struct Square { length: f64 }\n \n impl Shape for Circle {\n-    fn new(area: float) -> Circle { Circle { radius: (area / pi).sqrt() } }\n+    fn new(area: f64) -> Circle { Circle { radius: (area / pi).sqrt() } }\n }\n impl Shape for Square {\n-    fn new(area: float) -> Square { Square { length: (area).sqrt() } }\n+    fn new(area: f64) -> Square { Square { length: (area).sqrt() } }\n }\n \n let area = 42.5;\n@@ -2159,24 +2159,24 @@ For example,\n we can define a `Circle` trait that inherits from `Shape`.\n \n ~~~~\n-trait Shape { fn area(&self) -> float; }\n-trait Circle : Shape { fn radius(&self) -> float; }\n+trait Shape { fn area(&self) -> f64; }\n+trait Circle : Shape { fn radius(&self) -> f64; }\n ~~~~\n \n Now, we can implement `Circle` on a type only if we also implement `Shape`.\n \n ~~~~\n-use std::float::consts::pi;\n-# trait Shape { fn area(&self) -> float; }\n-# trait Circle : Shape { fn radius(&self) -> float; }\n-# struct Point { x: float, y: float }\n-# fn square(x: float) -> float { x * x }\n-struct CircleStruct { center: Point, radius: float }\n+use std::f64::consts::pi;\n+# trait Shape { fn area(&self) -> f64; }\n+# trait Circle : Shape { fn radius(&self) -> f64; }\n+# struct Point { x: f64, y: f64 }\n+# fn square(x: f64) -> f64 { x * x }\n+struct CircleStruct { center: Point, radius: f64 }\n impl Circle for CircleStruct {\n-    fn radius(&self) -> float { (self.area() / pi).sqrt() }\n+    fn radius(&self) -> f64 { (self.area() / pi).sqrt() }\n }\n impl Shape for CircleStruct {\n-    fn area(&self) -> float { pi * square(self.radius) }\n+    fn area(&self) -> f64 { pi * square(self.radius) }\n }\n ~~~~\n \n@@ -2190,9 +2190,9 @@ methods of the supertrait may be called on values of subtrait-bound type paramet\n Refering to the previous example of `trait Circle : Shape`:\n \n ~~~\n-# trait Shape { fn area(&self) -> float; }\n-# trait Circle : Shape { fn radius(&self) -> float; }\n-fn radius_times_area<T: Circle>(c: T) -> float {\n+# trait Shape { fn area(&self) -> f64; }\n+# trait Circle : Shape { fn radius(&self) -> f64; }\n+fn radius_times_area<T: Circle>(c: T) -> f64 {\n     // `c` is both a Circle and a Shape\n     c.radius() * c.area()\n }\n@@ -2201,13 +2201,13 @@ fn radius_times_area<T: Circle>(c: T) -> float {\n Likewise, supertrait methods may also be called on trait objects.\n \n ~~~ {.xfail-test}\n-use std::float::consts::pi;\n-# trait Shape { fn area(&self) -> float; }\n-# trait Circle : Shape { fn radius(&self) -> float; }\n-# struct Point { x: float, y: float }\n-# struct CircleStruct { center: Point, radius: float }\n-# impl Circle for CircleStruct { fn radius(&self) -> float { (self.area() / pi).sqrt() } }\n-# impl Shape for CircleStruct { fn area(&self) -> float { pi * square(self.radius) } }\n+use std::f64::consts::pi;\n+# trait Shape { fn area(&self) -> f64; }\n+# trait Circle : Shape { fn radius(&self) -> f64; }\n+# struct Point { x: f64, y: f64 }\n+# struct CircleStruct { center: Point, radius: f64 }\n+# impl Circle for CircleStruct { fn radius(&self) -> f64 { (self.area() / pi).sqrt() } }\n+# impl Shape for CircleStruct { fn area(&self) -> f64 { pi * square(self.radius) } }\n \n let concrete = @CircleStruct{center:Point{x:3f,y:4f},radius:5f};\n let mycircle: @Circle = concrete as @Circle;\n@@ -2227,7 +2227,7 @@ of type `ABC` can be randomly generated and converted to a string:\n \n ~~~\n #[deriving(Eq)]\n-struct Circle { radius: float }\n+struct Circle { radius: f64 }\n \n #[deriving(Rand, ToStr)]\n enum ABC { A, B, C }"}, {"sha": "0792400e857e3df92664f15227b8c1886c363ee2", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -422,10 +422,6 @@ pub mod reader {\n             let bits = doc_as_u32(self.next_doc(EsF32));\n             unsafe { transmute(bits) }\n         }\n-        fn read_float(&mut self) -> float {\n-            let bits = doc_as_u64(self.next_doc(EsFloat));\n-            (unsafe { transmute::<u64, f64>(bits) }) as float\n-        }\n         fn read_char(&mut self) -> char {\n             char::from_u32(doc_as_u32(self.next_doc(EsChar))).unwrap()\n         }\n@@ -839,11 +835,6 @@ pub mod writer {\n             let bits = unsafe { cast::transmute(v) };\n             self.wr_tagged_u32(EsF32 as uint, bits);\n         }\n-        fn emit_float(&mut self, v: float) {\n-            let bits = unsafe { cast::transmute(v as f64) };\n-            self.wr_tagged_u64(EsFloat as uint, bits);\n-        }\n-\n         fn emit_char(&mut self, v: char) {\n             self.wr_tagged_u32(EsChar as uint, v as u32);\n         }"}, {"sha": "a1dccf33f6ceed1064c6fceb4b68d348205695d5", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -127,7 +127,7 @@ mod tests {\n             let out = inflate_bytes(cmp);\n             debug2!(\"{} bytes deflated to {} ({:.1f}% size)\",\n                    input.len(), cmp.len(),\n-                   100.0 * ((cmp.len() as float) / (input.len() as float)));\n+                   100.0 * ((cmp.len() as f64) / (input.len() as f64)));\n             assert_eq!(input, out);\n         }\n     }"}, {"sha": "1d8f3ffdc62aae3077b2ae3fe665e9f19315a9e1", "filename": "src/libextra/json.rs", "status": "modified", "additions": 101, "deletions": 110, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -18,10 +18,11 @@\n \n use std::char;\n use std::cast::transmute;\n-use std::float;\n+use std::f64;\n use std::hashmap::HashMap;\n use std::io::WriterUtil;\n use std::io;\n+use std::num;\n use std::str;\n use std::to_str;\n \n@@ -32,7 +33,7 @@ use treemap::TreeMap;\n /// Represents a json value\n #[deriving(Clone, Eq)]\n pub enum Json {\n-    Number(float),\n+    Number(f64),\n     String(~str),\n     Boolean(bool),\n     List(List),\n@@ -99,17 +100,17 @@ pub fn Encoder(wr: @io::Writer) -> Encoder {\n impl serialize::Encoder for Encoder {\n     fn emit_nil(&mut self) { self.wr.write_str(\"null\") }\n \n-    fn emit_uint(&mut self, v: uint) { self.emit_float(v as float); }\n-    fn emit_u64(&mut self, v: u64) { self.emit_float(v as float); }\n-    fn emit_u32(&mut self, v: u32) { self.emit_float(v as float); }\n-    fn emit_u16(&mut self, v: u16) { self.emit_float(v as float); }\n-    fn emit_u8(&mut self, v: u8)   { self.emit_float(v as float); }\n+    fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n+    fn emit_u64(&mut self, v: u64) { self.emit_f64(v as f64); }\n+    fn emit_u32(&mut self, v: u32) { self.emit_f64(v as f64); }\n+    fn emit_u16(&mut self, v: u16) { self.emit_f64(v as f64); }\n+    fn emit_u8(&mut self, v: u8)   { self.emit_f64(v as f64); }\n \n-    fn emit_int(&mut self, v: int) { self.emit_float(v as float); }\n-    fn emit_i64(&mut self, v: i64) { self.emit_float(v as float); }\n-    fn emit_i32(&mut self, v: i32) { self.emit_float(v as float); }\n-    fn emit_i16(&mut self, v: i16) { self.emit_float(v as float); }\n-    fn emit_i8(&mut self, v: i8)   { self.emit_float(v as float); }\n+    fn emit_int(&mut self, v: int) { self.emit_f64(v as f64); }\n+    fn emit_i64(&mut self, v: i64) { self.emit_f64(v as f64); }\n+    fn emit_i32(&mut self, v: i32) { self.emit_f64(v as f64); }\n+    fn emit_i16(&mut self, v: i16) { self.emit_f64(v as f64); }\n+    fn emit_i8(&mut self, v: i8)   { self.emit_f64(v as f64); }\n \n     fn emit_bool(&mut self, v: bool) {\n         if v {\n@@ -119,11 +120,8 @@ impl serialize::Encoder for Encoder {\n         }\n     }\n \n-    fn emit_f64(&mut self, v: f64) { self.emit_float(v as float); }\n-    fn emit_f32(&mut self, v: f32) { self.emit_float(v as float); }\n-    fn emit_float(&mut self, v: float) {\n-        self.wr.write_str(float::to_str_digits(v, 6u));\n-    }\n+    fn emit_f64(&mut self, v: f64) { self.wr.write_str(f64::to_str_digits(v, 6u)) }\n+    fn emit_f32(&mut self, v: f32) { self.emit_f64(v as f64); }\n \n     fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n     fn emit_str(&mut self, v: &str) { self.wr.write_str(escape_str(v)) }\n@@ -260,17 +258,17 @@ pub fn PrettyEncoder(wr: @io::Writer) -> PrettyEncoder {\n impl serialize::Encoder for PrettyEncoder {\n     fn emit_nil(&mut self) { self.wr.write_str(\"null\") }\n \n-    fn emit_uint(&mut self, v: uint) { self.emit_float(v as float); }\n-    fn emit_u64(&mut self, v: u64) { self.emit_float(v as float); }\n-    fn emit_u32(&mut self, v: u32) { self.emit_float(v as float); }\n-    fn emit_u16(&mut self, v: u16) { self.emit_float(v as float); }\n-    fn emit_u8(&mut self, v: u8)   { self.emit_float(v as float); }\n+    fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n+    fn emit_u64(&mut self, v: u64) { self.emit_f64(v as f64); }\n+    fn emit_u32(&mut self, v: u32) { self.emit_f64(v as f64); }\n+    fn emit_u16(&mut self, v: u16) { self.emit_f64(v as f64); }\n+    fn emit_u8(&mut self, v: u8)   { self.emit_f64(v as f64); }\n \n-    fn emit_int(&mut self, v: int) { self.emit_float(v as float); }\n-    fn emit_i64(&mut self, v: i64) { self.emit_float(v as float); }\n-    fn emit_i32(&mut self, v: i32) { self.emit_float(v as float); }\n-    fn emit_i16(&mut self, v: i16) { self.emit_float(v as float); }\n-    fn emit_i8(&mut self, v: i8)   { self.emit_float(v as float); }\n+    fn emit_int(&mut self, v: int) { self.emit_f64(v as f64); }\n+    fn emit_i64(&mut self, v: i64) { self.emit_f64(v as f64); }\n+    fn emit_i32(&mut self, v: i32) { self.emit_f64(v as f64); }\n+    fn emit_i16(&mut self, v: i16) { self.emit_f64(v as f64); }\n+    fn emit_i8(&mut self, v: i8)   { self.emit_f64(v as f64); }\n \n     fn emit_bool(&mut self, v: bool) {\n         if v {\n@@ -280,11 +278,8 @@ impl serialize::Encoder for PrettyEncoder {\n         }\n     }\n \n-    fn emit_f64(&mut self, v: f64) { self.emit_float(v as float); }\n-    fn emit_f32(&mut self, v: f32) { self.emit_float(v as float); }\n-    fn emit_float(&mut self, v: float) {\n-        self.wr.write_str(float::to_str_digits(v, 6u));\n-    }\n+    fn emit_f64(&mut self, v: f64) { self.wr.write_str(f64::to_str_digits(v, 6u)) }\n+    fn emit_f32(&mut self, v: f32) { self.emit_f64(v as f64); }\n \n     fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n     fn emit_str(&mut self, v: &str) { self.wr.write_str(escape_str(v)); }\n@@ -585,11 +580,11 @@ impl<T : Iterator<char>> Parser<T> {\n     }\n \n     fn parse_number(&mut self) -> Result<Json, Error> {\n-        let mut neg = 1f;\n+        let mut neg = 1.0;\n \n         if self.ch == '-' {\n             self.bump();\n-            neg = -1f;\n+            neg = -1.0;\n         }\n \n         let mut res = match self.parse_integer() {\n@@ -614,8 +609,8 @@ impl<T : Iterator<char>> Parser<T> {\n         Ok(Number(neg * res))\n     }\n \n-    fn parse_integer(&mut self) -> Result<float, Error> {\n-        let mut res = 0f;\n+    fn parse_integer(&mut self) -> Result<f64, Error> {\n+        let mut res = 0.0;\n \n         match self.ch {\n           '0' => {\n@@ -631,8 +626,8 @@ impl<T : Iterator<char>> Parser<T> {\n             while !self.eof() {\n                 match self.ch {\n                   '0' .. '9' => {\n-                    res *= 10f;\n-                    res += ((self.ch as int) - ('0' as int)) as float;\n+                    res *= 10.0;\n+                    res += ((self.ch as int) - ('0' as int)) as f64;\n \n                     self.bump();\n                   }\n@@ -646,7 +641,7 @@ impl<T : Iterator<char>> Parser<T> {\n         Ok(res)\n     }\n \n-    fn parse_decimal(&mut self, res: float) -> Result<float, Error> {\n+    fn parse_decimal(&mut self, res: f64) -> Result<f64, Error> {\n         self.bump();\n \n         // Make sure a digit follows the decimal place.\n@@ -656,12 +651,12 @@ impl<T : Iterator<char>> Parser<T> {\n         }\n \n         let mut res = res;\n-        let mut dec = 1f;\n+        let mut dec = 1.0;\n         while !self.eof() {\n             match self.ch {\n               '0' .. '9' => {\n-                dec /= 10f;\n-                res += (((self.ch as int) - ('0' as int)) as float) * dec;\n+                dec /= 10.0;\n+                res += (((self.ch as int) - ('0' as int)) as f64) * dec;\n \n                 self.bump();\n               }\n@@ -672,7 +667,7 @@ impl<T : Iterator<char>> Parser<T> {\n         Ok(res)\n     }\n \n-    fn parse_exponent(&mut self, mut res: float) -> Result<float, Error> {\n+    fn parse_exponent(&mut self, mut res: f64) -> Result<f64, Error> {\n         self.bump();\n \n         let mut exp = 0u;\n@@ -702,7 +697,7 @@ impl<T : Iterator<char>> Parser<T> {\n             }\n         }\n \n-        let exp = float::pow_with_uint(10u, exp);\n+        let exp: f64 = num::pow_with_uint(10u, exp);\n         if neg_exp {\n             res /= exp;\n         } else {\n@@ -892,17 +887,17 @@ impl serialize::Decoder for Decoder {\n         }\n     }\n \n-    fn read_u64(&mut self)  -> u64  { self.read_float() as u64 }\n-    fn read_u32(&mut self)  -> u32  { self.read_float() as u32 }\n-    fn read_u16(&mut self)  -> u16  { self.read_float() as u16 }\n-    fn read_u8 (&mut self)  -> u8   { self.read_float() as u8 }\n-    fn read_uint(&mut self) -> uint { self.read_float() as uint }\n+    fn read_u64(&mut self)  -> u64  { self.read_f64() as u64 }\n+    fn read_u32(&mut self)  -> u32  { self.read_f64() as u32 }\n+    fn read_u16(&mut self)  -> u16  { self.read_f64() as u16 }\n+    fn read_u8 (&mut self)  -> u8   { self.read_f64() as u8 }\n+    fn read_uint(&mut self) -> uint { self.read_f64() as uint }\n \n-    fn read_i64(&mut self) -> i64 { self.read_float() as i64 }\n-    fn read_i32(&mut self) -> i32 { self.read_float() as i32 }\n-    fn read_i16(&mut self) -> i16 { self.read_float() as i16 }\n-    fn read_i8 (&mut self) -> i8  { self.read_float() as i8 }\n-    fn read_int(&mut self) -> int { self.read_float() as int }\n+    fn read_i64(&mut self) -> i64 { self.read_f64() as i64 }\n+    fn read_i32(&mut self) -> i32 { self.read_f64() as i32 }\n+    fn read_i16(&mut self) -> i16 { self.read_f64() as i16 }\n+    fn read_i8 (&mut self) -> i8  { self.read_f64() as i8 }\n+    fn read_int(&mut self) -> int { self.read_f64() as int }\n \n     fn read_bool(&mut self) -> bool {\n         debug2!(\"read_bool\");\n@@ -912,15 +907,15 @@ impl serialize::Decoder for Decoder {\n         }\n     }\n \n-    fn read_f64(&mut self) -> f64 { self.read_float() as f64 }\n-    fn read_f32(&mut self) -> f32 { self.read_float() as f32 }\n-    fn read_float(&mut self) -> float {\n-        debug2!(\"read_float\");\n+    fn read_f64(&mut self) -> f64 {\n+        debug2!(\"read_f64\");\n         match self.stack.pop() {\n             Number(f) => f,\n             value => fail2!(\"not a number: {:?}\", value)\n         }\n     }\n+    fn read_f32(&mut self) -> f32 { self.read_f64() as f32 }\n+    fn read_f32(&mut self) -> f32 { self.read_f64() as f32 }\n \n     fn read_char(&mut self) -> char {\n         let mut v = ~[];\n@@ -1192,55 +1187,51 @@ impl ToJson for @Json {\n }\n \n impl ToJson for int {\n-    fn to_json(&self) -> Json { Number(*self as float) }\n+    fn to_json(&self) -> Json { Number(*self as f64) }\n }\n \n impl ToJson for i8 {\n-    fn to_json(&self) -> Json { Number(*self as float) }\n+    fn to_json(&self) -> Json { Number(*self as f64) }\n }\n \n impl ToJson for i16 {\n-    fn to_json(&self) -> Json { Number(*self as float) }\n+    fn to_json(&self) -> Json { Number(*self as f64) }\n }\n \n impl ToJson for i32 {\n-    fn to_json(&self) -> Json { Number(*self as float) }\n+    fn to_json(&self) -> Json { Number(*self as f64) }\n }\n \n impl ToJson for i64 {\n-    fn to_json(&self) -> Json { Number(*self as float) }\n+    fn to_json(&self) -> Json { Number(*self as f64) }\n }\n \n impl ToJson for uint {\n-    fn to_json(&self) -> Json { Number(*self as float) }\n+    fn to_json(&self) -> Json { Number(*self as f64) }\n }\n \n impl ToJson for u8 {\n-    fn to_json(&self) -> Json { Number(*self as float) }\n+    fn to_json(&self) -> Json { Number(*self as f64) }\n }\n \n impl ToJson for u16 {\n-    fn to_json(&self) -> Json { Number(*self as float) }\n+    fn to_json(&self) -> Json { Number(*self as f64) }\n }\n \n impl ToJson for u32 {\n-    fn to_json(&self) -> Json { Number(*self as float) }\n+    fn to_json(&self) -> Json { Number(*self as f64) }\n }\n \n impl ToJson for u64 {\n-    fn to_json(&self) -> Json { Number(*self as float) }\n-}\n-\n-impl ToJson for float {\n-    fn to_json(&self) -> Json { Number(*self) }\n+    fn to_json(&self) -> Json { Number(*self as f64) }\n }\n \n impl ToJson for f32 {\n-    fn to_json(&self) -> Json { Number(*self as float) }\n+    fn to_json(&self) -> Json { Number(*self as f64) }\n }\n \n impl ToJson for f64 {\n-    fn to_json(&self) -> Json { Number(*self as float) }\n+    fn to_json(&self) -> Json { Number(*self) }\n }\n \n impl ToJson for () {\n@@ -1374,17 +1365,17 @@ mod tests {\n \n     #[test]\n     fn test_write_number() {\n-        assert_eq!(Number(3f).to_str(), ~\"3\");\n-        assert_eq!(Number(3f).to_pretty_str(), ~\"3\");\n+        assert_eq!(Number(3.0).to_str(), ~\"3\");\n+        assert_eq!(Number(3.0).to_pretty_str(), ~\"3\");\n \n-        assert_eq!(Number(3.1f).to_str(), ~\"3.1\");\n-        assert_eq!(Number(3.1f).to_pretty_str(), ~\"3.1\");\n+        assert_eq!(Number(3.1).to_str(), ~\"3.1\");\n+        assert_eq!(Number(3.1).to_pretty_str(), ~\"3.1\");\n \n-        assert_eq!(Number(-1.5f).to_str(), ~\"-1.5\");\n-        assert_eq!(Number(-1.5f).to_pretty_str(), ~\"-1.5\");\n+        assert_eq!(Number(-1.5).to_str(), ~\"-1.5\");\n+        assert_eq!(Number(-1.5).to_pretty_str(), ~\"-1.5\");\n \n-        assert_eq!(Number(0.5f).to_str(), ~\"0.5\");\n-        assert_eq!(Number(0.5f).to_pretty_str(), ~\"0.5\");\n+        assert_eq!(Number(0.5).to_str(), ~\"0.5\");\n+        assert_eq!(Number(0.5).to_pretty_str(), ~\"0.5\");\n     }\n \n     #[test]\n@@ -1422,7 +1413,7 @@ mod tests {\n         let longTestList = List(~[\n             Boolean(false),\n             Null,\n-            List(~[String(~\"foo\\nbar\"), Number(3.5f)])]);\n+            List(~[String(~\"foo\\nbar\"), Number(3.5)])]);\n \n         assert_eq!(longTestList.to_str(),\n             ~\"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n@@ -1649,45 +1640,45 @@ mod tests {\n         assert_eq!(from_str(\"1e+\"),\n             Err(Error {line: 1u, col: 4u, msg: @~\"invalid number\"}));\n \n-        assert_eq!(from_str(\"3\"), Ok(Number(3f)));\n-        assert_eq!(from_str(\"3.1\"), Ok(Number(3.1f)));\n-        assert_eq!(from_str(\"-1.2\"), Ok(Number(-1.2f)));\n-        assert_eq!(from_str(\"0.4\"), Ok(Number(0.4f)));\n-        assert_eq!(from_str(\"0.4e5\"), Ok(Number(0.4e5f)));\n-        assert_eq!(from_str(\"0.4e+15\"), Ok(Number(0.4e15f)));\n-        assert_eq!(from_str(\"0.4e-01\"), Ok(Number(0.4e-01f)));\n-        assert_eq!(from_str(\" 3 \"), Ok(Number(3f)));\n+        assert_eq!(from_str(\"3\"), Ok(Number(3.0)));\n+        assert_eq!(from_str(\"3.1\"), Ok(Number(3.1)));\n+        assert_eq!(from_str(\"-1.2\"), Ok(Number(-1.2)));\n+        assert_eq!(from_str(\"0.4\"), Ok(Number(0.4)));\n+        assert_eq!(from_str(\"0.4e5\"), Ok(Number(0.4e5)));\n+        assert_eq!(from_str(\"0.4e+15\"), Ok(Number(0.4e15)));\n+        assert_eq!(from_str(\"0.4e-01\"), Ok(Number(0.4e-01)));\n+        assert_eq!(from_str(\" 3 \"), Ok(Number(3.0)));\n     }\n \n     #[test]\n     fn test_decode_numbers() {\n         let mut decoder = Decoder(from_str(\"3\").unwrap());\n-        let v: float = Decodable::decode(&mut decoder);\n-        assert_eq!(v, 3f);\n+        let v: f64 = Decodable::decode(&mut decoder);\n+        assert_eq!(v, 3.0);\n \n         let mut decoder = Decoder(from_str(\"3.1\").unwrap());\n-        let v: float = Decodable::decode(&mut decoder);\n-        assert_eq!(v, 3.1f);\n+        let v: f64 = Decodable::decode(&mut decoder);\n+        assert_eq!(v, 3.1);\n \n         let mut decoder = Decoder(from_str(\"-1.2\").unwrap());\n-        let v: float = Decodable::decode(&mut decoder);\n-        assert_eq!(v, -1.2f);\n+        let v: f64 = Decodable::decode(&mut decoder);\n+        assert_eq!(v, -1.2);\n \n         let mut decoder = Decoder(from_str(\"0.4\").unwrap());\n-        let v: float = Decodable::decode(&mut decoder);\n-        assert_eq!(v, 0.4f);\n+        let v: f64 = Decodable::decode(&mut decoder);\n+        assert_eq!(v, 0.4);\n \n         let mut decoder = Decoder(from_str(\"0.4e5\").unwrap());\n-        let v: float = Decodable::decode(&mut decoder);\n-        assert_eq!(v, 0.4e5f);\n+        let v: f64 = Decodable::decode(&mut decoder);\n+        assert_eq!(v, 0.4e5);\n \n         let mut decoder = Decoder(from_str(\"0.4e15\").unwrap());\n-        let v: float = Decodable::decode(&mut decoder);\n-        assert_eq!(v, 0.4e15f);\n+        let v: f64 = Decodable::decode(&mut decoder);\n+        assert_eq!(v, 0.4e15);\n \n         let mut decoder = Decoder(from_str(\"0.4e-01\").unwrap());\n-        let v: float = Decodable::decode(&mut decoder);\n-        assert_eq!(v, 0.4e-01f);\n+        let v: f64 = Decodable::decode(&mut decoder);\n+        assert_eq!(v, 0.4e-01);\n     }\n \n     #[test]\n@@ -1769,11 +1760,11 @@ mod tests {\n         assert_eq!(from_str(\"[ false ]\"), Ok(List(~[Boolean(false)])));\n         assert_eq!(from_str(\"[null]\"), Ok(List(~[Null])));\n         assert_eq!(from_str(\"[3, 1]\"),\n-                     Ok(List(~[Number(3f), Number(1f)])));\n+                     Ok(List(~[Number(3.0), Number(1.0)])));\n         assert_eq!(from_str(\"\\n[3, 2]\\n\"),\n-                     Ok(List(~[Number(3f), Number(2f)])));\n+                     Ok(List(~[Number(3.0), Number(2.0)])));\n         assert_eq!(from_str(\"[2, [4, 1]]\"),\n-               Ok(List(~[Number(2f), List(~[Number(4f), Number(1f)])])));\n+               Ok(List(~[Number(2.0), List(~[Number(4.0), Number(1.0)])])));\n     }\n \n     #[test]\n@@ -1855,7 +1846,7 @@ mod tests {\n \n         assert_eq!(from_str(\"{}\").unwrap(), mk_object([]));\n         assert_eq!(from_str(\"{\\\"a\\\": 3}\").unwrap(),\n-                  mk_object([(~\"a\", Number(3.0f))]));\n+                  mk_object([(~\"a\", Number(3.0))]));\n \n         assert_eq!(from_str(\n                       \"{ \\\"a\\\": null, \\\"b\\\" : true }\").unwrap(),\n@@ -1882,7 +1873,7 @@ mod tests {\n                           \"]\" +\n                       \"}\").unwrap(),\n                   mk_object([\n-                      (~\"a\", Number(1.0f)),\n+                      (~\"a\", Number(1.0)),\n                       (~\"b\", List(~[\n                           Boolean(true),\n                           String(~\"foo\\nbar\"),"}, {"sha": "58af80fefb787184691bf0488e4c5e7b97e02da9", "filename": "src/libextra/num/complex.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibextra%2Fnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibextra%2Fnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fcomplex.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -30,7 +30,6 @@ pub struct Cmplx<T> {\n     im: T\n }\n \n-pub type Complex = Cmplx<float>;\n pub type Complex32 = Cmplx<f32>;\n pub type Complex64 = Cmplx<f64>;\n \n@@ -196,25 +195,25 @@ mod test {\n     use super::*;\n     use std::num::{Zero,One,Real};\n \n-    pub static _0_0i : Complex = Cmplx { re: 0f, im: 0f };\n-    pub static _1_0i : Complex = Cmplx { re: 1f, im: 0f };\n-    pub static _1_1i : Complex = Cmplx { re: 1f, im: 1f };\n-    pub static _0_1i : Complex = Cmplx { re: 0f, im: 1f };\n-    pub static _neg1_1i : Complex = Cmplx { re: -1f, im: 1f };\n-    pub static _05_05i : Complex = Cmplx { re: 0.5f, im: 0.5f };\n-    pub static all_consts : [Complex, .. 5] = [_0_0i, _1_0i, _1_1i, _neg1_1i, _05_05i];\n+    pub static _0_0i : Complex64 = Cmplx { re: 0.0, im: 0.0 };\n+    pub static _1_0i : Complex64 = Cmplx { re: 1.0, im: 0.0 };\n+    pub static _1_1i : Complex64 = Cmplx { re: 1.0, im: 1.0 };\n+    pub static _0_1i : Complex64 = Cmplx { re: 0.0, im: 1.0 };\n+    pub static _neg1_1i : Complex64 = Cmplx { re: -1.0, im: 1.0 };\n+    pub static _05_05i : Complex64 = Cmplx { re: 0.5, im: 0.5 };\n+    pub static all_consts : [Complex64, .. 5] = [_0_0i, _1_0i, _1_1i, _neg1_1i, _05_05i];\n \n     #[test]\n     fn test_consts() {\n         // check our constants are what Cmplx::new creates\n-        fn test(c : Complex, r : float, i: float) {\n+        fn test(c : Complex64, r : f64, i: f64) {\n             assert_eq!(c, Cmplx::new(r,i));\n         }\n-        test(_0_0i, 0f, 0f);\n-        test(_1_0i, 1f, 0f);\n-        test(_1_1i, 1f, 1f);\n-        test(_neg1_1i, -1f, 1f);\n-        test(_05_05i, 0.5f, 0.5f);\n+        test(_0_0i, 0.0, 0.0);\n+        test(_1_0i, 1.0, 0.0);\n+        test(_1_1i, 1.0, 1.0);\n+        test(_neg1_1i, -1.0, 1.0);\n+        test(_05_05i, 0.5, 0.5);\n \n         assert_eq!(_0_0i, Zero::zero());\n         assert_eq!(_1_0i, One::one());\n@@ -224,23 +223,23 @@ mod test {\n     #[ignore(cfg(target_arch = \"x86\"))]\n     // FIXME #7158: (maybe?) currently failing on x86.\n     fn test_norm() {\n-        fn test(c: Complex, ns: float) {\n+        fn test(c: Complex64, ns: f64) {\n             assert_eq!(c.norm_sqr(), ns);\n             assert_eq!(c.norm(), ns.sqrt())\n         }\n-        test(_0_0i, 0f);\n-        test(_1_0i, 1f);\n-        test(_1_1i, 2f);\n-        test(_neg1_1i, 2f);\n-        test(_05_05i, 0.5f);\n+        test(_0_0i, 0.0);\n+        test(_1_0i, 1.0);\n+        test(_1_1i, 2.0);\n+        test(_neg1_1i, 2.0);\n+        test(_05_05i, 0.5);\n     }\n \n     #[test]\n     fn test_scale_unscale() {\n-        assert_eq!(_05_05i.scale(2f), _1_1i);\n-        assert_eq!(_1_1i.unscale(2f), _05_05i);\n+        assert_eq!(_05_05i.scale(2.0), _1_1i);\n+        assert_eq!(_1_1i.unscale(2.0), _05_05i);\n         for &c in all_consts.iter() {\n-            assert_eq!(c.scale(2f).unscale(2f), c);\n+            assert_eq!(c.scale(2.0).unscale(2.0), c);\n         }\n     }\n \n@@ -268,18 +267,18 @@ mod test {\n \n     #[test]\n     fn test_arg() {\n-        fn test(c: Complex, arg: float) {\n+        fn test(c: Complex64, arg: f64) {\n             assert!(c.arg().approx_eq(&arg))\n         }\n-        test(_1_0i, 0f);\n-        test(_1_1i, 0.25f * Real::pi());\n-        test(_neg1_1i, 0.75f * Real::pi());\n-        test(_05_05i, 0.25f * Real::pi());\n+        test(_1_0i, 0.0);\n+        test(_1_1i, 0.25 * Real::pi());\n+        test(_neg1_1i, 0.75 * Real::pi());\n+        test(_05_05i, 0.25 * Real::pi());\n     }\n \n     #[test]\n     fn test_polar_conv() {\n-        fn test(c: Complex) {\n+        fn test(c: Complex64) {\n             let (r, theta) = c.to_polar();\n             assert!((c - Cmplx::from_polar(&r, &theta)).norm() < 1e-6);\n         }\n@@ -316,7 +315,7 @@ mod test {\n \n         #[test]\n         fn test_mul() {\n-            assert_eq!(_05_05i * _05_05i, _0_1i.unscale(2f));\n+            assert_eq!(_05_05i * _05_05i, _0_1i.unscale(2.0));\n             assert_eq!(_1_1i * _0_1i, _neg1_1i);\n \n             // i^2 & i^4\n@@ -349,7 +348,7 @@ mod test {\n \n     #[test]\n     fn test_to_str() {\n-        fn test(c : Complex, s: ~str) {\n+        fn test(c : Complex64, s: ~str) {\n             assert_eq!(c.to_str(), s);\n         }\n         test(_0_0i, ~\"0+0i\");"}, {"sha": "fb87414c8c364f5d088c60c82eea53deda3afb5f", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -41,7 +41,6 @@ pub trait Encoder {\n     fn emit_i16(&mut self, v: i16);\n     fn emit_i8(&mut self, v: i8);\n     fn emit_bool(&mut self, v: bool);\n-    fn emit_float(&mut self, v: float);\n     fn emit_f64(&mut self, v: f64);\n     fn emit_f32(&mut self, v: f32);\n     fn emit_char(&mut self, v: char);\n@@ -108,7 +107,6 @@ pub trait Decoder {\n     fn read_bool(&mut self) -> bool;\n     fn read_f64(&mut self) -> f64;\n     fn read_f32(&mut self) -> f32;\n-    fn read_float(&mut self) -> float;\n     fn read_char(&mut self) -> char;\n     fn read_str(&mut self) -> ~str;\n \n@@ -326,18 +324,6 @@ impl<D:Decoder> Decodable<D> for @str {\n     }\n }\n \n-impl<S:Encoder> Encodable<S> for float {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_float(*self)\n-    }\n-}\n-\n-impl<D:Decoder> Decodable<D> for float {\n-    fn decode(d: &mut D) -> float {\n-        d.read_float()\n-    }\n-}\n-\n impl<S:Encoder> Encodable<S> for f32 {\n     fn encode(&self, s: &mut S) {\n         s.emit_f32(*self)"}, {"sha": "e1230070836c0b9a5fd5840ad7ee0f397af8dc0a", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -915,13 +915,13 @@ mod test_tim_sort {\n \n     #[deriving(Clone)]\n     struct CVal {\n-        val: float,\n+        val: f64,\n     }\n \n     impl Ord for CVal {\n         fn lt(&self, other: &CVal) -> bool {\n             let mut rng = rand::rng();\n-            if rng.gen::<float>() > 0.995 {\n+            if rng.gen::<f64>() > 0.995 {\n                 fail2!(\"It's happening!!!\");\n             }\n             (*self).val < other.val\n@@ -1054,7 +1054,7 @@ mod big_tests {\n \n         for i in range(lo, hi) {\n             let n = 1 << i;\n-            let mut arr: ~[float] = do vec::from_fn(n) |_i| {\n+            let mut arr: ~[f64] = do vec::from_fn(n) |_i| {\n                 rng.gen()\n             };\n \n@@ -1106,7 +1106,7 @@ mod big_tests {\n             isSorted(arr);\n \n             let half = n / 2;\n-            let mut arr = makeRange(half).map(|i| *i as float);\n+            let mut arr = makeRange(half).map(|i| *i as f64);\n             tim_sort(arr); // !sort\n             isSorted(arr);\n         }\n@@ -1125,7 +1125,7 @@ mod big_tests {\n \n         for i in range(lo, hi) {\n             let n = 1 << i;\n-            let arr: ~[@float] = do vec::from_fn(n) |_i| {\n+            let arr: ~[@f64] = do vec::from_fn(n) |_i| {\n                 @rng.gen()\n             };\n             let mut arr = arr;\n@@ -1178,7 +1178,7 @@ mod big_tests {\n             isSorted(arr);\n \n             let half = n / 2;\n-            let mut arr = makeRange(half).map(|i| @(*i as float));\n+            let mut arr = makeRange(half).map(|i| @(*i as f64));\n             tim_sort(arr); // !sort\n             isSorted(arr);\n         }"}, {"sha": "9e30e5bcaabd5aa3970408fa43d3f7aa96a83484", "filename": "src/libextra/test.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -485,14 +485,14 @@ impl ConsoleTestState {\n                     self.out.write_str(*k);\n                     self.out.write_str(\": \");\n                     self.write_improved();\n-                    self.out.write_line(format!(\" by {:.2f}%\", pct as float))\n+                    self.out.write_line(format!(\" by {:.2f}%\", pct as f64))\n                 }\n                 Regression(pct) => {\n                     regressed += 1;\n                     self.out.write_str(*k);\n                     self.out.write_str(\": \");\n                     self.write_regressed();\n-                    self.out.write_line(format!(\" by {:.2f}%\", pct as float))\n+                    self.out.write_line(format!(\" by {:.2f}%\", pct as f64))\n                 }\n             }\n         }\n@@ -519,7 +519,7 @@ impl ConsoleTestState {\n                     None => (),\n                     Some(pct) =>\n                     self.out.write_str(format!(\"with noise-tolerance forced to: {}%%\\n\",\n-                                            pct as float))\n+                                            pct as f64))\n                 }\n                 let (diff, ok) = self.metrics.ratchet(pth, ratchet_pct);\n                 self.write_metric_diff(&diff);\n@@ -551,8 +551,8 @@ pub fn fmt_metrics(mm: &MetricMap) -> ~str {\n     let v : ~[~str] = mm.iter()\n         .map(|(k,v)| format!(\"{}: {} (+/- {})\",\n                           *k,\n-                          v.value as float,\n-                          v.noise as float))\n+                          v.value as f64,\n+                          v.noise as f64))\n         .collect();\n     v.connect(\", \")\n }\n@@ -878,8 +878,8 @@ fn calc_result(desc: &TestDesc, task_succeeded: bool) -> TestResult {\n impl ToJson for Metric {\n     fn to_json(&self) -> json::Json {\n         let mut map = ~TreeMap::new();\n-        map.insert(~\"value\", json::Number(self.value as float));\n-        map.insert(~\"noise\", json::Number(self.noise as float));\n+        map.insert(~\"value\", json::Number(self.value as f64));\n+        map.insert(~\"noise\", json::Number(self.noise as f64));\n         json::Object(map)\n     }\n }\n@@ -1083,9 +1083,9 @@ impl BenchHarness {\n \n             debug2!(\"{} samples, median {}, MAD={}, MADP={}\",\n                    samples.len(),\n-                   summ.median as float,\n-                   summ.median_abs_dev as float,\n-                   summ.median_abs_dev_pct as float);\n+                   summ.median as f64,\n+                   summ.median_abs_dev as f64,\n+                   summ.median_abs_dev_pct as f64);\n \n             let now = precise_time_ns();\n             let loop_run = now - loop_start;"}, {"sha": "b1fe0bc6d7c4eb65d1b4d7ffc6f250d00c53faa1", "filename": "src/libextra/time.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -92,8 +92,8 @@ pub fn precise_time_ns() -> u64 {\n  * Returns the current value of a high-resolution performance counter\n  * in seconds since an unspecified epoch.\n  */\n-pub fn precise_time_s() -> float {\n-    return (precise_time_ns() as float) / 1000000000.;\n+pub fn precise_time_s() -> f64 {\n+    return (precise_time_ns() as f64) / 1000000000.;\n }\n \n pub fn tzset() {\n@@ -905,7 +905,7 @@ fn do_strftime(format: &str, tm: &Tm) -> ~str {\n mod tests {\n     use super::*;\n \n-    use std::float;\n+    use std::f64;\n     use std::os;\n     use std::result::{Err, Ok};\n \n@@ -934,7 +934,7 @@ mod tests {\n         let s0 = precise_time_s();\n         let ns1 = precise_time_ns();\n \n-        debug2!(\"s0={} sec\", float::to_str_digits(s0, 9u));\n+        debug2!(\"s0={} sec\", f64::to_str_digits(s0, 9u));\n         assert!(s0 > 0.);\n         let ns0 = (s0 * 1000000000.) as u64;\n         debug2!(\"ns0={:?} ns\", ns0);"}, {"sha": "970f567359feec75385823b357c21e857bf6177c", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -603,11 +603,11 @@ pub fn build_target_config(sopts: @session::options,\n       None => early_error(demitter,\n                           ~\"unknown architecture: \" + sopts.target_triple)\n     };\n-    let (int_type, uint_type, float_type) = match arch {\n-      abi::X86 => (ast::ty_i32, ast::ty_u32, ast::ty_f64),\n-      abi::X86_64 => (ast::ty_i64, ast::ty_u64, ast::ty_f64),\n-      abi::Arm => (ast::ty_i32, ast::ty_u32, ast::ty_f64),\n-      abi::Mips => (ast::ty_i32, ast::ty_u32, ast::ty_f64)\n+    let (int_type, uint_type) = match arch {\n+      abi::X86 => (ast::ty_i32, ast::ty_u32),\n+      abi::X86_64 => (ast::ty_i64, ast::ty_u64),\n+      abi::Arm => (ast::ty_i32, ast::ty_u32),\n+      abi::Mips => (ast::ty_i32, ast::ty_u32)\n     };\n     let target_triple = sopts.target_triple.clone();\n     let target_strs = match arch {\n@@ -622,7 +622,6 @@ pub fn build_target_config(sopts: @session::options,\n         target_strs: target_strs,\n         int_type: int_type,\n         uint_type: uint_type,\n-        float_type: float_type\n     };\n     return target_cfg;\n }"}, {"sha": "066def72b471e58b545a6a80175cba1ab3633b3a", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -19,7 +19,7 @@ use metadata;\n use middle::lint;\n \n use syntax::ast::NodeId;\n-use syntax::ast::{int_ty, uint_ty, float_ty};\n+use syntax::ast::{int_ty, uint_ty};\n use syntax::codemap::Span;\n use syntax::diagnostic;\n use syntax::parse::ParseSess;\n@@ -47,7 +47,6 @@ pub struct config {\n     target_strs: target_strs::t,\n     int_type: int_ty,\n     uint_type: uint_ty,\n-    float_type: float_ty\n }\n \n pub static verbose:                 uint = 1 <<  0;"}, {"sha": "d7a544320c26e760fa0e2956b0ec054c624d2e77", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -304,7 +304,6 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n       'b' => return ty::mk_bool(),\n       'i' => return ty::mk_int(),\n       'u' => return ty::mk_uint(),\n-      'l' => return ty::mk_float(),\n       'M' => {\n         match next(st) {\n           'b' => return ty::mk_mach_uint(ast::ty_u8),"}, {"sha": "146e3cd920095bf6dc26b5d625d93dd167bcf2d5", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -260,7 +260,6 @@ fn enc_sty(w: @io::Writer, cx: @ctxt, st: &ty::sty) {\n       }\n       ty::ty_float(t) => {\n         match t {\n-          ty_f => w.write_char('l'),\n           ty_f32 => w.write_str(&\"Mf\"),\n           ty_f64 => w.write_str(&\"MF\"),\n         }"}, {"sha": "86a604b010472ae3db292ca4f18b57acb0c876bf", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -115,9 +115,9 @@ pub fn check_crate(\n     return (bccx.root_map, bccx.write_guard_map);\n \n     fn make_stat(bccx: &mut BorrowckCtxt, stat: uint) -> ~str {\n-        let stat_f = stat as float;\n-        let total = bccx.stats.guaranteed_paths as float;\n-        format!(\"{} ({:.0f}%)\", stat  , stat_f * 100f / total)\n+        let stat_f = stat as f64;\n+        let total = bccx.stats.guaranteed_paths as f64;\n+        format!(\"{} ({:.0f}%)\", stat  , stat_f * 100.0 / total)\n     }\n }\n "}, {"sha": "d13493c0a02971d33a0bbe935da372d699e2e510", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -475,9 +475,9 @@ pub fn lit_to_const(lit: &lit) -> const_val {\n       lit_int(n, _) => const_int(n),\n       lit_uint(n, _) => const_uint(n),\n       lit_int_unsuffixed(n) => const_int(n),\n-      lit_float(n, _) => const_float(from_str::<float>(n).unwrap() as f64),\n+      lit_float(n, _) => const_float(from_str::<f64>(n).unwrap() as f64),\n       lit_float_unsuffixed(n) =>\n-        const_float(from_str::<float>(n).unwrap() as f64),\n+        const_float(from_str::<f64>(n).unwrap() as f64),\n       lit_nil => const_int(0i64),\n       lit_bool(b) => const_bool(b)\n     }"}, {"sha": "b1984b920afc6184018ec5df00b0592af69070a4", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -772,7 +772,6 @@ pub fn PrimitiveTypeTable() -> PrimitiveTypeTable {\n \n     table.intern(\"bool\",    ty_bool);\n     table.intern(\"char\",    ty_char);\n-    table.intern(\"float\",   ty_float(ty_f));\n     table.intern(\"f32\",     ty_float(ty_f32));\n     table.intern(\"f64\",     ty_float(ty_f64));\n     table.intern(\"int\",     ty_int(ty_i));"}, {"sha": "25d600de1e92bb8e2b9b08b44c9d2f0b48c01176", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -56,12 +56,12 @@ pub fn const_lit(cx: &mut CrateContext, e: &ast::Expr, lit: ast::lit)\n                         ty_to_str(cx.tcx, lit_int_ty)))\n         }\n       }\n-      ast::lit_float(fs, t) => C_floating(fs, Type::float_from_ty(cx, t)),\n+      ast::lit_float(fs, t) => C_floating(fs, Type::float_from_ty(t)),\n       ast::lit_float_unsuffixed(fs) => {\n         let lit_float_ty = ty::node_id_to_type(cx.tcx, e.id);\n         match ty::get(lit_float_ty).sty {\n           ty::ty_float(t) => {\n-            C_floating(fs, Type::float_from_ty(cx, t))\n+            C_floating(fs, Type::float_from_ty(t))\n           }\n           _ => {\n             cx.sess.span_bug(lit.span,"}, {"sha": "3125155d0c793c929ce89c1ca64da1faf4434626", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -109,7 +109,6 @@ pub struct CrateContext {\n      upcalls: @upcall::Upcalls,\n      tydesc_type: Type,\n      int_type: Type,\n-     float_type: Type,\n      opaque_vec_type: Type,\n      builder: BuilderRef_res,\n      crate_map: ValueRef,\n@@ -156,7 +155,6 @@ impl CrateContext {\n                 base::declare_dbg_intrinsics(llmod, &mut intrinsics);\n             }\n             let int_type = Type::int(targ_cfg.arch);\n-            let float_type = Type::float(targ_cfg.arch);\n             let tydesc_type = Type::tydesc(targ_cfg.arch);\n             let opaque_vec_type = Type::opaque_vec(targ_cfg.arch);\n \n@@ -234,7 +232,6 @@ impl CrateContext {\n                   upcalls: upcall::declare_upcalls(targ_cfg, llmod),\n                   tydesc_type: tydesc_type,\n                   int_type: int_type,\n-                  float_type: float_type,\n                   opaque_vec_type: opaque_vec_type,\n                   builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n                   crate_map: crate_map,"}, {"sha": "ded61f975db80c0cbe2a7f10462c3a32cb1ca527", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -1046,7 +1046,6 @@ fn basic_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n             ast::ty_u64 => (~\"u64\", DW_ATE_unsigned)\n         },\n         ty::ty_float(float_ty) => match float_ty {\n-            ast::ty_f => (~\"float\", DW_ATE_float),\n             ast::ty_f32 => (~\"f32\", DW_ATE_float),\n             ast::ty_f64 => (~\"f64\", DW_ATE_float)\n         },"}, {"sha": "1ab9e4581f28c0ff4bc98fad4ecad1404a46b79b", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -168,7 +168,6 @@ impl Reflector {\n           ty::ty_uint(ast::ty_u16) => self.leaf(\"u16\"),\n           ty::ty_uint(ast::ty_u32) => self.leaf(\"u32\"),\n           ty::ty_uint(ast::ty_u64) => self.leaf(\"u64\"),\n-          ty::ty_float(ast::ty_f) => self.leaf(\"float\"),\n           ty::ty_float(ast::ty_f32) => self.leaf(\"f32\"),\n           ty::ty_float(ast::ty_f64) => self.leaf(\"f64\"),\n "}, {"sha": "1c2445dd6316e1ec7f09375cbf6d2f8267b63556", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -136,9 +136,8 @@ impl Type {\n         }\n     }\n \n-    pub fn float_from_ty(ctx: &CrateContext, t: ast::float_ty) -> Type {\n+    pub fn float_from_ty(t: ast::float_ty) -> Type {\n         match t {\n-            ast::ty_f => ctx.float_type,\n             ast::ty_f32 => Type::f32(),\n             ast::ty_f64 => Type::f64()\n         }"}, {"sha": "3d5ebefcccbefaa3d23fd76ffe1aec0772ce4873", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -111,7 +111,7 @@ pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n         ty::ty_char => Type::char(),\n         ty::ty_int(t) => Type::int_from_ty(cx, t),\n         ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n-        ty::ty_float(t) => Type::float_from_ty(cx, t),\n+        ty::ty_float(t) => Type::float_from_ty(t),\n \n         ty::ty_estr(ty::vstore_uniq) |\n         ty::ty_estr(ty::vstore_box) |\n@@ -199,7 +199,7 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n       ty::ty_char => Type::char(),\n       ty::ty_int(t) => Type::int_from_ty(cx, t),\n       ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n-      ty::ty_float(t) => Type::float_from_ty(cx, t),\n+      ty::ty_float(t) => Type::float_from_ty(t),\n       ty::ty_estr(ty::vstore_uniq) => {\n         Type::vec(cx.sess.targ_cfg.arch, &Type::i8()).ptr_to()\n       }"}, {"sha": "84ebda5db5c4af83d5abcbd34edf019fafa01a9f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -583,7 +583,6 @@ mod primitives {\n     def_prim_ty!(TY_U16,    super::ty_uint(ast::ty_u16),    10)\n     def_prim_ty!(TY_U32,    super::ty_uint(ast::ty_u32),    11)\n     def_prim_ty!(TY_U64,    super::ty_uint(ast::ty_u64),    12)\n-    def_prim_ty!(TY_FLOAT,  super::ty_float(ast::ty_f),     13)\n     def_prim_ty!(TY_F32,    super::ty_float(ast::ty_f32),   14)\n     def_prim_ty!(TY_F64,    super::ty_float(ast::ty_f64),   15)\n \n@@ -1121,9 +1120,6 @@ pub fn mk_i32() -> t { mk_prim_t(&primitives::TY_I32) }\n #[inline]\n pub fn mk_i64() -> t { mk_prim_t(&primitives::TY_I64) }\n \n-#[inline]\n-pub fn mk_float() -> t { mk_prim_t(&primitives::TY_FLOAT) }\n-\n #[inline]\n pub fn mk_f32() -> t { mk_prim_t(&primitives::TY_F32) }\n \n@@ -1167,7 +1163,6 @@ pub fn mk_mach_uint(tm: ast::uint_ty) -> t {\n \n pub fn mk_mach_float(tm: ast::float_ty) -> t {\n     match tm {\n-        ast::ty_f    => mk_float(),\n         ast::ty_f32  => mk_f32(),\n         ast::ty_f64  => mk_f64(),\n     }\n@@ -2560,7 +2555,7 @@ pub fn type_is_signed(ty: t) -> bool {\n \n pub fn type_is_machine(ty: t) -> bool {\n     match get(ty).sty {\n-        ty_int(ast::ty_i) | ty_uint(ast::ty_u) | ty_float(ast::ty_f) => false,\n+        ty_int(ast::ty_i) | ty_uint(ast::ty_u) => false,\n         ty_int(*) | ty_uint(*) | ty_float(*) => true,\n         _ => false\n     }"}, {"sha": "dcb0e6fbd413da27b19a2989615fba3f43e1d1aa", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -269,9 +269,9 @@ impl ResolveState {\n           Some(t) => ty::mk_mach_float(t),\n           None => {\n             if self.should(force_fvar) {\n-                // As a last resort, default to float.\n-                let ty = ty::mk_float();\n-                self.infcx.set(vid, Root(Some(ast::ty_f), node.rank));\n+                // As a last resort, default to f64.\n+                let ty = ty::mk_f64();\n+                self.infcx.set(vid, Root(Some(ast::ty_f64), node.rank));\n                 ty\n             } else {\n                 ty::mk_float_var(self.infcx.tcx, vid)"}, {"sha": "21517e42169c53a2ae7a07e01c012eacf14bdbe9", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -417,7 +417,6 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_int(t) => ast_util::int_ty_to_str(t),\n       ty_uint(ast::ty_u) => ~\"uint\",\n       ty_uint(t) => ast_util::uint_ty_to_str(t),\n-      ty_float(ast::ty_f) => ~\"float\",\n       ty_float(t) => ast_util::float_ty_to_str(t),\n       ty_box(ref tm) => ~\"@\" + mt_to_str(cx, tm),\n       ty_uniq(ref tm) => ~\"~\" + mt_to_str(cx, tm),"}, {"sha": "acbed7f4120f8c94e659e169b21e3f46f71a65b1", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -233,7 +233,6 @@ impl fmt::Default for clean::Type {\n                     ast::ty_uint(ast::ty_u16) => \"u16\",\n                     ast::ty_uint(ast::ty_u32) => \"u32\",\n                     ast::ty_uint(ast::ty_u64) => \"u64\",\n-                    ast::ty_float(ast::ty_f) => \"float\",\n                     ast::ty_float(ast::ty_f32) => \"f32\",\n                     ast::ty_float(ast::ty_f64) => \"f64\",\n                     ast::ty_str => \"str\","}, {"sha": "701be1b3dfa97171c18148a829f9a5c142a5f09b", "filename": "src/libstd/clone.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibstd%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibstd%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fclone.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -89,7 +89,6 @@ clone_impl!(u16)\n clone_impl!(u32)\n clone_impl!(u64)\n \n-clone_impl!(float)\n clone_impl!(f32)\n clone_impl!(f64)\n \n@@ -169,7 +168,6 @@ deep_clone_impl!(u16)\n deep_clone_impl!(u32)\n deep_clone_impl!(u64)\n \n-deep_clone_impl!(float)\n deep_clone_impl!(f32)\n deep_clone_impl!(f64)\n \n@@ -241,9 +239,9 @@ fn test_extern_fn_clone() {\n     trait Empty {}\n     impl Empty for int {}\n \n-    fn test_fn_a() -> float { 1.0 }\n+    fn test_fn_a() -> f64 { 1.0 }\n     fn test_fn_b<T: Empty>(x: T) -> T { x }\n-    fn test_fn_c(_: int, _: float, _: ~[int], _: int, _: int, _: int) {}\n+    fn test_fn_c(_: int, _: f64, _: ~[int], _: int, _: int, _: int) {}\n \n     let _ = test_fn_a.clone();\n     let _ = test_fn_b::<int>.clone();"}, {"sha": "a03f21d69c8d54df163bb3e027c722d9aece21d6", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -1035,7 +1035,6 @@ macro_rules! floating(($ty:ident) => {\n         }\n     }\n })\n-floating!(float)\n floating!(f32)\n floating!(f64)\n \n@@ -1096,7 +1095,6 @@ delegate!(~str to String)\n delegate!(&'self str to String)\n delegate!(bool to Bool)\n delegate!(char to Char)\n-delegate!(float to Float)\n delegate!(f32 to Float)\n delegate!(f64 to Float)\n "}, {"sha": "6043f7e3f52e40ed45b102ba1e389d1ee3d63f9c", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -2269,12 +2269,12 @@ mod tests {\n     #[test]\n     fn test_iterator_scan() {\n         // test the type inference\n-        fn add(old: &mut int, new: &uint) -> Option<float> {\n+        fn add(old: &mut int, new: &uint) -> Option<f64> {\n             *old += *new as int;\n-            Some(*old as float)\n+            Some(*old as f64)\n         }\n         let xs = [0u, 1, 2, 3, 4];\n-        let ys = [0f, 1f, 3f, 6f, 10f];\n+        let ys = [0f64, 1.0, 3.0, 6.0, 10.0];\n \n         let mut it = xs.iter().scan(0, add);\n         let mut i = 0;"}, {"sha": "4f676545d4f068c98cca83f08eb5cd62c4139339", "filename": "src/libstd/num/float.rs", "status": "removed", "additions": 0, "deletions": 1444, "changes": 1444, "blob_url": "https://github.com/rust-lang/rust/blob/c8cdabc32fc7c6a5c3b01ef24340bc2f4b1ae359/src%2Flibstd%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8cdabc32fc7c6a5c3b01ef24340bc2f4b1ae359/src%2Flibstd%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat.rs?ref=c8cdabc32fc7c6a5c3b01ef24340bc2f4b1ae359", "patch": "@@ -1,1444 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Operations and constants for `float`\n-\n-// Even though this module exports everything defined in it,\n-// because it contains re-exports, we also have to explicitly\n-// export locally defined things. That's a bit annoying.\n-\n-\n-// export when m_float == c_double\n-\n-\n-// PORT this must match in width according to architecture\n-\n-#[allow(missing_doc)];\n-#[allow(non_uppercase_statics)];\n-\n-use default::Default;\n-use num::{Zero, One, strconv};\n-use num::FPCategory;\n-use num;\n-use prelude::*;\n-use to_str;\n-\n-pub static NaN: float = 0.0/0.0;\n-\n-pub static infinity: float = 1.0/0.0;\n-\n-pub static neg_infinity: float = -1.0/0.0;\n-\n-/* Module: consts */\n-pub mod consts {\n-    // FIXME (requires Issue #1433 to fix): replace with mathematical\n-    // constants from cmath.\n-    /// Archimedes' constant\n-    pub static pi: float = 3.14159265358979323846264338327950288;\n-\n-    /// pi/2.0\n-    pub static frac_pi_2: float = 1.57079632679489661923132169163975144;\n-\n-    /// pi/4.0\n-    pub static frac_pi_4: float = 0.785398163397448309615660845819875721;\n-\n-    /// 1.0/pi\n-    pub static frac_1_pi: float = 0.318309886183790671537767526745028724;\n-\n-    /// 2.0/pi\n-    pub static frac_2_pi: float = 0.636619772367581343075535053490057448;\n-\n-    /// 2.0/sqrt(pi)\n-    pub static frac_2_sqrtpi: float = 1.12837916709551257389615890312154517;\n-\n-    /// sqrt(2.0)\n-    pub static sqrt2: float = 1.41421356237309504880168872420969808;\n-\n-    /// 1.0/sqrt(2.0)\n-    pub static frac_1_sqrt2: float = 0.707106781186547524400844362104849039;\n-\n-    /// Euler's number\n-    pub static e: float = 2.71828182845904523536028747135266250;\n-\n-    /// log2(e)\n-    pub static log2_e: float = 1.44269504088896340735992468100189214;\n-\n-    /// log10(e)\n-    pub static log10_e: float = 0.434294481903251827651128918916605082;\n-\n-    /// ln(2.0)\n-    pub static ln_2: float = 0.693147180559945309417232121458176568;\n-\n-    /// ln(10.0)\n-    pub static ln_10: float = 2.30258509299404568401799145468436421;\n-}\n-\n-//\n-// Section: String Conversions\n-//\n-\n-///\n-/// Converts a float to a string\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-///\n-#[inline]\n-pub fn to_str(num: float) -> ~str {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigAll);\n-    r\n-}\n-\n-///\n-/// Converts a float to a string in hexadecimal format\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-///\n-#[inline]\n-pub fn to_str_hex(num: float) -> ~str {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 16u, true, strconv::SignNeg, strconv::DigAll);\n-    r\n-}\n-\n-///\n-/// Converts a float to a string in a given radix, and a flag indicating\n-/// whether it's a special value\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * radix - The base to use\n-///\n-#[inline]\n-pub fn to_str_radix_special(num: float, radix: uint) -> (~str, bool) {\n-    strconv::float_to_str_common(num, radix, true,\n-                           strconv::SignNeg, strconv::DigAll)\n-}\n-\n-///\n-/// Converts a float to a string with exactly the number of\n-/// provided significant digits\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of significant digits\n-///\n-#[inline]\n-pub fn to_str_exact(num: float, digits: uint) -> ~str {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigExact(digits));\n-    r\n-}\n-\n-///\n-/// Converts a float to a string with a maximum number of\n-/// significant digits\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of significant digits\n-///\n-#[inline]\n-pub fn to_str_digits(num: float, digits: uint) -> ~str {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigMax(digits));\n-    r\n-}\n-\n-impl to_str::ToStr for float {\n-    #[inline]\n-    fn to_str(&self) -> ~str { to_str_digits(*self, 8) }\n-}\n-\n-impl num::ToStrRadix for float {\n-    /// Converts a float to a string in a given radix\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * num - The float value\n-    /// * radix - The base to use\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n-    /// possible misinterpretation of the result at higher bases. If those values\n-    /// are expected, use `to_str_radix_special()` instead.\n-    #[inline]\n-    fn to_str_radix(&self, radix: uint) -> ~str {\n-        let (r, special) = strconv::float_to_str_common(\n-            *self, radix, true, strconv::SignNeg, strconv::DigAll);\n-        if special { fail2!(\"number has a special value, \\\n-                             try to_str_radix_special() if those are expected\") }\n-        r\n-    }\n-}\n-\n-///\n-/// Convert a string in base 16 to a float.\n-/// Accepts a optional binary exponent.\n-///\n-/// This function accepts strings such as\n-///\n-/// * 'a4.fe'\n-/// * '+a4.fe', equivalent to 'a4.fe'\n-/// * '-a4.fe'\n-/// * '2b.aP128', or equivalently, '2b.ap128'\n-/// * '2b.aP-128'\n-/// * '.' (understood as 0)\n-/// * 'c.'\n-/// * '.c', or, equivalently,  '0.c'\n-/// * '+inf', 'inf', '-inf', 'NaN'\n-///\n-/// Leading and trailing whitespace represent an error.\n-///\n-/// # Arguments\n-///\n-/// * num - A string\n-///\n-/// # Return value\n-///\n-/// `none` if the string did not represent a valid number.  Otherwise,\n-/// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n-///\n-#[inline]\n-pub fn from_str_hex(num: &str) -> Option<float> {\n-    strconv::from_str_common(num, 16u, true, true, true,\n-                             strconv::ExpBin, false, false)\n-}\n-\n-impl FromStr for float {\n-    ///\n-    /// Convert a string in base 10 to a float.\n-    /// Accepts a optional decimal exponent.\n-    ///\n-    /// This function accepts strings such as\n-    ///\n-    /// * '3.14'\n-    /// * '+3.14', equivalent to '3.14'\n-    /// * '-3.14'\n-    /// * '2.5E10', or equivalently, '2.5e10'\n-    /// * '2.5E-10'\n-    /// * '.' (understood as 0)\n-    /// * '5.'\n-    /// * '.5', or, equivalently,  '0.5'\n-    /// * '+inf', 'inf', '-inf', 'NaN'\n-    ///\n-    /// Leading and trailing whitespace represent an error.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * num - A string\n-    ///\n-    /// # Return value\n-    ///\n-    /// `none` if the string did not represent a valid number.  Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `num`.\n-    ///\n-    #[inline]\n-    fn from_str(val: &str) -> Option<float> {\n-        strconv::from_str_common(val, 10u, true, true, true,\n-                                 strconv::ExpDec, false, false)\n-    }\n-}\n-\n-impl num::FromStrRadix for float {\n-    ///\n-    /// Convert a string in an given base to a float.\n-    ///\n-    /// Due to possible conflicts, this function does **not** accept\n-    /// the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n-    /// does it recognize exponents of any kind.\n-    ///\n-    /// Leading and trailing whitespace represent an error.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * num - A string\n-    /// * radix - The base to use. Must lie in the range [2 .. 36]\n-    ///\n-    /// # Return value\n-    ///\n-    /// `none` if the string did not represent a valid number. Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `num`.\n-    ///\n-    #[inline]\n-    fn from_str_radix(val: &str, radix: uint) -> Option<float> {\n-        strconv::from_str_common(val, radix, true, true, false,\n-                                 strconv::ExpNone, false, false)\n-    }\n-}\n-\n-//\n-// Section: Arithmetics\n-//\n-\n-///\n-/// Compute the exponentiation of an integer by another integer as a float\n-///\n-/// # Arguments\n-///\n-/// * x - The base\n-/// * pow - The exponent\n-///\n-/// # Return value\n-///\n-/// `NaN` if both `x` and `pow` are `0u`, otherwise `x^pow`\n-///\n-pub fn pow_with_uint(base: uint, pow: uint) -> float {\n-    if base == 0u {\n-        if pow == 0u {\n-            return NaN as float;\n-        }\n-        return 0.;\n-    }\n-    let mut my_pow     = pow;\n-    let mut total      = 1f;\n-    let mut multiplier = base as float;\n-    while (my_pow > 0u) {\n-        if my_pow % 2u == 1u {\n-            total = total * multiplier;\n-        }\n-        my_pow     /= 2u;\n-        multiplier *= multiplier;\n-    }\n-    return total;\n-}\n-\n-impl Num for float {}\n-\n-#[cfg(not(test))]\n-impl Eq for float {\n-    #[inline]\n-    fn eq(&self, other: &float) -> bool { (*self) == (*other) }\n-}\n-\n-#[cfg(not(test))]\n-impl ApproxEq<float> for float {\n-    #[inline]\n-    fn approx_epsilon() -> float { 1.0e-6 }\n-\n-    #[inline]\n-    fn approx_eq(&self, other: &float) -> bool {\n-        self.approx_eq_eps(other, &1.0e-6)\n-    }\n-\n-    #[inline]\n-    fn approx_eq_eps(&self, other: &float, approx_epsilon: &float) -> bool {\n-        (*self - *other).abs() < *approx_epsilon\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl Ord for float {\n-    #[inline]\n-    fn lt(&self, other: &float) -> bool { (*self) < (*other) }\n-    #[inline]\n-    fn le(&self, other: &float) -> bool { (*self) <= (*other) }\n-    #[inline]\n-    fn ge(&self, other: &float) -> bool { (*self) >= (*other) }\n-    #[inline]\n-    fn gt(&self, other: &float) -> bool { (*self) > (*other) }\n-}\n-\n-impl Orderable for float {\n-    /// Returns `NaN` if either of the numbers are `NaN`.\n-    #[inline]\n-    fn min(&self, other: &float) -> float {\n-        (*self as f64).min(&(*other as f64)) as float\n-    }\n-\n-    /// Returns `NaN` if either of the numbers are `NaN`.\n-    #[inline]\n-    fn max(&self, other: &float) -> float {\n-        (*self as f64).max(&(*other as f64)) as float\n-    }\n-\n-    /// Returns the number constrained within the range `mn <= self <= mx`.\n-    /// If any of the numbers are `NaN` then `NaN` is returned.\n-    #[inline]\n-    fn clamp(&self, mn: &float, mx: &float) -> float {\n-        (*self as f64).clamp(&(*mn as f64), &(*mx as f64)) as float\n-    }\n-}\n-\n-impl Default for float {\n-    #[inline]\n-    fn default() -> float { 0.0 }\n-}\n-\n-impl Zero for float {\n-    #[inline]\n-    fn zero() -> float { 0.0 }\n-\n-    /// Returns true if the number is equal to either `0.0` or `-0.0`\n-    #[inline]\n-    fn is_zero(&self) -> bool { *self == 0.0 || *self == -0.0 }\n-}\n-\n-impl One for float {\n-    #[inline]\n-    fn one() -> float { 1.0 }\n-}\n-\n-impl Round for float {\n-    /// Round half-way cases toward `neg_infinity`\n-    #[inline]\n-    fn floor(&self) -> float { (*self as f64).floor() as float }\n-\n-    /// Round half-way cases toward `infinity`\n-    #[inline]\n-    fn ceil(&self) -> float { (*self as f64).ceil() as float }\n-\n-    /// Round half-way cases away from `0.0`\n-    #[inline]\n-    fn round(&self) -> float { (*self as f64).round() as float }\n-\n-    /// The integer part of the number (rounds towards `0.0`)\n-    #[inline]\n-    fn trunc(&self) -> float { (*self as f64).trunc() as float }\n-\n-    ///\n-    /// The fractional part of the number, satisfying:\n-    ///\n-    /// ```rust\n-    /// assert!(x == trunc(x) + fract(x))\n-    /// ```\n-    ///\n-    #[inline]\n-    fn fract(&self) -> float { *self - self.trunc() }\n-}\n-\n-impl Fractional for float {\n-    /// The reciprocal (multiplicative inverse) of the number\n-    #[inline]\n-    fn recip(&self) -> float { 1.0 / *self }\n-}\n-\n-impl Algebraic for float {\n-    #[inline]\n-    fn pow(&self, n: &float) -> float {\n-        (*self as f64).pow(&(*n as f64)) as float\n-    }\n-\n-    #[inline]\n-    fn sqrt(&self) -> float {\n-        (*self as f64).sqrt() as float\n-    }\n-\n-    #[inline]\n-    fn rsqrt(&self) -> float {\n-        (*self as f64).rsqrt() as float\n-    }\n-\n-    #[inline]\n-    fn cbrt(&self) -> float {\n-        (*self as f64).cbrt() as float\n-    }\n-\n-    #[inline]\n-    fn hypot(&self, other: &float) -> float {\n-        (*self as f64).hypot(&(*other as f64)) as float\n-    }\n-}\n-\n-impl Trigonometric for float {\n-    #[inline]\n-    fn sin(&self) -> float {\n-        (*self as f64).sin() as float\n-    }\n-\n-    #[inline]\n-    fn cos(&self) -> float {\n-        (*self as f64).cos() as float\n-    }\n-\n-    #[inline]\n-    fn tan(&self) -> float {\n-        (*self as f64).tan() as float\n-    }\n-\n-    #[inline]\n-    fn asin(&self) -> float {\n-        (*self as f64).asin() as float\n-    }\n-\n-    #[inline]\n-    fn acos(&self) -> float {\n-        (*self as f64).acos() as float\n-    }\n-\n-    #[inline]\n-    fn atan(&self) -> float {\n-        (*self as f64).atan() as float\n-    }\n-\n-    #[inline]\n-    fn atan2(&self, other: &float) -> float {\n-        (*self as f64).atan2(&(*other as f64)) as float\n-    }\n-\n-    /// Simultaneously computes the sine and cosine of the number\n-    #[inline]\n-    fn sin_cos(&self) -> (float, float) {\n-        match (*self as f64).sin_cos() {\n-            (s, c) => (s as float, c as float)\n-        }\n-    }\n-}\n-\n-impl Exponential for float {\n-    /// Returns the exponential of the number\n-    #[inline]\n-    fn exp(&self) -> float {\n-        (*self as f64).exp() as float\n-    }\n-\n-    /// Returns 2 raised to the power of the number\n-    #[inline]\n-    fn exp2(&self) -> float {\n-        (*self as f64).exp2() as float\n-    }\n-\n-    /// Returns the natural logarithm of the number\n-    #[inline]\n-    fn ln(&self) -> float {\n-        (*self as f64).ln() as float\n-    }\n-\n-    /// Returns the logarithm of the number with respect to an arbitrary base\n-    #[inline]\n-    fn log(&self, base: &float) -> float {\n-        (*self as f64).log(&(*base as f64)) as float\n-    }\n-\n-    /// Returns the base 2 logarithm of the number\n-    #[inline]\n-    fn log2(&self) -> float {\n-        (*self as f64).log2() as float\n-    }\n-\n-    /// Returns the base 10 logarithm of the number\n-    #[inline]\n-    fn log10(&self) -> float {\n-        (*self as f64).log10() as float\n-    }\n-}\n-\n-impl Hyperbolic for float {\n-    #[inline]\n-    fn sinh(&self) -> float {\n-        (*self as f64).sinh() as float\n-    }\n-\n-    #[inline]\n-    fn cosh(&self) -> float {\n-        (*self as f64).cosh() as float\n-    }\n-\n-    #[inline]\n-    fn tanh(&self) -> float {\n-        (*self as f64).tanh() as float\n-    }\n-\n-    ///\n-    /// Inverse hyperbolic sine\n-    ///\n-    /// # Returns\n-    ///\n-    /// - on success, the inverse hyperbolic sine of `self` will be returned\n-    /// - `self` if `self` is `0.0`, `-0.0`, `infinity`, or `neg_infinity`\n-    /// - `NaN` if `self` is `NaN`\n-    ///\n-    #[inline]\n-    fn asinh(&self) -> float {\n-        (*self as f64).asinh() as float\n-    }\n-\n-    ///\n-    /// Inverse hyperbolic cosine\n-    ///\n-    /// # Returns\n-    ///\n-    /// - on success, the inverse hyperbolic cosine of `self` will be returned\n-    /// - `infinity` if `self` is `infinity`\n-    /// - `NaN` if `self` is `NaN` or `self < 1.0` (including `neg_infinity`)\n-    ///\n-    #[inline]\n-    fn acosh(&self) -> float {\n-        (*self as f64).acosh() as float\n-    }\n-\n-    ///\n-    /// Inverse hyperbolic tangent\n-    ///\n-    /// # Returns\n-    ///\n-    /// - on success, the inverse hyperbolic tangent of `self` will be returned\n-    /// - `self` if `self` is `0.0` or `-0.0`\n-    /// - `infinity` if `self` is `1.0`\n-    /// - `neg_infinity` if `self` is `-1.0`\n-    /// - `NaN` if the `self` is `NaN` or outside the domain of `-1.0 <= self <= 1.0`\n-    ///   (including `infinity` and `neg_infinity`)\n-    ///\n-    #[inline]\n-    fn atanh(&self) -> float {\n-        (*self as f64).atanh() as float\n-    }\n-}\n-\n-impl Real for float {\n-    /// Archimedes' constant\n-    #[inline]\n-    fn pi() -> float { 3.14159265358979323846264338327950288 }\n-\n-    /// 2.0 * pi\n-    #[inline]\n-    fn two_pi() -> float { 6.28318530717958647692528676655900576 }\n-\n-    /// pi / 2.0\n-    #[inline]\n-    fn frac_pi_2() -> float { 1.57079632679489661923132169163975144 }\n-\n-    /// pi / 3.0\n-    #[inline]\n-    fn frac_pi_3() -> float { 1.04719755119659774615421446109316763 }\n-\n-    /// pi / 4.0\n-    #[inline]\n-    fn frac_pi_4() -> float { 0.785398163397448309615660845819875721 }\n-\n-    /// pi / 6.0\n-    #[inline]\n-    fn frac_pi_6() -> float { 0.52359877559829887307710723054658381 }\n-\n-    /// pi / 8.0\n-    #[inline]\n-    fn frac_pi_8() -> float { 0.39269908169872415480783042290993786 }\n-\n-    /// 1.0 / pi\n-    #[inline]\n-    fn frac_1_pi() -> float { 0.318309886183790671537767526745028724 }\n-\n-    /// 2.0 / pi\n-    #[inline]\n-    fn frac_2_pi() -> float { 0.636619772367581343075535053490057448 }\n-\n-    /// 2 .0/ sqrt(pi)\n-    #[inline]\n-    fn frac_2_sqrtpi() -> float { 1.12837916709551257389615890312154517 }\n-\n-    /// sqrt(2.0)\n-    #[inline]\n-    fn sqrt2() -> float { 1.41421356237309504880168872420969808 }\n-\n-    /// 1.0 / sqrt(2.0)\n-    #[inline]\n-    fn frac_1_sqrt2() -> float { 0.707106781186547524400844362104849039 }\n-\n-    /// Euler's number\n-    #[inline]\n-    fn e() -> float { 2.71828182845904523536028747135266250 }\n-\n-    /// log2(e)\n-    #[inline]\n-    fn log2_e() -> float { 1.44269504088896340735992468100189214 }\n-\n-    /// log10(e)\n-    #[inline]\n-    fn log10_e() -> float { 0.434294481903251827651128918916605082 }\n-\n-    /// ln(2.0)\n-    #[inline]\n-    fn ln_2() -> float { 0.693147180559945309417232121458176568 }\n-\n-    /// ln(10.0)\n-    #[inline]\n-    fn ln_10() -> float { 2.30258509299404568401799145468436421 }\n-\n-    /// Converts to degrees, assuming the number is in radians\n-    #[inline]\n-    fn to_degrees(&self) -> float { (*self as f64).to_degrees() as float }\n-\n-    /// Converts to radians, assuming the number is in degrees\n-    #[inline]\n-    fn to_radians(&self) -> float { (*self as f64).to_radians() as float }\n-}\n-\n-impl RealExt for float {\n-    #[inline]\n-    fn lgamma(&self) -> (int, float) {\n-        let (sign, value) = (*self as f64).lgamma();\n-        (sign, value as float)\n-    }\n-\n-    #[inline]\n-    fn tgamma(&self) -> float { (*self as f64).tgamma() as float }\n-\n-    #[inline]\n-    fn j0(&self) -> float { (*self as f64).j0() as float }\n-\n-    #[inline]\n-    fn j1(&self) -> float { (*self as f64).j1() as float }\n-\n-    #[inline]\n-    fn jn(&self, n: int) -> float { (*self as f64).jn(n) as float }\n-\n-    #[inline]\n-    fn y0(&self) -> float { (*self as f64).y0() as float }\n-\n-    #[inline]\n-    fn y1(&self) -> float { (*self as f64).y1() as float }\n-\n-    #[inline]\n-    fn yn(&self, n: int) -> float { (*self as f64).yn(n) as float }\n-}\n-\n-#[cfg(not(test))]\n-impl Add<float,float> for float {\n-    #[inline]\n-    fn add(&self, other: &float) -> float { *self + *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Sub<float,float> for float {\n-    #[inline]\n-    fn sub(&self, other: &float) -> float { *self - *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Mul<float,float> for float {\n-    #[inline]\n-    fn mul(&self, other: &float) -> float { *self * *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Div<float,float> for float {\n-    #[inline]\n-    fn div(&self, other: &float) -> float { *self / *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Rem<float,float> for float {\n-    #[inline]\n-    fn rem(&self, other: &float) -> float { *self % *other }\n-}\n-#[cfg(not(test))]\n-impl Neg<float> for float {\n-    #[inline]\n-    fn neg(&self) -> float { -*self }\n-}\n-\n-impl Signed for float {\n-    /// Computes the absolute value. Returns `NaN` if the number is `NaN`.\n-    #[inline]\n-    fn abs(&self) -> float { (*self as f64).abs() as float }\n-\n-    ///\n-    /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n-    /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n-    ///\n-    #[inline]\n-    fn abs_sub(&self, other: &float) -> float {\n-        (*self as f64).abs_sub(&(*other as f64)) as float\n-    }\n-\n-    ///\n-    /// # Returns\n-    ///\n-    /// - `1.0` if the number is positive, `+0.0` or `infinity`\n-    /// - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n-    /// - `NaN` if the number is NaN\n-    ///\n-    #[inline]\n-    fn signum(&self) -> float {\n-        (*self as f64).signum() as float\n-    }\n-\n-    /// Returns `true` if the number is positive, including `+0.0` and `infinity`\n-    #[inline]\n-    fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == infinity }\n-\n-    /// Returns `true` if the number is negative, including `-0.0` and `neg_infinity`\n-    #[inline]\n-    fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == neg_infinity }\n-}\n-\n-impl Bounded for float {\n-    #[inline]\n-    fn min_value() -> float {\n-        let x: f64 = Bounded::min_value();\n-        x as float\n-    }\n-\n-    #[inline]\n-    fn max_value() -> float {\n-        let x: f64 = Bounded::max_value();\n-        x as float\n-    }\n-}\n-\n-impl Primitive for float {\n-    #[inline]\n-    fn bits(_: Option<float>) -> uint {\n-        let bits: uint = Primitive::bits(Some(0f64));\n-        bits\n-    }\n-\n-    #[inline]\n-    fn bytes(_: Option<float>) -> uint {\n-        let bytes: uint = Primitive::bytes(Some(0f64));\n-        bytes\n-    }\n-}\n-\n-impl Float for float {\n-    #[inline]\n-    fn nan() -> float {\n-        let value: f64 = Float::nan();\n-        value as float\n-    }\n-\n-    #[inline]\n-    fn infinity() -> float {\n-        let value: f64 = Float::infinity();\n-        value as float\n-    }\n-\n-    #[inline]\n-    fn neg_infinity() -> float {\n-        let value: f64 = Float::neg_infinity();\n-        value as float\n-    }\n-\n-    #[inline]\n-    fn neg_zero() -> float {\n-        let value: f64 = Float::neg_zero();\n-        value as float\n-    }\n-\n-    /// Returns `true` if the number is NaN\n-    #[inline]\n-    fn is_nan(&self) -> bool { (*self as f64).is_nan() }\n-\n-    /// Returns `true` if the number is infinite\n-    #[inline]\n-    fn is_infinite(&self) -> bool { (*self as f64).is_infinite() }\n-\n-    /// Returns `true` if the number is neither infinite or NaN\n-    #[inline]\n-    fn is_finite(&self) -> bool { (*self as f64).is_finite() }\n-\n-    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n-    #[inline]\n-    fn is_normal(&self) -> bool { (*self as f64).is_normal() }\n-\n-    /// Returns the floating point category of the number. If only one property is going to\n-    /// be tested, it is generally faster to use the specific predicate instead.\n-    #[inline]\n-    fn classify(&self) -> FPCategory { (*self as f64).classify() }\n-\n-    #[inline]\n-    fn mantissa_digits(_: Option<float>) -> uint {\n-        Float::mantissa_digits(Some(0f64))\n-    }\n-\n-    #[inline]\n-    fn digits(_: Option<float>) -> uint {\n-        Float::digits(Some(0f64))\n-    }\n-\n-    #[inline]\n-    fn epsilon() -> float {\n-        let value: f64 = Float::epsilon();\n-        value as float\n-    }\n-\n-    #[inline]\n-    fn min_exp(_: Option<float>) -> int {\n-        Float::min_exp(Some(0f64))\n-    }\n-\n-    #[inline]\n-    fn max_exp(_: Option<float>) -> int {\n-        Float::max_exp(Some(0f64))\n-    }\n-\n-    #[inline]\n-    fn min_10_exp(_: Option<float>) -> int {\n-        Float::min_10_exp(Some(0f64))\n-    }\n-\n-    #[inline]\n-    fn max_10_exp(_: Option<float>) -> int {\n-        Float::max_10_exp(Some(0f64))\n-    }\n-\n-    /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n-    #[inline]\n-    fn ldexp(x: float, exp: int) -> float {\n-        let value: f64 = Float::ldexp(x as f64, exp);\n-        value as float\n-    }\n-\n-    ///\n-    /// Breaks the number into a normalized fraction and a base-2 exponent, satisfying:\n-    ///\n-    /// - `self = x * pow(2, exp)`\n-    /// - `0.5 <= abs(x) < 1.0`\n-    ///\n-    #[inline]\n-    fn frexp(&self) -> (float, int) {\n-        match (*self as f64).frexp() {\n-            (x, exp) => (x as float, exp)\n-        }\n-    }\n-\n-    ///\n-    /// Returns the exponential of the number, minus `1`, in a way that is accurate\n-    /// even if the number is close to zero\n-    ///\n-    #[inline]\n-    fn exp_m1(&self) -> float {\n-        (*self as f64).exp_m1() as float\n-    }\n-\n-    ///\n-    /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n-    /// than if the operations were performed separately\n-    ///\n-    #[inline]\n-    fn ln_1p(&self) -> float {\n-        (*self as f64).ln_1p() as float\n-    }\n-\n-    ///\n-    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n-    /// produces a more accurate result with better performance than a separate multiplication\n-    /// operation followed by an add.\n-    ///\n-    #[inline]\n-    fn mul_add(&self, a: float, b: float) -> float {\n-        (*self as f64).mul_add(a as f64, b as f64) as float\n-    }\n-\n-    /// Returns the next representable floating-point value in the direction of `other`\n-    #[inline]\n-    fn next_after(&self, other: float) -> float {\n-        (*self as f64).next_after(other as f64) as float\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use super::*;\n-\n-    use num::*;\n-    use num;\n-    use sys;\n-\n-    #[test]\n-    fn test_num() {\n-        num::test_num(10f, 2f);\n-    }\n-\n-    #[test]\n-    fn test_min() {\n-        assert_eq!(1f.min(&2f), 1f);\n-        assert_eq!(2f.min(&1f), 1f);\n-    }\n-\n-    #[test]\n-    fn test_max() {\n-        assert_eq!(1f.max(&2f), 2f);\n-        assert_eq!(2f.max(&1f), 2f);\n-    }\n-\n-    #[test]\n-    fn test_clamp() {\n-        assert_eq!(1f.clamp(&2f, &4f), 2f);\n-        assert_eq!(8f.clamp(&2f, &4f), 4f);\n-        assert_eq!(3f.clamp(&2f, &4f), 3f);\n-        let nan: float = Float::nan();\n-        assert!(3f.clamp(&nan, &4f).is_nan());\n-        assert!(3f.clamp(&2f, &nan).is_nan());\n-        assert!(nan.clamp(&2f, &4f).is_nan());\n-    }\n-\n-    #[test]\n-    fn test_floor() {\n-        assert_approx_eq!(1.0f.floor(), 1.0f);\n-        assert_approx_eq!(1.3f.floor(), 1.0f);\n-        assert_approx_eq!(1.5f.floor(), 1.0f);\n-        assert_approx_eq!(1.7f.floor(), 1.0f);\n-        assert_approx_eq!(0.0f.floor(), 0.0f);\n-        assert_approx_eq!((-0.0f).floor(), -0.0f);\n-        assert_approx_eq!((-1.0f).floor(), -1.0f);\n-        assert_approx_eq!((-1.3f).floor(), -2.0f);\n-        assert_approx_eq!((-1.5f).floor(), -2.0f);\n-        assert_approx_eq!((-1.7f).floor(), -2.0f);\n-    }\n-\n-    #[test]\n-    fn test_ceil() {\n-        assert_approx_eq!(1.0f.ceil(), 1.0f);\n-        assert_approx_eq!(1.3f.ceil(), 2.0f);\n-        assert_approx_eq!(1.5f.ceil(), 2.0f);\n-        assert_approx_eq!(1.7f.ceil(), 2.0f);\n-        assert_approx_eq!(0.0f.ceil(), 0.0f);\n-        assert_approx_eq!((-0.0f).ceil(), -0.0f);\n-        assert_approx_eq!((-1.0f).ceil(), -1.0f);\n-        assert_approx_eq!((-1.3f).ceil(), -1.0f);\n-        assert_approx_eq!((-1.5f).ceil(), -1.0f);\n-        assert_approx_eq!((-1.7f).ceil(), -1.0f);\n-    }\n-\n-    #[test]\n-    fn test_round() {\n-        assert_approx_eq!(1.0f.round(), 1.0f);\n-        assert_approx_eq!(1.3f.round(), 1.0f);\n-        assert_approx_eq!(1.5f.round(), 2.0f);\n-        assert_approx_eq!(1.7f.round(), 2.0f);\n-        assert_approx_eq!(0.0f.round(), 0.0f);\n-        assert_approx_eq!((-0.0f).round(), -0.0f);\n-        assert_approx_eq!((-1.0f).round(), -1.0f);\n-        assert_approx_eq!((-1.3f).round(), -1.0f);\n-        assert_approx_eq!((-1.5f).round(), -2.0f);\n-        assert_approx_eq!((-1.7f).round(), -2.0f);\n-    }\n-\n-    #[test]\n-    fn test_trunc() {\n-        assert_approx_eq!(1.0f.trunc(), 1.0f);\n-        assert_approx_eq!(1.3f.trunc(), 1.0f);\n-        assert_approx_eq!(1.5f.trunc(), 1.0f);\n-        assert_approx_eq!(1.7f.trunc(), 1.0f);\n-        assert_approx_eq!(0.0f.trunc(), 0.0f);\n-        assert_approx_eq!((-0.0f).trunc(), -0.0f);\n-        assert_approx_eq!((-1.0f).trunc(), -1.0f);\n-        assert_approx_eq!((-1.3f).trunc(), -1.0f);\n-        assert_approx_eq!((-1.5f).trunc(), -1.0f);\n-        assert_approx_eq!((-1.7f).trunc(), -1.0f);\n-    }\n-\n-    #[test]\n-    fn test_fract() {\n-        assert_approx_eq!(1.0f.fract(), 0.0f);\n-        assert_approx_eq!(1.3f.fract(), 0.3f);\n-        assert_approx_eq!(1.5f.fract(), 0.5f);\n-        assert_approx_eq!(1.7f.fract(), 0.7f);\n-        assert_approx_eq!(0.0f.fract(), 0.0f);\n-        assert_approx_eq!((-0.0f).fract(), -0.0f);\n-        assert_approx_eq!((-1.0f).fract(), -0.0f);\n-        assert_approx_eq!((-1.3f).fract(), -0.3f);\n-        assert_approx_eq!((-1.5f).fract(), -0.5f);\n-        assert_approx_eq!((-1.7f).fract(), -0.7f);\n-    }\n-\n-    #[test]\n-    fn test_asinh() {\n-        assert_eq!(0.0f.asinh(), 0.0f);\n-        assert_eq!((-0.0f).asinh(), -0.0f);\n-\n-        let inf: float = Float::infinity();\n-        let neg_inf: float = Float::neg_infinity();\n-        let nan: float = Float::nan();\n-        assert_eq!(inf.asinh(), inf);\n-        assert_eq!(neg_inf.asinh(), neg_inf);\n-        assert!(nan.asinh().is_nan());\n-        assert_approx_eq!(2.0f.asinh(), 1.443635475178810342493276740273105f);\n-        assert_approx_eq!((-2.0f).asinh(), -1.443635475178810342493276740273105f);\n-    }\n-\n-    #[test]\n-    fn test_acosh() {\n-        assert_eq!(1.0f.acosh(), 0.0f);\n-        assert!(0.999f.acosh().is_nan());\n-\n-        let inf: float = Float::infinity();\n-        let neg_inf: float = Float::neg_infinity();\n-        let nan: float = Float::nan();\n-        assert_eq!(inf.acosh(), inf);\n-        assert!(neg_inf.acosh().is_nan());\n-        assert!(nan.acosh().is_nan());\n-        assert_approx_eq!(2.0f.acosh(), 1.31695789692481670862504634730796844f);\n-        assert_approx_eq!(3.0f.acosh(), 1.76274717403908605046521864995958461f);\n-    }\n-\n-    #[test]\n-    fn test_atanh() {\n-        assert_eq!(0.0f.atanh(), 0.0f);\n-        assert_eq!((-0.0f).atanh(), -0.0f);\n-\n-        let inf: float = Float::infinity();\n-        let neg_inf: float = Float::neg_infinity();\n-        let inf64: f64 = Float::infinity();\n-        let neg_inf64: f64 = Float::neg_infinity();\n-        let nan: float = Float::nan();\n-        assert_eq!(1.0f.atanh(), inf);\n-        assert_eq!((-1.0f).atanh(), neg_inf);\n-        assert!(2f64.atanh().atanh().is_nan());\n-        assert!((-2f64).atanh().atanh().is_nan());\n-        assert!(inf64.atanh().is_nan());\n-        assert!(neg_inf64.atanh().is_nan());\n-        assert!(nan.atanh().is_nan());\n-        assert_approx_eq!(0.5f.atanh(), 0.54930614433405484569762261846126285f);\n-        assert_approx_eq!((-0.5f).atanh(), -0.54930614433405484569762261846126285f);\n-    }\n-\n-    #[test]\n-    fn test_real_consts() {\n-        let pi: float = Real::pi();\n-        let two_pi: float = Real::two_pi();\n-        let frac_pi_2: float = Real::frac_pi_2();\n-        let frac_pi_3: float = Real::frac_pi_3();\n-        let frac_pi_4: float = Real::frac_pi_4();\n-        let frac_pi_6: float = Real::frac_pi_6();\n-        let frac_pi_8: float = Real::frac_pi_8();\n-        let frac_1_pi: float = Real::frac_1_pi();\n-        let frac_2_pi: float = Real::frac_2_pi();\n-        let frac_2_sqrtpi: float = Real::frac_2_sqrtpi();\n-        let sqrt2: float = Real::sqrt2();\n-        let frac_1_sqrt2: float = Real::frac_1_sqrt2();\n-        let e: float = Real::e();\n-        let log2_e: float = Real::log2_e();\n-        let log10_e: float = Real::log10_e();\n-        let ln_2: float = Real::ln_2();\n-        let ln_10: float = Real::ln_10();\n-\n-        assert_approx_eq!(two_pi, 2f * pi);\n-        assert_approx_eq!(frac_pi_2, pi / 2f);\n-        assert_approx_eq!(frac_pi_3, pi / 3f);\n-        assert_approx_eq!(frac_pi_4, pi / 4f);\n-        assert_approx_eq!(frac_pi_6, pi / 6f);\n-        assert_approx_eq!(frac_pi_8, pi / 8f);\n-        assert_approx_eq!(frac_1_pi, 1f / pi);\n-        assert_approx_eq!(frac_2_pi, 2f / pi);\n-        assert_approx_eq!(frac_2_sqrtpi, 2f / pi.sqrt());\n-        assert_approx_eq!(sqrt2, 2f.sqrt());\n-        assert_approx_eq!(frac_1_sqrt2, 1f / 2f.sqrt());\n-        assert_approx_eq!(log2_e, e.log2());\n-        assert_approx_eq!(log10_e, e.log10());\n-        assert_approx_eq!(ln_2, 2f.ln());\n-        assert_approx_eq!(ln_10, 10f.ln());\n-    }\n-\n-    #[test]\n-    fn test_abs() {\n-        assert_eq!(infinity.abs(), infinity);\n-        assert_eq!(1f.abs(), 1f);\n-        assert_eq!(0f.abs(), 0f);\n-        assert_eq!((-0f).abs(), 0f);\n-        assert_eq!((-1f).abs(), 1f);\n-        assert_eq!(neg_infinity.abs(), infinity);\n-        assert_eq!((1f/neg_infinity).abs(), 0f);\n-        assert!(NaN.abs().is_nan());\n-    }\n-\n-    #[test]\n-    fn test_abs_sub() {\n-        assert_eq!((-1f).abs_sub(&1f), 0f);\n-        assert_eq!(1f.abs_sub(&1f), 0f);\n-        assert_eq!(1f.abs_sub(&0f), 1f);\n-        assert_eq!(1f.abs_sub(&-1f), 2f);\n-        assert_eq!(neg_infinity.abs_sub(&0f), 0f);\n-        assert_eq!(infinity.abs_sub(&1f), infinity);\n-        assert_eq!(0f.abs_sub(&neg_infinity), infinity);\n-        assert_eq!(0f.abs_sub(&infinity), 0f);\n-    }\n-\n-    #[test] #[ignore(cfg(windows))] // FIXME #8663\n-    fn test_abs_sub_nowin() {\n-        assert!(NaN.abs_sub(&-1f).is_nan());\n-        assert!(1f.abs_sub(&NaN).is_nan());\n-    }\n-\n-    #[test]\n-    fn test_signum() {\n-        assert_eq!(infinity.signum(), 1f);\n-        assert_eq!(1f.signum(), 1f);\n-        assert_eq!(0f.signum(), 1f);\n-        assert_eq!((-0f).signum(), -1f);\n-        assert_eq!((-1f).signum(), -1f);\n-        assert_eq!(neg_infinity.signum(), -1f);\n-        assert_eq!((1f/neg_infinity).signum(), -1f);\n-        assert!(NaN.signum().is_nan());\n-    }\n-\n-    #[test]\n-    fn test_is_positive() {\n-        assert!(infinity.is_positive());\n-        assert!(1f.is_positive());\n-        assert!(0f.is_positive());\n-        assert!(!(-0f).is_positive());\n-        assert!(!(-1f).is_positive());\n-        assert!(!neg_infinity.is_positive());\n-        assert!(!(1f/neg_infinity).is_positive());\n-        assert!(!NaN.is_positive());\n-    }\n-\n-    #[test]\n-    fn test_is_negative() {\n-        assert!(!infinity.is_negative());\n-        assert!(!1f.is_negative());\n-        assert!(!0f.is_negative());\n-        assert!((-0f).is_negative());\n-        assert!((-1f).is_negative());\n-        assert!(neg_infinity.is_negative());\n-        assert!((1f/neg_infinity).is_negative());\n-        assert!(!NaN.is_negative());\n-    }\n-\n-    #[test]\n-    fn test_approx_eq() {\n-        assert!(1.0f.approx_eq(&1f));\n-        assert!(0.9999999f.approx_eq(&1f));\n-        assert!(1.000001f.approx_eq_eps(&1f, &1.0e-5));\n-        assert!(1.0000001f.approx_eq_eps(&1f, &1.0e-6));\n-        assert!(!1.0000001f.approx_eq_eps(&1f, &1.0e-7));\n-    }\n-\n-    #[test]\n-    fn test_primitive() {\n-        let none: Option<float> = None;\n-        assert_eq!(Primitive::bits(none), sys::size_of::<float>() * 8);\n-        assert_eq!(Primitive::bytes(none), sys::size_of::<float>());\n-    }\n-\n-    #[test]\n-    fn test_is_normal() {\n-        let nan: float = Float::nan();\n-        let inf: float = Float::infinity();\n-        let neg_inf: float = Float::neg_infinity();\n-        let zero: float = Zero::zero();\n-        let neg_zero: float = Float::neg_zero();\n-        assert!(!nan.is_normal());\n-        assert!(!inf.is_normal());\n-        assert!(!neg_inf.is_normal());\n-        assert!(!zero.is_normal());\n-        assert!(!neg_zero.is_normal());\n-        assert!(1f.is_normal());\n-        assert!(1e-307f.is_normal());\n-        assert!(!1e-308f.is_normal());\n-    }\n-\n-    #[test]\n-    fn test_classify() {\n-        let nan: float = Float::nan();\n-        let inf: float = Float::infinity();\n-        let neg_inf: float = Float::neg_infinity();\n-        let zero: float = Zero::zero();\n-        let neg_zero: float = Float::neg_zero();\n-        assert_eq!(nan.classify(), FPNaN);\n-        assert_eq!(inf.classify(), FPInfinite);\n-        assert_eq!(neg_inf.classify(), FPInfinite);\n-        assert_eq!(zero.classify(), FPZero);\n-        assert_eq!(neg_zero.classify(), FPZero);\n-        assert_eq!(1f.classify(), FPNormal);\n-        assert_eq!(1e-307f.classify(), FPNormal);\n-        assert_eq!(1e-308f.classify(), FPSubnormal);\n-    }\n-\n-    #[test]\n-    fn test_ldexp() {\n-        // We have to use from_str until base-2 exponents\n-        // are supported in floating-point literals\n-        let f1: float = from_str_hex(\"1p-123\").unwrap();\n-        let f2: float = from_str_hex(\"1p-111\").unwrap();\n-        assert_eq!(Float::ldexp(1f, -123), f1);\n-        assert_eq!(Float::ldexp(1f, -111), f2);\n-\n-        assert_eq!(Float::ldexp(0f, -123), 0f);\n-        assert_eq!(Float::ldexp(-0f, -123), -0f);\n-\n-        let inf: float = Float::infinity();\n-        let neg_inf: float = Float::neg_infinity();\n-        let nan: float = Float::nan();\n-        assert_eq!(Float::ldexp(inf, -123), inf);\n-        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n-        assert!(Float::ldexp(nan, -123).is_nan());\n-    }\n-\n-    #[test]\n-    fn test_frexp() {\n-        // We have to use from_str until base-2 exponents\n-        // are supported in floating-point literals\n-        let f1: float = from_str_hex(\"1p-123\").unwrap();\n-        let f2: float = from_str_hex(\"1p-111\").unwrap();\n-        let (x1, exp1) = f1.frexp();\n-        let (x2, exp2) = f2.frexp();\n-        assert_eq!((x1, exp1), (0.5f, -122));\n-        assert_eq!((x2, exp2), (0.5f, -110));\n-        assert_eq!(Float::ldexp(x1, exp1), f1);\n-        assert_eq!(Float::ldexp(x2, exp2), f2);\n-\n-        assert_eq!(0f.frexp(), (0f, 0));\n-        assert_eq!((-0f).frexp(), (-0f, 0));\n-    }\n-\n-    #[test] #[ignore(cfg(windows))] // FIXME #8755\n-    fn test_frexp_nowin() {\n-        let inf: float = Float::infinity();\n-        let neg_inf: float = Float::neg_infinity();\n-        let nan: float = Float::nan();\n-        assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n-        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n-        assert!(match nan.frexp() { (x, _) => x.is_nan() })\n-    }\n-\n-    #[test]\n-    pub fn test_to_str_exact_do_decimal() {\n-        let s = to_str_exact(5.0, 4u);\n-        assert_eq!(s, ~\"5.0000\");\n-    }\n-\n-    #[test]\n-    pub fn test_from_str() {\n-        assert_eq!(from_str::<float>(\"3\"), Some(3.));\n-        assert_eq!(from_str::<float>(\"3.14\"), Some(3.14));\n-        assert_eq!(from_str::<float>(\"+3.14\"), Some(3.14));\n-        assert_eq!(from_str::<float>(\"-3.14\"), Some(-3.14));\n-        assert_eq!(from_str::<float>(\"2.5E10\"), Some(25000000000.));\n-        assert_eq!(from_str::<float>(\"2.5e10\"), Some(25000000000.));\n-        assert_eq!(from_str::<float>(\"25000000000.E-10\"), Some(2.5));\n-        assert_eq!(from_str::<float>(\".\"), Some(0.));\n-        assert_eq!(from_str::<float>(\".e1\"), Some(0.));\n-        assert_eq!(from_str::<float>(\".e-1\"), Some(0.));\n-        assert_eq!(from_str::<float>(\"5.\"), Some(5.));\n-        assert_eq!(from_str::<float>(\".5\"), Some(0.5));\n-        assert_eq!(from_str::<float>(\"0.5\"), Some(0.5));\n-        assert_eq!(from_str::<float>(\"-.5\"), Some(-0.5));\n-        assert_eq!(from_str::<float>(\"-5\"), Some(-5.));\n-        assert_eq!(from_str::<float>(\"inf\"), Some(infinity));\n-        assert_eq!(from_str::<float>(\"+inf\"), Some(infinity));\n-        assert_eq!(from_str::<float>(\"-inf\"), Some(neg_infinity));\n-        // note: NaN != NaN, hence this slightly complex test\n-        match from_str::<float>(\"NaN\") {\n-            Some(f) => assert!(f.is_nan()),\n-            None => fail2!()\n-        }\n-        // note: -0 == 0, hence these slightly more complex tests\n-        match from_str::<float>(\"-0\") {\n-            Some(v) if v.is_zero() => assert!(v.is_negative()),\n-            _ => fail2!()\n-        }\n-        match from_str::<float>(\"0\") {\n-            Some(v) if v.is_zero() => assert!(v.is_positive()),\n-            _ => fail2!()\n-        }\n-\n-        assert!(from_str::<float>(\"\").is_none());\n-        assert!(from_str::<float>(\"x\").is_none());\n-        assert!(from_str::<float>(\" \").is_none());\n-        assert!(from_str::<float>(\"   \").is_none());\n-        assert!(from_str::<float>(\"e\").is_none());\n-        assert!(from_str::<float>(\"E\").is_none());\n-        assert!(from_str::<float>(\"E1\").is_none());\n-        assert!(from_str::<float>(\"1e1e1\").is_none());\n-        assert!(from_str::<float>(\"1e1.1\").is_none());\n-        assert!(from_str::<float>(\"1e1-1\").is_none());\n-    }\n-\n-    #[test]\n-    pub fn test_from_str_hex() {\n-        assert_eq!(from_str_hex(\"a4\"), Some(164.));\n-        assert_eq!(from_str_hex(\"a4.fe\"), Some(164.9921875));\n-        assert_eq!(from_str_hex(\"-a4.fe\"), Some(-164.9921875));\n-        assert_eq!(from_str_hex(\"+a4.fe\"), Some(164.9921875));\n-        assert_eq!(from_str_hex(\"ff0P4\"), Some(0xff00 as float));\n-        assert_eq!(from_str_hex(\"ff0p4\"), Some(0xff00 as float));\n-        assert_eq!(from_str_hex(\"ff0p-4\"), Some(0xff as float));\n-        assert_eq!(from_str_hex(\".\"), Some(0.));\n-        assert_eq!(from_str_hex(\".p1\"), Some(0.));\n-        assert_eq!(from_str_hex(\".p-1\"), Some(0.));\n-        assert_eq!(from_str_hex(\"f.\"), Some(15.));\n-        assert_eq!(from_str_hex(\".f\"), Some(0.9375));\n-        assert_eq!(from_str_hex(\"0.f\"), Some(0.9375));\n-        assert_eq!(from_str_hex(\"-.f\"), Some(-0.9375));\n-        assert_eq!(from_str_hex(\"-f\"), Some(-15.));\n-        assert_eq!(from_str_hex(\"inf\"), Some(infinity));\n-        assert_eq!(from_str_hex(\"+inf\"), Some(infinity));\n-        assert_eq!(from_str_hex(\"-inf\"), Some(neg_infinity));\n-        // note: NaN != NaN, hence this slightly complex test\n-        match from_str_hex(\"NaN\") {\n-            Some(f) => assert!(f.is_nan()),\n-            None => fail2!()\n-        }\n-        // note: -0 == 0, hence these slightly more complex tests\n-        match from_str_hex(\"-0\") {\n-            Some(v) if v.is_zero() => assert!(v.is_negative()),\n-            _ => fail2!()\n-        }\n-        match from_str_hex(\"0\") {\n-            Some(v) if v.is_zero() => assert!(v.is_positive()),\n-            _ => fail2!()\n-        }\n-        assert_eq!(from_str_hex(\"e\"), Some(14.));\n-        assert_eq!(from_str_hex(\"E\"), Some(14.));\n-        assert_eq!(from_str_hex(\"E1\"), Some(225.));\n-        assert_eq!(from_str_hex(\"1e1e1\"), Some(123361.));\n-        assert_eq!(from_str_hex(\"1e1.1\"), Some(481.0625));\n-\n-        assert!(from_str_hex(\"\").is_none());\n-        assert!(from_str_hex(\"x\").is_none());\n-        assert!(from_str_hex(\" \").is_none());\n-        assert!(from_str_hex(\"   \").is_none());\n-        assert!(from_str_hex(\"p\").is_none());\n-        assert!(from_str_hex(\"P\").is_none());\n-        assert!(from_str_hex(\"P1\").is_none());\n-        assert!(from_str_hex(\"1p1p1\").is_none());\n-        assert!(from_str_hex(\"1p1.1\").is_none());\n-        assert!(from_str_hex(\"1p1-1\").is_none());\n-    }\n-\n-    #[test]\n-    pub fn test_to_str_hex() {\n-        assert_eq!(to_str_hex(164.), ~\"a4\");\n-        assert_eq!(to_str_hex(164.9921875), ~\"a4.fe\");\n-        assert_eq!(to_str_hex(-164.9921875), ~\"-a4.fe\");\n-        assert_eq!(to_str_hex(0xff00 as float), ~\"ff00\");\n-        assert_eq!(to_str_hex(-(0xff00 as float)), ~\"-ff00\");\n-        assert_eq!(to_str_hex(0.), ~\"0\");\n-        assert_eq!(to_str_hex(15.), ~\"f\");\n-        assert_eq!(to_str_hex(-15.), ~\"-f\");\n-        assert_eq!(to_str_hex(0.9375), ~\"0.f\");\n-        assert_eq!(to_str_hex(-0.9375), ~\"-0.f\");\n-        assert_eq!(to_str_hex(infinity), ~\"inf\");\n-        assert_eq!(to_str_hex(neg_infinity), ~\"-inf\");\n-        assert_eq!(to_str_hex(NaN), ~\"NaN\");\n-        assert_eq!(to_str_hex(0.), ~\"0\");\n-        assert_eq!(to_str_hex(-0.), ~\"-0\");\n-    }\n-\n-    #[test]\n-    pub fn test_to_str_radix() {\n-        assert_eq!(36.0f.to_str_radix(36u), ~\"10\");\n-        assert_eq!(8.125f.to_str_radix(2u), ~\"1000.001\");\n-    }\n-\n-    #[test]\n-    pub fn test_from_str_radix() {\n-        assert_eq!(from_str_radix(\"10\", 36u), Some(36.));\n-        assert_eq!(from_str_radix(\"1000.001\", 2u), Some(8.125));\n-    }\n-\n-    #[test]\n-    pub fn test_to_str_inf() {\n-        assert_eq!(to_str_digits(infinity, 10u), ~\"inf\");\n-        assert_eq!(to_str_digits(-infinity, 10u), ~\"-inf\");\n-    }\n-}"}, {"sha": "95b1057dfd08052daf00844e3d3ea4992deb531d", "filename": "src/libstd/num/num.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibstd%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibstd%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fnum.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -385,7 +385,6 @@ pub trait NumCast {\n \n     fn to_f32(&self) -> f32;\n     fn to_f64(&self) -> f64;\n-    fn to_float(&self) -> float;\n }\n \n macro_rules! impl_num_cast(\n@@ -412,7 +411,6 @@ macro_rules! impl_num_cast(\n \n             #[inline] fn to_f32(&self)   -> f32   { *self as f32   }\n             #[inline] fn to_f64(&self)   -> f64   { *self as f64   }\n-            #[inline] fn to_float(&self) -> float { *self as float }\n         }\n     )\n )\n@@ -429,7 +427,6 @@ impl_num_cast!(i64,   to_i64)\n impl_num_cast!(int,   to_int)\n impl_num_cast!(f32,   to_f32)\n impl_num_cast!(f64,   to_f64)\n-impl_num_cast!(float, to_float)\n \n pub trait ToStrRadix {\n     fn to_str_radix(&self, radix: uint) -> ~str;\n@@ -579,7 +576,6 @@ mod tests {\n             assert_eq!(20i16, _20.to_i16());\n             assert_eq!(20i32, _20.to_i32());\n             assert_eq!(20i64, _20.to_i64());\n-            assert_eq!(20f,   _20.to_float());\n             assert_eq!(20f32, _20.to_f32());\n             assert_eq!(20f64, _20.to_f64());\n \n@@ -593,7 +589,6 @@ mod tests {\n             assert_eq!(_20, NumCast::from(20i16));\n             assert_eq!(_20, NumCast::from(20i32));\n             assert_eq!(_20, NumCast::from(20i64));\n-            assert_eq!(_20, NumCast::from(20f));\n             assert_eq!(_20, NumCast::from(20f32));\n             assert_eq!(_20, NumCast::from(20f64));\n \n@@ -607,7 +602,6 @@ mod tests {\n             assert_eq!(_20, cast(20i16));\n             assert_eq!(_20, cast(20i32));\n             assert_eq!(_20, cast(20i64));\n-            assert_eq!(_20, cast(20f));\n             assert_eq!(_20, cast(20f32));\n             assert_eq!(_20, cast(20f64));\n         })\n@@ -625,7 +619,6 @@ mod tests {\n     #[test] fn test_int_cast()   { test_cast_20!(20i)   }\n     #[test] fn test_f32_cast()   { test_cast_20!(20f32) }\n     #[test] fn test_f64_cast()   { test_cast_20!(20f64) }\n-    #[test] fn test_float_cast() { test_cast_20!(20f)   }\n \n     #[test]\n     fn test_saturating_add_uint() {"}, {"sha": "c45d77dad9d46bdc1d4acabb07fda39f15e07085", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -83,7 +83,6 @@ macro_rules! impl_NumStrConv_Integer (($t:ty) => (\n \n // FIXME: #4955\n // Replace by two generic impls for traits 'Integral' and 'Floating'\n-impl_NumStrConv_Floating!(float)\n impl_NumStrConv_Floating!(f32)\n impl_NumStrConv_Floating!(f64)\n \n@@ -735,8 +734,8 @@ mod test {\n mod bench {\n     use extra::test::BenchHarness;\n     use rand::{XorShiftRng, Rng};\n-    use float;\n     use to_str::ToStr;\n+    use f64;\n \n     #[bench]\n     fn uint_to_str_rand(bh: &mut BenchHarness) {\n@@ -750,7 +749,7 @@ mod bench {\n     fn float_to_str_rand(bh: &mut BenchHarness) {\n         let mut rng = XorShiftRng::new();\n         do bh.iter {\n-            float::to_str(rng.gen());\n+            f64::to_str(rng.gen());\n         }\n     }\n }"}, {"sha": "5a7708b7fb224f88f022e5db89029e30ebc362a1", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -14,7 +14,7 @@ Random number generation.\n The key functions are `random()` and `Rng::gen()`. These are polymorphic\n and so can be used to generate any type that implements `Rand`. Type inference\n means that often a simple call to `rand::random()` or `rng.gen()` will\n-suffice, but sometimes an annotation is required, e.g. `rand::random::<float>()`.\n+suffice, but sometimes an annotation is required, e.g. `rand::random::<f64>()`.\n \n See the `distributions` submodule for sampling random numbers from\n distributions like normal and exponential.\n@@ -145,13 +145,6 @@ impl Rand for u64 {\n     }\n }\n \n-impl Rand for float {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> float {\n-        rng.gen::<f64>() as float\n-    }\n-}\n-\n impl Rand for f32 {\n     #[inline]\n     fn rand<R: Rng>(rng: &mut R) -> f32 {\n@@ -271,7 +264,7 @@ pub trait Rng {\n     ///    let rng = rand::task_rng();\n     ///    let x: uint = rng.gen();\n     ///    println!(\"{}\", x);\n-    ///    println!(\"{:?}\", rng.gen::<(float, bool)>());\n+    ///    println!(\"{:?}\", rng.gen::<(f64, bool)>());\n     /// }\n     /// ```\n     #[inline(always)]\n@@ -290,7 +283,7 @@ pub trait Rng {\n     ///    let rng = rand::task_rng();\n     ///    let x: ~[uint] = rng.gen_vec(10);\n     ///    println!(\"{:?}\", x);\n-    ///    println!(\"{:?}\", rng.gen_vec::<(float, bool)>(5));\n+    ///    println!(\"{:?}\", rng.gen_vec::<(f64, bool)>(5));\n     /// }\n     /// ```\n     fn gen_vec<T: Rand>(&mut self, len: uint) -> ~[T] {\n@@ -936,10 +929,10 @@ mod test {\n     }\n \n     #[test]\n-    fn test_gen_float() {\n+    fn test_gen_f64() {\n         let mut r = rng();\n-        let a = r.gen::<float>();\n-        let b = r.gen::<float>();\n+        let a = r.gen::<f64>();\n+        let b = r.gen::<f64>();\n         debug2!(\"{:?}\", (a, b));\n     }\n \n@@ -1049,7 +1042,7 @@ mod test {\n         let _many : ((),\n                      (~uint, @int, ~Option<~(@u32, ~(@bool,))>),\n                      (u8, i8, u16, i16, u32, i32, u64, i64),\n-                     (f32, (f64, (float,)))) = random();\n+                     (f32, (f64, (f64,)))) = random();\n     }\n \n     #[test]"}, {"sha": "00b2b308c6f9a72775bda611be20123dec63100d", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -166,6 +166,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n+    #[cfg(stage0)]\n     fn visit_float(&mut self) -> bool {\n         self.align_to::<float>();\n         if ! self.inner.visit_float() { return false; }"}, {"sha": "f5a481785ddb9d3de918a9d6888451f8d104d02b", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -78,13 +78,6 @@ int_repr!(u16, \"u16\")\n int_repr!(u32, \"u32\")\n int_repr!(u64, \"u64\")\n \n-impl Repr for float {\n-    fn write_repr(&self, writer: &mut io::Writer) {\n-        let s = self.to_str();\n-        writer.write(s.as_bytes());\n-    }\n-}\n-\n macro_rules! num_repr(($ty:ident, $suffix:expr) => (impl Repr for $ty {\n     fn write_repr(&self, writer: &mut io::Writer) {\n         let s = self.to_str();\n@@ -278,7 +271,8 @@ impl<'self> TyVisitor for ReprVisitor<'self> {\n     fn visit_u32(&mut self) -> bool { self.write::<u32>() }\n     fn visit_u64(&mut self) -> bool { self.write::<u64>() }\n \n-    fn visit_float(&mut self) -> bool { self.write::<float>() }\n+    #[cfg(stage0)]\n+    fn visit_float(&mut self) -> bool { self.write::<f64>() }\n     fn visit_f32(&mut self) -> bool { self.write::<f32>() }\n     fn visit_f64(&mut self) -> bool { self.write::<f64>() }\n \n@@ -632,7 +626,7 @@ pub fn write_repr<T>(writer: &mut io::Writer, object: &T) {\n }\n \n #[cfg(test)]\n-struct P {a: int, b: float}\n+struct P {a: int, b: f64}\n \n #[test]\n fn test_repr() {\n@@ -653,7 +647,7 @@ fn test_repr() {\n     exact_test(&10, \"10\");\n     exact_test(&true, \"true\");\n     exact_test(&false, \"false\");\n-    exact_test(&1.234, \"1.234\");\n+    exact_test(&1.234, \"1.234f64\");\n     exact_test(&(&\"hello\"), \"\\\"hello\\\"\");\n     exact_test(&(@\"hello\"), \"@\\\"hello\\\"\");\n     exact_test(&(~\"he\\u10f3llo\"), \"~\\\"he\\\\u10f3llo\\\"\");\n@@ -682,11 +676,11 @@ fn test_repr() {\n     exact_test(&(&[\"hi\", \"there\"]),\n                \"&[\\\"hi\\\", \\\"there\\\"]\");\n     exact_test(&(P{a:10, b:1.234}),\n-               \"repr::P{a: 10, b: 1.234}\");\n+               \"repr::P{a: 10, b: 1.234f64}\");\n     exact_test(&(@P{a:10, b:1.234}),\n-               \"@repr::P{a: 10, b: 1.234}\");\n+               \"@repr::P{a: 10, b: 1.234f64}\");\n     exact_test(&(~P{a:10, b:1.234}),\n-               \"~repr::P{a: 10, b: 1.234}\");\n+               \"~repr::P{a: 10, b: 1.234f64}\");\n     exact_test(&(10u8, ~\"hello\"),\n                \"(10u8, ~\\\"hello\\\")\");\n     exact_test(&(10u16, ~\"hello\"),"}, {"sha": "ece623fab247e2190e64a0d7990238c5931aa018", "filename": "src/libstd/std.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -109,7 +109,6 @@ pub mod prelude;\n #[path = \"num/u32.rs\"]  pub mod u32;\n #[path = \"num/u64.rs\"]  pub mod u64;\n \n-#[path = \"num/float.rs\"] pub mod float;\n #[path = \"num/f32.rs\"]   pub mod f32;\n #[path = \"num/f64.rs\"]   pub mod f64;\n "}, {"sha": "4d5da19dafda97a78bdae78fe3ccd96b487cd1e3", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -198,13 +198,6 @@ impl IterBytes for int {\n     }\n }\n \n-impl IterBytes for float {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        (*self as f64).iter_bytes(lsb0, f)\n-    }\n-}\n-\n impl IterBytes for f32 {\n     #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {"}, {"sha": "0131f2c603cdac5c72392bb50e0a5010a5ecfab3", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -480,7 +480,7 @@ pub mod ct {\n #[doc(hidden)]\n #[allow(non_uppercase_statics)]\n pub mod rt {\n-    use float;\n+    use f64;\n     use str;\n     use sys;\n     use num;\n@@ -563,10 +563,10 @@ pub mod rt {\n         };\n         pad(cv, unpadded, None, PadNozero, buf);\n     }\n-    pub fn conv_float(cv: Conv, f: float, buf: &mut ~str) {\n+    pub fn conv_float(cv: Conv, f: f64, buf: &mut ~str) {\n         let (to_str, digits) = match cv.precision {\n-              CountIs(c) => (float::to_str_exact, c as uint),\n-              CountImplied => (float::to_str_digits, 6u)\n+              CountIs(c) => (f64::to_str_exact, c as uint),\n+              CountImplied => (f64::to_str_digits, 6u)\n         };\n         let s = to_str(f, digits);\n         let head = if 0.0 <= f {"}, {"sha": "190ac9da7fd30163abbb20b70726715dbe62c603", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -94,6 +94,7 @@ pub trait TyVisitor {\n     fn visit_u32(&mut self) -> bool;\n     fn visit_u64(&mut self) -> bool;\n \n+    #[cfg(stage0)]\n     fn visit_float(&mut self) -> bool;\n     fn visit_f32(&mut self) -> bool;\n     fn visit_f64(&mut self) -> bool;"}, {"sha": "5056bd5a00d9b653da43b8f9ecdbe5202ee50311", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -765,7 +765,6 @@ impl ToStr for uint_ty {\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum float_ty {\n-    ty_f,\n     ty_f32,\n     ty_f64,\n }"}, {"sha": "12ad7111f7f4038ee3eace5b2fb891ebdd5190aa", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -190,7 +190,7 @@ pub fn uint_ty_max(t: uint_ty) -> u64 {\n }\n \n pub fn float_ty_to_str(t: float_ty) -> ~str {\n-    match t { ty_f => ~\"f\", ty_f32 => ~\"f32\", ty_f64 => ~\"f64\" }\n+    match t { ty_f32 => ~\"f32\", ty_f64 => ~\"f64\" }\n }\n \n pub fn is_call_expr(e: @Expr) -> bool {"}, {"sha": "bfd1e9cc9943a6d58d913a3b20d8156f0dbf4f2e", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -446,7 +446,6 @@ fn mk_token(cx: @ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n \n         LIT_FLOAT(fident, fty) => {\n             let s_fty = match fty {\n-                ast::ty_f => ~\"ty_f\",\n                 ast::ty_f32 => ~\"ty_f32\",\n                 ast::ty_f64 => ~\"ty_f64\"\n             };"}, {"sha": "4a384f864b09d6c495c72be8ee63e258f453ebc6", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -530,7 +530,6 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n       None => ()\n     }\n \n-    let mut is_machine_float = false;\n     if rdr.curr == 'f' {\n         bump(rdr);\n         c = rdr.curr;\n@@ -549,14 +548,10 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n             32-bit or 64-bit float, it won't be noticed till the\n             back-end.  */\n         } else {\n-            is_float = true;\n-            is_machine_float = true;\n+            fatal_span(rdr, start_bpos, rdr.last_pos, ~\"expected `f32` or `f64` suffix\");\n         }\n     }\n     if is_float {\n-        if is_machine_float {\n-            return token::LIT_FLOAT(str_to_ident(num_str), ast::ty_f);\n-        }\n         return token::LIT_FLOAT_UNSUFFIXED(str_to_ident(num_str));\n     } else {\n         if num_str.len() == 0u {"}, {"sha": "0cbd4378490d935676323ae250dc91f22f4c8d07", "filename": "src/test/auxiliary/static_fn_inline_xc_aux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fauxiliary%2Fstatic_fn_inline_xc_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fauxiliary%2Fstatic_fn_inline_xc_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic_fn_inline_xc_aux.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -15,9 +15,9 @@ pub mod num {\n     }\n }\n \n-pub mod float {\n-    impl ::num::Num2 for float {\n+pub mod f64 {\n+    impl ::num::Num2 for f64 {\n         #[inline]\n-        fn from_int2(n: int) -> float { return n as float;  }\n+        fn from_int2(n: int) -> f64 { return n as f64;  }\n     }\n }"}, {"sha": "a0c9edac5e146bb31259a877010f1cd326194cd5", "filename": "src/test/auxiliary/static_fn_trait_xc_aux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fauxiliary%2Fstatic_fn_trait_xc_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fauxiliary%2Fstatic_fn_trait_xc_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic_fn_trait_xc_aux.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -4,8 +4,8 @@ pub mod num {\n     }\n }\n \n-pub mod float {\n-    impl ::num::Num2 for float {\n-        fn from_int2(n: int) -> float { return n as float;  }\n+pub mod f64 {\n+    impl ::num::Num2 for f64 {\n+        fn from_int2(n: int) -> f64 { return n as f64;  }\n     }\n }"}, {"sha": "123ad24e7a91ecc3a035bf0312a9f87bb638dfd0", "filename": "src/test/auxiliary/trait_default_method_xc_aux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fauxiliary%2Ftrait_default_method_xc_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fauxiliary%2Ftrait_default_method_xc_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_default_method_xc_aux.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -23,7 +23,7 @@ trait B<T> {\n }\n \n impl<T> B<T> for int { }\n-impl B<float> for bool { }\n+impl B<f64> for bool { }\n \n \n "}, {"sha": "569f22d364417282aa1ed5b22913d7d373b143a7", "filename": "src/test/auxiliary/xc_conditions_4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fauxiliary%2Fxc_conditions_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fauxiliary%2Fxc_conditions_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fxc_conditions_4.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -16,7 +16,7 @@ pub enum Color {\n }\n \n condition! {\n-    pub oops: (int,float,~str) -> Color;\n+    pub oops: (int,f64,~str) -> Color;\n }\n \n pub trait Thunk<T> {"}, {"sha": "138d5795ae1881b4847d172de11d05921adbd5b4", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -19,16 +19,16 @@ use std::rand;\n use std::uint;\n \n struct Results {\n-    sequential_ints: float,\n-    random_ints: float,\n-    delete_ints: float,\n+    sequential_ints: f64,\n+    random_ints: f64,\n+    delete_ints: f64,\n \n-    sequential_strings: float,\n-    random_strings: float,\n-    delete_strings: float\n+    sequential_strings: f64,\n+    random_strings: f64,\n+    delete_strings: f64\n }\n \n-fn timed(result: &mut float, op: &fn()) {\n+fn timed(result: &mut f64, op: &fn()) {\n     let start = extra::time::precise_time_s();\n     op();\n     let end = extra::time::precise_time_s();\n@@ -127,7 +127,7 @@ fn write_header(header: &str) {\n     io::stdout().write_str(\"\\n\");\n }\n \n-fn write_row(label: &str, value: float) {\n+fn write_row(label: &str, value: f64) {\n     io::stdout().write_str(format!(\"{:30s} {} s\\n\", label, value));\n }\n \n@@ -143,13 +143,13 @@ fn write_results(label: &str, results: &Results) {\n \n fn empty_results() -> Results {\n     Results {\n-        sequential_ints: 0f,\n-        random_ints: 0f,\n-        delete_ints: 0f,\n+        sequential_ints: 0.0,\n+        random_ints: 0.0,\n+        delete_ints: 0.0,\n \n-        sequential_strings: 0f,\n-        random_strings: 0f,\n-        delete_strings: 0f,\n+        sequential_strings: 0.0,\n+        random_strings: 0.0,\n+        delete_strings: 0.0,\n     }\n }\n "}, {"sha": "054b985a55ce24cb56dc4d31b7374e563d8b914d", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -55,7 +55,7 @@ fn maybe_run_test(argv: &[~str], name: ~str, test: &fn()) {\n     test();\n     let stop = precise_time_s();\n \n-    println!(\"{}:\\t\\t{} ms\", name, (stop - start) * 1000f);\n+    println!(\"{}:\\t\\t{} ms\", name, (stop - start) * 1000.0);\n }\n \n fn shift_push() {"}, {"sha": "83bb6a37e929ca87f69fbf60ca96aa37e72b9033", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -92,7 +92,7 @@ fn run(args: &[~str]) {\n     let elapsed = end - start;\n     io::stdout().write_str(format!(\"Count is {:?}\\n\", result));\n     io::stdout().write_str(format!(\"Test took {:?} seconds\\n\", elapsed));\n-    let thruput = ((size / workers * workers) as float) / (elapsed as float);\n+    let thruput = ((size / workers * workers) as f64) / (elapsed as f64);\n     io::stdout().write_str(format!(\"Throughput={} per sec\\n\", thruput));\n     assert_eq!(result, num_bytes * size);\n }"}, {"sha": "ad727318753747172cf4d434d6b988374a6eebe1", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -86,7 +86,7 @@ fn run(args: &[~str]) {\n     let elapsed = end - start;\n     io::stdout().write_str(format!(\"Count is {:?}\\n\", result));\n     io::stdout().write_str(format!(\"Test took {:?} seconds\\n\", elapsed));\n-    let thruput = ((size / workers * workers) as float) / (elapsed as float);\n+    let thruput = ((size / workers * workers) as f64) / (elapsed as f64);\n     io::stdout().write_str(format!(\"Throughput={} per sec\\n\", thruput));\n     assert_eq!(result, num_bytes * size);\n }"}, {"sha": "e4d45c6b74a9a05a74e61c3193c34f798ccb2c0a", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -116,7 +116,7 @@ fn main() {\n     // all done, report stats.\n     let num_msgs = num_tasks * msg_per_task;\n     let elapsed = (stop - start);\n-    let rate = (num_msgs as float) / elapsed;\n+    let rate = (num_msgs as f64) / elapsed;\n \n     println!(\"Sent {} messages in {} seconds\", num_msgs, elapsed);\n     println!(\"  {} messages / second\", rate);"}, {"sha": "d326fd81518eef2db11af6ac1f2c840685acf27a", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -112,7 +112,7 @@ fn main() {\n     // all done, report stats.\n     let num_msgs = num_tasks * msg_per_task;\n     let elapsed = (stop - start);\n-    let rate = (num_msgs as float) / elapsed;\n+    let rate = (num_msgs as f64) / elapsed;\n \n     println!(\"Sent {} messages in {} seconds\", num_msgs, elapsed);\n     println!(\"  {} messages / second\", rate);"}, {"sha": "a424c880c385fc453eaa9e9d4e423d37c7be6e5d", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -1,6 +1,6 @@\n // Perlin noise benchmark from https://gist.github.com/1170424\n \n-use std::float;\n+use std::f64;\n use std::rand::Rng;\n use std::rand;\n \n@@ -16,7 +16,7 @@ fn lerp(a: f32, b: f32, v: f32) -> f32 { a * (1.0 - v) + b * v }\n fn smooth(v: f32) -> f32 { v * v * (3.0 - 2.0 * v) }\n \n fn random_gradient<R:Rng>(r: &mut R) -> Vec2 {\n-    let v = 2.0 * float::consts::pi * r.gen();\n+    let v = 2.0 * f64::consts::pi * r.gen();\n     Vec2 {\n         x: v.cos() as f32,\n         y: v.sin() as f32,"}, {"sha": "3b8bd444c170b1638788f2cdc95e45c23b03f8f4", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -29,8 +29,8 @@ use std::vec;\n \n // given a map, print a sorted version of it\n fn sort_and_fmt(mm: &HashMap<~[u8], uint>, total: uint) -> ~str {\n-   fn pct(xx: uint, yy: uint) -> float {\n-      return (xx as float) * 100f / (yy as float);\n+   fn pct(xx: uint, yy: uint) -> f64 {\n+      return (xx as f64) * 100.0 / (yy as f64);\n    }\n \n    fn le_by_val<TT:Clone,"}, {"sha": "be2bd051cad868fb66c5758fcceba8ee02060f6c", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -53,11 +53,11 @@ fn main() {\n         check_sequential(0u, max, &map);\n         let end = extra::time::precise_time_s();\n \n-        checkf += (end - mid) as float;\n-        appendf += (mid - start) as float;\n+        checkf += (end - mid) as f64;\n+        appendf += (mid - start) as f64;\n     }\n \n-    let maxf = max as float;\n+    let maxf = max as f64;\n \n     io::stdout().write_str(format!(\"insert(): {:?} seconds\\n\", checkf));\n     io::stdout().write_str(format!(\"        : {} op/sec\\n\", maxf/checkf));"}, {"sha": "f9f4ccf0f07519e9a0e7a2fe1286de1cb4d184b3", "filename": "src/test/compile-fail/bad-mid-path-type-params.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -29,9 +29,9 @@ impl Trait<int> for S2 {\n }\n \n fn main() {\n-    let _ = S::new::<int,float>(1, 1.0);    //~ ERROR the impl referenced by this path has 1 type parameter, but 0 type parameters were supplied\n-    let _ = S::<'self,int>::new::<float>(1, 1.0);  //~ ERROR this impl has no lifetime parameter\n-    let _: S2 = Trait::new::<int,float>(1, 1.0);    //~ ERROR the trait referenced by this path has 1 type parameter, but 0 type parameters were supplied\n-    let _: S2 = Trait::<'self,int>::new::<float>(1, 1.0);   //~ ERROR this trait has no lifetime parameter\n+    let _ = S::new::<int,f64>(1, 1.0);    //~ ERROR the impl referenced by this path has 1 type parameter, but 0 type parameters were supplied\n+    let _ = S::<'self,int>::new::<f64>(1, 1.0);  //~ ERROR this impl has no lifetime parameter\n+    let _: S2 = Trait::new::<int,f64>(1, 1.0);    //~ ERROR the trait referenced by this path has 1 type parameter, but 0 type parameters were supplied\n+    let _: S2 = Trait::<'self,int>::new::<f64>(1, 1.0);   //~ ERROR this trait has no lifetime parameter\n }\n "}, {"sha": "71a0b8b7a8e85b45db9f18facab153fc1334333c", "filename": "src/test/compile-fail/block-arg-as-stmt-with-value.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn compute1() -> float {\n-    let v = ~[0f, 1f, 2f, 3f];\n+fn compute1() -> f64 {\n+    let v = ~[0f64, 1.0, 2.0, 3.0];\n \n-    do v.iter().fold(0f) |x, y| { x + *y } - 10f\n+    do v.iter().fold(0.0) |x, y| { x + *y } - 10.0\n     //~^ ERROR mismatched types: expected `()`\n }\n \n fn main() {\n     let x = compute1();\n     info2!(\"{:?}\", x);\n-    assert_eq!(x, -4f);\n+    assert_eq!(x, -4f64);\n }"}, {"sha": "9d9dd5b1ad8bdbe8d6640dfc0ca05e43a0d680a2", "filename": "src/test/compile-fail/borrowck-loan-local-as-both-mut-and-imm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -10,7 +10,7 @@\n \n use std::either::{Either, Left, Right};\n \n-    fn f(x: &mut Either<int,float>, y: &Either<int,float>) -> int {\n+    fn f(x: &mut Either<int,f64>, y: &Either<int,f64>) -> int {\n         match *y {\n             Left(ref z) => {\n                 *x = Right(1.0);\n@@ -21,14 +21,14 @@ use std::either::{Either, Left, Right};\n     }\n \n     fn g() {\n-        let mut x: Either<int,float> = Left(3);\n+        let mut x: Either<int,f64> = Left(3);\n         println(f(&mut x, &x).to_str()); //~ ERROR cannot borrow\n     }\n \n     fn h() {\n-        let mut x: Either<int,float> = Left(3);\n-        let y: &Either<int, float> = &x;\n-        let z: &mut Either<int, float> = &mut x; //~ ERROR cannot borrow\n+        let mut x: Either<int,f64> = Left(3);\n+        let y: &Either<int, f64> = &x;\n+        let z: &mut Either<int, f64> = &mut x; //~ ERROR cannot borrow\n         *z = *y;\n     }\n "}, {"sha": "1e58df69f166496c20b7c995d26e3328d1a8cafe", "filename": "src/test/compile-fail/float-literal-inference-restrictions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fcompile-fail%2Ffloat-literal-inference-restrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fcompile-fail%2Ffloat-literal-inference-restrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffloat-literal-inference-restrictions.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -10,5 +10,5 @@\n \n fn main() {\n     let x: f32 = 1; //~ ERROR mismatched types\n-    let y: f32 = 1f; //~ ERROR mismatched types\n+    let y: f32 = 1f64; //~ ERROR mismatched types\n }"}, {"sha": "f8f4b0608a57e461797a33fd344edec9ee050859", "filename": "src/test/compile-fail/issue-3973.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -12,12 +12,12 @@\n use std::io;\n \n struct Point {\n-    x: float,\n-    y: float,\n+    x: f64,\n+    y: f64,\n }\n \n impl ToStr for Point { //~ ERROR implements a method not defined in the trait\n-    fn new(x: float, y: float) -> Point {\n+    fn new(x: f64, y: f64) -> Point {\n         Point { x: x, y: y }\n     }\n "}, {"sha": "6bc9f7d1b2a6a1f29dfcd83caa5cef144d1ff56e", "filename": "src/test/compile-fail/issue-6804.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -1,6 +1,6 @@\n // Matching against NaN should result in a warning\n \n-use std::float::NaN;\n+use std::f64::NaN;\n \n fn main() {\n     let x = NaN;"}, {"sha": "0347c673779446ce68aa575d2016aac0ff42f156", "filename": "src/test/compile-fail/lint-unused-import-tricky-names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fcompile-fail%2Flint-unused-import-tricky-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fcompile-fail%2Flint-unused-import-tricky-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-import-tricky-names.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -19,7 +19,7 @@ mod issue6633 {\n         pub mod name {\n             pub type a = int;\n             pub mod name {\n-                pub type a = float;\n+                pub type a = f64;\n             }\n         }\n     }"}, {"sha": "463ad958f11b66aca3494f1301d9f4e37e3ddb6e", "filename": "src/test/compile-fail/macro-local-data-key-priv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fcompile-fail%2Fmacro-local-data-key-priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fcompile-fail%2Fmacro-local-data-key-priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-local-data-key-priv.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -13,7 +13,7 @@ use std::local_data;\n // check that the local data keys are private by default.\n \n mod bar {\n-    local_data_key!(baz: float)\n+    local_data_key!(baz: f64)\n }\n \n fn main() {"}, {"sha": "2e207f90d36cdc31f1d965f8362649b3845127bc", "filename": "src/test/compile-fail/no-binary-float-literal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fcompile-fail%2Fno-binary-float-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fcompile-fail%2Fno-binary-float-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-binary-float-literal.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -11,7 +11,7 @@\n // error-pattern:binary float literal is not supported\n \n fn main() {\n-    0b101010f;\n+    0b101010f64;\n     0b101.010;\n-    0b101p4f;\n+    0b101p4f64;\n }"}, {"sha": "0587e033a97891792241c1779d35b038fa838e55", "filename": "src/test/compile-fail/prim-with-args.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fcompile-fail%2Fprim-with-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fcompile-fail%2Fprim-with-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprim-with-args.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -20,7 +20,6 @@ let x: u8<int>; //~ ERROR type parameters are not allowed on this type\n let x: u16<int>; //~ ERROR type parameters are not allowed on this type\n let x: u32<int>; //~ ERROR type parameters are not allowed on this type\n let x: u64<int>; //~ ERROR type parameters are not allowed on this type\n-let x: float<int>; //~ ERROR type parameters are not allowed on this type\n let x: char<int>; //~ ERROR type parameters are not allowed on this type\n \n let x: int<'static>; //~ ERROR lifetime parameters are not allowed on this type\n@@ -33,7 +32,6 @@ let x: u8<'static>; //~ ERROR lifetime parameters are not allowed on this type\n let x: u16<'static>; //~ ERROR lifetime parameters are not allowed on this type\n let x: u32<'static>; //~ ERROR lifetime parameters are not allowed on this type\n let x: u64<'static>; //~ ERROR lifetime parameters are not allowed on this type\n-let x: float<'static>; //~ ERROR lifetime parameters are not allowed on this type\n let x: char<'static>; //~ ERROR lifetime parameters are not allowed on this type\n \n }"}, {"sha": "2d7ff386b7cc116f4549f9cf2e8e55b0f6fe336b", "filename": "src/test/compile-fail/syntax-extension-bytes-unsupported-literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-unsupported-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-unsupported-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-unsupported-literal.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    let vec = bytes!(45f); //~ ERROR Unsupported literal in bytes!\n+    let vec = bytes!(45f64); //~ ERROR Unsupported literal in bytes!\n }"}, {"sha": "60184464085a50254e3809b4c382647962d6ec53", "filename": "src/test/compile-fail/tuple-arity-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fcompile-fail%2Ftuple-arity-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fcompile-fail%2Ftuple-arity-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftuple-arity-mismatch.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -10,7 +10,7 @@\n \n // Issue #6155\n \n-fn first((value, _): (int, float)) -> int { value }\n+fn first((value, _): (int, f64)) -> int { value }\n \n fn main() {\n     let y = first ((1,2,3)); //~ ERROR expected a tuple with 2 elements but found one with 3 elements"}, {"sha": "010d3aada3dcbb75b150176af68059559ae99076", "filename": "src/test/debug-info/basic-types.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fbasic-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fbasic-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fbasic-types.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -42,12 +42,10 @@\n // check:$11 = 32\n // debugger:print u64\n // check:$12 = 64\n-// debugger:print f\n-// check:$13 = 1.5\n // debugger:print f32\n-// check:$14 = 2.5\n+// check:$13 = 2.5\n // debugger:print f64\n-// check:$15 = 3.5\n+// check:$14 = 3.5\n \n #[allow(unused_variable)];\n \n@@ -64,7 +62,6 @@ fn main() {\n     let u16: u16 = 16;\n     let u32: u32 = 32;\n     let u64: u64 = 64;\n-    let f: float = 1.5;\n     let f32: f32 = 2.5;\n     let f64: f64 = 3.5;\n     _zzz();"}, {"sha": "cdc4ce51b877b42a3a784d111719af179729b1c2", "filename": "src/test/debug-info/borrowed-basic.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fborrowed-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fborrowed-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fborrowed-basic.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -51,14 +51,11 @@\n // debugger:print *u64_ref\n // check:$12 = 64\n \n-// debugger:print *float_ref\n-// check:$13 = 1.5\n-\n // debugger:print *f32_ref\n-// check:$14 = 2.5\n+// check:$13 = 2.5\n \n // debugger:print *f64_ref\n-// check:$15 = 3.5\n+// check:$14 = 3.5\n \n #[allow(unused_variable)];\n \n@@ -99,9 +96,6 @@ fn main() {\n     let u64_val: u64 = 64;\n     let u64_ref: &u64 = &u64_val;\n \n-    let float_val: float = 1.5;\n-    let float_ref: &float = &float_val;\n-\n     let f32_val: f32 = 2.5;\n     let f32_ref: &f32 = &f32_val;\n "}, {"sha": "917db045edbcce6b50bbc19f2ae0d4d5626822c6", "filename": "src/test/debug-info/borrowed-managed-basic.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fborrowed-managed-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fborrowed-managed-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fborrowed-managed-basic.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -51,14 +51,11 @@\n // debugger:print *u64_ref\n // check:$12 = 64\n \n-// debugger:print *float_ref\n-// check:$13 = 1.5\n-\n // debugger:print *f32_ref\n-// check:$14 = 2.5\n+// check:$13 = 2.5\n \n // debugger:print *f64_ref\n-// check:$15 = 3.5\n+// check:$14 = 3.5\n \n #[allow(unused_variable)];\n \n@@ -99,9 +96,6 @@ fn main() {\n     let u64_box: @u64 = @64;\n     let u64_ref: &u64 = u64_box;\n \n-    let float_box: @float = @1.5;\n-    let float_ref: &float = float_box;\n-\n     let f32_box: @f32 = @2.5;\n     let f32_ref: &f32 = f32_box;\n "}, {"sha": "48ac507b04d0d43ed791d51953d581b55faa9fac", "filename": "src/test/debug-info/borrowed-unique-basic.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fborrowed-unique-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fborrowed-unique-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fborrowed-unique-basic.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -51,14 +51,11 @@\n // debugger:print *u64_ref\n // check:$12 = 64\n \n-// debugger:print *float_ref\n-// check:$13 = 1.5\n-\n // debugger:print *f32_ref\n-// check:$14 = 2.5\n+// check:$13 = 2.5\n \n // debugger:print *f64_ref\n-// check:$15 = 3.5\n+// check:$14 = 3.5\n \n #[allow(unused_variable)];\n \n@@ -100,9 +97,6 @@ fn main() {\n     let u64_box: ~u64 = ~64;\n     let u64_ref: &u64 = u64_box;\n \n-    let float_box: ~float = ~1.5;\n-    let float_ref: &float = float_box;\n-\n     let f32_box: ~f32 = ~2.5;\n     let f32_ref: &f32 = f32_box;\n "}, {"sha": "6ea0e0b12a3f5835c952d4a841dce03c7d8f2f09", "filename": "src/test/debug-info/by-value-non-immediate-argument.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fby-value-non-immediate-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fby-value-non-immediate-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fby-value-non-immediate-argument.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -44,7 +44,7 @@\n #[deriving(Clone)]\n struct Struct {\n     a: int,\n-    b: float\n+    b: f64\n }\n \n #[deriving(Clone)]\n@@ -61,11 +61,11 @@ fn fun_fun(StructStruct { a: x, b: Struct { a: y, b: z } }: StructStruct) {\n     zzz();\n }\n \n-fn tup(a: (int, uint, float, float)) {\n+fn tup(a: (int, uint, f64, f64)) {\n     zzz();\n }\n \n-struct Newtype(float, float, int, uint);\n+struct Newtype(f64, f64, int, uint);\n \n fn new_type(a: Newtype) {\n     zzz();"}, {"sha": "2a5d75be8b3b07b7e21382dccda6a778d18520dc", "filename": "src/test/debug-info/by-value-self-argument-in-trait-impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fby-value-self-argument-in-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fby-value-self-argument-in-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fby-value-self-argument-in-trait-impl.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -55,8 +55,8 @@ impl Trait for Struct {\n     }\n }\n \n-impl Trait for (float, int, int, float) {\n-    fn method(self) -> (float, int, int, float) {\n+impl Trait for (f64, int, int, f64) {\n+    fn method(self) -> (f64, int, int, f64) {\n         zzz();\n         self\n     }"}, {"sha": "3e139966ff186b520459434c2a6b86d196431d10", "filename": "src/test/debug-info/destructured-fn-argument.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fdestructured-fn-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fdestructured-fn-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fdestructured-fn-argument.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -190,7 +190,7 @@ enum Univariant {\n     Unit(i32)\n }\n \n-struct TupleStruct (float, int);\n+struct TupleStruct (f64, int);\n \n \n fn simple_tuple((a, b): (int, bool)) {"}, {"sha": "d222ad8b914fa8e02420667bff2b5a531a4b6ae0", "filename": "src/test/debug-info/destructured-local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -134,7 +134,7 @@ enum Univariant {\n     Unit(i32)\n }\n \n-struct TupleStruct (float, int);\n+struct TupleStruct (f64, int);\n \n \n fn main() {"}, {"sha": "91bf29f55977aa1e3a49669eb18a349664bfd869", "filename": "src/test/debug-info/generic-function.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fgeneric-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fgeneric-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fgeneric-function.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -42,7 +42,7 @@\n #[deriving(Clone)]\n struct Struct {\n     a: int,\n-    b: float\n+    b: f64\n }\n \n fn dup_tup<T0: Clone, T1: Clone>(t0: &T0, t1: &T1) -> ((T0, T1), (T1, T0)) {"}, {"sha": "bea901a75d04084117bd0b36359c9be59d595881", "filename": "src/test/debug-info/generic-static-method-on-struct-and-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fgeneric-static-method-on-struct-and-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fgeneric-static-method-on-struct-and-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fgeneric-static-method-on-struct-and-enum.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -46,7 +46,7 @@ impl Struct {\n enum Enum {\n     Variant1 { x: int },\n     Variant2,\n-    Variant3(float, int, char),\n+    Variant3(f64, int, char),\n }\n \n impl Enum {"}, {"sha": "36aded40ca5e006d1dc7ef585fb5e2a945c9bd60", "filename": "src/test/debug-info/method-on-tuple-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fmethod-on-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fmethod-on-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fmethod-on-tuple-struct.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -92,7 +92,7 @@\n // check:$21 = -16\n // debugger:continue\n \n-struct TupleStruct(int, float);\n+struct TupleStruct(int, f64);\n \n impl TupleStruct {\n "}, {"sha": "e4b2e06faf4d17827c01b30fac0731bf579b6a94", "filename": "src/test/debug-info/static-method-on-struct-and-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fstatic-method-on-struct-and-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fstatic-method-on-struct-and-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fstatic-method-on-struct-and-enum.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -46,12 +46,12 @@ impl Struct {\n enum Enum {\n     Variant1 { x: int },\n     Variant2,\n-    Variant3(float, int, char),\n+    Variant3(f64, int, char),\n }\n \n impl Enum {\n \n-    fn static_method(arg1: int, arg2: float, arg3: uint) -> int {\n+    fn static_method(arg1: int, arg2: f64, arg3: uint) -> int {\n         zzz();\n         arg1\n     }"}, {"sha": "4bd22c151e4f4c0bb40c99ae14da6ee7a560fac6", "filename": "src/test/debug-info/trait-pointers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Ftrait-pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Ftrait-pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ftrait-pointers.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -19,7 +19,7 @@ trait Trait {\n \n struct Struct {\n     a: int,\n-    b: float\n+    b: f64\n }\n \n impl Trait for Struct {}"}, {"sha": "152ba57ddba16698fcae76cea1638e4cf32588e1", "filename": "src/test/debug-info/var-captured-in-nested-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fvar-captured-in-nested-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fvar-captured-in-nested-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvar-captured-in-nested-closure.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -50,7 +50,7 @@\n \n struct Struct {\n     a: int,\n-    b: float,\n+    b: f64,\n     c: uint\n }\n "}, {"sha": "efc93d135a28c6770aeb48eca542b90ec3947a47", "filename": "src/test/debug-info/var-captured-in-sendable-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fvar-captured-in-sendable-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fvar-captured-in-sendable-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvar-captured-in-sendable-closure.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -24,7 +24,7 @@\n \n struct Struct {\n     a: int,\n-    b: float,\n+    b: f64,\n     c: uint\n }\n "}, {"sha": "987d19911c497caab7e328f2ad556117cdff93ec", "filename": "src/test/debug-info/var-captured-in-stack-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fvar-captured-in-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Fdebug-info%2Fvar-captured-in-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvar-captured-in-stack-closure.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -30,7 +30,7 @@\n \n struct Struct {\n     a: int,\n-    b: float,\n+    b: f64,\n     c: uint\n }\n "}, {"sha": "8509bde6d2d0714b814d189481a0f4cd2742d0b2", "filename": "src/test/run-fail/assert-approx-eq-eps-macro-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-fail%2Fassert-approx-eq-eps-macro-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-fail%2Fassert-approx-eq-eps-macro-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fassert-approx-eq-eps-macro-fail.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:left: 1.0000001 does not approximately equal right: 1 with epsilon: 0.0000001\n+// error-pattern:left: 1.0000001f64 does not approximately equal right: 1f64 with epsilon: 0.0000001f64\n pub fn main() {\n-    assert_approx_eq!(1.0000001f, 1.0f, 1.0e-7);\n+    assert_approx_eq!(1.0000001f64, 1.0f64, 1.0e-7);\n }"}, {"sha": "60b6cb216d940f80c56a3ec27275e938c9dcc416", "filename": "src/test/run-fail/assert-approx-eq-macro-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-fail%2Fassert-approx-eq-macro-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-fail%2Fassert-approx-eq-macro-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fassert-approx-eq-macro-fail.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:left: 1.00001 does not approximately equal right: 1\n+// error-pattern:left: 1.00001f64 does not approximately equal right: 1f64\n pub fn main() {\n-    assert_approx_eq!(1.00001f, 1.0f);\n+    assert_approx_eq!(1.00001f64, 1.0);\n }"}, {"sha": "3ea1f896dff3125b745ba4c39e59060fbafb6fe3", "filename": "src/test/run-pass/assert-approx-eq-macro-success.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fassert-approx-eq-macro-success.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fassert-approx-eq-macro-success.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassert-approx-eq-macro-success.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n pub fn main() {\n-    assert_approx_eq!(1.0f, 1.0f);\n-    assert_approx_eq!(1.0000001f, 1.0f);\n-    assert_approx_eq!(1.0000001f, 1.0f, 1.0e-6);\n-    assert_approx_eq!(1.000001f, 1.0f, 1.0e-5);\n+    assert_approx_eq!(1.0f64, 1.0);\n+    assert_approx_eq!(1.0000001f64, 1.0);\n+    assert_approx_eq!(1.0000001f64, 1.0, 1.0e-6);\n+    assert_approx_eq!(1.000001f64, 1.0, 1.0e-5);\n }"}, {"sha": "e65116f214743cd9798eb6ec1a60d297a7f80013", "filename": "src/test/run-pass/block-arg-can-be-followed-by-binop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n pub fn main() {\n-    let v = ~[-1f, 0f, 1f, 2f, 3f];\n+    let v = ~[-1.0, 0.0, 1.0, 2.0, 3.0];\n \n     // Trailing expressions don't require parentheses:\n-    let y = do v.iter().fold(0f) |x, y| { x + *y } + 10f;\n+    let y = do v.iter().fold(0.0) |x, y| { x + *y } + 10.0;\n \n-    assert_eq!(y, 15f);\n+    assert_eq!(y, 15.0);\n }"}, {"sha": "ed8641eaf85f99ddfc7afba968357acf934e1ae7", "filename": "src/test/run-pass/block-arg-can-be-followed-by-block-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -10,7 +10,7 @@\n \n pub fn main() {\n     fn f(i: &fn() -> uint) -> uint { i() }\n-    let v = ~[-1f, 0f, 1f, 2f, 3f];\n+    let v = ~[-1.0, 0.0, 1.0, 2.0, 3.0];\n     let z = do do v.iter().fold(f) |x, _y| { x } { 22u };\n     assert_eq!(z, 22u);\n }"}, {"sha": "1bb16f6041eec6b267f5aee866e185d3dd861390", "filename": "src/test/run-pass/block-arg-can-be-followed-by-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -10,7 +10,7 @@\n \n pub fn main() {\n     fn f(i: uint) -> uint { i }\n-    let v = ~[-1f, 0f, 1f, 2f, 3f];\n+    let v = ~[-1.0, 0.0, 1.0, 2.0, 3.0];\n     let z = do v.iter().fold(f) |x, _y| { x } (22u);\n     assert_eq!(z, 22u);\n }"}, {"sha": "c296a37a17ce0e3c4bdcdeeb3f7be8df565f6603", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -10,7 +10,7 @@\n \n // Check usage and precedence of block arguments in expressions:\n pub fn main() {\n-    let v = ~[-1f, 0f, 1f, 2f, 3f];\n+    let v = ~[-1.0f64, 0.0, 1.0, 2.0, 3.0];\n \n     // Statement form does not require parentheses:\n     for i in v.iter() {\n@@ -26,7 +26,7 @@ pub fn main() {\n     assert!(any_negative);\n \n     // Higher precedence than unary operations:\n-    let abs_v = do v.iter().map |e| { e.abs() }.collect::<~[float]>();\n+    let abs_v = do v.iter().map |e| { e.abs() }.collect::<~[f64]>();\n     assert!(do abs_v.iter().all |e| { e.is_positive() });\n     assert!(!do abs_v.iter().any |e| { e.is_negative() });\n \n@@ -48,9 +48,9 @@ pub fn main() {\n \n \n     // Lower precedence than binary operations:\n-    let w = do v.iter().fold(0f) |x, y| { x + *y } + 10f;\n-    let y = do v.iter().fold(0f) |x, y| { x + *y } + 10f;\n-    let z = 10f + do v.iter().fold(0f) |x, y| { x + *y };\n+    let w = do v.iter().fold(0.0) |x, y| { x + *y } + 10.0;\n+    let y = do v.iter().fold(0.0) |x, y| { x + *y } + 10.0;\n+    let z = 10.0 + do v.iter().fold(0.0) |x, y| { x + *y };\n     assert_eq!(w, y);\n     assert_eq!(y, z);\n "}, {"sha": "8ccfd9fa361d09118b076821d9f89302085e95ca", "filename": "src/test/run-pass/const-binops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fconst-binops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fconst-binops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-binops.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -1,18 +1,18 @@\n static a: int = -4 + 3;\n static a2: uint = 3 + 3;\n-static b: float = 3.0 + 2.7;\n+static b: f64 = 3.0 + 2.7;\n \n static c: int = 3 - 4;\n static d: uint = 3 - 3;\n-static e: float = 3.0 - 2.7;\n+static e: f64 = 3.0 - 2.7;\n \n static e2: int = -3 * 3;\n static f: uint = 3 * 3;\n-static g: float = 3.3 * 3.3;\n+static g: f64 = 3.3 * 3.3;\n \n static h: int = 3 / -1;\n static i: uint = 3 / 3;\n-static j: float = 3.3 / 3.3;\n+static j: f64 = 3.3 / 3.3;\n \n static n: bool = true && false;\n "}, {"sha": "616826f9f950239423880b52e32523503d18240e", "filename": "src/test/run-pass/const-contents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fconst-contents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fconst-contents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-contents.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -12,15 +12,15 @@\n \n static lsl : int = 1 << 2;\n static add : int = 1 + 2;\n-static addf : float = 1.0f + 2.0f;\n+static addf : f64 = 1.0 + 2.0;\n static not : int = !0;\n static notb : bool = !true;\n static neg : int = -(1);\n \n pub fn main() {\n     assert_eq!(lsl, 4);\n     assert_eq!(add, 3);\n-    assert_eq!(addf, 3.0f);\n+    assert_eq!(addf, 3.0);\n     assert_eq!(not, -1);\n     assert_eq!(notb, false);\n     assert_eq!(neg, -1);"}, {"sha": "75e942cb767c8f0a5bc713afe091f0a4e3ef99ca", "filename": "src/test/run-pass/const-enum-cast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fconst-enum-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fconst-enum-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-cast.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -14,12 +14,12 @@ enum B { B1=0, B2=2 }\n pub fn main () {\n     static c1: int = A2 as int;\n     static c2: int = B2 as int;\n-    static c3: float = A2 as float;\n-    static c4: float = B2 as float;\n+    static c3: f64 = A2 as f64;\n+    static c4: f64 = B2 as f64;\n     let a1 = A2 as int;\n     let a2 = B2 as int;\n-    let a3 = A2 as float;\n-    let a4 = B2 as float;\n+    let a3 = A2 as f64;\n+    let a4 = B2 as f64;\n     assert_eq!(c1, 1);\n     assert_eq!(c2, 2);\n     assert_eq!(c3, 1.0);"}, {"sha": "e6680fe3e8fdb66c93d7ff3161ee9c095d0740c1", "filename": "src/test/run-pass/const-rec-and-tup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fconst-rec-and-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fconst-rec-and-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-rec-and-tup.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct Pair { a: float, b: float }\n+struct Pair { a: f64, b: f64 }\n \n struct AnotherPair { x: (i64, i64), y: Pair }\n "}, {"sha": "52858a46ba53d069e6853afcdea771c88021f222", "filename": "src/test/run-pass/deriving-clone-struct.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fderiving-clone-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fderiving-clone-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-clone-struct.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -22,7 +22,6 @@ struct S {\n     _u32: u32,\n     _u64: u64,\n \n-    _float: float,\n     _f32: f32,\n     _f64: f64,\n "}, {"sha": "b2974b4be0b39025c0eb05b56db402715a3e3ac0", "filename": "src/test/run-pass/deriving-via-extension-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fderiving-via-extension-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fderiving-via-extension-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-enum.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -11,7 +11,7 @@\n #[deriving(Eq)]\n enum Foo {\n     Bar(int, int),\n-    Baz(float, float)\n+    Baz(f64, f64)\n }\n \n pub fn main() {"}, {"sha": "2c8271df03bb03ecefd3644b97656c63e1a7f9df", "filename": "src/test/run-pass/deriving-zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fderiving-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fderiving-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-zero.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -26,7 +26,7 @@ struct E { a: int, b: int }\n struct Lots {\n     d: u8,\n     e: char,\n-    f: float,\n+    f: f64,\n     g: (f32, char),\n     h: @mut (int, int),\n     i: bool,"}, {"sha": "89fee7358a11194df025bddf729eb2d9bc923d5d", "filename": "src/test/run-pass/early-vtbl-resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fearly-vtbl-resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fearly-vtbl-resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fearly-vtbl-resolution.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -19,5 +19,5 @@ fn foo_func<A, B: thing<A>>(x: B) -> Option<A> { x.foo() }\n struct A { a: int }\n \n pub fn main() {\n-    let _x: Option<float> = foo_func(0);\n+    let _x: Option<f64> = foo_func(0);\n }"}, {"sha": "ee2c1ffba11f8ccef0b2b5b93b680b59675e4c66", "filename": "src/test/run-pass/enum-disr-val-pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fenum-disr-val-pretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fenum-disr-val-pretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-disr-val-pretty.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -21,5 +21,5 @@ pub fn main() {\n \n fn test_color(color: color, val: int, _name: ~str) {\n     assert!(color as int == val);\n-    assert!(color as float == val as float);\n+    assert!(color as f64 == val as f64);\n }"}, {"sha": "6d93437971cde03b7ece27ed7b7f4d92652d36e7", "filename": "src/test/run-pass/enum-variants.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fenum-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fenum-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-variants.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -2,8 +2,8 @@\n #[allow(unused_variable)];\n \n enum Animal {\n-    Dog (~str, float),\n-    Cat { name: ~str, weight: float }\n+    Dog (~str, f64),\n+    Cat { name: ~str, weight: f64 }\n }\n \n pub fn main() {"}, {"sha": "c090ca3960bf44ac4d3fe7e1c04013ef14442260", "filename": "src/test/run-pass/explicit-self.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fexplicit-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fexplicit-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -9,17 +9,17 @@\n // except according to those terms.\n \n \n-static tau: float = 2.0*3.14159265358979323;\n+static tau: f64 = 2.0*3.14159265358979323;\n \n-struct Point {x: float, y: float}\n-struct Size {w: float, h: float}\n+struct Point {x: f64, y: f64}\n+struct Size {w: f64, h: f64}\n enum shape {\n-    circle(Point, float),\n+    circle(Point, f64),\n     rectangle(Point, Size)\n }\n \n \n-fn compute_area(shape: &shape) -> float {\n+fn compute_area(shape: &shape) -> f64 {\n     match *shape {\n         circle(_, radius) => 0.5 * tau * radius * radius,\n         rectangle(_, ref size) => size.w * size.h\n@@ -28,14 +28,14 @@ fn compute_area(shape: &shape) -> float {\n \n impl shape {\n     // self is in the implicit self region\n-    pub fn select<'r, T>(&self, threshold: float, a: &'r T, b: &'r T)\n+    pub fn select<'r, T>(&self, threshold: f64, a: &'r T, b: &'r T)\n                          -> &'r T {\n         if compute_area(self) > threshold {a} else {b}\n     }\n }\n \n fn select_based_on_unit_circle<'r, T>(\n-    threshold: float, a: &'r T, b: &'r T) -> &'r T {\n+    threshold: f64, a: &'r T, b: &'r T) -> &'r T {\n \n     let shape = &circle(Point{x: 0.0, y: 0.0}, 1.0);\n     shape.select(threshold, a, b)"}, {"sha": "b80cdf9fbbd9ccb216a642cd52810f58b175968b", "filename": "src/test/run-pass/float-literal-inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Ffloat-literal-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Ffloat-literal-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat-literal-inference.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -15,7 +15,7 @@ struct S {\n pub fn main() {\n     let x: f32 = 4.0;\n     println(x.to_str());\n-    let y: float = 64.0;\n+    let y: f64 = 64.0;\n     println(y.to_str());\n     let z = S { z: 1.0 };\n     println(z.z.to_str());"}, {"sha": "9035176a267b15388a141b8bb7b077991d86896f", "filename": "src/test/run-pass/float-nan.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Ffloat-nan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Ffloat-nan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat-nan.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -13,11 +13,11 @@ extern mod extra;\n use std::num::Float;\n \n pub fn main() {\n-  let nan: float = Float::nan();\n+  let nan: f64 = Float::nan();\n   assert!((nan).is_nan());\n \n-  let inf: float = Float::infinity();\n-  let neg_inf: float = Float::neg_infinity();\n+  let inf: f64 = Float::infinity();\n+  let neg_inf: f64 = Float::neg_infinity();\n   assert_eq!(-inf, neg_inf);\n \n   assert!( nan !=  nan);\n@@ -80,14 +80,14 @@ pub fn main() {\n   assert!((nan * 1.).is_nan());\n   assert!((nan / 1.).is_nan());\n   assert!((nan / 0.).is_nan());\n-  assert!((0f/0f).is_nan());\n+  assert!((0.0/0.0f64).is_nan());\n   assert!((-inf + inf).is_nan());\n   assert!((inf - inf).is_nan());\n \n-  assert!(!(-1f).is_nan());\n-  assert!(!(0f).is_nan());\n-  assert!(!(0.1f).is_nan());\n-  assert!(!(1f).is_nan());\n+  assert!(!(-1.0f64).is_nan());\n+  assert!(!(0.0f64).is_nan());\n+  assert!(!(0.1f64).is_nan());\n+  assert!(!(1.0f64).is_nan());\n   assert!(!(inf).is_nan());\n   assert!(!(-inf).is_nan());\n   assert!(!(1./-inf).is_nan());"}, {"sha": "dae41d34e05267f8fa4b0eb0460009a901ec1601", "filename": "src/test/run-pass/float-signature.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Ffloat-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Ffloat-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat-signature.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -11,8 +11,8 @@\n \n \n pub fn main() {\n-    fn foo(n: float) -> float { return n + 0.12345; }\n-    let n: float = 0.1;\n-    let m: float = foo(n);\n+    fn foo(n: f64) -> f64 { return n + 0.12345; }\n+    let n: f64 = 0.1;\n+    let m: f64 = foo(n);\n     info2!(\"{}\", m);\n }"}, {"sha": "39ca7b0b8ad84cc20bbadd2bd153e645bb85dac4", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -56,7 +56,6 @@ pub fn main() {\n     t!(format!(\"{}\", 1u16), \"1\");\n     t!(format!(\"{}\", 1u32), \"1\");\n     t!(format!(\"{}\", 1u64), \"1\");\n-    t!(format!(\"{}\", 1.0f), \"1\");\n     t!(format!(\"{}\", 1.0f32), \"1\");\n     t!(format!(\"{}\", 1.0f64), \"1\");\n     t!(format!(\"{}\", \"a\"), \"a\");\n@@ -212,13 +211,12 @@ pub fn main() {\n     t!(format!(\"{:+05d}\", -1), \"-0001\");\n \n     // Some float stuff\n-    t!(format!(\"{:f}\", 1.0f), \"1\");\n     t!(format!(\"{:f}\", 1.0f32), \"1\");\n     t!(format!(\"{:f}\", 1.0f64), \"1\");\n-    t!(format!(\"{:.3f}\", 1.0f), \"1.000\");\n-    t!(format!(\"{:10.3f}\", 1.0f),   \"     1.000\");\n-    t!(format!(\"{:+10.3f}\", 1.0f),  \"    +1.000\");\n-    t!(format!(\"{:+10.3f}\", -1.0f), \"    -1.000\");\n+    t!(format!(\"{:.3f}\", 1.0f64), \"1.000\");\n+    t!(format!(\"{:10.3f}\", 1.0f64),   \"     1.000\");\n+    t!(format!(\"{:+10.3f}\", 1.0f64),  \"    +1.000\");\n+    t!(format!(\"{:+10.3f}\", -1.0f64), \"    -1.000\");\n \n     // Escaping\n     t!(format!(\"\\\\{\"), \"{\");"}, {"sha": "fdd26478a99dc35f56deaa8039b6db610ac5562f", "filename": "src/test/run-pass/issue-3609.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3609.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -3,7 +3,7 @@ extern mod extra;\n use std::comm::Chan;\n use std::task;\n \n-type RingBuffer = ~[float];\n+type RingBuffer = ~[f64];\n type SamplesFn = ~fn(samples: &RingBuffer);\n \n enum Msg"}, {"sha": "13455bd4ca83e8ac74967c6aca616aa171ca0ec2", "filename": "src/test/run-pass/issue-3743.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fissue-3743.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fissue-3743.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3743.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -9,14 +9,14 @@\n // except according to those terms.\n \n struct Vec2 {\n-    x: float,\n-    y: float\n+    x: f64,\n+    y: f64\n }\n \n // methods we want to export as methods as well as operators\n impl Vec2 {\n #[inline(always)]\n-    fn vmul(self, other: float) -> Vec2 {\n+    fn vmul(self, other: f64) -> Vec2 {\n         Vec2 { x: self.x * other, y: self.y * other }\n     }\n }\n@@ -29,22 +29,22 @@ impl<Res, Rhs: RhsOfVec2Mul<Res>> Mul<Rhs,Res> for Vec2 {\n     fn mul(&self, rhs: &Rhs) -> Res { rhs.mul_vec2_by(self) }\n }\n \n-// Implementation of 'float as right-hand-side of Vec2::Mul'\n-impl RhsOfVec2Mul<Vec2> for float {\n+// Implementation of 'f64 as right-hand-side of Vec2::Mul'\n+impl RhsOfVec2Mul<Vec2> for f64 {\n     fn mul_vec2_by(&self, lhs: &Vec2) -> Vec2 { lhs.vmul(*self) }\n }\n \n // Usage with failing inference\n pub fn main() {\n-    let a = Vec2 { x: 3f, y: 4f };\n+    let a = Vec2 { x: 3.0, y: 4.0 };\n \n     // the following compiles and works properly\n-    let v1: Vec2 = a * 3f;\n+    let v1: Vec2 = a * 3.0;\n     println!(\"{} {}\", v1.x, v1.y);\n \n     // the following compiles but v2 will not be Vec2 yet and\n     // using it later will cause an error that the type of v2\n     // must be known\n-    let v2 = a * 3f;\n+    let v2 = a * 3.0;\n     println!(\"{} {}\", v2.x, v2.y); // error regarding v2's type\n }"}, {"sha": "49759f3b85b98b588a1e2eb5169181fe0cf172c8", "filename": "src/test/run-pass/issue-3753.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fissue-3753.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fissue-3753.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3753.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -12,28 +12,28 @@\n // Issue Name: pub method preceeded by attribute can't be parsed\n // Abstract: Visibility parsing failed when compiler parsing\n \n-use std::float;\n+use std::f64;\n \n struct Point {\n-    x: float,\n-    y: float\n+    x: f64,\n+    y: f64\n }\n \n pub enum Shape {\n-    Circle(Point, float),\n+    Circle(Point, f64),\n     Rectangle(Point, Point)\n }\n \n impl Shape {\n-    pub fn area(&self, sh: Shape) -> float {\n+    pub fn area(&self, sh: Shape) -> f64 {\n         match sh {\n-            Circle(_, size) => float::consts::pi * size * size,\n+            Circle(_, size) => f64::consts::pi * size * size,\n             Rectangle(Point {x, y}, Point {x: x2, y: y2}) => (x2 - x) * (y2 - y)\n         }\n     }\n }\n \n pub fn main(){\n-    let s = Circle(Point { x: 1f, y: 2f }, 3f);\n+    let s = Circle(Point { x: 1.0, y: 2.0 }, 3.0);\n     println!(\"{}\", s.area(s));\n }"}, {"sha": "2ed662e9f2d6039ad0cbab6383550f43a2c7af20", "filename": "src/test/run-pass/issue-4107.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fissue-4107.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fissue-4107.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4107.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let _id: &Mat2<float> = &Matrix::identity();\n+    let _id: &Mat2<f64> = &Matrix::identity();\n }\n \n pub trait Index<Index,Result> { }"}, {"sha": "b2eeedfbdc9225071314aec2dc3d171ee6bafe03", "filename": "src/test/run-pass/issue-5754.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fissue-5754.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fissue-5754.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5754.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n struct TwoDoubles {\n-    r: float,\n-    i: float\n+    r: f64,\n+    i: f64\n }\n \n extern \"C\" {"}, {"sha": "5db170fd52100de0f6a941b8fdfe580598b7af3b", "filename": "src/test/run-pass/issue-7222.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fissue-7222.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fissue-7222.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7222.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    static FOO: float = 10.0;\n+    static FOO: f64 = 10.0;\n \n     match 0.0 {\n         0.0 .. FOO => (),"}, {"sha": "e03256bfe499d275ef4aa8ea10716676077639cf", "filename": "src/test/run-pass/macro-local-data-key.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fmacro-local-data-key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fmacro-local-data-key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-local-data-key.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -13,7 +13,7 @@ use std::local_data;\n local_data_key!(foo: int)\n \n mod bar {\n-    local_data_key!(pub baz: float)\n+    local_data_key!(pub baz: f64)\n }\n \n pub fn main() {"}, {"sha": "bc4f4273dfbf80e757f65f95d71c125338dbe7fd", "filename": "src/test/run-pass/mid-path-type-params.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fmid-path-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fmid-path-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmid-path-type-params.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -27,7 +27,7 @@ impl Trait<int> for S2 {\n }\n \n pub fn main() {\n-    let _ = S::<int>::new::<float>(1, 1.0);\n-    let _: S2 = Trait::<int>::new::<float>(1, 1.0);\n+    let _ = S::<int>::new::<f64>(1, 1.0);\n+    let _: S2 = Trait::<int>::new::<f64>(1, 1.0);\n }\n "}, {"sha": "f2df3fc66ea8c18ccc8b4796cb4671371ab9131b", "filename": "src/test/run-pass/numeric-method-autoexport.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -36,7 +36,6 @@ pub fn main() {\n \n // floats\n     // num\n-    assert_eq!(10f.to_int(), 10);\n     assert_eq!(10f32.to_int(), 10);\n     assert_eq!(10f64.to_int(), 10);\n }"}, {"sha": "d7cf9f2cd2f78505a333376e249e4757d90a1588", "filename": "src/test/run-pass/pure-fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fpure-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fpure-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpure-fmt.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -11,7 +11,7 @@\n // Testing that calling fmt! (via info2!) doesn't complain about impure borrows\n \n struct Big { b: @~str, c: uint, d: int, e: char,\n-            f: float, g: bool }\n+            f: f64, g: bool }\n \n fn foo() {\n     let a = Big {"}, {"sha": "85cc8b224f6891d8f16fb4ec0ecc211f05540300", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -152,13 +152,6 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n         true\n     }\n \n-    fn visit_float(&mut self) -> bool {\n-        self.align_to::<float>();\n-        if ! self.inner.visit_float() { return false; }\n-        self.bump_past::<float>();\n-        true\n-    }\n-\n     fn visit_f32(&mut self) -> bool {\n         self.align_to::<f32>();\n         if ! self.inner.visit_f32() { return false; }\n@@ -528,7 +521,6 @@ impl TyVisitor for my_visitor {\n     fn visit_u32(&mut self) -> bool { true }\n     fn visit_u64(&mut self) -> bool { true }\n \n-    fn visit_float(&mut self) -> bool { true }\n     fn visit_f32(&mut self) -> bool { true }\n     fn visit_f64(&mut self) -> bool { true }\n "}, {"sha": "0afc5dd1b17ea24347d84444232bb0b4550f43f2", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -54,7 +54,6 @@ impl TyVisitor for MyVisitor {\n     fn visit_u32(&mut self) -> bool { true }\n     fn visit_u64(&mut self) -> bool { true }\n \n-    fn visit_float(&mut self) -> bool { true }\n     fn visit_f32(&mut self) -> bool { true }\n     fn visit_f64(&mut self) -> bool { true }\n "}, {"sha": "7cc83e2ff546e14246f07e1e1436fa9f4ff077e3", "filename": "src/test/run-pass/sendfn-generic-fn.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fsendfn-generic-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fsendfn-generic-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-generic-fn.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -24,15 +24,15 @@ fn make_generic_record<A,B>(a: A, b: B) -> Pair<A,B> {\n     return Pair {a: a, b: b};\n }\n \n-fn test05_start(f: &~fn(v: float, v: ~str) -> Pair<float, ~str>) {\n-    let p = (*f)(22.22f, ~\"Hi\");\n+fn test05_start(f: &~fn(v: f64, v: ~str) -> Pair<f64, ~str>) {\n+    let p = (*f)(22.22, ~\"Hi\");\n     info2!(\"{:?}\", p.clone());\n-    assert!(p.a == 22.22f);\n+    assert!(p.a == 22.22);\n     assert!(p.b == ~\"Hi\");\n \n-    let q = (*f)(44.44f, ~\"Ho\");\n+    let q = (*f)(44.44, ~\"Ho\");\n     info2!(\"{:?}\", q.clone());\n-    assert!(q.a == 44.44f);\n+    assert!(q.a == 44.44);\n     assert!(q.b == ~\"Ho\");\n }\n \n@@ -42,5 +42,5 @@ fn spawn<A,B>(f: extern fn(&~fn(A,B)->Pair<A,B>)) {\n }\n \n fn test05() {\n-    spawn::<float,~str>(test05_start);\n+    spawn::<f64,~str>(test05_start);\n }"}, {"sha": "e3441661d5b19a9259cf62adf9478a930ce73e2a", "filename": "src/test/run-pass/static-fn-inline-xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fstatic-fn-inline-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fstatic-fn-inline-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-fn-inline-xc.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -16,5 +16,5 @@ extern mod mycore(name =\"static_fn_inline_xc_aux\");\n use mycore::num;\n \n pub fn main() {\n-    let _1:float = num::Num2::from_int2(1i);\n+    let _1: f64 = num::Num2::from_int2(1i);\n }"}, {"sha": "41665871451f0769a7f56013522570b01df4805b", "filename": "src/test/run-pass/static-fn-trait-xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fstatic-fn-trait-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fstatic-fn-trait-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-fn-trait-xc.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -6,5 +6,5 @@ extern mod mycore(name =\"static_fn_trait_xc_aux\");\n use mycore::num;\n \n pub fn main() {\n-    let _1:float = num::Num2::from_int2(1i);\n+    let _1: f64 = num::Num2::from_int2(1i);\n }"}, {"sha": "a73978ce73c636be62ca29ea938010937ae3a895", "filename": "src/test/run-pass/static-methods-in-traits2.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fstatic-methods-in-traits2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fstatic-methods-in-traits2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-methods-in-traits2.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -2,18 +2,18 @@ pub trait Number: NumConv {\n     fn from<T:Number>(n: T) -> Self;\n }\n \n-impl Number for float {\n-    fn from<T:Number>(n: T) -> float { n.to_float() }\n+impl Number for f64 {\n+    fn from<T:Number>(n: T) -> f64 { n.to_float() }\n }\n \n pub trait NumConv {\n-    fn to_float(&self) -> float;\n+    fn to_float(&self) -> f64;\n }\n \n-impl NumConv for float {\n-    fn to_float(&self) -> float { *self }\n+impl NumConv for f64 {\n+    fn to_float(&self) -> f64 { *self }\n }\n \n pub fn main() {\n-    let _: float = Number::from(0.0f);\n+    let _: f64 = Number::from(0.0f64);\n }"}, {"sha": "42f119cbe396fd5e0863ccefc771dc148fe360c8", "filename": "src/test/run-pass/struct-like-variant-construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fstruct-like-variant-construct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fstruct-like-variant-construct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-like-variant-construct.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -14,8 +14,8 @@ enum Foo {\n         b: int\n     },\n     Baz {\n-        c: float,\n-        d: float\n+        c: f64,\n+        d: f64\n     }\n }\n "}, {"sha": "b0f2f65b3f41bd72da6f112c9529825ae5a7fb2c", "filename": "src/test/run-pass/struct-like-variant-match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fstruct-like-variant-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fstruct-like-variant-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-like-variant-match.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -14,8 +14,8 @@ enum Foo {\n         y: int\n     },\n     Baz {\n-        x: float,\n-        y: float\n+        x: f64,\n+        y: f64\n     }\n }\n "}, {"sha": "7b5988b9b3dd896f6a1ca9b672f209771b425814", "filename": "src/test/run-pass/struct-return.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fstruct-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fstruct-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-return.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -51,9 +51,9 @@ fn test2() {\n                  b: 0b_1010_1010_u8,\n                  c: 1.0987654321e-15_f64 };\n         let ff = rustrt::rust_dbg_abi_2(f);\n-        error2!(\"a: {}\", ff.a as float);\n+        error2!(\"a: {}\", ff.a as f64);\n         error2!(\"b: {}\", ff.b as uint);\n-        error2!(\"c: {}\", ff.c as float);\n+        error2!(\"c: {}\", ff.c as f64);\n         assert_eq!(ff.a, f.c + 1.0f64);\n         assert_eq!(ff.b, 0xff_u8);\n         assert_eq!(ff.c, f.a - 1.0f64);"}, {"sha": "090e932d8dc8b366cfa8df2a9817361631e904ba", "filename": "src/test/run-pass/supported-cast.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fsupported-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fsupported-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsupported-cast.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -25,7 +25,6 @@ pub fn main() {\n \n   info2!(\"{}\", 1 as int);\n   info2!(\"{}\", 1 as uint);\n-  info2!(\"{}\", 1 as float);\n   info2!(\"{}\", 1 as *libc::FILE);\n   info2!(\"{}\", 1 as i8);\n   info2!(\"{}\", 1 as i16);\n@@ -40,7 +39,6 @@ pub fn main() {\n \n   info2!(\"{}\", 1u as int);\n   info2!(\"{}\", 1u as uint);\n-  info2!(\"{}\", 1u as float);\n   info2!(\"{}\", 1u as *libc::FILE);\n   info2!(\"{}\", 1u as i8);\n   info2!(\"{}\", 1u as i16);\n@@ -55,7 +53,6 @@ pub fn main() {\n \n   info2!(\"{}\", 1i8 as int);\n   info2!(\"{}\", 1i8 as uint);\n-  info2!(\"{}\", 1i8 as float);\n   info2!(\"{}\", 1i8 as *libc::FILE);\n   info2!(\"{}\", 1i8 as i8);\n   info2!(\"{}\", 1i8 as i16);\n@@ -70,7 +67,6 @@ pub fn main() {\n \n   info2!(\"{}\", 1u8 as int);\n   info2!(\"{}\", 1u8 as uint);\n-  info2!(\"{}\", 1u8 as float);\n   info2!(\"{}\", 1u8 as *libc::FILE);\n   info2!(\"{}\", 1u8 as i8);\n   info2!(\"{}\", 1u8 as i16);\n@@ -85,7 +81,6 @@ pub fn main() {\n \n   info2!(\"{}\", 1i16 as int);\n   info2!(\"{}\", 1i16 as uint);\n-  info2!(\"{}\", 1i16 as float);\n   info2!(\"{}\", 1i16 as *libc::FILE);\n   info2!(\"{}\", 1i16 as i8);\n   info2!(\"{}\", 1i16 as i16);\n@@ -100,7 +95,6 @@ pub fn main() {\n \n   info2!(\"{}\", 1u16 as int);\n   info2!(\"{}\", 1u16 as uint);\n-  info2!(\"{}\", 1u16 as float);\n   info2!(\"{}\", 1u16 as *libc::FILE);\n   info2!(\"{}\", 1u16 as i8);\n   info2!(\"{}\", 1u16 as i16);\n@@ -115,7 +109,6 @@ pub fn main() {\n \n   info2!(\"{}\", 1i32 as int);\n   info2!(\"{}\", 1i32 as uint);\n-  info2!(\"{}\", 1i32 as float);\n   info2!(\"{}\", 1i32 as *libc::FILE);\n   info2!(\"{}\", 1i32 as i8);\n   info2!(\"{}\", 1i32 as i16);\n@@ -130,7 +123,6 @@ pub fn main() {\n \n   info2!(\"{}\", 1u32 as int);\n   info2!(\"{}\", 1u32 as uint);\n-  info2!(\"{}\", 1u32 as float);\n   info2!(\"{}\", 1u32 as *libc::FILE);\n   info2!(\"{}\", 1u32 as i8);\n   info2!(\"{}\", 1u32 as i16);\n@@ -145,7 +137,6 @@ pub fn main() {\n \n   info2!(\"{}\", 1i64 as int);\n   info2!(\"{}\", 1i64 as uint);\n-  info2!(\"{}\", 1i64 as float);\n   info2!(\"{}\", 1i64 as *libc::FILE);\n   info2!(\"{}\", 1i64 as i8);\n   info2!(\"{}\", 1i64 as i16);\n@@ -160,7 +151,6 @@ pub fn main() {\n \n   info2!(\"{}\", 1u64 as int);\n   info2!(\"{}\", 1u64 as uint);\n-  info2!(\"{}\", 1u64 as float);\n   info2!(\"{}\", 1u64 as *libc::FILE);\n   info2!(\"{}\", 1u64 as i8);\n   info2!(\"{}\", 1u64 as i16);\n@@ -175,7 +165,6 @@ pub fn main() {\n \n   info2!(\"{}\", 1u64 as int);\n   info2!(\"{}\", 1u64 as uint);\n-  info2!(\"{}\", 1u64 as float);\n   info2!(\"{}\", 1u64 as *libc::FILE);\n   info2!(\"{}\", 1u64 as i8);\n   info2!(\"{}\", 1u64 as i16);\n@@ -190,7 +179,6 @@ pub fn main() {\n \n   info2!(\"{}\", true as int);\n   info2!(\"{}\", true as uint);\n-  info2!(\"{}\", true as float);\n   info2!(\"{}\", true as *libc::FILE);\n   info2!(\"{}\", true as i8);\n   info2!(\"{}\", true as i16);\n@@ -205,7 +193,6 @@ pub fn main() {\n \n   info2!(\"{}\", 1. as int);\n   info2!(\"{}\", 1. as uint);\n-  info2!(\"{}\", 1. as float);\n   info2!(\"{}\", 1. as i8);\n   info2!(\"{}\", 1. as i16);\n   info2!(\"{}\", 1. as i32);\n@@ -219,7 +206,6 @@ pub fn main() {\n \n   info2!(\"{}\", 1f32 as int);\n   info2!(\"{}\", 1f32 as uint);\n-  info2!(\"{}\", 1f32 as float);\n   info2!(\"{}\", 1f32 as i8);\n   info2!(\"{}\", 1f32 as i16);\n   info2!(\"{}\", 1f32 as i32);\n@@ -233,7 +219,6 @@ pub fn main() {\n \n   info2!(\"{}\", 1f64 as int);\n   info2!(\"{}\", 1f64 as uint);\n-  info2!(\"{}\", 1f64 as float);\n   info2!(\"{}\", 1f64 as i8);\n   info2!(\"{}\", 1f64 as i16);\n   info2!(\"{}\", 1f64 as i32);"}, {"sha": "8eed2653a901a8d79574846dfd6b9c373226bb8a", "filename": "src/test/run-pass/tag-variant-disr-val.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -40,7 +40,7 @@ pub fn main() {\n fn test_color(color: color, val: int, name: ~str) {\n     //assert!(unsafe::transmute(color) == val);\n     assert_eq!(color as int, val);\n-    assert_eq!(color as float, val as float);\n+    assert_eq!(color as f64, val as f64);\n     assert!(get_color_alt(color) == name);\n     assert!(get_color_if(color) == name);\n }"}, {"sha": "fdc42e58f8cac32da1fb6a936a1991d65f8c62c8", "filename": "src/test/run-pass/trait-default-method-bound-subst4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound-subst4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound-subst4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound-subst4.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -20,6 +20,6 @@ fn f<T, V: A<T>>(i: V, j: uint) -> uint {\n }\n \n pub fn main () {\n-    assert_eq!(f::<float, int>(0, 2u), 2u);\n+    assert_eq!(f::<f64, int>(0, 2u), 2u);\n     assert_eq!(f::<uint, int>(0, 2u), 2u);\n }"}, {"sha": "1013a1273071bd7a5f64749b968efbd0d3f3c888", "filename": "src/test/run-pass/trait-default-method-xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -59,7 +59,7 @@ fn main () {\n \n     assert_eq!(0i.thing(3.14, 1), (3.14, 1));\n     assert_eq!(B::staticthing(&0i, 3.14, 1), (3.14, 1));\n-    assert_eq!(B::<float>::staticthing::<int>(&0i, 3.14, 1), (3.14, 1));\n+    assert_eq!(B::<f64>::staticthing::<int>(&0i, 3.14, 1), (3.14, 1));\n \n     assert_eq!(g(0i, 3.14, 1), (3.14, 1));\n     assert_eq!(g(false, 3.14, 1), (3.14, 1));"}, {"sha": "994941b4b226687f9fbef6d9c99d5c4d4cf12a4e", "filename": "src/test/run-pass/trait-inheritance-num2.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -33,7 +33,6 @@ impl TypeExt for int {}\n \n impl TypeExt for f32 {}\n impl TypeExt for f64 {}\n-impl TypeExt for float {}\n \n \n pub trait NumExt: TypeExt + Eq + Ord + Num + NumCast {}\n@@ -52,7 +51,6 @@ impl NumExt for int {}\n \n impl NumExt for f32 {}\n impl NumExt for f64 {}\n-impl NumExt for float {}\n \n \n pub trait UnSignedExt: NumExt {}\n@@ -74,7 +72,6 @@ impl SignedExt for int {}\n \n impl SignedExt for f32 {}\n impl SignedExt for f64 {}\n-impl SignedExt for float {}\n \n \n pub trait IntegerExt: NumExt {}\n@@ -96,7 +93,6 @@ pub trait FloatExt: NumExt + ApproxEq<Self> {}\n \n impl FloatExt for f32 {}\n impl FloatExt for f64 {}\n-impl FloatExt for float {}\n \n \n fn test_float_ext<T:FloatExt>(n: T) { println!(\"{}\", n < n) }"}, {"sha": "fac29e68525cf7a501ecd5dc298657f8b84053fc", "filename": "src/test/run-pass/trait-inheritance-self-in-supertype.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Ftrait-inheritance-self-in-supertype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Ftrait-inheritance-self-in-supertype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-self-in-supertype.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -2,7 +2,7 @@\n \n use std::num;\n \n-pub static FUZZY_EPSILON: float = 0.1;\n+pub static FUZZY_EPSILON: f64 = 0.1;\n \n pub trait FuzzyEq<Eps> {\n     fn fuzzy_eq(&self, other: &Self) -> bool;"}, {"sha": "66a1ebe26cd547dc1487507aa91d6223f6b33241", "filename": "src/test/run-pass/typeck-macro-interaction-issue-8852.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Ftypeck-macro-interaction-issue-8852.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Ftypeck-macro-interaction-issue-8852.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeck-macro-interaction-issue-8852.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -1,6 +1,6 @@\n enum T {\n     A(int),\n-    B(float)\n+    B(f64)\n }\n \n macro_rules! test("}, {"sha": "33f958f20bcb7224ba2304644f13e5622c2f549d", "filename": "src/test/run-pass/xcrate-address-insignificant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fxcrate-address-insignificant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b510c351e990d835511f45a28f2f29c12ee545/src%2Ftest%2Frun-pass%2Fxcrate-address-insignificant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fxcrate-address-insignificant.rs?ref=08b510c351e990d835511f45a28f2f29c12ee545", "patch": "@@ -14,5 +14,5 @@\n extern mod foo(name = \"xcrate_address_insignificant\");\n \n fn main() {\n-    assert_eq!(foo::foo::<float>(), foo::bar());\n+    assert_eq!(foo::foo::<f64>(), foo::bar());\n }"}]}