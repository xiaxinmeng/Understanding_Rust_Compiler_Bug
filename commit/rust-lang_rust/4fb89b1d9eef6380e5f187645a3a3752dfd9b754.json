{"sha": "4fb89b1d9eef6380e5f187645a3a3752dfd9b754", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmYjg5YjFkOWVlZjYzODBlNWYxODc2NDVhM2EzNzUyZGZkOWI3NTQ=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-12-07T18:42:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-12-07T18:42:52Z"}, "message": "Rollup merge of #38189 - GuillaumeGomez:rc_links, r=frewsxcv\n\nAdd missing links to Rc doc\n\nr? @frewsxcv", "tree": {"sha": "be6424863abc0cbcaa0970776679a878a7e04b5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be6424863abc0cbcaa0970776679a878a7e04b5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fb89b1d9eef6380e5f187645a3a3752dfd9b754", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fb89b1d9eef6380e5f187645a3a3752dfd9b754", "html_url": "https://github.com/rust-lang/rust/commit/4fb89b1d9eef6380e5f187645a3a3752dfd9b754", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fb89b1d9eef6380e5f187645a3a3752dfd9b754/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccbeb6d6ab3287ef39a0ccd9ee1082fb369f450b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccbeb6d6ab3287ef39a0ccd9ee1082fb369f450b", "html_url": "https://github.com/rust-lang/rust/commit/ccbeb6d6ab3287ef39a0ccd9ee1082fb369f450b"}, {"sha": "5caec61a7f459c2a62c2ab1c32bbd565e079766f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5caec61a7f459c2a62c2ab1c32bbd565e079766f", "html_url": "https://github.com/rust-lang/rust/commit/5caec61a7f459c2a62c2ab1c32bbd565e079766f"}], "stats": {"total": 88, "additions": 45, "deletions": 43}, "files": [{"sha": "d1e0e333b8f3aa7b538779e0d0ff4b9526f5e842", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 45, "deletions": 43, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/4fb89b1d9eef6380e5f187645a3a3752dfd9b754/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fb89b1d9eef6380e5f187645a3a3752dfd9b754/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=4fb89b1d9eef6380e5f187645a3a3752dfd9b754", "patch": "@@ -12,35 +12,35 @@\n \n //! Single-threaded reference-counting pointers.\n //!\n-//! The type [`Rc<T>`][rc] provides shared ownership of a value of type `T`,\n-//! allocated in the heap. Invoking [`clone`][clone] on `Rc` produces a new\n-//! pointer to the same value in the heap. When the last `Rc` pointer to a\n+//! The type [`Rc<T>`][`Rc`] provides shared ownership of a value of type `T`,\n+//! allocated in the heap. Invoking [`clone()`][clone] on [`Rc`] produces a new\n+//! pointer to the same value in the heap. When the last [`Rc`] pointer to a\n //! given value is destroyed, the pointed-to value is also destroyed.\n //!\n //! Shared references in Rust disallow mutation by default, and `Rc` is no\n-//! exception. If you need to mutate through an `Rc`, use [`Cell`][cell] or\n-//! [`RefCell`][refcell].\n+//! exception. If you need to mutate through an [`Rc`], use [`Cell`] or\n+//! [`RefCell`].\n //!\n-//! `Rc` uses non-atomic reference counting. This means that overhead is very\n-//! low, but an `Rc` cannot be sent between threads, and consequently `Rc`\n+//! [`Rc`] uses non-atomic reference counting. This means that overhead is very\n+//! low, but an [`Rc`] cannot be sent between threads, and consequently [`Rc`]\n //! does not implement [`Send`][send]. As a result, the Rust compiler\n-//! will check *at compile time* that you are not sending `Rc`s between\n+//! will check *at compile time* that you are not sending [`Rc`]s between\n //! threads. If you need multi-threaded, atomic reference counting, use\n //! [`sync::Arc`][arc].\n //!\n-//! The [`downgrade`][downgrade] method can be used to create a non-owning\n-//! [`Weak`][weak] pointer. A `Weak` pointer can be [`upgrade`][upgrade]d\n-//! to an `Rc`, but this will return [`None`][option] if the value has\n+//! The [`downgrade()`][downgrade] method can be used to create a non-owning\n+//! [`Weak`] pointer. A [`Weak`] pointer can be [`upgrade`][upgrade]d\n+//! to an [`Rc`], but this will return [`None`] if the value has\n //! already been dropped.\n //!\n-//! A cycle between `Rc` pointers will never be deallocated. For this reason,\n-//! `Weak` is used to break cycles. For example, a tree could have strong\n-//! `Rc` pointers from parent nodes to children, and `Weak` pointers from\n+//! A cycle between [`Rc`] pointers will never be deallocated. For this reason,\n+//! [`Weak`] is used to break cycles. For example, a tree could have strong\n+//! [`Rc`] pointers from parent nodes to children, and [`Weak`] pointers from\n //! children back to their parents.\n //!\n-//! `Rc<T>` automatically dereferences to `T` (via the [`Deref`][deref] trait),\n-//! so you can call `T`'s methods on a value of type `Rc<T>`. To avoid name\n-//! clashes with `T`'s methods, the methods of `Rc<T>` itself are [associated\n+//! `Rc<T>` automatically dereferences to `T` (via the [`Deref`] trait),\n+//! so you can call `T`'s methods on a value of type [`Rc<T>`][`Rc`]. To avoid name\n+//! clashes with `T`'s methods, the methods of [`Rc<T>`][`Rc`] itself are [associated\n //! functions][assoc], called using function-like syntax:\n //!\n //! ```\n@@ -50,28 +50,15 @@\n //! Rc::downgrade(&my_rc);\n //! ```\n //!\n-//! `Weak<T>` does not auto-dereference to `T`, because the value may have\n+//! [`Weak<T>`][`Weak`] does not auto-dereference to `T`, because the value may have\n //! already been destroyed.\n //!\n-//! [rc]: struct.Rc.html\n-//! [weak]: struct.Weak.html\n-//! [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n-//! [cell]: ../../std/cell/struct.Cell.html\n-//! [refcell]: ../../std/cell/struct.RefCell.html\n-//! [send]: ../../std/marker/trait.Send.html\n-//! [arc]: ../../std/sync/struct.Arc.html\n-//! [deref]: ../../std/ops/trait.Deref.html\n-//! [downgrade]: struct.Rc.html#method.downgrade\n-//! [upgrade]: struct.Weak.html#method.upgrade\n-//! [option]: ../../std/option/enum.Option.html\n-//! [assoc]: ../../book/method-syntax.html#associated-functions\n-//!\n //! # Examples\n //!\n //! Consider a scenario where a set of `Gadget`s are owned by a given `Owner`.\n //! We want to have our `Gadget`s point to their `Owner`. We can't do this with\n //! unique ownership, because more than one gadget may belong to the same\n-//! `Owner`. `Rc` allows us to share an `Owner` between multiple `Gadget`s,\n+//! `Owner`. [`Rc`] allows us to share an `Owner` between multiple `Gadget`s,\n //! and have the `Owner` remain allocated as long as any `Gadget` points at it.\n //!\n //! ```\n@@ -127,20 +114,20 @@\n //! ```\n //!\n //! If our requirements change, and we also need to be able to traverse from\n-//! `Owner` to\u00a0`Gadget`, we will run into problems. An `Rc` pointer from `Owner`\n+//! `Owner` to\u00a0`Gadget`, we will run into problems. An [`Rc`] pointer from `Owner`\n //! to `Gadget` introduces a cycle between the values. This means that their\n //! reference counts can never reach 0, and the values will remain allocated\n-//! forever: a memory leak. In order to get around this, we can use `Weak`\n+//! forever: a memory leak. In order to get around this, we can use [`Weak`]\n //! pointers.\n //!\n //! Rust actually makes it somewhat difficult to produce this loop in the first\n //! place. In order to end up with two values that point at each other, one of\n-//! them needs to be mutable. This is difficult because `Rc` enforces\n+//! them needs to be mutable. This is difficult because [`Rc`] enforces\n //! memory safety by only giving out shared references to the value it wraps,\n //! and these don't allow direct mutation. We need to wrap the part of the\n-//! value we wish to mutate in a [`RefCell`][refcell], which provides *interior\n+//! value we wish to mutate in a [`RefCell`], which provides *interior\n //! mutability*: a method to achieve mutability through a shared reference.\n-//! `RefCell` enforces Rust's borrowing rules at runtime.\n+//! [`RefCell`] enforces Rust's borrowing rules at runtime.\n //!\n //! ```\n //! use std::rc::Rc;\n@@ -214,6 +201,19 @@\n //!     // Gadget Man, so he gets destroyed as well.\n //! }\n //! ```\n+//!\n+//! [`Rc`]: struct.Rc.html\n+//! [`Weak`]: struct.Weak.html\n+//! [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n+//! [`Cell`]: ../../std/cell/struct.Cell.html\n+//! [`RefCell`]: ../../std/cell/struct.RefCell.html\n+//! [send]: ../../std/marker/trait.Send.html\n+//! [arc]: ../../std/sync/struct.Arc.html\n+//! [`Deref`]: ../../std/ops/trait.Deref.html\n+//! [downgrade]: struct.Rc.html#method.downgrade\n+//! [upgrade]: struct.Weak.html#method.upgrade\n+//! [`None`]: ../../std/option/enum.Option.html#variant.None\n+//! [assoc]: ../../book/method-syntax.html#associated-functions\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -251,9 +251,11 @@ struct RcBox<T: ?Sized> {\n /// See the [module-level documentation](./index.html) for more details.\n ///\n /// The inherent methods of `Rc` are all associated functions, which means\n-/// that you have to call them as e.g. `Rc::get_mut(&value)` instead of\n-/// `value.get_mut()`.  This avoids conflicts with methods of the inner\n+/// that you have to call them as e.g. [`Rc::get_mut(&value)`][get_mut] instead of\n+/// `value.get_mut()`. This avoids conflicts with methods of the inner\n /// type `T`.\n+///\n+/// [get_mut]: #method.get_mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T: ?Sized> {\n     ptr: Shared<RcBox<T>>,\n@@ -337,10 +339,10 @@ impl<T> Rc<T> {\n     }\n \n     /// Checks whether [`Rc::try_unwrap`][try_unwrap] would return\n-    /// [`Ok`][result].\n+    /// [`Ok`].\n     ///\n     /// [try_unwrap]: struct.Rc.html#method.try_unwrap\n-    /// [result]: ../../std/result/enum.Result.html\n+    /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n     ///\n     /// # Examples\n     ///\n@@ -543,14 +545,14 @@ impl<T: ?Sized> Rc<T> {\n     /// Returns a mutable reference to the inner value, if there are\n     /// no other `Rc` or [`Weak`][weak] pointers to the same value.\n     ///\n-    /// Returns [`None`][option] otherwise, because it is not safe to\n+    /// Returns [`None`] otherwise, because it is not safe to\n     /// mutate a shared value.\n     ///\n     /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n     /// the inner value when it's shared.\n     ///\n     /// [weak]: struct.Weak.html\n-    /// [option]: ../../std/option/enum.Option.html\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     /// [make_mut]: struct.Rc.html#method.make_mut\n     /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n     ///"}]}