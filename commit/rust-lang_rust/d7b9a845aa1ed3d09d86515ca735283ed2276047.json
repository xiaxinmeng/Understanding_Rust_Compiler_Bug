{"sha": "d7b9a845aa1ed3d09d86515ca735283ed2276047", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3YjlhODQ1YWExZWQzZDA5ZDg2NTE1Y2E3MzUyODNlZDIyNzYwNDc=", "commit": {"author": {"name": "Lukas Markeffsky", "email": "markeffsky@outlook.com", "date": "2019-08-09T15:44:05Z"}, "committer": {"name": "Lukas Markeffsky", "email": "markeffsky@outlook.com", "date": "2019-08-09T15:44:05Z"}, "message": "new_ret_no_self: walk associated types in impl Trait return types", "tree": {"sha": "0a6c95e3c3257dd63c4690baaadbf56a2f714a0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a6c95e3c3257dd63c4690baaadbf56a2f714a0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7b9a845aa1ed3d09d86515ca735283ed2276047", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7b9a845aa1ed3d09d86515ca735283ed2276047", "html_url": "https://github.com/rust-lang/rust/commit/d7b9a845aa1ed3d09d86515ca735283ed2276047", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7b9a845aa1ed3d09d86515ca735283ed2276047/comments", "author": null, "committer": null, "parents": [{"sha": "c55d38ed7ace06e4a3a5939b3c7c01045017bca4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c55d38ed7ace06e4a3a5939b3c7c01045017bca4", "html_url": "https://github.com/rust-lang/rust/commit/c55d38ed7ace06e4a3a5939b3c7c01045017bca4"}], "stats": {"total": 67, "additions": 43, "deletions": 24}, "files": [{"sha": "fc78355c399f3a934a16d1670e0cb429558dc0f4", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d7b9a845aa1ed3d09d86515ca735283ed2276047/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7b9a845aa1ed3d09d86515ca735283ed2276047/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=d7b9a845aa1ed3d09d86515ca735283ed2276047", "patch": "@@ -1070,11 +1070,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n                         (Predicate::Projection(poly_projection_predicate), _) => {\n                             let binder = poly_projection_predicate.ty();\n                             let associated_type = binder.skip_binder();\n-                            let associated_type_is_self_type = same_tys(cx, ty, associated_type);\n \n-                            // if the associated type is self, early return and do not trigger lint\n-                            if associated_type_is_self_type {\n-                                return;\n+                            // walk the associated type and check for Self\n+                            for inner_type in associated_type.walk() {\n+                                if same_tys(cx, ty, inner_type) {\n+                                    return;\n+                                }\n                             }\n                         },\n                         (_, _) => {},"}, {"sha": "bd9b178eedd698a6050b6f476534d842cc3a50e0", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d7b9a845aa1ed3d09d86515ca735283ed2276047/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7b9a845aa1ed3d09d86515ca735283ed2276047/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=d7b9a845aa1ed3d09d86515ca735283ed2276047", "patch": "@@ -23,10 +23,13 @@ use std::collections::BTreeMap;\n use std::collections::HashMap;\n use std::collections::HashSet;\n use std::collections::VecDeque;\n+use std::future::Future;\n use std::iter::FromIterator;\n use std::ops::Mul;\n+use std::pin::Pin;\n use std::rc::{self, Rc};\n use std::sync::{self, Arc};\n+use std::task::{Context, Poll};\n \n use option_helpers::IteratorFalsePositives;\n \n@@ -138,6 +141,21 @@ impl<T> V<T> {\n     }\n }\n \n+struct AsyncNew;\n+\n+impl AsyncNew {\n+    fn new() -> impl Future<Output = Option<Self>> {\n+        struct F;\n+        impl Future for F {\n+            type Output = Option<AsyncNew>;\n+            fn poll(self: Pin<&mut Self>, _cx: &mut Context) -> Poll<Self::Output> {\n+                unimplemented!()\n+            }\n+        }\n+        F\n+    }\n+}\n+\n impl Mul<T> for T {\n     type Output = T;\n     // No error, obviously."}, {"sha": "7ffee87a85c2e9e0b3b80b3aa63a55ab58f31b33", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d7b9a845aa1ed3d09d86515ca735283ed2276047/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7b9a845aa1ed3d09d86515ca735283ed2276047/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=d7b9a845aa1ed3d09d86515ca735283ed2276047", "patch": "@@ -1,5 +1,5 @@\n error: defining a method called `add` on this type; consider implementing the `std::ops::Add` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:36:5\n+  --> $DIR/methods.rs:39:5\n    |\n LL | /     pub fn add(self, other: T) -> T {\n LL | |         self\n@@ -9,7 +9,7 @@ LL | |     }\n    = note: `-D clippy::should-implement-trait` implied by `-D warnings`\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:158:13\n+  --> $DIR/methods.rs:176:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -21,7 +21,7 @@ LL | |                .unwrap_or(0);\n    = note: replace `map(|x| x + 1).unwrap_or(0)` with `map_or(0, |x| x + 1)`\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:162:13\n+  --> $DIR/methods.rs:180:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -31,7 +31,7 @@ LL | |               ).unwrap_or(0);\n    | |____________________________^\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:166:13\n+  --> $DIR/methods.rs:184:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -41,15 +41,15 @@ LL | |                 });\n    | |__________________^\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:171:13\n+  --> $DIR/methods.rs:189:13\n    |\n LL |     let _ = opt.map(|x| Some(x + 1)).unwrap_or(None);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `map(|x| Some(x + 1)).unwrap_or(None)` with `and_then(|x| Some(x + 1))`\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:173:13\n+  --> $DIR/methods.rs:191:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -59,7 +59,7 @@ LL | |     ).unwrap_or(None);\n    | |_____________________^\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:177:13\n+  --> $DIR/methods.rs:195:13\n    |\n LL |       let _ = opt\n    |  _____________^\n@@ -70,15 +70,15 @@ LL | |         .unwrap_or(None);\n    = note: replace `map(|x| Some(x + 1)).unwrap_or(None)` with `and_then(|x| Some(x + 1))`\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:188:13\n+  --> $DIR/methods.rs:206:13\n    |\n LL |     let _ = Some(\"prefix\").map(|p| format!(\"{}.\", p)).unwrap_or(id);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `map(|p| format!(\"{}.\", p)).unwrap_or(id)` with `map_or(id, |p| format!(\"{}.\", p))`\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:192:13\n+  --> $DIR/methods.rs:210:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -90,7 +90,7 @@ LL | |                .unwrap_or_else(|| 0);\n    = note: replace `map(|x| x + 1).unwrap_or_else(|| 0)` with `map_or_else(|| 0, |x| x + 1)`\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:196:13\n+  --> $DIR/methods.rs:214:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -100,7 +100,7 @@ LL | |               ).unwrap_or_else(|| 0);\n    | |____________________________________^\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:200:13\n+  --> $DIR/methods.rs:218:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -110,7 +110,7 @@ LL | |                 );\n    | |_________________^\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:230:13\n+  --> $DIR/methods.rs:248:13\n    |\n LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -119,7 +119,7 @@ LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    = note: replace `filter(|&x| *x < 0).next()` with `find(|&x| *x < 0)`\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:233:13\n+  --> $DIR/methods.rs:251:13\n    |\n LL |       let _ = v.iter().filter(|&x| {\n    |  _____________^\n@@ -129,7 +129,7 @@ LL | |                    ).next();\n    | |___________________________^\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:249:13\n+  --> $DIR/methods.rs:267:13\n    |\n LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -138,7 +138,7 @@ LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n    = note: replace `find(|&x| *x < 0).is_some()` with `any(|x| *x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:252:13\n+  --> $DIR/methods.rs:270:13\n    |\n LL |       let _ = v.iter().find(|&x| {\n    |  _____________^\n@@ -148,15 +148,15 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:258:13\n+  --> $DIR/methods.rs:276:13\n    |\n LL |     let _ = v.iter().position(|&x| x < 0).is_some();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `position(|&x| x < 0).is_some()` with `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:261:13\n+  --> $DIR/methods.rs:279:13\n    |\n LL |       let _ = v.iter().position(|&x| {\n    |  _____________^\n@@ -166,15 +166,15 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:267:13\n+  --> $DIR/methods.rs:285:13\n    |\n LL |     let _ = v.iter().rposition(|&x| x < 0).is_some();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `rposition(|&x| x < 0).is_some()` with `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:270:13\n+  --> $DIR/methods.rs:288:13\n    |\n LL |       let _ = v.iter().rposition(|&x| {\n    |  _____________^\n@@ -184,7 +184,7 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: used unwrap() on an Option value. If you don't want to handle the None case gracefully, consider using expect() to provide a better panic message\n-  --> $DIR/methods.rs:285:13\n+  --> $DIR/methods.rs:303:13\n    |\n LL |     let _ = opt.unwrap();\n    |             ^^^^^^^^^^^^"}]}