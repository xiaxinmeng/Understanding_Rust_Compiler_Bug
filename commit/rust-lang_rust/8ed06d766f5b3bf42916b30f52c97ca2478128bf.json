{"sha": "8ed06d766f5b3bf42916b30f52c97ca2478128bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlZDA2ZDc2NmY1YjNiZjQyOTE2YjMwZjUyYzk3Y2EyNDc4MTI4YmY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-04T09:48:39Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-04T09:48:39Z"}, "message": "better extend selection", "tree": {"sha": "025f877d0f797ad34f94038e5c4da137d6a47272", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/025f877d0f797ad34f94038e5c4da137d6a47272"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ed06d766f5b3bf42916b30f52c97ca2478128bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ed06d766f5b3bf42916b30f52c97ca2478128bf", "html_url": "https://github.com/rust-lang/rust/commit/8ed06d766f5b3bf42916b30f52c97ca2478128bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ed06d766f5b3bf42916b30f52c97ca2478128bf/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e44a6bcc8208f9d906febf9278120b75a6af67f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e44a6bcc8208f9d906febf9278120b75a6af67f9", "html_url": "https://github.com/rust-lang/rust/commit/e44a6bcc8208f9d906febf9278120b75a6af67f9"}], "stats": {"total": 83, "additions": 59, "deletions": 24}, "files": [{"sha": "9dc59e2541c8b8817fc2e8ade8126c30f7124547", "filename": "crates/libeditor/src/extend_selection.rs", "status": "modified", "additions": 59, "deletions": 24, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/8ed06d766f5b3bf42916b30f52c97ca2478128bf/crates%2Flibeditor%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed06d766f5b3bf42916b30f52c97ca2478128bf/crates%2Flibeditor%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fextend_selection.rs?ref=8ed06d766f5b3bf42916b30f52c97ca2478128bf", "patch": "@@ -1,7 +1,7 @@\n use libsyntax2::{\n     File, TextRange, SyntaxNodeRef, TextUnit,\n     SyntaxKind::*,\n-    algo::{find_leaf_at_offset, find_covering_node, ancestors, Direction, siblings},\n+    algo::{find_leaf_at_offset, LeafAtOffset, find_covering_node, ancestors, Direction, siblings},\n };\n \n pub fn extend_selection(file: &File, range: TextRange) -> Option<TextRange> {\n@@ -13,30 +13,15 @@ pub(crate) fn extend(root: SyntaxNodeRef, range: TextRange) -> Option<TextRange>\n     if range.is_empty() {\n         let offset = range.start();\n         let mut leaves = find_leaf_at_offset(root, offset);\n-        if let Some(leaf) = leaves.clone().find(|node| node.kind() != WHITESPACE) {\n-            return Some(leaf.range());\n+        if leaves.clone().all(|it| it.kind() == WHITESPACE) {\n+            return Some(extend_ws(root, leaves.next()?, offset));\n         }\n-        let ws = leaves.next()?;\n-        let ws_text = ws.leaf_text().unwrap();\n-        let suffix = TextRange::from_to(offset, ws.range().end()) - ws.range().start();\n-        let prefix = TextRange::from_to(ws.range().start(), offset) - ws.range().start();\n-        let ws_suffix = &ws_text.as_str()[suffix];\n-        let ws_prefix = &ws_text.as_str()[prefix];\n-        if ws_text.contains(\"\\n\") && !ws_suffix.contains(\"\\n\") {\n-            if let Some(node) = ws.next_sibling() {\n-                let start = match ws_prefix.rfind('\\n') {\n-                    Some(idx) => ws.range().start() + TextUnit::from((idx + 1) as u32),\n-                    None => node.range().start()\n-                };\n-                let end = if root.text().char_at(node.range().end()) == Some('\\n') {\n-                    node.range().end() + TextUnit::of_char('\\n')\n-                } else {\n-                    node.range().end()\n-                };\n-                return Some(TextRange::from_to(start, end));\n-            }\n-        }\n-        return Some(ws.range());\n+        let leaf = match leaves {\n+            LeafAtOffset::None => return None,\n+            LeafAtOffset::Single(l) => l,\n+            LeafAtOffset::Between(l, r) => pick_best(l, r),\n+        };\n+        return Some(leaf.range());\n     };\n     let node = find_covering_node(root, range);\n     if node.kind() == COMMENT && range == node.range() {\n@@ -51,6 +36,40 @@ pub(crate) fn extend(root: SyntaxNodeRef, range: TextRange) -> Option<TextRange>\n     }\n }\n \n+fn extend_ws(root: SyntaxNodeRef, ws: SyntaxNodeRef, offset: TextUnit) -> TextRange {\n+    let ws_text = ws.leaf_text().unwrap();\n+    let suffix = TextRange::from_to(offset, ws.range().end()) - ws.range().start();\n+    let prefix = TextRange::from_to(ws.range().start(), offset) - ws.range().start();\n+    let ws_suffix = &ws_text.as_str()[suffix];\n+    let ws_prefix = &ws_text.as_str()[prefix];\n+    if ws_text.contains(\"\\n\") && !ws_suffix.contains(\"\\n\") {\n+        if let Some(node) = ws.next_sibling() {\n+            let start = match ws_prefix.rfind('\\n') {\n+                Some(idx) => ws.range().start() + TextUnit::from((idx + 1) as u32),\n+                None => node.range().start()\n+            };\n+            let end = if root.text().char_at(node.range().end()) == Some('\\n') {\n+                node.range().end() + TextUnit::of_char('\\n')\n+            } else {\n+                node.range().end()\n+            };\n+            return TextRange::from_to(start, end);\n+        }\n+    }\n+    ws.range()\n+}\n+\n+fn pick_best<'a>(l: SyntaxNodeRef<'a>, r: SyntaxNodeRef<'a>) -> SyntaxNodeRef<'a> {\n+    return if priority(r) > priority(l) { r } else { l };\n+    fn priority(n: SyntaxNodeRef) -> usize {\n+        match n.kind() {\n+            WHITESPACE => 0,\n+            IDENT | SELF_KW | SUPER_KW | CRATE_KW => 2,\n+            _ => 1,\n+        }\n+    }\n+}\n+\n fn extend_comments(node: SyntaxNodeRef) -> Option<TextRange> {\n     let left = adj_comments(node, Direction::Backward);\n     let right = adj_comments(node, Direction::Forward);\n@@ -129,4 +148,20 @@ fn bar(){}\n             &[\"// 1 + 1\", \"// fn foo() {\\n// 1 + 1\\n// }\"]\n         );\n     }\n+\n+    #[test]\n+    fn test_extend_selection_prefer_idents() {\n+        do_check(\n+            r#\"\n+fn main() { foo<|>+bar;}\n+    \"#,\n+            &[\"foo\", \"foo+bar\"]\n+        );\n+        do_check(\n+            r#\"\n+fn main() { foo+<|>bar;}\n+    \"#,\n+            &[\"bar\", \"foo+bar\"]\n+        );\n+    }\n }"}]}