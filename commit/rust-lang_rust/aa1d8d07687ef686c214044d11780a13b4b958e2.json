{"sha": "aa1d8d07687ef686c214044d11780a13b4b958e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhMWQ4ZDA3Njg3ZWY2ODZjMjE0MDQ0ZDExNzgwYTEzYjRiOTU4ZTI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-31T17:48:54Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-31T17:48:54Z"}, "message": "Move unify_fn logic out-of-line.", "tree": {"sha": "2b8b72afc917f229c6eff8d8c164a14da03dcfac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b8b72afc917f229c6eff8d8c164a14da03dcfac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa1d8d07687ef686c214044d11780a13b4b958e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa1d8d07687ef686c214044d11780a13b4b958e2", "html_url": "https://github.com/rust-lang/rust/commit/aa1d8d07687ef686c214044d11780a13b4b958e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa1d8d07687ef686c214044d11780a13b4b958e2/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91809a17ac462e714e87b0150c0c525e52f69556", "url": "https://api.github.com/repos/rust-lang/rust/commits/91809a17ac462e714e87b0150c0c525e52f69556", "html_url": "https://github.com/rust-lang/rust/commit/91809a17ac462e714e87b0150c0c525e52f69556"}], "stats": {"total": 131, "additions": 72, "deletions": 59}, "files": [{"sha": "b7ddfe14754369075d9559131ba31f5b9a83c7ef", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 72, "deletions": 59, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/aa1d8d07687ef686c214044d11780a13b4b958e2/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1d8d07687ef686c214044d11780a13b4b958e2/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=aa1d8d07687ef686c214044d11780a13b4b958e2", "patch": "@@ -655,6 +655,75 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n         ret ures_err(terr_mismatch, expected, actual);\n     }\n \n+    fn unify_fn(&hashmap[int,@ty.t] bindings,\n+                @ty.t expected,\n+                @ty.t actual,\n+                &unify_handler handler,\n+                vec[arg] expected_inputs, @t expected_output,\n+                vec[arg] actual_inputs, @t actual_output)\n+      -> unify_result {\n+      auto expected_len = _vec.len[arg](expected_inputs);\n+      auto actual_len = _vec.len[arg](actual_inputs);\n+      if (expected_len != actual_len) {\n+        ret ures_err(terr_arg_count, expected, actual);\n+      }\n+\n+      // TODO: as above, we should have an iter2 iterator.\n+      let vec[arg] result_ins = vec();\n+      auto i = 0u;\n+      while (i < expected_len) {\n+        auto expected_input = expected_inputs.(i);\n+        auto actual_input = actual_inputs.(i);\n+\n+        // This should be safe, I think?\n+        auto result_mode;\n+        if (mode_is_alias(expected_input.mode) ||\n+            mode_is_alias(actual_input.mode)) {\n+          result_mode = ast.alias;\n+        } else {\n+          result_mode = ast.val;\n+        }\n+\n+        auto result = unify_step(bindings,\n+                                 actual_input.ty,\n+                                 expected_input.ty,\n+                                 handler);\n+\n+        alt (result) {\n+          case (ures_ok(?rty)) {\n+            result_ins += vec(rec(mode=result_mode,\n+                                  ty=rty));\n+          }\n+\n+          case (_) {\n+            ret result;\n+          }\n+        }\n+\n+        i += 1u;\n+      }\n+\n+      // Check the output.\n+      auto result_out;\n+      auto result = unify_step(bindings,\n+                               expected_output,\n+                               actual_output,\n+                               handler);\n+      alt (result) {\n+        case (ures_ok(?rty)) {\n+          result_out = rty;\n+        }\n+\n+        case (_) {\n+          ret result;\n+        }\n+      }\n+\n+      auto t = plain_ty(ty.ty_fn(result_ins, result_out));\n+      ret ures_ok(t);\n+\n+    }\n+\n     fn unify_step(&hashmap[int,@ty.t] bindings, @ty.t expected, @ty.t actual,\n                   &unify_handler handler) -> unify_result {\n         // TODO: rewrite this using tuple pattern matching when available, to\n@@ -881,65 +950,9 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n             case (ty.ty_fn(?expected_inputs, ?expected_output)) {\n                 alt (actual.struct) {\n                     case (ty.ty_fn(?actual_inputs, ?actual_output)) {\n-                        auto expected_len = _vec.len[arg](expected_inputs);\n-                        auto actual_len = _vec.len[arg](actual_inputs);\n-                        if (expected_len != actual_len) {\n-                            ret ures_err(terr_arg_count, expected, actual);\n-                        }\n-\n-                        // TODO: as above, we should have an iter2 iterator.\n-                        let vec[arg] result_ins = vec();\n-                        auto i = 0u;\n-                        while (i < expected_len) {\n-                            auto expected_input = expected_inputs.(i);\n-                            auto actual_input = actual_inputs.(i);\n-\n-                            // This should be safe, I think?\n-                            auto result_mode;\n-                            if (mode_is_alias(expected_input.mode) ||\n-                                    mode_is_alias(actual_input.mode)) {\n-                                result_mode = ast.alias;\n-                            } else {\n-                                result_mode = ast.val;\n-                            }\n-\n-                            auto result = unify_step(bindings,\n-                                                     actual_input.ty,\n-                                                     expected_input.ty,\n-                                                     handler);\n-\n-                            alt (result) {\n-                                case (ures_ok(?rty)) {\n-                                    result_ins += vec(rec(mode=result_mode,\n-                                                          ty=rty));\n-                                }\n-\n-                                case (_) {\n-                                    ret result;\n-                                }\n-                            }\n-\n-                            i += 1u;\n-                        }\n-\n-                        // Check the output.\n-                        auto result_out;\n-                        auto result = unify_step(bindings,\n-                                                 expected_output,\n-                                                 actual_output,\n-                                                 handler);\n-                        alt (result) {\n-                            case (ures_ok(?rty)) {\n-                                result_out = rty;\n-                            }\n-\n-                            case (_) {\n-                                ret result;\n-                            }\n-                        }\n-\n-                        auto t = plain_ty(ty.ty_fn(result_ins, result_out));\n-                        ret ures_ok(t);\n+                      ret unify_fn(bindings, expected, actual, handler,\n+                                   expected_inputs, expected_output,\n+                                   actual_inputs, actual_output);\n                     }\n \n                     case (_) {"}]}