{"sha": "5ab1ab4959c3a5bb55123a7f48934684fd62bc51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhYjFhYjQ5NTljM2E1YmI1NTEyM2E3ZjQ4OTM0Njg0ZmQ2MmJjNTE=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-02-07T23:27:07Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-02-09T22:17:09Z"}, "message": "Reduce queries/map lookups done by coherence\n\nThis has negligible perf impact, but it does improve the code a bit.\n\n* Only query the specialization graph of any trait once instead of once per\n  impl\n* Loop over impls only once, precomputing impl DefId and TraitRef", "tree": {"sha": "deca802e4f7c0b27f82757c7f9ff2a713e15faec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/deca802e4f7c0b27f82757c7f9ff2a713e15faec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ab1ab4959c3a5bb55123a7f48934684fd62bc51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ab1ab4959c3a5bb55123a7f48934684fd62bc51", "html_url": "https://github.com/rust-lang/rust/commit/5ab1ab4959c3a5bb55123a7f48934684fd62bc51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ab1ab4959c3a5bb55123a7f48934684fd62bc51/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71c7e149e42cb0fc78a80db70d2525973311d488", "url": "https://api.github.com/repos/rust-lang/rust/commits/71c7e149e42cb0fc78a80db70d2525973311d488", "html_url": "https://github.com/rust-lang/rust/commit/71c7e149e42cb0fc78a80db70d2525973311d488"}], "stats": {"total": 83, "additions": 37, "deletions": 46}, "files": [{"sha": "1970b1e5c5deb06f8ab7c84ad7a0ac6f15eb9e4e", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5ab1ab4959c3a5bb55123a7f48934684fd62bc51/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab1ab4959c3a5bb55123a7f48934684fd62bc51/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=5ab1ab4959c3a5bb55123a7f48934684fd62bc51", "patch": "@@ -18,14 +18,12 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::ItemKind;\n \n pub fn check_trait(tcx: TyCtxt<'_>, trait_def_id: DefId) {\n+    let lang_items = tcx.lang_items();\n     Checker { tcx, trait_def_id }\n-        .check(tcx.lang_items().drop_trait(), visit_implementation_of_drop)\n-        .check(tcx.lang_items().copy_trait(), visit_implementation_of_copy)\n-        .check(tcx.lang_items().coerce_unsized_trait(), visit_implementation_of_coerce_unsized)\n-        .check(\n-            tcx.lang_items().dispatch_from_dyn_trait(),\n-            visit_implementation_of_dispatch_from_dyn,\n-        );\n+        .check(lang_items.drop_trait(), visit_implementation_of_drop)\n+        .check(lang_items.copy_trait(), visit_implementation_of_copy)\n+        .check(lang_items.coerce_unsized_trait(), visit_implementation_of_coerce_unsized)\n+        .check(lang_items.dispatch_from_dyn_trait(), visit_implementation_of_dispatch_from_dyn);\n }\n \n struct Checker<'tcx> {"}, {"sha": "012cdb7b8aed7ab30d1f4c33f44be2beead1c3dd", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 30, "deletions": 37, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5ab1ab4959c3a5bb55123a7f48934684fd62bc51/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab1ab4959c3a5bb55123a7f48934684fd62bc51/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=5ab1ab4959c3a5bb55123a7f48934684fd62bc51", "patch": "@@ -10,36 +10,28 @@ use rustc::ty::query::Providers;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n use rustc_errors::struct_span_err;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_hir::HirId;\n \n mod builtin;\n mod inherent_impls;\n mod inherent_impls_overlap;\n mod orphan;\n mod unsafety;\n \n-fn check_impl(tcx: TyCtxt<'_>, hir_id: HirId) {\n-    let impl_def_id = tcx.hir().local_def_id(hir_id);\n+fn check_impl(tcx: TyCtxt<'_>, impl_def_id: DefId, trait_ref: ty::TraitRef<'_>) {\n+    debug!(\n+        \"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n+        trait_ref,\n+        tcx.def_path_str(impl_def_id)\n+    );\n \n-    // If there are no traits, then this implementation must have a\n-    // base type.\n-\n-    if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n-        debug!(\n-            \"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n-            trait_ref,\n-            tcx.def_path_str(impl_def_id)\n-        );\n-\n-        // Skip impls where one of the self type is an error type.\n-        // This occurs with e.g., resolve failures (#30589).\n-        if trait_ref.references_error() {\n-            return;\n-        }\n-\n-        enforce_trait_manually_implementable(tcx, impl_def_id, trait_ref.def_id);\n-        enforce_empty_impls_for_marker_traits(tcx, impl_def_id, trait_ref.def_id);\n+    // Skip impls where one of the self type is an error type.\n+    // This occurs with e.g., resolve failures (#30589).\n+    if trait_ref.references_error() {\n+        return;\n     }\n+\n+    enforce_trait_manually_implementable(tcx, impl_def_id, trait_ref.def_id);\n+    enforce_empty_impls_for_marker_traits(tcx, impl_def_id, trait_ref.def_id);\n }\n \n fn enforce_trait_manually_implementable(tcx: TyCtxt<'_>, impl_def_id: DefId, trait_def_id: DefId) {\n@@ -129,12 +121,17 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n fn coherent_trait(tcx: TyCtxt<'_>, def_id: DefId) {\n+    // Trigger building the specialization graph for the trait. This will detect and report any\n+    // overlap errors.\n+    tcx.specialization_graph_of(def_id);\n+\n     let impls = tcx.hir().trait_impls(def_id);\n-    for &impl_id in impls {\n-        check_impl(tcx, impl_id);\n-    }\n-    for &impl_id in impls {\n-        check_impl_overlap(tcx, impl_id);\n+    for &hir_id in impls {\n+        let impl_def_id = tcx.hir().local_def_id(hir_id);\n+        let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+\n+        check_impl(tcx, impl_def_id, trait_ref);\n+        check_object_overlap(tcx, impl_def_id, trait_ref);\n     }\n     builtin::check_trait(tcx, def_id);\n }\n@@ -152,24 +149,20 @@ pub fn check_coherence(tcx: TyCtxt<'_>) {\n     tcx.ensure().crate_inherent_impls_overlap_check(LOCAL_CRATE);\n }\n \n-/// Overlap: no two impls for the same trait are implemented for the\n-/// same type. Likewise, no two inherent impls for a given type\n-/// constructor provide a method with the same name.\n-fn check_impl_overlap<'tcx>(tcx: TyCtxt<'tcx>, hir_id: HirId) {\n-    let impl_def_id = tcx.hir().local_def_id(hir_id);\n-    let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+/// Checks whether an impl overlaps with the automatic `impl Trait for dyn Trait`.\n+fn check_object_overlap<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    impl_def_id: DefId,\n+    trait_ref: ty::TraitRef<'tcx>,\n+) {\n     let trait_def_id = trait_ref.def_id;\n \n     if trait_ref.references_error() {\n         debug!(\"coherence: skipping impl {:?} with error {:?}\", impl_def_id, trait_ref);\n         return;\n     }\n \n-    // Trigger building the specialization graph for the trait of this impl.\n-    // This will detect any overlap errors.\n-    tcx.specialization_graph_of(trait_def_id);\n-\n-    // check for overlap with the automatic `impl Trait for Trait`\n+    // check for overlap with the automatic `impl Trait for dyn Trait`\n     if let ty::Dynamic(ref data, ..) = trait_ref.self_ty().kind {\n         // This is something like impl Trait1 for Trait2. Illegal\n         // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe."}, {"sha": "71f997c54c6f23441951140f51a9105c1db566fb", "filename": "src/test/ui/coherence/coherence-inherited-assoc-ty-cycle-err.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ab1ab4959c3a5bb55123a7f48934684fd62bc51/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-assoc-ty-cycle-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ab1ab4959c3a5bb55123a7f48934684fd62bc51/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-assoc-ty-cycle-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-assoc-ty-cycle-err.stderr?ref=5ab1ab4959c3a5bb55123a7f48934684fd62bc51", "patch": "@@ -1,10 +1,10 @@\n-error[E0391]: cycle detected when processing `Trait`\n+error[E0391]: cycle detected when building specialization graph of trait `Trait`\n   --> $DIR/coherence-inherited-assoc-ty-cycle-err.rs:8:1\n    |\n LL | trait Trait<T> { type Assoc; }\n    | ^^^^^^^^^^^^^^\n    |\n-   = note: ...which again requires processing `Trait`, completing the cycle\n+   = note: ...which again requires building specialization graph of trait `Trait`, completing the cycle\n note: cycle used when coherence checking all impls of trait `Trait`\n   --> $DIR/coherence-inherited-assoc-ty-cycle-err.rs:8:1\n    |"}]}