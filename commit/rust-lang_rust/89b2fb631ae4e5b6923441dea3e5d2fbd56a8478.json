{"sha": "89b2fb631ae4e5b6923441dea3e5d2fbd56a8478", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5YjJmYjYzMWFlNGU1YjY5MjM0NDFkZWEzZTVkMmZiZDU2YTg0Nzg=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-18T10:50:57Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-05-25T08:07:02Z"}, "message": "rustc: integrate ty::Const into ty::print as print_const.", "tree": {"sha": "2155f5d1235b2c1649724691007fd81509c30f1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2155f5d1235b2c1649724691007fd81509c30f1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89b2fb631ae4e5b6923441dea3e5d2fbd56a8478", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89b2fb631ae4e5b6923441dea3e5d2fbd56a8478", "html_url": "https://github.com/rust-lang/rust/commit/89b2fb631ae4e5b6923441dea3e5d2fbd56a8478", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89b2fb631ae4e5b6923441dea3e5d2fbd56a8478/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28198bb3bea7c7637738588eedda2191852f7796", "url": "https://api.github.com/repos/rust-lang/rust/commits/28198bb3bea7c7637738588eedda2191852f7796", "html_url": "https://github.com/rust-lang/rust/commit/28198bb3bea7c7637738588eedda2191852f7796"}], "stats": {"total": 267, "additions": 160, "deletions": 107}, "files": [{"sha": "8ec9d42ec5f827b272ae5a78016fc45a4ee0e93b", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89b2fb631ae4e5b6923441dea3e5d2fbd56a8478/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b2fb631ae4e5b6923441dea3e5d2fbd56a8478/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=89b2fb631ae4e5b6923441dea3e5d2fbd56a8478", "patch": "@@ -462,6 +462,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             type Region = !;\n             type Type = !;\n             type DynExistential = !;\n+            type Const = !;\n \n             fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx> {\n                 self.tcx\n@@ -488,6 +489,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 Err(NonTrivialPath)\n             }\n \n+            fn print_const(\n+                self,\n+                _ct: &'tcx ty::Const<'tcx>,\n+            ) -> Result<Self::Const, Self::Error> {\n+                Err(NonTrivialPath)\n+            }\n+\n             fn path_crate(\n                 self,\n                 cnum: CrateNum,"}, {"sha": "b9ce42ac8f290847498b3b4d2bb253cf3cbf45b0", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/89b2fb631ae4e5b6923441dea3e5d2fbd56a8478/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b2fb631ae4e5b6923441dea3e5d2fbd56a8478/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=89b2fb631ae4e5b6923441dea3e5d2fbd56a8478", "patch": "@@ -791,6 +791,7 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n             type Region = ();\n             type Type = ();\n             type DynExistential = ();\n+            type Const = ();\n \n             fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n                 self.tcx\n@@ -807,7 +808,14 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n             fn print_dyn_existential(\n                 self,\n                 _predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n-                ) -> Result<Self::DynExistential, Self::Error> {\n+            ) -> Result<Self::DynExistential, Self::Error> {\n+                Ok(())\n+            }\n+\n+            fn print_const(\n+                self,\n+                _ct: &'tcx ty::Const<'tcx>,\n+            ) -> Result<Self::Const, Self::Error> {\n                 Ok(())\n             }\n "}, {"sha": "53d4466cfef684d8007e4b4c569ba64e15cfe634", "filename": "src/librustc/ty/print/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/89b2fb631ae4e5b6923441dea3e5d2fbd56a8478/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b2fb631ae4e5b6923441dea3e5d2fbd56a8478/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs?ref=89b2fb631ae4e5b6923441dea3e5d2fbd56a8478", "patch": "@@ -31,6 +31,7 @@ pub trait Printer<'gcx: 'tcx, 'tcx>: Sized {\n     type Region;\n     type Type;\n     type DynExistential;\n+    type Const;\n \n     fn tcx(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n \n@@ -66,6 +67,11 @@ pub trait Printer<'gcx: 'tcx, 'tcx>: Sized {\n         predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n     ) -> Result<Self::DynExistential, Self::Error>;\n \n+    fn print_const(\n+        self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<Self::Const, Self::Error>;\n+\n     fn path_crate(\n         self,\n         cnum: CrateNum,\n@@ -325,3 +331,11 @@ impl<'gcx: 'tcx, 'tcx, P: Printer<'gcx, 'tcx>> Print<'gcx, 'tcx, P>\n         cx.print_dyn_existential(self)\n     }\n }\n+\n+impl<'gcx: 'tcx, 'tcx, P: Printer<'gcx, 'tcx>> Print<'gcx, 'tcx, P> for &'tcx ty::Const<'tcx> {\n+    type Output = P::Const;\n+    type Error = P::Error;\n+    fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n+        cx.print_const(self)\n+    }\n+}"}, {"sha": "7212afc08dfcdae5a5037d7d908a191ff2609b46", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 121, "deletions": 106, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/89b2fb631ae4e5b6923441dea3e5d2fbd56a8478/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b2fb631ae4e5b6923441dea3e5d2fbd56a8478/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=89b2fb631ae4e5b6923441dea3e5d2fbd56a8478", "patch": "@@ -173,6 +173,7 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n         Region = Self,\n         Type = Self,\n         DynExistential = Self,\n+        Const = Self,\n     > +\n     fmt::Write\n {\n@@ -665,12 +666,10 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n             },\n             ty::Array(ty, sz) => {\n                 p!(write(\"[\"), print(ty), write(\"; \"));\n-                match sz.val {\n-                    ConstValue::Unevaluated(..) |\n-                    ConstValue::Infer(..) => p!(write(\"_\")),\n-                    ConstValue::Param(ParamConst { name, .. }) =>\n-                        p!(write(\"{}\", name)),\n-                    _ => p!(write(\"{}\", sz.unwrap_usize(self.tcx()))),\n+                if let Some(n) = sz.assert_usize(self.tcx()) {\n+                    p!(write(\"{}\", n));\n+                } else {\n+                    p!(print(sz));\n                 }\n                 p!(write(\"]\"))\n             }\n@@ -808,6 +807,113 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n \n         Ok(self)\n     }\n+\n+    fn pretty_print_const(\n+        mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<Self::Const, Self::Error> {\n+        define_scoped_cx!(self);\n+\n+        let u8 = self.tcx().types.u8;\n+        if let ty::FnDef(did, substs) = ct.ty.sty {\n+            p!(print_value_path(did, substs));\n+            return Ok(self);\n+        }\n+        if let ConstValue::Unevaluated(did, substs) = ct.val {\n+            match self.tcx().describe_def(did) {\n+                | Some(Def::Static(_))\n+                | Some(Def::Const(_))\n+                | Some(Def::AssociatedConst(_)) => p!(print_value_path(did, substs)),\n+                _ => if did.is_local() {\n+                    let span = self.tcx().def_span(did);\n+                    if let Ok(snip) = self.tcx().sess.source_map().span_to_snippet(span) {\n+                        p!(write(\"{}\", snip))\n+                    } else {\n+                        p!(write(\"_\"))\n+                    }\n+                } else {\n+                    p!(write(\"_\"))\n+                },\n+            }\n+            return Ok(self);\n+        }\n+        if let ConstValue::Infer(..) = ct.val {\n+            p!(write(\"_: \"), print(ct.ty));\n+            return Ok(self);\n+        }\n+        if let ConstValue::Param(ParamConst { name, .. }) = ct.val {\n+            p!(write(\"{}\", name));\n+            return Ok(self);\n+        }\n+        if let ConstValue::Scalar(Scalar::Bits { bits, .. }) = ct.val {\n+            match ct.ty.sty {\n+                ty::Bool => {\n+                    p!(write(\"{}\", if bits == 0 { \"false\" } else { \"true\" }));\n+                    return Ok(self);\n+                },\n+                ty::Float(ast::FloatTy::F32) => {\n+                    p!(write(\"{}f32\", Single::from_bits(bits)));\n+                    return Ok(self);\n+                },\n+                ty::Float(ast::FloatTy::F64) => {\n+                    p!(write(\"{}f64\", Double::from_bits(bits)));\n+                    return Ok(self);\n+                },\n+                ty::Uint(ui) => {\n+                    p!(write(\"{}{}\", bits, ui));\n+                    return Ok(self);\n+                },\n+                ty::Int(i) =>{\n+                    let ty = self.tcx().lift_to_global(&ct.ty).unwrap();\n+                    let size = self.tcx().layout_of(ty::ParamEnv::empty().and(ty))\n+                        .unwrap()\n+                        .size;\n+                    p!(write(\"{}{}\", sign_extend(bits, size) as i128, i));\n+                    return Ok(self);\n+                },\n+                ty::Char => {\n+                    p!(write(\"{:?}\", ::std::char::from_u32(bits as u32).unwrap()));\n+                    return Ok(self);\n+                }\n+                _ => {},\n+            }\n+        }\n+        if let ty::Ref(_, ref_ty, _) = ct.ty.sty {\n+            let byte_str = match (ct.val, &ref_ty.sty) {\n+                (ConstValue::Scalar(Scalar::Ptr(ptr)), ty::Array(t, n)) if *t == u8 => {\n+                    let n = n.unwrap_usize(self.tcx());\n+                    Some(self.tcx()\n+                        .alloc_map.lock()\n+                        .unwrap_memory(ptr.alloc_id)\n+                        .get_bytes(&self.tcx(), ptr, Size::from_bytes(n)).unwrap())\n+                },\n+                (ConstValue::Slice { data, start, end }, ty::Slice(t)) if *t == u8 => {\n+                    Some(&data.bytes[start..end])\n+                },\n+                (ConstValue::Slice { data, start, end }, ty::Str) => {\n+                    let slice = &data.bytes[start..end];\n+                    let s = ::std::str::from_utf8(slice)\n+                        .expect(\"non utf8 str from miri\");\n+                    p!(write(\"{:?}\", s));\n+                    return Ok(self);\n+                },\n+                _ => None,\n+            };\n+            if let Some(byte_str) = byte_str {\n+                p!(write(\"b\\\"\"));\n+                for &c in byte_str {\n+                    for e in std::ascii::escape_default(c) {\n+                        self.write_char(e as char)?;\n+                    }\n+                }\n+                p!(write(\"\\\"\"));\n+                return Ok(self);\n+            }\n+        }\n+        p!(write(\"{:?} : \", ct.val), print(ct.ty));\n+\n+        Ok(self)\n+    }\n }\n \n // HACK(eddyb) boxed to avoid moving around a large struct by-value.\n@@ -900,6 +1006,7 @@ impl<F: fmt::Write> Printer<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F> {\n     type Region = Self;\n     type Type = Self;\n     type DynExistential = Self;\n+    type Const = Self;\n \n     fn tcx(&'a self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.tcx\n@@ -975,6 +1082,13 @@ impl<F: fmt::Write> Printer<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F> {\n         self.pretty_print_dyn_existential(predicates)\n     }\n \n+    fn print_const(\n+        self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<Self::Const, Self::Error> {\n+        self.pretty_print_const(ct)\n+    }\n+\n     fn path_crate(\n         mut self,\n         cnum: CrateNum,\n@@ -1448,6 +1562,7 @@ impl fmt::Display for ty::RegionKind {\n forward_display_to_print! {\n     Ty<'tcx>,\n     &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    &'tcx ty::Const<'tcx>,\n \n     // HACK(eddyb) these are exhaustive instead of generic,\n     // because `for<'gcx: 'tcx, 'tcx>` isn't possible yet.\n@@ -1537,106 +1652,6 @@ define_print_and_forward_display! {\n         p!(print_def_path(self.def_id, self.substs));\n     }\n \n-    &'tcx ty::Const<'tcx> {\n-        let u8 = cx.tcx().types.u8;\n-        if let ty::FnDef(did, substs) = self.ty.sty {\n-            p!(print_value_path(did, substs));\n-            return Ok(cx);\n-        }\n-        if let ConstValue::Unevaluated(did, substs) = self.val {\n-            match cx.tcx().describe_def(did) {\n-                | Some(Def::Static(_))\n-                | Some(Def::Const(_))\n-                | Some(Def::AssociatedConst(_)) => p!(print_value_path(did, substs)),\n-                _ => if did.is_local() {\n-                    let span = cx.tcx().def_span(did);\n-                    if let Ok(snip) = cx.tcx().sess.source_map().span_to_snippet(span) {\n-                        p!(write(\"{}\", snip))\n-                    } else {\n-                        p!(write(\"_\"))\n-                    }\n-                } else {\n-                    p!(write(\"_\"))\n-                },\n-            }\n-            return Ok(cx);\n-        }\n-        if let ConstValue::Infer(..) = self.val {\n-            p!(write(\"_: \"), print(self.ty));\n-            return Ok(cx);\n-        }\n-        if let ConstValue::Param(ParamConst { name, .. }) = self.val {\n-            p!(write(\"{}\", name));\n-            return Ok(cx);\n-        }\n-        if let ConstValue::Scalar(Scalar::Bits { bits, .. }) = self.val {\n-            match self.ty.sty {\n-                ty::Bool => {\n-                    p!(write(\"{}\", if bits == 0 { \"false\" } else { \"true\" }));\n-                    return Ok(cx);\n-                },\n-                ty::Float(ast::FloatTy::F32) => {\n-                    p!(write(\"{}f32\", Single::from_bits(bits)));\n-                    return Ok(cx);\n-                },\n-                ty::Float(ast::FloatTy::F64) => {\n-                    p!(write(\"{}f64\", Double::from_bits(bits)));\n-                    return Ok(cx);\n-                },\n-                ty::Uint(ui) => {\n-                    p!(write(\"{}{}\", bits, ui));\n-                    return Ok(cx);\n-                },\n-                ty::Int(i) =>{\n-                    let ty = cx.tcx().lift_to_global(&self.ty).unwrap();\n-                    let size = cx.tcx().layout_of(ty::ParamEnv::empty().and(ty))\n-                        .unwrap()\n-                        .size;\n-                    p!(write(\"{}{}\", sign_extend(bits, size) as i128, i));\n-                    return Ok(cx);\n-                },\n-                ty::Char => {\n-                    p!(write(\"{:?}\", ::std::char::from_u32(bits as u32).unwrap()));\n-                    return Ok(cx);\n-                }\n-                _ => {},\n-            }\n-        }\n-        if let ty::Ref(_, ref_ty, _) = self.ty.sty {\n-            let byte_str = match (self.val, &ref_ty.sty) {\n-                (ConstValue::Scalar(Scalar::Ptr(ptr)), ty::Array(t, n)) if *t == u8 => {\n-                    let n = n.unwrap_usize(cx.tcx());\n-                    Some(cx.tcx()\n-                        .alloc_map.lock()\n-                        .unwrap_memory(ptr.alloc_id)\n-                        .get_bytes(&cx.tcx(), ptr, Size::from_bytes(n)).unwrap())\n-                },\n-                (ConstValue::Slice { data, start, end }, ty::Slice(t)) if *t == u8 => {\n-                    Some(&data.bytes[start..end])\n-                },\n-                (ConstValue::Slice { data, start, end }, ty::Str) => {\n-                    let slice = &data.bytes[start..end];\n-                    let s = ::std::str::from_utf8(slice)\n-                        .expect(\"non utf8 str from miri\");\n-                    p!(write(\"{:?}\", s));\n-                    return Ok(cx);\n-                },\n-                _ => None,\n-            };\n-            if let Some(byte_str) = byte_str {\n-                p!(write(\"b\\\"\"));\n-                for &c in byte_str {\n-                    for e in std::ascii::escape_default(c) {\n-                        cx.write_char(e as char)?;\n-                    }\n-                }\n-                p!(write(\"\\\"\"));\n-                return Ok(cx);\n-            }\n-        }\n-        p!(write(\"{:?} : \", self.val), print(self.ty));\n-    }\n-\n     ty::ParamTy {\n         p!(write(\"{}\", self.name))\n     }"}, {"sha": "f2f9ac8931feec25ff59fef32c8e45290d034d7f", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89b2fb631ae4e5b6923441dea3e5d2fbd56a8478/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b2fb631ae4e5b6923441dea3e5d2fbd56a8478/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=89b2fb631ae4e5b6923441dea3e5d2fbd56a8478", "patch": "@@ -391,6 +391,7 @@ impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n     type Region = Self;\n     type Type = Self;\n     type DynExistential = Self;\n+    type Const = Self;\n \n     fn tcx(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.tcx\n@@ -436,6 +437,13 @@ impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n         Ok(self)\n     }\n \n+    fn print_const(\n+        self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<Self::Const, Self::Error> {\n+        self.pretty_print_const(ct)\n+    }\n+\n     fn path_crate(\n         mut self,\n         cnum: CrateNum,"}]}