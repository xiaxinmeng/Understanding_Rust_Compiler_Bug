{"sha": "c25556865205e6978e6bc9eb0e6d5e151e1a68d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyNTU1Njg2NTIwNWU2OTc4ZTZiYzllYjBlNmQ1ZTE1MWUxYTY4ZDk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-10T20:46:05Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-16T06:22:06Z"}, "message": "core: Implement unwrap()/unwrap_err() on Result\n\nNow that std::fmt is in libcore, it's possible to implement this as an inherit\nmethod rather than through extension traits.\n\nThis commit also tweaks the failure interface of libcore to libstd to what it\nshould be, one method taking &fmt::Arguments", "tree": {"sha": "e4b76d3dad3688c127a17937dafb24ae6eeefee6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4b76d3dad3688c127a17937dafb24ae6eeefee6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c25556865205e6978e6bc9eb0e6d5e151e1a68d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c25556865205e6978e6bc9eb0e6d5e151e1a68d9", "html_url": "https://github.com/rust-lang/rust/commit/c25556865205e6978e6bc9eb0e6d5e151e1a68d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c25556865205e6978e6bc9eb0e6d5e151e1a68d9/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf0619383d2ce0f7bd822f82cf487c7fa33d0b76", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf0619383d2ce0f7bd822f82cf487c7fa33d0b76", "html_url": "https://github.com/rust-lang/rust/commit/cf0619383d2ce0f7bd822f82cf487c7fa33d0b76"}], "stats": {"total": 414, "additions": 66, "deletions": 348}, "files": [{"sha": "c4a2c9a609925fd15b9a565801c8399ad04d1bba", "filename": "src/libcore/failure.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c25556865205e6978e6bc9eb0e6d5e151e1a68d9/src%2Flibcore%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25556865205e6978e6bc9eb0e6d5e151e1a68d9/src%2Flibcore%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffailure.rs?ref=c25556865205e6978e6bc9eb0e6d5e151e1a68d9", "patch": "@@ -9,21 +9,28 @@\n // except according to those terms.\n \n //! Failure support for libcore\n+//!\n+//! The core library cannot define failure, but it does *declare* failure. This\n+//! means that the functions inside of libcore are allowed to fail, but to be\n+//! useful an upstream crate must define failure for libcore to use. The current\n+//! interface for failure is:\n+//!\n+//!     fn begin_unwind(fmt: &fmt::Arguments, file: &str, line: uint) -> !;\n+//!\n+//! This definition allows for failing with any general message, but it does not\n+//! allow for failing with a `~Any` value. The reason for this is that libcore\n+//! is not allowed to allocate.\n+//!\n+//! This module contains a few other failure functions, but these are just the\n+//! necessary lang items for the compiler. All failure is funneled through this\n+//! one function. Currently, the actual symbol is declared in the standard\n+//! library, but the location of this may change over time.\n \n #![allow(dead_code, missing_doc)]\n \n #[cfg(not(test))]\n use str::raw::c_str_to_static_slice;\n-\n-// FIXME: Once std::fmt is in libcore, all of these functions should delegate\n-//        to a common failure function with this signature:\n-//\n-//          extern {\n-//              fn rust_unwind(f: &fmt::Arguments, file: &str, line: uint) -> !;\n-//          }\n-//\n-//        Each of these functions can create a temporary fmt::Arguments\n-//        structure to pass to this function.\n+use fmt;\n \n #[cold] #[inline(never)] // this is the slow path, always\n #[lang=\"fail_\"]\n@@ -32,24 +39,31 @@ fn fail_(expr: *u8, file: *u8, line: uint) -> ! {\n     unsafe {\n         let expr = c_str_to_static_slice(expr as *i8);\n         let file = c_str_to_static_slice(file as *i8);\n-        begin_unwind(expr, file, line)\n+        format_args!(|args| -> () {\n+            begin_unwind(args, file, line);\n+        }, \"{}\", expr);\n+\n+        loop {}\n     }\n }\n \n #[cold]\n #[lang=\"fail_bounds_check\"]\n #[cfg(not(test))]\n fn fail_bounds_check(file: *u8, line: uint, index: uint, len: uint) -> ! {\n-    #[allow(ctypes)]\n-    extern { fn rust_fail_bounds_check(file: *u8, line: uint,\n-                                       index: uint, len: uint,) -> !; }\n-    unsafe { rust_fail_bounds_check(file, line, index, len) }\n+    let file = unsafe { c_str_to_static_slice(file as *i8) };\n+    format_args!(|args| -> () {\n+        begin_unwind(args, file, line);\n+    }, \"index out of bounds: the len is {} but the index is {}\", len, index);\n+    loop {}\n }\n \n #[cold]\n-pub fn begin_unwind(msg: &str, file: &'static str, line: uint) -> ! {\n+pub fn begin_unwind(fmt: &fmt::Arguments, file: &'static str, line: uint) -> ! {\n+    // FIXME: this should be a proper lang item, it should not just be some\n+    //        undefined symbol sitting in the middle of nowhere.\n     #[allow(ctypes)]\n-    extern { fn rust_begin_unwind(msg: &str, file: &'static str,\n+    extern { fn rust_begin_unwind(fmt: &fmt::Arguments, file: &'static str,\n                                   line: uint) -> !; }\n-    unsafe { rust_begin_unwind(msg, file, line) }\n+    unsafe { rust_begin_unwind(fmt, file, line) }\n }"}, {"sha": "81f089ae67d10ceabf161d05a15e4799b4a4cdc3", "filename": "src/libcore/result.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c25556865205e6978e6bc9eb0e6d5e151e1a68d9/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25556865205e6978e6bc9eb0e6d5e151e1a68d9/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=c25556865205e6978e6bc9eb0e6d5e151e1a68d9", "patch": "@@ -268,6 +268,7 @@\n \n use clone::Clone;\n use cmp::Eq;\n+use fmt::Show;\n use iter::{Iterator, FromIterator};\n use option::{None, Option, Some};\n \n@@ -515,6 +516,34 @@ impl<T, E> Result<T, E> {\n     }\n }\n \n+impl<T, E: Show> Result<T, E> {\n+    /// Unwraps a result, yielding the content of an `Ok`.\n+    ///\n+    /// Fails if the value is an `Err`.\n+    #[inline]\n+    pub fn unwrap(self) -> T {\n+        match self {\n+            Ok(t) => t,\n+            Err(e) =>\n+                fail!(\"called `Result::unwrap()` on an `Err` value: {}\", e)\n+        }\n+    }\n+}\n+\n+impl<T: Show, E> Result<T, E> {\n+    /// Unwraps a result, yielding the content of an `Err`.\n+    ///\n+    /// Fails if the value is an `Ok`.\n+    #[inline]\n+    pub fn unwrap_err(self) -> E {\n+        match self {\n+            Ok(t) =>\n+                fail!(\"called `Result::unwrap_err()` on an `Ok` value: {}\", t),\n+            Err(e) => e\n+        }\n+    }\n+}\n+\n /////////////////////////////////////////////////////////////////////////////\n // Free functions\n /////////////////////////////////////////////////////////////////////////////"}, {"sha": "119cd9aa2ca8848159a7dade3b5c94187a9ed6fd", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25556865205e6978e6bc9eb0e6d5e151e1a68d9/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25556865205e6978e6bc9eb0e6d5e151e1a68d9/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=c25556865205e6978e6bc9eb0e6d5e151e1a68d9", "patch": "@@ -153,6 +153,7 @@ pub use core::mem;\n pub use core::ptr;\n pub use core::raw;\n pub use core::tuple;\n+pub use core::result;\n \n // Run tests with libgreen instead of libnative.\n //\n@@ -218,7 +219,6 @@ pub mod hash;\n \n /* Common data structures */\n \n-pub mod result;\n pub mod option;\n \n /* Tasks and communication */"}, {"sha": "e39d8d34447a465e4eb54e8aaa91e762fb50e026", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c25556865205e6978e6bc9eb0e6d5e151e1a68d9/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25556865205e6978e6bc9eb0e6d5e151e1a68d9/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=c25556865205e6978e6bc9eb0e6d5e151e1a68d9", "patch": "@@ -64,13 +64,12 @@ pub use iter::{Iterator, DoubleEndedIterator, RandomAccessIterator, CloneableIte\n pub use iter::{OrdIterator, MutableDoubleEndedIterator, ExactSize};\n pub use num::{Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n pub use num::{Signed, Unsigned};\n-pub use num::{Primitive, Int, Float, ToPrimitive, FromPrimitive};\n+pub use num::{Primitive, Int, Float, FloatMath, ToPrimitive, FromPrimitive};\n pub use option::Expect;\n pub use owned::Box;\n pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n pub use ptr::RawPtr;\n pub use io::{Buffer, Writer, Reader, Seek};\n-pub use result::{ResultUnwrap, ResultUnwrapErr};\n pub use str::{Str, StrVector, StrSlice, OwnedStr, IntoMaybeOwned};\n pub use str::{StrAllocating};\n pub use to_str::{ToStr, IntoStr};"}, {"sha": "ecbc164590b5e85b81a21c1925676bd28c8cbf70", "filename": "src/libstd/result.rs", "status": "removed", "additions": 0, "deletions": 312, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/cf0619383d2ce0f7bd822f82cf487c7fa33d0b76/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0619383d2ce0f7bd822f82cf487c7fa33d0b76/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=cf0619383d2ce0f7bd822f82cf487c7fa33d0b76", "patch": "@@ -1,312 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Error handling with the `Result` type\n-//!\n-//! `Result<T>` is the type used for returning and propagating\n-//! errors. It is an enum with the variants, `Ok(T)`, representing\n-//! success and containing a value, and `Err(E)`, representing error\n-//! and containing an error value.\n-//!\n-//! ~~~\n-//! enum Result<T, E> {\n-//!    Ok(T),\n-//!    Err(E)\n-//! }\n-//! ~~~\n-//!\n-//! Functions return `Result` whenever errors are expected and\n-//! recoverable. In the `std` crate `Result` is most prominently used\n-//! for [I/O](../io/index.html).\n-//!\n-//! A simple function returning `Result` might be\n-//! defined and used like so:\n-//!\n-//! ~~~\n-//! #[deriving(Show)]\n-//! enum Version { Version1, Version2 }\n-//!\n-//! fn parse_version(header: &[u8]) -> Result<Version, &'static str> {\n-//!     if header.len() < 1 {\n-//!         return Err(\"invalid header length\");\n-//!     }\n-//!     match header[0] {\n-//!         1 => Ok(Version1),\n-//!         2 => Ok(Version2),\n-//!         _ => Err(\"invalid version\")\n-//!     }\n-//! }\n-//!\n-//! let version = parse_version(&[1, 2, 3, 4]);\n-//! match version {\n-//!     Ok(v) => {\n-//!         println!(\"working with version: {}\", v);\n-//!     }\n-//!     Err(e) => {\n-//!         println!(\"error parsing header: {}\", e);\n-//!     }\n-//! }\n-//! ~~~\n-//!\n-//! Pattern matching on `Result`s is clear and straightforward for\n-//! simple cases, but `Result` comes with some convenience methods\n-//! that make working it more succinct.\n-//!\n-//! ~~~\n-//! let good_result: Result<int, int> = Ok(10);\n-//! let bad_result: Result<int, int> = Err(10);\n-//!\n-//! // The `is_ok` and `is_err` methods do what they say.\n-//! assert!(good_result.is_ok() && !good_result.is_err());\n-//! assert!(bad_result.is_err() && !bad_result.is_ok());\n-//!\n-//! // `map` consumes the `Result` and produces another.\n-//! let good_result: Result<int, int> = good_result.map(|i| i + 1);\n-//! let bad_result: Result<int, int> = bad_result.map(|i| i - 1);\n-//!\n-//! // Use `and_then` to continue the computation.\n-//! let good_result: Result<bool, int> = good_result.and_then(|i| Ok(i == 11));\n-//!\n-//! // Use `or_else` to handle the error.\n-//! let bad_result: Result<int, int> = bad_result.or_else(|i| Ok(11));\n-//!\n-//! // Consume the result and return the contents with `unwrap`.\n-//! let final_awesome_result = good_result.ok().unwrap();\n-//! ~~~\n-//!\n-//! # Results must be used\n-//!\n-//! A common problem with using return values to indicate errors is\n-//! that it is easy to ignore the return value, thus failing to handle\n-//! the error. Result is annotated with the #[must_use] attribute,\n-//! which will cause the compiler to issue a warning when a Result\n-//! value is ignored. This makes `Result` especially useful with\n-//! functions that may encounter errors but don't otherwise return a\n-//! useful value.\n-//!\n-//! Consider the `write_line` method defined for I/O types\n-//! by the [`Writer`](../io/trait.Writer.html) trait:\n-//!\n-//! ~~~\n-//! use std::io::IoError;\n-//!\n-//! trait Writer {\n-//!     fn write_line(&mut self, s: &str) -> Result<(), IoError>;\n-//! }\n-//! ~~~\n-//!\n-//! *Note: The actual definition of `Writer` uses `IoResult`, which\n-//! is just a synonym for `Result<T, IoError>`.*\n-//!\n-//! This method doesn`t produce a value, but the write may\n-//! fail. It's crucial to handle the error case, and *not* write\n-//! something like this:\n-//!\n-//! ~~~ignore\n-//! use std::io::{File, Open, Write};\n-//!\n-//! let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n-//! // If `write_line` errors, then we'll never know, because the return\n-//! // value is ignored.\n-//! file.write_line(\"important message\");\n-//! drop(file);\n-//! ~~~\n-//!\n-//! If you *do* write that in Rust, the compiler will by give you a\n-//! warning (by default, controlled by the `unused_must_use` lint).\n-//!\n-//! You might instead, if you don't want to handle the error, simply\n-//! fail, by converting to an `Option` with `ok`, then asserting\n-//! success with `expect`. This will fail if the write fails, proving\n-//! a marginally useful message indicating why:\n-//!\n-//! ~~~no_run\n-//! use std::io::{File, Open, Write};\n-//!\n-//! let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n-//! file.write_line(\"important message\").ok().expect(\"failed to write message\");\n-//! drop(file);\n-//! ~~~\n-//!\n-//! You might also simply assert success:\n-//!\n-//! ~~~no_run\n-//! # use std::io::{File, Open, Write};\n-//!\n-//! # let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n-//! assert!(file.write_line(\"important message\").is_ok());\n-//! # drop(file);\n-//! ~~~\n-//!\n-//! Or propagate the error up the call stack with `try!`:\n-//!\n-//! ~~~\n-//! # use std::io::{File, Open, Write, IoError};\n-//! fn write_message() -> Result<(), IoError> {\n-//!     let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n-//!     try!(file.write_line(\"important message\"));\n-//!     drop(file);\n-//!     return Ok(());\n-//! }\n-//! ~~~\n-//!\n-//! # The `try!` macro\n-//!\n-//! When writing code that calls many functions that return the\n-//! `Result` type, the error handling can be tedious.  The `try!`\n-//! macro hides some of the boilerplate of propagating errors up the\n-//! call stack.\n-//!\n-//! It replaces this:\n-//!\n-//! ~~~\n-//! use std::io::{File, Open, Write, IoError};\n-//!\n-//! struct Info { name: ~str, age: int, rating: int }\n-//!\n-//! fn write_info(info: &Info) -> Result<(), IoError> {\n-//!     let mut file = File::open_mode(&Path::new(\"my_best_friends.txt\"), Open, Write);\n-//!     // Early return on error\n-//!     match file.write_line(format!(\"name: {}\", info.name)) {\n-//!         Ok(_) => (),\n-//!         Err(e) => return Err(e)\n-//!     }\n-//!     match file.write_line(format!(\"age: {}\", info.age)) {\n-//!         Ok(_) => (),\n-//!         Err(e) => return Err(e)\n-//!     }\n-//!     return file.write_line(format!(\"rating: {}\", info.rating));\n-//! }\n-//! ~~~\n-//!\n-//! With this:\n-//!\n-//! ~~~\n-//! use std::io::{File, Open, Write, IoError};\n-//!\n-//! struct Info { name: ~str, age: int, rating: int }\n-//!\n-//! fn write_info(info: &Info) -> Result<(), IoError> {\n-//!     let mut file = File::open_mode(&Path::new(\"my_best_friends.txt\"), Open, Write);\n-//!     // Early return on error\n-//!     try!(file.write_line(format!(\"name: {}\", info.name)));\n-//!     try!(file.write_line(format!(\"age: {}\", info.age)));\n-//!     try!(file.write_line(format!(\"rating: {}\", info.rating)));\n-//!     return Ok(());\n-//! }\n-//! ~~~\n-//!\n-//! *It's much nicer!*\n-//!\n-//! Wrapping an expression in `try!` will result in the unwrapped\n-//! success (`Ok`) value, unless the result is `Err`, in which case\n-//! `Err` is returned early from the enclosing function. Its simple definition\n-//! makes it clear:\n-//!\n-//! ~~~\n-//! # #![feature(macro_rules)]\n-//! macro_rules! try(\n-//!     ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n-//! )\n-//! # fn main() { }\n-//! ~~~\n-//!\n-//! `try!` is imported by the prelude, and is available everywhere.\n-//!\n-//! # `Result` and `Option`\n-//!\n-//! The `Result` and [`Option`](../option/index.html) types are\n-//! similar and complementary: they are often employed to indicate a\n-//! lack of a return value; and they are trivially converted between\n-//! each other, so `Result`s are often handled by first converting to\n-//! `Option` with the [`ok`](../../core/result/enum.Result.html#method.ok) and\n-//! [`err`](../../core/result/enum.Result.html#method.ok) methods.\n-//!\n-//! Whereas `Option` only indicates the lack of a value, `Result` is\n-//! specifically for error reporting, and carries with it an error\n-//! value.  Sometimes `Option` is used for indicating errors, but this\n-//! is only for simple cases and is generally discouraged. Even when\n-//! there is no useful error value to return, prefer `Result<T, ()>`.\n-//!\n-//! Converting to an `Option` with `ok()` to handle an error:\n-//!\n-//! ~~~\n-//! use std::io::Timer;\n-//! let mut t = Timer::new().ok().expect(\"failed to create timer!\");\n-//! ~~~\n-//!\n-//! # `Result` vs. `fail!`\n-//!\n-//! `Result` is for recoverable errors; `fail!` is for unrecoverable\n-//! errors. Callers should always be able to avoid failure if they\n-//! take the proper precautions, for example, calling `is_some()`\n-//! on an `Option` type before calling `unwrap`.\n-//!\n-//! The suitability of `fail!` as an error handling mechanism is\n-//! limited by Rust's lack of any way to \"catch\" and resume execution\n-//! from a thrown exception. Therefore using failure for error\n-//! handling requires encapsulating fallable code in a task. Calling\n-//! the `fail!` macro, or invoking `fail!` indirectly should be\n-//! avoided as an error reporting strategy. Failure is only for\n-//! unrecoverable errors and a failing task is typically the sign of\n-//! a bug.\n-//!\n-//! A module that instead returns `Results` is alerting the caller\n-//! that failure is possible, and providing precise control over how\n-//! it is handled.\n-//!\n-//! Furthermore, failure may not be recoverable at all, depending on\n-//! the context. The caller of `fail!` should assume that execution\n-//! will not resume after failure, that failure is catastrophic.\n-\n-use fmt::Show;\n-\n-pub use core::result::{Result, Ok, Err, collect, fold, fold_};\n-\n-// FIXME: These traits should not exist. Once std::fmt is moved to libcore,\n-//        these can once again become inherent methods on Result.\n-\n-/// Temporary trait for unwrapping a result\n-pub trait ResultUnwrap<T, E> {\n-    /// Unwraps a result, yielding the content of an `Ok`.\n-    ///\n-    /// Fails if the value is an `Err`.\n-    fn unwrap(self) -> T;\n-}\n-\n-/// Temporary trait for unwrapping the error of a result\n-pub trait ResultUnwrapErr<T, E> {\n-    /// Unwraps a result, yielding the content of an `Err`.\n-    ///\n-    /// Fails if the value is an `Ok`.\n-    fn unwrap_err(self) -> E;\n-}\n-\n-impl<T, E: Show> ResultUnwrap<T, E> for Result<T, E> {\n-    #[inline]\n-    fn unwrap(self) -> T {\n-        match self {\n-            Ok(t) => t,\n-            Err(e) =>\n-                fail!(\"called `Result::unwrap()` on an `Err` value: {}\", e)\n-        }\n-    }\n-}\n-\n-impl<T: Show, E> ResultUnwrapErr<T, E> for Result<T, E> {\n-    #[inline]\n-    fn unwrap_err(self) -> E {\n-        match self {\n-            Ok(t) =>\n-                fail!(\"called `Result::unwrap_err()` on an `Ok` value: {}\", t),\n-            Err(e) => e\n-        }\n-    }\n-}"}, {"sha": "c53346f69eee64f88f926c6b15fdcbc8639a4cff", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c25556865205e6978e6bc9eb0e6d5e151e1a68d9/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25556865205e6978e6bc9eb0e6d5e151e1a68d9/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=c25556865205e6978e6bc9eb0e6d5e151e1a68d9", "patch": "@@ -295,24 +295,12 @@ pub mod eabi {\n     }\n }\n \n-#[cold]\n-#[no_mangle]\n-#[cfg(not(test))]\n-pub extern fn rust_fail_bounds_check(file: *u8, line: uint,\n-                                     index: uint, len: uint) -> ! {\n-    use str::raw::c_str_to_static_slice;\n-\n-    let msg = format!(\"index out of bounds: the len is {} but the index is {}\",\n-                      len as uint, index as uint);\n-    begin_unwind(msg, unsafe { c_str_to_static_slice(file as *i8) }, line)\n-}\n-\n // Entry point of failure from the libcore crate\n #[no_mangle]\n #[cfg(not(test))]\n-pub extern fn rust_begin_unwind(msg: &str, file: &'static str, line: uint) -> ! {\n-    use str::StrAllocating;\n-    begin_unwind(msg.to_owned(), file, line)\n+pub extern fn rust_begin_unwind(msg: &fmt::Arguments,\n+                                file: &'static str, line: uint) -> ! {\n+    begin_unwind_fmt(msg, file, line)\n }\n \n /// The entry point for unwinding with a formatted message."}]}