{"sha": "ce00a8dd4d795f47a38a207af861a2cffcee7256", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlMDBhOGRkNGQ3OTVmNDdhMzhhMjA3YWY4NjFhMmNmZmNlZTcyNTY=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-11-30T17:05:56Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-11-30T18:03:41Z"}, "message": "Rollup merge of #56268 - nnethercote:fold_opt_expr-recycle, r=petrochenkov\n\nReuse the `P` in `InvocationCollector::fold_{,opt_}expr`.\n\nThis requires adding a new method, `P::filter_map`.\n\nThis commit reduces instruction counts for various benchmarks by up to\n0.7%.", "tree": {"sha": "2a6bc7612cd2b92a7766bc2d227617734106464b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a6bc7612cd2b92a7766bc2d227617734106464b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce00a8dd4d795f47a38a207af861a2cffcee7256", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlwBe34ACgkQ/vbIBR0O\nATzm4w/+LcQBL+Lx14CNQBvN5vQiJcMnFSF2spoVf9zOOaZvLxrs8c7UmlbQqZWi\nB/LXtIRRWShoaz9MqeEvcROjaLVTC4Btdn3BkDOPUTaACqx6UpRQKaEPhEcMF2fi\nfL0wrgqA62vocx4CEEODakx3ZMDDa+B5qQbygud5sxv7eUNy5bR5Ogm9Cu+XMyXg\nP74nLHcEIOa1MydoZViFOdHAS8rGkp6xyfEbKkjMhBuXhTcPGtvFLxLCEKVlotmv\nMGvGDN1gjk/ZBXskGDDCw7UwzQEoMFIEXHyFJrdZ+5Oe4s5E1J2A76T43ZiRe1ui\nnUxG//VQ23mv6/iwftDivpbAynMjd7pyC/gbWId3iuU3f/wA4EbtJ+RgkWL/sye6\nNq1vEkJBTBCgbRdBOzWtvCUO0aQFAc0b/dE0ui8wevgBt6LxB5IlJ0feSuodGynC\ntQfc/oWwcxXvZWiuuydn9zxsWJkrLMXymAZjyfecqtjkQneUc/8yHA5vdDY79vv9\nbPVivbpSGhbVnZfMIBINTQaasBgLhxiamnqizvPbyW9DyucfJ2SmVTyWA4VgVg1w\nUBG5KrMMjwq4lWNmmjI9sXKHchsVhLxvrao0lpMWtQjponBYaJY1WzgTip4nV0+M\nMLEsukXglCzJg9VqLGktT8fJELJapAis+VOPnzBnSkWwEtqCHXg=\n=g84f\n-----END PGP SIGNATURE-----", "payload": "tree 2a6bc7612cd2b92a7766bc2d227617734106464b\nparent f7c407eb8bc9413d9d1449eeda9710715ad255a2\nparent 6674db48872c1b84fe3ac3feb94b8d3e0ee82b24\nauthor kennytm <kennytm@gmail.com> 1543597556 +0800\ncommitter kennytm <kennytm@gmail.com> 1543601021 +0800\n\nRollup merge of #56268 - nnethercote:fold_opt_expr-recycle, r=petrochenkov\n\nReuse the `P` in `InvocationCollector::fold_{,opt_}expr`.\n\nThis requires adding a new method, `P::filter_map`.\n\nThis commit reduces instruction counts for various benchmarks by up to\n0.7%.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce00a8dd4d795f47a38a207af861a2cffcee7256", "html_url": "https://github.com/rust-lang/rust/commit/ce00a8dd4d795f47a38a207af861a2cffcee7256", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce00a8dd4d795f47a38a207af861a2cffcee7256/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7c407eb8bc9413d9d1449eeda9710715ad255a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7c407eb8bc9413d9d1449eeda9710715ad255a2", "html_url": "https://github.com/rust-lang/rust/commit/f7c407eb8bc9413d9d1449eeda9710715ad255a2"}, {"sha": "6674db48872c1b84fe3ac3feb94b8d3e0ee82b24", "url": "https://api.github.com/repos/rust-lang/rust/commits/6674db48872c1b84fe3ac3feb94b8d3e0ee82b24", "html_url": "https://github.com/rust-lang/rust/commit/6674db48872c1b84fe3ac3feb94b8d3e0ee82b24"}], "stats": {"total": 112, "additions": 73, "deletions": 39}, "files": [{"sha": "68a96293891a0c0bbce93e0c9ad83d9c8e95f85b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 48, "deletions": 36, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/ce00a8dd4d795f47a38a207af861a2cffcee7256/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce00a8dd4d795f47a38a207af861a2cffcee7256/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ce00a8dd4d795f47a38a207af861a2cffcee7256", "patch": "@@ -1201,50 +1201,62 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n \n impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n-        let mut expr = self.cfg.configure_expr(expr).into_inner();\n-        expr.node = self.cfg.configure_expr_kind(expr.node);\n-\n-        // ignore derives so they remain unused\n-        let (attr, expr, after_derive) = self.classify_nonitem(expr);\n-\n-        if attr.is_some() {\n-            // collect the invoc regardless of whether or not attributes are permitted here\n-            // expansion will eat the attribute so it won't error later\n-            attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n-\n-            // AstFragmentKind::Expr requires the macro to emit an expression\n-            return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n-                                     AstFragmentKind::Expr, after_derive).make_expr();\n-        }\n+        let expr = self.cfg.configure_expr(expr);\n+        expr.map(|mut expr| {\n+            expr.node = self.cfg.configure_expr_kind(expr.node);\n+\n+            // ignore derives so they remain unused\n+            let (attr, expr, after_derive) = self.classify_nonitem(expr);\n+\n+            if attr.is_some() {\n+                // Collect the invoc regardless of whether or not attributes are permitted here\n+                // expansion will eat the attribute so it won't error later.\n+                attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n+\n+                // AstFragmentKind::Expr requires the macro to emit an expression.\n+                return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n+                                         AstFragmentKind::Expr, after_derive)\n+                    .make_expr()\n+                    .into_inner()\n+            }\n \n-        if let ast::ExprKind::Mac(mac) = expr.node {\n-            self.check_attributes(&expr.attrs);\n-            self.collect_bang(mac, expr.span, AstFragmentKind::Expr).make_expr()\n-        } else {\n-            P(noop_fold_expr(expr, self))\n-        }\n+            if let ast::ExprKind::Mac(mac) = expr.node {\n+                self.check_attributes(&expr.attrs);\n+                self.collect_bang(mac, expr.span, AstFragmentKind::Expr)\n+                    .make_expr()\n+                    .into_inner()\n+            } else {\n+                noop_fold_expr(expr, self)\n+            }\n+        })\n     }\n \n     fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-        let mut expr = configure!(self, expr).into_inner();\n-        expr.node = self.cfg.configure_expr_kind(expr.node);\n+        let expr = configure!(self, expr);\n+        expr.filter_map(|mut expr| {\n+            expr.node = self.cfg.configure_expr_kind(expr.node);\n \n-        // ignore derives so they remain unused\n-        let (attr, expr, after_derive) = self.classify_nonitem(expr);\n+            // Ignore derives so they remain unused.\n+            let (attr, expr, after_derive) = self.classify_nonitem(expr);\n \n-        if attr.is_some() {\n-            attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n+            if attr.is_some() {\n+                attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n \n-            return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n-                                     AstFragmentKind::OptExpr, after_derive).make_opt_expr();\n-        }\n+                return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n+                                         AstFragmentKind::OptExpr, after_derive)\n+                    .make_opt_expr()\n+                    .map(|expr| expr.into_inner())\n+            }\n \n-        if let ast::ExprKind::Mac(mac) = expr.node {\n-            self.check_attributes(&expr.attrs);\n-            self.collect_bang(mac, expr.span, AstFragmentKind::OptExpr).make_opt_expr()\n-        } else {\n-            Some(P(noop_fold_expr(expr, self)))\n-        }\n+            if let ast::ExprKind::Mac(mac) = expr.node {\n+                self.check_attributes(&expr.attrs);\n+                self.collect_bang(mac, expr.span, AstFragmentKind::OptExpr)\n+                    .make_opt_expr()\n+                    .map(|expr| expr.into_inner())\n+            } else {\n+                Some(noop_fold_expr(expr, self))\n+            }\n+        })\n     }\n \n     fn fold_pat(&mut self, pat: P<ast::Pat>) -> P<ast::Pat> {"}, {"sha": "9fbc64758da4dc773cfd5dbf57d2d52e1863c1d2", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ce00a8dd4d795f47a38a207af861a2cffcee7256/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce00a8dd4d795f47a38a207af861a2cffcee7256/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=ce00a8dd4d795f47a38a207af861a2cffcee7256", "patch": "@@ -72,7 +72,7 @@ impl<T: 'static> P<T> {\n         *self.ptr\n     }\n \n-    /// Transform the inner value, consuming `self` and producing a new `P<T>`.\n+    /// Produce a new `P<T>` from `self` without reallocating.\n     pub fn map<F>(mut self, f: F) -> P<T> where\n         F: FnOnce(T) -> T,\n     {\n@@ -88,8 +88,30 @@ impl<T: 'static> P<T> {\n             ptr::write(p, f(ptr::read(p)));\n \n             // Recreate self from the raw pointer.\n-            P {\n-                ptr: Box::from_raw(p)\n+            P { ptr: Box::from_raw(p) }\n+        }\n+    }\n+\n+    /// Optionally produce a new `P<T>` from `self` without reallocating.\n+    pub fn filter_map<F>(mut self, f: F) -> Option<P<T>> where\n+        F: FnOnce(T) -> Option<T>,\n+    {\n+        let p: *mut T = &mut *self.ptr;\n+\n+        // Leak self in case of panic.\n+        // FIXME(eddyb) Use some sort of \"free guard\" that\n+        // only deallocates, without dropping the pointee,\n+        // in case the call the `f` below ends in a panic.\n+        mem::forget(self);\n+\n+        unsafe {\n+            if let Some(v) = f(ptr::read(p)) {\n+                ptr::write(p, v);\n+\n+                // Recreate self from the raw pointer.\n+                Some(P { ptr: Box::from_raw(p) })\n+            } else {\n+                None\n             }\n         }\n     }"}]}