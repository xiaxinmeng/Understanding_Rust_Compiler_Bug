{"sha": "d5e9dffddf5eb064f6b2b62bc698e35645d4d3c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1ZTlkZmZkZGY1ZWIwNjRmNmIyYjYyYmM2OThlMzU2NDVkNGQzYzc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-06-16T14:09:42Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-06-28T08:04:50Z"}, "message": "Support delegation in stable hashing macros", "tree": {"sha": "52d3d0b5bac3079a49e824eaf7181b549e6983d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52d3d0b5bac3079a49e824eaf7181b549e6983d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5e9dffddf5eb064f6b2b62bc698e35645d4d3c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5e9dffddf5eb064f6b2b62bc698e35645d4d3c7", "html_url": "https://github.com/rust-lang/rust/commit/d5e9dffddf5eb064f6b2b62bc698e35645d4d3c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5e9dffddf5eb064f6b2b62bc698e35645d4d3c7/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0622dfe5d5414c59258d8c2669d26d3dc34a469", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0622dfe5d5414c59258d8c2669d26d3dc34a469", "html_url": "https://github.com/rust-lang/rust/commit/f0622dfe5d5414c59258d8c2669d26d3dc34a469"}], "stats": {"total": 395, "additions": 115, "deletions": 280}, "files": [{"sha": "ecdca43ae2d48b4763bc4cd07e67c97f4ac9f9fa", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 71, "deletions": 182, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/d5e9dffddf5eb064f6b2b62bc698e35645d4d3c7/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e9dffddf5eb064f6b2b62bc698e35645d4d3c7/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=d5e9dffddf5eb064f6b2b62bc698e35645d4d3c7", "patch": "@@ -357,20 +357,11 @@ impl_stable_hash_for!(enum hir::FunctionRetTy {\n     Return(t)\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitRef {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let hir::TraitRef {\n-            ref path,\n-            // Don't hash the ref_id. It is tracked via the thing it is used to access\n-            ref_id: _,\n-        } = *self;\n-\n-        path.hash_stable(hcx, hasher);\n-    }\n-}\n-\n+impl_stable_hash_for!(struct hir::TraitRef {\n+    // Don't hash the ref_id. It is tracked via the thing it is used to access\n+    ref_id -> _,\n+    path,\n+});\n \n impl_stable_hash_for!(struct hir::PolyTraitRef {\n     bound_generic_params,\n@@ -393,66 +384,32 @@ impl_stable_hash_for!(struct hir::MacroDef {\n     body\n });\n \n+impl_stable_hash_for!(struct hir::Block {\n+    stmts,\n+    expr,\n+    id -> _,\n+    hir_id -> _,\n+    rules,\n+    span,\n+    targeted_by_break,\n+    recovered,\n+});\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::Block {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let hir::Block {\n-            ref stmts,\n-            ref expr,\n-            id: _,\n-            hir_id: _,\n-            rules,\n-            span,\n-            targeted_by_break,\n-            recovered,\n-        } = *self;\n-\n-        stmts.hash_stable(hcx, hasher);\n-        expr.hash_stable(hcx, hasher);\n-        rules.hash_stable(hcx, hasher);\n-        span.hash_stable(hcx, hasher);\n-        recovered.hash_stable(hcx, hasher);\n-        targeted_by_break.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for hir::Pat {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let hir::Pat {\n-            id: _,\n-            hir_id: _,\n-            ref node,\n-            ref span\n-        } = *self;\n-\n-\n-        node.hash_stable(hcx, hasher);\n-        span.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(struct hir::Pat {\n+    id -> _,\n+    hir_id -> _,\n+    node,\n+    span,\n+});\n \n impl_stable_hash_for_spanned!(hir::FieldPat);\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::FieldPat {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let hir::FieldPat {\n-            id: _,\n-            ident,\n-            ref pat,\n-            is_shorthand,\n-        } = *self;\n-\n-        ident.hash_stable(hcx, hasher);\n-        pat.hash_stable(hcx, hasher);\n-        is_shorthand.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(struct hir::FieldPat {\n+    id -> _,\n+    ident,\n+    pat,\n+    is_shorthand,\n+});\n \n impl_stable_hash_for!(enum hir::BindingAnnotation {\n     Unannotated,\n@@ -535,24 +492,13 @@ impl_stable_hash_for!(struct hir::Arm {\n     body\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::Field {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let hir::Field {\n-            id: _,\n-            ident,\n-            ref expr,\n-            span,\n-            is_shorthand,\n-        } = *self;\n-\n-        ident.hash_stable(hcx, hasher);\n-        expr.hash_stable(hcx, hasher);\n-        span.hash_stable(hcx, hasher);\n-        is_shorthand.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(struct hir::Field {\n+    id -> _,\n+    ident,\n+    expr,\n+    span,\n+    is_shorthand,\n+});\n \n impl_stable_hash_for_spanned!(ast::Name);\n \n@@ -684,19 +630,10 @@ impl_stable_hash_for!(enum hir::LoopIdError {\n     UnresolvedLabel\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>> for ast::Ident {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let ast::Ident {\n-            name,\n-            span,\n-        } = *self;\n-\n-        name.hash_stable(hcx, hasher);\n-        span.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(struct ast::Ident {\n+    name,\n+    span,\n+});\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -816,21 +753,13 @@ impl_stable_hash_for!(enum hir::ImplPolarity {\n     Negative\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::Mod {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let hir::Mod {\n-            inner,\n-            // We are not hashing the IDs of the items contained in the module.\n-            // This is harmless and matches the current behavior but it's not\n-            // actually correct. See issue #40876.\n-            item_ids: _,\n-        } = *self;\n-\n-        inner.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(struct hir::Mod {\n+    inner,\n+    // We are not hashing the IDs of the items contained in the module.\n+    // This is harmless and matches the current behavior but it's not\n+    // actually correct. See issue #40876.\n+    item_ids -> _,\n+});\n \n impl_stable_hash_for!(struct hir::ForeignMod {\n     abi,\n@@ -931,8 +860,7 @@ impl_stable_hash_for!(struct hir::ImplItemRef {\n     defaultness\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>>\n-for hir::AssociatedItemKind {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::AssociatedItemKind {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n@@ -1012,45 +940,22 @@ impl_stable_hash_for!(struct hir::InlineAsmOutput {\n     is_indirect\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::GlobalAsm {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let hir::GlobalAsm {\n-            asm,\n-            ctxt: _\n-        } = *self;\n-\n-        asm.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for hir::InlineAsm {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let hir::InlineAsm {\n-            asm,\n-            asm_str_style,\n-            ref outputs,\n-            ref inputs,\n-            ref clobbers,\n-            volatile,\n-            alignstack,\n-            dialect,\n-            ctxt: _, // This is used for error reporting\n-        } = *self;\n+impl_stable_hash_for!(struct hir::GlobalAsm {\n+    asm,\n+    ctxt -> _, // This is used for error reporting\n+});\n \n-        asm.hash_stable(hcx, hasher);\n-        asm_str_style.hash_stable(hcx, hasher);\n-        outputs.hash_stable(hcx, hasher);\n-        inputs.hash_stable(hcx, hasher);\n-        clobbers.hash_stable(hcx, hasher);\n-        volatile.hash_stable(hcx, hasher);\n-        alignstack.hash_stable(hcx, hasher);\n-        dialect.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(struct hir::InlineAsm {\n+    asm,\n+    asm_str_style,\n+    outputs,\n+    inputs,\n+    clobbers,\n+    volatile,\n+    alignstack,\n+    dialect,\n+    ctxt -> _, // This is used for error reporting\n+});\n \n impl_stable_hash_for!(enum hir::def::CtorKind {\n     Fn,\n@@ -1113,8 +1018,7 @@ impl_stable_hash_for!(enum hir::Constness {\n     NotConst\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>>\n-for hir::def_id::DefIndex {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::def_id::DefIndex {\n \n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n@@ -1140,8 +1044,7 @@ impl_stable_hash_for!(struct hir::def::Export {\n     span\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>>\n-for ::middle::lang_items::LangItem {\n+impl<'a> HashStable<StableHashingContext<'a>> for ::middle::lang_items::LangItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           _: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n@@ -1154,8 +1057,7 @@ impl_stable_hash_for!(struct ::middle::lang_items::LanguageItems {\n     missing\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>>\n-for hir::TraitCandidate {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitCandidate {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n@@ -1189,26 +1091,13 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::TraitCandidate {\n     }\n }\n \n-impl<'hir> HashStable<StableHashingContext<'hir>> for hir::CodegenFnAttrs\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'hir>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let hir::CodegenFnAttrs {\n-            flags,\n-            inline,\n-            export_name,\n-            ref target_features,\n-            linkage,\n-        } = *self;\n-\n-        flags.hash_stable(hcx, hasher);\n-        inline.hash_stable(hcx, hasher);\n-        export_name.hash_stable(hcx, hasher);\n-        target_features.hash_stable(hcx, hasher);\n-        linkage.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(struct hir::CodegenFnAttrs {\n+    flags,\n+    inline,\n+    export_name,\n+    target_features,\n+    linkage,\n+});\n \n impl<'hir> HashStable<StableHashingContext<'hir>> for hir::CodegenFnAttrFlags\n {"}, {"sha": "2b3336e2467d1da602132eb8cb74ad42bc2efd3d", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 33, "deletions": 87, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/d5e9dffddf5eb064f6b2b62bc698e35645d4d3c7/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e9dffddf5eb064f6b2b62bc698e35645d4d3c7/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=d5e9dffddf5eb064f6b2b62bc698e35645d4d3c7", "patch": "@@ -357,17 +357,11 @@ impl_stable_hash_for!(enum ty::VariantDiscr {\n     Relative(distance)\n });\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::FieldDef {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let ty::FieldDef { did, ident, vis } = *self;\n-\n-        did.hash_stable(hcx, hasher);\n-        ident.name.hash_stable(hcx, hasher);\n-        vis.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(struct ty::FieldDef {\n+    did,\n+    ident -> (ident.name),\n+    vis,\n+});\n \n impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ::middle::const_val::ConstVal<'gcx> {\n@@ -545,15 +539,7 @@ impl_stable_hash_for!(struct ty::GenericPredicates<'tcx> {\n     predicates\n });\n \n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for ::mir::interpret::EvalError<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        self.kind.hash_stable(hcx, hasher)\n-    }\n-}\n+impl_stable_hash_for!(struct ::mir::interpret::EvalError<'tcx> { kind });\n \n impl<'a, 'gcx, O: HashStable<StableHashingContext<'a>>> HashStable<StableHashingContext<'a>>\n for ::mir::interpret::EvalErrorKind<'gcx, O> {\n@@ -726,28 +712,15 @@ impl_stable_hash_for!(enum ty::adjustment::CustomCoerceUnsized {\n     Struct(index)\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>> for ty::Generics {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let ty::Generics {\n-            parent,\n-            ref parent_count,\n-            ref params,\n-\n-            // Reverse map to each param's `index` field, from its `def_id`.\n-            param_def_id_to_index: _, // Don't hash this\n-            has_self,\n-            has_late_bound_regions,\n-        } = *self;\n-\n-        parent.hash_stable(hcx, hasher);\n-        parent_count.hash_stable(hcx, hasher);\n-        params.hash_stable(hcx, hasher);\n-        has_self.hash_stable(hcx, hasher);\n-        has_late_bound_regions.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(struct ty::Generics {\n+    parent,\n+    parent_count,\n+    params,\n+    // Reverse map to each param's `index` field, from its `def_id`.\n+    param_def_id_to_index -> _, // Don't hash this\n+    has_self,\n+    has_late_bound_regions,\n+});\n \n impl_stable_hash_for!(struct ty::GenericParamDef {\n     name,\n@@ -1079,57 +1052,30 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::InstanceDef<'gcx> {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for ty::TraitDef {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let ty::TraitDef {\n-            // We already have the def_path_hash below, no need to hash it twice\n-            def_id: _,\n-            unsafety,\n-            paren_sugar,\n-            has_auto_impl,\n-            def_path_hash,\n-        } = *self;\n-\n-        unsafety.hash_stable(hcx, hasher);\n-        paren_sugar.hash_stable(hcx, hasher);\n-        has_auto_impl.hash_stable(hcx, hasher);\n-        def_path_hash.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(struct ty::TraitDef {\n+    // We already have the def_path_hash below, no need to hash it twice\n+    def_id -> _,\n+    unsafety,\n+    paren_sugar,\n+    has_auto_impl,\n+    def_path_hash,\n+});\n \n impl_stable_hash_for!(struct ty::Destructor {\n     did\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>> for ty::CrateVariancesMap {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let ty::CrateVariancesMap {\n-            ref variances,\n-            // This is just an irrelevant helper value.\n-            empty_variance: _,\n-        } = *self;\n-\n-        variances.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::CratePredicatesMap<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let ty::CratePredicatesMap {\n-            ref predicates,\n-            // This is just an irrelevant helper value.\n-            empty_predicate: _,\n-        } = *self;\n+impl_stable_hash_for!(struct ty::CrateVariancesMap {\n+    variances,\n+    // This is just an irrelevant helper value.\n+    empty_variance -> _,\n+});\n \n-        predicates.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(struct ty::CratePredicatesMap<'tcx> {\n+    predicates,\n+    // This is just an irrelevant helper value.\n+    empty_predicate -> _,\n+});\n \n impl_stable_hash_for!(struct ty::AssociatedItem {\n     def_id,"}, {"sha": "ccd9024f4aaabb412af30c066cbf7b9e27f88ad5", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d5e9dffddf5eb064f6b2b62bc698e35645d4d3c7/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e9dffddf5eb064f6b2b62bc698e35645d4d3c7/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=d5e9dffddf5eb064f6b2b62bc698e35645d4d3c7", "patch": "@@ -64,15 +64,14 @@ macro_rules! span_bug {\n \n #[macro_export]\n macro_rules! __impl_stable_hash_field {\n-    (DECL IGNORED) => (_);\n-    (DECL $name:ident) => (ref $name);\n-    (USE IGNORED $ctx:expr, $hasher:expr) => ({});\n-    (USE $name:ident, $ctx:expr, $hasher:expr) => ($name.hash_stable($ctx, $hasher));\n+    ($field:ident, $ctx:expr, $hasher:expr) => ($field.hash_stable($ctx, $hasher));\n+    ($field:ident, $ctx:expr, $hasher:expr, _) => ({ let _ = $field; });\n+    ($field:ident, $ctx:expr, $hasher:expr, $delegate:expr) => ($delegate.hash_stable($ctx, $hasher));\n }\n \n #[macro_export]\n macro_rules! impl_stable_hash_for {\n-    (enum $enum_name:path { $( $variant:ident $( ( $($arg:ident),* ) )* ),* $(,)* }) => {\n+    (enum $enum_name:path { $( $variant:ident $( ( $($field:ident $(-> $delegate:tt)?),* ) )* ),* $(,)? }) => {\n         impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $enum_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n@@ -83,15 +82,15 @@ macro_rules! impl_stable_hash_for {\n \n                 match *self {\n                     $(\n-                        $variant $( ( $( __impl_stable_hash_field!(DECL $arg) ),* ) )* => {\n-                            $($( __impl_stable_hash_field!(USE $arg, __ctx, __hasher) );*)*\n+                        $variant $( ( $(ref $field),* ) )* => {\n+                            $($( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)?) );*)*\n                         }\n                     )*\n                 }\n             }\n         }\n     };\n-    (struct $struct_name:path { $($field:ident),* }) => {\n+    (struct $struct_name:path { $($field:ident $(-> $delegate:tt)?),*  $(,)? }) => {\n         impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n@@ -101,11 +100,11 @@ macro_rules! impl_stable_hash_for {\n                     $(ref $field),*\n                 } = *self;\n \n-                $( $field.hash_stable(__ctx, __hasher));*\n+                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)?) );*\n             }\n         }\n     };\n-    (tuple_struct $struct_name:path { $($field:ident),* }) => {\n+    (tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)?),*  $(,)? }) => {\n         impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n@@ -115,7 +114,7 @@ macro_rules! impl_stable_hash_for {\n                     $(ref $field),*\n                 ) = *self;\n \n-                $( $field.hash_stable(__ctx, __hasher));*\n+                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)?) );*\n             }\n         }\n     };"}, {"sha": "0fbedcaff6ee89df79564eaeb6bc9e4211d2dcec", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5e9dffddf5eb064f6b2b62bc698e35645d4d3c7/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e9dffddf5eb064f6b2b62bc698e35645d4d3c7/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=d5e9dffddf5eb064f6b2b62bc698e35645d4d3c7", "patch": "@@ -15,6 +15,7 @@\n #![feature(box_patterns)]\n #![feature(fs_read_write)]\n #![feature(libc)]\n+#![feature(macro_at_most_once_rep)]\n #![cfg_attr(stage0, feature(macro_lifetime_matcher))]\n #![feature(proc_macro_internals)]\n #![feature(quote)]"}]}