{"sha": "a890c2cbf1dd92d79ade5bd8f04142ae5511943f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4OTBjMmNiZjFkZDkyZDc5YWRlNWJkOGYwNDE0MmFlNTUxMTk0M2Y=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-28T16:08:32Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-30T11:15:24Z"}, "message": "Convert vec::{rposition, rposition_elem, position_elem, contains} to methods.", "tree": {"sha": "4cb60f44f0f4d64d87f8a09937951adea5a8479d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cb60f44f0f4d64d87f8a09937951adea5a8479d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a890c2cbf1dd92d79ade5bd8f04142ae5511943f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a890c2cbf1dd92d79ade5bd8f04142ae5511943f", "html_url": "https://github.com/rust-lang/rust/commit/a890c2cbf1dd92d79ade5bd8f04142ae5511943f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a890c2cbf1dd92d79ade5bd8f04142ae5511943f/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45940ed988ab2d04e1dbecceef440071b04c11a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/45940ed988ab2d04e1dbecceef440071b04c11a9", "html_url": "https://github.com/rust-lang/rust/commit/45940ed988ab2d04e1dbecceef440071b04c11a9"}], "stats": {"total": 124, "additions": 50, "deletions": 74}, "files": [{"sha": "b07c05ad76a0381a033ecfb56acbe96c54dca3a6", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a890c2cbf1dd92d79ade5bd8f04142ae5511943f/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a890c2cbf1dd92d79ade5bd8f04142ae5511943f/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=a890c2cbf1dd92d79ade5bd8f04142ae5511943f", "patch": "@@ -383,8 +383,6 @@ mod test_set {\n \n     use super::SmallIntSet;\n \n-    use std::vec;\n-\n     #[test]\n     fn test_disjoint() {\n         let mut xs = SmallIntSet::new();\n@@ -456,7 +454,7 @@ mod test_set {\n         let mut i = 0;\n         let expected = [3, 5, 11, 77];\n         for a.intersection(&b) |x| {\n-            assert!(vec::contains(expected, x));\n+            assert!(expected.contains(x));\n             i += 1\n         }\n         assert_eq!(i, expected.len());\n@@ -479,7 +477,7 @@ mod test_set {\n         let mut i = 0;\n         let expected = [1, 5, 11];\n         for a.difference(&b) |x| {\n-            assert!(vec::contains(expected, x));\n+            assert!(expected.contains(x));\n             i += 1\n         }\n         assert_eq!(i, expected.len());\n@@ -504,7 +502,7 @@ mod test_set {\n         let mut i = 0;\n         let expected = [1, 5, 11, 14, 22];\n         for a.symmetric_difference(&b) |x| {\n-            assert!(vec::contains(expected, x));\n+            assert!(expected.contains(x));\n             i += 1\n         }\n         assert_eq!(i, expected.len());\n@@ -533,7 +531,7 @@ mod test_set {\n         let mut i = 0;\n         let expected = [1, 3, 5, 9, 11, 13, 16, 19, 24];\n         for a.union(&b) |x| {\n-            assert!(vec::contains(expected, x));\n+            assert!(expected.contains(x));\n             i += 1\n         }\n         assert_eq!(i, expected.len());"}, {"sha": "3413cd341ba42f6eb94bd534a82191df62d5c056", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a890c2cbf1dd92d79ade5bd8f04142ae5511943f/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a890c2cbf1dd92d79ade5bd8f04142ae5511943f/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=a890c2cbf1dd92d79ade5bd8f04142ae5511943f", "patch": "@@ -17,7 +17,6 @@ use metadata::cstore;\n use metadata::decoder;\n \n use std::hashmap::HashMap;\n-use std::vec;\n use extra;\n use syntax::ast;\n use syntax::parse::token::ident_interner;\n@@ -91,7 +90,7 @@ pub fn iter_crate_data(cstore: &CStore,\n }\n \n pub fn add_used_crate_file(cstore: &mut CStore, lib: &Path) {\n-    if !vec::contains(cstore.used_crate_files, lib) {\n+    if !cstore.used_crate_files.contains(lib) {\n         cstore.used_crate_files.push(copy *lib);\n     }\n }"}, {"sha": "c27b60477c09e204eb276834c9450acf09fbbc44", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a890c2cbf1dd92d79ade5bd8f04142ae5511943f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a890c2cbf1dd92d79ade5bd8f04142ae5511943f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=a890c2cbf1dd92d79ade5bd8f04142ae5511943f", "patch": "@@ -363,7 +363,7 @@ pub fn missing_ctor(cx: &MatchCheckCtxt,\n         for m.iter().advance |r| {\n             let r = pat_ctor_id(cx, r[0]);\n             for r.iter().advance |id| {\n-                if !vec::contains(found, id) {\n+                if !found.contains(id) {\n                     found.push(/*bad*/copy *id);\n                 }\n             }"}, {"sha": "8a6fff09c730b67841099ad86568fdfec6c2c317", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a890c2cbf1dd92d79ade5bd8f04142ae5511943f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a890c2cbf1dd92d79ade5bd8f04142ae5511943f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=a890c2cbf1dd92d79ade5bd8f04142ae5511943f", "patch": "@@ -2323,7 +2323,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n                 false\n             }\n \n-            ty_struct(ref did, _) if vec::contains(*seen, did) => {\n+            ty_struct(ref did, _) if seen.contains(did) => {\n                 false\n             }\n \n@@ -2339,7 +2339,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n                 ts.iter().any_(|t| type_requires(cx, seen, r_ty, *t))\n             }\n \n-            ty_enum(ref did, _) if vec::contains(*seen, did) => {\n+            ty_enum(ref did, _) if seen.contains(did) => {\n                 false\n             }\n \n@@ -3266,7 +3266,7 @@ pub fn occurs_check(tcx: ctxt, sp: span, vid: TyVid, rt: t) {\n     if !type_needs_infer(rt) { return; }\n \n     // Occurs check!\n-    if vec::contains(vars_in_type(rt), &vid) {\n+    if vars_in_type(rt).contains(&vid) {\n             // Maybe this should be span_err -- however, there's an\n             // assertion later on that the type doesn't contain\n             // variables, so in this case we have to be sure to die."}, {"sha": "d1edc1cd3630d4ec8ad6d424d03aa3289d36a1c2", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a890c2cbf1dd92d79ade5bd8f04142ae5511943f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a890c2cbf1dd92d79ade5bd8f04142ae5511943f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=a890c2cbf1dd92d79ade5bd8f04142ae5511943f", "patch": "@@ -985,7 +985,7 @@ pub fn do_autoderef(fcx: @mut FnCtxt, sp: span, t: ty::t) -> (ty::t, uint) {\n                 // concerned with this, as an error will be reported\n                 // on the enum definition as well because the enum is\n                 // not instantiable.\n-                if vec::contains(enum_dids, did) {\n+                if enum_dids.contains(did) {\n                     return (t1, autoderefs);\n                 }\n                 enum_dids.push(*did);\n@@ -3156,7 +3156,7 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                   }\n                 }\n             }\n-            if vec::contains(*disr_vals, &*disr_val) {\n+            if disr_vals.contains(&*disr_val) {\n                 ccx.tcx.sess.span_err(v.span,\n                                       \"discriminator value already exists\");\n             }"}, {"sha": "941431ce0e3d11742c5310bfa604a558d271b202", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a890c2cbf1dd92d79ade5bd8f04142ae5511943f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a890c2cbf1dd92d79ade5bd8f04142ae5511943f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=a890c2cbf1dd92d79ade5bd8f04142ae5511943f", "patch": "@@ -57,7 +57,6 @@ use middle::typeck::infer::unify::{Root, UnifyInferCtxtMethods};\n use util::common::{indent, indenter};\n use util::ppaux::ty_to_str;\n \n-use std::vec;\n use syntax::ast;\n \n pub static resolve_nested_tvar: uint = 0b0000000001;\n@@ -204,7 +203,7 @@ impl ResolveState {\n     }\n \n     pub fn resolve_ty_var(&mut self, vid: TyVid) -> ty::t {\n-        if vec::contains(self.v_seen, &vid) {\n+        if self.v_seen.contains(&vid) {\n             self.err = Some(cyclic_ty(vid));\n             return ty::mk_var(self.infcx.tcx, vid);\n         } else {"}, {"sha": "697a9f53f1b0b21b6797c8e70f2d6a65e630069e", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a890c2cbf1dd92d79ade5bd8f04142ae5511943f/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a890c2cbf1dd92d79ade5bd8f04142ae5511943f/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=a890c2cbf1dd92d79ade5bd8f04142ae5511943f", "patch": "@@ -596,9 +596,9 @@ fn rust_path_contents() {\n         let cwd = os::getcwd().push(\".rust\");\n         let parent = cwd.pop().pop().push(\".rust\");\n         let grandparent = cwd.pop().pop().pop().push(\".rust\");\n-        assert!(vec::contains(p, &cwd));\n-        assert!(vec::contains(p, &parent));\n-        assert!(vec::contains(p, &grandparent));\n+        assert!(p.contains(&cwd));\n+        assert!(p.contains(&parent));\n+        assert!(p.contains(&grandparent));\n         for p.iter().advance() |a_path| {\n             assert!(!a_path.components.is_empty());\n         }\n@@ -609,9 +609,9 @@ fn rust_path_contents() {\n fn rust_path_parse() {\n     os::setenv(\"RUST_PATH\", \"/a/b/c:/d/e/f:/g/h/i\");\n     let paths = rust_path();\n-    assert!(vec::contains(paths, &Path(\"/g/h/i\")));\n-    assert!(vec::contains(paths, &Path(\"/d/e/f\")));\n-    assert!(vec::contains(paths, &Path(\"/a/b/c\")));\n+    assert!(paths.contains(&Path(\"/g/h/i\")));\n+    assert!(paths.contains(&Path(\"/d/e/f\")));\n+    assert!(paths.contains(&Path(\"/a/b/c\")));\n     os::unsetenv(\"RUST_PATH\");\n }\n "}, {"sha": "85dca1154bc09330484fbcd34d58f975073b2846", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a890c2cbf1dd92d79ade5bd8f04142ae5511943f/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a890c2cbf1dd92d79ade5bd8f04142ae5511943f/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=a890c2cbf1dd92d79ade5bd8f04142ae5511943f", "patch": "@@ -939,7 +939,7 @@ mod test_map {\n mod test_set {\n     use super::*;\n     use container::{Container, Map, Set};\n-    use vec;\n+    use vec::ImmutableEqVector;\n     use uint;\n \n     #[test]\n@@ -1030,7 +1030,7 @@ mod test_set {\n         let mut i = 0;\n         let expected = [3, 5, 11, 77];\n         for a.intersection(&b) |x| {\n-            assert!(vec::contains(expected, x));\n+            assert!(expected.contains(x));\n             i += 1\n         }\n         assert_eq!(i, expected.len());\n@@ -1053,7 +1053,7 @@ mod test_set {\n         let mut i = 0;\n         let expected = [1, 5, 11];\n         for a.difference(&b) |x| {\n-            assert!(vec::contains(expected, x));\n+            assert!(expected.contains(x));\n             i += 1\n         }\n         assert_eq!(i, expected.len());\n@@ -1079,7 +1079,7 @@ mod test_set {\n         let mut i = 0;\n         let expected = [-2, 1, 5, 11, 14, 22];\n         for a.symmetric_difference(&b) |x| {\n-            assert!(vec::contains(expected, x));\n+            assert!(expected.contains(x));\n             i += 1\n         }\n         assert_eq!(i, expected.len());\n@@ -1109,7 +1109,7 @@ mod test_set {\n         let mut i = 0;\n         let expected = [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24];\n         for a.union(&b) |x| {\n-            assert!(vec::contains(expected, x));\n+            assert!(expected.contains(x));\n             i += 1\n         }\n         assert_eq!(i, expected.len());"}, {"sha": "6d13c662ee5de502b7325e2dd3b133d31bf1f980", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a890c2cbf1dd92d79ade5bd8f04142ae5511943f/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a890c2cbf1dd92d79ade5bd8f04142ae5511943f/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=a890c2cbf1dd92d79ade5bd8f04142ae5511943f", "patch": "@@ -1544,10 +1544,10 @@ mod tests {\n \n         let mut e = env();\n         setenv(n, \"VALUE\");\n-        assert!(!vec::contains(e, &(copy n, ~\"VALUE\")));\n+        assert!(!e.contains(&(copy n, ~\"VALUE\")));\n \n         e = env();\n-        assert!(vec::contains(e, &(n, ~\"VALUE\")));\n+        assert!(e.contains(&(n, ~\"VALUE\")));\n     }\n \n     #[test]"}, {"sha": "e2b0c54b9a4605711f96f8ed98c6f92cd2a04333", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 24, "deletions": 44, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/a890c2cbf1dd92d79ade5bd8f04142ae5511943f/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a890c2cbf1dd92d79ade5bd8f04142ae5511943f/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=a890c2cbf1dd92d79ade5bd8f04142ae5511943f", "patch": "@@ -220,9 +220,9 @@ pub fn splitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n         match v.slice(start, ln).iter().position_(|t| f(t)) {\n             None => break,\n             Some(i) => {\n-                result.push(v.slice(start, i).to_owned());\n+                result.push(v.slice(start, start + i).to_owned());\n                 // Make sure to skip the separator.\n-                start = i + 1u;\n+                start += i + 1u;\n                 count -= 1u;\n             }\n         }\n@@ -646,36 +646,6 @@ impl<'self, T:Copy> VectorVector<T> for &'self [&'self [T]] {\n     }\n }\n \n-/// Return true if a vector contains an element with the given value\n-pub fn contains<T:Eq>(v: &[T], x: &T) -> bool {\n-    for v.iter().advance |elt| { if *x == *elt { return true; } }\n-    false\n-}\n-\n-/// Find the first index containing a matching value\n-pub fn position_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n-    v.iter().position_(|y| *x == *y)\n-}\n-\n-/// Find the last index containing a matching value\n-pub fn rposition_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n-    rposition(v, |y| *x == *y)\n-}\n-\n-/**\n- * Find the last index matching some predicate\n- *\n- * Apply function `f` to each element of `v` in reverse order.  When function\n- * `f` returns true then an option containing the index is returned. If `f`\n- * matches no elements then none is returned.\n- */\n-pub fn rposition<T>(v: &[T], f: &fn(t: &T) -> bool) -> Option<uint> {\n-    for v.rev_iter().enumerate().advance |(i, t)| {\n-        if f(t) { return Some(v.len() - i - 1); }\n-    }\n-    None\n-}\n-\n /**\n  * Binary search a sorted vector with a comparator function.\n  *\n@@ -1265,11 +1235,14 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n      *\n      * Apply function `f` to each element of `v` in reverse order.  When\n      * function `f` returns true then an option containing the index is\n-     * returned. If `f` matches no elements then none is returned.\n+     * returned. If `f` matches no elements then None is returned.\n      */\n     #[inline]\n     fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint> {\n-        rposition(*self, f)\n+        for self.rev_iter().enumerate().advance |(i, t)| {\n+            if f(t) { return Some(self.len() - i - 1); }\n+        }\n+        None\n     }\n \n     /// Apply a function to each element of a vector and return the results\n@@ -1327,19 +1300,26 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n pub trait ImmutableEqVector<T:Eq> {\n     fn position_elem(&self, t: &T) -> Option<uint>;\n     fn rposition_elem(&self, t: &T) -> Option<uint>;\n+    fn contains(&self, x: &T) -> bool;\n }\n \n impl<'self,T:Eq> ImmutableEqVector<T> for &'self [T] {\n     /// Find the first index containing a matching value\n     #[inline]\n     fn position_elem(&self, x: &T) -> Option<uint> {\n-        position_elem(*self, x)\n+        self.iter().position_(|y| *x == *y)\n     }\n \n     /// Find the last index containing a matching value\n     #[inline]\n     fn rposition_elem(&self, t: &T) -> Option<uint> {\n-        rposition_elem(*self, t)\n+        self.rposition(|x| *x == *t)\n+    }\n+\n+    /// Return true if a vector contains an element with the given value\n+    fn contains(&self, x: &T) -> bool {\n+        for self.iter().advance |elt| { if *x == *elt { return true; } }\n+        false\n     }\n }\n \n@@ -2838,13 +2818,13 @@ mod tests {\n \n     #[test]\n     fn test_position_elem() {\n-        assert!(position_elem([], &1).is_none());\n+        assert!([].position_elem(&1).is_none());\n \n         let v1 = ~[1, 2, 3, 3, 2, 5];\n-        assert_eq!(position_elem(v1, &1), Some(0u));\n-        assert_eq!(position_elem(v1, &2), Some(1u));\n-        assert_eq!(position_elem(v1, &5), Some(5u));\n-        assert!(position_elem(v1, &4).is_none());\n+        assert_eq!(v1.position_elem(&1), Some(0u));\n+        assert_eq!(v1.position_elem(&2), Some(1u));\n+        assert_eq!(v1.position_elem(&5), Some(5u));\n+        assert!(v1.position_elem(&4).is_none());\n     }\n \n     #[test]\n@@ -2853,8 +2833,8 @@ mod tests {\n         fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n         let v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert_eq!(rposition(v, f), Some(3u));\n-        assert!(rposition(v, g).is_none());\n+        assert_eq!(v.rposition(f), Some(3u));\n+        assert!(v.rposition(g).is_none());\n     }\n \n     #[test]\n@@ -3417,7 +3397,7 @@ mod tests {\n     fn test_rposition_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        do rposition(v) |_elt| {\n+        do v.rposition |_elt| {\n             if i == 2 {\n                 fail!()\n             }"}, {"sha": "eeff4b71c0d2f69553842b76bcd454af07ae8b79", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a890c2cbf1dd92d79ade5bd8f04142ae5511943f/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a890c2cbf1dd92d79ade5bd8f04142ae5511943f/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=a890c2cbf1dd92d79ade5bd8f04142ae5511943f", "patch": "@@ -341,7 +341,7 @@ fn validate(edges: ~[(node_id, node_id)],\n         }\n         else {\n             while parent != root {\n-                if vec::contains(path, &parent) {\n+                if path.contains(&parent) {\n                     status = false;\n                 }\n "}]}