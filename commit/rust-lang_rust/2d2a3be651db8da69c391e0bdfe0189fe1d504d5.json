{"sha": "2d2a3be651db8da69c391e0bdfe0189fe1d504d5", "node_id": "C_kwDOAAsO6NoAKDJkMmEzYmU2NTFkYjhkYTY5YzM5MWUwYmRmZTAxODlmZTFkNTA0ZDU", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-08-25T12:19:38Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-08-26T01:12:36Z"}, "message": "Move `ArgAbi::pad_i32` into `PassMode::Cast`.\n\nBecause it's only needed for that variant. This shrinks the types and\nclarifies the logic.", "tree": {"sha": "9fdef6277a42e8f202be70a1f2025142a9cd36e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fdef6277a42e8f202be70a1f2025142a9cd36e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d2a3be651db8da69c391e0bdfe0189fe1d504d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d2a3be651db8da69c391e0bdfe0189fe1d504d5", "html_url": "https://github.com/rust-lang/rust/commit/2d2a3be651db8da69c391e0bdfe0189fe1d504d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d2a3be651db8da69c391e0bdfe0189fe1d504d5/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c989472e41f0b6033bcf62b76dcd28f75e7b25b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c989472e41f0b6033bcf62b76dcd28f75e7b25b", "html_url": "https://github.com/rust-lang/rust/commit/1c989472e41f0b6033bcf62b76dcd28f75e7b25b"}], "stats": {"total": 19, "additions": 11, "deletions": 8}, "files": [{"sha": "165f15bb3f1225a4e3326639d4dbea9c61c9b333", "filename": "src/abi/pass_mode.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2d2a3be651db8da69c391e0bdfe0189fe1d504d5/src%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2a3be651db8da69c391e0bdfe0189fe1d504d5/src%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fpass_mode.rs?ref=2d2a3be651db8da69c391e0bdfe0189fe1d504d5", "patch": "@@ -100,7 +100,10 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            PassMode::Cast(ref cast) => cast_target_to_abi_params(cast),\n+            PassMode::Cast(ref cast, pad_i32) => {\n+                assert!(!pad_i32, \"padding support not yet implemented\");\n+                cast_target_to_abi_params(cast)\n+            }\n             PassMode::Indirect { attrs, extra_attrs: None, on_stack } => {\n                 if on_stack {\n                     // Abi requires aligning struct size to pointer size\n@@ -145,7 +148,7 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            PassMode::Cast(ref cast) => {\n+            PassMode::Cast(ref cast, _) => {\n                 (None, cast_target_to_abi_params(cast).into_iter().collect())\n             }\n             PassMode::Indirect { attrs: _, extra_attrs: None, on_stack } => {\n@@ -226,7 +229,7 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n             let (a, b) = arg.load_scalar_pair(fx);\n             smallvec![a, b]\n         }\n-        PassMode::Cast(ref cast) => to_casted_value(fx, arg, cast),\n+        PassMode::Cast(ref cast, _) => to_casted_value(fx, arg, cast),\n         PassMode::Indirect { .. } => {\n             if is_owned {\n                 match arg.force_stack(fx) {\n@@ -284,7 +287,7 @@ pub(super) fn cvalue_for_param<'tcx>(\n             assert_eq!(block_params.len(), 2, \"{:?}\", block_params);\n             Some(CValue::by_val_pair(block_params[0], block_params[1], arg_abi.layout))\n         }\n-        PassMode::Cast(ref cast) => {\n+        PassMode::Cast(ref cast, _) => {\n             Some(from_casted_value(fx, &block_params, arg_abi.layout, cast))\n         }\n         PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {"}, {"sha": "aaa1418767a357680ef3b2cd5b2ad8a2d970c015", "filename": "src/abi/returning.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d2a3be651db8da69c391e0bdfe0189fe1d504d5/src%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2a3be651db8da69c391e0bdfe0189fe1d504d5/src%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Freturning.rs?ref=2d2a3be651db8da69c391e0bdfe0189fe1d504d5", "patch": "@@ -13,7 +13,7 @@ pub(super) fn codegen_return_param<'tcx>(\n     block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> CPlace<'tcx> {\n     let (ret_place, ret_param): (_, SmallVec<[_; 2]>) = match fx.fn_abi.as_ref().unwrap().ret.mode {\n-        PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => {\n+        PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(..) => {\n             let is_ssa = ssa_analyzed[RETURN_PLACE] == crate::analyze::SsaKind::Ssa;\n             (\n                 super::make_local_place(\n@@ -75,7 +75,7 @@ pub(super) fn codegen_with_call_return_arg<'tcx>(\n         PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n             unreachable!(\"unsized return value\")\n         }\n-        PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => (None, None),\n+        PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(..) => (None, None),\n     };\n \n     let call_inst = f(fx, return_ptr);\n@@ -92,7 +92,7 @@ pub(super) fn codegen_with_call_return_arg<'tcx>(\n             ret_place\n                 .write_cvalue(fx, CValue::by_val_pair(ret_val_a, ret_val_b, ret_arg_abi.layout));\n         }\n-        PassMode::Cast(ref cast) => {\n+        PassMode::Cast(ref cast, _) => {\n             let results =\n                 fx.bcx.inst_results(call_inst).iter().copied().collect::<SmallVec<[Value; 2]>>();\n             let result =\n@@ -131,7 +131,7 @@ pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, '_>) {\n             let (ret_val_a, ret_val_b) = place.to_cvalue(fx).load_scalar_pair(fx);\n             fx.bcx.ins().return_(&[ret_val_a, ret_val_b]);\n         }\n-        PassMode::Cast(ref cast) => {\n+        PassMode::Cast(ref cast, _) => {\n             let place = fx.get_local_place(RETURN_PLACE);\n             let ret_val = place.to_cvalue(fx);\n             let ret_vals = super::pass_mode::to_casted_value(fx, ret_val, cast);"}]}