{"sha": "ab402c0744f1cb542dee01f810b0c96e47c44df0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiNDAyYzA3NDRmMWNiNTQyZGVlMDFmODEwYjBjOTZlNDdjNDRkZjA=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-31T02:02:53Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-01T03:50:27Z"}, "message": "syntax: unbox closures used in let bindings", "tree": {"sha": "a7f9dfc4f10cf240528d169c33d3f7035285d020", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7f9dfc4f10cf240528d169c33d3f7035285d020"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab402c0744f1cb542dee01f810b0c96e47c44df0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab402c0744f1cb542dee01f810b0c96e47c44df0", "html_url": "https://github.com/rust-lang/rust/commit/ab402c0744f1cb542dee01f810b0c96e47c44df0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab402c0744f1cb542dee01f810b0c96e47c44df0/comments", "author": null, "committer": null, "parents": [{"sha": "12dd7781d64f5898a435bb3d0210e0518285e128", "url": "https://api.github.com/repos/rust-lang/rust/commits/12dd7781d64f5898a435bb3d0210e0518285e128", "html_url": "https://github.com/rust-lang/rust/commit/12dd7781d64f5898a435bb3d0210e0518285e128"}], "stats": {"total": 30, "additions": 15, "deletions": 15}, "files": [{"sha": "49bcb26a4c283027ed7e85a679480d18fef459ac", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab402c0744f1cb542dee01f810b0c96e47c44df0/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab402c0744f1cb542dee01f810b0c96e47c44df0/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=ab402c0744f1cb542dee01f810b0c96e47c44df0", "patch": "@@ -55,7 +55,7 @@ fn default_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructur\n         cx.ident_of(\"Default\"),\n         cx.ident_of(\"default\")\n     );\n-    let default_call = |span| cx.expr_call_global(span, default_ident.clone(), Vec::new());\n+    let default_call = |&: span| cx.expr_call_global(span, default_ident.clone(), Vec::new());\n \n     return match *substr.fields {\n         StaticStruct(_, ref summary) => {"}, {"sha": "9149c20ce1b57419f1b6b679595aecaa199ac5d7", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab402c0744f1cb542dee01f810b0c96e47c44df0/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab402c0744f1cb542dee01f810b0c96e47c44df0/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=ab402c0744f1cb542dee01f810b0c96e47c44df0", "patch": "@@ -935,7 +935,7 @@ impl<'a> MethodDef<'a> {\n         // where each tuple has length = self_args.len()\n         let mut match_arms: Vec<ast::Arm> = variants.iter().enumerate()\n             .map(|(index, variant)| {\n-                let mk_self_pat = |cx: &mut ExtCtxt, self_arg_name: &str| {\n+                let mk_self_pat = |&: cx: &mut ExtCtxt, self_arg_name: &str| {\n                     let (p, idents) = trait_.create_enum_variant_pattern(cx, type_ident,\n                                                                          &**variant,\n                                                                          self_arg_name,"}, {"sha": "9ad0ad1621765f13e71e72e2681ff838fdd20199", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab402c0744f1cb542dee01f810b0c96e47c44df0/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab402c0744f1cb542dee01f810b0c96e47c44df0/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=ab402c0744f1cb542dee01f810b0c96e47c44df0", "patch": "@@ -71,7 +71,7 @@ fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n         _ => cx.span_bug(trait_span, \"incorrect number of arguments in `deriving(Hash)`\")\n     };\n     let hash_ident = substr.method_ident;\n-    let call_hash = |span, thing_expr| {\n+    let call_hash = |&: span, thing_expr| {\n         let expr = cx.expr_method_call(span, thing_expr, hash_ident, vec!(state_expr.clone()));\n         cx.stmt_expr(expr)\n     };"}, {"sha": "73331f06aa4ee53a3bd6e74cc887c39a2971de52", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab402c0744f1cb542dee01f810b0c96e47c44df0/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab402c0744f1cb542dee01f810b0c96e47c44df0/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=ab402c0744f1cb542dee01f810b0c96e47c44df0", "patch": "@@ -71,7 +71,7 @@ fn zero_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n         cx.ident_of(\"Zero\"),\n         cx.ident_of(\"zero\")\n     );\n-    let zero_call = |span| cx.expr_call_global(span, zero_ident.clone(), Vec::new());\n+    let zero_call = |&: span| cx.expr_call_global(span, zero_ident.clone(), Vec::new());\n \n     return match *substr.fields {\n         StaticStruct(_, ref summary) => {"}, {"sha": "5de7068563d59e646a06a3468e234d139834a507", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab402c0744f1cb542dee01f810b0c96e47c44df0/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab402c0744f1cb542dee01f810b0c96e47c44df0/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ab402c0744f1cb542dee01f810b0c96e47c44df0", "patch": "@@ -1660,7 +1660,7 @@ mod test {\n             assert!((shouldmatch.len() == 0) ||\n                     (varrefs.len() > *shouldmatch.iter().max().unwrap()));\n             for (idx,varref) in varrefs.iter().enumerate() {\n-                let print_hygiene_debug_info = || {\n+                let print_hygiene_debug_info = |&:| {\n                     // good lord, you can't make a path with 0 segments, can you?\n                     let final_varref_ident = match varref.segments.last() {\n                         Some(pathsegment) => pathsegment.identifier,"}, {"sha": "d87960ebdb82af2d208268b9e4be8a50646309d2", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab402c0744f1cb542dee01f810b0c96e47c44df0/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab402c0744f1cb542dee01f810b0c96e47c44df0/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=ab402c0744f1cb542dee01f810b0c96e47c44df0", "patch": "@@ -800,11 +800,11 @@ fn expand_parse_call(cx: &ExtCtxt,\n                      tts: &[ast::TokenTree]) -> P<ast::Expr> {\n     let (cx_expr, tts_expr) = expand_tts(cx, sp, tts);\n \n-    let cfg_call = || cx.expr_method_call(\n+    let cfg_call = |&:| cx.expr_method_call(\n         sp, cx.expr_ident(sp, id_ext(\"ext_cx\")),\n         id_ext(\"cfg\"), Vec::new());\n \n-    let parse_sess_call = || cx.expr_method_call(\n+    let parse_sess_call = |&:| cx.expr_method_call(\n         sp, cx.expr_ident(sp, id_ext(\"ext_cx\")),\n         id_ext(\"parse_sess\"), Vec::new());\n "}, {"sha": "88c485a07acdf290a28ef5dd66c543b841c6ae76", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab402c0744f1cb542dee01f810b0c96e47c44df0/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab402c0744f1cb542dee01f810b0c96e47c44df0/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=ab402c0744f1cb542dee01f810b0c96e47c44df0", "patch": "@@ -240,7 +240,7 @@ pub fn new_parser_from_tts<'a>(sess: &'a ParseSess,\n /// add the path to the session's codemap and return the new filemap.\n pub fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n     -> Rc<FileMap> {\n-    let err = |msg: &str| {\n+    let err = |&: msg: &str| {\n         match spanopt {\n             Some(sp) => sess.span_diagnostic.span_fatal(sp, msg),\n             None => sess.span_diagnostic.handler().fatal(msg),\n@@ -399,7 +399,7 @@ pub fn char_lit(lit: &str) -> (char, int) {\n         .map(|x| (x, len as int))\n     }\n \n-    let unicode_escape: || -> Option<(char, int)> = ||\n+    let unicode_escape = |&: | -> Option<(char, int)>\n         if lit.as_bytes()[2] == b'{' {\n             let idx = lit.find('}').expect(msg2);\n             let subslice = lit[3..idx];\n@@ -426,7 +426,7 @@ pub fn str_lit(lit: &str) -> String {\n     let mut res = String::with_capacity(lit.len());\n \n     // FIXME #8372: This could be a for-loop if it didn't borrow the iterator\n-    let error = |i| format!(\"lexer should have rejected {} at {}\", lit, i);\n+    let error = |&: i| format!(\"lexer should have rejected {} at {}\", lit, i);\n \n     /// Eat everything up to a non-whitespace\n     fn eat<'a>(it: &mut iter::Peekable<(uint, char), str::CharIndices<'a>>) {\n@@ -561,7 +561,7 @@ pub fn float_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) -> a\n \n /// Parse a string representing a byte literal into its final form. Similar to `char_lit`\n pub fn byte_lit(lit: &str) -> (u8, uint) {\n-    let err = |i| format!(\"lexer accepted invalid byte literal {} step {}\", lit, i);\n+    let err = |&: i| format!(\"lexer accepted invalid byte literal {} step {}\", lit, i);\n \n     if lit.len() == 1 {\n         (lit.as_bytes()[0], 1)\n@@ -595,7 +595,7 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n     let mut res = Vec::with_capacity(lit.len());\n \n     // FIXME #8372: This could be a for-loop if it didn't borrow the iterator\n-    let error = |i| format!(\"lexer should have rejected {} at {}\", lit, i);\n+    let error = |&: i| format!(\"lexer should have rejected {} at {}\", lit, i);\n \n     /// Eat everything up to a non-whitespace\n     fn eat<'a, I: Iterator<(uint, u8)>>(it: &mut iter::Peekable<(uint, u8), I>) {"}, {"sha": "93fe868f52c682909887dc167bff0ab152e16c1b", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab402c0744f1cb542dee01f810b0c96e47c44df0/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab402c0744f1cb542dee01f810b0c96e47c44df0/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=ab402c0744f1cb542dee01f810b0c96e47c44df0", "patch": "@@ -545,11 +545,11 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n     let test_id = ecx.ident_of(\"test\");\n \n     // creates self::test::$name\n-    let test_path = |name| {\n+    let test_path = |&: name| {\n         ecx.path(span, vec![self_id, test_id, ecx.ident_of(name)])\n     };\n     // creates $name: $expr\n-    let field = |name, expr| ecx.field_imm(span, ecx.ident_of(name), expr);\n+    let field = |&: name, expr| ecx.field_imm(span, ecx.ident_of(name), expr);\n \n     debug!(\"encoding {}\", ast_util::path_name_i(path[]));\n \n@@ -563,7 +563,7 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n                                   vec![name_expr]);\n \n     let ignore_expr = ecx.expr_bool(span, test.ignore);\n-    let should_fail_path = |name| {\n+    let should_fail_path = |&: name| {\n         ecx.path(span, vec![self_id, test_id, ecx.ident_of(\"ShouldFail\"), ecx.ident_of(name)])\n     };\n     let fail_expr = match test.should_fail {"}]}